{
  "cve_id": "CVE-2011-3638",
  "cve_desc": "fs/ext4/extents.c in the Linux kernel before 3.0 does not mark a modified extent as dirty in certain cases of extent splitting, which allows local users to cause a denial of service (system crash) via vectors involving ext4 umount and mount operations.",
  "repo": "torvalds/linux",
  "patch_hash": "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
  "patch_info": {
    "commit_hash": "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
    "files": [
      "fs/ext4/extents.c"
    ],
    "message": "ext4: reimplement convert and split_unwritten\n\nReimplement ext4_ext_convert_to_initialized() and\next4_split_unwritten_extents() using ext4_split_extent()\n\nSigned-off-by: Yongqiang Yang <xiaoqiangnk@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nTested-by: Allison Henderson <achender@linux.vnet.ibm.com>",
    "before_after_code_files": [
      "fs/ext4/extents.c||fs/ext4/extents.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2757:         struct ext4_map_blocks *map,",
      "2758:         struct ext4_ext_path *path)",
      "2759: {",
      "2765:  ext4_lblk_t ee_block, eof_block;",
      "2766:  unsigned int allocated, ee_len, depth;",
      "2768:  int err = 0;",
      "2772:  ext_debug(\"ext4_ext_convert_to_initialized: inode %lu, logical\"",
      "2773:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
      "",
      "[Removed Lines]",
      "2760:  struct ext4_extent *ex, newex, orig_ex;",
      "2761:  struct ext4_extent *ex1 = NULL;",
      "2762:  struct ext4_extent *ex2 = NULL;",
      "2763:  struct ext4_extent *ex3 = NULL;",
      "2764:  struct ext4_extent_header *eh;",
      "2767:  ext4_fsblk_t newblock;",
      "2769:  int ret = 0;",
      "2770:  int may_zeroout;",
      "",
      "[Added Lines]",
      "2760:  struct ext4_map_blocks split_map;",
      "2761:  struct ext4_extent zero_ex;",
      "2762:  struct ext4_extent *ex;",
      "2766:  int split_flag = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2779:   eof_block = map->m_lblk + map->m_len;",
      "2781:  depth = ext_depth(inode);",
      "2783:  ex = path[depth].p_ext;",
      "2784:  ee_block = le32_to_cpu(ex->ee_block);",
      "2785:  ee_len = ext4_ext_get_actual_len(ex);",
      "2786:  allocated = ee_len - (map->m_lblk - ee_block);",
      "2806:   if (err)",
      "2945:    goto out;",
      "2952:   err = ext4_ext_get_access(handle, inode, path + depth);",
      "2953:   if (err)",
      "2954:    goto out;",
      "3013:  }",
      "3023:    if (err)",
      "3024:     goto out;",
      "3025:   }",
      "3026:  }",
      "3045: out:",
      "3047:  return err ? err : allocated;",
      "3056: }",
      "",
      "[Removed Lines]",
      "2782:  eh = path[depth].p_hdr;",
      "2787:  newblock = map->m_lblk - ee_block + ext4_ext_pblock(ex);",
      "2789:  ex2 = ex;",
      "2790:  orig_ex.ee_block = ex->ee_block;",
      "2791:  orig_ex.ee_len   = cpu_to_le16(ee_len);",
      "2792:  ext4_ext_store_pblock(&orig_ex, ext4_ext_pblock(ex));",
      "2798:  may_zeroout = ee_block + ee_len <= eof_block;",
      "2800:  err = ext4_ext_get_access(handle, inode, path + depth);",
      "2801:  if (err)",
      "2802:   goto out;",
      "2804:  if (ee_len <= 2*EXT4_EXT_ZERO_LEN && may_zeroout) {",
      "2805:   err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2807:    goto fix_extent_len;",
      "2809:   ex->ee_block = orig_ex.ee_block;",
      "2810:   ex->ee_len   = orig_ex.ee_len;",
      "2811:   ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2812:   ext4_ext_dirty(handle, inode, path + depth);",
      "2814:   return allocated;",
      "2815:  }",
      "2818:  if (map->m_lblk > ee_block) {",
      "2819:   ex1 = ex;",
      "2820:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "2821:   ext4_ext_mark_uninitialized(ex1);",
      "2822:   ex2 = &newex;",
      "2823:  }",
      "2829:  if (!ex1 && allocated > map->m_len)",
      "2830:   ex2->ee_len = cpu_to_le16(map->m_len);",
      "2832:  if (allocated > map->m_len) {",
      "2833:   unsigned int newdepth;",
      "2835:   if (allocated <= EXT4_EXT_ZERO_LEN && may_zeroout) {",
      "2843:    ex->ee_block = orig_ex.ee_block;",
      "2844:    ex->ee_len   = cpu_to_le16(ee_len - allocated);",
      "2845:    ext4_ext_mark_uninitialized(ex);",
      "2846:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2847:    ext4_ext_dirty(handle, inode, path + depth);",
      "2849:    ex3 = &newex;",
      "2850:    ex3->ee_block = cpu_to_le32(map->m_lblk);",
      "2851:    ext4_ext_store_pblock(ex3, newblock);",
      "2852:    ex3->ee_len = cpu_to_le16(allocated);",
      "2853:    err = ext4_ext_insert_extent(handle, inode, path,",
      "2854:        ex3, 0);",
      "2855:    if (err == -ENOSPC) {",
      "2856:     err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2857:     if (err)",
      "2858:      goto fix_extent_len;",
      "2859:     ex->ee_block = orig_ex.ee_block;",
      "2860:     ex->ee_len   = orig_ex.ee_len;",
      "2861:     ext4_ext_store_pblock(ex,",
      "2862:      ext4_ext_pblock(&orig_ex));",
      "2863:     ext4_ext_dirty(handle, inode, path + depth);",
      "2865:     return allocated;",
      "2867:    } else if (err)",
      "2868:     goto fix_extent_len;",
      "2877:    err =  ext4_ext_zeroout(inode, ex3);",
      "2878:    if (err) {",
      "2884:     depth = ext_depth(inode);",
      "2885:     ext4_ext_drop_refs(path);",
      "2886:     path = ext4_ext_find_extent(inode, map->m_lblk,",
      "2887:            path);",
      "2888:     if (IS_ERR(path)) {",
      "2889:      err = PTR_ERR(path);",
      "2890:      return err;",
      "2891:     }",
      "2893:     ex = path[depth].p_ext;",
      "2894:     err = ext4_ext_get_access(handle, inode,",
      "2895:         path + depth);",
      "2896:     if (err)",
      "2897:      return err;",
      "2898:     ext4_ext_mark_uninitialized(ex);",
      "2899:     ext4_ext_dirty(handle, inode, path + depth);",
      "2900:     return err;",
      "2901:    }",
      "2904:    return allocated;",
      "2905:   }",
      "2906:   ex3 = &newex;",
      "2907:   ex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);",
      "2908:   ext4_ext_store_pblock(ex3, newblock + map->m_len);",
      "2909:   ex3->ee_len = cpu_to_le16(allocated - map->m_len);",
      "2910:   ext4_ext_mark_uninitialized(ex3);",
      "2911:   err = ext4_ext_insert_extent(handle, inode, path, ex3, 0);",
      "2912:   if (err == -ENOSPC && may_zeroout) {",
      "2913:    err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2914:    if (err)",
      "2915:     goto fix_extent_len;",
      "2917:    ex->ee_block = orig_ex.ee_block;",
      "2918:    ex->ee_len   = orig_ex.ee_len;",
      "2919:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2920:    ext4_ext_dirty(handle, inode, path + depth);",
      "2923:    return allocated;",
      "2925:   } else if (err)",
      "2926:    goto fix_extent_len;",
      "2931:   newdepth = ext_depth(inode);",
      "2936:   ee_len -= ext4_ext_get_actual_len(ex3);",
      "2937:   orig_ex.ee_len = cpu_to_le16(ee_len);",
      "2938:   may_zeroout = ee_block + ee_len <= eof_block;",
      "2940:   depth = newdepth;",
      "2941:   ext4_ext_drop_refs(path);",
      "2942:   path = ext4_ext_find_extent(inode, map->m_lblk, path);",
      "2943:   if (IS_ERR(path)) {",
      "2944:    err = PTR_ERR(path);",
      "2946:   }",
      "2947:   eh = path[depth].p_hdr;",
      "2948:   ex = path[depth].p_ext;",
      "2949:   if (ex2 != &newex)",
      "2950:    ex2 = ex;",
      "2956:   allocated = map->m_len;",
      "2962:   if (le16_to_cpu(orig_ex.ee_len) <= EXT4_EXT_ZERO_LEN &&",
      "2963:    map->m_lblk != ee_block && may_zeroout) {",
      "2964:    err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2965:    if (err)",
      "2966:     goto fix_extent_len;",
      "2968:    ex->ee_block = orig_ex.ee_block;",
      "2969:    ex->ee_len   = orig_ex.ee_len;",
      "2970:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2971:    ext4_ext_dirty(handle, inode, path + depth);",
      "2974:    return allocated;",
      "2975:   }",
      "2976:  }",
      "2982:  if (ex1 && ex1 != ex) {",
      "2983:   ex1 = ex;",
      "2984:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "2985:   ext4_ext_mark_uninitialized(ex1);",
      "2986:   ex2 = &newex;",
      "2987:  }",
      "2989:  ex2->ee_block = cpu_to_le32(map->m_lblk);",
      "2990:  ext4_ext_store_pblock(ex2, newblock);",
      "2991:  ex2->ee_len = cpu_to_le16(allocated);",
      "2992:  if (ex2 != ex)",
      "2993:   goto insert;",
      "3000:  if (ex2 > EXT_FIRST_EXTENT(eh)) {",
      "3005:   ret = ext4_ext_try_to_merge(inode, path, ex2 - 1);",
      "3006:   if (ret) {",
      "3007:    err = ext4_ext_correct_indexes(handle, inode, path);",
      "3008:    if (err)",
      "3009:     goto out;",
      "3010:    depth = ext_depth(inode);",
      "3011:    ex2--;",
      "3012:   }",
      "3019:  if (!ex3) {",
      "3020:   ret = ext4_ext_try_to_merge(inode, path, ex2);",
      "3021:   if (ret) {",
      "3022:    err = ext4_ext_correct_indexes(handle, inode, path);",
      "3028:  err = ext4_ext_dirty(handle, inode, path + depth);",
      "3029:  goto out;",
      "3030: insert:",
      "3031:  err = ext4_ext_insert_extent(handle, inode, path, &newex, 0);",
      "3032:  if (err == -ENOSPC && may_zeroout) {",
      "3033:   err =  ext4_ext_zeroout(inode, &orig_ex);",
      "3034:   if (err)",
      "3035:    goto fix_extent_len;",
      "3037:   ex->ee_block = orig_ex.ee_block;",
      "3038:   ex->ee_len   = orig_ex.ee_len;",
      "3039:   ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3040:   ext4_ext_dirty(handle, inode, path + depth);",
      "3042:   return allocated;",
      "3043:  } else if (err)",
      "3044:   goto fix_extent_len;",
      "3046:  ext4_ext_show_leaf(inode, path);",
      "3049: fix_extent_len:",
      "3050:  ex->ee_block = orig_ex.ee_block;",
      "3051:  ex->ee_len   = orig_ex.ee_len;",
      "3052:  ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3053:  ext4_ext_mark_uninitialized(ex);",
      "3054:  ext4_ext_dirty(handle, inode, path + depth);",
      "3055:  return err;",
      "",
      "[Added Lines]",
      "2783:  WARN_ON(map->m_lblk < ee_block);",
      "2788:  split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;",
      "2791:  if (ee_len <= 2*EXT4_EXT_ZERO_LEN &&",
      "2792:      (EXT4_EXT_MAY_ZEROOUT & split_flag)) {",
      "2793:   err = ext4_ext_zeroout(inode, ex);",
      "2800:   ext4_ext_mark_initialized(ex);",
      "2801:   ext4_ext_try_to_merge(inode, path, ex);",
      "2802:   err = ext4_ext_dirty(handle, inode, path + depth);",
      "2803:   goto out;",
      "2813:  split_map.m_lblk = map->m_lblk;",
      "2814:  split_map.m_len = map->m_len;",
      "2816:  if (allocated > map->m_len) {",
      "2817:   if (allocated <= EXT4_EXT_ZERO_LEN &&",
      "2818:       (EXT4_EXT_MAY_ZEROOUT & split_flag)) {",
      "2820:    zero_ex.ee_block =",
      "2821:       cpu_to_le32(map->m_lblk + map->m_len);",
      "2822:    zero_ex.ee_len = cpu_to_le16(allocated - map->m_len);",
      "2823:    ext4_ext_store_pblock(&zero_ex,",
      "2824:     ext4_ext_pblock(ex) + map->m_lblk - ee_block);",
      "2825:    err = ext4_ext_zeroout(inode, &zero_ex);",
      "2828:    split_map.m_lblk = map->m_lblk;",
      "2829:    split_map.m_len = allocated;",
      "2830:   } else if ((map->m_lblk - ee_block + map->m_len <",
      "2831:       EXT4_EXT_ZERO_LEN) &&",
      "2832:       (EXT4_EXT_MAY_ZEROOUT & split_flag)) {",
      "2834:    if (map->m_lblk != ee_block) {",
      "2835:     zero_ex.ee_block = ex->ee_block;",
      "2836:     zero_ex.ee_len = cpu_to_le16(map->m_lblk -",
      "2837:        ee_block);",
      "2838:     ext4_ext_store_pblock(&zero_ex,",
      "2839:             ext4_ext_pblock(ex));",
      "2840:     err = ext4_ext_zeroout(inode, &zero_ex);",
      "2841:     if (err)",
      "2842:      goto out;",
      "2843:    }",
      "2845:    allocated = map->m_lblk - ee_block + map->m_len;",
      "2847:    split_map.m_lblk = ee_block;",
      "2848:    split_map.m_len = allocated;",
      "2852:  allocated = ext4_split_extent(handle, inode, path,",
      "2853:            &split_map, split_flag, 0);",
      "2854:  if (allocated < 0)",
      "2855:   err = allocated;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3083:      struct ext4_ext_path *path,",
      "3084:      int flags)",
      "3085: {",
      "3096:  ext_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"",
      "3097:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
      "",
      "[Removed Lines]",
      "3086:  struct ext4_extent *ex, newex, orig_ex;",
      "3087:  struct ext4_extent *ex1 = NULL;",
      "3088:  struct ext4_extent *ex2 = NULL;",
      "3089:  struct ext4_extent *ex3 = NULL;",
      "3090:  ext4_lblk_t ee_block, eof_block;",
      "3091:  unsigned int allocated, ee_len, depth;",
      "3092:  ext4_fsblk_t newblock;",
      "3093:  int err = 0;",
      "3094:  int may_zeroout;",
      "",
      "[Added Lines]",
      "2889:  ext4_lblk_t eof_block;",
      "2890:  ext4_lblk_t ee_block;",
      "2891:  struct ext4_extent *ex;",
      "2892:  unsigned int ee_len;",
      "2893:  int split_flag = 0, depth;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3101:   inode->i_sb->s_blocksize_bits;",
      "3102:  if (eof_block < map->m_lblk + map->m_len)",
      "3103:   eof_block = map->m_lblk + map->m_len;",
      "3253: }",
      "3255: static int ext4_convert_unwritten_extents_endio(handle_t *handle,",
      "",
      "[Removed Lines]",
      "3105:  depth = ext_depth(inode);",
      "3106:  ex = path[depth].p_ext;",
      "3107:  ee_block = le32_to_cpu(ex->ee_block);",
      "3108:  ee_len = ext4_ext_get_actual_len(ex);",
      "3109:  allocated = ee_len - (map->m_lblk - ee_block);",
      "3110:  newblock = map->m_lblk - ee_block + ext4_ext_pblock(ex);",
      "3112:  ex2 = ex;",
      "3113:  orig_ex.ee_block = ex->ee_block;",
      "3114:  orig_ex.ee_len   = cpu_to_le16(ee_len);",
      "3115:  ext4_ext_store_pblock(&orig_ex, ext4_ext_pblock(ex));",
      "3121:  may_zeroout = ee_block + ee_len <= eof_block;",
      "3128:  if ((map->m_lblk == ee_block) && (allocated <= map->m_len))",
      "3129:   return allocated;",
      "3131:  err = ext4_ext_get_access(handle, inode, path + depth);",
      "3132:  if (err)",
      "3133:   goto out;",
      "3135:  if (map->m_lblk > ee_block) {",
      "3136:   ex1 = ex;",
      "3137:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "3138:   ext4_ext_mark_uninitialized(ex1);",
      "3139:   ex2 = &newex;",
      "3140:  }",
      "3146:  if (!ex1 && allocated > map->m_len)",
      "3147:   ex2->ee_len = cpu_to_le16(map->m_len);",
      "3149:  if (allocated > map->m_len) {",
      "3150:   unsigned int newdepth;",
      "3151:   ex3 = &newex;",
      "3152:   ex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);",
      "3153:   ext4_ext_store_pblock(ex3, newblock + map->m_len);",
      "3154:   ex3->ee_len = cpu_to_le16(allocated - map->m_len);",
      "3155:   ext4_ext_mark_uninitialized(ex3);",
      "3156:   err = ext4_ext_insert_extent(handle, inode, path, ex3, flags);",
      "3157:   if (err == -ENOSPC && may_zeroout) {",
      "3158:    err =  ext4_ext_zeroout(inode, &orig_ex);",
      "3159:    if (err)",
      "3160:     goto fix_extent_len;",
      "3162:    ex->ee_block = orig_ex.ee_block;",
      "3163:    ex->ee_len   = orig_ex.ee_len;",
      "3164:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3165:    ext4_ext_dirty(handle, inode, path + depth);",
      "3168:    return allocated;",
      "3170:   } else if (err)",
      "3171:    goto fix_extent_len;",
      "3176:   newdepth = ext_depth(inode);",
      "3181:   ee_len -= ext4_ext_get_actual_len(ex3);",
      "3182:   orig_ex.ee_len = cpu_to_le16(ee_len);",
      "3183:   may_zeroout = ee_block + ee_len <= eof_block;",
      "3185:   depth = newdepth;",
      "3186:   ext4_ext_drop_refs(path);",
      "3187:   path = ext4_ext_find_extent(inode, map->m_lblk, path);",
      "3188:   if (IS_ERR(path)) {",
      "3189:    err = PTR_ERR(path);",
      "3190:    goto out;",
      "3191:   }",
      "3192:   ex = path[depth].p_ext;",
      "3193:   if (ex2 != &newex)",
      "3194:    ex2 = ex;",
      "3196:   err = ext4_ext_get_access(handle, inode, path + depth);",
      "3197:   if (err)",
      "3198:    goto out;",
      "3200:   allocated = map->m_len;",
      "3201:  }",
      "3207:  if (ex1 && ex1 != ex) {",
      "3208:   ex1 = ex;",
      "3209:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "3210:   ext4_ext_mark_uninitialized(ex1);",
      "3211:   ex2 = &newex;",
      "3212:  }",
      "3217:  ex2->ee_block = cpu_to_le32(map->m_lblk);",
      "3218:  ext4_ext_store_pblock(ex2, newblock);",
      "3219:  ex2->ee_len = cpu_to_le16(allocated);",
      "3220:  ext4_ext_mark_uninitialized(ex2);",
      "3221:  if (ex2 != ex)",
      "3222:   goto insert;",
      "3224:  err = ext4_ext_dirty(handle, inode, path + depth);",
      "3225:  ext_debug(\"out here\\n\");",
      "3226:  goto out;",
      "3227: insert:",
      "3228:  err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);",
      "3229:  if (err == -ENOSPC && may_zeroout) {",
      "3230:   err =  ext4_ext_zeroout(inode, &orig_ex);",
      "3231:   if (err)",
      "3232:    goto fix_extent_len;",
      "3234:   ex->ee_block = orig_ex.ee_block;",
      "3235:   ex->ee_len   = orig_ex.ee_len;",
      "3236:   ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3237:   ext4_ext_dirty(handle, inode, path + depth);",
      "3239:   return allocated;",
      "3240:  } else if (err)",
      "3241:   goto fix_extent_len;",
      "3242: out:",
      "3243:  ext4_ext_show_leaf(inode, path);",
      "3244:  return err ? err : allocated;",
      "3246: fix_extent_len:",
      "3247:  ex->ee_block = orig_ex.ee_block;",
      "3248:  ex->ee_len   = orig_ex.ee_len;",
      "3249:  ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3250:  ext4_ext_mark_uninitialized(ex);",
      "3251:  ext4_ext_dirty(handle, inode, path + depth);",
      "3252:  return err;",
      "",
      "[Added Lines]",
      "2907:  depth = ext_depth(inode);",
      "2908:  ex = path[depth].p_ext;",
      "2909:  ee_block = le32_to_cpu(ex->ee_block);",
      "2910:  ee_len = ext4_ext_get_actual_len(ex);",
      "2912:  split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;",
      "2913:  split_flag |= EXT4_EXT_MARK_UNINIT2;",
      "2915:  flags |= EXT4_GET_BLOCKS_PRE_IO;",
      "2916:  return ext4_split_extent(handle, inode, path, map, split_flag, flags);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "58590b06d79f7ce5ab64ff3b6d537180fa50dc84",
      "candidate_info": {
        "commit_hash": "58590b06d79f7ce5ab64ff3b6d537180fa50dc84",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/58590b06d79f7ce5ab64ff3b6d537180fa50dc84",
        "files": [
          "fs/ext4/extents.c"
        ],
        "message": "ext4: fix EOFBLOCKS_FL handling\n\nIt turns out we have several problems with how EOFBLOCKS_FL is\nhandled.  First of all, there was a fencepost error where we were not\nclearing the EOFBLOCKS_FL when fill in the last uninitialized block,\nbut rather when we allocate the next block _after_ the uninitalized\nblock.  Secondly we were not testing to see if we needed to clear the\nEOFBLOCKS_FL when writing to the file O_DIRECT or when were converting\nan uninitialized block (which is the most common case).\n\nGoogle-Bug-Id: 2928259\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/extents.c||fs/ext4/extents.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3180:                 unmap_underlying_metadata(bdev, block + i);",
          "3181: }",
          "3183: static int",
          "3184: ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,",
          "3185:    struct ext4_map_blocks *map,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3186: static int check_eofblocks_fl(handle_t *handle, struct inode *inode,",
          "3187:          struct ext4_map_blocks *map,",
          "3188:          struct ext4_ext_path *path,",
          "3189:          unsigned int len)",
          "3190: {",
          "3191:  int i, depth;",
          "3192:  struct ext4_extent_header *eh;",
          "3193:  struct ext4_extent *ex, *last_ex;",
          "3195:  if (!ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS))",
          "3196:   return 0;",
          "3198:  depth = ext_depth(inode);",
          "3199:  eh = path[depth].p_hdr;",
          "3200:  ex = path[depth].p_ext;",
          "3202:  if (unlikely(!eh->eh_entries)) {",
          "3203:   EXT4_ERROR_INODE(inode, \"eh->eh_entries == 0 and \"",
          "3204:      \"EOFBLOCKS_FL set\");",
          "3205:   return -EIO;",
          "3206:  }",
          "3207:  last_ex = EXT_LAST_EXTENT(eh);",
          "3217:  if (map->m_lblk + len < le32_to_cpu(last_ex->ee_block) +",
          "3218:      ext4_ext_get_actual_len(last_ex))",
          "3219:   return 0;",
          "3227:  for (i = depth-1; i >= 0; i--)",
          "3228:   if (path[i].p_idx != EXT_LAST_INDEX(path[i].p_hdr))",
          "3229:    return 0;",
          "3230:  ext4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);",
          "3231:  return ext4_mark_inode_dirty(handle, inode);",
          "3232: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3217:  if ((flags & EXT4_GET_BLOCKS_CONVERT)) {",
          "3218:   ret = ext4_convert_unwritten_extents_endio(handle, inode,",
          "3219:        path);",
          "3221:    ext4_update_inode_fsync_trans(handle, inode, 1);",
          "3222:   goto out2;",
          "3223:  }",
          "",
          "[Removed Lines]",
          "3220:   if (ret >= 0)",
          "",
          "[Added Lines]",
          "3271:   if (ret >= 0) {",
          "3273:    err = check_eofblocks_fl(handle, inode, map, path,",
          "3274:        map->m_len);",
          "3275:   } else",
          "3276:    err = ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3246:  ret = ext4_ext_convert_to_initialized(handle, inode, map, path);",
          "3248:   ext4_update_inode_fsync_trans(handle, inode, 1);",
          "3249: out:",
          "3250:  if (ret <= 0) {",
          "3251:   err = ret;",
          "",
          "[Removed Lines]",
          "3247:  if (ret >= 0)",
          "",
          "[Added Lines]",
          "3302:  if (ret >= 0) {",
          "3304:   err = check_eofblocks_fl(handle, inode, map, path, map->m_len);",
          "3305:   if (err < 0)",
          "3306:    goto out2;",
          "3307:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3315: {",
          "3316:  struct ext4_ext_path *path = NULL;",
          "3317:  struct ext4_extent_header *eh;",
          "3319:  ext4_fsblk_t newblock;",
          "3321:  unsigned int allocated = 0;",
          "3322:  struct ext4_allocation_request ar;",
          "3323:  ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;",
          "",
          "[Removed Lines]",
          "3318:  struct ext4_extent newex, *ex, *last_ex;",
          "3320:  int i, err = 0, depth, ret, cache_type;",
          "",
          "[Added Lines]",
          "3379:  struct ext4_extent newex, *ex;",
          "3381:  int err = 0, depth, ret, cache_type;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3497:    map->m_flags |= EXT4_MAP_UNINIT;",
          "3498:  }",
          "3525:  err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);",
          "3526:  if (err) {",
          "",
          "[Removed Lines]",
          "3500:  if (unlikely(ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS))) {",
          "3501:   if (unlikely(!eh->eh_entries)) {",
          "3502:    EXT4_ERROR_INODE(inode,",
          "3503:       \"eh->eh_entries == 0 and \"",
          "3504:       \"EOFBLOCKS_FL set\");",
          "3505:    err = -EIO;",
          "3506:    goto out2;",
          "3507:   }",
          "3508:   last_ex = EXT_LAST_EXTENT(eh);",
          "3516:   for (i = depth-1; i >= 0; i--) {",
          "3517:    if (path[i].p_idx != EXT_LAST_INDEX(path[i].p_hdr))",
          "3518:     break;",
          "3519:   }",
          "3520:   if ((i < 0) &&",
          "3521:       (map->m_lblk + ar.len > le32_to_cpu(last_ex->ee_block) +",
          "3522:        ext4_ext_get_actual_len(last_ex)))",
          "3523:    ext4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);",
          "3524:  }",
          "",
          "[Added Lines]",
          "3561:  err = check_eofblocks_fl(handle, inode, map, path, ar.len);",
          "3562:  if (err)",
          "3563:   goto out2;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "09dc942c2a767e2d298f1cc9294bc19c7d7208c5",
      "candidate_info": {
        "commit_hash": "09dc942c2a767e2d298f1cc9294bc19c7d7208c5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/09dc942c2a767e2d298f1cc9294bc19c7d7208c5",
        "files": [
          "fs/ext4/acl.c",
          "fs/ext4/balloc.c",
          "fs/ext4/block_validity.c",
          "fs/ext4/dir.c",
          "fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.c",
          "fs/ext4/ext4_jbd2.h",
          "fs/ext4/extents.c",
          "fs/ext4/file.c",
          "fs/ext4/ialloc.c",
          "fs/ext4/inode.c",
          "fs/ext4/mballoc.c",
          "fs/ext4/migrate.c",
          "fs/ext4/move_extent.c",
          "fs/ext4/namei.c",
          "fs/ext4/resize.c",
          "fs/ext4/super.c",
          "fs/ext4/xattr.c",
          "fs/jbd2/checkpoint.c",
          "fs/jbd2/commit.c",
          "fs/jbd2/journal.c",
          "fs/jbd2/recovery.c",
          "fs/jbd2/transaction.c",
          "fs/ocfs2/journal.c",
          "include/linux/jbd2.h",
          "include/trace/events/ext4.h"
        ],
        "message": "Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4\n\n* 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (40 commits)\n  ext4: Adding error check after calling ext4_mb_regular_allocator()\n  ext4: Fix dirtying of journalled buffers in data=journal mode\n  ext4: re-inline ext4_rec_len_(to|from)_disk functions\n  jbd2: Remove t_handle_lock from start_this_handle()\n  jbd2: Change j_state_lock to be a rwlock_t\n  jbd2: Use atomic variables to avoid taking t_handle_lock in jbd2_journal_stop\n  ext4: Add mount options in superblock\n  ext4: force block allocation on quota_off\n  ext4: fix freeze deadlock under IO\n  ext4: drop inode from orphan list if ext4_delete_inode() fails\n  ext4: check to make make sure bd_dev is set before dereferencing it\n  jbd2: Make barrier messages less scary\n  ext4: don't print scary messages for allocation failures post-abort\n  ext4: fix EFBIG edge case when writing to large non-extent file\n  ext4: fix ext4_get_blocks references\n  ext4: Always journal quota file modifications\n  ext4: Fix potential memory leak in ext4_fill_super\n  ext4: Don't error out the fs if the user tries to make a file too big\n  ext4: allocate stripe-multiple IOs on stripe boundaries\n  ext4: move aio completion after unwritten extent conversion\n  ...\n\nFix up conflicts in fs/ext4/inode.c as per Ted.\n\nFix up xfs conflicts as per earlier xfs merge.",
        "before_after_code_files": [
          "fs/ext4/acl.c||fs/ext4/acl.c",
          "fs/ext4/balloc.c||fs/ext4/balloc.c",
          "fs/ext4/block_validity.c||fs/ext4/block_validity.c",
          "fs/ext4/dir.c||fs/ext4/dir.c",
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.c||fs/ext4/ext4_jbd2.c",
          "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/ext4/ialloc.c||fs/ext4/ialloc.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/mballoc.c||fs/ext4/mballoc.c",
          "fs/ext4/migrate.c||fs/ext4/migrate.c",
          "fs/ext4/move_extent.c||fs/ext4/move_extent.c",
          "fs/ext4/namei.c||fs/ext4/namei.c",
          "fs/ext4/resize.c||fs/ext4/resize.c",
          "fs/ext4/super.c||fs/ext4/super.c",
          "fs/ext4/xattr.c||fs/ext4/xattr.c",
          "fs/jbd2/checkpoint.c||fs/jbd2/checkpoint.c",
          "fs/jbd2/commit.c||fs/jbd2/commit.c",
          "fs/jbd2/journal.c||fs/jbd2/journal.c",
          "fs/jbd2/recovery.c||fs/jbd2/recovery.c",
          "fs/jbd2/transaction.c||fs/jbd2/transaction.c",
          "fs/ocfs2/journal.c||fs/ocfs2/journal.c",
          "include/linux/jbd2.h||include/linux/jbd2.h",
          "include/trace/events/ext4.h||include/trace/events/ext4.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/acl.c||fs/ext4/acl.c": [
          "File: fs/ext4/acl.c -> fs/ext4/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "204:     return error;",
          "205:    else {",
          "206:     inode->i_mode = mode;",
          "207:     ext4_mark_inode_dirty(handle, inode);",
          "208:     if (error == 0)",
          "209:      acl = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:     inode->i_ctime = ext4_current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/balloc.c||fs/ext4/balloc.c": [
          "File: fs/ext4/balloc.c -> fs/ext4/balloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "377:  ext4_grpblk_t bit;",
          "378:  unsigned int i;",
          "379:  struct ext4_group_desc *desc;",
          "382:  int err = 0, ret, blk_free_count;",
          "383:  ext4_grpblk_t blocks_freed;",
          "384:  struct ext4_group_info *grp;",
          "388:  ext4_debug(\"Adding block(s) %llu-%llu\\n\", block, block + count - 1);",
          "390:  ext4_get_group_no_and_offset(sb, block, &block_group, &bit);",
          "",
          "[Removed Lines]",
          "380:  struct ext4_super_block *es;",
          "381:  struct ext4_sb_info *sbi;",
          "386:  sbi = EXT4_SB(sb);",
          "387:  es = sbi->s_es;",
          "",
          "[Added Lines]",
          "380:  struct ext4_sb_info *sbi = EXT4_SB(sb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "477:  ret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);",
          "478:  if (!err)",
          "479:   err = ret;",
          "482: error_return:",
          "483:  brelse(bitmap_bh);",
          "",
          "[Removed Lines]",
          "480:  sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/block_validity.c||fs/ext4/block_validity.c": [
          "File: fs/ext4/block_validity.c -> fs/ext4/block_validity.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "230:  if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||",
          "231:      (start_blk + count < start_blk) ||",
          "233:   return 0;",
          "234:  while (n) {",
          "235:   entry = rb_entry(n, struct ext4_system_zone, node);",
          "236:   if (start_blk + count - 1 < entry->start_blk)",
          "237:    n = n->rb_left;",
          "238:   else if (start_blk >= (entry->start_blk + entry->count))",
          "239:    n = n->rb_right;",
          "241:    return 0;",
          "242:  }",
          "243:  return 1;",
          "244: }",
          "",
          "[Removed Lines]",
          "232:      (start_blk + count > ext4_blocks_count(sbi->s_es)))",
          "240:   else",
          "",
          "[Added Lines]",
          "232:      (start_blk + count > ext4_blocks_count(sbi->s_es))) {",
          "233:   sbi->s_es->s_last_error_block = cpu_to_le64(start_blk);",
          "235:  }",
          "242:   else {",
          "243:    sbi->s_es->s_last_error_block = cpu_to_le64(start_blk);",
          "245:   }",
          "",
          "---------------"
        ],
        "fs/ext4/dir.c||fs/ext4/dir.c": [
          "File: fs/ext4/dir.c -> fs/ext4/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: }",
          "68: {",
          "69:  const char *error_msg = NULL;",
          "70:  const int rlen = ext4_rec_len_from_disk(de->rec_len,",
          "",
          "[Removed Lines]",
          "64: int ext4_check_dir_entry(const char *function, struct inode *dir,",
          "65:     struct ext4_dir_entry_2 *de,",
          "66:     struct buffer_head *bh,",
          "67:     unsigned int offset)",
          "",
          "[Added Lines]",
          "64: int __ext4_check_dir_entry(const char *function, unsigned int line,",
          "65:       struct inode *dir,",
          "66:       struct ext4_dir_entry_2 *de,",
          "67:       struct buffer_head *bh,",
          "68:       unsigned int offset)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:   error_msg = \"inode out of bounds\";",
          "85:  if (error_msg != NULL)",
          "88:    \"offset=%u(%u), inode=%u, rec_len=%d, name_len=%d\",",
          "91:    le32_to_cpu(de->inode),",
          "92:    rlen, de->name_len);",
          "93:  return error_msg == NULL ? 1 : 0;",
          "",
          "[Removed Lines]",
          "86:   ext4_error_inode(function, dir,",
          "87:    \"bad entry in directory: %s - block=%llu\"",
          "89:    error_msg, (unsigned long long) bh->b_blocknr,",
          "90:    (unsigned) (offset%bh->b_size), offset,",
          "",
          "[Added Lines]",
          "87:   ext4_error_inode(dir, function, line, bh->b_blocknr,",
          "88:    \"bad entry in directory: %s - \"",
          "90:    error_msg, (unsigned) (offset%bh->b_size), offset,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:  }",
          "126:  stored = 0;",
          "127:  offset = filp->f_pos & (sb->s_blocksize - 1);",
          "",
          "[Removed Lines]",
          "124:   ext4_clear_inode_flag(filp->f_path.dentry->d_inode, EXT4_INODE_INDEX);",
          "",
          "[Added Lines]",
          "124:   ext4_clear_inode_flag(filp->f_path.dentry->d_inode,",
          "125:           EXT4_INODE_INDEX);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "193:   while (!error && filp->f_pos < inode->i_size",
          "194:          && offset < sb->s_blocksize) {",
          "195:    de = (struct ext4_dir_entry_2 *) (bh->b_data + offset);",
          "197:         bh, offset)) {",
          "",
          "[Removed Lines]",
          "196:    if (!ext4_check_dir_entry(\"ext4_readdir\", inode, de,",
          "",
          "[Added Lines]",
          "197:    if (!ext4_check_dir_entry(inode, de,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "343:  struct dir_private_info *info;",
          "344:  int len;",
          "347:  p = &info->root.rb_node;",
          "",
          "[Removed Lines]",
          "346:  info = (struct dir_private_info *) dir_file->private_data;",
          "",
          "[Added Lines]",
          "347:  info = dir_file->private_data;",
          "",
          "---------------"
        ],
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #endif",
          "59: #define EXT4_ERROR_INODE(inode, fmt, a...) \\",
          "62: #define EXT4_ERROR_FILE(file, fmt, a...) \\",
          "66: typedef int ext4_grpblk_t;",
          "",
          "[Removed Lines]",
          "60:  ext4_error_inode(__func__, (inode), (fmt), ## a)",
          "63:  ext4_error_file(__func__, (file), (fmt), ## a)",
          "",
          "[Added Lines]",
          "60:  ext4_error_inode((inode), __func__, __LINE__, 0, (fmt), ## a)",
          "62: #define EXT4_ERROR_INODE_BLOCK(inode, block, fmt, a...)   \\",
          "63:  ext4_error_inode((inode), __func__, __LINE__, (block), (fmt), ## a)",
          "66:  ext4_error_file(__func__, __LINE__, (file), (fmt), ## a)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "985:  __u8 s_reserved_char_pad;",
          "",
          "[Added Lines]",
          "989:  __u8 s_jnl_backup_type;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1004:  __le16  s_reserved_pad;",
          "1007: };",
          "1009: #ifdef __KERNEL__",
          "",
          "[Removed Lines]",
          "1003:  __u8 s_reserved_char_pad2;",
          "",
          "[Added Lines]",
          "1007:  __u8 s_reserved_char_pad;",
          "1012:  __le64 s_snapshot_r_blocks_count; /* reserved blocks for active",
          "1014:  __le32 s_snapshot_list; /* inode number of the head of the",
          "1016: #define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)",
          "1028: #define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)",
          "1029:  __u8 s_mount_opts[64];",
          "1033: #define EXT4_S_ERR_LEN (EXT4_S_ERR_END - EXT4_S_ERR_START)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1145:  struct workqueue_struct *dio_unwritten_wq;",
          "1146: };",
          "1148: static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1174:  struct timer_list s_err_report;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1313: #define EXT4_DEFM_JMODE_DATA 0x0020",
          "1314: #define EXT4_DEFM_JMODE_ORDERED 0x0040",
          "1315: #define EXT4_DEFM_JMODE_WBACK 0x0060",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1345: #define EXT4_DEFM_NOBARRIER 0x0100",
          "1346: #define EXT4_DEFM_BLOCK_VALIDITY 0x0200",
          "1347: #define EXT4_DEFM_DISCARD 0x0400",
          "1348: #define EXT4_DEFM_NODELALLOC 0x0800",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1378:       ~EXT4_DIR_ROUND)",
          "1379: #define EXT4_MAX_REC_LEN  ((1<<16)-1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1418: static inline unsigned int",
          "1419: ext4_rec_len_from_disk(__le16 dlen, unsigned blocksize)",
          "1420: {",
          "1421:  unsigned len = le16_to_cpu(dlen);",
          "1423: #if (PAGE_CACHE_SIZE >= 65536)",
          "1424:  if (len == EXT4_MAX_REC_LEN || len == 0)",
          "1425:   return blocksize;",
          "1426:  return (len & 65532) | ((len & 3) << 16);",
          "1427: #else",
          "1428:  return len;",
          "1429: #endif",
          "1430: }",
          "1432: static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)",
          "1433: {",
          "1434:  if ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))",
          "1435:   BUG();",
          "1436: #if (PAGE_CACHE_SIZE >= 65536)",
          "1437:  if (len < 65536)",
          "1438:   return cpu_to_le16(len);",
          "1439:  if (len == blocksize) {",
          "1440:   if (blocksize == 65536)",
          "1441:    return cpu_to_le16(EXT4_MAX_REC_LEN);",
          "1442:   else",
          "1443:    return cpu_to_le16(0);",
          "1444:  }",
          "1445:  return cpu_to_le16((len & 65532) | ((len >> 16) & 3));",
          "1446: #else",
          "1447:  return cpu_to_le16(len);",
          "1448: #endif",
          "1449: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1510:   ext4_init_block_bitmap(sb, NULL, group, desc)",
          "1516: extern int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,",
          "1517:         __u32 minor_hash,",
          "1518:         struct ext4_dir_entry_2 *dirent);",
          "",
          "[Removed Lines]",
          "1513: extern int ext4_check_dir_entry(const char *, struct inode *,",
          "1514:     struct ext4_dir_entry_2 *,",
          "1515:     struct buffer_head *, unsigned int);",
          "",
          "[Added Lines]",
          "1583: extern int __ext4_check_dir_entry(const char *, unsigned int, struct inode *,",
          "1584:       struct ext4_dir_entry_2 *,",
          "1585:       struct buffer_head *, unsigned int);",
          "1586: #define ext4_check_dir_entry(dir, de, bh, offset) \\",
          "1587:  __ext4_check_dir_entry(__func__, __LINE__, (dir), (de), (bh), (offset))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1601: extern int ext4_ext_migrate(struct inode *);",
          "1606: extern int ext4_orphan_add(handle_t *, struct inode *);",
          "1607: extern int ext4_orphan_del(handle_t *, struct inode *);",
          "1608: extern int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,",
          "",
          "[Removed Lines]",
          "1604: extern unsigned int ext4_rec_len_from_disk(__le16 dlen, unsigned blocksize);",
          "1605: extern __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1616:     ext4_fsblk_t n_blocks_count);",
          "1630:      const char *, ...)",
          "1633: extern void ext4_msg(struct super_block *, const char *, const char *, ...)",
          "1634:  __attribute__ ((format (printf, 3, 4)));",
          "1638: extern void ext4_update_dynamic_rev(struct super_block *sb);",
          "1639: extern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,",
          "1640:      __u32 compat);",
          "",
          "[Removed Lines]",
          "1619: extern void __ext4_error(struct super_block *, const char *, const char *, ...)",
          "1620:  __attribute__ ((format (printf, 3, 4)));",
          "1621: #define ext4_error(sb, message...) __ext4_error(sb, __func__, ## message)",
          "1622: extern void ext4_error_inode(const char *, struct inode *, const char *, ...)",
          "1623:  __attribute__ ((format (printf, 3, 4)));",
          "1624: extern void ext4_error_file(const char *, struct file *, const char *, ...)",
          "1625:  __attribute__ ((format (printf, 3, 4)));",
          "1626: extern void __ext4_std_error(struct super_block *, const char *, int);",
          "1627: extern void ext4_abort(struct super_block *, const char *, const char *, ...)",
          "1628:  __attribute__ ((format (printf, 3, 4)));",
          "1629: extern void __ext4_warning(struct super_block *, const char *,",
          "1631:  __attribute__ ((format (printf, 3, 4)));",
          "1632: #define ext4_warning(sb, message...) __ext4_warning(sb, __func__, ## message)",
          "1635: extern void ext4_grp_locked_error(struct super_block *, ext4_group_t,",
          "1636:     const char *, const char *, ...)",
          "1637:  __attribute__ ((format (printf, 4, 5)));",
          "",
          "[Added Lines]",
          "1689: extern void __ext4_error(struct super_block *, const char *, unsigned int,",
          "1690:     const char *, ...)",
          "1691:  __attribute__ ((format (printf, 4, 5)));",
          "1692: #define ext4_error(sb, message...) __ext4_error(sb, __func__, \\",
          "1693:            __LINE__, ## message)",
          "1694: extern void ext4_error_inode(struct inode *, const char *, unsigned int,",
          "1695:         ext4_fsblk_t, const char *, ...)",
          "1696:  __attribute__ ((format (printf, 5, 6)));",
          "1697: extern void ext4_error_file(struct file *, const char *, unsigned int,",
          "1698:        const char *, ...)",
          "1699:  __attribute__ ((format (printf, 4, 5)));",
          "1700: extern void __ext4_std_error(struct super_block *, const char *,",
          "1701:         unsigned int, int);",
          "1702: extern void __ext4_abort(struct super_block *, const char *, unsigned int,",
          "1703:          const char *, ...)",
          "1704:  __attribute__ ((format (printf, 4, 5)));",
          "1705: #define ext4_abort(sb, message...) __ext4_abort(sb, __func__, \\",
          "1706:              __LINE__, ## message)",
          "1707: extern void __ext4_warning(struct super_block *, const char *, unsigned int,",
          "1709:  __attribute__ ((format (printf, 4, 5)));",
          "1710: #define ext4_warning(sb, message...) __ext4_warning(sb, __func__, \\",
          "1711:              __LINE__, ## message)",
          "1714: extern void __ext4_grp_locked_error(const char *, unsigned int, \\",
          "1715:         struct super_block *, ext4_group_t, \\",
          "1716:         unsigned long, ext4_fsblk_t, \\",
          "1717:         const char *, ...)",
          "1718:  __attribute__ ((format (printf, 7, 8)));",
          "1719: #define ext4_grp_locked_error(sb, grp, message...) \\",
          "1720:  __ext4_grp_locked_error(__func__, __LINE__, (sb), (grp), ## message)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1768: #define ext4_std_error(sb, errno)    \\",
          "1769: do {        \\",
          "1770:  if ((errno))      \\",
          "1772: } while (0)",
          "1774: #ifdef CONFIG_SMP",
          "",
          "[Removed Lines]",
          "1771:   __ext4_std_error((sb), __func__, (errno)); \\",
          "",
          "[Added Lines]",
          "1854:   __ext4_std_error((sb), __func__, __LINE__, (errno)); \\",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1860:  spin_unlock(ext4_group_lock_ptr(sb, group));",
          "1861: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1946: static inline void ext4_mark_super_dirty(struct super_block *sb)",
          "1947: {",
          "1948:  if (EXT4_SB(sb)->s_journal == NULL)",
          "1949:   sb->s_dirt =1;",
          "1950: }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1905:      ssize_t len);",
          "1906: extern int ext4_map_blocks(handle_t *handle, struct inode *inode,",
          "1907:       struct ext4_map_blocks *map, int flags);",
          "1911: extern int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,",
          "1912:    __u64 start, __u64 len);",
          "",
          "[Removed Lines]",
          "1908: extern int ext4_get_blocks(handle_t *handle, struct inode *inode,",
          "1909:       sector_t block, unsigned int max_blocks,",
          "1910:       struct buffer_head *bh, int flags);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/ext4_jbd2.c||fs/ext4/ext4_jbd2.c": [
          "File: fs/ext4/ext4_jbd2.c -> fs/ext4/ext4_jbd2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #include <trace/events/ext4.h>",
          "11: {",
          "12:  int err = 0;",
          "14:  if (ext4_handle_valid(handle)) {",
          "15:   err = jbd2_journal_get_undo_access(handle, bh);",
          "16:   if (err)",
          "18:         handle, err);",
          "19:  }",
          "20:  return err;",
          "21: }",
          "25: {",
          "26:  int err = 0;",
          "28:  if (ext4_handle_valid(handle)) {",
          "29:   err = jbd2_journal_get_write_access(handle, bh);",
          "30:   if (err)",
          "32:         handle, err);",
          "33:  }",
          "34:  return err;",
          "",
          "[Removed Lines]",
          "9: int __ext4_journal_get_undo_access(const char *where, handle_t *handle,",
          "10:     struct buffer_head *bh)",
          "17:    ext4_journal_abort_handle(where, __func__, bh,",
          "23: int __ext4_journal_get_write_access(const char *where, handle_t *handle,",
          "24:     struct buffer_head *bh)",
          "31:    ext4_journal_abort_handle(where, __func__, bh,",
          "",
          "[Added Lines]",
          "9: int __ext4_journal_get_undo_access(const char *where, unsigned int line,",
          "10:        handle_t *handle, struct buffer_head *bh)",
          "17:    ext4_journal_abort_handle(where, line, __func__, bh,",
          "23: int __ext4_journal_get_write_access(const char *where, unsigned int line,",
          "24:         handle_t *handle, struct buffer_head *bh)",
          "31:    ext4_journal_abort_handle(where, line, __func__, bh,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: {",
          "53:  int err;",
          "",
          "[Removed Lines]",
          "49: int __ext4_forget(const char *where, handle_t *handle, int is_metadata,",
          "50:     struct inode *inode, struct buffer_head *bh,",
          "51:     ext4_fsblk_t blocknr)",
          "",
          "[Added Lines]",
          "49: int __ext4_forget(const char *where, unsigned int line, handle_t *handle,",
          "50:     int is_metadata, struct inode *inode,",
          "51:     struct buffer_head *bh, ext4_fsblk_t blocknr)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:    BUFFER_TRACE(bh, \"call jbd2_journal_forget\");",
          "80:    err = jbd2_journal_forget(handle, bh);",
          "81:    if (err)",
          "84:    return err;",
          "85:   }",
          "86:   return 0;",
          "",
          "[Removed Lines]",
          "82:     ext4_journal_abort_handle(where, __func__, bh,",
          "83:          handle, err);",
          "",
          "[Added Lines]",
          "82:     ext4_journal_abort_handle(where, line, __func__,",
          "83:          bh, handle, err);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "92:  BUFFER_TRACE(bh, \"call jbd2_journal_revoke\");",
          "93:  err = jbd2_journal_revoke(handle, blocknr, bh);",
          "94:  if (err) {",
          "97:       \"error %d when attempting revoke\", err);",
          "98:  }",
          "99:  BUFFER_TRACE(bh, \"exit\");",
          "100:  return err;",
          "101: }",
          "104:     handle_t *handle, struct buffer_head *bh)",
          "105: {",
          "106:  int err = 0;",
          "",
          "[Removed Lines]",
          "95:   ext4_journal_abort_handle(where, __func__, bh, handle, err);",
          "96:   ext4_abort(inode->i_sb, __func__,",
          "103: int __ext4_journal_get_create_access(const char *where,",
          "",
          "[Added Lines]",
          "95:   ext4_journal_abort_handle(where, line, __func__,",
          "96:        bh, handle, err);",
          "97:   __ext4_abort(inode->i_sb, where, line,",
          "104: int __ext4_journal_get_create_access(const char *where, unsigned int line,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "108:  if (ext4_handle_valid(handle)) {",
          "109:   err = jbd2_journal_get_create_access(handle, bh);",
          "110:   if (err)",
          "113:  }",
          "114:  return err;",
          "115: }",
          "119: {",
          "120:  int err = 0;",
          "122:  if (ext4_handle_valid(handle)) {",
          "123:   err = jbd2_journal_dirty_metadata(handle, bh);",
          "124:   if (err)",
          "127:  } else {",
          "128:   if (inode)",
          "129:    mark_buffer_dirty_inode(bh, inode);",
          "",
          "[Removed Lines]",
          "111:    ext4_journal_abort_handle(where, __func__, bh,",
          "112:         handle, err);",
          "117: int __ext4_handle_dirty_metadata(const char *where, handle_t *handle,",
          "118:      struct inode *inode, struct buffer_head *bh)",
          "125:    ext4_journal_abort_handle(where, __func__, bh,",
          "126:         handle, err);",
          "",
          "[Added Lines]",
          "112:    ext4_journal_abort_handle(where, line, __func__,",
          "113:         bh, handle, err);",
          "118: int __ext4_handle_dirty_metadata(const char *where, unsigned int line,",
          "119:      handle_t *handle, struct inode *inode,",
          "120:      struct buffer_head *bh)",
          "127:    ext4_journal_abort_handle(where, line, __func__,",
          "128:         bh, handle, err);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "132:   if (inode && inode_needs_sync(inode)) {",
          "133:    sync_dirty_buffer(bh);",
          "134:    if (buffer_req(bh) && !buffer_uptodate(bh)) {",
          "140:     err = -EIO;",
          "141:    }",
          "142:   }",
          "143:  }",
          "144:  return err;",
          "145: }",
          "",
          "[Removed Lines]",
          "135:     ext4_error(inode->i_sb,",
          "136:         \"IO error syncing inode, \"",
          "137:         \"inode=%lu, block=%llu\",",
          "138:         inode->i_ino,",
          "139:         (unsigned long long) bh->b_blocknr);",
          "",
          "[Added Lines]",
          "137:     struct ext4_super_block *es;",
          "139:     es = EXT4_SB(inode->i_sb)->s_es;",
          "140:     es->s_last_error_block =",
          "141:      cpu_to_le64(bh->b_blocknr);",
          "142:     ext4_error_inode(inode, where, line,",
          "143:        bh->b_blocknr,",
          "144:      \"IO error syncing itable block\");",
          "152: int __ext4_handle_dirty_super(const char *where, unsigned int line,",
          "153:          handle_t *handle, struct super_block *sb)",
          "154: {",
          "155:  struct buffer_head *bh = EXT4_SB(sb)->s_sbh;",
          "156:  int err = 0;",
          "158:  if (ext4_handle_valid(handle)) {",
          "159:   err = jbd2_journal_dirty_metadata(handle, bh);",
          "160:   if (err)",
          "161:    ext4_journal_abort_handle(where, line, __func__,",
          "162:         bh, handle, err);",
          "163:  } else",
          "164:   sb->s_dirt = 1;",
          "165:  return err;",
          "166: }",
          "",
          "---------------"
        ],
        "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
          "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:   struct buffer_head *bh, handle_t *handle, int err);",
          "139:     handle_t *handle, struct buffer_head *bh);",
          "144: #define ext4_journal_get_undo_access(handle, bh) \\",
          "146: #define ext4_journal_get_write_access(handle, bh) \\",
          "148: #define ext4_forget(handle, is_metadata, inode, bh, block_nr) \\",
          "151: #define ext4_journal_get_create_access(handle, bh) \\",
          "153: #define ext4_handle_dirty_metadata(handle, inode, bh) \\",
          "156: handle_t *ext4_journal_start_sb(struct super_block *sb, int nblocks);",
          "159: #define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)",
          "",
          "[Removed Lines]",
          "125: void ext4_journal_abort_handle(const char *caller, const char *err_fn,",
          "128: int __ext4_journal_get_undo_access(const char *where, handle_t *handle,",
          "129:     struct buffer_head *bh);",
          "131: int __ext4_journal_get_write_access(const char *where, handle_t *handle,",
          "132:     struct buffer_head *bh);",
          "134: int __ext4_forget(const char *where, handle_t *handle, int is_metadata,",
          "135:     struct inode *inode, struct buffer_head *bh,",
          "136:     ext4_fsblk_t blocknr);",
          "138: int __ext4_journal_get_create_access(const char *where,",
          "141: int __ext4_handle_dirty_metadata(const char *where, handle_t *handle,",
          "142:      struct inode *inode, struct buffer_head *bh);",
          "145:  __ext4_journal_get_undo_access(__func__, (handle), (bh))",
          "147:  __ext4_journal_get_write_access(__func__, (handle), (bh))",
          "149:  __ext4_forget(__func__, (handle), (is_metadata), (inode), (bh),\\",
          "150:         (block_nr))",
          "152:  __ext4_journal_get_create_access(__func__, (handle), (bh))",
          "154:  __ext4_handle_dirty_metadata(__func__, (handle), (inode), (bh))",
          "157: int __ext4_journal_stop(const char *where, handle_t *handle);",
          "",
          "[Added Lines]",
          "125: void ext4_journal_abort_handle(const char *caller, unsigned int line,",
          "126:           const char *err_fn,",
          "129: int __ext4_journal_get_undo_access(const char *where, unsigned int line,",
          "130:        handle_t *handle, struct buffer_head *bh);",
          "132: int __ext4_journal_get_write_access(const char *where, unsigned int line,",
          "133:         handle_t *handle, struct buffer_head *bh);",
          "135: int __ext4_forget(const char *where, unsigned int line, handle_t *handle,",
          "136:     int is_metadata, struct inode *inode,",
          "137:     struct buffer_head *bh, ext4_fsblk_t blocknr);",
          "139: int __ext4_journal_get_create_access(const char *where, unsigned int line,",
          "142: int __ext4_handle_dirty_metadata(const char *where, unsigned int line,",
          "143:      handle_t *handle, struct inode *inode,",
          "144:      struct buffer_head *bh);",
          "146: int __ext4_handle_dirty_super(const char *where, unsigned int line,",
          "147:          handle_t *handle, struct super_block *sb);",
          "150:  __ext4_journal_get_undo_access(__func__, __LINE__, (handle), (bh))",
          "152:  __ext4_journal_get_write_access(__func__, __LINE__, (handle), (bh))",
          "154:  __ext4_forget(__func__, __LINE__, (handle), (is_metadata), (inode), \\",
          "155:         (bh), (block_nr))",
          "157:  __ext4_journal_get_create_access(__func__, __LINE__, (handle), (bh))",
          "159:  __ext4_handle_dirty_metadata(__func__, __LINE__, (handle), (inode), \\",
          "160:          (bh))",
          "161: #define ext4_handle_dirty_super(handle, sb) \\",
          "162:  __ext4_handle_dirty_super(__func__, __LINE__, (handle), (sb))",
          "165: int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207: }",
          "209: #define ext4_journal_stop(handle) \\",
          "212: static inline handle_t *ext4_journal_current_handle(void)",
          "213: {",
          "",
          "[Removed Lines]",
          "210:  __ext4_journal_stop(__func__, (handle))",
          "",
          "[Added Lines]",
          "218:  __ext4_journal_stop(__func__, __LINE__, (handle))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "316: static inline int ext4_should_dioread_nolock(struct inode *inode)",
          "317: {",
          "318:  if (!test_opt(inode->i_sb, DIOREAD_NOLOCK))",
          "319:   return 0;",
          "322:  if (!S_ISREG(inode->i_mode))",
          "323:   return 0;",
          "324:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "[Removed Lines]",
          "320:  if (test_opt(inode->i_sb, NOBH))",
          "321:   return 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "401:  return 1;",
          "402: }",
          "407: {",
          "408:  const char *error_msg;",
          "409:  int max = 0;",
          "",
          "[Removed Lines]",
          "404: static int __ext4_ext_check(const char *function, struct inode *inode,",
          "405:      struct ext4_extent_header *eh,",
          "406:      int depth)",
          "",
          "[Added Lines]",
          "404: static int __ext4_ext_check(const char *function, unsigned int line,",
          "405:        struct inode *inode, struct ext4_extent_header *eh,",
          "406:        int depth)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "436:  return 0;",
          "438: corrupted:",
          "440:    \"bad header/extent: %s - magic %x, \"",
          "441:    \"entries %u, max %u(%u), depth %u(%u)\",",
          "442:    error_msg, le16_to_cpu(eh->eh_magic),",
          "",
          "[Removed Lines]",
          "439:  ext4_error_inode(function, inode,",
          "",
          "[Added Lines]",
          "439:  ext4_error_inode(inode, function, line, 0,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "447: }",
          "449: #define ext4_ext_check(inode, eh, depth) \\",
          "452: int ext4_ext_check_inode(struct inode *inode)",
          "453: {",
          "",
          "[Removed Lines]",
          "450:  __ext4_ext_check(__func__, inode, eh, depth)",
          "",
          "[Added Lines]",
          "450:  __ext4_ext_check(__func__, __LINE__, inode, eh, depth)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1083: {",
          "1084:  struct ext4_ext_path *curp = path;",
          "1085:  struct ext4_extent_header *neh;",
          "1087:  struct buffer_head *bh;",
          "1088:  ext4_fsblk_t newblock;",
          "1089:  int err = 0;",
          "",
          "[Removed Lines]",
          "1086:  struct ext4_extent_idx *fidx;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1144:  ext4_idx_store_pblock(curp->p_idx, newblock);",
          "1146:  neh = ext_inode_hdr(inode);",
          "1148:  ext_debug(\"new root: num %d(%d), lblock %d, ptr %llu\\n\",",
          "1149:     le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),",
          "1152:  neh->eh_depth = cpu_to_le16(path->p_depth + 1);",
          "1153:  err = ext4_ext_dirty(handle, inode, curp);",
          "",
          "[Removed Lines]",
          "1147:  fidx = EXT_FIRST_INDEX(neh);",
          "1150:     le32_to_cpu(fidx->ei_block), idx_pblock(fidx));",
          "",
          "[Added Lines]",
          "1148:     le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),",
          "1149:     idx_pblock(EXT_FIRST_INDEX(neh)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2954:  struct ext4_extent *ex1 = NULL;",
          "2955:  struct ext4_extent *ex2 = NULL;",
          "2956:  struct ext4_extent *ex3 = NULL;",
          "2958:  ext4_lblk_t ee_block, eof_block;",
          "2959:  unsigned int allocated, ee_len, depth;",
          "2960:  ext4_fsblk_t newblock;",
          "",
          "[Removed Lines]",
          "2957:  struct ext4_extent_header *eh;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2971:   eof_block = map->m_lblk + map->m_len;",
          "2973:  depth = ext_depth(inode);",
          "2975:  ex = path[depth].p_ext;",
          "2976:  ee_block = le32_to_cpu(ex->ee_block);",
          "2977:  ee_len = ext4_ext_get_actual_len(ex);",
          "",
          "[Removed Lines]",
          "2974:  eh = path[depth].p_hdr;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3058:    err = PTR_ERR(path);",
          "3059:    goto out;",
          "3060:   }",
          "3062:   ex = path[depth].p_ext;",
          "3063:   if (ex2 != &newex)",
          "3064:    ex2 = ex;",
          "",
          "[Removed Lines]",
          "3061:   eh = path[depth].p_hdr;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:   struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);",
          "71:   size_t length = iov_length(iov, nr_segs);",
          "74:    return -EFBIG;",
          "76:   if (pos + length > sbi->s_bitmap_maxbytes) {",
          "",
          "[Removed Lines]",
          "73:   if (pos > sbi->s_bitmap_maxbytes)",
          "",
          "[Added Lines]",
          "73:   if ((pos > sbi->s_bitmap_maxbytes ||",
          "74:       (pos == sbi->s_bitmap_maxbytes && length > 0)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:   if (!IS_ERR(cp)) {",
          "124:    memcpy(sbi->s_es->s_last_mounted, cp,",
          "125:           sizeof(sbi->s_es->s_last_mounted));",
          "127:   }",
          "128:  }",
          "129:  return dquot_file_open(inode, filp);",
          "",
          "[Removed Lines]",
          "126:    sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "127:    ext4_mark_super_dirty(sb);",
          "",
          "---------------"
        ],
        "fs/ext4/ialloc.c||fs/ext4/ialloc.c": [
          "File: fs/ext4/ialloc.c -> fs/ext4/ialloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "279:   err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);",
          "280:   if (!fatal)",
          "281:    fatal = err;",
          "283:  } else",
          "284:   ext4_error(sb, \"bit already cleared for inode %lu\", ino);",
          "",
          "[Removed Lines]",
          "282:   sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "282:   ext4_mark_super_dirty(sb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "965:  percpu_counter_dec(&sbi->s_freeinodes_counter);",
          "966:  if (S_ISDIR(mode))",
          "967:   percpu_counter_inc(&sbi->s_dirs_counter);",
          "970:  if (sbi->s_log_groups_per_flex) {",
          "971:   flex_group = ext4_flex_group(sbi, group);",
          "",
          "[Removed Lines]",
          "968:  sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "968:  ext4_mark_super_dirty(sb);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "221:          \"couldn't extend journal (err %d)\", err);",
          "222:   stop_handle:",
          "223:    ext4_journal_stop(handle);",
          "224:    goto no_delete;",
          "225:   }",
          "226:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224:    ext4_orphan_del(NULL, inode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "337:  return n;",
          "338: }",
          "341:      __le32 *p, unsigned int max)",
          "342: {",
          "343:  __le32 *bref = p;",
          "344:  unsigned int blk;",
          "",
          "[Removed Lines]",
          "340: static int __ext4_check_blockref(const char *function, struct inode *inode,",
          "",
          "[Added Lines]",
          "341: static int __ext4_check_blockref(const char *function, unsigned int line,",
          "342:      struct inode *inode,",
          "345:  struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "348:   if (blk &&",
          "349:       unlikely(!ext4_data_block_valid(EXT4_SB(inode->i_sb),",
          "350:           blk, 1))) {",
          "353:    return -EIO;",
          "354:   }",
          "355:  }",
          "",
          "[Removed Lines]",
          "351:    ext4_error_inode(function, inode,",
          "352:       \"invalid block reference %u\", blk);",
          "",
          "[Added Lines]",
          "354:    es->s_last_error_block = cpu_to_le64(blk);",
          "355:    ext4_error_inode(inode, function, line, blk,",
          "356:       \"invalid block\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "360: #define ext4_check_indirect_blockref(inode, bh)                         \\",
          "362:          EXT4_ADDR_PER_BLOCK((inode)->i_sb))",
          "364: #define ext4_check_inode_blockref(inode)                                \\",
          "366:          EXT4_NDIR_BLOCKS)",
          "",
          "[Removed Lines]",
          "361:  __ext4_check_blockref(__func__, inode, (__le32 *)(bh)->b_data,  \\",
          "365:  __ext4_check_blockref(__func__, inode, EXT4_I(inode)->i_data,   \\",
          "",
          "[Added Lines]",
          "365:  __ext4_check_blockref(__func__, __LINE__, inode,  \\",
          "366:          (__le32 *)(bh)->b_data,   \\",
          "370:  __ext4_check_blockref(__func__, __LINE__, inode,  \\",
          "371:          EXT4_I(inode)->i_data,   \\",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1128:   ext4_discard_preallocations(inode);",
          "1129: }",
          "1132:     struct ext4_map_blocks *map)",
          "1133: {",
          "1134:  if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,",
          "1135:        map->m_len)) {",
          "1140:   return -EIO;",
          "1141:  }",
          "1142:  return 0;",
          "1143: }",
          "",
          "[Removed Lines]",
          "1131: static int check_block_validity(struct inode *inode, const char *func,",
          "1136:   ext4_error_inode(func, inode,",
          "1137:       \"lblock %lu mapped to illegal pblock %llu \"",
          "1138:       \"(length %d)\", (unsigned long) map->m_lblk,",
          "1139:      map->m_pblk, map->m_len);",
          "",
          "[Added Lines]",
          "1137: static int __check_block_validity(struct inode *inode, const char *func,",
          "1138:     unsigned int line,",
          "1143:   ext4_error_inode(inode, func, line, map->m_pblk,",
          "1144:      \"lblock %lu mapped to illegal pblock \"",
          "1145:      \"(length %d)\", (unsigned long) map->m_lblk,",
          "1146:      map->m_len);",
          "1152: #define check_block_validity(inode, map) \\",
          "1153:  __check_block_validity((inode), __func__, __LINE__, (map))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1244:  up_read((&EXT4_I(inode)->i_data_sem));",
          "1246:  if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {",
          "1248:   if (ret != 0)",
          "1249:    return ret;",
          "1250:  }",
          "",
          "[Removed Lines]",
          "1247:   int ret = check_block_validity(inode, __func__, map);",
          "",
          "[Added Lines]",
          "1257:   int ret = check_block_validity(inode, map);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1325:  up_write((&EXT4_I(inode)->i_data_sem));",
          "1326:  if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {",
          "1330:   if (ret != 0)",
          "1331:    return ret;",
          "1332:  }",
          "",
          "[Removed Lines]",
          "1327:   int ret = check_block_validity(inode,",
          "1328:             \"ext4_map_blocks_after_alloc\",",
          "1329:             map);",
          "",
          "[Added Lines]",
          "1337:   int ret = check_block_validity(inode, map);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1519: static int do_journal_get_write_access(handle_t *handle,",
          "1520:            struct buffer_head *bh)",
          "1521: {",
          "1522:  if (!buffer_mapped(bh) || buffer_freed(bh))",
          "1523:   return 0;",
          "1525: }",
          "",
          "[Removed Lines]",
          "1524:  return ext4_journal_get_write_access(handle, bh);",
          "",
          "[Added Lines]",
          "1530:  int dirty = buffer_dirty(bh);",
          "1531:  int ret;",
          "1543:  if (dirty)",
          "1544:   clear_buffer_dirty(bh);",
          "1545:  ret = ext4_journal_get_write_access(handle, bh);",
          "1546:  if (!ret && dirty)",
          "1547:   ret = ext4_handle_dirty_metadata(handle, NULL, bh);",
          "1548:  return ret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2222:  blks = ext4_map_blocks(handle, mpd->inode, &map, get_blocks_flags);",
          "2223:  if (blks < 0) {",
          "2224:   err = blks;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2248:   struct super_block *sb = mpd->inode->i_sb;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2231:    return 0;",
          "2233:   if (err == -ENOSPC &&",
          "2235:    mpd->retval = err;",
          "2236:    return 0;",
          "2237:   }",
          "",
          "[Removed Lines]",
          "2234:       ext4_count_free_blocks(mpd->inode->i_sb)) {",
          "",
          "[Added Lines]",
          "2260:       ext4_count_free_blocks(sb)) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2256:   }",
          "2258:   ext4_da_block_invalidatepages(mpd, next,",
          "",
          "[Removed Lines]",
          "2246:   ext4_msg(mpd->inode->i_sb, KERN_CRIT,",
          "2247:     \"delayed block allocation failed for inode %lu at \"",
          "2248:     \"logical offset %llu with max blocks %zd with \"",
          "2249:     \"error %d\", mpd->inode->i_ino,",
          "2250:     (unsigned long long) next,",
          "2251:     mpd->b_size >> mpd->inode->i_blkbits, err);",
          "2252:   printk(KERN_CRIT \"This should not happen!!  \"",
          "2253:          \"Data will be lost\\n\");",
          "2254:   if (err == -ENOSPC) {",
          "2255:    ext4_print_free_blocks(mpd->inode);",
          "",
          "[Added Lines]",
          "2272:   if (!(EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)) {",
          "2273:    ext4_msg(sb, KERN_CRIT,",
          "2274:      \"delayed block allocation failed for inode %lu \"",
          "2275:      \"at logical offset %llu with max blocks %zd \"",
          "2276:      \"with error %d\", mpd->inode->i_ino,",
          "2277:      (unsigned long long) next,",
          "2278:      mpd->b_size >> mpd->inode->i_blkbits, err);",
          "2279:    ext4_msg(sb, KERN_CRIT,",
          "2280:     \"This should not happen!! Data will be lost\\n\");",
          "2281:    if (err == -ENOSPC)",
          "2282:     ext4_print_free_blocks(mpd->inode);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2749:   return __ext4_journalled_writepage(page, len);",
          "2750:  }",
          "2755:   ext4_set_bh_endio(page_bufs, inode);",
          "2756:   ret = block_write_full_page_endio(page, noalloc_get_block_write,",
          "2757:          wbc, ext4_end_io_buffer_write);",
          "",
          "[Removed Lines]",
          "2752:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
          "2753:   ret = nobh_writepage(page, noalloc_get_block_write, wbc);",
          "2754:  else if (page_bufs && buffer_uninit(page_bufs)) {",
          "",
          "[Added Lines]",
          "2777:  if (page_bufs && buffer_uninit(page_bufs)) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3146:  int ret, retries = 0;",
          "3147:  struct page *page;",
          "3148:  pgoff_t index;",
          "3150:  struct inode *inode = mapping->host;",
          "3151:  handle_t *handle;",
          "3153:  index = pos >> PAGE_CACHE_SHIFT;",
          "3157:  if (ext4_nonda_switch(inode->i_sb)) {",
          "",
          "[Removed Lines]",
          "3149:  unsigned from, to;",
          "3154:  from = pos & (PAGE_CACHE_SIZE - 1);",
          "3155:  to = from + len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3668:   return ret;",
          "3669:  }",
          "3672:  io->flag = 0;",
          "3673:  return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3691:  if (io->iocb)",
          "3692:   aio_complete(io->iocb, io->result, 0);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3767:   io->offset = 0;",
          "3768:   io->size = 0;",
          "3769:   io->page = NULL;",
          "3770:   INIT_WORK(&io->work, ext4_end_io_work);",
          "3771:   INIT_LIST_HEAD(&io->list);",
          "3772:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3792:   io->iocb = NULL;",
          "3793:   io->result = 0;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3796:  if (io_end->flag != EXT4_IO_UNWRITTEN){",
          "3797:   ext4_free_io_end(io_end);",
          "3798:   iocb->private = NULL;",
          "3800:  }",
          "3802:  io_end->offset = offset;",
          "3803:  io_end->size = size;",
          "3805:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
          "",
          "[Removed Lines]",
          "3799:   goto out;",
          "3804:  io_end->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3823: out:",
          "3824:   if (is_async)",
          "3825:    aio_complete(iocb, ret, 0);",
          "3826:   return;",
          "3831:  if (is_async) {",
          "3832:   io_end->iocb = iocb;",
          "3833:   io_end->result = ret;",
          "3834:  }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3813:  list_add_tail(&io_end->list, &ei->i_completed_io_list);",
          "3814:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
          "3815:  iocb->private = NULL;",
          "3819: }",
          "3821: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)",
          "",
          "[Removed Lines]",
          "3816: out:",
          "3817:  if (is_async)",
          "3818:   aio_complete(iocb, ret, 0);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "4132:  length = blocksize - (offset & (blocksize - 1));",
          "4133:  iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);",
          "4146:  if (!page_has_buffers(page))",
          "4147:   create_empty_buffers(page, blocksize, 0);",
          "",
          "[Removed Lines]",
          "4139:  if (!page_has_buffers(page) && test_opt(inode->i_sb, NOBH) &&",
          "4140:       ext4_should_writeback_data(inode) && PageUptodate(page)) {",
          "4141:   zero_user(page, offset, length);",
          "4142:   set_page_dirty(page);",
          "4143:   goto unlock;",
          "4144:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "4494:    if (!bh) {",
          "4498:     continue;",
          "4499:    }",
          "",
          "[Removed Lines]",
          "4495:     EXT4_ERROR_INODE(inode,",
          "4496:        \"Read failure block=%llu\",",
          "4497:        (unsigned long long) nr);",
          "",
          "[Added Lines]",
          "4511:     EXT4_ERROR_INODE_BLOCK(inode, nr,",
          "4512:              \"Read failure\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4505:      (__le32 *) bh->b_data + addr_per_block,",
          "4506:      depth);",
          "",
          "[Removed Lines]",
          "4527:    ext4_forget(handle, 1, inode, bh, bh->b_blocknr);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4550:          blocks_for_truncate(inode));",
          "4551:    }",
          "4553:    ext4_free_blocks(handle, inode, 0, nr, 1,",
          "4556:    if (parent_bh) {",
          "",
          "[Removed Lines]",
          "4554:       EXT4_FREE_BLOCKS_METADATA);",
          "",
          "[Added Lines]",
          "4559:       EXT4_FREE_BLOCKS_METADATA|",
          "4560:       EXT4_FREE_BLOCKS_FORGET);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4810:  bh = sb_getblk(sb, block);",
          "4811:  if (!bh) {",
          "4814:   return -EIO;",
          "4815:  }",
          "4816:  if (!buffer_uptodate(bh)) {",
          "",
          "[Removed Lines]",
          "4812:   EXT4_ERROR_INODE(inode, \"unable to read inode block - \"",
          "4813:      \"block %llu\", block);",
          "",
          "[Added Lines]",
          "4818:   EXT4_ERROR_INODE_BLOCK(inode, block,",
          "4819:            \"unable to read itable block\");",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "4908:   submit_bh(READ_META, bh);",
          "4909:   wait_on_buffer(bh);",
          "4910:   if (!buffer_uptodate(bh)) {",
          "4913:    brelse(bh);",
          "4914:    return -EIO;",
          "4915:   }",
          "",
          "[Removed Lines]",
          "4911:    EXT4_ERROR_INODE(inode, \"unable to read inode \"",
          "4912:       \"block %llu\", block);",
          "",
          "[Added Lines]",
          "4917:    EXT4_ERROR_INODE_BLOCK(inode, block,",
          "4918:             \"unable to read itable block\");",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4981:   i_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |",
          "4982:      le32_to_cpu(raw_inode->i_blocks_lo);",
          "4985:    return i_blocks  << (inode->i_blkbits - 9);",
          "4986:   } else {",
          "",
          "[Removed Lines]",
          "4983:   if (ei->i_flags & EXT4_HUGE_FILE_FL) {",
          "",
          "[Added Lines]",
          "4989:   if (ext4_test_inode_flag(inode, EXT4_INODE_HUGE_FILE)) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5076:   transaction_t *transaction;",
          "5077:   tid_t tid;",
          "5080:   if (journal->j_running_transaction)",
          "5081:    transaction = journal->j_running_transaction;",
          "5082:   else",
          "",
          "[Removed Lines]",
          "5079:   spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "5085:   read_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "5085:    tid = transaction->t_tid;",
          "5086:   else",
          "5087:    tid = journal->j_commit_sequence;",
          "5089:   ei->i_sync_tid = tid;",
          "5090:   ei->i_datasync_tid = tid;",
          "5091:  }",
          "",
          "[Removed Lines]",
          "5088:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "5094:   read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "5130:      ei->i_file_acl);",
          "5131:   ret = -EIO;",
          "5132:   goto bad_inode;",
          "5134:   if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||",
          "5135:       (S_ISLNK(inode->i_mode) &&",
          "5136:        !ext4_inode_is_fast_symlink(inode)))",
          "",
          "[Removed Lines]",
          "5133:  } else if (ei->i_flags & EXT4_EXTENTS_FL) {",
          "",
          "[Added Lines]",
          "5139:  } else if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "5410:   if (wbc->sync_mode == WB_SYNC_ALL)",
          "5411:    sync_dirty_buffer(iloc.bh);",
          "5412:   if (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {",
          "5416:    err = -EIO;",
          "5417:   }",
          "5418:   brelse(iloc.bh);",
          "",
          "[Removed Lines]",
          "5413:    EXT4_ERROR_INODE(inode,",
          "5414:     \"IO error syncing inode (block=%llu)\",",
          "5415:     (unsigned long long) iloc.bh->b_blocknr);",
          "",
          "[Added Lines]",
          "5419:    EXT4_ERROR_INODE_BLOCK(inode, iloc.bh->b_blocknr,",
          "5420:       \"IO error syncing inode\");",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "5487:   if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {",
          "5488:    struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);",
          "5494:   }",
          "5495:  }",
          "",
          "[Removed Lines]",
          "5490:    if (attr->ia_size > sbi->s_bitmap_maxbytes) {",
          "5491:     error = -EFBIG;",
          "5492:     goto err_out;",
          "5493:    }",
          "",
          "[Added Lines]",
          "5495:    if (attr->ia_size > sbi->s_bitmap_maxbytes)",
          "5496:     return -EFBIG;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "5758: {",
          "5759:  struct ext4_inode *raw_inode;",
          "5760:  struct ext4_xattr_ibody_header *header;",
          "5763:  if (EXT4_I(inode)->i_extra_isize >= new_extra_isize)",
          "5764:   return 0;",
          "",
          "[Removed Lines]",
          "5761:  struct ext4_xattr_entry *entry;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "5766:  raw_inode = ext4_raw_inode(&iloc);",
          "5768:  header = IHDR(inode, raw_inode);",
          "5772:  if (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||",
          "",
          "[Removed Lines]",
          "5769:  entry = IFIRST(header);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/mballoc.c||fs/ext4/mballoc.c": [
          "File: fs/ext4/mballoc.c -> fs/ext4/mballoc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "446:    blocknr = ext4_group_first_block_no(sb, e4b->bd_group);",
          "447:    blocknr += first + i;",
          "448:    ext4_grp_locked_error(sb, e4b->bd_group,",
          "453:   }",
          "454:   mb_clear_bit(first + i, e4b->bd_info->bb_bitmap);",
          "455:  }",
          "",
          "[Removed Lines]",
          "449:        __func__, \"double-free of inode\"",
          "450:        \" %lu's block %llu(bit %u in group %u)\",",
          "451:        inode ? inode->i_ino : 0, blocknr,",
          "452:        first + i, e4b->bd_group);",
          "",
          "[Added Lines]",
          "449:            inode ? inode->i_ino : 0,",
          "450:            blocknr,",
          "451:            \"freeing block already freed \"",
          "452:            \"(bit %u)\",",
          "453:            first + i);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "712:  grp->bb_fragments = fragments;",
          "714:  if (free != grp->bb_free) {",
          "",
          "[Removed Lines]",
          "715:   ext4_grp_locked_error(sb, group,  __func__,",
          "716:    \"EXT4-fs: group %u: %u blocks in bitmap, %u in gd\",",
          "717:    group, free, grp->bb_free);",
          "",
          "[Added Lines]",
          "716:   ext4_grp_locked_error(sb, group, 0, 0,",
          "717:           \"%u blocks in bitmap, %u in gd\",",
          "718:           free, grp->bb_free);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1296:    blocknr = ext4_group_first_block_no(sb, e4b->bd_group);",
          "1297:    blocknr += block;",
          "1298:    ext4_grp_locked_error(sb, e4b->bd_group,",
          "1303:   }",
          "1304:   mb_clear_bit(block, EXT4_MB_BITMAP(e4b));",
          "1305:   e4b->bd_info->bb_counters[order]++;",
          "",
          "[Removed Lines]",
          "1299:        __func__, \"double-free of inode\"",
          "1300:        \" %lu's block %llu(bit %u in group %u)\",",
          "1301:        inode ? inode->i_ino : 0, blocknr, block,",
          "1302:        e4b->bd_group);",
          "",
          "[Added Lines]",
          "1300:            inode ? inode->i_ino : 0,",
          "1301:            blocknr,",
          "1302:            \"freeing already freed block \"",
          "1303:            \"(bit %u)\", block);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1793:      \"group info. But bitmap says 0\",",
          "1794:      free);",
          "1795:    break;",
          "",
          "[Removed Lines]",
          "1791:    ext4_grp_locked_error(sb, e4b->bd_group,",
          "1792:      __func__, \"%d free blocks as per \"",
          "",
          "[Added Lines]",
          "1792:    ext4_grp_locked_error(sb, e4b->bd_group, 0, 0,",
          "1793:      \"%d free blocks as per \"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1798:   mb_find_extent(e4b, 0, i, ac->ac_g_ex.fe_len, &ex);",
          "1799:   BUG_ON(ex.fe_len <= 0);",
          "1800:   if (free < ex.fe_len) {",
          "1803:      \"group info. But got %d blocks\",",
          "1804:      free, ex.fe_len);",
          "",
          "[Removed Lines]",
          "1801:    ext4_grp_locked_error(sb, e4b->bd_group,",
          "1802:      __func__, \"%d free blocks as per \"",
          "",
          "[Added Lines]",
          "1802:    ext4_grp_locked_error(sb, e4b->bd_group, 0, 0,",
          "1803:      \"%d free blocks as per \"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1999:  ext4_group_t ngroups, group, i;",
          "2000:  int cr;",
          "2001:  int err = 0;",
          "2003:  struct ext4_sb_info *sbi;",
          "2004:  struct super_block *sb;",
          "2005:  struct ext4_buddy e4b;",
          "",
          "[Removed Lines]",
          "2002:  int bsbits;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2041:    ac->ac_2order = i - 1;",
          "2042:  }",
          "2047:  if (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {",
          "",
          "[Removed Lines]",
          "2044:  bsbits = ac->ac_sb->s_blocksize_bits;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2094:    ac->ac_groups_scanned++;",
          "2095:    if (cr == 0)",
          "2096:     ext4_mb_simple_scan_group(ac, &e4b);",
          "2099:     ext4_mb_scan_aligned(ac, &e4b);",
          "2100:    else",
          "2101:     ext4_mb_complex_scan_group(ac, &e4b);",
          "",
          "[Removed Lines]",
          "2097:    else if (cr == 1 &&",
          "2098:      ac->ac_g_ex.fe_len == sbi->s_stripe)",
          "",
          "[Added Lines]",
          "2094:    else if (cr == 1 && sbi->s_stripe &&",
          "2095:      !(ac->ac_g_ex.fe_len % sbi->s_stripe))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2222:  rc = seq_open(file, &ext4_mb_seq_groups_ops);",
          "2223:  if (rc == 0) {",
          "2225:   m->private = sb;",
          "2226:  }",
          "2227:  return rc;",
          "",
          "[Removed Lines]",
          "2224:   struct seq_file *m = (struct seq_file *)file->private_data;",
          "",
          "[Added Lines]",
          "2221:   struct seq_file *m = file->private_data;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2560:  return 0;",
          "2561: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2560: static inline void ext4_issue_discard(struct super_block *sb,",
          "2561:   ext4_group_t block_group, ext4_grpblk_t block, int count)",
          "2562: {",
          "2563:  int ret;",
          "2564:  ext4_fsblk_t discard_block;",
          "2566:  discard_block = block + ext4_group_first_block_no(sb, block_group);",
          "2567:  trace_ext4_discard_blocks(sb,",
          "2568:    (unsigned long long) discard_block, count);",
          "2569:  ret = sb_issue_discard(sb, discard_block, count);",
          "2570:  if (ret == EOPNOTSUPP) {",
          "2571:   ext4_warning(sb, \"discard not supported, disabling\");",
          "2572:   clear_opt(EXT4_SB(sb)->s_mount_opt, DISCARD);",
          "2573:  }",
          "2574: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2579:   mb_debug(1, \"gonna free %u blocks in group %u (0x%p):\",",
          "2580:     entry->count, entry->group, entry);",
          "2599:   err = ext4_mb_load_buddy(sb, entry->group, &e4b);",
          "",
          "[Removed Lines]",
          "2582:   if (test_opt(sb, DISCARD)) {",
          "2583:    int ret;",
          "2584:    ext4_fsblk_t discard_block;",
          "2586:    discard_block = entry->start_blk +",
          "2587:     ext4_group_first_block_no(sb, entry->group);",
          "2588:    trace_ext4_discard_blocks(sb,",
          "2589:      (unsigned long long)discard_block,",
          "2590:      entry->count);",
          "2591:    ret = sb_issue_discard(sb, discard_block, entry->count);",
          "2592:    if (ret == EOPNOTSUPP) {",
          "2593:     ext4_warning(sb,",
          "2594:      \"discard not supported, disabling\");",
          "2595:     clear_opt(EXT4_SB(sb)->s_mount_opt, DISCARD);",
          "2596:    }",
          "2597:   }",
          "",
          "[Added Lines]",
          "2595:   if (test_opt(sb, DISCARD))",
          "2596:    ext4_issue_discard(sb, entry->group,",
          "2597:      entry->start_blk, entry->count);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2712:     handle_t *handle, unsigned int reserv_blks)",
          "2713: {",
          "2714:  struct buffer_head *bitmap_bh = NULL;",
          "2716:  struct ext4_group_desc *gdp;",
          "2717:  struct buffer_head *gdp_bh;",
          "2718:  struct ext4_sb_info *sbi;",
          "",
          "[Removed Lines]",
          "2715:  struct ext4_super_block *es;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2726:  sb = ac->ac_sb;",
          "2727:  sbi = EXT4_SB(sb);",
          "2731:  err = -EIO;",
          "2732:  bitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);",
          "",
          "[Removed Lines]",
          "2728:  es = sbi->s_es;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2812:  err = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);",
          "2814: out_err:",
          "2816:  brelse(bitmap_bh);",
          "2817:  return err;",
          "2818: }",
          "",
          "[Removed Lines]",
          "2815:  sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "2812:  ext4_mark_super_dirty(sb);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2850:  int bsbits, max;",
          "2851:  ext4_lblk_t end;",
          "2852:  loff_t size, orig_size, start_off;",
          "2854:  struct ext4_inode_info *ei = EXT4_I(ac->ac_inode);",
          "2855:  struct ext4_prealloc_space *pa;",
          "",
          "[Removed Lines]",
          "2853:  ext4_lblk_t start, orig_start;",
          "",
          "[Added Lines]",
          "2850:  ext4_lblk_t start;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2881:  size = size << bsbits;",
          "2882:  if (size < i_size_read(ac->ac_inode))",
          "2883:   size = i_size_read(ac->ac_inode);",
          "2886:  max = 2 << bsbits;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2881:  orig_size = size;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2922:   start_off = (loff_t)ac->ac_o_ex.fe_logical << bsbits;",
          "2923:   size   = ac->ac_o_ex.fe_len << bsbits;",
          "2924:  }",
          "2929:  if (ar->pleft && start <= ar->lleft) {",
          "",
          "[Removed Lines]",
          "2925:  orig_size = size = size >> bsbits;",
          "2926:  orig_start = start = start_off >> bsbits;",
          "",
          "[Added Lines]",
          "2923:  size = size >> bsbits;",
          "2924:  start = start_off >> bsbits;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3547:  ext4_group_t group;",
          "3548:  ext4_grpblk_t bit;",
          "3549:  unsigned long long grp_blk_start;",
          "3551:  int err = 0;",
          "3552:  int free = 0;",
          "",
          "[Removed Lines]",
          "3550:  sector_t start;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3567:   if (bit >= end)",
          "3568:    break;",
          "3569:   next = mb_find_next_bit(bitmap_bh->b_data, end, bit);",
          "3571:   mb_debug(1, \"    free preallocated %u/%u in group %u\\n\",",
          "3574:   free += next - bit;",
          "3576:   if (ac) {",
          "",
          "[Removed Lines]",
          "3570:   start = ext4_group_first_block_no(sb, group) + bit;",
          "3572:     (unsigned) start, (unsigned) next - bit,",
          "3573:     (unsigned) group);",
          "",
          "[Added Lines]",
          "3568:     (unsigned) ext4_group_first_block_no(sb, group) + bit,",
          "3569:     (unsigned) next - bit, (unsigned) group);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3581:    trace_ext4_mballoc_discard(ac);",
          "3582:   }",
          "3585:             next - bit);",
          "3586:   mb_free_blocks(pa->pa_inode, e4b, bit, next - bit);",
          "3587:   bit = next + 1;",
          "",
          "[Removed Lines]",
          "3584:   trace_ext4_mb_release_inode_pa(ac, pa, grp_blk_start + bit,",
          "",
          "[Added Lines]",
          "3580:   trace_ext4_mb_release_inode_pa(sb, ac, pa, grp_blk_start + bit,",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3591:    pa, (unsigned long) pa->pa_lstart,",
          "3592:    (unsigned long) pa->pa_pstart,",
          "3593:    (unsigned long) pa->pa_len);",
          "3596:      free, pa->pa_free);",
          "",
          "[Removed Lines]",
          "3594:   ext4_grp_locked_error(sb, group,",
          "3595:      __func__, \"free %u, pa_free %u\",",
          "",
          "[Added Lines]",
          "3590:   ext4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3613:  ext4_group_t group;",
          "3614:  ext4_grpblk_t bit;",
          "3617:  BUG_ON(pa->pa_deleted == 0);",
          "3618:  ext4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);",
          "3619:  BUG_ON(group != e4b->bd_group && pa->pa_len != 0);",
          "",
          "[Removed Lines]",
          "3616:  trace_ext4_mb_release_group_pa(ac, pa);",
          "",
          "[Added Lines]",
          "3611:  trace_ext4_mb_release_group_pa(sb, ac, pa);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3889:  struct super_block *sb = ac->ac_sb;",
          "3890:  ext4_group_t ngroups, i;",
          "3892:  printk(KERN_ERR \"EXT4-fs: Can't allocate:\"",
          "3893:    \" Allocation context details:\\n\");",
          "3894:  printk(KERN_ERR \"EXT4-fs: status %d flags %d\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3887:  if (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)",
          "3888:   return;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4257: ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,",
          "4259: {",
          "4260:  int freed;",
          "4261:  struct ext4_allocation_context *ac = NULL;",
          "",
          "[Removed Lines]",
          "4258:      struct ext4_allocation_request *ar, int *errp)",
          "",
          "[Added Lines]",
          "4256:     struct ext4_allocation_request *ar, int *errp)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "4299:   inquota = ar->len;",
          "4300:   if (ar->len == 0) {",
          "4303:   }",
          "4304:  }",
          "",
          "[Removed Lines]",
          "4302:    goto out3;",
          "",
          "[Added Lines]",
          "4300:    goto out;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "4307:  if (!ac) {",
          "4308:   ar->len = 0;",
          "4311:  }",
          "4314:  if (*errp) {",
          "4315:   ar->len = 0;",
          "4317:  }",
          "4319:  ac->ac_op = EXT4_MB_HISTORY_PREALLOC;",
          "",
          "[Removed Lines]",
          "4310:   goto out1;",
          "4316:   goto out2;",
          "",
          "[Added Lines]",
          "4308:   goto out;",
          "4314:   goto out;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "4322:   ext4_mb_normalize_request(ac, ar);",
          "4323: repeat:",
          "",
          "[Removed Lines]",
          "4325:   ext4_mb_regular_allocator(ac);",
          "",
          "[Added Lines]",
          "4324:   if (*errp)",
          "4325:    goto errout;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "4333:  }",
          "4334:  if (likely(ac->ac_status == AC_STATUS_FOUND)) {",
          "",
          "[Removed Lines]",
          "4336:   if (*errp ==  -EAGAIN) {",
          "",
          "[Added Lines]",
          "4336:   if (*errp == -EAGAIN) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "4344:    ac->ac_b_ex.fe_len = 0;",
          "4345:    ac->ac_status = AC_STATUS_CONTINUE;",
          "4346:    goto repeat;",
          "4348:    ext4_discard_allocated_blocks(ac);",
          "4353:    block = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);",
          "4354:    ar->len = ac->ac_b_ex.fe_len;",
          "4355:   }",
          "",
          "[Removed Lines]",
          "4347:   } else if (*errp) {",
          "4349:    ac->ac_b_ex.fe_len = 0;",
          "4350:    ar->len = 0;",
          "4351:    ext4_mb_show_ac(ac);",
          "4352:   } else {",
          "",
          "[Added Lines]",
          "4347:   } else if (*errp)",
          "4348:   errout:",
          "4350:   else {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "4358:   if (freed)",
          "4359:    goto repeat;",
          "4361:   ac->ac_b_ex.fe_len = 0;",
          "4362:   ar->len = 0;",
          "4363:   ext4_mb_show_ac(ac);",
          "4364:  }",
          "4366:  ext4_mb_release_context(ac);",
          "4371:  if (inquota && ar->len < inquota)",
          "4372:   dquot_free_block(ar->inode, inquota - ar->len);",
          "4374:  if (!ar->len) {",
          "4375:   if (!EXT4_I(ar->inode)->i_delalloc_reserved_flag)",
          "",
          "[Removed Lines]",
          "4368: out2:",
          "4369:  kmem_cache_free(ext4_ac_cachep, ac);",
          "4370: out1:",
          "4373: out3:",
          "",
          "[Added Lines]",
          "4359:  }",
          "4361:  if (*errp) {",
          "4367: out:",
          "4368:  if (ac)",
          "4369:   kmem_cache_free(ext4_ac_cachep, ac);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "4402: ext4_mb_free_metadata(handle_t *handle, struct ext4_buddy *e4b,",
          "4403:         struct ext4_free_data *new_entry)",
          "4404: {",
          "4405:  ext4_grpblk_t block;",
          "4406:  struct ext4_free_data *entry;",
          "4407:  struct ext4_group_info *db = e4b->bd_info;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4403:  ext4_group_t group = e4b->bd_group;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "4434:   else if (block >= (entry->start_blk + entry->count))",
          "4435:    n = &(*n)->rb_right;",
          "4436:   else {",
          "4440:    return 0;",
          "4441:   }",
          "4442:  }",
          "",
          "[Removed Lines]",
          "4437:    ext4_grp_locked_error(sb, e4b->bd_group, __func__,",
          "4438:      \"Double free of blocks %d (%d %d)\",",
          "4439:      block, entry->start_blk, entry->count);",
          "",
          "[Added Lines]",
          "4436:    ext4_grp_locked_error(sb, group, 0,",
          "4437:     ext4_group_first_block_no(sb, group) + block,",
          "4438:     \"Block already on to-be-freed list\");",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "4494:  struct super_block *sb = inode->i_sb;",
          "4495:  struct ext4_allocation_context *ac = NULL;",
          "4496:  struct ext4_group_desc *gdp;",
          "4498:  unsigned long freed = 0;",
          "4499:  unsigned int overflow;",
          "4500:  ext4_grpblk_t bit;",
          "",
          "[Removed Lines]",
          "4497:  struct ext4_super_block *es;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "4513:  }",
          "4515:  sbi = EXT4_SB(sb);",
          "4517:  if (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&",
          "4518:      !ext4_data_block_valid(sbi, block, count)) {",
          "4519:   ext4_error(sb, \"Freeing blocks not in datazone - \"",
          "",
          "[Removed Lines]",
          "4516:  es = EXT4_SB(sb)->s_es;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "4647:   mb_clear_bits(bitmap_bh->b_data, bit, count);",
          "4648:   mb_free_blocks(inode, &e4b, bit, count);",
          "4649:   ext4_mb_return_to_preallocation(inode, &e4b, block, count);",
          "4650:  }",
          "4652:  ret = ext4_free_blks_count(sb, gdp) + count;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4647:   if (test_opt(sb, DISCARD))",
          "4648:    ext4_issue_discard(sb, block_group, bit, count);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "4680:   put_bh(bitmap_bh);",
          "4681:   goto do_more;",
          "4682:  }",
          "4684: error_return:",
          "4685:  if (freed)",
          "4686:   dquot_free_block(inode, freed);",
          "",
          "[Removed Lines]",
          "4683:  sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "4682:  ext4_mark_super_dirty(sb);",
          "",
          "---------------"
        ],
        "fs/ext4/migrate.c||fs/ext4/migrate.c": [
          "File: fs/ext4/migrate.c -> fs/ext4/migrate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "380:  memcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));",
          "",
          "[Removed Lines]",
          "379:  ei->i_flags |= EXT4_EXTENTS_FL;",
          "",
          "[Added Lines]",
          "379:  ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS);",
          "",
          "---------------"
        ],
        "fs/ext4/move_extent.c||fs/ext4/move_extent.c": [
          "File: fs/ext4/move_extent.c -> fs/ext4/move_extent.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "149: static int",
          "150: mext_check_null_inode(struct inode *inode1, struct inode *inode2,",
          "152: {",
          "153:  int ret = 0;",
          "155:  if (inode1 == NULL) {",
          "157:    \"Both inodes should not be NULL: \"",
          "158:    \"inode1 NULL inode2 %lu\", inode2->i_ino);",
          "159:   ret = -EIO;",
          "160:  } else if (inode2 == NULL) {",
          "162:    \"Both inodes should not be NULL: \"",
          "163:    \"inode1 %lu inode2 NULL\", inode1->i_ino);",
          "164:   ret = -EIO;",
          "",
          "[Removed Lines]",
          "151:   const char *function)",
          "156:   __ext4_error(inode2->i_sb, function,",
          "161:   __ext4_error(inode1->i_sb, function,",
          "",
          "[Added Lines]",
          "151:         const char *function, unsigned int line)",
          "156:   __ext4_error(inode2->i_sb, function, line,",
          "161:   __ext4_error(inode1->i_sb, function, line,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1085:  BUG_ON(inode1 == NULL && inode2 == NULL);",
          "1088:  if (ret < 0)",
          "1089:   goto out;",
          "",
          "[Removed Lines]",
          "1087:  ret = mext_check_null_inode(inode1, inode2, __func__);",
          "",
          "[Added Lines]",
          "1087:  ret = mext_check_null_inode(inode1, inode2, __func__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1122:  BUG_ON(inode1 == NULL && inode2 == NULL);",
          "1125:  if (ret < 0)",
          "1126:   goto out;",
          "",
          "[Removed Lines]",
          "1124:  ret = mext_check_null_inode(inode1, inode2, __func__);",
          "",
          "[Added Lines]",
          "1124:  ret = mext_check_null_inode(inode1, inode2, __func__, __LINE__);",
          "",
          "---------------"
        ],
        "fs/ext4/namei.c||fs/ext4/namei.c": [
          "File: fs/ext4/namei.c -> fs/ext4/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "179: static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,",
          "180:         struct inode *inode);",
          "",
          "[Removed Lines]",
          "182: unsigned int ext4_rec_len_from_disk(__le16 dlen, unsigned blocksize)",
          "183: {",
          "184:  unsigned len = le16_to_cpu(dlen);",
          "186:  if (len == EXT4_MAX_REC_LEN || len == 0)",
          "187:   return blocksize;",
          "188:  return (len & 65532) | ((len & 3) << 16);",
          "189: }",
          "191: __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)",
          "192: {",
          "193:  if ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))",
          "194:   BUG();",
          "195:  if (len < 65536)",
          "196:   return cpu_to_le16(len);",
          "197:  if (len == blocksize) {",
          "198:   if (blocksize == 65536)",
          "199:    return cpu_to_le16(EXT4_MAX_REC_LEN);",
          "200:   else",
          "201:    return cpu_to_le16(0);",
          "202:  }",
          "203:  return cpu_to_le16((len & 65532) | ((len >> 16) & 3));",
          "204: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "605:         dir->i_sb->s_blocksize -",
          "606:         EXT4_DIR_REC_LEN(0));",
          "607:  for (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {",
          "609:      (block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))",
          "610:       +((char *)de - bh->b_data))) {",
          "",
          "[Removed Lines]",
          "608:   if (!ext4_check_dir_entry(\"htree_dirblock_to_tree\", dir, de, bh,",
          "",
          "[Added Lines]",
          "584:   if (!ext4_check_dir_entry(dir, de, bh,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "844:   if ((char *) de + namelen <= dlimit &&",
          "845:       ext4_match (namelen, name, de)) {",
          "849:     return -1;",
          "851:    return 1;",
          "",
          "[Removed Lines]",
          "847:    if (!ext4_check_dir_entry(\"ext4_find_entry\",",
          "848:         dir, de, bh, offset))",
          "",
          "[Added Lines]",
          "823:    if (!ext4_check_dir_entry(dir, de, bh, offset))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1019:    int off = (block << EXT4_BLOCK_SIZE_BITS(sb))",
          "1020:       + ((char *) de - bh->b_data);",
          "1023:     brelse(bh);",
          "1025:     goto errout;",
          "",
          "[Removed Lines]",
          "1022:    if (!ext4_check_dir_entry(__func__, dir, de, bh, off)) {",
          "",
          "[Added Lines]",
          "997:    if (!ext4_check_dir_entry(dir, de, bh, off)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1088: struct dentry *ext4_get_parent(struct dentry *child)",
          "1089: {",
          "1090:  __u32 ino;",
          "1092:  static const struct qstr dotdot = {",
          "1093:   .name = \"..\",",
          "1094:   .len = 2,",
          "",
          "[Removed Lines]",
          "1091:  struct inode *inode;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1097:  struct buffer_head *bh;",
          "1099:  bh = ext4_find_entry(child->d_inode, &dotdot, &de);",
          "1101:  if (!bh)",
          "1102:   return ERR_PTR(-ENOENT);",
          "1103:  ino = le32_to_cpu(de->inode);",
          "",
          "[Removed Lines]",
          "1100:  inode = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1305:   de = (struct ext4_dir_entry_2 *)bh->b_data;",
          "1306:   top = bh->b_data + blocksize - reclen;",
          "1307:   while ((char *) de <= top) {",
          "1310:     return -EIO;",
          "1311:    if (ext4_match(namelen, name, de))",
          "1312:     return -EEXIST;",
          "",
          "[Removed Lines]",
          "1308:    if (!ext4_check_dir_entry(\"ext4_add_entry\", dir, de,",
          "1309:         bh, offset))",
          "",
          "[Added Lines]",
          "1281:    if (!ext4_check_dir_entry(dir, de, bh, offset))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1673:  pde = NULL;",
          "1674:  de = (struct ext4_dir_entry_2 *) bh->b_data;",
          "1675:  while (i < bh->b_size) {",
          "1677:    return -EIO;",
          "1678:   if (de == de_del)  {",
          "1679:    BUFFER_TRACE(bh, \"get_write_access\");",
          "",
          "[Removed Lines]",
          "1676:   if (!ext4_check_dir_entry(\"ext4_delete_entry\", dir, de, bh, i))",
          "",
          "[Added Lines]",
          "1648:   if (!ext4_check_dir_entry(dir, de, bh, i))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1956:    }",
          "1957:    de = (struct ext4_dir_entry_2 *) bh->b_data;",
          "1958:   }",
          "1960:    de = (struct ext4_dir_entry_2 *)(bh->b_data +",
          "1961:         sb->s_blocksize);",
          "1962:    offset = (offset | (sb->s_blocksize - 1)) + 1;",
          "",
          "[Removed Lines]",
          "1959:   if (!ext4_check_dir_entry(\"empty_dir\", inode, de, bh, offset)) {",
          "",
          "[Added Lines]",
          "1931:   if (!ext4_check_dir_entry(inode, de, bh, offset)) {",
          "",
          "---------------"
        ],
        "fs/ext4/resize.c||fs/ext4/resize.c": [
          "File: fs/ext4/resize.c -> fs/ext4/resize.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "921:       &sbi->s_flex_groups[flex_group].free_inodes);",
          "922:  }",
          "927: exit_journal:",
          "928:  mutex_unlock(&sbi->s_resize_lock);",
          "",
          "[Removed Lines]",
          "924:  ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);",
          "925:  sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "924:  ext4_handle_dirty_super(handle, sb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "953:         ext4_fsblk_t n_blocks_count)",
          "954: {",
          "955:  ext4_fsblk_t o_blocks_count;",
          "957:  ext4_grpblk_t last;",
          "958:  ext4_grpblk_t add;",
          "959:  struct buffer_head *bh;",
          "",
          "[Removed Lines]",
          "956:  ext4_group_t o_groups_count;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "967:  o_blocks_count = ext4_blocks_count(es);",
          "970:  if (test_opt(sb, DEBUG))",
          "971:   printk(KERN_DEBUG \"EXT4-fs: extending last group from %llu uto %llu blocks\\n\",",
          "",
          "[Removed Lines]",
          "968:  o_groups_count = EXT4_SB(sb)->s_groups_count;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1045:   goto exit_put;",
          "1046:  }",
          "1047:  ext4_blocks_count_set(es, o_blocks_count + add);",
          "1050:  mutex_unlock(&EXT4_SB(sb)->s_resize_lock);",
          "1051:  ext4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,",
          "1052:      o_blocks_count + add);",
          "1054:  ext4_add_groupblocks(handle, sb, o_blocks_count, add);",
          "1055:  ext4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,",
          "1056:      o_blocks_count + add);",
          "1057:  if ((err = ext4_journal_stop(handle)))",
          "",
          "[Removed Lines]",
          "1048:  ext4_handle_dirty_metadata(handle, NULL, EXT4_SB(sb)->s_sbh);",
          "1049:  sb->s_dirt = 1;",
          "",
          "[Added Lines]",
          "1050:  ext4_handle_dirty_super(handle, sb);",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:  if (sb->s_flags & MS_RDONLY)",
          "242:   return ERR_PTR(-EROFS);",
          "248:  journal = EXT4_SB(sb)->s_journal;",
          "249:  if (journal) {",
          "250:   if (is_journal_aborted(journal)) {",
          "252:    return ERR_PTR(-EROFS);",
          "253:   }",
          "254:   return jbd2_journal_start(journal, nblocks);",
          "",
          "[Removed Lines]",
          "244:  vfs_check_frozen(sb, SB_FREEZE_WRITE);",
          "251:    ext4_abort(sb, __func__, \"Detected aborted journal\");",
          "",
          "[Added Lines]",
          "244:  vfs_check_frozen(sb, SB_FREEZE_TRANS);",
          "251:    ext4_abort(sb, \"Detected aborted journal\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "266: {",
          "267:  struct super_block *sb;",
          "268:  int err;",
          "",
          "[Removed Lines]",
          "265: int __ext4_journal_stop(const char *where, handle_t *handle)",
          "",
          "[Added Lines]",
          "265: int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "279:  if (!err)",
          "280:   err = rc;",
          "281:  if (err)",
          "283:  return err;",
          "284: }",
          "288: {",
          "289:  char nbuf[16];",
          "290:  const char *errstr = ext4_decode_error(NULL, err, nbuf);",
          "",
          "[Removed Lines]",
          "282:   __ext4_std_error(sb, where, err);",
          "286: void ext4_journal_abort_handle(const char *caller, const char *err_fn,",
          "287:   struct buffer_head *bh, handle_t *handle, int err)",
          "",
          "[Added Lines]",
          "282:   __ext4_std_error(sb, where, line, err);",
          "286: void ext4_journal_abort_handle(const char *caller, unsigned int line,",
          "287:           const char *err_fn, struct buffer_head *bh,",
          "288:           handle_t *handle, int err)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "300:  if (is_handle_aborted(handle))",
          "301:   return;",
          "306:  jbd2_journal_abort_handle(handle);",
          "307: }",
          "",
          "[Removed Lines]",
          "303:  printk(KERN_ERR \"%s: aborting transaction: %s in %s\\n\",",
          "304:         caller, errstr, err_fn);",
          "",
          "[Added Lines]",
          "304:  printk(KERN_ERR \"%s:%d: aborting transaction: %s in %s\\n\",",
          "305:         caller, line, errstr, err_fn);",
          "310: static void __save_error_info(struct super_block *sb, const char *func,",
          "311:        unsigned int line)",
          "312: {",
          "313:  struct ext4_super_block *es = EXT4_SB(sb)->s_es;",
          "315:  EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;",
          "316:  es->s_state |= cpu_to_le16(EXT4_ERROR_FS);",
          "317:  es->s_last_error_time = cpu_to_le32(get_seconds());",
          "318:  strncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));",
          "319:  es->s_last_error_line = cpu_to_le32(line);",
          "320:  if (!es->s_first_error_time) {",
          "321:   es->s_first_error_time = es->s_last_error_time;",
          "322:   strncpy(es->s_first_error_func, func,",
          "323:    sizeof(es->s_first_error_func));",
          "324:   es->s_first_error_line = cpu_to_le32(line);",
          "325:   es->s_first_error_ino = es->s_last_error_ino;",
          "326:   es->s_first_error_block = es->s_last_error_block;",
          "327:  }",
          "332:  if (!es->s_error_count)",
          "333:   mod_timer(&EXT4_SB(sb)->s_err_report, jiffies + 24*60*60*HZ);",
          "334:  es->s_error_count = cpu_to_le32(le32_to_cpu(es->s_error_count) + 1);",
          "335: }",
          "337: static void save_error_info(struct super_block *sb, const char *func,",
          "338:        unsigned int line)",
          "339: {",
          "340:  __save_error_info(sb, func, line);",
          "341:  ext4_commit_super(sb, 1);",
          "342: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "324: static void ext4_handle_error(struct super_block *sb)",
          "325: {",
          "331:  if (sb->s_flags & MS_RDONLY)",
          "332:   return;",
          "",
          "[Removed Lines]",
          "326:  struct ext4_super_block *es = EXT4_SB(sb)->s_es;",
          "328:  EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;",
          "329:  es->s_state |= cpu_to_le16(EXT4_ERROR_FS);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "342:   ext4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");",
          "343:   sb->s_flags |= MS_RDONLY;",
          "344:  }",
          "346:  if (test_opt(sb, ERRORS_PANIC))",
          "347:   panic(\"EXT4-fs (device %s): panic forced after error\\n\",",
          "348:    sb->s_id);",
          "349: }",
          "351: void __ext4_error(struct super_block *sb, const char *function,",
          "353: {",
          "354:  va_list args;",
          "356:  va_start(args, fmt);",
          "358:  vprintk(fmt, args);",
          "359:  printk(\"\\n\");",
          "360:  va_end(args);",
          "",
          "[Removed Lines]",
          "345:  ext4_commit_super(sb, 1);",
          "352:   const char *fmt, ...)",
          "357:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s: \", sb->s_id, function);",
          "",
          "[Added Lines]",
          "382:     unsigned int line, const char *fmt, ...)",
          "387:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: comm %s: \",",
          "388:         sb->s_id, function, line, current->comm);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "362:  ext4_handle_error(sb);",
          "363: }",
          "366:         const char *fmt, ...)",
          "367: {",
          "368:  va_list args;",
          "370:  va_start(args, fmt);",
          "373:  vprintk(fmt, args);",
          "374:  printk(\"\\n\");",
          "375:  va_end(args);",
          "",
          "[Removed Lines]",
          "365: void ext4_error_inode(const char *function, struct inode *inode,",
          "371:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s: inode #%lu: (comm %s) \",",
          "372:         inode->i_sb->s_id, function, inode->i_ino, current->comm);",
          "",
          "[Added Lines]",
          "396: void ext4_error_inode(struct inode *inode, const char *function,",
          "397:         unsigned int line, ext4_fsblk_t block,",
          "401:  struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;",
          "403:  es->s_last_error_ino = cpu_to_le32(inode->i_ino);",
          "404:  es->s_last_error_block = cpu_to_le64(block);",
          "405:  save_error_info(inode->i_sb, function, line);",
          "407:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: inode #%lu: \",",
          "408:         inode->i_sb->s_id, function, line, inode->i_ino);",
          "409:  if (block)",
          "410:   printk(\"block %llu: \", block);",
          "411:  printk(\"comm %s: \", current->comm);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "377:  ext4_handle_error(inode->i_sb);",
          "378: }",
          "382: {",
          "383:  va_list args;",
          "384:  struct inode *inode = file->f_dentry->d_inode;",
          "385:  char pathname[80], *path;",
          "387:  va_start(args, fmt);",
          "388:  path = d_path(&(file->f_path), pathname, sizeof(pathname));",
          "389:  if (!path)",
          "390:   path = \"(unknown)\";",
          "391:  printk(KERN_CRIT",
          "394:  vprintk(fmt, args);",
          "395:  printk(\"\\n\");",
          "396:  va_end(args);",
          "",
          "[Removed Lines]",
          "380: void ext4_error_file(const char *function, struct file *file,",
          "381:        const char *fmt, ...)",
          "392:         \"EXT4-fs error (device %s): %s: inode #%lu (comm %s path %s): \",",
          "393:         inode->i_sb->s_id, function, inode->i_ino, current->comm, path);",
          "",
          "[Added Lines]",
          "419: void ext4_error_file(struct file *file, const char *function,",
          "420:        unsigned int line, const char *fmt, ...)",
          "423:  struct ext4_super_block *es;",
          "427:  es = EXT4_SB(inode->i_sb)->s_es;",
          "428:  es->s_last_error_ino = cpu_to_le32(inode->i_ino);",
          "429:  save_error_info(inode->i_sb, function, line);",
          "435:         \"EXT4-fs error (device %s): %s:%d: inode #%lu \"",
          "436:         \"(comm %s path %s): \",",
          "437:         inode->i_sb->s_id, function, line, inode->i_ino,",
          "438:         current->comm, path);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "439: {",
          "440:  char nbuf[16];",
          "441:  const char *errstr;",
          "",
          "[Removed Lines]",
          "438: void __ext4_std_error(struct super_block *sb, const char *function, int errno)",
          "",
          "[Added Lines]",
          "483: void __ext4_std_error(struct super_block *sb, const char *function,",
          "484:         unsigned int line, int errno)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "448:   return;",
          "450:  errstr = ext4_decode_error(sb, errno, nbuf);",
          "454:  ext4_handle_error(sb);",
          "455: }",
          "",
          "[Removed Lines]",
          "451:  printk(KERN_CRIT \"EXT4-fs error (device %s) in %s: %s\\n\",",
          "452:         sb->s_id, function, errstr);",
          "",
          "[Added Lines]",
          "497:  printk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",",
          "498:         sb->s_id, function, line, errstr);",
          "499:  save_error_info(sb, function, line);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "469: {",
          "470:  va_list args;",
          "472:  va_start(args, fmt);",
          "474:  vprintk(fmt, args);",
          "475:  printk(\"\\n\");",
          "476:  va_end(args);",
          "478:  if (test_opt(sb, ERRORS_PANIC))",
          "479:   panic(\"EXT4-fs panic from previous error\\n\");",
          "490: }",
          "492: void ext4_msg (struct super_block * sb, const char *prefix,",
          "",
          "[Removed Lines]",
          "467: void ext4_abort(struct super_block *sb, const char *function,",
          "468:   const char *fmt, ...)",
          "473:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s: \", sb->s_id, function);",
          "481:  if (sb->s_flags & MS_RDONLY)",
          "482:   return;",
          "484:  ext4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");",
          "485:  EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;",
          "486:  sb->s_flags |= MS_RDONLY;",
          "487:  EXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;",
          "488:  if (EXT4_SB(sb)->s_journal)",
          "489:   jbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);",
          "",
          "[Added Lines]",
          "514: void __ext4_abort(struct super_block *sb, const char *function,",
          "515:   unsigned int line, const char *fmt, ...)",
          "519:  save_error_info(sb, function, line);",
          "521:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \", sb->s_id,",
          "522:         function, line);",
          "527:  if ((sb->s_flags & MS_RDONLY) == 0) {",
          "528:   ext4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");",
          "529:   sb->s_flags |= MS_RDONLY;",
          "530:   EXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;",
          "531:   if (EXT4_SB(sb)->s_journal)",
          "532:    jbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);",
          "533:   save_error_info(sb, function, line);",
          "534:  }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "502: }",
          "504: void __ext4_warning(struct super_block *sb, const char *function,",
          "506: {",
          "507:  va_list args;",
          "509:  va_start(args, fmt);",
          "512:  vprintk(fmt, args);",
          "513:  printk(\"\\n\");",
          "514:  va_end(args);",
          "515: }",
          "519: __releases(bitlock)",
          "520: __acquires(bitlock)",
          "521: {",
          "522:  va_list args;",
          "523:  struct ext4_super_block *es = EXT4_SB(sb)->s_es;",
          "525:  va_start(args, fmt);",
          "527:  vprintk(fmt, args);",
          "528:  printk(\"\\n\");",
          "529:  va_end(args);",
          "531:  if (test_opt(sb, ERRORS_CONT)) {",
          "534:   ext4_commit_super(sb, 0);",
          "535:   return;",
          "536:  }",
          "537:  ext4_unlock_group(sb, grp);",
          "538:  ext4_handle_error(sb);",
          "",
          "[Removed Lines]",
          "505:     const char *fmt, ...)",
          "510:  printk(KERN_WARNING \"EXT4-fs warning (device %s): %s: \",",
          "511:         sb->s_id, function);",
          "517: void ext4_grp_locked_error(struct super_block *sb, ext4_group_t grp,",
          "518:       const char *function, const char *fmt, ...)",
          "526:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s: \", sb->s_id, function);",
          "532:   EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;",
          "533:   es->s_state |= cpu_to_le16(EXT4_ERROR_FS);",
          "",
          "[Added Lines]",
          "552:       unsigned int line, const char *fmt, ...)",
          "557:  printk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: \",",
          "558:         sb->s_id, function, line);",
          "564: void __ext4_grp_locked_error(const char *function, unsigned int line,",
          "565:         struct super_block *sb, ext4_group_t grp,",
          "566:         unsigned long ino, ext4_fsblk_t block,",
          "567:         const char *fmt, ...)",
          "574:  es->s_last_error_ino = cpu_to_le32(ino);",
          "575:  es->s_last_error_block = cpu_to_le64(block);",
          "576:  __save_error_info(sb, function, line);",
          "578:  printk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u\",",
          "579:         sb->s_id, function, line, grp);",
          "580:  if (ino)",
          "581:   printk(\"inode %lu: \", ino);",
          "582:  if (block)",
          "583:   printk(\"block %llu:\", (unsigned long long) block);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "660:   err = jbd2_journal_destroy(sbi->s_journal);",
          "661:   sbi->s_journal = NULL;",
          "662:   if (err < 0)",
          "665:  }",
          "667:  ext4_release_system_zone(sb);",
          "",
          "[Removed Lines]",
          "663:    ext4_abort(sb, __func__,",
          "664:        \"Couldn't clean up the journal\");",
          "",
          "[Added Lines]",
          "719:    ext4_abort(sb, \"Couldn't clean up the journal\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "946:   seq_puts(seq, \",journal_async_commit\");",
          "947:  else if (test_opt(sb, JOURNAL_CHECKSUM))",
          "948:   seq_puts(seq, \",journal_checksum\");",
          "951:  if (test_opt(sb, I_VERSION))",
          "952:   seq_puts(seq, \",i_version\");",
          "954:   seq_puts(seq, \",nodelalloc\");",
          "957:  if (sbi->s_stripe)",
          "958:   seq_printf(seq, \",stripe=%lu\", sbi->s_stripe);",
          "",
          "[Removed Lines]",
          "949:  if (test_opt(sb, NOBH))",
          "950:   seq_puts(seq, \",nobh\");",
          "953:  if (!test_opt(sb, DELALLOC))",
          "",
          "[Added Lines]",
          "1006:  if (!test_opt(sb, DELALLOC) &&",
          "1007:      !(def_mount_opts & EXT4_DEFM_NODELALLOC))",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "977:  if (test_opt(sb, NO_AUTO_DA_ALLOC))",
          "978:   seq_puts(seq, \",noauto_da_alloc\");",
          "981:   seq_puts(seq, \",discard\");",
          "983:  if (test_opt(sb, NOLOAD))",
          "",
          "[Removed Lines]",
          "980:  if (test_opt(sb, DISCARD))",
          "",
          "[Added Lines]",
          "1033:  if (test_opt(sb, DISCARD) && !(def_mount_opts & EXT4_DEFM_DISCARD))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "986:  if (test_opt(sb, DIOREAD_NOLOCK))",
          "987:   seq_puts(seq, \",dioread_nolock\");",
          "989:  ext4_show_quota_options(seq, sb);",
          "991:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1042:  if (test_opt(sb, BLOCK_VALIDITY) &&",
          "1043:      !(def_mount_opts & EXT4_DEFM_BLOCK_VALIDITY))",
          "1044:   seq_puts(seq, \",block_validity\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1065: static int ext4_write_info(struct super_block *sb, int type);",
          "1066: static int ext4_quota_on(struct super_block *sb, int type, int format_id,",
          "1067:     char *path);",
          "1068: static int ext4_quota_on_mount(struct super_block *sb, int type);",
          "1069: static ssize_t ext4_quota_read(struct super_block *sb, int type, char *data,",
          "1070:           size_t len, loff_t off);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1125: static int ext4_quota_off(struct super_block *sb, int type);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1087: static const struct quotactl_ops ext4_qctl_operations = {",
          "1088:  .quota_on = ext4_quota_on,",
          "1090:  .quota_sync = dquot_quota_sync,",
          "1091:  .get_info = dquot_get_dqinfo,",
          "1092:  .set_info = dquot_set_dqinfo,",
          "",
          "[Removed Lines]",
          "1089:  .quota_off = dquot_quota_off,",
          "",
          "[Added Lines]",
          "1147:  .quota_off = ext4_quota_off,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1625:    break;",
          "1626:   case Opt_nobh:",
          "1628:    break;",
          "1629:   case Opt_bh:",
          "1631:    break;",
          "1632:   case Opt_i_version:",
          "1633:    set_opt(sbi->s_mount_opt, I_VERSION);",
          "",
          "[Removed Lines]",
          "1627:    set_opt(sbi->s_mount_opt, NOBH);",
          "1630:    clear_opt(sbi->s_mount_opt, NOBH);",
          "",
          "[Added Lines]",
          "1685:    ext4_msg(sb, KERN_WARNING,",
          "1686:      \"Ignoring deprecated nobh option\");",
          "1689:    ext4_msg(sb, KERN_WARNING,",
          "1690:      \"Ignoring deprecated bh option\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2249: {",
          "2250:  struct super_block *sb = sbi->s_buddy_cache->i_sb;",
          "2252:  return snprintf(buf, PAGE_SIZE, \"%lu\\n\",",
          "2253:    (part_stat_read(sb->s_bdev->bd_part, sectors[1]) -",
          "2254:     sbi->s_sectors_written_start) >> 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2312:  if (!sb->s_bdev->bd_part)",
          "2313:   return snprintf(buf, PAGE_SIZE, \"0\\n\");",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2259: {",
          "2260:  struct super_block *sb = sbi->s_buddy_cache->i_sb;",
          "2262:  return snprintf(buf, PAGE_SIZE, \"%llu\\n\",",
          "2263:    (unsigned long long)(sbi->s_kbytes_written +",
          "2264:    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2324:  if (!sb->s_bdev->bd_part)",
          "2325:   return snprintf(buf, PAGE_SIZE, \"0\\n\");",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2431:  return 1;",
          "2432: }",
          "2434: static int ext4_fill_super(struct super_block *sb, void *data, int silent)",
          "2435:     __releases(kernel_lock)",
          "2436:     __acquires(kernel_lock)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2502: static void print_daily_error_info(unsigned long arg)",
          "2503: {",
          "2504:  struct super_block *sb = (struct super_block *) arg;",
          "2505:  struct ext4_sb_info *sbi;",
          "2506:  struct ext4_super_block *es;",
          "2508:  sbi = EXT4_SB(sb);",
          "2509:  es = sbi->s_es;",
          "2511:  if (es->s_error_count)",
          "2512:   ext4_msg(sb, KERN_NOTICE, \"error count: %u\",",
          "2513:     le32_to_cpu(es->s_error_count));",
          "2514:  if (es->s_first_error_time) {",
          "2515:   printk(KERN_NOTICE \"EXT4-fs (%s): initial error at %u: %.*s:%d\",",
          "2516:          sb->s_id, le32_to_cpu(es->s_first_error_time),",
          "2517:          (int) sizeof(es->s_first_error_func),",
          "2518:          es->s_first_error_func,",
          "2519:          le32_to_cpu(es->s_first_error_line));",
          "2520:   if (es->s_first_error_ino)",
          "2521:    printk(\": inode %u\",",
          "2522:           le32_to_cpu(es->s_first_error_ino));",
          "2523:   if (es->s_first_error_block)",
          "2524:    printk(\": block %llu\", (unsigned long long)",
          "2525:           le64_to_cpu(es->s_first_error_block));",
          "2526:   printk(\"\\n\");",
          "2527:  }",
          "2528:  if (es->s_last_error_time) {",
          "2529:   printk(KERN_NOTICE \"EXT4-fs (%s): last error at %u: %.*s:%d\",",
          "2530:          sb->s_id, le32_to_cpu(es->s_last_error_time),",
          "2531:          (int) sizeof(es->s_last_error_func),",
          "2532:          es->s_last_error_func,",
          "2533:          le32_to_cpu(es->s_last_error_line));",
          "2534:   if (es->s_last_error_ino)",
          "2535:    printk(\": inode %u\",",
          "2536:           le32_to_cpu(es->s_last_error_ino));",
          "2537:   if (es->s_last_error_block)",
          "2538:    printk(\": block %llu\", (unsigned long long)",
          "2539:           le64_to_cpu(es->s_last_error_block));",
          "2540:   printk(\"\\n\");",
          "2541:  }",
          "2543: }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2448:  struct inode *root;",
          "2449:  char *cp;",
          "2450:  const char *descr;",
          "2452:  int blocksize;",
          "2453:  unsigned int db_count;",
          "2454:  unsigned int i;",
          "",
          "[Removed Lines]",
          "2451:  int ret = -EINVAL;",
          "",
          "[Added Lines]",
          "2562:  int ret = -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2460:  sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);",
          "2461:  if (!sbi)",
          "2464:  sbi->s_blockgroup_lock =",
          "2465:   kzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);",
          "2466:  if (!sbi->s_blockgroup_lock) {",
          "2467:   kfree(sbi);",
          "2469:  }",
          "2470:  sb->s_fs_info = sbi;",
          "2471:  sbi->s_mount_opt = 0;",
          "",
          "[Removed Lines]",
          "2462:   return -ENOMEM;",
          "2468:   return -ENOMEM;",
          "",
          "[Added Lines]",
          "2573:   goto out_free_orig;",
          "2579:   goto out_free_orig;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2473:  sbi->s_resgid = EXT4_DEF_RESGID;",
          "2474:  sbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;",
          "2475:  sbi->s_sb_block = sb_block;",
          "2479:  unlock_kernel();",
          "",
          "[Removed Lines]",
          "2476:  sbi->s_sectors_written_start = part_stat_read(sb->s_bdev->bd_part,",
          "2477:             sectors[1]);",
          "",
          "[Added Lines]",
          "2587:  if (sb->s_bdev->bd_part)",
          "2588:   sbi->s_sectors_written_start =",
          "2589:    part_stat_read(sb->s_bdev->bd_part, sectors[1]);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2482:  for (cp = sb->s_id; (cp = strchr(cp, '/'));)",
          "2485:  blocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);",
          "2486:  if (!blocksize) {",
          "2487:   ext4_msg(sb, KERN_ERR, \"unable to set blocksize\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2597:  ret = -EINVAL;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2546:   set_opt(sbi->s_mount_opt, ERRORS_CONT);",
          "2547:  else",
          "2548:   set_opt(sbi->s_mount_opt, ERRORS_RO);",
          "2550:  sbi->s_resuid = le16_to_cpu(es->s_def_resuid);",
          "2551:  sbi->s_resgid = le16_to_cpu(es->s_def_resgid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2662:  if (def_mount_opts & EXT4_DEFM_BLOCK_VALIDITY)",
          "2663:   set_opt(sbi->s_mount_opt, BLOCK_VALIDITY);",
          "2664:  if (def_mount_opts & EXT4_DEFM_DISCARD)",
          "2665:   set_opt(sbi->s_mount_opt, DISCARD);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2553:  sbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;",
          "2554:  sbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;",
          "2563:   set_opt(sbi->s_mount_opt, DELALLOC);",
          "2565:  if (!parse_options((char *) data, sb, &journal_devnum,",
          "2566:       &journal_ioprio, NULL, 0))",
          "2567:   goto failed_mount;",
          "",
          "[Removed Lines]",
          "2556:  set_opt(sbi->s_mount_opt, BARRIER);",
          "2562:  if (!IS_EXT3_SB(sb))",
          "",
          "[Added Lines]",
          "2673:  if ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)",
          "2674:   set_opt(sbi->s_mount_opt, BARRIER);",
          "2680:  if (!IS_EXT3_SB(sb) &&",
          "2681:      ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))",
          "2684:  if (!parse_options((char *) sbi->s_es->s_mount_opts, sb,",
          "2685:       &journal_devnum, &journal_ioprio, NULL, 0)) {",
          "2686:   ext4_msg(sb, KERN_WARNING,",
          "2687:     \"failed to parse options in superblock: %s\",",
          "2688:     sbi->s_es->s_mount_opts);",
          "2689:  }",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2912:   ext4_msg(sb, KERN_ERR, \"insufficient memory\");",
          "2913:   goto failed_mount_wq;",
          "2914:  }",
          "2927:  EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");",
          "2928:  if (!EXT4_SB(sb)->dio_unwritten_wq) {",
          "2929:   printk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");",
          "",
          "[Removed Lines]",
          "2915:  if (test_opt(sb, NOBH)) {",
          "2916:   if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {",
          "2917:    ext4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"",
          "2918:     \"its supported only with writeback mode\");",
          "2919:    clear_opt(sbi->s_mount_opt, NOBH);",
          "2920:   }",
          "2921:   if (test_opt(sb, DIOREAD_NOLOCK)) {",
          "2922:    ext4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"",
          "2923:     \"not supported with nobh mode\");",
          "2924:    goto failed_mount_wq;",
          "2925:   }",
          "2926:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3043:   descr = \"out journal\";",
          "3045:  ext4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"",
          "3048:  lock_kernel();",
          "3049:  kfree(orig_data);",
          "",
          "[Removed Lines]",
          "3046:   \"Opts: %s\", descr, orig_data);",
          "",
          "[Added Lines]",
          "3160:    \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,",
          "3163:  init_timer(&sbi->s_err_report);",
          "3164:  sbi->s_err_report.function = print_daily_error_info;",
          "3165:  sbi->s_err_report.data = (unsigned long) sb;",
          "3166:  if (es->s_error_count)",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3093:  kfree(sbi->s_blockgroup_lock);",
          "3094:  kfree(sbi);",
          "3095:  lock_kernel();",
          "3096:  kfree(orig_data);",
          "3097:  return ret;",
          "3098: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3217: out_free_orig:",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3110:  journal->j_min_batch_time = sbi->s_min_batch_time;",
          "3111:  journal->j_max_batch_time = sbi->s_max_batch_time;",
          "3114:  if (test_opt(sb, BARRIER))",
          "3115:   journal->j_flags |= JBD2_BARRIER;",
          "3116:  else",
          "",
          "[Removed Lines]",
          "3113:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "3235:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3119:   journal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;",
          "3120:  else",
          "3121:   journal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;",
          "3123: }",
          "3125: static journal_t *ext4_get_journal(struct super_block *sb,",
          "",
          "[Removed Lines]",
          "3122:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "3244:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3328:  if (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER))",
          "3329:   err = jbd2_journal_wipe(journal, !really_read_only);",
          "3331:   err = jbd2_journal_load(journal);",
          "3333:  if (err) {",
          "3334:   ext4_msg(sb, KERN_ERR, \"error loading journal\");",
          "",
          "[Removed Lines]",
          "3330:  if (!err)",
          "",
          "[Added Lines]",
          "3452:  if (!err) {",
          "3453:   char *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);",
          "3454:   if (save)",
          "3455:    memcpy(save, ((char *) es) +",
          "3456:           EXT4_S_ERR_START, EXT4_S_ERR_LEN);",
          "3458:   if (save)",
          "3459:    memcpy(((char *) es) + EXT4_S_ERR_START,",
          "3460:           save, EXT4_S_ERR_LEN);",
          "3461:   kfree(save);",
          "3462:  }",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3385:  if (!(sb->s_flags & MS_RDONLY))",
          "3386:   es->s_wtime = cpu_to_le32(get_seconds());",
          "3389:        ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -",
          "3390:          EXT4_SB(sb)->s_sectors_written_start) >> 1));",
          "3391:  ext4_free_blocks_count_set(es, percpu_counter_sum_positive(",
          "3392:      &EXT4_SB(sb)->s_freeblocks_counter));",
          "3393:  es->s_free_inodes_count = cpu_to_le32(percpu_counter_sum_positive(",
          "",
          "[Removed Lines]",
          "3387:  es->s_kbytes_written =",
          "3388:   cpu_to_le64(EXT4_SB(sb)->s_kbytes_written +",
          "",
          "[Added Lines]",
          "3518:  if (sb->s_bdev->bd_part)",
          "3519:   es->s_kbytes_written =",
          "3520:    cpu_to_le64(EXT4_SB(sb)->s_kbytes_written +",
          "3523:  else",
          "3524:   es->s_kbytes_written =",
          "3525:    cpu_to_le64(EXT4_SB(sb)->s_kbytes_written);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3492:  journal = EXT4_SB(sb)->s_journal;",
          "3493:  if (journal) {",
          "3495:   ret = ext4_journal_force_commit(journal);",
          "3496:  }",
          "",
          "[Removed Lines]",
          "3494:   vfs_check_frozen(sb, SB_FREEZE_WRITE);",
          "",
          "[Added Lines]",
          "3629:   vfs_check_frozen(sb, SB_FREEZE_TRANS);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3616:  }",
          "3618:  if (sbi->s_mount_flags & EXT4_MF_FS_ABORTED)",
          "3621:  sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |",
          "3622:   (test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);",
          "",
          "[Removed Lines]",
          "3619:   ext4_abort(sb, __func__, \"Abort forced by user\");",
          "",
          "[Added Lines]",
          "3754:   ext4_abort(sb, \"Abort forced by user\");",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3981:  return err;",
          "3982: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4119: static int ext4_quota_off(struct super_block *sb, int type)",
          "4120: {",
          "4122:  if (test_opt(sb, DELALLOC)) {",
          "4123:   down_read(&sb->s_umount);",
          "4124:   sync_filesystem(sb);",
          "4125:   up_read(&sb->s_umount);",
          "4126:  }",
          "4128:  return dquot_quota_off(sb, type);",
          "4129: }",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "4030:  ext4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);",
          "4031:  int err = 0;",
          "4032:  int offset = off & (sb->s_blocksize - 1);",
          "4034:  struct buffer_head *bh;",
          "4035:  handle_t *handle = journal_current_handle();",
          "",
          "[Removed Lines]",
          "4033:  int journal_quota = EXT4_SB(sb)->s_qf_names[type] != NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "4055:  bh = ext4_bread(handle, inode, blk, 1, &err);",
          "4056:  if (!bh)",
          "4057:   goto out;",
          "4064:  }",
          "4065:  lock_buffer(bh);",
          "4066:  memcpy(bh->b_data+offset, data, len);",
          "4067:  flush_dcache_page(bh->b_page);",
          "4068:  unlock_buffer(bh);",
          "4076:  brelse(bh);",
          "4077: out:",
          "4078:  if (err) {",
          "",
          "[Removed Lines]",
          "4058:  if (journal_quota) {",
          "4059:   err = ext4_journal_get_write_access(handle, bh);",
          "4060:   if (err) {",
          "4061:    brelse(bh);",
          "4062:    goto out;",
          "4063:   }",
          "4069:  if (journal_quota)",
          "4070:   err = ext4_handle_dirty_metadata(handle, NULL, bh);",
          "4071:  else {",
          "4073:   err = ext4_jbd2_file_inode(handle, inode);",
          "4074:   mark_buffer_dirty(bh);",
          "4075:  }",
          "",
          "[Added Lines]",
          "4204:  err = ext4_journal_get_write_access(handle, bh);",
          "4205:  if (err) {",
          "4206:   brelse(bh);",
          "4207:   goto out;",
          "4213:  err = ext4_handle_dirty_metadata(handle, NULL, bh);",
          "",
          "---------------"
        ],
        "fs/ext4/xattr.c||fs/ext4/xattr.c": [
          "File: fs/ext4/xattr.c -> fs/ext4/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "459:  if (ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh) == 0) {",
          "460:   EXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR);",
          "463:  }",
          "464: }",
          "",
          "[Removed Lines]",
          "461:   sb->s_dirt = 1;",
          "462:   ext4_handle_dirty_metadata(handle, NULL, EXT4_SB(sb)->s_sbh);",
          "",
          "[Added Lines]",
          "461:   ext4_handle_dirty_super(handle, sb);",
          "",
          "---------------"
        ],
        "fs/jbd2/checkpoint.c||fs/jbd2/checkpoint.c": [
          "File: fs/jbd2/checkpoint.c -> fs/jbd2/checkpoint.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118: void __jbd2_log_wait_for_space(journal_t *journal)",
          "119: {",
          "120:  int nblocks, space_left;",
          "123:  nblocks = jbd_space_needed(journal);",
          "124:  while (__jbd2_log_space_left(journal) < nblocks) {",
          "125:   if (journal->j_flags & JBD2_ABORT)",
          "126:    return;",
          "128:   mutex_lock(&journal->j_checkpoint_mutex);",
          "",
          "[Removed Lines]",
          "121:  assert_spin_locked(&journal->j_state_lock);",
          "127:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "127:   write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142:   spin_lock(&journal->j_list_lock);",
          "143:   nblocks = jbd_space_needed(journal);",
          "144:   space_left = __jbd2_log_space_left(journal);",
          "",
          "[Removed Lines]",
          "141:   spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "141:   write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:    if (journal->j_committing_transaction)",
          "150:     tid = journal->j_committing_transaction->t_tid;",
          "151:    spin_unlock(&journal->j_list_lock);",
          "153:    if (chkpt) {",
          "154:     jbd2_log_do_checkpoint(journal);",
          "155:    } else if (jbd2_cleanup_journal_tail(journal) == 0) {",
          "",
          "[Removed Lines]",
          "152:    spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "152:    write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "167:     WARN_ON(1);",
          "168:     jbd2_journal_abort(journal, 0);",
          "169:    }",
          "171:   } else {",
          "172:    spin_unlock(&journal->j_list_lock);",
          "173:   }",
          "",
          "[Removed Lines]",
          "170:    spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "170:    write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "478:  spin_lock(&journal->j_list_lock);",
          "479:  transaction = journal->j_checkpoint_transactions;",
          "480:  if (transaction) {",
          "",
          "[Removed Lines]",
          "477:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "477:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "498:  if (journal->j_tail_sequence == first_tid) {",
          "500:   return 1;",
          "501:  }",
          "",
          "[Removed Lines]",
          "499:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "499:   write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "516:  journal->j_free += freed;",
          "517:  journal->j_tail_sequence = first_tid;",
          "518:  journal->j_tail = blocknr;",
          "",
          "[Removed Lines]",
          "519:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "519:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "775:  J_ASSERT(transaction->t_log_list == NULL);",
          "776:  J_ASSERT(transaction->t_checkpoint_list == NULL);",
          "777:  J_ASSERT(transaction->t_checkpoint_io_list == NULL);",
          "779:  J_ASSERT(journal->j_committing_transaction != transaction);",
          "780:  J_ASSERT(journal->j_running_transaction != transaction);",
          "",
          "[Removed Lines]",
          "778:  J_ASSERT(transaction->t_updates == 0);",
          "",
          "[Added Lines]",
          "778:  J_ASSERT(atomic_read(&transaction->t_updates) == 0);",
          "",
          "---------------"
        ],
        "fs/jbd2/commit.c||fs/jbd2/commit.c": [
          "File: fs/jbd2/commit.c -> fs/jbd2/commit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "151:  if (ret == -EOPNOTSUPP && barrier_done) {",
          "152:   printk(KERN_WARNING",
          "156:   journal->j_flags &= ~JBD2_BARRIER;",
          "160:   lock_buffer(bh);",
          "",
          "[Removed Lines]",
          "153:          \"JBD: barrier-based sync failed on %s - \"",
          "154:          \"disabling barriers\\n\", journal->j_devname);",
          "155:   spin_lock(&journal->j_state_lock);",
          "157:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "153:          \"JBD2: Disabling barriers on %s, \"",
          "154:          \"not supported by device\\n\", journal->j_devname);",
          "155:   write_lock(&journal->j_state_lock);",
          "157:   write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "180:  wait_on_buffer(bh);",
          "181:  if (buffer_eopnotsupp(bh) && (journal->j_flags & JBD2_BARRIER)) {",
          "182:   printk(KERN_WARNING",
          "186:   journal->j_flags &= ~JBD2_BARRIER;",
          "189:   lock_buffer(bh);",
          "190:   clear_buffer_dirty(bh);",
          "",
          "[Removed Lines]",
          "183:          \"JBD2: wait_on_commit_record: sync failed on %s - \"",
          "184:          \"disabling barriers\\n\", journal->j_devname);",
          "185:   spin_lock(&journal->j_state_lock);",
          "187:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "183:          \"JBD2: %s: disabling barries on %s - not supported \"",
          "184:          \"by device\\n\", __func__, journal->j_devname);",
          "185:   write_lock(&journal->j_state_lock);",
          "187:   write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "400:  jbd_debug(1, \"JBD: starting commit of transaction %d\\n\",",
          "401:    commit_transaction->t_tid);",
          "404:  commit_transaction->t_state = T_LOCKED;",
          "",
          "[Removed Lines]",
          "403:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "403:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "417:            stats.run.rs_locked);",
          "419:  spin_lock(&commit_transaction->t_handle_lock);",
          "421:   DEFINE_WAIT(wait);",
          "423:   prepare_to_wait(&journal->j_wait_updates, &wait,",
          "424:      TASK_UNINTERRUPTIBLE);",
          "426:    spin_unlock(&commit_transaction->t_handle_lock);",
          "428:    schedule();",
          "430:    spin_lock(&commit_transaction->t_handle_lock);",
          "431:   }",
          "432:   finish_wait(&journal->j_wait_updates, &wait);",
          "433:  }",
          "434:  spin_unlock(&commit_transaction->t_handle_lock);",
          "437:    journal->j_max_transaction_buffers);",
          "",
          "[Removed Lines]",
          "420:  while (commit_transaction->t_updates) {",
          "425:   if (commit_transaction->t_updates) {",
          "427:    spin_unlock(&journal->j_state_lock);",
          "429:    spin_lock(&journal->j_state_lock);",
          "436:  J_ASSERT (commit_transaction->t_outstanding_credits <=",
          "",
          "[Added Lines]",
          "420:  while (atomic_read(&commit_transaction->t_updates)) {",
          "425:   if (atomic_read(&commit_transaction->t_updates)) {",
          "427:    write_unlock(&journal->j_state_lock);",
          "429:    write_lock(&journal->j_state_lock);",
          "436:  J_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "497:  start_time = ktime_get();",
          "498:  commit_transaction->t_log_start = journal->j_head;",
          "499:  wake_up(&journal->j_wait_transaction_locked);",
          "502:  jbd_debug (3, \"JBD: commit phase 2\\n\");",
          "",
          "[Removed Lines]",
          "500:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "500:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "523:  commit_transaction->t_state = T_COMMIT;",
          "526:  trace_jbd2_commit_logging(journal, commit_transaction);",
          "527:  stats.run.rs_logging = jiffies;",
          "528:  stats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,",
          "529:             stats.run.rs_logging);",
          "531:  stats.run.rs_blocks_logged = 0;",
          "533:  J_ASSERT(commit_transaction->t_nr_buffers <=",
          "536:  err = 0;",
          "537:  descriptor = NULL;",
          "",
          "[Removed Lines]",
          "522:  spin_lock(&journal->j_state_lock);",
          "524:  spin_unlock(&journal->j_state_lock);",
          "530:  stats.run.rs_blocks = commit_transaction->t_outstanding_credits;",
          "534:    commit_transaction->t_outstanding_credits);",
          "",
          "[Added Lines]",
          "522:  write_lock(&journal->j_state_lock);",
          "524:  write_unlock(&journal->j_state_lock);",
          "530:  stats.run.rs_blocks =",
          "531:   atomic_read(&commit_transaction->t_outstanding_credits);",
          "535:    atomic_read(&commit_transaction->t_outstanding_credits));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "622:                    the shadowed buffer!  @@@ This can go if we ever get",
          "",
          "[Removed Lines]",
          "619:   commit_transaction->t_outstanding_credits--;",
          "",
          "[Added Lines]",
          "620:   atomic_dec(&commit_transaction->t_outstanding_credits);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "981:  spin_lock(&journal->j_list_lock);",
          "",
          "[Removed Lines]",
          "980:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "981:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "986:  if (commit_transaction->t_forget) {",
          "987:   spin_unlock(&journal->j_list_lock);",
          "989:   goto restart_loop;",
          "990:  }",
          "",
          "[Removed Lines]",
          "988:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "989:   write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1005:  stats.ts_tid = commit_transaction->t_tid;",
          "1007:  trace_jbd2_run_stats(journal->j_fs_dev->bd_dev,",
          "1008:         commit_transaction->t_tid, &stats.run);",
          "",
          "[Removed Lines]",
          "1006:  stats.run.rs_handle_count = commit_transaction->t_handle_count;",
          "",
          "[Added Lines]",
          "1007:  stats.run.rs_handle_count =",
          "1008:   atomic_read(&commit_transaction->t_handle_count);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1037:     journal->j_average_commit_time*3) / 4;",
          "1038:  else",
          "1039:   journal->j_average_commit_time = commit_time;",
          "1042:  if (commit_transaction->t_checkpoint_list == NULL &&",
          "1043:      commit_transaction->t_checkpoint_io_list == NULL) {",
          "",
          "[Removed Lines]",
          "1040:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1042:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------"
        ],
        "fs/jbd2/journal.c||fs/jbd2/journal.c": [
          "File: fs/jbd2/journal.c -> fs/jbd2/journal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: #include <linux/hash.h>",
          "42: #include <linux/log2.h>",
          "43: #include <linux/vmalloc.h>",
          "45: #define CREATE_TRACE_POINTS",
          "46: #include <trace/events/jbd2.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44: #include <linux/backing-dev.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: #include <asm/uaccess.h>",
          "49: #include <asm/page.h>",
          "53: EXPORT_SYMBOL(jbd2_journal_extend);",
          "54: EXPORT_SYMBOL(jbd2_journal_stop);",
          "55: EXPORT_SYMBOL(jbd2_journal_lock_updates);",
          "",
          "[Removed Lines]",
          "51: EXPORT_SYMBOL(jbd2_journal_start);",
          "52: EXPORT_SYMBOL(jbd2_journal_restart);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "148: loop:",
          "149:  if (journal->j_flags & JBD2_UNMOUNT)",
          "",
          "[Removed Lines]",
          "146:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "145:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "155:  if (journal->j_commit_sequence != journal->j_commit_request) {",
          "156:   jbd_debug(1, \"OK, requests differ\\n\");",
          "158:   del_timer_sync(&journal->j_commit_timer);",
          "159:   jbd2_journal_commit_transaction(journal);",
          "161:   goto loop;",
          "162:  }",
          "",
          "[Removed Lines]",
          "157:   spin_unlock(&journal->j_state_lock);",
          "160:   spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "156:   write_unlock(&journal->j_state_lock);",
          "159:   write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "171:   jbd_debug(1, \"Now suspending kjournald2\\n\");",
          "173:   refrigerator();",
          "175:  } else {",
          "",
          "[Removed Lines]",
          "172:   spin_unlock(&journal->j_state_lock);",
          "174:   spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "171:   write_unlock(&journal->j_state_lock);",
          "173:   write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "191:   if (journal->j_flags & JBD2_UNMOUNT)",
          "192:    should_sleep = 0;",
          "193:   if (should_sleep) {",
          "195:    schedule();",
          "197:   }",
          "198:   finish_wait(&journal->j_wait_commit, &wait);",
          "199:  }",
          "",
          "[Removed Lines]",
          "194:    spin_unlock(&journal->j_state_lock);",
          "196:    spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "193:    write_unlock(&journal->j_state_lock);",
          "195:    write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "211:  goto loop;",
          "213: end_loop:",
          "215:  del_timer_sync(&journal->j_commit_timer);",
          "216:  journal->j_task = NULL;",
          "217:  wake_up(&journal->j_wait_done_commit);",
          "",
          "[Removed Lines]",
          "214:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "213:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "235: static void journal_kill_thread(journal_t *journal)",
          "236: {",
          "238:  journal->j_flags |= JBD2_UNMOUNT;",
          "240:  while (journal->j_task) {",
          "241:   wake_up(&journal->j_wait_commit);",
          "243:   wait_event(journal->j_wait_done_commit, journal->j_task == NULL);",
          "245:  }",
          "247: }",
          "",
          "[Removed Lines]",
          "237:  spin_lock(&journal->j_state_lock);",
          "242:   spin_unlock(&journal->j_state_lock);",
          "244:   spin_lock(&journal->j_state_lock);",
          "246:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "236:  write_lock(&journal->j_state_lock);",
          "241:   write_unlock(&journal->j_state_lock);",
          "243:   write_lock(&journal->j_state_lock);",
          "245:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "311:  J_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));",
          "315:  new_bh->b_state = 0;",
          "316:  init_buffer(new_bh, NULL, NULL);",
          "",
          "[Removed Lines]",
          "313:  new_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);",
          "",
          "[Added Lines]",
          "312: retry_alloc:",
          "313:  new_bh = alloc_buffer_head(GFP_NOFS);",
          "314:  if (!new_bh) {",
          "319:   congestion_wait(BLK_RW_ASYNC, HZ/50);",
          "320:   goto retry_alloc;",
          "321:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "442: {",
          "443:  int left = journal->j_free;",
          "",
          "[Removed Lines]",
          "445:  assert_spin_locked(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "487: {",
          "488:  int ret;",
          "491:  ret = __jbd2_log_start_commit(journal, tid);",
          "493:  return ret;",
          "494: }",
          "",
          "[Removed Lines]",
          "490:  spin_lock(&journal->j_state_lock);",
          "492:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "499:  write_lock(&journal->j_state_lock);",
          "501:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "508:  transaction_t *transaction = NULL;",
          "509:  tid_t tid;",
          "512:  if (journal->j_running_transaction && !current->journal_info) {",
          "513:   transaction = journal->j_running_transaction;",
          "514:   __jbd2_log_start_commit(journal, transaction->t_tid);",
          "",
          "[Removed Lines]",
          "511:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "520:  read_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "516:   transaction = journal->j_committing_transaction;",
          "518:  if (!transaction) {",
          "521:  }",
          "523:  tid = transaction->t_tid;",
          "525:  jbd2_log_wait_commit(journal, tid);",
          "526:  return 1;",
          "527: }",
          "",
          "[Removed Lines]",
          "519:   spin_unlock(&journal->j_state_lock);",
          "524:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "528:   read_unlock(&journal->j_state_lock);",
          "533:  read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "535: {",
          "536:  int ret = 0;",
          "539:  if (journal->j_running_transaction) {",
          "540:   tid_t tid = journal->j_running_transaction->t_tid;",
          "",
          "[Removed Lines]",
          "538:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "547:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "555:   ret = 1;",
          "556:  }",
          "558:  return ret;",
          "559: }",
          "",
          "[Removed Lines]",
          "557:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "566:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "566: {",
          "567:  int err = 0;",
          "569: #ifdef CONFIG_JBD2_DEBUG",
          "571:  if (!tid_geq(journal->j_commit_request, tid)) {",
          "572:   printk(KERN_EMERG",
          "573:          \"%s: error: j_commit_request=%d, tid=%d\\n\",",
          "574:          __func__, journal->j_commit_request, tid);",
          "575:  }",
          "577: #endif",
          "579:  while (tid_gt(tid, journal->j_commit_sequence)) {",
          "580:   jbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",",
          "581:       tid, journal->j_commit_sequence);",
          "582:   wake_up(&journal->j_wait_commit);",
          "584:   wait_event(journal->j_wait_done_commit,",
          "585:     !tid_gt(tid, journal->j_commit_sequence));",
          "587:  }",
          "590:  if (unlikely(is_journal_aborted(journal))) {",
          "591:   printk(KERN_EMERG \"journal commit I/O error\\n\");",
          "",
          "[Removed Lines]",
          "570:  spin_lock(&journal->j_state_lock);",
          "576:  spin_unlock(&journal->j_state_lock);",
          "578:  spin_lock(&journal->j_state_lock);",
          "583:   spin_unlock(&journal->j_state_lock);",
          "586:   spin_lock(&journal->j_state_lock);",
          "588:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "578:  read_lock(&journal->j_state_lock);",
          "590:   read_unlock(&journal->j_state_lock);",
          "593:   read_lock(&journal->j_state_lock);",
          "595:  read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "602: {",
          "603:  unsigned long blocknr;",
          "606:  J_ASSERT(journal->j_free > 1);",
          "608:  blocknr = journal->j_head;",
          "",
          "[Removed Lines]",
          "605:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "612:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "610:  journal->j_free--;",
          "611:  if (journal->j_head == journal->j_last)",
          "612:   journal->j_head = journal->j_first;",
          "614:  return jbd2_journal_bmap(journal, blocknr, retp);",
          "615: }",
          "",
          "[Removed Lines]",
          "613:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "620:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "830:  mutex_init(&journal->j_checkpoint_mutex);",
          "831:  spin_lock_init(&journal->j_revoke_lock);",
          "832:  spin_lock_init(&journal->j_list_lock);",
          "835:  journal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);",
          "836:  journal->j_min_batch_time = 0;",
          "",
          "[Removed Lines]",
          "833:  spin_lock_init(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "840:  rwlock_init(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1096:   set_buffer_uptodate(bh);",
          "1097:  }",
          "1100:  jbd_debug(1,\"JBD: updating superblock (start %ld, seq %d, errno %d)\\n\",",
          "1101:     journal->j_tail, journal->j_tail_sequence, journal->j_errno);",
          "1103:  sb->s_sequence = cpu_to_be32(journal->j_tail_sequence);",
          "1104:  sb->s_start    = cpu_to_be32(journal->j_tail);",
          "1105:  sb->s_errno    = cpu_to_be32(journal->j_errno);",
          "1108:  BUFFER_TRACE(bh, \"marking dirty\");",
          "1109:  mark_buffer_dirty(bh);",
          "",
          "[Removed Lines]",
          "1099:  spin_lock(&journal->j_state_lock);",
          "1106:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1106:  read_lock(&journal->j_state_lock);",
          "1113:  read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1128:  if (sb->s_start)",
          "1129:   journal->j_flags &= ~JBD2_FLUSHED;",
          "1130:  else",
          "1131:   journal->j_flags |= JBD2_FLUSHED;",
          "1133: }",
          "",
          "[Removed Lines]",
          "1127:  spin_lock(&journal->j_state_lock);",
          "1132:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1134:  write_lock(&journal->j_state_lock);",
          "1139:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1391: int jbd2_journal_check_available_features (journal_t *journal, unsigned long compat,",
          "1392:           unsigned long ro, unsigned long incompat)",
          "1393: {",
          "1396:  if (!compat && !ro && !incompat)",
          "1397:   return 1;",
          "",
          "[Removed Lines]",
          "1394:  journal_superblock_t *sb;",
          "1399:  sb = journal->j_superblock;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1545:  transaction_t *transaction = NULL;",
          "1546:  unsigned long old_tail;",
          "1551:  if (journal->j_running_transaction) {",
          "",
          "[Removed Lines]",
          "1548:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1551:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1558:  if (transaction) {",
          "1559:   tid_t tid = transaction->t_tid;",
          "1562:   jbd2_log_wait_commit(journal, tid);",
          "1563:  } else {",
          "1565:  }",
          "",
          "[Removed Lines]",
          "1561:   spin_unlock(&journal->j_state_lock);",
          "1564:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1564:   write_unlock(&journal->j_state_lock);",
          "1567:   write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1589:  old_tail = journal->j_tail;",
          "1590:  journal->j_tail = 0;",
          "1592:  jbd2_journal_update_superblock(journal, 1);",
          "1594:  journal->j_tail = old_tail;",
          "1596:  J_ASSERT(!journal->j_running_transaction);",
          "",
          "[Removed Lines]",
          "1588:  spin_lock(&journal->j_state_lock);",
          "1591:  spin_unlock(&journal->j_state_lock);",
          "1593:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1591:  write_lock(&journal->j_state_lock);",
          "1594:  write_unlock(&journal->j_state_lock);",
          "1596:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1598:  J_ASSERT(!journal->j_checkpoint_transactions);",
          "1599:  J_ASSERT(journal->j_head == journal->j_tail);",
          "1600:  J_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);",
          "1602:  return 0;",
          "1603: }",
          "",
          "[Removed Lines]",
          "1601:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1604:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1618: int jbd2_journal_wipe(journal_t *journal, int write)",
          "1619: {",
          "1621:  int err = 0;",
          "1623:  J_ASSERT (!(journal->j_flags & JBD2_LOADED));",
          "",
          "[Removed Lines]",
          "1620:  journal_superblock_t *sb;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1626:  if (err)",
          "1627:   return err;",
          "1631:  if (!journal->j_tail)",
          "1632:   goto no_recovery;",
          "",
          "[Removed Lines]",
          "1629:  sb = journal->j_superblock;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1665:  printk(KERN_ERR \"Aborting journal on device %s.\\n\",",
          "1666:         journal->j_devname);",
          "1669:  journal->j_flags |= JBD2_ABORT;",
          "1670:  transaction = journal->j_running_transaction;",
          "1671:  if (transaction)",
          "1672:   __jbd2_log_start_commit(journal, transaction->t_tid);",
          "1674: }",
          "",
          "[Removed Lines]",
          "1668:  spin_lock(&journal->j_state_lock);",
          "1673:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1668:  write_lock(&journal->j_state_lock);",
          "1673:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1755: {",
          "1756:  int err;",
          "1759:  if (journal->j_flags & JBD2_ABORT)",
          "1760:   err = -EROFS;",
          "1761:  else",
          "1762:   err = journal->j_errno;",
          "1764:  return err;",
          "1765: }",
          "",
          "[Removed Lines]",
          "1758:  spin_lock(&journal->j_state_lock);",
          "1763:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1758:  read_lock(&journal->j_state_lock);",
          "1763:  read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1775: {",
          "1776:  int err = 0;",
          "1779:  if (journal->j_flags & JBD2_ABORT)",
          "1780:   err = -EROFS;",
          "1781:  else",
          "1782:   journal->j_errno = 0;",
          "1784:  return err;",
          "1785: }",
          "",
          "[Removed Lines]",
          "1778:  spin_lock(&journal->j_state_lock);",
          "1783:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1778:  write_lock(&journal->j_state_lock);",
          "1783:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1794: void jbd2_journal_ack_err(journal_t *journal)",
          "1795: {",
          "1797:  if (journal->j_errno)",
          "1798:   journal->j_flags |= JBD2_ACK_ERR;",
          "1800: }",
          "1802: int jbd2_journal_blocks_per_page(struct inode *inode)",
          "",
          "[Removed Lines]",
          "1796:  spin_lock(&journal->j_state_lock);",
          "1799:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1796:  write_lock(&journal->j_state_lock);",
          "1799:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2201: void jbd2_journal_release_jbd_inode(journal_t *journal,",
          "2202:         struct jbd2_inode *jinode)",
          "2203: {",
          "2206:  if (!journal)",
          "2207:   return;",
          "2208: restart:",
          "",
          "[Removed Lines]",
          "2204:  int writeout = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2219:   goto restart;",
          "2220:  }",
          "2225:  if (jinode->i_transaction) {",
          "2226:   list_del(&jinode->i_list);",
          "2227:   jinode->i_transaction = NULL;",
          "",
          "[Removed Lines]",
          "2223:  if (journal->j_committing_transaction == jinode->i_transaction)",
          "2224:   writeout = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/jbd2/recovery.c||fs/jbd2/recovery.c": [
          "File: fs/jbd2/recovery.c -> fs/jbd2/recovery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "285: int jbd2_journal_skip_recovery(journal_t *journal)",
          "286: {",
          "287:  int   err;",
          "290:  struct recovery_info info;",
          "292:  memset (&info, 0, sizeof(info));",
          "295:  err = do_one_pass(journal, &info, PASS_SCAN);",
          "",
          "[Removed Lines]",
          "288:  journal_superblock_t * sb;",
          "293:  sb = journal->j_superblock;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "299:   ++journal->j_transaction_sequence;",
          "300:  } else {",
          "301: #ifdef CONFIG_JBD2_DEBUG",
          "303: #endif",
          "304:   jbd_debug(1,",
          "305:      \"JBD: ignoring %d transaction%s from the journal.\\n\",",
          "",
          "[Removed Lines]",
          "302:   int dropped = info.end_transaction - be32_to_cpu(sb->s_sequence);",
          "",
          "[Added Lines]",
          "300:   int dropped = info.end_transaction -",
          "301:    be32_to_cpu(journal->j_superblock->s_sequence);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "365:  int   tag_bytes = journal_tag_bytes(journal);",
          "",
          "[Removed Lines]",
          "369:  int   MAX_BLOCKS_PER_DESC;",
          "370:  MAX_BLOCKS_PER_DESC = ((journal->j_blocksize-sizeof(journal_header_t))",
          "371:           / tag_bytes);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/jbd2/transaction.c||fs/jbd2/transaction.c": [
          "File: fs/jbd2/transaction.c -> fs/jbd2/transaction.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <linux/mm.h>",
          "27: #include <linux/highmem.h>",
          "28: #include <linux/hrtimer.h>",
          "30: static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include <linux/backing-dev.h>",
          "30: #include <linux/module.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:  transaction->t_tid = journal->j_transaction_sequence++;",
          "54:  transaction->t_expires = jiffies + journal->j_commit_interval;",
          "55:  spin_lock_init(&transaction->t_handle_lock);",
          "56:  INIT_LIST_HEAD(&transaction->t_inode_list);",
          "57:  INIT_LIST_HEAD(&transaction->t_private_list);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58:  atomic_set(&transaction->t_updates, 0);",
          "59:  atomic_set(&transaction->t_outstanding_credits, 0);",
          "60:  atomic_set(&transaction->t_handle_count, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87: {",
          "88:  transaction_t *transaction;",
          "89:  int needed;",
          "90:  int nblocks = handle->h_buffer_credits;",
          "91:  transaction_t *new_transaction = NULL;",
          "93:  unsigned long ts = jiffies;",
          "95:  if (nblocks > journal->j_max_transaction_buffers) {",
          "96:   printk(KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\",",
          "97:          current->comm, nblocks,",
          "98:          journal->j_max_transaction_buffers);",
          "101:  }",
          "103: alloc_transaction:",
          "104:  if (!journal->j_running_transaction) {",
          "107:   if (!new_transaction) {",
          "110:   }",
          "111:  }",
          "113:  jbd_debug(3, \"New handle %p going live.\\n\", handle);",
          "123:  if (is_journal_aborted(journal) ||",
          "124:      (journal->j_errno != 0 && !(journal->j_flags & JBD2_ACK_ERR))) {",
          "128:  }",
          "131:  if (journal->j_barrier_count) {",
          "133:   wait_event(journal->j_wait_transaction_locked,",
          "134:     journal->j_barrier_count == 0);",
          "135:   goto repeat;",
          "136:  }",
          "138:  if (!journal->j_running_transaction) {",
          "141:    goto alloc_transaction;",
          "142:   }",
          "145:  }",
          "147:  transaction = journal->j_running_transaction;",
          "",
          "[Removed Lines]",
          "86: static int start_this_handle(journal_t *journal, handle_t *handle)",
          "92:  int ret = 0;",
          "99:   ret = -ENOSPC;",
          "100:   goto out;",
          "105:   new_transaction = kzalloc(sizeof(*new_transaction),",
          "106:       GFP_NOFS|__GFP_NOFAIL);",
          "108:    ret = -ENOMEM;",
          "109:    goto out;",
          "115: repeat:",
          "121:  spin_lock(&journal->j_state_lock);",
          "122: repeat_locked:",
          "125:   spin_unlock(&journal->j_state_lock);",
          "126:   ret = -EROFS;",
          "127:   goto out;",
          "132:   spin_unlock(&journal->j_state_lock);",
          "139:   if (!new_transaction) {",
          "140:    spin_unlock(&journal->j_state_lock);",
          "143:   jbd2_get_transaction(journal, new_transaction);",
          "144:   new_transaction = NULL;",
          "",
          "[Added Lines]",
          "91: static int start_this_handle(journal_t *journal, handle_t *handle,",
          "92:         int gfp_mask)",
          "104:   return -ENOSPC;",
          "109:   new_transaction = kzalloc(sizeof(*new_transaction), gfp_mask);",
          "118:    if ((gfp_mask & __GFP_FS) == 0) {",
          "119:     congestion_wait(BLK_RW_ASYNC, HZ/50);",
          "120:     goto alloc_transaction;",
          "121:    }",
          "122:    return -ENOMEM;",
          "132: repeat:",
          "133:  read_lock(&journal->j_state_lock);",
          "136:   read_unlock(&journal->j_state_lock);",
          "137:   kfree(new_transaction);",
          "138:   return -EROFS;",
          "143:   read_unlock(&journal->j_state_lock);",
          "150:   read_unlock(&journal->j_state_lock);",
          "151:   if (!new_transaction)",
          "153:   write_lock(&journal->j_state_lock);",
          "154:   if (!journal->j_running_transaction) {",
          "155:    jbd2_get_transaction(journal, new_transaction);",
          "156:    new_transaction = NULL;",
          "158:   write_unlock(&journal->j_state_lock);",
          "159:   goto repeat;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156:   prepare_to_wait(&journal->j_wait_transaction_locked,",
          "157:      &wait, TASK_UNINTERRUPTIBLE);",
          "159:   schedule();",
          "160:   finish_wait(&journal->j_wait_transaction_locked, &wait);",
          "161:   goto repeat;",
          "",
          "[Removed Lines]",
          "158:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "173:   read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "172:  if (needed > journal->j_max_transaction_buffers) {",
          "",
          "[Removed Lines]",
          "169:  spin_lock(&transaction->t_handle_lock);",
          "170:  needed = transaction->t_outstanding_credits + nblocks;",
          "",
          "[Added Lines]",
          "184:  needed = atomic_add_return(nblocks,",
          "185:        &transaction->t_outstanding_credits);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "178:   DEFINE_WAIT(wait);",
          "180:   jbd_debug(2, \"Handle %p starting new commit...\\n\", handle);",
          "182:   prepare_to_wait(&journal->j_wait_transaction_locked, &wait,",
          "183:     TASK_UNINTERRUPTIBLE);",
          "184:   __jbd2_log_start_commit(journal, transaction->t_tid);",
          "186:   schedule();",
          "187:   finish_wait(&journal->j_wait_transaction_locked, &wait);",
          "188:   goto repeat;",
          "",
          "[Removed Lines]",
          "181:   spin_unlock(&transaction->t_handle_lock);",
          "185:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "196:   atomic_sub(nblocks, &transaction->t_outstanding_credits);",
          "200:   read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "216:  if (__jbd2_log_space_left(journal) < jbd_space_needed(journal)) {",
          "217:   jbd_debug(2, \"Handle %p waiting for checkpoint...\\n\", handle);",
          "221:  }",
          "227:   ts = jbd2_time_diff(ts, transaction->t_start);",
          "228:   if (ts > transaction->t_max_wait)",
          "229:    transaction->t_max_wait = ts;",
          "230:  }",
          "232:  handle->h_transaction = transaction;",
          "236:  jbd_debug(4, \"Handle %p given %d credits (total %d, free %d)\\n\",",
          "238:     __jbd2_log_space_left(journal));",
          "242:  lock_map_acquire(&handle->h_lockdep_map);",
          "247: }",
          "249: static struct lock_class_key jbd2_handle_key;",
          "",
          "[Removed Lines]",
          "218:   spin_unlock(&transaction->t_handle_lock);",
          "219:   __jbd2_log_wait_for_space(journal);",
          "220:   goto repeat_locked;",
          "226:  if (time_after(transaction->t_start, ts)) {",
          "233:  transaction->t_outstanding_credits += nblocks;",
          "234:  transaction->t_updates++;",
          "235:  transaction->t_handle_count++;",
          "237:     handle, nblocks, transaction->t_outstanding_credits,",
          "239:  spin_unlock(&transaction->t_handle_lock);",
          "240:  spin_unlock(&journal->j_state_lock);",
          "243: out:",
          "245:   kfree(new_transaction);",
          "246:  return ret;",
          "",
          "[Added Lines]",
          "233:   atomic_sub(nblocks, &transaction->t_outstanding_credits);",
          "234:   read_unlock(&journal->j_state_lock);",
          "235:   write_lock(&journal->j_state_lock);",
          "236:   if (__jbd2_log_space_left(journal) < jbd_space_needed(journal))",
          "237:    __jbd2_log_wait_for_space(journal);",
          "238:   write_unlock(&journal->j_state_lock);",
          "239:   goto repeat;",
          "253: #ifdef CONFIG_JBD2_DEBUG",
          "254:  if (jbd2_journal_enable_debug &&",
          "255:      time_after(transaction->t_start, ts)) {",
          "257:   spin_lock(&transaction->t_handle_lock);",
          "260:   spin_unlock(&transaction->t_handle_lock);",
          "262: #endif",
          "264:  atomic_inc(&transaction->t_updates);",
          "265:  atomic_inc(&transaction->t_handle_count);",
          "267:     handle, nblocks,",
          "268:     atomic_read(&transaction->t_outstanding_credits),",
          "270:  read_unlock(&journal->j_state_lock);",
          "273:  kfree(new_transaction);",
          "274:  return 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "282: {",
          "283:  handle_t *handle = journal_current_handle();",
          "284:  int err;",
          "",
          "[Removed Lines]",
          "281: handle_t *jbd2_journal_start(journal_t *journal, int nblocks)",
          "",
          "[Added Lines]",
          "309: handle_t *jbd2__journal_start(journal_t *journal, int nblocks, int gfp_mask)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "299:  current->journal_info = handle;",
          "302:  if (err < 0) {",
          "303:   jbd2_free_handle(handle);",
          "304:   current->journal_info = NULL;",
          "",
          "[Removed Lines]",
          "301:  err = start_this_handle(journal, handle);",
          "",
          "[Added Lines]",
          "329:  err = start_this_handle(journal, handle, gfp_mask);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "308: out:",
          "309:  return handle;",
          "310: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "339: EXPORT_SYMBOL(jbd2__journal_start);",
          "342: handle_t *jbd2_journal_start(journal_t *journal, int nblocks)",
          "343: {",
          "344:  return jbd2__journal_start(journal, nblocks, GFP_NOFS);",
          "345: }",
          "346: EXPORT_SYMBOL(jbd2_journal_start);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "343:  result = 1;",
          "348:  if (handle->h_transaction->t_state != T_RUNNING) {",
          "",
          "[Removed Lines]",
          "345:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "382:  read_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "352:  }",
          "354:  spin_lock(&transaction->t_handle_lock);",
          "357:  if (wanted > journal->j_max_transaction_buffers) {",
          "358:   jbd_debug(3, \"denied handle %p %d blocks: \"",
          "",
          "[Removed Lines]",
          "355:  wanted = transaction->t_outstanding_credits + nblocks;",
          "",
          "[Added Lines]",
          "392:  wanted = atomic_read(&transaction->t_outstanding_credits) + nblocks;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "367:  }",
          "369:  handle->h_buffer_credits += nblocks;",
          "371:  result = 0;",
          "373:  jbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);",
          "374: unlock:",
          "375:  spin_unlock(&transaction->t_handle_lock);",
          "376: error_out:",
          "378: out:",
          "379:  return result;",
          "380: }",
          "",
          "[Removed Lines]",
          "370:  transaction->t_outstanding_credits += nblocks;",
          "377:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "407:  atomic_add(nblocks, &transaction->t_outstanding_credits);",
          "414:  read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "399: {",
          "400:  transaction_t *transaction = handle->h_transaction;",
          "401:  journal_t *journal = transaction->t_journal;",
          "",
          "[Removed Lines]",
          "398: int jbd2_journal_restart(handle_t *handle, int nblocks)",
          "",
          "[Added Lines]",
          "434: int jbd2__journal_restart(handle_t *handle, int nblocks, int gfp_mask)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "414:  J_ASSERT(journal_current_handle() == handle);",
          "417:  spin_lock(&transaction->t_handle_lock);",
          "422:   wake_up(&journal->j_wait_updates);",
          "423:  spin_unlock(&transaction->t_handle_lock);",
          "425:  jbd_debug(2, \"restarting handle %p\\n\", handle);",
          "426:  __jbd2_log_start_commit(journal, transaction->t_tid);",
          "429:  lock_map_release(&handle->h_lockdep_map);",
          "430:  handle->h_buffer_credits = nblocks;",
          "432:  return ret;",
          "433: }",
          "",
          "[Removed Lines]",
          "413:  J_ASSERT(transaction->t_updates > 0);",
          "416:  spin_lock(&journal->j_state_lock);",
          "418:  transaction->t_outstanding_credits -= handle->h_buffer_credits;",
          "419:  transaction->t_updates--;",
          "421:  if (!transaction->t_updates)",
          "427:  spin_unlock(&journal->j_state_lock);",
          "431:  ret = start_this_handle(journal, handle);",
          "",
          "[Added Lines]",
          "449:  J_ASSERT(atomic_read(&transaction->t_updates) > 0);",
          "452:  read_lock(&journal->j_state_lock);",
          "454:  atomic_sub(handle->h_buffer_credits,",
          "455:      &transaction->t_outstanding_credits);",
          "456:  if (atomic_dec_and_test(&transaction->t_updates))",
          "462:  read_unlock(&journal->j_state_lock);",
          "466:  ret = start_this_handle(journal, handle, gfp_mask);",
          "469: EXPORT_SYMBOL(jbd2__journal_restart);",
          "472: int jbd2_journal_restart(handle_t *handle, int nblocks)",
          "473: {",
          "474:  return jbd2__journal_restart(handle, nblocks, GFP_NOFS);",
          "475: }",
          "476: EXPORT_SYMBOL(jbd2_journal_restart);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "447: {",
          "448:  DEFINE_WAIT(wait);",
          "451:  ++journal->j_barrier_count;",
          "",
          "[Removed Lines]",
          "450:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "492:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "458:    break;",
          "460:   spin_lock(&transaction->t_handle_lock);",
          "462:    spin_unlock(&transaction->t_handle_lock);",
          "463:    break;",
          "464:   }",
          "465:   prepare_to_wait(&journal->j_wait_updates, &wait,",
          "466:     TASK_UNINTERRUPTIBLE);",
          "467:   spin_unlock(&transaction->t_handle_lock);",
          "469:   schedule();",
          "470:   finish_wait(&journal->j_wait_updates, &wait);",
          "472:  }",
          "",
          "[Removed Lines]",
          "461:   if (!transaction->t_updates) {",
          "468:   spin_unlock(&journal->j_state_lock);",
          "471:   spin_lock(&journal->j_state_lock);",
          "473:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "503:   if (!atomic_read(&transaction->t_updates)) {",
          "510:   write_unlock(&journal->j_state_lock);",
          "513:   write_lock(&journal->j_state_lock);",
          "515:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "494:  J_ASSERT(journal->j_barrier_count != 0);",
          "496:  mutex_unlock(&journal->j_barrier);",
          "498:  --journal->j_barrier_count;",
          "500:  wake_up(&journal->j_wait_transaction_locked);",
          "501: }",
          "",
          "[Removed Lines]",
          "497:  spin_lock(&journal->j_state_lock);",
          "499:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "539:  write_lock(&journal->j_state_lock);",
          "541:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1238: {",
          "1239:  transaction_t *transaction = handle->h_transaction;",
          "1240:  journal_t *journal = transaction->t_journal;",
          "1242:  pid_t pid;",
          "1244:  J_ASSERT(journal_current_handle() == handle);",
          "",
          "[Removed Lines]",
          "1241:  int err;",
          "",
          "[Added Lines]",
          "1283:  int err, wait_for_commit = 0;",
          "1284:  tid_t tid;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1246:  if (is_handle_aborted(handle))",
          "1247:   err = -EIO;",
          "1248:  else {",
          "1250:   err = 0;",
          "1251:  }",
          "",
          "[Removed Lines]",
          "1249:   J_ASSERT(transaction->t_updates > 0);",
          "",
          "[Added Lines]",
          "1292:   J_ASSERT(atomic_read(&transaction->t_updates) > 0);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1292:   journal->j_last_sync_writer = pid;",
          "1295:   commit_time = journal->j_average_commit_time;",
          "1298:   trans_time = ktime_to_ns(ktime_sub(ktime_get(),",
          "1299:          transaction->t_start_time));",
          "",
          "[Removed Lines]",
          "1294:   spin_lock(&journal->j_state_lock);",
          "1296:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1337:   read_lock(&journal->j_state_lock);",
          "1339:   read_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1314:  if (handle->h_sync)",
          "1315:   transaction->t_synchronous_commit = 1;",
          "1316:  current->journal_info = NULL;",
          "",
          "[Removed Lines]",
          "1317:  spin_lock(&transaction->t_handle_lock);",
          "1318:  transaction->t_outstanding_credits -= handle->h_buffer_credits;",
          "1319:  transaction->t_updates--;",
          "1320:  if (!transaction->t_updates) {",
          "1321:   wake_up(&journal->j_wait_updates);",
          "1322:   if (journal->j_barrier_count)",
          "1323:    wake_up(&journal->j_wait_transaction_locked);",
          "1324:  }",
          "",
          "[Added Lines]",
          "1360:  atomic_sub(handle->h_buffer_credits,",
          "1361:      &transaction->t_outstanding_credits);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1332:  if (handle->h_sync ||",
          "1342:   jbd_debug(2, \"transaction too old, requesting commit for \"",
          "1343:      \"handle %p\\n\", handle);",
          "",
          "[Removed Lines]",
          "1333:    transaction->t_outstanding_credits >",
          "1334:     journal->j_max_transaction_buffers ||",
          "1335:    time_after_eq(jiffies, transaction->t_expires)) {",
          "1339:   tid_t tid = transaction->t_tid;",
          "1341:   spin_unlock(&transaction->t_handle_lock);",
          "",
          "[Added Lines]",
          "1370:      (atomic_read(&transaction->t_outstanding_credits) >",
          "1371:       journal->j_max_transaction_buffers) ||",
          "1372:      time_after_eq(jiffies, transaction->t_expires)) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1351:   if (handle->h_sync && !(current->flags & PF_MEMALLOC))",
          "1355:  }",
          "1357:  lock_map_release(&handle->h_lockdep_map);",
          "1359:  jbd2_free_handle(handle);",
          "",
          "[Removed Lines]",
          "1352:    err = jbd2_log_wait_commit(journal, tid);",
          "1353:  } else {",
          "1354:   spin_unlock(&transaction->t_handle_lock);",
          "",
          "[Added Lines]",
          "1387:    wait_for_commit = 1;",
          "1396:  tid = transaction->t_tid;",
          "1397:  if (atomic_dec_and_test(&transaction->t_updates)) {",
          "1398:   wake_up(&journal->j_wait_updates);",
          "1399:   if (journal->j_barrier_count)",
          "1400:    wake_up(&journal->j_wait_transaction_locked);",
          "1401:  }",
          "1403:  if (wait_for_commit)",
          "1404:   err = jbd2_log_wait_commit(journal, tid);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1719:   goto zap_buffer_unlocked;",
          "1723:  jbd_lock_bh_state(bh);",
          "1724:  spin_lock(&journal->j_list_lock);",
          "",
          "[Removed Lines]",
          "1722:  spin_lock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1771:  write_lock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1772:    jbd2_journal_put_journal_head(jh);",
          "1773:    spin_unlock(&journal->j_list_lock);",
          "1774:    jbd_unlock_bh_state(bh);",
          "1776:    return ret;",
          "1777:   } else {",
          "",
          "[Removed Lines]",
          "1775:    spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1824:    write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1786:     jbd2_journal_put_journal_head(jh);",
          "1787:     spin_unlock(&journal->j_list_lock);",
          "1788:     jbd_unlock_bh_state(bh);",
          "1790:     return ret;",
          "1791:    } else {",
          "",
          "[Removed Lines]",
          "1789:     spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1838:     write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1810:   jbd2_journal_put_journal_head(jh);",
          "1811:   spin_unlock(&journal->j_list_lock);",
          "1812:   jbd_unlock_bh_state(bh);",
          "1814:   return 0;",
          "1815:  } else {",
          "",
          "[Removed Lines]",
          "1813:   spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1862:   write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1829: zap_buffer_no_jh:",
          "1830:  spin_unlock(&journal->j_list_lock);",
          "1831:  jbd_unlock_bh_state(bh);",
          "1833: zap_buffer_unlocked:",
          "1834:  clear_buffer_dirty(bh);",
          "1835:  J_ASSERT_BH(bh, !buffer_jbddirty(bh));",
          "",
          "[Removed Lines]",
          "1832:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "1881:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2140:  commit_trans = journal->j_committing_transaction;",
          "2142:  spin_lock(&journal->j_list_lock);",
          "2143:  inode_trans = jinode->i_transaction;",
          "2144:  spin_unlock(&journal->j_list_lock);",
          "",
          "[Removed Lines]",
          "2139:  spin_lock(&journal->j_state_lock);",
          "2141:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "2188:  read_lock(&journal->j_state_lock);",
          "2190:  read_unlock(&journal->j_state_lock);",
          "",
          "---------------"
        ],
        "fs/ocfs2/journal.c||fs/ocfs2/journal.c": [
          "File: fs/ocfs2/journal.c -> fs/ocfs2/journal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "760:  if (osb->osb_commit_interval)",
          "761:   commit_interval = osb->osb_commit_interval;",
          "764:  journal->j_commit_interval = commit_interval;",
          "765:  if (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)",
          "766:   journal->j_flags |= JBD2_BARRIER;",
          "767:  else",
          "768:   journal->j_flags &= ~JBD2_BARRIER;",
          "770: }",
          "772: int ocfs2_journal_init(struct ocfs2_journal *journal, int *dirty)",
          "",
          "[Removed Lines]",
          "763:  spin_lock(&journal->j_state_lock);",
          "769:  spin_unlock(&journal->j_state_lock);",
          "",
          "[Added Lines]",
          "763:  write_lock(&journal->j_state_lock);",
          "769:  write_unlock(&journal->j_state_lock);",
          "",
          "---------------"
        ],
        "include/linux/jbd2.h||include/linux/jbd2.h": [
          "File: include/linux/jbd2.h -> include/linux/jbd2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "604:  int   t_updates;",
          "610:  int   t_outstanding_credits;",
          "",
          "[Added Lines]",
          "604:  atomic_t  t_updates;",
          "610:  atomic_t  t_outstanding_credits;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "632:  int t_handle_count;",
          "",
          "[Added Lines]",
          "632:  atomic_t  t_handle_count;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "767:  spinlock_t  j_state_lock;",
          "",
          "[Added Lines]",
          "767:  rwlock_t  j_state_lock;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1084: extern handle_t *jbd2_journal_start(journal_t *, int nblocks);",
          "1086: extern int  jbd2_journal_extend (handle_t *, int nblocks);",
          "1087: extern int  jbd2_journal_get_write_access(handle_t *, struct buffer_head *);",
          "1088: extern int  jbd2_journal_get_create_access (handle_t *, struct buffer_head *);",
          "",
          "[Removed Lines]",
          "1085: extern int  jbd2_journal_restart (handle_t *, int nblocks);",
          "",
          "[Added Lines]",
          "1085: extern handle_t *jbd2__journal_start(journal_t *, int nblocks, int gfp_mask);",
          "1086: extern int  jbd2_journal_restart(handle_t *, int nblocks);",
          "1087: extern int  jbd2__journal_restart(handle_t *, int nblocks, int gfp_mask);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1257: {",
          "1258:  int nblocks = journal->j_max_transaction_buffers;",
          "1259:  if (journal->j_committing_transaction)",
          "1262:  return nblocks;",
          "1263: }",
          "",
          "[Removed Lines]",
          "1260:   nblocks += journal->j_committing_transaction->",
          "1261:      t_outstanding_credits;",
          "",
          "[Added Lines]",
          "1262:   nblocks += atomic_read(&journal->j_committing_transaction->",
          "1263:            t_outstanding_credits);",
          "",
          "---------------"
        ],
        "include/trace/events/ext4.h||include/trace/events/ext4.h": [
          "File: include/trace/events/ext4.h -> include/trace/events/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "395: );",
          "397: TRACE_EVENT(ext4_mb_release_inode_pa,",
          "399:    struct ext4_prealloc_space *pa,",
          "400:    unsigned long long block, unsigned int count),",
          "404:  TP_STRUCT__entry(",
          "405:   __field( dev_t, dev   )",
          "",
          "[Removed Lines]",
          "398:  TP_PROTO(struct ext4_allocation_context *ac,",
          "402:  TP_ARGS(ac, pa, block, count),",
          "",
          "[Added Lines]",
          "398:  TP_PROTO(struct super_block *sb,",
          "399:    struct ext4_allocation_context *ac,",
          "403:  TP_ARGS(sb, ac, pa, block, count),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "410:  ),",
          "412:  TP_fast_assign(",
          "415:   __entry->block  = block;",
          "416:   __entry->count  = count;",
          "417:  ),",
          "",
          "[Removed Lines]",
          "413:   __entry->dev  = ac->ac_sb->s_dev;",
          "414:   __entry->ino  = ac->ac_inode->i_ino;",
          "",
          "[Added Lines]",
          "414:   __entry->dev  = sb->s_dev;",
          "415:   __entry->ino  = (ac && ac->ac_inode) ?",
          "416:       ac->ac_inode->i_ino : 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "422: );",
          "424: TRACE_EVENT(ext4_mb_release_group_pa,",
          "426:    struct ext4_prealloc_space *pa),",
          "430:  TP_STRUCT__entry(",
          "431:   __field( dev_t, dev   )",
          "",
          "[Removed Lines]",
          "425:  TP_PROTO(struct ext4_allocation_context *ac,",
          "428:  TP_ARGS(ac, pa),",
          "",
          "[Added Lines]",
          "427:  TP_PROTO(struct super_block *sb,",
          "428:    struct ext4_allocation_context *ac,",
          "431:  TP_ARGS(sb, ac, pa),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "436:  ),",
          "438:  TP_fast_assign(",
          "441:   __entry->pa_pstart = pa->pa_pstart;",
          "442:   __entry->pa_len  = pa->pa_len;",
          "443:  ),",
          "",
          "[Removed Lines]",
          "439:   __entry->dev  = ac->ac_sb->s_dev;",
          "440:   __entry->ino  = ac->ac_inode->i_ino;",
          "",
          "[Added Lines]",
          "442:   __entry->dev  = sb->s_dev;",
          "443:   __entry->ino  = (ac && ac->ac_inode) ?",
          "444:       ac->ac_inode->i_ino : 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd2d0210cf22f2bd0cef72eb97cf94fc7d31d8cc",
      "candidate_info": {
        "commit_hash": "bd2d0210cf22f2bd0cef72eb97cf94fc7d31d8cc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bd2d0210cf22f2bd0cef72eb97cf94fc7d31d8cc",
        "files": [
          "fs/ext4/Makefile",
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/inode.c",
          "fs/ext4/page-io.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: use bio layer instead of buffer layer in mpage_da_submit_io\n\nCall the block I/O layer directly instad of going through the buffer\nlayer.  This should give us much better performance and scalability,\nas well as lowering our CPU utilization when doing buffered writeback.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/page-io.c||fs/ext4/page-io.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:  int pages_written;",
          "169:  int retval;",
          "170: };",
          "172: typedef struct ext4_io_end {",
          "",
          "[Removed Lines]",
          "171: #define EXT4_IO_UNWRITTEN 0x1",
          "",
          "[Added Lines]",
          "175: #define EXT4_IO_END_UNWRITTEN 0x0001",
          "176: #define EXT4_IO_END_ERROR 0x0002",
          "178: struct ext4_io_page {",
          "179:  struct page *p_page;",
          "180:  int  p_count;",
          "181: };",
          "183: #define MAX_IO_PAGES 128",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "182: } ext4_io_end_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "195:  int   num_io_pages;",
          "196:  struct ext4_io_page *pages[MAX_IO_PAGES];",
          "199: struct ext4_io_submit {",
          "200:  int   io_op;",
          "201:  struct bio  *io_bio;",
          "202:  ext4_io_end_t  *io_end;",
          "203:  struct ext4_io_page *io_page;",
          "204:  sector_t  io_next_block;",
          "205: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2044:         __u64 start_orig, __u64 start_donor,",
          "2045:         __u64 len, __u64 *moved_len);",
          "2049: enum ext4_state_bits {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2071: extern int __init init_ext4_pageio(void);",
          "2072: extern void exit_ext4_pageio(void);",
          "2073: extern void ext4_free_io_end(ext4_io_end_t *io);",
          "2074: extern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);",
          "2075: extern int ext4_end_io_nolock(ext4_io_end_t *io);",
          "2076: extern void ext4_io_submit(struct ext4_io_submit *io);",
          "2077: extern int ext4_bio_write_page(struct ext4_io_submit *io,",
          "2078:           struct page *page,",
          "2079:           int len,",
          "2080:           struct writeback_control *wbc);",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3204:   if (io)",
          "3206:   else",
          "3207:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
          "3208:   if (ext4_should_dioread_nolock(inode))",
          "",
          "[Removed Lines]",
          "3205:    io->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3205:    io->flag = EXT4_IO_END_UNWRITTEN;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3495:   if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
          "3496:    if (io)",
          "3498:    else",
          "3499:     ext4_set_inode_state(inode,",
          "3500:            EXT4_STATE_DIO_UNWRITTEN);",
          "",
          "[Removed Lines]",
          "3497:     io->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3497:     io->flag = EXT4_IO_END_UNWRITTEN;",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2016:  struct buffer_head *bh, *page_bufs = NULL;",
          "2017:  int journal_data = ext4_should_journal_data(inode);",
          "2018:  sector_t pblock = 0, cur_logical = 0;",
          "2020:  BUG_ON(mpd->next_page <= mpd->first_page);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2019:  struct ext4_io_submit io_submit;",
          "2022:  memset(&io_submit, 0, sizeof(io_submit));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2110:     block_commit_write(page, 0, len);",
          "2113:     err = __ext4_journalled_writepage(page, len);",
          "2123:    if (!err)",
          "2124:     mpd->pages_written++;",
          "",
          "[Removed Lines]",
          "2112:    if (journal_data && PageChecked(page))",
          "2114:    else if (buffer_uninit(page_bufs)) {",
          "2115:     ext4_set_bh_endio(page_bufs, inode);",
          "2116:     err = block_write_full_page_endio(page,",
          "2117:      noalloc_get_block_write,",
          "2118:      mpd->wbc, ext4_end_io_buffer_write);",
          "2119:    } else",
          "2120:     err = block_write_full_page(page,",
          "2121:          noalloc_get_block_write, mpd->wbc);",
          "",
          "[Added Lines]",
          "2119:    if (unlikely(journal_data && PageChecked(page)))",
          "2121:    else",
          "2122:     err = ext4_bio_write_page(&io_submit, page,",
          "2123:          len, mpd->wbc);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2131:   }",
          "2132:   pagevec_release(&pvec);",
          "2133:  }",
          "2134:  return ret;",
          "2135: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2136:  ext4_io_submit(&io_submit);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3426:  return mpage_readpages(mapping, pages, nr_pages, ext4_get_block);",
          "3427: }",
          "3438: static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)",
          "3439: {",
          "3440:  struct buffer_head *head, *bh;",
          "",
          "[Removed Lines]",
          "3429: static void ext4_free_io_end(ext4_io_end_t *io)",
          "3430: {",
          "3431:  BUG_ON(!io);",
          "3432:  if (io->page)",
          "3433:   put_page(io->page);",
          "3434:  iput(io->inode);",
          "3435:  kfree(io);",
          "3436: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3639: #endif",
          "3640: }",
          "",
          "[Removed Lines]",
          "3645: static int ext4_end_io_nolock(ext4_io_end_t *io)",
          "3646: {",
          "3647:  struct inode *inode = io->inode;",
          "3648:  loff_t offset = io->offset;",
          "3649:  ssize_t size = io->size;",
          "3650:  int ret = 0;",
          "3652:  ext4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "3653:      \"list->prev 0x%p\\n\",",
          "3654:             io, inode->i_ino, io->list.next, io->list.prev);",
          "3656:  if (list_empty(&io->list))",
          "3657:   return ret;",
          "3659:  if (io->flag != EXT4_IO_UNWRITTEN)",
          "3660:   return ret;",
          "3662:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
          "3663:  if (ret < 0) {",
          "3664:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
          "3665:    \"extents to written extents, error is %d\"",
          "3666:    \" io is still on inode %lu aio dio list\\n\",",
          "3667:                        __func__, ret, inode->i_ino);",
          "3668:   return ret;",
          "3669:  }",
          "3671:  if (io->iocb)",
          "3672:   aio_complete(io->iocb, io->result, 0);",
          "3674:  io->flag = 0;",
          "3675:  return ret;",
          "3676: }",
          "3681: static void ext4_end_io_work(struct work_struct *work)",
          "3682: {",
          "3683:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
          "3684:  struct inode  *inode = io->inode;",
          "3685:  struct ext4_inode_info *ei = EXT4_I(inode);",
          "3686:  unsigned long  flags;",
          "3687:  int   ret;",
          "3689:  mutex_lock(&inode->i_mutex);",
          "3690:  ret = ext4_end_io_nolock(io);",
          "3691:  if (ret < 0) {",
          "3692:   mutex_unlock(&inode->i_mutex);",
          "3693:   return;",
          "3694:  }",
          "3696:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
          "3697:  if (!list_empty(&io->list))",
          "3698:   list_del_init(&io->list);",
          "3699:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
          "3700:  mutex_unlock(&inode->i_mutex);",
          "3701:  ext4_free_io_end(io);",
          "3702: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3756:  return (ret2 < 0) ? ret2 : 0;",
          "3757: }",
          "3781: static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,",
          "3782:        ssize_t size, void *private, int ret,",
          "3783:        bool is_async)",
          "",
          "[Removed Lines]",
          "3759: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)",
          "3760: {",
          "3761:  ext4_io_end_t *io = NULL;",
          "3763:  io = kmalloc(sizeof(*io), flags);",
          "3765:  if (io) {",
          "3766:   igrab(inode);",
          "3767:   io->inode = inode;",
          "3768:   io->flag = 0;",
          "3769:   io->offset = 0;",
          "3770:   io->size = 0;",
          "3771:   io->page = NULL;",
          "3772:   io->iocb = NULL;",
          "3773:   io->result = 0;",
          "3774:   INIT_WORK(&io->work, ext4_end_io_work);",
          "3775:   INIT_LIST_HEAD(&io->list);",
          "3776:  }",
          "3778:  return io;",
          "3779: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3797:     size);",
          "3801:   ext4_free_io_end(io_end);",
          "3802:   iocb->private = NULL;",
          "3803: out:",
          "",
          "[Removed Lines]",
          "3800:  if (io_end->flag != EXT4_IO_UNWRITTEN){",
          "",
          "[Added Lines]",
          "3710:  if (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3842:   goto out;",
          "3843:  }",
          "3846:  inode = io_end->inode;",
          "",
          "[Removed Lines]",
          "3845:  io_end->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3755:  io_end->flag = EXT4_IO_END_UNWRITTEN;",
          "",
          "---------------"
        ],
        "fs/ext4/page-io.c||fs/ext4/page-io.c": [
          "File: fs/ext4/page-io.c -> fs/ext4/page-io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include <linux/module.h>",
          "10: #include <linux/fs.h>",
          "11: #include <linux/time.h>",
          "12: #include <linux/jbd2.h>",
          "13: #include <linux/highuid.h>",
          "14: #include <linux/pagemap.h>",
          "15: #include <linux/quotaops.h>",
          "16: #include <linux/string.h>",
          "17: #include <linux/buffer_head.h>",
          "18: #include <linux/writeback.h>",
          "19: #include <linux/pagevec.h>",
          "20: #include <linux/mpage.h>",
          "21: #include <linux/namei.h>",
          "22: #include <linux/uio.h>",
          "23: #include <linux/bio.h>",
          "24: #include <linux/workqueue.h>",
          "25: #include <linux/kernel.h>",
          "26: #include <linux/slab.h>",
          "28: #include \"ext4_jbd2.h\"",
          "29: #include \"xattr.h\"",
          "30: #include \"acl.h\"",
          "31: #include \"ext4_extents.h\"",
          "33: static struct kmem_cache *io_page_cachep, *io_end_cachep;",
          "35: int __init init_ext4_pageio(void)",
          "36: {",
          "37:  io_page_cachep = KMEM_CACHE(ext4_io_page, SLAB_RECLAIM_ACCOUNT);",
          "38:  if (io_page_cachep == NULL)",
          "39:   return -ENOMEM;",
          "40:  io_end_cachep = KMEM_CACHE(ext4_io_end, SLAB_RECLAIM_ACCOUNT);",
          "41:  if (io_page_cachep == NULL) {",
          "42:   kmem_cache_destroy(io_page_cachep);",
          "43:   return -ENOMEM;",
          "44:  }",
          "46:  return 0;",
          "47: }",
          "49: void exit_ext4_pageio(void)",
          "50: {",
          "51:  kmem_cache_destroy(io_end_cachep);",
          "52:  kmem_cache_destroy(io_page_cachep);",
          "53: }",
          "55: void ext4_free_io_end(ext4_io_end_t *io)",
          "56: {",
          "57:  int i;",
          "59:  BUG_ON(!io);",
          "60:  if (io->page)",
          "61:   put_page(io->page);",
          "62:  for (i = 0; i < io->num_io_pages; i++) {",
          "63:   if (--io->pages[i]->p_count == 0) {",
          "64:    struct page *page = io->pages[i]->p_page;",
          "66:    end_page_writeback(page);",
          "67:    put_page(page);",
          "68:    kmem_cache_free(io_page_cachep, io->pages[i]);",
          "69:   }",
          "70:  }",
          "71:  io->num_io_pages = 0;",
          "72:  iput(io->inode);",
          "73:  kmem_cache_free(io_end_cachep, io);",
          "74: }",
          "79: int ext4_end_io_nolock(ext4_io_end_t *io)",
          "80: {",
          "81:  struct inode *inode = io->inode;",
          "82:  loff_t offset = io->offset;",
          "83:  ssize_t size = io->size;",
          "84:  int ret = 0;",
          "86:  ext4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "87:      \"list->prev 0x%p\\n\",",
          "88:      io, inode->i_ino, io->list.next, io->list.prev);",
          "90:  if (list_empty(&io->list))",
          "91:   return ret;",
          "93:  if (!(io->flag & EXT4_IO_END_UNWRITTEN))",
          "94:   return ret;",
          "96:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
          "97:  if (ret < 0) {",
          "98:   printk(KERN_EMERG \"%s: failed to convert unwritten \"",
          "99:    \"extents to written extents, error is %d \"",
          "100:    \"io is still on inode %lu aio dio list\\n\",",
          "101:          __func__, ret, inode->i_ino);",
          "102:   return ret;",
          "103:  }",
          "105:  if (io->iocb)",
          "106:   aio_complete(io->iocb, io->result, 0);",
          "108:  io->flag &= ~EXT4_IO_END_UNWRITTEN;",
          "109:  return ret;",
          "110: }",
          "115: static void ext4_end_io_work(struct work_struct *work)",
          "116: {",
          "117:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
          "118:  struct inode  *inode = io->inode;",
          "119:  struct ext4_inode_info *ei = EXT4_I(inode);",
          "120:  unsigned long  flags;",
          "121:  int   ret;",
          "123:  mutex_lock(&inode->i_mutex);",
          "124:  ret = ext4_end_io_nolock(io);",
          "125:  if (ret < 0) {",
          "126:   mutex_unlock(&inode->i_mutex);",
          "127:   return;",
          "128:  }",
          "130:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
          "131:  if (!list_empty(&io->list))",
          "132:   list_del_init(&io->list);",
          "133:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
          "134:  mutex_unlock(&inode->i_mutex);",
          "135:  ext4_free_io_end(io);",
          "136: }",
          "138: ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)",
          "139: {",
          "140:  ext4_io_end_t *io = NULL;",
          "142:  io = kmem_cache_alloc(io_end_cachep, flags);",
          "143:  if (io) {",
          "144:   memset(io, 0, sizeof(*io));",
          "145:   io->inode = igrab(inode);",
          "146:   BUG_ON(!io->inode);",
          "147:   INIT_WORK(&io->work, ext4_end_io_work);",
          "148:   INIT_LIST_HEAD(&io->list);",
          "149:  }",
          "150:  return io;",
          "151: }",
          "160: static void buffer_io_error(struct buffer_head *bh)",
          "161: {",
          "162:  char b[BDEVNAME_SIZE];",
          "163:  printk(KERN_ERR \"Buffer I/O error on device %s, logical block %llu\\n\",",
          "164:    bdevname(bh->b_bdev, b),",
          "165:    (unsigned long long)bh->b_blocknr);",
          "166: }",
          "168: static void ext4_end_bio(struct bio *bio, int error)",
          "169: {",
          "170:  ext4_io_end_t *io_end = bio->bi_private;",
          "171:  struct workqueue_struct *wq;",
          "172:  struct inode *inode;",
          "173:  unsigned long flags;",
          "174:  ext4_fsblk_t err_block;",
          "175:  int i;",
          "177:  BUG_ON(!io_end);",
          "178:  inode = io_end->inode;",
          "179:  bio->bi_private = NULL;",
          "180:  bio->bi_end_io = NULL;",
          "181:  if (test_bit(BIO_UPTODATE, &bio->bi_flags))",
          "182:   error = 0;",
          "183:  err_block = bio->bi_sector >> (inode->i_blkbits - 9);",
          "184:  bio_put(bio);",
          "186:  if (!(inode->i_sb->s_flags & MS_ACTIVE)) {",
          "187:   pr_err(\"sb umounted, discard end_io request for inode %lu\\n\",",
          "188:    io_end->inode->i_ino);",
          "189:   ext4_free_io_end(io_end);",
          "190:   return;",
          "191:  }",
          "193:  if (error) {",
          "194:   io_end->flag |= EXT4_IO_END_ERROR;",
          "195:   ext4_warning(inode->i_sb, \"I/O error writing to inode %lu \"",
          "196:         \"(offset %llu size %ld starting block %llu)\",",
          "197:         inode->i_ino,",
          "198:         (unsigned long long) io_end->offset,",
          "199:         (long) io_end->size,",
          "200:         (unsigned long long) err_block);",
          "201:  }",
          "203:  for (i = 0; i < io_end->num_io_pages; i++) {",
          "204:   struct page *page = io_end->pages[i]->p_page;",
          "205:   struct buffer_head *bh, *head;",
          "206:   int partial_write = 0;",
          "208:   head = page_buffers(page);",
          "209:   if (error)",
          "210:    SetPageError(page);",
          "211:   BUG_ON(!head);",
          "212:   if (head->b_size == PAGE_CACHE_SIZE)",
          "213:    clear_buffer_dirty(head);",
          "214:   else {",
          "215:    loff_t offset;",
          "216:    loff_t io_end_offset = io_end->offset + io_end->size;",
          "218:    offset = (sector_t) page->index << PAGE_CACHE_SHIFT;",
          "219:    bh = head;",
          "220:    do {",
          "221:     if ((offset >= io_end->offset) &&",
          "222:         (offset+bh->b_size <= io_end_offset)) {",
          "223:      if (error)",
          "224:       buffer_io_error(bh);",
          "226:      clear_buffer_dirty(bh);",
          "227:     }",
          "228:     if (buffer_delay(bh))",
          "229:      partial_write = 1;",
          "230:     else if (!buffer_mapped(bh))",
          "231:      clear_buffer_dirty(bh);",
          "232:     else if (buffer_dirty(bh))",
          "233:      partial_write = 1;",
          "234:     offset += bh->b_size;",
          "235:     bh = bh->b_this_page;",
          "236:    } while (bh != head);",
          "237:   }",
          "239:   if (--io_end->pages[i]->p_count == 0) {",
          "240:    struct page *page = io_end->pages[i]->p_page;",
          "242:    end_page_writeback(page);",
          "243:    put_page(page);",
          "244:    kmem_cache_free(io_page_cachep, io_end->pages[i]);",
          "245:   }",
          "254:   if (!partial_write)",
          "255:    SetPageUptodate(page);",
          "256:  }",
          "258:  io_end->num_io_pages = 0;",
          "261:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
          "262:  list_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);",
          "263:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
          "265:  wq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;",
          "267:  queue_work(wq, &io_end->work);",
          "268: }",
          "270: void ext4_io_submit(struct ext4_io_submit *io)",
          "271: {",
          "272:  struct bio *bio = io->io_bio;",
          "274:  if (bio) {",
          "275:   bio_get(io->io_bio);",
          "276:   submit_bio(io->io_op, io->io_bio);",
          "277:   BUG_ON(bio_flagged(io->io_bio, BIO_EOPNOTSUPP));",
          "278:   bio_put(io->io_bio);",
          "279:  }",
          "280:  io->io_bio = 0;",
          "281:  io->io_op = 0;",
          "282:  io->io_end = 0;",
          "283: }",
          "285: static int io_submit_init(struct ext4_io_submit *io,",
          "286:      struct inode *inode,",
          "287:      struct writeback_control *wbc,",
          "288:      struct buffer_head *bh)",
          "289: {",
          "290:  ext4_io_end_t *io_end;",
          "291:  struct page *page = bh->b_page;",
          "292:  int nvecs = bio_get_nr_vecs(bh->b_bdev);",
          "293:  struct bio *bio;",
          "295:  io_end = ext4_init_io_end(inode, GFP_NOFS);",
          "296:  if (!io_end)",
          "297:   return -ENOMEM;",
          "298:  do {",
          "299:   bio = bio_alloc(GFP_NOIO, nvecs);",
          "300:   nvecs >>= 1;",
          "301:  } while (bio == NULL);",
          "303:  bio->bi_sector = bh->b_blocknr * (bh->b_size >> 9);",
          "304:  bio->bi_bdev = bh->b_bdev;",
          "305:  bio->bi_private = io->io_end = io_end;",
          "306:  bio->bi_end_io = ext4_end_bio;",
          "308:  io_end->inode = inode;",
          "309:  io_end->offset = (page->index << PAGE_CACHE_SHIFT) + bh_offset(bh);",
          "311:  io->io_bio = bio;",
          "312:  io->io_op = (wbc->sync_mode == WB_SYNC_ALL ?",
          "313:    WRITE_SYNC_PLUG : WRITE);",
          "314:  io->io_next_block = bh->b_blocknr;",
          "315:  return 0;",
          "316: }",
          "318: static int io_submit_add_bh(struct ext4_io_submit *io,",
          "319:        struct ext4_io_page *io_page,",
          "320:        struct inode *inode,",
          "321:        struct writeback_control *wbc,",
          "322:        struct buffer_head *bh)",
          "323: {",
          "324:  ext4_io_end_t *io_end;",
          "325:  int ret;",
          "327:  if (buffer_new(bh)) {",
          "328:   clear_buffer_new(bh);",
          "329:   unmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);",
          "330:  }",
          "332:  if (!buffer_mapped(bh) || buffer_delay(bh)) {",
          "333:   if (!buffer_mapped(bh))",
          "334:    clear_buffer_dirty(bh);",
          "335:   if (io->io_bio)",
          "336:    ext4_io_submit(io);",
          "337:   return 0;",
          "338:  }",
          "340:  if (io->io_bio && bh->b_blocknr != io->io_next_block) {",
          "341: submit_and_retry:",
          "342:   ext4_io_submit(io);",
          "343:  }",
          "344:  if (io->io_bio == NULL) {",
          "345:   ret = io_submit_init(io, inode, wbc, bh);",
          "346:   if (ret)",
          "347:    return ret;",
          "348:  }",
          "349:  io_end = io->io_end;",
          "350:  if ((io_end->num_io_pages >= MAX_IO_PAGES) &&",
          "351:      (io_end->pages[io_end->num_io_pages-1] != io_page))",
          "352:   goto submit_and_retry;",
          "353:  if (buffer_uninit(bh))",
          "354:   io->io_end->flag |= EXT4_IO_END_UNWRITTEN;",
          "355:  io->io_end->size += bh->b_size;",
          "356:  io->io_next_block++;",
          "357:  ret = bio_add_page(io->io_bio, bh->b_page, bh->b_size, bh_offset(bh));",
          "358:  if (ret != bh->b_size)",
          "359:   goto submit_and_retry;",
          "360:  if ((io_end->num_io_pages == 0) ||",
          "361:      (io_end->pages[io_end->num_io_pages-1] != io_page)) {",
          "362:   io_end->pages[io_end->num_io_pages++] = io_page;",
          "363:   io_page->p_count++;",
          "364:  }",
          "365:  return 0;",
          "366: }",
          "368: int ext4_bio_write_page(struct ext4_io_submit *io,",
          "369:    struct page *page,",
          "370:    int len,",
          "371:    struct writeback_control *wbc)",
          "372: {",
          "373:  struct inode *inode = page->mapping->host;",
          "374:  unsigned block_start, block_end, blocksize;",
          "375:  struct ext4_io_page *io_page;",
          "376:  struct buffer_head *bh, *head;",
          "377:  int ret = 0;",
          "379:  blocksize = 1 << inode->i_blkbits;",
          "381:  BUG_ON(PageWriteback(page));",
          "382:  set_page_writeback(page);",
          "383:  ClearPageError(page);",
          "385:  io_page = kmem_cache_alloc(io_page_cachep, GFP_NOFS);",
          "386:  if (!io_page) {",
          "387:   set_page_dirty(page);",
          "388:   unlock_page(page);",
          "389:   return -ENOMEM;",
          "390:  }",
          "391:  io_page->p_page = page;",
          "392:  io_page->p_count = 0;",
          "393:  get_page(page);",
          "395:  for (bh = head = page_buffers(page), block_start = 0;",
          "396:       bh != head || !block_start;",
          "397:       block_start = block_end, bh = bh->b_this_page) {",
          "398:   block_end = block_start + blocksize;",
          "399:   if (block_start >= len) {",
          "400:    clear_buffer_dirty(bh);",
          "401:    set_buffer_uptodate(bh);",
          "402:    continue;",
          "403:   }",
          "404:   ret = io_submit_add_bh(io, io_page, inode, wbc, bh);",
          "405:   if (ret) {",
          "411:    set_page_dirty(page);",
          "412:    break;",
          "413:   }",
          "414:  }",
          "415:  unlock_page(page);",
          "424:  if (io_page->p_count == 0) {",
          "425:   put_page(page);",
          "426:   end_page_writeback(page);",
          "427:   kmem_cache_free(io_page_cachep, io_page);",
          "428:  }",
          "429:  return ret;",
          "430: }",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4769:  int err;",
          "4771:  ext4_check_flag_values();",
          "4773:  if (err)",
          "4774:   return err;",
          "4775:  ext4_kset = kset_create_and_add(\"ext4\", NULL, fs_kobj);",
          "4776:  if (!ext4_kset)",
          "4777:   goto out4;",
          "",
          "[Removed Lines]",
          "4772:  err = init_ext4_system_zone();",
          "",
          "[Added Lines]",
          "4772:  err = init_ext4_pageio();",
          "4775:  err = init_ext4_system_zone();",
          "4776:  if (err)",
          "4777:   goto out5;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4812:  kset_unregister(ext4_kset);",
          "4813: out4:",
          "4814:  exit_ext4_system_zone();",
          "4815:  return err;",
          "4816: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4818: out5:",
          "4819:  exit_ext4_pageio();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4827:  remove_proc_entry(\"fs/ext4\", NULL);",
          "4828:  kset_unregister(ext4_kset);",
          "4829:  exit_ext4_system_zone();",
          "4830: }",
          "4832: MODULE_AUTHOR(\"Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4835:  exit_ext4_pageio();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "21ca087a3891efab4d45488db8febee474d26c68",
      "candidate_info": {
        "commit_hash": "21ca087a3891efab4d45488db8febee474d26c68",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/21ca087a3891efab4d45488db8febee474d26c68",
        "files": [
          "fs/ext4/extents.c"
        ],
        "message": "ext4: Do not zero out uninitialized extents beyond i_size\n\nThe extents code will sometimes zero out blocks and mark them as\ninitialized instead of splitting an extent into several smaller ones.\nThis optimization however, causes problems if the extent is beyond\ni_size because fsck will complain if there are uninitialized blocks\nafter i_size as this can not be distinguished from an inode that has\nan incorrect i_size field.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=15742\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/extents.c||fs/ext4/extents.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2631:  struct ext4_extent *ex2 = NULL;",
          "2632:  struct ext4_extent *ex3 = NULL;",
          "2633:  struct ext4_extent_header *eh;",
          "2635:  unsigned int allocated, ee_len, depth;",
          "2636:  ext4_fsblk_t newblock;",
          "2637:  int err = 0;",
          "2638:  int ret = 0;",
          "2640:  depth = ext_depth(inode);",
          "2641:  eh = path[depth].p_hdr;",
          "",
          "[Removed Lines]",
          "2634:  ext4_lblk_t ee_block;",
          "",
          "[Added Lines]",
          "2634:  ext4_lblk_t ee_block, eof_block;",
          "2639:  int may_zeroout;",
          "2641:  ext_debug(\"ext4_ext_convert_to_initialized: inode %lu, logical\"",
          "2642:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
          "2643:   (unsigned long long)iblock, max_blocks);",
          "2645:  eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>",
          "2646:   inode->i_sb->s_blocksize_bits;",
          "2647:  if (eof_block < iblock + max_blocks)",
          "2648:   eof_block = iblock + max_blocks;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2644:  ee_len = ext4_ext_get_actual_len(ex);",
          "2645:  allocated = ee_len - (iblock - ee_block);",
          "2646:  newblock = iblock - ee_block + ext_pblock(ex);",
          "2647:  ex2 = ex;",
          "2648:  orig_ex.ee_block = ex->ee_block;",
          "2649:  orig_ex.ee_len   = cpu_to_le16(ee_len);",
          "2650:  ext4_ext_store_pblock(&orig_ex, ext_pblock(ex));",
          "2652:  err = ext4_ext_get_access(handle, inode, path + depth);",
          "2653:  if (err)",
          "2654:   goto out;",
          "2657:   err =  ext4_ext_zeroout(inode, &orig_ex);",
          "2658:   if (err)",
          "2659:    goto fix_extent_len;",
          "",
          "[Removed Lines]",
          "2656:  if (ee_len <= 2*EXT4_EXT_ZERO_LEN) {",
          "",
          "[Added Lines]",
          "2667:  may_zeroout = ee_block + ee_len <= eof_block;",
          "2673:  if (ee_len <= 2*EXT4_EXT_ZERO_LEN && may_zeroout) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2684:  if (allocated > max_blocks) {",
          "2685:   unsigned int newdepth;",
          "",
          "[Removed Lines]",
          "2687:   if (allocated <= EXT4_EXT_ZERO_LEN) {",
          "",
          "[Added Lines]",
          "2704:   if (allocated <= EXT4_EXT_ZERO_LEN && may_zeroout) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2760:   ex3->ee_len = cpu_to_le16(allocated - max_blocks);",
          "2761:   ext4_ext_mark_uninitialized(ex3);",
          "2762:   err = ext4_ext_insert_extent(handle, inode, path, ex3, 0);",
          "2764:    err =  ext4_ext_zeroout(inode, &orig_ex);",
          "2765:    if (err)",
          "2766:     goto fix_extent_len;",
          "",
          "[Removed Lines]",
          "2763:   if (err == -ENOSPC) {",
          "",
          "[Added Lines]",
          "2780:   if (err == -ENOSPC && may_zeroout) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2789:   depth = newdepth;",
          "2790:   ext4_ext_drop_refs(path);",
          "2791:   path = ext4_ext_find_extent(inode, iblock, path);",
          "",
          "[Removed Lines]",
          "2787:   orig_ex.ee_len = cpu_to_le16(ee_len -",
          "2788:       ext4_ext_get_actual_len(ex3));",
          "",
          "[Added Lines]",
          "2804:   ee_len -= ext4_ext_get_actual_len(ex3);",
          "2805:   orig_ex.ee_len = cpu_to_le16(ee_len);",
          "2806:   may_zeroout = ee_block + ee_len <= eof_block;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2811:   if (le16_to_cpu(orig_ex.ee_len) <= EXT4_EXT_ZERO_LEN &&",
          "2813:    err =  ext4_ext_zeroout(inode, &orig_ex);",
          "2814:    if (err)",
          "2815:     goto fix_extent_len;",
          "",
          "[Removed Lines]",
          "2812:        iblock != ee_block) {",
          "",
          "[Added Lines]",
          "2831:    iblock != ee_block && may_zeroout) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2878:  goto out;",
          "2879: insert:",
          "2880:  err = ext4_ext_insert_extent(handle, inode, path, &newex, 0);",
          "2882:   err =  ext4_ext_zeroout(inode, &orig_ex);",
          "2883:   if (err)",
          "2884:    goto fix_extent_len;",
          "",
          "[Removed Lines]",
          "2881:  if (err == -ENOSPC) {",
          "",
          "[Added Lines]",
          "2900:  if (err == -ENOSPC && may_zeroout) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2938:  struct ext4_extent *ex2 = NULL;",
          "2939:  struct ext4_extent *ex3 = NULL;",
          "2940:  struct ext4_extent_header *eh;",
          "2942:  unsigned int allocated, ee_len, depth;",
          "2943:  ext4_fsblk_t newblock;",
          "2944:  int err = 0;",
          "2949:  depth = ext_depth(inode);",
          "2950:  eh = path[depth].p_hdr;",
          "2951:  ex = path[depth].p_ext;",
          "",
          "[Removed Lines]",
          "2941:  ext4_lblk_t ee_block;",
          "2946:  ext_debug(\"ext4_split_unwritten_extents: inode %lu,\"",
          "2947:     \"iblock %llu, max_blocks %u\\n\", inode->i_ino,",
          "2948:     (unsigned long long)iblock, max_blocks);",
          "",
          "[Added Lines]",
          "2960:  ext4_lblk_t ee_block, eof_block;",
          "2964:  int may_zeroout;",
          "2966:  ext_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"",
          "2967:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
          "2968:   (unsigned long long)iblock, max_blocks);",
          "2970:  eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>",
          "2971:   inode->i_sb->s_blocksize_bits;",
          "2972:  if (eof_block < iblock + max_blocks)",
          "2973:   eof_block = iblock + max_blocks;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2953:  ee_len = ext4_ext_get_actual_len(ex);",
          "2954:  allocated = ee_len - (iblock - ee_block);",
          "2955:  newblock = iblock - ee_block + ext_pblock(ex);",
          "2956:  ex2 = ex;",
          "2957:  orig_ex.ee_block = ex->ee_block;",
          "2958:  orig_ex.ee_len   = cpu_to_le16(ee_len);",
          "2959:  ext4_ext_store_pblock(&orig_ex, ext_pblock(ex));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2992:  may_zeroout = ee_block + ee_len <= eof_block;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2992:   ex3->ee_len = cpu_to_le16(allocated - max_blocks);",
          "2993:   ext4_ext_mark_uninitialized(ex3);",
          "2994:   err = ext4_ext_insert_extent(handle, inode, path, ex3, flags);",
          "2996:    err =  ext4_ext_zeroout(inode, &orig_ex);",
          "2997:    if (err)",
          "2998:     goto fix_extent_len;",
          "",
          "[Removed Lines]",
          "2995:   if (err == -ENOSPC) {",
          "",
          "[Added Lines]",
          "3028:   if (err == -ENOSPC && may_zeroout) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3021:   depth = newdepth;",
          "3022:   ext4_ext_drop_refs(path);",
          "3023:   path = ext4_ext_find_extent(inode, iblock, path);",
          "",
          "[Removed Lines]",
          "3019:   orig_ex.ee_len = cpu_to_le16(ee_len -",
          "3020:       ext4_ext_get_actual_len(ex3));",
          "",
          "[Added Lines]",
          "3052:   ee_len -= ext4_ext_get_actual_len(ex3);",
          "3053:   orig_ex.ee_len = cpu_to_le16(ee_len);",
          "3054:   may_zeroout = ee_block + ee_len <= eof_block;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3063:  goto out;",
          "3064: insert:",
          "3065:  err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);",
          "3067:   err =  ext4_ext_zeroout(inode, &orig_ex);",
          "3068:   if (err)",
          "3069:    goto fix_extent_len;",
          "",
          "[Removed Lines]",
          "3066:  if (err == -ENOSPC) {",
          "",
          "[Added Lines]",
          "3101:  if (err == -ENOSPC && may_zeroout) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e35fd6609b2fee54484d520deccb8f18bf7d38f3",
      "candidate_info": {
        "commit_hash": "e35fd6609b2fee54484d520deccb8f18bf7d38f3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e35fd6609b2fee54484d520deccb8f18bf7d38f3",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/inode.c"
        ],
        "message": "ext4: Add new abstraction ext4_map_blocks() underneath ext4_get_blocks()\n\nJack up ext4_get_blocks() and add a new function, ext4_map_blocks()\nwhich uses a much smaller structure, struct ext4_map_blocks which is\n20 bytes, as opposed to a struct buffer_head, which nearly 5 times\nbigger on an x86_64 machine.  By switching things to use\next4_map_blocks(), we can save stack space by using ext4_map_blocks()\nsince we can avoid allocating a struct buffer_head on the stack.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "125:  unsigned int flags;",
          "126: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "135: #define EXT4_MAP_NEW  (1 << BH_New)",
          "136: #define EXT4_MAP_MAPPED  (1 << BH_Mapped)",
          "137: #define EXT4_MAP_UNWRITTEN (1 << BH_Unwritten)",
          "138: #define EXT4_MAP_BOUNDARY (1 << BH_Boundary)",
          "139: #define EXT4_MAP_UNINIT  (1 << BH_Uninit)",
          "140: #define EXT4_MAP_FLAGS  (EXT4_MAP_NEW | EXT4_MAP_MAPPED |\\",
          "141:      EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY |\\",
          "142:      EXT4_MAP_UNINIT)",
          "144: struct ext4_map_blocks {",
          "145:  ext4_fsblk_t m_pblk;",
          "146:  ext4_lblk_t m_lblk;",
          "147:  unsigned int m_len;",
          "148:  unsigned int m_flags;",
          "149: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1773: extern int ext4_ext_writepage_trans_blocks(struct inode *, int);",
          "1774: extern int ext4_ext_index_trans_blocks(struct inode *inode, int nrblocks,",
          "1775:            int chunk);",
          "1779: extern void ext4_ext_truncate(struct inode *);",
          "1780: extern void ext4_ext_init(struct super_block *);",
          "1781: extern void ext4_ext_release(struct super_block *);",
          "",
          "[Removed Lines]",
          "1776: extern int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,",
          "1777:           ext4_lblk_t iblock, unsigned int max_blocks,",
          "1778:           struct buffer_head *bh_result, int flags);",
          "",
          "[Added Lines]",
          "1799: extern int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,",
          "1800:           struct ext4_map_blocks *map, int flags);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1783:      loff_t len);",
          "1784: extern int ext4_convert_unwritten_extents(struct inode *inode, loff_t offset,",
          "1785:      ssize_t len);",
          "1786: extern int ext4_get_blocks(handle_t *handle, struct inode *inode,",
          "1787:       sector_t block, unsigned int max_blocks,",
          "1788:       struct buffer_head *bh, int flags);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1808: extern int ext4_map_blocks(handle_t *handle, struct inode *inode,",
          "1809:       struct ext4_map_blocks *map, int flags);",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2623: static int ext4_ext_convert_to_initialized(handle_t *handle,",
          "2628: {",
          "2629:  struct ext4_extent *ex, newex, orig_ex;",
          "2630:  struct ext4_extent *ex1 = NULL;",
          "",
          "[Removed Lines]",
          "2624:       struct inode *inode,",
          "2625:       struct ext4_ext_path *path,",
          "2626:       ext4_lblk_t iblock,",
          "2627:       unsigned int max_blocks)",
          "",
          "[Added Lines]",
          "2624:         struct inode *inode,",
          "2625:         struct ext4_map_blocks *map,",
          "2626:         struct ext4_ext_path *path)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2641:  ext_debug(\"ext4_ext_convert_to_initialized: inode %lu, logical\"",
          "2642:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
          "2645:  eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>",
          "2646:   inode->i_sb->s_blocksize_bits;",
          "2650:  depth = ext_depth(inode);",
          "2651:  eh = path[depth].p_hdr;",
          "2652:  ex = path[depth].p_ext;",
          "2653:  ee_block = le32_to_cpu(ex->ee_block);",
          "2654:  ee_len = ext4_ext_get_actual_len(ex);",
          "2658:  ex2 = ex;",
          "2659:  orig_ex.ee_block = ex->ee_block;",
          "",
          "[Removed Lines]",
          "2643:   (unsigned long long)iblock, max_blocks);",
          "2647:  if (eof_block < iblock + max_blocks)",
          "2648:   eof_block = iblock + max_blocks;",
          "2655:  allocated = ee_len - (iblock - ee_block);",
          "2656:  newblock = iblock - ee_block + ext_pblock(ex);",
          "",
          "[Added Lines]",
          "2642:   (unsigned long long)map->m_lblk, map->m_len);",
          "2646:  if (eof_block < map->m_lblk + map->m_len)",
          "2647:   eof_block = map->m_lblk + map->m_len;",
          "2654:  allocated = ee_len - (map->m_lblk - ee_block);",
          "2655:  newblock = map->m_lblk - ee_block + ext_pblock(ex);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2683:   return allocated;",
          "2684:  }",
          "2688:   ex1 = ex;",
          "2690:   ext4_ext_mark_uninitialized(ex1);",
          "2691:   ex2 = &newex;",
          "2692:  }",
          "",
          "[Removed Lines]",
          "2687:  if (iblock > ee_block) {",
          "2689:   ex1->ee_len = cpu_to_le16(iblock - ee_block);",
          "",
          "[Added Lines]",
          "2686:  if (map->m_lblk > ee_block) {",
          "2688:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2702:   unsigned int newdepth;",
          "2704:   if (allocated <= EXT4_EXT_ZERO_LEN && may_zeroout) {",
          "",
          "[Removed Lines]",
          "2698:  if (!ex1 && allocated > max_blocks)",
          "2699:   ex2->ee_len = cpu_to_le16(max_blocks);",
          "2701:  if (allocated > max_blocks) {",
          "",
          "[Added Lines]",
          "2697:  if (!ex1 && allocated > map->m_len)",
          "2698:   ex2->ee_len = cpu_to_le16(map->m_len);",
          "2700:  if (allocated > map->m_len) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2716:    ext4_ext_dirty(handle, inode, path + depth);",
          "2718:    ex3 = &newex;",
          "2720:    ext4_ext_store_pblock(ex3, newblock);",
          "2721:    ex3->ee_len = cpu_to_le16(allocated);",
          "2722:    err = ext4_ext_insert_extent(handle, inode, path,",
          "",
          "[Removed Lines]",
          "2719:    ex3->ee_block = cpu_to_le32(iblock);",
          "",
          "[Added Lines]",
          "2718:    ex3->ee_block = cpu_to_le32(map->m_lblk);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2752:     depth = ext_depth(inode);",
          "2753:     ext4_ext_drop_refs(path);",
          "2756:     if (IS_ERR(path)) {",
          "2757:      err = PTR_ERR(path);",
          "2758:      return err;",
          "",
          "[Removed Lines]",
          "2754:     path = ext4_ext_find_extent(inode,",
          "2755:         iblock, path);",
          "",
          "[Added Lines]",
          "2753:     path = ext4_ext_find_extent(inode, map->m_lblk,",
          "2754:            path);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2772:    return allocated;",
          "2773:   }",
          "2774:   ex3 = &newex;",
          "2778:   ext4_ext_mark_uninitialized(ex3);",
          "2779:   err = ext4_ext_insert_extent(handle, inode, path, ex3, 0);",
          "2780:   if (err == -ENOSPC && may_zeroout) {",
          "",
          "[Removed Lines]",
          "2775:   ex3->ee_block = cpu_to_le32(iblock + max_blocks);",
          "2776:   ext4_ext_store_pblock(ex3, newblock + max_blocks);",
          "2777:   ex3->ee_len = cpu_to_le16(allocated - max_blocks);",
          "",
          "[Added Lines]",
          "2774:   ex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);",
          "2775:   ext4_ext_store_pblock(ex3, newblock + map->m_len);",
          "2776:   ex3->ee_len = cpu_to_le16(allocated - map->m_len);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2808:   depth = newdepth;",
          "2809:   ext4_ext_drop_refs(path);",
          "2811:   if (IS_ERR(path)) {",
          "2812:    err = PTR_ERR(path);",
          "2813:    goto out;",
          "",
          "[Removed Lines]",
          "2810:   path = ext4_ext_find_extent(inode, iblock, path);",
          "",
          "[Added Lines]",
          "2809:   path = ext4_ext_find_extent(inode, map->m_lblk, path);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2821:   if (err)",
          "2822:    goto out;",
          "2830:   if (le16_to_cpu(orig_ex.ee_len) <= EXT4_EXT_ZERO_LEN &&",
          "2832:    err =  ext4_ext_zeroout(inode, &orig_ex);",
          "2833:    if (err)",
          "2834:     goto fix_extent_len;",
          "",
          "[Removed Lines]",
          "2824:   allocated = max_blocks;",
          "2831:    iblock != ee_block && may_zeroout) {",
          "",
          "[Added Lines]",
          "2823:   allocated = map->m_len;",
          "2830:    map->m_lblk != ee_block && may_zeroout) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2850:  if (ex1 && ex1 != ex) {",
          "2851:   ex1 = ex;",
          "2853:   ext4_ext_mark_uninitialized(ex1);",
          "2854:   ex2 = &newex;",
          "2855:  }",
          "2858:  ext4_ext_store_pblock(ex2, newblock);",
          "2859:  ex2->ee_len = cpu_to_le16(allocated);",
          "2860:  if (ex2 != ex)",
          "",
          "[Removed Lines]",
          "2852:   ex1->ee_len = cpu_to_le16(iblock - ee_block);",
          "2857:  ex2->ee_block = cpu_to_le32(iblock);",
          "",
          "[Added Lines]",
          "2851:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
          "2856:  ex2->ee_block = cpu_to_le32(map->m_lblk);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2948: static int ext4_split_unwritten_extents(handle_t *handle,",
          "2949:      struct inode *inode,",
          "2950:      struct ext4_ext_path *path,",
          "2953:      int flags)",
          "2954: {",
          "2955:  struct ext4_extent *ex, newex, orig_ex;",
          "",
          "[Removed Lines]",
          "2951:      ext4_lblk_t iblock,",
          "2952:      unsigned int max_blocks,",
          "",
          "[Added Lines]",
          "2949:      struct ext4_map_blocks *map,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2966:  ext_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"",
          "2967:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
          "2970:  eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>",
          "2971:   inode->i_sb->s_blocksize_bits;",
          "2975:  depth = ext_depth(inode);",
          "2976:  eh = path[depth].p_hdr;",
          "2977:  ex = path[depth].p_ext;",
          "2978:  ee_block = le32_to_cpu(ex->ee_block);",
          "2979:  ee_len = ext4_ext_get_actual_len(ex);",
          "2983:  ex2 = ex;",
          "2984:  orig_ex.ee_block = ex->ee_block;",
          "",
          "[Removed Lines]",
          "2968:   (unsigned long long)iblock, max_blocks);",
          "2972:  if (eof_block < iblock + max_blocks)",
          "2973:   eof_block = iblock + max_blocks;",
          "2980:  allocated = ee_len - (iblock - ee_block);",
          "2981:  newblock = iblock - ee_block + ext_pblock(ex);",
          "",
          "[Added Lines]",
          "2966:   (unsigned long long)map->m_lblk, map->m_len);",
          "2970:  if (eof_block < map->m_lblk + map->m_len)",
          "2971:   eof_block = map->m_lblk + map->m_len;",
          "2978:  allocated = ee_len - (map->m_lblk - ee_block);",
          "2979:  newblock = map->m_lblk - ee_block + ext_pblock(ex);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3000:   return allocated;",
          "3002:  err = ext4_ext_get_access(handle, inode, path + depth);",
          "3003:  if (err)",
          "3004:   goto out;",
          "3007:   ex1 = ex;",
          "3009:   ext4_ext_mark_uninitialized(ex1);",
          "3010:   ex2 = &newex;",
          "3011:  }",
          "",
          "[Removed Lines]",
          "2999:  if ((iblock == ee_block) && (allocated <= max_blocks))",
          "3006:  if (iblock > ee_block) {",
          "3008:   ex1->ee_len = cpu_to_le16(iblock - ee_block);",
          "",
          "[Added Lines]",
          "2997:  if ((map->m_lblk == ee_block) && (allocated <= map->m_len))",
          "3004:  if (map->m_lblk > ee_block) {",
          "3006:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3021:   unsigned int newdepth;",
          "3022:   ex3 = &newex;",
          "3026:   ext4_ext_mark_uninitialized(ex3);",
          "3027:   err = ext4_ext_insert_extent(handle, inode, path, ex3, flags);",
          "3028:   if (err == -ENOSPC && may_zeroout) {",
          "",
          "[Removed Lines]",
          "3017:  if (!ex1 && allocated > max_blocks)",
          "3018:   ex2->ee_len = cpu_to_le16(max_blocks);",
          "3020:  if (allocated > max_blocks) {",
          "3023:   ex3->ee_block = cpu_to_le32(iblock + max_blocks);",
          "3024:   ext4_ext_store_pblock(ex3, newblock + max_blocks);",
          "3025:   ex3->ee_len = cpu_to_le16(allocated - max_blocks);",
          "",
          "[Added Lines]",
          "3015:  if (!ex1 && allocated > map->m_len)",
          "3016:   ex2->ee_len = cpu_to_le16(map->m_len);",
          "3018:  if (allocated > map->m_len) {",
          "3021:   ex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);",
          "3022:   ext4_ext_store_pblock(ex3, newblock + map->m_len);",
          "3023:   ex3->ee_len = cpu_to_le16(allocated - map->m_len);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3056:   depth = newdepth;",
          "3057:   ext4_ext_drop_refs(path);",
          "3059:   if (IS_ERR(path)) {",
          "3060:    err = PTR_ERR(path);",
          "3061:    goto out;",
          "",
          "[Removed Lines]",
          "3058:   path = ext4_ext_find_extent(inode, iblock, path);",
          "",
          "[Added Lines]",
          "3056:   path = ext4_ext_find_extent(inode, map->m_lblk, path);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3069:   if (err)",
          "3070:    goto out;",
          "3073:  }",
          "",
          "[Removed Lines]",
          "3072:   allocated = max_blocks;",
          "",
          "[Added Lines]",
          "3070:   allocated = map->m_len;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3079:  if (ex1 && ex1 != ex) {",
          "3080:   ex1 = ex;",
          "3082:   ext4_ext_mark_uninitialized(ex1);",
          "3083:   ex2 = &newex;",
          "3084:  }",
          "3090:  ext4_ext_store_pblock(ex2, newblock);",
          "3091:  ex2->ee_len = cpu_to_le16(allocated);",
          "3092:  ext4_ext_mark_uninitialized(ex2);",
          "",
          "[Removed Lines]",
          "3081:   ex1->ee_len = cpu_to_le16(iblock - ee_block);",
          "3089:  ex2->ee_block = cpu_to_le32(iblock);",
          "",
          "[Added Lines]",
          "3079:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
          "3087:  ex2->ee_block = cpu_to_le32(map->m_lblk);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3189: static int",
          "3190: ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,",
          "3192:    struct ext4_ext_path *path, int flags,",
          "3195: {",
          "3196:  int ret = 0;",
          "3197:  int err = 0;",
          "",
          "[Removed Lines]",
          "3191:    ext4_lblk_t iblock, unsigned int max_blocks,",
          "3193:    unsigned int allocated, struct buffer_head *bh_result,",
          "3194:    ext4_fsblk_t newblock)",
          "",
          "[Added Lines]",
          "3189:    struct ext4_map_blocks *map,",
          "3191:    unsigned int allocated, ext4_fsblk_t newblock)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3200:  ext_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical\"",
          "3201:     \"block %llu, max_blocks %u, flags %d, allocated %u\",",
          "3203:     flags, allocated);",
          "3204:  ext4_ext_show_leaf(inode, path);",
          "3207:  if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
          "",
          "[Removed Lines]",
          "3202:     inode->i_ino, (unsigned long long)iblock, max_blocks,",
          "3208:   ret = ext4_split_unwritten_extents(handle,",
          "3209:       inode, path, iblock,",
          "3210:       max_blocks, flags);",
          "",
          "[Added Lines]",
          "3199:     inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,",
          "3205:   ret = ext4_split_unwritten_extents(handle, inode, map,",
          "3206:          path, flags);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3218:   else",
          "3219:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
          "3220:   if (ext4_should_dioread_nolock(inode))",
          "3222:   goto out;",
          "3223:  }",
          "",
          "[Removed Lines]",
          "3221:    set_buffer_uninit(bh_result);",
          "",
          "[Added Lines]",
          "3217:    map->m_flags |= EXT4_MAP_UNINIT;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3250:   goto out1;",
          "3251:  }",
          "3257:  if (ret >= 0)",
          "3258:   ext4_update_inode_fsync_trans(handle, inode, 1);",
          "3259: out:",
          "",
          "[Removed Lines]",
          "3249:   set_buffer_unwritten(bh_result);",
          "3254:  ret = ext4_ext_convert_to_initialized(handle, inode,",
          "3255:       path, iblock,",
          "3256:       max_blocks);",
          "",
          "[Added Lines]",
          "3245:   map->m_flags |= EXT4_MAP_UNWRITTEN;",
          "3250:  ret = ext4_ext_convert_to_initialized(handle, inode, map, path);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3262:   goto out2;",
          "3263:  } else",
          "3264:   allocated = ret;",
          "",
          "[Removed Lines]",
          "3265:  set_buffer_new(bh_result);",
          "",
          "[Added Lines]",
          "3259:  map->m_flags |= EXT4_MAP_NEW;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3274:   unmap_underlying_metadata_blocks(inode->i_sb->s_bdev,",
          "3278:  }",
          "",
          "[Removed Lines]",
          "3273:  if (allocated > max_blocks) {",
          "3275:      newblock + max_blocks,",
          "3276:      allocated - max_blocks);",
          "3277:   allocated = max_blocks;",
          "",
          "[Added Lines]",
          "3267:  if (allocated > map->m_len) {",
          "3269:      newblock + map->m_len,",
          "3270:      allocated - map->m_len);",
          "3271:   allocated = map->m_len;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3288:   ext4_da_update_reserve_space(inode, allocated, 0);",
          "3290: map_out:",
          "3292: out1:",
          "3295:  ext4_ext_show_leaf(inode, path);",
          "3298: out2:",
          "3299:  if (path) {",
          "3300:   ext4_ext_drop_refs(path);",
          "",
          "[Removed Lines]",
          "3291:  set_buffer_mapped(bh_result);",
          "3293:  if (allocated > max_blocks)",
          "3294:   allocated = max_blocks;",
          "3296:  bh_result->b_bdev = inode->i_sb->s_bdev;",
          "3297:  bh_result->b_blocknr = newblock;",
          "",
          "[Added Lines]",
          "3285:  map->m_flags |= EXT4_MAP_MAPPED;",
          "3287:  if (allocated > map->m_len)",
          "3288:   allocated = map->m_len;",
          "3290:  map->m_pblk = newblock;",
          "3291:  map->m_len = allocated;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3327: {",
          "3328:  struct ext4_ext_path *path = NULL;",
          "3329:  struct ext4_extent_header *eh;",
          "",
          "[Removed Lines]",
          "3323: int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,",
          "3324:    ext4_lblk_t iblock,",
          "3325:    unsigned int max_blocks, struct buffer_head *bh_result,",
          "3326:    int flags)",
          "",
          "[Added Lines]",
          "3317: int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,",
          "3318:    struct ext4_map_blocks *map, int flags)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3334:  struct ext4_allocation_request ar;",
          "3335:  ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;",
          "3338:  ext_debug(\"blocks %u/%u requested for inode %lu\\n\",",
          "3343:  if (cache_type) {",
          "3344:   if (cache_type == EXT4_EXT_CACHE_GAP) {",
          "3345:    if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {",
          "",
          "[Removed Lines]",
          "3337:  __clear_bit(BH_New, &bh_result->b_state);",
          "3339:    iblock, max_blocks, inode->i_ino);",
          "3342:  cache_type = ext4_ext_in_cache(inode, iblock, &newex);",
          "",
          "[Added Lines]",
          "3330:     map->m_lblk, map->m_len, inode->i_ino);",
          "3333:  cache_type = ext4_ext_in_cache(inode, map->m_lblk, &newex);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3353:   } else if (cache_type == EXT4_EXT_CACHE_EXTENT) {",
          "3356:        - le32_to_cpu(newex.ee_block)",
          "3357:        + ext_pblock(&newex);",
          "3359:    allocated = ext4_ext_get_actual_len(&newex) -",
          "3361:    goto out;",
          "3362:   } else {",
          "3363:    BUG();",
          "",
          "[Removed Lines]",
          "3355:    newblock = iblock",
          "3360:      (iblock - le32_to_cpu(newex.ee_block));",
          "",
          "[Added Lines]",
          "3346:    newblock = map->m_lblk",
          "3351:     (map->m_lblk - le32_to_cpu(newex.ee_block));",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3365:  }",
          "3369:  if (IS_ERR(path)) {",
          "3370:   err = PTR_ERR(path);",
          "3371:   path = NULL;",
          "",
          "[Removed Lines]",
          "3368:  path = ext4_ext_find_extent(inode, iblock, NULL);",
          "",
          "[Added Lines]",
          "3359:  path = ext4_ext_find_extent(inode, map->m_lblk, NULL);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3382:  if (unlikely(path[depth].p_ext == NULL && depth != 0)) {",
          "3383:   EXT4_ERROR_INODE(inode, \"bad extent address \"",
          "3384:      \"iblock: %d, depth: %d pblock %lld\",",
          "3386:   err = -EIO;",
          "3387:   goto out2;",
          "3388:  }",
          "",
          "[Removed Lines]",
          "3385:      iblock, depth, path[depth].p_block);",
          "",
          "[Added Lines]",
          "3376:      map->m_lblk, depth, path[depth].p_block);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3401:   ee_len = ext4_ext_get_actual_len(ex);",
          "3411:    if (!ext4_ext_is_uninitialized(ex)) {",
          "",
          "[Removed Lines]",
          "3403:   if (in_range(iblock, ee_block, ee_len)) {",
          "3404:    newblock = iblock - ee_block + ee_start;",
          "3406:    allocated = ee_len - (iblock - ee_block);",
          "3407:    ext_debug(\"%u fit into %u:%d -> %llu\\n\", iblock,",
          "3408:      ee_block, ee_len, newblock);",
          "",
          "[Added Lines]",
          "3394:   if (in_range(map->m_lblk, ee_block, ee_len)) {",
          "3395:    newblock = map->m_lblk - ee_block + ee_start;",
          "3397:    allocated = ee_len - (map->m_lblk - ee_block);",
          "3398:    ext_debug(\"%u fit into %u:%d -> %llu\\n\", map->m_lblk,",
          "3399:       ee_block, ee_len, newblock);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3415:     goto out;",
          "3416:    }",
          "3417:    ret = ext4_ext_handle_uninitialized_extents(handle,",
          "3420:    return ret;",
          "3421:   }",
          "3422:  }",
          "",
          "[Removed Lines]",
          "3418:      inode, iblock, max_blocks, path,",
          "3419:      flags, allocated, bh_result, newblock);",
          "",
          "[Added Lines]",
          "3409:      inode, map, path, flags, allocated,",
          "3410:      newblock);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3434:   goto out2;",
          "3435:  }",
          "",
          "[Removed Lines]",
          "3433:   ext4_ext_put_gap_in_cache(inode, path, iblock);",
          "",
          "[Added Lines]",
          "3424:   ext4_ext_put_gap_in_cache(inode, path, map->m_lblk);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3442:  err = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);",
          "3443:  if (err)",
          "3444:   goto out2;",
          "3446:  err = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright);",
          "3447:  if (err)",
          "3448:   goto out2;",
          "",
          "[Removed Lines]",
          "3441:  ar.lleft = iblock;",
          "3445:  ar.lright = iblock;",
          "",
          "[Added Lines]",
          "3432:  ar.lleft = map->m_lblk;",
          "3436:  ar.lright = map->m_lblk;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3457:      !(flags & EXT4_GET_BLOCKS_UNINIT_EXT))",
          "3460:    (flags & EXT4_GET_BLOCKS_UNINIT_EXT))",
          "3466:  err = ext4_ext_check_overlap(inode, &newex, path);",
          "3467:  if (err)",
          "3468:   allocated = ext4_ext_get_actual_len(&newex);",
          "3469:  else",
          "3473:  ar.inode = inode;",
          "3476:  ar.len = allocated;",
          "3477:  if (S_ISREG(inode->i_mode))",
          "3478:   ar.flags = EXT4_MB_HINT_DATA;",
          "",
          "[Removed Lines]",
          "3456:  if (max_blocks > EXT_INIT_MAX_LEN &&",
          "3458:   max_blocks = EXT_INIT_MAX_LEN;",
          "3459:  else if (max_blocks > EXT_UNINIT_MAX_LEN &&",
          "3461:   max_blocks = EXT_UNINIT_MAX_LEN;",
          "3464:  newex.ee_block = cpu_to_le32(iblock);",
          "3465:  newex.ee_len = cpu_to_le16(max_blocks);",
          "3470:   allocated = max_blocks;",
          "3474:  ar.goal = ext4_ext_find_goal(inode, path, iblock);",
          "3475:  ar.logical = iblock;",
          "",
          "[Added Lines]",
          "3447:  if (map->m_len > EXT_INIT_MAX_LEN &&",
          "3449:   map->m_len = EXT_INIT_MAX_LEN;",
          "3450:  else if (map->m_len > EXT_UNINIT_MAX_LEN &&",
          "3452:   map->m_len = EXT_UNINIT_MAX_LEN;",
          "3455:  newex.ee_block = cpu_to_le32(map->m_lblk);",
          "3456:  newex.ee_len = cpu_to_le16(map->m_len);",
          "3461:   allocated = map->m_len;",
          "3465:  ar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);",
          "3466:  ar.logical = map->m_lblk;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3506:            EXT4_STATE_DIO_UNWRITTEN);",
          "3507:   }",
          "3508:   if (ext4_should_dioread_nolock(inode))",
          "3510:  }",
          "3512:  if (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {",
          "",
          "[Removed Lines]",
          "3509:    set_buffer_uninit(bh_result);",
          "",
          "[Added Lines]",
          "3500:    map->m_flags |= EXT4_MAP_UNINIT;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3518:    goto out2;",
          "3519:   }",
          "3520:   last_ex = EXT_LAST_EXTENT(eh);",
          "3522:       + ext4_ext_get_actual_len(last_ex))",
          "3523:    EXT4_I(inode)->i_flags &= ~EXT4_EOFBLOCKS_FL;",
          "3524:  }",
          "",
          "[Removed Lines]",
          "3521:   if (iblock + ar.len > le32_to_cpu(last_ex->ee_block)",
          "",
          "[Added Lines]",
          "3512:   if (map->m_lblk + ar.len > le32_to_cpu(last_ex->ee_block)",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3537:  newblock = ext_pblock(&newex);",
          "3538:  allocated = ext4_ext_get_actual_len(&newex);",
          "",
          "[Removed Lines]",
          "3539:  if (allocated > max_blocks)",
          "3540:   allocated = max_blocks;",
          "3541:  set_buffer_new(bh_result);",
          "",
          "[Added Lines]",
          "3530:  if (allocated > map->m_len)",
          "3531:   allocated = map->m_len;",
          "3532:  map->m_flags |= EXT4_MAP_NEW;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3554:  if ((flags & EXT4_GET_BLOCKS_UNINIT_EXT) == 0) {",
          "3556:       EXT4_EXT_CACHE_EXTENT);",
          "3557:   ext4_update_inode_fsync_trans(handle, inode, 1);",
          "3558:  } else",
          "3559:   ext4_update_inode_fsync_trans(handle, inode, 0);",
          "3560: out:",
          "3563:  ext4_ext_show_leaf(inode, path);",
          "3567: out2:",
          "3568:  if (path) {",
          "3569:   ext4_ext_drop_refs(path);",
          "",
          "[Removed Lines]",
          "3555:   ext4_ext_put_in_cache(inode, iblock, allocated, newblock,",
          "3561:  if (allocated > max_blocks)",
          "3562:   allocated = max_blocks;",
          "3564:  set_buffer_mapped(bh_result);",
          "3565:  bh_result->b_bdev = inode->i_sb->s_bdev;",
          "3566:  bh_result->b_blocknr = newblock;",
          "",
          "[Added Lines]",
          "3546:   ext4_ext_put_in_cache(inode, map->m_lblk, allocated, newblock,",
          "3552:  if (allocated > map->m_len)",
          "3553:   allocated = map->m_len;",
          "3555:  map->m_flags |= EXT4_MAP_MAPPED;",
          "3556:  map->m_pblk = newblock;",
          "3557:  map->m_len = allocated;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3729:   if (ret <= 0) {",
          "3730: #ifdef EXT4FS_DEBUG",
          "3731:    WARN_ON(ret <= 0);",
          "3733:         \"returned error inode#%lu, block=%u, \"",
          "3734:         \"max_blocks=%u\", __func__,",
          "3735:         inode->i_ino, block, max_blocks);",
          "",
          "[Removed Lines]",
          "3732:    printk(KERN_ERR \"%s: ext4_ext_get_blocks \"",
          "",
          "[Added Lines]",
          "3723:    printk(KERN_ERR \"%s: ext4_ext_map_blocks \"",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3806:           EXT4_GET_BLOCKS_IO_CONVERT_EXT);",
          "3807:   if (ret <= 0) {",
          "3808:    WARN_ON(ret <= 0);",
          "3810:         \"returned error inode#%lu, block=%u, \"",
          "3811:         \"max_blocks=%u\", __func__,",
          "3812:         inode->i_ino, block, max_blocks);",
          "",
          "[Removed Lines]",
          "3809:    printk(KERN_ERR \"%s: ext4_ext_get_blocks \"",
          "",
          "[Added Lines]",
          "3800:    printk(KERN_ERR \"%s: ext4_ext_map_blocks \"",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "923:           int flags)",
          "924: {",
          "925:  int err = -EIO;",
          "",
          "[Removed Lines]",
          "920: static int ext4_ind_get_blocks(handle_t *handle, struct inode *inode,",
          "921:           ext4_lblk_t iblock, unsigned int maxblocks,",
          "922:           struct buffer_head *bh_result,",
          "",
          "[Added Lines]",
          "920: static int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,",
          "921:           struct ext4_map_blocks *map,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "936:  J_ASSERT(!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL));",
          "937:  J_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);",
          "939:        &blocks_to_boundary);",
          "941:  if (depth == 0)",
          "",
          "[Removed Lines]",
          "938:  depth = ext4_block_to_path(inode, iblock, offsets,",
          "",
          "[Added Lines]",
          "937:  depth = ext4_block_to_path(inode, map->m_lblk, offsets,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "947:  if (!partial) {",
          "948:   first_block = le32_to_cpu(chain[depth - 1].key);",
          "950:   count++;",
          "953:    ext4_fsblk_t blk;",
          "955:    blk = le32_to_cpu(*(chain[depth-1].p + count));",
          "",
          "[Removed Lines]",
          "949:   clear_buffer_new(bh_result);",
          "952:   while (count < maxblocks && count <= blocks_to_boundary) {",
          "",
          "[Added Lines]",
          "950:   while (count < map->m_len && count <= blocks_to_boundary) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "975:  indirect_blks = (chain + depth) - partial - 1;",
          "",
          "[Removed Lines]",
          "972:  goal = ext4_find_goal(inode, iblock, partial);",
          "",
          "[Added Lines]",
          "970:  goal = ext4_find_goal(inode, map->m_lblk, partial);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "981:  count = ext4_blks_to_allocate(partial, indirect_blks,",
          "987:     &count, goal,",
          "988:     offsets + (partial - chain), partial);",
          "",
          "[Removed Lines]",
          "982:      maxblocks, blocks_to_boundary);",
          "986:  err = ext4_alloc_branch(handle, inode, iblock, indirect_blks,",
          "",
          "[Added Lines]",
          "980:           map->m_len, blocks_to_boundary);",
          "984:  err = ext4_alloc_branch(handle, inode, map->m_lblk, indirect_blks,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "997:  if (!err)",
          "999:       partial, indirect_blks, count);",
          "1000:  if (err)",
          "1001:   goto cleanup;",
          "1005:  ext4_update_inode_fsync_trans(handle, inode, 1);",
          "1006: got_it:",
          "1008:  if (count > blocks_to_boundary)",
          "1010:  err = count;",
          "",
          "[Removed Lines]",
          "998:   err = ext4_splice_branch(handle, inode, iblock,",
          "1003:  set_buffer_new(bh_result);",
          "1007:  map_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));",
          "1009:   set_buffer_boundary(bh_result);",
          "",
          "[Added Lines]",
          "996:   err = ext4_splice_branch(handle, inode, map->m_lblk,",
          "1001:  map->m_flags |= EXT4_MAP_NEW;",
          "1005:  map->m_flags |= EXT4_MAP_MAPPED;",
          "1006:  map->m_pblk = le32_to_cpu(chain[depth-1].key);",
          "1007:  map->m_len = count;",
          "1009:   map->m_flags |= EXT4_MAP_BOUNDARY;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1016:   brelse(partial->bh);",
          "1017:   partial--;",
          "1018:  }",
          "1020: out:",
          "1021:  return err;",
          "1022: }",
          "",
          "[Removed Lines]",
          "1019:  BUFFER_TRACE(bh_result, \"returned\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1230: {",
          "1231:  int retval;",
          "1243:  down_read((&EXT4_I(inode)->i_data_sem));",
          "1244:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) {",
          "1247:  } else {",
          "1250:  }",
          "1251:  up_read((&EXT4_I(inode)->i_data_sem));",
          "1254:   int ret = check_block_validity(inode, \"file system corruption\",",
          "1256:   if (ret != 0)",
          "1257:    return ret;",
          "1258:  }",
          "",
          "[Removed Lines]",
          "1227: int ext4_get_blocks(handle_t *handle, struct inode *inode, sector_t block,",
          "1228:       unsigned int max_blocks, struct buffer_head *bh,",
          "1229:       int flags)",
          "1233:  clear_buffer_mapped(bh);",
          "1234:  clear_buffer_unwritten(bh);",
          "1236:  ext_debug(\"ext4_get_blocks(): inode %lu, flag %d, max_blocks %u,\"",
          "1237:     \"logical block %lu\\n\", inode->i_ino, flags, max_blocks,",
          "1238:     (unsigned long)block);",
          "1245:   retval =  ext4_ext_get_blocks(handle, inode, block, max_blocks,",
          "1246:     bh, 0);",
          "1248:   retval = ext4_ind_get_blocks(handle, inode, block, max_blocks,",
          "1249:           bh, 0);",
          "1253:  if (retval > 0 && buffer_mapped(bh)) {",
          "1255:             block, bh->b_blocknr, retval);",
          "",
          "[Added Lines]",
          "1226: int ext4_map_blocks(handle_t *handle, struct inode *inode,",
          "1227:       struct ext4_map_blocks *map, int flags)",
          "1231:  map->m_flags = 0;",
          "1232:  ext_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"",
          "1233:     \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,",
          "1234:     (unsigned long) map->m_lblk);",
          "1241:   retval = ext4_ext_map_blocks(handle, inode, map, 0);",
          "1243:   retval = ext4_ind_map_blocks(handle, inode, map, 0);",
          "1247:  if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {",
          "1249:      map->m_lblk, map->m_pblk, retval);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1272:   return retval;",
          "",
          "[Removed Lines]",
          "1271:  if (retval > 0 && buffer_mapped(bh))",
          "",
          "[Added Lines]",
          "1265:  if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1284:  clear_buffer_unwritten(bh);",
          "",
          "[Added Lines]",
          "1278:  map->m_flags &= ~EXT4_MAP_UNWRITTEN;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1306:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) {",
          "1309:  } else {",
          "",
          "[Removed Lines]",
          "1307:   retval =  ext4_ext_get_blocks(handle, inode, block, max_blocks,",
          "1308:            bh, flags);",
          "1310:   retval = ext4_ind_get_blocks(handle, inode, block,",
          "1311:           max_blocks, bh, flags);",
          "1313:   if (retval > 0 && buffer_new(bh)) {",
          "",
          "[Added Lines]",
          "1301:   retval = ext4_ext_map_blocks(handle, inode, map, flags);",
          "1303:   retval = ext4_ind_map_blocks(handle, inode, map, flags);",
          "1305:   if (retval > 0 && map->m_flags & EXT4_MAP_NEW) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1333:   EXT4_I(inode)->i_delalloc_reserved_flag = 0;",
          "1335:  up_write((&EXT4_I(inode)->i_data_sem));",
          "1337:   int ret = check_block_validity(inode, \"file system \"",
          "1338:             \"corruption after allocation\",",
          "1340:   if (ret != 0)",
          "1341:    return ret;",
          "1342:  }",
          "1343:  return retval;",
          "1344: }",
          "1347: #define DIO_MAX_BLOCKS 4096",
          "",
          "[Removed Lines]",
          "1336:  if (retval > 0 && buffer_mapped(bh)) {",
          "1339:             block, bh->b_blocknr, retval);",
          "",
          "[Added Lines]",
          "1328:  if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {",
          "1331:             map->m_lblk, map->m_pblk,",
          "1332:             retval);",
          "1339: int ext4_get_blocks(handle_t *handle, struct inode *inode, sector_t block,",
          "1340:       unsigned int max_blocks, struct buffer_head *bh,",
          "1341:       int flags)",
          "1342: {",
          "1343:  struct ext4_map_blocks map;",
          "1344:  int ret;",
          "1346:  map.m_lblk = block;",
          "1347:  map.m_len = max_blocks;",
          "1349:  ret = ext4_map_blocks(handle, inode, &map, flags);",
          "1350:  if (ret < 0)",
          "1351:   return ret;",
          "1353:  bh->b_blocknr = map.m_pblk;",
          "1354:  bh->b_size = inode->i_sb->s_blocksize * map.m_len;",
          "1355:  bh->b_bdev = inode->i_sb->s_bdev;",
          "1356:  bh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;",
          "1357:  return ret;",
          "1358: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
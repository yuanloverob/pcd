{
  "cve_id": "CVE-2015-1870",
  "cve_desc": "The event scripts in Automatic Bug Reporting Tool (ABRT) uses world-readable permission on a copy of sosreport file in problem directories, which allows local users to obtain sensitive information from /var/log/messages via unspecified vectors.",
  "repo": "abrt/abrt",
  "patch_hash": "8939398b82006ba1fec4ed491339fc075f43fc7c",
  "patch_info": {
    "commit_hash": "8939398b82006ba1fec4ed491339fc075f43fc7c",
    "repo": "abrt/abrt",
    "commit_url": "https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c",
    "files": [
      "src/daemon/abrt-server.c",
      "src/daemon/abrt.conf",
      "src/hooks/abrt-hook-ccpp.c",
      "src/include/libabrt.h",
      "src/lib/abrt_conf.c",
      "src/lib/hooklib.c",
      "src/plugins/abrt-dump-oops.c",
      "src/plugins/abrt-dump-xorg.c"
    ],
    "message": "make the dump directories owned by root by default\n\nIt was discovered that the abrt event scripts create a user-readable\ncopy of a sosreport file in abrt problem directories, and include\nexcerpts of /var/log/messages selected by the user-controlled process\nname, leading to an information disclosure.\n\nThis issue was discovered by Florian Weimer of Red Hat Product Security.\n\nRelated: #1212868\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
    "before_after_code_files": [
      "src/daemon/abrt-server.c||src/daemon/abrt-server.c",
      "src/daemon/abrt.conf||src/daemon/abrt.conf",
      "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c",
      "src/include/libabrt.h||src/include/libabrt.h",
      "src/lib/abrt_conf.c||src/lib/abrt_conf.c",
      "src/lib/hooklib.c||src/lib/hooklib.c",
      "src/plugins/abrt-dump-oops.c||src/plugins/abrt-dump-oops.c",
      "src/plugins/abrt-dump-xorg.c||src/plugins/abrt-dump-xorg.c"
    ]
  },
  "patch_diff": {
    "src/daemon/abrt-server.c||src/daemon/abrt-server.c": [
      "File: src/daemon/abrt-server.c -> src/daemon/abrt-server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:   with this program; if not, write to the Free Software Foundation, Inc.,",
      "16:   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
      "18: #include \"libabrt.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: #include \"problem_api.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "153:         error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);",
      "155:     }",
      "157:     {",
      "158:         if (errno == ENOTDIR)",
      "159:         {",
      "",
      "[Removed Lines]",
      "156:     if (!dump_dir_accessible_by_uid(dirname, client_uid))",
      "",
      "[Added Lines]",
      "157:     if (g_settings_privatereports)",
      "158:     {",
      "159:         struct stat statbuf;",
      "160:         if (lstat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
      "161:         {",
      "162:             error_msg(\"Path '%s' isn't directory\", dirname);",
      "164:         }",
      "166:         struct group *gr = getgrnam(\"abrt\");",
      "167:         if (!gr)",
      "168:         {",
      "169:             error_msg(\"Group 'abrt' does not exist\");",
      "170:             return 500;",
      "171:         }",
      "172:         if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)",
      "173:         {",
      "174:             error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);",
      "175:             return 403;",
      "176:         }",
      "177:         struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);",
      "178:         const bool complete = dd && problem_dump_dir_is_complete(dd);",
      "179:         dd_close(dd);",
      "180:         if (complete)",
      "181:         {",
      "182:             error_msg(\"Problem directory '%s' has already been processed\", dirname);",
      "183:             return 403;",
      "184:         }",
      "185:     }",
      "186:     else if (!dump_dir_accessible_by_uid(dirname, client_uid))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "381:     if (!dd)",
      "382:     {",
      "383:         error_msg_and_die(\"Error creating problem directory '%s'\", path);",
      "",
      "[Removed Lines]",
      "380:     struct dump_dir *dd = dd_create(path, client_uid, DEFAULT_DUMP_DIR_MODE);",
      "",
      "[Added Lines]",
      "410:     struct dump_dir *dd = dd_create(path, g_settings_privatereports ? 0 : client_uid, DEFAULT_DUMP_DIR_MODE);",
      "",
      "---------------"
    ],
    "src/daemon/abrt.conf||src/daemon/abrt.conf": [
      "File: src/daemon/abrt.conf -> src/daemon/abrt.conf",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: #                session; otherwise No.",
      "44: #",
      "45: # ShortenedReporting = yes",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "47: # Disable this if you want to regular users to own the problem data colleted by",
      "48: # abrt.",
      "49: #",
      "50: PrivateReports = yes",
      "",
      "---------------"
    ],
    "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
      "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "682:         }",
      "683:     }",
      "686:     if (setting_MakeCompatCore && ulimit_c != 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "686:     const uid_t dduid = g_settings_privatereports ? 0 : fsuid;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "773:         goto create_user_core;",
      "774:     }",
      "784:     if (dd)",
      "785:     {",
      "786:         char *rootdir = get_rootdir(pid);",
      "788:         dd_create_basic_files(dd, fsuid, NULL);",
      "790:         char source_filename[sizeof(\"/proc/%lu/somewhat_long_name\") + sizeof(long)*3];",
      "",
      "[Removed Lines]",
      "783:     dd = dd_create_skeleton(path, fsuid, DEFAULT_DUMP_DIR_MODE, /*no flags*/0);",
      "",
      "[Added Lines]",
      "786:     dd = dd_create_skeleton(path, dduid, DEFAULT_DUMP_DIR_MODE, /*no flags*/0);",
      "",
      "---------------"
    ],
    "src/include/libabrt.h||src/include/libabrt.h": [
      "File: src/include/libabrt.h -> src/include/libabrt.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "62: extern char *        g_settings_autoreporting_event;",
      "63: #define g_settings_shortenedreporting abrt_g_settings_shortenedreporting",
      "64: extern bool          g_settings_shortenedreporting;",
      "67: #define load_abrt_conf abrt_load_abrt_conf",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "65: #define g_settings_privatereports abrt_g_settings_privatereports",
      "66: extern bool          g_settings_privatereports;",
      "",
      "---------------"
    ],
    "src/lib/abrt_conf.c||src/lib/abrt_conf.c": [
      "File: src/lib/abrt_conf.c -> src/lib/abrt_conf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: bool          g_settings_autoreporting = 0;",
      "28: char *        g_settings_autoreporting_event = NULL;",
      "29: bool          g_settings_shortenedreporting = 0;",
      "31: void free_abrt_conf_data()",
      "32: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "30: bool          g_settings_privatereports = true;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "102:     else",
      "103:         g_settings_shortenedreporting = 0;",
      "105:     GHashTableIter iter;",
      "106:     const char *name;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "106:     value = get_map_string_item_or_NULL(settings, \"PrivateReports\");",
      "107:     if (value)",
      "108:     {",
      "109:         g_settings_privatereports = string_to_bool(value);",
      "110:         remove_map_string_item(settings, \"PrivateReports\");",
      "111:     }",
      "",
      "---------------"
    ],
    "src/lib/hooklib.c||src/lib/hooklib.c": [
      "File: src/lib/hooklib.c -> src/lib/hooklib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "410: {",
      "411:     load_abrt_conf();",
      "415:     char *problem_id = NULL;",
      "416:     if (dd)",
      "",
      "[Removed Lines]",
      "413:     struct dump_dir *dd = create_dump_dir_from_problem_data(pd, g_settings_dump_location);",
      "",
      "[Added Lines]",
      "413:     struct dump_dir *dd = NULL;",
      "415:     if (g_settings_privatereports)",
      "416:         dd = create_dump_dir_from_problem_data_ext(pd, g_settings_dump_location, 0);",
      "417:     else",
      "418:         dd = create_dump_dir_from_problem_data(pd, g_settings_dump_location);",
      "",
      "---------------"
    ],
    "src/plugins/abrt-dump-oops.c||src/plugins/abrt-dump-oops.c": [
      "File: src/plugins/abrt-dump-oops.c -> src/plugins/abrt-dump-oops.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "189:         mode = DEFAULT_DUMP_DIR_MODE;",
      "190:         my_euid = geteuid();",
      "191:     }",
      "193:     pid_t my_pid = getpid();",
      "194:     unsigned idx = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "192:     if (g_settings_privatereports)",
      "193:     {",
      "194:         if (world_readable_dump)",
      "195:             log(\"Not going to make dump directories world readable because PrivateReports is on\");",
      "197:         mode = DEFAULT_DUMP_DIR_MODE;",
      "198:         my_euid = 0;",
      "199:     }",
      "",
      "---------------"
    ],
    "src/plugins/abrt-dump-xorg.c||src/plugins/abrt-dump-xorg.c": [
      "File: src/plugins/abrt-dump-xorg.c -> src/plugins/abrt-dump-xorg.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "82:         mode = DEFAULT_DUMP_DIR_MODE;",
      "83:         my_euid = geteuid();",
      "84:     }",
      "86:     pid_t my_pid = getpid();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "85:     if (g_settings_privatereports)",
      "86:     {",
      "87:         if ((g_opts & OPT_x))",
      "88:             log(\"Not going to make dump directories world readable because PrivateReports is on\");",
      "90:         mode = DEFAULT_DUMP_DIR_MODE;",
      "91:         my_euid = 0;",
      "92:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e6dc5900266663ed6c2d170f9c3ed3c9b033d1ba",
      "candidate_info": {
        "commit_hash": "e6dc5900266663ed6c2d170f9c3ed3c9b033d1ba",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/e6dc5900266663ed6c2d170f9c3ed3c9b033d1ba",
        "files": [
          "abrt.spec.in"
        ],
        "message": "spec: add libselinux-devel to BRs\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "abrt.spec.in||abrt.spec.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "abrt.spec.in||abrt.spec.in": [
          "File: abrt.spec.in -> abrt.spec.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: BuildRequires: satyr-devel >= 0.11",
          "75: BuildRequires: systemd-python",
          "76: BuildRequires: augeas",
          "78: Requires: libreport >= %{libreport_ver}",
          "79: Requires: satyr >= 0.11",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77: BuildRequires: libselinux-devel",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "89ae091014c69a2bafa7bb6fbe8843940a08fb39",
      "candidate_info": {
        "commit_hash": "89ae091014c69a2bafa7bb6fbe8843940a08fb39",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/89ae091014c69a2bafa7bb6fbe8843940a08fb39",
        "files": [
          "abrt.spec.in"
        ],
        "message": "spec: create /vat/spool/abrt\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "abrt.spec.in||abrt.spec.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "abrt.spec.in||abrt.spec.in": [
          "File: abrt.spec.in -> abrt.spec.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "403: %build",
          "404: autoconf",
          "412: CFLAGS=\"%{optflags} -Werror\" %configure \\",
          "413: %if 0%{?suse_version}",
          "",
          "[Removed Lines]",
          "406: %if 0%{?rhel:%{rhel} < 7}%{?fedora:%{fedora} < 18}",
          "407:     %define var_base_dir spool",
          "408: %else",
          "409:     %define var_base_dir tmp",
          "410: %endif",
          "",
          "[Added Lines]",
          "406: %define var_base_dir spool",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "416: %if %{without bodhi}",
          "417:         --without-bodhi \\",
          "418: %endif",
          "422: %if 0%{?rhel}",
          "423:         --enable-suggest-autoreporting \\",
          "424: %endif",
          "",
          "[Removed Lines]",
          "419: %if 0%{?rhel:%{rhel} < 7}%{?fedora:%{fedora} < 18}",
          "420:         --with-defaultdumplocation=/var/%{var_base_dir}/abrt \\",
          "421: %endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7814554e0827ece778ca88fd90832bd4d05520b1",
      "candidate_info": {
        "commit_hash": "7814554e0827ece778ca88fd90832bd4d05520b1",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/7814554e0827ece778ca88fd90832bd4d05520b1",
        "files": [
          "src/dbus/abrt-dbus.c",
          "src/lib/problem_api.c"
        ],
        "message": "dbus: avoid race-conditions in tests for dum dir availability\n\nFlorian Weimer <fweimer@redhat.com>\n\n    dump_dir_accessible_by_uid() is fundamentally insecure because it\n    opens up a classic time-of-check-time-of-use race between this\n    function and and dd_opendir().\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/dbus/abrt-dbus.c||src/dbus/abrt-dbus.c",
          "src/lib/problem_api.c||src/lib/problem_api.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/dbus/abrt-dbus.c||src/dbus/abrt-dbus.c": [
          "File: src/dbus/abrt-dbus.c -> src/dbus/abrt-dbus.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "245:         }",
          "246:     }",
          "249:     {",
          "250:         if (errno == ENOTDIR)",
          "251:         {",
          "",
          "[Removed Lines]",
          "248:     if (!dump_dir_accessible_by_uid(problem_id, caller_uid))",
          "",
          "[Added Lines]",
          "248:     int dir_fd = dd_openfd(problem_id);",
          "249:     if (dir_fd < 0)",
          "250:     {",
          "251:         perror_msg(\"can't open problem directory '%s'\", problem_id);",
          "252:         return_InvalidProblemDir_error(invocation, problem_id);",
          "253:         return NULL;",
          "254:     }",
          "256:     if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "260:                                 _(\"Not Authorized\"));",
          "261:         }",
          "263:         return NULL;",
          "264:     }",
          "267:     if (!dd)",
          "269:         log_notice(\"Can't access the problem '%s' for modification\", problem_id);",
          "",
          "[Removed Lines]",
          "266:     struct dump_dir *dd = dd_opendir(problem_id, /* flags : */ 0);",
          "",
          "[Added Lines]",
          "271:         close(dir_fd);",
          "275:     struct dump_dir *dd = dd_fdopendir(dir_fd, problem_id, /* flags : */ 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "429:             return;",
          "430:         }",
          "433:         if (ddstat < 0)",
          "434:         {",
          "435:             if (errno == ENOTDIR)",
          "",
          "[Removed Lines]",
          "432:         int ddstat = dump_dir_stat_for_uid(problem_dir, caller_uid);",
          "",
          "[Added Lines]",
          "441:         int dir_fd = dd_openfd(problem_dir);",
          "442:         if (dir_fd < 0)",
          "443:         {",
          "444:             perror_msg(\"can't open problem directory '%s'\", problem_dir);",
          "445:             return_InvalidProblemDir_error(invocation, problem_dir);",
          "446:             return;",
          "447:         }",
          "449:         int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "444:             return_InvalidProblemDir_error(invocation, problem_dir);",
          "446:             return;",
          "447:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "463:             close(dir_fd);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "450:         {   //caller seems to be in group with access to this dir, so no action needed",
          "451:             log_notice(\"caller has access to the requested directory %s\", problem_dir);",
          "452:             g_dbus_method_invocation_return_value(invocation, NULL);",
          "453:             return;",
          "454:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "471:             close(dir_fd);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "460:             g_dbus_method_invocation_return_dbus_error(invocation,",
          "461:                                               \"org.freedesktop.problems.AuthFailure\",",
          "462:                                               _(\"Not Authorized\"));",
          "463:             return;",
          "464:         }",
          "467:         if (!dd)",
          "468:         {",
          "469:             return_InvalidProblemDir_error(invocation, problem_dir);",
          "",
          "[Removed Lines]",
          "466:         struct dump_dir *dd = dd_opendir(problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);",
          "",
          "[Added Lines]",
          "482:             close(dir_fd);",
          "486:         struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "497:             return;",
          "498:         }",
          "501:         {",
          "502:             if (errno == ENOTDIR)",
          "503:             {",
          "504:                 log_notice(\"Requested directory does not exist '%s'\", problem_dir);",
          "505:                 return_InvalidProblemDir_error(invocation, problem_dir);",
          "506:                 return;",
          "507:             }",
          "",
          "[Removed Lines]",
          "500:         if (!dump_dir_accessible_by_uid(problem_dir, caller_uid))",
          "",
          "[Added Lines]",
          "520:         int dir_fd = dd_openfd(problem_dir);",
          "521:         if (dir_fd < 0)",
          "522:         {",
          "523:             perror_msg(\"can't open problem directory '%s'\", problem_dir);",
          "524:             return_InvalidProblemDir_error(invocation, problem_dir);",
          "525:             return;",
          "526:         }",
          "528:         if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))",
          "534:                 close(dir_fd);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "512:                 g_dbus_method_invocation_return_dbus_error(invocation,",
          "513:                                                   \"org.freedesktop.problems.AuthFailure\",",
          "514:                                                   _(\"Not Authorized\"));",
          "515:                 return;",
          "516:             }",
          "517:         }",
          "520:         if (!dd)",
          "521:         {",
          "522:             return_InvalidProblemDir_error(invocation, problem_dir);",
          "",
          "[Removed Lines]",
          "519:         struct dump_dir *dd = dd_opendir(problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);",
          "",
          "[Added Lines]",
          "544:                 close(dir_fd);",
          "549:         struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "677:         for (GList *l = problem_dirs; l; l = l->next)",
          "678:         {",
          "679:             const char *dir_name = (const char*)l->data;",
          "681:             {",
          "682:                 if (errno == ENOTDIR)",
          "683:                 {",
          "684:                     log_notice(\"Requested directory does not exist '%s'\", dir_name);",
          "685:                     continue;",
          "686:                 }",
          "688:                 if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)",
          "689:                 { // if user didn't provide correct credentials, just move to the next dir",
          "690:                     continue;",
          "691:                 }",
          "692:             }",
          "694:         }",
          "696:         g_dbus_method_invocation_return_value(invocation, NULL);",
          "",
          "[Removed Lines]",
          "680:             if (!dump_dir_accessible_by_uid(dir_name, caller_uid))",
          "693:             delete_dump_dir(dir_name);",
          "",
          "[Added Lines]",
          "711:             int dir_fd = dd_openfd(dir_name);",
          "712:             if (dir_fd < 0)",
          "713:             {",
          "714:                 perror_msg(\"can't open problem directory '%s'\", dir_name);",
          "715:                 return_InvalidProblemDir_error(invocation, dir_name);",
          "716:                 return;",
          "717:             }",
          "719:             if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))",
          "724:                     close(dir_fd);",
          "730:                     close(dir_fd);",
          "735:             struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);",
          "736:             if (dd)",
          "737:             {",
          "738:                 if (dd_delete(dd) != 0)",
          "739:                 {",
          "740:                     error_msg(\"Failed to delete problem directory '%s'\", dir_name);",
          "741:                     dd_close(dd);",
          "742:                 }",
          "743:             }",
          "",
          "---------------"
        ],
        "src/lib/problem_api.c||src/lib/problem_api.c": [
          "File: src/lib/problem_api.c -> src/lib/problem_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:         char *full_name = concat_path_file(path, dent->d_name);",
          "50:         {",
          "",
          "[Removed Lines]",
          "49:         if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid))",
          "",
          "[Added Lines]",
          "50:         int dir_fd = dd_openfd(full_name);",
          "51:         if (dir_fd < 0)",
          "52:         {",
          "53:             VERB2 perror_msg(\"can't open problem directory '%s'\", full_name);",
          "54:             continue;",
          "55:         }",
          "57:         if (caller_uid == -1 || fdump_dir_accessible_by_uid(dir_fd, caller_uid))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:             int sv_logmode = logmode;",
          "56:             logmode = 0;",
          "58:             logmode = sv_logmode;",
          "59:             if (dd)",
          "60:             {",
          "",
          "[Removed Lines]",
          "57:             struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);",
          "",
          "[Added Lines]",
          "65:             struct dump_dir *dd = dd_fdopendir(dir_fd, full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "62:                 dd_close(dd);",
          "63:             }",
          "64:         }",
          "65:         free(full_name);",
          "66:         if (brk)",
          "67:             break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73:         else",
          "74:             close(dir_fd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2acf4b7691165003cae6308f006cef329802f79e",
      "candidate_info": {
        "commit_hash": "2acf4b7691165003cae6308f006cef329802f79e",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/2acf4b7691165003cae6308f006cef329802f79e",
        "files": [
          "src/lib/hooklib.c"
        ],
        "message": "lib: prevent from creating non-root sub-dirs in dump dir\n\nIn the case an uid element doesn't exist in time of dump dir creating, we have\nto create dump dir owned by root.\n\nRelated to rhbz#1264921\n\nSigned-off-by: Matej Habrnal <mhabrnal@redhat.com>",
        "before_after_code_files": [
          "src/lib/hooklib.c||src/lib/hooklib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/hooklib.c||src/lib/hooklib.c"
          ],
          "candidate": [
            "src/lib/hooklib.c||src/lib/hooklib.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/hooklib.c||src/lib/hooklib.c": [
          "File: src/lib/hooklib.c -> src/lib/hooklib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "415:     if (g_settings_privatereports)",
          "416:         dd = create_dump_dir_from_problem_data_ext(pd, g_settings_dump_location, 0);",
          "417:     else",
          "420:     char *problem_id = NULL;",
          "421:     if (dd)",
          "",
          "[Removed Lines]",
          "418:         dd = create_dump_dir_from_problem_data(pd, g_settings_dump_location);",
          "",
          "[Added Lines]",
          "418:     {",
          "419:         if (problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)",
          "420:             dd = create_dump_dir_from_problem_data_ext(pd, g_settings_dump_location, 0);",
          "421:         else",
          "422:             dd = create_dump_dir_from_problem_data(pd, g_settings_dump_location);",
          "423:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a4794b39efc62c9ba92b38b419de3babbbcd8cfb",
      "candidate_info": {
        "commit_hash": "a4794b39efc62c9ba92b38b419de3babbbcd8cfb",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/a4794b39efc62c9ba92b38b419de3babbbcd8cfb",
        "files": [
          "src/hooks/abrt-hook-ccpp.c"
        ],
        "message": "ccpp: postpone changing ownership of new dump directories\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    Currently, dd_create changes ownership of the directory immediately,\n    when it is still empty. This means that any operations within the\n    directory (which happen as the root user) can race with changes to\n    the directory contents by the user. If you delay changing directory\n    ownership until all the files have created and written, this is no\n    longer a problem.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ],
          "candidate": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
          "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "677:     if (dd)",
          "678:     {",
          "679:         char *rootdir = get_rootdir(pid);",
          "",
          "[Removed Lines]",
          "676:     dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);",
          "",
          "[Added Lines]",
          "680:     dd = dd_create_skeleton(path, fsuid, DEFAULT_DUMP_DIR_MODE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "831:         }",
          "832: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "839:         dd_reset_ownership(dd);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-2208",
  "cve_desc": "CRLF injection vulnerability in the LightProcess protocol implementation in hphp/util/light-process.cpp in Facebook HipHop Virtual Machine (HHVM) before 2.4.2 allows remote attackers to execute arbitrary commands by entering a \\n (newline) character before the end of a string.",
  "repo": "facebook/hhvm",
  "patch_hash": "506a44194a9016406c752ad8e010c01aeffc18cc",
  "patch_info": {
    "commit_hash": "506a44194a9016406c752ad8e010c01aeffc18cc",
    "repo": "facebook/hhvm",
    "commit_url": "https://github.com/facebook/hhvm/commit/506a44194a9016406c752ad8e010c01aeffc18cc",
    "files": [
      "hphp/util/light-process.cpp"
    ],
    "message": "Fix escaping in LightProcess protocol\n\nThe LightProcess mechanism sends newline terminated commands\nover a pipe, but didn't escape newlines contained in the payload.\n\nReviewed By: otto\n\nDifferential Revision: D1184482",
    "before_after_code_files": [
      "hphp/util/light-process.cpp||hphp/util/light-process.cpp"
    ]
  },
  "patch_diff": {
    "hphp/util/light-process.cpp||hphp/util/light-process.cpp": [
      "File: hphp/util/light-process.cpp -> hphp/util/light-process.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "46: Mutex LightProcess::s_mutex;",
      "57: static bool send_fd(int afdt_fd, int fd) {",
      "58:   afdt_error_t err;",
      "59:   errno = 0;",
      "",
      "[Removed Lines]",
      "45: static const unsigned int BUFFER_SIZE = 4096;",
      "48: static void read_buf(FILE *fin, char *buf) {",
      "49:   if (!fgets(buf, BUFFER_SIZE, fin)) {",
      "50:     buf[0] = '\\0';",
      "51:     return;",
      "52:   }",
      "54:   buf[strlen(buf) - 1] = '\\0';",
      "55: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "101:   }",
      "102: }",
      "107: static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {",
      "112:   bool read_only = (buf[0] == 'r');",
      "116:   std::string old_cwd = Process::GetCurrentDirectory();",
      "118:   if (old_cwd != cwd) {",
      "123:     }",
      "124:   }",
      "128:   if (old_cwd != cwd && chdir(old_cwd.c_str())) {",
      "",
      "[Removed Lines]",
      "108:   char buf[BUFFER_SIZE];",
      "109:   char cwd[BUFFER_SIZE];",
      "111:   if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';",
      "114:   read_buf(fin, buf);",
      "117:   read_buf(fin, cwd);",
      "119:     if (chdir(cwd)) {",
      "122:       Logger::Warning(\"Light Process failed chdir to %s.\", cwd);",
      "126:   FILE *f = buf[0] ? ::popen(buf, read_only ? \"r\" : \"w\") : nullptr;",
      "",
      "[Added Lines]",
      "94: static void lwp_write(FILE *fout, const std::string &buf) {",
      "95:   size_t len = buf.length();",
      "96:   fwrite(&len, sizeof(len), 1, fout);",
      "97:   fwrite(buf.c_str(), sizeof(buf[0]), len, fout);",
      "98:   fflush(fout);",
      "99: }",
      "101: static void lwp_write_int32(FILE *fout, int32_t d) {",
      "102:   fwrite(&d, sizeof(d), 1, fout);",
      "103:   fflush(fout);",
      "104: }",
      "106: static void lwp_write_int64(FILE *fout, int64_t d) {",
      "107:   fwrite(&d, sizeof(d), 1, fout);",
      "108:   fflush(fout);",
      "109: }",
      "111: static void lwp_read(FILE *fin, std::string &buf) {",
      "112:   size_t len;",
      "113:   fread(&len, sizeof(len), 1, fin);",
      "114:   char *buffer = (char *)malloc(len + 1);",
      "115:   fread(buffer, sizeof(*buffer), len, fin);",
      "116:   buffer[len] = '\\0';",
      "117:   buf = std::string(buffer);",
      "118:   free(buffer);",
      "119: }",
      "121: static void lwp_read_int32(FILE *fin, int32_t &d) {",
      "122:   fread(&d, sizeof(d), 1, fin);",
      "123: }",
      "125: static void lwp_read_int64(FILE *fin, int64_t &d) {",
      "126:   fread(&d, sizeof(d), 1, fin);",
      "127: }",
      "133:   std::string buf;",
      "134:   std::string cwd;",
      "136:   lwp_read(fin, buf);",
      "139:   lwp_read(fin, buf);",
      "142:   lwp_read(fin, cwd);",
      "145:     if (chdir(cwd.c_str())) {",
      "148:       Logger::Warning(\"Light Process failed chdir to %s.\", cwd.c_str());",
      "152:   FILE *f = buf[0] ? ::popen(buf.c_str(), read_only ? \"r\" : \"w\") : nullptr;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "132:   if (f == nullptr) {",
      "133:     Logger::Error(\"Light process failed popen: %d (%s).\", errno,",
      "134:                   folly::errnoStr(errno).c_str());",
      "137:   } else {",
      "140:     int fd = fileno(f);",
      "141:     send_fd(afdt_fd, fd);",
      "142:   }",
      "143: }",
      "145: static void do_pclose(FILE *fin, FILE *fout) {",
      "148:   int64_t fptr = 0;",
      "151:   FILE *f = (FILE *)fptr;",
      "152:   int ret = ::pclose(f);",
      "155:   if (ret < 0) {",
      "157:   }",
      "158:   fflush(fout);",
      "159: }",
      "161: static void do_proc_open(FILE *fin, FILE *fout, int afdt_fd) {",
      "174:   int env_size = 0;",
      "175:   std::vector<std::string> env;",
      "178:   for (int i = 0; i < env_size; i++) {",
      "180:     env.push_back(buf);",
      "181:   }",
      "183:   int pipe_size = 0;",
      "186:   std::vector<int> pvals;",
      "187:   for (int i = 0; i < pipe_size; i++) {",
      "188:     int fd_value;",
      "191:     pvals.push_back(fd_value);",
      "192:   }",
      "",
      "[Removed Lines]",
      "135:     fprintf(fout, \"error\\n\");",
      "136:     fflush(fout);",
      "138:     fprintf(fout, \"success\\n%\" PRId64 \"\\n\", (int64_t)f);",
      "139:     fflush(fout);",
      "146:   char buf[BUFFER_SIZE];",
      "149:   read_buf(fin, buf);",
      "150:   sscanf(buf, \"%\" PRId64, &fptr);",
      "154:   fprintf(fout, \"%d\\n\", ret);",
      "156:     fprintf(fout, \"%d\\n\", errno);",
      "162:   char cmd[BUFFER_SIZE];",
      "163:   read_buf(fin, cmd);",
      "164:   if (strlen(cmd) == 0) {",
      "165:     fprintf(fout, \"error\\n%d\\n\", ENOENT);",
      "166:     fflush(fout);",
      "167:     return;",
      "168:   }",
      "170:   char cwd[BUFFER_SIZE];",
      "171:   read_buf(fin, cwd);",
      "173:   char buf[BUFFER_SIZE];",
      "176:   read_buf(fin, buf);",
      "177:   sscanf(buf, \"%d\", &env_size);",
      "179:     read_buf(fin, buf);",
      "184:   read_buf(fin, buf);",
      "185:   sscanf(buf, \"%d\", &pipe_size);",
      "189:     read_buf(fin, buf);",
      "190:     sscanf(buf, \"%d\", &fd_value);",
      "",
      "[Added Lines]",
      "161:     lwp_write(fout, \"error\");",
      "163:     lwp_write(fout, \"success\");",
      "164:     lwp_write_int64(fout, (int64_t)f);",
      "172:   lwp_read_int64(fin, fptr);",
      "176:   lwp_write_int32(fout, ret);",
      "178:     lwp_write_int32(fout, errno);",
      "184:   std::string cmd;",
      "185:   lwp_read(fin, cmd);",
      "187:   std::string cwd;",
      "188:   lwp_read(fin, cwd);",
      "190:   std::string buf;",
      "193:   lwp_read_int32(fin, env_size);",
      "195:     lwp_read(fin, buf);",
      "200:   lwp_read_int32(fin, pipe_size);",
      "204:     lwp_read_int32(fin, fd_value);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "195:   for (int i = 0; i < pipe_size; i++) {",
      "196:     int fd = recv_fd(afdt_fd);",
      "197:     if (fd < 0) {",
      "199:       fflush(fout);",
      "200:       close_fds(pkeys);",
      "201:       return;",
      "",
      "[Removed Lines]",
      "198:       fprintf(fout, \"error\\n%d\\n\", EPROTO);",
      "",
      "[Added Lines]",
      "212:       lwp_write(fout, \"error\");",
      "213:       lwp_write_int32(fout, EPROTO);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "203:     pkeys.push_back(fd);",
      "204:   }",
      "207:   pid_t child = fork();",
      "208:   if (child == 0) {",
      "209:     for (int i = 0; i < pipe_size; i++) {",
      "210:       dup2(pkeys[i], pvals[i]);",
      "211:     }",
      "215:     }",
      "216:     if (!env.empty()) {",
      "217:       char **envp = build_envp(env);",
      "219:       free(envp);",
      "220:     } else {",
      "222:     }",
      "223:     _exit(127);",
      "224:   } else if (child > 0) {",
      "227:     fflush(fout);",
      "228:   } else {",
      "231:     fflush(fout);",
      "232:   }",
      "",
      "[Removed Lines]",
      "212:     if (strlen(cwd) > 0 && chdir(cwd)) {",
      "218:       execle(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr, envp);",
      "221:       execl(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr);",
      "226:     fprintf(fout, \"%\" PRId64 \"\\n\", (int64_t)child);",
      "230:     fprintf(fout, \"error\\n%d\\n\", errno);",
      "",
      "[Added Lines]",
      "222:   if (cmd.length() == 0) {",
      "223:     lwp_write(fout, \"error\");",
      "224:     lwp_write_int32(fout, ENOENT);",
      "225:     return;",
      "226:   }",
      "234:     if (cwd.length() > 0 && chdir(cwd.c_str())) {",
      "240:       execle(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr, envp);",
      "243:       execl(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr);",
      "248:     lwp_write(fout, \"success\");",
      "249:     lwp_write_int64(fout, (int64_t)child);",
      "253:     lwp_write(fout, \"error\");",
      "254:     lwp_write_int32(fout, errno);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "243: }",
      "245: static void do_waitpid(FILE *fin, FILE *fout) {",
      "248:   int64_t p = -1;",
      "249:   int options = 0;",
      "250:   int timeout = 0;",
      "252:   pid_t pid = (pid_t)p;",
      "253:   int stat;",
      "254:   if (timeout > 0) {",
      "",
      "[Removed Lines]",
      "246:   char buf[BUFFER_SIZE];",
      "247:   read_buf(fin, buf);",
      "251:   sscanf(buf, \"%\" PRId64 \" %d %d\", &p, &options, &timeout);",
      "",
      "[Added Lines]",
      "273:   lwp_read_int64(fin, p);",
      "274:   lwp_read_int32(fin, options);",
      "275:   lwp_read_int32(fin, timeout);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "256:     signal(SIGALRM, kill_handler);",
      "257:     alarm(timeout);",
      "258:   }",
      "259:   pid_t ret = ::waitpid(pid, &stat, options);",
      "260:   alarm(0); // cancel the previous alarm if not triggered yet",
      "261:   waited = 0;",
      "263:   if (ret < 0) {",
      "265:   }",
      "266:   fflush(fout);",
      "267: }",
      "269: static void do_change_user(FILE *fin, FILE *fout) {",
      "274:     if (pw) {",
      "275:       if (pw->pw_gid) {",
      "276:         setgid(pw->pw_gid);",
      "",
      "[Removed Lines]",
      "262:   fprintf(fout, \"%\" PRId64 \" %d\\n\", (int64_t)ret, stat);",
      "264:     fprintf(fout, \"%d\\n\", errno);",
      "270:   char uname[BUFFER_SIZE];",
      "271:   read_buf(fin, uname);",
      "272:   if (strlen(uname) > 0) {",
      "273:     struct passwd *pw = getpwnam(uname);",
      "",
      "[Added Lines]",
      "288:   lwp_write_int64(fout, ret);",
      "289:   lwp_write_int32(fout, stat);",
      "291:     lwp_write_int32(fout, errno);",
      "297:   std::string uname;",
      "298:   lwp_read(fin, uname);",
      "299:   if (uname.length() > 0) {",
      "300:     struct passwd *pw = getpwnam(uname.c_str());",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "448: void LightProcess::closeShadow() {",
      "449:   Lock lock(m_procMutex);",
      "450:   if (m_shadowProcess) {",
      "452:     fflush(m_fout);",
      "453:     fclose(m_fin);",
      "454:     fclose(m_fout);",
      "",
      "[Removed Lines]",
      "451:     fprintf(m_fout, \"exit\\n\");",
      "",
      "[Added Lines]",
      "478:     lwp_write(m_fout, \"exit\");",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "480:   FILE *fin = fdopen(fdin, \"r\");",
      "481:   FILE *fout = fdopen(fdout, \"w\");",
      "485:   pollfd pfd[1];",
      "486:   pfd[0].fd = fdin;",
      "",
      "[Removed Lines]",
      "483:   char buf[BUFFER_SIZE];",
      "",
      "[Added Lines]",
      "510:   std::string buf;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "491:       continue;",
      "492:     }",
      "493:     if (pfd[0].revents & POLLIN) {",
      "496:         Logger::Info(\"LightProcess exiting upon request\");",
      "497:         break;",
      "499:         do_popen(fin, fout, m_afdt_fd);",
      "501:         do_pclose(fin, fout);",
      "503:         do_proc_open(fin, fout, m_afdt_fd);",
      "505:         do_waitpid(fin, fout);",
      "507:         do_change_user(fin, fout);",
      "508:       } else if (buf[0]) {",
      "510:       }",
      "511:     } else if (pfd[0].revents & POLLHUP) {",
      "",
      "[Removed Lines]",
      "494:       if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';",
      "495:       if (strncmp(buf, \"exit\", 4) == 0) {",
      "498:       } else if (strncmp(buf, \"popen\", 5) == 0) {",
      "500:       } else if (strncmp(buf, \"pclose\", 6) == 0) {",
      "502:       } else if (strncmp(buf, \"proc_open\", 9) == 0) {",
      "504:       } else if (strncmp(buf, \"waitpid\", 7) == 0) {",
      "506:       } else if (strncmp(buf, \"change_user\", 11) == 0) {",
      "509:         Logger::Info(\"LightProcess got invalid command: %.20s\", buf);",
      "",
      "[Added Lines]",
      "521:       lwp_read(fin, buf);",
      "522:       if (buf == \"exit\") {",
      "525:       } else if (buf == \"popen\") {",
      "527:       } else if (buf == \"pclose\") {",
      "529:       } else if (buf == \"proc_open\") {",
      "531:       } else if (buf == \"waitpid\") {",
      "533:       } else if (buf == \"change_user\") {",
      "536:         Logger::Info(\"LightProcess got invalid command: %.20s\", buf.c_str());",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "566:   int id = GetId();",
      "567:   Lock lock(g_procs[id].m_procMutex);",
      "575:     return nullptr;",
      "576:   }",
      "578:   int64_t fptr = 0;",
      "581:   if (!fptr) {",
      "582:     Logger::Error(\"Light process failed to return the file pointer.\");",
      "583:     return nullptr;",
      "",
      "[Removed Lines]",
      "569:   fprintf(g_procs[id].m_fout, \"popen\\n%s\\n%s\\n%s\\n\", type, cmd, cwd);",
      "570:   fflush(g_procs[id].m_fout);",
      "572:   char buf[BUFFER_SIZE];",
      "573:   read_buf(g_procs[id].m_fin, buf);",
      "574:   if (strncmp(buf, \"error\", 5) == 0) {",
      "579:   read_buf(g_procs[id].m_fin, buf);",
      "580:   sscanf(buf, \"%\" PRId64, &fptr);",
      "",
      "[Added Lines]",
      "596:   FILE *fout = g_procs[id].m_fout;",
      "597:   lwp_write(fout, \"popen\");",
      "598:   lwp_write(fout, type);",
      "599:   lwp_write(fout, cmd);",
      "600:   lwp_write(fout, cwd ? cwd : \"\");",
      "601:   fflush(fout);",
      "603:   std::string buf;",
      "604:   FILE *fin = g_procs[id].m_fin;",
      "605:   lwp_read(fin, buf);",
      "606:   if (buf == \"error\") {",
      "611:   lwp_read_int64(fin, fptr);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "611:   int64_t f2 = it->second;",
      "612:   g_procs[id].m_popenMap.erase((int64_t)f);",
      "613:   fclose(f);",
      "619:   int ret = -1;",
      "621:   if (ret < 0) {",
      "624:   }",
      "625:   return ret;",
      "626: }",
      "",
      "[Removed Lines]",
      "614:   fprintf(g_procs[id].m_fout, \"pclose\\n%\" PRId64 \"\\n\", f2);",
      "615:   fflush(g_procs[id].m_fout);",
      "617:   char buf[BUFFER_SIZE];",
      "618:   read_buf(g_procs[id].m_fin, buf);",
      "620:   sscanf(buf, \"%d\", &ret);",
      "622:     read_buf(g_procs[id].m_fin, buf);",
      "623:     sscanf(buf, \"%d\", &errno);",
      "",
      "[Added Lines]",
      "646:   lwp_write(g_procs[id].m_fout, \"pclose\");",
      "647:   lwp_write_int64(g_procs[id].m_fout, f2);",
      "650:   lwp_read_int32(g_procs[id].m_fin, ret);",
      "652:     lwp_read_int32(g_procs[id].m_fin, errno);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "634:   always_assert(Available());",
      "635:   always_assert(created.size() == desired.size());",
      "642:   for (unsigned int i = 0; i < env.size(); i++) {",
      "644:   }",
      "648:   for (unsigned int i = 0; i < desired.size(); i++) {",
      "650:   }",
      "652:   bool error_send = false;",
      "653:   int save_errno = 0;",
      "654:   for (unsigned int i = 0; i < created.size(); i++) {",
      "",
      "[Removed Lines]",
      "637:   if (fprintf(g_procs[id].m_fout, \"proc_open\\n%s\\n%s\\n\", cmd, cwd) <= 0) {",
      "638:     Logger::Error(\"Failed to send command proc_open\");",
      "639:     return -1;",
      "640:   }",
      "641:   fprintf(g_procs[id].m_fout, \"%d\\n\", (int)env.size());",
      "643:     fprintf(g_procs[id].m_fout, \"%s\\n\", env[i].c_str());",
      "646:   fprintf(g_procs[id].m_fout, \"%d\\n\", (int)created.size());",
      "649:     fprintf(g_procs[id].m_fout, \"%d\\n\", desired[i]);",
      "651:   fflush(g_procs[id].m_fout);",
      "",
      "[Added Lines]",
      "666:   FILE *fout = g_procs[id].m_fout;",
      "667:   lwp_write(fout, \"proc_open\");",
      "668:   lwp_write(fout, cmd);",
      "669:   lwp_write(fout, cwd ? cwd : \"\");",
      "670:   lwp_write_int32(fout, (int)env.size());",
      "672:     lwp_write(fout, env[i]);",
      "675:   lwp_write_int32(fout, (int)created.size());",
      "677:     lwp_write_int32(fout, desired[i]);",
      "679:   fflush(fout);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "659:     }",
      "660:   }",
      "667:     if (error_send) {",
      "",
      "[Removed Lines]",
      "662:   char buf[BUFFER_SIZE];",
      "663:   read_buf(g_procs[id].m_fin, buf);",
      "664:   if (strncmp(buf, \"error\", 5) == 0) {",
      "665:     read_buf(g_procs[id].m_fin, buf);",
      "666:     sscanf(buf, \"%d\", &errno);",
      "",
      "[Added Lines]",
      "691:   std::string buf;",
      "692:   FILE *fin = g_procs[id].m_fin;",
      "693:   lwp_read(fin, buf);",
      "694:   if (buf == \"error\") {",
      "695:     lwp_read_int32(fin, errno);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "671:     }",
      "672:     return -1;",
      "673:   }",
      "674:   int64_t pid = -1;",
      "677:   return (pid_t)pid;",
      "678: }",
      "",
      "[Removed Lines]",
      "675:   sscanf(buf, \"%\" PRId64, &pid);",
      "676:   assert(pid);",
      "",
      "[Added Lines]",
      "703:   always_assert(buf == \"success\");",
      "705:   lwp_read_int64(fin, pid);",
      "706:   always_assert(pid);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "687:   int id = GetId();",
      "688:   Lock lock(g_procs[id].m_procMutex);",
      "692:   fflush(g_procs[id].m_fout);",
      "697:   int64_t ret;",
      "698:   int stat;",
      "701:   if (ret < 0) {",
      "704:   }",
      "705:   return (pid_t)ret;",
      "706: }",
      "",
      "[Removed Lines]",
      "690:   fprintf(g_procs[id].m_fout, \"waitpid\\n%\" PRId64 \" %d %d\\n\", (int64_t)pid, options,",
      "691:           timeout);",
      "694:   char buf[BUFFER_SIZE];",
      "695:   read_buf(g_procs[id].m_fin, buf);",
      "696:   if (!buf[0]) return -1;",
      "699:   sscanf(buf, \"%\" PRId64 \" %d\", &ret, &stat);",
      "702:     read_buf(g_procs[id].m_fin, buf);",
      "703:     sscanf(buf, \"%d\", &errno);",
      "",
      "[Added Lines]",
      "720:   FILE *fout = g_procs[id].m_fout;",
      "721:   lwp_write(fout, \"waitpid\");",
      "722:   lwp_write_int64(fout, (int64_t)pid);",
      "723:   lwp_write_int32(fout, options);",
      "724:   lwp_write_int32(fout, timeout);",
      "729:   FILE *fin = g_procs[id].m_fin;",
      "730:   lwp_read_int64(fin, ret);",
      "731:   lwp_read_int32(fin, stat);",
      "735:     lwp_read_int32(fin, errno);",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "726:   if (username.empty()) return;",
      "727:   for (int i = 0; i < g_procsCount; i++) {",
      "728:     Lock lock(g_procs[i].m_procMutex);",
      "731:   }",
      "732: }",
      "",
      "[Removed Lines]",
      "729:     fprintf(g_procs[i].m_fout, \"change_user\\n%s\\n\", username.c_str());",
      "730:     fflush(g_procs[i].m_fout);",
      "",
      "[Added Lines]",
      "761:     FILE *fout = g_procs[i].m_fout;",
      "762:     lwp_write(fout, \"change_user\");",
      "763:     lwp_write(fout, username);",
      "764:     fflush(fout);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "37515c5753349f77cbcb59c18c6ccff5ec371827",
      "candidate_info": {
        "commit_hash": "37515c5753349f77cbcb59c18c6ccff5ec371827",
        "repo": "facebook/hhvm",
        "commit_url": "https://github.com/facebook/hhvm/commit/37515c5753349f77cbcb59c18c6ccff5ec371827",
        "files": [
          "hphp/util/light-process.cpp"
        ],
        "message": "Fix escaping in LightProcess protocol\n\nThe LightProcess mechanism sends newline terminated commands\nover a pipe, but didn't escape newlines contained in the payload.\n\nReviewed By: otto\n\nDifferential Revision: D1184482",
        "before_after_code_files": [
          "hphp/util/light-process.cpp||hphp/util/light-process.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hphp/util/light-process.cpp||hphp/util/light-process.cpp"
          ],
          "candidate": [
            "hphp/util/light-process.cpp||hphp/util/light-process.cpp"
          ]
        }
      },
      "candidate_diff": {
        "hphp/util/light-process.cpp||hphp/util/light-process.cpp": [
          "File: hphp/util/light-process.cpp -> hphp/util/light-process.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: Mutex LightProcess::s_mutex;",
          "56: static bool send_fd(int afdt_fd, int fd) {",
          "57:   afdt_error_t err;",
          "58:   errno = 0;",
          "",
          "[Removed Lines]",
          "44: static const unsigned int BUFFER_SIZE = 4096;",
          "47: static void read_buf(FILE *fin, char *buf) {",
          "48:   if (!fgets(buf, BUFFER_SIZE, fin)) {",
          "49:     buf[0] = '\\0';",
          "50:     return;",
          "51:   }",
          "53:   buf[strlen(buf) - 1] = '\\0';",
          "54: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:   }",
          "101: }",
          "106: static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {",
          "111:   bool read_only = (buf[0] == 'r');",
          "115:   std::string old_cwd = Process::GetCurrentDirectory();",
          "117:   if (old_cwd != cwd) {",
          "122:     }",
          "123:   }",
          "127:   if (old_cwd != cwd && chdir(old_cwd.c_str())) {",
          "",
          "[Removed Lines]",
          "107:   char buf[BUFFER_SIZE];",
          "108:   char cwd[BUFFER_SIZE];",
          "110:   if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';",
          "113:   read_buf(fin, buf);",
          "116:   read_buf(fin, cwd);",
          "118:     if (chdir(cwd)) {",
          "121:       Logger::Warning(\"Light Process failed chdir to %s.\", cwd);",
          "125:   FILE *f = buf[0] ? ::popen(buf, read_only ? \"r\" : \"w\") : nullptr;",
          "",
          "[Added Lines]",
          "93: static void lwp_write(FILE *fout, const std::string &buf) {",
          "94:   size_t len = buf.length();",
          "95:   fwrite(&len, sizeof(len), 1, fout);",
          "96:   fwrite(buf.c_str(), sizeof(buf[0]), len, fout);",
          "97:   fflush(fout);",
          "98: }",
          "100: static void lwp_write_int32(FILE *fout, int32_t d) {",
          "101:   fwrite(&d, sizeof(d), 1, fout);",
          "102:   fflush(fout);",
          "103: }",
          "105: static void lwp_write_int64(FILE *fout, int64_t d) {",
          "106:   fwrite(&d, sizeof(d), 1, fout);",
          "107:   fflush(fout);",
          "108: }",
          "110: static void lwp_read(FILE *fin, std::string &buf) {",
          "111:   size_t len;",
          "112:   fread(&len, sizeof(len), 1, fin);",
          "113:   char *buffer = (char *)malloc(len + 1);",
          "114:   fread(buffer, sizeof(*buffer), len, fin);",
          "115:   buffer[len] = '\\0';",
          "116:   buf = std::string(buffer);",
          "117:   free(buffer);",
          "118: }",
          "120: static void lwp_read_int32(FILE *fin, int32_t &d) {",
          "121:   fread(&d, sizeof(d), 1, fin);",
          "122: }",
          "124: static void lwp_read_int64(FILE *fin, int64_t &d) {",
          "125:   fread(&d, sizeof(d), 1, fin);",
          "126: }",
          "132:   std::string buf;",
          "133:   std::string cwd;",
          "135:   lwp_read(fin, buf);",
          "138:   lwp_read(fin, buf);",
          "141:   lwp_read(fin, cwd);",
          "144:     if (chdir(cwd.c_str())) {",
          "147:       Logger::Warning(\"Light Process failed chdir to %s.\", cwd.c_str());",
          "151:   FILE *f = buf[0] ? ::popen(buf.c_str(), read_only ? \"r\" : \"w\") : nullptr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131:   if (f == nullptr) {",
          "132:     Logger::Error(\"Light process failed popen: %d (%s).\", errno,",
          "133:                   folly::errnoStr(errno).c_str());",
          "136:   } else {",
          "139:     int fd = fileno(f);",
          "140:     send_fd(afdt_fd, fd);",
          "141:   }",
          "142: }",
          "144: static void do_pclose(FILE *fin, FILE *fout) {",
          "147:   int64_t fptr = 0;",
          "150:   FILE *f = (FILE *)fptr;",
          "151:   int ret = ::pclose(f);",
          "154:   if (ret < 0) {",
          "156:   }",
          "157:   fflush(fout);",
          "158: }",
          "160: static void do_proc_open(FILE *fin, FILE *fout, int afdt_fd) {",
          "173:   int env_size = 0;",
          "174:   std::vector<std::string> env;",
          "177:   for (int i = 0; i < env_size; i++) {",
          "179:     env.push_back(buf);",
          "180:   }",
          "182:   int pipe_size = 0;",
          "185:   std::vector<int> pvals;",
          "186:   for (int i = 0; i < pipe_size; i++) {",
          "187:     int fd_value;",
          "190:     pvals.push_back(fd_value);",
          "191:   }",
          "",
          "[Removed Lines]",
          "134:     fprintf(fout, \"error\\n\");",
          "135:     fflush(fout);",
          "137:     fprintf(fout, \"success\\n%\" PRId64 \"\\n\", (int64_t)f);",
          "138:     fflush(fout);",
          "145:   char buf[BUFFER_SIZE];",
          "148:   read_buf(fin, buf);",
          "149:   sscanf(buf, \"%\" PRId64, &fptr);",
          "153:   fprintf(fout, \"%d\\n\", ret);",
          "155:     fprintf(fout, \"%d\\n\", errno);",
          "161:   char cmd[BUFFER_SIZE];",
          "162:   read_buf(fin, cmd);",
          "163:   if (strlen(cmd) == 0) {",
          "164:     fprintf(fout, \"error\\n%d\\n\", ENOENT);",
          "165:     fflush(fout);",
          "166:     return;",
          "167:   }",
          "169:   char cwd[BUFFER_SIZE];",
          "170:   read_buf(fin, cwd);",
          "172:   char buf[BUFFER_SIZE];",
          "175:   read_buf(fin, buf);",
          "176:   sscanf(buf, \"%d\", &env_size);",
          "178:     read_buf(fin, buf);",
          "183:   read_buf(fin, buf);",
          "184:   sscanf(buf, \"%d\", &pipe_size);",
          "188:     read_buf(fin, buf);",
          "189:     sscanf(buf, \"%d\", &fd_value);",
          "",
          "[Added Lines]",
          "160:     lwp_write(fout, \"error\");",
          "162:     lwp_write(fout, \"success\");",
          "163:     lwp_write_int64(fout, (int64_t)f);",
          "171:   lwp_read_int64(fin, fptr);",
          "175:   lwp_write_int32(fout, ret);",
          "177:     lwp_write_int32(fout, errno);",
          "183:   std::string cmd;",
          "184:   lwp_read(fin, cmd);",
          "186:   std::string cwd;",
          "187:   lwp_read(fin, cwd);",
          "189:   std::string buf;",
          "192:   lwp_read_int32(fin, env_size);",
          "194:     lwp_read(fin, buf);",
          "199:   lwp_read_int32(fin, pipe_size);",
          "203:     lwp_read_int32(fin, fd_value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "194:   for (int i = 0; i < pipe_size; i++) {",
          "195:     int fd = recv_fd(afdt_fd);",
          "196:     if (fd < 0) {",
          "198:       fflush(fout);",
          "199:       close_fds(pkeys);",
          "200:       return;",
          "",
          "[Removed Lines]",
          "197:       fprintf(fout, \"error\\n%d\\n\", EPROTO);",
          "",
          "[Added Lines]",
          "211:       lwp_write(fout, \"error\");",
          "212:       lwp_write_int32(fout, EPROTO);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "202:     pkeys.push_back(fd);",
          "203:   }",
          "206:   pid_t child = fork();",
          "207:   if (child == 0) {",
          "208:     for (int i = 0; i < pipe_size; i++) {",
          "209:       dup2(pkeys[i], pvals[i]);",
          "210:     }",
          "214:     }",
          "215:     if (!env.empty()) {",
          "216:       char **envp = build_envp(env);",
          "218:       free(envp);",
          "219:     } else {",
          "221:     }",
          "222:     _exit(127);",
          "223:   } else if (child > 0) {",
          "226:     fflush(fout);",
          "227:   } else {",
          "230:     fflush(fout);",
          "231:   }",
          "",
          "[Removed Lines]",
          "211:     if (strlen(cwd) > 0 && chdir(cwd)) {",
          "217:       execle(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr, envp);",
          "220:       execl(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr);",
          "225:     fprintf(fout, \"%\" PRId64 \"\\n\", (int64_t)child);",
          "229:     fprintf(fout, \"error\\n%d\\n\", errno);",
          "",
          "[Added Lines]",
          "221:   if (cmd.length() == 0) {",
          "222:     lwp_write(fout, \"error\");",
          "223:     lwp_write_int32(fout, ENOENT);",
          "224:     return;",
          "225:   }",
          "233:     if (cwd.length() > 0 && chdir(cwd.c_str())) {",
          "239:       execle(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr, envp);",
          "242:       execl(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr);",
          "247:     lwp_write(fout, \"success\");",
          "248:     lwp_write_int64(fout, (int64_t)child);",
          "252:     lwp_write(fout, \"error\");",
          "253:     lwp_write_int32(fout, errno);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "242: }",
          "244: static void do_waitpid(FILE *fin, FILE *fout) {",
          "247:   int64_t p = -1;",
          "248:   int options = 0;",
          "249:   int timeout = 0;",
          "251:   pid_t pid = (pid_t)p;",
          "252:   int stat;",
          "253:   if (timeout > 0) {",
          "",
          "[Removed Lines]",
          "245:   char buf[BUFFER_SIZE];",
          "246:   read_buf(fin, buf);",
          "250:   sscanf(buf, \"%\" PRId64 \" %d %d\", &p, &options, &timeout);",
          "",
          "[Added Lines]",
          "272:   lwp_read_int64(fin, p);",
          "273:   lwp_read_int32(fin, options);",
          "274:   lwp_read_int32(fin, timeout);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "255:     signal(SIGALRM, kill_handler);",
          "256:     alarm(timeout);",
          "257:   }",
          "258:   pid_t ret = ::waitpid(pid, &stat, options);",
          "259:   alarm(0); // cancel the previous alarm if not triggered yet",
          "260:   waited = 0;",
          "262:   if (ret < 0) {",
          "264:   }",
          "265:   fflush(fout);",
          "266: }",
          "268: static void do_change_user(FILE *fin, FILE *fout) {",
          "273:     if (pw) {",
          "274:       if (pw->pw_gid) {",
          "275:         setgid(pw->pw_gid);",
          "",
          "[Removed Lines]",
          "261:   fprintf(fout, \"%\" PRId64 \" %d\\n\", (int64_t)ret, stat);",
          "263:     fprintf(fout, \"%d\\n\", errno);",
          "269:   char uname[BUFFER_SIZE];",
          "270:   read_buf(fin, uname);",
          "271:   if (strlen(uname) > 0) {",
          "272:     struct passwd *pw = getpwnam(uname);",
          "",
          "[Added Lines]",
          "287:   lwp_write_int64(fout, ret);",
          "288:   lwp_write_int32(fout, stat);",
          "290:     lwp_write_int32(fout, errno);",
          "296:   std::string uname;",
          "297:   lwp_read(fin, uname);",
          "298:   if (uname.length() > 0) {",
          "299:     struct passwd *pw = getpwnam(uname.c_str());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "447: void LightProcess::closeShadow() {",
          "448:   Lock lock(m_procMutex);",
          "449:   if (m_shadowProcess) {",
          "451:     fflush(m_fout);",
          "452:     fclose(m_fin);",
          "453:     fclose(m_fout);",
          "",
          "[Removed Lines]",
          "450:     fprintf(m_fout, \"exit\\n\");",
          "",
          "[Added Lines]",
          "477:     lwp_write(m_fout, \"exit\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "479:   FILE *fin = fdopen(fdin, \"r\");",
          "480:   FILE *fout = fdopen(fdout, \"w\");",
          "484:   pollfd pfd[1];",
          "485:   pfd[0].fd = fdin;",
          "",
          "[Removed Lines]",
          "482:   char buf[BUFFER_SIZE];",
          "",
          "[Added Lines]",
          "509:   std::string buf;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "490:       continue;",
          "491:     }",
          "492:     if (pfd[0].revents & POLLIN) {",
          "495:         Logger::Info(\"LightProcess exiting upon request\");",
          "496:         break;",
          "498:         do_popen(fin, fout, m_afdt_fd);",
          "500:         do_pclose(fin, fout);",
          "502:         do_proc_open(fin, fout, m_afdt_fd);",
          "504:         do_waitpid(fin, fout);",
          "506:         do_change_user(fin, fout);",
          "507:       } else if (buf[0]) {",
          "509:       }",
          "510:     } else if (pfd[0].revents & POLLHUP) {",
          "",
          "[Removed Lines]",
          "493:       if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';",
          "494:       if (strncmp(buf, \"exit\", 4) == 0) {",
          "497:       } else if (strncmp(buf, \"popen\", 5) == 0) {",
          "499:       } else if (strncmp(buf, \"pclose\", 6) == 0) {",
          "501:       } else if (strncmp(buf, \"proc_open\", 9) == 0) {",
          "503:       } else if (strncmp(buf, \"waitpid\", 7) == 0) {",
          "505:       } else if (strncmp(buf, \"change_user\", 11) == 0) {",
          "508:         Logger::Info(\"LightProcess got invalid command: %.20s\", buf);",
          "",
          "[Added Lines]",
          "520:       lwp_read(fin, buf);",
          "521:       if (buf == \"exit\") {",
          "524:       } else if (buf == \"popen\") {",
          "526:       } else if (buf == \"pclose\") {",
          "528:       } else if (buf == \"proc_open\") {",
          "530:       } else if (buf == \"waitpid\") {",
          "532:       } else if (buf == \"change_user\") {",
          "535:         Logger::Info(\"LightProcess got invalid command: %.20s\", buf.c_str());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "565:   int id = GetId();",
          "566:   Lock lock(g_procs[id].m_procMutex);",
          "574:     return nullptr;",
          "575:   }",
          "577:   int64_t fptr = 0;",
          "580:   if (!fptr) {",
          "581:     Logger::Error(\"Light process failed to return the file pointer.\");",
          "582:     return nullptr;",
          "",
          "[Removed Lines]",
          "568:   fprintf(g_procs[id].m_fout, \"popen\\n%s\\n%s\\n%s\\n\", type, cmd, cwd);",
          "569:   fflush(g_procs[id].m_fout);",
          "571:   char buf[BUFFER_SIZE];",
          "572:   read_buf(g_procs[id].m_fin, buf);",
          "573:   if (strncmp(buf, \"error\", 5) == 0) {",
          "578:   read_buf(g_procs[id].m_fin, buf);",
          "579:   sscanf(buf, \"%\" PRId64, &fptr);",
          "",
          "[Added Lines]",
          "595:   FILE *fout = g_procs[id].m_fout;",
          "596:   lwp_write(fout, \"popen\");",
          "597:   lwp_write(fout, type);",
          "598:   lwp_write(fout, cmd);",
          "599:   lwp_write(fout, cwd ? cwd : \"\");",
          "600:   fflush(fout);",
          "602:   std::string buf;",
          "603:   FILE *fin = g_procs[id].m_fin;",
          "604:   lwp_read(fin, buf);",
          "605:   if (buf == \"error\") {",
          "610:   lwp_read_int64(fin, fptr);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "610:   int64_t f2 = it->second;",
          "611:   g_procs[id].m_popenMap.erase((int64_t)f);",
          "612:   fclose(f);",
          "618:   int ret = -1;",
          "620:   if (ret < 0) {",
          "623:   }",
          "624:   return ret;",
          "625: }",
          "",
          "[Removed Lines]",
          "613:   fprintf(g_procs[id].m_fout, \"pclose\\n%\" PRId64 \"\\n\", f2);",
          "614:   fflush(g_procs[id].m_fout);",
          "616:   char buf[BUFFER_SIZE];",
          "617:   read_buf(g_procs[id].m_fin, buf);",
          "619:   sscanf(buf, \"%d\", &ret);",
          "621:     read_buf(g_procs[id].m_fin, buf);",
          "622:     sscanf(buf, \"%d\", &errno);",
          "",
          "[Added Lines]",
          "645:   lwp_write(g_procs[id].m_fout, \"pclose\");",
          "646:   lwp_write_int64(g_procs[id].m_fout, f2);",
          "649:   lwp_read_int32(g_procs[id].m_fin, ret);",
          "651:     lwp_read_int32(g_procs[id].m_fin, errno);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "633:   always_assert(Available());",
          "634:   always_assert(created.size() == desired.size());",
          "641:   for (unsigned int i = 0; i < env.size(); i++) {",
          "643:   }",
          "647:   for (unsigned int i = 0; i < desired.size(); i++) {",
          "649:   }",
          "651:   bool error_send = false;",
          "652:   int save_errno = 0;",
          "653:   for (unsigned int i = 0; i < created.size(); i++) {",
          "",
          "[Removed Lines]",
          "636:   if (fprintf(g_procs[id].m_fout, \"proc_open\\n%s\\n%s\\n\", cmd, cwd) <= 0) {",
          "637:     Logger::Error(\"Failed to send command proc_open\");",
          "638:     return -1;",
          "639:   }",
          "640:   fprintf(g_procs[id].m_fout, \"%d\\n\", (int)env.size());",
          "642:     fprintf(g_procs[id].m_fout, \"%s\\n\", env[i].c_str());",
          "645:   fprintf(g_procs[id].m_fout, \"%d\\n\", (int)created.size());",
          "648:     fprintf(g_procs[id].m_fout, \"%d\\n\", desired[i]);",
          "650:   fflush(g_procs[id].m_fout);",
          "",
          "[Added Lines]",
          "665:   FILE *fout = g_procs[id].m_fout;",
          "666:   lwp_write(fout, \"proc_open\");",
          "667:   lwp_write(fout, cmd);",
          "668:   lwp_write(fout, cwd ? cwd : \"\");",
          "669:   lwp_write_int32(fout, (int)env.size());",
          "671:     lwp_write(fout, env[i]);",
          "674:   lwp_write_int32(fout, (int)created.size());",
          "676:     lwp_write_int32(fout, desired[i]);",
          "678:   fflush(fout);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "658:     }",
          "659:   }",
          "666:     if (error_send) {",
          "",
          "[Removed Lines]",
          "661:   char buf[BUFFER_SIZE];",
          "662:   read_buf(g_procs[id].m_fin, buf);",
          "663:   if (strncmp(buf, \"error\", 5) == 0) {",
          "664:     read_buf(g_procs[id].m_fin, buf);",
          "665:     sscanf(buf, \"%d\", &errno);",
          "",
          "[Added Lines]",
          "690:   std::string buf;",
          "691:   FILE *fin = g_procs[id].m_fin;",
          "692:   lwp_read(fin, buf);",
          "693:   if (buf == \"error\") {",
          "694:     lwp_read_int32(fin, errno);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "670:     }",
          "671:     return -1;",
          "672:   }",
          "673:   int64_t pid = -1;",
          "676:   return (pid_t)pid;",
          "677: }",
          "",
          "[Removed Lines]",
          "674:   sscanf(buf, \"%\" PRId64, &pid);",
          "675:   assert(pid);",
          "",
          "[Added Lines]",
          "702:   always_assert(buf == \"success\");",
          "704:   lwp_read_int64(fin, pid);",
          "705:   always_assert(pid);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "686:   int id = GetId();",
          "687:   Lock lock(g_procs[id].m_procMutex);",
          "691:   fflush(g_procs[id].m_fout);",
          "696:   int64_t ret;",
          "697:   int stat;",
          "700:   if (ret < 0) {",
          "703:   }",
          "704:   return (pid_t)ret;",
          "705: }",
          "",
          "[Removed Lines]",
          "689:   fprintf(g_procs[id].m_fout, \"waitpid\\n%\" PRId64 \" %d %d\\n\", (int64_t)pid, options,",
          "690:           timeout);",
          "693:   char buf[BUFFER_SIZE];",
          "694:   read_buf(g_procs[id].m_fin, buf);",
          "695:   if (!buf[0]) return -1;",
          "698:   sscanf(buf, \"%\" PRId64 \" %d\", &ret, &stat);",
          "701:     read_buf(g_procs[id].m_fin, buf);",
          "702:     sscanf(buf, \"%d\", &errno);",
          "",
          "[Added Lines]",
          "719:   FILE *fout = g_procs[id].m_fout;",
          "720:   lwp_write(fout, \"waitpid\");",
          "721:   lwp_write_int64(fout, (int64_t)pid);",
          "722:   lwp_write_int32(fout, options);",
          "723:   lwp_write_int32(fout, timeout);",
          "728:   FILE *fin = g_procs[id].m_fin;",
          "729:   lwp_read_int64(fin, ret);",
          "730:   lwp_read_int32(fin, stat);",
          "734:     lwp_read_int32(fin, errno);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "725:   if (username.empty()) return;",
          "726:   for (int i = 0; i < g_procsCount; i++) {",
          "727:     Lock lock(g_procs[i].m_procMutex);",
          "730:   }",
          "731: }",
          "",
          "[Removed Lines]",
          "728:     fprintf(g_procs[i].m_fout, \"change_user\\n%s\\n\", username.c_str());",
          "729:     fflush(g_procs[i].m_fout);",
          "",
          "[Added Lines]",
          "760:     FILE *fout = g_procs[i].m_fout;",
          "761:     lwp_write(fout, \"change_user\");",
          "762:     lwp_write(fout, username);",
          "763:     fflush(fout);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
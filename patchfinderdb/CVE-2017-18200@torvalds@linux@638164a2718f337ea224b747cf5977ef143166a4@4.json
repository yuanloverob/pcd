{
  "cve_id": "CVE-2017-18200",
  "cve_desc": "The f2fs implementation in the Linux kernel before 4.14 mishandles reference counts associated with f2fs_wait_discard_bios calls, which allows local users to cause a denial of service (BUG), as demonstrated by fstrim.",
  "repo": "torvalds/linux",
  "patch_hash": "638164a2718f337ea224b747cf5977ef143166a4",
  "patch_info": {
    "commit_hash": "638164a2718f337ea224b747cf5977ef143166a4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4",
    "files": [
      "fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c",
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix potential panic during fstrim\n\nAs Ju Hyung Park reported:\n\n\"When 'fstrim' is called for manual trim, a BUG() can be triggered\nrandomly with this patch.\n\nI'm seeing this issue on both x86 Desktop and arm64 Android phone.\n\nOn x86 Desktop, this was caused during Ubuntu boot-up. I have a\ncronjob installed which calls 'fstrim -v /' during boot. On arm64\nAndroid, this was caused during GC looping with 1ms gc_min_sleep_time\n& gc_max_sleep_time.\"\n\nRoot cause of this issue is that f2fs_wait_discard_bios can only be\nused by f2fs_put_super, because during put_super there must be no\nother referrers, so it can ignore discard entry's reference count\nwhen removing the entry, otherwise in other caller we will hit bug_on\nin __remove_discard_cmd as there may be other issuer added reference\ncount in discard entry.\n\nThread A\t\t\t\tThread B\n\t\t\t\t\t- issue_discard_thread\n- f2fs_ioc_fitrim\n - f2fs_trim_fs\n  - f2fs_wait_discard_bios\n   - __issue_discard_cmd\n    - __submit_discard_cmd\n\t\t\t\t\t - __wait_discard_cmd\n\t\t\t\t\t  - dc->ref++\n\t\t\t\t\t  - __wait_one_discard_bio\n   - __wait_discard_cmd\n    - __remove_discard_cmd\n     - f2fs_bug_on(sbi, dc->ref)\n\nFixes: 969d1b180d987c2be02de890d0fff0f66a0e80de\nReported-by: Ju Hyung Park <qkrwngud825@gmail.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c||fs/f2fs/segment.c",
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
      "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "2525: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
      "2526: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
      "2527: void stop_discard_thread(struct f2fs_sb_info *sbi);",
      "2529: void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
      "2530: void release_discard_addrs(struct f2fs_sb_info *sbi);",
      "2531: int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);",
      "",
      "[Removed Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
      "",
      "[Added Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount);",
      "",
      "---------------"
    ],
    "fs/f2fs/segment.c||fs/f2fs/segment.c": [
      "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1210: }",
      "1214: {",
      "1215:  __issue_discard_cmd(sbi, false);",
      "1216:  __drop_discard_cmd(sbi);",
      "1218: }",
      "1220: static void mark_discard_range_all(struct f2fs_sb_info *sbi)",
      "",
      "[Removed Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
      "1217:  __wait_discard_cmd(sbi, false);",
      "",
      "[Added Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)",
      "1217:  __wait_discard_cmd(sbi, !umount);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2244:  }",
      "2246:  mark_discard_range_all(sbi);",
      "2248: out:",
      "2249:  range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);",
      "2250:  return err;",
      "",
      "[Removed Lines]",
      "2247:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "2247:  f2fs_wait_discard_bios(sbi, false);",
      "",
      "---------------"
    ],
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "801:  }",
      "806:  if (f2fs_discard_en(sbi) && !sbi->discard_blks) {",
      "807:   struct cp_control cpc = {",
      "",
      "[Removed Lines]",
      "804:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "804:  f2fs_wait_discard_bios(sbi, true);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8412663d177d95beff799c8bb256fccef86d09e6",
      "candidate_info": {
        "commit_hash": "8412663d177d95beff799c8bb256fccef86d09e6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8412663d177d95beff799c8bb256fccef86d09e6",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c",
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: support issuing/waiting discard in range\n\nFstrim intends to trim invalid blocks of filesystem only with specified\nrange and granularity, but actually, it will issue all previous cached\ndiscard commands which may be out-of-range and be with unmatched\ngranularity, it's unneeded.\n\nIn order to fix above issues, this patch introduces new helps to support\nto issue and wait discard in range and adds a new fstrim_list for tracking\nin-flight discard from ->fstrim.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2535: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "2536: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
          "2537: void stop_discard_thread(struct f2fs_sb_info *sbi);",
          "2539: void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
          "2540: void release_discard_addrs(struct f2fs_sb_info *sbi);",
          "2541: int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);",
          "",
          "[Removed Lines]",
          "2538: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount);",
          "",
          "[Added Lines]",
          "2539: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "875: static void __submit_discard_cmd(struct f2fs_sb_info *sbi,",
          "877: {",
          "878:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "879:  struct bio *bio = NULL;",
          "881:  if (dc->state != D_PREP)",
          "",
          "[Removed Lines]",
          "876:     struct discard_cmd *dc)",
          "",
          "[Added Lines]",
          "876:     struct discard_cmd *dc, bool fstrim)",
          "879:  struct list_head *wait_list = fstrim ? &(dcc->fstrim_list) :",
          "880:        &(dcc->wait_list);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "897:    bio->bi_end_io = f2fs_submit_discard_endio;",
          "898:    bio->bi_opf |= REQ_SYNC;",
          "899:    submit_bio(bio);",
          "901:    __check_sit_bitmap(sbi, dc->start, dc->start + dc->len);",
          "903:    f2fs_update_iostat(sbi, FS_DISCARD, 1);",
          "",
          "[Removed Lines]",
          "900:    list_move_tail(&dc->list, &dcc->wait_list);",
          "",
          "[Added Lines]",
          "902:    list_move_tail(&dc->list, wait_list);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1082:  return 0;",
          "1083: }",
          "1085: static int __issue_discard_cmd(struct f2fs_sb_info *sbi, bool issue_cond)",
          "1086: {",
          "1087:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1087: static void __issue_discard_cmd_range(struct f2fs_sb_info *sbi,",
          "1088:      unsigned int start, unsigned int end,",
          "1089:      unsigned int granularity)",
          "1090: {",
          "1091:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1092:  struct discard_cmd *prev_dc = NULL, *next_dc = NULL;",
          "1093:  struct rb_node **insert_p = NULL, *insert_parent = NULL;",
          "1094:  struct discard_cmd *dc;",
          "1095:  struct blk_plug plug;",
          "1096:  int issued;",
          "1098: next:",
          "1099:  issued = 0;",
          "1101:  mutex_lock(&dcc->cmd_lock);",
          "1102:  f2fs_bug_on(sbi, !__check_rb_tree_consistence(sbi, &dcc->root));",
          "1104:  dc = (struct discard_cmd *)__lookup_rb_tree_ret(&dcc->root,",
          "1105:      NULL, start,",
          "1106:      (struct rb_entry **)&prev_dc,",
          "1107:      (struct rb_entry **)&next_dc,",
          "1108:      &insert_p, &insert_parent, true);",
          "1109:  if (!dc)",
          "1110:   dc = next_dc;",
          "1112:  blk_start_plug(&plug);",
          "1114:  while (dc && dc->lstart <= end) {",
          "1115:   struct rb_node *node;",
          "1117:   if (dc->len < granularity)",
          "1118:    goto skip;",
          "1120:   if (dc->state != D_PREP) {",
          "1121:    list_move_tail(&dc->list, &dcc->fstrim_list);",
          "1122:    goto skip;",
          "1123:   }",
          "1125:   __submit_discard_cmd(sbi, dc, true);",
          "1127:   if (++issued >= DISCARD_ISSUE_RATE) {",
          "1128:    start = dc->lstart + dc->len;",
          "1130:    blk_finish_plug(&plug);",
          "1131:    mutex_unlock(&dcc->cmd_lock);",
          "1133:    schedule();",
          "1135:    goto next;",
          "1136:   }",
          "1137: skip:",
          "1138:   node = rb_next(&dc->rb_node);",
          "1139:   dc = rb_entry_safe(node, struct discard_cmd, rb_node);",
          "1141:   if (fatal_signal_pending(current))",
          "1142:    break;",
          "1143:  }",
          "1145:  blk_finish_plug(&plug);",
          "1146:  mutex_unlock(&dcc->cmd_lock);",
          "1147: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1106:    if (dcc->pend_list_tag[i] & P_TRIM) {",
          "1108:     issued++;",
          "1112:     continue;",
          "1113:    }",
          "1115:    if (!issue_cond) {",
          "1117:     issued++;",
          "1118:     continue;",
          "1119:    }",
          "1121:    if (is_idle(sbi)) {",
          "1123:     issued++;",
          "1124:    } else {",
          "1125:     io_interrupted = true;",
          "",
          "[Removed Lines]",
          "1107:     __submit_discard_cmd(sbi, dc);",
          "1110:     if (fatal_signal_pending(current))",
          "1111:      break;",
          "1116:     __submit_discard_cmd(sbi, dc);",
          "1122:     __submit_discard_cmd(sbi, dc);",
          "",
          "[Added Lines]",
          "1171:     __submit_discard_cmd(sbi, dc, false);",
          "1177:     __submit_discard_cmd(sbi, dc, false);",
          "1183:     __submit_discard_cmd(sbi, dc, false);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1173:  mutex_unlock(&dcc->cmd_lock);",
          "1174: }",
          "1177: {",
          "1178:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1180:  struct discard_cmd *dc, *tmp;",
          "1181:  bool need_wait;",
          "",
          "[Removed Lines]",
          "1176: static void __wait_discard_cmd(struct f2fs_sb_info *sbi, bool wait_cond)",
          "1179:  struct list_head *wait_list = &(dcc->wait_list);",
          "",
          "[Added Lines]",
          "1237: static void __wait_discard_cmd_range(struct f2fs_sb_info *sbi, bool wait_cond,",
          "1238:       block_t start, block_t end,",
          "1239:       unsigned int granularity,",
          "1240:       bool fstrim)",
          "1243:  struct list_head *wait_list = fstrim ? &(dcc->fstrim_list) :",
          "1244:        &(dcc->wait_list);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1186:  mutex_lock(&dcc->cmd_lock);",
          "1187:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "1188:   if (!wait_cond || (dc->state == D_DONE && !dc->ref)) {",
          "1189:    wait_for_completion_io(&dc->wait);",
          "1190:    __remove_discard_cmd(sbi, dc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1253:   if (dc->lstart + dc->len <= start || end <= dc->lstart)",
          "1254:    continue;",
          "1255:   if (dc->len < granularity)",
          "1256:    continue;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1202:  }",
          "1203: }",
          "1206: void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr)",
          "1207: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1274: static void __wait_all_discard_cmd(struct f2fs_sb_info *sbi, bool wait_cond)",
          "1275: {",
          "1276:  __wait_discard_cmd_range(sbi, wait_cond, 0, UINT_MAX, 1, false);",
          "1277: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1237:  }",
          "1238: }",
          "1242: {",
          "1243:  __issue_discard_cmd(sbi, false);",
          "1244:  __drop_discard_cmd(sbi);",
          "1246: }",
          "1248: static void mark_discard_range_all(struct f2fs_sb_info *sbi)",
          "",
          "[Removed Lines]",
          "1241: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)",
          "1245:  __wait_discard_cmd(sbi, !umount);",
          "",
          "[Added Lines]",
          "1315: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
          "1319:  __wait_all_discard_cmd(sbi, false);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1287:   issued = __issue_discard_cmd(sbi, true);",
          "1288:   if (issued) {",
          "1290:    wait_ms = DEF_MIN_DISCARD_ISSUE_TIME;",
          "1291:   } else {",
          "1292:    wait_ms = DEF_MAX_DISCARD_ISSUE_TIME;",
          "",
          "[Removed Lines]",
          "1289:    __wait_discard_cmd(sbi, true);",
          "",
          "[Added Lines]",
          "1363:    __wait_all_discard_cmd(sbi, true);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1597:    dcc->pend_list_tag[i] |= P_ACTIVE;",
          "1598:  }",
          "1599:  INIT_LIST_HEAD(&dcc->wait_list);",
          "1600:  mutex_init(&dcc->cmd_lock);",
          "1601:  atomic_set(&dcc->issued_discard, 0);",
          "1602:  atomic_set(&dcc->issing_discard, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1674:  INIT_LIST_HEAD(&dcc->fstrim_list);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2224: {",
          "2225:  __u64 start = F2FS_BYTES_TO_BLK(range->start);",
          "2226:  __u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;",
          "2228:  struct cp_control cpc;",
          "2229:  int err = 0;",
          "",
          "[Removed Lines]",
          "2227:  unsigned int start_segno, end_segno;",
          "",
          "[Added Lines]",
          "2302:  unsigned int start_segno, end_segno, cur_segno;",
          "2303:  block_t start_block, end_block;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2245:  start_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);",
          "2246:  end_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :",
          "2247:       GET_SEGNO(sbi, end);",
          "2248:  cpc.reason = CP_DISCARD;",
          "2249:  cpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));",
          "2255:   if (sbi->discard_blks == 0)",
          "2256:    break;",
          "",
          "[Removed Lines]",
          "2252:  for (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {",
          "2253:   cpc.trim_start = start_segno;",
          "",
          "[Added Lines]",
          "2325:  start_block = START_BLOCK(sbi, start_segno);",
          "2326:  end_block = START_BLOCK(sbi, end_segno + 1);",
          "2332:  for (cur_segno = start_segno; cur_segno <= end_segno;",
          "2333:      cur_segno = cpc.trim_end + 1) {",
          "2334:   cpc.trim_start = cur_segno;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2258:    cpc.trim_end = end_segno;",
          "2259:   else",
          "2260:    cpc.trim_end = min_t(unsigned int,",
          "2262:     BATCHED_TRIM_SEGMENTS(sbi),",
          "2263:     sbi->segs_per_sec) - 1, end_segno);",
          "",
          "[Removed Lines]",
          "2261:     rounddown(start_segno +",
          "",
          "[Added Lines]",
          "2342:     rounddown(cur_segno +",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2271:   schedule();",
          "2272:  }",
          "2276: out:",
          "2277:  range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);",
          "2278:  return err;",
          "",
          "[Removed Lines]",
          "2274:  mark_discard_range_all(sbi);",
          "2275:  f2fs_wait_discard_bios(sbi, false);",
          "",
          "[Added Lines]",
          "2355:  start_block = START_BLOCK(sbi, start_segno);",
          "2356:  end_block = START_BLOCK(sbi, min(cur_segno, end_segno) + 1);",
          "2358:  __issue_discard_cmd_range(sbi, start_block, end_block, cpc.trim_minlen);",
          "2359:  __wait_discard_cmd_range(sbi, true, start_block, end_block,",
          "2360:       cpc.trim_minlen, true);",
          "",
          "---------------"
        ],
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "801:  }",
          "806:  if (f2fs_discard_en(sbi) && !sbi->discard_blks) {",
          "807:   struct cp_control cpc = {",
          "",
          "[Removed Lines]",
          "804:  f2fs_wait_discard_bios(sbi, true);",
          "",
          "[Added Lines]",
          "804:  f2fs_wait_discard_bios(sbi);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
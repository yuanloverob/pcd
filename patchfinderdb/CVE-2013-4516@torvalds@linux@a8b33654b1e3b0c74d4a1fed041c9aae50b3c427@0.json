{
  "cve_id": "CVE-2013-4516",
  "cve_desc": "The mp_get_count function in drivers/staging/sb105x/sb_pci_mp.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a TIOCGICOUNT ioctl call.",
  "repo": "torvalds/linux",
  "patch_hash": "a8b33654b1e3b0c74d4a1fed041c9aae50b3c427",
  "patch_info": {
    "commit_hash": "a8b33654b1e3b0c74d4a1fed041c9aae50b3c427",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427",
    "files": [
      "drivers/staging/sb105x/sb_pci_mp.c"
    ],
    "message": "Staging: sb105x: info leak in mp_get_count()\n\nThe icount.reserved[] array isn't initialized so it leaks stack\ninformation to userspace.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "drivers/staging/sb105x/sb_pci_mp.c||drivers/staging/sb105x/sb_pci_mp.c"
    ]
  },
  "patch_diff": {
    "drivers/staging/sb105x/sb_pci_mp.c||drivers/staging/sb105x/sb_pci_mp.c": [
      "File: drivers/staging/sb105x/sb_pci_mp.c -> drivers/staging/sb105x/sb_pci_mp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1064: static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)",
      "1065: {",
      "1067:  struct sb_uart_icount cnow;",
      "1068:  struct sb_uart_port *port = state->port;",
      "",
      "[Removed Lines]",
      "1066:  struct serial_icounter_struct icount;",
      "",
      "[Added Lines]",
      "1066:  struct serial_icounter_struct icount = {};",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "68a81291ff6650f3ff409ebfc58ef97dfe85a2e4",
      "candidate_info": {
        "commit_hash": "68a81291ff6650f3ff409ebfc58ef97dfe85a2e4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/68a81291ff6650f3ff409ebfc58ef97dfe85a2e4",
        "files": [
          "drivers/staging/Kconfig",
          "drivers/staging/Makefile",
          "drivers/staging/sb105x/Kconfig",
          "drivers/staging/sb105x/Makefile",
          "drivers/staging/sb105x/sb_mp_register.h",
          "drivers/staging/sb105x/sb_pci_mp.c",
          "drivers/staging/sb105x/sb_pci_mp.h",
          "drivers/staging/sb105x/sb_ser_core.h"
        ],
        "message": "staging: Add SystemBase Multi-2/PCI driver\n\nI ported the driver supplied by SystemBase to mainline.\n\nAs the driver had MODULE_LICENSE(\"GPL\") it is declared as a GPL module\nand thus I have the right to distribute it upstream. Note, I did the\nbare minimum to get it working. It still needs a lot of loving.\n\nCc: hjchoi <hjchoi@sysbas.com>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/staging/sb105x/sb_mp_register.h||drivers/staging/sb105x/sb_mp_register.h",
          "drivers/staging/sb105x/sb_pci_mp.c||drivers/staging/sb105x/sb_pci_mp.c",
          "drivers/staging/sb105x/sb_pci_mp.h||drivers/staging/sb105x/sb_pci_mp.h",
          "drivers/staging/sb105x/sb_ser_core.h||drivers/staging/sb105x/sb_ser_core.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/staging/sb105x/sb_pci_mp.c||drivers/staging/sb105x/sb_pci_mp.c"
          ],
          "candidate": [
            "drivers/staging/sb105x/sb_pci_mp.c||drivers/staging/sb105x/sb_pci_mp.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/staging/sb105x/sb_mp_register.h||drivers/staging/sb105x/sb_mp_register.h": [
          "File: drivers/staging/sb105x/sb_mp_register.h -> drivers/staging/sb105x/sb_mp_register.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #ifndef UART_SB105X_H",
          "16: #define UART_SB105X_H",
          "28: #define DIR_UART_16C550  0",
          "29: #define DIR_UART_16C1050 1",
          "30: #define DIR_UART_16C1050A 2",
          "63: #define MP_OPTR_GPOCR  0x20",
          "66: #define MP_OPTR_GPODR  0x21",
          "69: #define MP_OPTR_PAFR  0x23",
          "75: #define PAGE_0 0",
          "76: #define PAGE_1 1",
          "77: #define PAGE_2 2",
          "78: #define PAGE_3 3",
          "79: #define PAGE_4 4",
          "144: #define SB105X_LCR_BF  0xBF",
          "270: #define SB105X_GET_CHAR(port) inb((port)->iobase + SB105X_RX)",
          "271: #define SB105X_GET_IER(port) inb((port)->iobase + SB105X_IER)",
          "272: #define SB105X_GET_ISR(port) inb((port)->iobase + SB105X_ISR)",
          "273: #define SB105X_GET_LCR(port) inb((port)->iobase + SB105X_LCR)",
          "274: #define SB105X_GET_MCR(port) inb((port)->iobase + SB105X_MCR)",
          "275: #define SB105X_GET_LSR(port) inb((port)->iobase + SB105X_LSR)",
          "276: #define SB105X_GET_MSR(port) inb((port)->iobase + SB105X_MSR)",
          "277: #define SB105X_GET_SPR(port) inb((port)->iobase + SB105X_SPR)",
          "279: #define SB105X_PUT_CHAR(port,v) outb((v),(port)->iobase + SB105X_TX )",
          "280: #define SB105X_PUT_IER(port,v) outb((v),(port)->iobase + SB105X_IER )",
          "281: #define SB105X_PUT_FCR(port,v) outb((v),(port)->iobase + SB105X_FCR )",
          "282: #define SB105X_PUT_LCR(port,v) outb((v),(port)->iobase + SB105X_LCR )",
          "283: #define SB105X_PUT_MCR(port,v) outb((v),(port)->iobase + SB105X_MCR )",
          "284: #define SB105X_PUT_SPR(port,v) outb((v),(port)->iobase + SB105X_SPR )",
          "288: #define SB105X_GET_REG(port,reg) inb((port)->iobase + (reg))",
          "289: #define SB105X_PUT_REG(port,reg,v) outb((v),(port)->iobase + (reg))",
          "293: #define SB105X_PUT_PSR(port,v) outb((v),(port)->iobase + SB105X_PSR )",
          "295: #endif",
          "",
          "---------------"
        ],
        "drivers/staging/sb105x/sb_pci_mp.c||drivers/staging/sb105x/sb_pci_mp.c": [
          "File: drivers/staging/sb105x/sb_pci_mp.c -> drivers/staging/sb105x/sb_pci_mp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"sb_pci_mp.h\"",
          "2: #include <linux/module.h>",
          "3: #include <linux/parport.h>",
          "5: extern struct parport *parport_pc_probe_port(unsigned long base_lo,",
          "6:   unsigned long base_hi,",
          "7:   int irq, int dma,",
          "8:   struct device *dev,",
          "9:   int irqflags);",
          "11: static struct mp_device_t mp_devs[MAX_MP_DEV];",
          "12: static int mp_nrpcibrds = sizeof(mp_pciboards)/sizeof(mppcibrd_t);",
          "13: static int NR_BOARD=0;",
          "14: static int NR_PORTS=0;",
          "15: static struct mp_port multi_ports[MAX_MP_PORT];",
          "16: static struct irq_info irq_lists[NR_IRQS];",
          "18: static _INLINE_ unsigned int serial_in(struct mp_port *mtpt, int offset);",
          "19: static _INLINE_ void serial_out(struct mp_port *mtpt, int offset, int value);",
          "20: static _INLINE_ unsigned int read_option_register(struct mp_port *mtpt, int offset);",
          "21: static int sb1054_get_register(struct sb_uart_port * port, int page, int reg);",
          "22: static int sb1054_set_register(struct sb_uart_port * port, int page, int reg, int value);",
          "23: static void SendATCommand(struct mp_port * mtpt);",
          "24: static int set_deep_fifo(struct sb_uart_port * port, int status);",
          "25: static int get_deep_fifo(struct sb_uart_port * port);",
          "26: static int get_device_type(int arg);",
          "27: static int set_auto_rts(struct sb_uart_port *port, int status);",
          "28: static void mp_stop(struct tty_struct *tty);",
          "29: static void __mp_start(struct tty_struct *tty);",
          "30: static void mp_start(struct tty_struct *tty);",
          "31: static void mp_tasklet_action(unsigned long data);",
          "32: static inline void mp_update_mctrl(struct sb_uart_port *port, unsigned int set, unsigned int clear);",
          "33: static int mp_startup(struct sb_uart_state *state, int init_hw);",
          "34: static void mp_shutdown(struct sb_uart_state *state);",
          "35: static void mp_change_speed(struct sb_uart_state *state, struct MP_TERMIOS *old_termios);",
          "37: static inline int __mp_put_char(struct sb_uart_port *port, struct circ_buf *circ, unsigned char c);",
          "38: static int mp_put_char(struct tty_struct *tty, unsigned char ch);",
          "40: static void mp_put_chars(struct tty_struct *tty);",
          "41: static int mp_write(struct tty_struct *tty, const unsigned char * buf, int count);",
          "42: static int mp_write_room(struct tty_struct *tty);",
          "43: static int mp_chars_in_buffer(struct tty_struct *tty);",
          "44: static void mp_flush_buffer(struct tty_struct *tty);",
          "45: static void mp_send_xchar(struct tty_struct *tty, char ch);",
          "46: static void mp_throttle(struct tty_struct *tty);",
          "47: static void mp_unthrottle(struct tty_struct *tty);",
          "48: static int mp_get_info(struct sb_uart_state *state, struct serial_struct *retinfo);",
          "49: static int mp_set_info(struct sb_uart_state *state, struct serial_struct *newinfo);",
          "50: static int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value);",
          "52: static int mp_tiocmget(struct tty_struct *tty);",
          "53: static int mp_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear);",
          "54: static int mp_break_ctl(struct tty_struct *tty, int break_state);",
          "55: static int mp_do_autoconfig(struct sb_uart_state *state);",
          "56: static int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg);",
          "57: static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt);",
          "58: static int mp_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg);",
          "59: static void mp_set_termios(struct tty_struct *tty, struct MP_TERMIOS *old_termios);",
          "60: static void mp_close(struct tty_struct *tty, struct file *filp);",
          "61: static void mp_wait_until_sent(struct tty_struct *tty, int timeout);",
          "62: static void mp_hangup(struct tty_struct *tty);",
          "63: static void mp_update_termios(struct sb_uart_state *state);",
          "64: static int mp_block_til_ready(struct file *filp, struct sb_uart_state *state);",
          "65: static struct sb_uart_state *uart_get(struct uart_driver *drv, int line);",
          "66: static int mp_open(struct tty_struct *tty, struct file *filp);",
          "67: static const char *mp_type(struct sb_uart_port *port);",
          "68: static void mp_change_pm(struct sb_uart_state *state, int pm_state);",
          "69: static inline void mp_report_port(struct uart_driver *drv, struct sb_uart_port *port);",
          "70: static void mp_configure_port(struct uart_driver *drv, struct sb_uart_state *state, struct sb_uart_port *port);",
          "71: static void mp_unconfigure_port(struct uart_driver *drv, struct sb_uart_state *state);",
          "72: static int mp_register_driver(struct uart_driver *drv);",
          "73: static void mp_unregister_driver(struct uart_driver *drv);",
          "74: static int mp_add_one_port(struct uart_driver *drv, struct sb_uart_port *port);",
          "75: static int mp_remove_one_port(struct uart_driver *drv, struct sb_uart_port *port);",
          "76: static void autoconfig(struct mp_port *mtpt, unsigned int probeflags);",
          "77: static void autoconfig_irq(struct mp_port *mtpt);",
          "78: static void multi_stop_tx(struct sb_uart_port *port);",
          "79: static void multi_start_tx(struct sb_uart_port *port);",
          "80: static void multi_stop_rx(struct sb_uart_port *port);",
          "81: static void multi_enable_ms(struct sb_uart_port *port);",
          "82: static _INLINE_ void receive_chars(struct mp_port *mtpt, int *status );",
          "83: static _INLINE_ void transmit_chars(struct mp_port *mtpt);",
          "84: static _INLINE_ void check_modem_status(struct mp_port *mtpt);",
          "85: static inline void multi_handle_port(struct mp_port *mtpt);",
          "86: static irqreturn_t multi_interrupt(int irq, void *dev_id);",
          "87: static void serial_do_unlink(struct irq_info *i, struct mp_port *mtpt);",
          "88: static int serial_link_irq_chain(struct mp_port *mtpt);",
          "89: static void serial_unlink_irq_chain(struct mp_port *mtpt);",
          "90: static void multi_timeout(unsigned long data);",
          "91: static unsigned int multi_tx_empty(struct sb_uart_port *port);",
          "92: static unsigned int multi_get_mctrl(struct sb_uart_port *port);",
          "93: static void multi_set_mctrl(struct sb_uart_port *port, unsigned int mctrl);",
          "94: static void multi_break_ctl(struct sb_uart_port *port, int break_state);",
          "95: static int multi_startup(struct sb_uart_port *port);",
          "96: static void multi_shutdown(struct sb_uart_port *port);",
          "97: static unsigned int multi_get_divisor(struct sb_uart_port *port, unsigned int baud);",
          "98: static void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old);",
          "99: static void multi_pm(struct sb_uart_port *port, unsigned int state, unsigned int oldstate);",
          "100: static void multi_release_std_resource(struct mp_port *mtpt);",
          "101: static void multi_release_port(struct sb_uart_port *port);",
          "102: static int multi_request_port(struct sb_uart_port *port);",
          "103: static void multi_config_port(struct sb_uart_port *port, int flags);",
          "104: static int multi_verify_port(struct sb_uart_port *port, struct serial_struct *ser);",
          "105: static const char * multi_type(struct sb_uart_port *port);",
          "106: static void __init multi_init_ports(void);",
          "107: static void __init multi_register_ports(struct uart_driver *drv);",
          "108: static int init_mp_dev(struct pci_dev *pcidev, mppcibrd_t brd);",
          "110: static int deep[256];",
          "111: static int deep_count;",
          "112: static int fcr_arr[256];",
          "113: static int fcr_count;",
          "114: static int ttr[256];",
          "115: static int ttr_count;",
          "116: static int rtr[256];",
          "117: static int rtr_count;",
          "119: module_param_array(deep,int,&deep_count,0);",
          "120: module_param_array(fcr_arr,int,&fcr_count,0);",
          "121: module_param_array(ttr,int,&ttr_count,0);",
          "122: module_param_array(rtr,int,&rtr_count,0);",
          "124: static _INLINE_ unsigned int serial_in(struct mp_port *mtpt, int offset)",
          "125: {",
          "126:  return inb(mtpt->port.iobase + offset);",
          "127: }",
          "129: static _INLINE_ void serial_out(struct mp_port *mtpt, int offset, int value)",
          "130: {",
          "131:  outb(value, mtpt->port.iobase + offset);",
          "132: }",
          "134: static _INLINE_ unsigned int read_option_register(struct mp_port *mtpt, int offset)",
          "135: {",
          "136:  return inb(mtpt->option_base_addr + offset);",
          "137: }",
          "139: static int sb1053a_get_interface(struct mp_port *mtpt, int port_num)",
          "140: {",
          "141:  unsigned long option_base_addr = mtpt->option_base_addr;",
          "142:  unsigned int  interface = 0;",
          "144:  switch (port_num)",
          "145:  {",
          "146:   case 0:",
          "147:   case 1:",
          "149:    outb(0x00, option_base_addr + MP_OPTR_GPODR);",
          "150:    break;",
          "151:   case 2:",
          "152:   case 3:",
          "154:    outb(0x01, option_base_addr + MP_OPTR_GPODR);",
          "155:    break;",
          "156:   case 4:",
          "157:   case 5:",
          "159:    outb(0x02, option_base_addr + MP_OPTR_GPODR);",
          "160:    break;",
          "161:   default:",
          "162:    break;",
          "163:  }",
          "165:  port_num &= 0x1;",
          "168:  interface = inb(option_base_addr + MP_OPTR_IIR0 + port_num);",
          "171:  outb(0x03, option_base_addr + MP_OPTR_GPODR);",
          "173:  return (interface);",
          "174: }",
          "176: static int sb1054_get_register(struct sb_uart_port * port, int page, int reg)",
          "177: {",
          "178:  int ret = 0;",
          "179:  unsigned int lcr = 0;",
          "180:  unsigned int mcr = 0;",
          "181:  unsigned int tmp = 0;",
          "183:  if( page <= 0)",
          "184:  {",
          "185:   printk(\" page 0 can not use this fuction\\n\");",
          "186:   return -1;",
          "187:  }",
          "189:  switch(page)",
          "190:  {",
          "191:   case 1:",
          "192:    lcr = SB105X_GET_LCR(port);",
          "193:    tmp = lcr | SB105X_LCR_DLAB;",
          "194:    SB105X_PUT_LCR(port, tmp);",
          "196:    tmp = SB105X_GET_LCR(port);",
          "198:    ret = SB105X_GET_REG(port,reg);",
          "199:    SB105X_PUT_LCR(port,lcr);",
          "200:    break;",
          "201:   case 2:",
          "202:    mcr = SB105X_GET_MCR(port);",
          "203:    tmp = mcr | SB105X_MCR_P2S;",
          "204:    SB105X_PUT_MCR(port,tmp);",
          "206:    ret = SB105X_GET_REG(port,reg);",
          "208:    SB105X_PUT_MCR(port,mcr);",
          "209:    break;",
          "210:   case 3:",
          "211:    lcr = SB105X_GET_LCR(port);",
          "212:    tmp = lcr | SB105X_LCR_BF;",
          "213:    SB105X_PUT_LCR(port,tmp);",
          "214:    SB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P3KEY);",
          "216:    ret = SB105X_GET_REG(port,reg);",
          "218:    SB105X_PUT_LCR(port,lcr);",
          "219:    break;",
          "220:   case 4:",
          "221:    lcr = SB105X_GET_LCR(port);",
          "222:    tmp = lcr | SB105X_LCR_BF;",
          "223:    SB105X_PUT_LCR(port,tmp);",
          "224:    SB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P4KEY);",
          "226:    ret = SB105X_GET_REG(port,reg);",
          "228:    SB105X_PUT_LCR(port,lcr);",
          "229:    break;",
          "230:   default:",
          "231:    printk(\" error invalid page number \\n\");",
          "232:    return -1;",
          "233:  }",
          "235:  return ret;",
          "236: }",
          "238: static int sb1054_set_register(struct sb_uart_port * port, int page, int reg, int value)",
          "239: {",
          "240:  int lcr = 0;",
          "241:  int mcr = 0;",
          "242:  int ret = 0;",
          "244:  if( page <= 0)",
          "245:  {",
          "246:   printk(\" page 0 can not use this fuction\\n\");",
          "247:   return -1;",
          "248:  }",
          "249:  switch(page)",
          "250:  {",
          "251:   case 1:",
          "252:    lcr = SB105X_GET_LCR(port);",
          "253:    SB105X_PUT_LCR(port, lcr | SB105X_LCR_DLAB);",
          "255:    SB105X_PUT_REG(port,reg,value);",
          "257:    SB105X_PUT_LCR(port, lcr);",
          "258:    ret = 1;",
          "259:    break;",
          "260:   case 2:",
          "261:    mcr = SB105X_GET_MCR(port);",
          "262:    SB105X_PUT_MCR(port, mcr | SB105X_MCR_P2S);",
          "264:    SB105X_PUT_REG(port,reg,value);",
          "266:    SB105X_PUT_MCR(port, mcr);",
          "267:    ret = 1;",
          "268:    break;",
          "269:   case 3:",
          "270:    lcr = SB105X_GET_LCR(port);",
          "271:    SB105X_PUT_LCR(port, lcr | SB105X_LCR_BF);",
          "272:    SB105X_PUT_PSR(port, SB105X_PSR_P3KEY);",
          "274:    SB105X_PUT_REG(port,reg,value);",
          "276:    SB105X_PUT_LCR(port, lcr);",
          "277:    ret = 1;",
          "278:    break;",
          "279:   case 4:",
          "280:    lcr = SB105X_GET_LCR(port);",
          "281:    SB105X_PUT_LCR(port, lcr | SB105X_LCR_BF);",
          "282:    SB105X_PUT_PSR(port, SB105X_PSR_P4KEY);",
          "284:    SB105X_PUT_REG(port,reg,value);",
          "286:    SB105X_PUT_LCR(port, lcr);",
          "287:    ret = 1;",
          "288:    break;",
          "289:   default:",
          "290:    printk(\" error invalid page number \\n\");",
          "291:    return -1;",
          "292:  }",
          "294:  return ret;",
          "295: }",
          "297: static int set_multidrop_mode(struct sb_uart_port *port, unsigned int mode)",
          "298: {",
          "299:  int mdr = SB105XA_MDR_NPS;",
          "301:  if (mode & MDMODE_ENABLE)",
          "302:  {",
          "303:   mdr |= SB105XA_MDR_MDE;",
          "304:  }",
          "306:  if (1) //(mode & MDMODE_AUTO)",
          "307:  {",
          "308:   int efr = 0;",
          "309:   mdr |= SB105XA_MDR_AME;",
          "310:   efr = sb1054_get_register(port, PAGE_3, SB105X_EFR);",
          "311:   efr |= SB105X_EFR_SCD;",
          "312:   sb1054_set_register(port, PAGE_3, SB105X_EFR, efr);",
          "313:  }",
          "315:  sb1054_set_register(port, PAGE_1, SB105XA_MDR, mdr);",
          "316:  port->mdmode &= ~0x6;",
          "317:  port->mdmode |= mode;",
          "318:  printk(\"[%d] multidrop init: %x\\n\", port->line, port->mdmode);",
          "320:  return 0;",
          "321: }",
          "323: static int get_multidrop_addr(struct sb_uart_port *port)",
          "324: {",
          "325:  return sb1054_get_register(port, PAGE_3, SB105X_XOFF2);",
          "326: }",
          "328: static int set_multidrop_addr(struct sb_uart_port *port, unsigned int addr)",
          "329: {",
          "330:  sb1054_set_register(port, PAGE_3, SB105X_XOFF2, addr);",
          "332:  return 0;",
          "333: }",
          "335: static void SendATCommand(struct mp_port * mtpt)",
          "336: {",
          "338:  unsigned char ch[] = {0x61,0x74,0x0d,0x0a,0x0};",
          "339:  unsigned char lineControl;",
          "340:  unsigned char i=0;",
          "341:  unsigned char Divisor = 0xc;",
          "343:  lineControl = serial_inp(mtpt,UART_LCR);",
          "344:  serial_outp(mtpt,UART_LCR,(lineControl | UART_LCR_DLAB));",
          "345:  serial_outp(mtpt,UART_DLL,(Divisor & 0xff));",
          "346:  serial_outp(mtpt,UART_DLM,(Divisor & 0xff00)>>8); //baudrate is 4800",
          "349:  serial_outp(mtpt,UART_LCR,lineControl);",
          "350:  serial_outp(mtpt,UART_LCR,0x03); // N-8-1",
          "351:  serial_outp(mtpt,UART_FCR,7);",
          "352:  serial_outp(mtpt,UART_MCR,0x3);",
          "353:  while(ch[i]){",
          "354:   while((serial_inp(mtpt,UART_LSR) & 0x60) !=0x60){",
          "355:    ;",
          "356:   }",
          "357:   serial_outp(mtpt,0,ch[i++]);",
          "358:  }",
          "361: }// end of SendATCommand()",
          "363: static int set_deep_fifo(struct sb_uart_port * port, int status)",
          "364: {",
          "365:  int afr_status = 0;",
          "366:  afr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);",
          "368:  if(status == ENABLE)",
          "369:  {",
          "370:   afr_status |= SB105X_AFR_AFEN;",
          "371:  }",
          "372:  else",
          "373:  {",
          "374:   afr_status &= ~SB105X_AFR_AFEN;",
          "375:  }",
          "377:  sb1054_set_register(port,PAGE_4,SB105X_AFR,afr_status);",
          "378:  sb1054_set_register(port,PAGE_4,SB105X_TTR,ttr[port->line]);",
          "379:  sb1054_set_register(port,PAGE_4,SB105X_RTR,rtr[port->line]);",
          "380:  afr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);",
          "382:  return afr_status;",
          "383: }",
          "385: static int get_device_type(int arg)",
          "386: {",
          "387:  int ret;",
          "388:         ret = inb(mp_devs[arg].option_reg_addr+MP_OPTR_DIR0);",
          "389:         ret = (ret & 0xf0) >> 4;",
          "390:         switch (ret)",
          "391:         {",
          "392:                case DIR_UART_16C550:",
          "393:                     return PORT_16C55X;",
          "394:                case DIR_UART_16C1050:",
          "395:                     return PORT_16C105X;",
          "396:                case DIR_UART_16C1050A:",
          "398:                if (mtpt->port.line < 2)",
          "399:                {",
          "400:                     return PORT_16C105XA;",
          "401:                }",
          "402:                else",
          "403:                {",
          "404:                    if (mtpt->device->device_id & 0x50)",
          "405:                    {",
          "406:                        return PORT_16C55X;",
          "407:                    }",
          "408:                    else",
          "409:                    {",
          "410:                        return PORT_16C105X;",
          "411:                    }",
          "413:                return PORT_16C105XA;",
          "414:                default:",
          "415:                     return PORT_UNKNOWN;",
          "416:         }",
          "418: }",
          "419: static int get_deep_fifo(struct sb_uart_port * port)",
          "420: {",
          "421:  int afr_status = 0;",
          "422:  afr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);",
          "423:  return afr_status;",
          "424: }",
          "426: static int set_auto_rts(struct sb_uart_port *port, int status)",
          "427: {",
          "428:  int atr_status = 0;",
          "430: #if 0",
          "431:  int efr_status = 0;",
          "433:  efr_status = sb1054_get_register(port, PAGE_3, SB105X_EFR);",
          "434:  if(status == ENABLE)",
          "435:   efr_status |= SB105X_EFR_ARTS;",
          "436:  else",
          "437:   efr_status &= ~SB105X_EFR_ARTS;",
          "438:  sb1054_set_register(port,PAGE_3,SB105X_EFR,efr_status);",
          "439:  efr_status = sb1054_get_register(port, PAGE_3, SB105X_EFR);",
          "440: #endif",
          "443:  atr_status = sb1054_get_register(port, PAGE_3, SB105X_ATR);",
          "444:  switch(status)",
          "445:  {",
          "446:   case RS422PTP:",
          "447:    atr_status = (SB105X_ATR_TPS) | (SB105X_ATR_A80);",
          "448:    break;",
          "449:   case RS422MD:",
          "450:    atr_status = (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);",
          "451:    break;",
          "452:   case RS485NE:",
          "453:    atr_status = (SB105X_ATR_RCMS) | (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);",
          "454:    break;",
          "455:   case RS485ECHO:",
          "456:    atr_status = (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);",
          "457:    break;",
          "458:  }",
          "460:  sb1054_set_register(port,PAGE_3,SB105X_ATR,atr_status);",
          "461:  atr_status = sb1054_get_register(port, PAGE_3, SB105X_ATR);",
          "463:  return atr_status;",
          "464: }",
          "466: static void mp_stop(struct tty_struct *tty)",
          "467: {",
          "468:  struct sb_uart_state *state = tty->driver_data;",
          "469:  struct sb_uart_port *port = state->port;",
          "470:  unsigned long flags;",
          "472:  spin_lock_irqsave(&port->lock, flags);",
          "473:  port->ops->stop_tx(port);",
          "474:  spin_unlock_irqrestore(&port->lock, flags);",
          "475: }",
          "477: static void __mp_start(struct tty_struct *tty)",
          "478: {",
          "479:  struct sb_uart_state *state = tty->driver_data;",
          "480:  struct sb_uart_port *port = state->port;",
          "482:  if (!uart_circ_empty(&state->info->xmit) && state->info->xmit.buf &&",
          "483:    !tty->stopped && !tty->hw_stopped)",
          "484:   port->ops->start_tx(port);",
          "485: }",
          "487: static void mp_start(struct tty_struct *tty)",
          "488: {",
          "489:  __mp_start(tty);",
          "490: }",
          "492: static void mp_tasklet_action(unsigned long data)",
          "493: {",
          "494:  struct sb_uart_state *state = (struct sb_uart_state *)data;",
          "495:  struct tty_struct *tty;",
          "497:  printk(\"tasklet is called!\\n\");",
          "498:  tty = state->info->tty;",
          "499:  tty_wakeup(tty);",
          "500: }",
          "502: static inline void mp_update_mctrl(struct sb_uart_port *port, unsigned int set, unsigned int clear)",
          "503: {",
          "504:  unsigned int old;",
          "506:  old = port->mctrl;",
          "507:  port->mctrl = (old & ~clear) | set;",
          "508:  if (old != port->mctrl)",
          "509:   port->ops->set_mctrl(port, port->mctrl);",
          "510: }",
          "512: #define uart_set_mctrl(port,set) mp_update_mctrl(port,set,0)",
          "513: #define uart_clear_mctrl(port,clear) mp_update_mctrl(port,0,clear)",
          "515: static int mp_startup(struct sb_uart_state *state, int init_hw)",
          "516: {",
          "517:  struct sb_uart_info *info = state->info;",
          "518:  struct sb_uart_port *port = state->port;",
          "519:  unsigned long page;",
          "520:  int retval = 0;",
          "522:  if (info->flags & UIF_INITIALIZED)",
          "523:   return 0;",
          "525:  if (info->tty)",
          "526:   set_bit(TTY_IO_ERROR, &info->tty->flags);",
          "528:  if (port->type == PORT_UNKNOWN)",
          "529:   return 0;",
          "531:  if (!info->xmit.buf) {",
          "532:   page = get_zeroed_page(GFP_KERNEL);",
          "533:   if (!page)",
          "534:    return -ENOMEM;",
          "536:   info->xmit.buf = (unsigned char *) page;",
          "538:   uart_circ_clear(&info->xmit);",
          "539:  }",
          "541:  retval = port->ops->startup(port);",
          "542:  if (retval == 0) {",
          "543:   if (init_hw) {",
          "544:    mp_change_speed(state, NULL);",
          "546:    if (info->tty->termios.c_cflag & CBAUD)",
          "547:     uart_set_mctrl(port, TIOCM_RTS | TIOCM_DTR);",
          "548:   }",
          "550:   info->flags |= UIF_INITIALIZED;",
          "553:   clear_bit(TTY_IO_ERROR, &info->tty->flags);",
          "554:  }",
          "556:  if (retval && capable(CAP_SYS_ADMIN))",
          "557:   retval = 0;",
          "559:  return retval;",
          "560: }",
          "562: static void mp_shutdown(struct sb_uart_state *state)",
          "563: {",
          "564:  struct sb_uart_info *info = state->info;",
          "565:  struct sb_uart_port *port = state->port;",
          "567:  if (info->tty)",
          "568:   set_bit(TTY_IO_ERROR, &info->tty->flags);",
          "570:  if (info->flags & UIF_INITIALIZED) {",
          "571:   info->flags &= ~UIF_INITIALIZED;",
          "573:   if (!info->tty || (info->tty->termios.c_cflag & HUPCL))",
          "574:    uart_clear_mctrl(port, TIOCM_DTR | TIOCM_RTS);",
          "576:   wake_up_interruptible(&info->delta_msr_wait);",
          "578:   port->ops->shutdown(port);",
          "580:   synchronize_irq(port->irq);",
          "581:  }",
          "582:  tasklet_kill(&info->tlet);",
          "584:  if (info->xmit.buf) {",
          "585:   free_page((unsigned long)info->xmit.buf);",
          "586:   info->xmit.buf = NULL;",
          "587:  }",
          "588: }",
          "590: static void mp_change_speed(struct sb_uart_state *state, struct MP_TERMIOS *old_termios)",
          "591: {",
          "592:  struct tty_struct *tty = state->info->tty;",
          "593:  struct sb_uart_port *port = state->port;",
          "595:  if (!tty || port->type == PORT_UNKNOWN)",
          "596:   return;",
          "598:  if (tty->termios.c_cflag & CRTSCTS)",
          "599:   state->info->flags |= UIF_CTS_FLOW;",
          "600:  else",
          "601:   state->info->flags &= ~UIF_CTS_FLOW;",
          "603:  if (tty->termios.c_cflag & CLOCAL)",
          "604:   state->info->flags &= ~UIF_CHECK_CD;",
          "605:  else",
          "606:   state->info->flags |= UIF_CHECK_CD;",
          "608:  port->ops->set_termios(port, &tty->termios, old_termios);",
          "609: }",
          "611: static inline int __mp_put_char(struct sb_uart_port *port, struct circ_buf *circ, unsigned char c)",
          "612: {",
          "613:  unsigned long flags;",
          "614:  int ret = 0;",
          "616:  if (!circ->buf)",
          "617:   return 0;",
          "619:  spin_lock_irqsave(&port->lock, flags);",
          "620:  if (uart_circ_chars_free(circ) != 0) {",
          "621:   circ->buf[circ->head] = c;",
          "622:   circ->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);",
          "623:   ret = 1;",
          "624:  }",
          "625:  spin_unlock_irqrestore(&port->lock, flags);",
          "626:  return ret;",
          "627: }",
          "629: static int mp_put_char(struct tty_struct *tty, unsigned char ch)",
          "630: {",
          "631:  struct sb_uart_state *state = tty->driver_data;",
          "633:  return __mp_put_char(state->port, &state->info->xmit, ch);",
          "634: }",
          "636: static void mp_put_chars(struct tty_struct *tty)",
          "637: {",
          "638:  mp_start(tty);",
          "639: }",
          "641: static int mp_write(struct tty_struct *tty, const unsigned char * buf, int count)",
          "642: {",
          "643:  struct sb_uart_state *state = tty->driver_data;",
          "644:  struct sb_uart_port *port;",
          "645:  struct circ_buf *circ;",
          "646:  int c, ret = 0;",
          "648:  if (!state || !state->info) {",
          "649:   return -EL3HLT;",
          "650:  }",
          "652:  port = state->port;",
          "653:  circ = &state->info->xmit;",
          "655:  if (!circ->buf)",
          "656:   return 0;",
          "658:  while (1) {",
          "659:   c = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);",
          "660:   if (count < c)",
          "661:    c = count;",
          "662:   if (c <= 0)",
          "663:    break;",
          "664:  memcpy(circ->buf + circ->head, buf, c);",
          "666:   circ->head = (circ->head + c) & (UART_XMIT_SIZE - 1);",
          "667:   buf += c;",
          "668:   count -= c;",
          "669:   ret += c;",
          "670:  }",
          "671:  mp_start(tty);",
          "672:  return ret;",
          "673: }",
          "675: static int mp_write_room(struct tty_struct *tty)",
          "676: {",
          "677:  struct sb_uart_state *state = tty->driver_data;",
          "679:  return uart_circ_chars_free(&state->info->xmit);",
          "680: }",
          "682: static int mp_chars_in_buffer(struct tty_struct *tty)",
          "683: {",
          "684:  struct sb_uart_state *state = tty->driver_data;",
          "686:  return uart_circ_chars_pending(&state->info->xmit);",
          "687: }",
          "689: static void mp_flush_buffer(struct tty_struct *tty)",
          "690: {",
          "691:  struct sb_uart_state *state = tty->driver_data;",
          "692:  struct sb_uart_port *port = state->port;",
          "693:  unsigned long flags;",
          "695:  if (!state || !state->info) {",
          "696:   return;",
          "697:  }",
          "699:  spin_lock_irqsave(&port->lock, flags);",
          "700:  uart_circ_clear(&state->info->xmit);",
          "701:  spin_unlock_irqrestore(&port->lock, flags);",
          "702:  wake_up_interruptible(&tty->write_wait);",
          "703:  tty_wakeup(tty);",
          "704: }",
          "706: static void mp_send_xchar(struct tty_struct *tty, char ch)",
          "707: {",
          "708:  struct sb_uart_state *state = tty->driver_data;",
          "709:  struct sb_uart_port *port = state->port;",
          "710:  unsigned long flags;",
          "712:  if (port->ops->send_xchar)",
          "713:   port->ops->send_xchar(port, ch);",
          "714:  else {",
          "715:   port->x_char = ch;",
          "716:   if (ch) {",
          "717:    spin_lock_irqsave(&port->lock, flags);",
          "718:    port->ops->start_tx(port);",
          "719:    spin_unlock_irqrestore(&port->lock, flags);",
          "720:   }",
          "721:  }",
          "722: }",
          "724: static void mp_throttle(struct tty_struct *tty)",
          "725: {",
          "726:  struct sb_uart_state *state = tty->driver_data;",
          "728:  if (I_IXOFF(tty))",
          "729:   mp_send_xchar(tty, STOP_CHAR(tty));",
          "731:  if (tty->termios.c_cflag & CRTSCTS)",
          "732:   uart_clear_mctrl(state->port, TIOCM_RTS);",
          "733: }",
          "735: static void mp_unthrottle(struct tty_struct *tty)",
          "736: {",
          "737:  struct sb_uart_state *state = tty->driver_data;",
          "738:  struct sb_uart_port *port = state->port;",
          "740:  if (I_IXOFF(tty)) {",
          "741:   if (port->x_char)",
          "742:    port->x_char = 0;",
          "743:   else",
          "744:    mp_send_xchar(tty, START_CHAR(tty));",
          "745:  }",
          "747:  if (tty->termios.c_cflag & CRTSCTS)",
          "748:   uart_set_mctrl(port, TIOCM_RTS);",
          "749: }",
          "751: static int mp_get_info(struct sb_uart_state *state, struct serial_struct *retinfo)",
          "752: {",
          "753:  struct sb_uart_port *port = state->port;",
          "754:  struct serial_struct tmp;",
          "756:  memset(&tmp, 0, sizeof(tmp));",
          "757:  tmp.type     = port->type;",
          "758:  tmp.line     = port->line;",
          "759:  tmp.port     = port->iobase;",
          "760:  if (HIGH_BITS_OFFSET)",
          "761:   tmp.port_high = (long) port->iobase >> HIGH_BITS_OFFSET;",
          "762:  tmp.irq      = port->irq;",
          "763:  tmp.flags     = port->flags;",
          "764:  tmp.xmit_fifo_size  = port->fifosize;",
          "765:  tmp.baud_base     = port->uartclk / 16;",
          "766:  tmp.close_delay     = state->close_delay;",
          "767:  tmp.closing_wait    = state->closing_wait == USF_CLOSING_WAIT_NONE ?",
          "768:   ASYNC_CLOSING_WAIT_NONE :",
          "769:   state->closing_wait;",
          "770:  tmp.custom_divisor  = port->custom_divisor;",
          "771:  tmp.hub6     = port->hub6;",
          "772:  tmp.io_type         = port->iotype;",
          "773:  tmp.iomem_reg_shift = port->regshift;",
          "774:  tmp.iomem_base      = (void *)port->mapbase;",
          "776:  if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))",
          "777:   return -EFAULT;",
          "778:  return 0;",
          "779: }",
          "781: static int mp_set_info(struct sb_uart_state *state, struct serial_struct *newinfo)",
          "782: {",
          "783:  struct serial_struct new_serial;",
          "784:  struct sb_uart_port *port = state->port;",
          "785:  unsigned long new_port;",
          "786:  unsigned int change_irq, change_port, closing_wait;",
          "787:  unsigned int old_custom_divisor;",
          "788:  unsigned int old_flags, new_flags;",
          "789:  int retval = 0;",
          "791:  if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))",
          "792:   return -EFAULT;",
          "794:  new_port = new_serial.port;",
          "795:  if (HIGH_BITS_OFFSET)",
          "796:   new_port += (unsigned long) new_serial.port_high << HIGH_BITS_OFFSET;",
          "798:  new_serial.irq = irq_canonicalize(new_serial.irq);",
          "800:  closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?",
          "801:   USF_CLOSING_WAIT_NONE : new_serial.closing_wait;",
          "802:  MP_STATE_LOCK(state);",
          "804:  change_irq  = new_serial.irq != port->irq;",
          "805:  change_port = new_port != port->iobase ||",
          "806:   (unsigned long)new_serial.iomem_base != port->mapbase ||",
          "807:   new_serial.hub6 != port->hub6 ||",
          "808:   new_serial.io_type != port->iotype ||",
          "809:   new_serial.iomem_reg_shift != port->regshift ||",
          "810:   new_serial.type != port->type;",
          "811:  old_flags = port->flags;",
          "812:  new_flags = new_serial.flags;",
          "813:  old_custom_divisor = port->custom_divisor;",
          "815:  if (!capable(CAP_SYS_ADMIN)) {",
          "816:   retval = -EPERM;",
          "817:   if (change_irq || change_port ||",
          "818:     (new_serial.baud_base != port->uartclk / 16) ||",
          "819:     (new_serial.close_delay != state->close_delay) ||",
          "820:     (closing_wait != state->closing_wait) ||",
          "821:     (new_serial.xmit_fifo_size != port->fifosize) ||",
          "822:     (((new_flags ^ old_flags) & ~UPF_USR_MASK) != 0))",
          "823:    goto exit;",
          "824:   port->flags = ((port->flags & ~UPF_USR_MASK) |",
          "825:     (new_flags & UPF_USR_MASK));",
          "826:   port->custom_divisor = new_serial.custom_divisor;",
          "827:   goto check_and_exit;",
          "828:  }",
          "830:  if (port->ops->verify_port)",
          "831:   retval = port->ops->verify_port(port, &new_serial);",
          "833:  if ((new_serial.irq >= NR_IRQS) || (new_serial.irq < 0) ||",
          "834:    (new_serial.baud_base < 9600))",
          "835:   retval = -EINVAL;",
          "837:  if (retval)",
          "838:   goto exit;",
          "840:  if (change_port || change_irq) {",
          "841:   retval = -EBUSY;",
          "843:   if (uart_users(state) > 1)",
          "844:    goto exit;",
          "846:   mp_shutdown(state);",
          "847:  }",
          "849:  if (change_port) {",
          "850:   unsigned long old_iobase, old_mapbase;",
          "851:   unsigned int old_type, old_iotype, old_hub6, old_shift;",
          "853:   old_iobase = port->iobase;",
          "854:   old_mapbase = port->mapbase;",
          "855:   old_type = port->type;",
          "856:   old_hub6 = port->hub6;",
          "857:   old_iotype = port->iotype;",
          "858:   old_shift = port->regshift;",
          "860:   if (old_type != PORT_UNKNOWN)",
          "861:    port->ops->release_port(port);",
          "863:   port->iobase = new_port;",
          "864:   port->type = new_serial.type;",
          "865:   port->hub6 = new_serial.hub6;",
          "866:   port->iotype = new_serial.io_type;",
          "867:   port->regshift = new_serial.iomem_reg_shift;",
          "868:   port->mapbase = (unsigned long)new_serial.iomem_base;",
          "870:   if (port->type != PORT_UNKNOWN) {",
          "871:    retval = port->ops->request_port(port);",
          "872:   } else {",
          "873:    retval = 0;",
          "874:   }",
          "876:   if (retval && old_type != PORT_UNKNOWN) {",
          "877:    port->iobase = old_iobase;",
          "878:    port->type = old_type;",
          "879:    port->hub6 = old_hub6;",
          "880:    port->iotype = old_iotype;",
          "881:    port->regshift = old_shift;",
          "882:    port->mapbase = old_mapbase;",
          "883:    retval = port->ops->request_port(port);",
          "884:    if (retval)",
          "885:     port->type = PORT_UNKNOWN;",
          "887:    retval = -EBUSY;",
          "888:   }",
          "889:  }",
          "891:  port->irq              = new_serial.irq;",
          "892:  port->uartclk          = new_serial.baud_base * 16;",
          "893:  port->flags            = (port->flags & ~UPF_CHANGE_MASK) |",
          "894:   (new_flags & UPF_CHANGE_MASK);",
          "895:  port->custom_divisor   = new_serial.custom_divisor;",
          "896:  state->close_delay     = new_serial.close_delay;",
          "897:  state->closing_wait    = closing_wait;",
          "898:  port->fifosize         = new_serial.xmit_fifo_size;",
          "899:  if (state->info->tty)",
          "900:   state->info->tty->low_latency =",
          "901:    (port->flags & UPF_LOW_LATENCY) ? 1 : 0;",
          "903: check_and_exit:",
          "904:  retval = 0;",
          "905:  if (port->type == PORT_UNKNOWN)",
          "906:   goto exit;",
          "907:  if (state->info->flags & UIF_INITIALIZED) {",
          "908:   if (((old_flags ^ port->flags) & UPF_SPD_MASK) ||",
          "909:     old_custom_divisor != port->custom_divisor) {",
          "910:    if (port->flags & UPF_SPD_MASK) {",
          "911:     printk(KERN_NOTICE",
          "912:       \"%s sets custom speed on ttyMP%d. This \"",
          "913:       \"is deprecated.\\n\", current->comm,",
          "914:       port->line);",
          "915:    }",
          "916:    mp_change_speed(state, NULL);",
          "917:   }",
          "918:  } else",
          "919:   retval = mp_startup(state, 1);",
          "920: exit:",
          "921:  MP_STATE_UNLOCK(state);",
          "922:  return retval;",
          "923: }",
          "926: static int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value)",
          "927: {",
          "928:  struct sb_uart_port *port = state->port;",
          "929:  unsigned int result;",
          "931:  result = port->ops->tx_empty(port);",
          "933:  if (port->x_char ||",
          "934:    ((uart_circ_chars_pending(&state->info->xmit) > 0) &&",
          "935:     !state->info->tty->stopped && !state->info->tty->hw_stopped))",
          "936:   result &= ~TIOCSER_TEMT;",
          "938:  return put_user(result, value);",
          "939: }",
          "941: static int mp_tiocmget(struct tty_struct *tty)",
          "942: {",
          "943:  struct sb_uart_state *state = tty->driver_data;",
          "944:  struct sb_uart_port *port = state->port;",
          "945:  int result = -EIO;",
          "947:  MP_STATE_LOCK(state);",
          "948:  if (!(tty->flags & (1 << TTY_IO_ERROR))) {",
          "949:   result = port->mctrl;",
          "950:   spin_lock_irq(&port->lock);",
          "951:   result |= port->ops->get_mctrl(port);",
          "952:   spin_unlock_irq(&port->lock);",
          "953:  }",
          "954:  MP_STATE_UNLOCK(state);",
          "955:  return result;",
          "956: }",
          "958: static int mp_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)",
          "959: {",
          "960:  struct sb_uart_state *state = tty->driver_data;",
          "961:  struct sb_uart_port *port = state->port;",
          "962:  int ret = -EIO;",
          "965:  MP_STATE_LOCK(state);",
          "966:  if (!(tty->flags & (1 << TTY_IO_ERROR))) {",
          "967:   mp_update_mctrl(port, set, clear);",
          "968:   ret = 0;",
          "969:  }",
          "970:  MP_STATE_UNLOCK(state);",
          "972:  return ret;",
          "973: }",
          "975: static int mp_break_ctl(struct tty_struct *tty, int break_state)",
          "976: {",
          "977:  struct sb_uart_state *state = tty->driver_data;",
          "978:  struct sb_uart_port *port = state->port;",
          "980:  MP_STATE_LOCK(state);",
          "982:  if (port->type != PORT_UNKNOWN)",
          "983:   port->ops->break_ctl(port, break_state);",
          "985:  MP_STATE_UNLOCK(state);",
          "986:  return 0;",
          "987: }",
          "989: static int mp_do_autoconfig(struct sb_uart_state *state)",
          "990: {",
          "991:  struct sb_uart_port *port = state->port;",
          "992:  int flags, ret;",
          "994:  if (!capable(CAP_SYS_ADMIN))",
          "995:   return -EPERM;",
          "997:  if (mutex_lock_interruptible(&state->mutex))",
          "998:   return -ERESTARTSYS;",
          "999:  ret = -EBUSY;",
          "1000:  if (uart_users(state) == 1) {",
          "1001:   mp_shutdown(state);",
          "1003:   if (port->type != PORT_UNKNOWN)",
          "1004:    port->ops->release_port(port);",
          "1006:   flags = UART_CONFIG_TYPE;",
          "1007:   if (port->flags & UPF_AUTO_IRQ)",
          "1008:    flags |= UART_CONFIG_IRQ;",
          "1010:   port->ops->config_port(port, flags);",
          "1012:   ret = mp_startup(state, 1);",
          "1013:  }",
          "1014:  MP_STATE_UNLOCK(state);",
          "1015:  return ret;",
          "1016: }",
          "1018: static int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg)",
          "1019: {",
          "1020:  struct sb_uart_port *port = state->port;",
          "1021:  DECLARE_WAITQUEUE(wait, current);",
          "1022:  struct sb_uart_icount cprev, cnow;",
          "1023:  int ret;",
          "1025:  spin_lock_irq(&port->lock);",
          "1026:  memcpy(&cprev, &port->icount, sizeof(struct sb_uart_icount));",
          "1028:  port->ops->enable_ms(port);",
          "1029:  spin_unlock_irq(&port->lock);",
          "1031:  add_wait_queue(&state->info->delta_msr_wait, &wait);",
          "1032:  for (;;) {",
          "1033:   spin_lock_irq(&port->lock);",
          "1034:   memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));",
          "1035:   spin_unlock_irq(&port->lock);",
          "1037:   set_current_state(TASK_INTERRUPTIBLE);",
          "1039:   if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||",
          "1040:     ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||",
          "1041:     ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||",
          "1042:     ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {",
          "1043:    ret = 0;",
          "1044:    break;",
          "1045:   }",
          "1047:   schedule();",
          "1049:   if (signal_pending(current)) {",
          "1050:    ret = -ERESTARTSYS;",
          "1051:    break;",
          "1052:   }",
          "1054:   cprev = cnow;",
          "1055:  }",
          "1057:  current->state = TASK_RUNNING;",
          "1058:  remove_wait_queue(&state->info->delta_msr_wait, &wait);",
          "1060:  return ret;",
          "1061: }",
          "1063: static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)",
          "1064: {",
          "1065:  struct serial_icounter_struct icount;",
          "1066:  struct sb_uart_icount cnow;",
          "1067:  struct sb_uart_port *port = state->port;",
          "1069:  spin_lock_irq(&port->lock);",
          "1070:  memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));",
          "1071:  spin_unlock_irq(&port->lock);",
          "1073:  icount.cts         = cnow.cts;",
          "1074:  icount.dsr         = cnow.dsr;",
          "1075:  icount.rng         = cnow.rng;",
          "1076:  icount.dcd         = cnow.dcd;",
          "1077:  icount.rx          = cnow.rx;",
          "1078:  icount.tx          = cnow.tx;",
          "1079:  icount.frame       = cnow.frame;",
          "1080:  icount.overrun     = cnow.overrun;",
          "1081:  icount.parity      = cnow.parity;",
          "1082:  icount.brk         = cnow.brk;",
          "1083:  icount.buf_overrun = cnow.buf_overrun;",
          "1085:  return copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;",
          "1086: }",
          "1088: static int mp_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)",
          "1089: {",
          "1090:  struct sb_uart_state *state = tty->driver_data;",
          "1091:  struct mp_port *info = (struct mp_port *)state->port;",
          "1092:  int ret = -ENOIOCTLCMD;",
          "1095:  switch (cmd) {",
          "1096:   case TIOCSMULTIDROP:",
          "1098:    if (info->port.type == PORT_16C105XA)",
          "1099:    {",
          "1102:     return set_multidrop_mode((struct sb_uart_port *)info, (unsigned int)arg);",
          "1103:    }",
          "1104:    ret = -ENOTSUPP;",
          "1105:    break;",
          "1106:   case GETDEEPFIFO:",
          "1107:    ret = get_deep_fifo(state->port);",
          "1108:    return ret;",
          "1109:   case SETDEEPFIFO:",
          "1110:    ret = set_deep_fifo(state->port,arg);",
          "1111:    deep[state->port->line] = arg;",
          "1112:    return ret;",
          "1113:   case SETTTR:",
          "1114:    if (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){",
          "1115:     ret = sb1054_set_register(state->port,PAGE_4,SB105X_TTR,arg);",
          "1116:     ttr[state->port->line] = arg;",
          "1117:    }",
          "1118:    return ret;",
          "1119:   case SETRTR:",
          "1120:    if (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){",
          "1121:     ret = sb1054_set_register(state->port,PAGE_4,SB105X_RTR,arg);",
          "1122:     rtr[state->port->line] = arg;",
          "1123:    }",
          "1124:    return ret;",
          "1125:   case GETTTR:",
          "1126:    if (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){",
          "1127:     ret = sb1054_get_register(state->port,PAGE_4,SB105X_TTR);",
          "1128:    }",
          "1129:    return ret;",
          "1130:   case GETRTR:",
          "1131:    if (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){",
          "1132:     ret = sb1054_get_register(state->port,PAGE_4,SB105X_RTR);",
          "1133:    }",
          "1134:    return ret;",
          "1136:   case SETFCR:",
          "1137:    if (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){",
          "1138:     ret = sb1054_set_register(state->port,PAGE_1,SB105X_FCR,arg);",
          "1139:    }",
          "1140:    else{",
          "1141:     serial_out(info,2,arg);",
          "1142:    }",
          "1144:    return ret;",
          "1145:   case TIOCSMDADDR:",
          "1147:    if (info->port.type == PORT_16C105XA)",
          "1148:    {",
          "1149:     state->port->mdmode |= MDMODE_ADDR;",
          "1150:     return set_multidrop_addr((struct sb_uart_port *)info, (unsigned int)arg);",
          "1151:    }",
          "1152:    ret = -ENOTSUPP;",
          "1153:    break;",
          "1155:   case TIOCGMDADDR:",
          "1157:    if ((info->port.type == PORT_16C105XA) && (state->port->mdmode & MDMODE_ADDR))",
          "1158:    {",
          "1159:     return get_multidrop_addr((struct sb_uart_port *)info);",
          "1160:    }",
          "1161:    ret = -ENOTSUPP;",
          "1162:    break;",
          "1164:   case TIOCSENDADDR:",
          "1166:    if ((info->port.type == PORT_16C105XA)",
          "1167:      && (state->port->mdmode & (MDMODE_ENABLE)))",
          "1168:    {",
          "1169:     if (mp_chars_in_buffer(tty) > 0)",
          "1170:     {",
          "1171:      tty_wait_until_sent(tty, 0);",
          "1172:     }",
          "1175:     while ((serial_in(info, UART_LSR) & 0x60) != 0x60);",
          "1176:     serial_out(info, UART_SCR, (int)arg);",
          "1177:    }",
          "1178:    break;",
          "1180:   case TIOCGSERIAL:",
          "1181:    ret = mp_get_info(state, (struct serial_struct *)arg);",
          "1182:    break;",
          "1184:   case TIOCSSERIAL:",
          "1185:    ret = mp_set_info(state, (struct serial_struct *)arg);",
          "1186:    break;",
          "1188:   case TIOCSERCONFIG:",
          "1189:    ret = mp_do_autoconfig(state);",
          "1190:    break;",
          "1194:    ret = 0;",
          "1195:    break;",
          "1198:    return NR_PORTS;",
          "1199:   case TIOCGGETDEVID:",
          "1200:    return mp_devs[arg].device_id;",
          "1201:   case TIOCGGETREV:",
          "1202:    return mp_devs[arg].revision;",
          "1203:   case TIOCGGETNRPORTS:",
          "1204:    return mp_devs[arg].nr_ports;",
          "1205:   case TIOCGGETBDNO:",
          "1206:    return NR_BOARD;",
          "1207:   case TIOCGGETINTERFACE:",
          "1208:    if (mp_devs[arg].revision == 0xc0)",
          "1209:    {",
          "1211:     return (sb1053a_get_interface(info, info->port.line));",
          "1212:    }",
          "1213:    else",
          "1214:    {",
          "1215:     return (inb(mp_devs[arg].option_reg_addr+MP_OPTR_IIR0+(state->port->line/8)));",
          "1216:    }",
          "1217:   case TIOCGGETPORTTYPE:",
          "1218:    ret = get_device_type(arg);;",
          "1219:    return ret;",
          "1221:    outb( ( inb(info->interface_config_addr) & ~0x03 ) | 0x01 ,",
          "1222:      info->interface_config_addr);",
          "1223:    return 0;",
          "1225:    outb( ( inb(info->interface_config_addr) & ~0x03 )  ,",
          "1226:      info->interface_config_addr);",
          "1227:    return 0;",
          "1228:  }",
          "1230:  if (ret != -ENOIOCTLCMD)",
          "1231:   goto out;",
          "1233:  if (tty->flags & (1 << TTY_IO_ERROR)) {",
          "1234:   ret = -EIO;",
          "1235:   goto out;",
          "1236:  }",
          "1238:  switch (cmd) {",
          "1239:   case TIOCMIWAIT:",
          "1240:    ret = mp_wait_modem_status(state, arg);",
          "1241:    break;",
          "1243:   case TIOCGICOUNT:",
          "1244:    ret = mp_get_count(state, (struct serial_icounter_struct *)arg);",
          "1245:    break;",
          "1246:  }",
          "1248:  if (ret != -ENOIOCTLCMD)",
          "1249:   goto out;",
          "1251:  MP_STATE_LOCK(state);",
          "1252:  switch (cmd) {",
          "1254:    ret = mp_get_lsr_info(state, (unsigned int *)arg);",
          "1255:    break;",
          "1257:   default: {",
          "1258:      struct sb_uart_port *port = state->port;",
          "1259:      if (port->ops->ioctl)",
          "1260:       ret = port->ops->ioctl(port, cmd, arg);",
          "1261:      break;",
          "1262:     }",
          "1263:  }",
          "1265:  MP_STATE_UNLOCK(state);",
          "1266: out:",
          "1267:  return ret;",
          "1268: }",
          "1270: static void mp_set_termios(struct tty_struct *tty, struct MP_TERMIOS *old_termios)",
          "1271: {",
          "1272:  struct sb_uart_state *state = tty->driver_data;",
          "1273:  unsigned long flags;",
          "1274:  unsigned int cflag = tty->termios.c_cflag;",
          "1276: #define RELEVANT_IFLAG(iflag) ((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))",
          "1278:  if ((cflag ^ old_termios->c_cflag) == 0 &&",
          "1279:    RELEVANT_IFLAG(tty->termios.c_iflag ^ old_termios->c_iflag) == 0)",
          "1280:   return;",
          "1282:  mp_change_speed(state, old_termios);",
          "1284:  if ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD))",
          "1285:   uart_clear_mctrl(state->port, TIOCM_RTS | TIOCM_DTR);",
          "1287:  if (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {",
          "1288:   unsigned int mask = TIOCM_DTR;",
          "1289:   if (!(cflag & CRTSCTS) ||",
          "1290:     !test_bit(TTY_THROTTLED, &tty->flags))",
          "1291:    mask |= TIOCM_RTS;",
          "1292:   uart_set_mctrl(state->port, mask);",
          "1293:  }",
          "1295:  if ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {",
          "1296:   spin_lock_irqsave(&state->port->lock, flags);",
          "1297:   tty->hw_stopped = 0;",
          "1298:   __mp_start(tty);",
          "1299:   spin_unlock_irqrestore(&state->port->lock, flags);",
          "1300:  }",
          "1302:  if (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {",
          "1303:   spin_lock_irqsave(&state->port->lock, flags);",
          "1304:   if (!(state->port->ops->get_mctrl(state->port) & TIOCM_CTS)) {",
          "1305:    tty->hw_stopped = 1;",
          "1306:    state->port->ops->stop_tx(state->port);",
          "1307:   }",
          "1308:   spin_unlock_irqrestore(&state->port->lock, flags);",
          "1309:  }",
          "1310: }",
          "1312: static void mp_close(struct tty_struct *tty, struct file *filp)",
          "1313: {",
          "1314:  struct sb_uart_state *state = tty->driver_data;",
          "1315:  struct sb_uart_port *port;",
          "1317:  printk(\"mp_close!\\n\");",
          "1318:  if (!state || !state->port)",
          "1319:   return;",
          "1321:  port = state->port;",
          "1323:  printk(\"close1 %d\\n\", __LINE__);",
          "1324:  MP_STATE_LOCK(state);",
          "1326:  printk(\"close2 %d\\n\", __LINE__);",
          "1327:  if (tty_hung_up_p(filp))",
          "1328:   goto done;",
          "1330:  printk(\"close3 %d\\n\", __LINE__);",
          "1331:  if ((tty->count == 1) && (state->count != 1)) {",
          "1332:   printk(\"mp_close: bad serial port count; tty->count is 1, \"",
          "1333:     \"state->count is %d\\n\", state->count);",
          "1334:   state->count = 1;",
          "1335:  }",
          "1336:  printk(\"close4 %d\\n\", __LINE__);",
          "1337:  if (--state->count < 0) {",
          "1338:   printk(\"rs_close: bad serial port count for ttyMP%d: %d\\n\",",
          "1339:     port->line, state->count);",
          "1340:   state->count = 0;",
          "1341:  }",
          "1342:  if (state->count)",
          "1343:   goto done;",
          "1345:  tty->closing = 1;",
          "1347:  printk(\"close5 %d\\n\", __LINE__);",
          "1348:  if (state->closing_wait != USF_CLOSING_WAIT_NONE)",
          "1349:   tty_wait_until_sent(tty, state->closing_wait);",
          "1351:  printk(\"close6 %d\\n\", __LINE__);",
          "1352:  if (state->info->flags & UIF_INITIALIZED) {",
          "1353:   unsigned long flags;",
          "1354:   spin_lock_irqsave(&port->lock, flags);",
          "1355:   port->ops->stop_rx(port);",
          "1356:   spin_unlock_irqrestore(&port->lock, flags);",
          "1357:   mp_wait_until_sent(tty, port->timeout);",
          "1358:  }",
          "1359:  printk(\"close7 %d\\n\", __LINE__);",
          "1361:  mp_shutdown(state);",
          "1362:  printk(\"close8 %d\\n\", __LINE__);",
          "1363:  mp_flush_buffer(tty);",
          "1364:  tty_ldisc_flush(tty);",
          "1365:  tty->closing = 0;",
          "1366:  state->info->tty = NULL;",
          "1367:  if (state->info->blocked_open)",
          "1368:  {",
          "1369:   if (state->close_delay)",
          "1370:   {",
          "1371:    set_current_state(TASK_INTERRUPTIBLE);",
          "1372:    schedule_timeout(state->close_delay);",
          "1373:   }",
          "1374:  }",
          "1375:  else",
          "1376:  {",
          "1377:   mp_change_pm(state, 3);",
          "1378:  }",
          "1379:  printk(\"close8 %d\\n\", __LINE__);",
          "1381:  state->info->flags &= ~UIF_NORMAL_ACTIVE;",
          "1382:  wake_up_interruptible(&state->info->open_wait);",
          "1384: done:",
          "1385:  printk(\"close done\\n\");",
          "1386:  MP_STATE_UNLOCK(state);",
          "1387:  module_put(THIS_MODULE);",
          "1388: }",
          "1390: static void mp_wait_until_sent(struct tty_struct *tty, int timeout)",
          "1391: {",
          "1392:  struct sb_uart_state *state = tty->driver_data;",
          "1393:  struct sb_uart_port *port = state->port;",
          "1394:  unsigned long char_time, expire;",
          "1396:  if (port->type == PORT_UNKNOWN || port->fifosize == 0)",
          "1397:   return;",
          "1399:  char_time = (port->timeout - HZ/50) / port->fifosize;",
          "1400:  char_time = char_time / 5;",
          "1401:  if (char_time == 0)",
          "1402:   char_time = 1;",
          "1403:  if (timeout && timeout < char_time)",
          "1404:   char_time = timeout;",
          "1406:  if (timeout == 0 || timeout > 2 * port->timeout)",
          "1407:   timeout = 2 * port->timeout;",
          "1409:  expire = jiffies + timeout;",
          "1411:  while (!port->ops->tx_empty(port)) {",
          "1412:   set_current_state(TASK_INTERRUPTIBLE);",
          "1413:   schedule_timeout(char_time);",
          "1414:   if (signal_pending(current))",
          "1415:    break;",
          "1416:   if (time_after(jiffies, expire))",
          "1417:    break;",
          "1418:  }",
          "1420: }",
          "1422: static void mp_hangup(struct tty_struct *tty)",
          "1423: {",
          "1424:  struct sb_uart_state *state = tty->driver_data;",
          "1426:  MP_STATE_LOCK(state);",
          "1427:  if (state->info && state->info->flags & UIF_NORMAL_ACTIVE) {",
          "1428:   mp_flush_buffer(tty);",
          "1429:   mp_shutdown(state);",
          "1430:   state->count = 0;",
          "1431:   state->info->flags &= ~UIF_NORMAL_ACTIVE;",
          "1432:   state->info->tty = NULL;",
          "1433:   wake_up_interruptible(&state->info->open_wait);",
          "1434:   wake_up_interruptible(&state->info->delta_msr_wait);",
          "1435:  }",
          "1436:  MP_STATE_UNLOCK(state);",
          "1437: }",
          "1439: static void mp_update_termios(struct sb_uart_state *state)",
          "1440: {",
          "1441:  struct tty_struct *tty = state->info->tty;",
          "1442:  struct sb_uart_port *port = state->port;",
          "1444:  if (!(tty->flags & (1 << TTY_IO_ERROR))) {",
          "1445:   mp_change_speed(state, NULL);",
          "1447:   if (tty->termios.c_cflag & CBAUD)",
          "1448:    uart_set_mctrl(port, TIOCM_DTR | TIOCM_RTS);",
          "1449:  }",
          "1450: }",
          "1452: static int mp_block_til_ready(struct file *filp, struct sb_uart_state *state)",
          "1453: {",
          "1454:  DECLARE_WAITQUEUE(wait, current);",
          "1455:  struct sb_uart_info *info = state->info;",
          "1456:  struct sb_uart_port *port = state->port;",
          "1457:  unsigned int mctrl;",
          "1459:  info->blocked_open++;",
          "1460:  state->count--;",
          "1462:  add_wait_queue(&info->open_wait, &wait);",
          "1463:  while (1) {",
          "1464:   set_current_state(TASK_INTERRUPTIBLE);",
          "1466:   if (tty_hung_up_p(filp) || info->tty == NULL)",
          "1467:    break;",
          "1469:   if (!(info->flags & UIF_INITIALIZED))",
          "1470:    break;",
          "1472:   if ((filp->f_flags & O_NONBLOCK) ||",
          "1473:     (info->tty->termios.c_cflag & CLOCAL) ||",
          "1474:     (info->tty->flags & (1 << TTY_IO_ERROR))) {",
          "1475:    break;",
          "1476:   }",
          "1478:   if (info->tty->termios.c_cflag & CBAUD)",
          "1479:    uart_set_mctrl(port, TIOCM_DTR);",
          "1481:   spin_lock_irq(&port->lock);",
          "1482:   port->ops->enable_ms(port);",
          "1483:   mctrl = port->ops->get_mctrl(port);",
          "1484:   spin_unlock_irq(&port->lock);",
          "1485:   if (mctrl & TIOCM_CAR)",
          "1486:    break;",
          "1488:   MP_STATE_UNLOCK(state);",
          "1489:   schedule();",
          "1490:   MP_STATE_LOCK(state);",
          "1492:   if (signal_pending(current))",
          "1493:    break;",
          "1494:  }",
          "1495:  set_current_state(TASK_RUNNING);",
          "1496:  remove_wait_queue(&info->open_wait, &wait);",
          "1498:  state->count++;",
          "1499:  info->blocked_open--;",
          "1501:  if (signal_pending(current))",
          "1502:   return -ERESTARTSYS;",
          "1504:  if (!info->tty || tty_hung_up_p(filp))",
          "1505:   return -EAGAIN;",
          "1507:  return 0;",
          "1508: }",
          "1510: static struct sb_uart_state *uart_get(struct uart_driver *drv, int line)",
          "1511: {",
          "1512:  struct sb_uart_state *state;",
          "1514:  MP_MUTEX_LOCK(mp_mutex);",
          "1515:  state = drv->state + line;",
          "1516:  if (mutex_lock_interruptible(&state->mutex)) {",
          "1517:   state = ERR_PTR(-ERESTARTSYS);",
          "1518:   goto out;",
          "1519:  }",
          "1520:  state->count++;",
          "1521:  if (!state->port) {",
          "1522:   state->count--;",
          "1523:   MP_STATE_UNLOCK(state);",
          "1524:   state = ERR_PTR(-ENXIO);",
          "1525:   goto out;",
          "1526:  }",
          "1528:  if (!state->info) {",
          "1529:   state->info = kmalloc(sizeof(struct sb_uart_info), GFP_KERNEL);",
          "1530:   if (state->info) {",
          "1531:    memset(state->info, 0, sizeof(struct sb_uart_info));",
          "1532:    init_waitqueue_head(&state->info->open_wait);",
          "1533:    init_waitqueue_head(&state->info->delta_msr_wait);",
          "1535:    state->port->info = state->info;",
          "1537:    tasklet_init(&state->info->tlet, mp_tasklet_action,",
          "1538:      (unsigned long)state);",
          "1539:   } else {",
          "1540:    state->count--;",
          "1541:    MP_STATE_UNLOCK(state);",
          "1542:    state = ERR_PTR(-ENOMEM);",
          "1543:   }",
          "1544:  }",
          "1546: out:",
          "1547:  MP_MUTEX_UNLOCK(mp_mutex);",
          "1548:  return state;",
          "1549: }",
          "1551: static int mp_open(struct tty_struct *tty, struct file *filp)",
          "1552: {",
          "1553:  struct uart_driver *drv = (struct uart_driver *)tty->driver->driver_state;",
          "1554:  struct sb_uart_state *state;",
          "1555:  int retval;",
          "1556:  int  line = tty->index;",
          "1557:  struct mp_port *mtpt;",
          "1559:  retval = -ENODEV;",
          "1560:  if (line >= tty->driver->num)",
          "1561:   goto fail;",
          "1563:  state = uart_get(drv, line);",
          "1565:  mtpt  = (struct mp_port *)state->port;",
          "1567:  if (IS_ERR(state)) {",
          "1568:   retval = PTR_ERR(state);",
          "1569:   goto fail;",
          "1570:  }",
          "1572:  tty->driver_data = state;",
          "1573:  tty->low_latency = (state->port->flags & UPF_LOW_LATENCY) ? 1 : 0;",
          "1574:  tty->alt_speed = 0;",
          "1575:  state->info->tty = tty;",
          "1577:  if (tty_hung_up_p(filp)) {",
          "1578:   retval = -EAGAIN;",
          "1579:   state->count--;",
          "1580:   MP_STATE_UNLOCK(state);",
          "1581:   goto fail;",
          "1582:  }",
          "1584:  if (state->count == 1)",
          "1585:   mp_change_pm(state, 0);",
          "1587:  retval = mp_startup(state, 0);",
          "1589:  if (retval == 0)",
          "1590:   retval = mp_block_til_ready(filp, state);",
          "1591:  MP_STATE_UNLOCK(state);",
          "1593:  if (retval == 0 && !(state->info->flags & UIF_NORMAL_ACTIVE)) {",
          "1594:   state->info->flags |= UIF_NORMAL_ACTIVE;",
          "1596:   mp_update_termios(state);",
          "1597:  }",
          "1599:  uart_clear_mctrl(state->port, TIOCM_RTS);",
          "1600:  try_module_get(THIS_MODULE);",
          "1601: fail:",
          "1602:  return retval;",
          "1603: }",
          "1606: static const char *mp_type(struct sb_uart_port *port)",
          "1607: {",
          "1608:  const char *str = NULL;",
          "1610:  if (port->ops->type)",
          "1611:   str = port->ops->type(port);",
          "1613:  if (!str)",
          "1614:   str = \"unknown\";",
          "1616:  return str;",
          "1617: }",
          "1619: static void mp_change_pm(struct sb_uart_state *state, int pm_state)",
          "1620: {",
          "1621:  struct sb_uart_port *port = state->port;",
          "1622:  if (port->ops->pm)",
          "1623:   port->ops->pm(port, pm_state, state->pm_state);",
          "1624:  state->pm_state = pm_state;",
          "1625: }",
          "1627: static inline void mp_report_port(struct uart_driver *drv, struct sb_uart_port *port)",
          "1628: {",
          "1629:  char address[64];",
          "1631:  switch (port->iotype) {",
          "1632:   case UPIO_PORT:",
          "1633:    snprintf(address, sizeof(address),\"I/O 0x%x\", port->iobase);",
          "1634:    break;",
          "1635:   case UPIO_HUB6:",
          "1636:    snprintf(address, sizeof(address),\"I/O 0x%x offset 0x%x\", port->iobase, port->hub6);",
          "1637:    break;",
          "1638:   case UPIO_MEM:",
          "1639:    snprintf(address, sizeof(address),\"MMIO 0x%lx\", port->mapbase);",
          "1640:    break;",
          "1641:   default:",
          "1642:    snprintf(address, sizeof(address),\"*unknown*\" );",
          "1643:    strlcpy(address, \"*unknown*\", sizeof(address));",
          "1644:    break;",
          "1645:  }",
          "1647:  printk( \"%s%d at %s (irq = %d) is a %s\\n\",",
          "1648:    drv->dev_name, port->line, address, port->irq, mp_type(port));",
          "1650: }",
          "1652: static void mp_configure_port(struct uart_driver *drv, struct sb_uart_state *state, struct sb_uart_port *port)",
          "1653: {",
          "1654:  unsigned int flags;",
          "1657:  if (!port->iobase && !port->mapbase && !port->membase)",
          "1658:  {",
          "1659:   DPRINTK(\"%s error \\n\",__FUNCTION__);",
          "1660:   return;",
          "1661:  }",
          "1662:  flags = UART_CONFIG_TYPE;",
          "1663:  if (port->flags & UPF_AUTO_IRQ)",
          "1664:   flags |= UART_CONFIG_IRQ;",
          "1665:  if (port->flags & UPF_BOOT_AUTOCONF) {",
          "1666:   port->type = PORT_UNKNOWN;",
          "1667:   port->ops->config_port(port, flags);",
          "1668:  }",
          "1670:  if (port->type != PORT_UNKNOWN) {",
          "1671:   unsigned long flags;",
          "1673:   mp_report_port(drv, port);",
          "1675:   spin_lock_irqsave(&port->lock, flags);",
          "1676:   port->ops->set_mctrl(port, 0);",
          "1677:   spin_unlock_irqrestore(&port->lock, flags);",
          "1679:   mp_change_pm(state, 3);",
          "1680:  }",
          "1681: }",
          "1683: static void mp_unconfigure_port(struct uart_driver *drv, struct sb_uart_state *state)",
          "1684: {",
          "1685:  struct sb_uart_port *port = state->port;",
          "1686:  struct sb_uart_info *info = state->info;",
          "1688:  if (info && info->tty)",
          "1689:   tty_hangup(info->tty);",
          "1691:  MP_STATE_LOCK(state);",
          "1693:  state->info = NULL;",
          "1695:  if (port->type != PORT_UNKNOWN)",
          "1696:   port->ops->release_port(port);",
          "1698:  port->type = PORT_UNKNOWN;",
          "1700:  if (info) {",
          "1701:   tasklet_kill(&info->tlet);",
          "1702:   kfree(info);",
          "1703:  }",
          "1705:  MP_STATE_UNLOCK(state);",
          "1706: }",
          "1707: static struct tty_operations mp_ops = {",
          "1708:  .open  = mp_open,",
          "1709:  .close  = mp_close,",
          "1710:  .write  = mp_write,",
          "1711:  .put_char = mp_put_char,",
          "1712:  .flush_chars = mp_put_chars,",
          "1713:  .write_room = mp_write_room,",
          "1714:  .chars_in_buffer= mp_chars_in_buffer,",
          "1715:  .flush_buffer = mp_flush_buffer,",
          "1716:  .ioctl  = mp_ioctl,",
          "1717:  .throttle = mp_throttle,",
          "1718:  .unthrottle = mp_unthrottle,",
          "1719:  .send_xchar = mp_send_xchar,",
          "1720:  .set_termios = mp_set_termios,",
          "1721:  .stop  = mp_stop,",
          "1722:  .start  = mp_start,",
          "1723:  .hangup  = mp_hangup,",
          "1724:  .break_ctl = mp_break_ctl,",
          "1725:  .wait_until_sent= mp_wait_until_sent,",
          "1726: #ifdef CONFIG_PROC_FS",
          "1727:  .proc_fops = NULL,",
          "1728: #endif",
          "1729:  .tiocmget = mp_tiocmget,",
          "1730:  .tiocmset = mp_tiocmset,",
          "1731: };",
          "1733: static int mp_register_driver(struct uart_driver *drv)",
          "1734: {",
          "1735:  struct tty_driver *normal = NULL;",
          "1736:  int i, retval;",
          "1738:  drv->state = kmalloc(sizeof(struct sb_uart_state) * drv->nr, GFP_KERNEL);",
          "1739:  retval = -ENOMEM;",
          "1740:  if (!drv->state)",
          "1741:  {",
          "1742:   printk(\"SB PCI Error: Kernel memory allocation error!\\n\");",
          "1743:   goto out;",
          "1744:  }",
          "1745:  memset(drv->state, 0, sizeof(struct sb_uart_state) * drv->nr);",
          "1747:  normal = alloc_tty_driver(drv->nr);",
          "1748:  if (!normal)",
          "1749:  {",
          "1750:   printk(\"SB PCI Error: tty allocation error!\\n\");",
          "1751:   goto out;",
          "1752:  }",
          "1754:  drv->tty_driver = normal;",
          "1756:  normal->owner           = drv->owner;",
          "1757:  normal->magic  = TTY_DRIVER_MAGIC;",
          "1758:  normal->driver_name     = drv->driver_name;",
          "1759:  normal->name  = drv->dev_name;",
          "1760:  normal->major  = drv->major;",
          "1761:  normal->minor_start = drv->minor;",
          "1763:  normal->num  = MAX_MP_PORT ;",
          "1765:  normal->type  = TTY_DRIVER_TYPE_SERIAL;",
          "1766:  normal->subtype  = SERIAL_TYPE_NORMAL;",
          "1767:  normal->init_termios = tty_std_termios;",
          "1768:  normal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;",
          "1769:  normal->flags  = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;",
          "1770:  normal->driver_state    = drv;",
          "1772:  tty_set_operations(normal, &mp_ops);",
          "1774: for (i = 0; i < drv->nr; i++) {",
          "1775:  struct sb_uart_state *state = drv->state + i;",
          "1777:  state->close_delay     = 500;",
          "1778:  state->closing_wait    = 30000;",
          "1780:  mutex_init(&state->mutex);",
          "1781:  }",
          "1783:  retval = tty_register_driver(normal);",
          "1784: out:",
          "1785:  if (retval < 0) {",
          "1786:   printk(\"Register tty driver Fail!\\n\");",
          "1787:   put_tty_driver(normal);",
          "1788:   kfree(drv->state);",
          "1789:  }",
          "1791:  return retval;",
          "1792: }",
          "1794: void mp_unregister_driver(struct uart_driver *drv)",
          "1795: {",
          "1796:     struct tty_driver *normal = NULL;",
          "1798:     normal = drv->tty_driver;",
          "1800:     if (!normal)",
          "1801:     {",
          "1802:         return;",
          "1803:     }",
          "1805:     tty_unregister_driver(normal);",
          "1806:     put_tty_driver(normal);",
          "1807:     drv->tty_driver = NULL;",
          "1810:     if (drv->state)",
          "1811:     {",
          "1812:         kfree(drv->state);",
          "1813:     }",
          "1815: }",
          "1817: static int mp_add_one_port(struct uart_driver *drv, struct sb_uart_port *port)",
          "1818: {",
          "1819:  struct sb_uart_state *state;",
          "1820:  int ret = 0;",
          "1823:  if (port->line >= drv->nr)",
          "1824:   return -EINVAL;",
          "1826:  state = drv->state + port->line;",
          "1828:  MP_MUTEX_LOCK(mp_mutex);",
          "1829:  if (state->port) {",
          "1830:   ret = -EINVAL;",
          "1831:   goto out;",
          "1832:  }",
          "1834:  state->port = port;",
          "1836:  spin_lock_init(&port->lock);",
          "1837:  port->cons = drv->cons;",
          "1838:  port->info = state->info;",
          "1840:  mp_configure_port(drv, state, port);",
          "1842:  tty_register_device(drv->tty_driver, port->line, port->dev);",
          "1844: out:",
          "1845:  MP_MUTEX_UNLOCK(mp_mutex);",
          "1848:  return ret;",
          "1849: }",
          "1851: static int mp_remove_one_port(struct uart_driver *drv, struct sb_uart_port *port)",
          "1852: {",
          "1853:  struct sb_uart_state *state = drv->state + port->line;",
          "1855:  if (state->port != port)",
          "1856:   printk(KERN_ALERT \"Removing wrong port: %p != %p\\n\",",
          "1857:     state->port, port);",
          "1859:  MP_MUTEX_LOCK(mp_mutex);",
          "1861:  tty_unregister_device(drv->tty_driver, port->line);",
          "1863:  mp_unconfigure_port(drv, state);",
          "1864:  state->port = NULL;",
          "1865:  MP_MUTEX_UNLOCK(mp_mutex);",
          "1867:  return 0;",
          "1868: }",
          "1870: static void autoconfig(struct mp_port *mtpt, unsigned int probeflags)",
          "1871: {",
          "1872:  unsigned char status1, scratch, scratch2, scratch3;",
          "1873:  unsigned char save_lcr, save_mcr;",
          "1874:  unsigned long flags;",
          "1876:  unsigned char u_type;",
          "1877:  unsigned char b_ret = 0;",
          "1879:  if (!mtpt->port.iobase && !mtpt->port.mapbase && !mtpt->port.membase)",
          "1880:   return;",
          "1882:  DEBUG_AUTOCONF(\"ttyMP%d: autoconf (0x%04x, 0x%p): \",",
          "1883:    mtpt->port.line, mtpt->port.iobase, mtpt->port.membase);",
          "1885:  spin_lock_irqsave(&mtpt->port.lock, flags);",
          "1887:  if (!(mtpt->port.flags & UPF_BUGGY_UART)) {",
          "1888:   scratch = serial_inp(mtpt, UART_IER);",
          "1889:   serial_outp(mtpt, UART_IER, 0);",
          "1890: #ifdef __i386__",
          "1891:   outb(0xff, 0x080);",
          "1892: #endif",
          "1893:   scratch2 = serial_inp(mtpt, UART_IER) & 0x0f;",
          "1894:   serial_outp(mtpt, UART_IER, 0x0F);",
          "1895: #ifdef __i386__",
          "1896:   outb(0, 0x080);",
          "1897: #endif",
          "1898:   scratch3 = serial_inp(mtpt, UART_IER) & 0x0F;",
          "1899:   serial_outp(mtpt, UART_IER, scratch);",
          "1900:   if (scratch2 != 0 || scratch3 != 0x0F) {",
          "1901:    DEBUG_AUTOCONF(\"IER test failed (%02x, %02x) \",",
          "1902:      scratch2, scratch3);",
          "1903:    goto out;",
          "1904:   }",
          "1905:  }",
          "1907:  save_mcr = serial_in(mtpt, UART_MCR);",
          "1908:  save_lcr = serial_in(mtpt, UART_LCR);",
          "1910:  if (!(mtpt->port.flags & UPF_SKIP_TEST)) {",
          "1911:   serial_outp(mtpt, UART_MCR, UART_MCR_LOOP | 0x0A);",
          "1912:   status1 = serial_inp(mtpt, UART_MSR) & 0xF0;",
          "1913:   serial_outp(mtpt, UART_MCR, save_mcr);",
          "1914:   if (status1 != 0x90) {",
          "1915:    DEBUG_AUTOCONF(\"LOOP test failed (%02x) \",",
          "1916:      status1);",
          "1917:    goto out;",
          "1918:   }",
          "1919:  }",
          "1921:  serial_outp(mtpt, UART_LCR, 0xBF);",
          "1922:  serial_outp(mtpt, UART_EFR, 0);",
          "1923:  serial_outp(mtpt, UART_LCR, 0);",
          "1925:  serial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);",
          "1926:  scratch = serial_in(mtpt, UART_IIR) >> 6;",
          "1928:  DEBUG_AUTOCONF(\"iir=%d \", scratch);",
          "1929:  if(mtpt->device->nr_ports >= 8)",
          "1930:   b_ret = read_option_register(mtpt,(MP_OPTR_DIR0 + ((mtpt->port.line)/8)));",
          "1931:  else",
          "1932:   b_ret = read_option_register(mtpt,MP_OPTR_DIR0);",
          "1933:  u_type = (b_ret & 0xf0) >> 4;",
          "1934:  if(mtpt->port.type == PORT_UNKNOWN )",
          "1935:  {",
          "1936:   switch (u_type)",
          "1937:   {",
          "1938:    case DIR_UART_16C550:",
          "1939:     mtpt->port.type = PORT_16C55X;",
          "1940:     break;",
          "1941:    case DIR_UART_16C1050:",
          "1942:     mtpt->port.type = PORT_16C105X;",
          "1943:     break;",
          "1944:    case DIR_UART_16C1050A:",
          "1945:     if (mtpt->port.line < 2)",
          "1946:     {",
          "1947:      mtpt->port.type = PORT_16C105XA;",
          "1948:     }",
          "1949:     else",
          "1950:     {",
          "1951:      if (mtpt->device->device_id & 0x50)",
          "1952:      {",
          "1953:       mtpt->port.type = PORT_16C55X;",
          "1954:      }",
          "1955:      else",
          "1956:      {",
          "1957:       mtpt->port.type = PORT_16C105X;",
          "1958:      }",
          "1959:     }",
          "1960:     break;",
          "1961:    default:",
          "1962:     mtpt->port.type = PORT_UNKNOWN;",
          "1963:     break;",
          "1964:   }",
          "1965:  }",
          "1967:  if(mtpt->port.type == PORT_UNKNOWN )",
          "1968:  {",
          "1969: printk(\"unknow2\\n\");",
          "1970:   switch (scratch) {",
          "1971:    case 0:",
          "1972:    case 1:",
          "1973:     mtpt->port.type = PORT_UNKNOWN;",
          "1974:     break;",
          "1975:    case 2:",
          "1976:    case 3:",
          "1977:     mtpt->port.type = PORT_16C55X;",
          "1978:     break;",
          "1979:   }",
          "1980:  }",
          "1982:  serial_outp(mtpt, UART_LCR, save_lcr);",
          "1984:  mtpt->port.fifosize = uart_config[mtpt->port.type].dfl_xmit_fifo_size;",
          "1985:  mtpt->capabilities = uart_config[mtpt->port.type].flags;",
          "1987:  if (mtpt->port.type == PORT_UNKNOWN)",
          "1988:   goto out;",
          "1989:  serial_outp(mtpt, UART_MCR, save_mcr);",
          "1990:  serial_outp(mtpt, UART_FCR, (UART_FCR_ENABLE_FIFO |",
          "1991:     UART_FCR_CLEAR_RCVR |",
          "1992:     UART_FCR_CLEAR_XMIT));",
          "1993:  serial_outp(mtpt, UART_FCR, 0);",
          "1994:  (void)serial_in(mtpt, UART_RX);",
          "1995:  serial_outp(mtpt, UART_IER, 0);",
          "1997: out:",
          "1998:  spin_unlock_irqrestore(&mtpt->port.lock, flags);",
          "1999:  DEBUG_AUTOCONF(\"type=%s\\n\", uart_config[mtpt->port.type].name);",
          "2000: }",
          "2002: static void autoconfig_irq(struct mp_port *mtpt)",
          "2003: {",
          "2004:  unsigned char save_mcr, save_ier;",
          "2005:  unsigned long irqs;",
          "2006:  int irq;",
          "2009:  probe_irq_off(probe_irq_on());",
          "2010:  save_mcr = serial_inp(mtpt, UART_MCR);",
          "2011:  save_ier = serial_inp(mtpt, UART_IER);",
          "2012:  serial_outp(mtpt, UART_MCR, UART_MCR_OUT1 | UART_MCR_OUT2);",
          "2014:  irqs = probe_irq_on();",
          "2015:  serial_outp(mtpt, UART_MCR, 0);",
          "2016:  serial_outp(mtpt, UART_MCR,",
          "2017:   UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);",
          "2020:  (void)serial_inp(mtpt, UART_LSR);",
          "2021:  (void)serial_inp(mtpt, UART_RX);",
          "2022:  (void)serial_inp(mtpt, UART_IIR);",
          "2023:  (void)serial_inp(mtpt, UART_MSR);",
          "2024:  serial_outp(mtpt, UART_TX, 0xFF);",
          "2025:  irq = probe_irq_off(irqs);",
          "2027:  serial_outp(mtpt, UART_MCR, save_mcr);",
          "2028:  serial_outp(mtpt, UART_IER, save_ier);",
          "2030:  mtpt->port.irq = (irq > 0) ? irq : 0;",
          "2031: }",
          "2033: static void multi_stop_tx(struct sb_uart_port *port)",
          "2034: {",
          "2035:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2037:  if (mtpt->ier & UART_IER_THRI) {",
          "2038:   mtpt->ier &= ~UART_IER_THRI;",
          "2039:   serial_out(mtpt, UART_IER, mtpt->ier);",
          "2040:  }",
          "2042:  tasklet_schedule(&port->info->tlet);",
          "2043: }",
          "2045: static void multi_start_tx(struct sb_uart_port *port)",
          "2046: {",
          "2047:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2049:  if (!(mtpt->ier & UART_IER_THRI)) {",
          "2050:   mtpt->ier |= UART_IER_THRI;",
          "2051:   serial_out(mtpt, UART_IER, mtpt->ier);",
          "2052:  }",
          "2053: }",
          "2055: static void multi_stop_rx(struct sb_uart_port *port)",
          "2056: {",
          "2057:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2059:  mtpt->ier &= ~UART_IER_RLSI;",
          "2060:  mtpt->port.read_status_mask &= ~UART_LSR_DR;",
          "2061:  serial_out(mtpt, UART_IER, mtpt->ier);",
          "2062: }",
          "2064: static void multi_enable_ms(struct sb_uart_port *port)",
          "2065: {",
          "2066:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2068:  mtpt->ier |= UART_IER_MSI;",
          "2069:  serial_out(mtpt, UART_IER, mtpt->ier);",
          "2070: }",
          "2073: static _INLINE_ void receive_chars(struct mp_port *mtpt, int *status )",
          "2074: {",
          "2075:  struct tty_struct *tty = mtpt->port.info->tty;",
          "2076:  unsigned char lsr = *status;",
          "2077:  int max_count = 256;",
          "2078:  unsigned char ch;",
          "2079:  char flag;",
          "2083:  do {",
          "2084:   if ((lsr & UART_LSR_PE) && (mtpt->port.mdmode & MDMODE_ENABLE))",
          "2085:   {",
          "2086:    ch = serial_inp(mtpt, UART_RX);",
          "2087:   }",
          "2088:   else if (lsr & UART_LSR_SPECIAL)",
          "2089:   {",
          "2090:    flag = 0;",
          "2091:    ch = serial_inp(mtpt, UART_RX);",
          "2093:    if (lsr & UART_LSR_BI)",
          "2094:    {",
          "2096:     mtpt->port.icount.brk++;",
          "2097:     flag = TTY_BREAK;",
          "2099:     if (sb_uart_handle_break(&mtpt->port))",
          "2100:      goto ignore_char;",
          "2101:    }",
          "2102:    if (lsr & UART_LSR_PE)",
          "2103:    {",
          "2104:     mtpt->port.icount.parity++;",
          "2105:     flag = TTY_PARITY;",
          "2106:    }",
          "2107:    if (lsr & UART_LSR_FE)",
          "2108:    {",
          "2109:     mtpt->port.icount.frame++;",
          "2110:     flag = TTY_FRAME;",
          "2111:    }",
          "2112:    if (lsr & UART_LSR_OE)",
          "2113:    {",
          "2114:     mtpt->port.icount.overrun++;",
          "2115:     flag = TTY_OVERRUN;",
          "2116:    }",
          "2117:    tty_insert_flip_char(tty, ch, flag);",
          "2118:   }",
          "2119:   else",
          "2120:   {",
          "2121:    ch = serial_inp(mtpt, UART_RX);",
          "2122:    tty_insert_flip_char(tty, ch, 0);",
          "2123:   }",
          "2124: ignore_char:",
          "2125:   lsr = serial_inp(mtpt, UART_LSR);",
          "2126:  } while ((lsr & UART_LSR_DR) && (max_count-- > 0));",
          "2128:  tty_flip_buffer_push(tty);",
          "2129: }",
          "2134: static _INLINE_ void transmit_chars(struct mp_port *mtpt)",
          "2135: {",
          "2136:  struct circ_buf *xmit = &mtpt->port.info->xmit;",
          "2137:  int count;",
          "2139:  if (mtpt->port.x_char) {",
          "2140:   serial_outp(mtpt, UART_TX, mtpt->port.x_char);",
          "2141:   mtpt->port.icount.tx++;",
          "2142:   mtpt->port.x_char = 0;",
          "2143:   return;",
          "2144:  }",
          "2145:  if (uart_circ_empty(xmit) || uart_tx_stopped(&mtpt->port)) {",
          "2146:   multi_stop_tx(&mtpt->port);",
          "2147:   return;",
          "2148:  }",
          "2150:  count = uart_circ_chars_pending(xmit);",
          "2152:  if(count > mtpt->port.fifosize)",
          "2153:  {",
          "2154:   count = mtpt->port.fifosize;",
          "2155:  }",
          "2157:  printk(\"[%d] mdmode: %x\\n\", mtpt->port.line, mtpt->port.mdmode);",
          "2158:  do {",
          "2159: #if 0",
          "2161:   if ((mtpt->port.mdmode & (MDMODE_ENABLE | MDMODE_ADDR)) == (MDMODE_ENABLE | MDMODE_ADDR))",
          "2162:   {",
          "2163:    printk(\"send address\\n\");",
          "2165:    serial_out(mtpt, UART_SCR, xmit->buf[xmit->tail]);",
          "2166:   }",
          "2167:   else",
          "2168: #endif",
          "2169:   {",
          "2170:    serial_out(mtpt, UART_TX, xmit->buf[xmit->tail]);",
          "2171:   }",
          "2172:   xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);",
          "2173:   mtpt->port.icount.tx++;",
          "2174:  } while (--count > 0);",
          "2175: }",
          "2179: static _INLINE_ void check_modem_status(struct mp_port *mtpt)",
          "2180: {",
          "2181:  int status;",
          "2183:  status = serial_in(mtpt, UART_MSR);",
          "2185:  if ((status & UART_MSR_ANY_DELTA) == 0)",
          "2186:   return;",
          "2188:  if (status & UART_MSR_TERI)",
          "2189:   mtpt->port.icount.rng++;",
          "2190:  if (status & UART_MSR_DDSR)",
          "2191:   mtpt->port.icount.dsr++;",
          "2192:  if (status & UART_MSR_DDCD)",
          "2193:   sb_uart_handle_dcd_change(&mtpt->port, status & UART_MSR_DCD);",
          "2194:  if (status & UART_MSR_DCTS)",
          "2195:   sb_uart_handle_cts_change(&mtpt->port, status & UART_MSR_CTS);",
          "2197:  wake_up_interruptible(&mtpt->port.info->delta_msr_wait);",
          "2198: }",
          "2200: static inline void multi_handle_port(struct mp_port *mtpt)",
          "2201: {",
          "2202:  unsigned int status = serial_inp(mtpt, UART_LSR);",
          "2206:  if ((status & UART_LSR_DR) || (status & UART_LSR_SPECIAL))",
          "2207:   receive_chars(mtpt, &status);",
          "2208:  check_modem_status(mtpt);",
          "2209:  if (status & UART_LSR_THRE)",
          "2210:  {",
          "2211:   if ((mtpt->port.type == PORT_16C105X)",
          "2212:    || (mtpt->port.type == PORT_16C105XA))",
          "2213:    transmit_chars(mtpt);",
          "2214:   else",
          "2215:   {",
          "2216:    if (mtpt->interface >= RS485NE)",
          "2217:     uart_set_mctrl(&mtpt->port, TIOCM_RTS);",
          "2219:    transmit_chars(mtpt);",
          "2222:    if (mtpt->interface >= RS485NE)",
          "2223:    {",
          "2224:     while((status=serial_in(mtpt,UART_LSR) &0x60)!=0x60);",
          "2225:     uart_clear_mctrl(&mtpt->port, TIOCM_RTS);",
          "2226:    }",
          "2227:   }",
          "2228:  }",
          "2229: }",
          "2233: static irqreturn_t multi_interrupt(int irq, void *dev_id)",
          "2234: {",
          "2235:  struct irq_info *iinfo = dev_id;",
          "2236:  struct list_head *lhead, *end = NULL;",
          "2237:  int pass_counter = 0;",
          "2240:  spin_lock(&iinfo->lock);",
          "2242:  lhead = iinfo->head;",
          "2243:  do {",
          "2244:   struct mp_port *mtpt;",
          "2245:   unsigned int iir;",
          "2247:   mtpt = list_entry(lhead, struct mp_port, list);",
          "2249:   iir = serial_in(mtpt, UART_IIR);",
          "2250:   printk(\"intrrupt! port %d, iir 0x%x\\n\", mtpt->port.line, iir); //wlee",
          "2251:   if (!(iir & UART_IIR_NO_INT))",
          "2252:   {",
          "2253:    printk(\"interrupt handle\\n\");",
          "2254:    spin_lock(&mtpt->port.lock);",
          "2255:    multi_handle_port(mtpt);",
          "2256:    spin_unlock(&mtpt->port.lock);",
          "2258:    end = NULL;",
          "2259:   } else if (end == NULL)",
          "2260:    end = lhead;",
          "2262:   lhead = lhead->next;",
          "2263:   if (lhead == iinfo->head && pass_counter++ > PASS_LIMIT)",
          "2264:   {",
          "2265:    printk(KERN_ERR \"multi: too much work for \"",
          "2266:      \"irq%d\\n\", irq);",
          "2267:    printk( \"multi: too much work for \"",
          "2268:      \"irq%d\\n\", irq);",
          "2269:    break;",
          "2270:   }",
          "2271:  } while (lhead != end);",
          "2273:  spin_unlock(&iinfo->lock);",
          "2276:         return IRQ_HANDLED;",
          "2277: }",
          "2279: static void serial_do_unlink(struct irq_info *i, struct mp_port *mtpt)",
          "2280: {",
          "2281:  spin_lock_irq(&i->lock);",
          "2283:  if (!list_empty(i->head)) {",
          "2284:   if (i->head == &mtpt->list)",
          "2285:    i->head = i->head->next;",
          "2286:   list_del(&mtpt->list);",
          "2287:  } else {",
          "2288:   i->head = NULL;",
          "2289:  }",
          "2291:  spin_unlock_irq(&i->lock);",
          "2292: }",
          "2294: static int serial_link_irq_chain(struct mp_port *mtpt)",
          "2295: {",
          "2296:  struct irq_info *i = irq_lists + mtpt->port.irq;",
          "2297:  int ret, irq_flags = mtpt->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;",
          "2298:  spin_lock_irq(&i->lock);",
          "2300:  if (i->head) {",
          "2301:   list_add(&mtpt->list, i->head);",
          "2302:   spin_unlock_irq(&i->lock);",
          "2304:   ret = 0;",
          "2305:  } else {",
          "2306:   INIT_LIST_HEAD(&mtpt->list);",
          "2307:   i->head = &mtpt->list;",
          "2308:   spin_unlock_irq(&i->lock);",
          "2310:   ret = request_irq(mtpt->port.irq, multi_interrupt,",
          "2311:     irq_flags, \"serial\", i);",
          "2312:   if (ret < 0)",
          "2313:    serial_do_unlink(i, mtpt);",
          "2314:  }",
          "2316:  return ret;",
          "2317: }",
          "2322: static void serial_unlink_irq_chain(struct mp_port *mtpt)",
          "2323: {",
          "2324:  struct irq_info *i = irq_lists + mtpt->port.irq;",
          "2326:  if (list_empty(i->head))",
          "2327:  {",
          "2328:   free_irq(mtpt->port.irq, i);",
          "2329:  }",
          "2330:  serial_do_unlink(i, mtpt);",
          "2331: }",
          "2333: static void multi_timeout(unsigned long data)",
          "2334: {",
          "2335:  struct mp_port *mtpt = (struct mp_port *)data;",
          "2338:  spin_lock(&mtpt->port.lock);",
          "2339:  multi_handle_port(mtpt);",
          "2340:  spin_unlock(&mtpt->port.lock);",
          "2342:  mod_timer(&mtpt->timer, jiffies+1 );",
          "2343: }",
          "2345: static unsigned int multi_tx_empty(struct sb_uart_port *port)",
          "2346: {",
          "2347:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2348:  unsigned long flags;",
          "2349:  unsigned int ret;",
          "2351:  spin_lock_irqsave(&mtpt->port.lock, flags);",
          "2352:  ret = serial_in(mtpt, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;",
          "2353:  spin_unlock_irqrestore(&mtpt->port.lock, flags);",
          "2355:  return ret;",
          "2356: }",
          "2359: static unsigned int multi_get_mctrl(struct sb_uart_port *port)",
          "2360: {",
          "2361:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2362:  unsigned char status;",
          "2363:  unsigned int ret;",
          "2365:  status = serial_in(mtpt, UART_MSR);",
          "2367:  ret = 0;",
          "2368:  if (status & UART_MSR_DCD)",
          "2369:   ret |= TIOCM_CAR;",
          "2370:  if (status & UART_MSR_RI)",
          "2371:   ret |= TIOCM_RNG;",
          "2372:  if (status & UART_MSR_DSR)",
          "2373:   ret |= TIOCM_DSR;",
          "2374:  if (status & UART_MSR_CTS)",
          "2375:   ret |= TIOCM_CTS;",
          "2376:  return ret;",
          "2377: }",
          "2379: static void multi_set_mctrl(struct sb_uart_port *port, unsigned int mctrl)",
          "2380: {",
          "2381:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2382:  unsigned char mcr = 0;",
          "2384:  mctrl &= 0xff;",
          "2386:  if (mctrl & TIOCM_RTS)",
          "2387:   mcr |= UART_MCR_RTS;",
          "2388:  if (mctrl & TIOCM_DTR)",
          "2389:   mcr |= UART_MCR_DTR;",
          "2390:  if (mctrl & TIOCM_OUT1)",
          "2391:   mcr |= UART_MCR_OUT1;",
          "2392:  if (mctrl & TIOCM_OUT2)",
          "2393:   mcr |= UART_MCR_OUT2;",
          "2394:  if (mctrl & TIOCM_LOOP)",
          "2395:   mcr |= UART_MCR_LOOP;",
          "2398:  serial_out(mtpt, UART_MCR, mcr);",
          "2399: }",
          "2402: static void multi_break_ctl(struct sb_uart_port *port, int break_state)",
          "2403: {",
          "2404:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2405:  unsigned long flags;",
          "2407:  spin_lock_irqsave(&mtpt->port.lock, flags);",
          "2408:  if (break_state == -1)",
          "2409:   mtpt->lcr |= UART_LCR_SBC;",
          "2410:  else",
          "2411:   mtpt->lcr &= ~UART_LCR_SBC;",
          "2412:  serial_out(mtpt, UART_LCR, mtpt->lcr);",
          "2413:  spin_unlock_irqrestore(&mtpt->port.lock, flags);",
          "2414: }",
          "2418: static int multi_startup(struct sb_uart_port *port)",
          "2419: {",
          "2420:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2421:  unsigned long flags;",
          "2422:  int retval;",
          "2424:  mtpt->capabilities = uart_config[mtpt->port.type].flags;",
          "2425:  mtpt->mcr = 0;",
          "2427:  if (mtpt->capabilities & UART_CLEAR_FIFO) {",
          "2428:   serial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);",
          "2429:   serial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO |",
          "2430:     UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);",
          "2431:   serial_outp(mtpt, UART_FCR, 0);",
          "2432:  }",
          "2434:  (void) serial_inp(mtpt, UART_LSR);",
          "2435:  (void) serial_inp(mtpt, UART_RX);",
          "2436:  (void) serial_inp(mtpt, UART_IIR);",
          "2437:  (void) serial_inp(mtpt, UART_MSR);",
          "2439:  serial_outp(mtpt, UART_MSR, 0);",
          "2442:  if (!(mtpt->port.flags & UPF_BUGGY_UART) &&",
          "2443:    (serial_inp(mtpt, UART_LSR) == 0xff)) {",
          "2444:   printk(\"ttyS%d: LSR safety check engaged!\\n\", mtpt->port.line);",
          "2446:  }",
          "2448:  if ((!is_real_interrupt(mtpt->port.irq)) || (mtpt->poll_type==TYPE_POLL)) {",
          "2449:   unsigned int timeout = mtpt->port.timeout;",
          "2451:   timeout = timeout > 6 ? (timeout / 2 - 2) : 1;",
          "2453:   mtpt->timer.data = (unsigned long)mtpt;",
          "2454:   mod_timer(&mtpt->timer, jiffies + timeout);",
          "2455:  }",
          "2456:  else",
          "2457:  {",
          "2458:   retval = serial_link_irq_chain(mtpt);",
          "2459:   if (retval)",
          "2460:    return retval;",
          "2461:  }",
          "2463:  serial_outp(mtpt, UART_LCR, UART_LCR_WLEN8);",
          "2465:  spin_lock_irqsave(&mtpt->port.lock, flags);",
          "2466:  if ((is_real_interrupt(mtpt->port.irq))||(mtpt->poll_type==TYPE_INTERRUPT))",
          "2467:   mtpt->port.mctrl |= TIOCM_OUT2;",
          "2469:  multi_set_mctrl(&mtpt->port, mtpt->port.mctrl);",
          "2470:  spin_unlock_irqrestore(&mtpt->port.lock, flags);",
          "2473:  mtpt->ier = UART_IER_RLSI | UART_IER_RDI;",
          "2474:  serial_outp(mtpt, UART_IER, mtpt->ier);",
          "2476:  (void) serial_inp(mtpt, UART_LSR);",
          "2477:  (void) serial_inp(mtpt, UART_RX);",
          "2478:  (void) serial_inp(mtpt, UART_IIR);",
          "2479:  (void) serial_inp(mtpt, UART_MSR);",
          "2481:  return 0;",
          "2482: }",
          "2486: static void multi_shutdown(struct sb_uart_port *port)",
          "2487: {",
          "2488:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2489:  unsigned long flags;",
          "2492:  mtpt->ier = 0;",
          "2493:  serial_outp(mtpt, UART_IER, 0);",
          "2495:  spin_lock_irqsave(&mtpt->port.lock, flags);",
          "2496:  mtpt->port.mctrl &= ~TIOCM_OUT2;",
          "2498:  multi_set_mctrl(&mtpt->port, mtpt->port.mctrl);",
          "2499:  spin_unlock_irqrestore(&mtpt->port.lock, flags);",
          "2501:  serial_out(mtpt, UART_LCR, serial_inp(mtpt, UART_LCR) & ~UART_LCR_SBC);",
          "2502:  serial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO |",
          "2503:    UART_FCR_CLEAR_RCVR |",
          "2504:    UART_FCR_CLEAR_XMIT);",
          "2505:  serial_outp(mtpt, UART_FCR, 0);",
          "2508:  (void) serial_in(mtpt, UART_RX);",
          "2510:  if ((!is_real_interrupt(mtpt->port.irq))||(mtpt->poll_type==TYPE_POLL))",
          "2511:  {",
          "2512:   del_timer_sync(&mtpt->timer);",
          "2513:  }",
          "2514:  else",
          "2515:  {",
          "2516:   serial_unlink_irq_chain(mtpt);",
          "2517:  }",
          "2518: }",
          "2522: static unsigned int multi_get_divisor(struct sb_uart_port *port, unsigned int baud)",
          "2523: {",
          "2524:  unsigned int quot;",
          "2526:  if ((port->flags & UPF_MAGIC_MULTIPLIER) &&",
          "2527:    baud == (port->uartclk/4))",
          "2528:   quot = 0x8001;",
          "2529:  else if ((port->flags & UPF_MAGIC_MULTIPLIER) &&",
          "2530:    baud == (port->uartclk/8))",
          "2531:   quot = 0x8002;",
          "2532:  else",
          "2533:   quot = sb_uart_get_divisor(port, baud);",
          "2535:  return quot;",
          "2536: }",
          "2541: static void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old)",
          "2542: {",
          "2543:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2544:  unsigned char cval, fcr = 0;",
          "2545:  unsigned long flags;",
          "2546:  unsigned int baud, quot;",
          "2548:  switch (termios->c_cflag & CSIZE) {",
          "2549:   case CS5:",
          "2550:    cval = 0x00;",
          "2551:    break;",
          "2552:   case CS6:",
          "2553:    cval = 0x01;",
          "2554:    break;",
          "2555:   case CS7:",
          "2556:    cval = 0x02;",
          "2557:    break;",
          "2558:   default:",
          "2559:   case CS8:",
          "2560:    cval = 0x03;",
          "2561:    break;",
          "2562:  }",
          "2564:  if (termios->c_cflag & CSTOPB)",
          "2565:   cval |= 0x04;",
          "2566:  if (termios->c_cflag & PARENB)",
          "2567:   cval |= UART_LCR_PARITY;",
          "2568:  if (!(termios->c_cflag & PARODD))",
          "2569:   cval |= UART_LCR_EPAR;",
          "2571: #ifdef CMSPAR",
          "2572:  if (termios->c_cflag & CMSPAR)",
          "2573:   cval |= UART_LCR_SPAR;",
          "2574: #endif",
          "2576:  baud = sb_uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);",
          "2577:  quot = multi_get_divisor(port, baud);",
          "2579:  if (mtpt->capabilities & UART_USE_FIFO) {",
          "2586:    fcr = fcr_arr[mtpt->port.line];",
          "2587:  }",
          "2589:  spin_lock_irqsave(&mtpt->port.lock, flags);",
          "2591:  sb_uart_update_timeout(port, termios->c_cflag, baud);",
          "2593:  mtpt->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;",
          "2594:  if (termios->c_iflag & INPCK)",
          "2595:   mtpt->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;",
          "2596:  if (termios->c_iflag & (BRKINT | PARMRK))",
          "2597:   mtpt->port.read_status_mask |= UART_LSR_BI;",
          "2599:  mtpt->port.ignore_status_mask = 0;",
          "2600:  if (termios->c_iflag & IGNPAR)",
          "2601:   mtpt->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;",
          "2602:  if (termios->c_iflag & IGNBRK) {",
          "2603:   mtpt->port.ignore_status_mask |= UART_LSR_BI;",
          "2604:   if (termios->c_iflag & IGNPAR)",
          "2605:    mtpt->port.ignore_status_mask |= UART_LSR_OE;",
          "2606:  }",
          "2608:  if ((termios->c_cflag & CREAD) == 0)",
          "2609:   mtpt->port.ignore_status_mask |= UART_LSR_DR;",
          "2611:  mtpt->ier &= ~UART_IER_MSI;",
          "2612:  if (UART_ENABLE_MS(&mtpt->port, termios->c_cflag))",
          "2613:   mtpt->ier |= UART_IER_MSI;",
          "2615:  serial_out(mtpt, UART_IER, mtpt->ier);",
          "2617:  if (mtpt->capabilities & UART_STARTECH) {",
          "2618:   serial_outp(mtpt, UART_LCR, 0xBF);",
          "2619:   serial_outp(mtpt, UART_EFR,",
          "2620:     termios->c_cflag & CRTSCTS ? UART_EFR_CTS :0);",
          "2621:  }",
          "2631:  if (fcr & UART_FCR_ENABLE_FIFO) {",
          "2633:   serial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);",
          "2634:  }",
          "2639:  if ((mtpt->port.type == PORT_16C105X)",
          "2640:   || (mtpt->port.type == PORT_16C105XA))",
          "2641:  {",
          "2642:   if(deep[mtpt->port.line]!=0)",
          "2643:    set_deep_fifo(port, ENABLE);",
          "2645:   if (mtpt->interface != RS232)",
          "2646:    set_auto_rts(port,mtpt->interface);",
          "2648:  }",
          "2649:  else",
          "2650:  {",
          "2651:   if (mtpt->interface >= RS485NE)",
          "2652:   {",
          "2653:    uart_clear_mctrl(&mtpt->port, TIOCM_RTS);",
          "2654:   }",
          "2655:  }",
          "2657:  if(mtpt->device->device_id == PCI_DEVICE_ID_MP4M)",
          "2658:  {",
          "2659:   SendATCommand(mtpt);",
          "2660:   printk(\"SendATCommand\\n\");",
          "2661:  }",
          "2662:  multi_set_mctrl(&mtpt->port, mtpt->port.mctrl);",
          "2663:  spin_unlock_irqrestore(&mtpt->port.lock, flags);",
          "2664: }",
          "2666: static void multi_pm(struct sb_uart_port *port, unsigned int state, unsigned int oldstate)",
          "2667: {",
          "2668:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2669:  if (state) {",
          "2670:   if (mtpt->capabilities & UART_STARTECH) {",
          "2671:    serial_outp(mtpt, UART_LCR, 0xBF);",
          "2672:    serial_outp(mtpt, UART_EFR, UART_EFR_ECB);",
          "2673:    serial_outp(mtpt, UART_LCR, 0);",
          "2674:    serial_outp(mtpt, UART_IER, UART_IERX_SLEEP);",
          "2675:    serial_outp(mtpt, UART_LCR, 0xBF);",
          "2676:    serial_outp(mtpt, UART_EFR, 0);",
          "2677:    serial_outp(mtpt, UART_LCR, 0);",
          "2678:   }",
          "2680:   if (mtpt->pm)",
          "2681:    mtpt->pm(port, state, oldstate);",
          "2682:  }",
          "2683:  else",
          "2684:  {",
          "2685:   if (mtpt->capabilities & UART_STARTECH) {",
          "2686:    serial_outp(mtpt, UART_LCR, 0xBF);",
          "2687:    serial_outp(mtpt, UART_EFR, UART_EFR_ECB);",
          "2688:    serial_outp(mtpt, UART_LCR, 0);",
          "2689:    serial_outp(mtpt, UART_IER, 0);",
          "2690:    serial_outp(mtpt, UART_LCR, 0xBF);",
          "2691:    serial_outp(mtpt, UART_EFR, 0);",
          "2692:    serial_outp(mtpt, UART_LCR, 0);",
          "2693:   }",
          "2695:   if (mtpt->pm)",
          "2696:    mtpt->pm(port, state, oldstate);",
          "2697:  }",
          "2698: }",
          "2700: static void multi_release_std_resource(struct mp_port *mtpt)",
          "2701: {",
          "2702:  unsigned int size = 8 << mtpt->port.regshift;",
          "2704:  switch (mtpt->port.iotype) {",
          "2705:   case UPIO_MEM:",
          "2706:    if (!mtpt->port.mapbase)",
          "2707:     break;",
          "2709:    if (mtpt->port.flags & UPF_IOREMAP) {",
          "2710:     iounmap(mtpt->port.membase);",
          "2711:     mtpt->port.membase = NULL;",
          "2712:    }",
          "2714:    release_mem_region(mtpt->port.mapbase, size);",
          "2715:    break;",
          "2717:   case UPIO_HUB6:",
          "2718:   case UPIO_PORT:",
          "2719:    release_region(mtpt->port.iobase,size);",
          "2720:    break;",
          "2721:  }",
          "2722: }",
          "2724: static void multi_release_port(struct sb_uart_port *port)",
          "2725: {",
          "2726: }",
          "2728: static int multi_request_port(struct sb_uart_port *port)",
          "2729: {",
          "2730:  return 0;",
          "2731: }",
          "2733: static void multi_config_port(struct sb_uart_port *port, int flags)",
          "2734: {",
          "2735:  struct mp_port *mtpt = (struct mp_port *)port;",
          "2736:  int probeflags = PROBE_ANY;",
          "2738:  if (flags & UART_CONFIG_TYPE)",
          "2739:   autoconfig(mtpt, probeflags);",
          "2740:  if (mtpt->port.type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)",
          "2741:   autoconfig_irq(mtpt);",
          "2743:  if (mtpt->port.type == PORT_UNKNOWN)",
          "2744:   multi_release_std_resource(mtpt);",
          "2745: }",
          "2747: static int multi_verify_port(struct sb_uart_port *port, struct serial_struct *ser)",
          "2748: {",
          "2749:  if (ser->irq >= NR_IRQS || ser->irq < 0 ||",
          "2750:    ser->baud_base < 9600 || ser->type < PORT_UNKNOWN ||",
          "2751:    ser->type == PORT_STARTECH)",
          "2752:   return -EINVAL;",
          "2753:  return 0;",
          "2754: }",
          "2756: static const char * multi_type(struct sb_uart_port *port)",
          "2757: {",
          "2758:  int type = port->type;",
          "2760:  if (type >= ARRAY_SIZE(uart_config))",
          "2761:   type = 0;",
          "2762:  return uart_config[type].name;",
          "2763: }",
          "2765: static struct sb_uart_ops multi_pops = {",
          "2766:  .tx_empty   = multi_tx_empty,",
          "2767:  .set_mctrl  = multi_set_mctrl,",
          "2768:  .get_mctrl  = multi_get_mctrl,",
          "2769:  .stop_tx    = multi_stop_tx,",
          "2770:  .start_tx   = multi_start_tx,",
          "2771:  .stop_rx    = multi_stop_rx,",
          "2772:  .enable_ms  = multi_enable_ms,",
          "2773:  .break_ctl  = multi_break_ctl,",
          "2774:  .startup    = multi_startup,",
          "2775:  .shutdown   = multi_shutdown,",
          "2776:  .set_termios    = multi_set_termios,",
          "2777:  .pm      = multi_pm,",
          "2778:  .type        = multi_type,",
          "2779:  .release_port   = multi_release_port,",
          "2780:  .request_port   = multi_request_port,",
          "2781:  .config_port    = multi_config_port,",
          "2782:  .verify_port    = multi_verify_port,",
          "2783: };",
          "2785: static struct uart_driver multi_reg = {",
          "2786:  .owner          = THIS_MODULE,",
          "2787:  .driver_name    = \"goldel_tulip\",",
          "2788:  .dev_name       = \"ttyMP\",",
          "2789:  .major          = SB_TTY_MP_MAJOR,",
          "2790:  .minor          = 0,",
          "2791:  .nr             = MAX_MP_PORT,",
          "2792:  .cons           = NULL,",
          "2793: };",
          "2795: static void __init multi_init_ports(void)",
          "2796: {",
          "2797:  struct mp_port *mtpt;",
          "2798:  static int first = 1;",
          "2799:  int i,j,k;",
          "2800:  unsigned char osc;",
          "2801:  unsigned char b_ret = 0;",
          "2802:  static struct mp_device_t * sbdev;",
          "2804:  if (!first)",
          "2805:   return;",
          "2806:  first = 0;",
          "2808:  mtpt = multi_ports;",
          "2810:  for (k=0;k<NR_BOARD;k++)",
          "2811:  {",
          "2812:   sbdev = &mp_devs[k];",
          "2814:   for (i = 0; i < sbdev->nr_ports; i++, mtpt++)",
          "2815:   {",
          "2816:    mtpt->device   = sbdev;",
          "2817:    mtpt->port.iobase   = sbdev->uart_access_addr + 8*i;",
          "2818:    mtpt->port.irq      = sbdev->irq;",
          "2819:    if ( ((sbdev->device_id == PCI_DEVICE_ID_MP4)&&(sbdev->revision==0x91)))",
          "2820:     mtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + i;",
          "2821:    else if (sbdev->revision == 0xc0)",
          "2822:     mtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + (i & 0x1);",
          "2823:    else",
          "2824:     mtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + i/8;",
          "2826:    mtpt->option_base_addr = sbdev->option_reg_addr;",
          "2828:    mtpt->poll_type = sbdev->poll_type;",
          "2830:    mtpt->port.uartclk  = BASE_BAUD * 16;",
          "2833:    osc = inb(sbdev->option_reg_addr + MP_OPTR_DIR0 + i/8) & 0x0F;",
          "2834:    if (osc==0x0f)",
          "2835:     osc = 0;",
          "2836:    for(j=0;j<osc;j++)",
          "2837:     mtpt->port.uartclk *= 2;",
          "2838:    mtpt->port.flags    |= STD_COM_FLAGS | UPF_SHARE_IRQ ;",
          "2839:    mtpt->port.iotype   = UPIO_PORT;",
          "2840:    mtpt->port.ops      = &multi_pops;",
          "2842:    if (sbdev->revision == 0xc0)",
          "2843:    {",
          "2845:     b_ret = sb1053a_get_interface(mtpt, i);",
          "2846:    }",
          "2847:    else",
          "2848:    {",
          "2849:     b_ret = read_option_register(mtpt,(MP_OPTR_IIR0 + i/8));",
          "2850:     printk(\"IIR_RET = %x\\n\",b_ret);",
          "2851:    }",
          "2853:    if(IIR_RS232 == (b_ret & IIR_RS232))",
          "2854:    {",
          "2855:     mtpt->interface = RS232;",
          "2856:    }",
          "2857:    if(IIR_RS422 == (b_ret & IIR_RS422))",
          "2858:    {",
          "2859:     mtpt->interface = RS422PTP;",
          "2860:    }",
          "2861:    if(IIR_RS485 == (b_ret & IIR_RS485))",
          "2862:    {",
          "2863:     mtpt->interface = RS485NE;",
          "2864:    }",
          "2865:   }",
          "2866:  }",
          "2867: }",
          "2869: static void __init multi_register_ports(struct uart_driver *drv)",
          "2870: {",
          "2871:  int i;",
          "2873:  multi_init_ports();",
          "2875:  for (i = 0; i < NR_PORTS; i++) {",
          "2876:   struct mp_port *mtpt = &multi_ports[i];",
          "2878:   mtpt->port.line = i;",
          "2879:   mtpt->port.ops = &multi_pops;",
          "2880:   init_timer(&mtpt->timer);",
          "2881:   mtpt->timer.function = multi_timeout;",
          "2882:   mp_add_one_port(drv, &mtpt->port);",
          "2883:  }",
          "2884: }",
          "2898: static int pci_remap_base(struct pci_dev *pcidev, unsigned int offset,",
          "2899:   unsigned int address, unsigned int size)",
          "2900: {",
          "2901: #if 0",
          "2902:  struct resource *root;",
          "2903:  unsigned index = (offset - 0x10) >> 2;",
          "2904: #endif",
          "2906:  pci_write_config_dword(pcidev, offset, address);",
          "2907: #if 0",
          "2908:  root = pcidev->resource[index].parent;",
          "2909:  release_resource(&pcidev->resource[index]);",
          "2910:  address &= ~0x1;",
          "2911:  pcidev->resource[index].start = address;",
          "2912:  pcidev->resource[index].end   = address + size - 1;",
          "2914:  if (request_resource(root, &pcidev->resource[index]) != NULL)",
          "2915:  {",
          "2916:   printk(KERN_ERR \"pci remap conflict!! 0x%x\\n\", address);",
          "2917:   return (-1);",
          "2918:  }",
          "2919: #endif",
          "2921:  return (0);",
          "2922: }",
          "2924: static int init_mp_dev(struct pci_dev *pcidev, mppcibrd_t brd)",
          "2925: {",
          "2926:  static struct mp_device_t * sbdev = mp_devs;",
          "2927:  unsigned long addr = 0;",
          "2928:  int j;",
          "2929:  struct resource * ret = NULL;",
          "2931:  sbdev->device_id = brd.device_id;",
          "2932:  pci_read_config_byte(pcidev, PCI_CLASS_REVISION, &(sbdev->revision));",
          "2933:  sbdev->name = brd.name;",
          "2934:  sbdev->uart_access_addr = pcidev->resource[0].start & PCI_BASE_ADDRESS_IO_MASK;",
          "2937:  if (sbdev->revision == 0xc0)",
          "2938:  {",
          "2940:   sbdev->option_reg_addr = pcidev->resource[4].start & PCI_BASE_ADDRESS_IO_MASK;",
          "2941:  }",
          "2942:  else",
          "2943:  {",
          "2944:   sbdev->option_reg_addr = pcidev->resource[1].start & PCI_BASE_ADDRESS_IO_MASK;",
          "2945:  }",
          "2946: #if 1",
          "2947:  if (sbdev->revision == 0xc0)",
          "2948:  {",
          "2949:   outb(0x00, sbdev->option_reg_addr + MP_OPTR_GPOCR);",
          "2950:   inb(sbdev->option_reg_addr + MP_OPTR_GPOCR);",
          "2951:   outb(0x83, sbdev->option_reg_addr + MP_OPTR_GPOCR);",
          "2952:  }",
          "2953: #endif",
          "2955:  sbdev->irq = pcidev->irq;",
          "2957:  if ((brd.device_id & 0x0800) || !(brd.device_id &0xff00))",
          "2958:  {",
          "2959:   sbdev->poll_type = TYPE_INTERRUPT;",
          "2960:  }",
          "2961:  else",
          "2962:  {",
          "2963:   sbdev->poll_type = TYPE_POLL;",
          "2964:  }",
          "2967:  switch(brd.device_id){",
          "2968:   case PCI_DEVICE_ID_MP1 :",
          "2969:   case PCIE_DEVICE_ID_MP1 :",
          "2970:   case PCIE_DEVICE_ID_MP1E :",
          "2971:   case PCIE_DEVICE_ID_GT_MP1 :",
          "2972:    sbdev->nr_ports = 1;",
          "2973:    break;",
          "2974:   case PCI_DEVICE_ID_MP2 :",
          "2975:   case PCIE_DEVICE_ID_MP2 :",
          "2976:   case PCIE_DEVICE_ID_GT_MP2 :",
          "2977:   case PCIE_DEVICE_ID_MP2B :",
          "2978:   case PCIE_DEVICE_ID_MP2E :",
          "2979:    sbdev->nr_ports = 2;",
          "2982:    if (sbdev->revision == 0xc0)",
          "2983:    {",
          "2984:     int prev_port_addr = 0;",
          "2986:     pci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);",
          "2987:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);",
          "2988:    }",
          "2989:    break;",
          "2990:   case PCI_DEVICE_ID_MP4 :",
          "2991:   case PCI_DEVICE_ID_MP4A :",
          "2992:   case PCIE_DEVICE_ID_MP4 :",
          "2993:   case PCI_DEVICE_ID_GT_MP4 :",
          "2994:   case PCI_DEVICE_ID_GT_MP4A :",
          "2995:   case PCIE_DEVICE_ID_GT_MP4 :",
          "2996:   case PCI_DEVICE_ID_MP4M :",
          "2997:   case PCIE_DEVICE_ID_MP4B :",
          "2998:    sbdev->nr_ports = 4;",
          "3000:    if(sbdev->revision == 0x91){",
          "3001:     sbdev->reserved_addr[0] = pcidev->resource[0].start & PCI_BASE_ADDRESS_IO_MASK;",
          "3002:     outb(0x03 , sbdev->reserved_addr[0] + 0x01);",
          "3003:     outb(0x03 , sbdev->reserved_addr[0] + 0x02);",
          "3004:     outb(0x01 , sbdev->reserved_addr[0] + 0x20);",
          "3005:     outb(0x00 , sbdev->reserved_addr[0] + 0x21);",
          "3006:     request_region(sbdev->reserved_addr[0], 32, sbdev->name);",
          "3007:     sbdev->uart_access_addr = pcidev->resource[1].start & PCI_BASE_ADDRESS_IO_MASK;",
          "3008:     sbdev->option_reg_addr = pcidev->resource[2].start & PCI_BASE_ADDRESS_IO_MASK;",
          "3009:    }",
          "3012:    if (sbdev->revision == 0xc0)",
          "3013:    {",
          "3014:     int prev_port_addr = 0;",
          "3016:     pci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);",
          "3017:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);",
          "3018:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_2, prev_port_addr + 16, 8);",
          "3019:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_3, prev_port_addr + 24, 8);",
          "3020:    }",
          "3021:    break;",
          "3022:   case PCI_DEVICE_ID_MP6 :",
          "3023:   case PCI_DEVICE_ID_MP6A :",
          "3024:   case PCI_DEVICE_ID_GT_MP6 :",
          "3025:   case PCI_DEVICE_ID_GT_MP6A :",
          "3026:    sbdev->nr_ports = 6;",
          "3029:    if (sbdev->revision == 0xc0)",
          "3030:    {",
          "3031:     int prev_port_addr = 0;",
          "3033:     pci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);",
          "3034:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);",
          "3035:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_2, prev_port_addr + 16, 16);",
          "3036:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_3, prev_port_addr + 32, 16);",
          "3037:    }",
          "3038:    break;",
          "3039:   case PCI_DEVICE_ID_MP8 :",
          "3040:   case PCIE_DEVICE_ID_MP8 :",
          "3041:   case PCI_DEVICE_ID_GT_MP8 :",
          "3042:   case PCIE_DEVICE_ID_GT_MP8 :",
          "3043:   case PCIE_DEVICE_ID_MP8B :",
          "3044:    sbdev->nr_ports = 8;",
          "3045:    break;",
          "3046:   case PCI_DEVICE_ID_MP32 :",
          "3047:   case PCIE_DEVICE_ID_MP32 :",
          "3048:   case PCI_DEVICE_ID_GT_MP32 :",
          "3049:   case PCIE_DEVICE_ID_GT_MP32 :",
          "3050:    {",
          "3051:     int portnum_hex=0;",
          "3052:     portnum_hex = inb(sbdev->option_reg_addr);",
          "3053:     sbdev->nr_ports = ((portnum_hex/16)*10) + (portnum_hex % 16);",
          "3054:    }",
          "3055:    break;",
          "3056:   case PCI_DEVICE_ID_MP2S1P :",
          "3057:    sbdev->nr_ports = 2;",
          "3060:    if (sbdev->revision == 0xc0)",
          "3061:    {",
          "3062:     int prev_port_addr = 0;",
          "3064:     pci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);",
          "3065:     pci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);",
          "3066:    }",
          "3069:    parport_pc_probe_port(pcidev->resource[2].start, pcidev->resource[3].start, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &pcidev->dev, 0);",
          "3070:    break;",
          "3071:   case PCI_DEVICE_ID_MP1P :",
          "3073:    parport_pc_probe_port(pcidev->resource[2].start, pcidev->resource[3].start, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &pcidev->dev, 0);",
          "3074:    break;",
          "3075:  }",
          "3077:  ret = request_region(sbdev->uart_access_addr, (8*sbdev->nr_ports), sbdev->name);",
          "3079:  if (sbdev->revision == 0xc0)",
          "3080:  {",
          "3081:   ret = request_region(sbdev->option_reg_addr, 0x40, sbdev->name);",
          "3082:  }",
          "3083:  else",
          "3084:  {",
          "3085:   ret = request_region(sbdev->option_reg_addr, 0x20, sbdev->name);",
          "3086:  }",
          "3089:  NR_BOARD++;",
          "3090:  NR_PORTS += sbdev->nr_ports;",
          "3093:  addr = sbdev->option_reg_addr + MP_OPTR_IMR0;",
          "3094:  for(j=0; j < (sbdev->nr_ports/8)+1; j++)",
          "3095:  {",
          "3096:   if (sbdev->poll_type == TYPE_INTERRUPT)",
          "3097:   {",
          "3098:    outb(0xff,addr +j);",
          "3099:   }",
          "3100:  }",
          "3101:  sbdev++;",
          "3103:  return 0;",
          "3104: }",
          "3106: static int __init multi_init(void)",
          "3107: {",
          "3108:  int ret, i;",
          "3109:  struct pci_dev  *dev = NULL;",
          "3111:  if(fcr_count==0)",
          "3112:  {",
          "3113:   for(i=0;i<256;i++)",
          "3114:   {",
          "3115:    fcr_arr[i] = 0x01;",
          "3117:   }",
          "3118:  }",
          "3119:  if(deep_count==0)",
          "3120:  {",
          "3121:   for(i=0;i<256;i++)",
          "3122:   {",
          "3123:    deep[i] = 1;",
          "3125:   }",
          "3126:  }",
          "3127:  if(rtr_count==0)",
          "3128:         {",
          "3129:                 for(i=0;i<256;i++)",
          "3130:                 {",
          "3131:                         rtr[i] = 0x10;",
          "3132:                 }",
          "3133:         }",
          "3134:  if(ttr_count==0)",
          "3135:         {",
          "3136:                 for(i=0;i<256;i++)",
          "3137:                 {",
          "3138:                         ttr[i] = 0x38;",
          "3139:                 }",
          "3140:         }",
          "3143: printk(\"MULTI INIT\\n\");",
          "3144:  for( i=0; i< mp_nrpcibrds; i++)",
          "3145:  {",
          "3147:   while( (dev = pci_get_device(mp_pciboards[i].vendor_id, mp_pciboards[i].device_id, dev) ) )",
          "3149:   {",
          "3150: printk(\"FOUND~~~\\n\");",
          "3153:    {",
          "3154:     int status;",
          "3155:            pci_disable_device(dev);",
          "3156:            status = pci_enable_device(dev);",
          "3158:             if (status != 0)",
          "3159:            {",
          "3160:                    printk(\"Multiport Board Enable Fail !\\n\\n\");",
          "3161:                    status = -ENXIO;",
          "3162:                    return status;",
          "3163:               }",
          "3164:    }",
          "3166:    init_mp_dev(dev, mp_pciboards[i]);",
          "3167:   }",
          "3168:  }",
          "3170:  for (i = 0; i < NR_IRQS; i++)",
          "3171:   spin_lock_init(&irq_lists[i].lock);",
          "3173:  ret = mp_register_driver(&multi_reg);",
          "3175:  if (ret >= 0)",
          "3176:   multi_register_ports(&multi_reg);",
          "3178:  return ret;",
          "3179: }",
          "3181: static void __exit multi_exit(void)",
          "3182: {",
          "3183:  int i;",
          "3185:  for (i = 0; i < NR_PORTS; i++)",
          "3186:   mp_remove_one_port(&multi_reg, &multi_ports[i].port);",
          "3188:  mp_unregister_driver(&multi_reg);",
          "3189: }",
          "3191: module_init(multi_init);",
          "3192: module_exit(multi_exit);",
          "3194: MODULE_DESCRIPTION(\"SystemBase Multiport PCI/PCIe CORE\");",
          "3195: MODULE_LICENSE(\"GPL\");",
          "",
          "---------------"
        ],
        "drivers/staging/sb105x/sb_pci_mp.h||drivers/staging/sb105x/sb_pci_mp.h": [
          "File: drivers/staging/sb105x/sb_pci_mp.h -> drivers/staging/sb105x/sb_pci_mp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <linux/errno.h>",
          "2: #include <linux/signal.h>",
          "3: #include <linux/tty.h>",
          "4: #include <linux/tty_flip.h>",
          "5: #include <linux/serial.h>",
          "6: #include <linux/serial_reg.h>",
          "7: #include <linux/ioport.h>",
          "8: #include <linux/mm.h>",
          "9: #include <linux/sched.h>",
          "11: #include <linux/kernel.h>",
          "12: #include <linux/init.h>",
          "13: #include <linux/slab.h>",
          "14: #include <linux/wait.h>",
          "15: #include <linux/tty_driver.h>",
          "16: #include <linux/pci.h>",
          "17: #include <linux/circ_buf.h>",
          "19: #include <asm/uaccess.h>",
          "20: #include <asm/io.h>",
          "21: #include <asm/irq.h>",
          "22: #include <asm/segment.h>",
          "23: #include <asm/serial.h>",
          "24: #include <linux/interrupt.h>",
          "27: #include <linux/parport.h>",
          "28: #include <linux/ctype.h>",
          "29: #include <linux/poll.h>",
          "32: #define MP_TERMIOS  ktermios",
          "34: #include \"sb_mp_register.h\"",
          "35: #include \"sb_ser_core.h\"",
          "37: #define DRIVER_VERSION  \"1.1\"",
          "38: #define DRIVER_DATE     \"2012/01/05\"",
          "39: #define DRIVER_AUTHOR  \"SYSTEMBASE<tech@sysbas.com>\"",
          "40: #define DRIVER_DESC  \"SystemBase PCI/PCIe Multiport Core\"",
          "42: #define SB_TTY_MP_MAJOR   54",
          "43: #define PCI_VENDOR_ID_MULTIPORT  0x14A1",
          "45: #define PCI_DEVICE_ID_MP1  0x4d01",
          "46: #define PCI_DEVICE_ID_MP2  0x4d02",
          "47: #define PCI_DEVICE_ID_MP4  0x4d04",
          "48: #define PCI_DEVICE_ID_MP4A  0x4d54",
          "49: #define PCI_DEVICE_ID_MP6  0x4d06",
          "50: #define PCI_DEVICE_ID_MP6A  0x4d56",
          "51: #define PCI_DEVICE_ID_MP8  0x4d08",
          "52: #define PCI_DEVICE_ID_MP32  0x4d32",
          "54: #define PCI_DEVICE_ID_MP1P  0x4301",
          "55: #define PCI_DEVICE_ID_MP2S1P  0x4303",
          "57: #define PCIE_DEVICE_ID_MP1  0x4501",
          "58: #define PCIE_DEVICE_ID_MP2  0x4502",
          "59: #define PCIE_DEVICE_ID_MP4  0x4504",
          "60: #define PCIE_DEVICE_ID_MP8  0x4508",
          "61: #define PCIE_DEVICE_ID_MP32  0x4532",
          "63: #define PCIE_DEVICE_ID_MP1E  0x4e01",
          "64: #define PCIE_DEVICE_ID_MP2E  0x4e02",
          "65: #define PCIE_DEVICE_ID_MP2B  0x4b02",
          "66: #define PCIE_DEVICE_ID_MP4B  0x4b04",
          "67: #define PCIE_DEVICE_ID_MP8B  0x4b08",
          "69: #define PCI_DEVICE_ID_GT_MP4  0x0004",
          "70: #define PCI_DEVICE_ID_GT_MP4A  0x0054",
          "71: #define PCI_DEVICE_ID_GT_MP6  0x0006",
          "72: #define PCI_DEVICE_ID_GT_MP6A  0x0056",
          "73: #define PCI_DEVICE_ID_GT_MP8  0x0008",
          "74: #define PCI_DEVICE_ID_GT_MP32  0x0032",
          "76: #define PCIE_DEVICE_ID_GT_MP1  0x1501",
          "77: #define PCIE_DEVICE_ID_GT_MP2  0x1502",
          "78: #define PCIE_DEVICE_ID_GT_MP4  0x1504",
          "79: #define PCIE_DEVICE_ID_GT_MP8  0x1508",
          "80: #define PCIE_DEVICE_ID_GT_MP32  0x1532",
          "82: #define PCI_DEVICE_ID_MP4M  0x4604  //modem",
          "84: #define MAX_MP_DEV  8",
          "88: #define PORT_16C105XA 3",
          "89: #define PORT_16C105X 2",
          "90: #define PORT_16C55X  1",
          "92: #define ENABLE  1",
          "93: #define DISABLE  0",
          "96: #define TIOCGNUMOFPORT  0x545F",
          "97: #define TIOCSMULTIECHO  0x5440",
          "98: #define TIOCSPTPNOECHO  0x5441",
          "100: #define TIOCGOPTIONREG  0x5461",
          "101: #define TIOCGDISABLEIRQ  0x5462",
          "102: #define TIOCGENABLEIRQ  0x5463",
          "103: #define TIOCGSOFTRESET  0x5464",
          "104: #define TIOCGSOFTRESETR  0x5465",
          "105: #define TIOCGREGINFO  0x5466",
          "106: #define TIOCGGETLSR  0x5467",
          "107: #define TIOCGGETDEVID  0x5468",
          "108: #define TIOCGGETBDNO  0x5469",
          "109: #define TIOCGGETINTERFACE 0x546A",
          "110: #define TIOCGGETREV  0x546B",
          "111: #define TIOCGGETNRPORTS  0x546C",
          "112: #define TIOCGGETPORTTYPE 0x546D",
          "113: #define GETDEEPFIFO  0x54AA",
          "114: #define SETDEEPFIFO  0x54AB",
          "115: #define SETFCR   0x54BA",
          "116: #define SETTTR   0x54B1",
          "117: #define SETRTR   0x54B2",
          "118: #define GETTTR   0x54B3",
          "119: #define GETRTR   0x54B4",
          "122: #define TIOCSMULTIDROP  0x5470",
          "123: #define TIOCSMDADDR     0x5471",
          "124: #define TIOCGMDADDR     0x5472",
          "125: #define TIOCSENDADDR  0x5473",
          "129: #define RS232  1",
          "130: #define RS422PTP 2",
          "131: #define RS422MD  3",
          "132: #define RS485NE  4",
          "133: #define RS485ECHO 5",
          "135: #define serial_inp(up, offset)      serial_in(up, offset)",
          "136: #define serial_outp(up, offset, value)  serial_out(up, offset, value)",
          "138: #define PASS_LIMIT  256",
          "139: #define is_real_interrupt(irq)  ((irq) != 0)",
          "141: #define PROBE_ANY   (~0)",
          "143: static DEFINE_MUTEX(mp_mutex);",
          "144: #define MP_MUTEX_LOCK(x) mutex_lock(&(x))",
          "145: #define MP_MUTEX_UNLOCK(x) mutex_unlock(&(x))",
          "146: #define MP_STATE_LOCK(x) mutex_lock(&((x)->mutex))",
          "147: #define MP_STATE_UNLOCK(x) mutex_unlock(&((x)->mutex))",
          "150: #define UART_LSR_SPECIAL    0x1E",
          "152: #define HIGH_BITS_OFFSET        ((sizeof(long)-sizeof(int))*8)",
          "153: #define uart_users(state)       ((state)->count + ((state)->info ? (state)->info->blocked_open : 0))",
          "157: #undef MP_DEBUG",
          "159: #ifdef MP_DEBUG",
          "160: #define DPRINTK(x...)   printk(x)",
          "161: #else",
          "162: #define DPRINTK(x...)   do { } while (0)",
          "163: #endif",
          "165: #ifdef MP_DEBUG",
          "166: #define DEBUG_AUTOCONF(fmt...)  printk(fmt)",
          "167: #else",
          "168: #define DEBUG_AUTOCONF(fmt...)  do { } while (0)",
          "169: #endif",
          "171: #ifdef MP_DEBUG",
          "172: #define DEBUG_INTR(fmt...)  printk(fmt)",
          "173: #else",
          "174: #define DEBUG_INTR(fmt...)  do { } while (0)",
          "175: #endif",
          "177: #if defined(__i386__) && (defined(CONFIG_M386) || defined(CONFIG_M486))",
          "178: #define SERIAL_INLINE",
          "179: #endif",
          "180: #ifdef SERIAL_INLINE",
          "181: #define _INLINE_ inline",
          "182: #else",
          "183: #define _INLINE_",
          "184: #endif",
          "186: #define TYPE_POLL 1",
          "187: #define TYPE_INTERRUPT 2",
          "190: struct mp_device_t {",
          "191:         unsigned short  device_id;",
          "192:         unsigned char   revision;",
          "193:         char            *name;",
          "194:         unsigned long   uart_access_addr;",
          "195:         unsigned long   option_reg_addr;",
          "196:         unsigned long   reserved_addr[4];",
          "197:         int             irq;",
          "198:         int             nr_ports;",
          "199:         int             poll_type;",
          "200: };",
          "202: typedef struct mppcibrd {",
          "203:         char            *name;",
          "204:         unsigned short  vendor_id;",
          "205:         unsigned short  device_id;",
          "206: } mppcibrd_t;",
          "208: static mppcibrd_t mp_pciboards[] = {",
          "210:         { \"Multi-1 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP1} ,",
          "211:         { \"Multi-2 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP2} ,",
          "212:         { \"Multi-4 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP4} ,",
          "213:         { \"Multi-4 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP4A} ,",
          "214:         { \"Multi-6 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP6} ,",
          "215:         { \"Multi-6 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP6A} ,",
          "216:         { \"Multi-8 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP8} ,",
          "217:         { \"Multi-32 PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP32} ,",
          "219:         { \"Multi-1P PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP1P} ,",
          "220:         { \"Multi-2S1P PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP2S1P} ,",
          "222:         { \"Multi-4(GT) PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_GT_MP4} ,",
          "223:         { \"Multi-4(GT) PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_GT_MP4A} ,",
          "224:         { \"Multi-6(GT) PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_GT_MP6} ,",
          "225:         { \"Multi-6(GT) PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_GT_MP6A} ,",
          "226:         { \"Multi-8(GT) PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_GT_MP8} ,",
          "227:         { \"Multi-32(GT) PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_GT_MP32} ,",
          "229:         { \"Multi-1 PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP1} ,",
          "230:         { \"Multi-2 PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP2} ,",
          "231:         { \"Multi-4 PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP4} ,",
          "232:         { \"Multi-8 PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP8} ,",
          "233:         { \"Multi-32 PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP32} ,",
          "235:         { \"Multi-1 PCIe E\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP1E} ,",
          "236:         { \"Multi-2 PCIe E\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP2E} ,",
          "237:         { \"Multi-2 PCIe B\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP2B} ,",
          "238:         { \"Multi-4 PCIe B\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP4B} ,",
          "239:         { \"Multi-8 PCIe B\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_MP8B} ,",
          "241:         { \"Multi-1(GT) PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_GT_MP1} ,",
          "242:         { \"Multi-2(GT) PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_GT_MP2} ,",
          "243:         { \"Multi-4(GT) PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_GT_MP4} ,",
          "244:         { \"Multi-8(GT) PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_GT_MP8} ,",
          "245:         { \"Multi-32(GT) PCIe\", PCI_VENDOR_ID_MULTIPORT , PCIE_DEVICE_ID_GT_MP32} ,",
          "247:         { \"Multi-4M PCI\", PCI_VENDOR_ID_MULTIPORT , PCI_DEVICE_ID_MP4M} ,",
          "248: };",
          "250: struct mp_port {",
          "251:         struct sb_uart_port port;",
          "256:         unsigned short      rev;",
          "257:         unsigned char       acr;",
          "258:         unsigned char       ier;",
          "259:         unsigned char       lcr;",
          "260:         unsigned char       mcr;",
          "263:         unsigned char       lsr_break_flag;",
          "265:         void            (*pm)(struct sb_uart_port *port,",
          "266:                         unsigned int state, unsigned int old);",
          "267:         struct mp_device_t *device;",
          "268:         unsigned long   interface_config_addr;",
          "269:         unsigned long   option_base_addr;",
          "270:         unsigned char   interface;",
          "271:         unsigned char   poll_type;",
          "272: };",
          "274: struct irq_info {",
          "275:         spinlock_t      lock;",
          "276:         struct list_head    *head;",
          "277: };",
          "279: struct sb105x_uart_config {",
          "280:  char    *name;",
          "281:  int     dfl_xmit_fifo_size;",
          "282:  int     flags;",
          "283: };",
          "285: static const struct sb105x_uart_config uart_config[] = {",
          "286:         { \"unknown\",    1,  0 },",
          "287:         { \"16550A\", 16, UART_CLEAR_FIFO | UART_USE_FIFO },",
          "288:         { \"SB16C1050\",    128,    UART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },",
          "289:         { \"SB16C1050A\",    128,    UART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },",
          "290: };",
          "",
          "---------------"
        ],
        "drivers/staging/sb105x/sb_ser_core.h||drivers/staging/sb105x/sb_ser_core.h": [
          "File: drivers/staging/sb105x/sb_ser_core.h -> drivers/staging/sb105x/sb_ser_core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <linux/wait.h>",
          "3: #define UART_CONFIG_TYPE (1 << 0)",
          "4: #define UART_CONFIG_IRQ  (1 << 1)",
          "5: #define UPIO_PORT  (0)",
          "6: #define UPIO_HUB6  (1)",
          "7: #define UPIO_MEM  (2)",
          "8: #define UPIO_MEM32  (3)",
          "11: #define UPF_FOURPORT  (1 << 1)",
          "12: #define UPF_SAK   (1 << 2)",
          "13: #define UPF_SPD_MASK  (0x1030)",
          "14: #define UPF_SPD_HI  (0x0010)",
          "15: #define UPF_SPD_VHI  (0x0020)",
          "16: #define UPF_SPD_CUST  (0x0030)",
          "17: #define UPF_SPD_SHI  (0x1000)",
          "18: #define UPF_SPD_WARP  (0x1010)",
          "19: #define UPF_SKIP_TEST  (1 << 6)",
          "20: #define UPF_AUTO_IRQ  (1 << 7)",
          "21: #define UPF_HARDPPS_CD  (1 << 11)",
          "22: #define UPF_LOW_LATENCY  (1 << 13)",
          "23: #define UPF_BUGGY_UART  (1 << 14)",
          "24: #define UPF_MAGIC_MULTIPLIER (1 << 16)",
          "25: #define UPF_CONS_FLOW  (1 << 23)",
          "26: #define UPF_SHARE_IRQ  (1 << 24)",
          "27: #define UPF_BOOT_AUTOCONF (1 << 28)",
          "28: #define UPF_DEAD  (1 << 30)",
          "29: #define UPF_IOREMAP  (1 << 31)",
          "30: #define UPF_CHANGE_MASK  (0x17fff)",
          "31: #define UPF_USR_MASK  (UPF_SPD_MASK|UPF_LOW_LATENCY)",
          "32: #define USF_CLOSING_WAIT_INF (0)",
          "33: #define USF_CLOSING_WAIT_NONE (~0U)",
          "35: #define UART_XMIT_SIZE PAGE_SIZE",
          "37: #define UIF_CHECK_CD  (1 << 25)",
          "38: #define UIF_CTS_FLOW  (1 << 26)",
          "39: #define UIF_NORMAL_ACTIVE (1 << 29)",
          "40: #define UIF_INITIALIZED  (1 << 31)",
          "41: #define UIF_SUSPENDED  (1 << 30)",
          "43: #define WAKEUP_CHARS  256",
          "45: #define uart_circ_empty(circ)  ((circ)->head == (circ)->tail)",
          "46: #define uart_circ_clear(circ)  ((circ)->head = (circ)->tail = 0)",
          "48: #define uart_circ_chars_pending(circ) \\",
          "49:  (CIRC_CNT((circ)->head, (circ)->tail, UART_XMIT_SIZE))",
          "51: #define uart_circ_chars_free(circ) \\",
          "52:  (CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))",
          "54: #define uart_tx_stopped(port)  \\",
          "55:  ((port)->info->tty->stopped || (port)->info->tty->hw_stopped)",
          "57: #define UART_ENABLE_MS(port,cflag) ((port)->flags & UPF_HARDPPS_CD || \\",
          "58:       (cflag) & CRTSCTS || \\",
          "59:       !((cflag) & CLOCAL))",
          "62: struct sb_uart_port;",
          "63: struct sb_uart_info;",
          "64: struct serial_struct;",
          "65: struct device;",
          "67: struct sb_uart_ops {",
          "68:  unsigned int (*tx_empty)(struct sb_uart_port *);",
          "69:  void  (*set_mctrl)(struct sb_uart_port *, unsigned int mctrl);",
          "70:  unsigned int (*get_mctrl)(struct sb_uart_port *);",
          "71:  void  (*stop_tx)(struct sb_uart_port *);",
          "72:  void  (*start_tx)(struct sb_uart_port *);",
          "73:  void  (*send_xchar)(struct sb_uart_port *, char ch);",
          "74:  void  (*stop_rx)(struct sb_uart_port *);",
          "75:  void  (*enable_ms)(struct sb_uart_port *);",
          "76:  void  (*break_ctl)(struct sb_uart_port *, int ctl);",
          "77:  int  (*startup)(struct sb_uart_port *);",
          "78:  void  (*shutdown)(struct sb_uart_port *);",
          "79:  void  (*set_termios)(struct sb_uart_port *, struct MP_TERMIOS *new,",
          "80:            struct MP_TERMIOS *old);",
          "81:  void  (*pm)(struct sb_uart_port *, unsigned int state,",
          "82:          unsigned int oldstate);",
          "83:  int  (*set_wake)(struct sb_uart_port *, unsigned int state);",
          "85:  const char *(*type)(struct sb_uart_port *);",
          "87:  void  (*release_port)(struct sb_uart_port *);",
          "89:  int  (*request_port)(struct sb_uart_port *);",
          "90:  void  (*config_port)(struct sb_uart_port *, int);",
          "91:  int  (*verify_port)(struct sb_uart_port *, struct serial_struct *);",
          "92:  int  (*ioctl)(struct sb_uart_port *, unsigned int, unsigned long);",
          "93: };",
          "96: struct sb_uart_icount {",
          "97:  __u32 cts;",
          "98:  __u32 dsr;",
          "99:  __u32 rng;",
          "100:  __u32 dcd;",
          "101:  __u32 rx;",
          "102:  __u32 tx;",
          "103:  __u32 frame;",
          "104:  __u32 overrun;",
          "105:  __u32 parity;",
          "106:  __u32 brk;",
          "107:  __u32 buf_overrun;",
          "108: };",
          "109: typedef unsigned int  upf_t;",
          "111: struct sb_uart_port {",
          "121:  unsigned char  unused1;",
          "130: #ifdef CONFIG_SERIAL_CORE_CONSOLE",
          "132: #endif",
          "134:  upf_t   flags;",
          "139:  const struct sb_uart_ops *ops;",
          "140:  unsigned int  custom_divisor;",
          "145:  unsigned char  unused[3];",
          "146: };",
          "148: #define mdmode   unused[2]",
          "149: #define MDMODE_ADDR  0x1",
          "150: #define MDMODE_ENABLE 0x2",
          "151: #define MDMODE_AUTO  0x4",
          "152: #define MDMODE_ADDRSEND 0x8",
          "154: struct sb_uart_state {",
          "159:  int   count;",
          "160:  int   pm_state;",
          "161:  struct sb_uart_info *info;",
          "162:  struct sb_uart_port *port;",
          "164:  struct mutex  mutex;",
          "165: };",
          "167: typedef unsigned int  uif_t;",
          "169: struct sb_uart_info {",
          "170:  struct tty_struct *tty;",
          "171:  struct circ_buf  xmit;",
          "172:  uif_t   flags;",
          "174:  int   blocked_open;",
          "176:  struct tasklet_struct tlet;",
          "178:  wait_queue_head_t open_wait;",
          "179:  wait_queue_head_t delta_msr_wait;",
          "180: };",
          "183: struct module;",
          "184: struct tty_driver;",
          "186: struct uart_driver {",
          "187:  struct module  *owner;",
          "188:  const char  *driver_name;",
          "189:  const char  *dev_name;",
          "190:  int    major;",
          "191:  int    minor;",
          "192:  int    nr;",
          "193:  struct console  *cons;",
          "195:  struct sb_uart_state *state;",
          "196:         struct tty_driver               *tty_driver;",
          "197: };",
          "199: void sb_uart_write_wakeup(struct sb_uart_port *port)",
          "200: {",
          "201:     struct sb_uart_info *info = port->info;",
          "202:     tasklet_schedule(&info->tlet);",
          "203: }",
          "205: void sb_uart_update_timeout(struct sb_uart_port *port, unsigned int cflag,",
          "206:     unsigned int baud)",
          "207: {",
          "208:     unsigned int bits;",
          "210:     switch (cflag & CSIZE)",
          "211:     {",
          "212:         case CS5:",
          "213:             bits = 7;",
          "214:             break;",
          "216:         case CS6:",
          "217:             bits = 8;",
          "218:             break;",
          "220:         case CS7:",
          "221:             bits = 9;",
          "222:             break;",
          "224:         default:",
          "225:             bits = 10;",
          "226:             break;",
          "227:     }",
          "229:     if (cflag & CSTOPB)",
          "230:     {",
          "231:         bits++;",
          "232:     }",
          "234:     if (cflag & PARENB)",
          "235:     {",
          "236:         bits++;",
          "237:     }",
          "239:     bits = bits * port->fifosize;",
          "241:     port->timeout = (HZ * bits) / baud + HZ/50;",
          "242: }",
          "243: unsigned int sb_uart_get_baud_rate(struct sb_uart_port *port, struct MP_TERMIOS *termios,",
          "244:     struct MP_TERMIOS *old, unsigned int min,",
          "245:     unsigned int max)",
          "246: {",
          "247:         unsigned int try, baud, altbaud = 38400;",
          "248:         upf_t flags = port->flags & UPF_SPD_MASK;",
          "250:         if (flags == UPF_SPD_HI)",
          "251:                 altbaud = 57600;",
          "252:         if (flags == UPF_SPD_VHI)",
          "253:                 altbaud = 115200;",
          "254:         if (flags == UPF_SPD_SHI)",
          "255:                 altbaud = 230400;",
          "256:         if (flags == UPF_SPD_WARP)",
          "257:                 altbaud = 460800;",
          "259:         for (try = 0; try < 2; try++) {",
          "261:                 switch (termios->c_cflag & (CBAUD | CBAUDEX))",
          "262:                 {",
          "263:                  case B921600    : baud = 921600;    break;",
          "264:                  case B460800    : baud = 460800;    break;",
          "265:                  case B230400    : baud = 230400;    break;",
          "266:                  case B115200    : baud = 115200;    break;",
          "267:                  case B57600     : baud = 57600;     break;",
          "268:                  case B38400     : baud = 38400;     break;",
          "269:                  case B19200     : baud = 19200;     break;",
          "270:                  case B9600      : baud = 9600;      break;",
          "271:                  case B4800      : baud = 4800;      break;",
          "272:                  case B2400      : baud = 2400;      break;",
          "273:                  case B1800      : baud = 1800;      break;",
          "274:                  case B1200      : baud = 1200;      break;",
          "275:                  case B600       : baud = 600;       break;",
          "276:                  case B300       : baud = 300;       break;",
          "277:                         case B200       : baud = 200;       break;",
          "278:                  case B150       : baud = 150;       break;",
          "279:                  case B134       : baud = 134;       break;",
          "280:                  case B110       : baud = 110;       break;",
          "281:                  case B75        : baud = 75;        break;",
          "282:                  case B50        : baud = 50;        break;",
          "283:                  default         : baud = 9600;      break;",
          "284:                 }",
          "286:                 if (baud == 38400)",
          "287:                         baud = altbaud;",
          "289:                 if (baud == 0)",
          "290:                         baud = 9600;",
          "292:                 if (baud >= min && baud <= max)",
          "293:                         return baud;",
          "295:                 termios->c_cflag &= ~CBAUD;",
          "296:                 if (old) {",
          "297:                         termios->c_cflag |= old->c_cflag & CBAUD;",
          "298:                         old = NULL;",
          "299:                         continue;",
          "300:                 }",
          "302:                 termios->c_cflag |= B9600;",
          "303:         }",
          "305:         return 0;",
          "306: }",
          "307: unsigned int sb_uart_get_divisor(struct sb_uart_port *port, unsigned int baud)",
          "308: {",
          "309:         unsigned int quot;",
          "311:         if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)",
          "312:                 quot = port->custom_divisor;",
          "313:         else",
          "314:                 quot = (port->uartclk + (8 * baud)) / (16 * baud);",
          "316:         return quot;",
          "317: }",
          "321: static inline int sb_uart_handle_break(struct sb_uart_port *port)",
          "322: {",
          "323:  struct sb_uart_info *info = port->info;",
          "325:  if (port->flags & UPF_SAK)",
          "326:   do_SAK(info->tty);",
          "327:  return 0;",
          "328: }",
          "330: static inline void sb_uart_handle_dcd_change(struct sb_uart_port *port, unsigned int status)",
          "331: {",
          "332:  struct sb_uart_info *info = port->info;",
          "334:  port->icount.dcd++;",
          "336:  if (info->flags & UIF_CHECK_CD) {",
          "337:   if (status)",
          "338:    wake_up_interruptible(&info->open_wait);",
          "339:   else if (info->tty)",
          "340:    tty_hangup(info->tty);",
          "341:  }",
          "342: }",
          "344: static inline void sb_uart_handle_cts_change(struct sb_uart_port *port, unsigned int status)",
          "345: {",
          "346:  struct sb_uart_info *info = port->info;",
          "347:  struct tty_struct *tty = info->tty;",
          "349:  port->icount.cts++;",
          "351:  if (info->flags & UIF_CTS_FLOW) {",
          "352:   if (tty->hw_stopped) {",
          "353:    if (status) {",
          "354:     tty->hw_stopped = 0;",
          "355:     port->ops->start_tx(port);",
          "356:     sb_uart_write_wakeup(port);",
          "357:    }",
          "358:   } else {",
          "359:    if (!status) {",
          "360:     tty->hw_stopped = 1;",
          "361:     port->ops->stop_tx(port);",
          "362:    }",
          "363:   }",
          "364:  }",
          "365: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-18672",
  "cve_desc": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
  "repo": "keepkey/keepkey-firmware",
  "patch_hash": "769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
  "patch_info": {
    "commit_hash": "769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
    "repo": "keepkey/keepkey-firmware",
    "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
    "files": [
      "lib/firmware/recovery_cipher.c"
    ],
    "message": "firmware: stronger recovery state machine checks",
    "before_after_code_files": [
      "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
    ]
  },
  "patch_diff": {
    "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c": [
      "File: lib/firmware/recovery_cipher.c -> lib/firmware/recovery_cipher.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "37: #define MAX_UNCYPHERED_WORDS (3)",
      "39: static bool enforce_wordlist;",
      "40: static bool dry_run;",
      "41: static bool awaiting_character;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "39: static bool recovery_started = false;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "56:         storage_reset();",
      "57:     }",
      "59:     awaiting_character = false;",
      "60:     memzero(mnemonic, sizeof(mnemonic));",
      "61:     memzero(cipher, sizeof(cipher));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "60:     recovery_started = false;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "272:     awaiting_character = true;",
      "273:     next_character();",
      "274: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "275:     recovery_started = true;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "284: void next_character(void)",
      "285: {",
      "287:     strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);",
      "288:     random_permute_char(cipher, strlen(cipher));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "289:     if (!recovery_started) {",
      "290:         recovery_abort();",
      "291:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
      "292:         layoutHome();",
      "293:         return;",
      "294:     }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "342: void recovery_character(const char *character)",
      "343: {",
      "345:         recovery_abort();",
      "346:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
      "347:         layoutHome();",
      "",
      "[Removed Lines]",
      "344:     if (!awaiting_character) {",
      "",
      "[Added Lines]",
      "354:     if (!awaiting_character || !recovery_started) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "431: void recovery_delete_character(void)",
      "432: {",
      "433:     if(strlen(mnemonic) > 0)",
      "434:     {",
      "435:         mnemonic[strlen(mnemonic) - 1] = '\\0';",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "443:     if (!recovery_started) {",
      "444:         recovery_abort();",
      "445:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
      "446:         layoutHome();",
      "447:         return;",
      "448:     }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "449: void recovery_cipher_finalize(void)",
      "450: {",
      "451:     static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";",
      "452:     static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];",
      "453:     volatile bool auto_completed = true;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "468:     if (!recovery_started) {",
      "469:         recovery_abort();",
      "470:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
      "471:         layoutHome();",
      "472:         return;",
      "473:     }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "479:     }",
      "484:     if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {",
      "485:         storage_setMnemonic(new_mnemonic);",
      "",
      "[Removed Lines]",
      "482:     new_mnemonic[strlen(new_mnemonic) - 1] = '\\0';",
      "",
      "[Added Lines]",
      "506:     new_mnemonic[MAX(0u, strnlen(new_mnemonic, sizeof(new_mnemonic)) - 1)] = '\\0';",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "533: bool recovery_cipher_abort(void)",
      "534: {",
      "535:     if (awaiting_character) {",
      "536:         awaiting_character = false;",
      "537:         return true;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "559:     recovery_started = false;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a66c4bdf4902ba23514b98807b74b2c9c5270fe4",
      "candidate_info": {
        "commit_hash": "a66c4bdf4902ba23514b98807b74b2c9c5270fe4",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/a66c4bdf4902ba23514b98807b74b2c9c5270fe4",
        "files": [
          "lib/firmware/eos.h",
          "lib/firmware/recovery_cipher.c"
        ],
        "message": "firmware: better default initialization",
        "before_after_code_files": [
          "lib/firmware/eos.h||lib/firmware/eos.h",
          "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ],
          "candidate": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/firmware/eos.h||lib/firmware/eos.h": [
          "File: lib/firmware/eos.h -> lib/firmware/eos.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:         return retval; \\",
          "30:     }",
          "35: extern CONFIDENTIAL Hasher hasher_preimage;",
          "",
          "[Removed Lines]",
          "32: #define MAX(a, b) ({ typeof(a) _a = (a); typeof(b) _b = (b); _a > _b ? _a : _b; })",
          "33: #define MIN(a, b) ({ typeof(a) _a = (a); typeof(b) _b = (b); _a < _b ? _a : _b; })",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c": [
          "File: lib/firmware/recovery_cipher.c -> lib/firmware/recovery_cipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"trezor/crypto/memzero.h\"",
          "25: #include \"keepkey/firmware/app_layout.h\"",
          "26: #include \"keepkey/board/confirm_sm.h\"",
          "27: #include \"keepkey/firmware/fsm.h\"",
          "28: #include \"keepkey/firmware/home_sm.h\"",
          "29: #include \"keepkey/firmware/pin_sm.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"keepkey/board/util.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: #define MAX_UNCYPHERED_WORDS (3)",
          "39: static bool recovery_started = false;",
          "42: static bool awaiting_character;",
          "43: static CONFIDENTIAL char mnemonic[MNEMONIC_BUF];",
          "44: static char english_alphabet[ENGLISH_ALPHABET_BUF] = \"abcdefghijklmnopqrstuvwxyz\";",
          "",
          "[Removed Lines]",
          "40: static bool enforce_wordlist;",
          "41: static bool dry_run;",
          "",
          "[Added Lines]",
          "41: static bool enforce_wordlist = true;",
          "42: static bool dry_run = true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "60:     recovery_started = false;",
          "61:     awaiting_character = false;",
          "62:     memzero(mnemonic, sizeof(mnemonic));",
          "63:     memzero(cipher, sizeof(cipher));",
          "64: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:     enforce_wordlist = true;",
          "64:     dry_run = true;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "476:     static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];",
          "477:     volatile bool auto_completed = true;",
          "480:     char *tok = strtok(mnemonic, \" \");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "482:     memzero(new_mnemonic, sizeof(new_mnemonic));",
          "483:     memzero(temp_word, sizeof(temp_word));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "542:     memzero(new_mnemonic, sizeof(new_mnemonic));",
          "543:     awaiting_character = false;",
          "544:     memzero(mnemonic, sizeof(mnemonic));",
          "545:     memzero(cipher, sizeof(cipher));",
          "546:     layoutHome();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "550:     enforce_wordlist = true;",
          "551:     dry_run = true;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8ae264058c0f388b9f917df70e17db157f7c0175",
      "candidate_info": {
        "commit_hash": "8ae264058c0f388b9f917df70e17db157f7c0175",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/8ae264058c0f388b9f917df70e17db157f7c0175",
        "files": [
          "lib/firmware/recovery_cipher.c"
        ],
        "message": "firmware: reset word_count",
        "before_after_code_files": [
          "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ],
          "candidate": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c": [
          "File: lib/firmware/recovery_cipher.c -> lib/firmware/recovery_cipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69:     enforce_wordlist = true;",
          "70:     dry_run = true;",
          "71:     words_entered = 0;",
          "72:     memzero(mnemonic, sizeof(mnemonic));",
          "73:     memzero(cipher, sizeof(cipher));",
          "74: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72:     word_count = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "602:     enforce_wordlist = true;",
          "603:     dry_run = true;",
          "604:     words_entered = 0;",
          "605:     memzero(mnemonic, sizeof(mnemonic));",
          "606:     memzero(cipher, sizeof(cipher));",
          "607:     layoutHome();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "606:     word_count = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "efea76ad165085aa8a6df4529f27cfec4ea174af",
      "candidate_info": {
        "commit_hash": "efea76ad165085aa8a6df4529f27cfec4ea174af",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/efea76ad165085aa8a6df4529f27cfec4ea174af",
        "files": [
          "include/keepkey/board/layout.h",
          "include/keepkey/board/resources.h",
          "include/keepkey/firmware/recovery.h",
          "include/keepkey/firmware/recovery_cipher.h",
          "lib/board/layout.c",
          "lib/board/resources.c",
          "lib/firmware/CMakeLists.txt",
          "lib/firmware/fsm.c",
          "lib/firmware/fsm_msg_common.h",
          "lib/firmware/fsm_msg_debug.h",
          "lib/firmware/messagemap.def",
          "lib/firmware/recovery.c",
          "lib/firmware/recovery_cipher.c"
        ],
        "message": "Remove word recovery\n\nIt takes up space in .text/.data/.bss, and isn't being used.",
        "before_after_code_files": [
          "include/keepkey/board/layout.h||include/keepkey/board/layout.h",
          "include/keepkey/board/resources.h||include/keepkey/board/resources.h",
          "include/keepkey/firmware/recovery.h||include/keepkey/firmware/recovery.h",
          "include/keepkey/firmware/recovery_cipher.h||include/keepkey/firmware/recovery_cipher.h",
          "lib/board/layout.c||lib/board/layout.c",
          "lib/board/resources.c||lib/board/resources.c",
          "lib/firmware/fsm.c||lib/firmware/fsm.c",
          "lib/firmware/fsm_msg_common.h||lib/firmware/fsm_msg_common.h",
          "lib/firmware/fsm_msg_debug.h||lib/firmware/fsm_msg_debug.h",
          "lib/firmware/messagemap.def||lib/firmware/messagemap.def",
          "lib/firmware/recovery.c||lib/firmware/recovery.c",
          "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ],
          "candidate": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ]
        }
      },
      "candidate_diff": {
        "include/keepkey/board/layout.h||include/keepkey/board/layout.h": [
          "File: include/keepkey/board/layout.h -> include/keepkey/board/layout.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:     NOTIFICATION_INFO,",
          "72:     NOTIFICATION_REQUEST,",
          "73:     NOTIFICATION_REQUEST_NO_ANIMATION,",
          "75:     NOTIFICATION_UNPLUG,",
          "76:     NOTIFICATION_CONFIRM_ANIMATION,",
          "77:     NOTIFICATION_CONFIRMED,",
          "",
          "[Removed Lines]",
          "74:     NOTIFICATION_RECOVERY,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/keepkey/board/resources.h||include/keepkey/board/resources.h": [
          "File: include/keepkey/board/resources.h -> include/keepkey/board/resources.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: const AnimationFrame *get_confirm_icon_frame(void);",
          "29: const AnimationFrame *get_confirmed_frame(void);",
          "30: const AnimationFrame *get_unplug_frame(void);",
          "32: const AnimationFrame *get_warning_frame(void);",
          "33: const AnimationFrame *get_logo_frame(void);",
          "",
          "[Removed Lines]",
          "31: const AnimationFrame *get_recovery_frame(void);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/keepkey/firmware/recovery.h||include/keepkey/firmware/recovery.h": [
          "File: include/keepkey/firmware/recovery.h -> include/keepkey/firmware/recovery.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/keepkey/firmware/recovery_cipher.h||include/keepkey/firmware/recovery_cipher.h": [
          "File: include/keepkey/firmware/recovery_cipher.h -> include/keepkey/firmware/recovery_cipher.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: void recovery_character(const char *character);",
          "38: void recovery_delete_character(void);",
          "39: void recovery_cipher_finalize(void);",
          "42: #if DEBUG_LINK",
          "43: const char* recovery_get_cipher(void);",
          "",
          "[Removed Lines]",
          "40: bool recovery_cipher_abort(void);",
          "",
          "[Added Lines]",
          "40: void recovery_cipher_abort(void);",
          "",
          "---------------"
        ],
        "lib/board/layout.c||lib/board/layout.c": [
          "File: lib/board/layout.c -> lib/board/layout.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "361:             draw_bitmap_mono_rle(canvas, get_unplug_frame(), false);",
          "362:             break;",
          "370:         case NOTIFICATION_LOGO: {",
          "371:             const Image *image = variant_keepkey.logo->frames[variant_keepkey.logo->count - 1].image;",
          "372:             const AnimationFrame frame = { 190, 9, 0, 100, image };",
          "",
          "[Removed Lines]",
          "364:         case NOTIFICATION_RECOVERY:",
          "365:             sp->x = 221;",
          "366:             sp->y = 20;",
          "367:             draw_bitmap_mono_rle(canvas, get_recovery_frame(), false);",
          "368:             break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/board/resources.c||lib/board/resources.c": [
          "File: lib/board/resources.c -> lib/board/resources.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "532: static const Image unplug_image = {45, 27, sizeof(unplug_data), unplug_data};",
          "533: const AnimationFrame unplug_frame = {208, 21, 20, 100, &unplug_image};",
          "",
          "[Removed Lines]",
          "537: static const uint8_t recovery_data[372] =",
          "538: {",
          "539:     0xff, 0xc2, 0x08, 0x00, 0xf5, 0x14, 0x6d, 0xb0, 0xd6, 0xf4, 0xff, 0xf4, 0xd6, 0xb0, 0x6d, 0x14, 0x09, 0x00, 0xfe, 0xff, 0xc2, 0x05, 0x00, 0xfd, 0x29, 0xb0, 0xfd, 0x09, 0xff, 0xfd, 0xfd, 0xb0, 0x29, 0x07, 0x00, 0x02, 0xff, 0xff, 0xc2, 0x03, 0x00, 0xfe, 0x96, 0xfd, 0x0d, 0xff, 0xfe, 0xfd, 0x96, 0x06, 0x00, 0x03, 0xff, 0xfd, 0xc2, 0x14, 0xd6, 0x11, 0xff, 0xfe, 0xd6, 0x14, 0x04, 0x00, 0x04, 0xff, 0xff, 0xf4, 0x05, 0xff, 0xfd, 0xf4, 0xba, 0x7d, 0x03, 0x4e, 0xfd, 0x7d, 0xba, 0xf4, 0x05, 0xff, 0xfe, 0xe6, 0x14, 0x03, 0x00, 0x08, 0xff, 0xfd, 0xfd, 0x96, 0x29, 0x07, 0x00, 0xfd, 0x29, 0x96, 0xfd, 0x04, 0xff, 0xff, 0xd6, 0x03, 0x00, 0x07, 0xff, 0xfe, 0xe6, 0x4e, 0x0b, 0x00, 0xfe, 0x4e, 0xe6, 0x04, 0xff, 0xff, 0x96, 0x02, 0x00, 0x07, 0xff, 0xff, 0xc2, 0x0d, 0x00, 0xfe, 0x29, 0xe6, 0x03, 0xff, 0xfd, 0xfd, 0x29, 0x00, 0x08, 0xff, 0xff, 0xc2, 0x0d, 0x00, 0xfe, 0x4e, 0xfd, 0x03, 0xff, 0xfe, 0xb0, 0x00, 0x09, 0xff, 0xff, 0xc2, 0x0d, 0x00, 0xff, 0x96, 0x03, 0xff, 0xfe, 0xfd, 0x14, 0x0a, 0xff, 0xff, 0xc2, 0x0c, 0x00, 0xfe, 0x14, 0xf4, 0x03, 0xff, 0xff, 0x6d, 0x0b, 0xff, 0xff, 0xc2, 0x0c, 0x00, 0xff, 0xba, 0x03, 0xff, 0xff, 0xb0, 0x18, 0x00, 0xff, 0x7d, 0x03, 0xff, 0xff, 0xd6, 0x18, 0x00, 0xff, 0x4e, 0x03, 0xff, 0xff, 0xf4, 0x18, 0x00, 0xff, 0x4e, 0x04, 0xff, 0x18, 0x00, 0xff, 0x4e, 0x03, 0xff, 0xff, 0xf4, 0x18, 0x00, 0xff, 0x7d, 0x03, 0xff, 0xff, 0xd6, 0x18, 0x00, 0xff, 0xba, 0x03, 0xff, 0xff, 0xb0, 0x17, 0x00, 0xfe, 0x14, 0xf4, 0x03, 0xff, 0xff, 0x6d, 0x17, 0x00, 0xff, 0x96, 0x03, 0xff, 0xfe, 0xfd, 0x14, 0x16, 0x00, 0xfe, 0x4e, 0xfd, 0x03, 0xff, 0xff, 0xb0, 0x16, 0x00, 0xfe, 0x29, 0xe6, 0x03, 0xff, 0xfe, 0xfd, 0x29, 0x08, 0x00, 0xfe, 0x96, 0x4e, 0x0b, 0x00, 0xfe, 0x4e, 0xe6, 0x04, 0xff, 0xff, 0x96, 0x08, 0x00, 0xfb, 0xa2, 0xff, 0xfd, 0x96, 0x29, 0x07, 0x00, 0xfd, 0x29, 0x96, 0xfd, 0x04, 0xff, 0xff, 0xd6, 0x08, 0x00, 0xff, 0xa2, 0x04, 0xff, 0xfd, 0xf4, 0xba, 0x7d, 0x03, 0x4e, 0xfd, 0x7d, 0xba, 0xf4, 0x05, 0xff, 0xfe, 0xe6, 0x14, 0x07, 0x00, 0xfe, 0x14, 0xd6, 0x11, 0xff, 0xfe, 0xd6, 0x14, 0x0a, 0x00, 0xfe, 0x96, 0xfd, 0x0d, 0xff, 0xfe, 0xfd, 0x96, 0x0d, 0x00, 0xfd, 0x29, 0xb0, 0xfd, 0x09, 0xff, 0xfd, 0xfd, 0xb0, 0x29, 0x10, 0x00, 0xf5, 0x14, 0x6d, 0xb0, 0xd6, 0xf4, 0xff, 0xf4, 0xd6, 0xb0, 0x6d, 0x14, 0x09, 0x00",
          "540: };",
          "541: static const Image recovery_image = {29, 29, sizeof(recovery_data), recovery_data};",
          "542: const AnimationFrame recovery_frame = {221, 20, 20, 100, &recovery_image};",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "582:     return &unplug_frame;",
          "583: }",
          "",
          "[Removed Lines]",
          "593: const AnimationFrame *get_recovery_frame(void)",
          "594: {",
          "595:     return &recovery_frame;",
          "596: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/firmware/fsm.c||lib/firmware/fsm.c": [
          "File: lib/firmware/fsm.c -> lib/firmware/fsm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #include \"keepkey/firmware/passphrase_sm.h\"",
          "47: #include \"keepkey/firmware/pin_sm.h\"",
          "48: #include \"keepkey/firmware/policy.h\"",
          "50: #include \"keepkey/firmware/recovery_cipher.h\"",
          "51: #include \"keepkey/firmware/reset.h\"",
          "52: #include \"keepkey/firmware/signing.h\"",
          "",
          "[Removed Lines]",
          "49: #include \"keepkey/firmware/recovery.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/firmware/fsm_msg_common.h||lib/firmware/fsm_msg_common.h": [
          "File: lib/firmware/fsm_msg_common.h -> lib/firmware/fsm_msg_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: void fsm_msgInitialize(Initialize *msg)",
          "2: {",
          "3:     (void)msg;",
          "5:     signing_abort();",
          "6:     ethereum_signing_abort();",
          "7:     eos_signingAbort();",
          "",
          "[Removed Lines]",
          "4:     recovery_abort(false);",
          "",
          "[Added Lines]",
          "4:     recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "380: void fsm_msgCancel(Cancel *msg)",
          "381: {",
          "382:     (void)msg;",
          "384:     signing_abort();",
          "385:     ethereum_signing_abort();",
          "386:     eos_signingAbort();",
          "",
          "[Removed Lines]",
          "383:     recovery_abort(true);",
          "",
          "[Added Lines]",
          "383:     recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "485:         CHECK_NOT_INITIALIZED",
          "486:     }",
          "520: }",
          "522: void fsm_msgCharacterAck(CharacterAck *msg)",
          "",
          "[Removed Lines]",
          "488:     if (msg->has_use_character_cipher &&",
          "489:         msg->use_character_cipher)               // recovery via character cipher",
          "490:     {",
          "491:         recovery_cipher_init(",
          "492:             msg->has_word_count ? msg->word_count : 0,",
          "493:             msg->has_passphrase_protection && msg->passphrase_protection,",
          "494:             msg->has_pin_protection && msg->pin_protection,",
          "495:             msg->has_language ? msg->language : 0,",
          "496:             msg->has_label ? msg->label : 0,",
          "497:             msg->has_enforce_wordlist ? msg->enforce_wordlist : false,",
          "498:             msg->has_auto_lock_delay_ms ? msg->auto_lock_delay_ms : STORAGE_DEFAULT_SCREENSAVER_TIMEOUT,",
          "499:             msg->has_u2f_counter ? msg->u2f_counter : 0,",
          "500:             msg->has_dry_run ? msg->dry_run : false",
          "501:         );",
          "502:     } else {                                     // legacy way of recovery",
          "503:         recovery_init(",
          "504:             msg->has_word_count ? msg->word_count : 12,",
          "505:             msg->has_passphrase_protection && msg->passphrase_protection,",
          "506:             msg->has_pin_protection && msg->pin_protection,",
          "507:             msg->has_language ? msg->language : 0,",
          "508:             msg->has_label ? msg->label : 0,",
          "509:             msg->has_enforce_wordlist ? msg->enforce_wordlist : false,",
          "510:             msg->has_auto_lock_delay_ms ? msg->auto_lock_delay_ms : STORAGE_DEFAULT_SCREENSAVER_TIMEOUT,",
          "511:             msg->has_u2f_counter ? msg->u2f_counter : 0,",
          "512:             msg->has_dry_run ? msg->dry_run : false",
          "513:         );",
          "514:     }",
          "515: }",
          "517: void fsm_msgWordAck(WordAck *msg)",
          "518: {",
          "519:     recovery_word(msg->word);",
          "",
          "[Added Lines]",
          "488:     recovery_cipher_init(",
          "489:          msg->has_word_count ? msg->word_count : 0,",
          "490:          msg->has_passphrase_protection && msg->passphrase_protection,",
          "491:          msg->has_pin_protection && msg->pin_protection,",
          "492:          msg->has_language ? msg->language : 0,",
          "493:          msg->has_label ? msg->label : 0,",
          "494:          msg->has_enforce_wordlist ? msg->enforce_wordlist : false,",
          "495:          msg->has_auto_lock_delay_ms ? msg->auto_lock_delay_ms : STORAGE_DEFAULT_SCREENSAVER_TIMEOUT,",
          "496:          msg->has_u2f_counter ? msg->u2f_counter : 0,",
          "497:          msg->has_dry_run ? msg->dry_run : false",
          "498:     );",
          "",
          "---------------"
        ],
        "lib/firmware/fsm_msg_debug.h||lib/firmware/fsm_msg_debug.h": [
          "File: lib/firmware/fsm_msg_debug.h -> lib/firmware/fsm_msg_debug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:     resp->has_reset_word = true;",
          "20:     strlcpy(resp->reset_word, reset_get_word(), sizeof(resp->reset_word));",
          "29:     if(storage_hasMnemonic())",
          "30:     {",
          "31:         resp->has_mnemonic = true;",
          "",
          "[Removed Lines]",
          "22:     resp->has_recovery_fake_word = true;",
          "23:     strlcpy(resp->recovery_fake_word, recovery_get_fake_word(),",
          "24:             sizeof(resp->recovery_fake_word));",
          "26:     resp->has_recovery_word_pos = true;",
          "27:     resp->recovery_word_pos = recovery_get_word_pos();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/firmware/messagemap.def||lib/firmware/messagemap.def": [
          "File: lib/firmware/messagemap.def -> lib/firmware/messagemap.def",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:     MSG_IN(MessageType_MessageType_PassphraseAck,                   PassphraseAck,               NO_PROCESS_FUNC)",
          "32:     MSG_IN(MessageType_MessageType_RecoveryDevice,                  RecoveryDevice,              fsm_msgRecoveryDevice)",
          "34:     MSG_IN(MessageType_MessageType_CharacterAck,                    CharacterAck,                fsm_msgCharacterAck)",
          "35:     MSG_IN(MessageType_MessageType_ApplyPolicies,                   ApplyPolicies,               fsm_msgApplyPolicies)",
          "36:     MSG_IN(MessageType_MessageType_EthereumGetAddress,              EthereumGetAddress,          fsm_msgEthereumGetAddress)",
          "",
          "[Removed Lines]",
          "33:     MSG_IN(MessageType_MessageType_WordAck,                         WordAck,                     fsm_msgWordAck)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/firmware/recovery.c||lib/firmware/recovery.c": [
          "File: lib/firmware/recovery.c -> lib/firmware/recovery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c": [
          "File: lib/firmware/recovery_cipher.c -> lib/firmware/recovery_cipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: static uint32_t get_current_word_pos(void);",
          "62: static void get_current_word(char *current_word);",
          "65:     if (!dry_run) {",
          "66:         storage_reset();",
          "67:     }",
          "",
          "[Removed Lines]",
          "64: static void recovery_abort(void) {",
          "",
          "[Added Lines]",
          "64: void recovery_cipher_abort(void) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "275:     if (!dry_run) {",
          "276:         if (pin_protection) {",
          "277:             if (!change_pin()) {",
          "279:                 fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");",
          "280:                 layoutHome();",
          "281:                 return;",
          "",
          "[Removed Lines]",
          "278:                 recovery_abort();",
          "",
          "[Added Lines]",
          "278:                 recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "326: void next_character(void)",
          "327: {",
          "328:     if (!recovery_started) {",
          "330:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
          "331:         layoutHome();",
          "332:         return;",
          "",
          "[Removed Lines]",
          "329:         recovery_abort();",
          "",
          "[Added Lines]",
          "329:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "343:     if (strlen(current_word) > 4) {",
          "344:         memzero(current_word, sizeof(current_word));",
          "347:         fsm_sendFailure(FailureType_Failure_SyntaxError,",
          "348:                         \"Words were not entered correctly. Make sure you are using the substition cipher.\");",
          "349:         layoutHome();",
          "",
          "[Removed Lines]",
          "346:         recovery_abort();",
          "",
          "[Added Lines]",
          "346:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "353:     uint32_t word_pos = get_current_word_pos();",
          "354:     if (word_pos + 1 != words_entered) {",
          "356:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Sanity check failed\");",
          "357:         layoutHome();",
          "358:         return;",
          "",
          "[Removed Lines]",
          "355:         recovery_abort();",
          "",
          "[Added Lines]",
          "355:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "399: void recovery_character(const char *character)",
          "400: {",
          "401:     if (!awaiting_character || !recovery_started) {",
          "403:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
          "404:         layoutHome();",
          "405:         return;",
          "406:     }",
          "408:     if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {",
          "410:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage,",
          "411:                         \"Too many characters attempted during recovery\");",
          "412:         layoutHome();",
          "",
          "[Removed Lines]",
          "402:         recovery_abort();",
          "409:         recovery_abort();",
          "",
          "[Added Lines]",
          "402:         recovery_cipher_abort();",
          "409:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "419:     if (character[0] != ' ' && pos == NULL) {",
          "421:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");",
          "422:         layoutHome();",
          "423:         return;",
          "",
          "[Removed Lines]",
          "420:         recovery_abort();",
          "",
          "[Added Lines]",
          "420:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "459:                 definitely_using_cipher = true;",
          "460:             } else if (maybe_not_using_cipher && !definitely_using_cipher &&",
          "461:                        MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {",
          "463:                 fsm_sendFailure(FailureType_Failure_SyntaxError,",
          "464:                                 \"Words were not entered correctly. Make sure you are using the substition cipher.\");",
          "465:                 layoutHome();",
          "",
          "[Removed Lines]",
          "462:                 recovery_abort();",
          "",
          "[Added Lines]",
          "462:                 recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "472:         words_entered++;",
          "474:         if (words_entered > 24 || (word_count && words_entered > word_count)) {",
          "476:             fsm_sendFailure(FailureType_Failure_SyntaxError, \"Too many words entered\");",
          "477:             layoutHome();",
          "478:             return;",
          "",
          "[Removed Lines]",
          "475:             recovery_abort();",
          "",
          "[Added Lines]",
          "475:             recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "496: void recovery_delete_character(void)",
          "497: {",
          "498:     if (!recovery_started) {",
          "500:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
          "501:         layoutHome();",
          "502:         return;",
          "",
          "[Removed Lines]",
          "499:         recovery_abort();",
          "",
          "[Added Lines]",
          "499:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "525: void recovery_cipher_finalize(void)",
          "526: {",
          "527:     if (!recovery_started) {",
          "529:         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
          "530:         layoutHome();",
          "531:         return;",
          "",
          "[Removed Lines]",
          "528:         recovery_abort();",
          "",
          "[Added Lines]",
          "528:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "537:         if (words_entered != word_count) {",
          "539:             fsm_sendFailure(FailureType_Failure_SyntaxError, \"Not enough words entered\");",
          "540:             layoutHome();",
          "541:             return;",
          "",
          "[Removed Lines]",
          "538:             recovery_abort();",
          "",
          "[Added Lines]",
          "538:             recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "616:         session_clear(true);",
          "617:         fsm_sendFailure(FailureType_Failure_SyntaxError,",
          "618:                         \"Invalid mnemonic, are words in correct order?\");",
          "620:     }",
          "622:     memzero(new_mnemonic, sizeof(new_mnemonic));",
          "",
          "[Removed Lines]",
          "619:         recovery_abort();",
          "",
          "[Added Lines]",
          "619:         recovery_cipher_abort();",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "630:     layoutHome();",
          "631: }",
          "652: #if DEBUG_LINK",
          "",
          "[Removed Lines]",
          "641: bool recovery_cipher_abort(void)",
          "642: {",
          "643:     recovery_started = false;",
          "645:     if (awaiting_character) {",
          "646:         awaiting_character = false;",
          "647:         return true;",
          "648:     }",
          "649:     return false;",
          "650: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d6f64d5a44d4ecd2e21cdf4ed30ed606faf7402",
      "candidate_info": {
        "commit_hash": "6d6f64d5a44d4ecd2e21cdf4ed30ed606faf7402",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/6d6f64d5a44d4ecd2e21cdf4ed30ed606faf7402",
        "files": [
          "include/keepkey/firmware/recovery_cipher.h",
          "lib/firmware/fsm_msg_common.h",
          "lib/firmware/recovery_cipher.c"
        ],
        "message": "firmware: enforce word count in recovery_cipher",
        "before_after_code_files": [
          "include/keepkey/firmware/recovery_cipher.h||include/keepkey/firmware/recovery_cipher.h",
          "lib/firmware/fsm_msg_common.h||lib/firmware/fsm_msg_common.h",
          "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ],
          "candidate": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ]
        }
      },
      "candidate_diff": {
        "include/keepkey/firmware/recovery_cipher.h||include/keepkey/firmware/recovery_cipher.h": [
          "File: include/keepkey/firmware/recovery_cipher.h -> include/keepkey/firmware/recovery_cipher.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #define ENGLISH_ALPHABET_BUF    32",
          "29: #define ENGLISH_MAX_WORD_LEN    8",
          "34: void next_character(void);",
          "35: void recovery_character(const char *character);",
          "36: void recovery_delete_character(void);",
          "",
          "[Removed Lines]",
          "31: void recovery_cipher_init(bool passphrase_protection, bool pin_protection, const char *language,",
          "32:     const char *label, bool _enforce_wordlist, uint32_t _auto_lock_delay_ms,",
          "33:     uint32_t _u2f_counter, bool _dry_run);",
          "",
          "[Added Lines]",
          "31: void recovery_cipher_init(uint32_t _word_count, bool passphrase_protection,",
          "32:                           bool pin_protection, const char *language,",
          "33:                           const char *label, bool _enforce_wordlist,",
          "34:                           uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter,",
          "35:                           bool _dry_run);",
          "",
          "---------------"
        ],
        "lib/firmware/fsm_msg_common.h||lib/firmware/fsm_msg_common.h": [
          "File: lib/firmware/fsm_msg_common.h -> lib/firmware/fsm_msg_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "489:         msg->use_character_cipher)               // recovery via character cipher",
          "490:     {",
          "491:         recovery_cipher_init(",
          "492:             msg->has_passphrase_protection && msg->passphrase_protection,",
          "493:             msg->has_pin_protection && msg->pin_protection,",
          "494:             msg->has_language ? msg->language : 0,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "492:             msg->has_word_count ? msg->word_count : 12,",
          "",
          "---------------"
        ],
        "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c": [
          "File: lib/firmware/recovery_cipher.c -> lib/firmware/recovery_cipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #define MAX_UNCYPHERED_WORDS (3)",
          "40: static bool recovery_started = false;",
          "41: static bool enforce_wordlist = true;",
          "42: static bool dry_run = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: static uint32_t word_count = 0;",
          "41: static uint32_t words_entered = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49: static char auto_completed_word[CURRENT_WORD_BUF];",
          "50: #endif",
          "53: static uint32_t get_current_word_pos(void);",
          "54: static void get_current_word(char *current_word);",
          "",
          "[Removed Lines]",
          "52: static void format_current_word(char *current_word, bool auto_completed);",
          "",
          "[Added Lines]",
          "54: static void format_current_word(uint32_t word_pos, char *current_word, bool auto_completed);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "62:     awaiting_character = false;",
          "63:     enforce_wordlist = true;",
          "64:     dry_run = true;",
          "65:     memzero(mnemonic, sizeof(mnemonic));",
          "66:     memzero(cipher, sizeof(cipher));",
          "67: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67:     words_entered = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "75: {",
          "76:     static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];",
          "79:     snprintf(temp_word, CURRENT_WORD_BUF, \"%\" PRIu32 \".%s\", word_num, current_word);",
          "",
          "[Removed Lines]",
          "74: static void format_current_word(char *current_word, bool auto_completed)",
          "77:     uint32_t word_num = get_current_word_pos() + 1;",
          "",
          "[Added Lines]",
          "77: static void format_current_word(uint32_t word_pos, char *current_word, bool auto_completed)",
          "80:     uint32_t word_num = word_pos + 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "234:                           const char *language, const char *label, bool _enforce_wordlist,",
          "235:                           uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)",
          "236: {",
          "237:     enforce_wordlist = _enforce_wordlist;",
          "238:     dry_run = _dry_run;",
          "",
          "[Removed Lines]",
          "233: void recovery_cipher_init(bool passphrase_protection, bool pin_protection,",
          "",
          "[Added Lines]",
          "237: void recovery_cipher_init(uint32_t _word_count, bool passphrase_protection, bool pin_protection,",
          "241:     if (_word_count != 12 && _word_count != 18 && _word_count != 24) {",
          "242:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Invalid word count (has to be 12, 18 or 24\");",
          "243:         layoutHome();",
          "244:         return;",
          "245:     }",
          "247:     word_count = _word_count;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "277:     awaiting_character = true;",
          "278:     recovery_started = true;",
          "279:     next_character();",
          "280: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:     words_entered = 1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "314:         return;",
          "315:     }",
          "317:     CharacterRequest resp;",
          "318:     memset(&resp, 0, sizeof(CharacterRequest));",
          "321:     resp.character_pos = strlen(current_word);",
          "323:     msg_write(MessageType_MessageType_CharacterRequest, &resp);",
          "",
          "[Removed Lines]",
          "320:     resp.word_pos = get_current_word_pos();",
          "",
          "[Added Lines]",
          "329:     uint32_t word_pos = get_current_word_pos();",
          "330:     if (word_pos + 1 != words_entered) {",
          "331:         recovery_abort();",
          "332:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Sanity check failed\");",
          "333:         layoutHome();",
          "334:         return;",
          "335:     }",
          "340:     resp.word_pos = word_pos;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "337: #endif",
          "343:     layout_cipher(current_word, cipher);",
          "",
          "[Removed Lines]",
          "340:     format_current_word(current_word, auto_completed);",
          "",
          "[Added Lines]",
          "360:     format_current_word(word_pos, current_word, auto_completed);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "425:     } else {",
          "426:         memzero(coded_word, sizeof(coded_word));",
          "427:         memzero(decoded_word, sizeof(decoded_word));",
          "428:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "448:         words_entered++;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "450:         return;",
          "451:     }",
          "454:     {",
          "456:     }",
          "458:     next_character();",
          "",
          "[Removed Lines]",
          "453:     if(strlen(mnemonic) > 0)",
          "455:         mnemonic[strlen(mnemonic) - 1] = '\\0';",
          "",
          "[Added Lines]",
          "474:     size_t len = strlen(mnemonic);",
          "475:     if (len > 0)",
          "477:         if (mnemonic[len - 1] == ' ')",
          "478:             words_entered--;",
          "480:         mnemonic[len - 1] = '\\0';",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "475:         return;",
          "476:     }",
          "478:     static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";",
          "479:     static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];",
          "480:     volatile bool auto_completed = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "503:     if (words_entered != word_count) {",
          "504:         recovery_abort();",
          "505:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Not enough words entered\");",
          "506:         layoutHome();",
          "507:         return;",
          "508:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "549:     awaiting_character = false;",
          "550:     enforce_wordlist = true;",
          "551:     dry_run = true;",
          "552:     memzero(mnemonic, sizeof(mnemonic));",
          "553:     memzero(cipher, sizeof(cipher));",
          "554:     layoutHome();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "584:     words_entered = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9043f0f69ff5b0ed1e44db3ba8594a4267ba055e",
      "candidate_info": {
        "commit_hash": "9043f0f69ff5b0ed1e44db3ba8594a4267ba055e",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/9043f0f69ff5b0ed1e44db3ba8594a4267ba055e",
        "files": [
          "include/keepkey/firmware/recovery.h",
          "include/keepkey/firmware/recovery_cipher.h",
          "include/keepkey/firmware/storage.h",
          "lib/firmware/fsm_msg_common.h",
          "lib/firmware/recovery.c",
          "lib/firmware/recovery_cipher.c",
          "lib/firmware/storage.c"
        ],
        "message": "Recovery dry run",
        "before_after_code_files": [
          "include/keepkey/firmware/recovery.h||include/keepkey/firmware/recovery.h",
          "include/keepkey/firmware/recovery_cipher.h||include/keepkey/firmware/recovery_cipher.h",
          "include/keepkey/firmware/storage.h||include/keepkey/firmware/storage.h",
          "lib/firmware/fsm_msg_common.h||lib/firmware/fsm_msg_common.h",
          "lib/firmware/recovery.c||lib/firmware/recovery.c",
          "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c",
          "lib/firmware/storage.c||lib/firmware/storage.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ],
          "candidate": [
            "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c"
          ]
        }
      },
      "candidate_diff": {
        "include/keepkey/firmware/recovery.h||include/keepkey/firmware/recovery.h": [
          "File: include/keepkey/firmware/recovery.h -> include/keepkey/firmware/recovery.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: void recovery_init(uint32_t _word_count, bool passphrase_protection,",
          "27:                    bool pin_protection, const char *language, const char *label,",
          "28:                    bool _enforce_wordlist, uint32_t _auto_lock_delay_ms,",
          "30: void recovery_word(const char *word);",
          "31: void recovery_abort(bool send_failure);",
          "32: const char *recovery_get_fake_word(void);",
          "33: uint32_t recovery_get_word_pos(void);",
          "",
          "[Removed Lines]",
          "29:                    uint32_t _u2f_counter);",
          "",
          "[Added Lines]",
          "29:                    uint32_t _u2f_counter, bool _dry_run);",
          "31: void recovery_done(void);",
          "",
          "---------------"
        ],
        "include/keepkey/firmware/recovery_cipher.h||include/keepkey/firmware/recovery_cipher.h": [
          "File: include/keepkey/firmware/recovery_cipher.h -> include/keepkey/firmware/recovery_cipher.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: void recovery_cipher_init(bool passphrase_protection, bool pin_protection, const char *language,",
          "32:     const char *label, bool _enforce_wordlist, uint32_t _auto_lock_delay_ms,",
          "34: void next_character(void);",
          "35: void recovery_character(const char *character);",
          "36: void recovery_delete_character(void);",
          "",
          "[Removed Lines]",
          "33:     uint32_t _u2f_counter);",
          "",
          "[Added Lines]",
          "33:     uint32_t _u2f_counter, bool _dry_run);",
          "",
          "---------------"
        ],
        "include/keepkey/firmware/storage.h||include/keepkey/firmware/storage.h": [
          "File: include/keepkey/firmware/storage.h -> include/keepkey/firmware/storage.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "116: const char *storage_getShadowMnemonic(void);",
          "119: bool storage_getImported(void);",
          "122: Allocation storage_getLocation(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119: bool storage_containsMnemonic(const char *mnemonic);",
          "125: void storage_setImported(bool val);",
          "",
          "---------------"
        ],
        "lib/firmware/fsm_msg_common.h||lib/firmware/fsm_msg_common.h": [
          "File: lib/firmware/fsm_msg_common.h -> lib/firmware/fsm_msg_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "480: void fsm_msgRecoveryDevice(RecoveryDevice *msg)",
          "481: {",
          "484:     if (msg->has_use_character_cipher &&",
          "486:     {",
          "487:         recovery_cipher_init(",
          "488:             msg->has_passphrase_protection && msg->passphrase_protection,",
          "",
          "[Removed Lines]",
          "482:     CHECK_NOT_INITIALIZED",
          "485:         msg->use_character_cipher)   // recovery via character cipher",
          "",
          "[Added Lines]",
          "482:     if (msg->has_dry_run && msg->dry_run) {",
          "483:         CHECK_INITIALIZED",
          "484:     } else {",
          "485:         CHECK_NOT_INITIALIZED",
          "486:     }",
          "489:         msg->use_character_cipher)               // recovery via character cipher",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "491:             msg->has_label ? msg->label : 0,",
          "492:             msg->has_enforce_wordlist ? msg->enforce_wordlist : false,",
          "493:             msg->has_auto_lock_delay_ms ? msg->auto_lock_delay_ms : STORAGE_DEFAULT_SCREENSAVER_TIMEOUT,",
          "495:         );",
          "496:     } else {                                     // legacy way of recovery",
          "497:         recovery_init(",
          "",
          "[Removed Lines]",
          "494:             msg->has_u2f_counter ? msg->u2f_counter : 0",
          "",
          "[Added Lines]",
          "498:             msg->has_u2f_counter ? msg->u2f_counter : 0,",
          "499:             msg->has_dry_run ? msg->dry_run : false",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "502:             msg->has_label ? msg->label : 0,",
          "503:             msg->has_enforce_wordlist ? msg->enforce_wordlist : false,",
          "504:             msg->has_auto_lock_delay_ms ? msg->auto_lock_delay_ms : STORAGE_DEFAULT_SCREENSAVER_TIMEOUT,",
          "506:         );",
          "507:     }",
          "508: }",
          "",
          "[Removed Lines]",
          "505:             msg->has_u2f_counter ? msg->u2f_counter : 0",
          "",
          "[Added Lines]",
          "510:             msg->has_u2f_counter ? msg->u2f_counter : 0,",
          "511:             msg->has_dry_run ? msg->dry_run : false",
          "",
          "---------------"
        ],
        "lib/firmware/recovery.c||lib/firmware/recovery.c": [
          "File: lib/firmware/recovery.c -> lib/firmware/recovery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"keepkey/board/keepkey_board.h\"",
          "22: #include \"keepkey/board/layout.h\"",
          "23: #include \"keepkey/board/messages.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"keepkey/board/confirm_sm.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35: #include <string.h>",
          "36: #include <stdio.h>",
          "39: static uint32_t word_count;",
          "40: static bool awaiting_word = false;",
          "41: static bool enforce_wordlist;",
          "42: static char fake_word[12];",
          "43: static uint32_t word_pos;",
          "44: static uint32_t word_index;",
          "45: static char CONFIDENTIAL word_order[24];",
          "46: static char CONFIDENTIAL words[24][12];",
          "49: void next_word(void) {",
          "50:  if (sizeof(word_order)/sizeof(word_order[0]) <= word_index) {",
          "51:   fsm_sendFailure(FailureType_Failure_SyntaxError, \"Invalid word_index\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: static bool dry_run;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:  memset(&resp, 0, sizeof(WordRequest));",
          "95:  msg_write(MessageType_MessageType_WordRequest, &resp);",
          "99: }",
          "101: void recovery_init(uint32_t _word_count, bool passphrase_protection,",
          "102:                    bool pin_protection, const char *language, const char *label,",
          "103:                    bool _enforce_wordlist, uint32_t _auto_lock_delay_ms,",
          "105: {",
          "106:  if (_word_count != 12 && _word_count != 18 && _word_count != 24) {",
          "107:   fsm_sendFailure(FailureType_Failure_SyntaxError, \"Invalid word count (has to be 12, 18 or 24\");",
          "",
          "[Removed Lines]",
          "97:     memzero(title_formatted, sizeof(title_formatted));",
          "98:     memzero(body_formatted, sizeof(body_formatted));",
          "104:                    uint32_t _u2f_counter)",
          "",
          "[Added Lines]",
          "96:  memzero(title_formatted, sizeof(title_formatted));",
          "97:  memzero(body_formatted, sizeof(body_formatted));",
          "103:                    uint32_t _u2f_counter, bool _dry_run)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "112:  word_count = _word_count;",
          "113:  enforce_wordlist = _enforce_wordlist;",
          "120:   }",
          "131:  uint32_t i;",
          "139:  awaiting_word = true;",
          "140:  word_index = 0;",
          "141:  next_word();",
          "",
          "[Removed Lines]",
          "115:  if (pin_protection) {",
          "116:   if (!change_pin()) {",
          "117:    fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");",
          "118:    layoutHome();",
          "119:    return;",
          "121:  } else {",
          "122:   storage_setPin(\"\");",
          "123:  }",
          "125:  storage_setPassphraseProtected(passphrase_protection);",
          "126:  storage_setLanguage(language);",
          "127:  storage_setLabel(label);",
          "128:  storage_setAutoLockDelayMs(_auto_lock_delay_ms);",
          "129:  storage_setU2FCounter(_u2f_counter);",
          "132:     for (i = 0; i < word_count; i++) {",
          "133:         word_order[i] = i + 1;",
          "134:     }",
          "135:     for (i = word_count; i < 24; i++) {",
          "136:         word_order[i] = 0;",
          "137:     }",
          "138:     random_permute_char(word_order, 24);",
          "",
          "[Added Lines]",
          "113:  dry_run = _dry_run;",
          "115:  if (!dry_run) {",
          "116:   if (pin_protection) {",
          "117:    if (!change_pin()) {",
          "118:     fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");",
          "119:     layoutHome();",
          "120:     return;",
          "121:    }",
          "122:   } else {",
          "123:    storage_setPin(\"\");",
          "126:   storage_setPassphraseProtected(passphrase_protection);",
          "127:   storage_setLanguage(language);",
          "128:   storage_setLabel(label);",
          "129:   storage_setAutoLockDelayMs(_auto_lock_delay_ms);",
          "130:   storage_setU2FCounter(_u2f_counter);",
          "131:  } else if (!pin_protect(\"Enter Your PIN\")) {",
          "132:   layoutHome();",
          "133:   return;",
          "134:  }",
          "137:  for (i = 0; i < word_count; i++) {",
          "138:   word_order[i] = i + 1;",
          "139:  }",
          "140:  for (i = word_count; i < 24; i++) {",
          "141:   word_order[i] = 0;",
          "142:  }",
          "143:  random_permute_char(word_order, 24);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "173:     if (word_pos == 0) {",
          "174:         if (!isCorrectFake) {",
          "177:             fsm_sendFailure(FailureType_Failure_SyntaxError, \"Wrong word retyped\");",
          "178:             layoutHome();",
          "179:             return;",
          "",
          "[Removed Lines]",
          "176:             storage_reset();",
          "",
          "[Added Lines]",
          "181:             if (!dry_run)",
          "182:                 storage_reset();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "181:     } else {",
          "183:         if (enforce_wordlist & (!found)) {",
          "185:             fsm_sendFailure(FailureType_Failure_SyntaxError, \"Word not found in the bip39 wordlist\");",
          "186:             layoutHome();",
          "187:             return;",
          "",
          "[Removed Lines]",
          "184:             storage_reset();",
          "",
          "[Added Lines]",
          "190:             if (!dry_run)",
          "191:                 storage_reset();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "190:     }",
          "192:     if (word_index + 1 == 24) {",
          "200:         } else {",
          "203:         }",
          "206:     } else {",
          "209:     }",
          "210: }",
          "212: void recovery_abort(bool send_failure)",
          "",
          "[Removed Lines]",
          "194:         storage_setMnemonicFromWords(words, word_count);",
          "196:         const char *entered_mnemonic = storage_getShadowMnemonic();",
          "197:         if (entered_mnemonic && (!enforce_wordlist || mnemonic_check(entered_mnemonic))) {",
          "198:             storage_commit();",
          "199:             fsm_sendSuccess(\"Device recovered\");",
          "201:             storage_reset();",
          "202:             fsm_sendFailure(FailureType_Failure_SyntaxError, \"Invalid mnemonic, are words in correct order?\");",
          "204:         awaiting_word = false;",
          "205:         layoutHome();",
          "207:         word_index++;",
          "208:         next_word();",
          "",
          "[Added Lines]",
          "200:         recovery_done();",
          "201:     } else {",
          "202:         word_index++;",
          "203:         next_word();",
          "204:     }",
          "205: }",
          "207: void recovery_done(void) {",
          "208:     char new_mnemonic[241] = {0};",
          "209:     strlcpy(new_mnemonic, words[0], sizeof(new_mnemonic));",
          "210:     for (uint32_t i = 0; i < word_count; i++) {",
          "211:         strlcat(new_mnemonic, \" \", sizeof(new_mnemonic));",
          "212:         strlcat(new_mnemonic, words[i], sizeof(new_mnemonic));",
          "213:     }",
          "215:     if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {",
          "216:         storage_setMnemonic(new_mnemonic);",
          "217:         memzero(new_mnemonic, sizeof(new_mnemonic));",
          "218:         if (!enforce_wordlist) {",
          "220:             storage_setImported(true);",
          "221:         }",
          "222:         storage_commit();",
          "223:         fsm_sendSuccess(\"Device recovered\");",
          "224:     } else if (dry_run) {",
          "225:         bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);",
          "226:         memzero(new_mnemonic, sizeof(new_mnemonic));",
          "227:         if (match) {",
          "228:             review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",",
          "229:                    \"The seed is valid and MATCHES the one in the device.\");",
          "230:             fsm_sendSuccess(\"The seed is valid and matches the one in the device.\");",
          "231:         } else if (mnemonic_check(new_mnemonic)) {",
          "232:             review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",",
          "233:                    \"The seed is valid, but DOES NOT MATCH the one in the device.\");",
          "234:             fsm_sendFailure(FailureType_Failure_Other,",
          "235:                             \"The seed is valid, but does not match the one in the device.\");",
          "237:             review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",",
          "238:                    \"The seed is INVALID, and DOES NOT MATCH the one in the device.\");",
          "239:             fsm_sendFailure(FailureType_Failure_Other,",
          "240:                             \"The seed is invalid, and does not match the one in the device.\");",
          "243:         session_clear(true);",
          "244:         fsm_sendFailure(FailureType_Failure_SyntaxError,",
          "245:                         \"Invalid mnemonic, are words in correct order?\");",
          "248:     memzero(new_mnemonic, sizeof(new_mnemonic));",
          "249:     awaiting_word = false;",
          "250:     layoutHome();",
          "",
          "---------------"
        ],
        "lib/firmware/recovery_cipher.c||lib/firmware/recovery_cipher.c": [
          "File: lib/firmware/recovery_cipher.c -> lib/firmware/recovery_cipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"trezor/crypto/bip39.h\"",
          "24: #include \"trezor/crypto/memzero.h\"",
          "25: #include \"keepkey/firmware/app_layout.h\"",
          "26: #include \"keepkey/firmware/fsm.h\"",
          "27: #include \"keepkey/firmware/home_sm.h\"",
          "28: #include \"keepkey/firmware/pin_sm.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include \"keepkey/board/confirm_sm.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36: #define MAX_UNCYPHERED_WORDS (3)",
          "38: static bool enforce_wordlist;",
          "39: static bool awaiting_character;",
          "40: static CONFIDENTIAL char mnemonic[MNEMONIC_BUF];",
          "41: static char english_alphabet[ENGLISH_ALPHABET_BUF] = \"abcdefghijklmnopqrstuvwxyz\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: static bool dry_run;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "222: void recovery_cipher_init(bool passphrase_protection, bool pin_protection,",
          "223:                           const char *language, const char *label, bool _enforce_wordlist,",
          "225: {",
          "232:         }",
          "246:     memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));",
          "",
          "[Removed Lines]",
          "224:                           uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter)",
          "226:     if (pin_protection) {",
          "227:         if (!change_pin()) {",
          "228:             recovery_abort();",
          "229:             fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");",
          "230:             layoutHome();",
          "231:             return;",
          "233:     } else {",
          "234:         storage_setPin(\"\");",
          "235:     }",
          "237:     storage_setPassphraseProtected(passphrase_protection);",
          "238:     storage_setLanguage(language);",
          "239:     storage_setLabel(label);",
          "240:     storage_setAutoLockDelayMs(_auto_lock_delay_ms);",
          "241:     storage_setU2FCounter(_u2f_counter);",
          "243:     enforce_wordlist = _enforce_wordlist;",
          "",
          "[Added Lines]",
          "226:                           uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)",
          "228:     enforce_wordlist = _enforce_wordlist;",
          "229:     dry_run = _dry_run;",
          "231:     if (!dry_run) {",
          "232:         if (pin_protection) {",
          "233:             if (!change_pin()) {",
          "234:                 recovery_abort();",
          "235:                 fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");",
          "236:                 layoutHome();",
          "237:                 return;",
          "238:             }",
          "239:         } else {",
          "240:             storage_setPin(\"\");",
          "243:         storage_setPassphraseProtected(passphrase_protection);",
          "244:         storage_setLanguage(language);",
          "245:         storage_setLabel(label);",
          "246:         storage_setAutoLockDelayMs(_auto_lock_delay_ms);",
          "247:         storage_setU2FCounter(_u2f_counter);",
          "248:     } else if (!pin_protect(\"Enter Your PIN\")) {",
          "249:         layoutHome();",
          "250:         return;",
          "251:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "271:     if (strlen(current_word) > 4) {",
          "272:         memzero(current_word, sizeof(current_word));",
          "275:         recovery_abort();",
          "276:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Words were not entered correctly.\");",
          "277:         layoutHome();",
          "",
          "[Removed Lines]",
          "274:         storage_reset();",
          "",
          "[Added Lines]",
          "282:         if (!dry_run) {",
          "283:             storage_reset();",
          "284:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "409: void recovery_cipher_finalize(void)",
          "410: {",
          "412:     static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];",
          "413:     volatile bool auto_completed = true;",
          "416:     char *tok = strtok(mnemonic, \" \");",
          "420:         strlcpy(temp_word, tok, CURRENT_WORD_BUF);",
          "422:         auto_completed &= attempt_auto_complete(temp_word);",
          "427:         tok = strtok(NULL, \" \");",
          "428:     }",
          "429:     memzero(temp_word, sizeof(temp_word));",
          "437:     }",
          "443:         storage_commit();",
          "444:         fsm_sendSuccess(\"Device recovered\");",
          "454:         fsm_sendFailure(FailureType_Failure_SyntaxError,",
          "455:                         \"Invalid mnemonic, are words in correct order?\");",
          "456:     }",
          "458:     recovery_abort();",
          "459:     layoutHome();",
          "460: }",
          "",
          "[Removed Lines]",
          "411:     static char CONFIDENTIAL full_mnemonic[MNEMONIC_BUF] = \"\";",
          "418:     while(tok)",
          "419:     {",
          "424:         strlcat(full_mnemonic, temp_word, MNEMONIC_BUF);",
          "425:         strlcat(full_mnemonic, \" \", MNEMONIC_BUF);",
          "431:     if(auto_completed)",
          "432:     {",
          "434:         full_mnemonic[strlen(full_mnemonic) - 1] = '\\0';",
          "436:         storage_setMnemonic(full_mnemonic);",
          "438:     memzero(full_mnemonic, sizeof(full_mnemonic));",
          "440:     const char *entered_mnemonic = storage_getShadowMnemonic();",
          "441:     if (entered_mnemonic && (!enforce_wordlist || mnemonic_check(entered_mnemonic)))",
          "442:     {",
          "445:     }",
          "446:     else if (!auto_completed)",
          "447:     {",
          "448:         storage_reset();",
          "449:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Words were not entered correctly.\");",
          "450:     }",
          "451:     else",
          "452:     {",
          "453:         storage_reset();",
          "",
          "[Added Lines]",
          "422:     static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";",
          "429:     while(tok) {",
          "434:         strlcat(new_mnemonic, temp_word, MNEMONIC_BUF);",
          "435:         strlcat(new_mnemonic, \" \", MNEMONIC_BUF);",
          "441:     if (!auto_completed) {",
          "442:         if (!dry_run) {",
          "443:             storage_reset();",
          "444:         }",
          "445:         fsm_sendFailure(FailureType_Failure_SyntaxError, \"Words were not entered correctly.\");",
          "446:         awaiting_character = false;",
          "447:         layoutHome();",
          "448:         return;",
          "452:     new_mnemonic[strlen(new_mnemonic) - 1] = '\\0';",
          "454:     if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {",
          "455:         storage_setMnemonic(new_mnemonic);",
          "456:         memzero(new_mnemonic, sizeof(new_mnemonic));",
          "457:         if (!enforce_wordlist) {",
          "459:             storage_setImported(true);",
          "460:         }",
          "463:     } else if (dry_run) {",
          "464:         bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);",
          "465:         memzero(new_mnemonic, sizeof(new_mnemonic));",
          "466:         if (match) {",
          "467:             review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",",
          "468:                    \"The seed is valid and MATCHES the one in the device.\");",
          "469:             fsm_sendSuccess(\"The seed is valid and matches the one in the device.\");",
          "470:         } else if (mnemonic_check(new_mnemonic)) {",
          "471:             review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",",
          "472:                    \"The seed is valid, but DOES NOT MATCH the one in the device.\");",
          "473:             fsm_sendFailure(FailureType_Failure_Other,",
          "474:                             \"The seed is valid, but does not match the one in the device.\");",
          "475:         } else {",
          "476:             review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",",
          "477:                    \"The seed is INVALID, and DOES NOT MATCH the one in the device.\");",
          "478:             fsm_sendFailure(FailureType_Failure_Other,",
          "479:                             \"The seed is invalid, and does not match the one in the device.\");",
          "480:         }",
          "481:     } else {",
          "482:         session_clear(true);",
          "488:     memzero(new_mnemonic, sizeof(new_mnemonic));",
          "489:     awaiting_character = false;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "470: bool recovery_cipher_abort(void)",
          "471: {",
          "474:         awaiting_character = false;",
          "475:         return true;",
          "476:     }",
          "481: }",
          "483: #if DEBUG_LINK",
          "",
          "[Removed Lines]",
          "472:     if(awaiting_character)",
          "473:     {",
          "477:     else",
          "478:     {",
          "479:         return false;",
          "480:     }",
          "",
          "[Added Lines]",
          "503:     if (awaiting_character) {",
          "507:     return false;",
          "",
          "---------------"
        ],
        "lib/firmware/storage.c||lib/firmware/storage.c": [
          "File: lib/firmware/storage.c -> lib/firmware/storage.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1442:     return shadow_config.storage.pub.has_mnemonic;",
          "1443: }",
          "1445: const char *storage_getShadowMnemonic(void)",
          "1446: {",
          "1447:     if (!shadow_config.storage.has_sec)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1448: bool storage_containsMnemonic(const char *mnemonic) {",
          "1449:  if (!storage_hasMnemonic())",
          "1450:   return false;",
          "1451:  if (!shadow_config.storage.has_sec)",
          "1452:   return false;",
          "1456:  char diff = 0;",
          "1457:  uint32_t i = 0;",
          "1458:  for (; mnemonic[i]; i++) {",
          "1459:   diff |= (shadow_config.storage.sec.mnemonic[i] - mnemonic[i]);",
          "1460:  }",
          "1461:  diff |= shadow_config.storage.sec.mnemonic[i];",
          "1462:  return diff == 0;",
          "1463: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1454:     return shadow_config.storage.pub.imported;",
          "1455: }",
          "1457: bool storage_hasNode(void)",
          "1458: {",
          "1459:     return shadow_config.storage.pub.has_node;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1477: void storage_setImported(bool val)",
          "1478: {",
          "1479:     shadow_config.storage.pub.imported = val;",
          "1480: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
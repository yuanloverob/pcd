{
  "cve_id": "CVE-2018-13100",
  "cve_desc": "An issue was discovered in fs/f2fs/super.c in the Linux kernel through 4.17.3, which does not properly validate secs_per_zone in a corrupted f2fs image, as demonstrated by a divide-by-zero error.",
  "repo": "torvalds/linux",
  "patch_hash": "42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
  "patch_info": {
    "commit_hash": "42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
    "files": [
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix to do sanity check with secs_per_zone\n\nAs Wen Xu reported in below link:\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200183\n\n- Overview\nDivide zero in reset_curseg() when mounting a crafted f2fs image\n\n- Reproduce\n\n- Kernel message\n[  588.281510] divide error: 0000 [#1] SMP KASAN PTI\n[  588.282701] CPU: 0 PID: 1293 Comm: mount Not tainted 4.18.0-rc1+ #4\n[  588.284000] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  588.286178] RIP: 0010:reset_curseg+0x94/0x1a0\n[  588.298166] RSP: 0018:ffff8801e88d7940 EFLAGS: 00010246\n[  588.299360] RAX: 0000000000000014 RBX: ffff8801e1d46d00 RCX: ffffffffb88bf60b\n[  588.300809] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e1d46d64\n[  588.305272] R13: 0000000000000000 R14: 0000000000000014 R15: 0000000000000000\n[  588.306822] FS:  00007fad85008840(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  588.308456] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  588.309623] CR2: 0000000001705078 CR3: 00000001f30f8000 CR4: 00000000000006f0\n[  588.311085] Call Trace:\n[  588.311637]  f2fs_build_segment_manager+0x103f/0x3410\n[  588.316136]  ? f2fs_commit_super+0x1b0/0x1b0\n[  588.317031]  ? set_blocksize+0x90/0x140\n[  588.319473]  f2fs_mount+0x15/0x20\n[  588.320166]  mount_fs+0x60/0x1a0\n[  588.320847]  ? alloc_vfsmnt+0x309/0x360\n[  588.321647]  vfs_kern_mount+0x6b/0x1a0\n[  588.322432]  do_mount+0x34a/0x18c0\n[  588.323175]  ? strndup_user+0x46/0x70\n[  588.323937]  ? copy_mount_string+0x20/0x20\n[  588.324793]  ? memcg_kmem_put_cache+0x1b/0xa0\n[  588.325702]  ? kasan_check_write+0x14/0x20\n[  588.326562]  ? _copy_from_user+0x6a/0x90\n[  588.327375]  ? memdup_user+0x42/0x60\n[  588.328118]  ksys_mount+0x83/0xd0\n[  588.328808]  __x64_sys_mount+0x67/0x80\n[  588.329607]  do_syscall_64+0x78/0x170\n[  588.330400]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  588.331461] RIP: 0033:0x7fad848e8b9a\n[  588.336022] RSP: 002b:00007ffd7c5b6be8 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5\n[  588.337547] RAX: ffffffffffffffda RBX: 00000000016f8030 RCX: 00007fad848e8b9a\n[  588.338999] RDX: 00000000016f8210 RSI: 00000000016f9f30 RDI: 0000000001700ec0\n[  588.340442] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000013\n[  588.341887] R10: 00000000c0ed0000 R11: 0000000000000206 R12: 0000000001700ec0\n[  588.343341] R13: 00000000016f8210 R14: 0000000000000000 R15: 0000000000000003\n[  588.354891] ---[ end trace 4ce02f25ff7d3df5 ]---\n[  588.355862] RIP: 0010:reset_curseg+0x94/0x1a0\n[  588.360742] RSP: 0018:ffff8801e88d7940 EFLAGS: 00010246\n[  588.361812] RAX: 0000000000000014 RBX: ffff8801e1d46d00 RCX: ffffffffb88bf60b\n[  588.363485] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e1d46d64\n[  588.365213] RBP: ffff8801e88d7968 R08: ffffed003c32266f R09: ffffed003c32266f\n[  588.366661] R10: 0000000000000001 R11: ffffed003c32266e R12: ffff8801f0337700\n[  588.368110] R13: 0000000000000000 R14: 0000000000000014 R15: 0000000000000000\n[  588.370057] FS:  00007fad85008840(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  588.372099] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  588.373291] CR2: 0000000001705078 CR3: 00000001f30f8000 CR4: 00000000000006f0\n\n- Location\nhttps://elixir.bootlin.com/linux/latest/source/fs/f2fs/segment.c#L2147\n        curseg->zone = GET_ZONE_FROM_SEG(sbi, curseg->segno);\n\nIf secs_per_zone is corrupted due to fuzzing test, it will cause divide\nzero operation when using GET_ZONE_FROM_SEG macro, so we should do more\nsanity check with secs_per_zone during mount to avoid this issue.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2227:   return 1;",
      "2228:  }",
      "2231:   f2fs_msg(sb, KERN_INFO,",
      "2233:    secs_per_zone, total_sections);",
      "2234:   return 1;",
      "2235:  }",
      "",
      "[Removed Lines]",
      "2230:  if (secs_per_zone > total_sections) {",
      "2232:    \"Wrong secs_per_zone (%u > %u)\",",
      "",
      "[Added Lines]",
      "2230:  if (secs_per_zone > total_sections || !secs_per_zone) {",
      "2232:    \"Wrong secs_per_zone / total_sections (%u, %u)\",",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b57334b9453949bf81281321d14d86d60aee6fde",
      "candidate_info": {
        "commit_hash": "b57334b9453949bf81281321d14d86d60aee6fde",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b57334b9453949bf81281321d14d86d60aee6fde",
        "files": [
          "tools/perf/util/machine.c"
        ],
        "message": "perf machine: Use last_match threads cache only in single thread mode\n\nThere's an issue with using threads::last_match in multithread mode\nwhich is enabled during the perf top synthesize. It might crash with\nfollowing assertion:\n\n  perf: ...include/linux/refcount.h:109: refcount_inc:\n        Assertion `!(!refcount_inc_not_zero(r))' failed.\n\nThe gdb backtrace looks like this:\n\n  0x00007ffff50839fb in raise () from /lib64/libc.so.6\n  (gdb)\n  #0  0x00007ffff50839fb in raise () from /lib64/libc.so.6\n  #1  0x00007ffff5085800 in abort () from /lib64/libc.so.6\n  #2  0x00007ffff507c0da in __assert_fail_base () from /lib64/libc.so.6\n  #3  0x00007ffff507c152 in __assert_fail () from /lib64/libc.so.6\n  #4  0x0000000000535ff9 in refcount_inc (r=0x7fffe8009a70)\n      at ...include/linux/refcount.h:109\n  #5  0x0000000000536771 in thread__get (thread=0x7fffe8009a40)\n      at util/thread.c:115\n  #6  0x0000000000523cd0 in ____machine__findnew_thread (machine=0xbfde38,\n      threads=0xbfdf28, pid=2, tid=2, create=true) at util/machine.c:432\n  #7  0x0000000000523eb4 in __machine__findnew_thread (machine=0xbfde38,\n      pid=2, tid=2) at util/machine.c:489\n  #8  0x0000000000523f24 in machine__findnew_thread (machine=0xbfde38,\n      pid=2, tid=2) at util/machine.c:499\n  #9  0x0000000000526fbe in machine__process_fork_event (machine=0xbfde38,\n  ...\n\nThe failing assertion is this one:\n\n  REFCOUNT_WARN(!refcount_inc_not_zero(r), ...\n\nthe problem is that we don't serialize access to threads::last_match.\nWe serialize the access to the threads tree, but we don't care how's\nthreads::last_match being accessed. Both locked/unlocked paths use\nthat data and can set it. In multithreaded mode we can end up with\ninvalid object in thread__get call, like in following paths race:\n\n  thread 1\n    ...\n    machine__findnew_thread\n      down_write(&threads->lock);\n      __machine__findnew_thread\n        ____machine__findnew_thread\n          th = threads->last_match;\n          if (th->tid == tid) {\n            thread__get\n\n  thread 2\n    ...\n    machine__find_thread\n      down_read(&threads->lock);\n      __machine__findnew_thread\n        ____machine__findnew_thread\n          th = threads->last_match;\n          if (th->tid == tid) {\n            thread__get\n\n  thread 3\n    ...\n    machine__process_fork_event\n      machine__remove_thread\n        __machine__remove_thread\n          threads->last_match = NULL\n          thread__put\n      thread__put\n\nThread 1 and 2 might got stale last_match, before thread 3 clears\nit. Thread 1 and 2 then race with thread 3's thread__put and they\nmight trigger the refcnt == 0 assertion above.\n\nThe patch is disabling the last_match cache for multiple thread\nmode. It was originally meant for single thread scenarios, where\nit's common to have multiple sequential searches of the same\nthread.\n\nIn multithread mode this does not make sense, because top's threads\nprocesses different /proc entries and so the 'struct threads' object\nis queried for various threads. Moreover we'd need to add more locks\nto make it work.\n\nSigned-off-by: Jiri Olsa <jolsa@kernel.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\nCc: Andi Kleen <ak@linux.intel.com>\nCc: David Ahern <dsahern@gmail.com>\nCc: Kan Liang <kan.liang@linux.intel.com>\nCc: Lukasz Odzioba <lukasz.odzioba@intel.com>\nCc: Namhyung Kim <namhyung@kernel.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Wang Nan <wangnan0@huawei.com>\nLink: http://lkml.kernel.org/r/20180719143345.12963-4-jolsa@kernel.org\nSigned-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>",
        "before_after_code_files": [
          "tools/perf/util/machine.c||tools/perf/util/machine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/perf/util/machine.c||tools/perf/util/machine.c": [
          "File: tools/perf/util/machine.c -> tools/perf/util/machine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "415: static struct thread*",
          "418: {",
          "419:  struct thread *th;",
          "",
          "[Removed Lines]",
          "416: threads__get_last_match(struct threads *threads, struct machine *machine,",
          "417:    int pid, int tid)",
          "",
          "[Added Lines]",
          "416: __threads__get_last_match(struct threads *threads, struct machine *machine,",
          "417:      int pid, int tid)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "431:  return NULL;",
          "432: }",
          "434: static void",
          "436: {",
          "437:  threads->last_match = th;",
          "438: }",
          "",
          "[Removed Lines]",
          "435: threads__set_last_match(struct threads *threads, struct thread *th)",
          "",
          "[Added Lines]",
          "434: static struct thread*",
          "435: threads__get_last_match(struct threads *threads, struct machine *machine,",
          "436:    int pid, int tid)",
          "437: {",
          "438:  struct thread *th = NULL;",
          "440:  if (perf_singlethreaded)",
          "441:   th = __threads__get_last_match(threads, machine, pid, tid);",
          "443:  return th;",
          "444: }",
          "447: __threads__set_last_match(struct threads *threads, struct thread *th)",
          "452: static void",
          "453: threads__set_last_match(struct threads *threads, struct thread *th)",
          "454: {",
          "455:  if (perf_singlethreaded)",
          "456:   __threads__set_last_match(threads, th);",
          "457: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "76d56d4ab4f2a9e4f085c7d77172194ddaccf7d2",
      "candidate_info": {
        "commit_hash": "76d56d4ab4f2a9e4f085c7d77172194ddaccf7d2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/76d56d4ab4f2a9e4f085c7d77172194ddaccf7d2",
        "files": [
          "fs/f2fs/inode.c"
        ],
        "message": "f2fs: fix to do sanity check with extra_attr feature\n\nIf FI_EXTRA_ATTR is set in inode by fuzzing, inode.i_addr[0] will be\nparsed as inode.i_extra_isize, then in __recover_inline_status, inline\ndata address will beyond boundary of page, result in accessing invalid\nmemory.\n\nSo in this condition, during reading inode page, let's do sanity check\nwith EXTRA_ATTR feature of fs and extra_attr bit of inode, if they're\ninconsistent, deny to load this inode.\n\n- Overview\nOut-of-bound access in f2fs_iget() when mounting a corrupted f2fs image\n\n- Reproduce\n\nThe following message will be got in KASAN build of 4.18 upstream kernel.\n[  819.392227] ==================================================================\n[  819.393901] BUG: KASAN: slab-out-of-bounds in f2fs_iget+0x736/0x1530\n[  819.395329] Read of size 4 at addr ffff8801f099c968 by task mount/1292\n\n[  819.397079] CPU: 1 PID: 1292 Comm: mount Not tainted 4.18.0-rc1+ #4\n[  819.397082] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  819.397088] Call Trace:\n[  819.397124]  dump_stack+0x7b/0xb5\n[  819.397154]  print_address_description+0x70/0x290\n[  819.397159]  kasan_report+0x291/0x390\n[  819.397163]  ? f2fs_iget+0x736/0x1530\n[  819.397176]  check_memory_region+0x139/0x190\n[  819.397182]  __asan_loadN+0xf/0x20\n[  819.397185]  f2fs_iget+0x736/0x1530\n[  819.397197]  f2fs_fill_super+0x1b4f/0x2b40\n[  819.397202]  ? f2fs_fill_super+0x1b4f/0x2b40\n[  819.397208]  ? f2fs_commit_super+0x1b0/0x1b0\n[  819.397227]  ? set_blocksize+0x90/0x140\n[  819.397241]  mount_bdev+0x1c5/0x210\n[  819.397245]  ? f2fs_commit_super+0x1b0/0x1b0\n[  819.397252]  f2fs_mount+0x15/0x20\n[  819.397256]  mount_fs+0x60/0x1a0\n[  819.397267]  ? alloc_vfsmnt+0x309/0x360\n[  819.397272]  vfs_kern_mount+0x6b/0x1a0\n[  819.397282]  do_mount+0x34a/0x18c0\n[  819.397300]  ? lockref_put_or_lock+0xcf/0x160\n[  819.397306]  ? copy_mount_string+0x20/0x20\n[  819.397318]  ? memcg_kmem_put_cache+0x1b/0xa0\n[  819.397324]  ? kasan_check_write+0x14/0x20\n[  819.397334]  ? _copy_from_user+0x6a/0x90\n[  819.397353]  ? memdup_user+0x42/0x60\n[  819.397359]  ksys_mount+0x83/0xd0\n[  819.397365]  __x64_sys_mount+0x67/0x80\n[  819.397388]  do_syscall_64+0x78/0x170\n[  819.397403]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  819.397422] RIP: 0033:0x7f54c667cb9a\n[  819.397424] Code: 48 8b 0d 01 c3 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d ce c2 2b 00 f7 d8 64 89 01 48\n[  819.397483] RSP: 002b:00007ffd8f46cd08 EFLAGS: 00000202 ORIG_RAX: 00000000000000a5\n[  819.397496] RAX: ffffffffffffffda RBX: 0000000000dfa030 RCX: 00007f54c667cb9a\n[  819.397498] RDX: 0000000000dfa210 RSI: 0000000000dfbf30 RDI: 0000000000e02ec0\n[  819.397501] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000013\n[  819.397503] R10: 00000000c0ed0000 R11: 0000000000000202 R12: 0000000000e02ec0\n[  819.397505] R13: 0000000000dfa210 R14: 0000000000000000 R15: 0000000000000003\n\n[  819.397866] Allocated by task 139:\n[  819.398702]  save_stack+0x46/0xd0\n[  819.398705]  kasan_kmalloc+0xad/0xe0\n[  819.398709]  kasan_slab_alloc+0x11/0x20\n[  819.398713]  kmem_cache_alloc+0xd1/0x1e0\n[  819.398717]  dup_fd+0x50/0x4c0\n[  819.398740]  copy_process.part.37+0xbed/0x32e0\n[  819.398744]  _do_fork+0x16e/0x590\n[  819.398748]  __x64_sys_clone+0x69/0x80\n[  819.398752]  do_syscall_64+0x78/0x170\n[  819.398756]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[  819.399097] Freed by task 159:\n[  819.399743]  save_stack+0x46/0xd0\n[  819.399747]  __kasan_slab_free+0x13c/0x1a0\n[  819.399750]  kasan_slab_free+0xe/0x10\n[  819.399754]  kmem_cache_free+0x89/0x1e0\n[  819.399757]  put_files_struct+0x132/0x150\n[  819.399761]  exit_files+0x62/0x70\n[  819.399766]  do_exit+0x47b/0x1390\n[  819.399770]  do_group_exit+0x86/0x130\n[  819.399774]  __x64_sys_exit_group+0x2c/0x30\n[  819.399778]  do_syscall_64+0x78/0x170\n[  819.399782]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[  819.400115] The buggy address belongs to the object at ffff8801f099c680\n                which belongs to the cache files_cache of size 704\n[  819.403234] The buggy address is located 40 bytes to the right of\n                704-byte region [ffff8801f099c680, ffff8801f099c940)\n[  819.405689] The buggy address belongs to the page:\n[  819.406709] page:ffffea0007c26700 count:1 mapcount:0 mapping:ffff8801f69a3340 index:0xffff8801f099d380 compound_mapcount: 0\n[  819.408984] flags: 0x2ffff0000008100(slab|head)\n[  819.409932] raw: 02ffff0000008100 ffffea00077fb600 0000000200000002 ffff8801f69a3340\n[  819.411514] raw: ffff8801f099d380 0000000080130000 00000001ffffffff 0000000000000000\n[  819.413073] page dumped because: kasan: bad access detected\n\n[  819.414539] Memory state around the buggy address:\n[  819.415521]  ffff8801f099c800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[  819.416981]  ffff8801f099c880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[  819.418454] >ffff8801f099c900: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc\n[  819.419921]                                                           ^\n[  819.421265]  ffff8801f099c980: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n[  819.422745]  ffff8801f099ca00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[  819.424206] ==================================================================\n[  819.425668] Disabling lock debugging due to kernel taint\n[  819.457463] F2FS-fs (loop0): Mounted with checkpoint version = 3\n\nThe kernel still mounts the image. If you run the following program on the mounted folder mnt,\n\n(poc.c)\n\nstatic void activity(char *mpoint) {\n\n  char *foo_bar_baz;\n  int err;\n\n  static int buf[8192];\n  memset(buf, 0, sizeof(buf));\n\n  err = asprintf(&foo_bar_baz, \"%s/foo/bar/baz\", mpoint);\n    int fd = open(foo_bar_baz, O_RDONLY, 0);\n  if (fd >= 0) {\n      read(fd, (char *)buf, 11);\n      close(fd);\n  }\n}\n\nint main(int argc, char *argv[]) {\n  activity(argv[1]);\n  return 0;\n}\n\nYou can get kernel crash:\n[  819.457463] F2FS-fs (loop0): Mounted with checkpoint version = 3\n[  918.028501] BUG: unable to handle kernel paging request at ffffed0048000d82\n[  918.044020] PGD 23ffee067 P4D 23ffee067 PUD 23fbef067 PMD 0\n[  918.045207] Oops: 0000 [#1] SMP KASAN PTI\n[  918.046048] CPU: 0 PID: 1309 Comm: poc Tainted: G    B             4.18.0-rc1+ #4\n[  918.047573] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  918.049552] RIP: 0010:check_memory_region+0x5e/0x190\n[  918.050565] Code: f8 49 c1 e8 03 49 89 db 49 c1 eb 03 4d 01 cb 4d 01 c1 4d 8d 63 01 4c 89 c8 4d 89 e2 4d 29 ca 49 83 fa 10 7f 3d 4d 85 d2 74 32 <41> 80 39 00 75 23 48 b8 01 00 00 00 00 fc ff df 4d 01 d1 49 01 c0\n[  918.054322] RSP: 0018:ffff8801e3a1f258 EFLAGS: 00010202\n[  918.055400] RAX: ffffed0048000d82 RBX: ffff880240006c11 RCX: ffffffffb8867d14\n[  918.056832] RDX: 0000000000000000 RSI: 0000000000000002 RDI: ffff880240006c10\n[  918.058253] RBP: ffff8801e3a1f268 R08: 1ffff10048000d82 R09: ffffed0048000d82\n[  918.059717] R10: 0000000000000001 R11: ffffed0048000d82 R12: ffffed0048000d83\n[  918.061159] R13: ffff8801e3a1f390 R14: 0000000000000000 R15: ffff880240006c08\n[  918.062614] FS:  00007fac9732c700(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  918.064246] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  918.065412] CR2: ffffed0048000d82 CR3: 00000001df77a000 CR4: 00000000000006f0\n[  918.066882] Call Trace:\n[  918.067410]  __asan_loadN+0xf/0x20\n[  918.068149]  f2fs_find_target_dentry+0xf4/0x270\n[  918.069083]  ? __get_node_page+0x331/0x5b0\n[  918.069925]  f2fs_find_in_inline_dir+0x24b/0x310\n[  918.070881]  ? f2fs_recover_inline_data+0x4c0/0x4c0\n[  918.071905]  ? unwind_next_frame.part.5+0x34f/0x490\n[  918.072901]  ? unwind_dump+0x290/0x290\n[  918.073695]  ? is_bpf_text_address+0xe/0x20\n[  918.074566]  __f2fs_find_entry+0x599/0x670\n[  918.075408]  ? kasan_unpoison_shadow+0x36/0x50\n[  918.076315]  ? kasan_kmalloc+0xad/0xe0\n[  918.077100]  ? memcg_kmem_put_cache+0x55/0xa0\n[  918.077998]  ? f2fs_find_target_dentry+0x270/0x270\n[  918.079006]  ? d_set_d_op+0x30/0x100\n[  918.079749]  ? __d_lookup_rcu+0x69/0x2e0\n[  918.080556]  ? __d_alloc+0x275/0x450\n[  918.081297]  ? kasan_check_write+0x14/0x20\n[  918.082135]  ? memset+0x31/0x40\n[  918.082820]  ? fscrypt_setup_filename+0x1ec/0x4c0\n[  918.083782]  ? d_alloc_parallel+0x5bb/0x8c0\n[  918.084640]  f2fs_find_entry+0xe9/0x110\n[  918.085432]  ? __f2fs_find_entry+0x670/0x670\n[  918.086308]  ? kasan_check_write+0x14/0x20\n[  918.087163]  f2fs_lookup+0x297/0x590\n[  918.087902]  ? f2fs_link+0x2b0/0x2b0\n[  918.088646]  ? legitimize_path.isra.29+0x61/0xa0\n[  918.089589]  __lookup_slow+0x12e/0x240\n[  918.090371]  ? may_delete+0x2b0/0x2b0\n[  918.091123]  ? __nd_alloc_stack+0xa0/0xa0\n[  918.091944]  lookup_slow+0x44/0x60\n[  918.092642]  walk_component+0x3ee/0xa40\n[  918.093428]  ? is_bpf_text_address+0xe/0x20\n[  918.094283]  ? pick_link+0x3e0/0x3e0\n[  918.095047]  ? in_group_p+0xa5/0xe0\n[  918.095771]  ? generic_permission+0x53/0x1e0\n[  918.096666]  ? security_inode_permission+0x1d/0x70\n[  918.097646]  ? inode_permission+0x7a/0x1f0\n[  918.098497]  link_path_walk+0x2a2/0x7b0\n[  918.099298]  ? apparmor_capget+0x3d0/0x3d0\n[  918.100140]  ? walk_component+0xa40/0xa40\n[  918.100958]  ? path_init+0x2e6/0x580\n[  918.101695]  path_openat+0x1bb/0x2160\n[  918.102471]  ? __save_stack_trace+0x92/0x100\n[  918.103352]  ? save_stack+0xb5/0xd0\n[  918.104070]  ? vfs_unlink+0x250/0x250\n[  918.104822]  ? save_stack+0x46/0xd0\n[  918.105538]  ? kasan_slab_alloc+0x11/0x20\n[  918.106370]  ? kmem_cache_alloc+0xd1/0x1e0\n[  918.107213]  ? getname_flags+0x76/0x2c0\n[  918.107997]  ? getname+0x12/0x20\n[  918.108677]  ? do_sys_open+0x14b/0x2c0\n[  918.109450]  ? __x64_sys_open+0x4c/0x60\n[  918.110255]  ? do_syscall_64+0x78/0x170\n[  918.111083]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  918.112148]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  918.113204]  ? f2fs_empty_inline_dir+0x1e0/0x1e0\n[  918.114150]  ? timespec64_trunc+0x5c/0x90\n[  918.114993]  ? wb_io_lists_depopulated+0x1a/0xc0\n[  918.115937]  ? inode_io_list_move_locked+0x102/0x110\n[  918.116949]  do_filp_open+0x12b/0x1d0\n[  918.117709]  ? may_open_dev+0x50/0x50\n[  918.118475]  ? kasan_kmalloc+0xad/0xe0\n[  918.119246]  do_sys_open+0x17c/0x2c0\n[  918.119983]  ? do_sys_open+0x17c/0x2c0\n[  918.120751]  ? filp_open+0x60/0x60\n[  918.121463]  ? task_work_run+0x4d/0xf0\n[  918.122237]  __x64_sys_open+0x4c/0x60\n[  918.123001]  do_syscall_64+0x78/0x170\n[  918.123759]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  918.124802] RIP: 0033:0x7fac96e3e040\n[  918.125537] Code: 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 83 3d 09 27 2d 00 00 75 10 b8 02 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 7e e0 01 00 48 89 04 24\n[  918.129341] RSP: 002b:00007fff1b37f848 EFLAGS: 00000246 ORIG_RAX: 0000000000000002\n[  918.130870] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fac96e3e040\n[  918.132295] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 000000000122d080\n[  918.133748] RBP: 00007fff1b37f9b0 R08: 00007fac9710bbd8 R09: 0000000000000001\n[  918.135209] R10: 000000000000069d R11: 0000000000000246 R12: 0000000000400c20\n[  918.136650] R13: 00007fff1b37fab0 R14: 0000000000000000 R15: 0000000000000000\n[  918.138093] Modules linked in: snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mac_hid i2c_piix4 soundcore ib_iser rdma_cm iw_cm ib_cm ib_core iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx raid1 raid0 multipath linear 8139too crct10dif_pclmul crc32_pclmul qxl drm_kms_helper syscopyarea aesni_intel sysfillrect sysimgblt fb_sys_fops ttm drm aes_x86_64 crypto_simd cryptd 8139cp glue_helper mii pata_acpi floppy\n[  918.147924] CR2: ffffed0048000d82\n[  918.148619] ---[ end trace 4ce02f25ff7d3df5 ]---\n[  918.149563] RIP: 0010:check_memory_region+0x5e/0x190\n[  918.150576] Code: f8 49 c1 e8 03 49 89 db 49 c1 eb 03 4d 01 cb 4d 01 c1 4d 8d 63 01 4c 89 c8 4d 89 e2 4d 29 ca 49 83 fa 10 7f 3d 4d 85 d2 74 32 <41> 80 39 00 75 23 48 b8 01 00 00 00 00 fc ff df 4d 01 d1 49 01 c0\n[  918.154360] RSP: 0018:ffff8801e3a1f258 EFLAGS: 00010202\n[  918.155411] RAX: ffffed0048000d82 RBX: ffff880240006c11 RCX: ffffffffb8867d14\n[  918.156833] RDX: 0000000000000000 RSI: 0000000000000002 RDI: ffff880240006c10\n[  918.158257] RBP: ffff8801e3a1f268 R08: 1ffff10048000d82 R09: ffffed0048000d82\n[  918.159722] R10: 0000000000000001 R11: ffffed0048000d82 R12: ffffed0048000d83\n[  918.161149] R13: ffff8801e3a1f390 R14: 0000000000000000 R15: ffff880240006c08\n[  918.162587] FS:  00007fac9732c700(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  918.164203] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  918.165356] CR2: ffffed0048000d82 CR3: 00000001df77a000 CR4: 00000000000006f0\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/inode.c||fs/f2fs/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/inode.c||fs/f2fs/inode.c": [
          "File: fs/f2fs/inode.c -> fs/f2fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:    __func__, inode->i_ino);",
          "206:   return false;",
          "207:  }",
          "208:  return true;",
          "209: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209:  if (f2fs_has_extra_attr(inode) &&",
          "210:    !f2fs_sb_has_extra_attr(sbi->sb)) {",
          "211:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "212:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "213:    \"%s: inode (ino=%lx) is with extra_attr, \"",
          "214:    \"but extra_attr feature is off\",",
          "215:    __func__, inode->i_ino);",
          "216:   return false;",
          "217:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "258:  get_inline_info(inode, ri);",
          "260:  fi->i_extra_isize = f2fs_has_extra_attr(inode) ?",
          "261:      le16_to_cpu(ri->i_extra_isize) : 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:  if (!sanity_check_inode(inode)) {",
          "271:   f2fs_put_page(node_page, 1);",
          "272:   return -EINVAL;",
          "273:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "338:  ret = do_read_inode(inode);",
          "339:  if (ret)",
          "340:   goto bad_inode;",
          "345: make_now:",
          "346:  if (ino == F2FS_NODE_INO(sbi)) {",
          "347:   inode->i_mapping->a_ops = &f2fs_node_aops;",
          "",
          "[Removed Lines]",
          "341:  if (!sanity_check_inode(inode)) {",
          "342:   ret = -EINVAL;",
          "343:   goto bad_inode;",
          "344:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "52dda80d62dff39979fb407d67b7c9fc02381589",
      "candidate_info": {
        "commit_hash": "52dda80d62dff39979fb407d67b7c9fc02381589",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/52dda80d62dff39979fb407d67b7c9fc02381589",
        "files": [
          "drivers/gpu/drm/i915/intel_guc.c"
        ],
        "message": "drm/i915: Protect guc_fini_wq() against module load abort\n\nPrevent\n[  397.873143] general protection fault: 0000 [#1] PREEMPT SMP PTI\n[  397.873154] CPU: 4 PID: 4799 Comm: drv_module_relo Tainted: G     U            4.18.0-rc6-CI-CI_DRM_4534+ #1\n[  397.873162] Hardware name: Micro-Star International Co., Ltd. MS-7B54/Z370M MORTAR (MS-7B54), BIOS 1.10 12/28/2017\n[  397.873175] RIP: 0010:__lock_acquire+0xf6/0x1b50\n[  397.873179] Code: 85 c0 4c 8b 9d 40 ff ff ff 8b 8d 38 ff ff ff 44 8b 8d 30 ff ff ff 4c 8b 85 28 ff ff ff 44 8b 95 24 ff ff ff 0f 84 54 03 00 00 <f0> ff 80 38 01 00 00 8b 15 45 8c 59 02 45 8b bc 24 70 08 00 00 85\n[  397.873240] RSP: 0018:ffffc90000497b40 EFLAGS: 00010002\n[  397.873246] RAX: 6b6b6b6b6b6b6b6b RBX: 0000000000000001 RCX: 0000000000000000\n[  397.873252] RDX: 0000000000000046 RSI: 0000000000000000 RDI: 0000000000000000\n[  397.873258] RBP: ffffc90000497c20 R08: ffffffff810a25e9 R09: 0000000000000000\n[  397.873264] R10: 0000000000000000 R11: ffff880255c63c28 R12: ffff8801093b2840\n[  397.873270] R13: 0000000000000001 R14: 0000000000000001 R15: 0000000000000246\n[  397.873277] FS:  00007faf88d71980(0000) GS:ffff880266300000(0000) knlGS:0000000000000000\n[  397.873284] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  397.873289] CR2: 000055d866c9ca10 CR3: 000000025472e006 CR4: 00000000003606e0\n[  397.873295] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  397.873301] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  397.873308] Call Trace:\n[  397.873318]  ? lock_acquire+0xa6/0x210\n[  397.873323]  lock_acquire+0xa6/0x210\n[  397.873331]  ? drain_workqueue+0x19/0x180\n[  397.873339]  __mutex_lock+0x89/0x980\n[  397.873346]  ? drain_workqueue+0x19/0x180\n[  397.873352]  ? _raw_spin_unlock_irqrestore+0x4c/0x60\n[  397.873359]  ? trace_hardirqs_on_caller+0xe0/0x1b0\n[  397.873365]  ? drain_workqueue+0x19/0x180\n[  397.873373]  ? debug_object_active_state+0x127/0x150\n[  397.873381]  ? drain_workqueue+0x19/0x180\n[  397.873387]  drain_workqueue+0x19/0x180\n[  397.873395]  destroy_workqueue+0x12/0x1f0\n[  397.873476]  intel_guc_fini_misc+0x36/0x90 [i915]\n[  397.873540]  i915_gem_fini+0x91/0x100 [i915]\n[  397.873588]  i915_driver_unload+0xd2/0x110 [i915]\n[  397.873638]  i915_pci_remove+0x19/0x30 [i915]\n[  397.873646]  pci_device_remove+0x36/0xb0\n[  397.873653]  device_release_driver_internal+0x185/0x250\n[  397.873660]  driver_detach+0x35/0x70\n[  397.873668]  bus_remove_driver+0x53/0xd0\n[  397.873675]  pci_unregister_driver+0x25/0xa0\n[  397.873683]  __se_sys_delete_module+0x162/0x210\n[  397.873691]  ? do_syscall_64+0xd/0x190\n[  397.873697]  do_syscall_64+0x55/0x190\n[  397.873704]  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  397.873710] RIP: 0033:0x7faf884231b7\n[  397.873714] Code: 73 01 c3 48 8b 0d d1 8c 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 b8 b0 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a1 8c 2c 00 f7 d8 64 89 01 48\n[  397.873775] RSP: 002b:00007ffda4e98cf8 EFLAGS: 00000206 ORIG_RAX: 00000000000000b0\n[  397.873784] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007faf884231b7\n[  397.873790] RDX: 0000000000000000 RSI: 0000000000000800 RDI: 000055fbb18f1bd8\n[  397.873796] RBP: 000055fbb18f1b70 R08: 000055fbb18f1bdc R09: 00007ffda4e98d38\n[  397.873802] R10: 00007ffda4e97cf4 R11: 0000000000000206 R12: 000055fbb0d32470\n[  397.873808] R13: 00007ffda4e992e0 R14: 0000000000000000 R15: 0000000000000000\n\nv2: It's use-after-free; not a NULL pointer.\n\nTestcase: igt/drv_module_reload/basic-reload-inject\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Micha\u0142 Winiarski <michal.winiarski@intel.com>\nCc: Michal Wajdeczko <michal.wajdeczko@intel.com>\nReviewed-by: Micha\u0142 Winiarski <michal.winiarski@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20180726085033.4044-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/intel_guc.c||drivers/gpu/drm/i915/intel_guc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/intel_guc.c||drivers/gpu/drm/i915/intel_guc.c": [
          "File: drivers/gpu/drm/i915/intel_guc.c -> drivers/gpu/drm/i915/intel_guc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "129: static void guc_fini_wq(struct intel_guc *guc)",
          "130: {",
          "138: }",
          "140: int intel_guc_init_misc(struct intel_guc *guc)",
          "",
          "[Removed Lines]",
          "131:  struct drm_i915_private *dev_priv = guc_to_i915(guc);",
          "133:  if (HAS_LOGICAL_RING_PREEMPTION(dev_priv) &&",
          "134:      USES_GUC_SUBMISSION(dev_priv))",
          "135:   destroy_workqueue(guc->preempt_wq);",
          "137:  destroy_workqueue(guc->log.relay.flush_wq);",
          "",
          "[Added Lines]",
          "131:  struct workqueue_struct *wq;",
          "133:  wq = fetch_and_zero(&guc->preempt_wq);",
          "134:  if (wq)",
          "135:   destroy_workqueue(wq);",
          "137:  wq = fetch_and_zero(&guc->log.relay.flush_wq);",
          "138:  if (wq)",
          "139:   destroy_workqueue(wq);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c77ec61ca0a49544ca81881cc5d5529858f7e196",
      "candidate_info": {
        "commit_hash": "c77ec61ca0a49544ca81881cc5d5529858f7e196",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c77ec61ca0a49544ca81881cc5d5529858f7e196",
        "files": [
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: fix to do sanity check with {sit,nat}_ver_bitmap_bytesize\n\nThis patch adds to do sanity check with {sit,nat}_ver_bitmap_bytesize\nduring mount, in order to avoid accessing across cache boundary with\nthis abnormal bitmap size.\n\n- Overview\nbuffer overrun in build_sit_info() when mounting a crafted f2fs image\n\n- Reproduce\n\n- Kernel message\n[  548.580867] F2FS-fs (loop0): Invalid log blocks per segment (8201)\n\n[  548.580877] F2FS-fs (loop0): Can't find valid F2FS filesystem in 1th superblock\n[  548.584979] ==================================================================\n[  548.586568] BUG: KASAN: use-after-free in kmemdup+0x36/0x50\n[  548.587715] Read of size 64 at addr ffff8801e9c265ff by task mount/1295\n\n[  548.589428] CPU: 1 PID: 1295 Comm: mount Not tainted 4.18.0-rc1+ #4\n[  548.589432] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  548.589438] Call Trace:\n[  548.589474]  dump_stack+0x7b/0xb5\n[  548.589487]  print_address_description+0x70/0x290\n[  548.589492]  kasan_report+0x291/0x390\n[  548.589496]  ? kmemdup+0x36/0x50\n[  548.589509]  check_memory_region+0x139/0x190\n[  548.589514]  memcpy+0x23/0x50\n[  548.589518]  kmemdup+0x36/0x50\n[  548.589545]  f2fs_build_segment_manager+0x8fa/0x3410\n[  548.589551]  ? __asan_loadN+0xf/0x20\n[  548.589560]  ? f2fs_sanity_check_ckpt+0x1be/0x240\n[  548.589566]  ? f2fs_flush_sit_entries+0x10c0/0x10c0\n[  548.589587]  ? __put_user_ns+0x40/0x40\n[  548.589604]  ? find_next_bit+0x57/0x90\n[  548.589610]  f2fs_fill_super+0x194b/0x2b40\n[  548.589617]  ? f2fs_commit_super+0x1b0/0x1b0\n[  548.589637]  ? set_blocksize+0x90/0x140\n[  548.589651]  mount_bdev+0x1c5/0x210\n[  548.589655]  ? f2fs_commit_super+0x1b0/0x1b0\n[  548.589667]  f2fs_mount+0x15/0x20\n[  548.589672]  mount_fs+0x60/0x1a0\n[  548.589683]  ? alloc_vfsmnt+0x309/0x360\n[  548.589688]  vfs_kern_mount+0x6b/0x1a0\n[  548.589699]  do_mount+0x34a/0x18c0\n[  548.589710]  ? lockref_put_or_lock+0xcf/0x160\n[  548.589716]  ? copy_mount_string+0x20/0x20\n[  548.589728]  ? memcg_kmem_put_cache+0x1b/0xa0\n[  548.589734]  ? kasan_check_write+0x14/0x20\n[  548.589740]  ? _copy_from_user+0x6a/0x90\n[  548.589744]  ? memdup_user+0x42/0x60\n[  548.589750]  ksys_mount+0x83/0xd0\n[  548.589755]  __x64_sys_mount+0x67/0x80\n[  548.589781]  do_syscall_64+0x78/0x170\n[  548.589797]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  548.589820] RIP: 0033:0x7f76fc331b9a\n[  548.589821] Code: 48 8b 0d 01 c3 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d ce c2 2b 00 f7 d8 64 89 01 48\n[  548.589880] RSP: 002b:00007ffd4f0a0e48 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5\n[  548.589890] RAX: ffffffffffffffda RBX: 000000000146c030 RCX: 00007f76fc331b9a\n[  548.589892] RDX: 000000000146c210 RSI: 000000000146df30 RDI: 0000000001474ec0\n[  548.589895] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000013\n[  548.589897] R10: 00000000c0ed0000 R11: 0000000000000206 R12: 0000000001474ec0\n[  548.589900] R13: 000000000146c210 R14: 0000000000000000 R15: 0000000000000003\n\n[  548.590242] The buggy address belongs to the page:\n[  548.591243] page:ffffea0007a70980 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  548.592886] flags: 0x2ffff0000000000()\n[  548.593665] raw: 02ffff0000000000 dead000000000100 dead000000000200 0000000000000000\n[  548.595258] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\n[  548.603713] page dumped because: kasan: bad access detected\n\n[  548.605203] Memory state around the buggy address:\n[  548.606198]  ffff8801e9c26480: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  548.607676]  ffff8801e9c26500: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  548.609157] >ffff8801e9c26580: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  548.610629]                                                                 ^\n[  548.612088]  ffff8801e9c26600: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  548.613674]  ffff8801e9c26680: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  548.615141] ==================================================================\n[  548.616613] Disabling lock debugging due to kernel taint\n[  548.622871] WARNING: CPU: 1 PID: 1295 at mm/page_alloc.c:4065 __alloc_pages_slowpath+0xe4a/0x1420\n[  548.622878] Modules linked in: snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mac_hid i2c_piix4 soundcore ib_iser rdma_cm iw_cm ib_cm ib_core iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx raid1 raid0 multipath linear 8139too crct10dif_pclmul crc32_pclmul qxl drm_kms_helper syscopyarea aesni_intel sysfillrect sysimgblt fb_sys_fops ttm drm aes_x86_64 crypto_simd cryptd 8139cp glue_helper mii pata_acpi floppy\n[  548.623217] CPU: 1 PID: 1295 Comm: mount Tainted: G    B             4.18.0-rc1+ #4\n[  548.623219] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  548.623226] RIP: 0010:__alloc_pages_slowpath+0xe4a/0x1420\n[  548.623227] Code: ff ff 01 89 85 c8 fe ff ff e9 91 fc ff ff 41 89 c5 e9 5c fc ff ff 0f 0b 89 f8 25 ff ff f7 ff 89 85 8c fe ff ff e9 d5 f2 ff ff <0f> 0b e9 65 f2 ff ff 65 8b 05 38 81 d2 47 f6 c4 01 74 1c 65 48 8b\n[  548.623281] RSP: 0018:ffff8801f28c7678 EFLAGS: 00010246\n[  548.623284] RAX: 0000000000000000 RBX: 00000000006040c0 RCX: ffffffffb82f73b7\n[  548.623287] RDX: 1ffff1003e518eeb RSI: 000000000000000c RDI: 0000000000000000\n[  548.623290] RBP: ffff8801f28c7880 R08: 0000000000000000 R09: ffffed0047fff2c5\n[  548.623292] R10: 0000000000000001 R11: ffffed0047fff2c4 R12: ffff8801e88de040\n[  548.623295] R13: 00000000006040c0 R14: 000000000000000c R15: ffff8801f28c7938\n[  548.623299] FS:  00007f76fca51840(0000) GS:ffff8801f6f00000(0000) knlGS:0000000000000000\n[  548.623302] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  548.623304] CR2: 00007f19b9171760 CR3: 00000001ed952000 CR4: 00000000000006e0\n[  548.623317] Call Trace:\n[  548.623325]  ? kasan_check_read+0x11/0x20\n[  548.623330]  ? __zone_watermark_ok+0x92/0x240\n[  548.623336]  ? get_page_from_freelist+0x1c3/0x1d90\n[  548.623347]  ? _raw_spin_lock_irqsave+0x2a/0x60\n[  548.623353]  ? warn_alloc+0x250/0x250\n[  548.623358]  ? save_stack+0x46/0xd0\n[  548.623361]  ? kasan_kmalloc+0xad/0xe0\n[  548.623366]  ? __isolate_free_page+0x2a0/0x2a0\n[  548.623370]  ? mount_fs+0x60/0x1a0\n[  548.623374]  ? vfs_kern_mount+0x6b/0x1a0\n[  548.623378]  ? do_mount+0x34a/0x18c0\n[  548.623383]  ? ksys_mount+0x83/0xd0\n[  548.623387]  ? __x64_sys_mount+0x67/0x80\n[  548.623391]  ? do_syscall_64+0x78/0x170\n[  548.623396]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  548.623401]  __alloc_pages_nodemask+0x3c5/0x400\n[  548.623407]  ? __alloc_pages_slowpath+0x1420/0x1420\n[  548.623412]  ? __mutex_lock_slowpath+0x20/0x20\n[  548.623417]  ? kvmalloc_node+0x31/0x80\n[  548.623424]  alloc_pages_current+0x75/0x110\n[  548.623436]  kmalloc_order+0x24/0x60\n[  548.623442]  kmalloc_order_trace+0x24/0xb0\n[  548.623448]  __kmalloc_track_caller+0x207/0x220\n[  548.623455]  ? f2fs_build_node_manager+0x399/0xbb0\n[  548.623460]  kmemdup+0x20/0x50\n[  548.623465]  f2fs_build_node_manager+0x399/0xbb0\n[  548.623470]  f2fs_fill_super+0x195e/0x2b40\n[  548.623477]  ? f2fs_commit_super+0x1b0/0x1b0\n[  548.623481]  ? set_blocksize+0x90/0x140\n[  548.623486]  mount_bdev+0x1c5/0x210\n[  548.623489]  ? f2fs_commit_super+0x1b0/0x1b0\n[  548.623495]  f2fs_mount+0x15/0x20\n[  548.623498]  mount_fs+0x60/0x1a0\n[  548.623503]  ? alloc_vfsmnt+0x309/0x360\n[  548.623508]  vfs_kern_mount+0x6b/0x1a0\n[  548.623513]  do_mount+0x34a/0x18c0\n[  548.623518]  ? lockref_put_or_lock+0xcf/0x160\n[  548.623523]  ? copy_mount_string+0x20/0x20\n[  548.623528]  ? memcg_kmem_put_cache+0x1b/0xa0\n[  548.623533]  ? kasan_check_write+0x14/0x20\n[  548.623537]  ? _copy_from_user+0x6a/0x90\n[  548.623542]  ? memdup_user+0x42/0x60\n[  548.623547]  ksys_mount+0x83/0xd0\n[  548.623552]  __x64_sys_mount+0x67/0x80\n[  548.623557]  do_syscall_64+0x78/0x170\n[  548.623562]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  548.623566] RIP: 0033:0x7f76fc331b9a\n[  548.623567] Code: 48 8b 0d 01 c3 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d ce c2 2b 00 f7 d8 64 89 01 48\n[  548.623632] RSP: 002b:00007ffd4f0a0e48 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5\n[  548.623636] RAX: ffffffffffffffda RBX: 000000000146c030 RCX: 00007f76fc331b9a\n[  548.623639] RDX: 000000000146c210 RSI: 000000000146df30 RDI: 0000000001474ec0\n[  548.623641] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000013\n[  548.623643] R10: 00000000c0ed0000 R11: 0000000000000206 R12: 0000000001474ec0\n[  548.623646] R13: 000000000146c210 R14: 0000000000000000 R15: 0000000000000003\n[  548.623650] ---[ end trace 4ce02f25ff7d3df5 ]---\n[  548.623656] F2FS-fs (loop0): Failed to initialize F2FS node manager\n[  548.627936] F2FS-fs (loop0): Invalid log blocks per segment (8201)\n\n[  548.627940] F2FS-fs (loop0): Can't find valid F2FS filesystem in 1th superblock\n[  548.635835] F2FS-fs (loop0): Failed to initialize F2FS node manager\n\n- Location\nhttps://elixir.bootlin.com/linux/v4.18-rc1/source/fs/f2fs/segment.c#L3578\n\n\tsit_i->sit_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);\n\nBuffer overrun happens when doing memcpy. I suspect there is missing (inconsistent) checks on bitmap_size.\n\nReported by Wen Xu (wen.xu@gatech.edu) from SSLab, Gatech.\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2280:  struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);",
          "2281:  unsigned int ovp_segments, reserved_segments;",
          "2282:  unsigned int main_segs, blocks_per_seg;",
          "2283:  int i;",
          "2285:  total = le32_to_cpu(raw_super->segment_count);",
          "2286:  fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);",
          "2289:  fsmeta += le32_to_cpu(ckpt->rsvd_segment_count);",
          "2290:  fsmeta += le32_to_cpu(raw_super->segment_count_ssa);",
          "",
          "[Removed Lines]",
          "2287:  fsmeta += le32_to_cpu(raw_super->segment_count_sit);",
          "2288:  fsmeta += le32_to_cpu(raw_super->segment_count_nat);",
          "",
          "[Added Lines]",
          "2283:  unsigned int sit_segs, nat_segs;",
          "2284:  unsigned int sit_bitmap_size, nat_bitmap_size;",
          "2285:  unsigned int log_blocks_per_seg;",
          "2290:  sit_segs = le32_to_cpu(raw_super->segment_count_sit);",
          "2291:  fsmeta += sit_segs;",
          "2292:  nat_segs = le32_to_cpu(raw_super->segment_count_nat);",
          "2293:  fsmeta += nat_segs;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2316:    return 1;",
          "2317:  }",
          "2319:  if (unlikely(f2fs_cp_error(sbi))) {",
          "2320:   f2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");",
          "2321:   return 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2324:  sit_bitmap_size = le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);",
          "2325:  nat_bitmap_size = le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);",
          "2326:  log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);",
          "2328:  if (sit_bitmap_size != ((sit_segs / 2) << log_blocks_per_seg) / 8 ||",
          "2329:   nat_bitmap_size != ((nat_segs / 2) << log_blocks_per_seg) / 8) {",
          "2330:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2331:    \"Wrong bitmap size: sit: %u, nat:%u\",",
          "2332:    sit_bitmap_size, nat_bitmap_size);",
          "2333:   return 1;",
          "2334:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20cdcaf903298d54b834daedf65a2ddef70cae0a",
      "candidate_info": {
        "commit_hash": "20cdcaf903298d54b834daedf65a2ddef70cae0a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/20cdcaf903298d54b834daedf65a2ddef70cae0a",
        "files": [
          "drivers/media/usb/em28xx/em28xx-cards.c"
        ],
        "message": "media: em28xx: Fix DualHD disconnect oops\n\nDuring the duplication of em28xx state for the second tuner pair\na pointer to alt_max_pkt_size_isoc is copied. During tear down\nthe second tuner is destroyed first and kfrees alt_max_pkt_size_isoc,\nthen the first tuner is destroyed and kfrees it again. The property\nshould only be kfree'd if the tuner is PRIMARY_TS.\n\n[  354.888560] ------------[ cut here ]------------\n[  354.888562] kernel BUG at mm/slub.c:296!\n[  354.888574] invalid opcode: 0000 [#1] SMP NOPTI\n[  354.888869] CPU: 1 PID: 19 Comm: kworker/1:0 Not tainted 4.18.0-rc1+ #20\n[  354.889140] Hardware name: MSI MS-7A39/B350M GAMING PRO (MS-7A39), BIOS 2.G0 04/27/2018\n[  354.889408] Workqueue: usb_hub_wq hub_event\n[  354.889679] RIP: 0010:__slab_free+0x217/0x370\n[  354.889942] Code: bb c0 e8 07 41 38 c7 72 39 48 83 c4 70 5b 41 5a 41 5c 41 5d 41 5e 41 5f 5d 49 8d 62 f8 c3 f3 90 49 8b 04 24 a8 01 75 f6 eb 82 <0f> 0b 44 89 45 80 48 89 4d 88 e8 aa fa ff ff 85 c0 74 cc e9 b7 fe\n[  354.890598] RSP: 0018:ffffb84c41a4fad0 EFLAGS: 00010246\n[  354.890934] RAX: ffff948646e85150 RBX: ffff948646e85150 RCX: ffff948646e85150\n[  354.891280] RDX: 00000000820001d9 RSI: fffffa8fd01ba140 RDI: ffff94865e807c00\n[  354.891649] RBP: ffffb84c41a4fb70 R08: 0000000000000001 R09: ffffffffc059ce21\n[  354.892025] R10: ffff948646e85150 R11: 0000000000000001 R12: fffffa8fd01ba140\n[  354.892403] R13: ffff948646e85150 R14: ffff94865e807c00 R15: ffff94864c92e0a0\n[  354.892780] FS:  0000000000000000(0000) GS:ffff94865ec40000(0000) knlGS:0000000000000000\n[  354.893150] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  354.893530] CR2: 00007f4e476da950 CR3: 000000040112c000 CR4: 00000000003406e0\n[  354.893917] Call Trace:\n[  354.894315]  ? __dev_printk+0x3c/0x80\n[  354.894695]  ? _dev_info+0x64/0x80\n[  354.895082]  ? em28xx_free_device+0x41/0x50 [em28xx]\n[  354.895464]  kfree+0x17a/0x190\n[  354.895852]  ? kfree+0x17a/0x190\n[  354.896310]  em28xx_free_device+0x41/0x50 [em28xx]\n[  354.896698]  em28xx_usb_disconnect+0xfa/0x110 [em28xx]\n[  354.897083]  usb_unbind_interface+0x7a/0x270\n[  354.897475]  device_release_driver_internal+0x17c/0x250\n[  354.897864]  device_release_driver+0x12/0x20\n[  354.898252]  bus_remove_device+0xec/0x160\n[  354.898639]  device_del+0x13d/0x320\n[  354.899018]  ? usb_remove_ep_devs+0x1f/0x30\n[  354.899392]  usb_disable_device+0x9e/0x270\n[  354.899772]  usb_disconnect+0x92/0x2a0\n[  354.900149]  hub_event+0x98e/0x1650\n[  354.900519]  ? sched_clock_cpu+0x11/0xa0\n[  354.900890]  process_one_work+0x167/0x3f0\n[  354.901251]  worker_thread+0x4d/0x460\n[  354.901610]  kthread+0x105/0x140\n[  354.901964]  ? rescuer_thread+0x360/0x360\n[  354.902318]  ? kthread_associate_blkcg+0xa0/0xa0\n[  354.902672]  ret_from_fork+0x22/0x40\n[  354.903024] Modules linked in: rc_hauppauge em28xx_rc rc_core si2157 lgdt3306a i2c_mux em28xx_dvb dvb_core videobuf2_vmalloc videobuf2_memops videobuf2_common snd_hda_codec_hdmi nls_iso8859_1 edac_mce_amd kvm crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcbc snd_hda_intel snd_hda_codec snd_hda_core snd_hwdep snd_pcm snd_seq_midi aesni_intel snd_seq_midi_event aes_x86_64 snd_rawmidi crypto_simd em28xx cryptd glue_helper asix tveeprom usbnet snd_seq v4l2_common mii videodev snd_seq_device media input_leds snd_timer joydev ccp k10temp wmi_bmof snd soundcore mac_hid sch_fq_codel parport_pc ppdev lp parport ip_tables x_tables vfio_pci vfio_virqfd irqbypass vfio_iommu_type1 vfio nouveau mxm_wmi video i2c_algo_bit ttm drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops i2c_piix4 drm ahci libahci\n[  354.905129]  wmi gpio_amdpt gpio_generic hid_generic usbhid hid\n[  354.908140] ---[ end trace c230d02716298c34 ]---\n[  354.908145] RIP: 0010:__slab_free+0x217/0x370\n[  354.908147] Code: bb c0 e8 07 41 38 c7 72 39 48 83 c4 70 5b 41 5a 41 5c 41 5d 41 5e 41 5f 5d 49 8d 62 f8 c3 f3 90 49 8b 04 24 a8 01 75 f6 eb 82 <0f> 0b 44 89 45 80 48 89 4d 88 e8 aa fa ff ff 85 c0 74 cc e9 b7 fe\n[  354.908183] RSP: 0018:ffffb84c41a4fad0 EFLAGS: 00010246\n[  354.908186] RAX: ffff948646e85150 RBX: ffff948646e85150 RCX: ffff948646e85150\n[  354.908189] RDX: 00000000820001d9 RSI: fffffa8fd01ba140 RDI: ffff94865e807c00\n[  354.908191] RBP: ffffb84c41a4fb70 R08: 0000000000000001 R09: ffffffffc059ce21\n[  354.908193] R10: ffff948646e85150 R11: 0000000000000001 R12: fffffa8fd01ba140\n[  354.908195] R13: ffff948646e85150 R14: ffff94865e807c00 R15: ffff94864c92e0a0\n[  354.908198] FS:  0000000000000000(0000) GS:ffff94865ec40000(0000) knlGS:0000000000000000\n[  354.908201] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  354.908203] CR2: 00007f4e476da950 CR3: 000000016b20a000 CR4: 00000000003406e0\n\nSigned-off-by: Brad Love <brad@nextdimension.cc>\nSigned-off-by: Michael Ira Krufky <mkrufky@gmail.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>",
        "before_after_code_files": [
          "drivers/mediusb/em28xx/em28xx-cards.c||drivers/media/usem28xx/em28xx-cards.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mediusb/em28xx/em28xx-cards.c||drivers/media/usem28xx/em28xx-cards.c": [
          "File: drivers/mediusb/em28xx/em28xx-cards.c -> drivers/media/usem28xx/em28xx-cards.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
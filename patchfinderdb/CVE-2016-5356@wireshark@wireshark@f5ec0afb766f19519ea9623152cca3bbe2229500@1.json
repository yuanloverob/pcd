{
  "cve_id": "CVE-2016-5356",
  "cve_desc": "wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.",
  "repo": "wireshark/wireshark",
  "patch_hash": "f5ec0afb766f19519ea9623152cca3bbe2229500",
  "patch_info": {
    "commit_hash": "f5ec0afb766f19519ea9623152cca3bbe2229500",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500",
    "files": [
      "wiretap/cosine.c"
    ],
    "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12395\nChange-Id: Ia70f33b71ff28451190fcf144c333fd1362646b2\nReviewed-on: https://code.wireshark.org/review/15172\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
    "before_after_code_files": [
      "wiretap/cosine.c||wiretap/cosine.c"
    ]
  },
  "patch_diff": {
    "wiretap/cosine.c||wiretap/cosine.c": [
      "File: wiretap/cosine.c -> wiretap/cosine.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "157: #define COSINE_HEADER_LINES_TO_CHECK 200",
      "158: #define COSINE_LINE_LENGTH  240",
      "162: static gboolean empty_line(const gchar *line);",
      "163: static gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,",
      "164:  char *hdr);",
      "",
      "[Removed Lines]",
      "160: #define COSINE_MAX_PACKET_LEN 65536",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "167:  gint64 *data_offset);",
      "168: static gboolean cosine_seek_read(wtap *wth, gint64 seek_off,",
      "169:  struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);",
      "174: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
      "175:  guint byte_offset);",
      "",
      "[Removed Lines]",
      "170: static int parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
      "171:  int *err, gchar **err_info);",
      "172: static gboolean parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr,",
      "173:  int pkt_len, Buffer* buf, int *err, gchar **err_info);",
      "",
      "[Added Lines]",
      "168: static int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
      "169:  char *line, int *err, gchar **err_info);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "287:     gint64 *data_offset)",
      "288: {",
      "289:  gint64 offset;",
      "291:  char line[COSINE_LINE_LENGTH];",
      "",
      "[Removed Lines]",
      "290:  int pkt_len;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "296:   return FALSE;",
      "307: }",
      "",
      "[Removed Lines]",
      "300:  pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);",
      "301:  if (pkt_len == -1)",
      "302:   return FALSE;",
      "305:  return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,",
      "306:      wth->frame_buffer, err, err_info);",
      "",
      "[Added Lines]",
      "295:  return parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,",
      "296:      line, err, err_info);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "311: cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,",
      "312:  Buffer *buf, int *err, gchar **err_info)",
      "313: {",
      "315:  char line[COSINE_LINE_LENGTH];",
      "317:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
      "",
      "[Removed Lines]",
      "314:  int pkt_len;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "325:   return FALSE;",
      "326:  }",
      "335:      err_info);",
      "336: }",
      "",
      "[Removed Lines]",
      "329:  pkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);",
      "330:  if (pkt_len == -1)",
      "331:   return FALSE;",
      "334:  return parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,",
      "",
      "[Added Lines]",
      "318:  return parse_cosine_packet(wth->random_fh, phdr, buf, line, err,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "340:         2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]",
      "341:     2) output to PE without date and time",
      "346: {",
      "347:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
      "348:  int num_items_scanned;",
      "350:  int pro, off, pri, rm, error;",
      "351:  guint code1, code2;",
      "352:  char if_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";",
      "353:  struct tm tm;",
      "355:  if (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",",
      "356:      &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {",
      "358:   num_items_scanned = sscanf(line,",
      "360:    &yy, &mm, &dd, &hr, &min, &sec, &csec,",
      "361:        direction, if_name, &pkt_len,",
      "362:        &pro, &off, &pri, &rm, &error,",
      "",
      "[Removed Lines]",
      "343: static int",
      "344: parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
      "345:      int *err, gchar **err_info)",
      "349:  int yy, mm, dd, hr, min, sec, csec, pkt_len;",
      "359:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
      "",
      "[Added Lines]",
      "327: static gboolean",
      "328: parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,",
      "329:     char *line, int *err, gchar **err_info)",
      "333:  int yy, mm, dd, hr, min, sec, csec;",
      "334:  guint pkt_len;",
      "339:  guint8 *pd;",
      "340:  int i, hex_lines, n, caplen = 0;",
      "346:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "365:   if (num_items_scanned != 17) {",
      "369:   }",
      "370:  } else {",
      "372:   num_items_scanned = sscanf(line,",
      "374:        direction, if_name, &pkt_len,",
      "375:        &pro, &off, &pri, &rm, &error,",
      "376:        &code1, &code2);",
      "",
      "[Removed Lines]",
      "368:    return -1;",
      "373:      \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
      "",
      "[Added Lines]",
      "355:    return FALSE;",
      "360:      \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "378:   if (num_items_scanned != 10) {",
      "382:   }",
      "383:   yy = mm = dd = hr = min = sec = csec = 0;",
      "384:  }",
      "386:  phdr->rec_type = REC_TYPE_PACKET;",
      "387:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
      "",
      "[Removed Lines]",
      "381:    return -1;",
      "",
      "[Added Lines]",
      "368:    return FALSE;",
      "372:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
      "379:       pkt_len, WTAP_MAX_PACKET_SIZE);",
      "380:   return FALSE;",
      "381:  }",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "430:  pseudo_header->cosine.rm = rm;",
      "431:  pseudo_header->cosine.err = error;",
      "448:  pd = ws_buffer_start_ptr(buf);",
      "",
      "[Removed Lines]",
      "433:  return pkt_len;",
      "434: }",
      "438: static gboolean",
      "439: parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,",
      "440:     Buffer* buf, int *err, gchar **err_info)",
      "441: {",
      "442:  guint8 *pd;",
      "443:  gchar line[COSINE_LINE_LENGTH];",
      "444:  int i, hex_lines, n, caplen = 0;",
      "447:  ws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);",
      "",
      "[Added Lines]",
      "431:  ws_buffer_assure_space(buf, pkt_len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7ffa6593529551cd38297a60bc9bc58bdd1d5837",
      "candidate_info": {
        "commit_hash": "7ffa6593529551cd38297a60bc9bc58bdd1d5837",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/7ffa6593529551cd38297a60bc9bc58bdd1d5837",
        "files": [
          "wiretap/netscreen.c",
          "wiretap/netscreen.h"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I78ff4e5a429db5d1cf678abd9ac4db4210c92d6b\nReviewed-on: https://code.wireshark.org/review/15178\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/netscreen.c||wiretap/netscreen.c",
          "wiretap/netscreen.h||wiretap/netscreen.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/netscreen.c||wiretap/netscreen.c": [
          "File: wiretap/netscreen.c -> wiretap/netscreen.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71: static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,",
          "72:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "73:  int *err, gchar **err_info);",
          "80: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
          "81:  guint byte_offset);",
          "",
          "[Removed Lines]",
          "74: static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "75:  char *cap_int, gboolean *cap_dir, char *cap_dst,",
          "76:  int *err, gchar **err_info);",
          "77: static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,",
          "78:  const char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,",
          "79:  Buffer* buf, int *err, gchar **err_info);",
          "",
          "[Added Lines]",
          "74: static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,",
          "75:  Buffer* buf, char *line, int *err, gchar **err_info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "193:     gint64 *data_offset)",
          "194: {",
          "195:  gint64  offset;",
          "197:  char  line[NETSCREEN_LINE_LENGTH];",
          "203:  offset = netscreen_seek_next_packet(wth, err, err_info, line);",
          "204:  if (offset < 0)",
          "205:   return FALSE;",
          "217:   return FALSE;",
          "",
          "[Removed Lines]",
          "196:  int  pkt_len;",
          "198:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "199:  gboolean cap_dir;",
          "200:  char  cap_dst[13];",
          "208:  pkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,",
          "209:      cap_dst, err, err_info);",
          "210:  if (pkt_len == -1)",
          "211:   return FALSE;",
          "215:  if (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,",
          "216:      cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))",
          "",
          "[Added Lines]",
          "200:  if (!parse_netscreen_packet(wth->fh, &wth->phdr,",
          "201:      wth->frame_buffer, line, err, err_info))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "241:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "242:  int *err, gchar **err_info)",
          "243: {",
          "245:  char  line[NETSCREEN_LINE_LENGTH];",
          "250:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {",
          "251:   return FALSE;",
          "",
          "[Removed Lines]",
          "244:  int  pkt_len;",
          "246:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "247:  gboolean cap_dir;",
          "248:  char  cap_dst[13];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "259:   return FALSE;",
          "260:  }",
          "271: }",
          "",
          "[Removed Lines]",
          "262:  pkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,",
          "263:      cap_dst, err, err_info);",
          "264:  if (pkt_len == -1)",
          "265:   return FALSE;",
          "267:  if (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,",
          "268:      cap_dst, phdr, buf, err, err_info))",
          "269:   return FALSE;",
          "270:  return TRUE;",
          "",
          "[Added Lines]",
          "243:  return parse_netscreen_packet(wth->random_fh, phdr, buf, line,",
          "244:      err, err_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "293: {",
          "299:  phdr->rec_type = REC_TYPE_PACKET;",
          "300:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "303:      &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {",
          "306:   return -1;",
          "307:  }",
          "311:  phdr->ts.secs  = sec;",
          "312:  phdr->ts.nsecs = dsec * 100000000;",
          "313:  phdr->len = pkt_len;",
          "333:  pd = buffer_start_ptr(buf);",
          "335:  while(1) {",
          "",
          "[Removed Lines]",
          "290: static int",
          "291: parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,",
          "292:     gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)",
          "294:  int sec;",
          "295:  int dsec, pkt_len;",
          "296:  char direction[2];",
          "297:  char cap_src[13];",
          "302:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",",
          "315:  return pkt_len;",
          "316: }",
          "320: static gboolean",
          "321: parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,",
          "322:     const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,",
          "323:     int *err, gchar **err_info)",
          "324: {",
          "325:  guint8 *pd;",
          "326:  gchar line[NETSCREEN_LINE_LENGTH];",
          "327:  gchar *p;",
          "328:  int n, i = 0, offset = 0;",
          "329:  gchar dststr[13];",
          "332:  buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "264: static gboolean",
          "265: parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "266:     char *line, int *err, gchar **err_info)",
          "268:  int  sec;",
          "269:  int  dsec;",
          "270:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "271:  char  direction[2];",
          "272:  guint  pkt_len;",
          "273:  char  cap_src[13];",
          "274:  char  cap_dst[13];",
          "275:  guint8  *pd;",
          "276:  gchar  *p;",
          "277:  int  n, i = 0;",
          "278:  guint  offset = 0;",
          "279:  gchar  dststr[13];",
          "284:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",",
          "290:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "297:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "298:   return FALSE;",
          "299:  }",
          "311:  buffer_assure_space(buf, pkt_len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "381:    return FALSE;",
          "",
          "[Removed Lines]",
          "378:   if(n == -1) {",
          "",
          "[Added Lines]",
          "357:   if (n == -1) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "393:                         return FALSE;",
          "",
          "[Removed Lines]",
          "390:   if(offset > pkt_len) {",
          "",
          "[Added Lines]",
          "369:   if (offset > pkt_len) {",
          "",
          "---------------"
        ],
        "wiretap/netscreen.h||wiretap/netscreen.h": [
          "File: wiretap/netscreen.h -> wiretap/netscreen.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #define NETSCREEN_INGRESS  FALSE",
          "47: #define NETSCREEN_EGRESS  TRUE",
          "52: int netscreen_open(wtap *wth, int *err, gchar **err_info);",
          "54: #endif",
          "",
          "[Removed Lines]",
          "50: #define NETSCREEN_MAX_PACKET_LEN 65536",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a098bbe2ec444405dc492d23a36abc2ae908f97",
      "candidate_info": {
        "commit_hash": "4a098bbe2ec444405dc492d23a36abc2ae908f97",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/4a098bbe2ec444405dc492d23a36abc2ae908f97",
        "files": [
          "wiretap/netscreen.c",
          "wiretap/netscreen.h"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I7f981f9cdcbea7ecdeb88bfff2f12d875de2244f\nReviewed-on: https://code.wireshark.org/review/15176\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit 6a140eca7b78b230f1f90a739a32257476513c78)\nReviewed-on: https://code.wireshark.org/review/15177",
        "before_after_code_files": [
          "wiretap/netscreen.c||wiretap/netscreen.c",
          "wiretap/netscreen.h||wiretap/netscreen.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/netscreen.c||wiretap/netscreen.c": [
          "File: wiretap/netscreen.c -> wiretap/netscreen.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,",
          "70:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "71:  int *err, gchar **err_info);",
          "78: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
          "79:  guint byte_offset);",
          "",
          "[Removed Lines]",
          "72: static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "73:  char *cap_int, gboolean *cap_dir, char *cap_dst,",
          "74:  int *err, gchar **err_info);",
          "75: static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,",
          "76:  const char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,",
          "77:  Buffer* buf, int *err, gchar **err_info);",
          "",
          "[Added Lines]",
          "72: static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,",
          "73:  Buffer* buf, char *line, int *err, gchar **err_info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191:     gint64 *data_offset)",
          "192: {",
          "193:  gint64  offset;",
          "195:  char  line[NETSCREEN_LINE_LENGTH];",
          "201:  offset = netscreen_seek_next_packet(wth, err, err_info, line);",
          "202:  if (offset < 0)",
          "203:   return FALSE;",
          "215:   return FALSE;",
          "",
          "[Removed Lines]",
          "194:  int  pkt_len;",
          "196:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "197:  gboolean cap_dir;",
          "198:  char  cap_dst[13];",
          "206:  pkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,",
          "207:      cap_dst, err, err_info);",
          "208:  if (pkt_len == -1)",
          "209:   return FALSE;",
          "213:  if (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,",
          "214:      cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))",
          "",
          "[Added Lines]",
          "198:  if (!parse_netscreen_packet(wth->fh, &wth->phdr,",
          "199:      wth->frame_buffer, line, err, err_info))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "239:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "240:  int *err, gchar **err_info)",
          "241: {",
          "243:  char  line[NETSCREEN_LINE_LENGTH];",
          "248:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {",
          "249:   return FALSE;",
          "",
          "[Removed Lines]",
          "242:  int  pkt_len;",
          "244:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "245:  gboolean cap_dir;",
          "246:  char  cap_dst[13];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "257:   return FALSE;",
          "258:  }",
          "269: }",
          "",
          "[Removed Lines]",
          "260:  pkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,",
          "261:      cap_dst, err, err_info);",
          "262:  if (pkt_len == -1)",
          "263:   return FALSE;",
          "265:  if (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,",
          "266:      cap_dst, phdr, buf, err, err_info))",
          "267:   return FALSE;",
          "268:  return TRUE;",
          "",
          "[Added Lines]",
          "241:  return parse_netscreen_packet(wth->random_fh, phdr, buf, line,",
          "242:      err, err_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "291: {",
          "297:  phdr->rec_type = REC_TYPE_PACKET;",
          "298:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "301:      &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {",
          "304:   return -1;",
          "305:  }",
          "309:  phdr->ts.secs  = sec;",
          "310:  phdr->ts.nsecs = dsec * 100000000;",
          "311:  phdr->len = pkt_len;",
          "331:  pd = ws_buffer_start_ptr(buf);",
          "333:  while(1) {",
          "",
          "[Removed Lines]",
          "288: static int",
          "289: parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,",
          "290:     gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)",
          "292:  int sec;",
          "293:  int dsec, pkt_len;",
          "294:  char direction[2];",
          "295:  char cap_src[13];",
          "300:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",",
          "313:  return pkt_len;",
          "314: }",
          "318: static gboolean",
          "319: parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,",
          "320:     const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,",
          "321:     int *err, gchar **err_info)",
          "322: {",
          "323:  guint8 *pd;",
          "324:  gchar line[NETSCREEN_LINE_LENGTH];",
          "325:  gchar *p;",
          "326:  int n, i = 0, offset = 0;",
          "327:  gchar dststr[13];",
          "330:  ws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "262: static gboolean",
          "263: parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "264:     char *line, int *err, gchar **err_info)",
          "266:  int  sec;",
          "267:  int  dsec;",
          "268:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "269:  char  direction[2];",
          "270:  guint  pkt_len;",
          "271:  char  cap_src[13];",
          "272:  char  cap_dst[13];",
          "273:  guint8  *pd;",
          "274:  gchar  *p;",
          "275:  int  n, i = 0;",
          "276:  guint  offset = 0;",
          "277:  gchar  dststr[13];",
          "282:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",",
          "288:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "295:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "296:   return FALSE;",
          "297:  }",
          "309:  ws_buffer_assure_space(buf, pkt_len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "379:    return FALSE;",
          "",
          "[Removed Lines]",
          "376:   if(n == -1) {",
          "",
          "[Added Lines]",
          "355:   if (n == -1) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "391:    return FALSE;",
          "",
          "[Removed Lines]",
          "388:   if(offset > pkt_len) {",
          "",
          "[Added Lines]",
          "367:   if (offset > pkt_len) {",
          "",
          "---------------"
        ],
        "wiretap/netscreen.h||wiretap/netscreen.h": [
          "File: wiretap/netscreen.h -> wiretap/netscreen.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #define NETSCREEN_INGRESS  FALSE",
          "47: #define NETSCREEN_EGRESS  TRUE",
          "52: wtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info);",
          "54: #endif",
          "",
          "[Removed Lines]",
          "50: #define NETSCREEN_MAX_PACKET_LEN 65536",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5386607e78c9b190ca02a5038c8dccb269ca3ce4",
      "candidate_info": {
        "commit_hash": "5386607e78c9b190ca02a5038c8dccb269ca3ce4",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/5386607e78c9b190ca02a5038c8dccb269ca3ce4",
        "files": [
          "wiretap/netscreen.c",
          "wiretap/netscreen.h"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I78ff4e5a429db5d1cf678abd9ac4db4210c92d6b\nReviewed-on: https://code.wireshark.org/review/15178\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit 7ffa6593529551cd38297a60bc9bc58bdd1d5837)\nReviewed-on: https://code.wireshark.org/review/16115\nReviewed-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "wiretap/netscreen.c||wiretap/netscreen.c",
          "wiretap/netscreen.h||wiretap/netscreen.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/netscreen.c||wiretap/netscreen.c": [
          "File: wiretap/netscreen.c -> wiretap/netscreen.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,",
          "73:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "74:  int *err, gchar **err_info);",
          "81: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
          "82:  guint byte_offset);",
          "",
          "[Removed Lines]",
          "75: static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "76:  char *cap_int, gboolean *cap_dir, char *cap_dst,",
          "77:  int *err, gchar **err_info);",
          "78: static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,",
          "79:  const char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,",
          "80:  Buffer* buf, int *err, gchar **err_info);",
          "",
          "[Added Lines]",
          "75: static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,",
          "76:  Buffer* buf, char *line, int *err, gchar **err_info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "194:     gint64 *data_offset)",
          "195: {",
          "196:  gint64  offset;",
          "198:  char  line[NETSCREEN_LINE_LENGTH];",
          "204:  offset = netscreen_seek_next_packet(wth, err, err_info, line);",
          "205:  if (offset < 0)",
          "206:   return FALSE;",
          "218:   return FALSE;",
          "",
          "[Removed Lines]",
          "197:  int  pkt_len;",
          "199:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "200:  gboolean cap_dir;",
          "201:  char  cap_dst[13];",
          "209:  pkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,",
          "210:      cap_dst, err, err_info);",
          "211:  if (pkt_len == -1)",
          "212:   return FALSE;",
          "216:  if (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,",
          "217:      cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))",
          "",
          "[Added Lines]",
          "201:  if (!parse_netscreen_packet(wth->fh, &wth->phdr,",
          "202:      wth->frame_buffer, line, err, err_info))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "243:  int *err, gchar **err_info)",
          "244: {",
          "246:  char  line[NETSCREEN_LINE_LENGTH];",
          "251:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {",
          "252:   return FALSE;",
          "",
          "[Removed Lines]",
          "245:  int  pkt_len;",
          "247:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "248:  gboolean cap_dir;",
          "249:  char  cap_dst[13];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "260:   return FALSE;",
          "261:  }",
          "272: }",
          "",
          "[Removed Lines]",
          "263:  pkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,",
          "264:      cap_dst, err, err_info);",
          "265:  if (pkt_len == -1)",
          "266:   return FALSE;",
          "268:  if (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,",
          "269:      cap_dst, phdr, buf, err, err_info))",
          "270:   return FALSE;",
          "271:  return TRUE;",
          "",
          "[Added Lines]",
          "244:  return parse_netscreen_packet(wth->random_fh, phdr, buf, line,",
          "245:      err, err_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "294: {",
          "300:  phdr->rec_type = REC_TYPE_PACKET;",
          "301:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "304:      &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {",
          "307:   return -1;",
          "308:  }",
          "312:  phdr->ts.secs  = sec;",
          "313:  phdr->ts.nsecs = dsec * 100000000;",
          "314:  phdr->len = pkt_len;",
          "334:  pd = buffer_start_ptr(buf);",
          "336:  while(1) {",
          "",
          "[Removed Lines]",
          "291: static int",
          "292: parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,",
          "293:     gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)",
          "295:  int sec;",
          "296:  int dsec, pkt_len;",
          "297:  char direction[2];",
          "298:  char cap_src[13];",
          "303:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",",
          "316:  return pkt_len;",
          "317: }",
          "321: static gboolean",
          "322: parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,",
          "323:     const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,",
          "324:     int *err, gchar **err_info)",
          "325: {",
          "326:  guint8 *pd;",
          "327:  gchar line[NETSCREEN_LINE_LENGTH];",
          "328:  gchar *p;",
          "329:  int n, i = 0, offset = 0;",
          "330:  gchar dststr[13];",
          "333:  buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "265: static gboolean",
          "266: parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "267:     char *line, int *err, gchar **err_info)",
          "269:  int  sec;",
          "270:  int  dsec;",
          "271:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "272:  char  direction[2];",
          "273:  guint  pkt_len;",
          "274:  char  cap_src[13];",
          "275:  char  cap_dst[13];",
          "276:  guint8  *pd;",
          "277:  gchar  *p;",
          "278:  int  n, i = 0;",
          "279:  guint  offset = 0;",
          "280:  gchar  dststr[13];",
          "285:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",",
          "291:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "298:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "299:   return FALSE;",
          "300:  }",
          "312:  buffer_assure_space(buf, pkt_len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "382:    return FALSE;",
          "",
          "[Removed Lines]",
          "379:   if(n == -1) {",
          "",
          "[Added Lines]",
          "358:   if (n == -1) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "394:                         return FALSE;",
          "",
          "[Removed Lines]",
          "391:   if(offset > pkt_len) {",
          "",
          "[Added Lines]",
          "370:   if (offset > pkt_len) {",
          "",
          "---------------"
        ],
        "wiretap/netscreen.h||wiretap/netscreen.h": [
          "File: wiretap/netscreen.h -> wiretap/netscreen.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #define NETSCREEN_INGRESS  FALSE",
          "47: #define NETSCREEN_EGRESS  TRUE",
          "52: int netscreen_open(wtap *wth, int *err, gchar **err_info);",
          "54: #endif",
          "",
          "[Removed Lines]",
          "50: #define NETSCREEN_MAX_PACKET_LEN 65536",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-8099",
  "cve_desc": "Incorrect returning of an error code in the index.c:read_entry() function leads to a double free in libgit2 before v0.26.2, which allows an attacker to cause a denial of service via a crafted repository index file.",
  "repo": "libgit2/libgit2",
  "patch_hash": "58a6fe94cb851f71214dbefac3f9bffee437d6fe",
  "patch_info": {
    "commit_hash": "58a6fe94cb851f71214dbefac3f9bffee437d6fe",
    "repo": "libgit2/libgit2",
    "commit_url": "https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe",
    "files": [
      "src/index.c"
    ],
    "message": "index: convert `read_entry` to return entry size via an out-param\n\nThe function `read_entry` does not conform to our usual coding style of\nreturning stuff via the out parameter and to use the return value for\nreporting errors. Due to most of our code conforming to that pattern, it\nhas become quite natural for us to actually return `-1` in case there is\nany error, which has also slipped in with commit 5625d86b9 (index:\nsupport index v4, 2016-05-17). As the function returns an `size_t` only,\nthough, the return value is wrapped around, causing the caller of\n`read_tree` to continue with an invalid index entry. Ultimately, this\ncan lead to a double-free.\n\nImprove code and fix the bug by converting the function to return the\nindex entry size via an out parameter and only using the return value to\nindicate errors.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
    "before_after_code_files": [
      "src/index.c||src/index.c"
    ]
  },
  "patch_diff": {
    "src/index.c||src/index.c": [
      "File: src/index.c -> src/index.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2299:  }",
      "2300: }",
      "2303:  git_index_entry **out,",
      "2304:  git_index *index,",
      "2305:  const void *buffer,",
      "2306:  size_t buffer_size,",
      "",
      "[Removed Lines]",
      "2302: static size_t read_entry(",
      "",
      "[Added Lines]",
      "2302: static int read_entry(",
      "2304:  size_t *out_size,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2314:  char *tmp_path = NULL;",
      "2316:  if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)",
      "2320:  memcpy(&source, buffer, sizeof(struct entry_short));",
      "",
      "[Removed Lines]",
      "2317:   return 0;",
      "",
      "[Added Lines]",
      "2318:   return -1;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2357:    path_end = memchr(path_ptr, '\\0', buffer_size);",
      "2358:    if (path_end == NULL)",
      "2361:    path_length = path_end - path_ptr;",
      "2362:   }",
      "",
      "[Removed Lines]",
      "2359:     return 0;",
      "",
      "[Added Lines]",
      "2360:     return -1;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2386:   entry.path = tmp_path;",
      "2387:  }",
      "2389:  if (INDEX_FOOTER_SIZE + entry_size > buffer_size)",
      "2392:  if (index_entry_dup(out, index, &entry) < 0) {",
      "2393:   git__free(tmp_path);",
      "2395:  }",
      "2397:  git__free(tmp_path);",
      "2399: }",
      "2401: static int read_header(struct index_header *dest, const void *buffer)",
      "",
      "[Removed Lines]",
      "2390:   return 0;",
      "2394:   return 0;",
      "2398:  return entry_size;",
      "",
      "[Added Lines]",
      "2390:  if (entry_size == 0)",
      "2391:   return -1;",
      "2394:   return -1;",
      "2398:   return -1;",
      "2403:  return 0;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2500:  for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {",
      "2501:   git_index_entry *entry = NULL;",
      "2506:    error = index_error_invalid(\"invalid entry\");",
      "2507:    goto done;",
      "2508:   }",
      "",
      "[Removed Lines]",
      "2502:   size_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);",
      "2505:   if (entry_size == 0) {",
      "",
      "[Added Lines]",
      "2507:   size_t entry_size;",
      "2509:   if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3db1af1f370295ad5355b8f64b865a2a357bcac0",
      "candidate_info": {
        "commit_hash": "3db1af1f370295ad5355b8f64b865a2a357bcac0",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/3db1af1f370295ad5355b8f64b865a2a357bcac0",
        "files": [
          "src/index.c"
        ],
        "message": "index: error out on unreasonable prefix-compressed path lengths\n\nWhen computing the complete path length from the encoded\nprefix-compressed path, we end up just allocating the complete path\nwithout ever checking what the encoded path length actually is. This can\neasily lead to a denial of service by just encoding an unreasonable long\npath name inside of the index. Git already enforces a maximum path\nlength of 4096 bytes. As we also have that enforcement ready in some\nplaces, just make sure that the resulting path is smaller than\nGIT_PATH_MAX.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
        "before_after_code_files": [
          "src/index.c||src/index.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/4575"
        ],
        "olp_code_files": {
          "patch": [
            "src/index.c||src/index.c"
          ],
          "candidate": [
            "src/index.c||src/index.c"
          ]
        }
      },
      "candidate_diff": {
        "src/index.c||src/index.c": [
          "File: src/index.c -> src/index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2380:   GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);",
          "2381:   GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);",
          "2382:   tmp_path = git__malloc(path_len);",
          "2383:   GITERR_CHECK_ALLOC(tmp_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2383:   if (path_len > GIT_PATH_MAX)",
          "2384:    return index_error_invalid(\"unreasonable path length\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3207ddb0103543da8ad2139ec6539f590f9900c1",
      "candidate_info": {
        "commit_hash": "3207ddb0103543da8ad2139ec6539f590f9900c1",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/3207ddb0103543da8ad2139ec6539f590f9900c1",
        "files": [
          "src/index.c"
        ],
        "message": "index: fix out-of-bounds read with invalid index entry prefix length\n\nThe index format in version 4 has prefix-compressed entries, where every\nindex entry can compress its path by using a path prefix of the previous\nentry. Since implmenting support for this index format version in commit\n5625d86b9 (index: support index v4, 2016-05-17), though, we do not\ncorrectly verify that the prefix length that we want to reuse is\nactually smaller or equal to the amount of characters than the length of\nthe previous index entry's path. This can lead to a an integer underflow\nand subsequently to an out-of-bounds read.\n\nFix this by verifying that the prefix is actually smaller than the\nprevious entry's path length.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
        "before_after_code_files": [
          "src/index.c||src/index.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/4575"
        ],
        "olp_code_files": {
          "patch": [
            "src/index.c||src/index.c"
          ],
          "candidate": [
            "src/index.c||src/index.c"
          ]
        }
      },
      "candidate_diff": {
        "src/index.c||src/index.c": [
          "File: src/index.c -> src/index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2365:   entry_size = index_entry_size(path_length, 0, entry.flags);",
          "2366:   entry.path = (char *)path_ptr;",
          "2367:  } else {",
          "2377:    return index_error_invalid(\"incorrect prefix length\");",
          "2379:   GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);",
          "2380:   GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);",
          "2381:   tmp_path = git__malloc(path_len);",
          "",
          "[Removed Lines]",
          "2368:   size_t varint_len;",
          "2369:   size_t strip_len = git_decode_varint((const unsigned char *)path_ptr,",
          "2370:            &varint_len);",
          "2371:   size_t last_len = strlen(last);",
          "2372:   size_t prefix_len = last_len - strip_len;",
          "2373:   size_t suffix_len = strlen(path_ptr + varint_len);",
          "2374:   size_t path_len;",
          "2376:   if (varint_len == 0)",
          "",
          "[Added Lines]",
          "2368:   size_t varint_len, last_len, prefix_len, suffix_len, path_len;",
          "2369:   uintmax_t strip_len;",
          "2371:   strip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);",
          "2372:   last_len = strlen(last);",
          "2374:   if (varint_len == 0 || last_len < strip_len)",
          "2377:   prefix_len = last_len - strip_len;",
          "2378:   suffix_len = strlen(path_ptr + varint_len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "83e0392ceadb7e1d9db09a7f013e28759a666e89",
      "candidate_info": {
        "commit_hash": "83e0392ceadb7e1d9db09a7f013e28759a666e89",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/83e0392ceadb7e1d9db09a7f013e28759a666e89",
        "files": [
          "src/index.c"
        ],
        "message": "index: also sanity check entry size with compressed entries\n\nWe have a check in place whether the index has enough data left for the\nrequired footer after reading an index entry, but this was only used for\nuncompressed entries. Move the check down a bit so that it is executed\nfor both compressed and uncompressed index entries.",
        "before_after_code_files": [
          "src/index.c||src/index.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/index.c||src/index.c"
          ],
          "candidate": [
            "src/index.c||src/index.c"
          ]
        }
      },
      "candidate_diff": {
        "src/index.c||src/index.c": [
          "File: src/index.c -> src/index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2358:   }",
          "2360:   entry_size = index_entry_size(path_length, 0, entry.flags);",
          "2365:   entry.path = (char *)path_ptr;",
          "2366:  } else {",
          "2367:   size_t varint_len;",
          "",
          "[Removed Lines]",
          "2362:   if (INDEX_FOOTER_SIZE + entry_size > buffer_size)",
          "2363:    return 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2386:   entry.path = tmp_path;",
          "2387:  }",
          "2389:  if (index_entry_dup(out, index, &entry) < 0) {",
          "2390:   git__free(tmp_path);",
          "2391:   return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2385:  if (INDEX_FOOTER_SIZE + entry_size > buffer_size)",
          "2386:   return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b6756821d9259cd5991caabd7835658572278051",
      "candidate_info": {
        "commit_hash": "b6756821d9259cd5991caabd7835658572278051",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/b6756821d9259cd5991caabd7835658572278051",
        "files": [
          "src/index.c"
        ],
        "message": "index: convert `read_entry` to return entry size via an out-param\n\nThe function `read_entry` does not conform to our usual coding style of\nreturning stuff via the out parameter and to use the return value for\nreporting errors. Due to most of our code conforming to that pattern, it\nhas become quite natural for us to actually return `-1` in case there is\nany error, which has also slipped in with commit 5625d86b9 (index:\nsupport index v4, 2016-05-17). As the function returns an `size_t` only,\nthough, the return value is wrapped around, causing the caller of\n`read_tree` to continue with an invalid index entry. Ultimately, this\ncan lead to a double-free.\n\nImprove code and fix the bug by converting the function to return the\nindex entry size via an out parameter and only using the return value to\nindicate errors.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
        "before_after_code_files": [
          "src/index.c||src/index.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/index.c||src/index.c"
          ],
          "candidate": [
            "src/index.c||src/index.c"
          ]
        }
      },
      "candidate_diff": {
        "src/index.c||src/index.c": [
          "File: src/index.c -> src/index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2295:  }",
          "2296: }",
          "2299:  git_index_entry **out,",
          "2300:  git_index *index,",
          "2301:  const void *buffer,",
          "2302:  size_t buffer_size,",
          "",
          "[Removed Lines]",
          "2298: static size_t read_entry(",
          "",
          "[Added Lines]",
          "2298: static int read_entry(",
          "2300:  size_t *out_size,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2310:  char *tmp_path = NULL;",
          "2312:  if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)",
          "2316:  memcpy(&source, buffer, sizeof(struct entry_short));",
          "",
          "[Removed Lines]",
          "2313:   return 0;",
          "",
          "[Added Lines]",
          "2314:   return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2353:    path_end = memchr(path_ptr, '\\0', buffer_size);",
          "2354:    if (path_end == NULL)",
          "2357:    path_length = path_end - path_ptr;",
          "2358:   }",
          "",
          "[Removed Lines]",
          "2355:     return 0;",
          "",
          "[Added Lines]",
          "2356:     return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2382:   entry.path = tmp_path;",
          "2383:  }",
          "2385:  if (INDEX_FOOTER_SIZE + entry_size > buffer_size)",
          "2388:  if (index_entry_dup(out, index, &entry) < 0) {",
          "2389:   git__free(tmp_path);",
          "2391:  }",
          "2393:  git__free(tmp_path);",
          "2395: }",
          "2397: static int read_header(struct index_header *dest, const void *buffer)",
          "",
          "[Removed Lines]",
          "2386:   return 0;",
          "2390:   return 0;",
          "2394:  return entry_size;",
          "",
          "[Added Lines]",
          "2386:  if (entry_size == 0)",
          "2387:   return -1;",
          "2390:   return -1;",
          "2394:   return -1;",
          "2399:  return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2496:  for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {",
          "2497:   git_index_entry *entry;",
          "2502:    error = index_error_invalid(\"invalid entry\");",
          "2503:    goto done;",
          "2504:   }",
          "",
          "[Removed Lines]",
          "2498:   size_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);",
          "2501:   if (entry_size == 0) {",
          "",
          "[Added Lines]",
          "2503:   size_t entry_size;",
          "2505:   if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
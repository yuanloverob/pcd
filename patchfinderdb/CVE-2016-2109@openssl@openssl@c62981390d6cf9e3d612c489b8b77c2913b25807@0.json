{
  "cve_id": "CVE-2016-2109",
  "cve_desc": "The asn1_d2i_read_bio function in crypto/asn1/a_d2i_fp.c in the ASN.1 BIO implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (memory consumption) via a short invalid encoding.",
  "repo": "openssl/openssl",
  "patch_hash": "c62981390d6cf9e3d612c489b8b77c2913b25807",
  "patch_info": {
    "commit_hash": "c62981390d6cf9e3d612c489b8b77c2913b25807",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/c62981390d6cf9e3d612c489b8b77c2913b25807",
    "files": [
      "crypto/asn1/a_d2i_fp.c"
    ],
    "message": "Harden ASN.1 BIO handling of large amounts of data.\n\nIf the ASN.1 BIO is presented with a large length field read it in\nchunks of increasing size checking for EOF on each read. This prevents\nsmall files allocating excessive amounts of data.\n\nCVE-2016-2109\n\nThanks to Brian Carpenter for reporting this issue.\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>",
    "before_after_code_files": [
      "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c"
    ]
  },
  "patch_diff": {
    "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c": [
      "File: crypto/asn1/a_d2i_fp.c -> crypto/asn1/a_d2i_fp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "138: #endif",
      "140: #define HEADER_SIZE   8",
      "141: static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)",
      "142: {",
      "143:     BUF_MEM *b;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "141: #define ASN1_CHUNK_INITIAL_SIZE (16 * 1024)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "217:             want = slen;",
      "218:             if (want > (len - off)) {",
      "219:                 want -= (len - off);",
      "220:                 if (want > INT_MAX /* BIO_read takes an int length */  ||",
      "221:                     len + want < len) {",
      "222:                     ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);",
      "223:                     goto err;",
      "224:                 }",
      "229:                 while (want > 0) {",
      "234:                         goto err;",
      "235:                     }",
      "242:                 }",
      "243:             }",
      "244:             if (off + slen < off) {",
      "",
      "[Removed Lines]",
      "225:                 if (!BUF_MEM_grow_clean(b, len + want)) {",
      "226:                     ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);",
      "227:                     goto err;",
      "228:                 }",
      "230:                     i = BIO_read(in, &(b->data[len]), want);",
      "231:                     if (i <= 0) {",
      "232:                         ASN1err(ASN1_F_ASN1_D2I_READ_BIO,",
      "233:                                 ASN1_R_NOT_ENOUGH_DATA);",
      "240:                     len += i;",
      "241:                     want -= i;",
      "",
      "[Added Lines]",
      "220:                 size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE;",
      "235:                     size_t chunk = want > chunk_max ? chunk_max : want;",
      "237:                     if (!BUF_MEM_grow_clean(b, len + chunk)) {",
      "238:                         ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);",
      "241:                     want -= chunk;",
      "242:                     while (chunk > 0) {",
      "243:                         i = BIO_read(in, &(b->data[len]), chunk);",
      "244:                         if (i <= 0) {",
      "245:                             ASN1err(ASN1_F_ASN1_D2I_READ_BIO,",
      "246:                                     ASN1_R_NOT_ENOUGH_DATA);",
      "247:                             goto err;",
      "248:                         }",
      "253:                         len += i;",
      "254:                         chunk -= i;",
      "255:                     }",
      "256:                     if (chunk_max < INT_MAX/2)",
      "257:                         chunk_max *= 2;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f32774087f7b3db1f789688368d16d917757421e",
      "candidate_info": {
        "commit_hash": "f32774087f7b3db1f789688368d16d917757421e",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/f32774087f7b3db1f789688368d16d917757421e",
        "files": [
          "crypto/asn1/a_d2i_fp.c"
        ],
        "message": "Harden ASN.1 BIO handling of large amounts of data.\n\nIf the ASN.1 BIO is presented with a large length field read it in\nchunks of increasing size checking for EOF on each read. This prevents\nsmall files allocating excessive amounts of data.\n\nCVE-2016-2109\n\nThanks to Brian Carpenter for reporting this issue.\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\n(cherry picked from commit c62981390d6cf9e3d612c489b8b77c2913b25807)",
        "before_after_code_files": [
          "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c"
          ],
          "candidate": [
            "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c": [
          "File: crypto/asn1/a_d2i_fp.c -> crypto/asn1/a_d2i_fp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: #endif",
          "143: #define HEADER_SIZE   8",
          "144: static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)",
          "145: {",
          "146:     BUF_MEM *b;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144: #define ASN1_CHUNK_INITIAL_SIZE (16 * 1024)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "218:             want = c.slen;",
          "219:             if (want > (len - off)) {",
          "220:                 want -= (len - off);",
          "221:                 if (want > INT_MAX /* BIO_read takes an int length */  ||",
          "222:                     len + want < len) {",
          "223:                     ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);",
          "224:                     goto err;",
          "225:                 }",
          "230:                 while (want > 0) {",
          "235:                         goto err;",
          "236:                     }",
          "243:                 }",
          "244:             }",
          "245:             if (off + c.slen < off) {",
          "",
          "[Removed Lines]",
          "226:                 if (!BUF_MEM_grow_clean(b, len + want)) {",
          "227:                     ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);",
          "228:                     goto err;",
          "229:                 }",
          "231:                     i = BIO_read(in, &(b->data[len]), want);",
          "232:                     if (i <= 0) {",
          "233:                         ASN1err(ASN1_F_ASN1_D2I_READ_BIO,",
          "234:                                 ASN1_R_NOT_ENOUGH_DATA);",
          "241:                     len += i;",
          "242:                     want -= i;",
          "",
          "[Added Lines]",
          "221:                 size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE;",
          "236:                     size_t chunk = want > chunk_max ? chunk_max : want;",
          "238:                     if (!BUF_MEM_grow_clean(b, len + chunk)) {",
          "239:                         ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);",
          "242:                     want -= chunk;",
          "243:                     while (chunk > 0) {",
          "244:                         i = BIO_read(in, &(b->data[len]), chunk);",
          "245:                         if (i <= 0) {",
          "246:                             ASN1err(ASN1_F_ASN1_D2I_READ_BIO,",
          "247:                                     ASN1_R_NOT_ENOUGH_DATA);",
          "248:                             goto err;",
          "249:                         }",
          "254:                         len += i;",
          "255:                         chunk -= i;",
          "256:                     }",
          "257:                     if (chunk_max < INT_MAX/2)",
          "258:                         chunk_max *= 2;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3d411057a5e28530fffc40b257698f453c89aa87",
      "candidate_info": {
        "commit_hash": "3d411057a5e28530fffc40b257698f453c89aa87",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/3d411057a5e28530fffc40b257698f453c89aa87",
        "files": [
          "crypto/asn1/a_d2i_fp.c"
        ],
        "message": "Harden ASN.1 BIO handling of large amounts of data.\n\nIf the ASN.1 BIO is presented with a large length field read it in\nchunks of increasing size checking for EOF on each read. This prevents\nsmall files allocating excessive amounts of data.\n\nCVE-2016-2109\n\nThanks to Brian Carpenter for reporting this issue.\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\n(cherry picked from commit c62981390d6cf9e3d612c489b8b77c2913b25807)",
        "before_after_code_files": [
          "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c"
          ],
          "candidate": [
            "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/asn1/a_d2i_fp.c||crypto/asn1/a_d2i_fp.c": [
          "File: crypto/asn1/a_d2i_fp.c -> crypto/asn1/a_d2i_fp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: #endif",
          "143: #define HEADER_SIZE   8",
          "144: static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)",
          "145: {",
          "146:     BUF_MEM *b;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144: #define ASN1_CHUNK_INITIAL_SIZE (16 * 1024)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "218:             want = c.slen;",
          "219:             if (want > (len - off)) {",
          "220:                 want -= (len - off);",
          "221:                 if (want > INT_MAX /* BIO_read takes an int length */  ||",
          "222:                     len + want < len) {",
          "223:                     ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);",
          "224:                     goto err;",
          "225:                 }",
          "230:                 while (want > 0) {",
          "235:                         goto err;",
          "236:                     }",
          "243:                 }",
          "244:             }",
          "245:             if (off + c.slen < off) {",
          "",
          "[Removed Lines]",
          "226:                 if (!BUF_MEM_grow_clean(b, len + want)) {",
          "227:                     ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);",
          "228:                     goto err;",
          "229:                 }",
          "231:                     i = BIO_read(in, &(b->data[len]), want);",
          "232:                     if (i <= 0) {",
          "233:                         ASN1err(ASN1_F_ASN1_D2I_READ_BIO,",
          "234:                                 ASN1_R_NOT_ENOUGH_DATA);",
          "241:                     len += i;",
          "242:                     want -= i;",
          "",
          "[Added Lines]",
          "221:                 size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE;",
          "236:                     size_t chunk = want > chunk_max ? chunk_max : want;",
          "238:                     if (!BUF_MEM_grow_clean(b, len + chunk)) {",
          "239:                         ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);",
          "242:                     want -= chunk;",
          "243:                     while (chunk > 0) {",
          "244:                         i = BIO_read(in, &(b->data[len]), chunk);",
          "245:                         if (i <= 0) {",
          "246:                             ASN1err(ASN1_F_ASN1_D2I_READ_BIO,",
          "247:                                     ASN1_R_NOT_ENOUGH_DATA);",
          "248:                             goto err;",
          "249:                         }",
          "254:                         len += i;",
          "255:                         chunk -= i;",
          "256:                     }",
          "257:                     if (chunk_max < INT_MAX/2)",
          "258:                         chunk_max *= 2;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
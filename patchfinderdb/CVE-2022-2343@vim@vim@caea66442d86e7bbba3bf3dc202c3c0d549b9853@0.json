{
  "cve_id": "CVE-2022-2343",
  "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0044.",
  "repo": "vim/vim",
  "patch_hash": "caea66442d86e7bbba3bf3dc202c3c0d549b9853",
  "patch_info": {
    "commit_hash": "caea66442d86e7bbba3bf3dc202c3c0d549b9853",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/caea66442d86e7bbba3bf3dc202c3c0d549b9853",
    "files": [
      "src/insexpand.c",
      "src/testdir/test_ins_complete.vim",
      "src/version.c"
    ],
    "message": "patch 9.0.0045: reading past end of completion with a long line\n\nProblem:    Reading past end of completion with a long line and 'infercase'\n            set.\nSolution:   Allocate the string if needed.",
    "before_after_code_files": [
      "src/insexpand.c||src/insexpand.c",
      "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim",
      "src/version.c||src/version.c"
    ]
  },
  "patch_diff": {
    "src/insexpand.c||src/insexpand.c": [
      "File: src/insexpand.c -> src/insexpand.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "528:     static char_u *",
      "529: ins_compl_infercase_gettext(",
      "530:  char_u *str,",
      "534: {",
      "535:     int  *wca;   // Wide character array.",
      "536:     char_u *p;",
      "537:     int  i, c;",
      "538:     int  has_lower = FALSE;",
      "539:     int  was_letter = FALSE;",
      "541:     IObuff[0] = NUL;",
      "545:     if (wca == NULL)",
      "546:  return IObuff;",
      "548:     p = str;",
      "550:  if (has_mbyte)",
      "551:      wca[i] = mb_ptr2char_adv(&p);",
      "552:  else",
      "",
      "[Removed Lines]",
      "531:  int actual_len,",
      "532:  int actual_compl_length,",
      "533:  int min_len)",
      "544:     wca = ALLOC_MULT(int, actual_len);",
      "549:     for (i = 0; i < actual_len; ++i)",
      "",
      "[Added Lines]",
      "532:  int char_len,",
      "533:  int compl_char_len,",
      "534:  int min_len,",
      "535:  char_u  **tofree)",
      "542:     garray_T gap;",
      "547:     wca = ALLOC_MULT(int, char_len);",
      "552:     for (i = 0; i < char_len; ++i)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "566:      if (MB_ISUPPER(wca[i]))",
      "567:      {",
      "570:       wca[i] = MB_TOLOWER(wca[i]);",
      "571:   break;",
      "572:      }",
      "",
      "[Removed Lines]",
      "569:   for (i = actual_compl_length; i < actual_len; ++i)",
      "",
      "[Added Lines]",
      "572:   for (i = compl_char_len; i < char_len; ++i)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "587:      if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))",
      "588:      {",
      "591:       wca[i] = MB_TOUPPER(wca[i]);",
      "592:   break;",
      "593:      }",
      "",
      "[Removed Lines]",
      "590:   for (i = actual_compl_length; i < actual_len; ++i)",
      "",
      "[Added Lines]",
      "593:   for (i = compl_char_len; i < char_len; ++i)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "610:     }",
      "616:     p = IObuff;",
      "617:     i = 0;",
      "620:      p += (*mb_char2bytes)(wca[i++], p);",
      "621:  else",
      "625:     vim_free(wca);",
      "627:     return IObuff;",
      "628: }",
      "",
      "[Removed Lines]",
      "618:     while (i < actual_len && (p - IObuff + 6) < IOSIZE)",
      "619:  if (has_mbyte)",
      "",
      "[Added Lines]",
      "618:     ga_init2(&gap, 1, 500);",
      "619:     while (i < char_len)",
      "620:     {",
      "621:  if (gap.ga_data != NULL)",
      "622:  {",
      "623:      if (ga_grow(&gap, 10) == FAIL)",
      "624:      {",
      "625:   ga_clear(&gap);",
      "626:   return (char_u *)\"[failed]\";",
      "627:      }",
      "628:      p = (char_u *)gap.ga_data + gap.ga_len;",
      "629:      if (has_mbyte)",
      "630:   gap.ga_len += (*mb_char2bytes)(wca[i++], p);",
      "631:      else",
      "632:      {",
      "634:   ++gap.ga_len;",
      "635:      }",
      "636:  }",
      "637:  else if ((p - IObuff) + 6 >= IOSIZE)",
      "638:  {",
      "643:      if (ga_grow(&gap, IOSIZE) == FAIL)",
      "644:   return (char_u *)\"[failed]\";",
      "645:      STRCPY(gap.ga_data, IObuff);",
      "646:      gap.ga_len = STRLEN(IObuff);",
      "647:  }",
      "648:  else if (has_mbyte)",
      "652:     }",
      "655:     if (gap.ga_data != NULL)",
      "656:     {",
      "658:  return gap.ga_data;",
      "659:     }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "644: {",
      "645:     char_u *str = str_arg;",
      "646:     char_u *p;",
      "649:     int  min_len;",
      "650:     int  flags = 0;",
      "652:     if (p_ic && curbuf->b_p_inf && len > 0)",
      "653:     {",
      "",
      "[Removed Lines]",
      "647:     int  actual_len;  // Take multi-byte characters",
      "648:     int  actual_compl_length; // into account.",
      "",
      "[Added Lines]",
      "682:     int  char_len;  // count multi-byte characters",
      "683:     int  compl_char_len;",
      "686:     int  res;",
      "687:     char_u *tofree = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "657:  if (has_mbyte)",
      "658:  {",
      "659:      p = str;",
      "661:      while (*p != NUL)",
      "662:      {",
      "663:   MB_PTR_ADV(p);",
      "665:      }",
      "666:  }",
      "667:  else",
      "671:  if (has_mbyte)",
      "672:  {",
      "673:      p = compl_orig_text;",
      "675:      while (*p != NUL)",
      "676:      {",
      "677:   MB_PTR_ADV(p);",
      "679:      }",
      "680:  }",
      "681:  else",
      "691:     }",
      "692:     if (cont_s_ipos)",
      "693:  flags |= CP_CONT_S_IPOS;",
      "694:     if (icase)",
      "695:  flags |= CP_ICASE;",
      "698: }",
      "",
      "[Removed Lines]",
      "660:      actual_len = 0;",
      "664:   ++actual_len;",
      "668:      actual_len = len;",
      "674:      actual_compl_length = 0;",
      "678:   ++actual_compl_length;",
      "682:      actual_compl_length = compl_length;",
      "686:  min_len = actual_len < actual_compl_length",
      "687:         ? actual_len : actual_compl_length;",
      "689:  str = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,",
      "690:         min_len);",
      "697:     return ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);",
      "",
      "[Added Lines]",
      "697:      char_len = 0;",
      "701:   ++char_len;",
      "705:      char_len = len;",
      "711:      compl_char_len = 0;",
      "715:   ++compl_char_len;",
      "719:      compl_char_len = compl_length;",
      "723:  min_len = char_len < compl_char_len ? char_len : compl_char_len;",
      "725:  str = ins_compl_infercase_gettext(str, char_len,",
      "726:        compl_char_len, min_len, &tofree);",
      "733:     res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);",
      "734:     vim_free(tofree);",
      "735:     return res;",
      "",
      "---------------"
    ],
    "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim": [
      "File: src/testdir/test_ins_complete.vim -> src/testdir/test_ins_complete.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "2097: \u0005",
      "2098:   bwipe!",
      "2099: endfunc",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2101: func Test_infercase_very_long_line()",
      "2102:   \" this was truncating the line when inferring case",
      "2103:   new",
      "2104:   let longLine = \"blah \"->repeat(300)",
      "2105:   let verylongLine = \"blah \"->repeat(400)",
      "2106:   call setline(1, verylongLine)",
      "2107:   call setline(2, longLine)",
      "2108:   set ic infercase",
      "2109:   exe \"normal 2Go\\<C-X>\\<C-L>\\<Esc>\"",
      "2110:   call assert_equal(longLine, getline(3))",
      "2112:   bwipe!",
      "2113:   set noic noinfercase",
      "2114: endfunc",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "736: static int included_patches[] =",
      "739:     44,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "739:     45,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c7bd2f08e531f08723cdc677212a3633d11c9a97",
      "candidate_info": {
        "commit_hash": "c7bd2f08e531f08723cdc677212a3633d11c9a97",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/c7bd2f08e531f08723cdc677212a3633d11c9a97",
        "files": [
          "src/insexpand.c",
          "src/version.c"
        ],
        "message": "patch 9.0.0054: compiler warning for size_t to int conversion\n\nProblem:    Compiler warning for size_t to int conversion.\nSolution:   Add type cast. (Mike Williams, closes #10741)",
        "before_after_code_files": [
          "src/insexpand.c||src/insexpand.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/insexpand.c||src/insexpand.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/insexpand.c||src/insexpand.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/insexpand.c||src/insexpand.c": [
          "File: src/insexpand.c -> src/insexpand.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "643:      if (ga_grow(&gap, IOSIZE) == FAIL)",
          "644:   return (char_u *)\"[failed]\";",
          "645:      STRCPY(gap.ga_data, IObuff);",
          "647:  }",
          "648:  else if (has_mbyte)",
          "649:      p += (*mb_char2bytes)(wca[i++], p);",
          "",
          "[Removed Lines]",
          "646:      gap.ga_len = STRLEN(IObuff);",
          "",
          "[Added Lines]",
          "646:      gap.ga_len = (int)STRLEN(IObuff);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "736: static int included_patches[] =",
          "739:     53,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "739:     54,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6ad84ab3e48d9490e4139df04f2c55b136f5501d",
      "candidate_info": {
        "commit_hash": "6ad84ab3e48d9490e4139df04f2c55b136f5501d",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/6ad84ab3e48d9490e4139df04f2c55b136f5501d",
        "files": [
          "src/insexpand.c",
          "src/version.c"
        ],
        "message": "patch 8.2.3953: insert completion code is too complicated\n\nProblem:    Insert completion code is too complicated.\nSolution:   More refactoring.  Move function arguments into a struct.\n            (Yegappan Lakshmanan, closes #9437)",
        "before_after_code_files": [
          "src/insexpand.c||src/insexpand.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/insexpand.c||src/insexpand.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/insexpand.c||src/insexpand.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/insexpand.c||src/insexpand.c": [
          "File: src/insexpand.c -> src/insexpand.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "391:     return FALSE;",
          "392: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "398:     static int",
          "399: ins_compl_at_original_text(compl_T *match)",
          "400: {",
          "401:     return match->cp_flags & CP_ORIGINAL_TEXT;",
          "402: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "425:     return vim_iswordc(c);",
          "426: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "441:     static char_u *",
          "442: ins_compl_infercase_gettext(",
          "443:  char_u *str,",
          "444:  int actual_len,",
          "445:  int actual_compl_length,",
          "446:  int min_len)",
          "447: {",
          "448:     int  *wca;   // Wide character array.",
          "449:     char_u *p;",
          "450:     int  i, c;",
          "451:     int  has_lower = FALSE;",
          "452:     int  was_letter = FALSE;",
          "454:     IObuff[0] = NUL;",
          "457:     wca = ALLOC_MULT(int, actual_len);",
          "458:     if (wca == NULL)",
          "459:  return IObuff;",
          "461:     p = str;",
          "462:     for (i = 0; i < actual_len; ++i)",
          "463:  if (has_mbyte)",
          "464:      wca[i] = mb_ptr2char_adv(&p);",
          "465:  else",
          "466:      wca[i] = *(p++);",
          "469:     p = compl_orig_text;",
          "470:     for (i = 0; i < min_len; ++i)",
          "471:     {",
          "472:  if (has_mbyte)",
          "473:      c = mb_ptr2char_adv(&p);",
          "474:  else",
          "475:      c = *(p++);",
          "476:  if (MB_ISLOWER(c))",
          "477:  {",
          "478:      has_lower = TRUE;",
          "479:      if (MB_ISUPPER(wca[i]))",
          "480:      {",
          "482:   for (i = actual_compl_length; i < actual_len; ++i)",
          "483:       wca[i] = MB_TOLOWER(wca[i]);",
          "484:   break;",
          "485:      }",
          "486:  }",
          "487:     }",
          "491:     if (!has_lower)",
          "492:     {",
          "493:  p = compl_orig_text;",
          "494:  for (i = 0; i < min_len; ++i)",
          "495:  {",
          "496:      if (has_mbyte)",
          "497:   c = mb_ptr2char_adv(&p);",
          "498:      else",
          "499:   c = *(p++);",
          "500:      if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))",
          "501:      {",
          "503:   for (i = actual_compl_length; i < actual_len; ++i)",
          "504:       wca[i] = MB_TOUPPER(wca[i]);",
          "505:   break;",
          "506:      }",
          "507:      was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);",
          "508:  }",
          "509:     }",
          "512:     p = compl_orig_text;",
          "513:     for (i = 0; i < min_len; ++i)",
          "514:     {",
          "515:  if (has_mbyte)",
          "516:      c = mb_ptr2char_adv(&p);",
          "517:  else",
          "518:      c = *(p++);",
          "519:  if (MB_ISLOWER(c))",
          "520:      wca[i] = MB_TOLOWER(wca[i]);",
          "521:  else if (MB_ISUPPER(c))",
          "522:      wca[i] = MB_TOUPPER(wca[i]);",
          "523:     }",
          "529:     p = IObuff;",
          "530:     i = 0;",
          "531:     while (i < actual_len && (p - IObuff + 6) < IOSIZE)",
          "532:  if (has_mbyte)",
          "533:      p += (*mb_char2bytes)(wca[i++], p);",
          "534:  else",
          "538:     vim_free(wca);",
          "540:     return IObuff;",
          "541: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "442: {",
          "443:     char_u *str = str_arg;",
          "444:     char_u *p;",
          "446:     int  actual_len;  // Take multi-byte characters",
          "447:     int  actual_compl_length; // into account.",
          "448:     int  min_len;",
          "452:     int  flags = 0;",
          "454:     if (p_ic && curbuf->b_p_inf && len > 0)",
          "",
          "[Removed Lines]",
          "445:     int  i, c;",
          "449:     int  *wca;   // Wide character array.",
          "450:     int  has_lower = FALSE;",
          "451:     int  was_letter = FALSE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "488:  min_len = actual_len < actual_compl_length",
          "489:         ? actual_len : actual_compl_length;",
          "576:     }",
          "577:     if (cont_s_ipos)",
          "578:  flags |= CP_CONT_S_IPOS;",
          "",
          "[Removed Lines]",
          "492:  wca = ALLOC_MULT(int, actual_len);",
          "493:  if (wca != NULL)",
          "494:  {",
          "495:      p = str;",
          "496:      for (i = 0; i < actual_len; ++i)",
          "497:   if (has_mbyte)",
          "498:       wca[i] = mb_ptr2char_adv(&p);",
          "499:   else",
          "500:       wca[i] = *(p++);",
          "503:      p = compl_orig_text;",
          "504:      for (i = 0; i < min_len; ++i)",
          "505:      {",
          "506:   if (has_mbyte)",
          "507:       c = mb_ptr2char_adv(&p);",
          "508:   else",
          "509:       c = *(p++);",
          "510:   if (MB_ISLOWER(c))",
          "511:   {",
          "512:       has_lower = TRUE;",
          "513:       if (MB_ISUPPER(wca[i]))",
          "514:       {",
          "516:    for (i = actual_compl_length; i < actual_len; ++i)",
          "517:        wca[i] = MB_TOLOWER(wca[i]);",
          "518:    break;",
          "519:       }",
          "520:   }",
          "521:      }",
          "525:      if (!has_lower)",
          "526:      {",
          "527:   p = compl_orig_text;",
          "528:   for (i = 0; i < min_len; ++i)",
          "529:   {",
          "530:       if (has_mbyte)",
          "531:    c = mb_ptr2char_adv(&p);",
          "532:       else",
          "533:    c = *(p++);",
          "534:       if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))",
          "535:       {",
          "537:    for (i = actual_compl_length; i < actual_len; ++i)",
          "538:        wca[i] = MB_TOUPPER(wca[i]);",
          "539:    break;",
          "540:       }",
          "541:       was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);",
          "542:   }",
          "543:      }",
          "546:      p = compl_orig_text;",
          "547:      for (i = 0; i < min_len; ++i)",
          "548:      {",
          "549:   if (has_mbyte)",
          "550:       c = mb_ptr2char_adv(&p);",
          "551:   else",
          "552:       c = *(p++);",
          "553:   if (MB_ISLOWER(c))",
          "554:       wca[i] = MB_TOLOWER(wca[i]);",
          "555:   else if (MB_ISUPPER(c))",
          "556:       wca[i] = MB_TOUPPER(wca[i]);",
          "557:      }",
          "563:      p = IObuff;",
          "564:      i = 0;",
          "565:      while (i < actual_len && (p - IObuff + 6) < IOSIZE)",
          "566:   if (has_mbyte)",
          "567:       p += (*mb_char2bytes)(wca[i++], p);",
          "568:   else",
          "572:      vim_free(wca);",
          "573:  }",
          "575:  str = IObuff;",
          "",
          "[Added Lines]",
          "602:  str = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,",
          "603:         min_len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "618:  match = compl_first_match;",
          "619:  do",
          "620:  {",
          "622:       && STRNCMP(match->cp_str, str, len) == 0",
          "623:       && match->cp_str[len] == NUL)",
          "624:   return NOTDONE;",
          "",
          "[Removed Lines]",
          "621:      if (    !(match->cp_flags & CP_ORIGINAL_TEXT)",
          "",
          "[Added Lines]",
          "649:      if (!ins_compl_at_original_text(match)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "730:     {",
          "732:  compl_leader = vim_strsave(match->cp_str);",
          "736:      ins_compl_delete();",
          "746:     }",
          "748:     {",
          "753:  {",
          "777:  }",
          "780:  {",
          "792:  }",
          "795:     }",
          "796: }",
          "",
          "[Removed Lines]",
          "733:  if (compl_leader != NULL)",
          "734:  {",
          "735:      had_match = (curwin->w_cursor.col > compl_col);",
          "737:      ins_bytes(compl_leader + ins_compl_len());",
          "738:      ins_redraw(FALSE);",
          "742:      if (!had_match)",
          "743:   ins_compl_delete();",
          "744:      compl_used_match = FALSE;",
          "745:  }",
          "747:     else",
          "750:  p = compl_leader;",
          "751:  s = match->cp_str;",
          "752:  while (*p != NUL)",
          "754:      if (has_mbyte)",
          "755:      {",
          "756:   c1 = mb_ptr2char(p);",
          "757:   c2 = mb_ptr2char(s);",
          "758:      }",
          "759:      else",
          "760:      {",
          "761:   c1 = *p;",
          "762:   c2 = *s;",
          "763:      }",
          "764:      if ((match->cp_flags & CP_ICASE)",
          "765:         ? (MB_TOLOWER(c1) != MB_TOLOWER(c2)) : (c1 != c2))",
          "766:   break;",
          "767:      if (has_mbyte)",
          "768:      {",
          "769:   MB_PTR_ADV(p);",
          "770:   MB_PTR_ADV(s);",
          "771:      }",
          "772:      else",
          "773:      {",
          "774:   ++p;",
          "775:   ++s;",
          "776:      }",
          "779:  if (*p != NUL)",
          "783:      had_match = (curwin->w_cursor.col > compl_col);",
          "784:      ins_compl_delete();",
          "785:      ins_bytes(compl_leader + ins_compl_len());",
          "786:      ins_redraw(FALSE);",
          "790:      if (!had_match)",
          "791:   ins_compl_delete();",
          "794:  compl_used_match = FALSE;",
          "",
          "[Added Lines]",
          "761:  if (compl_leader == NULL)",
          "762:      return;",
          "764:  had_match = (curwin->w_cursor.col > compl_col);",
          "765:  ins_compl_delete();",
          "766:  ins_bytes(compl_leader + ins_compl_len());",
          "767:  ins_redraw(FALSE);",
          "771:  if (!had_match)",
          "773:  compl_used_match = FALSE;",
          "775:  return;",
          "779:     p = compl_leader;",
          "780:     s = match->cp_str;",
          "781:     while (*p != NUL)",
          "783:  if (has_mbyte)",
          "785:      c1 = mb_ptr2char(p);",
          "786:      c2 = mb_ptr2char(s);",
          "788:  else",
          "790:      c1 = *p;",
          "791:      c2 = *s;",
          "792:  }",
          "793:  if ((match->cp_flags & CP_ICASE)",
          "794:   ? (MB_TOLOWER(c1) != MB_TOLOWER(c2)) : (c1 != c2))",
          "795:      break;",
          "796:  if (has_mbyte)",
          "797:  {",
          "798:      MB_PTR_ADV(p);",
          "799:      MB_PTR_ADV(s);",
          "801:  else",
          "802:  {",
          "803:      ++p;",
          "804:      ++s;",
          "805:  }",
          "806:     }",
          "808:     if (*p != NUL)",
          "809:     {",
          "812:  had_match = (curwin->w_cursor.col > compl_col);",
          "813:  ins_compl_delete();",
          "814:  ins_bytes(compl_leader + ins_compl_len());",
          "815:  ins_redraw(FALSE);",
          "819:  if (!had_match)",
          "820:      ins_compl_delete();",
          "823:     compl_used_match = FALSE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "827:     compl_T *match;",
          "828:     int     count = 0;",
          "831:     {",
          "842:     }",
          "843:     return count;",
          "844: }",
          "",
          "[Removed Lines]",
          "830:     if (compl_first_match != NULL)",
          "833:  match = compl_first_match;",
          "835:  while (match->cp_next != NULL && match->cp_next != compl_first_match)",
          "836:  {",
          "837:      match = match->cp_next;",
          "838:      ++count;",
          "839:  }",
          "840:  match->cp_next = compl_first_match;",
          "841:  compl_first_match->cp_prev = match;",
          "",
          "[Added Lines]",
          "858:     if (compl_first_match == NULL)",
          "859:  return 0;",
          "862:     match = compl_first_match;",
          "864:     while (match->cp_next != NULL && match->cp_next != compl_first_match)",
          "866:  match = match->cp_next;",
          "867:  ++count;",
          "869:     match->cp_next = compl_first_match;",
          "870:     compl_first_match->cp_prev = match;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "892: {",
          "893:     int  h;",
          "903: }",
          "",
          "[Removed Lines]",
          "895:     if (compl_match_array != NULL)",
          "896:     {",
          "897:  h = curwin->w_cline_height;",
          "899:  pum_call_update_screen();",
          "900:  if (h != curwin->w_cline_height)",
          "901:      ins_compl_del_pum();",
          "902:     }",
          "",
          "[Added Lines]",
          "924:     if (compl_match_array == NULL)",
          "925:  return;",
          "927:     h = curwin->w_cline_height;",
          "929:     pum_call_update_screen();",
          "930:     if (h != curwin->w_cline_height)",
          "931:  ins_compl_del_pum();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "908:     static void",
          "909: ins_compl_del_pum(void)",
          "910: {",
          "916: }",
          "",
          "[Removed Lines]",
          "911:     if (compl_match_array != NULL)",
          "912:     {",
          "913:  pum_undisplay();",
          "914:  VIM_CLEAR(compl_match_array);",
          "915:     }",
          "",
          "[Added Lines]",
          "940:     if (compl_match_array == NULL)",
          "941:  return;",
          "943:     pum_undisplay();",
          "944:     VIM_CLEAR(compl_match_array);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "952:     do",
          "953:     {",
          "954:  if (compl == NULL",
          "956:      break;",
          "957:  compl = compl->cp_next;",
          "958:     } while (compl != compl_first_match);",
          "",
          "[Removed Lines]",
          "955:         || ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0 && ++i == 2))",
          "",
          "[Added Lines]",
          "984:         || (!ins_compl_at_original_text(compl) && ++i == 2))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "972: {",
          "973:     dict_T *dict = dict_alloc_lock(VAR_FIXED);",
          "987:     return dict;",
          "988: }",
          "",
          "[Removed Lines]",
          "975:     if (dict != NULL)",
          "976:     {",
          "977:  dict_add_string(dict, \"word\", match->cp_str);",
          "978:  dict_add_string(dict, \"abbr\", match->cp_text[CPT_ABBR]);",
          "979:  dict_add_string(dict, \"menu\", match->cp_text[CPT_MENU]);",
          "980:  dict_add_string(dict, \"kind\", match->cp_text[CPT_KIND]);",
          "981:  dict_add_string(dict, \"info\", match->cp_text[CPT_INFO]);",
          "982:  if (match->cp_user_data.v_type == VAR_UNKNOWN)",
          "983:      dict_add_string(dict, \"user_data\", (char_u *)\"\");",
          "984:  else",
          "985:      dict_add_tv(dict, \"user_data\", &match->cp_user_data);",
          "986:     }",
          "",
          "[Added Lines]",
          "1004:     if (dict == NULL)",
          "1005:  return NULL;",
          "1007:     dict_add_string(dict, \"word\", match->cp_str);",
          "1008:     dict_add_string(dict, \"abbr\", match->cp_text[CPT_ABBR]);",
          "1009:     dict_add_string(dict, \"menu\", match->cp_text[CPT_MENU]);",
          "1010:     dict_add_string(dict, \"kind\", match->cp_text[CPT_KIND]);",
          "1011:     dict_add_string(dict, \"info\", match->cp_text[CPT_INFO]);",
          "1012:     if (match->cp_user_data.v_type == VAR_UNKNOWN)",
          "1013:  dict_add_string(dict, \"user_data\", (char_u *)\"\");",
          "1014:     else",
          "1015:  dict_add_tv(dict, \"user_data\", &match->cp_user_data);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1020: #endif",
          "1028: {",
          "1029:     compl_T     *compl;",
          "1030:     compl_T     *shown_compl = NULL;",
          "",
          "[Removed Lines]",
          "1026:     void",
          "1027: ins_compl_show_pum(void)",
          "",
          "[Added Lines]",
          "1057:     static int",
          "1058: ins_compl_build_pum(void)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1032:     int  shown_match_ok = FALSE;",
          "1033:     int  i;",
          "1034:     int  cur = -1;",
          "1036:     int  lead_len = 0;",
          "1049:     if (compl_match_array == NULL)",
          "1050:     {",
          "1057:  {",
          "1068:  {",
          "1072:   shown_match_ok = TRUE;",
          "1077:      {",
          "1137:     else",
          "1138:     {",
          "",
          "[Removed Lines]",
          "1035:     colnr_T col;",
          "1038:     if (!pum_wanted() || !pum_enough_matches())",
          "1039:  return;",
          "1041: #if defined(FEAT_EVAL)",
          "1043:     do_cmdline_cmd((char_u *)\"if exists('g:loaded_matchparen')|:3match none|endif\");",
          "1044: #endif",
          "1047:     pum_call_update_screen();",
          "1052:  compl_match_arraysize = 0;",
          "1053:  compl = compl_first_match;",
          "1054:  if (compl_leader != NULL)",
          "1055:      lead_len = (int)STRLEN(compl_leader);",
          "1056:  do",
          "1058:      if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0",
          "1059:       && (compl_leader == NULL",
          "1060:    || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1061:   ++compl_match_arraysize;",
          "1062:      compl = compl->cp_next;",
          "1063:  } while (compl != NULL && compl != compl_first_match);",
          "1064:  if (compl_match_arraysize == 0)",
          "1065:      return;",
          "1066:  compl_match_array = ALLOC_CLEAR_MULT(pumitem_T, compl_match_arraysize);",
          "1067:  if (compl_match_array != NULL)",
          "1071:      if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT)",
          "1074:      i = 0;",
          "1075:      compl = compl_first_match;",
          "1076:      do",
          "1078:   if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0",
          "1079:    && (compl_leader == NULL",
          "1080:        || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1081:   {",
          "1082:       if (!shown_match_ok)",
          "1083:       {",
          "1084:    if (compl == compl_shown_match || did_find_shown_match)",
          "1085:    {",
          "1088:        compl_shown_match = compl;",
          "1089:        did_find_shown_match = TRUE;",
          "1090:        shown_match_ok = TRUE;",
          "1091:    }",
          "1092:    else",
          "1095:        shown_compl = compl;",
          "1096:    cur = i;",
          "1097:       }",
          "1099:       if (compl->cp_text[CPT_ABBR] != NULL)",
          "1100:    compl_match_array[i].pum_text =",
          "1101:            compl->cp_text[CPT_ABBR];",
          "1102:       else",
          "1103:    compl_match_array[i].pum_text = compl->cp_str;",
          "1104:       compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];",
          "1105:       compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];",
          "1106:       if (compl->cp_text[CPT_MENU] != NULL)",
          "1107:    compl_match_array[i++].pum_extra =",
          "1108:            compl->cp_text[CPT_MENU];",
          "1109:       else",
          "1110:    compl_match_array[i++].pum_extra = compl->cp_fname;",
          "1111:   }",
          "1113:   if (compl == compl_shown_match)",
          "1114:   {",
          "1115:       did_find_shown_match = TRUE;",
          "1119:       if (compl->cp_flags & CP_ORIGINAL_TEXT)",
          "1120:    shown_match_ok = TRUE;",
          "1122:       if (!shown_match_ok && shown_compl != NULL)",
          "1123:       {",
          "1126:    compl_shown_match = shown_compl;",
          "1127:    shown_match_ok = TRUE;",
          "1128:       }",
          "1129:   }",
          "1130:   compl = compl->cp_next;",
          "1131:      } while (compl != NULL && compl != compl_first_match);",
          "1133:      if (!shown_match_ok)    // no displayed match at all",
          "1134:   cur = -1;",
          "1135:  }",
          "1136:     }",
          "",
          "[Added Lines]",
          "1069:     compl_match_arraysize = 0;",
          "1070:     compl = compl_first_match;",
          "1071:     if (compl_leader != NULL)",
          "1072:  lead_len = (int)STRLEN(compl_leader);",
          "1074:     do",
          "1075:     {",
          "1076:  if (!ins_compl_at_original_text(compl)",
          "1077:   && (compl_leader == NULL",
          "1078:       || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1079:      ++compl_match_arraysize;",
          "1080:  compl = compl->cp_next;",
          "1081:     } while (compl != NULL && compl != compl_first_match);",
          "1083:     if (compl_match_arraysize == 0)",
          "1084:  return -1;",
          "1086:     compl_match_array = ALLOC_CLEAR_MULT(pumitem_T, compl_match_arraysize);",
          "1088:  return -1;",
          "1092:     if (ins_compl_at_original_text(compl_shown_match))",
          "1093:  shown_match_ok = TRUE;",
          "1095:     i = 0;",
          "1096:     compl = compl_first_match;",
          "1097:     do",
          "1099:  if (!ins_compl_at_original_text(compl)",
          "1100:   && (compl_leader == NULL",
          "1101:       || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1103:      if (!shown_match_ok)",
          "1104:      {",
          "1105:   if (compl == compl_shown_match || did_find_shown_match)",
          "1106:   {",
          "1109:       compl_shown_match = compl;",
          "1110:       did_find_shown_match = TRUE;",
          "1111:       shown_match_ok = TRUE;",
          "1112:   }",
          "1113:   else",
          "1116:       shown_compl = compl;",
          "1117:   cur = i;",
          "1118:      }",
          "1120:      if (compl->cp_text[CPT_ABBR] != NULL)",
          "1121:   compl_match_array[i].pum_text =",
          "1122:       compl->cp_text[CPT_ABBR];",
          "1123:      else",
          "1124:   compl_match_array[i].pum_text = compl->cp_str;",
          "1125:      compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];",
          "1126:      compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];",
          "1127:      if (compl->cp_text[CPT_MENU] != NULL)",
          "1128:   compl_match_array[i++].pum_extra =",
          "1129:       compl->cp_text[CPT_MENU];",
          "1130:      else",
          "1131:   compl_match_array[i++].pum_extra = compl->cp_fname;",
          "1132:  }",
          "1134:  if (compl == compl_shown_match)",
          "1136:      did_find_shown_match = TRUE;",
          "1140:      if (ins_compl_at_original_text(compl))",
          "1143:      if (!shown_match_ok && shown_compl != NULL)",
          "1147:   compl_shown_match = shown_compl;",
          "1148:   shown_match_ok = TRUE;",
          "1149:      }",
          "1150:  }",
          "1151:  compl = compl->cp_next;",
          "1152:     } while (compl != NULL && compl != compl_first_match);",
          "1154:     if (!shown_match_ok)    // no displayed match at all",
          "1155:  cur = -1;",
          "1157:     return cur;",
          "1158: }",
          "1164:     void",
          "1165: ins_compl_show_pum(void)",
          "1166: {",
          "1167:     int  i;",
          "1168:     int  cur = -1;",
          "1169:     colnr_T col;",
          "1171:     if (!pum_wanted() || !pum_enough_matches())",
          "1172:  return;",
          "1174: #if defined(FEAT_EVAL)",
          "1176:     do_cmdline_cmd((char_u *)\"if exists('g:loaded_matchparen')|:3match none|endif\");",
          "1177: #endif",
          "1180:     pum_call_update_screen();",
          "1182:     if (compl_match_array == NULL)",
          "1184:  cur = ins_compl_build_pum();",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1147:      }",
          "1148:     }",
          "1163: #ifdef FEAT_EVAL",
          "1166: #endif",
          "1168: }",
          "1170: #define DICT_FIRST (1) // use just first element in \"dict\"",
          "",
          "[Removed Lines]",
          "1150:     if (compl_match_array != NULL)",
          "1151:     {",
          "1154:  dollar_vcol = -1;",
          "1158:  col = curwin->w_cursor.col;",
          "1159:  curwin->w_cursor.col = compl_col;",
          "1160:  pum_display(compl_match_array, compl_match_arraysize, cur);",
          "1161:  curwin->w_cursor.col = col;",
          "1164:  if (has_completechanged())",
          "1165:      trigger_complete_changed_event(cur);",
          "1167:     }",
          "",
          "[Added Lines]",
          "1198:     if (compl_match_array == NULL)",
          "1199:  return;",
          "1203:     dollar_vcol = -1;",
          "1207:     col = curwin->w_cursor.col;",
          "1208:     curwin->w_cursor.col = compl_col;",
          "1209:     pum_display(compl_match_array, compl_match_arraysize, cur);",
          "1210:     curwin->w_cursor.col = col;",
          "1213:     if (has_completechanged())",
          "1214:  trigger_complete_changed_event(cur);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1324:      (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "1325:  }",
          "1328:  {",
          "1333:      {",
          "1336:   {",
          "1346:       {",
          "1382:       }",
          "1392:   }",
          "1395:      }",
          "1397:  }",
          "1398:     }",
          "1399: }",
          "",
          "[Removed Lines]",
          "1327:  if (fp != NULL)",
          "1331:      while (!got_int && !compl_interrupted",
          "1332:          && !vim_fgets(buf, LSIZE, fp))",
          "1334:   ptr = buf;",
          "1335:   while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf)))",
          "1337:       ptr = regmatch->startp[0];",
          "1338:       if (ctrl_x_mode_line_or_eval())",
          "1339:    ptr = find_line_end(ptr);",
          "1340:       else",
          "1341:    ptr = find_word_end(ptr);",
          "1342:       add_r = ins_compl_add_infercase(regmatch->startp[0],",
          "1343:        (int)(ptr - regmatch->startp[0]),",
          "1344:         p_ic, files[i], *dir, FALSE);",
          "1345:       if (thesaurus)",
          "1347:    char_u *wstart;",
          "1350:    ptr = buf;",
          "1351:    while (!got_int)",
          "1352:    {",
          "1355:        ptr = find_word_start(ptr);",
          "1356:        if (*ptr == NUL || *ptr == NL)",
          "1357:     break;",
          "1358:        wstart = ptr;",
          "1361:        if (has_mbyte)",
          "1365:     while (*ptr != NUL)",
          "1366:     {",
          "1367:         int l = (*mb_ptr2len)(ptr);",
          "1369:         if (l < 2 && !vim_iswordc(*ptr))",
          "1370:      break;",
          "1371:         ptr += l;",
          "1372:     }",
          "1373:        else",
          "1374:     ptr = find_word_end(ptr);",
          "1377:        if (wstart != regmatch->startp[0])",
          "1378:     add_r = ins_compl_add_infercase(wstart,",
          "1379:      (int)(ptr - wstart),",
          "1380:      p_ic, files[i], *dir, FALSE);",
          "1381:    }",
          "1383:       if (add_r == OK)",
          "1386:       else if (add_r == FAIL)",
          "1387:    break;",
          "1390:       if (*ptr == '\\n' || got_int)",
          "1391:    break;",
          "1393:   line_breakcheck();",
          "1394:   ins_compl_check_keys(50, FALSE);",
          "1396:      fclose(fp);",
          "",
          "[Added Lines]",
          "1375:  if (fp == NULL)",
          "1376:      continue;",
          "1380:  while (!got_int && !compl_interrupted && !vim_fgets(buf, LSIZE, fp))",
          "1382:      ptr = buf;",
          "1383:      while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf)))",
          "1385:   ptr = regmatch->startp[0];",
          "1386:   if (ctrl_x_mode_line_or_eval())",
          "1387:       ptr = find_line_end(ptr);",
          "1388:   else",
          "1389:       ptr = find_word_end(ptr);",
          "1390:   add_r = ins_compl_add_infercase(regmatch->startp[0],",
          "1391:    (int)(ptr - regmatch->startp[0]),",
          "1392:    p_ic, files[i], *dir, FALSE);",
          "1393:   if (thesaurus)",
          "1395:       char_u *wstart;",
          "1398:       ptr = buf;",
          "1399:       while (!got_int)",
          "1403:    ptr = find_word_start(ptr);",
          "1404:    if (*ptr == NUL || *ptr == NL)",
          "1405:        break;",
          "1406:    wstart = ptr;",
          "1409:    if (has_mbyte)",
          "1413:        while (*ptr != NUL)",
          "1414:        {",
          "1415:     int l = (*mb_ptr2len)(ptr);",
          "1417:     if (l < 2 && !vim_iswordc(*ptr))",
          "1418:         break;",
          "1419:     ptr += l;",
          "1420:        }",
          "1421:    else",
          "1422:        ptr = find_word_end(ptr);",
          "1425:    if (wstart != regmatch->startp[0])",
          "1426:        add_r = ins_compl_add_infercase(wstart,",
          "1427:         (int)(ptr - wstart),",
          "1428:         p_ic, files[i], *dir, FALSE);",
          "1431:   if (add_r == OK)",
          "1434:   else if (add_r == FAIL)",
          "1435:       break;",
          "1438:   if (*ptr == '\\n' || got_int)",
          "1439:       break;",
          "1441:      line_breakcheck();",
          "1442:      ins_compl_check_keys(50, FALSE);",
          "1444:  fclose(fp);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1757:     char_u *p;",
          "1763:     {",
          "1764:  p = vim_strsave(str);",
          "1765:  if (p != NULL)",
          "",
          "[Removed Lines]",
          "1762:     if (compl_first_match->cp_flags & CP_ORIGINAL_TEXT) // safety check",
          "",
          "[Added Lines]",
          "1809:     if (ins_compl_at_original_text(compl_first_match)) // safety check",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1769:  }",
          "1770:     }",
          "1771:     else if (compl_first_match->cp_prev != NULL",
          "1773:     {",
          "1774:        p = vim_strsave(str);",
          "1775:        if (p != NULL)",
          "",
          "[Removed Lines]",
          "1772:      && (compl_first_match->cp_prev->cp_flags & CP_ORIGINAL_TEXT))",
          "",
          "[Added Lines]",
          "1819:      && ins_compl_at_original_text(compl_first_match->cp_prev))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1797:     {",
          "1801:  {",
          "1805:      {",
          "1813:      }",
          "1816:  }",
          "1818:      return;",
          "1819:     }",
          "1820:     p += len;",
          "",
          "[Removed Lines]",
          "1800:  if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT)",
          "1802:      p = NULL;",
          "1803:      for (cp = compl_shown_match->cp_next; cp != NULL",
          "1804:      && cp != compl_first_match; cp = cp->cp_next)",
          "1806:   if (compl_leader == NULL",
          "1807:    || ins_compl_equal(cp, compl_leader,",
          "1808:          (int)STRLEN(compl_leader)))",
          "1809:   {",
          "1810:       p = cp->cp_str;",
          "1811:       break;",
          "1812:   }",
          "1814:      if (p == NULL || (int)STRLEN(p) <= len)",
          "1815:   return;",
          "1817:  else",
          "",
          "[Added Lines]",
          "1847:  if (!ins_compl_at_original_text(compl_shown_match))",
          "1848:      return;",
          "1850:  p = NULL;",
          "1851:  for (cp = compl_shown_match->cp_next; cp != NULL",
          "1852:   && cp != compl_first_match; cp = cp->cp_next)",
          "1854:      if (compl_leader == NULL",
          "1855:       || ins_compl_equal(cp, compl_leader,",
          "1856:    (int)STRLEN(compl_leader)))",
          "1858:   p = cp->cp_str;",
          "1859:   break;",
          "1862:  if (p == NULL || (int)STRLEN(p) <= len)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2860:      match = compl_first_match;",
          "2861:      do",
          "2862:      {",
          "2864:   {",
          "2865:       di = dict_alloc();",
          "2866:       if (di == NULL)",
          "",
          "[Removed Lines]",
          "2863:   if (!(match->cp_flags & CP_ORIGINAL_TEXT))",
          "",
          "[Added Lines]",
          "2908:   if (!ins_compl_at_original_text(match))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2949: };",
          "2971:     static int",
          "2972: process_next_cpt_value(",
          "2974:  int  *compl_type_arg,",
          "2983: {",
          "2985:     int     compl_type = -1;",
          "2986:     int     status = INS_COMPL_CPT_OK;",
          "2996:     {",
          "3002:  {",
          "3009:  }",
          "3011:  compl_type = 0;",
          "3016:     }",
          "3019:     {",
          "3022:  {",
          "3023:      compl_started = TRUE;",
          "3027:      compl_type = 0;",
          "3028:  }",
          "3029:  else // unloaded buffer, scan like dictionary",
          "3030:  {",
          "3033:      {",
          "3034:   status = INS_COMPL_CPT_CONT;",
          "3035:   goto done;",
          "3036:      }",
          "3037:      compl_type = CTRL_X_DICTIONARY;",
          "3040:  }",
          "3041:  msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3042:  vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),",
          "3048:  (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "3049:     }",
          "3051:  status = INS_COMPL_CPT_END;",
          "3052:     else",
          "3053:     {",
          "3054:  if (ctrl_x_mode_line_or_eval())",
          "3055:      compl_type = -1;",
          "3057:  {",
          "3059:   compl_type = CTRL_X_DICTIONARY;",
          "3060:      else",
          "3061:   compl_type = CTRL_X_THESAURUS;",
          "3063:      {",
          "3066:      }",
          "3067:  }",
          "3068: #ifdef FEAT_FIND_ID",
          "3070:      compl_type = CTRL_X_PATH_PATTERNS;",
          "3072:      compl_type = CTRL_X_PATH_DEFINES;",
          "3073: #endif",
          "3075:  {",
          "3076:      msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3077:      compl_type = CTRL_X_TAGS;",
          "",
          "[Removed Lines]",
          "2973:  char_u  **e_cpt_arg,",
          "2975:  int  *found_all_arg,",
          "2976:  buf_T  **buf_arg,",
          "2977:  pos_T  *start_match_pos,",
          "2978:  pos_T  *first_match_pos,",
          "2979:  pos_T  *last_match_pos,",
          "2980:  int  *set_match_pos,",
          "2981:  char_u  **dict_arg,",
          "2982:  int  *dict_flag)",
          "2984:     char_u  *e_cpt = *e_cpt_arg;",
          "2987:     buf_T   *buf = *buf_arg;",
          "2988:     int     found_all = FALSE;",
          "2989:     char_u  *dict = NULL;",
          "2990:     int     dict_f = 0;",
          "2992:     while (*e_cpt == ',' || *e_cpt == ' ')",
          "2993:  e_cpt++;",
          "2995:     if (*e_cpt == '.' && !curbuf->b_scanned)",
          "2997:  buf = curbuf;",
          "3001:  if (ctrl_x_mode == CTRL_X_NORMAL && dec(first_match_pos) < 0)",
          "3006:      first_match_pos->lnum = buf->b_ml.ml_line_count;",
          "3007:      first_match_pos->col =",
          "3008:   (colnr_T)STRLEN(ml_get(first_match_pos->lnum));",
          "3017:     else if (vim_strchr((char_u *)\"buwU\", *e_cpt) != NULL",
          "3018:      && (buf = ins_compl_next_buf(buf, *e_cpt)) != curbuf)",
          "3021:  if (buf->b_ml.ml_mfp != NULL)   // loaded buffer",
          "3024:      first_match_pos->col = last_match_pos->col = 0;",
          "3025:      first_match_pos->lnum = buf->b_ml.ml_line_count + 1;",
          "3026:      last_match_pos->lnum = 0;",
          "3031:      found_all = TRUE;",
          "3032:      if (buf->b_fname == NULL)",
          "3038:      dict = buf->b_fname;",
          "3039:      dict_f = DICT_EXACT;",
          "3043:   buf->b_fname == NULL",
          "3044:       ? buf_spname(buf)",
          "3045:       : buf->b_sfname == NULL",
          "3046:    ? buf->b_fname",
          "3047:    : buf->b_sfname);",
          "3050:     else if (*e_cpt == NUL)",
          "3056:  else if (*e_cpt == 'k' || *e_cpt == 's')",
          "3058:      if (*e_cpt == 'k')",
          "3062:      if (*++e_cpt != ',' && *e_cpt != NUL)",
          "3064:   dict = e_cpt;",
          "3065:   dict_f = DICT_FIRST;",
          "3069:  else if (*e_cpt == 'i')",
          "3071:  else if (*e_cpt == 'd')",
          "3074:  else if (*e_cpt == ']' || *e_cpt == 't')",
          "",
          "[Added Lines]",
          "3000: typedef struct",
          "3001: {",
          "3002:     char_u *e_cpt;   // current entry in 'complete'",
          "3003:     buf_T *ins_buf;  // buffer being scanned",
          "3004:     pos_T *cur_match_pos;   // current match position",
          "3005:     pos_T prev_match_pos;  // previous match position",
          "3006:     int  set_match_pos;  // save first_match_pos/last_match_pos",
          "3007:     pos_T first_match_pos; // first match position",
          "3008:     pos_T last_match_pos;  // last match position",
          "3009:     int  found_all;  // found all matches of a certain type.",
          "3010:     char_u *dict;   // dictionary file to search",
          "3011:     int  dict_f;   // \"dict\" is an exact file name or not",
          "3012: } ins_compl_next_state_T;",
          "3036:  ins_compl_next_state_T *st,",
          "3038:  pos_T  *start_match_pos)",
          "3043:     st->found_all = FALSE;",
          "3045:     while (*st->e_cpt == ',' || *st->e_cpt == ' ')",
          "3046:  st->e_cpt++;",
          "3048:     if (*st->e_cpt == '.' && !curbuf->b_scanned)",
          "3050:  st->ins_buf = curbuf;",
          "3051:  st->first_match_pos = *start_match_pos;",
          "3054:  if (ctrl_x_mode == CTRL_X_NORMAL && dec(&st->first_match_pos) < 0)",
          "3059:      st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count;",
          "3060:      st->first_match_pos.col =",
          "3061:   (colnr_T)STRLEN(ml_get(st->first_match_pos.lnum));",
          "3063:  st->last_match_pos = st->first_match_pos;",
          "3068:  st->set_match_pos = TRUE;",
          "3070:     else if (vim_strchr((char_u *)\"buwU\", *st->e_cpt) != NULL",
          "3071:      && (st->ins_buf = ins_compl_next_buf(st->ins_buf, *st->e_cpt)) != curbuf)",
          "3074:  if (st->ins_buf->b_ml.ml_mfp != NULL)   // loaded buffer",
          "3077:      st->first_match_pos.col = st->last_match_pos.col = 0;",
          "3078:      st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count + 1;",
          "3079:      st->last_match_pos.lnum = 0;",
          "3084:      st->found_all = TRUE;",
          "3085:      if (st->ins_buf->b_fname == NULL)",
          "3091:      st->dict = st->ins_buf->b_fname;",
          "3092:      st->dict_f = DICT_EXACT;",
          "3096:   st->ins_buf->b_fname == NULL",
          "3097:       ? buf_spname(st->ins_buf)",
          "3098:       : st->ins_buf->b_sfname == NULL",
          "3099:    ? st->ins_buf->b_fname",
          "3100:    : st->ins_buf->b_sfname);",
          "3103:     else if (*st->e_cpt == NUL)",
          "3109:  else if (*st->e_cpt == 'k' || *st->e_cpt == 's')",
          "3111:      if (*st->e_cpt == 'k')",
          "3115:      if (*++st->e_cpt != ',' && *st->e_cpt != NUL)",
          "3117:   st->dict = st->e_cpt;",
          "3118:   st->dict_f = DICT_FIRST;",
          "3122:  else if (*st->e_cpt == 'i')",
          "3124:  else if (*st->e_cpt == 'd')",
          "3127:  else if (*st->e_cpt == ']' || *st->e_cpt == 't')",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3082:      compl_type = -1;",
          "3088:  if (compl_type == -1)",
          "3089:      status = INS_COMPL_CPT_CONT;",
          "3090:     }",
          "3092: done:",
          "3099:     return status;",
          "3100: }",
          "",
          "[Removed Lines]",
          "3085:  (void)copy_option_part(&e_cpt, IObuff, IOSIZE, \",\");",
          "3087:  found_all = TRUE;",
          "",
          "[Added Lines]",
          "3138:  (void)copy_option_part(&st->e_cpt, IObuff, IOSIZE, \",\");",
          "3140:  st->found_all = TRUE;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3123:     static void",
          "3125: {",
          "3126: #ifdef FEAT_COMPL_FUNC",
          "3127:     if (thesaurus_func_complete(compl_type))",
          "",
          "[Removed Lines]",
          "3124: get_next_dict_tsr_completion(int compl_type, char_u **dict, int dict_f)",
          "",
          "[Added Lines]",
          "3172: get_next_dict_tsr_completion(int compl_type, char_u *dict, int dict_f)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3129:     else",
          "3130: #endif",
          "3131:  ins_compl_dictionaries(",
          "3133:   : (compl_type == CTRL_X_THESAURUS",
          "3134:       ? (*curbuf->b_p_tsr == NUL ? p_tsr : curbuf->b_p_tsr)",
          "3135:       : (*curbuf->b_p_dict == NUL ? p_dict : curbuf->b_p_dict)),",
          "3136:   compl_pattern,",
          "3138:   compl_type == CTRL_X_THESAURUS);",
          "3140: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3180:   dict != NULL ? dict",
          "3185:   dict != NULL ? dict_f : 0,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3343:     static int",
          "3353: {",
          "3354:     int  found_new_match = FAIL;",
          "3355:     int  save_p_scs;",
          "",
          "[Removed Lines]",
          "3344: get_next_default_completion(",
          "3345:  buf_T *ins_buf,  // buffer being scanned",
          "3346:  pos_T *start_pos,  // search start position",
          "3347:  pos_T *cur_match_pos,  // current match position",
          "3348:  pos_T *prev_match_pos, // previous match position",
          "3349:  int *save_match_pos, // set first_match_pos/last_match_pos",
          "3350:  pos_T *first_match_pos, // first match position",
          "3351:  pos_T *last_match_pos, // last match position",
          "3352:  int scan_curbuf)  // scan current buffer for completion",
          "",
          "[Added Lines]",
          "3392: get_next_default_completion(ins_compl_next_state_T *st, pos_T *start_pos)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3362:     save_p_scs = p_scs;",
          "3364:  p_scs = FALSE;",
          "",
          "[Removed Lines]",
          "3363:     if (ins_buf->b_p_inf)",
          "",
          "[Added Lines]",
          "3403:     if (st->ins_buf->b_p_inf)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3370:     save_p_ws = p_ws;",
          "3372:  p_ws = FALSE;",
          "3374:  p_ws = TRUE;",
          "3375:     looped_around = FALSE;",
          "3376:     for (;;)",
          "",
          "[Removed Lines]",
          "3371:     if (ins_buf != curbuf)",
          "3373:     else if (scan_curbuf)",
          "",
          "[Added Lines]",
          "3411:     if (st->ins_buf != curbuf)",
          "3413:     else if (*st->e_cpt == '.')",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3384:  if (ctrl_x_mode_line_or_eval()",
          "3385:   || (compl_cont_status & CONT_SOL))",
          "3388:  else",
          "3393:  --msg_silent;",
          "3395:  {",
          "3397:      compl_started = TRUE;",
          "3401:  }",
          "3404:  {",
          "3405:      found_new_match = FAIL;",
          "3406:  }",
          "3407:  else if ((compl_direction == FORWARD)",
          "3411:  {",
          "3412:      if (looped_around)",
          "3413:   found_new_match = FAIL;",
          "",
          "[Removed Lines]",
          "3386:      found_new_match = search_for_exact_line(ins_buf, cur_match_pos,",
          "3387:       compl_direction, compl_pattern);",
          "3389:      found_new_match = searchit(NULL, ins_buf, cur_match_pos, NULL,",
          "3390:       compl_direction,",
          "3391:       compl_pattern, 1L, SEARCH_KEEP + SEARCH_NFMSG,",
          "3392:       RE_LAST, NULL);",
          "3394:  if (!compl_started || *save_match_pos)",
          "3402:  else if (first_match_pos->lnum == last_match_pos->lnum",
          "3403:   && first_match_pos->col == last_match_pos->col)",
          "3408:   && (prev_match_pos->lnum > cur_match_pos->lnum",
          "3409:       || (prev_match_pos->lnum == cur_match_pos->lnum",
          "3410:    && prev_match_pos->col >= cur_match_pos->col)))",
          "",
          "[Added Lines]",
          "3426:      found_new_match = search_for_exact_line(st->ins_buf,",
          "3427:        st->cur_match_pos, compl_direction, compl_pattern);",
          "3429:      found_new_match = searchit(NULL, st->ins_buf, st->cur_match_pos,",
          "3430:     NULL, compl_direction, compl_pattern, 1L,",
          "3431:     SEARCH_KEEP + SEARCH_NFMSG, RE_LAST, NULL);",
          "3433:  if (!compl_started || st->set_match_pos)",
          "3437:      st->first_match_pos = *st->cur_match_pos;",
          "3438:      st->last_match_pos = *st->cur_match_pos;",
          "3439:      st->set_match_pos = FALSE;",
          "3441:  else if (st->first_match_pos.lnum == st->last_match_pos.lnum",
          "3442:   && st->first_match_pos.col == st->last_match_pos.col)",
          "3447:   && (st->prev_match_pos.lnum > st->cur_match_pos->lnum",
          "3448:       || (st->prev_match_pos.lnum == st->cur_match_pos->lnum",
          "3449:    && st->prev_match_pos.col >= st->cur_match_pos->col)))",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3415:   looped_around = TRUE;",
          "3416:  }",
          "3417:  else if ((compl_direction != FORWARD)",
          "3421:  {",
          "3422:      if (looped_around)",
          "3423:   found_new_match = FAIL;",
          "3424:      else",
          "3425:   looped_around = TRUE;",
          "3426:  }",
          "3428:  if (found_new_match == FAIL)",
          "3429:      break;",
          "3435:      continue;",
          "3439:  if (ptr == NULL)",
          "3440:      continue;",
          "3442:  if (ins_compl_add_infercase(ptr, len, p_ic,",
          "3444:       0, cont_s_ipos) != NOTDONE)",
          "3445:  {",
          "3446:      found_new_match = OK;",
          "",
          "[Removed Lines]",
          "3418:   && (prev_match_pos->lnum < cur_match_pos->lnum",
          "3419:       || (prev_match_pos->lnum == cur_match_pos->lnum",
          "3420:    && prev_match_pos->col <= cur_match_pos->col)))",
          "3432:  if ((compl_cont_status & CONT_ADDING) && ins_buf == curbuf",
          "3433:   && start_pos->lnum == cur_match_pos->lnum",
          "3434:   && start_pos->col  == cur_match_pos->col)",
          "3437:  ptr = ins_comp_get_next_word_or_line(ins_buf, cur_match_pos, &len,",
          "3438:        &cont_s_ipos);",
          "3443:       ins_buf == curbuf ? NULL : ins_buf->b_sfname,",
          "",
          "[Added Lines]",
          "3457:   && (st->prev_match_pos.lnum < st->cur_match_pos->lnum",
          "3458:       || (st->prev_match_pos.lnum == st->cur_match_pos->lnum",
          "3459:    && st->prev_match_pos.col <= st->cur_match_pos->col)))",
          "3466:  st->prev_match_pos = *st->cur_match_pos;",
          "3471:  if ((compl_cont_status & CONT_ADDING) && st->ins_buf == curbuf",
          "3472:   && start_pos->lnum == st->cur_match_pos->lnum",
          "3473:   && start_pos->col  == st->cur_match_pos->col)",
          "3476:  ptr = ins_comp_get_next_word_or_line(st->ins_buf, st->cur_match_pos,",
          "3477:        &len, &cont_s_ipos);",
          "3482:       st->ins_buf == curbuf ? NULL : st->ins_buf->b_sfname,",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3453:     return found_new_match;",
          "3454: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3499:     static int",
          "3500: get_next_completion_match(int type, ins_compl_next_state_T *st, pos_T *ini)",
          "3501: {",
          "3502:     int found_new_match = FALSE;",
          "3504:     switch (type)",
          "3505:     {",
          "3506:  case -1:",
          "3507:      break;",
          "3508: #ifdef FEAT_FIND_ID",
          "3509:  case CTRL_X_PATH_PATTERNS:",
          "3510:  case CTRL_X_PATH_DEFINES:",
          "3511:      get_next_include_file_completion(type);",
          "3512:      break;",
          "3513: #endif",
          "3515:  case CTRL_X_DICTIONARY:",
          "3516:  case CTRL_X_THESAURUS:",
          "3517:      get_next_dict_tsr_completion(type, st->dict, st->dict_f);",
          "3518:      st->dict = NULL;",
          "3519:      break;",
          "3521:  case CTRL_X_TAGS:",
          "3522:      get_next_tag_completion();",
          "3523:      break;",
          "3525:  case CTRL_X_FILES:",
          "3526:      get_next_filename_completion();",
          "3527:      break;",
          "3529:  case CTRL_X_CMDLINE:",
          "3530:  case CTRL_X_CMDLINE_CTRL_X:",
          "3531:      get_next_cmdline_completion();",
          "3532:      break;",
          "3534: #ifdef FEAT_COMPL_FUNC",
          "3535:  case CTRL_X_FUNCTION:",
          "3536:  case CTRL_X_OMNI:",
          "3537:      expand_by_function(type, compl_pattern);",
          "3538:      break;",
          "3539: #endif",
          "3541:  case CTRL_X_SPELL:",
          "3542:      get_next_spell_completion(st->first_match_pos.lnum);",
          "3543:      break;",
          "3545:  default: // normal ^P/^N and ^X^L",
          "3546:      found_new_match = get_next_default_completion(st, ini);",
          "3547:      if (found_new_match == FAIL && st->ins_buf == curbuf)",
          "3548:   st->found_all = TRUE;",
          "3549:     }",
          "3553:     if (type != 0 && compl_curr_match != compl_old_match)",
          "3554:  found_new_match = OK;",
          "3556:     return found_new_match;",
          "3557: }",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3465:     static int",
          "3466: ins_compl_get_exp(pos_T *ini)",
          "3467: {",
          "3476:     int  i;",
          "3477:     int  found_new_match;",
          "3478:     int  type = ctrl_x_mode;",
          "3484:     if (!compl_started)",
          "3485:     {",
          "3491:          ? (char_u *)\".\" : curbuf->b_p_cpt;",
          "3493:     }",
          "3497:     compl_old_match = compl_curr_match; // remember the last current match",
          "3501:     for (;;)",
          "3502:     {",
          "3503:  found_new_match = FAIL;",
          "3509:  if ((ctrl_x_mode == CTRL_X_NORMAL",
          "3510:       || ctrl_x_mode_line_or_eval())",
          "3512:  {",
          "3517:      if (status == INS_COMPL_CPT_END)",
          "3518:   break;",
          "",
          "[Removed Lines]",
          "3468:     static pos_T first_match_pos;",
          "3469:     static pos_T last_match_pos;",
          "3470:     static char_u *e_cpt = (char_u *)\"\"; // curr. entry in 'complete'",
          "3471:     static int  found_all = FALSE; // Found all matches of a",
          "3473:     static buf_T *ins_buf = NULL; // buffer being scanned",
          "3475:     pos_T *pos;",
          "3479:     char_u *dict = NULL;",
          "3480:     int  dict_f = 0;",
          "3481:     int  set_match_pos;",
          "3482:     pos_T prev_pos = {0, 0, 0};",
          "3486:  FOR_ALL_BUFFERS(ins_buf)",
          "3487:      ins_buf->b_scanned = 0;",
          "3488:  found_all = FALSE;",
          "3489:  ins_buf = curbuf;",
          "3490:  e_cpt = (compl_cont_status & CONT_LOCAL)",
          "3492:  last_match_pos = first_match_pos = *ini;",
          "3494:     else if (ins_buf != curbuf && !buf_valid(ins_buf))",
          "3495:  ins_buf = curbuf;  // In case the buffer was wiped out.",
          "3498:     pos = (compl_direction == FORWARD) ? &last_match_pos : &first_match_pos;",
          "3504:  set_match_pos = FALSE;",
          "3511:      && (!compl_started || found_all))",
          "3513:      int status = process_next_cpt_value(&e_cpt, &type, &found_all,",
          "3514:       &ins_buf, ini, &first_match_pos, &last_match_pos,",
          "3515:       &set_match_pos, &dict, &dict_f);",
          "",
          "[Added Lines]",
          "3571:     static ins_compl_next_state_T st;",
          "3578:  FOR_ALL_BUFFERS(st.ins_buf)",
          "3579:      st.ins_buf->b_scanned = 0;",
          "3580:  st.found_all = FALSE;",
          "3581:  st.ins_buf = curbuf;",
          "3582:  st.e_cpt = (compl_cont_status & CONT_LOCAL)",
          "3584:  st.last_match_pos = st.first_match_pos = *ini;",
          "3586:     else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))",
          "3587:  st.ins_buf = curbuf;  // In case the buffer was wiped out.",
          "3590:     st.cur_match_pos = (compl_direction == FORWARD)",
          "3591:     ? &st.last_match_pos : &st.first_match_pos;",
          "3597:  st.set_match_pos = FALSE;",
          "3604:      && (!compl_started || st.found_all))",
          "3606:      int status = process_next_cpt_value(&st, &type, ini);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3525:  if (compl_pattern == NULL)",
          "3526:      break;",
          "",
          "[Removed Lines]",
          "3528:  switch (type)",
          "3529:  {",
          "3530:  case -1:",
          "3531:      break;",
          "3532: #ifdef FEAT_FIND_ID",
          "3533:  case CTRL_X_PATH_PATTERNS:",
          "3534:  case CTRL_X_PATH_DEFINES:",
          "3535:      get_next_include_file_completion(type);",
          "3536:      break;",
          "3537: #endif",
          "3539:  case CTRL_X_DICTIONARY:",
          "3540:  case CTRL_X_THESAURUS:",
          "3541:      get_next_dict_tsr_completion(type, &dict, dict_f);",
          "3542:      break;",
          "3544:  case CTRL_X_TAGS:",
          "3545:      get_next_tag_completion();",
          "3546:      break;",
          "3548:  case CTRL_X_FILES:",
          "3549:      get_next_filename_completion();",
          "3550:      break;",
          "3552:  case CTRL_X_CMDLINE:",
          "3553:  case CTRL_X_CMDLINE_CTRL_X:",
          "3554:      get_next_cmdline_completion();",
          "3555:      break;",
          "3557: #ifdef FEAT_COMPL_FUNC",
          "3558:  case CTRL_X_FUNCTION:",
          "3559:  case CTRL_X_OMNI:",
          "3560:      expand_by_function(type, compl_pattern);",
          "3561:      break;",
          "3562: #endif",
          "3564:  case CTRL_X_SPELL:",
          "3565:      get_next_spell_completion(first_match_pos.lnum);",
          "3566:      break;",
          "3568:  default: // normal ^P/^N and ^X^L",
          "3569:      found_new_match = get_next_default_completion(ins_buf, ini, pos,",
          "3570:       &prev_pos, &set_match_pos, &first_match_pos,",
          "3571:       &last_match_pos, (*e_cpt == '.'));",
          "3572:      if (found_new_match == FAIL && ins_buf == curbuf)",
          "3573:   found_all = TRUE;",
          "3574:  }",
          "3578:  if (type != 0 && compl_curr_match != compl_old_match)",
          "3579:      found_new_match = OK;",
          "",
          "[Added Lines]",
          "3620:  found_new_match = get_next_completion_match(type, &st, ini);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3599:  {",
          "3601:      if (type == 0 || type == CTRL_X_PATH_PATTERNS)",
          "3604:      compl_started = FALSE;",
          "3605:  }",
          "",
          "[Removed Lines]",
          "3602:   ins_buf->b_scanned = TRUE;",
          "",
          "[Added Lines]",
          "3643:   st.ins_buf->b_scanned = TRUE;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3607:     compl_started = TRUE;",
          "3609:     if ((ctrl_x_mode == CTRL_X_NORMAL || ctrl_x_mode_line_or_eval())",
          "3611:  found_new_match = FAIL;",
          "3613:     i = -1;  // total of matches, unknown",
          "",
          "[Removed Lines]",
          "3610:      && *e_cpt == NUL)  // Got to end of 'complete'",
          "",
          "[Added Lines]",
          "3651:      && *st.e_cpt == NUL)  // Got to end of 'complete'",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3700:     if (compl_len < (int)STRLEN(compl_shown_match->cp_str))",
          "3701:  ins_bytes(compl_shown_match->cp_str + compl_len);",
          "3703:  compl_used_match = FALSE;",
          "3704:     else",
          "3705:  compl_used_match = TRUE;",
          "",
          "[Removed Lines]",
          "3702:     if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT)",
          "",
          "[Added Lines]",
          "3743:     if (ins_compl_at_original_text(compl_shown_match))",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3832:      }",
          "3833:      found_end = FALSE;",
          "3834:  }",
          "3836:   && compl_leader != NULL",
          "3837:   && !ins_compl_equal(compl_shown_match,",
          "3838:       compl_leader, (int)STRLEN(compl_leader)))",
          "",
          "[Removed Lines]",
          "3835:  if ((compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0",
          "",
          "[Added Lines]",
          "3876:  if (!ins_compl_at_original_text(compl_shown_match)",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3891:  return -1;",
          "3893:     if (compl_leader != NULL",
          "3896:  ins_compl_update_shown_match();",
          "",
          "[Removed Lines]",
          "3894:         && (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0)",
          "",
          "[Added Lines]",
          "3935:         && !ins_compl_at_original_text(compl_shown_match))",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "4662:     if (edit_submode_extra == NULL)",
          "4663:     {",
          "4665:  {",
          "4666:      edit_submode_extra = (char_u *)_(\"Back at original\");",
          "4667:      edit_submode_highl = HLF_W;",
          "",
          "[Removed Lines]",
          "4664:  if (compl_curr_match->cp_flags & CP_ORIGINAL_TEXT)",
          "",
          "[Added Lines]",
          "4705:  if (ins_compl_at_original_text(compl_curr_match))",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3952,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3953,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
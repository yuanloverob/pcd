{
  "cve_id": "CVE-2017-7533",
  "cve_desc": "Race condition in the fsnotify implementation in the Linux kernel through 4.12.4 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted application that leverages simultaneous execution of the inotify_handle_event and vfs_rename functions.",
  "repo": "torvalds/linux",
  "patch_hash": "49d31c2f389acfe83417083e1208422b4091cd9e",
  "patch_info": {
    "commit_hash": "49d31c2f389acfe83417083e1208422b4091cd9e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e",
    "files": [
      "fs/dcache.c",
      "fs/debugfs/inode.c",
      "fs/namei.c",
      "fs/notify/fsnotify.c",
      "include/linux/dcache.h",
      "include/linux/fsnotify.h"
    ],
    "message": "dentry name snapshots\n\ntake_dentry_name_snapshot() takes a safe snapshot of dentry name;\nif the name is a short one, it gets copied into caller-supplied\nstructure, otherwise an extra reference to external name is grabbed\n(those are never modified).  In either case the pointer to stable\nstring is stored into the same structure.\n\ndentry must be held by the caller of take_dentry_name_snapshot(),\nbut may be freely dropped afterwards - the snapshot will stay\nuntil destroyed by release_dentry_name_snapshot().\n\nIntended use:\n\tstruct name_snapshot s;\n\n\ttake_dentry_name_snapshot(&s, dentry);\n\t...\n\taccess s.name\n\t...\n\trelease_dentry_name_snapshot(&s);\n\nReplaces fsnotify_oldname_...(), gets used in fsnotify to obtain the name\nto pass down with event.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "fs/dcache.c||fs/dcache.c",
      "fs/debugfs/inode.c||fs/debugfs/inode.c",
      "fs/namei.c||fs/namei.c",
      "fs/notify/fsnotify.c||fs/notify/fsnotify.c",
      "include/linux/dcache.h||include/linux/dcache.h",
      "include/linux/fsnotify.h||include/linux/fsnotify.h"
    ]
  },
  "patch_diff": {
    "fs/dcache.c||fs/dcache.c": [
      "File: fs/dcache.c -> fs/dcache.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "277:  return dentry->d_name.name != dentry->d_iname;",
      "278: }",
      "280: static inline void __d_set_inode_and_type(struct dentry *dentry,",
      "281:        struct inode *inode,",
      "282:        unsigned type_flags)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "280: void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)",
      "281: {",
      "282:  spin_lock(&dentry->d_lock);",
      "283:  if (unlikely(dname_external(dentry))) {",
      "284:   struct external_name *p = external_name(dentry);",
      "285:   atomic_inc(&p->u.count);",
      "286:   spin_unlock(&dentry->d_lock);",
      "287:   name->name = p->name;",
      "288:  } else {",
      "289:   memcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);",
      "290:   spin_unlock(&dentry->d_lock);",
      "291:   name->name = name->inline_name;",
      "292:  }",
      "293: }",
      "294: EXPORT_SYMBOL(take_dentry_name_snapshot);",
      "296: void release_dentry_name_snapshot(struct name_snapshot *name)",
      "297: {",
      "298:  if (unlikely(name->name != name->inline_name)) {",
      "299:   struct external_name *p;",
      "300:   p = container_of(name->name, struct external_name, name[0]);",
      "301:   if (unlikely(atomic_dec_and_test(&p->u.count)))",
      "302:    kfree_rcu(p, u.head);",
      "303:  }",
      "304: }",
      "305: EXPORT_SYMBOL(release_dentry_name_snapshot);",
      "",
      "---------------"
    ],
    "fs/debugfs/inode.c||fs/debugfs/inode.c": [
      "File: fs/debugfs/inode.c -> fs/debugfs/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "766: {",
      "767:  int error;",
      "768:  struct dentry *dentry = NULL, *trap;",
      "771:  trap = lock_rename(new_dir, old_dir);",
      "",
      "[Removed Lines]",
      "769:  const char *old_name;",
      "",
      "[Added Lines]",
      "769:  struct name_snapshot old_name;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "781:  if (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))",
      "782:   goto exit;",
      "786:  error = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),",
      "787:          dentry, 0);",
      "788:  if (error) {",
      "790:   goto exit;",
      "791:  }",
      "792:  d_move(old_dentry, dentry);",
      "794:   d_is_dir(old_dentry),",
      "795:   NULL, old_dentry);",
      "797:  unlock_rename(new_dir, old_dir);",
      "798:  dput(dentry);",
      "799:  return old_dentry;",
      "",
      "[Removed Lines]",
      "784:  old_name = fsnotify_oldname_init(old_dentry->d_name.name);",
      "789:   fsnotify_oldname_free(old_name);",
      "793:  fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,",
      "796:  fsnotify_oldname_free(old_name);",
      "",
      "[Added Lines]",
      "784:  take_dentry_name_snapshot(&old_name, old_dentry);",
      "789:   release_dentry_name_snapshot(&old_name);",
      "793:  fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,",
      "796:  release_dentry_name_snapshot(&old_name);",
      "",
      "---------------"
    ],
    "fs/namei.c||fs/namei.c": [
      "File: fs/namei.c -> fs/namei.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4362: {",
      "4363:  int error;",
      "4364:  bool is_dir = d_is_dir(old_dentry);",
      "4366:  struct inode *source = old_dentry->d_inode;",
      "4367:  struct inode *target = new_dentry->d_inode;",
      "4368:  bool new_is_dir = false;",
      "4369:  unsigned max_links = new_dir->i_sb->s_max_links;",
      "4371:  if (source == target)",
      "4372:   return 0;",
      "",
      "[Removed Lines]",
      "4365:  const unsigned char *old_name;",
      "",
      "[Added Lines]",
      "4369:  struct name_snapshot old_name;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4413:  if (error)",
      "4414:   return error;",
      "4417:  dget(new_dentry);",
      "4418:  if (!is_dir || (flags & RENAME_EXCHANGE))",
      "4419:   lock_two_nondirectories(source, target);",
      "",
      "[Removed Lines]",
      "4416:  old_name = fsnotify_oldname_init(old_dentry->d_name.name);",
      "",
      "[Added Lines]",
      "4416:  take_dentry_name_snapshot(&old_name, old_dentry);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4468:   inode_unlock(target);",
      "4469:  dput(new_dentry);",
      "4470:  if (!error) {",
      "4472:          !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);",
      "4473:   if (flags & RENAME_EXCHANGE) {",
      "4474:    fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,",
      "4475:           new_is_dir, NULL, new_dentry);",
      "4476:   }",
      "4477:  }",
      "4480:  return error;",
      "4481: }",
      "",
      "[Removed Lines]",
      "4471:   fsnotify_move(old_dir, new_dir, old_name, is_dir,",
      "4478:  fsnotify_oldname_free(old_name);",
      "",
      "[Added Lines]",
      "4471:   fsnotify_move(old_dir, new_dir, old_name.name, is_dir,",
      "4478:  release_dentry_name_snapshot(&old_name);",
      "",
      "---------------"
    ],
    "fs/notify/fsnotify.c||fs/notify/fsnotify.c": [
      "File: fs/notify/fsnotify.c -> fs/notify/fsnotify.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "161:  if (unlikely(!fsnotify_inode_watches_children(p_inode)))",
      "162:   __fsnotify_update_child_dentry_flags(p_inode);",
      "163:  else if (p_inode->i_fsnotify_mask & mask) {",
      "166:   mask |= FS_EVENT_ON_CHILD;",
      "168:   if (path)",
      "169:    ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,",
      "171:   else",
      "172:    ret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,",
      "174:  }",
      "176:  dput(parent);",
      "",
      "[Removed Lines]",
      "170:            dentry->d_name.name, 0);",
      "173:            dentry->d_name.name, 0);",
      "",
      "[Added Lines]",
      "164:   struct name_snapshot name;",
      "170:   take_dentry_name_snapshot(&name, dentry);",
      "173:            name.name, 0);",
      "176:            name.name, 0);",
      "177:   release_dentry_name_snapshot(&name);",
      "",
      "---------------"
    ],
    "include/linux/dcache.h||include/linux/dcache.h": [
      "File: include/linux/dcache.h -> include/linux/dcache.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "591:  return d_backing_inode(d_real((struct dentry *) dentry, NULL, 0));",
      "592: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "594: struct name_snapshot {",
      "595:  const char *name;",
      "596:  char inline_name[DNAME_INLINE_LEN];",
      "597: };",
      "598: void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);",
      "599: void release_dentry_name_snapshot(struct name_snapshot *);",
      "",
      "---------------"
    ],
    "include/linux/fsnotify.h||include/linux/fsnotify.h": [
      "File: include/linux/fsnotify.h -> include/linux/fsnotify.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "293:  }",
      "294: }",
      "",
      "[Removed Lines]",
      "301: static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)",
      "302: {",
      "303:  return kstrdup(name, GFP_KERNEL);",
      "304: }",
      "309: static inline void fsnotify_oldname_free(const unsigned char *old_name)",
      "310: {",
      "311:  kfree(old_name);",
      "312: }",
      "316: static inline const char *fsnotify_oldname_init(const unsigned char *name)",
      "317: {",
      "318:  return NULL;",
      "319: }",
      "321: static inline void fsnotify_oldname_free(const unsigned char *old_name)",
      "322: {",
      "323: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f1782c9bc547754f4bd3043fe8cfda53db85f13f",
      "candidate_info": {
        "commit_hash": "f1782c9bc547754f4bd3043fe8cfda53db85f13f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f1782c9bc547754f4bd3043fe8cfda53db85f13f",
        "files": [
          "fs/dcache.c"
        ],
        "message": "dcache: account external names as indirectly reclaimable memory\n\nI received a report about suspicious growth of unreclaimable slabs on\nsome machines.  I've found that it happens on machines with low memory\npressure, and these unreclaimable slabs are external names attached to\ndentries.\n\nExternal names are allocated using generic kmalloc() function, so they\nare accounted as unreclaimable.  But they are held by dentries, which\nare reclaimable, and they will be reclaimed under the memory pressure.\n\nIn particular, this breaks MemAvailable calculation, as it doesn't take\nunreclaimable slabs into account.  This leads to a silly situation, when\na machine is almost idle, has no memory pressure and therefore has a big\ndentry cache.  And the resulting MemAvailable is too low to start a new\nworkload.\n\nTo address the issue, the NR_INDIRECTLY_RECLAIMABLE_BYTES counter is\nused to track the amount of memory, consumed by external names.  The\ncounter is increased in the dentry allocation path, if an external name\nstructure is allocated; and it's decreased in the dentry freeing path.\n\nTo reproduce the problem I've used the following Python script:\n\n  import os\n\n  for iter in range (0, 10000000):\n      try:\n          name = (\"/some_long_name_%d\" % iter) + \"_\" * 220\n          os.stat(name)\n      except Exception:\n          pass\n\nWithout this patch:\n  $ cat /proc/meminfo | grep MemAvailable\n  MemAvailable:    7811688 kB\n  $ python indirect.py\n  $ cat /proc/meminfo | grep MemAvailable\n  MemAvailable:    2753052 kB\n\nWith the patch:\n  $ cat /proc/meminfo | grep MemAvailable\n  MemAvailable:    7809516 kB\n  $ python indirect.py\n  $ cat /proc/meminfo | grep MemAvailable\n  MemAvailable:    7749144 kB\n\n[guro@fb.com: fix indirectly reclaimable memory accounting for CONFIG_SLOB]\n  Link: http://lkml.kernel.org/r/20180312194140.19517-1-guro@fb.com\n[guro@fb.com: fix indirectly reclaimable memory accounting]\n  Link: http://lkml.kernel.org/r/20180313125701.7955-1-guro@fb.com\nLink: http://lkml.kernel.org/r/20180305133743.12746-5-guro@fb.com\nSigned-off-by: Roman Gushchin <guro@fb.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@techsingularity.net>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/dcache.c||fs/dcache.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/dcache.c||fs/dcache.c"
          ],
          "candidate": [
            "fs/dcache.c||fs/dcache.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/dcache.c||fs/dcache.c": [
          "File: fs/dcache.c -> fs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:  kmem_cache_free(dentry_cache, dentry);",
          "258: }",
          "260: static void __d_free_external(struct rcu_head *head)",
          "261: {",
          "262:  struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);",
          "265: }",
          "267: static inline int dname_external(const struct dentry *dentry)",
          "",
          "[Removed Lines]",
          "263:  kfree(external_name(dentry));",
          "264:  kmem_cache_free(dentry_cache, dentry);",
          "",
          "[Added Lines]",
          "260: static void __d_free_external_name(struct rcu_head *head)",
          "261: {",
          "262:  struct external_name *name = container_of(head, struct external_name,",
          "263:         u.head);",
          "265:  mod_node_page_state(page_pgdat(virt_to_page(name)),",
          "266:        NR_INDIRECTLY_RECLAIMABLE_BYTES,",
          "267:        -ksize(name));",
          "269:  kfree(name);",
          "270: }",
          "276:  __d_free_external_name(&external_name(dentry)->u.head);",
          "278:  kmem_cache_free(dentry_cache, dentry);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "291:   struct external_name *p;",
          "292:   p = container_of(name->name, struct external_name, name[0]);",
          "293:   if (unlikely(atomic_dec_and_test(&p->u.count)))",
          "295:  }",
          "296: }",
          "297: EXPORT_SYMBOL(release_dentry_name_snapshot);",
          "",
          "[Removed Lines]",
          "294:    kfree_rcu(p, u.head);",
          "",
          "[Added Lines]",
          "308:    call_rcu(&p->u.head, __d_free_external_name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1618: struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)",
          "1619: {",
          "1620:  struct dentry *dentry;",
          "1621:  char *dname;",
          "1622:  int err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1634:  struct external_name *ext = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1637:   dname = dentry->d_iname;",
          "1638:  } else if (name->len > DNAME_INLINE_LEN-1) {",
          "1639:   size_t size = offsetof(struct external_name, name[1]);",
          "1643:    kmem_cache_free(dentry_cache, dentry);",
          "1644:    return NULL;",
          "1645:   }",
          "1648:  } else  {",
          "1649:   dname = dentry->d_iname;",
          "1650:  }",
          "",
          "[Removed Lines]",
          "1640:   struct external_name *p = kmalloc(size + name->len,",
          "1641:         GFP_KERNEL_ACCOUNT);",
          "1642:   if (!p) {",
          "1646:   atomic_set(&p->u.count, 1);",
          "1647:   dname = p->name;",
          "",
          "[Added Lines]",
          "1656:   ext = kmalloc(size + name->len, GFP_KERNEL_ACCOUNT);",
          "1657:   if (!ext) {",
          "1661:   atomic_set(&ext->u.count, 1);",
          "1662:   dname = ext->name;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1683:   }",
          "1684:  }",
          "1686:  this_cpu_inc(nr_dentry);",
          "1688:  return dentry;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1701:  if (unlikely(ext)) {",
          "1702:   pg_data_t *pgdat = page_pgdat(virt_to_page(ext));",
          "1703:   mod_node_page_state(pgdat, NR_INDIRECTLY_RECLAIMABLE_BYTES,",
          "1704:         ksize(ext));",
          "1705:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2770:   dentry->d_name.hash_len = target->d_name.hash_len;",
          "2771:  }",
          "2772:  if (old_name && likely(atomic_dec_and_test(&old_name->u.count)))",
          "2774: }",
          "",
          "[Removed Lines]",
          "2773:   kfree_rcu(old_name, u.head);",
          "",
          "[Added Lines]",
          "2794:   call_rcu(&old_name->u.head, __d_free_external_name);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a2c13d9cd76c84f2520f573ff83f777eb7464aa",
      "candidate_info": {
        "commit_hash": "0a2c13d9cd76c84f2520f573ff83f777eb7464aa",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0a2c13d9cd76c84f2520f573ff83f777eb7464aa",
        "files": [
          "include/linux/dcache.h"
        ],
        "message": "include/linux/dcache.h: use unsigned chars in struct name_snapshot\n\n\"kernel.h: handle pointers to arrays better in container_of()\" triggers:\n\nIn file included from include/uapi/linux/stddef.h:1:0,\n                 from include/linux/stddef.h:4,\n                 from include/uapi/linux/posix_types.h:4,\n                 from include/uapi/linux/types.h:13,\n                 from include/linux/types.h:5,\n                 from include/linux/syscalls.h:71,\n                 from fs/dcache.c:17:\nfs/dcache.c: In function 'release_dentry_name_snapshot':\ninclude/linux/compiler.h:542:38: error: call to '__compiletime_assert_305' declared with attribute error: pointer type mismatch in container_of()\n  _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)\n                                      ^\ninclude/linux/compiler.h:525:4: note: in definition of macro '__compiletime_assert'\n    prefix ## suffix();    \\\n    ^\ninclude/linux/compiler.h:542:2: note: in expansion of macro '_compiletime_assert'\n  _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)\n  ^\ninclude/linux/build_bug.h:46:37: note: in expansion of macro 'compiletime_assert'\n #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n                                     ^\ninclude/linux/kernel.h:860:2: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n  BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) && \\\n  ^\nfs/dcache.c:305:7: note: in expansion of macro 'container_of'\n   p = container_of(name->name, struct external_name, name[0]);\n\nSwitch name_snapshot to use unsigned chars, matching struct qstr and\nstruct external_name.\n\nLink: http://lkml.kernel.org/r/20170710152134.0f78c1e6@canb.auug.org.au\nSigned-off-by: Stephen Rothwell <sfr@canb.auug.org.au>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/dcache.h||include/linux/dcache.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/dcache.h||include/linux/dcache.h"
          ],
          "candidate": [
            "include/linux/dcache.h||include/linux/dcache.h"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/dcache.h||include/linux/dcache.h": [
          "File: include/linux/dcache.h -> include/linux/dcache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "592: }",
          "594: struct name_snapshot {",
          "597: };",
          "598: void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);",
          "599: void release_dentry_name_snapshot(struct name_snapshot *);",
          "",
          "[Removed Lines]",
          "595:  const char *name;",
          "596:  char inline_name[DNAME_INLINE_LEN];",
          "",
          "[Added Lines]",
          "595:  const unsigned char *name;",
          "596:  unsigned char inline_name[DNAME_INLINE_LEN];",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-25020",
  "cve_desc": "The BPF subsystem in the Linux kernel before 4.17 mishandles situations with a long jump over an instruction sequence where inner instructions require substantial expansions into multiple BPF instructions, leading to an overflow. This affects kernel/bpf/core.c and net/core/filter.c.",
  "repo": "torvalds/linux",
  "patch_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
  "patch_info": {
    "commit_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "files": [
      "kernel/bpf/core.c",
      "net/core/filter.c"
    ],
    "message": "bpf: fix truncated jump targets on heavy expansions\n\nRecently during testing, I ran into the following panic:\n\n  [  207.892422] Internal error: Accessing user space memory outside uaccess.h routines: 96000004 [#1] SMP\n  [  207.901637] Modules linked in: binfmt_misc [...]\n  [  207.966530] CPU: 45 PID: 2256 Comm: test_verifier Tainted: G        W         4.17.0-rc3+ #7\n  [  207.974956] Hardware name: FOXCONN R2-1221R-A4/C2U4N_MB, BIOS G31FB18A 03/31/2017\n  [  207.982428] pstate: 60400005 (nZCv daif +PAN -UAO)\n  [  207.987214] pc : bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  207.992603] lr : 0xffff000000bdb754\n  [  207.996080] sp : ffff000013703ca0\n  [  207.999384] x29: ffff000013703ca0 x28: 0000000000000001\n  [  208.004688] x27: 0000000000000001 x26: 0000000000000000\n  [  208.009992] x25: ffff000013703ce0 x24: ffff800fb4afcb00\n  [  208.015295] x23: ffff00007d2f5038 x22: ffff00007d2f5000\n  [  208.020599] x21: fffffffffeff2a6f x20: 000000000000000a\n  [  208.025903] x19: ffff000009578000 x18: 0000000000000a03\n  [  208.031206] x17: 0000000000000000 x16: 0000000000000000\n  [  208.036510] x15: 0000ffff9de83000 x14: 0000000000000000\n  [  208.041813] x13: 0000000000000000 x12: 0000000000000000\n  [  208.047116] x11: 0000000000000001 x10: ffff0000089e7f18\n  [  208.052419] x9 : fffffffffeff2a6f x8 : 0000000000000000\n  [  208.057723] x7 : 000000000000000a x6 : 00280c6160000000\n  [  208.063026] x5 : 0000000000000018 x4 : 0000000000007db6\n  [  208.068329] x3 : 000000000008647a x2 : 19868179b1484500\n  [  208.073632] x1 : 0000000000000000 x0 : ffff000009578c08\n  [  208.078938] Process test_verifier (pid: 2256, stack limit = 0x0000000049ca7974)\n  [  208.086235] Call trace:\n  [  208.088672]  bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  208.093713]  0xffff000000bdb754\n  [  208.096845]  bpf_test_run+0x78/0xf8\n  [  208.100324]  bpf_prog_test_run_skb+0x148/0x230\n  [  208.104758]  sys_bpf+0x314/0x1198\n  [  208.108064]  el0_svc_naked+0x30/0x34\n  [  208.111632] Code: 91302260 f9400001 f9001fa1 d2800001 (29500680)\n  [  208.117717] ---[ end trace 263cb8a59b5bf29f ]---\n\nThe program itself which caused this had a long jump over the whole\ninstruction sequence where all of the inner instructions required\nheavy expansions into multiple BPF instructions. Additionally, I also\nhad BPF hardening enabled which requires once more rewrites of all\nconstant values in order to blind them. Each time we rewrite insns,\nbpf_adj_branches() would need to potentially adjust branch targets\nwhich cross the patchlet boundary to accommodate for the additional\ndelta. Eventually that lead to the case where the target offset could\nnot fit into insn->off's upper 0x7fff limit anymore where then offset\nwraps around becoming negative (in s16 universe), or vice versa\ndepending on the jump direction.\n\nTherefore it becomes necessary to detect and reject any such occasions\nin a generic way for native eBPF and cBPF to eBPF migrations. For\nthe latter we can simply check bounds in the bpf_convert_filter()'s\nBPF_EMIT_JMP helper macro and bail out once we surpass limits. The\nbpf_patch_insn_single() for native eBPF (and cBPF to eBPF in case\nof subsequent hardening) is a bit more complex in that we need to\ndetect such truncations before hitting the bpf_prog_realloc(). Thus\nthe latter is split into an extra pass to probe problematic offsets\non the original program in order to fail early. With that in place\nand carefully tested I no longer hit the panic and the rewrites are\nrejected properly. The above example panic I've seen on bpf-next,\nthough the issue itself is generic in that a guard against this issue\nin bpf seems more appropriate in this case.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Martin KaFai Lau <kafai@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "kernel/bpf/core.c||kernel/bpf/core.c",
      "net/core/filter.c||net/core/filter.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/core.c||kernel/bpf/core.c": [
      "File: kernel/bpf/core.c -> kernel/bpf/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "218:  return 0;",
      "219: }",
      "222: {",
      "223:  struct bpf_insn *insn = prog->insnsi;",
      "229:  for (i = 0; i < insn_cnt; i++, insn++) {",
      "230:   code = insn->code;",
      "234:    continue;",
      "235:   if (BPF_OP(code) == BPF_CALL) {",
      "239:     continue;",
      "240:   } else {",
      "242:   }",
      "255:  }",
      "256: }",
      "258: struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,",
      "259:            const struct bpf_insn *patch, u32 len)",
      "260: {",
      "261:  u32 insn_adj_cnt, insn_rest, insn_delta = len - 1;",
      "262:  struct bpf_prog *prog_adj;",
      "",
      "[Removed Lines]",
      "221: static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)",
      "224:  u32 i, insn_cnt = prog->len;",
      "225:  bool pseudo_call;",
      "226:  u8 code;",
      "227:  int off;",
      "231:   if (BPF_CLASS(code) != BPF_JMP)",
      "232:    continue;",
      "233:   if (BPF_OP(code) == BPF_EXIT)",
      "236:    if (insn->src_reg == BPF_PSEUDO_CALL)",
      "237:     pseudo_call = true;",
      "238:    else",
      "241:    pseudo_call = false;",
      "243:   off = pseudo_call ? insn->imm : insn->off;",
      "246:   if (i < pos && i + off + 1 > pos)",
      "247:    off += delta;",
      "248:   else if (i > pos + delta && i + off + 1 <= pos + delta)",
      "249:    off -= delta;",
      "251:   if (pseudo_call)",
      "252:    insn->imm = off;",
      "253:   else",
      "254:    insn->off = off;",
      "",
      "[Added Lines]",
      "221: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,",
      "222:     u32 curr, const bool probe_pass)",
      "224:  const s64 imm_min = S32_MIN, imm_max = S32_MAX;",
      "225:  s64 imm = insn->imm;",
      "227:  if (curr < pos && curr + imm + 1 > pos)",
      "228:   imm += delta;",
      "229:  else if (curr > pos + delta && curr + imm + 1 <= pos + delta)",
      "230:   imm -= delta;",
      "231:  if (imm < imm_min || imm > imm_max)",
      "232:   return -ERANGE;",
      "233:  if (!probe_pass)",
      "234:   insn->imm = imm;",
      "235:  return 0;",
      "236: }",
      "238: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,",
      "239:     u32 curr, const bool probe_pass)",
      "240: {",
      "241:  const s32 off_min = S16_MIN, off_max = S16_MAX;",
      "242:  s32 off = insn->off;",
      "244:  if (curr < pos && curr + off + 1 > pos)",
      "245:   off += delta;",
      "246:  else if (curr > pos + delta && curr + off + 1 <= pos + delta)",
      "247:   off -= delta;",
      "248:  if (off < off_min || off > off_max)",
      "249:   return -ERANGE;",
      "250:  if (!probe_pass)",
      "251:   insn->off = off;",
      "252:  return 0;",
      "253: }",
      "255: static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,",
      "256:        const bool probe_pass)",
      "257: {",
      "258:  u32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);",
      "260:  int ret = 0;",
      "263:   u8 code;",
      "269:   if (probe_pass && i == pos) {",
      "270:    i += delta + 1;",
      "271:    insn++;",
      "272:   }",
      "274:   if (BPF_CLASS(code) != BPF_JMP ||",
      "275:       BPF_OP(code) == BPF_EXIT)",
      "279:    if (insn->src_reg != BPF_PSEUDO_CALL)",
      "281:    ret = bpf_adj_delta_to_imm(insn, pos, delta, i,",
      "282:          probe_pass);",
      "284:    ret = bpf_adj_delta_to_off(insn, pos, delta, i,",
      "285:          probe_pass);",
      "287:   if (ret)",
      "288:    break;",
      "291:  return ret;",
      "298:  const u32 cnt_max = S16_MAX;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:  insn_adj_cnt = prog->len + insn_delta;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "314:  if (insn_adj_cnt > cnt_max &&",
      "315:      bpf_adj_branches(prog, off, insn_delta, true))",
      "316:   return NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "294:   sizeof(*patch) * insn_rest);",
      "295:  memcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);",
      "299:  return prog_adj;",
      "300: }",
      "",
      "[Removed Lines]",
      "297:  bpf_adj_branches(prog_adj, off, insn_delta);",
      "",
      "[Added Lines]",
      "347:  BUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));",
      "",
      "---------------"
    ],
    "net/core/filter.c||net/core/filter.c": [
      "File: net/core/filter.c -> net/core/filter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "482: #define BPF_EMIT_JMP       \\",
      "483:  do {        \\",
      "484:   if (target >= len || target < 0)   \\",
      "485:    goto err;     \\",
      "489:  } while (0)",
      "491:   case BPF_JMP | BPF_JA:",
      "",
      "[Removed Lines]",
      "486:   insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0; \\",
      "488:   insn->off -= insn - tmp_insns;    \\",
      "",
      "[Added Lines]",
      "484:   const s32 off_min = S16_MIN, off_max = S16_MAX;  \\",
      "485:   s32 off;      \\",
      "486:          \\",
      "489:   off = addrs ? addrs[target] - addrs[i] - 1 : 0;  \\",
      "491:   off -= insn - tmp_insns;    \\",
      "493:   if (off < off_min || off > off_max)   \\",
      "494:    goto err;     \\",
      "495:   insn->off = off;     \\",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7bb572fddd757512130afcc0a8a683095eee1cd5",
      "candidate_info": {
        "commit_hash": "7bb572fddd757512130afcc0a8a683095eee1cd5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7bb572fddd757512130afcc0a8a683095eee1cd5",
        "files": [
          "drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c"
        ],
        "message": "net: hns3: Fixes kernel panic issue during rmmod hns3 driver\n\nIf CONFIG_ARM_SMMU_V3 is enabled, arm64's dma_ops will replace\narm64_swiotlb_dma_ops with iommu_dma_ops. When releasing contiguous\ndma memory, the new ops will call the vunmap function which cannot\nbe run in interrupt context.\n\nCurrently, spin_lock_bh is called before vunmap is executed. This\ndisables BH and causes the interrupt context to be detected to\ngenerate a kernel panic like below:\n\n[ 2831.573400] kernel BUG at mm/vmalloc.c:1621!\n[ 2831.577659] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n...\n[ 2831.699907] Process rmmod (pid: 1893, stack limit = 0x0000000055103ee2)\n[ 2831.706507] Call trace:\n[ 2831.708941]  vunmap+0x48/0x50\n[ 2831.711897]  dma_common_free_remap+0x78/0x88\n[ 2831.716155]  __iommu_free_attrs+0xa8/0x1c0\n[ 2831.720255]  hclge_free_cmd_desc+0xc8/0x118 [hclge]\n[ 2831.725128]  hclge_destroy_cmd_queue+0x34/0x68 [hclge]\n[ 2831.730261]  hclge_uninit_ae_dev+0x90/0x100 [hclge]\n[ 2831.735127]  hnae3_unregister_ae_dev+0xb0/0x868 [hnae3]\n[ 2831.740345]  hns3_remove+0x3c/0x90 [hns3]\n[ 2831.744344]  pci_device_remove+0x48/0x108\n[ 2831.748342]  device_release_driver_internal+0x164/0x200\n[ 2831.753553]  driver_detach+0x4c/0x88\n[ 2831.757116]  bus_remove_driver+0x60/0xc0\n[ 2831.761026]  driver_unregister+0x34/0x60\n[ 2831.764935]  pci_unregister_driver+0x30/0xb0\n[ 2831.769197]  hns3_exit_module+0x10/0x978 [hns3]\n[ 2831.773715]  SyS_delete_module+0x1f8/0x248\n[ 2831.777799]  el0_svc_naked+0x30/0x34\n\nThis patch fixes it by using spin_lock instead of spin_lock_bh.\n\nFixes: 68c0a5c70614 (\"net: hns3: Add HNS3 IMP(Integrated Mgmt Proc) Cmd Interface Support\")\nSigned-off-by: Xi Wang <wangxi11@huawei.com>\nSigned-off-by: Peng Li <lipeng321@huawei.com>\nSigned-off-by: Salil Mehta <salil.mehta@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c||drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c||drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c": [
          "File: drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c -> drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_cmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "386: static void hclge_destroy_queue(struct hclge_cmq_ring *ring)",
          "387: {",
          "389:  hclge_free_cmd_desc(ring);",
          "391: }",
          "393: void hclge_destroy_cmd_queue(struct hclge_hw *hw)",
          "",
          "[Removed Lines]",
          "388:  spin_lock_bh(&ring->lock);",
          "390:  spin_unlock_bh(&ring->lock);",
          "",
          "[Added Lines]",
          "388:  spin_lock(&ring->lock);",
          "390:  spin_unlock(&ring->lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f3336254263c3b6a7734379084f4873a335f1577",
      "candidate_info": {
        "commit_hash": "f3336254263c3b6a7734379084f4873a335f1577",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f3336254263c3b6a7734379084f4873a335f1577",
        "files": [
          "drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c"
        ],
        "message": "drm/amdgpu/uvd7: add emit_reg_write_reg_wait ring callback\n\nFix the NULL pointer dereference while running amdgpu_test:\n\n[   54.972246] BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n[   54.972265] IP:           (null)\n[   54.972273] PGD 0 P4D 0\n[   54.972280] Oops: 0010 [#1] SMP PTI\n[   54.972288] Modules linked in: amdkfd amd_iommu_v2 amdgpu(OE) chash gpu_sched ttm drm_kms_helper drm i2c_algo_bit fb_sys_fops syscopyarea sysfillrect sysimgblt snd_hda_codec_realtek snd_hda_codec_generic snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hda_core snd_hwdep intel_rapl snd_pcm snd_seq_midi snd_seq_midi_event snd_rawmidi x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel snd_seq snd_seq_device kvm irqbypass snd_timer crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcbc snd soundcore joydev input_leds aesni_intel aes_x86_64 crypto_simd glue_helper cryptd idma64 virt_dma mei_me intel_lpss_pci serio_raw intel_cstate intel_rapl_perf shpchp intel_pch_thermal mei mac_hid intel_lpss acpi_pad parport_pc ppdev nfsd lp auth_rpcgss nfs_acl lockd grace sunrpc parport autofs4 hid_generic\n[   54.972434]  usbhid mxm_wmi e1000e psmouse ahci hid libahci wmi pinctrl_sunrisepoint video pinctrl_intel\n[   54.972457] CPU: 6 PID: 1393 Comm: uvd Tainted: G           OE    4.16.0-rc7-27fb84fda777 #1\n[   54.972473] Hardware name: MSI MS-7984/Z170 KRAIT GAMING (MS-7984), BIOS B.80 05/11/2016\n[   54.972489] RIP: 0010:          (null)\n[   54.972497] RSP: 0018:ffffaea002c8bcc0 EFLAGS: 00010202\n[   54.972508] RAX: 0000000000000000 RBX: ffff9d30d3c56f60 RCX: 00000000007c0002\n[   54.972522] RDX: 000000000001a6fb RSI: 000000000001a6e9 RDI: ffff9d30d3c56f60\n[   54.972536] RBP: ffffaea002c8bd10 R08: 0000000000000002 R09: ffffffffc06977d0\n[   54.972550] R10: 0000000000000040 R11: 0000000000000000 R12: 0000000000000002\n[   54.972564] R13: ffff9d30d3c5001c R14: ffff9d30d3c50000 R15: 0000000000000006\n[   54.972579] FS:  0000000000000000(0000) GS:ffff9d30eed80000(0000) knlGS:0000000000000000\n[   54.972594] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   54.972606] CR2: 0000000000000000 CR3: 00000002dbc0a001 CR4: 00000000003606e0\n[   54.972620] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[   54.972634] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[   54.972648] Call Trace:\n[   54.972685]  ? gmc_v9_0_emit_flush_gpu_tlb+0x111/0x140 [amdgpu]\n[   54.972721]  uvd_v7_0_ring_emit_vm_flush+0x31/0x70 [amdgpu]\n[   54.972751]  amdgpu_vm_flush+0x5dc/0x6c0 [amdgpu]\n[   54.972787]  ? pp_dpm_powergate_uvd+0x50/0x80 [amdgpu]\n[   54.972816]  amdgpu_ib_schedule+0x120/0x4e0 [amdgpu]\n[   54.972850]  amdgpu_job_run+0x17b/0x1c0 [amdgpu]\n[   54.972861]  drm_sched_main+0x2cc/0x490 [gpu_sched]\n[   54.972873]  ? wait_woken+0x80/0x80\n[   54.972882]  kthread+0x121/0x140\n[   54.972891]  ? drm_sched_job_finish+0xf0/0xf0 [gpu_sched]\n[   54.972902]  ? kthread_create_worker_on_cpu+0x70/0x70\n[   54.972914]  ret_from_fork+0x35/0x40\n[   54.972922] Code:  Bad RIP value.\n[   54.972932] RIP:           (null) RSP: ffffaea002c8bcc0\n[   54.972943] CR2: 0000000000000000\n[   54.972951] ---[ end trace 5feb349263bbf633 ]---\n\nSigned-off-by: Xiaojie Yuan <Xiaojie.Yuan@amd.com>\nReviewed-by: Alex Deucher <alexander.deucher@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>",
        "before_after_code_files": [
          "drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c||drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c||drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c": [
          "File: drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c -> drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1671:  .end_use = amdgpu_uvd_ring_end_use,",
          "1672:  .emit_wreg = uvd_v7_0_ring_emit_wreg,",
          "1673:  .emit_reg_wait = uvd_v7_0_ring_emit_reg_wait,",
          "1674: };",
          "1676: static const struct amdgpu_ring_funcs uvd_v7_0_enc_ring_vm_funcs = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1674:  .emit_reg_write_reg_wait = amdgpu_ring_emit_reg_write_reg_wait_helper,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b71534583f22d08c3e3563bf5100aeb5f5c9fbe5",
      "candidate_info": {
        "commit_hash": "b71534583f22d08c3e3563bf5100aeb5f5c9fbe5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b71534583f22d08c3e3563bf5100aeb5f5c9fbe5",
        "files": [
          "net/netfilter/nft_ct.c"
        ],
        "message": "netfilter: nf_tables: fix NULL pointer dereference on nft_ct_helper_obj_dump()\n\nIn the nft_ct_helper_obj_dump(), always priv->helper4 is dereferenced.\nBut if family is ipv6, priv->helper6 should be dereferenced.\n\nSteps to reproduces:\n\n   #test.nft\n   table ip6 filter {\n\t   ct helper ftp {\n\t\t   type \"ftp\" protocol tcp\n\t   }\n\t   chain input {\n\t\t   type filter hook input priority 4;\n\t\t   ct helper set \"ftp\"\n\t   }\n   }\n\n   %nft -f test.nft\n   %nft list ruleset\n\nwe can see the below messages:\n\n[  916.286233] kasan: GPF could be caused by NULL-ptr deref or user memory access\n[  916.294777] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI\n[  916.302613] Modules linked in: nft_objref nf_conntrack_sip nf_conntrack_snmp nf_conntrack_broadcast nf_conntrack_ftp nft_ct nf_conntrack nf_tables nfnetlink [last unloaded: nfnetlink]\n[  916.318758] CPU: 1 PID: 2093 Comm: nft Not tainted 4.17.0-rc4+ #181\n[  916.326772] Hardware name: To be filled by O.E.M. To be filled by O.E.M./Aptio CRB, BIOS 5.6.5 07/08/2015\n[  916.338773] RIP: 0010:strlen+0x1a/0x90\n[  916.342781] RSP: 0018:ffff88010ff0f2f8 EFLAGS: 00010292\n[  916.346773] RAX: dffffc0000000000 RBX: ffff880119b26ee8 RCX: ffff88010c150038\n[  916.354777] RDX: 0000000000000002 RSI: ffff880119b26ee8 RDI: 0000000000000010\n[  916.362773] RBP: 0000000000000010 R08: 0000000000007e88 R09: ffff88010c15003c\n[  916.370773] R10: ffff88010c150037 R11: ffffed002182a007 R12: ffff88010ff04040\n[  916.378779] R13: 0000000000000010 R14: ffff880119b26f30 R15: ffff88010ff04110\n[  916.387265] FS:  00007f57a1997700(0000) GS:ffff88011b800000(0000) knlGS:0000000000000000\n[  916.394785] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  916.402778] CR2: 00007f57a0ac80f0 CR3: 000000010ff02000 CR4: 00000000001006e0\n[  916.410772] Call Trace:\n[  916.414787]  nft_ct_helper_obj_dump+0x94/0x200 [nft_ct]\n[  916.418779]  ? nft_ct_set_eval+0x560/0x560 [nft_ct]\n[  916.426771]  ? memset+0x1f/0x40\n[  916.426771]  ? __nla_reserve+0x92/0xb0\n[  916.434774]  ? memcpy+0x34/0x50\n[  916.434774]  nf_tables_fill_obj_info+0x484/0x860 [nf_tables]\n[  916.442773]  ? __nft_release_basechain+0x600/0x600 [nf_tables]\n[  916.450779]  ? lock_acquire+0x193/0x380\n[  916.454771]  ? lock_acquire+0x193/0x380\n[  916.458789]  ? nf_tables_dump_obj+0x148/0xcb0 [nf_tables]\n[  916.462777]  nf_tables_dump_obj+0x5f0/0xcb0 [nf_tables]\n[  916.470769]  ? __alloc_skb+0x30b/0x500\n[  916.474779]  netlink_dump+0x752/0xb50\n[  916.478775]  __netlink_dump_start+0x4d3/0x750\n[  916.482784]  nf_tables_getobj+0x27a/0x930 [nf_tables]\n[  916.490774]  ? nft_obj_notify+0x100/0x100 [nf_tables]\n[  916.494772]  ? nf_tables_getobj+0x930/0x930 [nf_tables]\n[  916.502579]  ? nf_tables_dump_flowtable_done+0x70/0x70 [nf_tables]\n[  916.506774]  ? nft_obj_notify+0x100/0x100 [nf_tables]\n[  916.514808]  nfnetlink_rcv_msg+0x8ab/0xa86 [nfnetlink]\n[  916.518771]  ? nfnetlink_rcv_msg+0x550/0xa86 [nfnetlink]\n[  916.526782]  netlink_rcv_skb+0x23e/0x360\n[  916.530773]  ? nfnetlink_bind+0x200/0x200 [nfnetlink]\n[  916.534778]  ? debug_check_no_locks_freed+0x280/0x280\n[  916.542770]  ? netlink_ack+0x870/0x870\n[  916.546786]  ? ns_capable_common+0xf4/0x130\n[  916.550765]  nfnetlink_rcv+0x172/0x16c0 [nfnetlink]\n[  916.554771]  ? sched_clock_local+0xe2/0x150\n[  916.558774]  ? sched_clock_cpu+0x144/0x180\n[  916.566575]  ? lock_acquire+0x380/0x380\n[  916.570775]  ? sched_clock_local+0xe2/0x150\n[  916.574765]  ? nfnetlink_net_init+0x130/0x130 [nfnetlink]\n[  916.578763]  ? sched_clock_cpu+0x144/0x180\n[  916.582770]  ? lock_acquire+0x193/0x380\n[  916.590771]  ? lock_acquire+0x193/0x380\n[  916.594766]  ? lock_acquire+0x380/0x380\n[  916.598760]  ? netlink_deliver_tap+0x262/0xa60\n[  916.602766]  ? lock_acquire+0x193/0x380\n[  916.606766]  netlink_unicast+0x3ef/0x5a0\n[  916.610771]  ? netlink_attachskb+0x630/0x630\n[  916.614763]  netlink_sendmsg+0x72a/0xb00\n[  916.618769]  ? netlink_unicast+0x5a0/0x5a0\n[  916.626766]  ? _copy_from_user+0x92/0xc0\n[  916.630773]  __sys_sendto+0x202/0x300\n[  916.634772]  ? __ia32_sys_getpeername+0xb0/0xb0\n[  916.638759]  ? lock_acquire+0x380/0x380\n[  916.642769]  ? lock_acquire+0x193/0x380\n[  916.646761]  ? finish_task_switch+0xf4/0x560\n[  916.650763]  ? __schedule+0x582/0x19a0\n[  916.655301]  ? __sched_text_start+0x8/0x8\n[  916.655301]  ? up_read+0x1c/0x110\n[  916.655301]  ? __do_page_fault+0x48b/0xaa0\n[  916.655301]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[  916.655301]  __x64_sys_sendto+0xdd/0x1b0\n[  916.655301]  do_syscall_64+0x96/0x3d0\n[  916.655301]  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  916.655301] RIP: 0033:0x7f57a0ff5e03\n[  916.655301] RSP: 002b:00007fff6367e0a8 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\n[  916.655301] RAX: ffffffffffffffda RBX: 00007fff6367f1e0 RCX: 00007f57a0ff5e03\n[  916.655301] RDX: 0000000000000020 RSI: 00007fff6367e110 RDI: 0000000000000003\n[  916.655301] RBP: 00007fff6367e100 R08: 00007f57a0ce9160 R09: 000000000000000c\n[  916.655301] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff6367e110\n[  916.655301] R13: 0000000000000020 R14: 00007f57a153c610 R15: 0000562417258de0\n[  916.655301] Code: ff ff ff 0f 1f 40 00 66 2e 0f 1f 84 00 00 00 00 00 55 48 89 fa 53 48 c1 ea 03 48 b8 00 00 00 00 00 fc ff df 48 89 fd 48 83 ec 08 <0f> b6 04 02 48 89 fa 83 e2 07 38 d0 7f\n[  916.655301] RIP: strlen+0x1a/0x90 RSP: ffff88010ff0f2f8\n[  916.771929] ---[ end trace 1065e048e72479fe ]---\n[  916.777204] Kernel panic - not syncing: Fatal exception\n[  916.778158] Kernel Offset: 0x14000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n\nSigned-off-by: Taehee Yoo <ap420073@gmail.com>\nAcked-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/netfilter/nft_ct.c||net/netfilter/nft_ct.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/netfilter/nft_ct.c||net/netfilter/nft_ct.c": [
          "File: net/netfilter/nft_ct.c -> net/netfilter/nft_ct.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "880:       struct nft_object *obj, bool reset)",
          "881: {",
          "882:  const struct nft_ct_helper_obj *priv = nft_obj_data(obj);",
          "884:  u16 family;",
          "886:  if (nla_put_string(skb, NFTA_CT_HELPER_NAME, helper->name))",
          "887:   return -1;",
          "889:  if (nla_put_u8(skb, NFTA_CT_HELPER_L4PROTO, priv->l4proto))",
          "890:   return -1;",
          "899:  if (nla_put_be16(skb, NFTA_CT_HELPER_L3PROTO, htons(family)))",
          "900:   return -1;",
          "",
          "[Removed Lines]",
          "883:  const struct nf_conntrack_helper *helper = priv->helper4;",
          "892:  if (priv->helper4 && priv->helper6)",
          "893:   family = NFPROTO_INET;",
          "894:  else if (priv->helper6)",
          "895:   family = NFPROTO_IPV6;",
          "896:  else",
          "897:   family = NFPROTO_IPV4;",
          "",
          "[Added Lines]",
          "883:  const struct nf_conntrack_helper *helper;",
          "886:  if (priv->helper4 && priv->helper6) {",
          "887:   family = NFPROTO_INET;",
          "888:   helper = priv->helper4;",
          "889:  } else if (priv->helper6) {",
          "890:   family = NFPROTO_IPV6;",
          "891:   helper = priv->helper6;",
          "892:  } else {",
          "893:   family = NFPROTO_IPV4;",
          "894:   helper = priv->helper4;",
          "895:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5691484df961aff897d824bcc26cd1a2aa036b5b",
      "candidate_info": {
        "commit_hash": "5691484df961aff897d824bcc26cd1a2aa036b5b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5691484df961aff897d824bcc26cd1a2aa036b5b",
        "files": [
          "net/ipv6/ip6_gre.c"
        ],
        "message": "net: ip6_gre: Fix headroom request in ip6erspan_tunnel_xmit()\n\ndev->needed_headroom is not primed until ip6_tnl_xmit(), so it starts\nout zero. Thus the call to skb_cow_head() fails to actually make sure\nthere's enough headroom to push the ERSPAN headers to. That can lead to\nthe panic cited below. (Reproducer below that).\n\nFix by requesting either needed_headroom if already primed, or just the\nbare minimum needed for the header otherwise.\n\n[  190.703567] kernel BUG at net/core/skbuff.c:104!\n[  190.708384] invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\n[  190.714007] Modules linked in: act_mirred cls_matchall ip6_gre ip6_tunnel tunnel6 gre sch_ingress vrf veth x86_pkg_temp_thermal mlx_platform nfsd e1000e leds_mlxcpld\n[  190.728975] CPU: 1 PID: 959 Comm: kworker/1:2 Not tainted 4.17.0-rc4-net_master-custom-139 #10\n[  190.737647] Hardware name: Mellanox Technologies Ltd. \"MSN2410-CB2F\"/\"SA000874\", BIOS 4.6.5 03/08/2016\n[  190.747006] Workqueue: ipv6_addrconf addrconf_dad_work\n[  190.752222] RIP: 0010:skb_panic+0xc3/0x100\n[  190.756358] RSP: 0018:ffff8801d54072f0 EFLAGS: 00010282\n[  190.761629] RAX: 0000000000000085 RBX: ffff8801c1a8ecc0 RCX: 0000000000000000\n[  190.768830] RDX: 0000000000000085 RSI: dffffc0000000000 RDI: ffffed003aa80e54\n[  190.776025] RBP: ffff8801bd1ec5a0 R08: ffffed003aabce19 R09: ffffed003aabce19\n[  190.783226] R10: 0000000000000001 R11: ffffed003aabce18 R12: ffff8801bf695dbe\n[  190.790418] R13: 0000000000000084 R14: 00000000000006c0 R15: ffff8801bf695dc8\n[  190.797621] FS:  0000000000000000(0000) GS:ffff8801d5400000(0000) knlGS:0000000000000000\n[  190.805786] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  190.811582] CR2: 000055fa929aced0 CR3: 0000000003228004 CR4: 00000000001606e0\n[  190.818790] Call Trace:\n[  190.821264]  <IRQ>\n[  190.823314]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]\n[  190.828940]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]\n[  190.834562]  skb_push+0x78/0x90\n[  190.837749]  ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]\n[  190.843219]  ? ip6gre_tunnel_ioctl+0xd90/0xd90 [ip6_gre]\n[  190.848577]  ? debug_check_no_locks_freed+0x210/0x210\n[  190.853679]  ? debug_check_no_locks_freed+0x210/0x210\n[  190.858783]  ? print_irqtrace_events+0x120/0x120\n[  190.863451]  ? sched_clock_cpu+0x18/0x210\n[  190.867496]  ? cyc2ns_read_end+0x10/0x10\n[  190.871474]  ? skb_network_protocol+0x76/0x200\n[  190.875977]  dev_hard_start_xmit+0x137/0x770\n[  190.880317]  ? do_raw_spin_trylock+0x6d/0xa0\n[  190.884624]  sch_direct_xmit+0x2ef/0x5d0\n[  190.888589]  ? pfifo_fast_dequeue+0x3fa/0x670\n[  190.892994]  ? pfifo_fast_change_tx_queue_len+0x810/0x810\n[  190.898455]  ? __lock_is_held+0xa0/0x160\n[  190.902422]  __qdisc_run+0x39e/0xfc0\n[  190.906041]  ? _raw_spin_unlock+0x29/0x40\n[  190.910090]  ? pfifo_fast_enqueue+0x24b/0x3e0\n[  190.914501]  ? sch_direct_xmit+0x5d0/0x5d0\n[  190.918658]  ? pfifo_fast_dequeue+0x670/0x670\n[  190.923047]  ? __dev_queue_xmit+0x172/0x1770\n[  190.927365]  ? preempt_count_sub+0xf/0xd0\n[  190.931421]  __dev_queue_xmit+0x410/0x1770\n[  190.935553]  ? ___slab_alloc+0x605/0x930\n[  190.939524]  ? print_irqtrace_events+0x120/0x120\n[  190.944186]  ? memcpy+0x34/0x50\n[  190.947364]  ? netdev_pick_tx+0x1c0/0x1c0\n[  190.951428]  ? __skb_clone+0x2fd/0x3d0\n[  190.955218]  ? __copy_skb_header+0x270/0x270\n[  190.959537]  ? rcu_read_lock_sched_held+0x93/0xa0\n[  190.964282]  ? kmem_cache_alloc+0x344/0x4d0\n[  190.968520]  ? cyc2ns_read_end+0x10/0x10\n[  190.972495]  ? skb_clone+0x123/0x230\n[  190.976112]  ? skb_split+0x820/0x820\n[  190.979747]  ? tcf_mirred+0x554/0x930 [act_mirred]\n[  190.984582]  tcf_mirred+0x554/0x930 [act_mirred]\n[  190.989252]  ? tcf_mirred_act_wants_ingress.part.2+0x10/0x10 [act_mirred]\n[  190.996109]  ? __lock_acquire+0x706/0x26e0\n[  191.000239]  ? sched_clock_cpu+0x18/0x210\n[  191.004294]  tcf_action_exec+0xcf/0x2a0\n[  191.008179]  tcf_classify+0xfa/0x340\n[  191.011794]  __netif_receive_skb_core+0x8e1/0x1c60\n[  191.016630]  ? debug_check_no_locks_freed+0x210/0x210\n[  191.021732]  ? nf_ingress+0x500/0x500\n[  191.025458]  ? process_backlog+0x347/0x4b0\n[  191.029619]  ? print_irqtrace_events+0x120/0x120\n[  191.034302]  ? lock_acquire+0xd8/0x320\n[  191.038089]  ? process_backlog+0x1b6/0x4b0\n[  191.042246]  ? process_backlog+0xc2/0x4b0\n[  191.046303]  process_backlog+0xc2/0x4b0\n[  191.050189]  net_rx_action+0x5cc/0x980\n[  191.053991]  ? napi_complete_done+0x2c0/0x2c0\n[  191.058386]  ? mark_lock+0x13d/0xb40\n[  191.062001]  ? clockevents_program_event+0x6b/0x1d0\n[  191.066922]  ? print_irqtrace_events+0x120/0x120\n[  191.071593]  ? __lock_is_held+0xa0/0x160\n[  191.075566]  __do_softirq+0x1d4/0x9d2\n[  191.079282]  ? ip6_finish_output2+0x524/0x1460\n[  191.083771]  do_softirq_own_stack+0x2a/0x40\n[  191.087994]  </IRQ>\n[  191.090130]  do_softirq.part.13+0x38/0x40\n[  191.094178]  __local_bh_enable_ip+0x135/0x190\n[  191.098591]  ip6_finish_output2+0x54d/0x1460\n[  191.102916]  ? ip6_forward_finish+0x2f0/0x2f0\n[  191.107314]  ? ip6_mtu+0x3c/0x2c0\n[  191.110674]  ? ip6_finish_output+0x2f8/0x650\n[  191.114992]  ? ip6_output+0x12a/0x500\n[  191.118696]  ip6_output+0x12a/0x500\n[  191.122223]  ? ip6_route_dev_notify+0x5b0/0x5b0\n[  191.126807]  ? ip6_finish_output+0x650/0x650\n[  191.131120]  ? ip6_fragment+0x1a60/0x1a60\n[  191.135182]  ? icmp6_dst_alloc+0x26e/0x470\n[  191.139317]  mld_sendpack+0x672/0x830\n[  191.143021]  ? igmp6_mcf_seq_next+0x2f0/0x2f0\n[  191.147429]  ? __local_bh_enable_ip+0x77/0x190\n[  191.151913]  ipv6_mc_dad_complete+0x47/0x90\n[  191.156144]  addrconf_dad_completed+0x561/0x720\n[  191.160731]  ? addrconf_rs_timer+0x3a0/0x3a0\n[  191.165036]  ? mark_held_locks+0xc9/0x140\n[  191.169095]  ? __local_bh_enable_ip+0x77/0x190\n[  191.173570]  ? addrconf_dad_work+0x50d/0xa20\n[  191.177886]  ? addrconf_dad_work+0x529/0xa20\n[  191.182194]  addrconf_dad_work+0x529/0xa20\n[  191.186342]  ? addrconf_dad_completed+0x720/0x720\n[  191.191088]  ? __lock_is_held+0xa0/0x160\n[  191.195059]  ? process_one_work+0x45d/0xe20\n[  191.199302]  ? process_one_work+0x51e/0xe20\n[  191.203531]  ? rcu_read_lock_sched_held+0x93/0xa0\n[  191.208279]  process_one_work+0x51e/0xe20\n[  191.212340]  ? pwq_dec_nr_in_flight+0x200/0x200\n[  191.216912]  ? get_lock_stats+0x4b/0xf0\n[  191.220788]  ? preempt_count_sub+0xf/0xd0\n[  191.224844]  ? worker_thread+0x219/0x860\n[  191.228823]  ? do_raw_spin_trylock+0x6d/0xa0\n[  191.233142]  worker_thread+0xeb/0x860\n[  191.236848]  ? process_one_work+0xe20/0xe20\n[  191.241095]  kthread+0x206/0x300\n[  191.244352]  ? process_one_work+0xe20/0xe20\n[  191.248587]  ? kthread_stop+0x570/0x570\n[  191.252459]  ret_from_fork+0x3a/0x50\n[  191.256082] Code: 14 3e ff 8b 4b 78 55 4d 89 f9 41 56 41 55 48 c7 c7 a0 cf db 82 41 54 44 8b 44 24 2c 48 8b 54 24 30 48 8b 74 24 20 e8 16 94 13 ff <0f> 0b 48 c7 c7 60 8e 1f 85 48 83 c4 20 e8 55 ef a6 ff 89 74 24\n[  191.275327] RIP: skb_panic+0xc3/0x100 RSP: ffff8801d54072f0\n[  191.281024] ---[ end trace 7ea51094e099e006 ]---\n[  191.285724] Kernel panic - not syncing: Fatal exception in interrupt\n[  191.292168] Kernel Offset: disabled\n[  191.295697] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---\n\nReproducer:\n\n\tip link add h1 type veth peer name swp1\n\tip link add h3 type veth peer name swp3\n\n\tip link set dev h1 up\n\tip address add 192.0.2.1/28 dev h1\n\n\tip link add dev vh3 type vrf table 20\n\tip link set dev h3 master vh3\n\tip link set dev vh3 up\n\tip link set dev h3 up\n\n\tip link set dev swp3 up\n\tip address add dev swp3 2001:db8:2::1/64\n\n\tip link set dev swp1 up\n\ttc qdisc add dev swp1 clsact\n\n\tip link add name gt6 type ip6erspan \\\n\t\tlocal 2001:db8:2::1 remote 2001:db8:2::2 oseq okey 123\n\tip link set dev gt6 up\n\n\tsleep 1\n\n\ttc filter add dev swp1 ingress pref 1000 matchall skip_hw \\\n\t\taction mirred egress mirror dev gt6\n\tping -I h1 192.0.2.2\n\nFixes: e41c7c68ea77 (\"ip6erspan: make sure enough headroom at xmit.\")\nSigned-off-by: Petr Machata <petrm@mellanox.com>\nAcked-by: William Tu <u9012063@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_gre.c||net/ipv6/ip6_gre.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_gre.c||net/ipv6/ip6_gre.c": [
          "File: net/ipv6/ip6_gre.c -> net/ipv6/ip6_gre.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "911:   truncate = true;",
          "912:  }",
          "915:   goto tx_err;",
          "917:  t->parms.o_flags &= ~TUNNEL_KEY;",
          "",
          "[Removed Lines]",
          "914:  if (skb_cow_head(skb, dev->needed_headroom))",
          "",
          "[Added Lines]",
          "914:  if (skb_cow_head(skb, dev->needed_headroom ?: t->hlen))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "378831e4daec75fbba6d3612bcf3b4dd00ddbf08",
      "candidate_info": {
        "commit_hash": "378831e4daec75fbba6d3612bcf3b4dd00ddbf08",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/378831e4daec75fbba6d3612bcf3b4dd00ddbf08",
        "files": [
          "fs/afs/security.c"
        ],
        "message": "afs: Fix directory permissions check\n\nDoing faccessat(\"/afs/some/directory\", 0) triggers a BUG in the permissions\ncheck code.\n\nFix this by just removing the BUG section.  If no permissions are asked\nfor, just return okay if the file exists.\n\nAlso:\n\n (1) Split up the directory check so that it has separate if-statements\n     rather than if-else-if (e.g. checking for MAY_EXEC shouldn't skip the\n     check for MAY_READ and MAY_WRITE).\n\n (2) Check for MAY_CHDIR as MAY_EXEC.\n\nWithout the main fix, the following BUG may occur:\n\n kernel BUG at fs/afs/security.c:386!\n invalid opcode: 0000 [#1] SMP PTI\n ...\n RIP: 0010:afs_permission+0x19d/0x1a0 [kafs]\n ...\n Call Trace:\n  ? inode_permission+0xbe/0x180\n  ? do_faccessat+0xdc/0x270\n  ? do_syscall_64+0x60/0x1f0\n  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nFixes: 00d3b7a4533e (\"[AFS]: Add security support.\")\nReported-by: Jonathan Billings <jsbillings@jsbillings.org>\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "fs/afs/security.c||fs/afs/security.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/afs/security.c||fs/afs/security.c": [
          "File: fs/afs/security.c -> fs/afs/security.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "372:         mask, access, S_ISDIR(inode->i_mode) ? \"dir\" : \"file\");",
          "374:  if (S_ISDIR(inode->i_mode)) {",
          "376:    if (!(access & AFS_ACE_LOOKUP))",
          "377:     goto permission_denied;",
          "384:     goto permission_denied;",
          "387:   }",
          "388:  } else {",
          "389:   if (!(access & AFS_ACE_LOOKUP))",
          "",
          "[Removed Lines]",
          "375:   if (mask & MAY_EXEC) {",
          "378:   } else if (mask & MAY_READ) {",
          "379:    if (!(access & AFS_ACE_LOOKUP))",
          "380:     goto permission_denied;",
          "381:   } else if (mask & MAY_WRITE) {",
          "385:   } else {",
          "386:    BUG();",
          "",
          "[Added Lines]",
          "375:   if (mask & (MAY_EXEC | MAY_READ | MAY_CHDIR)) {",
          "378:   }",
          "379:   if (mask & MAY_WRITE) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-1342",
  "cve_desc": "LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",
  "repo": "lxc/lxcfs",
  "patch_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
  "patch_info": {
    "commit_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "repo": "lxc/lxcfs",
    "commit_url": "https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "files": [
      "Makefile.am",
      "lxcfs.c",
      "tests/test_confinement.sh",
      "tests/test_syscalls.c"
    ],
    "message": "Fix checking of parent directories\n\nTaken from the justification in the launchpad bug:\n\nTo a task in freezer cgroup /a/b/c/d, it should appear that there are no\ncgroups other than its descendents. Since this is a filesystem, we must have\nthe parent directories, but each parent cgroup should only contain the child\nwhich the task can see.\n\nSo, when this task looks at /a/b, it should see only directory 'c' and no\nfiles. Attempt to create /a/b/x should result in -EPERM, whether /a/b/x already\nexists or not. Attempts to query /a/b/x should result in -ENOENT whether /a/b/x\nexists or not. Opening /a/b/tasks should result in -ENOENT.\n\nThe caller_may_see_dir checks specifically whether a task may see a cgroup\ndirectory - i.e. /a/b/x if opening /a/b/x/tasks, and /a/b/c/d if doing\nopendir('/a/b/c/d').\n\ncaller_is_in_ancestor() will return true if the caller in /a/b/c/d looks at\n/a/b/c/d/e. If the caller is in a child cgroup of the queried one - i.e. if the\ntask in /a/b/c/d queries /a/b, then *nextcg will container the next (the only)\ndirectory which he can see in the path - 'c'.\n\nBeyond this, regular DAC permissions should apply, with the\nroot-in-user-namespace privilege over its mapped uids being respected. The\nfc_may_access check does this check for both directories and files.\n\nThis is CVE-2015-1342 (LP: #1508481)\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
    "before_after_code_files": [
      "Makefile.am||Makefile.am",
      "lxcfs.c||lxcfs.c",
      "tests/test_confinement.sh||tests/test_confinement.sh",
      "tests/test_syscalls.c||tests/test_syscalls.c"
    ]
  },
  "patch_diff": {
    "Makefile.am||Makefile.am": [
      "File: Makefile.am -> Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: TEST_READ: tests/test-read.c",
      "31:  $(CC) -o tests/test-read tests/test-read.c",
      "33: TEST_CPUSET: tests/cpusetrange.c cpuset.c",
      "34:  $(CC) -o tests/cpusetrange tests/cpusetrange.c cpuset.c",
      "38: distclean:",
      "39:  rm -rf .deps/ \\",
      "",
      "[Removed Lines]",
      "36: tests: TEST_READ TEST_CPUSET",
      "",
      "[Added Lines]",
      "34: TEST_SYSCALLS: tests/test_syscalls.c",
      "35:  $(CC) -o tests/test_syscalls tests/test_syscalls.c",
      "37: tests: TEST_READ TEST_CPUSET TEST_SYSCALLS",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "60:   lxcfs.o \\",
      "61:   m4/ \\",
      "62:   missing \\",
      "",
      "[Removed Lines]",
      "63:   stamp-h1",
      "",
      "[Added Lines]",
      "64:   stamp-h1 \\",
      "65:   tests/test_syscalls",
      "",
      "---------------"
    ],
    "lxcfs.c||lxcfs.c": [
      "File: lxcfs.c -> lxcfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "379: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
      "380: {",
      "383:  bool answer = false;",
      "392:   return false;",
      "420:   }",
      "421:   answer = true;",
      "422:   goto out;",
      "423:  }",
      "425: out:",
      "428:  return answer;",
      "429: }",
      "",
      "[Removed Lines]",
      "381:  char fnam[PROCLEN];",
      "382:  FILE *f;",
      "384:  char *line = NULL;",
      "385:  size_t len = 0;",
      "386:  int ret;",
      "388:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
      "389:  if (ret < 0 || ret >= PROCLEN)",
      "390:   return false;",
      "391:  if (!(f = fopen(fnam, \"r\")))",
      "394:  while (getline(&line, &len, f) != -1) {",
      "395:   char *c1, *c2, *linecmp;",
      "396:   if (!line[0])",
      "397:    continue;",
      "398:   c1 = strchr(line, ':');",
      "399:   if (!c1)",
      "400:    goto out;",
      "401:   c1++;",
      "402:   c2 = strchr(c1, ':');",
      "403:   if (!c2)",
      "404:    goto out;",
      "406:   if (strcmp(c1, contrl) != 0)",
      "407:    continue;",
      "408:   c2++;",
      "409:   stripnewline(c2);",
      "410:   prune_init_slice(c2);",
      "415:   linecmp = *cg == '/' ? c2 : c2+1;",
      "416:   if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "417:    if (nextcg)",
      "419:    goto out;",
      "426:  fclose(f);",
      "427:  free(line);",
      "",
      "[Added Lines]",
      "388:  char *c2 = get_pid_cgroup(pid, contrl);",
      "389:  char *linecmp;",
      "391:  if (!c2)",
      "393:  prune_init_slice(c2);",
      "399:  linecmp = *cg == '/' ? c2 : c2+1;",
      "400:  if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "401:   if (nextcg) {",
      "404:   goto out;",
      "405:  }",
      "406:  answer = true;",
      "408: out:",
      "409:  free(c2);",
      "410:  return answer;",
      "411: }",
      "416: static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)",
      "417: {",
      "418:  bool answer = false;",
      "419:  char *c2, *task_cg;",
      "420:  size_t target_len, task_len;",
      "422:  if (strcmp(cg, \"/\") == 0)",
      "423:   return true;",
      "425:  c2 = get_pid_cgroup(pid, contrl);",
      "427:  if (!c2)",
      "428:   return false;",
      "430:  task_cg = c2 + 1;",
      "431:  target_len = strlen(cg);",
      "432:  task_len = strlen(task_cg);",
      "433:  if (strcmp(cg, task_cg) == 0) {",
      "437:  if (target_len < task_len) {",
      "439:   if (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')",
      "440:    answer = true;",
      "441:   goto out;",
      "442:  }",
      "443:  if (target_len > task_len) {",
      "445:   if (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')",
      "446:    answer = true;",
      "447:   goto out;",
      "448:  }",
      "451:  free(c2);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "554:  if (is_child_cgroup(controller, path1, path2)) {",
      "555:   if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {",
      "557:    sb->st_mode = S_IFDIR | 00555;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "579:   if (!caller_may_see_dir(fc->pid, controller, cgroup)) {",
      "580:    ret = -ENOENT;",
      "581:    goto out;",
      "582:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "630:   }",
      "631:  }",
      "635:  }",
      "",
      "[Removed Lines]",
      "633:  if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
      "634:   return -EACCES;",
      "",
      "[Added Lines]",
      "661:  if (cgroup) {",
      "662:   if (!caller_may_see_dir(fc->pid, controller, cgroup))",
      "663:    return -ENOENT;",
      "664:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
      "665:    return -EACCES;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "780:  }",
      "781:  free_key(k);",
      "783:  if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {",
      "785:   ret = -EACCES;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "814:  if (!caller_may_see_dir(fc->pid, controller, path1)) {",
      "815:   ret = -ENOENT;",
      "816:   goto out;",
      "817:  }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1563: int cg_mkdir(const char *path, mode_t mode)",
      "1564: {",
      "1565:  struct fuse_context *fc = fuse_get_context();",
      "1567:  const char *cgroup;",
      "1568:  int ret;",
      "",
      "[Removed Lines]",
      "1566:  char *fpath = NULL, *path1, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1601:  char *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1585:  else",
      "1586:   path1 = cgdir;",
      "1588:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {",
      "1589:   ret = -EACCES;",
      "1590:   goto out;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1623:  if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {",
      "1624:   if (fpath && strcmp(next, fpath) == 0)",
      "1625:    ret = -EEXIST;",
      "1626:   else",
      "1627:    ret = -ENOENT;",
      "1628:   goto out;",
      "1629:  }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1600: out:",
      "1601:  free(cgdir);",
      "1602:  return ret;",
      "1603: }",
      "1605: static int cg_rmdir(const char *path)",
      "1606: {",
      "1607:  struct fuse_context *fc = fuse_get_context();",
      "1609:  const char *cgroup;",
      "1610:  int ret;",
      "",
      "[Removed Lines]",
      "1608:  char *fpath = NULL, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1645:  free(next);",
      "1652:  char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1626:   goto out;",
      "1627:  }",
      "1631:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {",
      "1632:   ret = -EACCES;",
      "1633:   goto out;",
      "",
      "[Removed Lines]",
      "1629:  fprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",",
      "1630:    controller, cgdir, path);",
      "",
      "[Added Lines]",
      "1673:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {",
      "1674:   if (!fpath || strcmp(next, fpath) == 0)",
      "1675:    ret = -EBUSY;",
      "1676:   else",
      "1677:    ret = -ENOENT;",
      "1678:   goto out;",
      "1679:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1647: out:",
      "1648:  free(cgdir);",
      "1649:  return ret;",
      "1650: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1699:  free(next);",
      "",
      "---------------"
    ],
    "tests/test_confinement.sh||tests/test_confinement.sh": [
      "File: tests/test_confinement.sh -> tests/test_confinement.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #!/bin/bash",
      "3: set -ex",
      "5: [ $(id -u) -eq 0 ]",
      "7: d=$(mktemp -t -d tmp.XXX)",
      "8: d2=$(mktemp -t -d tmp.XXX)",
      "10: pid=-1",
      "11: cleanup() {",
      "12:  [ $pid -ne -1 ] && kill -9 $pid",
      "13:  umount -l $d || true",
      "14:  umount -l $d2 || true",
      "15:  rm -rf $d $d2",
      "16: }",
      "18: cmdline=$(realpath $0)",
      "19: dirname=$(dirname ${cmdline})",
      "20: topdir=$(dirname ${dirname})",
      "22: trap cleanup EXIT HUP INT TERM",
      "24: ${topdir}/lxcfs $d &",
      "25: pid=$!",
      "27: # put ourselves into x1",
      "28: cgm movepidabs freezer / $$",
      "29: cgm create freezer x1",
      "30: cgm movepid freezer x1 $$",
      "32: mount -t cgroup -o freezer freezer $d2",
      "33: sudo rmdir $d2/lxcfs_test_a1/lxcfs_test_a2 || true",
      "34: sudo rmdir $d2/lxcfs_test_a1 || true",
      "36: echo \"Making sure root cannot mkdir\"",
      "37: bad=0",
      "38: mkdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "39: if [ \"${bad}\" -eq 1 ]; then",
      "40:  false",
      "41: fi",
      "43: echo \"Making sure root cannot rmdir\"",
      "44: mkdir $d2/lxcfs_test_a1",
      "45: mkdir $d2/lxcfs_test_a1/lxcfs_test_a2",
      "46: rmdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "47: if [ \"${bad}\" -eq 1 ]; then",
      "48:  false",
      "49: fi",
      "50: [ -d $d2/lxcfs_test_a1 ]",
      "51: rmdir $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2 && bad=1",
      "52: if [ \"${bad}\" -eq 1 ]; then",
      "53:  false",
      "54: fi",
      "55: [ -d $d2/lxcfs_test_a1/lxcfs_test_a2 ]",
      "57: echo \"Making sure root cannot read/write\"",
      "58: sleep 200 &",
      "59: p=$!",
      "60: echo $p > $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "61: if [ \"${bad}\" -eq 1 ]; then",
      "62:  false",
      "63: fi",
      "64: cat $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "65: if [ \"${bad}\" -eq 1 ]; then",
      "66:  false",
      "67: fi",
      "68: echo $p > $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "69: if [ \"${bad}\" -eq 1 ]; then",
      "70:  false",
      "71: fi",
      "72: cat $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "73: if [ \"${bad}\" -eq 1 ]; then",
      "74:  false",
      "75: fi",
      "77: # make sure things like truncate and access don't leak info about",
      "78: # the /lxcfs_test_a1 cgroup which we shouldn't be able to reach",
      "79: echo \"Testing other system calls\"",
      "80: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1",
      "81: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2",
      "83: echo \"Making sure root can act on descendents\"",
      "84: mycg=$(cgm getpidcgroupabs freezer $$)",
      "85: newcg=${mycg}/lxcfs_test_a1",
      "86: rmdir $d2/$newcg || true  # cleanup previosu run",
      "87: mkdir $d/cgroup/freezer/$newcg",
      "88: echo $p > $d/cgroup/freezer/$newcg/tasks",
      "89: cat $d/cgroup/freezer/$newcg/tasks",
      "90: kill -9 $p",
      "91: while [ `wc -l $d/cgroup/freezer/$newcg/tasks | awk '{ print $1 }'` -ne 0 ]; do",
      "92:  sleep 1",
      "93: done",
      "94: rmdir $d/cgroup/freezer/$newcg",
      "96: echo \"All tests passed!\"",
      "",
      "---------------"
    ],
    "tests/test_syscalls.c||tests/test_syscalls.c": [
      "File: tests/test_syscalls.c -> tests/test_syscalls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #define _GNU_SOURCE",
      "2: #include <stdio.h>",
      "3: #include <stdlib.h>",
      "4: #include <string.h>",
      "5: #include <unistd.h>",
      "6: #include <sys/types.h>",
      "7: #include <sys/socket.h>",
      "8: #include <linux/un.h>",
      "9: #include <attr/xattr.h>",
      "10: #include <utime.h>",
      "11: #include <sys/stat.h>",
      "12: #include <sys/mount.h>",
      "13: #include <libgen.h>",
      "14: #include <fcntl.h>",
      "15: #include <errno.h>",
      "18: void test_open(const char *path)",
      "19: {",
      "20:  int fd = open(path, O_RDONLY);",
      "21:  if (fd >= 0) {",
      "22:   fprintf(stderr, \"leak at open of %s\\n\", path);",
      "23:   exit(1);",
      "24:  }",
      "25:  if (errno != ENOENT) {",
      "26:   fprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);",
      "27:   exit(1);",
      "28:  }",
      "29: }",
      "31: void test_stat(const char *path)",
      "32: {",
      "33:  struct stat sb;",
      "34:  if (stat(path, &sb) >= 0) {",
      "35:   fprintf(stderr, \"leak at stat of %s\\n\", path);",
      "36:   exit(1);",
      "37:  }",
      "38:  if (errno != ENOENT) {",
      "39:   fprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);",
      "40:   exit(1);",
      "41:  }",
      "42: }",
      "44: void test_access(const char *path)",
      "45: {",
      "46:  if (access(path, O_RDONLY) >= 0) {",
      "47:   fprintf(stderr, \"leak at access of %s\\n\", path);",
      "48:   exit(1);",
      "49:  }",
      "50:  if (errno != ENOENT) {",
      "51:   fprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);",
      "52:   exit(1);",
      "53:  }",
      "54: }",
      "56: void test_bind(const char *path)",
      "57: {",
      "58:  int sfd;",
      "59:  struct sockaddr_un my_addr, peer_addr;",
      "61:  sfd = socket(AF_UNIX, SOCK_STREAM, 0);",
      "63:  if (sfd < 0) {",
      "64:   fprintf(stderr, \"Failed to open a socket for bind test\\n\");",
      "65:   exit(1);",
      "66:  }",
      "67:  memset(&my_addr, 0, sizeof(struct sockaddr_un));",
      "68:  my_addr.sun_family = AF_UNIX;",
      "69:  strncpy(my_addr.sun_path, path,",
      "70:    sizeof(my_addr.sun_path) - 1);",
      "71:  if (bind(sfd, (struct sockaddr *) &my_addr,",
      "72:     sizeof(struct sockaddr_un)) != -1) {",
      "73:   fprintf(stderr, \"leak at bind of %s\\n\", path);",
      "74:   exit(1);",
      "75:  }",
      "76:  if (errno != ENOENT && errno != ENOSYS) {",
      "77:   fprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));",
      "78:   exit(1);",
      "79:  }",
      "80:  close(sfd);",
      "81: }",
      "83: void test_bindmount(const char *path)",
      "84: {",
      "85:  if (mount(path, path, \"none\", MS_BIND, NULL) == 0) {",
      "86:   fprintf(stderr, \"leak at bind mount of %s\\n\", path);",
      "87:   exit(1);",
      "88:  }",
      "89: }",
      "91: void test_truncate(const char *path)",
      "92: {",
      "93:  if (truncate(path, 0) == 0) {",
      "94:   fprintf(stderr, \"leak at truncate of %s\\n\", path);",
      "95:   exit(1);",
      "96:  }",
      "97: }",
      "99: void test_chdir(const char *path)",
      "100: {",
      "101:  if (chdir(path) == 0) {",
      "102:   fprintf(stderr, \"leak at chdir to %s\\n\", path);",
      "103:   exit(1);",
      "104:  }",
      "105: }",
      "107: void test_rename(const char *path)",
      "108: {",
      "109:  char *d = strdupa(path), *tmpname;",
      "110:  d = dirname(d);",
      "111:  size_t len = strlen(path) + 30;",
      "113:  tmpname = alloca(len);",
      "114:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "115:  if (rename(path, tmpname) == 0 || errno != ENOENT) {",
      "116:   fprintf(stderr, \"leak at rename of %s\\n\", path);",
      "117:   exit(1);",
      "118:  }",
      "119: }",
      "121: void test_mkdir(const char *path)",
      "122: {",
      "123:  size_t len = strlen(path) + 30;",
      "124:  char *tmpname = alloca(len);",
      "125:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "127:  if (mkdir(path, 0755) == 0) {",
      "128:   fprintf(stderr, \"leak at mkdir of %s\\n\", path);",
      "129:   exit(1);",
      "130:  }",
      "131:  if (errno != ENOENT) {",
      "132:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "133:   exit(1);",
      "134:  }",
      "135:  if (mkdir(tmpname, 0755) == 0) {",
      "136:   fprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);",
      "137:   exit(1);",
      "138:  }",
      "139:  if (errno != ENOENT) {",
      "140:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "141:   exit(1);",
      "142:  }",
      "143: }",
      "145: void test_rmdir(const char *path)",
      "146: {",
      "147:  size_t len = strlen(path) + 30;",
      "148:  char *tmpname = alloca(len);",
      "149:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "151:  if (rmdir(path) == 0 || errno != ENOENT) {",
      "152:   fprintf(stderr, \"leak at rmdir of %s\\n\", path);",
      "153:   exit(1);",
      "154:  }",
      "155:  if (rmdir(tmpname) == 0 || errno != ENOENT) {",
      "156:   fprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);",
      "157:   exit(1);",
      "158:  }",
      "159: }",
      "161: void test_creat(const char *path)",
      "162: {",
      "163:  if (creat(path, 0755) >= 0) {",
      "164:   fprintf(stderr, \"leak at creat of %s\\n\", path);",
      "165:   exit(1);",
      "166:  }",
      "167:  if (errno != ENOENT && errno != ENOSYS) {",
      "168:   fprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));",
      "169:   exit(1);",
      "170:  }",
      "171: }",
      "173: void test_link(const char *path)",
      "174: {",
      "175:  char *d = strdupa(path), *tmpname;",
      "176:  d = dirname(d);",
      "177:  size_t len = strlen(path) + 30;",
      "178:  tmpname = alloca(len);",
      "179:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "181:  if (link(path, tmpname) == 0) {",
      "182:   fprintf(stderr, \"leak at link of %s\\n\", path);",
      "183:   exit(1);",
      "184:  }",
      "185:  if (errno != ENOENT && errno != ENOSYS) {",
      "186:   fprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));",
      "187:   exit(1);",
      "188:  }",
      "190:  if (link(tmpname, path) == 0) {",
      "191:   fprintf(stderr, \"leak at link (2) of %s\\n\", path);",
      "192:   exit(1);",
      "193:  }",
      "194:  if (errno != ENOENT && errno != ENOSYS) {",
      "195:   fprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "196:   exit(1);",
      "197:  }",
      "198: }",
      "200: void test_unlink(const char *path)",
      "201: {",
      "202:  if (unlink(path) == 0) {",
      "203:   fprintf(stderr, \"leak at unlink of %s\\n\", path);",
      "204:   exit(1);",
      "205:  }",
      "206:  if (errno != ENOENT && errno != ENOSYS) {",
      "207:   fprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));",
      "208:   exit(1);",
      "209:  }",
      "210: }",
      "212: void test_symlink(const char *path)",
      "213: {",
      "214:  char *d = strdupa(path), *tmpname;",
      "215:  d = dirname(d);",
      "216:  size_t len = strlen(path) + 30;",
      "217:  tmpname = alloca(len);",
      "218:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "220:  if (symlink(tmpname, path) == 0) {",
      "221:   fprintf(stderr, \"leak at symlink of %s\\n\", path);",
      "222:   exit(1);",
      "223:  }",
      "224:  if (errno != ENOENT && errno != ENOSYS) {",
      "225:   fprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));",
      "226:   exit(1);",
      "227:  }",
      "228:  if (symlink(path, tmpname) == 0) {",
      "229:   fprintf(stderr, \"leak at symlink (2) of %s\\n\", path);",
      "230:   exit(1);",
      "231:  }",
      "232:  if (errno != ENOENT && errno != ENOSYS) {",
      "233:   fprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "234:   exit(1);",
      "235:  }",
      "236: }",
      "238: void test_readlink(const char *path)",
      "239: {",
      "240:  char *dest = alloca(2 * strlen(path));",
      "242:  if (readlink(path, dest, 2 * strlen(path)) >= 0) {",
      "243:   fprintf(stderr, \"leak at readlink of %s\\n\", path);",
      "244:   exit(1);",
      "245:  }",
      "246:  if (errno != ENOENT && errno != ENOSYS) {",
      "247:   fprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));",
      "248:   exit(1);",
      "249:  }",
      "250: }",
      "252: void test_chmod(const char *path)",
      "253: {",
      "254:  if (chmod(path, 0755) == 0) {",
      "255:   fprintf(stderr, \"leak at chmod of %s\\n\", path);",
      "256:   exit(1);",
      "257:  }",
      "258:  if (errno != ENOENT && errno != ENOSYS) {",
      "259:   fprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));",
      "260:   exit(1);",
      "261:  }",
      "262: }",
      "264: void test_chown(const char *path)",
      "265: {",
      "266:  if (chown(path, 0, 0) == 0) {",
      "267:   fprintf(stderr, \"leak at chown of %s\\n\", path);",
      "268:   exit(1);",
      "269:  }",
      "270:  if (errno != ENOENT && errno != ENOSYS) {",
      "271:   fprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));",
      "272:   exit(1);",
      "273:  }",
      "274: }",
      "276: void test_lchown(const char *path)",
      "277: {",
      "278:  if (lchown(path, 0, 0) == 0) {",
      "279:   fprintf(stderr, \"leak at lchown of %s\\n\", path);",
      "280:   exit(1);",
      "281:  }",
      "282:  if (errno != ENOENT && errno != ENOSYS) {",
      "283:   fprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));",
      "284:   exit(1);",
      "285:  }",
      "286: }",
      "288: void test_mknod(const char *path)",
      "289: {",
      "290:  if (mknod(path, 0755, makedev(0, 0)) == 0) {",
      "291:   fprintf(stderr, \"leak at mknod of %s\\n\", path);",
      "292:   exit(1);",
      "293:  }",
      "294:  if (errno != ENOENT && errno != ENOSYS) {",
      "295:   fprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));",
      "296:   exit(1);",
      "297:  }",
      "298: }",
      "300: void test_chroot(const char *path)",
      "301: {",
      "302:  if (chroot(path) == 0) {",
      "303:   fprintf(stderr, \"leak at chroot of %s\\n\", path);",
      "304:   exit(1);",
      "305:  }",
      "306:  if (errno != ENOENT && errno != ENOSYS) {",
      "307:   fprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));",
      "308:   exit(1);",
      "309:  }",
      "310: }",
      "312: void test_xattrs(const char *path)",
      "313: {",
      "325:   char value[200];",
      "326:   if (getxattr(path, \"security.selinux\", value, 200) >= 0) {",
      "327:   fprintf(stderr, \"leak at getxattr of %s\\n\", path);",
      "328:   exit(1);",
      "329:  }",
      "330:  if (errno != ENOENT && errno != ENOSYS) {",
      "331:   fprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));",
      "332:   exit(1);",
      "333:  }",
      "334: }",
      "336: void test_utimes(const char *path)",
      "337: {",
      "338:  struct utimbuf times;",
      "339:  times.actime = 0;",
      "340:  times.modtime = 0;",
      "342:  if (utime(path, &times) == 0) {",
      "343:   fprintf(stderr, \"leak at utime of %s\\n\", path);",
      "344:   exit(1);",
      "345:  }",
      "346:  if (errno != ENOENT && errno != ENOSYS) {",
      "347:   fprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));",
      "348:   exit(1);",
      "349:  }",
      "350: }",
      "352: void test_openat(const char *path)",
      "353: {",
      "354:  char *d = strdupa(path), *f, *tmpname;",
      "355:  int fd, fd2;",
      "356:  f = basename(d);",
      "357:  d = dirname(d);",
      "358:  fd = open(d, O_RDONLY);",
      "359:  if (fd < 0) {",
      "360:   fprintf(stderr, \"Error in openat test: could not open parent dir\\n\");",
      "361:   fprintf(stderr, \"(this is expected on the second run)\\n\");",
      "362:   return;",
      "363:  }",
      "364:  fd2 = openat(fd, f, O_RDONLY);",
      "365:  if (fd2 >= 0 || errno != ENOENT) {",
      "366:   fprintf(stderr, \"leak at openat of %s\\n\", f);",
      "367:   exit(1);",
      "368:  }",
      "369:  size_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;",
      "370:  tmpname = alloca(len);",
      "371:  snprintf(tmpname, len, \"%s/cgroup.procs\", f);",
      "372:  fd2 = openat(fd, tmpname, O_RDONLY);",
      "373:  if (fd2 >= 0 || errno != ENOENT) {",
      "374:   fprintf(stderr, \"leak at openat of %s\\n\", tmpname);",
      "375:   exit(1);",
      "376:  }",
      "377:  close(fd);",
      "378: }",
      "380: int main(int argc, char *argv[])",
      "381: {",
      "382:  char *procspath;",
      "383:  size_t len;",
      "385:  if (geteuid() != 0) {",
      "386:   fprintf(stderr, \"Run me as root\\n\");",
      "387:   exit(1);",
      "388:  }",
      "390:  if (argc != 2)  {",
      "391:   fprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);",
      "392:   exit(1);",
      "393:  }",
      "396:  len = strlen(argv[1]) + strlen(\"/cgroup.procs\") + 1;",
      "397:  procspath = alloca(len);",
      "398:  snprintf(procspath, len, \"%s/cgroup.procs\", argv[1]);",
      "400:  test_open(argv[1]);",
      "401:  test_open(procspath);",
      "402:  test_stat(argv[1]);",
      "403:  test_stat(procspath);",
      "404:  test_access(argv[1]);",
      "405:  test_access(procspath);",
      "407:  test_bind(argv[1]);",
      "408:  test_bind(procspath);",
      "409:  test_bindmount(argv[1]);",
      "410:  test_bindmount(procspath);",
      "411:  test_truncate(argv[1]);",
      "412:  test_truncate(procspath);",
      "413:  test_chdir(argv[1]);",
      "414:  test_chdir(procspath);",
      "415:  test_rename(argv[1]);",
      "416:  test_rename(procspath);",
      "417:  test_mkdir(argv[1]);",
      "418:  test_mkdir(procspath);",
      "419:  test_rmdir(argv[1]);",
      "420:  test_rmdir(procspath);",
      "421:  test_creat(argv[1]);",
      "422:  test_creat(procspath);",
      "423:  test_link(argv[1]);",
      "424:  test_link(procspath);",
      "425:  test_unlink(argv[1]);",
      "426:  test_unlink(procspath);",
      "427:  test_symlink(argv[1]);",
      "428:  test_symlink(procspath);",
      "429:  test_readlink(argv[1]);",
      "430:  test_readlink(procspath);",
      "431:  test_chmod(argv[1]);",
      "432:  test_chmod(procspath);",
      "433:  test_chown(argv[1]);",
      "434:  test_chown(procspath);",
      "435:  test_lchown(argv[1]);",
      "436:  test_lchown(procspath);",
      "437:  test_mknod(argv[1]);",
      "438:  test_mknod(procspath);",
      "439:  test_chroot(argv[1]);",
      "440:  test_chroot(procspath);",
      "441:  test_xattrs(argv[1]);",
      "442:  test_xattrs(procspath);",
      "443:  test_utimes(argv[1]);",
      "444:  test_utimes(procspath);",
      "446:  test_openat(argv[1]);",
      "449:  printf(\"All tests passed\\n\");",
      "450:  return 0;",
      "451: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "febf2b87ddc44dd72cc440a33a24893afc13bc95",
      "candidate_info": {
        "commit_hash": "febf2b87ddc44dd72cc440a33a24893afc13bc95",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/febf2b87ddc44dd72cc440a33a24893afc13bc95",
        "files": [
          "cgfs.c",
          "lxcfs.c"
        ],
        "message": "Don't use tasks file to determine access rights to its cgroup\n\nAlso rename 'fpath' to 'last' when it is simply referring to the\nlast path element.\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "cgfs.c||cgfs.c",
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "cgfs.c||cgfs.c": [
          "File: cgfs.c -> cgfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "680:  if (!tmpc)",
          "681:   return false;",
          "684:   file++;",
          "687:   return NULL;",
          "691:  fnam = alloca(len);",
          "694:  ret = stat(fnam, &sb);",
          "695:  if (ret < 0)",
          "",
          "[Removed Lines]",
          "683:  if (*file == '/')",
          "686:  if (index(file, '/'))",
          "690:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + strlen(file) + 4;",
          "692:  snprintf(fnam, len, \"%s/%s/%s/%s\", basedir, tmpc, cgroup, file);",
          "",
          "[Added Lines]",
          "683:  if (file && *file == '/')",
          "686:  if (file && index(file, '/'))",
          "690:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + 3;",
          "691:  if (file)",
          "692:   len += strlen(file) + 1;",
          "694:  snprintf(fnam, len, \"%s/%s/%s/%s\", basedir, tmpc, cgroup,",
          "695:   file ? \"/\" : \"\", file ? file : \"\");",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "320:  struct cgfs_files *k = NULL;",
          "321:  bool ret = false;",
          "329:  k = cgfs_get_key(contrl, cg, file);",
          "330:  if (!k)",
          "331:   return false;",
          "",
          "[Removed Lines]",
          "323:  if (!file)",
          "324:   file = \"tasks\";",
          "326:  if (*file == '/')",
          "327:   file++;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "496: }",
          "502: {",
          "503:  char *p;",
          "505:  do {",
          "507:  } while (!*dir);",
          "511:   return;",
          "512:  }",
          "513:  p = strrchr(*dir, '/');",
          "",
          "[Removed Lines]",
          "501: static void get_cgdir_and_path(const char *cg, char **dir, char **file)",
          "509:  if (!*file) {",
          "",
          "[Added Lines]",
          "496: static void get_cgdir_and_path(const char *cg, char **dir, char **last)",
          "504:  if (!*last) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "523:  struct timespec now;",
          "524:  struct fuse_context *fc = fuse_get_context();",
          "525:  char * cgdir = NULL;",
          "527:  struct cgfs_files *k = NULL;",
          "528:  const char *cgroup;",
          "529:  const char *controller = NULL;",
          "",
          "[Removed Lines]",
          "526:  char *fpath = NULL, *path1, *path2;",
          "",
          "[Added Lines]",
          "521:  char *last = NULL, *path1, *path2;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "559:   return 0;",
          "560:  }",
          "565:   path1 = \"/\";",
          "566:   path2 = cgdir;",
          "567:  } else {",
          "568:   path1 = cgdir;",
          "570:  }",
          "576:  if (is_child_cgroup(controller, path1, path2)) {",
          "577:   if (!caller_may_see_dir(fc->pid, controller, cgroup)) {",
          "",
          "[Removed Lines]",
          "562:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "564:  if (!fpath) {",
          "569:   path2 = fpath;",
          "",
          "[Added Lines]",
          "557:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "559:  if (!last) {",
          "564:   path2 = last;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "595:   sb->st_mode = S_IFDIR | 00755;",
          "597:   if (!k) {",
          "598:    sb->st_uid = sb->st_gid = 0;",
          "599:   } else {",
          "",
          "[Removed Lines]",
          "596:   k = cgfs_get_key(controller, cgroup, \"tasks\");",
          "",
          "[Added Lines]",
          "591:   k = cgfs_get_key(controller, cgroup, NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "777: static int cg_open(const char *path, struct fuse_file_info *fi)",
          "778: {",
          "779:  const char *cgroup;",
          "781:  struct cgfs_files *k = NULL;",
          "782:  struct file_info *file_info;",
          "783:  struct fuse_context *fc = fuse_get_context();",
          "",
          "[Removed Lines]",
          "780:  char *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;",
          "",
          "[Added Lines]",
          "775:  char *last = NULL, *path1, *path2, * cgdir = NULL, *controller;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "793:  if (!cgroup)",
          "794:   return -EINVAL;",
          "798:   path1 = \"/\";",
          "799:   path2 = cgdir;",
          "800:  } else {",
          "801:   path1 = cgdir;",
          "803:  }",
          "805:  k = cgfs_get_key(controller, path1, path2);",
          "",
          "[Removed Lines]",
          "796:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "797:  if (!fpath) {",
          "802:   path2 = fpath;",
          "",
          "[Added Lines]",
          "791:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "792:  if (!last) {",
          "797:   path2 = last;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1539: int cg_chown(const char *path, uid_t uid, gid_t gid)",
          "1540: {",
          "1541:  struct fuse_context *fc = fuse_get_context();",
          "1543:  struct cgfs_files *k = NULL;",
          "1544:  const char *cgroup;",
          "1545:  int ret;",
          "",
          "[Removed Lines]",
          "1542:  char *cgdir = NULL, *fpath = NULL, *path1, *path2, *controller;",
          "",
          "[Added Lines]",
          "1537:  char *cgdir = NULL, *last = NULL, *path1, *path2, *controller;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1559:   return -EINVAL;",
          "1564:   path1 = \"/\";",
          "1565:   path2 = cgdir;",
          "1566:  } else {",
          "1567:   path1 = cgdir;",
          "1569:  }",
          "1571:  if (is_child_cgroup(controller, path1, path2)) {",
          "",
          "[Removed Lines]",
          "1561:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "1563:  if (!fpath) {",
          "1568:   path2 = fpath;",
          "",
          "[Added Lines]",
          "1556:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1558:  if (!last) {",
          "1563:   path2 = last;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1604: int cg_chmod(const char *path, mode_t mode)",
          "1605: {",
          "1606:  struct fuse_context *fc = fuse_get_context();",
          "1608:  struct cgfs_files *k = NULL;",
          "1609:  const char *cgroup;",
          "1610:  int ret;",
          "",
          "[Removed Lines]",
          "1607:  char * cgdir = NULL, *fpath = NULL, *path1, *path2, *controller;",
          "",
          "[Added Lines]",
          "1602:  char * cgdir = NULL, *last = NULL, *path1, *path2, *controller;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1624:   return -EINVAL;",
          "1629:   path1 = \"/\";",
          "1630:   path2 = cgdir;",
          "1631:  } else {",
          "1632:   path1 = cgdir;",
          "1634:  }",
          "1636:  if (is_child_cgroup(controller, path1, path2)) {",
          "",
          "[Removed Lines]",
          "1626:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "1628:  if (!fpath) {",
          "1633:   path2 = fpath;",
          "",
          "[Added Lines]",
          "1621:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1623:  if (!last) {",
          "1628:   path2 = last;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1672: int cg_mkdir(const char *path, mode_t mode)",
          "1673: {",
          "1674:  struct fuse_context *fc = fuse_get_context();",
          "1676:  const char *cgroup;",
          "1677:  int ret;",
          "",
          "[Removed Lines]",
          "1675:  char *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
          "",
          "[Added Lines]",
          "1670:  char *last = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1688:  if (!cgroup)",
          "1689:   return -EINVAL;",
          "1693:   path1 = \"/\";",
          "1694:  else",
          "1695:   path1 = cgdir;",
          "1697:  if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {",
          "1699:    ret = -EEXIST;",
          "1700:   else",
          "1701:    ret = -ENOENT;",
          "",
          "[Removed Lines]",
          "1691:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "1692:  if (!fpath)",
          "1698:   if (fpath && strcmp(next, fpath) == 0)",
          "",
          "[Added Lines]",
          "1686:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1687:  if (!last)",
          "1693:   if (last && strcmp(next, last) == 0)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1722: static int cg_rmdir(const char *path)",
          "1723: {",
          "1724:  struct fuse_context *fc = fuse_get_context();",
          "1726:  const char *cgroup;",
          "1727:  int ret;",
          "",
          "[Removed Lines]",
          "1725:  char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;",
          "",
          "[Added Lines]",
          "1720:  char *last = NULL, *cgdir = NULL, *controller, *next = NULL;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1737:  if (!cgroup)",
          "1738:   return -EINVAL;",
          "1742:   ret = -EINVAL;",
          "1743:   goto out;",
          "1744:  }",
          "1746:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {",
          "1748:    ret = -EBUSY;",
          "1749:   else",
          "1750:    ret = -ENOENT;",
          "",
          "[Removed Lines]",
          "1740:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "1741:  if (!fpath) {",
          "1747:   if (!fpath || strcmp(next, fpath) == 0)",
          "",
          "[Added Lines]",
          "1735:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1736:  if (!last) {",
          "1742:   if (!last || strcmp(next, last) == 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fa47bb52fe020e64ff07876770d808588cdcda82",
      "candidate_info": {
        "commit_hash": "fa47bb52fe020e64ff07876770d808588cdcda82",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/fa47bb52fe020e64ff07876770d808588cdcda82",
        "files": [
          ".gitignore",
          "Makefile.am",
          "cpuset.c",
          "lxcfs.c",
          "tests/cpusetrange.c"
        ],
        "message": "Fix the check for cpu being in cpuset range\n\nAlso add a testcase to make sure that the new function is correct.\nIn order to share the cpuset range checking code with with the\ntest, move it into cpuset.c.  Not sure whether we want that in a\nutils.c instead.\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "cpuset.c||cpuset.c",
          "lxcfs.c||lxcfs.c",
          "tests/cpusetrange.c||tests/cpusetrange.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: bin_PROGRAMS = lxcfs",
          "18: EXTRA_DIST = \\",
          "19:  lxcfs.man.add",
          "",
          "[Removed Lines]",
          "16: lxcfs_SOURCES = lxcfs.c cgmanager.c cgmanager.h",
          "",
          "[Added Lines]",
          "16: lxcfs_SOURCES = lxcfs.c cgmanager.c cgmanager.h cpuset.c",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28: TEST_READ: tests/test-read.c",
          "29:  $(CC) -o tests/test-read tests/test-read.c",
          "33: distclean:",
          "34:  rm -rf .deps/ \\",
          "",
          "[Removed Lines]",
          "31: tests: TEST_READ",
          "",
          "[Added Lines]",
          "31: TEST_CPUSET: tests/cpusetrange.c cpuset.c",
          "32:  $(CC) -o tests/cpusetrange tests/cpusetrange.c cpuset.c",
          "34: tests: TEST_READ TEST_CPUSET",
          "",
          "---------------"
        ],
        "cpuset.c||cpuset.c": [
          "File: cpuset.c -> cpuset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <stdio.h>",
          "2: #include <string.h>",
          "3: #include <stdbool.h>",
          "4: #include <stdlib.h>",
          "9: static char *cpuset_nexttok(const char *c)",
          "10: {",
          "11:  char *r = strchr(c+1, ',');",
          "12:  if (r)",
          "13:   return r+1;",
          "14:  return NULL;",
          "15: }",
          "17: static int cpuset_getrange(const char *c, int *a, int *b)",
          "18: {",
          "19:  int ret;",
          "21:  ret = sscanf(c, \"%d-%d\", a, b);",
          "22:  return ret;",
          "23: }",
          "29: bool cpu_in_cpuset(int cpu, const char *cpuset)",
          "30: {",
          "31:  const char *c;",
          "33:  for (c = cpuset; c; c = cpuset_nexttok(c)) {",
          "34:   int a, b, ret;",
          "36:   ret = cpuset_getrange(c, &a, &b);",
          "37:   if (ret == 1 && cpu == a) // \"1\" or \"1,6\"",
          "38:    return true;",
          "39:   else if (ret == 2 && cpu >= a && cpu <= b) // range match",
          "40:    return true;",
          "41:  }",
          "43:  return false;",
          "44: }",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1684:  return answer;",
          "1685: }",
          "1729: static bool cpuline_in_cpuset(const char *line, const char *cpuset)",
          "1730: {",
          "",
          "[Removed Lines]",
          "1690: char *cpuset_nexttok(const char *c)",
          "1691: {",
          "1692:  char *r = strchr(c+1, ',');",
          "1693:  if (r)",
          "1694:   return r+1;",
          "1695:  return NULL;",
          "1696: }",
          "1698: int cpuset_getrange(const char *c, int *a, int *b)",
          "1699: {",
          "1700:  int ret;",
          "1702:  ret = sscanf(c, \"%d-%d\", a, b);",
          "1703:  return ret;",
          "1704: }",
          "1710: static bool cpu_in_cpuset(int cpu, const char *cpuset)",
          "1711: {",
          "1712:  const char *c;",
          "1714:  for (c = cpuset; c; c = cpuset_nexttok(c)) {",
          "1715:   int a, b, ret;",
          "1717:   ret = cpuset_getrange(c, &a, &b);",
          "1718:   if (ret == 1 && cpu == a)",
          "1719:    return true;",
          "1720:   if (ret != 2) // bad cpuset!",
          "1721:    return false;",
          "1722:   if (cpu >= a && cpu <= b)",
          "1723:    return true;",
          "1724:  }",
          "1726:  return false;",
          "1727: }",
          "",
          "[Added Lines]",
          "1687: bool cpu_in_cpuset(int cpu, const char *cpuset);",
          "",
          "---------------"
        ],
        "tests/cpusetrange.c||tests/cpusetrange.c": [
          "File: tests/cpusetrange.c -> tests/cpusetrange.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <stdio.h>",
          "2: #include <string.h>",
          "3: #include <stdbool.h>",
          "4: #include <stdlib.h>",
          "10: extern bool cpu_in_cpuset(int cpu, const char *cpuset);",
          "12: void verify(bool condition) {",
          "13:  if (condition) {",
          "14:   printf(\" PASS\\n\");",
          "15:  } else {",
          "16:   printf(\" FAIL!\\n\");",
          "17:   exit(1);",
          "18:  }",
          "19: }",
          "21: int main() {",
          "22:  char *a = \"1,2\";",
          "23:  char *b = \"1-3,5\";",
          "24:  char *c = \"1,4-5\";",
          "25:  char *d = \"\";",
          "26:  char *e = \"\\n\";",
          "28:  printf(\"1 in %s\", a);",
          "29:  verify(cpu_in_cpuset(1, a));",
          "30:  printf(\"2 in %s\", a);",
          "31:  verify(cpu_in_cpuset(2, a));",
          "32:  printf(\"NOT 4 in %s\", a);",
          "33:  verify(!cpu_in_cpuset(4, a));",
          "34:  printf(\"1 in %s\", b);",
          "35:  verify(cpu_in_cpuset(1, b));",
          "36:  printf(\"NOT 4 in %s\", b);",
          "37:  verify(!cpu_in_cpuset(4, b));",
          "38:  printf(\"5 in %s\", b);",
          "39:  verify(cpu_in_cpuset(5, b));",
          "40:  printf(\"1 in %s\", c);",
          "41:  verify(cpu_in_cpuset(1, c));",
          "42:  printf(\"5 in %s\", c);",
          "43:  verify(cpu_in_cpuset(5, c));",
          "44:  printf(\"NOT 6 in %s\", c);",
          "45:  verify(!cpu_in_cpuset(6, c));",
          "46:  printf(\"NOT 6 in empty set\");",
          "47:  verify(!cpu_in_cpuset(6, d));",
          "48:  printf(\"NOT 6 in empty set(2)\");",
          "49:  verify(!cpu_in_cpuset(6, e));",
          "50: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ab54b798968bb26c60aed2bd3c1b24a48063cfbe",
      "candidate_info": {
        "commit_hash": "ab54b798968bb26c60aed2bd3c1b24a48063cfbe",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/ab54b798968bb26c60aed2bd3c1b24a48063cfbe",
        "files": [
          "cgmanager.c",
          "cgmanager.h",
          "lxcfs.c"
        ],
        "message": "Implement mkdir\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "cgmanager.c||cgmanager.c",
          "cgmanager.h||cgmanager.h",
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "cgmanager.c||cgmanager.c": [
          "File: cgmanager.c -> cgmanager.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include <sys/param.h>",
          "40: #include <sys/inotify.h>",
          "41: #include <sys/mount.h>",
          "42: #include <netinet/in.h>",
          "43: #include <net/if.h>",
          "44: #include <stdbool.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: #include <sys/wait.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:  cgm_dbus_disconnect();",
          "225:  return true;",
          "226: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "229: static int wait_for_pid(pid_t pid)",
          "230: {",
          "231:  int status, ret;",
          "233: again:",
          "234:  ret = waitpid(pid, &status, 0);",
          "235:  if (ret == -1) {",
          "236:   if (errno == EINTR)",
          "237:    goto again;",
          "238:   return -1;",
          "239:  }",
          "240:  if (ret != pid)",
          "241:   goto again;",
          "242:  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)",
          "243:   return -1;",
          "244:  return 0;",
          "245: }",
          "247: bool cgm_create(const char *controller, const char *cg, uid_t uid, gid_t gid)",
          "248: {",
          "249:  int32_t e;",
          "250:  pid_t pid = fork();",
          "252:  if (pid) {",
          "253:   if (wait_for_pid(pid) != 0)",
          "254:    return false;",
          "255:   return true;",
          "256:  }",
          "258:  if (setgroups(0, NULL))",
          "259:   exit(1);",
          "260:  if (setresgid(gid, gid, gid))",
          "261:   exit(1);",
          "262:  if (setresuid(uid, uid, uid))",
          "263:   exit(1);",
          "265:  if (!cgm_dbus_connect()) {",
          "266:   exit(1);",
          "267:  }",
          "269:  if ( cgmanager_create_sync(NULL, cgroup_manager, controller, cg, &e) != 0) {",
          "270:   NihError *nerr;",
          "271:   nerr = nih_error_get();",
          "272:   fprintf(stderr, \"call to create failed: %s\", nerr->message);",
          "273:   nih_free(nerr);",
          "274:   cgm_dbus_disconnect();",
          "275:   exit(1);",
          "276:  }",
          "278:  cgm_dbus_disconnect();",
          "279:  exit(0);",
          "280: }",
          "282: #if 0",
          "283: bool cgm_chown(const char *controller, const char *cg, uid_t uid, gid_t gid)",
          "284: {",
          "285:  if (!cgm_dbus_connect()) {",
          "286:   return false;",
          "287:  }",
          "289:  if ( cgmanager_chown_sync(NULL, cgroup_manager, controller, cg, uid, gid) != 0) {",
          "290:   NihError *nerr;",
          "291:   nerr = nih_error_get();",
          "292:   fprintf(stderr, \"call to chown failed: %s\", nerr->message);",
          "293:   nih_free(nerr);",
          "294:   cgm_dbus_disconnect();",
          "295:   return false;",
          "296:  }",
          "298:  cgm_dbus_disconnect();",
          "299:  return true;",
          "300: }",
          "302: bool cgm_remove(const char *controller, const char *cg)",
          "303: {",
          "304:  int32_t r = 1, e;",
          "306:  if (!cgm_dbus_connect()) {",
          "307:   return false;",
          "308:  }",
          "310:  if ( cgmanager_remove_sync(NULL, cgroup_manager, controller, cg, r, &e) != 0) {",
          "311:   NihError *nerr;",
          "312:   nerr = nih_error_get();",
          "313:   fprintf(stderr, \"call to remove failed: %s\", nerr->message);",
          "314:   nih_free(nerr);",
          "315:   cgm_dbus_disconnect();",
          "316:   return false;",
          "317:  }",
          "319:  cgm_dbus_disconnect();",
          "320:  return true;",
          "321: }",
          "322: #endif",
          "",
          "---------------"
        ],
        "cgmanager.h||cgmanager.h": [
          "File: cgmanager.h -> cgmanager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: char *cgm_get_pid_cgroup(pid_t pid, const char *controller);",
          "11: bool cgm_get_value(const char *controller, const char *cgroup, const char *file,",
          "12:   char **value);",
          "14: bool cgm_escape_cgroup(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: bool cgm_create(const char *controller, const char *cg, uid_t uid, gid_t gid);",
          "14: #if 0",
          "15: bool cgm_chown(const char *controller, const char *cg, uid_t uid, gid_t gid);",
          "16: bool cgm_remove(const char *controller, const char *cg);",
          "17: #endif",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "380:   return 0;",
          "381:  }",
          "384: }",
          "386: static int cg_opendir(const char *path, struct fuse_file_info *fi)",
          "",
          "[Removed Lines]",
          "383:  return -EINVAL;",
          "",
          "[Added Lines]",
          "383:  return -ENOENT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "555:  return -EINVAL;",
          "556: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "558: int cg_mkdir(const char *path, mode_t mode)",
          "559: {",
          "560:  struct fuse_context *fc = fuse_get_context();",
          "561:  nih_local struct cgm_keys **list = NULL;",
          "562:  char *fpath = NULL, *path1;",
          "563:  nih_local char * cgdir = NULL;",
          "564:  const char *cgroup;",
          "565:  nih_local char *controller = NULL;",
          "567: fprintf(stderr, \"XXX cg_mkdir: starting for %s\\n\", path);",
          "568:  if (!fc)",
          "569:   return -EIO;",
          "572:  controller = pick_controller_from_path(fc, path);",
          "573:  if (!controller)",
          "574:   return -EIO;",
          "576:  cgroup = find_cgroup_in_path(path);",
          "577:  if (!cgroup)",
          "578:   return -EIO;",
          "580:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "581:  if (!fpath)",
          "582:   path1 = \"/\";",
          "583:  else",
          "584:   path1 = cgdir;",
          "586:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR))",
          "587:   return -EPERM;",
          "590:  if (!cgm_create(controller, cgroup, fc->uid, fc->gid))",
          "591:   return -EINVAL;",
          "593:  return 0;",
          "594: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "565:  .readlink = NULL,",
          "566:  .getdir = NULL,",
          "567:  .mknod = NULL,",
          "569:  .unlink = NULL,",
          "570:  .rmdir = NULL,",
          "571:  .symlink = NULL,",
          "",
          "[Removed Lines]",
          "568:  .mkdir = NULL,",
          "",
          "[Added Lines]",
          "606:  .mkdir = cg_mkdir,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "737:  return 0;",
          "738: }",
          "740: const struct fuse_operations lxcfs_ops = {",
          "741:  .getattr = lxcfs_getattr,",
          "742:  .readlink = NULL,",
          "743:  .getdir = NULL,",
          "744:  .mknod = NULL,",
          "746:  .unlink = NULL,",
          "747:  .rmdir = NULL,",
          "748:  .symlink = NULL,",
          "",
          "[Removed Lines]",
          "745:  .mkdir = NULL,",
          "",
          "[Added Lines]",
          "778: int lxcfs_mkdir(const char *path, mode_t mode)",
          "779: {",
          "780:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "781:   return cg_mkdir(path, mode);",
          "783:  return -EINVAL;",
          "784: }",
          "791:  .mkdir = lxcfs_mkdir,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5e7d2556ba8e15091b29d086812f0fd936439b3",
      "candidate_info": {
        "commit_hash": "e5e7d2556ba8e15091b29d086812f0fd936439b3",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/e5e7d2556ba8e15091b29d086812f0fd936439b3",
        "files": [
          ".gitignore",
          "tests/test_cgroup",
          "tests/test_confinement.sh",
          "tests/test_meminfo_hierarchy.sh",
          "tests/test_read_proc.sh"
        ],
        "message": "Don't hardcode strings in testsuites\n\nWith this, we should be able to run more than one testsuite at once.\n\nSigned-off-by: St\u00e9phane Graber <stgraber@ubuntu.com>",
        "before_after_code_files": [
          "tests/test_confinement.sh||tests/test_confinement.sh",
          "tests/test_meminfo_hierarchy.sh||tests/test_meminfo_hierarchy.sh",
          "tests/test_read_proc.sh||tests/test_read_proc.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/test_confinement.sh||tests/test_confinement.sh"
          ],
          "candidate": [
            "tests/test_confinement.sh||tests/test_confinement.sh"
          ]
        }
      },
      "candidate_diff": {
        "tests/test_confinement.sh||tests/test_confinement.sh": [
          "File: tests/test_confinement.sh -> tests/test_confinement.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: set -ex",
          "5: [ $(id -u) -eq 0 ]",
          "7: d=$(mktemp -t -d tmp.XXX)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: UUID=$(uuidgen)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: cgm movepid freezer x1 1",
          "32: mount -t cgroup -o freezer freezer $d2",
          "36: echo \"Making sure root cannot mkdir\"",
          "37: bad=0",
          "39: if [ \"${bad}\" -eq 1 ]; then",
          "40:  false",
          "41: fi",
          "43: echo \"Making sure root cannot rmdir\"",
          "47: if [ \"${bad}\" -eq 1 ]; then",
          "48:  false",
          "49: fi",
          "52: if [ \"${bad}\" -eq 1 ]; then",
          "53:  false",
          "54: fi",
          "57: echo \"Making sure root cannot read/write\"",
          "58: sleep 200 &",
          "59: p=$!",
          "61: if [ \"${bad}\" -eq 1 ]; then",
          "62:  false",
          "63: fi",
          "65: if [ \"${bad}\" -eq 1 ]; then",
          "66:  false",
          "67: fi",
          "69: if [ \"${bad}\" -eq 1 ]; then",
          "70:  false",
          "71: fi",
          "73: if [ \"${bad}\" -eq 1 ]; then",
          "74:  false",
          "75: fi",
          "77: # make sure things like truncate and access don't leak info about",
          "79: echo \"Testing other system calls\"",
          "83: echo \"Making sure root can act on descendents\"",
          "84: mycg=$(cgm getpidcgroupabs freezer 1)",
          "86: rmdir $d2/$newcg || true  # cleanup previosu run",
          "87: mkdir $d/cgroup/freezer/$newcg",
          "88: echo $p > $d/cgroup/freezer/$newcg/tasks",
          "",
          "[Removed Lines]",
          "33: sudo rmdir $d2/lxcfs_test_a1/lxcfs_test_a2 || true",
          "34: sudo rmdir $d2/lxcfs_test_a1 || true",
          "38: mkdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
          "44: mkdir $d2/lxcfs_test_a1",
          "45: mkdir $d2/lxcfs_test_a1/lxcfs_test_a2",
          "46: rmdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
          "50: [ -d $d2/lxcfs_test_a1 ]",
          "51: rmdir $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2 && bad=1",
          "55: [ -d $d2/lxcfs_test_a1/lxcfs_test_a2 ]",
          "60: echo $p > $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
          "64: cat $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
          "68: echo $p > $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
          "72: cat $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
          "78: # the /lxcfs_test_a1 cgroup which we shouldn't be able to reach",
          "80: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1",
          "81: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2",
          "85: newcg=${mycg}/lxcfs_test_a1",
          "",
          "[Added Lines]",
          "35: sudo rmdir $d2/${UUID}_a1/${UUID}_a2 || true",
          "36: sudo rmdir $d2/${UUID}_a1 || true",
          "40: mkdir $d/cgroup/freezer/${UUID}_a1 && bad=1",
          "46: mkdir $d2/${UUID}_a1",
          "47: mkdir $d2/${UUID}_a1/${UUID}_a2",
          "48: rmdir $d/cgroup/freezer/${UUID}_a1 && bad=1",
          "52: [ -d $d2/${UUID}_a1 ]",
          "53: rmdir $d/cgroup/freezer/${UUID}_a1/${UUID}_a2 && bad=1",
          "57: [ -d $d2/${UUID}_a1/${UUID}_a2 ]",
          "62: echo $p > $d/cgroup/freezer/${UUID}_a1/tasks && bad=1",
          "66: cat $d/cgroup/freezer/${UUID}_a1/tasks && bad=1",
          "70: echo $p > $d/cgroup/freezer/${UUID}_a1/${UUID}_a2/tasks && bad=1",
          "74: cat $d/cgroup/freezer/${UUID}_a1/${UUID}_a2/tasks && bad=1",
          "80: # the /${UUID}_a1 cgroup which we shouldn't be able to reach",
          "82: ${dirname}/test_syscalls $d/cgroup/freezer/${UUID}_a1",
          "83: ${dirname}/test_syscalls $d/cgroup/freezer/${UUID}_a1/${UUID}_a2",
          "87: newcg=${mycg}/${UUID}_a1",
          "",
          "---------------"
        ],
        "tests/test_meminfo_hierarchy.sh||tests/test_meminfo_hierarchy.sh": [
          "File: tests/test_meminfo_hierarchy.sh -> tests/test_meminfo_hierarchy.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: LXCFSDIR=${LXCFSDIR:-/var/lib/lxcfs}",
          "10: cleanup() {",
          "11:  if [ $FAILED -eq 1 ]; then",
          "",
          "[Removed Lines]",
          "7: cg1=x1.$$",
          "8: cg2=x2.$$",
          "",
          "[Added Lines]",
          "7: cg1=$(uuidgen).$$",
          "8: cg2=$(uuidgen).$$",
          "",
          "---------------"
        ],
        "tests/test_read_proc.sh||tests/test_read_proc.sh": [
          "File: tests/test_read_proc.sh -> tests/test_read_proc.sh"
        ]
      }
    },
    {
      "candidate_hash": "2c51f8dd8610f0ff89aa757329aae6117a54611a",
      "candidate_info": {
        "commit_hash": "2c51f8dd8610f0ff89aa757329aae6117a54611a",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/2c51f8dd8610f0ff89aa757329aae6117a54611a",
        "files": [
          "Makefile.am",
          "cgmanager.c",
          "cgmanager.h",
          "configure.ac",
          "lxcfs.c",
          "lxcfs_mkdir.c"
        ],
        "message": "swap out libnih and libnih-dbus for glib\n\nThe motivation is to make threading possible, to hopefully greatly\nspeed up systemd startup inside containers.\n\nThis required converting all the nih-ified memory tracking.  (Some\nof this can probably be done smarter in a more glib-friendly way, i.e.\navoiding doing a glib string alloc followed by strdup followed by\nfreeing the glib string)\n\nWe open a single dbus connection for all threads to use.  If that\nconnection is closed (i.e. cgmanager exits / restarts) the first\ntask to find it so takes a mutex and attempts to reconnect, once\nper second, until it is reconnected.\n\nWhen creating a directory for non-root user, execute a new binary\nto get a clean dbus session as that user.\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "cgmanager.c||cgmanager.c",
          "cgmanager.h||cgmanager.h",
          "configure.ac||configure.ac",
          "lxcfs.c||lxcfs.c",
          "lxcfs_mkdir.c||lxcfs_mkdir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: VERSION_REVISION = 0",
          "8: VERSION_AGE      = 0",
          "16: lxcfs_SOURCES = lxcfs.c cgmanager.c cgmanager.h cpuset.c",
          "18: EXTRA_DIST = \\",
          "19:  lxcfs.man.add",
          "",
          "[Removed Lines]",
          "10: AM_CFLAGS = -Wall -ggdb -D_GNU_SOURCE -DSBINDIR=\\\"$(SBINDIR)\\\"",
          "11: AM_CFLAGS += $(DBUS_CFLAGS) $(NIH_CFLAGS) $(NIH_DBUS_CFLAGS) $(CGMANAGER_CFLAGS) $(FUSE_CFLAGS)",
          "12: AM_LDFLAGS = $(DBUS_LIBS) $(NIH_LIBS) $(NIH_DBUS_LIBS) $(CGMANAGER_LIBS) $(FUSE_LIBS)",
          "14: bin_PROGRAMS = lxcfs",
          "",
          "[Added Lines]",
          "10: AM_CFLAGS = -Wall -ggdb -D_GNU_SOURCE -DSBINDIR=\\\"$(SBINDIR)\\\" -pthread",
          "11: AM_CFLAGS += $(DBUS_CFLAGS) $(FUSE_CFLAGS) $(GLIB_CFLAGS) $(GLIBDBUS_CFLAGS) $(GIO_CFLAGS)",
          "12: AM_LDFLAGS = $(DBUS_LIBS) $(FUSE_LIBS) $(GLIB_LIBS) -pthread $(GLIBDBUS_LIBS) $(GIO_LIBS)",
          "14: bin_PROGRAMS = lxcfs lxcfs_mkdir",
          "17: lxcfs_mkdir_SOURCES = lxcfs_mkdir.c cgmanager.c cgmanager.h cpuset.c",
          "",
          "---------------"
        ],
        "cgmanager.c||cgmanager.c": [
          "File: cgmanager.c -> cgmanager.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: #include <netinet/in.h>",
          "44: #include <net/if.h>",
          "45: #include <stdbool.h>",
          "59: {",
          "66: }",
          "70: {",
          "106:  }",
          "108: }",
          "111: {",
          "114:  }",
          "123:  }",
          "126:  return true;",
          "127: }",
          "130: {",
          "131:  if (!cgm_dbus_connect()) {",
          "132:   return false;",
          "133:  }",
          "142:   return false;",
          "143:  }",
          "146:  return true;",
          "147: }",
          "150: {",
          "161:   return false;",
          "162:  }",
          "165:  return true;",
          "166: }",
          "169: {",
          "187: }",
          "190: {",
          "202:  }",
          "206: }",
          "209: {",
          "212:  }",
          "222:  }",
          "226: }",
          "230: {",
          "232:   return false;",
          "243:  }",
          "246:  return true;",
          "247: }",
          "251: {",
          "263:   return false;",
          "264:  }",
          "267:  return true;",
          "268: }",
          "271: {",
          "286: }",
          "289: {",
          "321: }",
          "324: {",
          "335:   return false;",
          "339:  return true;",
          "340: }",
          "343: {",
          "359: }",
          "361: bool cgm_remove(const char *controller, const char *cg)",
          "362: {",
          "384: }",
          "",
          "[Removed Lines]",
          "47: #include <nih-dbus/dbus_connection.h>",
          "48: #include <cgmanager/cgmanager-client.h>",
          "49: #include <nih/alloc.h>",
          "50: #include <nih/error.h>",
          "51: #include <nih/string.h>",
          "53: #include \"cgmanager.h\"",
          "55: static __thread NihDBusProxy *cgroup_manager = NULL;",
          "56: static __thread int32_t api_version;",
          "58: static void cgm_dbus_disconnect(void)",
          "60:        if (cgroup_manager) {",
          "61:         dbus_connection_flush(cgroup_manager->connection);",
          "62:         dbus_connection_close(cgroup_manager->connection);",
          "63:                nih_free(cgroup_manager);",
          "64:        }",
          "65:        cgroup_manager = NULL;",
          "68: #define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
          "69: static bool cgm_dbus_connect(void)",
          "71:  DBusError dbus_error;",
          "72:  static DBusConnection *connection;",
          "74:  dbus_error_init(&dbus_error);",
          "76:  connection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);",
          "77:  if (!connection) {",
          "78:   fprintf(stderr, \"Failed opening dbus connection: %s: %s\\n\",",
          "79:     dbus_error.name, dbus_error.message);",
          "80:   dbus_error_free(&dbus_error);",
          "81:   return false;",
          "82:  }",
          "83:  dbus_connection_set_exit_on_disconnect(connection, FALSE);",
          "84:  dbus_error_free(&dbus_error);",
          "85:  cgroup_manager = nih_dbus_proxy_new(NULL, connection,",
          "86:     NULL /* p2p */,",
          "87:     \"/org/linuxcontainers/cgmanager\", NULL, NULL);",
          "88:  dbus_connection_unref(connection);",
          "89:  if (!cgroup_manager) {",
          "90:   NihError *nerr;",
          "91:   nerr = nih_error_get();",
          "92:   fprintf(stderr, \"Error opening cgmanager proxy: %s\\n\", nerr->message);",
          "93:   nih_free(nerr);",
          "94:   cgm_dbus_disconnect();",
          "95:   return false;",
          "96:  }",
          "99:  if (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {",
          "100:   NihError *nerr;",
          "101:   nerr = nih_error_get();",
          "102:   fprintf(stderr, \"Error cgroup manager api version: %s\\n\", nerr->message);",
          "103:   nih_free(nerr);",
          "104:   cgm_dbus_disconnect();",
          "105:   return false;",
          "107:  return true;",
          "110: bool cgm_get_controllers(char ***contrls)",
          "112:  if (!cgm_dbus_connect()) {",
          "113:   return false;",
          "116:  if ( cgmanager_list_controllers_sync(NULL, cgroup_manager, contrls) != 0 ) {",
          "117:   NihError *nerr;",
          "118:   nerr = nih_error_get();",
          "119:   fprintf(stderr, \"call to list_controllers failed: %s\\n\", nerr->message);",
          "120:   nih_free(nerr);",
          "121:   cgm_dbus_disconnect();",
          "122:   return false;",
          "125:  cgm_dbus_disconnect();",
          "129: bool cgm_list_keys(const char *controller, const char *cgroup, struct cgm_keys ***keys)",
          "135:  if ( cgmanager_list_keys_sync(NULL, cgroup_manager, controller, cgroup,",
          "136:     (CgmanagerListKeysOutputElement ***)keys) != 0 ) {",
          "137:   NihError *nerr;",
          "138:   nerr = nih_error_get();",
          "139:   fprintf(stderr, \"call to list_keys (%s:%s) failed: %s\\n\", controller, cgroup, nerr->message);",
          "140:   nih_free(nerr);",
          "141:   cgm_dbus_disconnect();",
          "145:  cgm_dbus_disconnect();",
          "149: bool cgm_list_children(const char *controller, const char *cgroup, char ***list)",
          "151:  if (!cgm_dbus_connect()) {",
          "152:   return false;",
          "153:  }",
          "155:  if ( cgmanager_list_children_sync(NULL, cgroup_manager, controller, cgroup, list) != 0 ) {",
          "156:   NihError *nerr;",
          "157:   nerr = nih_error_get();",
          "158:   fprintf(stderr, \"call to list_children (%s:%s) failed: %s\\n\", controller, cgroup, nerr->message);",
          "159:   nih_free(nerr);",
          "160:   cgm_dbus_disconnect();",
          "164:  cgm_dbus_disconnect();",
          "168: char *cgm_get_pid_cgroup(pid_t pid, const char *controller)",
          "170:  char *output = NULL;",
          "172:  if (!cgm_dbus_connect()) {",
          "173:   return NULL;",
          "174:  }",
          "176:  if ( cgmanager_get_pid_cgroup_sync(NULL, cgroup_manager, controller, pid, &output) != 0 ) {",
          "177:   NihError *nerr;",
          "178:   nerr = nih_error_get();",
          "179:   fprintf(stderr, \"call to get_pid_cgroup (%s) failed: %s\\n\", controller, nerr->message);",
          "180:   nih_free(nerr);",
          "181:   cgm_dbus_disconnect();",
          "182:   return NULL;",
          "183:  }",
          "185:  cgm_dbus_disconnect();",
          "186:  return output;",
          "189: bool cgm_escape_cgroup(void)",
          "191:  if (!cgm_dbus_connect()) {",
          "192:   return false;",
          "193:  }",
          "195:  if ( cgmanager_move_pid_abs_sync(NULL, cgroup_manager, \"all\", \"/\", (int32_t) getpid()) != 0 ) {",
          "196:   NihError *nerr;",
          "197:   nerr = nih_error_get();",
          "198:   fprintf(stderr, \"call to move_pid_abs (all:/) failed: %s\\n\", nerr->message);",
          "199:   nih_free(nerr);",
          "200:   cgm_dbus_disconnect();",
          "201:   return false;",
          "204:  cgm_dbus_disconnect();",
          "205:  return true;",
          "208: bool cgm_move_pid(const char *controller, const char *cgroup, pid_t pid)",
          "210:  if (!cgm_dbus_connect()) {",
          "211:   return false;",
          "214:  if ( cgmanager_move_pid_sync(NULL, cgroup_manager, controller, cgroup,",
          "215:     (int32_t) pid) != 0 ) {",
          "216:   NihError *nerr;",
          "217:   nerr = nih_error_get();",
          "218:   fprintf(stderr, \"call to move_pid (%s:%s, %d) failed: %s\\n\", controller, cgroup, pid, nerr->message);",
          "219:   nih_free(nerr);",
          "220:   cgm_dbus_disconnect();",
          "221:   return false;",
          "224:  cgm_dbus_disconnect();",
          "225:  return true;",
          "228: bool cgm_get_value(const char *controller, const char *cgroup, const char *file,",
          "229:   char **value)",
          "231:  if (!cgm_dbus_connect()) {",
          "233:  }",
          "235:  if ( cgmanager_get_value_sync(NULL, cgroup_manager, controller, cgroup,",
          "236:    file, value) != 0 ) {",
          "237:   NihError *nerr;",
          "238:   nerr = nih_error_get();",
          "239:   fprintf(stderr, \"call to get_value (%s:%s, %s) failed: %s\\n\", controller, cgroup, file, nerr->message);",
          "240:   nih_free(nerr);",
          "241:   cgm_dbus_disconnect();",
          "242:   return false;",
          "245:  cgm_dbus_disconnect();",
          "249: bool cgm_set_value(const char *controller, const char *cgroup, const char *file,",
          "250:   const char *value)",
          "252:  if (!cgm_dbus_connect()) {",
          "253:   return false;",
          "254:  }",
          "256:  if ( cgmanager_set_value_sync(NULL, cgroup_manager, controller, cgroup,",
          "257:    file, value) != 0 ) {",
          "258:   NihError *nerr;",
          "259:   nerr = nih_error_get();",
          "260:   fprintf(stderr, \"call to set_value (%s:%s, %s, %s) failed: %s\\n\", controller, cgroup, file, value, nerr->message);",
          "261:   nih_free(nerr);",
          "262:   cgm_dbus_disconnect();",
          "266:  cgm_dbus_disconnect();",
          "270: static int wait_for_pid(pid_t pid)",
          "272:  int status, ret;",
          "274: again:",
          "275:  ret = waitpid(pid, &status, 0);",
          "276:  if (ret == -1) {",
          "277:   if (errno == EINTR)",
          "278:    goto again;",
          "279:   return -1;",
          "280:  }",
          "281:  if (ret != pid)",
          "282:   goto again;",
          "283:  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)",
          "284:   return -1;",
          "285:  return 0;",
          "288: bool cgm_create(const char *controller, const char *cg, uid_t uid, gid_t gid)",
          "290:  int32_t e;",
          "291:  pid_t pid = fork();",
          "293:  if (pid) {",
          "294:   if (wait_for_pid(pid) != 0)",
          "295:    return false;",
          "296:   return true;",
          "297:  }",
          "299:  if (setgroups(0, NULL))",
          "300:   _exit(1);",
          "301:  if (setresgid(gid, gid, gid))",
          "302:   _exit(1);",
          "303:  if (setresuid(uid, uid, uid))",
          "304:   _exit(1);",
          "306:  if (!cgm_dbus_connect()) {",
          "307:   _exit(1);",
          "308:  }",
          "310:  if ( cgmanager_create_sync(NULL, cgroup_manager, controller, cg, &e) != 0) {",
          "311:   NihError *nerr;",
          "312:   nerr = nih_error_get();",
          "313:   fprintf(stderr, \"call to create failed (%s:%s): %s\\n\", controller, cg, nerr->message);",
          "314:   nih_free(nerr);",
          "315:   cgm_dbus_disconnect();",
          "316:   _exit(1);",
          "317:  }",
          "319:  cgm_dbus_disconnect();",
          "320:  _exit(0);",
          "323: bool cgm_chown_file(const char *controller, const char *cg, uid_t uid, gid_t gid)",
          "325:  if (!cgm_dbus_connect()) {",
          "326:   return false;",
          "327:  }",
          "329:  if ( cgmanager_chown_sync(NULL, cgroup_manager, controller, cg, uid, gid) != 0) {",
          "330:   NihError *nerr;",
          "331:   nerr = nih_error_get();",
          "332:   fprintf(stderr, \"call to chown (%s:%s, %d, %d) failed: %s\\n\", controller, cg, uid, gid, nerr->message);",
          "333:   nih_free(nerr);",
          "334:   cgm_dbus_disconnect();",
          "336:  }",
          "338:  cgm_dbus_disconnect();",
          "342: bool cgm_chmod_file(const char *controller, const char *file, mode_t mode)",
          "344:  if (!cgm_dbus_connect()) {",
          "345:   return false;",
          "346:  }",
          "348:  if ( cgmanager_chmod_sync(NULL, cgroup_manager, controller, file, \"\", mode) != 0) {",
          "349:   NihError *nerr;",
          "350:   nerr = nih_error_get();",
          "351:   fprintf(stderr, \"call to chmod (%s:%s, %d) failed: %s\\n\", controller, file, mode, nerr->message);",
          "352:   nih_free(nerr);",
          "353:   cgm_dbus_disconnect();",
          "354:   return false;",
          "355:  }",
          "357:  cgm_dbus_disconnect();",
          "358:  return true;",
          "367:  int32_t r = 0, e;",
          "369:  if (!cgm_dbus_connect()) {",
          "370:   return false;",
          "371:  }",
          "373:  if ( cgmanager_remove_sync(NULL, cgroup_manager, controller, cg, r, &e) != 0) {",
          "374:   NihError *nerr;",
          "375:   nerr = nih_error_get();",
          "376:   fprintf(stderr, \"call to remove (%s:%s) failed: %s\\n\", controller, cg, nerr->message);",
          "377:   nih_free(nerr);",
          "378:   cgm_dbus_disconnect();",
          "379:   return false;",
          "380:  }",
          "382:  cgm_dbus_disconnect();",
          "383:  return true;",
          "",
          "[Added Lines]",
          "42: #include \"cgmanager.h\"",
          "43: #include <assert.h>",
          "45: #include <glib.h>",
          "46: #include <gio/gio.h>",
          "48: #define CGM_DBUS_ADDRESS          \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
          "49: #define CGM_REQUIRED_VERSION      9  // we need list_keys",
          "51: static GDBusConnection *cgroup_manager = NULL;",
          "53: static pthread_mutex_t cgm_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "55: static void lock_mutex(pthread_mutex_t *l)",
          "57:  int ret;",
          "58:  if ((ret = pthread_mutex_lock(l)) != 0) {",
          "59:   fprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));",
          "60:   exit(1);",
          "61:  }",
          "64: static void unlock_mutex(pthread_mutex_t *l)",
          "66:  int ret;",
          "67:  if ((ret = pthread_mutex_unlock(l)) != 0) {",
          "68:   fprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));",
          "69:   exit(1);",
          "70:  }",
          "71: }",
          "73: void cgm_lock(void)",
          "74: {",
          "75:  lock_mutex(&cgm_mutex);",
          "76: }",
          "78: void cgm_unlock(void)",
          "79: {",
          "80:  unlock_mutex(&cgm_mutex);",
          "81: }",
          "84: void cgm_dbus_disconnect(void)",
          "85: {",
          "86:  GError *error = NULL;",
          "88:  if (!cgroup_manager)",
          "89:   return;",
          "91:  if (!g_dbus_connection_flush_sync(cgroup_manager, NULL, &error)) {",
          "92:   g_warning(\"failed to flush connection: %s.\"",
          "93:     \"Use G_DBUS_DEBUG=message for more info.\", error->message);",
          "94:   g_error_free(error);",
          "96:  if (!g_dbus_connection_close_sync(cgroup_manager, NULL, &error)) {",
          "97:   g_warning(\"failed to close connection: %s.\"",
          "98:     \"Use G_DBUS_DEBUG=message for more info.\", error->message);",
          "99:   g_error_free(error);",
          "100:  }",
          "101:  g_object_unref(cgroup_manager);",
          "102:  cgroup_manager = NULL;",
          "105: bool cgm_dbus_connect(void)",
          "107:  GDBusConnection *connection;",
          "108:  GVariant *reply;",
          "109:  GVariant *version;",
          "110:  GError *error = NULL;",
          "113:  if (cgroup_manager && !g_dbus_connection_is_closed(cgroup_manager))",
          "114:   return true;",
          "116:  cgm_lock();",
          "119: retry:",
          "120:  if (cgroup_manager) {",
          "121:   if (!g_dbus_connection_is_closed(cgroup_manager)) {",
          "123:    cgm_unlock();",
          "124:    return true;",
          "125:   }",
          "126:   fprintf(stderr, \"cgmanager connection was closed\\n\");",
          "127:   g_object_unref(cgroup_manager);",
          "128:   cgroup_manager = NULL;",
          "131:  connection = g_dbus_connection_new_for_address_sync (CGM_DBUS_ADDRESS,",
          "132:    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT,",
          "133:    NULL, NULL, &error);",
          "134:  if (!connection) {",
          "135:   g_warning(\"Could not connect to cgmanager: %s\\n\"",
          "136:    \"Use G_DBUS_DEBUG=message for more info.\", error->message);",
          "137:   g_error_free(error);",
          "138:   error = NULL;",
          "139:   fprintf(stderr, \"Retrying...\\n\");",
          "140:   sleep(1);",
          "141:   goto retry;",
          "144:  reply = g_dbus_connection_call_sync (connection, NULL, \"/org/linuxcontainers/cgmanager\",",
          "145:    \"org.freedesktop.DBus.Properties\", \"Get\",",
          "146:    g_variant_new (\"(ss)\", \"org.linuxcontainers.cgmanager0_0\", \"api_version\"),",
          "147:    G_VARIANT_TYPE (\"(v)\"), G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);",
          "148:  if (!reply)",
          "149:  {",
          "150:   g_warning(\"Failed to get cgmanager api version: %s\\n\"",
          "151:    \"Use G_DBUS_DEBUG=message for more info.\", error->message);",
          "152:   g_error_free(error);",
          "153:   g_object_unref (connection);",
          "154:   cgm_unlock();",
          "155:   return false;",
          "156:  }",
          "157:  g_variant_get (reply, \"(v)\", &version);",
          "158:  g_variant_unref (reply);",
          "159:  if (!g_variant_is_of_type (version, G_VARIANT_TYPE_INT32) || g_variant_get_int32 (version) < CGM_REQUIRED_VERSION)",
          "160:  {",
          "161:   g_warning(\"Cgmanager does not meet minimal API version\");",
          "162:   g_object_unref (connection);",
          "163:   g_variant_unref (version);",
          "164:   cgm_unlock();",
          "165:   return false; }",
          "166:  g_variant_unref (version);",
          "167:  cgroup_manager = connection;",
          "169:  cgm_unlock();",
          "173: static bool cgcall(const gchar *method_name, GVariant *parameters,",
          "174:   const GVariantType *reply_type, GVariant **reply)",
          "176:  GVariant *my_reply = NULL;",
          "177:  GError *error = NULL;",
          "180:   g_warning(\"Error: unable to connect to cgmanager\");",
          "184:  if (!reply)",
          "185:   reply = &my_reply;",
          "190:    \"org.linuxcontainers.cgmanager0_0\", method_name,",
          "191:    parameters, reply_type, G_DBUS_CALL_FLAGS_NONE,",
          "192:    -1, NULL, &error);",
          "193:  if (!*reply)",
          "194:  {",
          "195:   if (reply_type)",
          "196:    g_warning (\"cgmanager method call org.linuxcontainers.cgmanager0_0.%s failed: %s.  \"",
          "197:      \"Use G_DBUS_DEBUG=message for more info.\", method_name, error->message);",
          "198:   g_error_free (error);",
          "201:  if (my_reply)",
          "202:   g_variant_unref (my_reply);",
          "209: #define MAX_CONTROLLERS 20",
          "210: bool cgm_get_controllers(char ***contrls)",
          "212:  char **list = NULL;",
          "213:  GVariantIter *iter = NULL;",
          "214:  GVariant *reply = NULL;",
          "215:  gchar *ctrl;",
          "216:  int i = 0;",
          "218:  if (!cgcall(\"ListControllers\", NULL, G_VARIANT_TYPE(\"(as)\"), &reply))",
          "221:  do {",
          "222:   list = malloc(MAX_CONTROLLERS * sizeof(*list));",
          "223:  } while (!list);",
          "224:  memset(list, 0, MAX_CONTROLLERS * sizeof(*list));",
          "225:  g_variant_get(reply, \"(as)\", &iter);",
          "226:  while (g_variant_iter_next(iter, \"s\", &ctrl)) {",
          "227:   if (i >= MAX_CONTROLLERS) {",
          "228:    g_warning(\"Too many cgroup subsystems\");",
          "229:    exit(1);",
          "230:   }",
          "231:   do {",
          "232:    list[i] = strdup(ctrl);",
          "233:   } while (!list[i]);",
          "234:   i++;",
          "235:   g_free(ctrl);",
          "237:  g_variant_iter_free(iter);",
          "238:  g_variant_unref(reply);",
          "244: void free_key(struct cgm_keys *k)",
          "246:  if (!k)",
          "247:   return;",
          "248:  free(k->name);",
          "249:  free(k);",
          "252: void free_keys(struct cgm_keys **keys)",
          "254:  int i;",
          "256:  if (!keys)",
          "257:   return;",
          "258:  for (i = 0; keys[i]; i++) {",
          "259:   free_key(keys[i]);",
          "261:  free(keys);",
          "264: #define BATCH_SIZE 50",
          "265: void append_key(struct cgm_keys ***keys, struct cgm_keys *newk, size_t *sz, size_t *asz)",
          "267:  assert(keys);",
          "268:  if (sz == 0) {",
          "271:   do {",
          "273:   } while (!*keys);",
          "274:   (*keys)[0] = newk;",
          "275:   (*keys)[1] = NULL;",
          "276:   return;",
          "278:  if (*sz + 2 >= *asz) {",
          "279:   struct cgm_keys **tmp;",
          "281:   do {",
          "282:    tmp = realloc(*keys, *asz * sizeof(struct cgm_keys *));",
          "283:   } while (!tmp);",
          "286:  (*keys)[(*sz)++] = newk;",
          "287:  (*keys)[(*sz)] = NULL;",
          "290: bool cgm_list_keys(const char *controller, const char *cgroup, struct cgm_keys ***keys)",
          "292:  GVariantIter *iter = NULL;",
          "293:  GVariant *reply = NULL;",
          "294:  size_t sz = 0, asz = 0;",
          "295:  gchar *name;",
          "296:  guint32 uid, gid, mode;",
          "298:  if (!cgcall(\"ListKeys\", g_variant_new(\"(ss)\", controller, cgroup),",
          "299:    G_VARIANT_TYPE(\"(a(suuu))\"), &reply))",
          "302:  g_variant_get(reply, \"(a(suuu))\", &iter);",
          "303:  while (g_variant_iter_next(iter, \"(suuu)\", &name, &uid, &gid, &mode)) {",
          "305:   struct cgm_keys *k;",
          "307:   do {",
          "308:    k = malloc(sizeof(*k));",
          "309:   } while (!k);",
          "310:   do {",
          "311:    k->name = strdup(name);",
          "312:   } while (!k->name);",
          "313:   k->uid = uid;",
          "314:   k->gid = gid;",
          "315:   k->mode = mode;",
          "316:   g_free(name);",
          "317:   append_key(keys, k, &sz, &asz);",
          "320:  g_variant_iter_free(iter);",
          "321:  g_variant_unref(reply);",
          "326: bool cgm_list_children(const char *controller, const char *cgroup, char ***list)",
          "328:  GVariantIter *iter = NULL;",
          "329:  GVariant *reply = NULL;",
          "330:  gchar *child;",
          "331:  size_t sz = 0, asz = 0;",
          "333:  if (!cgcall(\"ListChildren\", g_variant_new(\"(ss)\", controller, cgroup),",
          "334:    G_VARIANT_TYPE(\"(as)\"), &reply))",
          "337:  g_variant_get(reply, \"(as)\", &iter);",
          "338:  do {",
          "340:  } while (!*list);",
          "341:  (*list)[0] = NULL;",
          "342:  while (g_variant_iter_next(iter, \"s\", &child)) {",
          "343:   if (sz+2 >= asz) {",
          "344:    char **tmp;",
          "345:    asz += BATCH_SIZE;",
          "346:    do {",
          "347:     tmp = realloc(*list, asz * sizeof(char *));",
          "348:    } while  (!tmp);",
          "350:   }",
          "351:   do {",
          "352:    (*list)[sz] = strdup(child);",
          "353:   } while (!(*list)[sz]);",
          "354:   (*list)[sz+1] = NULL;",
          "355:   sz++;",
          "356:   g_free(child);",
          "359:  g_variant_iter_free(iter);",
          "360:  g_variant_unref(reply);",
          "365: bool cgm_escape_cgroup(void)",
          "367:  return cgcall(\"MovePidAbs\", g_variant_new(\"(ssi)\", \"all\", \"/\", getpid()),",
          "368:    G_VARIANT_TYPE_UNIT, NULL);",
          "371: bool cgm_move_pid(const char *controller, const char *cgroup, pid_t pid)",
          "373:  return cgcall(\"MovePid\", g_variant_new(\"(ssi)\", controller, cgroup, pid),",
          "374:    G_VARIANT_TYPE_UNIT, NULL);",
          "375: }",
          "377: bool cgm_get_value(const char *controller, const char *cgroup, const char *file,",
          "378:   char **value)",
          "379: {",
          "380:  GVariant *reply = NULL;",
          "381:  gchar *str;",
          "383:  if (!cgcall(\"GetValue\", g_variant_new(\"(sss)\", controller, cgroup, file),",
          "384:    G_VARIANT_TYPE(\"(s)\"), &reply))",
          "385:   return false;",
          "387:  g_variant_get(reply, \"(s)\", &str);",
          "388:  g_variant_unref(reply);",
          "390:  do {",
          "392:  } while (!*value);",
          "393:  g_free(str);",
          "395:  return true;",
          "398: bool cgm_set_value(const char *controller, const char *cgroup, const char *file,",
          "399:   const char *value)",
          "401:  return cgcall(\"SetValue\", g_variant_new(\"(ssss)\", controller, cgroup, file, value),",
          "402:    G_VARIANT_TYPE_UNIT, NULL);",
          "403: }",
          "405: bool cgm_create(const char *controller, const char *cg)",
          "406: {",
          "407:  if (!cgcall(\"Create\", g_variant_new(\"(ss)\", controller, cg),",
          "408:     G_VARIANT_TYPE (\"(i)\"), NULL))",
          "414: bool cgm_chown_file(const char *controller, const char *cg, uid_t uid, gid_t gid)",
          "416:  return cgcall(\"Chown\", g_variant_new(\"(ssii)\", controller, cg, uid, gid),",
          "417:    G_VARIANT_TYPE_UNIT, NULL);",
          "418: }",
          "420: bool cgm_chmod_file(const char *controller, const char *file, mode_t mode)",
          "421: {",
          "422:  return cgcall(\"Chmod\", g_variant_new(\"(sssi)\", controller, file, \"\", mode), G_VARIANT_TYPE_UNIT, NULL);",
          "427:  return cgcall(\"Remove\", g_variant_new (\"(ssi)\", \"all\", cg, 1), G_VARIANT_TYPE (\"(i)\"), NULL);",
          "",
          "---------------"
        ],
        "cgmanager.h||cgmanager.h": [
          "File: cgmanager.h -> cgmanager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3:  uint32_t uid, gid;",
          "4:  uint32_t mode;",
          "5: };",
          "7: bool cgm_get_controllers(char ***contrls);",
          "8: bool cgm_list_keys(const char *controller, const char *cgroup, struct cgm_keys ***keys);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: void free_key(struct cgm_keys *k);",
          "7: void free_keys(struct cgm_keys **keys);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "12:   char **value);",
          "13: bool cgm_set_value(const char *controller, const char *cgroup, const char *file,",
          "14:   const char *value);",
          "16: bool cgm_chown_file(const char *controller, const char *cg, uid_t uid, gid_t gid);",
          "17: bool cgm_chmod_file(const char *controller, const char *file, mode_t mode);",
          "18: bool cgm_remove(const char *controller, const char *cg);",
          "20: bool cgm_escape_cgroup(void);",
          "21: bool cgm_move_pid(const char *controller, const char *cgroup, pid_t pid);",
          "",
          "[Removed Lines]",
          "15: bool cgm_create(const char *controller, const char *cg, uid_t uid, gid_t gid);",
          "",
          "[Added Lines]",
          "17: bool cgm_create(const char *controller, const char *cg);",
          "25: void cgm_dbus_disconnect(void);",
          "26: bool cgm_dbus_connect(void);",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: AC_PROG_CC_C99",
          "27: PKG_CHECK_MODULES([CGMANAGER], [libcgmanager >= 0.0.0])",
          "28: PKG_CHECK_MODULES(FUSE, fuse)",
          "34: AC_PATH_PROG(HELP2MAN, help2man, false // No help2man //)",
          "35: AM_CONDITIONAL([HAVE_HELP2MAN], [test \"x$HELP2MAN\" != \"xfalse // No help2man //\" ])",
          "",
          "[Removed Lines]",
          "24: PKG_CHECK_MODULES([NIH], [libnih >= 1.0.2])",
          "25: PKG_CHECK_MODULES([NIH_DBUS], [libnih-dbus >= 1.0.0])",
          "26: PKG_CHECK_MODULES([DBUS], [dbus-1 >= 1.2.16])",
          "29: AC_CHECK_LIB(cgmanager, cgmanager_list_controllers_sync, [], AC_MSG_ERROR([\"cgmanager 0.35 or higher is required\"]))",
          "30: AC_CHECK_LIB(cgmanager, cgmanager_list_keys_sync, [], AC_MSG_ERROR([\"cgmanager 0.35 or higher is required\"]))",
          "31: AC_CHECK_LIB(nih, nih_alloc)",
          "32: AC_CHECK_FUNCS(nih_threadsafe, , , libnih)",
          "",
          "[Added Lines]",
          "24: AC_CHECK_LIB(pthread, main)",
          "26: PKG_CHECK_MODULES([GLIB], [glib-2.0])",
          "27: PKG_CHECK_MODULES([GLIBDBUS], [dbus-glib-1])",
          "28: PKG_CHECK_MODULES(GIO, gio-2.0)",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #define FUSE_USE_VERSION 26",
          "11: #include <stdio.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10:   and add libdbus-glib-1-dev, and libglib2.0-dev to build-deps.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25: #include <sys/mount.h>",
          "26: #include <wait.h>",
          "33: #include \"cgmanager.h\"",
          "34: #include \"config.h\" // for VERSION",
          "36: struct lxcfs_state {",
          "41:  char **subsystems;",
          "",
          "[Removed Lines]",
          "28: #include <nih-dbus/dbus_connection.h>",
          "29: #include <nih/alloc.h>",
          "30: #include <nih/string.h>",
          "31: #include <nih/error.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "66: #define BUF_RESERVE_SIZE 256",
          "68: static char *must_copy_string(void *parent, const char *str)",
          "69: {",
          "70:  if (!str)",
          "71:   return NULL;",
          "73: }",
          "",
          "[Removed Lines]",
          "72:  return NIH_MUST( nih_strdup(parent, str) );",
          "",
          "[Added Lines]",
          "73: static void must_strcat_pid(char **src, size_t *sz, size_t *asz, pid_t pid)",
          "74: {",
          "75:  char *d = *src;",
          "76:  char tmp[30];",
          "78:  sprintf(tmp, \"%d\\n\", (int)pid);",
          "80:  if (!d) {",
          "81:   do {",
          "82:    d = malloc(BUF_RESERVE_SIZE);",
          "83:   } while (!d);",
          "86:  } else if (strlen(tmp) + sz + 1 >= asz) {",
          "87:   do {",
          "88:    d = realloc(d, *asz + BUF_RESERVE_SIZE);",
          "89:   } while (!d);",
          "92:  }",
          "93:  memcpy(d+*sz, tmp, strlen(tmp));",
          "95:  d[*sz] = '\\0';",
          "96: }",
          "100:  char *dup = NULL;",
          "103:  do {",
          "104:   dup = strdup(str);",
          "105:  } while (!dup);",
          "107:  return dup;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "146: #define NS_ROOT_REQD true",
          "147: #define NS_ROOT_OPT false",
          "149: static bool is_privileged_over(pid_t pid, uid_t uid, uid_t victim, bool req_ns_root)",
          "150: {",
          "152:  bool answer = false;",
          "153:  uid_t nsuid;",
          "",
          "[Removed Lines]",
          "151:  nih_local char *fpath = NULL;",
          "",
          "[Added Lines]",
          "184: #define PROCLEN 100",
          "188:  char fpath[PROCLEN];",
          "189:  int ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "163:  if (!req_ns_root && uid == victim)",
          "164:   return true;",
          "167:  FILE *f = fopen(fpath, \"r\");",
          "168:  if (!f)",
          "169:   return false;",
          "",
          "[Removed Lines]",
          "166:  fpath = NIH_MUST( nih_sprintf(NULL, \"/proc/%d/uid_map\", pid) );",
          "",
          "[Added Lines]",
          "204:  ret = snprintf(fpath, PROCLEN, \"/proc/%d/uid_map\", pid);",
          "205:  if (ret < 0 || ret >= PROCLEN)",
          "206:   return false;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "219:  }",
          "221:  if (strcmp(querycg, \"/\") == 0)",
          "223:  else",
          "225:  end = strchr(start, '/');",
          "226:  if (end)",
          "228:  return start;",
          "229: }",
          "",
          "[Removed Lines]",
          "222:   start = NIH_MUST( nih_strdup(NULL, taskcg + 1) );",
          "224:   start = NIH_MUST( nih_strdup(NULL, taskcg + strlen(querycg) + 1) );",
          "",
          "[Added Lines]",
          "262:   start =  strdup(taskcg + 1);",
          "264:   start = strdup(taskcg + strlen(querycg) + 1);",
          "265:  if (!start)",
          "266:   return NULL;",
          "273: static void stripnewline(char *x)",
          "274: {",
          "275:  size_t l = strlen(x);",
          "276:  if (l && x[l-1] == '\\n')",
          "277:   x[l-1] = '\\0';",
          "278: }",
          "280: static char *get_pid_cgroup(pid_t pid, const char *contrl)",
          "281: {",
          "282:  char fnam[PROCLEN];",
          "283:  FILE *f;",
          "284:  char *answer = NULL;",
          "285:  char *line = NULL;",
          "286:  size_t len = 0;",
          "287:  int ret;",
          "289:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
          "290:  if (ret < 0 || ret >= PROCLEN)",
          "291:   return NULL;",
          "292:  if (!(f = fopen(fnam, \"r\")))",
          "293:   return NULL;",
          "295:  while (getline(&line, &len, f) != -1) {",
          "296:   char *c1, *c2;",
          "297:   if (!line[0])",
          "298:    continue;",
          "299:   c1 = strchr(line, ':');",
          "300:   if (!c1)",
          "301:    goto out;",
          "302:   c1++;",
          "303:   c2 = strchr(c1, ':');",
          "304:   if (!c2)",
          "305:    goto out;",
          "307:   if (strcmp(c1, contrl) != 0)",
          "308:    continue;",
          "309:   c2++;",
          "310:   stripnewline(c2);",
          "311:   do {",
          "312:    answer = strdup(c2);",
          "313:   } while (!answer);",
          "314:   break;",
          "315:  }",
          "317: out:",
          "318:  fclose(f);",
          "319:  free(line);",
          "320:  return answer;",
          "321: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "242: static bool fc_may_access(struct fuse_context *fc, const char *contrl, const char *cg, const char *file, mode_t mode)",
          "243: {",
          "245:  int i;",
          "247:  if (!file)",
          "",
          "[Removed Lines]",
          "244:  nih_local struct cgm_keys **list = NULL;",
          "",
          "[Added Lines]",
          "336:  struct cgm_keys **list = NULL;",
          "337:  bool ret = false;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "256:   if (strcmp(list[i]->name, file) == 0) {",
          "257:    struct cgm_keys *k = list[i];",
          "258:    if (is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT)) {",
          "261:    }",
          "262:    if (fc->gid == k->gid) {",
          "265:    }",
          "267:   }",
          "268:  }",
          "278: }",
          "280: #define INITSCOPE \"/init.scope\"",
          "",
          "[Removed Lines]",
          "259:     if (perms_include(k->mode >> 6, mode))",
          "260:      return true;",
          "263:     if (perms_include(k->mode >> 3, mode))",
          "264:      return true;",
          "266:    return perms_include(k->mode, mode);",
          "270:  return false;",
          "271: }",
          "273: static void stripnewline(char *x)",
          "274: {",
          "275:  size_t l = strlen(x);",
          "276:  if (l && x[l-1] == '\\n')",
          "277:   x[l-1] = '\\0';",
          "",
          "[Added Lines]",
          "352:     if (perms_include(k->mode >> 6, mode)) {",
          "353:      ret = true;",
          "354:      goto out;",
          "355:     }",
          "358:     if (perms_include(k->mode >> 3, mode)) {",
          "359:      ret = true;",
          "360:      goto out;",
          "361:     }",
          "363:    ret = perms_include(k->mode, mode);",
          "364:    goto out;",
          "368: out:",
          "369:  free_keys(list);",
          "370:  return ret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "301: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
          "302: {",
          "304:  FILE *f;",
          "305:  bool answer = false;",
          "306:  char *line = NULL;",
          "307:  size_t len = 0;",
          "310:  if (!(f = fopen(fnam, \"r\")))",
          "311:   return false;",
          "",
          "[Removed Lines]",
          "303:  nih_local char *fnam = NULL;",
          "309:  fnam = NIH_MUST( nih_sprintf(NULL, \"/proc/%d/cgroup\", pid) );",
          "",
          "[Added Lines]",
          "397:  char fnam[PROCLEN];",
          "402:  int ret;",
          "404:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
          "405:  if (ret < 0 || ret >= PROCLEN)",
          "406:   return false;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "348: }",
          "354: static char *pick_controller_from_path(struct fuse_context *fc, const char *path)",
          "355: {",
          "356:  const char *p1;",
          "359:  if (strlen(path) < 9)",
          "360:   return NULL;",
          "361:  if (*(path+7) != '/')",
          "362:   return NULL;",
          "363:  p1 = path+8;",
          "368:  if (slash)",
          "372:  char **list = LXCFS_DATA ? LXCFS_DATA->subsystems : NULL;",
          "373:  int i;",
          "376:   return NULL;",
          "378:  for (i = 0;  list[i];  i++) {",
          "381:  }",
          "383:  return NULL;",
          "384: }",
          "",
          "[Removed Lines]",
          "357:  char *ret, *slash;",
          "364:  ret = nih_strdup(NULL, p1);",
          "365:  if (!ret)",
          "366:   return ret;",
          "367:  slash = strstr(ret, \"/\");",
          "374:  if (!list) {",
          "375:   nih_free(ret);",
          "377:  }",
          "379:   if (strcmp(list[i], ret) == 0)",
          "380:    return ret;",
          "382:  nih_free(ret);",
          "",
          "[Added Lines]",
          "454:  char *contr, *slash;",
          "461:  contr = strdupa(p1);",
          "462:  if (!contr)",
          "463:   return NULL;",
          "464:  slash = strstr(contr, \"/\");",
          "471:  if (!list)",
          "474:   if (strcmp(list[i], contr) == 0)",
          "475:    return list[i];",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "402: static bool is_child_cgroup(const char *contr, const char *dir, const char *f)",
          "403: {",
          "405:  int i;",
          "407:  if (!f)",
          "",
          "[Removed Lines]",
          "404:  nih_local char **list = NULL;",
          "",
          "[Added Lines]",
          "498:  char **list;",
          "499:  bool ret = false;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "412:  if (!cgm_list_children(contr, dir, &list))",
          "413:   return false;",
          "414:  for (i = 0; list[i]; i++) {",
          "417:  }",
          "420: }",
          "422: static struct cgm_keys *get_cgroup_key(const char *contr, const char *dir, const char *f)",
          "423: {",
          "426:  int i;",
          "428:  if (!f)",
          "",
          "[Removed Lines]",
          "415:   if (strcmp(list[i], f) == 0)",
          "416:    return true;",
          "419:  return false;",
          "424:  nih_local struct cgm_keys **list = NULL;",
          "425:  struct cgm_keys *k;",
          "",
          "[Added Lines]",
          "510:   if (strcmp(list[i], f) == 0) {",
          "511:    ret = true;",
          "512:    goto out;",
          "513:   }",
          "516: out:",
          "517:  for (i = 0; list[i]; i++)",
          "518:   free(list[i]);",
          "519:  free(list);",
          "520:  return ret;",
          "525:  struct cgm_keys **list = NULL;",
          "526:  struct cgm_keys *k = NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "433:   return NULL;",
          "434:  for (i = 0; list[i]; i++) {",
          "435:   if (strcmp(list[i]->name, f) == 0) {",
          "441:    return k;",
          "442:   }",
          "443:  }",
          "445:  return NULL;",
          "446: }",
          "448: static void get_cgdir_and_path(const char *cg, char **dir, char **file)",
          "449: {",
          "450:  char *p;",
          "454:  if (!*file) {",
          "",
          "[Removed Lines]",
          "436:    k = NIH_MUST( nih_alloc(NULL, (sizeof(*k))) );",
          "437:    k->name = NIH_MUST( nih_strdup(k, list[i]->name) );",
          "438:    k->uid = list[i]->uid;",
          "439:    k->gid = list[i]->gid;",
          "440:    k->mode = list[i]->mode;",
          "",
          "[Added Lines]",
          "537:    int j;",
          "539:    k = list[i];",
          "540:    for (j = 0; list[j]; j++) {",
          "541:     if (i != j)",
          "542:      free(list[j]);",
          "543:    }",
          "544:    free(list);",
          "549:  free_keys(list);",
          "560:  do {",
          "562:  } while (!*dir);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "467: {",
          "468:  struct timespec now;",
          "469:  struct fuse_context *fc = fuse_get_context();",
          "471:  char *fpath = NULL, *path1, *path2;",
          "473:  const char *cgroup;",
          "477:  if (!fc)",
          "",
          "[Removed Lines]",
          "470:  nih_local char * cgdir = NULL;",
          "472:  nih_local struct cgm_keys *k = NULL;",
          "474:  nih_local char *controller = NULL;",
          "",
          "[Added Lines]",
          "580:  char * cgdir = NULL;",
          "582:  struct cgm_keys *k = NULL;",
          "584:  const char *controller = NULL;",
          "585:  int ret = -ENOENT;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "523:    sb->st_mode = S_IFDIR | 00555;",
          "524:    sb->st_nlink = 2;",
          "526:   }",
          "",
          "[Removed Lines]",
          "525:    return 0;",
          "527:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "528:    return -EACCES;",
          "",
          "[Added Lines]",
          "636:    ret = 0;",
          "637:    goto out;",
          "638:   }",
          "639:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
          "640:    ret = -EACCES;",
          "641:    goto out;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "537:    sb->st_uid = k->uid;",
          "538:    sb->st_gid = k->gid;",
          "539:   }",
          "540:   sb->st_nlink = 2;",
          "542:  }",
          "544:  if ((k = get_cgroup_key(controller, path1, path2)) != NULL) {",
          "550:   sb->st_mode = S_IFREG | k->mode;",
          "551:   sb->st_nlink = 1;",
          "552:   sb->st_uid = k->uid;",
          "553:   sb->st_gid = k->gid;",
          "554:   sb->st_size = 0;",
          "556:  }",
          "559: }",
          "",
          "[Removed Lines]",
          "541:   return 0;",
          "545:   if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL))",
          "546:    return -ENOENT;",
          "547:   if (!fc_may_access(fc, controller, path1, path2, O_RDONLY))",
          "548:    return -EACCES;",
          "555:   return 0;",
          "558:  return -ENOENT;",
          "",
          "[Added Lines]",
          "654:   free_key(k);",
          "656:   ret = 0;",
          "657:   goto out;",
          "666:   free_key(k);",
          "667:   if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL))",
          "668:    return -ENOENT;",
          "669:   if (!fc_may_access(fc, controller, path1, path2, O_RDONLY))",
          "670:    return -EACCES;",
          "672:   ret = 0;",
          "675: out:",
          "676:  free(cgdir);",
          "677:  return ret;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "565: static int cg_opendir(const char *path, struct fuse_file_info *fi)",
          "566: {",
          "567:  struct fuse_context *fc = fuse_get_context();",
          "569:  const char *cgroup;",
          "570:  struct file_info *dir_info;",
          "573:  if (!fc)",
          "574:   return -EIO;",
          "",
          "[Removed Lines]",
          "568:  nih_local struct cgm_keys **list = NULL;",
          "571:  nih_local char *controller = NULL;",
          "",
          "[Added Lines]",
          "689:  char *controller = NULL;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "589:   }",
          "590:  }",
          "593:   return -EACCES;",
          "597:  dir_info->controller = must_copy_string(dir_info, controller);",
          "598:  dir_info->cgroup = must_copy_string(dir_info, cgroup);",
          "599:  dir_info->type = LXC_TYPE_CGDIR;",
          "",
          "[Removed Lines]",
          "592:  if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "596:  dir_info = NIH_MUST( nih_alloc(NULL, sizeof(*dir_info)) );",
          "",
          "[Added Lines]",
          "710:  if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
          "712:  }",
          "715:  dir_info = malloc(sizeof(*dir_info));",
          "716:  if (!dir_info)",
          "717:   return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "609:   struct fuse_file_info *fi)",
          "610: {",
          "611:  struct file_info *d = (struct file_info *)fi->fh;",
          "615:  struct fuse_context *fc = fuse_get_context();",
          "617:  if (d->type != LXC_TYPE_CGDIR) {",
          "618:   fprintf(stderr, \"Internal error: file cache info used in readdir\\n\");",
          "",
          "[Removed Lines]",
          "612:  nih_local struct cgm_keys **list = NULL;",
          "613:  int i;",
          "614:  nih_local char *nextcg = NULL;",
          "",
          "[Added Lines]",
          "733:  struct cgm_keys **list = NULL;",
          "734:  int i, ret;",
          "735:  char *nextcg = NULL;",
          "737:  char **clist = NULL;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "634:   return 0;",
          "635:  }",
          "641:  if (!caller_is_in_ancestor(fc->pid, d->controller, d->cgroup, &nextcg)) {",
          "642:   if (nextcg) {",
          "643:    int ret;",
          "644:    ret = filler(buf, nextcg,  NULL, 0);",
          "647:   }",
          "649:  }",
          "651:  for (i = 0; list[i]; i++) {",
          "652:   if (filler(buf, list[i]->name, NULL, 0) != 0) {",
          "654:   }",
          "655:  }",
          "662:  for (i = 0; clist[i]; i++) {",
          "663:   if (filler(buf, clist[i], NULL, 0) != 0) {",
          "665:   }",
          "666:  }",
          "668: }",
          "670: static void do_release_file_info(struct file_info *f)",
          "671: {",
          "677: }",
          "679: static int cg_releasedir(const char *path, struct fuse_file_info *fi)",
          "",
          "[Removed Lines]",
          "637:  if (!cgm_list_keys(d->controller, d->cgroup, &list))",
          "639:   return -EINVAL;",
          "645:    if (ret != 0)",
          "646:     return -EIO;",
          "648:   return 0;",
          "653:    return -EIO;",
          "658:  nih_local char **clist = NULL;",
          "660:  if (!cgm_list_children(d->controller, d->cgroup, &clist))",
          "661:   return 0;",
          "664:    return -EIO;",
          "667:  return 0;",
          "676:  nih_free(f);",
          "",
          "[Added Lines]",
          "759:  if (!cgm_list_keys(d->controller, d->cgroup, &list)) {",
          "761:   ret = -EINVAL;",
          "762:   goto out;",
          "763:  }",
          "769:    free(nextcg);",
          "770:    if (ret != 0) {",
          "771:     ret = -EIO;",
          "772:     goto out;",
          "773:    }",
          "775:   ret = 0;",
          "776:   goto out;",
          "781:    ret = -EIO;",
          "782:    goto out;",
          "788:  if (!cgm_list_children(d->controller, d->cgroup, &clist)) {",
          "789:   ret = 0;",
          "790:   goto out;",
          "791:  }",
          "794:    ret = -EIO;",
          "795:    goto out;",
          "798:  ret = 0;",
          "800: out:",
          "801:  free_keys(list);",
          "802:  if (clist) {",
          "803:   for (i = 0; clist[i]; i++)",
          "804:    free(clist[i]);",
          "805:   free(clist);",
          "806:  }",
          "807:  return ret;",
          "812:  if (!f)",
          "813:   return;",
          "814:  free(f->controller);",
          "815:  free(f->cgroup);",
          "816:  free(f->file);",
          "817:  free(f->buf);",
          "818:  free(f);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "687: static int cg_open(const char *path, struct fuse_file_info *fi)",
          "688: {",
          "690:  const char *cgroup;",
          "694:  struct file_info *file_info;",
          "695:  struct fuse_context *fc = fuse_get_context();",
          "697:  if (!fc)",
          "698:   return -EIO;",
          "",
          "[Removed Lines]",
          "689:  nih_local char *controller = NULL;",
          "691:  char *fpath = NULL, *path1, *path2;",
          "692:  nih_local char * cgdir = NULL;",
          "693:  nih_local struct cgm_keys *k = NULL;",
          "",
          "[Added Lines]",
          "832:  char *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;",
          "833:  struct cgm_keys *k = NULL;",
          "836:  int ret;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "714:  }",
          "716:  k = get_cgroup_key(controller, path1, path2);",
          "726:  file_info->controller = must_copy_string(file_info, controller);",
          "727:  file_info->cgroup = must_copy_string(file_info, path1);",
          "728:  file_info->file = must_copy_string(file_info, path2);",
          "",
          "[Removed Lines]",
          "717:  if (!k)",
          "718:   return -EINVAL;",
          "720:  if (!fc_may_access(fc, controller, path1, path2, fi->flags))",
          "722:   return -EACCES;",
          "725:  file_info = NIH_MUST( nih_alloc(NULL, sizeof(*file_info)) );",
          "",
          "[Added Lines]",
          "858:  if (!k) {",
          "859:   ret = -EINVAL;",
          "860:   goto out;",
          "861:  }",
          "862:  free_key(k);",
          "864:  if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {",
          "866:   ret = -EACCES;",
          "867:   goto out;",
          "868:  }",
          "871:  file_info = malloc(sizeof(*file_info));",
          "872:  if (!file_info) {",
          "873:   ret = -ENOMEM;",
          "874:   goto out;",
          "875:  }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "731:  file_info->buflen = 0;",
          "733:  fi->fh = (unsigned long)file_info;",
          "735: }",
          "737: static int cg_release(const char *path, struct fuse_file_info *fi)",
          "",
          "[Removed Lines]",
          "734:  return 0;",
          "",
          "[Added Lines]",
          "884:  ret = 0;",
          "886: out:",
          "887:  free(cgdir);",
          "888:  return ret;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "967: static bool do_read_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, char **d)",
          "968: {",
          "969:  int sock[2] = {-1, -1};",
          "971:  int ret;",
          "972:  pid_t qpid, cpid = -1;",
          "973:  bool answer = false;",
          "974:  char v = '0';",
          "975:  struct ucred cred;",
          "976:  struct timeval tv;",
          "977:  fd_set s;",
          "979:  if (!cgm_get_value(contrl, cg, file, &tmpdata))",
          "",
          "[Removed Lines]",
          "970:  nih_local char *tmpdata = NULL;",
          "",
          "[Added Lines]",
          "1124:  char *tmpdata = NULL;",
          "1131:  size_t sz = 0, asz = 0;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "988:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "989:   perror(\"socketpair\");",
          "991:  }",
          "993:  cpid = fork();",
          "",
          "[Removed Lines]",
          "990:   exit(1);",
          "",
          "[Added Lines]",
          "1145:   free(tmpdata);",
          "1146:   return false;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1025:     __func__, strerror(errno));",
          "1026:    goto out;",
          "1027:   }",
          "1029: next:",
          "1030:   ptr = strchr(ptr, '\\n');",
          "1031:   if (!ptr)",
          "",
          "[Removed Lines]",
          "1028:   NIH_MUST( nih_strcat_sprintf(d, NULL, \"%d\\n\", qpid) );",
          "",
          "[Added Lines]",
          "1184:   must_strcat_pid(d, &sz, &asz, qpid);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1045:  answer = true;",
          "1047: out:",
          "1048:  if (cpid != -1)",
          "1049:   wait_for_pid(cpid);",
          "1050:  if (sock[0] != -1) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1204:  free(tmpdata);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1059: {",
          "1060:  struct fuse_context *fc = fuse_get_context();",
          "1061:  struct file_info *f = (struct file_info *)fi->fh;",
          "1064:  if (f->type != LXC_TYPE_CGFILE) {",
          "1065:   fprintf(stderr, \"Internal error: directory cache info used in cg_read\\n\");",
          "",
          "[Removed Lines]",
          "1062:  nih_local struct cgm_keys *k = NULL;",
          "",
          "[Added Lines]",
          "1219:  struct cgm_keys *k = NULL;",
          "1220:  char *data = NULL;",
          "1221:  int ret, s;",
          "1222:  bool r;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1075:  if (!f->controller)",
          "1076:   return -EINVAL;",
          "1109:  }",
          "1112: }",
          "1114: static void pid_from_ns(int sock, pid_t tpid)",
          "",
          "[Removed Lines]",
          "1078:  if ((k = get_cgroup_key(f->controller, f->cgroup, f->file)) != NULL) {",
          "1079:   nih_local char *data = NULL;",
          "1080:   int s;",
          "1081:   bool r;",
          "1083:   if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_RDONLY))",
          "1085:    return -EACCES;",
          "1087:   if (strcmp(f->file, \"tasks\") == 0 ||",
          "1088:     strcmp(f->file, \"/tasks\") == 0 ||",
          "1089:     strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "1090:     strcmp(f->file, \"cgroup.procs\") == 0)",
          "1092:    r = do_read_pids(fc->pid, f->controller, f->cgroup, f->file, &data);",
          "1093:   else",
          "1094:    r = cgm_get_value(f->controller, f->cgroup, f->file, &data);",
          "1096:   if (!r)",
          "1097:    return -EINVAL;",
          "1099:   if (!data)",
          "1100:    return 0;",
          "1101:   s = strlen(data);",
          "1102:   if (s > size)",
          "1103:    s = size;",
          "1104:   memcpy(buf, data, s);",
          "1105:   if (s > 0 && s < size && data[s-1] != '\\n')",
          "1106:    buf[s++] = '\\n';",
          "1108:   return s;",
          "1111:  return -EINVAL;",
          "",
          "[Added Lines]",
          "1238:  if ((k = get_cgroup_key(f->controller, f->cgroup, f->file)) == NULL) {",
          "1239:   return -EINVAL;",
          "1240:  }",
          "1241:  free_key(k);",
          "1244:  if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_RDONLY)) { // should never get here",
          "1245:   ret = -EACCES;",
          "1246:   goto out;",
          "1247:  }",
          "1249:  if (strcmp(f->file, \"tasks\") == 0 ||",
          "1250:    strcmp(f->file, \"/tasks\") == 0 ||",
          "1251:    strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "1252:    strcmp(f->file, \"cgroup.procs\") == 0)",
          "1254:   r = do_read_pids(fc->pid, f->controller, f->cgroup, f->file, &data);",
          "1255:  else",
          "1256:   r = cgm_get_value(f->controller, f->cgroup, f->file, &data);",
          "1258:  if (!r) {",
          "1259:   ret = -EINVAL;",
          "1260:   goto out;",
          "1261:  }",
          "1263:  if (!data) {",
          "1264:   ret = 0;",
          "1265:   goto out;",
          "1267:  s = strlen(data);",
          "1268:  if (s > size)",
          "1269:   s = size;",
          "1270:  memcpy(buf, data, s);",
          "1271:  if (s > 0 && s < size && data[s-1] != '\\n')",
          "1272:   buf[s++] = '\\n';",
          "1274:  ret = s;",
          "1276: out:",
          "1277:  free(data);",
          "1278:  return ret;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1283:       struct fuse_file_info *fi)",
          "1284: {",
          "1285:  struct fuse_context *fc = fuse_get_context();",
          "1288:  struct file_info *f = (struct file_info *)fi->fh;",
          "1290:  if (f->type != LXC_TYPE_CGFILE) {",
          "1291:   fprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");",
          "",
          "[Removed Lines]",
          "1286:  nih_local char *localbuf = NULL;",
          "1287:  nih_local struct cgm_keys *k = NULL;",
          "",
          "[Added Lines]",
          "1453:  char *localbuf = NULL;",
          "1454:  struct cgm_keys *k = NULL;",
          "1456:  bool r;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1298:  if (!fc)",
          "1299:   return -EIO;",
          "1302:  localbuf[size] = '\\0';",
          "1303:  memcpy(localbuf, buf, size);",
          "1327: }",
          "1329: int cg_chown(const char *path, uid_t uid, gid_t gid)",
          "1330: {",
          "1331:  struct fuse_context *fc = fuse_get_context();",
          "1335:  const char *cgroup;",
          "1339:  if (!fc)",
          "1340:   return -EIO;",
          "",
          "[Removed Lines]",
          "1301:  localbuf = NIH_MUST( nih_alloc(NULL, size+1) );",
          "1305:  if ((k = get_cgroup_key(f->controller, f->cgroup, f->file)) != NULL) {",
          "1306:   bool r;",
          "1308:   if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY))",
          "1309:    return -EACCES;",
          "1311:   if (strcmp(f->file, \"tasks\") == 0 ||",
          "1312:     strcmp(f->file, \"/tasks\") == 0 ||",
          "1313:     strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "1314:     strcmp(f->file, \"cgroup.procs\") == 0)",
          "1316:    r = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);",
          "1317:   else",
          "1318:    r = cgm_set_value(f->controller, f->cgroup, f->file, localbuf);",
          "1320:   if (!r)",
          "1321:    return -EINVAL;",
          "1323:   return size;",
          "1324:  }",
          "1326:  return -EINVAL;",
          "1332:  nih_local char * cgdir = NULL;",
          "1333:  char *fpath = NULL, *path1, *path2;",
          "1334:  nih_local struct cgm_keys *k = NULL;",
          "1336:  nih_local char *controller = NULL;",
          "",
          "[Added Lines]",
          "1469:  localbuf = alloca(size+1);",
          "1473:  if ((k = get_cgroup_key(f->controller, f->cgroup, f->file)) == NULL) {",
          "1474:   size = -EINVAL;",
          "1475:   goto out;",
          "1476:  }",
          "1478:  if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {",
          "1479:   size = -EACCES;",
          "1480:   goto out;",
          "1481:  }",
          "1483:  if (strcmp(f->file, \"tasks\") == 0 ||",
          "1484:    strcmp(f->file, \"/tasks\") == 0 ||",
          "1485:    strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "1486:    strcmp(f->file, \"cgroup.procs\") == 0)",
          "1488:   r = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);",
          "1489:  else",
          "1490:   r = cgm_set_value(f->controller, f->cgroup, f->file, localbuf);",
          "1492:  if (!r)",
          "1493:   size = -EINVAL;",
          "1495: out:",
          "1496:  free_key(k);",
          "1497:  return size;",
          "1503:  char *cgdir = NULL, *fpath = NULL, *path1, *path2, *controller;",
          "1504:  struct cgm_keys *k = NULL;",
          "1506:  int ret;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1368:  } else",
          "1369:   k = get_cgroup_key(controller, path1, path2);",
          "",
          "[Removed Lines]",
          "1371:  if (!k)",
          "1372:   return -EINVAL;",
          "",
          "[Added Lines]",
          "1540:  if (!k) {",
          "1541:   ret = -EINVAL;",
          "1542:   goto out;",
          "1543:  }",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1386: }",
          "1388: int cg_chmod(const char *path, mode_t mode)",
          "1389: {",
          "1390:  struct fuse_context *fc = fuse_get_context();",
          "1394:  const char *cgroup;",
          "1397:  if (!fc)",
          "1398:   return -EIO;",
          "",
          "[Removed Lines]",
          "1380:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_REQD))",
          "1381:   return -EACCES;",
          "1383:  if (!cgm_chown_file(controller, cgroup, uid, gid))",
          "1384:   return -EINVAL;",
          "1385:  return 0;",
          "1391:  nih_local char * cgdir = NULL;",
          "1392:  char *fpath = NULL, *path1, *path2;",
          "1393:  nih_local struct cgm_keys *k = NULL;",
          "1395:  nih_local char *controller = NULL;",
          "",
          "[Added Lines]",
          "1551:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_REQD)) {",
          "1552:   ret = -EACCES;",
          "1553:   goto out;",
          "1554:  }",
          "1556:  if (!cgm_chown_file(controller, cgroup, uid, gid)) {",
          "1557:   ret = -EINVAL;",
          "1558:   goto out;",
          "1559:  }",
          "1561:  ret = 0;",
          "1563: out:",
          "1564:  free_key(k);",
          "1565:  free(cgdir);",
          "1567:  return ret;",
          "1573:  char * cgdir = NULL, *fpath = NULL, *path1, *path2, *controller;",
          "1574:  struct cgm_keys *k = NULL;",
          "1576:  int ret;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1426:  } else",
          "1427:   k = get_cgroup_key(controller, path1, path2);",
          "",
          "[Removed Lines]",
          "1429:  if (!k)",
          "1430:   return -EINVAL;",
          "",
          "[Added Lines]",
          "1610:  if (!k) {",
          "1611:   ret = -EINVAL;",
          "1612:   goto out;",
          "1613:  }",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1444: }",
          "1446: int cg_mkdir(const char *path, mode_t mode)",
          "1447: {",
          "1448:  struct fuse_context *fc = fuse_get_context();",
          "1452:  const char *cgroup;",
          "1455:  if (!fc)",
          "1456:   return -EIO;",
          "",
          "[Removed Lines]",
          "1438:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT))",
          "1439:   return -EPERM;",
          "1441:  if (!cgm_chmod_file(controller, cgroup, mode))",
          "1442:   return -EINVAL;",
          "1443:  return 0;",
          "1449:  nih_local struct cgm_keys **list = NULL;",
          "1450:  char *fpath = NULL, *path1;",
          "1451:  nih_local char * cgdir = NULL;",
          "1453:  nih_local char *controller = NULL;",
          "",
          "[Added Lines]",
          "1621:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT)) {",
          "1622:   ret = -EPERM;",
          "1623:   goto out;",
          "1624:  }",
          "1626:  if (!cgm_chmod_file(controller, cgroup, mode)) {",
          "1627:   ret = -EINVAL;",
          "1628:   goto out;",
          "1629:  }",
          "1631:  ret = 0;",
          "1632: out:",
          "1633:  free_key(k);",
          "1634:  free(cgdir);",
          "1635:  return ret;",
          "1641:  char *fpath = NULL, *path1, *cgdir = NULL, *controller;",
          "1643:  int ret;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1470:  else",
          "1471:   path1 = cgdir;",
          "1481: }",
          "1483: static int cg_rmdir(const char *path)",
          "1484: {",
          "1485:  struct fuse_context *fc = fuse_get_context();",
          "1489:  const char *cgroup;",
          "1492:  if (!fc)",
          "1493:   return -EIO;",
          "1496:  controller = pick_controller_from_path(fc, path);",
          "1497:  if (!controller)",
          "1498:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "1473:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR))",
          "1474:   return -EACCES;",
          "1477:  if (!cgm_create(controller, cgroup, fc->uid, fc->gid))",
          "1478:   return -EINVAL;",
          "1480:  return 0;",
          "1486:  nih_local struct cgm_keys **list = NULL;",
          "1487:  char *fpath = NULL;",
          "1488:  nih_local char * cgdir = NULL;",
          "1490:  nih_local char *controller = NULL;",
          "",
          "[Added Lines]",
          "1663:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {",
          "1664:   ret = -EACCES;",
          "1665:   goto out;",
          "1666:  }",
          "1667:  if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {",
          "1668:   ret = -EACCES;",
          "1669:   goto out;",
          "1670:  }",
          "1672:  if (fc->uid == 0 && fc->gid == 0) {",
          "1673:   if (!cgm_create(controller, cgroup)) {",
          "1674:    ret = -EINVAL;",
          "1675:    goto out;",
          "1676:   }",
          "1677:  } else {",
          "1683:   size_t len = strlen(cgroup) + strlen(controller) + 17 + 50;",
          "1684:   char *cmd = alloca(len);",
          "1685:   ret = snprintf(cmd, len, \"lxcfs_mkdir %d %d %s %s\\n\",",
          "1686:     fc->uid, fc->gid, controller, cgroup);",
          "1687:   if (ret < 0 || ret >= len) {",
          "1688:    ret = -EINVAL;",
          "1689:    goto out;",
          "1690:   }",
          "1691:   ret = system(cmd);",
          "1692:   if (ret != 0)",
          "1693:    goto out;",
          "1694:  }",
          "1696:  ret = 0;",
          "1698: out:",
          "1699:  free(cgdir);",
          "1700:  return ret;",
          "1706:  char *fpath = NULL, *cgdir = NULL, *controller;",
          "1708:  int ret;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1502:   return -EINVAL;",
          "1504:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "1515: }",
          "1517: static bool startswith(const char *line, const char *pref)",
          "",
          "[Removed Lines]",
          "1505:  if (!fpath)",
          "1506:   return -EINVAL;",
          "1508:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY))",
          "1509:   return -EACCES;",
          "1511:  if (!cgm_remove(controller, cgroup))",
          "1512:   return -EINVAL;",
          "1514:  return 0;",
          "",
          "[Added Lines]",
          "1722:  if (!fpath) {",
          "1723:   ret = -EINVAL;",
          "1724:   goto out;",
          "1725:  }",
          "1727:  fprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",",
          "1728:    controller, cgdir, path);",
          "1729:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {",
          "1730:   ret = -EACCES;",
          "1731:   goto out;",
          "1732:  }",
          "1733:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {",
          "1734:   ret = -EACCES;",
          "1735:   goto out;",
          "1736:  }",
          "1738:  if (!cgm_remove(controller, cgroup)) {",
          "1739:   ret = -EINVAL;",
          "1740:   goto out;",
          "1741:  }",
          "1743:  ret = 0;",
          "1745: out:",
          "1746:  free(cgdir);",
          "1747:  return ret;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1562:  }",
          "1563: }",
          "1603: static int read_file(const char *path, char *buf, size_t size,",
          "1604:        struct file_info *d)",
          "1605: {",
          "",
          "[Removed Lines]",
          "1565: static char *get_pid_cgroup(pid_t pid, const char *contrl)",
          "1566: {",
          "1567:  nih_local char *fnam = NULL;",
          "1568:  FILE *f;",
          "1569:  char *answer = NULL;",
          "1570:  char *line = NULL;",
          "1571:  size_t len = 0;",
          "1573:  fnam = NIH_MUST( nih_sprintf(NULL, \"/proc/%d/cgroup\", pid) );",
          "1574:  if (!(f = fopen(fnam, \"r\")))",
          "1575:   return false;",
          "1577:  while (getline(&line, &len, f) != -1) {",
          "1578:   char *c1, *c2;",
          "1579:   if (!line[0])",
          "1580:    continue;",
          "1581:   c1 = strchr(line, ':');",
          "1582:   if (!c1)",
          "1583:    goto out;",
          "1584:   c1++;",
          "1585:   c2 = strchr(c1, ':');",
          "1586:   if (!c2)",
          "1587:    goto out;",
          "1589:   if (strcmp(c1, contrl) != 0)",
          "1590:    continue;",
          "1591:   c2++;",
          "1592:   stripnewline(c2);",
          "1593:   answer = NIH_MUST( nih_strdup(NULL, c2) );",
          "1594:   goto out;",
          "1595:  }",
          "1597: out:",
          "1598:  fclose(f);",
          "1599:  free(line);",
          "1600:  return answer;",
          "1601: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1656: {",
          "1657:  struct fuse_context *fc = fuse_get_context();",
          "1658:  struct file_info *d = (struct file_info *)fi->fh;",
          "1661:  unsigned long memlimit = 0, memusage = 0, cached = 0, hosttotal = 0;",
          "1662:  char *line = NULL;",
          "1663:  size_t linelen = 0, total_len = 0, rv = 0;",
          "1664:  char *cache = d->buf;",
          "1665:  size_t cache_size = d->buflen;",
          "1668:  if (offset){",
          "1669:   if (offset > d->size)",
          "",
          "[Removed Lines]",
          "1659:  nih_local char *cg = get_pid_cgroup(fc->pid, \"memory\");",
          "1660:  nih_local char *memlimit_str = NULL, *memusage_str = NULL, *memstat_str = NULL;",
          "1666:  FILE *f;",
          "",
          "[Added Lines]",
          "1854:  char *cg;",
          "1855:  char *memlimit_str = NULL, *memusage_str = NULL, *memstat_str = NULL;",
          "1861:  FILE *f = NULL;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1674:   return total_len;",
          "1675:  }",
          "1677:  if (!cg)",
          "1678:   return read_file(\"/proc/meminfo\", buf, size, d);",
          "1680:  if (!cgm_get_value(\"memory\", cg, \"memory.limit_in_bytes\", &memlimit_str))",
          "1682:  if (!cgm_get_value(\"memory\", cg, \"memory.usage_in_bytes\", &memusage_str))",
          "1684:  if (!cgm_get_value(\"memory\", cg, \"memory.stat\", &memstat_str))",
          "1686:  memlimit = strtoul(memlimit_str, NULL, 10);",
          "1687:  memusage = strtoul(memusage_str, NULL, 10);",
          "1688:  memlimit /= 1024;",
          "",
          "[Removed Lines]",
          "1681:   return 0;",
          "1683:   return 0;",
          "1685:   return 0;",
          "",
          "[Added Lines]",
          "1872:  cg = get_pid_cgroup(fc->pid, \"memory\");",
          "1877:   goto err;",
          "1879:   goto err;",
          "1881:   goto err;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1692:  f = fopen(\"/proc/meminfo\", \"r\");",
          "1693:  if (!f)",
          "1696:  while (getline(&line, &linelen, f) != -1) {",
          "1697:   size_t l;",
          "",
          "[Removed Lines]",
          "1694:   return 0;",
          "",
          "[Added Lines]",
          "1890:   goto err;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1745:  memcpy(buf, d->buf, total_len);",
          "1747:  rv = total_len;",
          "1750:  free(line);",
          "1751:  return rv;",
          "1752: }",
          "1758: static char *get_cpuset(const char *cg)",
          "1759: {",
          "",
          "[Removed Lines]",
          "1748:   err:",
          "1749:  fclose(f);",
          "",
          "[Added Lines]",
          "1944: err:",
          "1945:  if (f)",
          "1946:   fclose(f);",
          "1948:  free(cg);",
          "1949:  free(memlimit_str);",
          "1950:  free(memusage_str);",
          "1951:  free(memstat_str);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1792: {",
          "1793:  struct fuse_context *fc = fuse_get_context();",
          "1794:  struct file_info *d = (struct file_info *)fi->fh;",
          "1797:  char *line = NULL;",
          "1798:  size_t linelen = 0, total_len = 0, rv = 0;",
          "1799:  bool am_printing = false;",
          "1800:  int curcpu = -1;",
          "1801:  char *cache = d->buf;",
          "1802:  size_t cache_size = d->buflen;",
          "1805:  if (offset){",
          "1806:   if (offset > d->size)",
          "",
          "[Removed Lines]",
          "1795:  nih_local char *cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "1796:  nih_local char *cpuset = NULL;",
          "1803:  FILE *f;",
          "",
          "[Added Lines]",
          "1996:  char *cg;",
          "1997:  char *cpuset = NULL;",
          "2004:  FILE *f = NULL;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1811:   return total_len;",
          "1812:  }",
          "1814:  if (!cg)",
          "1815:   return read_file(\"proc/cpuinfo\", buf, size, d);",
          "1817:  cpuset = get_cpuset(cg);",
          "1818:  if (!cpuset)",
          "1821:  f = fopen(\"/proc/cpuinfo\", \"r\");",
          "1822:  if (!f)",
          "1825:  while (getline(&line, &linelen, f) != -1) {",
          "1826:   size_t l;",
          "",
          "[Removed Lines]",
          "1819:   return 0;",
          "1823:   return 0;",
          "",
          "[Added Lines]",
          "2015:  cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "2021:   goto err;",
          "2025:   goto err;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1884:  memcpy(buf, d->buf, total_len);",
          "1885:  rv = total_len;",
          "1888:  free(line);",
          "1889:  return rv;",
          "1890: }",
          "",
          "[Removed Lines]",
          "1886:   err:",
          "1887:  fclose(f);",
          "",
          "[Added Lines]",
          "2088: err:",
          "2089:  if (f)",
          "2090:   fclose(f);",
          "2092:  free(cpuset);",
          "2093:  free(cg);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1894: {",
          "1895:  struct fuse_context *fc = fuse_get_context();",
          "1896:  struct file_info *d = (struct file_info *)fi->fh;",
          "1899:  char *line = NULL;",
          "1900:  size_t linelen = 0, total_len = 0, rv = 0;",
          "",
          "[Removed Lines]",
          "1897:  nih_local char *cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "1898:  nih_local char *cpuset = NULL;",
          "",
          "[Added Lines]",
          "2102:  char *cg;",
          "2103:  char *cpuset = NULL;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1908:  char *cache = d->buf + CPUALL_MAX_SIZE;",
          "1909:  size_t cache_size = d->buflen - CPUALL_MAX_SIZE;",
          "1912:  if (offset){",
          "1913:   if (offset > d->size)",
          "",
          "[Removed Lines]",
          "1910:  FILE *f;",
          "",
          "[Added Lines]",
          "2115:  FILE *f = NULL;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1918:   return total_len;",
          "1919:  }",
          "1921:  if (!cg)",
          "1922:   return read_file(\"/proc/stat\", buf, size, d);",
          "1924:  cpuset = get_cpuset(cg);",
          "1925:  if (!cpuset)",
          "1928:  f = fopen(\"/proc/stat\", \"r\");",
          "1929:  if (!f)",
          "1933:  if (getline(&line, &linelen, f) < 0) {",
          "1934:   fprintf(stderr, \"proc_stat_read read first line failed\\n\");",
          "1936:  }",
          "1938:  while (getline(&line, &linelen, f) != -1) {",
          "",
          "[Removed Lines]",
          "1926:   return 0;",
          "1930:   return 0;",
          "1935:   goto out;",
          "",
          "[Added Lines]",
          "2126:  cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "2132:   goto err;",
          "2136:   goto err;",
          "2141:   goto err;",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2015:  if (cpuall_len > 0 && cpuall_len < CPUALL_MAX_SIZE){",
          "2016:   memcpy(cache, cpuall, cpuall_len);",
          "2017:   cache += cpuall_len;",
          "2020:   fprintf(stderr, \"proc_stat_read copy cpuall failed, cpuall_len=%d\\n\", cpuall_len);",
          "2021:   cpuall_len = 0;",
          "",
          "[Removed Lines]",
          "2018:  }else{",
          "",
          "[Added Lines]",
          "2224:  } else{",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2027:  if (total_len > size ) total_len = size;",
          "2029:  memcpy(buf, d->buf, total_len);",
          "2031:  rv = total_len;",
          "2034:  free(line);",
          "2035:  return rv;",
          "2036: }",
          "",
          "[Removed Lines]",
          "2030:   out:",
          "2032:   err:",
          "2033:  fclose(f);",
          "",
          "[Added Lines]",
          "2238: err:",
          "2239:  if (f)",
          "2240:   fclose(f);",
          "2242:  free(cpuset);",
          "2243:  free(cg);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2239:  char dev_name[72];",
          "2240:  struct fuse_context *fc = fuse_get_context();",
          "2241:  struct file_info *d = (struct file_info *)fi->fh;",
          "2245:  unsigned long read = 0, write = 0;",
          "2246:  unsigned long read_merged = 0, write_merged = 0;",
          "",
          "[Removed Lines]",
          "2242:  nih_local char *cg = get_pid_cgroup(fc->pid, \"blkio\");",
          "2243:  nih_local char *io_serviced_str = NULL, *io_merged_str = NULL, *io_service_bytes_str = NULL,",
          "",
          "[Added Lines]",
          "2451:  char *cg;",
          "2452:  char *io_serviced_str = NULL, *io_merged_str = NULL, *io_service_bytes_str = NULL,",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2252:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2253:  unsigned int major = 0, minor = 0;",
          "2254:  int i = 0;",
          "2257:  if (offset){",
          "2258:   if (offset > d->size)",
          "",
          "[Removed Lines]",
          "2255:  FILE *f;",
          "",
          "[Added Lines]",
          "2464:  FILE *f = NULL;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2260:   return 0;",
          "2261:  }",
          "2263:  if (!cg)",
          "2264:   return read_file(\"/proc/diskstats\", buf, size, d);",
          "2266:  if (!cgm_get_value(\"blkio\", cg, \"blkio.io_serviced\", &io_serviced_str))",
          "2268:  if (!cgm_get_value(\"blkio\", cg, \"blkio.io_merged\", &io_merged_str))",
          "2270:  if (!cgm_get_value(\"blkio\", cg, \"blkio.io_service_bytes\", &io_service_bytes_str))",
          "2272:  if (!cgm_get_value(\"blkio\", cg, \"blkio.io_wait_time\", &io_wait_time_str))",
          "2274:  if (!cgm_get_value(\"blkio\", cg, \"blkio.io_service_time\", &io_service_time_str))",
          "2278:  f = fopen(\"/proc/diskstats\", \"r\");",
          "2279:  if (!f)",
          "2282:  while (getline(&line, &linelen, f) != -1) {",
          "2283:   size_t l;",
          "",
          "[Removed Lines]",
          "2267:   return 0;",
          "2269:   return 0;",
          "2271:   return 0;",
          "2273:   return 0;",
          "2275:   return 0;",
          "2280:   return 0;",
          "",
          "[Added Lines]",
          "2472:  cg = get_pid_cgroup(fc->pid, \"blkio\");",
          "2477:   goto err;",
          "2479:   goto err;",
          "2481:   goto err;",
          "2483:   goto err;",
          "2485:   goto err;",
          "2490:   goto err;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "2340:  d->size = total_len;",
          "2341:  rv = total_len;",
          "2344:  free(line);",
          "2345:  return rv;",
          "2346: }",
          "",
          "[Removed Lines]",
          "2342:   err:",
          "2343:  fclose(f);",
          "",
          "[Added Lines]",
          "2552: err:",
          "2553:  free(cg);",
          "2554:  if (f)",
          "2555:   fclose(f);",
          "2557:  free(io_serviced_str);",
          "2558:  free(io_merged_str);",
          "2559:  free(io_service_bytes_str);",
          "2560:  free(io_wait_time_str);",
          "2561:  free(io_service_time_str);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "2420:  if (type == -1)",
          "2421:   return -ENOENT;",
          "2424:  memset(info, 0, sizeof(*info));",
          "2425:  info->type = type;",
          "2427:  info->buflen = get_procfile_size(path) + BUF_RESERVE_SIZE;",
          "2429:  memset(info->buf, 0, info->buflen);",
          "2431:  info->size = info->buflen;",
          "",
          "[Removed Lines]",
          "2423:  info = NIH_MUST( nih_alloc(NULL, sizeof(*info)) );",
          "2428:  info->buf = NIH_MUST( nih_alloc(info, info->buflen) );",
          "",
          "[Added Lines]",
          "2640:  info = malloc(sizeof(*info));",
          "2641:  if (!info)",
          "2642:   return -ENOMEM;",
          "2648:  do {",
          "2649:   info->buf = malloc(info->buflen);",
          "2650:  } while (!info->buf);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2717:  }",
          "2718: }",
          "2729: int main(int argc, char *argv[])",
          "2730: {",
          "2731:  int ret = -1;",
          "",
          "[Removed Lines]",
          "2720: bool detect_libnih_threadsafe(void)",
          "2721: {",
          "2722: #ifdef HAVE_NIH_THREADSAFE",
          "2723:  if (nih_threadsafe())",
          "2724:   return true;",
          "2725: #endif",
          "2726:  return false;",
          "2727: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2749:  swallow_arg(&argc, argv, \"-s\");",
          "",
          "[Removed Lines]",
          "2737:  int nargs = 6;",
          "2738:  bool threadsafe = detect_libnih_threadsafe();",
          "2739:  char *newargv[7]; // one more than if needed if threadsafe",
          "2741:  threadsafe = false; // still not safe with libnih+libdbus",
          "2743:  dbus_threads_init_default();",
          "2745:  if (threadsafe)",
          "2746:   nargs = 5;",
          "",
          "[Added Lines]",
          "2950:  int nargs = 5, cnt = 0;",
          "2951:  char *newargv[6];",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "2757:  if (argc != 2 || is_help(argv[1]))",
          "2758:   usage(argv[0]);",
          "2763:  newargv[cnt++] = argv[0];",
          "2766:  newargv[cnt++] = \"-f\";",
          "2767:  newargv[cnt++] = \"-o\";",
          "2768:  newargv[cnt++] = \"allow_other,direct_io\";",
          "",
          "[Removed Lines]",
          "2760:  d = NIH_MUST( malloc(sizeof(*d)) );",
          "2762:  int cnt = 0;",
          "2764:  if (!threadsafe)",
          "2765:   newargv[cnt++] = \"-s\";",
          "",
          "[Added Lines]",
          "2965:  do {",
          "2966:   d = malloc(sizeof(*d));",
          "2967:  } while (!d);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2776:   goto out;",
          "2778:  ret = fuse_main(nargs, newargv, &lxcfs_ops, d);",
          "2780: out:",
          "2781:  free(d);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2983:  cgm_dbus_disconnect();",
          "",
          "---------------"
        ],
        "lxcfs_mkdir.c||lxcfs_mkdir.c": [
          "File: lxcfs_mkdir.c -> lxcfs_mkdir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include <stdio.h>",
          "10: #include <unistd.h>",
          "11: #include <stdlib.h>",
          "12: #include <stdint.h>",
          "13: #include <stdbool.h>",
          "14: #include <errno.h>",
          "16: #include \"cgmanager.h\"",
          "18: void do_mkdir(char *argv[])",
          "19: {",
          "20:  uid_t uid;",
          "21:  gid_t gid;",
          "22:  unsigned long int tmp;",
          "23:  const char *controller = argv[3], *cgroup = argv[4];",
          "24:  errno = 0;",
          "25:  tmp = strtoul(argv[1], NULL, 10);",
          "26:  if (tmp < 0 || errno != 0)",
          "27:   exit(1);",
          "28:  uid = (uid_t) tmp;",
          "29:  tmp = strtoul(argv[2], NULL, 10);",
          "30:  if (tmp < 0 || errno != 0)",
          "31:   exit(1);",
          "32:  gid = (gid_t) tmp;",
          "33:  if (setresgid(gid, gid, gid) != 0) {",
          "34:   fprintf(stderr, \"Error dropping root group\\n\");",
          "35:   exit(1);",
          "36:  }",
          "37:  if (setresuid(uid, uid, uid) != 0) {",
          "38:   fprintf(stderr, \"Error dropping root uid\\n\");",
          "39:   exit(1);",
          "40:  }",
          "41:  if (!cgm_create(controller, cgroup)) {",
          "42:   exit(1);",
          "43:  }",
          "44: }",
          "50: int main(int argc, char *argv[])",
          "51: {",
          "52:  if (getuid() || getgid())",
          "53:   exit(1);",
          "54:  if (argc != 5)",
          "55:   exit(1);",
          "56:  do_mkdir(argv);",
          "57:  exit(0);",
          "58: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
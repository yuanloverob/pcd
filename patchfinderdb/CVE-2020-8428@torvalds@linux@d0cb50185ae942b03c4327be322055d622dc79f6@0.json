{
  "cve_id": "CVE-2020-8428",
  "cve_desc": "fs/namei.c in the Linux kernel before 5.5 has a may_create_in_sticky use-after-free, which allows local users to cause a denial of service (OOPS) or possibly obtain sensitive information from kernel memory, aka CID-d0cb50185ae9. One attack vector may be an open system call for a UNIX domain socket, if the socket is being moved to a new parent directory and its old parent directory is being removed.",
  "repo": "torvalds/linux",
  "patch_hash": "d0cb50185ae942b03c4327be322055d622dc79f6",
  "patch_info": {
    "commit_hash": "d0cb50185ae942b03c4327be322055d622dc79f6",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6",
    "files": [
      "fs/namei.c"
    ],
    "message": "do_last(): fetch directory ->i_mode and ->i_uid before it's too late\n\nmay_create_in_sticky() call is done when we already have dropped the\nreference to dir.\n\nFixes: 30aba6656f61e (namei: allow restricted O_CREAT of FIFOs and regular files)\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "fs/namei.c||fs/namei.c"
    ]
  },
  "patch_diff": {
    "fs/namei.c||fs/namei.c": [
      "File: fs/namei.c -> fs/namei.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1021:     struct inode * const inode)",
      "1022: {",
      "1023:  if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||",
      "1024:      (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||",
      "1027:      uid_eq(current_fsuid(), inode->i_uid))",
      "1028:   return 0;",
      "1032:       ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||",
      "1033:        (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {",
      "1034:   const char *operation = S_ISFIFO(inode->i_mode) ?",
      "",
      "[Removed Lines]",
      "1020: static int may_create_in_sticky(struct dentry * const dir,",
      "1025:      likely(!(dir->d_inode->i_mode & S_ISVTX)) ||",
      "1026:      uid_eq(inode->i_uid, dir->d_inode->i_uid) ||",
      "1030:  if (likely(dir->d_inode->i_mode & 0002) ||",
      "1031:      (dir->d_inode->i_mode & 0020 &&",
      "",
      "[Added Lines]",
      "1021: static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,",
      "1026:      likely(!(dir_mode & S_ISVTX)) ||",
      "1027:      uid_eq(inode->i_uid, dir_uid) ||",
      "1031:  if (likely(dir_mode & 0002) ||",
      "1032:      (dir_mode & 0020 &&",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3201:      struct file *file, const struct open_flags *op)",
      "3202: {",
      "3203:  struct dentry *dir = nd->path.dentry;",
      "3204:  int open_flag = op->open_flag;",
      "3205:  bool will_truncate = (open_flag & O_TRUNC) != 0;",
      "3206:  bool got_write = false;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3205:  kuid_t dir_uid = dir->d_inode->i_uid;",
      "3206:  umode_t dir_mode = dir->d_inode->i_mode;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3331:   error = -EISDIR;",
      "3332:   if (d_is_dir(nd->path.dentry))",
      "3333:    goto out;",
      "3335:           d_backing_inode(nd->path.dentry));",
      "3336:   if (unlikely(error))",
      "3337:    goto out;",
      "",
      "[Removed Lines]",
      "3334:   error = may_create_in_sticky(dir,",
      "",
      "[Added Lines]",
      "3337:   error = may_create_in_sticky(dir_mode, dir_uid,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6404674acd596de41fd3ad5f267b4525494a891a",
      "candidate_info": {
        "commit_hash": "6404674acd596de41fd3ad5f267b4525494a891a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6404674acd596de41fd3ad5f267b4525494a891a",
        "files": [
          "fs/namei.c"
        ],
        "message": "vfs: fix do_last() regression\n\nBrown paperbag time: fetching ->i_uid/->i_mode really should've been\ndone from nd->inode.  I even suggested that, but the reason for that has\nslipped through the cracks and I went for dir->d_inode instead - made\nfor more \"obvious\" patch.\n\nAnalysis:\n\n - at the entry into do_last() and all the way to step_into(): dir (aka\n   nd->path.dentry) is known not to have been freed; so's nd->inode and\n   it's equal to dir->d_inode unless we are already doomed to -ECHILD.\n   inode of the file to get opened is not known.\n\n - after step_into(): inode of the file to get opened is known; dir\n   might be pointing to freed memory/be negative/etc.\n\n - at the call of may_create_in_sticky(): guaranteed to be out of RCU\n   mode; inode of the file to get opened is known and pinned; dir might\n   be garbage.\n\nThe last was the reason for the original patch.  Except that at the\ndo_last() entry we can be in RCU mode and it is possible that\nnd->path.dentry->d_inode has already changed under us.\n\nIn that case we are going to fail with -ECHILD, but we need to be\ncareful; nd->inode is pointing to valid struct inode and it's the same\nas nd->path.dentry->d_inode in \"won't fail with -ECHILD\" case, so we\nshould use that.\n\nReported-by: \"Rantala, Tommi T. (Nokia - FI/Espoo)\" <tommi.t.rantala@nokia.com>\nReported-by: syzbot+190005201ced78a74ad6@syzkaller.appspotmail.com\nWearing-brown-paperbag: Al Viro <viro@zeniv.linux.org.uk>\nCc: stable@kernel.org\nFixes: d0cb50185ae9 (\"do_last(): fetch directory ->i_mode and ->i_uid before it's too late\")\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/namei.c||fs/namei.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namei.c||fs/namei.c"
          ],
          "candidate": [
            "fs/namei.c||fs/namei.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namei.c||fs/namei.c": [
          "File: fs/namei.c -> fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3333:      struct file *file, const struct open_flags *op)",
          "3334: {",
          "3335:  struct dentry *dir = nd->path.dentry;",
          "3338:  int open_flag = op->open_flag;",
          "3339:  bool will_truncate = (open_flag & O_TRUNC) != 0;",
          "3340:  bool got_write = false;",
          "",
          "[Removed Lines]",
          "3336:  kuid_t dir_uid = dir->d_inode->i_uid;",
          "3337:  umode_t dir_mode = dir->d_inode->i_mode;",
          "",
          "[Added Lines]",
          "3336:  kuid_t dir_uid = nd->inode->i_uid;",
          "3337:  umode_t dir_mode = nd->inode->i_mode;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0f705953012a753068b20016f55dc12d1f7e17e5",
      "candidate_info": {
        "commit_hash": "0f705953012a753068b20016f55dc12d1f7e17e5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0f705953012a753068b20016f55dc12d1f7e17e5",
        "files": [
          "fs/namei.c"
        ],
        "message": "link_path_walk(): sample parent's i_uid and i_mode for the last component\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/namei.c||fs/namei.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namei.c||fs/namei.c"
          ],
          "candidate": [
            "fs/namei.c||fs/namei.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namei.c||fs/namei.c": [
          "File: fs/namei.c -> fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "505:  struct nameidata *saved;",
          "506:  unsigned root_seq;",
          "507:  int  dfd;",
          "508: } __randomize_layout;",
          "510: static void set_nameidata(struct nameidata *p, int dfd, struct filename *name)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "508:  kuid_t  dir_uid;",
          "509:  umode_t  dir_mode;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "939: static inline int may_follow_link(struct nameidata *nd, const struct inode *inode)",
          "940: {",
          "944:  if (!sysctl_protected_symlinks)",
          "945:   return 0;",
          "",
          "[Removed Lines]",
          "941:  const struct inode *parent;",
          "942:  kuid_t puid;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "949:   return 0;",
          "954:   return 0;",
          "959:   return 0;",
          "961:  if (nd->flags & LOOKUP_RCU)",
          "",
          "[Removed Lines]",
          "952:  parent = nd->inode;",
          "953:  if ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))",
          "957:  puid = parent->i_uid;",
          "958:  if (uid_valid(puid) && uid_eq(puid, inode->i_uid))",
          "",
          "[Added Lines]",
          "951:  if ((nd->dir_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))",
          "955:  if (uid_valid(nd->dir_uid) && uid_eq(nd->dir_uid, inode->i_uid))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2159: OK:",
          "2161:    if (!depth) {",
          "2162:     nd->flags &= ~LOOKUP_PARENT;",
          "2163:     return 0;",
          "2164:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2159:     nd->dir_uid = nd->inode->i_uid;",
          "2160:     nd->dir_mode = nd->inode->i_mode;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3224: static const char *do_last(struct nameidata *nd,",
          "3225:      struct file *file, const struct open_flags *op)",
          "3226: {",
          "3229:  int open_flag = op->open_flag;",
          "3230:  bool do_truncate;",
          "3231:  int acc_mode;",
          "",
          "[Removed Lines]",
          "3227:  kuid_t dir_uid = nd->inode->i_uid;",
          "3228:  umode_t dir_mode = nd->inode->i_mode;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3241:  if (open_flag & O_CREAT) {",
          "3242:   if (d_is_dir(nd->path.dentry))",
          "3243:    return ERR_PTR(-EISDIR);",
          "3245:           d_backing_inode(nd->path.dentry));",
          "3246:   if (unlikely(error))",
          "3247:    return ERR_PTR(error);",
          "",
          "[Removed Lines]",
          "3244:   error = may_create_in_sticky(dir_mode, dir_uid,",
          "",
          "[Added Lines]",
          "3241:   error = may_create_in_sticky(nd->dir_mode, nd->dir_uid,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ba73d98745be1c10dc3cce68e8d7b95012d07d05",
      "candidate_info": {
        "commit_hash": "ba73d98745be1c10dc3cce68e8d7b95012d07d05",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ba73d98745be1c10dc3cce68e8d7b95012d07d05",
        "files": [
          "fs/btrfs/ioctl.c",
          "fs/init.c",
          "fs/inode.c",
          "fs/internal.h",
          "fs/namei.c",
          "fs/xattr.c",
          "include/linux/fs.h"
        ],
        "message": "namei: handle idmapped mounts in may_*() helpers\n\nThe may_follow_link(), may_linkat(), may_lookup(), may_open(),\nmay_o_create(), may_create_in_sticky(), may_delete(), and may_create()\nhelpers determine whether the caller is privileged enough to perform the\nassociated operations. Let them handle idmapped mounts by mapping the\ninode or fsids according to the mount's user namespace. Afterwards the\nchecks are identical to non-idmapped inodes. The patch takes care to\nretrieve the mount's user namespace right before performing permission\nchecks and passing it down into the fileystem so the user namespace\ncan't change in between by someone idmapping a mount that is currently\nnot idmapped. If the initial user namespace is passed nothing changes so\nnon-idmapped mounts will see identical behavior as before.\n\nLink: https://lore.kernel.org/r/20210121131959.646623-13-christian.brauner@ubuntu.com\nCc: Christoph Hellwig <hch@lst.de>\nCc: David Howells <dhowells@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: linux-fsdevel@vger.kernel.org\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: James Morris <jamorris@linux.microsoft.com>\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "before_after_code_files": [
          "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c",
          "fs/init.c||fs/init.c",
          "fs/inode.c||fs/inode.c",
          "fs/internal.h||fs/internal.h",
          "fs/namei.c||fs/namei.c",
          "fs/xattr.c||fs/xattr.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namei.c||fs/namei.c"
          ],
          "candidate": [
            "fs/namei.c||fs/namei.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c": [
          "File: fs/btrfs/ioctl.c -> fs/btrfs/ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "927:   return error;",
          "928:  if (IS_APPEND(dir))",
          "929:   return -EPERM;",
          "932:   return -EPERM;",
          "933:  if (isdir) {",
          "934:   if (!d_is_dir(victim))",
          "",
          "[Removed Lines]",
          "930:  if (check_sticky(dir, d_inode(victim)) || IS_APPEND(d_inode(victim)) ||",
          "931:      IS_IMMUTABLE(d_inode(victim)) || IS_SWAPFILE(d_inode(victim)))",
          "",
          "[Added Lines]",
          "930:  if (check_sticky(&init_user_ns, dir, d_inode(victim)) ||",
          "931:      IS_APPEND(d_inode(victim)) || IS_IMMUTABLE(d_inode(victim)) ||",
          "932:      IS_SWAPFILE(d_inode(victim)))",
          "",
          "---------------"
        ],
        "fs/init.c||fs/init.c": [
          "File: fs/init.c -> fs/init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "181:  error = -EXDEV;",
          "182:  if (old_path.mnt != new_path.mnt)",
          "183:   goto out_dput;",
          "185:  if (unlikely(error))",
          "186:   goto out_dput;",
          "187:  error = security_path_link(old_path.dentry, &new_path, new_dentry);",
          "",
          "[Removed Lines]",
          "184:  error = may_linkat(&old_path);",
          "",
          "[Added Lines]",
          "184:  error = may_linkat(&init_user_ns, &old_path);",
          "",
          "---------------"
        ],
        "fs/inode.c||fs/inode.c": [
          "File: fs/inode.c -> fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1800:   return false;",
          "1802:  if (IS_NOATIME(inode))",
          "",
          "[Removed Lines]",
          "1799:  if (HAS_UNMAPPED_ID(inode))",
          "",
          "[Added Lines]",
          "1799:  if (HAS_UNMAPPED_ID(mnt_user_ns(mnt), inode))",
          "",
          "---------------"
        ],
        "fs/internal.h||fs/internal.h": [
          "File: fs/internal.h -> fs/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:       const char *, unsigned int, struct path *);",
          "74: long do_rmdir(int dfd, struct filename *name);",
          "75: long do_unlinkat(int dfd, struct filename *name);",
          "77: int do_renameat2(int olddfd, struct filename *oldname, int newdfd,",
          "78:    struct filename *newname, unsigned int flags);",
          "",
          "[Removed Lines]",
          "76: int may_linkat(struct path *link);",
          "",
          "[Added Lines]",
          "76: int may_linkat(struct user_namespace *mnt_userns, struct path *link);",
          "",
          "---------------"
        ],
        "fs/namei.c||fs/namei.c": [
          "File: fs/namei.c -> fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "510:    return -EACCES;",
          "511:  }",
          "",
          "[Removed Lines]",
          "509:   if (HAS_UNMAPPED_ID(inode))",
          "",
          "[Added Lines]",
          "509:   if (HAS_UNMAPPED_ID(mnt_userns, inode))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1005: static inline int may_follow_link(struct nameidata *nd, const struct inode *inode)",
          "1006: {",
          "1007:  if (!sysctl_protected_symlinks)",
          "1008:   return 0;",
          "1012:   return 0;",
          "",
          "[Removed Lines]",
          "1011:  if (uid_eq(current_cred()->fsuid, inode->i_uid))",
          "",
          "[Added Lines]",
          "1007:  struct user_namespace *mnt_userns;",
          "1008:  kuid_t i_uid;",
          "1013:  mnt_userns = mnt_user_ns(nd->path.mnt);",
          "1014:  i_uid = i_uid_into_mnt(mnt_userns, inode);",
          "1016:  if (uid_eq(current_cred()->fsuid, i_uid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1016:   return 0;",
          "1020:   return 0;",
          "1022:  if (nd->flags & LOOKUP_RCU)",
          "",
          "[Removed Lines]",
          "1019:  if (uid_valid(nd->dir_uid) && uid_eq(nd->dir_uid, inode->i_uid))",
          "",
          "[Added Lines]",
          "1024:  if (uid_valid(nd->dir_uid) && uid_eq(nd->dir_uid, i_uid))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1043: {",
          "1044:  umode_t mode = inode->i_mode;",
          "",
          "[Removed Lines]",
          "1042: static bool safe_hardlink_source(struct inode *inode)",
          "",
          "[Added Lines]",
          "1048: static bool safe_hardlink_source(struct user_namespace *mnt_userns,",
          "1049:      struct inode *inode)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1056:   return false;",
          "1060:   return false;",
          "1062:  return true;",
          "",
          "[Removed Lines]",
          "1059:  if (inode_permission(&init_user_ns, inode, MAY_READ | MAY_WRITE))",
          "",
          "[Added Lines]",
          "1066:  if (inode_permission(mnt_userns, inode, MAY_READ | MAY_WRITE))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1078: {",
          "1079:  struct inode *inode = link->dentry->d_inode;",
          "1083:   return -EOVERFLOW;",
          "1085:  if (!sysctl_protected_hardlinks)",
          "",
          "[Removed Lines]",
          "1077: int may_linkat(struct path *link)",
          "1082:  if (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))",
          "",
          "[Added Lines]",
          "1091: int may_linkat(struct user_namespace *mnt_userns, struct path *link)",
          "1096:  if (!uid_valid(i_uid_into_mnt(mnt_userns, inode)) ||",
          "1097:      !gid_valid(i_gid_into_mnt(mnt_userns, inode)))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1093:   return 0;",
          "1095:  audit_log_path_denied(AUDIT_ANOM_LINK, \"linkat\");",
          "",
          "[Removed Lines]",
          "1091:  if (safe_hardlink_source(inode) ||",
          "1092:      inode_owner_or_capable(&init_user_ns, inode))",
          "",
          "[Added Lines]",
          "1106:  if (safe_hardlink_source(mnt_userns, inode) ||",
          "1107:      inode_owner_or_capable(mnt_userns, inode))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1122: {",
          "1123:  if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||",
          "1124:      (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||",
          "1125:      likely(!(dir_mode & S_ISVTX)) ||",
          "1128:   return 0;",
          "1130:  if (likely(dir_mode & 0002) ||",
          "",
          "[Removed Lines]",
          "1120: static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,",
          "1121:     struct inode * const inode)",
          "1126:      uid_eq(inode->i_uid, dir_uid) ||",
          "1127:      uid_eq(current_fsuid(), inode->i_uid))",
          "",
          "[Added Lines]",
          "1142: static int may_create_in_sticky(struct user_namespace *mnt_userns,",
          "1143:     struct nameidata *nd, struct inode *const inode)",
          "1145:  umode_t dir_mode = nd->dir_mode;",
          "1146:  kuid_t dir_uid = nd->dir_uid;",
          "1151:      uid_eq(i_uid_into_mnt(mnt_userns, inode), dir_uid) ||",
          "1152:      uid_eq(current_fsuid(), i_uid_into_mnt(mnt_userns, inode)))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1614:  return res;",
          "1615: }",
          "1618: {",
          "1619:  if (nd->flags & LOOKUP_RCU) {",
          "1621:         MAY_EXEC | MAY_NOT_BLOCK);",
          "1622:   if (err != -ECHILD)",
          "1623:    return err;",
          "1624:   if (unlazy_walk(nd))",
          "1625:    return -ECHILD;",
          "1626:  }",
          "1628: }",
          "1630: static int reserve_stack(struct nameidata *nd, struct path *link, unsigned seq)",
          "",
          "[Removed Lines]",
          "1617: static inline int may_lookup(struct nameidata *nd)",
          "1620:   int err = inode_permission(&init_user_ns, nd->inode,",
          "1627:  return inode_permission(&init_user_ns, nd->inode, MAY_EXEC);",
          "",
          "[Added Lines]",
          "1642: static inline int may_lookup(struct user_namespace *mnt_userns,",
          "1643:         struct nameidata *nd)",
          "1646:   int err = inode_permission(mnt_userns, nd->inode,",
          "1653:  return inode_permission(mnt_userns, nd->inode, MAY_EXEC);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2177:   u64 hash_len;",
          "2178:   int type;",
          "2181:   if (err)",
          "2182:    return err;",
          "",
          "[Removed Lines]",
          "2180:   err = may_lookup(nd);",
          "",
          "[Added Lines]",
          "2206:   err = may_lookup(&init_user_ns, nd);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2225: OK:",
          "2227:    if (!depth) {",
          "2229:     nd->dir_mode = nd->inode->i_mode;",
          "2230:     nd->flags &= ~LOOKUP_PARENT;",
          "2231:     return 0;",
          "",
          "[Removed Lines]",
          "2228:     nd->dir_uid = nd->inode->i_uid;",
          "",
          "[Added Lines]",
          "2254:     nd->dir_uid = i_uid_into_mnt(&init_user_ns, nd->inode);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2703: }",
          "2704: EXPORT_SYMBOL(user_path_at_empty);",
          "2707: {",
          "2708:  kuid_t fsuid = current_fsuid();",
          "2711:   return 0;",
          "2713:   return 0;",
          "2715: }",
          "2716: EXPORT_SYMBOL(__check_sticky);",
          "",
          "[Removed Lines]",
          "2706: int __check_sticky(struct inode *dir, struct inode *inode)",
          "2710:  if (uid_eq(inode->i_uid, fsuid))",
          "2712:  if (uid_eq(dir->i_uid, fsuid))",
          "2714:  return !capable_wrt_inode_uidgid(&init_user_ns, inode, CAP_FOWNER);",
          "",
          "[Added Lines]",
          "2732: int __check_sticky(struct user_namespace *mnt_userns, struct inode *dir,",
          "2733:      struct inode *inode)",
          "2737:  if (uid_eq(i_uid_into_mnt(mnt_userns, inode), fsuid))",
          "2739:  if (uid_eq(i_uid_into_mnt(mnt_userns, dir), fsuid))",
          "2741:  return !capable_wrt_inode_uidgid(mnt_userns, inode, CAP_FOWNER);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2739: {",
          "2740:  struct inode *inode = d_backing_inode(victim);",
          "2741:  int error;",
          "",
          "[Removed Lines]",
          "2738: static int may_delete(struct inode *dir, struct dentry *victim, bool isdir)",
          "",
          "[Added Lines]",
          "2765: static int may_delete(struct user_namespace *mnt_userns, struct inode *dir,",
          "2766:         struct dentry *victim, bool isdir)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2747:  BUG_ON(victim->d_parent->d_inode != dir);",
          "2751:   return -EOVERFLOW;",
          "2753:  audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);",
          "2756:  if (error)",
          "2757:   return error;",
          "2758:  if (IS_APPEND(dir))",
          "2759:   return -EPERM;",
          "2763:   return -EPERM;",
          "2764:  if (isdir) {",
          "2765:   if (!d_is_dir(victim))",
          "",
          "[Removed Lines]",
          "2750:  if (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))",
          "2755:  error = inode_permission(&init_user_ns, dir, MAY_WRITE | MAY_EXEC);",
          "2761:  if (check_sticky(dir, inode) || IS_APPEND(inode) ||",
          "2762:      IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) || HAS_UNMAPPED_ID(inode))",
          "",
          "[Added Lines]",
          "2778:  if (!uid_valid(i_uid_into_mnt(mnt_userns, inode)) ||",
          "2779:      !gid_valid(i_gid_into_mnt(mnt_userns, inode)))",
          "2784:  error = inode_permission(mnt_userns, dir, MAY_WRITE | MAY_EXEC);",
          "2790:  if (check_sticky(mnt_userns, dir, inode) || IS_APPEND(inode) ||",
          "2791:      IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) ||",
          "2792:      HAS_UNMAPPED_ID(mnt_userns, inode))",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2788: {",
          "2789:  struct user_namespace *s_user_ns;",
          "2790:  audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);",
          "",
          "[Removed Lines]",
          "2787: static inline int may_create(struct inode *dir, struct dentry *child)",
          "",
          "[Added Lines]",
          "2817: static inline int may_create(struct user_namespace *mnt_userns,",
          "2818:         struct inode *dir, struct dentry *child)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2793:  if (IS_DEADDIR(dir))",
          "2794:   return -ENOENT;",
          "2795:  s_user_ns = dir->i_sb->s_user_ns;",
          "2798:   return -EOVERFLOW;",
          "2800: }",
          "",
          "[Removed Lines]",
          "2796:  if (!kuid_has_mapping(s_user_ns, current_fsuid()) ||",
          "2797:      !kgid_has_mapping(s_user_ns, current_fsgid()))",
          "2799:  return inode_permission(&init_user_ns, dir, MAY_WRITE | MAY_EXEC);",
          "",
          "[Added Lines]",
          "2827:  if (!kuid_has_mapping(s_user_ns, fsuid_into_mnt(mnt_userns)) ||",
          "2828:      !kgid_has_mapping(s_user_ns, fsgid_into_mnt(mnt_userns)))",
          "2830:  return inode_permission(mnt_userns, dir, MAY_WRITE | MAY_EXEC);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2846: int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,",
          "2847:   bool want_excl)",
          "2848: {",
          "2850:  if (error)",
          "2851:   return error;",
          "",
          "[Removed Lines]",
          "2849:  int error = may_create(dir, dentry);",
          "",
          "[Added Lines]",
          "2880:  int error = may_create(&init_user_ns, dir, dentry);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2869:   void *arg)",
          "2870: {",
          "2871:  struct inode *dir = dentry->d_parent->d_inode;",
          "2873:  if (error)",
          "2874:   return error;",
          "",
          "[Removed Lines]",
          "2872:  int error = may_create(dir, dentry);",
          "",
          "[Added Lines]",
          "2903:  int error = may_create(&init_user_ns, dir, dentry);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2891:   !(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);",
          "2892: }",
          "2895: {",
          "2896:  struct dentry *dentry = path->dentry;",
          "2897:  struct inode *inode = dentry->d_inode;",
          "",
          "[Removed Lines]",
          "2894: static int may_open(const struct path *path, int acc_mode, int flag)",
          "",
          "[Added Lines]",
          "2925: static int may_open(struct user_namespace *mnt_userns, const struct path *path,",
          "2926:       int acc_mode, int flag)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2926:   break;",
          "2927:  }",
          "2930:  if (error)",
          "2931:   return error;",
          "",
          "[Removed Lines]",
          "2929:  error = inode_permission(&init_user_ns, inode, MAY_OPEN | acc_mode);",
          "",
          "[Added Lines]",
          "2961:  error = inode_permission(mnt_userns, inode, MAY_OPEN | acc_mode);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2941:  }",
          "2945:   return -EPERM;",
          "2947:  return 0;",
          "",
          "[Removed Lines]",
          "2944:  if (flag & O_NOATIME && !inode_owner_or_capable(&init_user_ns, inode))",
          "",
          "[Added Lines]",
          "2976:  if (flag & O_NOATIME && !inode_owner_or_capable(mnt_userns, inode))",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2976:  return flag;",
          "2977: }",
          "2980: {",
          "2981:  struct user_namespace *s_user_ns;",
          "2982:  int error = security_path_mknod(dir, dentry, mode, 0);",
          "",
          "[Removed Lines]",
          "2979: static int may_o_create(const struct path *dir, struct dentry *dentry, umode_t mode)",
          "",
          "[Added Lines]",
          "3011: static int may_o_create(struct user_namespace *mnt_userns,",
          "3012:    const struct path *dir, struct dentry *dentry,",
          "3013:    umode_t mode)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2984:   return error;",
          "2986:  s_user_ns = dir->dentry->d_sb->s_user_ns;",
          "2989:   return -EOVERFLOW;",
          "2992:      MAY_WRITE | MAY_EXEC);",
          "2993:  if (error)",
          "2994:   return error;",
          "",
          "[Removed Lines]",
          "2987:  if (!kuid_has_mapping(s_user_ns, current_fsuid()) ||",
          "2988:      !kgid_has_mapping(s_user_ns, current_fsgid()))",
          "2991:  error = inode_permission(&init_user_ns, dir->dentry->d_inode,",
          "",
          "[Added Lines]",
          "3021:  if (!kuid_has_mapping(s_user_ns, fsuid_into_mnt(mnt_userns)) ||",
          "3022:      !kgid_has_mapping(s_user_ns, fsgid_into_mnt(mnt_userns)))",
          "3025:  error = inode_permission(mnt_userns, dir->dentry->d_inode,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3121:   if (!IS_POSIXACL(dir->d_inode))",
          "3122:    mode &= ~current_umask();",
          "3123:   if (likely(got_write))",
          "3125:   else",
          "3126:    create_error = -EROFS;",
          "3127:  }",
          "",
          "[Removed Lines]",
          "3124:    create_error = may_o_create(&nd->path, dentry, mode);",
          "",
          "[Added Lines]",
          "3158:    create_error = may_o_create(&init_user_ns, &nd->path,",
          "3159:           dentry, mode);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3282:    return -EEXIST;",
          "3283:   if (d_is_dir(nd->path.dentry))",
          "3284:    return -EISDIR;",
          "3286:           d_backing_inode(nd->path.dentry));",
          "3287:   if (unlikely(error))",
          "3288:    return error;",
          "",
          "[Removed Lines]",
          "3285:   error = may_create_in_sticky(nd->dir_mode, nd->dir_uid,",
          "",
          "[Added Lines]",
          "3320:   error = may_create_in_sticky(&init_user_ns, nd,",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3302:    return error;",
          "3303:   do_truncate = true;",
          "3304:  }",
          "3306:  if (!error && !(file->f_mode & FMODE_OPENED))",
          "3307:   error = vfs_open(&nd->path, file);",
          "3308:  if (!error)",
          "",
          "[Removed Lines]",
          "3305:  error = may_open(&nd->path, acc_mode, open_flag);",
          "",
          "[Added Lines]",
          "3340:  error = may_open(&init_user_ns, &nd->path, acc_mode, open_flag);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3377:  path.dentry = child;",
          "3378:  audit_inode(nd->name, child, 0);",
          "3381:  if (error)",
          "3382:   goto out2;",
          "3383:  file->f_path.mnt = path.mnt;",
          "",
          "[Removed Lines]",
          "3380:  error = may_open(&path, 0, op->open_flag);",
          "",
          "[Added Lines]",
          "3415:  error = may_open(&init_user_ns, &path, 0, op->open_flag);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3584: int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)",
          "3585: {",
          "3586:  bool is_whiteout = S_ISCHR(mode) && dev == WHITEOUT_DEV;",
          "3589:  if (error)",
          "3590:   return error;",
          "",
          "[Removed Lines]",
          "3587:  int error = may_create(dir, dentry);",
          "",
          "[Added Lines]",
          "3622:  int error = may_create(&init_user_ns, dir, dentry);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3686: int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)",
          "3687: {",
          "3689:  unsigned max_links = dir->i_sb->s_max_links;",
          "3691:  if (error)",
          "",
          "[Removed Lines]",
          "3688:  int error = may_create(dir, dentry);",
          "",
          "[Added Lines]",
          "3723:  int error = may_create(&init_user_ns, dir, dentry);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3747: int vfs_rmdir(struct inode *dir, struct dentry *dentry)",
          "3748: {",
          "3751:  if (error)",
          "3752:   return error;",
          "",
          "[Removed Lines]",
          "3749:  int error = may_delete(dir, dentry, 1);",
          "",
          "[Added Lines]",
          "3784:  int error = may_delete(&init_user_ns, dir, dentry, 1);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3868: int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)",
          "3869: {",
          "3870:  struct inode *target = dentry->d_inode;",
          "3873:  if (error)",
          "3874:   return error;",
          "",
          "[Removed Lines]",
          "3871:  int error = may_delete(dir, dentry, 0);",
          "",
          "[Added Lines]",
          "3906:  int error = may_delete(&init_user_ns, dir, dentry, 0);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "4001: int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)",
          "4002: {",
          "4005:  if (error)",
          "4006:   return error;",
          "",
          "[Removed Lines]",
          "4003:  int error = may_create(dir, dentry);",
          "",
          "[Added Lines]",
          "4038:  int error = may_create(&init_user_ns, dir, dentry);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "4089:  if (!inode)",
          "4090:   return -ENOENT;",
          "4093:  if (error)",
          "4094:   return error;",
          "",
          "[Removed Lines]",
          "4092:  error = may_create(dir, new_dentry);",
          "",
          "[Added Lines]",
          "4127:  error = may_create(&init_user_ns, dir, new_dentry);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "4110:   return -EPERM;",
          "4111:  if (!dir->i_op->link)",
          "4112:   return -EPERM;",
          "",
          "[Removed Lines]",
          "4109:  if (HAS_UNMAPPED_ID(inode))",
          "",
          "[Added Lines]",
          "4144:  if (HAS_UNMAPPED_ID(&init_user_ns, inode))",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "4188:  error = -EXDEV;",
          "4189:  if (old_path.mnt != new_path.mnt)",
          "4190:   goto out_dput;",
          "4192:  if (unlikely(error))",
          "4193:   goto out_dput;",
          "4194:  error = security_path_link(old_path.dentry, &new_path, new_dentry);",
          "",
          "[Removed Lines]",
          "4191:  error = may_linkat(&old_path);",
          "",
          "[Added Lines]",
          "4226:  error = may_linkat(&init_user_ns, &old_path);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "4281:         struct inode **delegated_inode, unsigned int flags)",
          "4282: {",
          "4283:  int error;",
          "4284:  bool is_dir = d_is_dir(old_dentry);",
          "4285:  struct inode *source = old_dentry->d_inode;",
          "4286:  struct inode *target = new_dentry->d_inode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4319:  struct user_namespace *mnt_userns = &init_user_ns;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "4291:  if (source == target)",
          "4292:   return 0;",
          "4295:  if (error)",
          "4296:   return error;",
          "4298:  if (!target) {",
          "4300:  } else {",
          "4301:   new_is_dir = d_is_dir(new_dentry);",
          "4303:   if (!(flags & RENAME_EXCHANGE))",
          "4305:   else",
          "4307:  }",
          "4308:  if (error)",
          "4309:   return error;",
          "",
          "[Removed Lines]",
          "4294:  error = may_delete(old_dir, old_dentry, is_dir);",
          "4299:   error = may_create(new_dir, new_dentry);",
          "4304:    error = may_delete(new_dir, new_dentry, is_dir);",
          "4306:    error = may_delete(new_dir, new_dentry, new_is_dir);",
          "",
          "[Added Lines]",
          "4330:  error = may_delete(mnt_userns, old_dir, old_dentry, is_dir);",
          "4335:   error = may_create(mnt_userns, new_dir, new_dentry);",
          "4340:    error = may_delete(mnt_userns, new_dir, new_dentry, is_dir);",
          "4342:    error = may_delete(mnt_userns, new_dir, new_dentry, new_is_dir);",
          "",
          "---------------"
        ],
        "fs/xattr.c||fs/xattr.c": [
          "File: fs/xattr.c -> fs/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "102:    return -EPERM;",
          "103:  }",
          "",
          "[Removed Lines]",
          "101:   if (HAS_UNMAPPED_ID(inode))",
          "",
          "[Added Lines]",
          "101:   if (HAS_UNMAPPED_ID(mnt_userns, inode))",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2083: #define IS_WHITEOUT(inode) (S_ISCHR(inode->i_mode) && \\",
          "2084:      (inode)->i_rdev == WHITEOUT_DEV)",
          "2087: {",
          "2089: }",
          "2091: static inline enum rw_hint file_write_hint(struct file *file)",
          "",
          "[Removed Lines]",
          "2086: static inline bool HAS_UNMAPPED_ID(struct inode *inode)",
          "2088:  return !uid_valid(inode->i_uid) || !gid_valid(inode->i_gid);",
          "",
          "[Added Lines]",
          "2086: static inline bool HAS_UNMAPPED_ID(struct user_namespace *mnt_userns,",
          "2087:        struct inode *inode)",
          "2089:  return !uid_valid(i_uid_into_mnt(mnt_userns, inode)) ||",
          "2090:         !gid_valid(i_gid_into_mnt(mnt_userns, inode));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2823:  return inode_permission(mnt_user_ns(path->mnt),",
          "2824:     d_inode(path->dentry), mask);",
          "2825: }",
          "2828: static inline bool execute_ok(struct inode *inode)",
          "2829: {",
          "",
          "[Removed Lines]",
          "2826: extern int __check_sticky(struct inode *dir, struct inode *inode);",
          "",
          "[Added Lines]",
          "2828: int __check_sticky(struct user_namespace *mnt_userns, struct inode *dir,",
          "2829:      struct inode *inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3442:  return (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));",
          "3443: }",
          "3446: {",
          "3447:  if (!(dir->i_mode & S_ISVTX))",
          "3448:   return 0;",
          "3451: }",
          "3453: static inline void inode_has_no_xattr(struct inode *inode)",
          "",
          "[Removed Lines]",
          "3445: static inline int check_sticky(struct inode *dir, struct inode *inode)",
          "3450:  return __check_sticky(dir, inode);",
          "",
          "[Added Lines]",
          "3448: static inline int check_sticky(struct user_namespace *mnt_userns,",
          "3449:           struct inode *dir, struct inode *inode)",
          "3454:  return __check_sticky(mnt_userns, dir, inode);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
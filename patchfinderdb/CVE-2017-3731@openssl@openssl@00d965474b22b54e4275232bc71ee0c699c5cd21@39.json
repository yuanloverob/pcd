{
  "cve_id": "CVE-2017-3731",
  "cve_desc": "If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k.",
  "repo": "openssl/openssl",
  "patch_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
  "patch_info": {
    "commit_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21",
    "files": [
      "crypto/evp/e_aes.c",
      "crypto/evp/e_chacha20_poly1305.c"
    ],
    "message": "crypto/evp: harden AEAD ciphers.\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory. Since hash\noperation is read-only it is not considered to be exploitable\nbeyond a DoS condition. Other ciphers were hardened.\n\nThanks to Robert \u015awi\u0119cki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "crypto/evp/e_aes.c||crypto/evp/e_aes.c",
      "crypto/evp/e_chacha20_poly1305.c||crypto/evp/e_chacha20_poly1305.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/e_aes.c||crypto/evp/e_aes.c": [
      "File: crypto/evp/e_aes.c -> crypto/evp/e_aes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1388:                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8",
      "1389:                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];",
      "1391:             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;",
      "1394:                 len -= EVP_GCM_TLS_TAG_LEN;",
      "1395:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;",
      "1396:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;",
      "1397:         }",
      "",
      "[Removed Lines]",
      "1393:             if (!EVP_CIPHER_CTX_encrypting(c))",
      "",
      "[Added Lines]",
      "1391:             if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)",
      "1392:                 return 0;",
      "1395:             if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "1396:                 if (len < EVP_GCM_TLS_TAG_LEN)",
      "1397:                     return 0;",
      "1399:             }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1946:                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8",
      "1947:                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];",
      "1949:             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;",
      "1952:                 len -= cctx->M;",
      "1953:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;",
      "1954:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;",
      "1955:         }",
      "",
      "[Removed Lines]",
      "1951:             if (!EVP_CIPHER_CTX_encrypting(c))",
      "",
      "[Added Lines]",
      "1954:             if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)",
      "1955:                 return 0;",
      "1958:             if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "1959:                 if (len < cctx->M)",
      "1960:                     return 0;",
      "1962:             }",
      "",
      "---------------"
    ],
    "crypto/evp/e_chacha20_poly1305.c||crypto/evp/e_chacha20_poly1305.c": [
      "File: crypto/evp/e_chacha20_poly1305.c -> crypto/evp/e_chacha20_poly1305.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "398:             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |",
      "399:                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];",
      "400:             if (!ctx->encrypt) {",
      "402:                 memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);",
      "403:                 aad = temp;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "401:                 if (len < POLY1305_BLOCK_SIZE)",
      "402:                     return 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "edc18749bd5dfb7e12513d3978f78f9b56104fd6",
      "candidate_info": {
        "commit_hash": "edc18749bd5dfb7e12513d3978f78f9b56104fd6",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/edc18749bd5dfb7e12513d3978f78f9b56104fd6",
        "files": [
          "crypto/threads_win.c"
        ],
        "message": "Fixed deadlock in CRYPTO_THREAD_run_once for Windows\n\nFixed deadlock in CRYPTO_THREAD_run_once() if call to init() is causing\na recursive call to CRYPTO_THREAD_run_once() again that is causing a hot\ndeadloop inside do { } while (result == ONCE_ININIT); section.\n\nCLA: trivial\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1913)\n\n(cherry picked from commit 349d1cfddcfa33d352240582a3803f2eba39d9a0)",
        "before_after_code_files": [
          "crypto/threads_win.c||crypto/threads_win.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/threads_win.c||crypto/threads_win.c": [
          "File: crypto/threads_win.c -> crypto/threads_win.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:     do {",
          "79:         result = InterlockedCompareExchange(lock, ONCE_ININIT, ONCE_UNINITED);",
          "80:         if (result == ONCE_UNINITED) {",
          "83:             return 1;",
          "84:         }",
          "85:     } while (result == ONCE_ININIT);",
          "",
          "[Removed Lines]",
          "81:             init();",
          "",
          "[Added Lines]",
          "82:             init();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "263390c32cd4f6baefd41346407eee51c1fd3fa2",
      "candidate_info": {
        "commit_hash": "263390c32cd4f6baefd41346407eee51c1fd3fa2",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/263390c32cd4f6baefd41346407eee51c1fd3fa2",
        "files": [
          "ssl/ssl_lib.c"
        ],
        "message": "Don't read uninitialised data for short session IDs.\n\nWhile it's always safe to read |SSL_MAX_SSL_SESSION_ID_LENGTH| bytes\nfrom an |SSL_SESSION|'s |session_id| array, the hash function would do\nso with without considering if all those bytes had been written to.\n\nThis change checks |session_id_length| before possibly reading\nuninitialised memory. Since the result of the hash function was already\nattacker controlled, and since a lookup of a short session ID will\nalways fail, it doesn't appear that this is anything more than a clean\nup.\n\nIn particular, |ssl_get_prev_session| uses a stack-allocated placeholder\n|SSL_SESSION| as a lookup key, so the |session_id| array may be\nuninitialised.\n\nThis was originally found with libFuzzer and MSan in\nhttps://boringssl.googlesource.com/boringssl/+/e976e4349d693b4bbb97e1694f45be5a1b22c8c7,\nthen by Robert Swiecki with honggfuzz and MSan here. Thanks to both.\n\nReviewed-by: Geoff Thorpe <geoff@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2583)\n(cherry picked from commit bd5d27c1c6d3f83464ddf5124f18a2cac2cbb37f)",
        "before_after_code_files": [
          "ssl/ssl_lib.c||ssl/ssl_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ssl/ssl_lib.c||ssl/ssl_lib.c": [
          "File: ssl/ssl_lib.c -> ssl/ssl_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2306: static unsigned long ssl_session_hash(const SSL_SESSION *a)",
          "2307: {",
          "2308:     unsigned long l;",
          "2310:     l = (unsigned long)",
          "2315:     return (l);",
          "2316: }",
          "",
          "[Removed Lines]",
          "2311:         ((unsigned int)a->session_id[0]) |",
          "2312:         ((unsigned int)a->session_id[1] << 8L) |",
          "2313:         ((unsigned long)a->session_id[2] << 16L) |",
          "2314:         ((unsigned long)a->session_id[3] << 24L);",
          "",
          "[Added Lines]",
          "2308:     const unsigned char *session_id = a->session_id;",
          "2310:     unsigned char tmp_storage[4];",
          "2312:     if (a->session_id_length < sizeof(tmp_storage)) {",
          "2313:         memset(tmp_storage, 0, sizeof(tmp_storage));",
          "2314:         memcpy(tmp_storage, a->session_id, a->session_id_length);",
          "2315:         session_id = tmp_storage;",
          "2316:     }",
          "2319:         ((unsigned long)session_id[0]) |",
          "2320:         ((unsigned long)session_id[1] << 8L) |",
          "2321:         ((unsigned long)session_id[2] << 16L) |",
          "2322:         ((unsigned long)session_id[3] << 24L);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20b53c3efedd192c5a4050bfd44d317e5d802d2e",
      "candidate_info": {
        "commit_hash": "20b53c3efedd192c5a4050bfd44d317e5d802d2e",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/20b53c3efedd192c5a4050bfd44d317e5d802d2e",
        "files": [
          "crypto/init.c"
        ],
        "message": "Add a warning stipulating how things should be coded in ossl_init_base\n\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1922)\n(cherry picked from commit 8aa9cf7e655ae1e41f283fbf16dcc810970058a0)",
        "before_after_code_files": [
          "crypto/init.c||crypto/init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/init.c||crypto/init.c": [
          "File: crypto/init.c -> crypto/init.c"
        ]
      }
    },
    {
      "candidate_hash": "723f616df81ea05f31407f7417f49eea89bb459a",
      "candidate_info": {
        "commit_hash": "723f616df81ea05f31407f7417f49eea89bb459a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/723f616df81ea05f31407f7417f49eea89bb459a",
        "files": [
          "crypto/asn1/bio_asn1.c"
        ],
        "message": "Exit the loop on failure\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2805)\n(cherry picked from commit f125430063dd81efe098c99542b02b2a918adc1d)",
        "before_after_code_files": [
          "crypto/asn1/bio_asn1.c||crypto/asn1/bio_asn1.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/asn1/bio_asn1.c||crypto/asn1/bio_asn1.c": [
          "File: crypto/asn1/bio_asn1.c -> crypto/asn1/bio_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "209:                 wrmax = inl;",
          "210:             ret = BIO_write(next, in, wrmax);",
          "211:             if (ret <= 0)",
          "213:             wrlen += ret;",
          "214:             ctx->copylen -= ret;",
          "215:             in += ret;",
          "",
          "[Removed Lines]",
          "212:                 break;",
          "",
          "[Added Lines]",
          "212:                 goto done;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "249452df67f7a5e4b203d71837cc0e8a31d62c75",
      "candidate_info": {
        "commit_hash": "249452df67f7a5e4b203d71837cc0e8a31d62c75",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/249452df67f7a5e4b203d71837cc0e8a31d62c75",
        "files": [
          "crypto/asn1/x_long.c"
        ],
        "message": "Fix decoding of ASN.1 LONG and ZLONG items\n\nLONG and ZLONG items (which are OpenSSL private special cases of\nASN1_INTEGER) are encoded into DER with padding if the leading octet\nhas the high bit set, where the padding can be 0x00 (for positive\nnumbers) or 0xff (for negative ones).\n\nWhen decoding DER to LONG or ZLONG, the padding wasn't taken in\naccount at all, which means that if the encoded size with padding\nis one byte more than the size of long, decoding fails.  This change\nfixes that issue.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3000)",
        "before_after_code_files": [
          "crypto/asn1/x_long.c||crypto/asn1/x_long.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/asn1/x_long.c||crypto/asn1/x_long.c": [
          "File: crypto/asn1/x_long.c -> crypto/asn1/x_long.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "105: static int long_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "106:                     int utype, char *free_cont, const ASN1_ITEM *it)",
          "107: {",
          "109:     long ltmp;",
          "110:     unsigned long utmp = 0;",
          "111:     char *cp = (char *)pval;",
          "112:     if (len > (int)sizeof(long)) {",
          "113:         ASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);",
          "114:         return 0;",
          "115:     }",
          "121:     utmp = 0;",
          "122:     for (i = 0; i < len; i++) {",
          "123:         utmp <<= 8;",
          "",
          "[Removed Lines]",
          "108:     int neg, i;",
          "117:     if (len && (cont[0] & 0x80))",
          "118:         neg = 1;",
          "119:     else",
          "120:         neg = 0;",
          "",
          "[Added Lines]",
          "108:     int neg = -1, i;",
          "113:     if (len) {",
          "119:         switch (cont[0]) {",
          "120:         case 0xff:",
          "121:             cont++;",
          "122:             len--;",
          "123:             neg = 1;",
          "124:             break;",
          "125:         case 0:",
          "126:             cont++;",
          "127:             len--;",
          "128:             neg = 0;",
          "129:             break;",
          "130:         }",
          "131:     }",
          "136:     if (neg == -1) {",
          "138:         if (len && (cont[0] & 0x80))",
          "139:             neg = 1;",
          "140:         else",
          "141:             neg = 0;",
          "142:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-32136",
  "cve_desc": "Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.",
  "repo": "gpac/gpac",
  "patch_hash": "eb71812fcc10e9c5348a5d1c61bd25b6fa06eaed",
  "patch_info": {
    "commit_hash": "eb71812fcc10e9c5348a5d1c61bd25b6fa06eaed",
    "repo": "gpac/gpac",
    "commit_url": "https://github.com/gpac/gpac/commit/eb71812fcc10e9c5348a5d1c61bd25b6fa06eaed",
    "files": [
      "applications/mp4box/filedump.c"
    ],
    "message": "fixed #1765",
    "before_after_code_files": [
      "applications/mp4box/filedump.c||applications/mp4box/filedump.c"
    ]
  },
  "patch_diff": {
    "applications/mp4box/filedump.c||applications/mp4box/filedump.c": [
      "File: applications/mp4box/filedump.c -> applications/mp4box/filedump.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1895:    u32 udta_size;",
      "1896:    gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);",
      "1897:    if (!udta) continue;",
      "1899:     if (first) {",
      "1900:      fprintf(stderr, \"\\n\");",
      "1901:      first = GF_FALSE;",
      "1902:     }",
      "1904:    }",
      "1905:    gf_free(udta);",
      "1906:   }",
      "",
      "[Removed Lines]",
      "1898:    if (gf_utf8_is_legal(udta, udta_size)) {",
      "1903:     fprintf(stderr, \"\\t%s\\n\", (char *) udta);",
      "",
      "[Added Lines]",
      "1898:    if (udta_size && gf_utf8_is_legal(udta, udta_size)) {",
      "1899:     u32 idx;",
      "1904:     fprintf(stderr, \"\\t\");",
      "1905:     for (idx=0; idx<udta_size; idx++) {",
      "1906:      if (!udta[idx]) break;",
      "1907:      fprintf(stderr, \"%c\", udta[idx]);",
      "1908:     }",
      "1909:     fprintf(stderr, \"\\n\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c0205efc2ee2edfffb9fb687ba1dd27043b01ead",
      "candidate_info": {
        "commit_hash": "c0205efc2ee2edfffb9fb687ba1dd27043b01ead",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/c0205efc2ee2edfffb9fb687ba1dd27043b01ead",
        "files": [
          "applications/mp4box/filedump.c",
          "include/gpac/utf.h",
          "src/export.cpp",
          "src/filters/isoffin_load.c",
          "src/utils/utf.c"
        ],
        "message": "add valid utf8 check for udta print (cf #1606) and export udta values in filters",
        "before_after_code_files": [
          "applications/mp4box/filedump.c||applications/mp4box/filedump.c",
          "include/gpac/utf.h||include/gpac/utf.h",
          "src/export.cpp||src/export.cpp",
          "src/filters/isoffin_load.c||src/filters/isoffin_load.c",
          "src/utils/utf.c||src/utils/utf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "applications/mp4box/filedump.c||applications/mp4box/filedump.c"
          ],
          "candidate": [
            "applications/mp4box/filedump.c||applications/mp4box/filedump.c"
          ]
        }
      },
      "candidate_diff": {
        "applications/mp4box/filedump.c||applications/mp4box/filedump.c": [
          "File: applications/mp4box/filedump.c -> applications/mp4box/filedump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1830:  return szTime;",
          "1831: }",
          "1843: void print_udta(GF_ISOFile *file, u32 track_number)",
          "1844: {",
          "1845:  u32 i, count;",
          "",
          "[Removed Lines]",
          "1833: static Bool is_printable(u8 *data, u32 data_size)",
          "1834: {",
          "1835:  u32 i;",
          "1836:  for (i=0; i<data_size; i++) {",
          "1837:   if (i && data[i]==0) return GF_TRUE;",
          "1838:   if (!isascii(data[i])) return GF_FALSE;",
          "1839:  }",
          "1840:  return GF_TRUE;",
          "1841: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1859:    u8 *udta=NULL;",
          "1860:    u32 udta_size;",
          "1861:    gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);",
          "1863:     if (first) {",
          "1864:      fprintf(stderr, \"\\n\");",
          "1865:      first = GF_FALSE;",
          "",
          "[Removed Lines]",
          "1862:    if (udta && is_printable(udta, udta_size)) {",
          "",
          "[Added Lines]",
          "1852:    if (!udta) continue;",
          "1853:    if (gf_utf8_is_legal(udta, udta_size)) {",
          "",
          "---------------"
        ],
        "include/gpac/utf.h||include/gpac/utf.h": [
          "File: include/gpac/utf.h -> include/gpac/utf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "93: char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr);",
          "96: \\brief string bidi reordering",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96: \\brief Checks validity of a UTF8 string",
          "98: Checks if a given byte sequence is a valid UTF-8 encoding",
          "99: \\param data the byte equence buffer",
          "100: \\param size the length of the byte sequence",
          "101: \\return GF_TRUE if valid UTF8, GF_FALSE otherwise",
          "103: Bool gf_utf8_is_legal(const u8 *data, u32 size);",
          "",
          "---------------"
        ],
        "src/export.cpp||src/export.cpp": [
          "File: src/export.cpp -> src/export.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "390: #pragma comment (linker, EXPORT_SYMBOL(gf_utf8_wcslen) )",
          "391: #pragma comment (linker, EXPORT_SYMBOL(gf_utf8_to_wcs) )",
          "392: #pragma comment (linker, EXPORT_SYMBOL(gf_wcs_to_utf8) )",
          "393: #ifndef GPAC_DISABLE_PLAYER",
          "394: #pragma comment (linker, EXPORT_SYMBOL(gf_utf8_is_right_to_left) )",
          "395: #pragma comment (linker, EXPORT_SYMBOL(gf_utf8_reorder_bidi) )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "393: #pragma comment (linker, EXPORT_SYMBOL(gf_utf8_is_legal) )",
          "",
          "---------------"
        ],
        "src/filters/isoffin_load.c||src/filters/isoffin_load.c": [
          "File: src/filters/isoffin_load.c -> src/filters/isoffin_load.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "730:   }",
          "732:   if (!gf_sys_is_test_mode()) {",
          "733:    const char *hdlr = NULL;",
          "734:    gf_isom_get_handler_name(read->mov, ch->track, &hdlr);",
          "735:    if (hdlr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "733:    u32 nb_udta;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "748:     gf_isom_get_track_matrix(read->mov, ch->track, vals);",
          "749:     gf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_MATRIX, &p);",
          "750:    }",
          "751:   }",
          "752:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:    nb_udta =  gf_isom_get_udta_count(read->mov, ch->track);",
          "755:    if (nb_udta) {",
          "756:     for (i=0; i<nb_udta; i++) {",
          "757:      u32 j, type, nb_items;",
          "758:      bin128 uuid;",
          "759:      gf_isom_get_udta_type(read->mov, ch->track, i+1, &type, &uuid);",
          "760:      nb_items = gf_isom_get_user_data_count(read->mov, ch->track, type, uuid);",
          "762:      if (!type) continue;",
          "764:      for (j=0; j<nb_items; j++) {",
          "765:       char szName[31];",
          "766:       u8 *udta=NULL;",
          "767:       u32 udta_size;",
          "768:       gf_isom_get_user_data(read->mov, ch->track, type, uuid, j+1, &udta, &udta_size);",
          "769:       if (!udta) continue;",
          "770:       if (nb_items>1)",
          "771:        snprintf(szName, 30, \"udta_%s_%d\", gf_4cc_to_str(type), j+1);",
          "772:       else",
          "773:        snprintf(szName, 30, \"udta_%s\", gf_4cc_to_str(type));",
          "774:       szName[30]=0;",
          "775:       if (gf_utf8_is_legal(udta, udta_size)) {",
          "776:        gf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_STRING_NO_COPY(udta));",
          "777:       } else {",
          "778:        gf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_DATA_NO_COPY(udta, udta_size));",
          "779:       }",
          "780:      }",
          "781:     }",
          "782:    }",
          "",
          "---------------"
        ],
        "src/utils/utf.c||src/utils/utf.c": [
          "File: src/utils/utf.c -> src/utils/utf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "252:  UTF8 a;",
          "253:  const UTF8 *srcptr = source+length;",
          "254:  switch (length) {",
          "",
          "[Removed Lines]",
          "251: static Boolean isLegalUTF8(const UTF8 *source, int length) {",
          "",
          "[Added Lines]",
          "251: Boolean isLegalUTF8(const UTF8 *source, int length) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "375: }",
          "379: GF_EXPORT",
          "380: size_t gf_utf8_wcslen (const unsigned short *s)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "378: GF_EXPORT",
          "379: Bool gf_utf8_is_legal(const u8 *data, u32 length)",
          "380: {",
          "382:  const UTF8** sourceStart = (const UTF8**) &data;",
          "383:  const UTF8* sourceEnd = (const UTF8*) ( data + length );",
          "384:  ConversionFlags flags = strictConversion;",
          "385:  ConversionResult result = conversionOK;",
          "386:  const UTF8* source = *sourceStart;",
          "388:  while (source < sourceEnd) {",
          "389:   UTF32 ch = 0;",
          "390:   unsigned short extraBytesToRead = trailingBytesForUTF8[*source];",
          "391:   if (source + extraBytesToRead >= sourceEnd) {",
          "392:    result = sourceExhausted;",
          "393:    break;",
          "394:   }",
          "396:   if (! isLegalUTF8(source, extraBytesToRead+1)) {",
          "397:    result = sourceIllegal;",
          "398:    break;",
          "399:   }",
          "403:   switch (extraBytesToRead) {",
          "404:   case 5:",
          "405:    ch += *source++;",
          "407:   case 4:",
          "408:    ch += *source++;",
          "410:   case 3:",
          "411:    ch += *source++;",
          "412:    ch <<= 6;",
          "413:   case 2:",
          "414:    ch += *source++;",
          "415:    ch <<= 6;",
          "416:   case 1:",
          "417:    ch += *source++;",
          "418:    ch <<= 6;",
          "419:   case 0:",
          "420:    ch += *source++;",
          "421:   }",
          "422:   ch -= offsetsFromUTF8[extraBytesToRead];",
          "426:    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {",
          "427:     if (flags == strictConversion) {",
          "429:      result = sourceIllegal;",
          "430:      break;",
          "431:     }",
          "432:    }",
          "433:   } else if (ch > UNI_MAX_UTF16) {",
          "434:    if (flags == strictConversion) {",
          "435:     result = sourceIllegal;",
          "438:    }",
          "439:   } else {",
          "440:    ch -= halfBase;",
          "441:   }",
          "442:  }",
          "443:  return (result==conversionOK) ? GF_TRUE : GF_FALSE;",
          "444: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "caec5a1327ec53c9c6dd9dd4f9e7a70de70431d7",
      "candidate_info": {
        "commit_hash": "caec5a1327ec53c9c6dd9dd4f9e7a70de70431d7",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/caec5a1327ec53c9c6dd9dd4f9e7a70de70431d7",
        "files": [
          "applications/mp4box/filedump.c",
          "applications/mp4box/main.c"
        ],
        "message": "cosmetics",
        "before_after_code_files": [
          "applications/mp4box/filedump.c||applications/mp4box/filedump.c",
          "applications/mp4box/main.c||applications/mp4box/main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "applications/mp4box/filedump.c||applications/mp4box/filedump.c"
          ],
          "candidate": [
            "applications/mp4box/filedump.c||applications/mp4box/filedump.c"
          ]
        }
      },
      "candidate_diff": {
        "applications/mp4box/filedump.c||applications/mp4box/filedump.c": [
          "File: applications/mp4box/filedump.c -> applications/mp4box/filedump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2058:  fprintf(stderr, \"%d UDTA types: \", count);",
          "2060:  for (i=0; i<count; i++) {",
          "2062:   bin128 uuid;",
          "2063:   gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);",
          "2064:   nb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);",
          "2066:   for (j=0; j<nb_items; j++) {",
          "2067:    u8 *udta=NULL;",
          "2068:    u32 udta_size;",
          "2069:    gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);",
          "2070:    if (!udta) continue;",
          "2071:    if (udta_size && gf_utf8_is_legal(udta, udta_size)) {",
          "2072:     u32 idx;",
          "2078:     for (idx=0; idx<udta_size; idx++) {",
          "2079:      if (!udta[idx]) break;",
          "2080:      fprintf(stderr, \"%c\", udta[idx]);",
          "2081:     }",
          "2083:    }",
          "2084:    gf_free(udta);",
          "2085:   }",
          "",
          "[Removed Lines]",
          "2061:   u32 j, type, nb_items, first=GF_TRUE;",
          "2065:   fprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);",
          "2073:     if (first) {",
          "2074:      fprintf(stderr, \"\\n\");",
          "2075:      first = GF_FALSE;",
          "2076:     }",
          "2077:     fprintf(stderr, \"\\t\");",
          "2082:     fprintf(stderr, \"\\n\");",
          "",
          "[Added Lines]",
          "2061:   u32 j, type, nb_items;",
          "2065:   if (!nb_items) continue;",
          "2067:   fprintf(stderr, \"\\n\\t%s: \", gf_4cc_to_str(type));",
          "2073:    if (j) fprintf(stderr, \", \");",
          "2080:    } else {",
          "2081:     fprintf(stderr, \" unknown type (%d bytes)\", udta_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2633:  print_udta(file, trackNum, GF_FALSE);",
          "2635:  if (gf_isom_is_video_handler_type(mtype) ) {",
          "2636:   s32 tx, ty;",
          "2637:   u32 w, h;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2634:  DumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");",
          "2636:  gf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);",
          "2637:  if (alt_group) {",
          "2638:   fprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);",
          "2639:   for (i=0; i<nb_groups; i++) {",
          "2640:    u32 nb_crit, switchGroupID;",
          "2641:    const u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);",
          "2642:    if (!nb_crit) {",
          "2643:     fprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");",
          "2644:    } else {",
          "2645:     if (switchGroupID) {",
          "2646:      fprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);",
          "2647:     } else {",
          "2648:      fprintf(stderr, \"\\tAlternate Group criterias: \");",
          "2649:     }",
          "2650:     for (j=0; j<nb_crit; j++) {",
          "2651:      if (j) fprintf(stderr, \" \");",
          "2652:      fprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );",
          "2653:     }",
          "2654:     fprintf(stderr, \"\\n\");",
          "2655:    }",
          "2656:   }",
          "2657:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3202:    if (auxiliary_mimes != NULL) {",
          "3203:     fprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);",
          "3204:    }",
          "3205:   } else {",
          "3206:    fprintf(stderr, \"Unknown Text Stream\");",
          "3207:   }",
          "3209:  } else if (mtype == GF_ISOM_MEDIA_META) {",
          "3210:   const char *content_encoding = NULL;",
          "3211:   if (msub_type == GF_ISOM_SUBTYPE_METT) {",
          "",
          "[Removed Lines]",
          "3208:   fprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);",
          "",
          "[Added Lines]",
          "3229:   } else if (mtype == GF_ISOM_MEDIA_SUBT) {",
          "3230:    fprintf(stderr, \"QT/3GPP subtitle\");",
          "3234:   fprintf(stderr, \"\\n\\tSize %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3455:  }",
          "3483:  switch (gf_isom_has_sync_points(file, trackNum)) {",
          "3484:  case 0:",
          "3485:   fprintf(stderr, \"\\tAll samples are sync\\n\");",
          "",
          "[Removed Lines]",
          "3458:  DumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");",
          "3460:  gf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);",
          "3461:  if (alt_group) {",
          "3462:   fprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);",
          "3463:   for (i=0; i<nb_groups; i++) {",
          "3464:    u32 nb_crit, switchGroupID;",
          "3465:    const u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);",
          "3466:    if (!nb_crit) {",
          "3467:     fprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");",
          "3468:    } else {",
          "3469:     if (switchGroupID) {",
          "3470:      fprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);",
          "3471:     } else {",
          "3472:      fprintf(stderr, \"\\tAlternate Group criterias: \");",
          "3473:     }",
          "3474:     for (j=0; j<nb_crit; j++) {",
          "3475:      if (j) fprintf(stderr, \" \");",
          "3476:      fprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );",
          "3477:     }",
          "3478:     fprintf(stderr, \"\\n\");",
          "3479:    }",
          "3480:   }",
          "3481:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "applications/mp4box/main.c||applications/mp4box/main.c": [
          "File: applications/mp4box/main.c -> applications/mp4box/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "117: typedef enum {",
          "140: } TrackActionType;",
          "142: typedef struct",
          "",
          "[Removed Lines]",
          "118:  TRAC_ACTION_REM_TRACK= 0,",
          "119:  TRAC_ACTION_SET_LANGUAGE,",
          "120:  TRAC_ACTION_SET_DELAY,",
          "121:  TRAC_ACTION_SET_KMS_URI,",
          "122:  TRAC_ACTION_SET_PAR,",
          "123:  TRAC_ACTION_SET_HANDLER_NAME,",
          "124:  TRAC_ACTION_ENABLE,",
          "125:  TRAC_ACTION_DISABLE,",
          "126:  TRAC_ACTION_REFERENCE,",
          "127:  TRAC_ACTION_RAW_EXTRACT,",
          "128:  TRAC_ACTION_REM_NON_RAP,",
          "129:  TRAC_ACTION_SET_KIND,",
          "130:  TRAC_ACTION_REM_KIND,",
          "131:  TRAC_ACTION_SET_ID,",
          "132:  TRAC_ACTION_SET_UDTA,",
          "133:  TRAC_ACTION_SWAP_ID,",
          "134:  TRAC_ACTION_REM_NON_REFS,",
          "135:  TRAC_ACTION_SET_CLAP,",
          "136:  TRAC_ACTION_SET_MX,",
          "137:  TRAC_ACTION_SET_EDITS,",
          "138:  TRAC_ACTION_SET_TIME,",
          "139:  TRAC_ACTION_SET_MEDIA_TIME,",
          "",
          "[Added Lines]",
          "118:  TRACK_ACTION_REM_TRACK= 0,",
          "119:  TRACK_ACTION_SET_LANGUAGE,",
          "120:  TRACK_ACTION_SET_DELAY,",
          "121:  TRACK_ACTION_SET_KMS_URI,",
          "122:  TRACK_ACTION_SET_PAR,",
          "123:  TRACK_ACTION_SET_HANDLER_NAME,",
          "124:  TRACK_ACTION_ENABLE,",
          "125:  TRACK_ACTION_DISABLE,",
          "126:  TRACK_ACTION_REFERENCE,",
          "127:  TRACK_ACTION_RAW_EXTRACT,",
          "128:  TRACK_ACTION_REM_NON_RAP,",
          "129:  TRACK_ACTION_SET_KIND,",
          "130:  TRACK_ACTION_REM_KIND,",
          "131:  TRACK_ACTION_SET_ID,",
          "132:  TRACK_ACTION_SET_UDTA,",
          "133:  TRACK_ACTION_SWAP_ID,",
          "134:  TRACK_ACTION_REM_NON_REFS,",
          "135:  TRACK_ACTION_SET_CLAP,",
          "136:  TRACK_ACTION_SET_MX,",
          "137:  TRACK_ACTION_SET_EDITS,",
          "138:  TRACK_ACTION_SET_TIME,",
          "139:  TRACK_ACTION_SET_MEDIA_TIME,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "376:   \"  - SMPTE codes: `h:m:s;nb_f/fps chapter_name` and `h:m:s;nb_f chapter_name` with `nb_f` the number of frames and `fps` the framerate with 1 chapter per line\\n\"",
          "377:   \"  - Common syntax: `CHAPTERX=h:m:s[:ms or .ms]` on first line and `CHAPTERXNAME=name` on next line (reverse order accepted)\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file, 0, ARG_OPEN_EDIT),",
          "378:   MP4BOX_ARG(\"chapqt\", \"set chapter information from given file, using QT signaling for text tracks\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file_qt, 0, ARG_OPEN_EDIT),",
          "382:   MP4BOX_ARG(\"rap\", \"remove all non-RAP samples from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),",
          "383:   MP4BOX_ARG(\"refonly\", \"remove all non-reference pictures from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 1, ARG_IS_FUN | ARG_EMPTY),",
          "386:   {\"timescale\", NULL, \"set movie timescale to given value (ticks per second)\", \"600\", NULL, GF_ARG_INT, 0, &timescale, 0, ARG_OPEN_EDIT},",
          "389:   MP4BOX_ARG_S(\"par\", \"tkID=PAR\", \"set visual track pixel aspect ratio. PAR is:\\n\"",
          "390:      \"  - N:D: set PAR to N:D in track, do not modify the bitstream\\n\"",
          "391:      \"  - wN:D: set PAR to N:D in track and try to modify the bitstream\\n\"",
          "392:      \"  - none: remove PAR info from track, do not modify the bitstream\\n\"",
          "393:      \"  - auto: retrieve PAR info from bitstream and set it in track\\n\"",
          "395:      ),",
          "396:   MP4BOX_ARG_S(\"clap\", \"tkID=CLAP\", \"set visual track clean aperture. CLAP is `Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd` or `none`\\n\"",
          "397:     \"- n, d: numerator, denominator\\n\"",
          "398:          \"- W, H, HO, VO: clap width, clap height, clap horizontal offset, clap vertical offset\\n\"",
          "400:   MP4BOX_ARG_S(\"mx\", \"tkID=MX\", \"set track matrix, with MX is M1:M2:M3:M4:M5:M6:M7:M8:M9 in 16.16 fixed point intergers or hexa\"",
          "405:   MP4BOX_ARG(\"itags\", \"set iTunes tags to file, see `-h tags`\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &itunes_tags, 0, ARG_OPEN_EDIT),",
          "406:   MP4BOX_ARG(\"group-add\", \"create a new grouping information in the file. Format is a colon-separated list of following options:\\n\"",
          "407:          \"- refTrack=ID: ID of the track used as a group reference. If not set, the track will belong to the same group as the \"",
          "",
          "[Removed Lines]",
          "379:   MP4BOX_ARG_S(\"set-track-id\", \"id1:id2\", \"change id of track with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SET_ID, ARG_IS_FUN),",
          "380:   MP4BOX_ARG_S(\"swap-track-id\", \"id1:id2\", \"swap the id between tracks with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SWAP_ID, ARG_IS_FUN),",
          "381:   MP4BOX_ARG(\"rem\", \"remove given track from file\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_REM_TRACK, ARG_IS_FUN),",
          "384:   MP4BOX_ARG(\"enable\", \"enable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_ENABLE, ARG_IS_FUN),",
          "385:   MP4BOX_ARG(\"disable\", \"disable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_DISABLE, ARG_IS_FUN),",
          "387:   MP4BOX_ARG_S(\"lang\", \"[tkID=]LAN\", \"set language. LAN is the BCP-47 code (eng, en-UK, ...). If no track ID is given, sets language to all tracks\", 0, parse_track_action, TRAC_ACTION_SET_LANGUAGE, ARG_IS_FUN),",
          "388:   MP4BOX_ARG_S(\"delay\", \"tkID=TIME\", \"set track start delay (>0) or initial skip (<0) in ms or in fractional seconds (`N/D`)\", 0, parse_track_action, TRAC_ACTION_SET_DELAY, ARG_IS_FUN),",
          "394:      \"  - force: force 1:1 PAR in track, do not modify the bitstream\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_PAR, ARG_IS_FUN",
          "399:     , GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_CLAP, ARG_IS_FUN),",
          "401:     , GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_MX, ARG_IS_FUN),",
          "402:  MP4BOX_ARG_S(\"kind\", \"tkID=schemeURI=value\", \"set kind for the track or for all tracks using `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_SET_KIND, ARG_IS_FUN),",
          "403:  MP4BOX_ARG_S(\"kind-rem\", \"tkID=schemeURI=value\", \"remove kind if given schemeID for the track or for all tracks with `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_REM_KIND, ARG_IS_FUN),",
          "404:   MP4BOX_ARG_S(\"name\", \"tkID=NAME\", \"set track handler name to NAME (UTF-8 string)\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_HANDLER_NAME, ARG_IS_FUN),",
          "",
          "[Added Lines]",
          "379:   MP4BOX_ARG_S(\"set-track-id\", \"id1:id2\", \"change id of track with id1 to id2\", 0, parse_track_action, TRACK_ACTION_SET_ID, ARG_IS_FUN),",
          "380:   MP4BOX_ARG_S(\"swap-track-id\", \"id1:id2\", \"swap the id between tracks with id1 to id2\", 0, parse_track_action, TRACK_ACTION_SWAP_ID, ARG_IS_FUN),",
          "381:   MP4BOX_ARG(\"rem\", \"remove given track from file\", GF_ARG_INT, 0, parse_track_action, TRACK_ACTION_REM_TRACK, ARG_IS_FUN),",
          "384:   MP4BOX_ARG(\"enable\", \"enable given track\", GF_ARG_INT, 0, parse_track_action, TRACK_ACTION_ENABLE, ARG_IS_FUN),",
          "385:   MP4BOX_ARG(\"disable\", \"disable given track\", GF_ARG_INT, 0, parse_track_action, TRACK_ACTION_DISABLE, ARG_IS_FUN),",
          "387:   MP4BOX_ARG_S(\"lang\", \"[tkID=]LAN\", \"set language. LAN is the BCP-47 code (eng, en-UK, ...). If no track ID is given, sets language to all tracks\", 0, parse_track_action, TRACK_ACTION_SET_LANGUAGE, ARG_IS_FUN),",
          "388:   MP4BOX_ARG_S(\"delay\", \"tkID=TIME\", \"set track start delay (>0) or initial skip (<0) in ms or in fractional seconds (`N/D`)\", 0, parse_track_action, TRACK_ACTION_SET_DELAY, ARG_IS_FUN),",
          "394:      \"  - force: force 1:1 PAR in track, do not modify the bitstream\", GF_ARG_HINT_ADVANCED, parse_track_action, TRACK_ACTION_SET_PAR, ARG_IS_FUN",
          "399:     , GF_ARG_HINT_ADVANCED, parse_track_action, TRACK_ACTION_SET_CLAP, ARG_IS_FUN),",
          "401:     , GF_ARG_HINT_ADVANCED, parse_track_action, TRACK_ACTION_SET_MX, ARG_IS_FUN),",
          "402:  MP4BOX_ARG_S(\"kind\", \"tkID=schemeURI=value\", \"set kind for the track or for all tracks using `all=schemeURI=value`\", 0, parse_track_action, TRACK_ACTION_SET_KIND, ARG_IS_FUN),",
          "403:  MP4BOX_ARG_S(\"kind-rem\", \"tkID=schemeURI=value\", \"remove kind if given schemeID for the track or for all tracks with `all=schemeURI=value`\", 0, parse_track_action, TRACK_ACTION_REM_KIND, ARG_IS_FUN),",
          "404:   MP4BOX_ARG_S(\"name\", \"tkID=NAME\", \"set track handler name to NAME (UTF-8 string)\", GF_ARG_HINT_ADVANCED, parse_track_action, TRACK_ACTION_SET_HANDLER_NAME, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "416:  MP4BOX_ARG(\"group-rem-track\", \"remove given track from its group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_TSEL, ARG_IS_FUN),",
          "417:  MP4BOX_ARG(\"group-rem\", \"remove the track's group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP, ARG_IS_FUN),",
          "418:  MP4BOX_ARG(\"group-clean\", \"remove all group information from all tracks\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &clean_groups, 0, ARG_OPEN_EDIT),",
          "420:  MP4BOX_ARG(\"keep-utc\", \"keep UTC timing in the file after edit\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &keep_utc, 0, 0),",
          "421:  MP4BOX_ARG_S(\"udta\", \"tkID:[OPTS]\", \"set udta for given track or movie if tkID is 0. OPTS is a colon separated list of:\\n\"",
          "422:          \"- type=CODE: 4CC code of the UDTA (not needed for `box=` option)\\n\"",
          "",
          "[Removed Lines]",
          "419:  MP4BOX_ARG_S(\"ref\", \"id:XXXX:refID\", \"add a reference of type 4CC from track ID to track refID\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_REFERENCE, ARG_IS_FUN),",
          "",
          "[Added Lines]",
          "419:  MP4BOX_ARG_S(\"ref\", \"id:XXXX:refID\", \"add a reference of type 4CC from track ID to track refID\", GF_ARG_HINT_ADVANCED, parse_track_action, TRACK_ACTION_REFERENCE, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "425:          \"- src=FILE: location of the udta data (will be stored in a single box of type CODE)\\n\"",
          "426:          \"- src=base64,DATA: base64 encoded udta data (will be stored in a single box of type CODE)\\n\"",
          "427:          \"- str=STRING: use the given string as payload for the udta box\\n\"",
          "429:  MP4BOX_ARG_S(\"patch\", \"[tkID=]FILE\", \"apply box patch described in FILE, for given trackID if set\", GF_ARG_HINT_ADVANCED, parse_boxpatch, 0, ARG_IS_FUN),",
          "430:  MP4BOX_ARG(\"bo\", \"freeze the order of boxes in input file\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &freeze_box_order, 0, 0),",
          "431:  MP4BOX_ARG(\"init-seg\", \"use the given file as an init segment for dumping or for encryption\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &use_init_seg, 0, 0),",
          "",
          "[Removed Lines]",
          "428:          \"Note: If no source is set, UDTA of type CODE will be removed\\n\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_UDTA, ARG_IS_FUN|ARG_OPEN_EDIT),",
          "",
          "[Added Lines]",
          "428:          \"Note: If no source is set, UDTA of type CODE will be removed\\n\", GF_ARG_HINT_ADVANCED, parse_track_action, TRACK_ACTION_SET_UDTA, ARG_IS_FUN|ARG_OPEN_EDIT),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "440:    \" - Examples: \\n\"",
          "441:    \"   - `re0-5e5-3,4`: remove edits, add empty edit at 0s for 5s, then add regular edit at 5s for 3s starting at 4s in media track\\n\"",
          "442:    \"   - `re0-4,0,0.5`: remove edits, add single edit at 0s for 4s starting at 0s in media track and playing at speed 0.5\\n\"",
          "444:   MP4BOX_ARG(\"moovpad\", \"specify amount of padding to keep after moov box for later inplace editing - if 0, moov padding is disabled\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &moov_pading, 0, ARG_NEED_SAVE),",
          "445:   MP4BOX_ARG(\"no-inplace\", \"disable inplace rewrite\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &no_inplace, 0, 0),",
          "446:   MP4BOX_ARG(\"hdr\", \"update HDR information based on given XML\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &high_dynamc_range_filename, 0, ARG_OPEN_EDIT),",
          "449:  {0}",
          "450: };",
          "",
          "[Removed Lines]",
          "443:     , 0, parse_track_action, TRAC_ACTION_SET_EDITS, ARG_IS_FUN),",
          "447:   MP4BOX_ARG_S(\"time\", \"[tkID=]DAY/MONTH/YEAR-H:M:S\", \"set movie or track creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRAC_ACTION_SET_TIME, ARG_IS_FUN),",
          "448:   MP4BOX_ARG_S(\"mtime\", \"tkID=DAY/MONTH/YEAR-H:M:S\", \"set media creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRAC_ACTION_SET_MEDIA_TIME, ARG_IS_FUN),",
          "",
          "[Added Lines]",
          "443:     , 0, parse_track_action, TRACK_ACTION_SET_EDITS, ARG_IS_FUN),",
          "447:   MP4BOX_ARG_S(\"time\", \"[tkID=]DAY/MONTH/YEAR-H:M:S\", \"set movie or track creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRACK_ACTION_SET_TIME, ARG_IS_FUN),",
          "448:   MP4BOX_ARG_S(\"mtime\", \"tkID=DAY/MONTH/YEAR-H:M:S\", \"set media creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRACK_ACTION_SET_MEDIA_TIME, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "986: {",
          "987:   MP4BOX_ARG(\"crypt\", \"encrypt the input file using the given `CryptFile`\", GF_ARG_STRING, 0, parse_cryp, 0, ARG_IS_FUN),",
          "988:   MP4BOX_ARG(\"decrypt\", \"decrypt the input file, potentially using the given `CryptFile`. If `CryptFile` is not given, will fail if the key management system is not supported\", GF_ARG_STRING, 0, parse_cryp, 1, ARG_IS_FUN | ARG_EMPTY),",
          "990:   {0}",
          "991: };",
          "",
          "[Removed Lines]",
          "989:   MP4BOX_ARG_S(\"set-kms\", \"tkID=kms_uri\", \"change ISMA/OMA KMS location for a given track or for all tracks if `all=` is used\", 0, parse_track_action, TRAC_ACTION_SET_KMS_URI, ARG_IS_FUN),",
          "",
          "[Added Lines]",
          "989:   MP4BOX_ARG_S(\"set-kms\", \"tkID=kms_uri\", \"change ISMA/OMA KMS location for a given track or for all tracks if `all=` is used\", 0, parse_track_action, TRACK_ACTION_SET_KMS_URI, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2168:  memset(tka, 0, sizeof(TrackAction) );",
          "2169:  tka->act_type = act_type;",
          "2170:  tka->dump_type = dump_type;",
          "2172:   open_edit = GF_TRUE;",
          "2173:   do_save = GF_TRUE;",
          "2174:  }",
          "2177:   if (sscanf(param, \"%d:%u\", &tka->trackID, &tka->newTrackID) != 2) {",
          "2178:    M4_LOG(GF_LOG_ERROR, (\"Bad format for -set-track-id - expecting \\\"id1:id2\\\" got \\\"%s\\\"\\n\", param));",
          "2179:    return GF_FALSE;",
          "2180:   }",
          "2181:   return GF_TRUE;",
          "2182:  }",
          "2184:   char *ext;",
          "2185:   ext = strchr(param, '=');",
          "2186:   if (!ext) {",
          "",
          "[Removed Lines]",
          "2171:  if (act_type != TRAC_ACTION_RAW_EXTRACT) {",
          "2176:  if ((act_type==TRAC_ACTION_SET_ID) || (act_type==TRAC_ACTION_SWAP_ID)) {",
          "2183:  if (act_type==TRAC_ACTION_SET_PAR) {",
          "",
          "[Added Lines]",
          "2171:  if (act_type != TRACK_ACTION_RAW_EXTRACT) {",
          "2176:  if ((act_type==TRACK_ACTION_SET_ID) || (act_type==TRACK_ACTION_SWAP_ID)) {",
          "2183:  if (act_type==TRACK_ACTION_SET_PAR) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2213:   }",
          "2214:   return GF_TRUE;",
          "2215:  }",
          "2217:   char *ext = strchr(param, '=');",
          "2218:   if (!ext) {",
          "2219:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param));",
          "",
          "[Removed Lines]",
          "2216:  if (act_type==TRAC_ACTION_SET_CLAP) {",
          "",
          "[Added Lines]",
          "2216:  if (act_type==TRACK_ACTION_SET_CLAP) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2232:   return GF_TRUE;",
          "2233:  }",
          "2236:   char *ext = strchr(param, '=');",
          "2237:   if (!ext) {",
          "2238:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param));",
          "",
          "[Removed Lines]",
          "2235:  if (act_type==TRAC_ACTION_SET_MX) {",
          "",
          "[Added Lines]",
          "2235:  if (act_type==TRACK_ACTION_SET_MX) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2258:   }",
          "2259:   return GF_TRUE;",
          "2260:  }",
          "2262:   char *ext = strchr(param, '=');",
          "2263:   if (!ext) {",
          "2264:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track edits - expecting ID=EDITS got %s\\n\", param));",
          "",
          "[Removed Lines]",
          "2261:  if (act_type==TRAC_ACTION_SET_EDITS) {",
          "",
          "[Added Lines]",
          "2261:  if (act_type==TRACK_ACTION_SET_EDITS) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2270:   tka->string = gf_strdup(ext+1);",
          "2271:   return GF_TRUE;",
          "2272:  }",
          "2274:   char *ext = strchr(param, '=');",
          "2275:   if (!strnicmp(param, \"all=\", 4)) {",
          "2276:    strncpy(tka->lang, param + 4, 10-1);",
          "",
          "[Removed Lines]",
          "2273:  if (act_type==TRAC_ACTION_SET_LANGUAGE) {",
          "",
          "[Added Lines]",
          "2273:  if (act_type==TRACK_ACTION_SET_LANGUAGE) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2285:   }",
          "2286:   return GF_TRUE;",
          "2287:  }",
          "2289:   char *ext;",
          "2290:   char *scheme_start = NULL;",
          "",
          "[Removed Lines]",
          "2288:  if ((act_type==TRAC_ACTION_SET_KIND) || (act_type==TRAC_ACTION_REM_KIND)) {",
          "",
          "[Added Lines]",
          "2288:  if ((act_type==TRACK_ACTION_SET_KIND) || (act_type==TRACK_ACTION_REM_KIND)) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2324:   }",
          "2325:   return GF_TRUE;",
          "2326:  }",
          "2328:   char *ext = strchr(param, '=');",
          "2329:   if (!ext) {",
          "2330:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track delay - expecting tkID=DLAY got %s\\n\", param));",
          "",
          "[Removed Lines]",
          "2327:  if (act_type==TRAC_ACTION_SET_DELAY) {",
          "",
          "[Added Lines]",
          "2327:  if (act_type==TRACK_ACTION_SET_DELAY) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2339:   }",
          "2340:   return GF_TRUE;",
          "2341:  }",
          "2343:   char *ext = strchr(param, '=');",
          "2344:   if (!ext) ext = strchr(param, ':');",
          "2345:   if (!ext) {",
          "",
          "[Removed Lines]",
          "2342:  if (act_type==TRAC_ACTION_REFERENCE) {",
          "",
          "[Added Lines]",
          "2342:  if (act_type==TRACK_ACTION_REFERENCE) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2361:   tka->newTrackID = (s32) atoi(ext2 + 1);",
          "2362:   return GF_TRUE;",
          "2363:  }",
          "2365:   char *ext = strchr(param, '=');",
          "2366:   if (!ext) {",
          "2367:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track name - expecting tkID=name got %s\\n\", param));",
          "",
          "[Removed Lines]",
          "2364:  if (act_type==TRAC_ACTION_SET_HANDLER_NAME) {",
          "",
          "[Added Lines]",
          "2364:  if (act_type==TRACK_ACTION_SET_HANDLER_NAME) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2373:   tka->hdl_name = ext + 1;",
          "2374:   return GF_TRUE;",
          "2375:  }",
          "2377:   char *ext = strchr(param, '=');",
          "2379:   if (!strnicmp(param, \"all=\", 4)) {",
          "",
          "[Removed Lines]",
          "2376:  if (act_type==TRAC_ACTION_SET_KMS_URI) {",
          "",
          "[Added Lines]",
          "2376:  if (act_type==TRACK_ACTION_SET_KMS_URI) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2388:   }",
          "2389:   return GF_TRUE;",
          "2390:  }",
          "2392:   struct tm time;",
          "2393:   char *ext = strchr(arg_val, '=');",
          "2394:   if (ext) {",
          "",
          "[Removed Lines]",
          "2391:  if ((act_type==TRAC_ACTION_SET_TIME) || (act_type==TRAC_ACTION_SET_MEDIA_TIME)) {",
          "",
          "[Added Lines]",
          "2391:  if ((act_type==TRACK_ACTION_SET_TIME) || (act_type==TRACK_ACTION_SET_MEDIA_TIME)) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2442:   if (!strcmp(arg_val, \"*\")) {",
          "2443:    tka->trackID = (u32) -1;",
          "2444:   } else {",
          "2446:     if (!strncmp(arg_val, \"video\", 5)) {",
          "2447:      arg_val += 5;",
          "2448:      tka->dump_track_type = 1;",
          "",
          "[Removed Lines]",
          "2445:    if (act_type==TRAC_ACTION_RAW_EXTRACT) {",
          "",
          "[Added Lines]",
          "2445:    if (act_type==TRACK_ACTION_RAW_EXTRACT) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2462: u32 parse_track_dump(char *arg, u32 dump_type)",
          "2463: {",
          "2465:   return 2;",
          "2466:  track_dump_type = dump_type;",
          "2467:  return 0;",
          "",
          "[Removed Lines]",
          "2464:  if (!create_new_track_action(arg, TRAC_ACTION_RAW_EXTRACT, dump_type))",
          "",
          "[Added Lines]",
          "2464:  if (!create_new_track_action(arg, TRACK_ACTION_RAW_EXTRACT, dump_type))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2541: {",
          "2542:  if (arg_val) {",
          "2543:   if (sscanf(arg_val, \"%d\", &trackID) == 1) {",
          "2545:   }",
          "2546:  }",
          "2547:  hint_flags |= GP_RTP_PCK_SIGNAL_RAP;",
          "",
          "[Removed Lines]",
          "2544:    parse_track_action(arg_val, opt ? TRAC_ACTION_REM_NON_REFS : TRAC_ACTION_REM_NON_RAP);",
          "",
          "[Added Lines]",
          "2544:    parse_track_action(arg_val, opt ? TRACK_ACTION_REM_NON_REFS : TRACK_ACTION_REM_NON_RAP);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4625:  for (i=0; i<nb_track_act; i++) {",
          "4626:   GF_Err e;",
          "4627:   TrackAction *tka = &tracks[i];",
          "4629:   memset(&mdump, 0, sizeof(mdump));",
          "4630:   mdump.in_name = inName;",
          "4631:   mdump.flags = tka->dump_type;",
          "",
          "[Removed Lines]",
          "4628:   if (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;",
          "",
          "[Added Lines]",
          "4628:   if (tka->act_type != TRACK_ACTION_RAW_EXTRACT) continue;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4695:  for (i=0; i<nb_track_act; i++) {",
          "4696:   u32 j;",
          "4697:   TrackAction *tka = &tracks[i];",
          "4699:   memset(&mdump, 0, sizeof(mdump));",
          "4700:   mdump.file = file;",
          "4701:   mdump.flags = tka->dump_type;",
          "",
          "[Removed Lines]",
          "4698:   if (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;",
          "",
          "[Added Lines]",
          "4698:   if (tka->act_type != TRACK_ACTION_RAW_EXTRACT) continue;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5074:   timescale = gf_isom_get_timescale(file);",
          "5075:   switch (tka->act_type) {",
          "5077:    e = gf_isom_remove_track(file, track);",
          "5078:    if (e) {",
          "5079:     M4_LOG(GF_LOG_ERROR, (\"Error Removing track ID %d: %s\\n\", tka->trackID, gf_error_to_string(e)));",
          "",
          "[Removed Lines]",
          "5076:   case TRAC_ACTION_REM_TRACK:",
          "",
          "[Added Lines]",
          "5076:   case TRACK_ACTION_REM_TRACK:",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "5082:    }",
          "5083:    do_save = GF_TRUE;",
          "5084:    break;",
          "5086:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5087:     if (track && (track != i+1)) continue;",
          "5088:     e = gf_isom_set_media_language(file, i+1, tka->lang);",
          "",
          "[Removed Lines]",
          "5085:   case TRAC_ACTION_SET_LANGUAGE:",
          "",
          "[Added Lines]",
          "5085:   case TRACK_ACTION_SET_LANGUAGE:",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5091:    }",
          "5092:    do_save = GF_TRUE;",
          "5093:    break;",
          "5095:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5096:     if (track && (track != i+1)) continue;",
          "5097:     e = gf_isom_add_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "",
          "[Removed Lines]",
          "5094:   case TRAC_ACTION_SET_KIND:",
          "",
          "[Added Lines]",
          "5094:   case TRACK_ACTION_SET_KIND:",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "5100:    }",
          "5101:    do_save = GF_TRUE;",
          "5102:    break;",
          "5104:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5105:     if (track && (track != i+1)) continue;",
          "5106:     e = gf_isom_remove_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "",
          "[Removed Lines]",
          "5103:   case TRAC_ACTION_REM_KIND:",
          "",
          "[Added Lines]",
          "5103:   case TRACK_ACTION_REM_KIND:",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "5109:    }",
          "5110:    do_save = GF_TRUE;",
          "5111:    break;",
          "5113:    if (tka->delay.num && tka->delay.den) {",
          "5114:     u64 tk_dur;",
          "",
          "[Removed Lines]",
          "5112:   case TRAC_ACTION_SET_DELAY:",
          "",
          "[Added Lines]",
          "5112:   case TRACK_ACTION_SET_DELAY:",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "5144:     do_save = GF_TRUE;",
          "5145:    }",
          "5146:    break;",
          "5148:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5149:     if (track && (track != i+1)) continue;",
          "5150:     if (!gf_isom_is_media_encrypted(file, i+1, 1)) continue;",
          "",
          "[Removed Lines]",
          "5147:   case TRAC_ACTION_SET_KMS_URI:",
          "",
          "[Added Lines]",
          "5147:   case TRACK_ACTION_SET_KMS_URI:",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "5154:     do_save = GF_TRUE;",
          "5155:    }",
          "5156:    break;",
          "5158:    if (!tka->trackID && (gf_isom_get_track_count(file) == 1)) {",
          "5159:     M4_LOG(GF_LOG_WARNING, (\"Warning: track id is not specified, but file has only one track - assume that you want to change id for this track\\n\"));",
          "5160:     track = 1;",
          "",
          "[Removed Lines]",
          "5157:   case TRAC_ACTION_SET_ID:",
          "",
          "[Added Lines]",
          "5157:   case TRACK_ACTION_SET_ID:",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "5173:     M4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));",
          "5174:    }",
          "5175:    break;",
          "5177:    if (track) {",
          "5178:     u32 tk1, tk2;",
          "5179:     tk1 = gf_isom_get_track_by_id(file, tka->trackID);",
          "",
          "[Removed Lines]",
          "5176:   case TRAC_ACTION_SWAP_ID:",
          "",
          "[Added Lines]",
          "5176:   case TRACK_ACTION_SWAP_ID:",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "5193:     M4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));",
          "5194:    }",
          "5195:    break;",
          "5197:    e = gf_media_change_par(file, track, tka->par_num, tka->par_den, tka->force_par, tka->rewrite_bs);",
          "5198:    do_save = GF_TRUE;",
          "5199:    break;",
          "5201:    e = gf_isom_set_clean_aperture(file, track, 1, tka->clap_wnum, tka->clap_wden, tka->clap_hnum, tka->clap_hden, tka->clap_honum, tka->clap_hoden, tka->clap_vonum, tka->clap_voden);",
          "5202:    do_save = GF_TRUE;",
          "5203:    break;",
          "5205:    e = gf_isom_set_track_matrix(file, track, tka->mx);",
          "5206:    do_save = GF_TRUE;",
          "5207:    break;",
          "5209:    e = gf_isom_set_handler_name(file, track, tka->hdl_name);",
          "5210:    do_save = GF_TRUE;",
          "5211:    break;",
          "5213:    if (!gf_isom_is_track_enabled(file, track)) {",
          "5214:     e = gf_isom_set_track_enabled(file, track, GF_TRUE);",
          "5215:     do_save = GF_TRUE;",
          "5216:    }",
          "5217:    break;",
          "5219:    if (gf_isom_is_track_enabled(file, track)) {",
          "5220:     e = gf_isom_set_track_enabled(file, track, GF_FALSE);",
          "5221:     do_save = GF_TRUE;",
          "5222:    }",
          "5223:    break;",
          "5225:    e = gf_isom_set_track_reference(file, track, GF_4CC(tka->lang[0], tka->lang[1], tka->lang[2], tka->lang[3]), tka->newTrackID);",
          "5226:    do_save = GF_TRUE;",
          "5227:    break;",
          "5229:    e = gf_media_remove_non_rap(file, track, GF_FALSE);",
          "5230:    do_save = GF_TRUE;",
          "5231:    break;",
          "5233:    e = gf_media_remove_non_rap(file, track, GF_TRUE);",
          "5234:    do_save = GF_TRUE;",
          "5235:    break;",
          "5237:    e = set_file_udta(file, track, tka->udta_type, tka->string ? tka->string : tka->src_name , tka->sample_num ? GF_TRUE : GF_FALSE, tka->string ? GF_TRUE : GF_FALSE);",
          "5238:    do_save = GF_TRUE;",
          "5239:    break;",
          "5241:    e = apply_edits(file, track, tka->string);",
          "5242:    do_save = GF_TRUE;",
          "5243:    break;",
          "5245:    if (!tka->trackID) {",
          "5246:     e = gf_isom_set_creation_time(file, tka->time, tka->time);",
          "5247:     if (e) return e;",
          "",
          "[Removed Lines]",
          "5196:   case TRAC_ACTION_SET_PAR:",
          "5200:   case TRAC_ACTION_SET_CLAP:",
          "5204:   case TRAC_ACTION_SET_MX:",
          "5208:   case TRAC_ACTION_SET_HANDLER_NAME:",
          "5212:   case TRAC_ACTION_ENABLE:",
          "5218:   case TRAC_ACTION_DISABLE:",
          "5224:   case TRAC_ACTION_REFERENCE:",
          "5228:   case TRAC_ACTION_REM_NON_RAP:",
          "5232:   case TRAC_ACTION_REM_NON_REFS:",
          "5236:   case TRAC_ACTION_SET_UDTA:",
          "5240:   case TRAC_ACTION_SET_EDITS:",
          "5244:   case TRAC_ACTION_SET_TIME:",
          "",
          "[Added Lines]",
          "5196:   case TRACK_ACTION_SET_PAR:",
          "5200:   case TRACK_ACTION_SET_CLAP:",
          "5204:   case TRACK_ACTION_SET_MX:",
          "5208:   case TRACK_ACTION_SET_HANDLER_NAME:",
          "5212:   case TRACK_ACTION_ENABLE:",
          "5218:   case TRACK_ACTION_DISABLE:",
          "5224:   case TRACK_ACTION_REFERENCE:",
          "5228:   case TRACK_ACTION_REM_NON_RAP:",
          "5232:   case TRACK_ACTION_REM_NON_REFS:",
          "5236:   case TRACK_ACTION_SET_UDTA:",
          "5240:   case TRACK_ACTION_SET_EDITS:",
          "5244:   case TRACK_ACTION_SET_TIME:",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "5254:    }",
          "5255:    do_save = GF_TRUE;",
          "5256:    break;",
          "5258:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5259:     if (track && (track != i+1)) continue;",
          "5260:     e = gf_isom_set_media_creation_time(file, i+1, tka->time, tka->time);",
          "",
          "[Removed Lines]",
          "5257:   case TRAC_ACTION_SET_MEDIA_TIME:",
          "",
          "[Added Lines]",
          "5257:   case TRACK_ACTION_SET_MEDIA_TIME:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e7c0a1150b87473acd3a8465bcf94a5d66b56329",
      "candidate_info": {
        "commit_hash": "e7c0a1150b87473acd3a8465bcf94a5d66b56329",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/e7c0a1150b87473acd3a8465bcf94a5d66b56329",
        "files": [
          "applications/mp4box/filedump.c",
          "applications/mp4box/main.c",
          "share/doc/man/gpac-filters.1",
          "share/doc/man/gpac.1",
          "share/doc/man/mp4box.1",
          "share/doc/man/mp4client.1",
          "src/isomedia/isom_read.c",
          "testsuite"
        ],
        "message": "rework help for split (cf #1619) and print udta values when possible (cf #1606)",
        "before_after_code_files": [
          "applications/mp4box/filedump.c||applications/mp4box/filedump.c",
          "applications/mp4box/main.c||applications/mp4box/main.c",
          "src/isomedia/isom_read.c||src/isomedia/isom_read.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "applications/mp4box/filedump.c||applications/mp4box/filedump.c"
          ],
          "candidate": [
            "applications/mp4box/filedump.c||applications/mp4box/filedump.c"
          ]
        }
      },
      "candidate_diff": {
        "applications/mp4box/filedump.c||applications/mp4box/filedump.c": [
          "File: applications/mp4box/filedump.c -> applications/mp4box/filedump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1830:  return szTime;",
          "1831: }",
          "1833: void print_udta(GF_ISOFile *file, u32 track_number)",
          "1834: {",
          "1835:  u32 i, count;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1833: static Bool is_printable(u8 *data, u32 data_size)",
          "1834: {",
          "1835:  u32 i;",
          "1836:  for (i=0; i<data_size; i++) {",
          "1837:   if (i && data[i]==0) return GF_TRUE;",
          "1838:   if (!isascii(data[i])) return GF_FALSE;",
          "1839:  }",
          "1840:  return GF_TRUE;",
          "1841: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1840:  fprintf(stderr, \"%d UDTA types: \", count);",
          "1842:  for (i=0; i<count; i++) {",
          "1844:   bin128 uuid;",
          "1845:   gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);",
          "1847:  }",
          "1848:  fprintf(stderr, \"\\n\");",
          "1849: }",
          "",
          "[Removed Lines]",
          "1843:   u32 type;",
          "1846:   fprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), gf_isom_get_user_data_count(file, track_number, type, uuid) );",
          "",
          "[Added Lines]",
          "1853:   u32 j, type, nb_items, first=GF_TRUE;",
          "1856:   nb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);",
          "1857:   fprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);",
          "1858:   for (j=0; j<nb_items; j++) {",
          "1859:    u8 *udta=NULL;",
          "1860:    u32 udta_size;",
          "1861:    gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);",
          "1862:    if (udta && is_printable(udta, udta_size)) {",
          "1863:     if (first) {",
          "1864:      fprintf(stderr, \"\\n\");",
          "1865:      first = GF_FALSE;",
          "1866:     }",
          "1867:     fprintf(stderr, \"\\t%s\\n\", (char *) udta);",
          "1868:    }",
          "1869:    gf_free(udta);",
          "1870:   }",
          "",
          "---------------"
        ],
        "applications/mp4box/main.c||applications/mp4box/main.c": [
          "File: applications/mp4box/main.c -> applications/mp4box/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:   GF_DEF_ARG(\"name `tkID=NAME`\", NULL, \"set track handler name to NAME (UTF-8 string)\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "171:   GF_DEF_ARG(\"itags `tag1[:tag2]`\", NULL, \"set iTunes tags to file, see [-tag-list]()\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "172:   GF_DEF_ARG(\"tag-list\", NULL, \"print the set of supported iTunes tags\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "181:   GF_DEF_ARG(\"group-add\", NULL, \"create a new grouping information in the file. Format is a colon-separated list of following options:\\n\"",
          "182:          \"- refTrack=ID: ID of the track used as a group reference. If not set, the track will belong to the same group as the \"",
          "183:          \"previous trackID specified. If 0 or no previous track specified, a new alternate group will be created\\n\"",
          "",
          "[Removed Lines]",
          "173:   GF_DEF_ARG(\"split\", NULL, \"split in files of given max duration\", NULL, NULL, GF_ARG_STRING, 0),",
          "174:  GF_DEF_ARG(\"split-size\", \"splits\", \"split in files of given max size (in kb)\", NULL, NULL, GF_ARG_STRING, 0),",
          "175:  GF_DEF_ARG(\"split-rap\", \"splitr\", \"split in files at each new RAP\", NULL, NULL, GF_ARG_STRING, 0),",
          "176:  GF_DEF_ARG(\"split-chunk VAL\", \"splitx\", \"extract a new file from source. `VAL` can be formated as:\\n\"",
          "177:  \"- `S:E`: `S` (number of seconds) to `E` with `E` a number (in seconds), `end` or `end-N`, N  number of seconds before the end\\n\"",
          "178:  \"- `S-E`: start and end dates, each formatted as `HH:MM:SS.ms` or `MM:SS.ms`\", NULL, NULL, GF_ARG_STRING, 0),",
          "179:  GF_DEF_ARG(\"splitz `S:E`\", NULL, \"same as -split-chunk, but adjust the end time to be before the last RAP sample\", NULL, NULL, GF_ARG_STRING, 0),",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "214: {",
          "215:  u32 i=0;",
          "216:  gf_sys_format_help(helpout, help_flags, \"# General Options\\n\"",
          "218:   \"MP4Box provides a large set of options, classified by categories (see [-h]()). These options do not follow any particular ordering.\\n\"",
          "219:   \"MP4Box performs in-place rewrite of IsoMedia files (the input file is overwritten). You can change this behaviour by using the [-out]() option.\\n\"",
          "220:   \"MP4Box stores by default the file with 0.5 second interleaving and meta-data (`moov`...) at the beginning, making it suitable for HTTP streaming. This may however takes longer to store the file, use [-flat]() to change this behaviour.\\n\"",
          "",
          "[Removed Lines]",
          "217:   \"MP4Box is a multimedia packager, with a vast number of functionalities: conversion, splitting, hinting, dumping, DASH-ing, encryption and others.\\n\"",
          "",
          "[Added Lines]",
          "207:   \"MP4Box is a multimedia packager, with a vast number of functionalities: conversion, splitting, hinting, dumping, DASH-ing, encryption, transcoding and others.\\n\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "224:   \"Unless specified otherwise, an option of type `integer` expects a trackID value following it.\"",
          "225:   \"An option of type `boolean` expects no following value.\"",
          "226:   \"  \\n\"",
          "233:  );",
          "235:  while (m4b_gen_args[i].name) {",
          "236:   GF_GPACArg *arg = &m4b_gen_args[i];",
          "237:   i++;",
          "",
          "[Removed Lines]",
          "227:   \"# File Splitting and Concatenation\\n\"",
          "228:   \"MP4Box can split IsoMedia files by size, duration or extract a given part of the file to new IsoMedia file(s). This process requires that at most one track in the input file has non random-access points (typically one video track at most). This process will also ignore all MPEG-4 Systems tracks and hint tracks, but will try to split private media tracks.\\n\"",
          "229:   \"Note: The input file must have enough random access points in order to be split. This may not be the case with some video files where only the very first sample of the video track is a key frame (many 3GP files with H263 video are recorded that way). In order to split such files you will have to use a real video editor and re-encode the content.\\n\"",
          "230:   \"Note: You can add media to a file and split it in the same pass. In this case, the destination file (the one which would be obtained without spliting) will not be stored.\\n\"",
          "231:   \"  \\n\"",
          "232:   \"Options:\\n\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "240: }",
          "243: GF_GPACArg m4b_dash_args[] =",
          "244: {",
          "245:   GF_DEF_ARG(\"mpd\", NULL, \"convert given HLS or smooth manifest (local or remote http) to MPD.  \\nWarning: This is not compatible with other DASH options and does not convert associated segments\", NULL, NULL, GF_ARG_STRING, 0),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "228: GF_GPACArg m4b_split_args[] =",
          "229: {",
          "230:   GF_DEF_ARG(\"split\", NULL, \"split in files of given max duration\", NULL, NULL, GF_ARG_STRING, 0),",
          "231:  GF_DEF_ARG(\"split-size\", \"splits\", \"split in files of given max size (in kb)\", NULL, NULL, GF_ARG_STRING, 0),",
          "232:  GF_DEF_ARG(\"split-rap\", \"splitr\", \"split in files at each new RAP\", NULL, NULL, GF_ARG_STRING, 0),",
          "233:  GF_DEF_ARG(\"split-chunk VAL\", \"splitx\", \"extract a new file from source. `VAL` can be formated as:\\n\"",
          "234:  \"- `S:E`: `S` (number of seconds) to `E` with `E` a number (in seconds), `end` or `end-N`, N  number of seconds before the end\\n\"",
          "235:  \"- `S-E`: start and end dates, each formatted as `HH:MM:SS.ms` or `MM:SS.ms`\", NULL, NULL, GF_ARG_STRING, 0),",
          "236:  GF_DEF_ARG(\"splitz `S:E`\", NULL, \"same as -split-chunk, but adjust the end time to be before the last RAP sample\", NULL, NULL, GF_ARG_STRING, 0),",
          "237:  {0}",
          "238: };",
          "241: static void PrintSplitUsage()",
          "242: {",
          "243:  u32 i=0;",
          "244:  gf_sys_format_help(helpout, help_flags, \"  \\n\"",
          "245:   \"# File Spliting\\n\"",
          "246:   \"MP4Box can split IsoMedia files by size, duration or extract a given part of the file to new IsoMedia file(s).\\n\"",
          "247:   \"This requires that at most one track in the input file has non random-access points (typically one video track at most).\\n\"",
          "248:   \"Spliting will ignore all MPEG-4 Systems tracks and hint tracks, but will try to split private media tracks.\\n\"",
          "249:   \"The input file must have enough random access points in order to be split. If this is not the case, you will have to re-encode the content.\\n\"",
          "250:   \"You can add media to a file and split it in the same pass. In this case, the destination file (the one which would be obtained without spliting) will not be stored.\\n\"",
          "251:   \"  \\n\"",
          "252:  );",
          "254:  i=0;",
          "255:  while (m4b_split_args[i].name) {",
          "256:   GF_GPACArg *arg = &m4b_split_args[i];",
          "257:   i++;",
          "258:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-split\");",
          "259:  }",
          "261: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "413: };",
          "417:  GF_DEF_ARG(\"dur\", NULL, \"`X` import only the specified duration from the media. Value can be:\\n\"",
          "418:   \"  - positive float: specifies duration in seconds\\n\"",
          "419:   \"  - fraction: specifies duration as NUM/DEN fraction\\n\"",
          "",
          "[Removed Lines]",
          "416: static GF_GPACArg ImportFileOpts [] = {",
          "",
          "[Added Lines]",
          "437: static GF_GPACArg m4b_imp_fileopt_args [] = {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "571:  );",
          "573:  i=0;",
          "576:   i++;",
          "577:   gf_sys_print_arg(helpout, help_flags | GF_PRINTARG_NO_DASH, arg, \"mp4box-import\");",
          "578:  }",
          "",
          "[Removed Lines]",
          "574:  while (ImportFileOpts[i].name) {",
          "575:   GF_GPACArg *arg = &ImportFileOpts[i];",
          "",
          "[Added Lines]",
          "595:  while (m4b_imp_fileopt_args[i].name) {",
          "596:   GF_GPACArg *arg = &m4b_imp_fileopt_args[i];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "942:    \"- general: general options help\\n\"",
          "943:   \"- hint: hinting options help\\n\"",
          "944:   \"- dash: DASH segmenter help\\n\"",
          "945:   \"- import: import options help\\n\"",
          "946:   \"- encode: encode options help\\n\"",
          "948:   \"- extract: extraction options help\\n\"",
          "949:   \"- dump: dump options help\\n\"",
          "950:   \"- swf: Flash (SWF) options help\\n\"",
          "",
          "[Removed Lines]",
          "947:   \"- meta: meta handling options help\\n\"",
          "",
          "[Added Lines]",
          "966:   \"- split: split options help\\n\"",
          "969:   \"- meta: meta (HEIF, MPEG-21) handling options help\\n\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1021:   GF_GPACArg an_arg;",
          "1022:   Bool do_match = GF_FALSE;",
          "1025:    flags = GF_PRINTARG_COLON;",
          "1026:    if (!strncmp(arg_name, arg->name, alen) && ((arg->name[alen]==0) || (arg->name[alen]=='=')))",
          "1027:     do_match = GF_TRUE;",
          "",
          "[Removed Lines]",
          "1024:   if (args==ImportFileOpts) {",
          "",
          "[Added Lines]",
          "1046:   if (args==m4b_imp_fileopt_args) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1066:  u32 res = 0;",
          "1067:  u32 alen = (u32) strlen(arg_name);",
          "1068:  res += PrintHelpForArgs(arg_name, m4b_gen_args, search_type);",
          "1069:  res += PrintHelpForArgs(arg_name, m4b_dash_args, search_type);",
          "1070:  res += PrintHelpForArgs(arg_name, m4b_imp_args, search_type);",
          "1072:  res += PrintHelpForArgs(arg_name, m4b_senc_args, search_type);",
          "1073:  res += PrintHelpForArgs(arg_name, m4b_crypt_args, search_type);",
          "1074:  res += PrintHelpForArgs(arg_name, m4b_hint_args, search_type);",
          "",
          "[Removed Lines]",
          "1071:  res += PrintHelpForArgs(arg_name, ImportFileOpts, search_type);",
          "",
          "[Added Lines]",
          "1091:  res += PrintHelpForArgs(arg_name, m4b_split_args, search_type);",
          "1094:  res += PrintHelpForArgs(arg_name, m4b_imp_fileopt_args, search_type);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3516:    if (i + 1 == (u32)argc) PrintUsage();",
          "3517:    else if (!strcmp(argv[i + 1], \"general\")) PrintGeneralUsage();",
          "3518:    else if (!strcmp(argv[i + 1], \"extract\")) PrintExtractUsage();",
          "3519:    else if (!strcmp(argv[i + 1], \"dash\")) PrintDASHUsage();",
          "3520:    else if (!strcmp(argv[i + 1], \"dump\")) PrintDumpUsage();",
          "3521:    else if (!strcmp(argv[i + 1], \"import\")) PrintImportUsage();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3542:    else if (!strcmp(argv[i + 1], \"split\")) PrintSplitUsage();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3534:     PrintGeneralUsage();",
          "3535:     PrintExtractUsage();",
          "3536:     PrintDASHUsage();",
          "3537:     PrintDumpUsage();",
          "3538:     PrintImportUsage();",
          "3539:     PrintHintUsage();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3561:     PrintSplitUsage();",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3633:    PrintGeneralUsage();",
          "3634:    PrintExtractUsage();",
          "3635:    PrintDASHUsage();",
          "3636:    PrintDumpUsage();",
          "3637:    PrintImportUsage();",
          "3638:    PrintHintUsage();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3661:    PrintSplitUsage();",
          "",
          "---------------"
        ],
        "src/isomedia/isom_read.c||src/isomedia/isom_read.c": [
          "File: src/isomedia/isom_read.c -> src/isomedia/isom_read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2585:    memcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);",
          "2587:    return GF_OK;",
          "2589:    GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;",
          "2591:    if (!*userData) return GF_OUT_OF_MEM;",
          "",
          "[Removed Lines]",
          "2588:   } else if (ptr->type != GF_ISOM_BOX_TYPE_UUID) {",
          "",
          "[Added Lines]",
          "2588:   } else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2594:    return GF_OK;",
          "2595:   } else {",
          "2597:   }",
          "2598:  }",
          "",
          "[Removed Lines]",
          "2596:    return GF_ISOM_INVALID_FILE;",
          "",
          "[Added Lines]",
          "2596:    char *str = NULL;",
          "2597:    switch (ptr->type) {",
          "2598:    case GF_ISOM_BOX_TYPE_NAME:",
          "2600:     str = ((GF_NameBox *)ptr)->string;",
          "2601:     break;",
          "2602:    case GF_ISOM_BOX_TYPE_KIND:",
          "2603:     str = ((GF_KindBox *)ptr)->value;",
          "2604:     break;",
          "2605:    }",
          "2606:    if (str) {",
          "2607:     u32 len = (u32) strlen(str) + 1;",
          "2609:     if (!*userData) return GF_OUT_OF_MEM;",
          "2610:     memcpy(*userData, str, sizeof(char)*len);",
          "2612:     return GF_OK;",
          "2613:    }",
          "2614:    return GF_NOT_SUPPORTED;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
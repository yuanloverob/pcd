{
  "cve_id": "CVE-2021-3905",
  "cve_desc": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.",
  "repo": "openvswitch/ovs",
  "patch_hash": "803ed12e31b0377c37d7aa8c94b3b92f2081e349",
  "patch_info": {
    "commit_hash": "803ed12e31b0377c37d7aa8c94b3b92f2081e349",
    "repo": "openvswitch/ovs",
    "commit_url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349",
    "files": [
      "lib/ipf.c"
    ],
    "message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>",
    "before_after_code_files": [
      "lib/ipf.c||lib/ipf.c"
    ]
  },
  "patch_diff": {
    "lib/ipf.c||lib/ipf.c": [
      "File: lib/ipf.c -> lib/ipf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "943:             ovs_mutex_lock(&ipf->ipf_lock);",
      "944:             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {",
      "945:                 dp_packet_batch_refill(pb, pkt, pb_idx);",
      "946:             }",
      "947:             ovs_mutex_unlock(&ipf->ipf_lock);",
      "948:         } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "946:             } else {",
      "947:                 dp_packet_delete(pkt);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9efa2ea619e563f7ec70c93e4eefb4b96cdfd7d4",
      "candidate_info": {
        "commit_hash": "9efa2ea619e563f7ec70c93e4eefb4b96cdfd7d4",
        "repo": "openvswitch/ovs",
        "commit_url": "https://github.com/openvswitch/ovs/commit/9efa2ea619e563f7ec70c93e4eefb4b96cdfd7d4",
        "files": [
          "lib/ipf.c"
        ],
        "message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>",
        "before_after_code_files": [
          "lib/ipf.c||lib/ipf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/ipf.c||lib/ipf.c"
          ],
          "candidate": [
            "lib/ipf.c||lib/ipf.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/ipf.c||lib/ipf.c": [
          "File: lib/ipf.c -> lib/ipf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "940:             ovs_mutex_lock(&ipf->ipf_lock);",
          "941:             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {",
          "942:                 dp_packet_batch_refill(pb, pkt, pb_idx);",
          "943:             }",
          "944:             ovs_mutex_unlock(&ipf->ipf_lock);",
          "945:         } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "943:             } else {",
          "944:                 dp_packet_delete(pkt);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39c4269a080d16f9c60f0c504d73f994b08fce3b",
      "candidate_info": {
        "commit_hash": "39c4269a080d16f9c60f0c504d73f994b08fce3b",
        "repo": "openvswitch/ovs",
        "commit_url": "https://github.com/openvswitch/ovs/commit/39c4269a080d16f9c60f0c504d73f994b08fce3b",
        "files": [
          "lib/ipf.c"
        ],
        "message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>",
        "before_after_code_files": [
          "lib/ipf.c||lib/ipf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/ipf.c||lib/ipf.c"
          ],
          "candidate": [
            "lib/ipf.c||lib/ipf.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/ipf.c||lib/ipf.c": [
          "File: lib/ipf.c -> lib/ipf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "937:             ovs_mutex_lock(&ipf->ipf_lock);",
          "938:             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {",
          "939:                 dp_packet_batch_refill(pb, pkt, pb_idx);",
          "940:             }",
          "941:             ovs_mutex_unlock(&ipf->ipf_lock);",
          "942:         } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "940:             } else {",
          "941:                 dp_packet_delete(pkt);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ec44c50cf07b47c1fa603534d34eae19460d829c",
      "candidate_info": {
        "commit_hash": "ec44c50cf07b47c1fa603534d34eae19460d829c",
        "repo": "openvswitch/ovs",
        "commit_url": "https://github.com/openvswitch/ovs/commit/ec44c50cf07b47c1fa603534d34eae19460d829c",
        "files": [
          "lib/ipf.c"
        ],
        "message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>",
        "before_after_code_files": [
          "lib/ipf.c||lib/ipf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/ipf.c||lib/ipf.c"
          ],
          "candidate": [
            "lib/ipf.c||lib/ipf.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/ipf.c||lib/ipf.c": [
          "File: lib/ipf.c -> lib/ipf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "940:             ovs_mutex_lock(&ipf->ipf_lock);",
          "941:             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {",
          "942:                 dp_packet_batch_refill(pb, pkt, pb_idx);",
          "943:             }",
          "944:             ovs_mutex_unlock(&ipf->ipf_lock);",
          "945:         } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "943:             } else {",
          "944:                 dp_packet_delete(pkt);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4873b772f912814889d7cab7acfb65dcdd3fa938",
      "candidate_info": {
        "commit_hash": "4873b772f912814889d7cab7acfb65dcdd3fa938",
        "repo": "openvswitch/ovs",
        "commit_url": "https://github.com/openvswitch/ovs/commit/4873b772f912814889d7cab7acfb65dcdd3fa938",
        "files": [
          "lib/ipf.c"
        ],
        "message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>",
        "before_after_code_files": [
          "lib/ipf.c||lib/ipf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/ipf.c||lib/ipf.c"
          ],
          "candidate": [
            "lib/ipf.c||lib/ipf.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/ipf.c||lib/ipf.c": [
          "File: lib/ipf.c -> lib/ipf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "940:             ovs_mutex_lock(&ipf->ipf_lock);",
          "941:             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {",
          "942:                 dp_packet_batch_refill(pb, pkt, pb_idx);",
          "943:             }",
          "944:             ovs_mutex_unlock(&ipf->ipf_lock);",
          "945:         } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "943:             } else {",
          "944:                 dp_packet_delete(pkt);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0fd17fbb09f046583e8c883aa21e68036cb7580a",
      "candidate_info": {
        "commit_hash": "0fd17fbb09f046583e8c883aa21e68036cb7580a",
        "repo": "openvswitch/ovs",
        "commit_url": "https://github.com/openvswitch/ovs/commit/0fd17fbb09f046583e8c883aa21e68036cb7580a",
        "files": [
          "lib/ipf.c"
        ],
        "message": "ipf: release unhandled packets from the batch\n\nSince 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf\nframework unconditionally allocates a new dp_packet to track\nindividual fragments.  This prevents a use-after-free.  However, an\nadditional issue was present - even when the packet buffer is cloned,\nif the ip fragment handling code keeps it, the original buffer is\nleaked during the refill loop.  Even in the original processing code,\nthe hardcoded dnsteal branches would always leak a packet buffer from\nthe refill loop.\n\nThis can be confirmed with valgrind:\n\n==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390\n==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380)\n==717566==    by 0x537BFD: xmalloc__ (util.c:137)\n==717566==    by 0x537BFD: xmalloc (util.c:172)\n==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153)\n==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163)\n==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262)\n==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511)\n==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727)\n==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699)\n==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957)\n==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370)\n==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768)\n==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245)\n==717566==    by 0x411269: bridge_run (bridge.c:3310)\n==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)\n\nThe fix is to delete the original packet when it isn't able to be\nreinserted into the packet batch.  Subsequent valgrind runs show that\nthe packets are not leaked from the batch any longer.\n\nFixes: 640d4db788ed (\"ipf: Fix a use-after-free error, and remove the 'do_not_steal' flag.\")\nFixes: 4ea96698f667 (\"Userspace datapath: Add fragmentation handling.\")\nReported-by: Wan Junjie <wanjunjie@bytedance.com>\nReported-at: https://github.com/openvswitch/ovs-issues/issues/226\nSigned-off-by: Aaron Conole <aconole@redhat.com>\nReviewed-by: David Marchand <david.marchand@redhat.com>\nTested-by: Wan Junjie <wanjunjie@bytedance.com>\nSigned-off-by: Alin-Gabriel Serdean <aserdean@ovn.org>",
        "before_after_code_files": [
          "lib/ipf.c||lib/ipf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/ipf.c||lib/ipf.c"
          ],
          "candidate": [
            "lib/ipf.c||lib/ipf.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/ipf.c||lib/ipf.c": [
          "File: lib/ipf.c -> lib/ipf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "943:             ovs_mutex_lock(&ipf->ipf_lock);",
          "944:             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {",
          "945:                 dp_packet_batch_refill(pb, pkt, pb_idx);",
          "946:             }",
          "947:             ovs_mutex_unlock(&ipf->ipf_lock);",
          "948:         } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "946:             } else {",
          "947:                 dp_packet_delete(pkt);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
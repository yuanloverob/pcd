{
  "cve_id": "CVE-2015-1793",
  "cve_desc": "The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.",
  "repo": "openssl/openssl",
  "patch_hash": "2aacec8f4a5ba1b365620a7b17fcce311ada93ad",
  "patch_info": {
    "commit_hash": "2aacec8f4a5ba1b365620a7b17fcce311ada93ad",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/2aacec8f4a5ba1b365620a7b17fcce311ada93ad",
    "files": [
      "crypto/x509/x509_vfy.c"
    ],
    "message": "Fix alternate chains certificate forgery issue\n\nDuring certificate verfification, OpenSSL will attempt to find an\nalternative certificate chain if the first attempt to build such a chain\nfails. An error in the implementation of this logic can mean that an\nattacker could cause certain checks on untrusted certificates to be\nbypassed, such as the CA flag, enabling them to use a valid leaf\ncertificate to act as a CA and \"issue\" an invalid certificate.\n\nThis occurs where at least one cert is added to the first chain from the\ntrust store, but that chain still ends up being untrusted. In that case\nctx->last_untrusted is decremented in error.\n\nPatch provided by the BoringSSL project.\n\nCVE-2015-1793\n\nReviewed-by: Stephen Henson <steve@openssl.org>",
    "before_after_code_files": [
      "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
    ]
  },
  "patch_diff": {
    "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c": [
      "File: crypto/x509/x509_vfy.c -> crypto/x509/x509_vfy.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "392:                         xtmp = sk_X509_pop(ctx->chain);",
      "393:                         X509_free(xtmp);",
      "394:                         num--;",
      "396:                     }",
      "397:                     retry = 1;",
      "398:                     break;",
      "399:                 }",
      "",
      "[Removed Lines]",
      "395:                         ctx->last_untrusted--;",
      "",
      "[Added Lines]",
      "396:                     ctx->last_untrusted = sk_X509_num(ctx->chain);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d9b8b89bec4480de3a10bdaf9425db371c19145b",
      "candidate_info": {
        "commit_hash": "d9b8b89bec4480de3a10bdaf9425db371c19145b",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/d9b8b89bec4480de3a10bdaf9425db371c19145b",
        "files": [
          "crypto/x509/x509_err.c",
          "crypto/x509/x509_vfy.c",
          "include/openssl/x509.h",
          "include/openssl/x509_vfy.h"
        ],
        "message": "X509_verify_cert() cleanup\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "crypto/x509/x509_err.c||crypto/x509/x509_err.c",
          "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c",
          "include/openssl/x509.h||include/openssl/x509.h",
          "include/openssl/x509_vfy.h||include/openssl/x509_vfy.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
          ],
          "candidate": [
            "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/x509/x509_err.c||crypto/x509/x509_err.c": [
          "File: crypto/x509/x509_err.c -> crypto/x509/x509_err.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: static ERR_STRING_DATA X509_str_functs[] = {",
          "73:     {ERR_FUNC(X509_F_ADD_CERT_DIR), \"add_cert_dir\"},",
          "74:     {ERR_FUNC(X509_F_BY_FILE_CTRL), \"by_file_ctrl\"},",
          "75:     {ERR_FUNC(X509_F_CHECK_POLICY), \"check_policy\"},",
          "76:     {ERR_FUNC(X509_F_DIR_CTRL), \"dir_ctrl\"},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74:     {ERR_FUNC(X509_F_BUILD_CHAIN), \"build_chain\"},",
          "",
          "---------------"
        ],
        "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c": [
          "File: crypto/x509/x509_vfy.c -> crypto/x509/x509_vfy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: #include <stdio.h>",
          "60: #include <time.h>",
          "61: #include <errno.h>",
          "63: #include \"internal/cryptlib.h\"",
          "64: #include <openssl/crypto.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #include <limits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69: #include <openssl/x509.h>",
          "70: #include <openssl/x509v3.h>",
          "71: #include <openssl/objects.h>",
          "73: #include \"x509_lcl.h\"",
          "",
          "[Removed Lines]",
          "72: #include \"internal/x509_int.h\"",
          "",
          "[Added Lines]",
          "73: #include <internal/x509_int.h>",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111: #define CRL_SCORE_TIME_DELTA    0x002",
          "113: static int null_callback(int ok, X509_STORE_CTX *e);",
          "114: static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);",
          "115: static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x);",
          "116: static int check_chain_extensions(X509_STORE_CTX *ctx);",
          "117: static int check_name_constraints(X509_STORE_CTX *ctx);",
          "118: static int check_id(X509_STORE_CTX *ctx);",
          "120: static int check_revocation(X509_STORE_CTX *ctx);",
          "121: static int check_cert(X509_STORE_CTX *ctx);",
          "122: static int check_policy(X509_STORE_CTX *ctx);",
          "",
          "[Removed Lines]",
          "119: static int check_trust(X509_STORE_CTX *ctx);",
          "",
          "[Added Lines]",
          "114: static int build_chain(X509_STORE_CTX *ctx);",
          "115: static int verify_chain(X509_STORE_CTX *ctx);",
          "122: static int check_trust(X509_STORE_CTX *ctx, int num_untrusted);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "180:     return xtmp;",
          "181: }",
          "183: int X509_verify_cert(X509_STORE_CTX *ctx)",
          "184: {",
          "192:     if (ctx->cert == NULL) {",
          "193:         X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);",
          "194:         return -1;",
          "195:     }",
          "196:     if (ctx->chain != NULL) {",
          "",
          "[Removed Lines]",
          "185:     X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;",
          "186:     int bad_chain = 0;",
          "187:     X509_VERIFY_PARAM *param = ctx->param;",
          "188:     int depth, i, ok = 0;",
          "189:     int num, j, retry;",
          "190:     int (*cb) (int xok, X509_STORE_CTX *xctx);",
          "191:     STACK_OF(X509) *sktmp = NULL;",
          "",
          "[Added Lines]",
          "191: static int verify_chain(X509_STORE_CTX *ctx)",
          "192: {",
          "193:     int (*cb) (int xok, X509_STORE_CTX *xctx) = ctx->verify_cb;",
          "194:     int err;",
          "195:     int ok;",
          "201:     if ((ok = build_chain(ctx)) == 0 ||",
          "202:         (ok = check_chain_extensions(ctx)) == 0 ||",
          "203:         (ok = check_name_constraints(ctx)) == 0 ||",
          "204:         (ok = check_id(ctx)) == 0 || 1)",
          "205:         X509_get_pubkey_parameters(NULL, ctx->chain);",
          "206:     if (ok == 0 || (ok = ctx->check_revocation(ctx)) == 0)",
          "207:         return ok;",
          "209:     err = X509_chain_check_suiteb(&ctx->error_depth, NULL, ctx->chain,",
          "210:                                   ctx->param->flags);",
          "211:     if (err != X509_V_OK) {",
          "212:         ctx->error = err;",
          "213:         ctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);",
          "214:         if ((ok = cb(0, ctx)) == 0)",
          "215:             return ok;",
          "216:     }",
          "219:     ok = (ctx->verify != NULL) ? ctx->verify(ctx) : internal_verify(ctx);",
          "220:     if (!ok)",
          "221:         return ok;",
          "223: #ifndef OPENSSL_NO_RFC3779",
          "225:     if ((ok = v3_asid_validate_path(ctx)) == 0)",
          "226:         return ok;",
          "227:     if ((ok = v3_addr_validate_path(ctx)) == 0)",
          "228:         return ok;",
          "229: #endif",
          "232:     if (ctx->param->flags & X509_V_FLAG_POLICY_CHECK)",
          "233:         ok = ctx->check_policy(ctx);",
          "234:     return ok;",
          "235: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "202:         return -1;",
          "203:     }",
          "",
          "[Removed Lines]",
          "205:     cb = ctx->verify_cb;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "211:     if (((ctx->chain = sk_X509_new_null()) == NULL) ||",
          "212:         (!sk_X509_push(ctx->chain, ctx->cert))) {",
          "213:         X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);",
          "215:     }",
          "216:     X509_up_ref(ctx->cert);",
          "510: }",
          "",
          "[Removed Lines]",
          "214:         goto end;",
          "217:     ctx->last_untrusted = 1;",
          "220:     if (ctx->untrusted != NULL",
          "221:         && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {",
          "222:         X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);",
          "223:         goto end;",
          "224:     }",
          "226:     num = sk_X509_num(ctx->chain);",
          "227:     x = sk_X509_value(ctx->chain, num - 1);",
          "228:     depth = param->depth;",
          "230:     for (;;) {",
          "232:         if (depth < num)",
          "233:             break;              /* FIXME: If this happens, we should take",
          "239:         if (cert_self_signed(x))",
          "240:             break;",
          "244:         if (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {",
          "245:             ok = ctx->get_issuer(&xtmp, ctx, x);",
          "246:             if (ok < 0)",
          "247:                 goto end;",
          "252:             if (ok > 0) {",
          "253:                 X509_free(xtmp);",
          "254:                 break;",
          "255:             }",
          "256:         }",
          "259:         if (ctx->untrusted != NULL) {",
          "260:             xtmp = find_issuer(ctx, sktmp, x);",
          "261:             if (xtmp != NULL) {",
          "262:                 if (!sk_X509_push(ctx->chain, xtmp)) {",
          "263:                     X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);",
          "264:                     goto end;",
          "265:                 }",
          "266:                 X509_up_ref(xtmp);",
          "267:                 (void)sk_X509_delete_ptr(sktmp, xtmp);",
          "268:                 ctx->last_untrusted++;",
          "269:                 x = xtmp;",
          "270:                 num++;",
          "274:                 continue;",
          "275:             }",
          "276:         }",
          "277:         break;",
          "278:     }",
          "281:     j = num;",
          "288:     do {",
          "292:         i = sk_X509_num(ctx->chain);",
          "293:         x = sk_X509_value(ctx->chain, i - 1);",
          "294:         if (cert_self_signed(x)) {",
          "296:             if (sk_X509_num(ctx->chain) == 1) {",
          "302:                 ok = ctx->get_issuer(&xtmp, ctx, x);",
          "303:                 if ((ok <= 0) || X509_cmp(x, xtmp)) {",
          "304:                     ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;",
          "305:                     ctx->current_cert = x;",
          "306:                     ctx->error_depth = i - 1;",
          "307:                     if (ok == 1)",
          "308:                         X509_free(xtmp);",
          "309:                     bad_chain = 1;",
          "310:                     ok = cb(0, ctx);",
          "311:                     if (!ok)",
          "312:                         goto end;",
          "313:                 } else {",
          "318:                     X509_free(x);",
          "319:                     x = xtmp;",
          "320:                     (void)sk_X509_set(ctx->chain, i - 1, x);",
          "321:                     ctx->last_untrusted = 0;",
          "322:                 }",
          "323:             } else {",
          "327:                 chain_ss = sk_X509_pop(ctx->chain);",
          "328:                 ctx->last_untrusted--;",
          "329:                 num--;",
          "330:                 j--;",
          "331:                 x = sk_X509_value(ctx->chain, num - 1);",
          "332:             }",
          "333:         }",
          "335:         for (;;) {",
          "337:             if (depth < num)",
          "338:                 break;",
          "340:             if (cert_self_signed(x))",
          "341:                 break;",
          "342:             ok = ctx->get_issuer(&xtmp, ctx, x);",
          "344:             if (ok < 0)",
          "345:                 goto end;",
          "346:             if (ok == 0)",
          "347:                 break;",
          "348:             x = xtmp;",
          "349:             if (!sk_X509_push(ctx->chain, x)) {",
          "350:                 X509_free(xtmp);",
          "351:                 X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);",
          "352:                 ok = 0;",
          "353:                 goto done;",
          "354:             }",
          "355:             num++;",
          "356:         }",
          "359:         i = check_trust(ctx);",
          "362:         if (i == X509_TRUST_REJECTED)",
          "363:             goto end;",
          "370:         retry = 0;",
          "371:         if (i != X509_TRUST_TRUSTED",
          "372:             && !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)",
          "373:             && !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {",
          "374:             while (j-- > 1) {",
          "375:                 STACK_OF(X509) *chtmp = ctx->chain;",
          "376:                 xtmp2 = sk_X509_value(ctx->chain, j - 1);",
          "382:                 ctx->chain = NULL;",
          "383:                 ok = ctx->get_issuer(&xtmp, ctx, xtmp2);",
          "384:                 ctx->chain = chtmp;",
          "385:                 if (ok < 0)",
          "386:                     goto end;",
          "388:                 if (ok > 0) {",
          "392:                     X509_free(xtmp);",
          "398:                     while (num > j) {",
          "399:                         xtmp = sk_X509_pop(ctx->chain);",
          "400:                         X509_free(xtmp);",
          "401:                         num--;",
          "402:                     }",
          "403:                     ctx->last_untrusted = sk_X509_num(ctx->chain);",
          "404:                     retry = 1;",
          "405:                     break;",
          "406:                 }",
          "407:             }",
          "408:         }",
          "409:     } while (retry);",
          "416:     if (i != X509_TRUST_TRUSTED && !bad_chain) {",
          "417:         if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {",
          "418:             if (ctx->last_untrusted >= num)",
          "419:                 ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;",
          "420:             else",
          "421:                 ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;",
          "422:             ctx->current_cert = x;",
          "423:         } else {",
          "425:             sk_X509_push(ctx->chain, chain_ss);",
          "426:             num++;",
          "427:             ctx->last_untrusted = num;",
          "428:             ctx->current_cert = chain_ss;",
          "429:             ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;",
          "430:             chain_ss = NULL;",
          "431:         }",
          "433:         ctx->error_depth = num - 1;",
          "434:         bad_chain = 1;",
          "435:         ok = cb(0, ctx);",
          "436:         if (!ok)",
          "437:             goto end;",
          "438:     }",
          "441:     ok = check_chain_extensions(ctx);",
          "443:     if (!ok)",
          "444:         goto end;",
          "448:     ok = check_name_constraints(ctx);",
          "450:     if (!ok)",
          "451:         goto end;",
          "453:     ok = check_id(ctx);",
          "455:     if (!ok)",
          "456:         goto end;",
          "459:     X509_get_pubkey_parameters(NULL, ctx->chain);",
          "466:     ok = ctx->check_revocation(ctx);",
          "467:     if (!ok)",
          "468:         goto end;",
          "470:     i = X509_chain_check_suiteb(&ctx->error_depth, NULL, ctx->chain,",
          "471:                                 ctx->param->flags);",
          "472:     if (i != X509_V_OK) {",
          "473:         ctx->error = i;",
          "474:         ctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);",
          "475:         ok = cb(0, ctx);",
          "476:         if (!ok)",
          "477:             goto end;",
          "478:     }",
          "481:     if (ctx->verify != NULL)",
          "482:         ok = ctx->verify(ctx);",
          "483:     else",
          "484:         ok = internal_verify(ctx);",
          "485:     if (!ok)",
          "486:         goto end;",
          "488: #ifndef OPENSSL_NO_RFC3779",
          "490:     ok = v3_asid_validate_path(ctx);",
          "491:     if (!ok)",
          "492:         goto end;",
          "493:     ok = v3_addr_validate_path(ctx);",
          "494:     if (!ok)",
          "495:         goto end;",
          "496: #endif",
          "499:     if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))",
          "500:         ok = ctx->check_policy(ctx);",
          "501:     if (ok)",
          "502:         goto done;",
          "504:  end:",
          "505:     X509_get_pubkey_parameters(NULL, ctx->chain);",
          "506:  done:",
          "507:     sk_X509_free(sktmp);",
          "508:     X509_free(chain_ss);",
          "509:     return ok;",
          "",
          "[Added Lines]",
          "261:         return -1;",
          "264:     ctx->num_untrusted = 1;",
          "266:     return verify_chain(ctx);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "618:     }",
          "622:         int ret;",
          "623:         x = sk_X509_value(ctx->chain, i);",
          "624:         if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)",
          "",
          "[Removed Lines]",
          "621:     for (i = 0; i < ctx->last_untrusted; i++) {",
          "",
          "[Added Lines]",
          "378:     for (i = 0; i == 0 || i < ctx->num_untrusted; i++) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "801:     return 1;",
          "802: }",
          "805: {",
          "807:     X509 *x = NULL;",
          "812:         x = sk_X509_value(ctx->chain, i);",
          "829:     }",
          "834:     if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {",
          "838:         x = sk_X509_value(ctx->chain, 0);",
          "839:         mx = lookup_cert_match(ctx, x);",
          "845:         }",
          "846:     }",
          "",
          "[Removed Lines]",
          "804: static int check_trust(X509_STORE_CTX *ctx)",
          "806:     int i, ok;",
          "808:     int (*cb) (int xok, X509_STORE_CTX *xctx);",
          "809:     cb = ctx->verify_cb;",
          "811:     for (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {",
          "813:         ok = X509_check_trust(x, ctx->param->trust, 0);",
          "815:         if (ok == X509_TRUST_TRUSTED)",
          "816:             return X509_TRUST_TRUSTED;",
          "821:         if (ok == X509_TRUST_REJECTED) {",
          "822:             ctx->error_depth = i;",
          "823:             ctx->current_cert = x;",
          "824:             ctx->error = X509_V_ERR_CERT_REJECTED;",
          "825:             ok = cb(0, ctx);",
          "826:             if (!ok)",
          "827:                 return X509_TRUST_REJECTED;",
          "828:         }",
          "835:         X509 *mx;",
          "836:         if (ctx->last_untrusted < sk_X509_num(ctx->chain))",
          "837:             return X509_TRUST_TRUSTED;",
          "840:         if (mx) {",
          "841:             (void)sk_X509_set(ctx->chain, 0, mx);",
          "842:             X509_free(x);",
          "843:             ctx->last_untrusted = 0;",
          "844:             return X509_TRUST_TRUSTED;",
          "",
          "[Added Lines]",
          "561: static int check_trust(X509_STORE_CTX *ctx, int num_untrusted)",
          "563:     int i, ok = 0;",
          "565:     X509 *mx;",
          "566:     int (*cb) (int xok, X509_STORE_CTX *xctx) = ctx->verify_cb;",
          "567:     int num = sk_X509_num(ctx->chain);",
          "568:     int trust;",
          "576:     for (i = num_untrusted; i < num; i++) {",
          "578:         trust = X509_check_trust(x, ctx->param->trust, 0);",
          "580:         if (trust == X509_TRUST_TRUSTED)",
          "581:             goto trusted;",
          "582:         if (trust == X509_TRUST_REJECTED)",
          "583:             goto rejected;",
          "590:     if (num_untrusted < num) {",
          "591:         if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN)",
          "592:             goto trusted;",
          "593:         return X509_TRUST_UNTRUSTED;",
          "594:     }",
          "603:         if (!mx)",
          "604:             return X509_TRUST_UNTRUSTED;",
          "610:         trust = X509_check_trust(mx, ctx->param->trust, 0);",
          "611:         if (trust == X509_TRUST_REJECTED) {",
          "612:             X509_free(mx);",
          "613:             goto rejected;",
          "617:         (void) sk_X509_set(ctx->chain, 0, mx);",
          "618:         X509_free(x);",
          "619:         ctx->num_untrusted = 0;",
          "620:         goto trusted;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "852:     return X509_TRUST_UNTRUSTED;",
          "853: }",
          "855: static int check_revocation(X509_STORE_CTX *ctx)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "629:  rejected:",
          "630:     ctx->error_depth = i;",
          "631:     ctx->current_cert = x;",
          "632:     ctx->error = X509_V_ERR_CERT_REJECTED;",
          "633:     ok = cb(0, ctx);",
          "634:     if (!ok)",
          "635:         return X509_TRUST_REJECTED;",
          "636:     return X509_TRUST_UNTRUSTED;",
          "638:  trusted:",
          "639:     return X509_TRUST_TRUSTED;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1733:     cb = ctx->verify_cb;",
          "1738:     xi = sk_X509_value(ctx->chain, n);",
          "1740:     if (ctx->check_issued(ctx, xi, xi))",
          "",
          "[Removed Lines]",
          "1735:     n = sk_X509_num(ctx->chain);",
          "1736:     ctx->error_depth = n - 1;",
          "1737:     n--;",
          "",
          "[Added Lines]",
          "1522:     n = sk_X509_num(ctx->chain) - 1;",
          "1523:     ctx->error_depth = n;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2269:     ctx->cert = x509;",
          "2270:     ctx->untrusted = chain;",
          "2271:     ctx->crls = NULL;",
          "2273:     ctx->other_ctx = NULL;",
          "2274:     ctx->valid = 0;",
          "2275:     ctx->chain = NULL;",
          "",
          "[Removed Lines]",
          "2272:     ctx->last_untrusted = 0;",
          "",
          "[Added Lines]",
          "2061:     ctx->num_untrusted = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2380:     }",
          "2381:     return 1;",
          "2384:     X509_STORE_CTX_cleanup(ctx);",
          "2385:     return 0;",
          "2386: }",
          "",
          "[Removed Lines]",
          "2383: err:",
          "",
          "[Added Lines]",
          "2172:  err:",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2448: int X509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx)",
          "2449: {",
          "2451: }",
          "2453: int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)",
          "",
          "[Removed Lines]",
          "2450:     return ctx->last_untrusted;",
          "",
          "[Added Lines]",
          "2239:     return ctx->num_untrusted;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2469:     X509_VERIFY_PARAM_free(ctx->param);",
          "2470:     ctx->param = param;",
          "2471: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2262: static int build_chain(X509_STORE_CTX *ctx)",
          "2263: {",
          "2264:     int (*cb) (int, X509_STORE_CTX *) = ctx->verify_cb;",
          "2265:     int num = sk_X509_num(ctx->chain);",
          "2266:     X509 *cert = sk_X509_value(ctx->chain, num - 1);",
          "2267:     int ss = cert_self_signed(cert);",
          "2268:     STACK_OF(X509) *sktmp = NULL;",
          "2269:     unsigned int search;",
          "2270:     int may_trusted = 1;",
          "2271:     int may_alternate = 0;",
          "2272:     int trust = X509_TRUST_UNTRUSTED;",
          "2273:     int alt_untrusted = 0;",
          "2274:     int depth;",
          "2275:     int ok = 0;",
          "2276:     int i;",
          "2279:     OPENSSL_assert(num == 1 && ctx->num_untrusted == num);",
          "2289:     search = (ctx->untrusted != NULL) ? S_DOUNTRUSTED : 0;",
          "2290:     if (search == 0 || ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)",
          "2291:         search |= S_DOTRUSTED;",
          "2292:     else if (!(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS))",
          "2293:         may_alternate = 1;",
          "2300:     if (ctx->untrusted && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {",
          "2301:         X509err(X509_F_BUILD_CHAIN, ERR_R_MALLOC_FAILURE);",
          "2302:         return 0;",
          "2303:     }",
          "2309:     if (ctx->param->depth > INT_MAX/2)",
          "2310:         ctx->param->depth = INT_MAX/2;",
          "2317:     depth = ctx->param->depth + 1;",
          "2319:     while (search != 0) {",
          "2320:         X509 *x;",
          "2321:         X509 *xtmp = NULL;",
          "2328:         if ((search & S_DOTRUSTED) != 0) {",
          "2329:             STACK_OF(X509) *hide = ctx->chain;",
          "2331:             i = num = sk_X509_num(ctx->chain);",
          "2332:             if ((search & S_DOALTERNATE) != 0) {",
          "2348:                 i = alt_untrusted;",
          "2349:             }",
          "2350:             x = sk_X509_value(ctx->chain, i-1);",
          "2353:             ctx->chain = NULL;",
          "2354:             ok = (depth < num) ? 0 : ctx->get_issuer(&xtmp, ctx, x);",
          "2355:             ctx->chain = hide;",
          "2357:             if (ok < 0) {",
          "2358:                 trust = X509_TRUST_REJECTED;",
          "2359:                 search = 0;",
          "2360:                 continue;",
          "2361:             }",
          "2363:             if (ok > 0) {",
          "2374:                 if ((search & S_DOALTERNATE) != 0) {",
          "2375:                     OPENSSL_assert(num > i && i > 0 && ss == 0);",
          "2376:                     search &= ~S_DOALTERNATE;",
          "2377:                     for (; num > i; --num)",
          "2378:                         X509_free(sk_X509_pop(ctx->chain));",
          "2379:                     ctx->num_untrusted = num;",
          "2380:                 }",
          "2386:                 if (ss == 0) {",
          "2387:                     if (!sk_X509_push(ctx->chain, x = xtmp)) {",
          "2388:                         X509_free(xtmp);",
          "2389:                         X509err(X509_F_BUILD_CHAIN, ERR_R_MALLOC_FAILURE);",
          "2390:                         trust = X509_TRUST_REJECTED;",
          "2391:                         search = 0;",
          "2392:                         continue;",
          "2393:                     }",
          "2394:                     ss = cert_self_signed(x);",
          "2395:                 } else if (num == ctx->num_untrusted) {",
          "2402:                     if (X509_cmp(x, xtmp) != 0) {",
          "2404:                         X509_free(xtmp);",
          "2405:                         ok = 0;",
          "2406:                     } else {",
          "2407:                         X509_free(x);",
          "2408:                         ctx->num_untrusted = --num;",
          "2409:                         (void) sk_X509_set(ctx->chain, num, x = xtmp);",
          "2410:                     }",
          "2411:                 }",
          "2419:                 if (ok) {",
          "2420:                     OPENSSL_assert(ctx->num_untrusted <= num);",
          "2421:                     search &= ~S_DOUNTRUSTED;",
          "2422:                     switch (trust = check_trust(ctx, num)) {",
          "2423:                     case X509_TRUST_TRUSTED:",
          "2424:                     case X509_TRUST_REJECTED:",
          "2425:                         search = 0;",
          "2426:                         continue;",
          "2427:                     }",
          "2428:                     if (ss == 0)",
          "2429:                         continue;",
          "2430:                 }",
          "2431:             }",
          "2439:             if ((search & S_DOUNTRUSTED) == 0) {",
          "2441:                 if ((search & S_DOALTERNATE) != 0 && --alt_untrusted > 0)",
          "2442:                     continue;",
          "2444:                 if (!may_alternate || (search & S_DOALTERNATE) != 0 ||",
          "2445:                     ctx->num_untrusted < 2)",
          "2446:                     break;",
          "2448:                 search |= S_DOALTERNATE;",
          "2449:                 alt_untrusted = ctx->num_untrusted - 1;",
          "2450:                 ss = 0;",
          "2451:             }",
          "2452:         }",
          "2457:         if ((search & S_DOUNTRUSTED) != 0) {",
          "2458:             num = sk_X509_num(ctx->chain);",
          "2459:             OPENSSL_assert(num == ctx->num_untrusted);",
          "2460:             x = sk_X509_value(ctx->chain, num-1);",
          "2461:             xtmp = (depth < num) ? NULL : find_issuer(ctx, sktmp, x);",
          "2467:             if (xtmp == NULL) {",
          "2468:                 search &= ~S_DOUNTRUSTED;",
          "2469:                 if (may_trusted)",
          "2470:                     search |= S_DOTRUSTED;",
          "2471:                 continue;",
          "2472:             }",
          "2474:             if (!sk_X509_push(ctx->chain, x = xtmp)) {",
          "2475:                 X509err(X509_F_BUILD_CHAIN, ERR_R_MALLOC_FAILURE);",
          "2476:                 trust = X509_TRUST_REJECTED;",
          "2477:                 search = 0;",
          "2478:                 continue;",
          "2479:             }",
          "2480:             X509_up_ref(x);",
          "2481:             ++ctx->num_untrusted;",
          "2482:             ss = cert_self_signed(xtmp);",
          "2488:             (void) sk_X509_delete_ptr(sktmp, x);",
          "2489:         }",
          "2490:     }",
          "2491:     sk_X509_free(sktmp);",
          "2496:     if (sk_X509_num(ctx->chain) <= depth) {",
          "2497:         if (trust == X509_TRUST_UNTRUSTED &&",
          "2498:             sk_X509_num(ctx->chain) == ctx->num_untrusted)",
          "2499:             trust = check_trust(ctx, 1);",
          "2500:     }",
          "2502:     switch (trust) {",
          "2503:     case X509_TRUST_TRUSTED:",
          "2504:         return 1;",
          "2505:     case X509_TRUST_REJECTED:",
          "2506:         return 0;",
          "2507:     case X509_TRUST_UNTRUSTED:",
          "2508:     default:",
          "2509:         num = sk_X509_num(ctx->chain);",
          "2510:         ctx->current_cert = sk_X509_value(ctx->chain, num - 1);",
          "2511:         ctx->error_depth = num-1;",
          "2512:         if (num > depth)",
          "2513:             ctx->error = X509_V_ERR_CERT_CHAIN_TOO_LONG;",
          "2514:         else if (ss && sk_X509_num(ctx->chain) == 1)",
          "2515:             ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;",
          "2516:         else if (ss)",
          "2517:             ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;",
          "2518:         else if (ctx->num_untrusted == num)",
          "2519:             ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;",
          "2520:         else",
          "2521:             ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;",
          "2522:         return cb(0, ctx);",
          "2523:     }",
          "2524: }",
          "",
          "---------------"
        ],
        "include/openssl/x509.h||include/openssl/x509.h": [
          "File: include/openssl/x509.h -> include/openssl/x509.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1072: # define X509_F_ADD_CERT_DIR                              100",
          "1073: # define X509_F_BY_FILE_CTRL                              101",
          "1074: # define X509_F_CHECK_POLICY                              145",
          "1075: # define X509_F_DIR_CTRL                                  102",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1073: # define X509_F_BUILD_CHAIN                               106",
          "",
          "---------------"
        ],
        "include/openssl/x509_vfy.h||include/openssl/x509_vfy.h": [
          "File: include/openssl/x509_vfy.h -> include/openssl/x509_vfy.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "242:     int valid;",
          "246:     STACK_OF(X509) *chain;",
          "",
          "[Removed Lines]",
          "244:     int last_untrusted;",
          "",
          "[Added Lines]",
          "244:     int num_untrusted;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "21376d8ae310cf0455ca2b73c8e9f77cafeb28dd",
      "candidate_info": {
        "commit_hash": "21376d8ae310cf0455ca2b73c8e9f77cafeb28dd",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/21376d8ae310cf0455ca2b73c8e9f77cafeb28dd",
        "files": [
          "crypto/x509/x509_vfy.c"
        ],
        "message": "Fix alternate chains certificate forgery issue\n\nDuring certificate verfification, OpenSSL will attempt to find an\nalternative certificate chain if the first attempt to build such a chain\nfails. An error in the implementation of this logic can mean that an\nattacker could cause certain checks on untrusted certificates to be\nbypassed, such as the CA flag, enabling them to use a valid leaf\ncertificate to act as a CA and \"issue\" an invalid certificate.\n\nThis occurs where at least one cert is added to the first chain from the\ntrust store, but that chain still ends up being untrusted. In that case\nctx->last_untrusted is decremented in error.\n\nPatch provided by the BoringSSL project.\n\nCVE-2015-1793\n\nReviewed-by: Stephen Henson <steve@openssl.org>",
        "before_after_code_files": [
          "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
          ],
          "candidate": [
            "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c": [
          "File: crypto/x509/x509_vfy.c -> crypto/x509/x509_vfy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "389:                         xtmp = sk_X509_pop(ctx->chain);",
          "390:                         X509_free(xtmp);",
          "391:                         num--;",
          "393:                     }",
          "394:                     retry = 1;",
          "395:                     break;",
          "396:                 }",
          "",
          "[Removed Lines]",
          "392:                         ctx->last_untrusted--;",
          "",
          "[Added Lines]",
          "393:                     ctx->last_untrusted = sk_X509_num(ctx->chain);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9a0db453ba017ebcaccbee933ee6511a9ae4d1c8",
      "candidate_info": {
        "commit_hash": "9a0db453ba017ebcaccbee933ee6511a9ae4d1c8",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/9a0db453ba017ebcaccbee933ee6511a9ae4d1c8",
        "files": [
          "crypto/x509/x509_vfy.c"
        ],
        "message": "Fix alternate chains certificate forgery issue\n\nDuring certificate verfification, OpenSSL will attempt to find an\nalternative certificate chain if the first attempt to build such a chain\nfails. An error in the implementation of this logic can mean that an\nattacker could cause certain checks on untrusted certificates to be\nbypassed, such as the CA flag, enabling them to use a valid leaf\ncertificate to act as a CA and \"issue\" an invalid certificate.\n\nThis occurs where at least one cert is added to the first chain from the\ntrust store, but that chain still ends up being untrusted. In that case\nctx->last_untrusted is decremented in error.\n\nPatch provided by the BoringSSL project.\n\nCVE-2015-1793\n\nReviewed-by: Stephen Henson <steve@openssl.org>",
        "before_after_code_files": [
          "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
          ],
          "candidate": [
            "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/x509/x509_vfy.c||crypto/x509/x509_vfy.c": [
          "File: crypto/x509/x509_vfy.c -> crypto/x509/x509_vfy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "328:                         xtmp = sk_X509_pop(ctx->chain);",
          "329:                         X509_free(xtmp);",
          "330:                         num--;",
          "332:                     }",
          "333:                     retry = 1;",
          "334:                     break;",
          "335:                 }",
          "",
          "[Removed Lines]",
          "331:                         ctx->last_untrusted--;",
          "",
          "[Added Lines]",
          "332:                     ctx->last_untrusted = sk_X509_num(ctx->chain);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
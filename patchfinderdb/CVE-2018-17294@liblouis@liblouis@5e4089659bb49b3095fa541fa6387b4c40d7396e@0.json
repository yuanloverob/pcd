{
  "cve_id": "CVE-2018-17294",
  "cve_desc": "The matchCurrentInput function inside lou_translateString.c of Liblouis prior to 3.7 does not check the input string's length, allowing attackers to cause a denial of service (application crash via out-of-bounds read) by crafting an input file with certain translation dictionaries.",
  "repo": "liblouis/liblouis",
  "patch_hash": "5e4089659bb49b3095fa541fa6387b4c40d7396e",
  "patch_info": {
    "commit_hash": "5e4089659bb49b3095fa541fa6387b4c40d7396e",
    "repo": "liblouis/liblouis",
    "commit_url": "https://github.com/liblouis/liblouis/commit/5e4089659bb49b3095fa541fa6387b4c40d7396e",
    "files": [
      "liblouis/lou_translateString.c"
    ],
    "message": "Fix a buffer overflow\n\nFixes #635\n\nThanks to HongxuChen for reporting it",
    "before_after_code_files": [
      "liblouis/lou_translateString.c||liblouis/lou_translateString.c"
    ]
  },
  "patch_diff": {
    "liblouis/lou_translateString.c||liblouis/lou_translateString.c": [
      "File: liblouis/lou_translateString.c -> liblouis/lou_translateString.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "354:   const InString *input, int pos, const widechar *passInstructions, int passIC) {",
      "355:  int k;",
      "356:  int kk = pos;",
      "358:   if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])",
      "359:    return 0;",
      "360:  return 1;",
      "",
      "[Removed Lines]",
      "357:  for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)",
      "",
      "[Added Lines]",
      "357:  for (k = passIC + 2;",
      "358:    ((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length));",
      "359:    k++)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "92a80353d2be64e5fcc4e28b2bf47944e12c0135",
      "candidate_info": {
        "commit_hash": "92a80353d2be64e5fcc4e28b2bf47944e12c0135",
        "repo": "liblouis/liblouis",
        "commit_url": "https://github.com/liblouis/liblouis/commit/92a80353d2be64e5fcc4e28b2bf47944e12c0135",
        "files": [
          "liblouis/commonTranslationFunctions.c",
          "liblouis/compileTranslationTable.c",
          "liblouis/internal.h",
          "liblouis/liblouis.h.in",
          "liblouis/logging.c",
          "liblouis/lou_backTranslateString.c",
          "liblouis/lou_translateString.c",
          "liblouis/maketable.c",
          "liblouis/metadata.c",
          "liblouis/pattern.c",
          "liblouis/utils.c",
          "tools/brl_checks.c",
          "tools/brl_checks.h",
          "tools/lou_allround.c",
          "tools/lou_checkhyphens.c",
          "tools/lou_checktable.c",
          "tools/lou_checkyaml.c",
          "tools/lou_compare.c",
          "tools/lou_debug.c",
          "tools/lou_tableinfo.c",
          "tools/lou_trace.c",
          "tools/lou_translate.c"
        ],
        "message": "Apply the new style",
        "before_after_code_files": [
          "liblouis/commonTranslationFunctions.c||liblouis/commonTranslationFunctions.c",
          "liblouis/compileTranslationTable.c||liblouis/compileTranslationTable.c",
          "liblouis/internal.h||liblouis/internal.h",
          "liblouis/liblouis.h.in||liblouis/liblouis.h.in",
          "liblouis/logging.c||liblouis/logging.c",
          "liblouis/lou_backTranslateString.c||liblouis/lou_backTranslateString.c",
          "liblouis/lou_translateString.c||liblouis/lou_translateString.c",
          "liblouis/maketable.c||liblouis/maketable.c",
          "liblouis/metadata.c||liblouis/metadata.c",
          "liblouis/pattern.c||liblouis/pattern.c",
          "liblouis/utils.c||liblouis/utils.c",
          "tools/brl_checks.c||tools/brl_checks.c",
          "tools/brl_checks.h||tools/brl_checks.h",
          "tools/lou_allround.c||tools/lou_allround.c",
          "tools/lou_checkhyphens.c||tools/lou_checkhyphens.c",
          "tools/lou_checktable.c||tools/lou_checktable.c",
          "tools/lou_checkyaml.c||tools/lou_checkyaml.c",
          "tools/lou_compare.c||tools/lou_compare.c",
          "tools/lou_debug.c||tools/lou_debug.c",
          "tools/lou_tableinfo.c||tools/lou_tableinfo.c",
          "tools/lou_trace.c||tools/lou_trace.c",
          "tools/lou_translate.c||tools/lou_translate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "liblouis/lou_translateString.c||liblouis/lou_translateString.c"
          ],
          "candidate": [
            "liblouis/lou_translateString.c||liblouis/lou_translateString.c"
          ]
        }
      },
      "candidate_diff": {
        "liblouis/commonTranslationFunctions.c||liblouis/commonTranslationFunctions.c": [
          "File: liblouis/commonTranslationFunctions.c -> liblouis/commonTranslationFunctions.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: static int passVariables[NUMVAR];",
          "32: void EXPORT_CALL",
          "36: }",
          "38: int EXPORT_CALL",
          "76: }",
          "78: int EXPORT_CALL",
          "103: }",
          "",
          "[Removed Lines]",
          "33: _lou_resetPassVariables(void)",
          "34: {",
          "35:   memset(passVariables, 0, sizeof(passVariables[0]) * NUMVAR);",
          "39: _lou_handlePassVariableTest (const widechar *instructions, int *IC, int *itsTrue)",
          "40: {",
          "41:   switch (instructions[*IC])",
          "42:     {",
          "43:       case pass_eq:",
          "44:  if (passVariables[instructions[*IC + 1]] != instructions[*IC + 2])",
          "47:  return 1;",
          "49:       case pass_lt:",
          "50:  if (passVariables[instructions[*IC + 1]] >= instructions[*IC + 2])",
          "53:  return 1;",
          "55:       case pass_gt:",
          "56:  if (passVariables[instructions[*IC + 1]] <= instructions[*IC + 2])",
          "59:  return 1;",
          "61:       case pass_lteq:",
          "62:  if (passVariables[instructions[*IC + 1]] > instructions[*IC + 2])",
          "65:  return 1;",
          "67:       case pass_gteq:",
          "68:  if (passVariables[instructions[*IC + 1]] < instructions[*IC + 2])",
          "71:  return 1;",
          "73:       default:",
          "74:         return 0;",
          "75:     }",
          "79: _lou_handlePassVariableAction (const widechar *instructions, int *IC)",
          "80: {",
          "81:   switch (instructions[*IC])",
          "82:     {",
          "83:       case pass_eq:",
          "84:  passVariables[instructions[*IC + 1]] = instructions[*IC + 2];",
          "86:  return 1;",
          "88:       case pass_hyphen:",
          "89:  passVariables[instructions[*IC + 1]] -= 1;",
          "90:  if (passVariables[instructions[*IC + 1]] < 0)",
          "91:    passVariables[instructions[*IC + 1]] = 0;",
          "93:  return 1;",
          "95:       case pass_plus:",
          "96:  passVariables[instructions[*IC + 1]] += 1;",
          "98:  return 1;",
          "100:       default:",
          "101:         return 0;",
          "102:     }",
          "",
          "[Added Lines]",
          "33: _lou_resetPassVariables(void) {",
          "34:  memset(passVariables, 0, sizeof(passVariables[0]) * NUMVAR);",
          "38: _lou_handlePassVariableTest(const widechar *instructions, int *IC, int *itsTrue) {",
          "39:  switch (instructions[*IC]) {",
          "40:  case pass_eq:",
          "41:   if (passVariables[instructions[*IC + 1]] != instructions[*IC + 2]) *itsTrue = 0;",
          "43:   return 1;",
          "45:  case pass_lt:",
          "46:   if (passVariables[instructions[*IC + 1]] >= instructions[*IC + 2]) *itsTrue = 0;",
          "48:   return 1;",
          "50:  case pass_gt:",
          "51:   if (passVariables[instructions[*IC + 1]] <= instructions[*IC + 2]) *itsTrue = 0;",
          "53:   return 1;",
          "55:  case pass_lteq:",
          "56:   if (passVariables[instructions[*IC + 1]] > instructions[*IC + 2]) *itsTrue = 0;",
          "58:   return 1;",
          "60:  case pass_gteq:",
          "61:   if (passVariables[instructions[*IC + 1]] < instructions[*IC + 2]) *itsTrue = 0;",
          "63:   return 1;",
          "65:  default:",
          "66:   return 0;",
          "67:  }",
          "71: _lou_handlePassVariableAction(const widechar *instructions, int *IC) {",
          "72:  switch (instructions[*IC]) {",
          "73:  case pass_eq:",
          "74:   passVariables[instructions[*IC + 1]] = instructions[*IC + 2];",
          "76:   return 1;",
          "78:  case pass_hyphen:",
          "79:   passVariables[instructions[*IC + 1]] -= 1;",
          "80:   if (passVariables[instructions[*IC + 1]] < 0)",
          "81:    passVariables[instructions[*IC + 1]] = 0;",
          "83:   return 1;",
          "85:  case pass_plus:",
          "86:   passVariables[instructions[*IC + 1]] += 1;",
          "88:   return 1;",
          "90:  default:",
          "91:   return 0;",
          "92:  }",
          "",
          "---------------"
        ],
        "liblouis/compileTranslationTable.c||liblouis/compileTranslationTable.c": [
          "File: liblouis/compileTranslationTable.c -> liblouis/compileTranslationTable.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: static char *dataPathPtr;",
          "57: char *EXPORT_CALL",
          "67: }",
          "69: char *EXPORT_CALL",
          "73: }",
          "77: static int",
          "85: }",
          "87: typedef struct CharsString {",
          "90: } CharsString;",
          "92: static int errorCount;",
          "",
          "[Removed Lines]",
          "58: lou_setDataPath (const char *path)",
          "59: {",
          "60:   static char dataPath[MAXSTRING];",
          "61:   dataPathPtr = NULL;",
          "62:   if (path == NULL)",
          "63:     return NULL;",
          "64:   strcpy (dataPath, path);",
          "65:   dataPathPtr = dataPath;",
          "66:   return dataPathPtr;",
          "70: lou_getDataPath (void)",
          "71: {",
          "72:   return dataPathPtr;",
          "78: eqasc2uni (const unsigned char *a, const widechar * b, const int len)",
          "79: {",
          "80:   int k;",
          "81:   for (k = 0; k < len; k++)",
          "82:     if ((widechar) a[k] != b[k])",
          "83:       return 0;",
          "84:   return 1;",
          "88:   widechar length;",
          "89:   widechar chars[MAXSTRING];",
          "",
          "[Added Lines]",
          "58: lou_setDataPath(const char *path) {",
          "59:  static char dataPath[MAXSTRING];",
          "60:  dataPathPtr = NULL;",
          "61:  if (path == NULL) return NULL;",
          "62:  strcpy(dataPath, path);",
          "63:  dataPathPtr = dataPath;",
          "64:  return dataPathPtr;",
          "68: lou_getDataPath(void) {",
          "69:  return dataPathPtr;",
          "75: eqasc2uni(const unsigned char *a, const widechar *b, const int len) {",
          "76:  int k;",
          "77:  for (k = 0; k < len; k++)",
          "78:   if ((widechar)a[k] != b[k]) return 0;",
          "79:  return 1;",
          "83:  widechar length;",
          "84:  widechar chars[MAXSTRING];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98: static TranslationTableOffset tableUsed;",
          "100: typedef struct ChainEntry {",
          "105: } ChainEntry;",
          "107: static ChainEntry *tableChain = NULL;",
          "109: static const char *characterClassNames[] = {",
          "120: };",
          "122: typedef struct CharacterClass {",
          "127: } CharacterClass;",
          "129: static CharacterClass *gCharacterClasses;",
          "",
          "[Removed Lines]",
          "101:   struct ChainEntry *next;",
          "102:   TranslationTableHeader *table;",
          "103:   int tableListLength;",
          "104:   char tableList[1];",
          "110:   \"space\",",
          "111:   \"letter\",",
          "112:   \"digit\",",
          "113:   \"punctuation\",",
          "114:   \"uppercase\",",
          "115:   \"lowercase\",",
          "116:   \"math\",",
          "117:   \"sign\",",
          "118:   \"litdigit\",",
          "119:   NULL,",
          "123:   struct CharacterClass *next;",
          "124:   TranslationTableCharacterAttributes attribute;",
          "125:   widechar length;",
          "126:   widechar name[1];",
          "",
          "[Added Lines]",
          "96:  struct ChainEntry *next;",
          "97:  TranslationTableHeader *table;",
          "98:  int tableListLength;",
          "99:  char tableList[1];",
          "105:  \"space\", \"letter\", \"digit\", \"punctuation\", \"uppercase\", \"lowercase\", \"math\", \"sign\",",
          "106:  \"litdigit\", NULL,",
          "110:  struct CharacterClass *next;",
          "111:  TranslationTableCharacterAttributes attribute;",
          "112:  widechar length;",
          "113:  widechar name[1];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131: static TranslationTableCharacterAttributes gCharacterClassAttribute;",
          "133: static const char *opcodeNames[CTO_None] = {",
          "248: };",
          "250: static short gOpcodeLengths[CTO_None] = { 0 };",
          "254: static int",
          "316:  }",
          "321: }",
          "323: int EXPORT_CALL",
          "339:  }",
          "351: }",
          "353: static inline int",
          "357: }",
          "359: static inline int",
          "363: }",
          "365: static int",
          "397: }",
          "399: static void",
          "403: #ifndef __SYMBIAN32__",
          "415: #endif",
          "416: }",
          "418: static void",
          "421: #ifndef __SYMBIAN32__",
          "433: #endif",
          "434: }",
          "436: static int",
          "454:  }",
          "472: }",
          "474: static int",
          "479: }",
          "481: static int",
          "502: }",
          "504: static TranslationTableCharacter *",
          "527: }",
          "531: static TranslationTableCharacter *",
          "573: }",
          "575: static TranslationTableCharacter *",
          "615: }",
          "617: static CharOrDots *",
          "636: }",
          "638: widechar EXPORT_CALL",
          "645: }",
          "647: widechar EXPORT_CALL",
          "654: }",
          "656: static int",
          "683:  }",
          "703:  }",
          "706: }",
          "",
          "[Removed Lines]",
          "134:   \"include\",",
          "135:   \"locale\",",
          "136:   \"undefined\",",
          "137:   \"capsletter\",",
          "138:   \"begcapsword\",",
          "139:   \"endcapsword\",",
          "140:   \"begcaps\",",
          "141:   \"endcaps\",",
          "142:   \"begcapsphrase\",",
          "143:   \"endcapsphrase\",",
          "144:   \"lencapsphrase\",",
          "145:   \"letsign\",",
          "146:   \"noletsignbefore\",",
          "147:   \"noletsign\",",
          "148:   \"noletsignafter\",",
          "149:   \"numsign\",",
          "150:   \"numericmodechars\",",
          "151:   \"numericnocontchars\",",
          "152:   \"seqdelimiter\",",
          "153:   \"seqbeforechars\",",
          "154:   \"seqafterchars\",",
          "155:   \"seqafterpattern\",",
          "156:   \"seqafterexpression\",",
          "157:   \"emphclass\",",
          "158:   \"emphletter\",",
          "159:   \"begemphword\",",
          "160:   \"endemphword\",",
          "161:   \"begemph\",",
          "162:   \"endemph\",",
          "163:   \"begemphphrase\",",
          "164:   \"endemphphrase\",",
          "165:   \"lenemphphrase\",",
          "166:   \"capsmodechars\",",
          "168:   \"begcomp\",",
          "169:   \"compbegemph1\",",
          "170:   \"compendemph1\",",
          "171:   \"compbegemph2\",",
          "172:   \"compendemph2\",",
          "173:   \"compbegemph3\",",
          "174:   \"compendemph3\",",
          "175:   \"compcapsign\",",
          "176:   \"compbegcaps\",",
          "177:   \"compendcaps\",",
          "178:   \"endcomp\",",
          "179:   \"nocontractsign\",",
          "180:   \"multind\",",
          "181:   \"compdots\",",
          "182:   \"comp6\",",
          "183:   \"class\",",
          "184:   \"after\",",
          "185:   \"before\",",
          "186:   \"noback\",",
          "187:   \"nofor\",",
          "188:   \"empmatchbefore\",",
          "189:   \"empmatchafter\",",
          "190:   \"swapcc\",",
          "191:   \"swapcd\",",
          "192:   \"swapdd\",",
          "193:   \"space\",",
          "194:   \"digit\",",
          "195:   \"punctuation\",",
          "196:   \"math\",",
          "197:   \"sign\",",
          "198:   \"letter\",",
          "199:   \"uppercase\",",
          "200:   \"lowercase\",",
          "201:   \"grouping\",",
          "202:   \"uplow\",",
          "203:   \"litdigit\",",
          "204:   \"display\",",
          "205:   \"replace\",",
          "206:   \"context\",",
          "207:   \"correct\",",
          "208:   \"pass2\",",
          "209:   \"pass3\",",
          "210:   \"pass4\",",
          "211:   \"repeated\",",
          "212:   \"repword\",",
          "213:   \"capsnocont\",",
          "214:   \"always\",",
          "215:   \"exactdots\",",
          "216:   \"nocross\",",
          "217:   \"syllable\",",
          "218:   \"nocont\",",
          "219:   \"compbrl\",",
          "220:   \"literal\",",
          "221:   \"largesign\",",
          "222:   \"word\",",
          "223:   \"partword\",",
          "224:   \"joinnum\",",
          "225:   \"joinword\",",
          "226:   \"lowword\",",
          "227:   \"contraction\",",
          "228:   \"sufword\",",
          "229:   \"prfword\",",
          "230:   \"begword\",",
          "231:   \"begmidword\",",
          "232:   \"midword\",",
          "233:   \"midendword\",",
          "234:   \"endword\",",
          "235:   \"prepunc\",",
          "236:   \"postpunc\",",
          "237:   \"begnum\",",
          "238:   \"midnum\",",
          "239:   \"endnum\",",
          "240:   \"decpoint\",",
          "241:   \"hyphen\",",
          "244:   \"nobreak\",",
          "245:   \"match\",",
          "246:   \"backmatch\",",
          "247:   \"attribute\",",
          "252: static void compileError (FileInfo * nested, char *format, ...);",
          "255: getAChar (FileInfo * nested)",
          "256: {",
          "259:   int ch1 = 0, ch2 = 0;",
          "260:   widechar character;",
          "261:   if (nested->encoding == ascii8)",
          "262:     if (nested->status == 2)",
          "263:       {",
          "264:  nested->status++;",
          "265:  return nested->checkencoding[1];",
          "266:       }",
          "267:   while ((ch1 = fgetc (nested->in)) != EOF)",
          "268:     {",
          "269:       if (nested->status < 2)",
          "270:  nested->checkencoding[nested->status] = ch1;",
          "271:       nested->status++;",
          "272:       if (nested->status == 2)",
          "273:  {",
          "274:    if (nested->checkencoding[0] == 0xfe",
          "275:        && nested->checkencoding[1] == 0xff)",
          "276:      nested->encoding = bigEndian;",
          "277:    else if (nested->checkencoding[0] == 0xff",
          "278:      && nested->checkencoding[1] == 0xfe)",
          "279:      nested->encoding = littleEndian;",
          "280:    else if (nested->checkencoding[0] < 128",
          "281:      && nested->checkencoding[1] < 128)",
          "282:      {",
          "283:        nested->encoding = ascii8;",
          "284:        return nested->checkencoding[0];",
          "285:      }",
          "286:    else",
          "287:      {",
          "288:        compileError (nested,",
          "289:        \"encoding is neither big-endian, little-endian nor ASCII 8.\");",
          "290:        ch1 = EOF;",
          "291:        break;;",
          "292:      }",
          "293:    continue;",
          "294:  }",
          "295:       switch (nested->encoding)",
          "296:  {",
          "297:  case noEncoding:",
          "298:    break;",
          "299:  case ascii8:",
          "300:    return ch1;",
          "301:    break;",
          "302:  case bigEndian:",
          "303:    ch2 = fgetc (nested->in);",
          "304:    if (ch2 == EOF)",
          "305:      break;",
          "306:    character = (widechar) (ch1 << 8) | ch2;",
          "307:    return (int) character;",
          "308:    break;",
          "309:  case littleEndian:",
          "310:    ch2 = fgetc (nested->in);",
          "311:    if (ch2 == EOF)",
          "312:      break;",
          "313:    character = (widechar) (ch2 << 8) | ch1;",
          "314:    return (int) character;",
          "315:    break;",
          "317:       if (ch1 == EOF || ch2 == EOF)",
          "318:  break;",
          "319:     }",
          "320:   return EOF;",
          "324: _lou_getALine (FileInfo * nested)",
          "325: {",
          "327:   int ch;",
          "328:   int pch = 0;",
          "329:   nested->linelen = 0;",
          "330:   while ((ch = getAChar (nested)) != EOF)",
          "331:     {",
          "332:       if (ch == 13)",
          "333:  continue;",
          "334:       if (pch == '\\\\' && ch == 10)",
          "335:  {",
          "336:    nested->linelen--;",
          "337:    pch = ch;",
          "338:    continue;",
          "340:       if (ch == 10 || nested->linelen >= MAXSTRING-1)",
          "341:  break;",
          "342:       nested->line[nested->linelen++] = (widechar) ch;",
          "343:       pch = ch;",
          "344:     }",
          "345:   nested->line[nested->linelen] = 0;",
          "346:   nested->linepos = 0;",
          "347:   if (ch == EOF)",
          "348:     return 0;",
          "349:   nested->lineNumber++;",
          "350:   return 1;",
          "354: atEndOfLine (FileInfo *nested)",
          "355: {",
          "356:   return nested->linepos >= nested->linelen;",
          "360: atTokenDelimiter (FileInfo *nested)",
          "361: {",
          "362:   return nested->line[nested->linepos] <= 32;",
          "366: getToken (FileInfo * nested,",
          "367:    CharsString * result, const char *description,",
          "368:    int *lastToken)",
          "369: {",
          "372:   while (!atEndOfLine(nested) && atTokenDelimiter(nested))",
          "373:     nested->linepos++;",
          "374:   result->length = 0;",
          "375:   while (!atEndOfLine(nested) && !atTokenDelimiter(nested))",
          "376:     {",
          "377:     int maxlen = MAXSTRING;",
          "378:     if (result->length >= maxlen)",
          "379:     {",
          "380:     compileError (nested, \"more than %d characters (bytes)\", maxlen);",
          "381:     return 0;",
          "382:     }",
          "383:     else",
          "384:     result->chars[result->length++] = nested->line[nested->linepos++];",
          "385:     }",
          "386:   if (!result->length)",
          "387:     {",
          "389:       if (description)",
          "390:  compileError (nested, \"%s not specified.\", description);",
          "391:       return 0;",
          "392:     }",
          "393:   result->chars[result->length] = 0;",
          "394:   while (!atEndOfLine(nested) && atTokenDelimiter(nested))",
          "395:     nested->linepos++;",
          "396:   return (*lastToken = atEndOfLine(nested))? 2: 1;",
          "400: compileError (FileInfo * nested,",
          "401:        char *format, ...)",
          "402: {",
          "404:   char buffer[MAXSTRING];",
          "405:   va_list arguments;",
          "406:   va_start (arguments, format);",
          "407:   vsnprintf (buffer, sizeof (buffer), format, arguments);",
          "408:   va_end (arguments);",
          "409:   if (nested)",
          "410:     _lou_logMessage (LOG_ERROR, \"%s:%d: error: %s\", nested->fileName,",
          "411:     nested->lineNumber, buffer);",
          "412:   else",
          "413:     _lou_logMessage (LOG_ERROR, \"error: %s\", buffer);",
          "414:   errorCount++;",
          "419: compileWarning (FileInfo * nested, char *format, ...)",
          "420: {",
          "422:   char buffer[MAXSTRING];",
          "423:   va_list arguments;",
          "424:   va_start (arguments, format);",
          "425:   vsnprintf (buffer, sizeof (buffer), format, arguments);",
          "426:   va_end (arguments);",
          "427:   if (nested)",
          "428:     _lou_logMessage (LOG_WARN, \"%s:%d: warning: %s\", nested->fileName,",
          "429:     nested->lineNumber, buffer);",
          "430:   else",
          "431:     _lou_logMessage (LOG_WARN, \"warning: %s\", buffer);",
          "432:   warningCount++;",
          "437: allocateSpaceInTable (FileInfo * nested, TranslationTableOffset * offset,",
          "438:         int count,",
          "439:         TranslationTableHeader **table)",
          "440: {",
          "443:   int spaceNeeded = ((count + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;",
          "444:   TranslationTableOffset size = tableUsed + spaceNeeded;",
          "445:   if (size > tableSize)",
          "446:     {",
          "447:       TranslationTableHeader *newTable;",
          "448:       size += (size / OFFSETSIZE);",
          "449:       newTable = realloc (*table, size);",
          "450:       if (!newTable)",
          "451:  {",
          "452:    compileError (nested, \"Not enough memory for translation table.\");",
          "453:    _lou_outOfMemory ();",
          "455:       memset (((unsigned char *) newTable) + tableSize, 0, size - tableSize);",
          "457:       {",
          "458:  ChainEntry *entry;",
          "459:  for (entry = tableChain; entry != NULL; entry = entry->next)",
          "460:    if (entry->table == *table)",
          "461:      entry->table = (TranslationTableHeader *) newTable;",
          "462:       }",
          "464:       tableSize = size;",
          "465:     }",
          "466:   if (offset != NULL)",
          "467:     {",
          "469:       tableUsed += spaceNeeded;",
          "470:     }",
          "471:   return 1;",
          "475: reserveSpaceInTable (FileInfo * nested, int count,",
          "476:        TranslationTableHeader **table)",
          "477: {",
          "478:   return (allocateSpaceInTable (nested, NULL, count, table));",
          "482: allocateHeader (FileInfo * nested,",
          "483:   TranslationTableHeader **table)",
          "484: {",
          "487:   const TranslationTableOffset startSize = 2 * sizeof (**table);",
          "488:   if (*table)",
          "489:     return 1;",
          "491:   if (!(*table = malloc (startSize)))",
          "492:     {",
          "493:       compileError (nested, \"Not enough memory\");",
          "494:       if (*table != NULL)",
          "495:  free (*table);",
          "497:       _lou_outOfMemory ();",
          "498:     }",
          "499:   memset (*table, 0, startSize);",
          "500:   tableSize = startSize;",
          "501:   return 1;",
          "505: compile_findCharOrDots (widechar c, int m,",
          "506:    TranslationTableHeader *table)",
          "507: {",
          "512:   TranslationTableCharacter *character;",
          "513:   TranslationTableOffset bucket;",
          "514:   unsigned long int makeHash = (unsigned long int) c % HASHNUM;",
          "515:   if (m == 0)",
          "516:     bucket = table->characters[makeHash];",
          "517:   else",
          "518:     bucket = table->dots[makeHash];",
          "519:   while (bucket)",
          "520:     {",
          "521:       character = (TranslationTableCharacter *) & table->ruleArea[bucket];",
          "522:       if (character->realchar == c)",
          "523:  return character;",
          "524:       bucket = character->next;",
          "525:     }",
          "526:   return NULL;",
          "529: static char *unknownDots (widechar dots);",
          "532: definedCharOrDots (FileInfo * nested,",
          "533:      widechar c, int m,",
          "534:      TranslationTableHeader *table)",
          "535: {",
          "536:   static TranslationTableCharacter noChar = {",
          "537:     .next = 0,",
          "538:     .definitionRule = 0,",
          "539:     .otherRules = 0,",
          "540:     .attributes = CTC_Space,",
          "541:     .realchar = 32,",
          "542:     .uppercase = 32,",
          "543:     .lowercase = 32,",
          "544:   };",
          "545:   static TranslationTableCharacter noDots = {",
          "546:     .next = 0,",
          "547:     .definitionRule = 0,",
          "548:     .otherRules = 0,",
          "549:     .attributes = CTC_Space,",
          "550:     .realchar = B16,",
          "551:     .uppercase = B16,",
          "552:     .lowercase = B16,",
          "553:   };",
          "554:   TranslationTableCharacter *notFound;",
          "555:   TranslationTableCharacter *charOrDots = compile_findCharOrDots (c, m, table);",
          "556:   if (charOrDots)",
          "557:     return charOrDots;",
          "558:   if (m == 0)",
          "559:     {",
          "560:       notFound = &noChar;",
          "561:       compileError (nested,",
          "562:       \"character %s should be defined at this point but is not\",",
          "563:       _lou_showString (&c, 1));",
          "564:     }",
          "565:   else",
          "566:     {",
          "567:       notFound = &noDots;",
          "568:       compileError (nested,",
          "569:       \"cell %s should be defined at this point but is not\",",
          "570:       unknownDots (c));",
          "571:     }",
          "572:   return notFound;",
          "576: addCharOrDots (FileInfo * nested, widechar c, int m,",
          "577:         TranslationTableHeader **table)",
          "578: {",
          "582:   TranslationTableOffset bucket;",
          "583:   TranslationTableCharacter *character;",
          "584:   TranslationTableCharacter *oldchar;",
          "585:   TranslationTableOffset offset;",
          "586:   unsigned long int makeHash;",
          "587:   if ((character = compile_findCharOrDots (c, m, *table)))",
          "588:     return character;",
          "589:   if (!allocateSpaceInTable (nested, &offset, sizeof (*character), table))",
          "590:     return NULL;",
          "591:   character = (TranslationTableCharacter *) & (*table)->ruleArea[offset];",
          "592:   memset (character, 0, sizeof (*character));",
          "593:   character->realchar = c;",
          "594:   makeHash = (unsigned long int) c % HASHNUM;",
          "595:   if (m == 0)",
          "596:     bucket = (*table)->characters[makeHash];",
          "597:   else",
          "598:     bucket = (*table)->dots[makeHash];",
          "599:   if (!bucket)",
          "600:     {",
          "601:       if (m == 0)",
          "602:  (*table)->characters[makeHash] = offset;",
          "603:       else",
          "604:  (*table)->dots[makeHash] = offset;",
          "605:     }",
          "606:   else",
          "607:     {",
          "608:       oldchar = (TranslationTableCharacter *) & (*table)->ruleArea[bucket];",
          "609:       while (oldchar->next)",
          "610:  oldchar =",
          "611:    (TranslationTableCharacter *) & (*table)->ruleArea[oldchar->next];",
          "612:       oldchar->next = offset;",
          "613:     }",
          "614:   return character;",
          "618: getCharOrDots (widechar c, int m,",
          "619:         TranslationTableHeader *table)",
          "620: {",
          "621:   CharOrDots *cdPtr;",
          "622:   TranslationTableOffset bucket;",
          "623:   unsigned long int makeHash = (unsigned long int) c % HASHNUM;",
          "624:   if (m == 0)",
          "625:     bucket = table->charToDots[makeHash];",
          "626:   else",
          "627:     bucket = table->dotsToChar[makeHash];",
          "628:   while (bucket)",
          "629:     {",
          "630:       cdPtr = (CharOrDots *) & table->ruleArea[bucket];",
          "631:       if (cdPtr->lookFor == c)",
          "632:  return cdPtr;",
          "633:       bucket = cdPtr->next;",
          "634:     }",
          "635:   return NULL;",
          "639: _lou_getDotsForChar (widechar c)",
          "640: {",
          "641:   CharOrDots *cdPtr = getCharOrDots (c, 0, gTable);",
          "642:   if (cdPtr)",
          "643:     return cdPtr->found;",
          "644:   return B16;",
          "648: _lou_getCharFromDots (widechar d)",
          "649: {",
          "650:   CharOrDots *cdPtr = getCharOrDots (d, 1, gTable);",
          "651:   if (cdPtr)",
          "652:     return cdPtr->found;",
          "653:   return ' ';",
          "657: putCharAndDots (FileInfo * nested, widechar c, widechar d,",
          "658:   TranslationTableHeader **table)",
          "659: {",
          "660:   TranslationTableOffset bucket;",
          "661:   CharOrDots *cdPtr;",
          "662:   CharOrDots *oldcdPtr = NULL;",
          "663:   TranslationTableOffset offset;",
          "664:   unsigned long int makeHash;",
          "665:   if (!(cdPtr = getCharOrDots (c, 0, *table)))",
          "666:     {",
          "667:       if (!allocateSpaceInTable (nested, &offset, sizeof (*cdPtr), table))",
          "668:  return 0;",
          "669:       cdPtr = (CharOrDots *) & (*table)->ruleArea[offset];",
          "670:       cdPtr->next = 0;",
          "671:       cdPtr->lookFor = c;",
          "672:       cdPtr->found = d;",
          "673:       makeHash = (unsigned long int) c % HASHNUM;",
          "674:       bucket = (*table)->charToDots[makeHash];",
          "675:       if (!bucket)",
          "676:  (*table)->charToDots[makeHash] = offset;",
          "677:       else",
          "678:  {",
          "679:    oldcdPtr = (CharOrDots *) & (*table)->ruleArea[bucket];",
          "680:    while (oldcdPtr->next)",
          "681:      oldcdPtr = (CharOrDots *) & (*table)->ruleArea[oldcdPtr->next];",
          "682:    oldcdPtr->next = offset;",
          "684:     }",
          "685:   if (!(cdPtr = getCharOrDots (d, 1, *table)))",
          "686:     {",
          "687:       if (!allocateSpaceInTable (nested, &offset, sizeof (*cdPtr), table))",
          "688:  return 0;",
          "689:       cdPtr = (CharOrDots *) & (*table)->ruleArea[offset];",
          "690:       cdPtr->next = 0;",
          "691:       cdPtr->lookFor = d;",
          "692:       cdPtr->found = c;",
          "693:       makeHash = (unsigned long int) d % HASHNUM;",
          "694:       bucket = (*table)->dotsToChar[makeHash];",
          "695:       if (!bucket)",
          "696:  (*table)->dotsToChar[makeHash] = offset;",
          "697:       else",
          "698:  {",
          "699:    oldcdPtr = (CharOrDots *) & (*table)->ruleArea[bucket];",
          "700:    while (oldcdPtr->next)",
          "701:      oldcdPtr = (CharOrDots *) & (*table)->ruleArea[oldcdPtr->next];",
          "702:    oldcdPtr->next = offset;",
          "704:     }",
          "705:   return 1;",
          "",
          "[Added Lines]",
          "121:  \"include\", \"locale\", \"undefined\", \"capsletter\", \"begcapsword\", \"endcapsword\",",
          "122:  \"begcaps\", \"endcaps\", \"begcapsphrase\", \"endcapsphrase\", \"lencapsphrase\", \"letsign\",",
          "123:  \"noletsignbefore\", \"noletsign\", \"noletsignafter\", \"numsign\", \"numericmodechars\",",
          "124:  \"numericnocontchars\", \"seqdelimiter\", \"seqbeforechars\", \"seqafterchars\",",
          "125:  \"seqafterpattern\", \"seqafterexpression\", \"emphclass\", \"emphletter\", \"begemphword\",",
          "126:  \"endemphword\", \"begemph\", \"endemph\", \"begemphphrase\", \"endemphphrase\",",
          "127:  \"lenemphphrase\", \"capsmodechars\",",
          "129:  \"begcomp\", \"compbegemph1\", \"compendemph1\", \"compbegemph2\", \"compendemph2\",",
          "130:  \"compbegemph3\", \"compendemph3\", \"compcapsign\", \"compbegcaps\", \"compendcaps\",",
          "131:  \"endcomp\", \"nocontractsign\", \"multind\", \"compdots\", \"comp6\", \"class\", \"after\",",
          "132:  \"before\", \"noback\", \"nofor\", \"empmatchbefore\", \"empmatchafter\", \"swapcc\", \"swapcd\",",
          "133:  \"swapdd\", \"space\", \"digit\", \"punctuation\", \"math\", \"sign\", \"letter\", \"uppercase\",",
          "134:  \"lowercase\", \"grouping\", \"uplow\", \"litdigit\", \"display\", \"replace\", \"context\",",
          "135:  \"correct\", \"pass2\", \"pass3\", \"pass4\", \"repeated\", \"repword\", \"capsnocont\", \"always\",",
          "136:  \"exactdots\", \"nocross\", \"syllable\", \"nocont\", \"compbrl\", \"literal\", \"largesign\",",
          "137:  \"word\", \"partword\", \"joinnum\", \"joinword\", \"lowword\", \"contraction\", \"sufword\",",
          "138:  \"prfword\", \"begword\", \"begmidword\", \"midword\", \"midendword\", \"endword\", \"prepunc\",",
          "139:  \"postpunc\", \"begnum\", \"midnum\", \"endnum\", \"decpoint\", \"hyphen\",",
          "142:  \"nobreak\", \"match\", \"backmatch\", \"attribute\",",
          "147: static void",
          "148: compileError(FileInfo *nested, char *format, ...);",
          "151: getAChar(FileInfo *nested) {",
          "154:  int ch1 = 0, ch2 = 0;",
          "155:  widechar character;",
          "156:  if (nested->encoding == ascii8)",
          "157:   if (nested->status == 2) {",
          "158:    nested->status++;",
          "159:    return nested->checkencoding[1];",
          "160:   }",
          "161:  while ((ch1 = fgetc(nested->in)) != EOF) {",
          "162:   if (nested->status < 2) nested->checkencoding[nested->status] = ch1;",
          "163:   nested->status++;",
          "164:   if (nested->status == 2) {",
          "165:    if (nested->checkencoding[0] == 0xfe && nested->checkencoding[1] == 0xff)",
          "166:     nested->encoding = bigEndian;",
          "167:    else if (nested->checkencoding[0] == 0xff && nested->checkencoding[1] == 0xfe)",
          "168:     nested->encoding = littleEndian;",
          "169:    else if (nested->checkencoding[0] < 128 && nested->checkencoding[1] < 128) {",
          "170:     nested->encoding = ascii8;",
          "171:     return nested->checkencoding[0];",
          "172:    } else {",
          "173:     compileError(nested,",
          "174:       \"encoding is neither big-endian, little-endian nor ASCII 8.\");",
          "175:     ch1 = EOF;",
          "176:     break;",
          "177:     ;",
          "178:    }",
          "179:    continue;",
          "180:   }",
          "181:   switch (nested->encoding) {",
          "182:   case noEncoding:",
          "183:    break;",
          "184:   case ascii8:",
          "185:    return ch1;",
          "186:    break;",
          "187:   case bigEndian:",
          "188:    ch2 = fgetc(nested->in);",
          "189:    if (ch2 == EOF) break;",
          "190:    character = (widechar)(ch1 << 8) | ch2;",
          "191:    return (int)character;",
          "192:    break;",
          "193:   case littleEndian:",
          "194:    ch2 = fgetc(nested->in);",
          "195:    if (ch2 == EOF) break;",
          "196:    character = (widechar)(ch2 << 8) | ch1;",
          "197:    return (int)character;",
          "198:    break;",
          "199:   }",
          "200:   if (ch1 == EOF || ch2 == EOF) break;",
          "202:  return EOF;",
          "206: _lou_getALine(FileInfo *nested) {",
          "208:  int ch;",
          "209:  int pch = 0;",
          "210:  nested->linelen = 0;",
          "211:  while ((ch = getAChar(nested)) != EOF) {",
          "212:   if (ch == 13) continue;",
          "213:   if (pch == '\\\\' && ch == 10) {",
          "214:    nested->linelen--;",
          "215:    pch = ch;",
          "216:    continue;",
          "217:   }",
          "218:   if (ch == 10 || nested->linelen >= MAXSTRING - 1) break;",
          "219:   nested->line[nested->linelen++] = (widechar)ch;",
          "220:   pch = ch;",
          "222:  nested->line[nested->linelen] = 0;",
          "223:  nested->linepos = 0;",
          "224:  if (ch == EOF) return 0;",
          "225:  nested->lineNumber++;",
          "226:  return 1;",
          "230: atEndOfLine(FileInfo *nested) {",
          "231:  return nested->linepos >= nested->linelen;",
          "235: atTokenDelimiter(FileInfo *nested) {",
          "236:  return nested->line[nested->linepos] <= 32;",
          "240: getToken(FileInfo *nested, CharsString *result, const char *description, int *lastToken) {",
          "243:  while (!atEndOfLine(nested) && atTokenDelimiter(nested)) nested->linepos++;",
          "244:  result->length = 0;",
          "245:  while (!atEndOfLine(nested) && !atTokenDelimiter(nested)) {",
          "246:   int maxlen = MAXSTRING;",
          "247:   if (result->length >= maxlen) {",
          "248:    compileError(nested, \"more than %d characters (bytes)\", maxlen);",
          "249:    return 0;",
          "250:   } else",
          "251:    result->chars[result->length++] = nested->line[nested->linepos++];",
          "252:  }",
          "253:  if (!result->length) {",
          "255:   if (description) compileError(nested, \"%s not specified.\", description);",
          "256:   return 0;",
          "257:  }",
          "258:  result->chars[result->length] = 0;",
          "259:  while (!atEndOfLine(nested) && atTokenDelimiter(nested)) nested->linepos++;",
          "260:  return (*lastToken = atEndOfLine(nested)) ? 2 : 1;",
          "264: compileError(FileInfo *nested, char *format, ...) {",
          "266:  char buffer[MAXSTRING];",
          "267:  va_list arguments;",
          "268:  va_start(arguments, format);",
          "269:  vsnprintf(buffer, sizeof(buffer), format, arguments);",
          "270:  va_end(arguments);",
          "271:  if (nested)",
          "272:   _lou_logMessage(LOG_ERROR, \"%s:%d: error: %s\", nested->fileName,",
          "273:     nested->lineNumber, buffer);",
          "274:  else",
          "275:   _lou_logMessage(LOG_ERROR, \"error: %s\", buffer);",
          "276:  errorCount++;",
          "281: compileWarning(FileInfo *nested, char *format, ...) {",
          "283:  char buffer[MAXSTRING];",
          "284:  va_list arguments;",
          "285:  va_start(arguments, format);",
          "286:  vsnprintf(buffer, sizeof(buffer), format, arguments);",
          "287:  va_end(arguments);",
          "288:  if (nested)",
          "289:   _lou_logMessage(LOG_WARN, \"%s:%d: warning: %s\", nested->fileName,",
          "290:     nested->lineNumber, buffer);",
          "291:  else",
          "292:   _lou_logMessage(LOG_WARN, \"warning: %s\", buffer);",
          "293:  warningCount++;",
          "298: allocateSpaceInTable(FileInfo *nested, TranslationTableOffset *offset, int count,",
          "299:   TranslationTableHeader **table) {",
          "302:  int spaceNeeded = ((count + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;",
          "303:  TranslationTableOffset size = tableUsed + spaceNeeded;",
          "304:  if (size > tableSize) {",
          "305:   TranslationTableHeader *newTable;",
          "306:   size += (size / OFFSETSIZE);",
          "307:   newTable = realloc(*table, size);",
          "308:   if (!newTable) {",
          "309:    compileError(nested, \"Not enough memory for translation table.\");",
          "310:    _lou_outOfMemory();",
          "311:   }",
          "312:   memset(((unsigned char *)newTable) + tableSize, 0, size - tableSize);",
          "314:   {",
          "315:    ChainEntry *entry;",
          "316:    for (entry = tableChain; entry != NULL; entry = entry->next)",
          "317:     if (entry->table == *table)",
          "318:      entry->table = (TranslationTableHeader *)newTable;",
          "319:   }",
          "321:   tableSize = size;",
          "323:  if (offset != NULL) {",
          "325:   tableUsed += spaceNeeded;",
          "326:  }",
          "327:  return 1;",
          "331: reserveSpaceInTable(FileInfo *nested, int count, TranslationTableHeader **table) {",
          "332:  return (allocateSpaceInTable(nested, NULL, count, table));",
          "336: allocateHeader(FileInfo *nested, TranslationTableHeader **table) {",
          "339:  const TranslationTableOffset startSize = 2 * sizeof(**table);",
          "340:  if (*table) return 1;",
          "342:  if (!(*table = malloc(startSize))) {",
          "343:   compileError(nested, \"Not enough memory\");",
          "344:   if (*table != NULL) free(*table);",
          "346:   _lou_outOfMemory();",
          "347:  }",
          "348:  memset(*table, 0, startSize);",
          "349:  tableSize = startSize;",
          "350:  return 1;",
          "354: compile_findCharOrDots(widechar c, int m, TranslationTableHeader *table) {",
          "359:  TranslationTableCharacter *character;",
          "360:  TranslationTableOffset bucket;",
          "361:  unsigned long int makeHash = (unsigned long int)c % HASHNUM;",
          "362:  if (m == 0)",
          "363:   bucket = table->characters[makeHash];",
          "364:  else",
          "365:   bucket = table->dots[makeHash];",
          "366:  while (bucket) {",
          "367:   character = (TranslationTableCharacter *)&table->ruleArea[bucket];",
          "368:   if (character->realchar == c) return character;",
          "369:   bucket = character->next;",
          "370:  }",
          "371:  return NULL;",
          "374: static char *",
          "375: unknownDots(widechar dots);",
          "378: definedCharOrDots(FileInfo *nested, widechar c, int m, TranslationTableHeader *table) {",
          "379:  static TranslationTableCharacter noChar = {",
          "380:   .next = 0,",
          "381:   .definitionRule = 0,",
          "382:   .otherRules = 0,",
          "383:   .attributes = CTC_Space,",
          "384:   .realchar = 32,",
          "385:   .uppercase = 32,",
          "386:   .lowercase = 32,",
          "387:  };",
          "388:  static TranslationTableCharacter noDots = {",
          "389:   .next = 0,",
          "390:   .definitionRule = 0,",
          "391:   .otherRules = 0,",
          "392:   .attributes = CTC_Space,",
          "393:   .realchar = B16,",
          "394:   .uppercase = B16,",
          "395:   .lowercase = B16,",
          "396:  };",
          "397:  TranslationTableCharacter *notFound;",
          "398:  TranslationTableCharacter *charOrDots = compile_findCharOrDots(c, m, table);",
          "399:  if (charOrDots) return charOrDots;",
          "400:  if (m == 0) {",
          "401:   notFound = &noChar;",
          "402:   compileError(nested, \"character %s should be defined at this point but is not\",",
          "403:     _lou_showString(&c, 1));",
          "404:  } else {",
          "405:   notFound = &noDots;",
          "406:   compileError(nested, \"cell %s should be defined at this point but is not\",",
          "407:     unknownDots(c));",
          "408:  }",
          "409:  return notFound;",
          "413: addCharOrDots(FileInfo *nested, widechar c, int m, TranslationTableHeader **table) {",
          "417:  TranslationTableOffset bucket;",
          "418:  TranslationTableCharacter *character;",
          "419:  TranslationTableCharacter *oldchar;",
          "420:  TranslationTableOffset offset;",
          "421:  unsigned long int makeHash;",
          "422:  if ((character = compile_findCharOrDots(c, m, *table))) return character;",
          "423:  if (!allocateSpaceInTable(nested, &offset, sizeof(*character), table)) return NULL;",
          "424:  character = (TranslationTableCharacter *)&(*table)->ruleArea[offset];",
          "425:  memset(character, 0, sizeof(*character));",
          "426:  character->realchar = c;",
          "427:  makeHash = (unsigned long int)c % HASHNUM;",
          "428:  if (m == 0)",
          "429:   bucket = (*table)->characters[makeHash];",
          "430:  else",
          "431:   bucket = (*table)->dots[makeHash];",
          "432:  if (!bucket) {",
          "433:   if (m == 0)",
          "434:    (*table)->characters[makeHash] = offset;",
          "435:   else",
          "436:    (*table)->dots[makeHash] = offset;",
          "437:  } else {",
          "438:   oldchar = (TranslationTableCharacter *)&(*table)->ruleArea[bucket];",
          "439:   while (oldchar->next)",
          "440:    oldchar = (TranslationTableCharacter *)&(*table)->ruleArea[oldchar->next];",
          "441:   oldchar->next = offset;",
          "442:  }",
          "443:  return character;",
          "447: getCharOrDots(widechar c, int m, TranslationTableHeader *table) {",
          "448:  CharOrDots *cdPtr;",
          "449:  TranslationTableOffset bucket;",
          "450:  unsigned long int makeHash = (unsigned long int)c % HASHNUM;",
          "451:  if (m == 0)",
          "452:   bucket = table->charToDots[makeHash];",
          "453:  else",
          "454:   bucket = table->dotsToChar[makeHash];",
          "455:  while (bucket) {",
          "456:   cdPtr = (CharOrDots *)&table->ruleArea[bucket];",
          "457:   if (cdPtr->lookFor == c) return cdPtr;",
          "458:   bucket = cdPtr->next;",
          "459:  }",
          "460:  return NULL;",
          "464: _lou_getDotsForChar(widechar c) {",
          "465:  CharOrDots *cdPtr = getCharOrDots(c, 0, gTable);",
          "466:  if (cdPtr) return cdPtr->found;",
          "467:  return B16;",
          "471: _lou_getCharFromDots(widechar d) {",
          "472:  CharOrDots *cdPtr = getCharOrDots(d, 1, gTable);",
          "473:  if (cdPtr) return cdPtr->found;",
          "474:  return ' ';",
          "478: putCharAndDots(FileInfo *nested, widechar c, widechar d, TranslationTableHeader **table) {",
          "479:  TranslationTableOffset bucket;",
          "480:  CharOrDots *cdPtr;",
          "481:  CharOrDots *oldcdPtr = NULL;",
          "482:  TranslationTableOffset offset;",
          "483:  unsigned long int makeHash;",
          "484:  if (!(cdPtr = getCharOrDots(c, 0, *table))) {",
          "485:   if (!allocateSpaceInTable(nested, &offset, sizeof(*cdPtr), table)) return 0;",
          "486:   cdPtr = (CharOrDots *)&(*table)->ruleArea[offset];",
          "487:   cdPtr->next = 0;",
          "488:   cdPtr->lookFor = c;",
          "489:   cdPtr->found = d;",
          "490:   makeHash = (unsigned long int)c % HASHNUM;",
          "491:   bucket = (*table)->charToDots[makeHash];",
          "492:   if (!bucket)",
          "493:    (*table)->charToDots[makeHash] = offset;",
          "494:   else {",
          "495:    oldcdPtr = (CharOrDots *)&(*table)->ruleArea[bucket];",
          "496:    while (oldcdPtr->next)",
          "497:     oldcdPtr = (CharOrDots *)&(*table)->ruleArea[oldcdPtr->next];",
          "498:    oldcdPtr->next = offset;",
          "499:   }",
          "501:  if (!(cdPtr = getCharOrDots(d, 1, *table))) {",
          "502:   if (!allocateSpaceInTable(nested, &offset, sizeof(*cdPtr), table)) return 0;",
          "503:   cdPtr = (CharOrDots *)&(*table)->ruleArea[offset];",
          "504:   cdPtr->next = 0;",
          "505:   cdPtr->lookFor = d;",
          "506:   cdPtr->found = c;",
          "507:   makeHash = (unsigned long int)d % HASHNUM;",
          "508:   bucket = (*table)->dotsToChar[makeHash];",
          "509:   if (!bucket)",
          "510:    (*table)->dotsToChar[makeHash] = offset;",
          "511:   else {",
          "512:    oldcdPtr = (CharOrDots *)&(*table)->ruleArea[bucket];",
          "513:    while (oldcdPtr->next)",
          "514:     oldcdPtr = (CharOrDots *)&(*table)->ruleArea[oldcdPtr->next];",
          "515:    oldcdPtr->next = offset;",
          "516:   }",
          "518:  return 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "714: static char *",
          "727: }",
          "729: static TranslationTableOffset gNewRuleOffset = 0;",
          "730: static TranslationTableRule *gNewRule = NULL;",
          "732: static int",
          "771: }",
          "773: static inline const char *",
          "777: }",
          "779: static int",
          "807:   }",
          "868:  }",
          "871: NOT_FOUND:",
          "877: }",
          "881: static void",
          "921: }",
          "923: static void",
          "946: }",
          "948: static void",
          "980: }",
          "982: static void",
          "1012: }",
          "1014: static int",
          "1052: }",
          "1054: static int",
          "1092: }",
          "1168:  }",
          "1176: }",
          "1178: static const CharacterClass *",
          "1193: }",
          "1195: static CharacterClass *",
          "1215:  }",
          "1219: }",
          "1221: static void",
          "1231: }",
          "1233: static int",
          "1252:  }",
          "1256: }",
          "1258: static TranslationTableOpcode",
          "1282: }",
          "1284: TranslationTableOpcode EXPORT_CALL",
          "1306: }",
          "1308: const char *EXPORT_CALL",
          "1319: }",
          "1321: static widechar",
          "1341:  }",
          "1345: }",
          "1347: #define MAXBYTES 7",
          "1350: static int",
          "1437:   }",
          "1474:  }",
          "1478: }",
          "1480: int EXPORT_CALL",
          "1500: }",
          "1502: static int",
          "1576:   return 0;",
          "1600:  }",
          "1610: }",
          "1612: int EXPORT_CALL",
          "1634: }",
          "1636: static int",
          "1646: }",
          "1648: static int",
          "1657: }",
          "1659: static int",
          "1668: }",
          "1670: static int",
          "1682:  }",
          "1687: }",
          "1689: static int",
          "1702: }",
          "1704: typedef struct RuleName {",
          "1709: } RuleName;",
          "1720: static struct RuleName *gRuleNames = NULL;",
          "1722: static TranslationTableOffset",
          "1736: }",
          "1738: static int",
          "1762:  }",
          "1770: }",
          "1772: static void",
          "1782: }",
          "1784: static int",
          "1806:  }",
          "1810: }",
          "1812: static int",
          "1857: }",
          "1860: static int",
          "1869: }",
          "1873: static int",
          "1930:  }",
          "1941: }",
          "1943: static int",
          "1974:  (*passLinepos)++;",
          "1983: }",
          "1985: static int",
          "2009: }",
          "2011: static int",
          "2024:  }",
          "2037: }",
          "2039: static int",
          "2052: }",
          "2054: static int",
          "2064: }",
          "2066: static int",
          "2095: }",
          "2097: static int",
          "2115: }",
          "2123: };",
          "2125: static struct PassName *passNames = NULL;",
          "2127: static int",
          "2150: }",
          "2152: static int",
          "2180: }",
          "2182: static pass_Codes",
          "2361:  }",
          "2364: }",
          "2366: static int",
          "2382: }",
          "2384: static int",
          "2400: }",
          "2402: static int",
          "2418: }",
          "2420: static int",
          "2436: }",
          "2438: static int",
          "2454: }",
          "2456: static int",
          "2498: }",
          "2500: static int",
          "2516: }",
          "2518: static inline int",
          "2524: }",
          "2526: static int",
          "2541: }",
          "2543: static int",
          "2582: #define SEPCHAR 0x0001",
          "2662:   }",
          "2692:   }",
          "2732:   }",
          "2739:   }",
          "2774:   }",
          "2790:   }",
          "2805:  }",
          "2810:  {",
          "2876:   }",
          "2889:  }",
          "3122:   return 0;",
          "3229: }",
          "3233: static int",
          "3252: }",
          "3254: static int",
          "3269: }",
          "3271: static int",
          "3342: }",
          "3344: static int",
          "3449: }",
          "3456: } HyphenDict;",
          "3458: #define DEFAULTSTATE 0xffff",
          "3459: #define HYPHENHASHSIZE 8191",
          "3461: typedef struct HyphenHashEntry {",
          "3465: } HyphenHashEntry;",
          "3472: static unsigned int",
          "3484:  }",
          "3487: }",
          "3489: static HyphenHashTab *",
          "3497: }",
          "3499: static void",
          "3512: }",
          "3515: static void",
          "3532: }",
          "3535: static int",
          "3554: }",
          "3556: static int",
          "3572: }",
          "3576: static void",
          "3590: }",
          "3592: static int",
          "3699:  }",
          "3718:  }",
          "3729: }",
          "3731: static int",
          "3772:  }",
          "3782: }",
          "3784: static int",
          "3789:  CharsString token;",
          "3790:  CharsString tmp;",
          "3791:  if (getToken(nested, &token, \"last word before or after\", lastToken))",
          "3792:   if (parseChars(nested, &tmp, &token)) {",
          "3795:   }",
          "3796:  return 0;",
          "3797: }",
          "3799: static int",
          "3820:  TranslationTableCharacter *c = NULL;",
          "3826: doOpcode:",
          "3990:   switch (compileBeforeAfter(nested, &lastToken)) {",
          "4016:     break;",
          "4019:     ok = 0;",
          "4020:     break;",
          "4021:   }",
          "4029:   break;",
          "4138:   break;",
          "4146:   break;",
          "4176:   break;",
          "4222:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4229:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4239:      }",
          "4250:       break;",
          "4251:      }",
          "4257:      break;",
          "4260:      ok = 0;",
          "4261:      break;",
          "4262:    }",
          "4325:  case CTO_Attribute:",
          "4327:   c = NULL;",
          "4328:   ok = 1;",
          "4331:    compileError(nested, \"Expected attribute number.\");",
          "4332:    ok = 0;",
          "4333:    break;",
          "4334:   }",
          "4336:   k = -1;",
          "4347:   }",
          "4350:    compileError(nested, \"Invalid attribute number.\");",
          "4351:    ok = 0;",
          "4352:    break;",
          "4353:   }",
          "4359:     c = compile_findCharOrDots(ruleChars.chars[i], 0, *table);",
          "4361:      c->attributes |= (CTC_UserDefined0 << k);",
          "4364:      compileError(nested, \"Attribute character undefined\");",
          "4365:      ok = 0;",
          "4366:      break;",
          "",
          "[Removed Lines]",
          "715: unknownDots (widechar dots)",
          "716: {",
          "717:   static char buffer[20];",
          "718:   int k = 1;",
          "719:   buffer[0] = '\\\\';",
          "720:   for (int mappingPos = 0; dotMapping[mappingPos].key; mappingPos++) {",
          "721:     if (dots & dotMapping[mappingPos].key)",
          "722:       buffer[k++] = dotMapping[mappingPos].value;",
          "723:   }",
          "724:   buffer[k++] = '/';",
          "725:   buffer[k] = 0;",
          "726:   return buffer;",
          "733: charactersDefined (FileInfo * nested,",
          "734:      TranslationTableRule *newRule,",
          "735:      TranslationTableHeader *table)",
          "736: {",
          "739:   int noErrors = 1;",
          "740:   int k;",
          "741:   if ((newRule->opcode >= CTO_Space && newRule->opcode <= CTO_LitDigit)",
          "742:       || newRule->opcode == CTO_SwapDd",
          "743:       ||",
          "744:       newRule->opcode == CTO_Replace || newRule->opcode == CTO_MultInd",
          "745:       || newRule->opcode == CTO_Repeated ||",
          "746:       ((newRule->opcode >= CTO_Context && newRule->opcode <=",
          "747:  CTO_Pass4) && newRule->opcode != CTO_Correct)",
          "748:   || newRule->opcode == CTO_Match)",
          "749:     return 1;",
          "750:   for (k = 0; k < newRule->charslen; k++)",
          "751:     if (!compile_findCharOrDots (newRule->charsdots[k], 0, table))",
          "752:       {",
          "753:  compileError (nested, \"Character %s is not defined\", _lou_showString",
          "754:         (&newRule->charsdots[k], 1));",
          "755:  noErrors = 0;",
          "756:       }",
          "757:   if (!(newRule->opcode == CTO_Correct || newRule->opcode == CTO_SwapCc || newRule->opcode == CTO_SwapCd)",
          "759:  && !(newRule->opcode >= CTO_CapsLetterRule && newRule->opcode <= CTO_EndEmph10PhraseAfterRule))",
          "760:     {",
          "761:       for (k = newRule->charslen; k < newRule->charslen + newRule->dotslen;",
          "762:     k++)",
          "763:  if (!compile_findCharOrDots (newRule->charsdots[k], 1, table))",
          "764:    {",
          "765:      compileError (nested, \"Dot pattern %s is not defined.\",",
          "766:      unknownDots (newRule->charsdots[k]));",
          "767:      noErrors = 0;",
          "768:    }",
          "769:     }",
          "770:   return noErrors;",
          "774: getPartName (int actionPart)",
          "775: {",
          "776:   return actionPart? \"action\": \"test\";",
          "780: passFindCharacters (FileInfo *nested, int actionPart,",
          "781:       widechar *instructions, int end,",
          "782:       widechar **characters, int *length)",
          "783: {",
          "784:   int IC = 0;",
          "785:   int finding = !actionPart;",
          "790:   while (IC < end)",
          "791:     {",
          "792:       widechar instruction = instructions[IC];",
          "794:       switch (instruction)",
          "795:  {",
          "796:    case pass_string:",
          "797:    case pass_dots:",
          "798:      {",
          "799:        int count = instructions[IC + 1];",
          "800:               IC += 2;",
          "802:        if (finding)",
          "803:   {",
          "806:     return 1;",
          "809:        IC += count;",
          "810:        continue;",
          "811:      }",
          "813:    case pass_attributes:",
          "814:      IC += 5;",
          "815:      goto NO_CHARACTERS;",
          "817:    case pass_swap:",
          "819:      if (!actionPart != !finding) IC += 2;",
          "822:    case pass_groupstart:",
          "823:    case pass_groupend:",
          "824:    case pass_groupreplace:",
          "825:      IC += 3;",
          "827:    NO_CHARACTERS:",
          "828:      {",
          "829:        if (finding) return 1;",
          "830:        continue;",
          "831:      }",
          "833:    case pass_eq:",
          "834:    case pass_lt:",
          "835:    case pass_gt:",
          "836:    case pass_lteq:",
          "837:    case pass_gteq:",
          "838:      IC += 3;",
          "839:      continue;",
          "841:    case pass_lookback:",
          "842:      IC += 2;",
          "843:      continue;",
          "845:    case pass_not:",
          "846:    case pass_startReplace:",
          "847:    case pass_endReplace:",
          "848:    case pass_first:",
          "849:    case pass_last:",
          "850:    case pass_copy:",
          "851:    case pass_omit:",
          "852:    case pass_plus:",
          "853:    case pass_hyphen:",
          "854:      IC += 1;",
          "855:      continue;",
          "857:    case pass_endTest:",
          "858:      if (finding) goto NOT_FOUND;",
          "859:      finding = 1;",
          "860:      IC += 1;",
          "861:      continue;",
          "863:    default:",
          "864:      compileError(nested, \"unhandled %s suboperand: \\\\x%02x\",",
          "865:     getPartName(actionPart),",
          "866:     instruction);",
          "867:      return 0;",
          "869:     }",
          "872:   compileError(nested,",
          "873:         \"characters, dots, attributes, or class swap not found in %s part\",",
          "874:         getPartName(actionPart));",
          "876:   return 0;",
          "882: addForwardRuleWithSingleChar (FileInfo * nested,",
          "883:          TranslationTableOffset *newRuleOffset,",
          "884:          TranslationTableRule *newRule,",
          "885:          TranslationTableHeader *table)",
          "886: {",
          "888:   TranslationTableRule *currentRule;",
          "889:   TranslationTableOffset *currentOffsetPtr;",
          "890:   TranslationTableCharacter *character;",
          "891:   int m = 0;",
          "892:   if (newRule->opcode == CTO_CompDots || newRule->opcode == CTO_Comp6)",
          "893:     return;",
          "894:   if (newRule->opcode >= CTO_Pass2 && newRule->opcode <= CTO_Pass4)",
          "895:     m = 1;",
          "896:   character = definedCharOrDots (nested, newRule->charsdots[0], m, table);",
          "897:   if (m != 1 && character->attributes & CTC_Letter && (newRule->opcode ==",
          "898:              CTO_WholeWord",
          "899:              || newRule->opcode ==",
          "900:              CTO_LargeSign))",
          "901:     {",
          "902:       if (table->noLetsignCount < LETSIGNSIZE)",
          "903:  table->noLetsign[table->noLetsignCount++] = newRule->charsdots[0];",
          "904:     }",
          "905:   if (newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow)",
          "906:     character->definitionRule = *newRuleOffset;",
          "907:   currentOffsetPtr = &character->otherRules;",
          "908:   while (*currentOffsetPtr)",
          "909:     {",
          "910:       currentRule = (TranslationTableRule *)",
          "911:  & table->ruleArea[*currentOffsetPtr];",
          "912:       if (currentRule->charslen == 0)",
          "913:  break;",
          "914:       if (currentRule->opcode >= CTO_Space && currentRule->opcode < CTO_UpLow)",
          "915:  if (!(newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow))",
          "916:    break;",
          "917:       currentOffsetPtr = &currentRule->charsnext;",
          "918:     }",
          "919:   newRule->charsnext = *currentOffsetPtr;",
          "924: addForwardRuleWithMultipleChars (TranslationTableOffset *newRuleOffset,",
          "925:      TranslationTableRule *newRule,",
          "926:      TranslationTableHeader *table)",
          "927: {",
          "929:   TranslationTableRule *currentRule = NULL;",
          "930:   TranslationTableOffset *currentOffsetPtr =",
          "931:     &table->forRules[_lou_stringHash (&newRule->charsdots[0])];",
          "932:   while (*currentOffsetPtr)",
          "933:     {",
          "934:       currentRule = (TranslationTableRule *)",
          "935:  & table->ruleArea[*currentOffsetPtr];",
          "936:       if (newRule->charslen > currentRule->charslen)",
          "937:  break;",
          "938:       if (newRule->charslen == currentRule->charslen)",
          "939:  if ((currentRule->opcode == CTO_Always)",
          "940:      && (newRule->opcode != CTO_Always))",
          "941:    break;",
          "942:       currentOffsetPtr = &currentRule->charsnext;",
          "943:     }",
          "944:   newRule->charsnext = *currentOffsetPtr;",
          "949: addBackwardRuleWithSingleCell (FileInfo * nested, widechar cell,",
          "950:           TranslationTableOffset *newRuleOffset,",
          "951:           TranslationTableRule *newRule,",
          "952:           TranslationTableHeader *table)",
          "953: {",
          "955:   TranslationTableRule *currentRule;",
          "956:   TranslationTableOffset *currentOffsetPtr;",
          "957:   TranslationTableCharacter *dots;",
          "958:   if (newRule->opcode == CTO_SwapCc ||",
          "959:       newRule->opcode == CTO_Repeated ||",
          "960:       (newRule->opcode == CTO_Always && newRule->charslen == 1))",
          "962:   dots = definedCharOrDots (nested, cell, 1, table);",
          "963:   if (newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow)",
          "964:     dots->definitionRule = *newRuleOffset;",
          "965:   currentOffsetPtr = &dots->otherRules;",
          "966:   while (*currentOffsetPtr)",
          "967:     {",
          "968:       currentRule = (TranslationTableRule *)",
          "969:  & table->ruleArea[*currentOffsetPtr];",
          "970:       if (newRule->charslen > currentRule->charslen ||",
          "971:    currentRule->dotslen == 0)",
          "972:  break;",
          "973:       if (currentRule->opcode >= CTO_Space && currentRule->opcode < CTO_UpLow)",
          "974:  if (!(newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow))",
          "975:    break;",
          "976:       currentOffsetPtr = &currentRule->dotsnext;",
          "977:     }",
          "978:   newRule->dotsnext = *currentOffsetPtr;",
          "983: addBackwardRuleWithMultipleCells (widechar *cells, int count,",
          "984:       TranslationTableOffset *newRuleOffset,",
          "985:       TranslationTableRule *newRule,",
          "986:       TranslationTableHeader *table)",
          "987: {",
          "989:   TranslationTableRule *currentRule = NULL;",
          "990:   TranslationTableOffset *currentOffsetPtr =",
          "991:     &table->backRules[_lou_stringHash(cells)];",
          "992:   if (newRule->opcode == CTO_SwapCc)",
          "993:     return;",
          "994:   while (*currentOffsetPtr)",
          "995:     {",
          "996:       int currentLength;",
          "997:       int newLength;",
          "998:       currentRule = (TranslationTableRule *)",
          "999:  & table->ruleArea[*currentOffsetPtr];",
          "1000:       currentLength = currentRule->dotslen + currentRule->charslen;",
          "1001:       newLength = count + newRule->charslen;",
          "1002:       if (newLength > currentLength)",
          "1003:  break;",
          "1004:       if (currentLength == newLength)",
          "1005:  if ((currentRule->opcode == CTO_Always)",
          "1006:      && (newRule->opcode != CTO_Always))",
          "1007:    break;",
          "1008:       currentOffsetPtr = &currentRule->dotsnext;",
          "1009:     }",
          "1010:   newRule->dotsnext = *currentOffsetPtr;",
          "1015: addForwardPassRule (TranslationTableOffset *newRuleOffset,",
          "1016:       TranslationTableRule *newRule,",
          "1017:       TranslationTableHeader *table)",
          "1018: {",
          "1019:   TranslationTableOffset *currentOffsetPtr;",
          "1020:   TranslationTableRule *currentRule;",
          "1021:   switch (newRule->opcode)",
          "1022:     {",
          "1023:     case CTO_Correct:",
          "1024:       currentOffsetPtr = &table->forPassRules[0];",
          "1025:       break;",
          "1026:     case CTO_Context:",
          "1027:       currentOffsetPtr = &table->forPassRules[1];",
          "1028:       break;",
          "1029:     case CTO_Pass2:",
          "1030:       currentOffsetPtr = &table->forPassRules[2];",
          "1031:       break;",
          "1032:     case CTO_Pass3:",
          "1033:       currentOffsetPtr = &table->forPassRules[3];",
          "1034:       break;",
          "1035:     case CTO_Pass4:",
          "1036:       currentOffsetPtr = &table->forPassRules[4];",
          "1037:       break;",
          "1038:     default:",
          "1039:       return 0;",
          "1040:     }",
          "1041:   while (*currentOffsetPtr)",
          "1042:     {",
          "1043:       currentRule = (TranslationTableRule *)",
          "1044:  & table->ruleArea[*currentOffsetPtr];",
          "1045:       if (newRule->charslen > currentRule->charslen)",
          "1046:  break;",
          "1047:       currentOffsetPtr = &currentRule->charsnext;",
          "1048:     }",
          "1049:   newRule->charsnext = *currentOffsetPtr;",
          "1051:   return 1;",
          "1055: addBackwardPassRule (TranslationTableOffset *newRuleOffset,",
          "1056:        TranslationTableRule *newRule,",
          "1057:        TranslationTableHeader *table)",
          "1058: {",
          "1059:   TranslationTableOffset *currentOffsetPtr;",
          "1060:   TranslationTableRule *currentRule;",
          "1061:   switch (newRule->opcode)",
          "1062:     {",
          "1063:     case CTO_Correct:",
          "1064:       currentOffsetPtr = &table->backPassRules[0];",
          "1065:       break;",
          "1066:     case CTO_Context:",
          "1067:       currentOffsetPtr = &table->backPassRules[1];",
          "1068:       break;",
          "1069:     case CTO_Pass2:",
          "1070:       currentOffsetPtr = &table->backPassRules[2];",
          "1071:       break;",
          "1072:     case CTO_Pass3:",
          "1073:       currentOffsetPtr = &table->backPassRules[3];",
          "1074:       break;",
          "1075:     case CTO_Pass4:",
          "1076:       currentOffsetPtr = &table->backPassRules[4];",
          "1077:       break;",
          "1078:     default:",
          "1079:       return 0;",
          "1080:     }",
          "1081:   while (*currentOffsetPtr)",
          "1082:     {",
          "1083:       currentRule = (TranslationTableRule *)",
          "1084:  & table->ruleArea[*currentOffsetPtr];",
          "1085:       if (newRule->charslen > currentRule->charslen)",
          "1086:  break;",
          "1087:       currentOffsetPtr = &currentRule->dotsnext;",
          "1088:     }",
          "1089:   newRule->dotsnext = *currentOffsetPtr;",
          "1091:   return 1;",
          "1094: static int addRule (FileInfo * nested,",
          "1095:       TranslationTableOpcode opcode,",
          "1096:       CharsString * ruleChars,",
          "1097:       CharsString * ruleDots,",
          "1098:       TranslationTableCharacterAttributes after,",
          "1099:       TranslationTableCharacterAttributes before,",
          "1100:       TranslationTableOffset *newRuleOffset,",
          "1101:       TranslationTableRule **newRule,",
          "1102:       int noback, int nofor,",
          "1103:       TranslationTableHeader **table)",
          "1104: {",
          "1107:   int ruleSize = sizeof (TranslationTableRule) - (DEFAULTRULESIZE * CHARSIZE);",
          "1108:   if (ruleChars)",
          "1109:     ruleSize += CHARSIZE * ruleChars->length;",
          "1110:   if (ruleDots)",
          "1111:     ruleSize += CHARSIZE * ruleDots->length;",
          "1112:   if (!allocateSpaceInTable (nested, newRuleOffset, ruleSize, table))",
          "1113:     return 0;",
          "1114:   TranslationTableRule *rule = (TranslationTableRule *) & (*table)->ruleArea[*newRuleOffset];",
          "1116:   rule->opcode = opcode;",
          "1117:   rule->after = after;",
          "1118:   rule->before = before;",
          "1119:   if (ruleChars)",
          "1120:     memcpy (&rule->charsdots[0], &ruleChars->chars[0],",
          "1121:      CHARSIZE * (rule->charslen = ruleChars->length));",
          "1122:   else",
          "1123:     rule->charslen = 0;",
          "1124:   if (ruleDots)",
          "1125:     memcpy (&rule->charsdots[rule->charslen],",
          "1126:      &ruleDots->chars[0], CHARSIZE * (rule->dotslen =",
          "1127:           ruleDots->length));",
          "1128:   else",
          "1129:     rule->dotslen = 0;",
          "1130:   if (!charactersDefined (nested, rule, *table))",
          "1131:     return 0;",
          "1134:   if (opcode == CTO_SwapCc || opcode == CTO_SwapCd || opcode == CTO_SwapDd)",
          "1135:     return 1;",
          "1136:   if (opcode >= CTO_Context && opcode <= CTO_Pass4)",
          "1137:     if (!(opcode == CTO_Context && rule->charslen > 0))",
          "1138:       {",
          "1139:  if (!nofor)",
          "1140:    if (!addForwardPassRule(newRuleOffset, rule, *table))",
          "1141:      return 0;",
          "1142:  if (!noback)",
          "1143:    if (!addBackwardPassRule(newRuleOffset, rule, *table))",
          "1144:      return 0;",
          "1145:  return 1;",
          "1146:       }",
          "1147:   if (!nofor)",
          "1148:     {",
          "1149:       if (rule->charslen == 1)",
          "1150:  addForwardRuleWithSingleChar (nested, newRuleOffset, rule, *table);",
          "1151:       else if (rule->charslen > 1)",
          "1152:  addForwardRuleWithMultipleChars (newRuleOffset, rule, *table);",
          "1153:     }",
          "1154:   if (!noback)",
          "1155:     {",
          "1156:       widechar *cells;",
          "1157:       int count;",
          "1159:       if (rule->opcode == CTO_Context)",
          "1160:  {",
          "1161:    cells = &rule->charsdots[0];",
          "1162:    count = rule->charslen;",
          "1163:  }",
          "1164:       else",
          "1165:  {",
          "1166:    cells = &rule->charsdots[rule->charslen];",
          "1167:    count = rule->dotslen;",
          "1170:       if (count == 1)",
          "1171:  addBackwardRuleWithSingleCell(nested, *cells, newRuleOffset, rule, *table);",
          "1172:       else if (count > 1)",
          "1173:  addBackwardRuleWithMultipleCells(cells, count, newRuleOffset, rule, *table);",
          "1174:     }",
          "1175:   return 1;",
          "1179: findCharacterClass (const CharsString * name,",
          "1180:       CharacterClass *characterClasses)",
          "1181: {",
          "1183:   const CharacterClass *class = characterClasses;",
          "1184:   while (class)",
          "1185:     {",
          "1186:       if ((name->length == class->length) &&",
          "1187:    (memcmp (&name->chars[0], class->name, CHARSIZE *",
          "1188:      name->length) == 0))",
          "1189:  return class;",
          "1190:       class = class->next;",
          "1191:     }",
          "1192:   return NULL;",
          "1196: addCharacterClass (FileInfo * nested, const widechar * name, int length,",
          "1197:      CharacterClass **characterClasses,",
          "1198:      TranslationTableCharacterAttributes *characterClassAttribute)",
          "1199: {",
          "1201:   CharacterClass *class;",
          "1202:   if (*characterClassAttribute)",
          "1203:     {",
          "1204:       if (!(class = malloc (sizeof (*class) + CHARSIZE * (length - 1))))",
          "1205:  _lou_outOfMemory ();",
          "1206:       else",
          "1207:  {",
          "1208:    memset (class, 0, sizeof (*class));",
          "1209:    memcpy (class->name, name, CHARSIZE * (class->length = length));",
          "1210:    class->attribute = *characterClassAttribute;",
          "1212:    class->next = *characterClasses;",
          "1214:    return class;",
          "1216:     }",
          "1217:   compileError (nested, \"character class table overflow.\");",
          "1218:   return NULL;",
          "1222: deallocateCharacterClasses (CharacterClass **characterClasses)",
          "1223: {",
          "1224:   while (*characterClasses)",
          "1225:     {",
          "1226:       CharacterClass *class = *characterClasses;",
          "1228:       if (class)",
          "1229:  free (class);",
          "1230:     }",
          "1234: allocateCharacterClasses (CharacterClass **characterClasses,",
          "1235:      TranslationTableCharacterAttributes *characterClassAttribute)",
          "1236: {",
          "1238:   int k = 0;",
          "1241:   while (characterClassNames[k])",
          "1242:     {",
          "1243:       widechar wname[MAXSTRING];",
          "1244:       int length = (int)strlen (characterClassNames[k]);",
          "1245:       int kk;",
          "1246:       for (kk = 0; kk < length; kk++)",
          "1247:  wname[kk] = (widechar) characterClassNames[k][kk];",
          "1248:       if (!addCharacterClass (NULL, wname, length, characterClasses, characterClassAttribute))",
          "1249:  {",
          "1250:    deallocateCharacterClasses (characterClasses);",
          "1251:    return 0;",
          "1253:       k++;",
          "1254:     }",
          "1255:   return 1;",
          "1259: getOpcode (FileInfo * nested, const CharsString * token,",
          "1260:     short opcodeLengths[])",
          "1261: {",
          "1262:   static TranslationTableOpcode lastOpcode = 0;",
          "1263:   TranslationTableOpcode opcode = lastOpcode;",
          "1265:   do",
          "1266:     {",
          "1267:       if (token->length == opcodeLengths[opcode])",
          "1268:  if (eqasc2uni ((unsigned char *) opcodeNames[opcode],",
          "1269:          &token->chars[0], token->length))",
          "1270:    {",
          "1271:      lastOpcode = opcode;",
          "1272:      return opcode;",
          "1273:    }",
          "1274:       opcode++;",
          "1275:       if (opcode >= CTO_None)",
          "1276:  opcode = 0;",
          "1277:     }",
          "1278:   while (opcode != lastOpcode);",
          "1279:   compileError (nested, \"opcode %s not defined.\", _lou_showString",
          "1280:   (&token->chars[0], token->length));",
          "1281:   return CTO_None;",
          "1285: _lou_findOpcodeNumber (const char *toFind)",
          "1286: {",
          "1288:   static TranslationTableOpcode lastOpcode = 0;",
          "1289:   TranslationTableOpcode opcode = lastOpcode;",
          "1290:   int length = (int)strlen (toFind);",
          "1291:   do",
          "1292:     {",
          "1293:       if (length == gOpcodeLengths[opcode] && strcasecmp (toFind,",
          "1294:          opcodeNames[opcode])",
          "1295:    == 0)",
          "1296:  {",
          "1297:    lastOpcode = opcode;",
          "1298:    return opcode;",
          "1299:  }",
          "1300:       opcode++;",
          "1301:       if (opcode >= CTO_None)",
          "1302:  opcode = 0;",
          "1303:     }",
          "1304:   while (opcode != lastOpcode);",
          "1305:   return CTO_None;",
          "1309: _lou_findOpcodeName (TranslationTableOpcode opcode)",
          "1310: {",
          "1311:   static char scratchBuf[MAXSTRING];",
          "1313:   if (opcode < 0 || opcode >= CTO_None)",
          "1314:     {",
          "1315:       sprintf (scratchBuf, \"%d\", opcode);",
          "1316:       return scratchBuf;",
          "1317:     }",
          "1318:   return opcodeNames[opcode];",
          "1322: hexValue (FileInfo * nested,",
          "1323:    const widechar * digits, int length)",
          "1324: {",
          "1325:   int k;",
          "1326:   unsigned int binaryValue = 0;",
          "1327:   for (k = 0; k < length; k++)",
          "1328:     {",
          "1329:       unsigned int hexDigit = 0;",
          "1330:       if (digits[k] >= '0' && digits[k] <= '9')",
          "1331:  hexDigit = digits[k] - '0';",
          "1332:       else if (digits[k] >= 'a' && digits[k] <= 'f')",
          "1333:  hexDigit = digits[k] - 'a' + 10;",
          "1334:       else if (digits[k] >= 'A' && digits[k] <= 'F')",
          "1335:  hexDigit = digits[k] - 'A' + 10;",
          "1336:       else",
          "1337:  {",
          "1338:    compileError (nested, \"invalid %d-digit hexadecimal number\",",
          "1339:    length);",
          "1340:    return (widechar) 0xffffffff;",
          "1342:       binaryValue |= hexDigit << (4 * (length - 1 - k));",
          "1343:     }",
          "1344:   return (widechar) binaryValue;",
          "1348: static const unsigned int first0Bit[MAXBYTES] = { 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0XFE };",
          "1351: parseChars (FileInfo * nested,",
          "1352:      CharsString * result,",
          "1353:      CharsString * token)",
          "1354: {",
          "1355:   int in = 0;",
          "1356:   int out = 0;",
          "1357:   int lastOutSize = 0;",
          "1358:   int lastIn;",
          "1359:   unsigned int ch = 0;",
          "1360:   int numBytes = 0;",
          "1361:   unsigned int utf32 = 0;",
          "1362:   int k;",
          "1363:   while (in < token->length)",
          "1364:     {",
          "1365:       ch = token->chars[in++] & 0xff;",
          "1366:       if (ch < 128)",
          "1367:  {",
          "1368:    if (ch == '\\\\')",
          "1370:        switch (ch = token->chars[in])",
          "1371:   {",
          "1372:   case '\\\\':",
          "1373:     break;",
          "1374:   case 'e':",
          "1375:     ch = 0x1b;",
          "1376:     break;",
          "1377:   case 'f':",
          "1378:     ch = 12;",
          "1379:     break;",
          "1380:   case 'n':",
          "1381:     ch = 10;",
          "1382:     break;",
          "1383:   case 'r':",
          "1384:     ch = 13;",
          "1385:     break;",
          "1386:   case 's':",
          "1387:     ch = ' ';",
          "1388:     break;",
          "1389:   case 't':",
          "1390:     ch = 9;",
          "1391:     break;",
          "1392:   case 'v':",
          "1393:     ch = 11;",
          "1394:     break;",
          "1395:   case 'w':",
          "1396:     ch = ENDSEGMENT;",
          "1397:     break;",
          "1398:   case 34:",
          "1399:     ch = QUOTESUB;",
          "1400:     break;",
          "1401:   case 'X':",
          "1402:   case 'x':",
          "1403:     if (token->length - in > 4)",
          "1404:       {",
          "1405:         ch = hexValue (nested, &token->chars[in + 1], 4);",
          "1406:         in += 4;",
          "1407:       }",
          "1408:     break;",
          "1409:   case 'y':",
          "1410:   case 'Y':",
          "1411:     if (CHARSIZE == 2)",
          "1412:       {",
          "1413:       not32:",
          "1414:         compileError (nested,",
          "1415:         \"liblouis has not been compiled for 32-bit Unicode\");",
          "1416:         break;",
          "1417:       }",
          "1418:     if (token->length - in > 5)",
          "1419:       {",
          "1420:         ch = hexValue (nested, &token->chars[in + 1], 5);",
          "1421:         in += 5;",
          "1422:       }",
          "1423:     break;",
          "1424:   case 'z':",
          "1425:   case 'Z':",
          "1426:     if (CHARSIZE == 2)",
          "1427:       goto not32;",
          "1428:     if (token->length - in > 8)",
          "1429:       {",
          "1430:         ch = hexValue (nested, &token->chars[in + 1], 8);",
          "1431:         in += 8;",
          "1432:       }",
          "1433:     break;",
          "1434:   default:",
          "1435:     compileError (nested, \"invalid escape sequence '\\\\%c'\", ch);",
          "1436:     break;",
          "1438:        in++;",
          "1439:      }",
          "1440:    result->chars[out++] = (widechar) ch;",
          "1441:    if (out >= MAXSTRING)",
          "1442:      {",
          "1443:        result->length = out;",
          "1444:        return 1;",
          "1445:      }",
          "1446:    continue;",
          "1447:  }",
          "1448:       lastOutSize = out;",
          "1449:       lastIn = in;",
          "1450:       for (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--)",
          "1451:  if (ch >= first0Bit[numBytes])",
          "1452:    break;",
          "1453:       utf32 = ch & (0XFF - first0Bit[numBytes]);",
          "1454:       for (k = 0; k < numBytes; k++)",
          "1455:  {",
          "1456:    if (in >= MAXSTRING)",
          "1457:      break;",
          "1458:    if (token->chars[in] < 128 || (token->chars[in] & 0x0040))",
          "1459:      {",
          "1460:        compileWarning (nested, \"invalid UTF-8. Assuming Latin-1.\");",
          "1461:        result->chars[out++] = token->chars[lastIn];",
          "1462:        in = lastIn + 1;",
          "1463:        continue;",
          "1464:      }",
          "1465:    utf32 = (utf32 << 6) + (token->chars[in++] & 0x3f);",
          "1466:  }",
          "1467:       if (CHARSIZE == 2 && utf32 > 0xffff)",
          "1468:  utf32 = 0xffff;",
          "1469:       result->chars[out++] = (widechar) utf32;",
          "1470:       if (out >= MAXSTRING)",
          "1471:  {",
          "1472:    result->length = lastOutSize;",
          "1473:    return 1;",
          "1475:     }",
          "1476:   result->length = out;",
          "1477:   return 1;",
          "1481: _lou_extParseChars (const char *inString, widechar * outString)",
          "1482: {",
          "1484:   CharsString wideIn;",
          "1485:   CharsString result;",
          "1486:   int k;",
          "1487:   for (k = 0; inString[k] && k < MAXSTRING-1; k++)",
          "1488:     wideIn.chars[k] = inString[k];",
          "1489:   wideIn.chars[k] = 0;",
          "1490:   wideIn.length = k;",
          "1491:   parseChars (NULL, &result, &wideIn);",
          "1492:   if (errorCount)",
          "1493:     {",
          "1494:       errorCount = 0;",
          "1495:       return 0;",
          "1496:     }",
          "1497:   for (k = 0; k < result.length; k++)",
          "1498:     outString[k] = result.chars[k];",
          "1499:   return result.length;",
          "1503: parseDots (FileInfo * nested,",
          "1504:     CharsString * cells, const CharsString * token)",
          "1505: {",
          "1508:   int cellCount = 0;",
          "1509:   int index;",
          "1510:   int start = 0;",
          "1512:   for (index = 0; index < token->length; index++)",
          "1513:     {",
          "1514:       int started = index != start;",
          "1515:       widechar character = token->chars[index];",
          "1516:       switch (character)",
          "1518:    {",
          "1519:      int dot;",
          "1520:  case '1':",
          "1521:      dot = B1;",
          "1522:      goto haveDot;",
          "1523:  case '2':",
          "1524:      dot = B2;",
          "1525:      goto haveDot;",
          "1526:  case '3':",
          "1527:      dot = B3;",
          "1528:      goto haveDot;",
          "1529:  case '4':",
          "1530:      dot = B4;",
          "1531:      goto haveDot;",
          "1532:  case '5':",
          "1533:      dot = B5;",
          "1534:      goto haveDot;",
          "1535:  case '6':",
          "1536:      dot = B6;",
          "1537:      goto haveDot;",
          "1538:  case '7':",
          "1539:      dot = B7;",
          "1540:      goto haveDot;",
          "1541:  case '8':",
          "1542:      dot = B8;",
          "1543:      goto haveDot;",
          "1544:  case '9':",
          "1545:      dot = B9;",
          "1546:      goto haveDot;",
          "1547:  case 'a':",
          "1548:  case 'A':",
          "1549:      dot = B10;",
          "1550:      goto haveDot;",
          "1551:  case 'b':",
          "1552:  case 'B':",
          "1553:      dot = B11;",
          "1554:      goto haveDot;",
          "1555:  case 'c':",
          "1556:  case 'C':",
          "1557:      dot = B12;",
          "1558:      goto haveDot;",
          "1559:  case 'd':",
          "1560:  case 'D':",
          "1561:      dot = B13;",
          "1562:      goto haveDot;",
          "1563:  case 'e':",
          "1564:  case 'E':",
          "1565:      dot = B14;",
          "1566:      goto haveDot;",
          "1567:  case 'f':",
          "1568:  case 'F':",
          "1569:      dot = B15;",
          "1570:    haveDot:",
          "1571:      if (started && !cell)",
          "1572:        goto invalid;",
          "1573:      if (cell & dot)",
          "1574:        {",
          "1575:   compileError (nested, \"dot specified more than once.\");",
          "1577:        }",
          "1578:      cell |= dot;",
          "1579:      break;",
          "1580:    }",
          "1582:    if (started)",
          "1583:      goto invalid;",
          "1584:    break;",
          "1586:    if (!started)",
          "1587:      {",
          "1588:        compileError (nested, \"missing cell specification.\");",
          "1589:        return 0;",
          "1590:      }",
          "1591:    cells->chars[cellCount++] = cell | B16;",
          "1592:    cell = 0;",
          "1593:    start = index + 1;",
          "1594:    break;",
          "1595:  default:",
          "1596:  invalid:",
          "1597:    compileError (nested, \"invalid dot number %s.\", _lou_showString",
          "1598:    (&character, 1));",
          "1599:    return 0;",
          "1601:     }",
          "1602:   if (index == start)",
          "1603:     {",
          "1604:       compileError (nested, \"missing cell specification.\");",
          "1605:       return 0;",
          "1606:     }",
          "1608:   cells->length = cellCount;",
          "1609:   return 1;",
          "1613: _lou_extParseDots (const char *inString,",
          "1614:      widechar * outString)",
          "1615: {",
          "1617:   CharsString wideIn;",
          "1618:   CharsString result;",
          "1619:   int k;",
          "1620:   for (k = 0; inString[k] && k < MAXSTRING-1; k++)",
          "1621:     wideIn.chars[k] = inString[k];",
          "1622:   wideIn.chars[k] = 0;",
          "1623:   wideIn.length = k;",
          "1624:   parseDots (NULL, &result, &wideIn);",
          "1625:   if (errorCount)",
          "1626:     {",
          "1627:       errorCount = 0;",
          "1628:       return 0;",
          "1629:     }",
          "1630:   for (k = 0; k < result.length; k++)",
          "1631:     outString[k] = result.chars[k];",
          "1632:   outString[k] = 0;",
          "1633:   return result.length;",
          "1637: getCharacters (FileInfo * nested, CharsString * characters,",
          "1638:         int *lastToken)",
          "1639: {",
          "1641:   CharsString token;",
          "1642:   if (getToken (nested, &token, \"characters\", lastToken))",
          "1643:     if (parseChars (nested, characters, &token))",
          "1644:       return 1;",
          "1645:   return 0;",
          "1649: getRuleCharsText (FileInfo * nested, CharsString * ruleChars,",
          "1650:     int *lastToken)",
          "1651: {",
          "1652:   CharsString token;",
          "1653:   if (getToken (nested, &token, \"Characters operand\", lastToken))",
          "1654:     if (parseChars (nested, ruleChars, &token))",
          "1655:       return 1;",
          "1656:   return 0;",
          "1660: getRuleDotsText (FileInfo * nested, CharsString * ruleDots,",
          "1661:    int *lastToken)",
          "1662: {",
          "1663:   CharsString token;",
          "1664:   if (getToken (nested, &token, \"characters\", lastToken))",
          "1665:     if (parseChars (nested, ruleDots, &token))",
          "1666:       return 1;",
          "1667:   return 0;",
          "1671: getRuleDotsPattern (FileInfo * nested, CharsString * ruleDots,",
          "1672:       int *lastToken)",
          "1673: {",
          "1675:   CharsString token;",
          "1676:   if (getToken (nested, &token, \"Dots operand\", lastToken))",
          "1677:     {",
          "1678:       if (token.length == 1 && token.chars[0] == '=')",
          "1679:  {",
          "1680:    ruleDots->length = 0;",
          "1681:    return 1;",
          "1683:       if (parseDots (nested, ruleDots, &token))",
          "1684:  return 1;",
          "1685:     }",
          "1686:   return 0;",
          "1690: getCharacterClass (FileInfo * nested, const CharacterClass **class,",
          "1691:      CharacterClass *characterClasses,",
          "1692:      int *lastToken)",
          "1693: {",
          "1694:   CharsString token;",
          "1695:   if (getToken (nested, &token, \"character class name\", lastToken))",
          "1696:     {",
          "1697:       if ((*class = findCharacterClass (&token, characterClasses)))",
          "1698:  return 1;",
          "1699:       compileError (nested, \"character class not defined.\");",
          "1700:     }",
          "1701:   return 0;",
          "1705:   struct RuleName *next;",
          "1706:   TranslationTableOffset ruleOffset;",
          "1707:   widechar length;",
          "1708:   widechar name[1];",
          "1711: static int includeFile (FileInfo * nested, CharsString * includedFile,",
          "1712:    CharacterClass **characterClasses,",
          "1713:    TranslationTableCharacterAttributes *characterClassAttribute,",
          "1714:    short opcodeLengths[],",
          "1715:    TranslationTableOffset *newRuleOffset,",
          "1716:    TranslationTableRule **newRule,",
          "1717:    RuleName **ruleNames,",
          "1718:    TranslationTableHeader **table);",
          "1723: findRuleName (const CharsString * name,",
          "1724:        RuleName *ruleNames)",
          "1725: {",
          "1726:   const struct RuleName *nameRule = ruleNames;",
          "1727:   while (nameRule)",
          "1728:     {",
          "1729:       if ((name->length == nameRule->length) &&",
          "1730:    (memcmp (&name->chars[0], nameRule->name, CHARSIZE *",
          "1731:      name->length) == 0))",
          "1732:  return nameRule->ruleOffset;",
          "1733:       nameRule = nameRule->next;",
          "1734:     }",
          "1735:   return 0;",
          "1739: addRuleName (FileInfo * nested, CharsString * name,",
          "1740:       TranslationTableOffset *newRuleOffset,",
          "1741:       RuleName **ruleNames,",
          "1742:       TranslationTableHeader *table)",
          "1743: {",
          "1744:   int k;",
          "1745:   struct RuleName *nameRule;",
          "1746:   if (!(nameRule = malloc (sizeof (*nameRule) + CHARSIZE *",
          "1747:       (name->length - 1))))",
          "1748:     {",
          "1749:       compileError (nested, \"not enough memory\");",
          "1750:       _lou_outOfMemory ();",
          "1751:     }",
          "1752:   memset (nameRule, 0, sizeof (*nameRule));",
          "1753:   for (k = 0; k < name->length; k++)",
          "1754:     {",
          "1755:       TranslationTableCharacter *ch = definedCharOrDots",
          "1756:  (nested, name->chars[k],",
          "1757:   0, table);",
          "1758:       if (!(ch->attributes & CTC_Letter))",
          "1759:  {",
          "1760:    compileError (nested, \"a name may contain only letters\");",
          "1761:    return 0;",
          "1763:       nameRule->name[k] = name->chars[k];",
          "1764:     }",
          "1765:   nameRule->length = name->length;",
          "1766:   nameRule->ruleOffset = *newRuleOffset;",
          "1767:   nameRule->next = *ruleNames;",
          "1769:   return 1;",
          "1773: deallocateRuleNames (RuleName **ruleNames)",
          "1774: {",
          "1775:   while (*ruleNames)",
          "1776:     {",
          "1777:       struct RuleName *nameRule = *ruleNames;",
          "1779:       if (nameRule)",
          "1780:  free (nameRule);",
          "1781:     }",
          "1785: compileSwapDots (FileInfo * nested, CharsString * source, CharsString * dest,",
          "1786:    TranslationTableHeader *table)",
          "1787: {",
          "1788:   int k = 0;",
          "1789:   int kk = 0;",
          "1790:   CharsString dotsSource;",
          "1791:   CharsString dotsDest;",
          "1792:   dest->length = 0;",
          "1793:   dotsSource.length = 0;",
          "1794:   while (k <= source->length)",
          "1795:     {",
          "1796:       if (source->chars[k] != ',' && k != source->length)",
          "1797:  dotsSource.chars[dotsSource.length++] = source->chars[k];",
          "1798:       else",
          "1799:  {",
          "1800:    if (!parseDots (nested, &dotsDest, &dotsSource))",
          "1801:      return 0;",
          "1802:    dest->chars[dest->length++] = dotsDest.length + 1;",
          "1803:    for (kk = 0; kk < dotsDest.length; kk++)",
          "1804:      dest->chars[dest->length++] = dotsDest.chars[kk];",
          "1805:    dotsSource.length = 0;",
          "1807:       k++;",
          "1808:     }",
          "1809:   return 1;",
          "1813: compileSwap (FileInfo * nested, TranslationTableOpcode opcode,",
          "1814:       int *lastToken,",
          "1815:       TranslationTableOffset *newRuleOffset,",
          "1816:       TranslationTableRule **newRule,",
          "1817:       int noback, int nofor,",
          "1818:       RuleName **ruleNames,",
          "1819:       TranslationTableHeader **table)",
          "1820: {",
          "1821:   CharsString ruleChars;",
          "1822:   CharsString ruleDots;",
          "1823:   CharsString name;",
          "1824:   CharsString matches;",
          "1825:   CharsString replacements;",
          "1826:   if (!getToken (nested, &name, \"name operand\", lastToken))",
          "1827:     return 0;",
          "1828:   if (!getToken (nested, &matches, \"matches operand\", lastToken))",
          "1829:     return 0;",
          "1830:   if (!getToken (nested, &replacements, \"replacements operand\", lastToken))",
          "1831:     return 0;",
          "1832:   if (opcode == CTO_SwapCc || opcode == CTO_SwapCd)",
          "1833:     {",
          "1834:       if (!parseChars (nested, &ruleChars, &matches))",
          "1835:  return 0;",
          "1836:     }",
          "1837:   else",
          "1838:     {",
          "1839:       if (!compileSwapDots (nested, &matches, &ruleChars, *table))",
          "1840:  return 0;",
          "1841:     }",
          "1842:   if (opcode == CTO_SwapCc)",
          "1843:     {",
          "1844:       if (!parseChars (nested, &ruleDots, &replacements))",
          "1845:  return 0;",
          "1846:     }",
          "1847:   else",
          "1848:     {",
          "1849:       if (!compileSwapDots (nested, &replacements, &ruleDots, *table))",
          "1850:  return 0;",
          "1851:     }",
          "1852:   if (!addRule (nested, opcode, &ruleChars, &ruleDots, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "1853:     return 0;",
          "1854:   if (!addRuleName (nested, &name, newRuleOffset, ruleNames, *table))",
          "1855:     return 0;",
          "1856:   return 1;",
          "1861: getNumber (widechar * source, widechar * dest)",
          "1862: {",
          "1864:   int k = 0;",
          "1866:   while (source[k] >= '0' && source[k] <= '9')",
          "1868:   return k;",
          "1874: passGetAttributes (CharsString *passLine,",
          "1875:      int *passLinepos,",
          "1876:      TranslationTableCharacterAttributes *passAttributes,",
          "1877:      FileInfo *passNested)",
          "1878: {",
          "1879:   int more = 1;",
          "1881:   while (more)",
          "1882:     {",
          "1883:       switch (passLine->chars[*passLinepos])",
          "1884:  {",
          "1885:  case pass_any:",
          "1887:    break;",
          "1888:  case pass_digit:",
          "1890:    break;",
          "1891:  case pass_litDigit:",
          "1893:    break;",
          "1894:  case pass_letter:",
          "1896:    break;",
          "1897:  case pass_math:",
          "1899:    break;",
          "1900:  case pass_punctuation:",
          "1902:    break;",
          "1903:  case pass_sign:",
          "1905:    break;",
          "1906:  case pass_space:",
          "1908:    break;",
          "1909:  case pass_uppercase:",
          "1911:    break;",
          "1912:  case pass_lowercase:",
          "1914:    break;",
          "1915:  case pass_class1:",
          "1917:    break;",
          "1918:  case pass_class2:",
          "1920:    break;",
          "1921:  case pass_class3:",
          "1923:    break;",
          "1924:  case pass_class4:",
          "1926:    break;",
          "1927:  default:",
          "1928:    more = 0;",
          "1929:    break;",
          "1931:       if (more)",
          "1932:  (*passLinepos)++;",
          "1933:     }",
          "1934:   if (!*passAttributes)",
          "1935:     {",
          "1936:       compileError (passNested, \"missing attribute\");",
          "1937:       (*passLinepos)--;",
          "1938:       return 0;",
          "1939:     }",
          "1940:   return 1;",
          "1944: passGetEmphasis (CharsString *passLine,",
          "1945:    int *passLinepos,",
          "1946:    FileInfo *passNested",
          "1947:    )",
          "1948: {",
          "1949:   static widechar passEmphasis;",
          "1950:   int more = 1;",
          "1951:   (*passLinepos)++;",
          "1952:   passEmphasis = 0;",
          "1953:   while (more)",
          "1954:     {",
          "1955:       switch (passLine->chars[*passLinepos])",
          "1956:  {",
          "1957:  case 'i':",
          "1958:    passEmphasis |= italic;",
          "1959:    break;",
          "1960:  case 'b':",
          "1961:    passEmphasis |= bold;",
          "1962:    break;",
          "1963:  case 'u':",
          "1964:    passEmphasis |= underline;",
          "1965:    break;",
          "1966:  case 'c':",
          "1967:    passEmphasis |= computer_braille;",
          "1968:    break;",
          "1969:  default:",
          "1970:    more = 0;",
          "1971:    break;",
          "1972:  }",
          "1973:       if (more)",
          "1975:     }",
          "1976:   if (!passEmphasis)",
          "1977:     {",
          "1978:       compileError (passNested, \"emphasis indicators expected\");",
          "1979:       (*passLinepos)--;",
          "1980:       return 0;",
          "1981:     }",
          "1982:   return 1;",
          "1986: passGetDots (CharsString *passLine,",
          "1987:       int *passLinepos,",
          "1988:       CharsString *passHoldString,",
          "1989:       FileInfo *passNested)",
          "1990: {",
          "1991:   CharsString collectDots;",
          "1992:   collectDots.length = 0;",
          "1993:   while (*passLinepos < passLine->length && (passLine->chars[*passLinepos]",
          "1994:         == '-'",
          "1995:         || (passLine->chars[*passLinepos] >=",
          "1996:             '0'",
          "1997:             && passLine->",
          "1998:             chars[*passLinepos] <= '9')",
          "1999:         ||",
          "2000:         ((passLine->",
          "2001:           chars[*passLinepos] | 32) >= 'a'",
          "2002:          && (passLine->",
          "2003:       chars[*passLinepos] | 32) <=",
          "2004:          'f')))",
          "2005:     collectDots.chars[collectDots.length++] = passLine->chars[(*passLinepos)++];",
          "2006:   if (!parseDots (passNested, passHoldString, &collectDots))",
          "2007:     return 0;",
          "2008:   return 1;",
          "2012: passGetString (CharsString *passLine,",
          "2013:         int *passLinepos,",
          "2014:         CharsString *passHoldString,",
          "2015:         FileInfo *passNested)",
          "2016: {",
          "2017:   passHoldString->length = 0;",
          "2018:   while (1)",
          "2019:     {",
          "2020:       if ((*passLinepos >= passLine->length) || !passLine->chars[*passLinepos])",
          "2021:  {",
          "2022:    compileError (passNested, \"unterminated string\");",
          "2023:    return 0;",
          "2025:       if (passLine->chars[*passLinepos] == 34)",
          "2026:  break;",
          "2027:       if (passLine->chars[*passLinepos] == QUOTESUB)",
          "2028:  passHoldString->chars[passHoldString->length++] = 34;",
          "2029:       else",
          "2030:  passHoldString->chars[passHoldString->length++] =",
          "2031:    passLine->chars[*passLinepos];",
          "2032:       (*passLinepos)++;",
          "2033:     }",
          "2034:   passHoldString->chars[passHoldString->length] = 0;",
          "2035:   (*passLinepos)++;",
          "2036:   return 1;",
          "2040: passGetNumber (CharsString *passLine,",
          "2041:         int *passLinepos,",
          "2042:         widechar *passHoldNumber)",
          "2043: {",
          "2046:   while ((*passLinepos < passLine->length) &&",
          "2047:          (passLine->chars[*passLinepos] >= '0') &&",
          "2048:   (passLine->chars[*passLinepos] <= '9'))",
          "2050:       10 * (*passHoldNumber) + (passLine->chars[(*passLinepos)++] - '0');",
          "2051:   return 1;",
          "2055: passGetVariableNumber (FileInfo *nested,",
          "2056:          CharsString *passLine,",
          "2057:          int *passLinepos,",
          "2058:          widechar *passHoldNumber)",
          "2059: {",
          "2060:   if (!passGetNumber(passLine, passLinepos, passHoldNumber)) return 0;",
          "2061:   if ((*passHoldNumber >= 0) && (*passHoldNumber < NUMVAR)) return 1;",
          "2062:   compileError(nested, \"variable number out of range\");",
          "2063:   return 0;",
          "2067: passGetName (CharsString *passLine,",
          "2068:       int *passLinepos,",
          "2069:       CharsString *passHoldString,",
          "2070:       FileInfo *passNested,",
          "2071:       TranslationTableHeader *table)",
          "2072: {",
          "2073:   TranslationTableCharacterAttributes attr;",
          "2074:   passHoldString->length = 0;",
          "2075:   do",
          "2076:     {",
          "2077:       attr = definedCharOrDots (passNested, passLine->chars[*passLinepos],",
          "2078:     0, table)->attributes;",
          "2079:       if (passHoldString->length == 0)",
          "2080:  {",
          "2081:    if (!(attr & CTC_Letter))",
          "2082:      {",
          "2083:        (*passLinepos)++;",
          "2084:        continue;",
          "2085:      }",
          "2086:  }",
          "2087:       if (!(attr & CTC_Letter))",
          "2088:  break;",
          "2089:       passHoldString->chars[passHoldString->length++] =",
          "2090:  passLine->chars[*passLinepos];",
          "2091:       (*passLinepos)++;",
          "2092:     }",
          "2093:   while (*passLinepos < passLine->length);",
          "2094:   return 1;",
          "2098: passIsKeyword (const char *token,",
          "2099:         CharsString *passLine,",
          "2100:         int *passLinepos)",
          "2101: {",
          "2102:   int k;",
          "2103:   int length = (int)strlen (token);",
          "2104:   int ch = passLine->chars[*passLinepos + length + 1];",
          "2105:   if (((ch | 32) >= 'a' && (ch | 32) <= 'z') || (ch >= '0' && ch <= '9'))",
          "2106:     return 0;",
          "2107:   for (k = 0; k < length && passLine->chars[*passLinepos + k + 1]",
          "2108:        == (widechar) token[k]; k++);",
          "2109:   if (k == length)",
          "2110:     {",
          "2112:       return 1;",
          "2113:     }",
          "2114:   return 0;",
          "2117: struct PassName",
          "2118: {",
          "2119:   struct PassName *next;",
          "2120:   int varnum;",
          "2121:   widechar length;",
          "2122:   widechar name[1];",
          "2128: passFindName (const CharsString * name,",
          "2129:        FileInfo *passNested,",
          "2130:        TranslationTableOpcode *passOpcode)",
          "2131: {",
          "2132:   const struct PassName *curname = passNames;",
          "2133:   CharsString augmentedName;",
          "2134:   for (augmentedName.length = 0; augmentedName.length < name->length;",
          "2135:        augmentedName.length++)",
          "2136:     augmentedName.chars[augmentedName.length] =",
          "2137:       name->chars[augmentedName.length];",
          "2138:   augmentedName.chars[augmentedName.length++] = *passOpcode;",
          "2139:   while (curname)",
          "2140:     {",
          "2141:       if ((augmentedName.length == curname->length) &&",
          "2142:    (memcmp",
          "2143:     (&augmentedName.chars[0], curname->name,",
          "2144:      CHARSIZE * name->length) == 0))",
          "2145:  return curname->varnum;",
          "2146:       curname = curname->next;",
          "2147:     }",
          "2148:   compileError (passNested, \"name not found\");",
          "2149:   return 0;",
          "2153: passAddName (CharsString * name, int var,",
          "2154:       TranslationTableOpcode *passOpcode)",
          "2155: {",
          "2156:   int k;",
          "2157:   struct PassName *curname;",
          "2158:   CharsString augmentedName;",
          "2159:   for (augmentedName.length = 0;",
          "2160:        augmentedName.length < name->length; augmentedName.length++)",
          "2161:     augmentedName.",
          "2162:       chars[augmentedName.length] = name->chars[augmentedName.length];",
          "2163:   augmentedName.chars[augmentedName.length++] = *passOpcode;",
          "2164:   if (!",
          "2165:       (curname =",
          "2166:        malloc (sizeof (*curname) + CHARSIZE * (augmentedName.length - 1))))",
          "2167:     {",
          "2168:       _lou_outOfMemory ();",
          "2169:     }",
          "2170:   memset (curname, 0, sizeof (*curname));",
          "2171:   for (k = 0; k < augmentedName.length; k++)",
          "2172:     {",
          "2173:       curname->name[k] = augmentedName.chars[k];",
          "2174:     }",
          "2175:   curname->length = augmentedName.length;",
          "2176:   curname->varnum = var;",
          "2177:   curname->next = passNames;",
          "2178:   passNames = curname;",
          "2179:   return 1;",
          "2183: passGetScriptToken (CharsString *passLine,",
          "2184:       int *passLinepos,",
          "2185:       int *passPrevLinepos,",
          "2186:       CharsString *passHoldString,",
          "2187:       widechar *passHoldNumber,",
          "2188:       FileInfo *passNested,",
          "2189:       TranslationTableHeader *table)",
          "2190: {",
          "2191:   while (*passLinepos < passLine->length)",
          "2192:     {",
          "2194:       switch (passLine->chars[*passLinepos])",
          "2195:  {",
          "2196:  case '\\\"':",
          "2197:    (*passLinepos)++;",
          "2198:    if (passGetString (passLine, passLinepos, passHoldString, passNested))",
          "2199:      return pass_string;",
          "2200:    return pass_invalidToken;",
          "2201:  case '@':",
          "2202:    (*passLinepos)++;",
          "2203:    if (passGetDots (passLine, passLinepos, passHoldString, passNested))",
          "2204:      return pass_dots;",
          "2205:    return pass_invalidToken;",
          "2208:    return pass_noMoreTokens;",
          "2209:  case '!':",
          "2210:    if (passLine->chars[*passLinepos + 1] == '=')",
          "2211:      {",
          "2213:        return pass_noteq;",
          "2214:      }",
          "2215:    (*passLinepos)++;",
          "2216:    return pass_not;",
          "2217:  case '-':",
          "2218:    (*passLinepos)++;",
          "2219:    return pass_hyphen;",
          "2220:  case '=':",
          "2221:    (*passLinepos)++;",
          "2222:    return pass_eq;",
          "2223:  case '<':",
          "2224:    (*passLinepos)++;",
          "2225:    if (passLine->chars[*passLinepos] == '=')",
          "2226:      {",
          "2227:        (*passLinepos)++;",
          "2228:        return pass_lteq;",
          "2229:      }",
          "2230:    return pass_lt;",
          "2231:  case '>':",
          "2232:    (*passLinepos)++;",
          "2233:    if (passLine->chars[*passLinepos] == '=')",
          "2234:      {",
          "2235:        (*passLinepos)++;",
          "2236:        return pass_gteq;",
          "2237:      }",
          "2238:    return pass_gt;",
          "2239:  case '+':",
          "2240:    (*passLinepos)++;",
          "2241:    return pass_plus;",
          "2242:  case '(':",
          "2243:    (*passLinepos)++;",
          "2244:    return pass_leftParen;",
          "2245:  case ')':",
          "2246:    (*passLinepos)++;",
          "2247:    return pass_rightParen;",
          "2248:  case ',':",
          "2249:    (*passLinepos)++;",
          "2250:    return pass_comma;",
          "2251:  case '&':",
          "2252:    if (passLine->chars[*passLinepos = 1] == '&')",
          "2253:      {",
          "2255:        return pass_and;",
          "2256:      }",
          "2257:    return pass_invalidToken;",
          "2258:  case '|':",
          "2259:    if (passLine->chars[*passLinepos + 1] == '|')",
          "2260:      {",
          "2262:        return pass_or;",
          "2263:      }",
          "2264:    return pass_invalidToken;",
          "2265:  case 'a':",
          "2266:    if (passIsKeyword (\"ttr\", passLine, passLinepos))",
          "2267:      return pass_attributes;",
          "2268:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2269:    return pass_nameFound;",
          "2270:  case 'b':",
          "2271:    if (passIsKeyword (\"ack\", passLine, passLinepos))",
          "2272:      return pass_lookback;",
          "2273:    if (passIsKeyword (\"ool\", passLine, passLinepos))",
          "2274:      return pass_boolean;",
          "2275:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2276:    return pass_nameFound;",
          "2277:  case 'c':",
          "2278:    if (passIsKeyword (\"lass\", passLine, passLinepos))",
          "2279:      return pass_class;",
          "2280:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2281:    return pass_nameFound;",
          "2282:  case 'd':",
          "2283:    if (passIsKeyword (\"ef\", passLine, passLinepos))",
          "2284:      return pass_define;",
          "2285:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2286:    return pass_nameFound;",
          "2287:  case 'e':",
          "2288:    if (passIsKeyword (\"mph\", passLine, passLinepos))",
          "2289:      return pass_emphasis;",
          "2290:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2291:    return pass_nameFound;",
          "2292:  case 'f':",
          "2293:    if (passIsKeyword (\"ind\", passLine, passLinepos))",
          "2294:      return pass_search;",
          "2295:    if (passIsKeyword (\"irst\", passLine, passLinepos))",
          "2296:      return pass_first;",
          "2297:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2298:    return pass_nameFound;",
          "2299:  case 'g':",
          "2300:    if (passIsKeyword (\"roup\", passLine, passLinepos))",
          "2301:      return pass_group;",
          "2302:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2303:    return pass_nameFound;",
          "2304:  case 'i':",
          "2305:    if (passIsKeyword (\"f\", passLine, passLinepos))",
          "2306:      return pass_if;",
          "2307:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2308:    return pass_nameFound;",
          "2309:  case 'l':",
          "2310:    if (passIsKeyword (\"ast\", passLine, passLinepos))",
          "2311:      return pass_last;",
          "2312:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2313:    return pass_nameFound;",
          "2314:  case 'm':",
          "2315:    if (passIsKeyword (\"ark\", passLine, passLinepos))",
          "2316:      return pass_mark;",
          "2317:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2318:    return pass_nameFound;",
          "2319:  case 'r':",
          "2320:    if (passIsKeyword (\"epgroup\", passLine, passLinepos))",
          "2321:      return pass_repGroup;",
          "2322:    if (passIsKeyword (\"epcopy\", passLine, passLinepos))",
          "2323:      return pass_copy;",
          "2324:    if (passIsKeyword (\"epomit\", passLine, passLinepos))",
          "2325:      return pass_omit;",
          "2326:    if (passIsKeyword (\"ep\", passLine, passLinepos))",
          "2327:      return pass_replace;",
          "2328:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2329:    return pass_nameFound;",
          "2330:  case 's':",
          "2331:    if (passIsKeyword (\"cript\", passLine, passLinepos))",
          "2332:      return pass_script;",
          "2333:    if (passIsKeyword (\"wap\", passLine, passLinepos))",
          "2334:      return pass_swap;",
          "2335:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2336:    return pass_nameFound;",
          "2337:  case 't':",
          "2338:    if (passIsKeyword (\"hen\", passLine, passLinepos))",
          "2339:      return pass_then;",
          "2340:    passGetName (passLine, passLinepos, passHoldString, passNested, table);",
          "2341:    return pass_nameFound;",
          "2342:  default:",
          "2343:    if (passLine->chars[*passLinepos] <= 32)",
          "2344:      {",
          "2345:        (*passLinepos)++;",
          "2346:        break;",
          "2347:      }",
          "2348:    if (passLine->chars[*passLinepos] >= '0'",
          "2349:        && passLine->chars[*passLinepos] <= '9')",
          "2350:      {",
          "2351:        passGetNumber (passLine, passLinepos, passHoldNumber);",
          "2352:        return pass_numberFound;",
          "2353:      }",
          "2354:    else",
          "2355:      {",
          "2356:        if (!passGetName (passLine, passLinepos, passHoldString, passNested, table))",
          "2357:   return pass_invalidToken;",
          "2358:        else",
          "2359:   return pass_nameFound;",
          "2360:      }",
          "2362:     }",
          "2363:   return pass_noMoreTokens;",
          "2367: passIsLeftParen (CharsString *passLine,",
          "2368:    int *passLinepos,",
          "2369:    int *passPrevLinepos,",
          "2370:    CharsString *passHoldString,",
          "2371:    FileInfo *passNested,",
          "2372:    TranslationTableHeader *table)",
          "2373: {",
          "2374:   widechar passHoldNumber;",
          "2375:   pass_Codes passCode = passGetScriptToken (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table);",
          "2376:   if (passCode != pass_leftParen)",
          "2377:     {",
          "2378:       compileError (passNested, \"'(' expected\");",
          "2379:       return 0;",
          "2380:     }",
          "2381:   return 1;",
          "2385: passIsName (CharsString *passLine,",
          "2386:      int *passLinepos,",
          "2387:      int *passPrevLinepos,",
          "2388:      CharsString *passHoldString,",
          "2389:      FileInfo *passNested,",
          "2390:      TranslationTableHeader *table)",
          "2391: {",
          "2392:   widechar passHoldNumber;",
          "2393:   pass_Codes passCode = passGetScriptToken (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table);",
          "2394:   if (passCode != pass_nameFound)",
          "2395:     {",
          "2396:       compileError (passNested, \"a name expected\");",
          "2397:       return 0;",
          "2398:     }",
          "2399:   return 1;",
          "2403: passIsComma (CharsString *passLine,",
          "2404:       int *passLinepos,",
          "2405:       int *passPrevLinepos,",
          "2406:       CharsString *passHoldString,",
          "2407:       FileInfo *passNested,",
          "2408:       TranslationTableHeader *table)",
          "2409: {",
          "2410:   widechar passHoldNumber;",
          "2411:   pass_Codes passCode = passGetScriptToken (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table);",
          "2412:   if (passCode != pass_comma)",
          "2413:     {",
          "2414:       compileError (passNested, \"',' expected\");",
          "2415:       return 0;",
          "2416:     }",
          "2417:   return 1;",
          "2421: passIsNumber (CharsString *passLine,",
          "2422:        int *passLinepos,",
          "2423:        int *passPrevLinepos,",
          "2424:        CharsString *passHoldString,",
          "2425:        widechar *passHoldNumber,",
          "2426:        FileInfo *passNested,",
          "2427:        TranslationTableHeader *table)",
          "2428: {",
          "2429:   pass_Codes passCode = passGetScriptToken (passLine, passLinepos, passPrevLinepos, passHoldString, passHoldNumber, passNested, table);",
          "2430:   if (passCode != pass_numberFound)",
          "2431:     {",
          "2432:       compileError (passNested, \"a number expected\");",
          "2433:       return 0;",
          "2434:     }",
          "2435:   return 1;",
          "2439: passIsRightParen (CharsString *passLine,",
          "2440:     int *passLinepos,",
          "2441:     int *passPrevLinepos,",
          "2442:     CharsString *passHoldString,",
          "2443:     FileInfo *passNested,",
          "2444:     TranslationTableHeader *table)",
          "2445: {",
          "2446:   widechar passHoldNumber;",
          "2447:   pass_Codes passCode = passGetScriptToken (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table);",
          "2448:   if (passCode != pass_rightParen)",
          "2449:     {",
          "2450:       compileError (passNested, \"')' expected\");",
          "2451:       return 0;",
          "2452:     }",
          "2453:   return 1;",
          "2457: passGetRange (CharsString *passLine,",
          "2458:        int *passLinepos,",
          "2459:        int *passPrevLinepos,",
          "2460:        CharsString *passHoldString,",
          "2461:        FileInfo *passNested,",
          "2462:        widechar *passInstructions, int *passIC,",
          "2463:        TranslationTableHeader *table)",
          "2464: {",
          "2465:   widechar passHoldNumber;",
          "2466:   pass_Codes passCode = passGetScriptToken (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table);",
          "2467:   if (!(passCode == pass_comma || passCode == pass_rightParen))",
          "2468:     {",
          "2469:       compileError (passNested, \"invalid range\");",
          "2470:       return 0;",
          "2471:     }",
          "2472:   if (passCode == pass_rightParen)",
          "2473:     {",
          "2474:       passInstructions[(*passIC)++] = 1;",
          "2475:       passInstructions[(*passIC)++] = 1;",
          "2476:       return 1;",
          "2477:     }",
          "2478:   if (!passIsNumber (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table))",
          "2479:     return 0;",
          "2480:   passInstructions[(*passIC)++] = passHoldNumber;",
          "2481:   passCode = passGetScriptToken (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table);",
          "2482:   if (!(passCode == pass_comma || passCode == pass_rightParen))",
          "2483:     {",
          "2484:       compileError (passNested, \"invalid range\");",
          "2485:       return 0;",
          "2486:     }",
          "2487:   if (passCode == pass_rightParen)",
          "2488:     {",
          "2489:       passInstructions[(*passIC)++] = passHoldNumber;",
          "2490:       return 1;",
          "2491:     }",
          "2492:   if (!passIsNumber (passLine, passLinepos, passPrevLinepos, passHoldString, &passHoldNumber, passNested, table))",
          "2493:     return 0;",
          "2494:   passInstructions[(*passIC)++] = passHoldNumber;",
          "2495:   if (!passIsRightParen (passLine, passLinepos, passPrevLinepos, passHoldString, passNested, table))",
          "2496:     return 0;",
          "2497:   return 1;",
          "2501: passInsertAttributes (CharsString *passLine,",
          "2502:         int *passLinepos,",
          "2503:         int *passPrevLinepos,",
          "2504:         CharsString *passHoldString,",
          "2505:         TranslationTableCharacterAttributes *passAttributes,",
          "2506:         FileInfo *passNested,",
          "2507:         widechar *passInstructions, int *passIC,",
          "2508:         TranslationTableHeader *table)",
          "2509: {",
          "2510:   passInstructions[(*passIC)++] = pass_attributes;",
          "2511:   passInstructions[(*passIC)++] = *passAttributes >> 16;",
          "2512:   passInstructions[(*passIC)++] = *passAttributes & 0xffff;",
          "2513:   if (!passGetRange (passLine, passLinepos, passPrevLinepos, passHoldString, passNested, passInstructions, passIC, table))",
          "2514:     return 0;",
          "2515:   return 1;",
          "2519: wantsString (TranslationTableOpcode opcode, int actionPart,",
          "2520:       int nofor) {",
          "2521:   if (opcode == CTO_Correct) return 1;",
          "2522:   if (opcode != CTO_Context) return 0;",
          "2523:   return !nofor == !actionPart;",
          "2527: verifyStringOrDots (FileInfo *nested, TranslationTableOpcode opcode,",
          "2528:       int isString, int actionPart,",
          "2529:       int nofor)",
          "2530: {",
          "2531:   if (!wantsString(opcode, actionPart, nofor) == !isString) return 1;",
          "2533:   compileError(nested, \"%s are not allowed in the %s part of a %s translation %s rule.\",",
          "2534:     isString? \"strings\": \"dots\",",
          "2535:     getPartName(actionPart),",
          "2536:     nofor? \"backward\": \"forward\",",
          "2537:     _lou_findOpcodeName(opcode)",
          "2538:   );",
          "2540:   return 0;",
          "2544: compilePassOpcode (FileInfo * nested,",
          "2545:      TranslationTableOpcode opcode,",
          "2546:      CharacterClass *characterClasses,",
          "2547:      TranslationTableOffset *newRuleOffset,",
          "2548:      TranslationTableRule **newRule,",
          "2549:      int noback, int nofor,",
          "2550:      RuleName *ruleNames,",
          "2551:      TranslationTableHeader **table)",
          "2552: {",
          "2553:   static CharsString passRuleChars;",
          "2554:   static CharsString passRuleDots;",
          "2556:   widechar passSubOp;",
          "2557:   const CharacterClass *class;",
          "2558:   TranslationTableOffset ruleOffset = 0;",
          "2559:   TranslationTableRule *rule = NULL;",
          "2560:   int k;",
          "2561:   int kk = 0;",
          "2562:   pass_Codes passCode;",
          "2563:   int endTest = 0;",
          "2564:   int isScript = 1;",
          "2565:   widechar *passInstructions = passRuleDots.chars;",
          "2567:   passRuleChars.length = 0;",
          "2568:   FileInfo *passNested = nested;",
          "2569:   TranslationTableOpcode passOpcode = opcode;",
          "2570:   CharsString passHoldString;",
          "2571:   widechar passHoldNumber;",
          "2572:   CharsString passLine;",
          "2573:   int passLinepos = 0;",
          "2574:   int passPrevLinepos;",
          "2575:   TranslationTableCharacterAttributes passAttributes;",
          "2576:   passHoldString.length = 0;",
          "2577:   for (k = nested->linepos; k < nested->linelen; k++)",
          "2578:     passHoldString.chars[passHoldString.length++] = nested->line[k];",
          "2579:   if (!eqasc2uni ((unsigned char *) \"script\", passHoldString.chars, 6))",
          "2580:     {",
          "2581:       isScript = 0;",
          "2583:       for (k = 0; k < passHoldString.length && passHoldString.chars[k] > 32;",
          "2584:     k++);",
          "2585:       if (k < passHoldString.length)",
          "2586:  passHoldString.chars[k] = SEPCHAR;",
          "2587:       else",
          "2588:  {",
          "2589:    compileError (passNested, \"Invalid multipass operands\");",
          "2590:    return 0;",
          "2591:  }",
          "2592:     }",
          "2593:   parseChars (passNested, &passLine, &passHoldString);",
          "2594:   if (isScript)",
          "2595:     {",
          "2596:       int more = 1;",
          "2597:       passCode = passGetScriptToken (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table);",
          "2598:       if (passCode != pass_script)",
          "2599:  {",
          "2600:    compileError (passNested, \"Invalid multipass statement\");",
          "2601:    return 0;",
          "2602:  }",
          "2604:       while (more)",
          "2605:  {",
          "2606:    passCode = passGetScriptToken (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table);",
          "2607:    switch (passCode)",
          "2608:      {",
          "2609:      case pass_define:",
          "2610:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2611:   return 0;",
          "2612:        if (!passIsName (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2613:   return 0;",
          "2614:        if (!passIsComma (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2615:   return 0;",
          "2616:        if (!passIsNumber (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table))",
          "2617:   return 0;",
          "2618:        if (!passIsRightParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2619:   return 0;",
          "2620:        passAddName (&passHoldString, passHoldNumber, &passOpcode);",
          "2621:        break;",
          "2622:      case pass_if:",
          "2623:        more = 0;",
          "2624:        break;",
          "2625:      default:",
          "2626:        compileError (passNested,",
          "2627:        \"invalid definition in declarative part\");",
          "2628:        return 0;",
          "2629:      }",
          "2630:  }",
          "2632:       more = 1;",
          "2633:       while (more)",
          "2634:  {",
          "2635:    passCode = passGetScriptToken (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table);",
          "2636:    passSubOp = passCode;",
          "2637:    switch (passCode)",
          "2638:      {",
          "2639:      case pass_not:",
          "2640:        passInstructions[passIC++] = pass_not;",
          "2641:        break;",
          "2642:      case pass_first:",
          "2643:        passInstructions[passIC++] = pass_first;",
          "2644:        break;",
          "2645:      case pass_last:",
          "2646:        passInstructions[passIC++] = pass_last;",
          "2647:        break;",
          "2648:      case pass_search:",
          "2649:        passInstructions[passIC++] = pass_search;",
          "2650:        break;",
          "2651:      case pass_string:",
          "2652:        if (!verifyStringOrDots(nested, opcode, 1, 0, nofor))",
          "2653:   {",
          "2654:     return 0;",
          "2655:   }",
          "2656:        passInstructions[passIC++] = pass_string;",
          "2657:        goto ifDoCharsDots;",
          "2658:      case pass_dots:",
          "2659:        if (!verifyStringOrDots(nested, opcode, 0, 0, nofor))",
          "2660:   {",
          "2661:     return 0;",
          "2663:        passInstructions[passIC++] = pass_dots;",
          "2664:      ifDoCharsDots:",
          "2665:        passInstructions[passIC++] = passHoldString.length;",
          "2666:        for (kk = 0; kk < passHoldString.length; kk++)",
          "2667:   passInstructions[passIC++] = passHoldString.chars[kk];",
          "2668:        break;",
          "2669:      case pass_attributes:",
          "2670:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2671:   return 0;",
          "2672:        if (!passGetAttributes (&passLine, &passLinepos, &passAttributes, passNested))",
          "2673:   return 0;",
          "2674:        if (!passInsertAttributes (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passAttributes, passNested, passInstructions, &passIC, *table))",
          "2675:   return 0;",
          "2676:        break;",
          "2677:      case pass_emphasis:",
          "2678:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2679:   return 0;",
          "2680:        if (!passGetEmphasis (&passLine, &passLinepos, passNested))",
          "2681:   return 0;",
          "2683:        break;",
          "2684:      case pass_lookback:",
          "2685:        passInstructions[passIC++] = pass_lookback;",
          "2686:        passCode = passGetScriptToken (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table);",
          "2687:        if (passCode != pass_leftParen)",
          "2688:   {",
          "2689:     passInstructions[passIC++] = 1;",
          "2690:     passLinepos = passPrevLinepos;",
          "2691:     break;",
          "2693:        if (!passIsNumber (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table))",
          "2694:   return 0;",
          "2695:        if (!passIsRightParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2696:   return 0;",
          "2697:        passInstructions[passIC] = passHoldNumber;",
          "2698:        break;",
          "2699:      case pass_group:",
          "2700:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2701:   return 0;",
          "2702:        break;",
          "2703:      case pass_mark:",
          "2704:        passInstructions[passIC++] = pass_startReplace;",
          "2705:        passInstructions[passIC++] = pass_endReplace;",
          "2706:        break;",
          "2707:      case pass_replace:",
          "2708:        passInstructions[passIC++] = pass_startReplace;",
          "2709:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2710:   return 0;",
          "2711:        break;",
          "2712:      case pass_rightParen:",
          "2713:        passInstructions[passIC++] = pass_endReplace;",
          "2714:        break;",
          "2715:      case pass_groupstart:",
          "2716:      case pass_groupend:",
          "2717:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2718:   return 0;",
          "2719:        if (!passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2720:   return 0;",
          "2721:        if (!passIsRightParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2722:   return 0;",
          "2723:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "2724:        if (ruleOffset)",
          "2725:   rule = (TranslationTableRule *) & (*table)->ruleArea[ruleOffset];",
          "2726:        if (rule && rule->opcode == CTO_Grouping)",
          "2727:   {",
          "2728:     passInstructions[passIC++] = passSubOp;",
          "2729:     passInstructions[passIC++] = ruleOffset >> 16;",
          "2730:     passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2731:     break;",
          "2733:        else",
          "2734:   {",
          "2735:     compileError (passNested, \"%s is not a grouping name\",",
          "2736:     _lou_showString (&passHoldString.chars[0],",
          "2737:          passHoldString.length));",
          "2738:     return 0;",
          "2740:        break;",
          "2741:      case pass_class:",
          "2742:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2743:   return 0;",
          "2744:        if (!passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2745:   return 0;",
          "2746:        if (!passIsRightParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2747:   return 0;",
          "2748:        if (!(class = findCharacterClass (&passHoldString, characterClasses)))",
          "2749:   return 0;",
          "2750:        passAttributes = class->attribute;",
          "2751:        passInsertAttributes (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passAttributes, passNested, passInstructions, &passIC, *table);",
          "2752:        break;",
          "2753:      case pass_swap:",
          "2754:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "2755:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2756:   return 0;",
          "2757:        if (!passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2758:   return 0;",
          "2759:        if (!passIsRightParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2760:   return 0;",
          "2761:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "2762:        if (ruleOffset)",
          "2763:   rule = (TranslationTableRule *) & (*table)->ruleArea[ruleOffset];",
          "2764:        if (rule",
          "2765:     && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd",
          "2766:         || rule->opcode == CTO_SwapDd))",
          "2767:   {",
          "2768:     passInstructions[passIC++] = pass_swap;",
          "2769:     passInstructions[passIC++] = ruleOffset >> 16;",
          "2770:     passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2771:     if (!passGetRange (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, passInstructions, &passIC, *table))",
          "2772:       return 0;",
          "2773:     break;",
          "2775:        compileError (passNested,",
          "2776:        \"%s is not a swap name.\",",
          "2777:        _lou_showString (&passHoldString.chars[0],",
          "2778:      passHoldString.length));",
          "2779:        return 0;",
          "2780:      case pass_nameFound:",
          "2781:        passHoldNumber = passFindName (&passHoldString, passNested, &passOpcode);",
          "2782:        passCode = passGetScriptToken (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table);",
          "2783:        if (!(passCode == pass_eq || passCode == pass_lt || passCode",
          "2784:       == pass_gt || passCode == pass_noteq || passCode ==",
          "2785:       pass_lteq || passCode == pass_gteq))",
          "2786:   {",
          "2787:     compileError (nested,",
          "2788:     \"invalid comparison operator in if part\");",
          "2789:     return 0;",
          "2791:        passInstructions[passIC++] = passCode;",
          "2792:        passInstructions[passIC++] = passHoldNumber;",
          "2793:        if (!passIsNumber (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table))",
          "2794:   return 0;",
          "2795:        passInstructions[passIC++] = passHoldNumber;",
          "2796:        break;",
          "2797:      case pass_then:",
          "2798:        passInstructions[passIC++] = pass_endTest;",
          "2799:        more = 0;",
          "2800:        break;",
          "2801:      default:",
          "2802:        compileError (passNested, \"invalid choice in if part\");",
          "2803:        return 0;",
          "2804:      }",
          "2808:       more = 1;",
          "2809:       while (more)",
          "2811:    passCode = passGetScriptToken (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table);",
          "2812:    passSubOp = passCode;",
          "2813:    switch (passCode)",
          "2814:      {",
          "2815:      case pass_string:",
          "2816:        if (!verifyStringOrDots(nested, opcode, 1, 1, nofor))",
          "2817:   {",
          "2818:     return 0;",
          "2819:   }",
          "2820:        passInstructions[passIC++] = pass_string;",
          "2821:        goto thenDoCharsDots;",
          "2822:      case pass_dots:",
          "2823:        if (!verifyStringOrDots(nested, opcode, 0, 1, nofor))",
          "2824:   {",
          "2825:     return 0;",
          "2826:   }",
          "2827:        passInstructions[passIC++] = pass_dots;",
          "2828:      thenDoCharsDots:",
          "2829:        passInstructions[passIC++] = passHoldString.length;",
          "2830:        for (kk = 0; kk < passHoldString.length; kk++)",
          "2831:   passInstructions[passIC++] = passHoldString.chars[kk];",
          "2832:        break;",
          "2833:      case pass_nameFound:",
          "2834:        passHoldNumber = passFindName (&passHoldString, passNested, &passOpcode);",
          "2835:        passCode = passGetScriptToken (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table);",
          "2836:        if (!(passCode == pass_plus || passCode == pass_hyphen",
          "2837:       || passCode == pass_eq))",
          "2838:   {",
          "2839:     compileError (nested,",
          "2840:     \"Invalid variable operator in then part\");",
          "2841:     return 0;",
          "2842:   }",
          "2843:        passInstructions[passIC++] = passCode;",
          "2844:        passInstructions[passIC++] = passHoldNumber;",
          "2845:        if (!passIsNumber (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, &passHoldNumber, passNested, *table))",
          "2846:   return 0;",
          "2847:        passInstructions[passIC++] = passHoldNumber;",
          "2848:        break;",
          "2849:      case pass_copy:",
          "2850:        passInstructions[passIC++] = pass_copy;",
          "2851:        break;",
          "2852:      case pass_omit:",
          "2853:        passInstructions[passIC++] = pass_omit;",
          "2854:        break;",
          "2855:      case pass_swap:",
          "2856:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "2857:        if (!passIsLeftParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2858:   return 0;",
          "2859:        if (!passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2860:   return 0;",
          "2861:        if (!passIsRightParen (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, *table))",
          "2862:   return 0;",
          "2863:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "2864:        if (ruleOffset)",
          "2865:   rule = (TranslationTableRule *) & (*table)->ruleArea[ruleOffset];",
          "2866:        if (rule",
          "2867:     && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd",
          "2868:         || rule->opcode == CTO_SwapDd))",
          "2869:   {",
          "2870:     passInstructions[passIC++] = pass_swap;",
          "2871:     passInstructions[passIC++] = ruleOffset >> 16;",
          "2872:     passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2873:     if (!passGetRange (&passLine, &passLinepos, &passPrevLinepos, &passHoldString, passNested, passInstructions, &passIC, *table))",
          "2874:       return 0;",
          "2875:     break;",
          "2877:        compileError (passNested,",
          "2878:        \"%s is not a swap name.\",",
          "2879:        _lou_showString (&passHoldString.chars[0],",
          "2880:      passHoldString.length));",
          "2881:        return 0;",
          "2882:      case pass_noMoreTokens:",
          "2883:        more = 0;",
          "2884:        break;",
          "2885:      default:",
          "2886:        compileError (passNested, \"invalid action in then part\");",
          "2887:        return 0;",
          "2888:      }",
          "2890:     }",
          "2891:   else",
          "2892:     {",
          "2896:       for (k = 0; k < passLine.length && passLine.chars[k] != SEPCHAR; k++);",
          "2897:       endTest = k;",
          "2898:       passLine.chars[endTest] = pass_endTest;",
          "2899:       passLinepos = 0;",
          "2900:       while (passLinepos <= endTest)",
          "2901:  {",
          "2902:    switch ((passSubOp = passLine.chars[passLinepos]))",
          "2903:      {",
          "2904:      case pass_lookback:",
          "2905:        passInstructions[passIC++] = pass_lookback;",
          "2906:        passLinepos++;",
          "2907:        passGetNumber (&passLine, &passLinepos, &passHoldNumber);",
          "2908:        if (passHoldNumber == 0)",
          "2909:   passHoldNumber = 1;",
          "2910:        passInstructions[passIC++] = passHoldNumber;",
          "2911:        break;",
          "2912:      case pass_not:",
          "2913:        passInstructions[passIC++] = pass_not;",
          "2914:        passLinepos++;",
          "2915:        break;",
          "2916:      case pass_first:",
          "2917:        passInstructions[passIC++] = pass_first;",
          "2918:        passLinepos++;",
          "2919:        break;",
          "2920:      case pass_last:",
          "2921:        passInstructions[passIC++] = pass_last;",
          "2922:        passLinepos++;",
          "2923:        break;",
          "2924:      case pass_search:",
          "2925:        passInstructions[passIC++] = pass_search;",
          "2926:        passLinepos++;",
          "2927:        break;",
          "2928:      case pass_string:",
          "2929:        if (!verifyStringOrDots(nested, opcode, 1, 0, nofor))",
          "2930:   {",
          "2931:     return 0;",
          "2932:   }",
          "2933:        passLinepos++;",
          "2934:        passInstructions[passIC++] = pass_string;",
          "2935:        passGetString (&passLine, &passLinepos, &passHoldString, passNested);",
          "2936:        goto testDoCharsDots;",
          "2937:      case pass_dots:",
          "2938:        if (!verifyStringOrDots(nested, opcode, 0, 0, nofor))",
          "2939:          {",
          "2940:     return 0;",
          "2941:   }",
          "2942:        passLinepos++;",
          "2943:        passInstructions[passIC++] = pass_dots;",
          "2944:        passGetDots (&passLine, &passLinepos, &passHoldString, passNested);",
          "2945:      testDoCharsDots:",
          "2946:        if (passHoldString.length == 0)",
          "2947:   return 0;",
          "2948:        passInstructions[passIC++] = passHoldString.length;",
          "2949:        for (kk = 0; kk < passHoldString.length; kk++)",
          "2950:   passInstructions[passIC++] = passHoldString.chars[kk];",
          "2951:        break;",
          "2952:      case pass_startReplace:",
          "2953:        passInstructions[passIC++] = pass_startReplace;",
          "2954:        passLinepos++;",
          "2955:        break;",
          "2956:      case pass_endReplace:",
          "2957:        passInstructions[passIC++] = pass_endReplace;",
          "2958:        passLinepos++;",
          "2959:        break;",
          "2960:      case pass_variable:",
          "2961:        passLinepos++;",
          "2962:        if (!passGetVariableNumber(nested, &passLine, &passLinepos, &passHoldNumber))",
          "2963:          return 0;",
          "2964:        switch (passLine.chars[passLinepos])",
          "2965:   {",
          "2966:   case pass_eq:",
          "2967:     passInstructions[passIC++] = pass_eq;",
          "2968:     goto doComp;",
          "2969:   case pass_lt:",
          "2970:     if (passLine.chars[passLinepos + 1] == pass_eq)",
          "2971:       {",
          "2972:         passLinepos++;",
          "2973:         passInstructions[passIC++] = pass_lteq;",
          "2974:       }",
          "2975:     else",
          "2976:       passInstructions[passIC++] = pass_lt;",
          "2977:     goto doComp;",
          "2978:   case pass_gt:",
          "2979:     if (passLine.chars[passLinepos + 1] == pass_eq)",
          "2980:       {",
          "2981:         passLinepos++;",
          "2982:         passInstructions[passIC++] = pass_gteq;",
          "2983:       }",
          "2984:     else",
          "2985:       passInstructions[passIC++] = pass_gt;",
          "2986:   doComp:",
          "2987:     passInstructions[passIC++] = passHoldNumber;",
          "2988:     passLinepos++;",
          "2989:     passGetNumber (&passLine, &passLinepos, &passHoldNumber);",
          "2990:     passInstructions[passIC++] = passHoldNumber;",
          "2991:     break;",
          "2992:   default:",
          "2993:     compileError (passNested, \"incorrect comparison operator\");",
          "2994:     return 0;",
          "2995:   }",
          "2996:        break;",
          "2997:      case pass_attributes:",
          "2998:        passLinepos++;",
          "2999:        if (!passGetAttributes(&passLine, &passLinepos, &passAttributes, passNested))",
          "3000:                 return 0;",
          "3001:      insertAttributes:",
          "3002:        passInstructions[passIC++] = pass_attributes;",
          "3003:        passInstructions[passIC++] = passAttributes >> 16;",
          "3004:        passInstructions[passIC++] = passAttributes & 0xffff;",
          "3005:      getRange:",
          "3006:        if (passLine.chars[passLinepos] == pass_until)",
          "3007:   {",
          "3008:     passLinepos++;",
          "3009:     passInstructions[passIC++] = 1;",
          "3010:     passInstructions[passIC++] = 0xffff;",
          "3011:     break;",
          "3012:   }",
          "3013:        passGetNumber (&passLine, &passLinepos, &passHoldNumber);",
          "3014:        if (passHoldNumber == 0)",
          "3015:   {",
          "3016:     passHoldNumber = passInstructions[passIC++] = 1;",
          "3018:     break;",
          "3019:   }",
          "3020:        passInstructions[passIC++] = passHoldNumber;",
          "3021:        if (passLine.chars[passLinepos] != pass_hyphen)",
          "3022:   {",
          "3023:     passInstructions[passIC++] = passHoldNumber;",
          "3024:     break;",
          "3025:   }",
          "3026:        passLinepos++;",
          "3027:        passGetNumber (&passLine, &passLinepos, &passHoldNumber);",
          "3028:        if (passHoldNumber == 0)",
          "3029:   {",
          "3030:     compileError (passNested, \"invalid range\");",
          "3031:     return 0;",
          "3032:   }",
          "3033:        passInstructions[passIC++] = passHoldNumber;",
          "3034:        break;",
          "3035:      case pass_groupstart:",
          "3036:      case pass_groupend:",
          "3037:        passLinepos++;",
          "3038:        passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "3039:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "3040:        if (ruleOffset)",
          "3041:   rule = (TranslationTableRule *) & (*table)->ruleArea[ruleOffset];",
          "3042:        if (rule && rule->opcode == CTO_Grouping)",
          "3043:   {",
          "3044:     passInstructions[passIC++] = passSubOp;",
          "3045:     passInstructions[passIC++] = ruleOffset >> 16;",
          "3046:     passInstructions[passIC++] = ruleOffset & 0xffff;",
          "3047:     break;",
          "3048:   }",
          "3049:        else",
          "3050:   {",
          "3051:     compileError (passNested, \"%s is not a grouping name\",",
          "3052:     _lou_showString (&passHoldString.chars[0],",
          "3053:          passHoldString.length));",
          "3054:     return 0;",
          "3055:   }",
          "3056:        break;",
          "3057:      case pass_swap:",
          "3058:        passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "3059:        if ((class = findCharacterClass (&passHoldString, characterClasses)))",
          "3060:   {",
          "3061:     passAttributes = class->attribute;",
          "3062:     goto insertAttributes;",
          "3063:   }",
          "3064:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "3065:        if (ruleOffset)",
          "3066:   rule = (TranslationTableRule *) & (*table)->ruleArea[ruleOffset];",
          "3067:        if (rule",
          "3068:     && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd",
          "3069:         || rule->opcode == CTO_SwapDd))",
          "3070:   {",
          "3071:     passInstructions[passIC++] = pass_swap;",
          "3072:     passInstructions[passIC++] = ruleOffset >> 16;",
          "3073:     passInstructions[passIC++] = ruleOffset & 0xffff;",
          "3074:     goto getRange;",
          "3075:   }",
          "3076:        compileError (passNested,",
          "3077:        \"%s is neither a class name nor a swap name.\",",
          "3078:        _lou_showString (&passHoldString.chars[0],",
          "3079:      passHoldString.length));",
          "3080:        return 0;",
          "3081:      case pass_endTest:",
          "3082:        passInstructions[passIC++] = pass_endTest;",
          "3083:        passLinepos++;",
          "3084:        break;",
          "3085:      default:",
          "3086:        compileError (passNested,",
          "3087:        \"incorrect operator '%c ' in test part\",",
          "3088:        passLine.chars[passLinepos]);",
          "3089:        return 0;",
          "3090:      }",
          "3095:       while (passLinepos < passLine.length &&",
          "3096:       passLine.chars[passLinepos] <= 32)",
          "3097:  passLinepos++;",
          "3098:       while (passLinepos < passLine.length &&",
          "3099:       passLine.chars[passLinepos] > 32)",
          "3100:  {",
          "3101:    switch ((passSubOp = passLine.chars[passLinepos]))",
          "3102:      {",
          "3103:      case pass_string:",
          "3104:        if (!verifyStringOrDots(nested, opcode, 1, 1, nofor))",
          "3105:   {",
          "3106:     return 0;",
          "3107:   }",
          "3108:        passLinepos++;",
          "3109:        passInstructions[passIC++] = pass_string;",
          "3110:        passGetString (&passLine, &passLinepos, &passHoldString, passNested);",
          "3111:        goto actionDoCharsDots;",
          "3112:      case pass_dots:",
          "3113:        if (!verifyStringOrDots(nested, opcode, 0, 1, nofor))",
          "3114:   {",
          "3115:     return 0;",
          "3116:   }",
          "3117:        passLinepos++;",
          "3118:        passGetDots (&passLine, &passLinepos, &passHoldString, passNested);",
          "3119:        passInstructions[passIC++] = pass_dots;",
          "3120:      actionDoCharsDots:",
          "3121:        if (passHoldString.length == 0)",
          "3123:        passInstructions[passIC++] = passHoldString.length;",
          "3124:        for (kk = 0; kk < passHoldString.length; kk++)",
          "3125:   passInstructions[passIC++] = passHoldString.chars[kk];",
          "3126:        break;",
          "3127:      case pass_variable:",
          "3128:        passLinepos++;",
          "3129:        if (!passGetVariableNumber(nested, &passLine, &passLinepos, &passHoldNumber))",
          "3130:          return 0;",
          "3131:        switch (passLine.chars[passLinepos])",
          "3132:   {",
          "3133:   case pass_eq:",
          "3134:     passInstructions[passIC++] = pass_eq;",
          "3135:     passInstructions[passIC++] = passHoldNumber;",
          "3136:     passLinepos++;",
          "3137:     passGetNumber (&passLine, &passLinepos, &passHoldNumber);",
          "3138:     passInstructions[passIC++] = passHoldNumber;",
          "3139:     break;",
          "3140:   case pass_plus:",
          "3141:   case pass_hyphen:",
          "3142:     passInstructions[passIC++] = passLine.chars[passLinepos++];",
          "3143:     passInstructions[passIC++] = passHoldNumber;",
          "3144:     break;",
          "3145:   default:",
          "3146:     compileError (passNested,",
          "3147:     \"incorrect variable operator in action part\");",
          "3148:     return 0;",
          "3149:   }",
          "3150:        break;",
          "3151:      case pass_copy:",
          "3152:        passInstructions[passIC++] = pass_copy;",
          "3153:        passLinepos++;",
          "3154:        break;",
          "3155:      case pass_omit:",
          "3156:        passInstructions[passIC++] = pass_omit;",
          "3157:        passLinepos++;",
          "3158:        break;",
          "3159:      case pass_groupreplace:",
          "3160:      case pass_groupstart:",
          "3161:      case pass_groupend:",
          "3162:        passLinepos++;",
          "3163:        passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "3164:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "3165:        if (ruleOffset)",
          "3166:   rule = (TranslationTableRule *) & (*table)->ruleArea[ruleOffset];",
          "3167:        if (rule && rule->opcode == CTO_Grouping)",
          "3168:   {",
          "3169:     passInstructions[passIC++] = passSubOp;",
          "3170:     passInstructions[passIC++] = ruleOffset >> 16;",
          "3171:     passInstructions[passIC++] = ruleOffset & 0xffff;",
          "3172:     break;",
          "3173:   }",
          "3174:        compileError (passNested, \"%s is not a grouping name\",",
          "3175:        _lou_showString (&passHoldString.chars[0],",
          "3176:      passHoldString.length));",
          "3177:        return 0;",
          "3178:      case pass_swap:",
          "3179:        passLinepos++;",
          "3180:        passGetName (&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "3181:        ruleOffset = findRuleName (&passHoldString, ruleNames);",
          "3182:        if (ruleOffset)",
          "3183:   rule = (TranslationTableRule *) & (*table)->ruleArea[ruleOffset];",
          "3184:        if (rule",
          "3185:     && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd",
          "3186:         || rule->opcode == CTO_SwapDd))",
          "3187:   {",
          "3188:     passInstructions[passIC++] = pass_swap;",
          "3189:     passInstructions[passIC++] = ruleOffset >> 16;",
          "3190:     passInstructions[passIC++] = ruleOffset & 0xffff;",
          "3191:     break;",
          "3192:   }",
          "3193:        compileError (passNested, \"%s is not a swap name.\",",
          "3194:        _lou_showString (&passHoldString.chars[0],",
          "3195:      passHoldString.length));",
          "3196:        return 0;",
          "3197:        break;",
          "3198:      default:",
          "3199:        compileError (passNested, \"incorrect operator in action part\");",
          "3200:        return 0;",
          "3201:      }",
          "3202:  }",
          "3203:     }",
          "3206:   passRuleDots.length = passIC;",
          "3208:   {",
          "3209:     widechar *characters;",
          "3210:     int length;",
          "3211:     int found = passFindCharacters(passNested, 0, passInstructions, passRuleDots.length,",
          "3212:        &characters, &length);",
          "3214:     if (!found)",
          "3215:       return 0;",
          "3217:     if (characters)",
          "3218:       {",
          "3219:  for (k = 0; k < length; k += 1)",
          "3220:    passRuleChars.chars[k] = characters[k];",
          "3221:  passRuleChars.length = k;",
          "3222:       }",
          "3223:   }",
          "3225:   if (!addRule(passNested, opcode, &passRuleChars, &passRuleDots, 0, 0,",
          "3226:         newRuleOffset, newRule, noback, nofor, table))",
          "3227:     return 0;",
          "3228:   return 1;",
          "3234: compileBrailleIndicator (FileInfo * nested,",
          "3235:     char *ermsg,",
          "3236:     TranslationTableOpcode opcode,",
          "3237:     TranslationTableOffset * rule,",
          "3238:     int *lastToken,",
          "3239:     TranslationTableOffset *newRuleOffset,",
          "3240:     TranslationTableRule **newRule,",
          "3241:     int noback, int nofor,",
          "3242:     TranslationTableHeader **table)",
          "3243: {",
          "3244:   CharsString token;",
          "3245:   CharsString cells;",
          "3246:   if (getToken (nested, &token, ermsg, lastToken))",
          "3247:     if (parseDots (nested, &cells, &token))",
          "3248:       if (!addRule (nested, opcode, NULL, &cells, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3249:  return 0;",
          "3251:   return 1;",
          "3255: compileNumber (FileInfo * nested,",
          "3256:         int *lastToken)",
          "3257: {",
          "3258:   CharsString token;",
          "3259:   widechar dest;",
          "3260:   if (!getToken (nested, &token, \"number\", lastToken))",
          "3261:     return 0;",
          "3262:   getNumber (&token.chars[0], &dest);",
          "3263:   if (!(dest > 0))",
          "3264:     {",
          "3265:       compileError (nested, \"a nonzero positive number is required\");",
          "3266:       return 0;",
          "3267:     }",
          "3268:   return dest;",
          "3272: compileGrouping (FileInfo * nested,",
          "3273:    int *lastToken,",
          "3274:    TranslationTableOffset *newRuleOffset,",
          "3275:    TranslationTableRule **newRule,",
          "3276:    int noback, int nofor,",
          "3277:    RuleName **ruleNames,",
          "3278:    TranslationTableHeader **table)",
          "3279: {",
          "3280:   int k;",
          "3281:   CharsString name;",
          "3282:   CharsString groupChars;",
          "3283:   CharsString groupDots;",
          "3284:   CharsString dotsParsed;",
          "3285:   TranslationTableCharacter *charsDotsPtr;",
          "3286:   widechar endChar;",
          "3287:   widechar endDots;",
          "3288:   if (!getToken (nested, &name, \"name operand\", lastToken))",
          "3289:     return 0;",
          "3290:   if (!getRuleCharsText (nested, &groupChars, lastToken))",
          "3291:     return 0;",
          "3292:   if (!getToken (nested, &groupDots, \"dots operand\", lastToken))",
          "3293:     return 0;",
          "3294:   for (k = 0; k < groupDots.length && groupDots.chars[k] != ','; k++);",
          "3295:   if (k == groupDots.length)",
          "3296:     {",
          "3297:       compileError (nested,",
          "3298:       \"Dots operand must consist of two cells separated by a comma\");",
          "3299:       return 0;",
          "3300:     }",
          "3301:   groupDots.chars[k] = '-';",
          "3302:   if (!parseDots (nested, &dotsParsed, &groupDots))",
          "3303:     return 0;",
          "3304:   if (groupChars.length != 2 || dotsParsed.length != 2)",
          "3305:     {",
          "3306:       compileError (nested,",
          "3307:       \"two Unicode characters and two cells separated by a comma are needed.\");",
          "3308:       return 0;",
          "3309:     }",
          "3310:   charsDotsPtr = addCharOrDots (nested, groupChars.chars[0], 0, table);",
          "3311:   charsDotsPtr->attributes |= CTC_Math;",
          "3312:   charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "3313:   charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "3314:   charsDotsPtr = addCharOrDots (nested, groupChars.chars[1], 0, table);",
          "3315:   charsDotsPtr->attributes |= CTC_Math;",
          "3316:   charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "3317:   charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "3318:   charsDotsPtr = addCharOrDots (nested, dotsParsed.chars[0], 1, table);",
          "3319:   charsDotsPtr->attributes |= CTC_Math;",
          "3320:   charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "3321:   charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "3322:   charsDotsPtr = addCharOrDots (nested, dotsParsed.chars[1], 1, table);",
          "3323:   charsDotsPtr->attributes |= CTC_Math;",
          "3324:   charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "3325:   charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "3326:   if (!addRule (nested, CTO_Grouping, &groupChars, &dotsParsed, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3327:     return 0;",
          "3328:   if (!addRuleName (nested, &name, newRuleOffset, ruleNames, *table))",
          "3329:     return 0;",
          "3330:   putCharAndDots (nested, groupChars.chars[0], dotsParsed.chars[0], table);",
          "3331:   putCharAndDots (nested, groupChars.chars[1], dotsParsed.chars[1], table);",
          "3332:   endChar = groupChars.chars[1];",
          "3333:   endDots = dotsParsed.chars[1];",
          "3334:   groupChars.length = dotsParsed.length = 1;",
          "3335:   if (!addRule (nested, CTO_Math, &groupChars, &dotsParsed, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3336:     return 0;",
          "3337:   groupChars.chars[0] = endChar;",
          "3338:   dotsParsed.chars[0] = endDots;",
          "3339:   if (!addRule (nested, CTO_Math, &groupChars, &dotsParsed, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3340:     return 0;",
          "3341:   return 1;",
          "3345: compileUplow (FileInfo * nested,",
          "3346:        int *lastToken,",
          "3347:        TranslationTableOffset *newRuleOffset,",
          "3348:        TranslationTableRule **newRule,",
          "3349:        int noback, int nofor,",
          "3350:        TranslationTableHeader **table)",
          "3351: {",
          "3352:   int k;",
          "3353:   TranslationTableCharacter *upperChar;",
          "3354:   TranslationTableCharacter *lowerChar;",
          "3355:   TranslationTableCharacter *upperCell = NULL;",
          "3356:   TranslationTableCharacter *lowerCell = NULL;",
          "3357:   CharsString ruleChars;",
          "3358:   CharsString ruleDots;",
          "3359:   CharsString upperDots;",
          "3360:   CharsString lowerDots;",
          "3361:   int haveLowerDots = 0;",
          "3362:   TranslationTableCharacterAttributes attr;",
          "3363:   if (!getRuleCharsText (nested, &ruleChars, lastToken))",
          "3364:     return 0;",
          "3365:   if (!getToken (nested, &ruleDots, \"dots operand\", lastToken))",
          "3366:     return 0;",
          "3367:   for (k = 0; k < ruleDots.length && ruleDots.chars[k] != ','; k++);",
          "3368:   if (k == ruleDots.length)",
          "3369:     {",
          "3370:       if (!parseDots (nested, &upperDots, &ruleDots))",
          "3371:  return 0;",
          "3372:       lowerDots.length = upperDots.length;",
          "3373:       for (k = 0; k < upperDots.length; k++)",
          "3374:  lowerDots.chars[k] = upperDots.chars[k];",
          "3375:       lowerDots.chars[k] = 0;",
          "3376:     }",
          "3377:   else",
          "3378:     {",
          "3379:       haveLowerDots = ruleDots.length;",
          "3380:       ruleDots.length = k;",
          "3381:       if (!parseDots (nested, &upperDots, &ruleDots))",
          "3382:  return 0;",
          "3383:       ruleDots.length = 0;",
          "3384:       k++;",
          "3385:       for (; k < haveLowerDots; k++)",
          "3386:  ruleDots.chars[ruleDots.length++] = ruleDots.chars[k];",
          "3387:       if (!parseDots (nested, &lowerDots, &ruleDots))",
          "3388:  return 0;",
          "3389:     }",
          "3390:   if (ruleChars.length != 2 || upperDots.length < 1)",
          "3391:     {",
          "3392:       compileError (nested,",
          "3393:       \"Exactly two Unicode characters and at least one cell are required.\");",
          "3394:       return 0;",
          "3395:     }",
          "3396:   if (haveLowerDots && lowerDots.length < 1)",
          "3397:     {",
          "3398:       compileError (nested, \"at least one cell is required after the comma.\");",
          "3399:       return 0;",
          "3400:     }",
          "3401:   upperChar = addCharOrDots (nested, ruleChars.chars[0], 0, table);",
          "3402:   upperChar->attributes |= CTC_Letter | CTC_UpperCase;",
          "3403:   upperChar->uppercase = ruleChars.chars[0];",
          "3404:   upperChar->lowercase = ruleChars.chars[1];",
          "3405:   lowerChar = addCharOrDots (nested, ruleChars.chars[1], 0, table);",
          "3406:   lowerChar->attributes |= CTC_Letter | CTC_LowerCase;",
          "3407:   lowerChar->uppercase = ruleChars.chars[0];",
          "3408:   lowerChar->lowercase = ruleChars.chars[1];",
          "3409:   for (k = 0; k < upperDots.length; k++)",
          "3410:     if (!compile_findCharOrDots (upperDots.chars[k], 1, *table))",
          "3411:       {",
          "3412:  attr = CTC_Letter | CTC_UpperCase;",
          "3413:  upperCell = addCharOrDots (nested, upperDots.chars[k], 1, table);",
          "3414:  upperCell->attributes |= attr;",
          "3415:  upperCell->uppercase = upperCell->realchar;",
          "3416:       }",
          "3417:   if (haveLowerDots)",
          "3418:     {",
          "3419:       for (k = 0; k < lowerDots.length; k++)",
          "3420:  if (!compile_findCharOrDots (lowerDots.chars[k], 1, *table))",
          "3421:    {",
          "3422:      attr = CTC_Letter | CTC_LowerCase;",
          "3423:      lowerCell = addCharOrDots (nested, lowerDots.chars[k], 1, table);",
          "3424:      if (lowerDots.length != 1)",
          "3425:        attr = CTC_Space;",
          "3426:      lowerCell->attributes |= attr;",
          "3427:      lowerCell->lowercase = lowerCell->realchar;",
          "3428:    }",
          "3429:     }",
          "3430:   else if (upperCell != NULL && upperDots.length == 1)",
          "3431:     upperCell->attributes |= CTC_LowerCase;",
          "3432:   if (lowerDots.length == 1)",
          "3433:     putCharAndDots (nested, ruleChars.chars[1], lowerDots.chars[0], table);",
          "3434:   if (upperCell != NULL)",
          "3435:     upperCell->lowercase = lowerDots.chars[0];",
          "3436:   if (lowerCell != NULL)",
          "3437:     lowerCell->uppercase = upperDots.chars[0];",
          "3438:   if (upperDots.length == 1)",
          "3439:     putCharAndDots (nested, ruleChars.chars[0], upperDots.chars[0], table);",
          "3440:   ruleChars.length = 1;",
          "3441:   ruleChars.chars[2] = ruleChars.chars[0];",
          "3442:   ruleChars.chars[0] = ruleChars.chars[1];",
          "3443:   if (!addRule (nested, CTO_LowerCase, &ruleChars, &lowerDots, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3444:     return 0;",
          "3445:   ruleChars.chars[0] = ruleChars.chars[2];",
          "3446:   if (!addRule (nested, CTO_UpperCase, &ruleChars, &upperDots, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3447:     return 0;",
          "3448:   return 1;",
          "3454:   int numStates;",
          "3455:   HyphenationState *states;",
          "3462:   struct HyphenHashEntry *next;",
          "3463:   CharsString *key;",
          "3464:   int val;",
          "3467: typedef struct HyphenHashTab {",
          "3468:   HyphenHashEntry *entries[HYPHENHASHSIZE];",
          "3469: } HyphenHashTab;",
          "3473: hyphenStringHash (const CharsString * s)",
          "3474: {",
          "3475:   int k;",
          "3476:   unsigned int h = 0, g;",
          "3477:   for (k = 0; k < s->length; k++)",
          "3478:     {",
          "3479:       h = (h << 4) + s->chars[k];",
          "3480:       if ((g = h & 0xf0000000))",
          "3481:  {",
          "3482:    h = h ^ (g >> 24);",
          "3483:    h = h ^ g;",
          "3485:     }",
          "3486:   return h;",
          "3490: hyphenHashNew (void)",
          "3491: {",
          "3492:   HyphenHashTab *hashTab;",
          "3493:   if (!(hashTab = malloc (sizeof (HyphenHashTab))))",
          "3494:     _lou_outOfMemory ();",
          "3495:   memset (hashTab, 0, sizeof (HyphenHashTab));",
          "3496:   return hashTab;",
          "3500: hyphenHashFree (HyphenHashTab * hashTab)",
          "3501: {",
          "3502:   int i;",
          "3503:   HyphenHashEntry *e, *next;",
          "3504:   for (i = 0; i < HYPHENHASHSIZE; i++)",
          "3505:     for (e = hashTab->entries[i]; e; e = next)",
          "3506:       {",
          "3507:  next = e->next;",
          "3508:  free (e->key);",
          "3509:  free (e);",
          "3510:       }",
          "3511:   free (hashTab);",
          "3516: hyphenHashInsert (HyphenHashTab * hashTab, const CharsString * key, int val)",
          "3517: {",
          "3518:   int i, j;",
          "3519:   HyphenHashEntry *e;",
          "3520:   i = hyphenStringHash (key) % HYPHENHASHSIZE;",
          "3521:   if (!(e = malloc (sizeof (HyphenHashEntry))))",
          "3522:     _lou_outOfMemory ();",
          "3523:   e->next = hashTab->entries[i];",
          "3524:   e->key = malloc ((key->length + 1) * CHARSIZE);",
          "3525:   if (!e->key)",
          "3526:     _lou_outOfMemory ();",
          "3527:   e->key->length = key->length;",
          "3528:   for (j = 0; j < key->length; j++)",
          "3529:     e->key->chars[j] = key->chars[j];",
          "3530:   e->val = val;",
          "3531:   hashTab->entries[i] = e;",
          "3536: hyphenHashLookup (HyphenHashTab * hashTab, const CharsString * key)",
          "3537: {",
          "3538:   int i, j;",
          "3539:   HyphenHashEntry *e;",
          "3540:   if (key->length == 0)",
          "3541:     return 0;",
          "3542:   i = hyphenStringHash (key) % HYPHENHASHSIZE;",
          "3543:   for (e = hashTab->entries[i]; e; e = e->next)",
          "3544:     {",
          "3545:       if (key->length != e->key->length)",
          "3546:  continue;",
          "3547:       for (j = 0; j < key->length; j++)",
          "3548:  if (key->chars[j] != e->key->chars[j])",
          "3549:    break;",
          "3550:       if (j == key->length)",
          "3551:  return e->val;",
          "3552:     }",
          "3553:   return DEFAULTSTATE;",
          "3557: hyphenGetNewState (HyphenDict * dict, HyphenHashTab * hashTab, const",
          "3558:      CharsString * string)",
          "3559: {",
          "3560:   hyphenHashInsert (hashTab, string, dict->numStates);",
          "3562:   if (!(dict->numStates & (dict->numStates - 1)))",
          "3563:     dict->states = realloc (dict->states, (dict->numStates << 1) *",
          "3564:        sizeof (HyphenationState));",
          "3565:   if (!dict->states)",
          "3566:     _lou_outOfMemory ();",
          "3567:   dict->states[dict->numStates].hyphenPattern = 0;",
          "3568:   dict->states[dict->numStates].fallbackState = DEFAULTSTATE;",
          "3569:   dict->states[dict->numStates].numTrans = 0;",
          "3570:   dict->states[dict->numStates].trans.pointer = NULL;",
          "3571:   return dict->numStates++;",
          "3577: hyphenAddTrans (HyphenDict * dict, int state1, int state2, widechar ch)",
          "3578: {",
          "3579:   int numTrans;",
          "3580:   numTrans = dict->states[state1].numTrans;",
          "3581:   if (numTrans == 0)",
          "3582:     dict->states[state1].trans.pointer = malloc (sizeof (HyphenationTrans));",
          "3583:   else if (!(numTrans & (numTrans - 1)))",
          "3584:     dict->states[state1].trans.pointer = realloc",
          "3585:       (dict->states[state1].trans.pointer,",
          "3586:        (numTrans << 1) * sizeof (HyphenationTrans));",
          "3587:   dict->states[state1].trans.pointer[numTrans].ch = ch;",
          "3588:   dict->states[state1].trans.pointer[numTrans].newState = state2;",
          "3589:   dict->states[state1].numTrans++;",
          "3593: compileHyphenation (FileInfo * nested, CharsString * encoding,",
          "3594:       int *lastToken,",
          "3595:       TranslationTableHeader **table)",
          "3596: {",
          "3597:   CharsString hyph;",
          "3598:   HyphenationTrans *holdPointer;",
          "3599:   HyphenHashTab *hashTab;",
          "3600:   CharsString word;",
          "3601:   char pattern[MAXSTRING];",
          "3602:   unsigned int stateNum = 0, lastState = 0;",
          "3603:   int i, j, k = encoding->length;",
          "3604:   widechar ch;",
          "3605:   int found;",
          "3606:   HyphenHashEntry *e;",
          "3607:   HyphenDict dict;",
          "3608:   TranslationTableOffset holdOffset;",
          "3611:   reserveSpaceInTable (nested, 250000, table);",
          "3612:   hashTab = hyphenHashNew ();",
          "3613:   dict.numStates = 1;",
          "3614:   dict.states = malloc (sizeof (HyphenationState));",
          "3615:   if (!dict.states)",
          "3616:     _lou_outOfMemory ();",
          "3617:   dict.states[0].hyphenPattern = 0;",
          "3618:   dict.states[0].fallbackState = DEFAULTSTATE;",
          "3619:   dict.states[0].numTrans = 0;",
          "3620:   dict.states[0].trans.pointer = NULL;",
          "3621:   do",
          "3622:     {",
          "3623:       if (encoding->chars[0] == 'I')",
          "3624:  {",
          "3625:    if (!getToken (nested, &hyph, NULL, lastToken))",
          "3626:      continue;",
          "3627:  }",
          "3628:       else",
          "3629:  {",
          "3631:    if (!getToken (nested, &word, NULL, lastToken))",
          "3632:      continue;",
          "3633:    parseChars (nested, &hyph, &word);",
          "3634:  }",
          "3635:       if (hyph.length == 0 || hyph.chars[0] == '#' || hyph.chars[0] ==",
          "3636:    '%' || hyph.chars[0] == '<')",
          "3638:       for (i = 0; i < hyph.length; i++)",
          "3639:  definedCharOrDots (nested, hyph.chars[i], 0, *table);",
          "3640:       j = 0;",
          "3641:       pattern[j] = '0';",
          "3642:       for (i = 0; i < hyph.length; i++)",
          "3643:  {",
          "3644:    if (hyph.chars[i] >= '0' && hyph.chars[i] <= '9')",
          "3645:      pattern[j] = (char) hyph.chars[i];",
          "3646:    else",
          "3647:      {",
          "3648:        word.chars[j] = hyph.chars[i];",
          "3649:        pattern[++j] = '0';",
          "3650:      }",
          "3651:  }",
          "3652:       word.chars[j] = 0;",
          "3653:       word.length = j;",
          "3654:       pattern[j + 1] = 0;",
          "3655:       for (i = 0; pattern[i] == '0'; i++);",
          "3656:       found = hyphenHashLookup (hashTab, &word);",
          "3657:       if (found != DEFAULTSTATE)",
          "3658:  stateNum = found;",
          "3659:       else",
          "3660:  stateNum = hyphenGetNewState (&dict, hashTab, &word);",
          "3661:       k = j + 2 - i;",
          "3662:       if (k > 0)",
          "3663:  {",
          "3664:    allocateSpaceInTable (nested,",
          "3665:     &dict.states[stateNum].hyphenPattern, k, table);",
          "3666:    memcpy (&(*table)->ruleArea[dict.states[stateNum].hyphenPattern],",
          "3667:     &pattern[i], k);",
          "3668:  }",
          "3670:       while (found == DEFAULTSTATE)",
          "3671:  {",
          "3672:    lastState = stateNum;",
          "3673:    ch = word.chars[word.length-- - 1];",
          "3674:    found = hyphenHashLookup (hashTab, &word);",
          "3675:    if (found != DEFAULTSTATE)",
          "3676:      stateNum = found;",
          "3677:    else",
          "3678:      stateNum = hyphenGetNewState (&dict, hashTab, &word);",
          "3679:    hyphenAddTrans (&dict, stateNum, lastState, ch);",
          "3680:  }",
          "3681:     }",
          "3682:   while (_lou_getALine (nested));",
          "3684:   for (i = 0; i < HYPHENHASHSIZE; i++)",
          "3685:     {",
          "3686:       for (e = hashTab->entries[i]; e; e = e->next)",
          "3687:  {",
          "3688:    for (j = 1; j <= e->key->length; j++)",
          "3689:      {",
          "3690:        word.length = 0;",
          "3691:        for (k = j; k < e->key->length; k++)",
          "3692:   word.chars[word.length++] = e->key->chars[k];",
          "3693:        stateNum = hyphenHashLookup (hashTab, &word);",
          "3694:        if (stateNum != DEFAULTSTATE)",
          "3695:   break;",
          "3696:      }",
          "3697:    if (e->val)",
          "3698:      dict.states[e->val].fallbackState = stateNum;",
          "3700:     }",
          "3701:   hyphenHashFree (hashTab);",
          "3703:   for (i = 0; i < dict.numStates; i++)",
          "3704:     {",
          "3705:       if (dict.states[i].numTrans == 0)",
          "3706:  dict.states[i].trans.offset = 0;",
          "3707:       else",
          "3708:  {",
          "3709:    holdPointer = dict.states[i].trans.pointer;",
          "3710:    allocateSpaceInTable (nested,",
          "3711:     &dict.states[i].trans.offset,",
          "3712:     dict.states[i].numTrans *",
          "3713:     sizeof (HyphenationTrans), table);",
          "3714:    memcpy (&(*table)->ruleArea[dict.states[i].trans.offset],",
          "3715:     holdPointer,",
          "3716:     dict.states[i].numTrans * sizeof (HyphenationTrans));",
          "3717:    free (holdPointer);",
          "3719:     }",
          "3720:   allocateSpaceInTable (nested,",
          "3721:    &holdOffset, dict.numStates *",
          "3722:    sizeof (HyphenationState), table);",
          "3723:   (*table)->hyphenStatesArray = holdOffset;",
          "3725:   memcpy (&(*table)->ruleArea[(*table)->hyphenStatesArray], &dict.states[0],",
          "3726:    dict.numStates * sizeof (HyphenationState));",
          "3727:   free (dict.states);",
          "3728:   return 1;",
          "3732: compileCharDef (FileInfo * nested,",
          "3733:   TranslationTableOpcode opcode,",
          "3734:   TranslationTableCharacterAttributes attributes,",
          "3735:   int *lastToken,",
          "3736:   TranslationTableOffset *newRuleOffset,",
          "3737:   TranslationTableRule **newRule,",
          "3738:   int noback, int nofor,",
          "3739:   TranslationTableHeader **table)",
          "3740: {",
          "3741:   CharsString ruleChars;",
          "3742:   CharsString ruleDots;",
          "3743:   TranslationTableCharacter *character;",
          "3744:   TranslationTableCharacter *cell = NULL;",
          "3745:   int k;",
          "3746:   if (!getRuleCharsText (nested, &ruleChars, lastToken))",
          "3747:     return 0;",
          "3748:   if (!getRuleDotsPattern (nested, &ruleDots, lastToken))",
          "3749:     return 0;",
          "3750:   if (ruleChars.length != 1)",
          "3751:     {",
          "3752:       compileError (nested, \"Exactly one character is required.\");",
          "3753:       return 0;",
          "3754:     }",
          "3755:   if (ruleDots.length < 1)",
          "3756:     {",
          "3757:       compileError (nested, \"At least one cell is required.\");",
          "3758:       return 0;",
          "3759:     }",
          "3760:   if (attributes & (CTC_UpperCase | CTC_LowerCase))",
          "3761:     attributes |= CTC_Letter;",
          "3762:   character = addCharOrDots (nested, ruleChars.chars[0], 0, table);",
          "3763:   character->attributes |= attributes;",
          "3764:   character->uppercase = character->lowercase = character->realchar;",
          "3765:   for (k = ruleDots.length-1; k >= 0; k -= 1)",
          "3766:     {",
          "3767:       cell = compile_findCharOrDots (ruleDots.chars[k], 1, *table);",
          "3768:       if (!cell)",
          "3769:  {",
          "3770:    cell = addCharOrDots (nested, ruleDots.chars[k], 1, table);",
          "3771:    cell->uppercase = cell->lowercase = cell->realchar;",
          "3773:     }",
          "3774:   if (ruleDots.length == 1)",
          "3775:     {",
          "3776:       cell->attributes |= attributes;",
          "3777:       putCharAndDots (nested, ruleChars.chars[0], ruleDots.chars[0], table);",
          "3778:     }",
          "3779:   if (!addRule (nested, opcode, &ruleChars, &ruleDots, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3780:     return 0;",
          "3781:   return 1;",
          "3785: compileBeforeAfter(FileInfo * nested,",
          "3786:      int *lastToken)",
          "3787: {",
          "3793:     if (eqasc2uni((unsigned char *)\"before\", tmp.chars, 6)) return 1;",
          "3794:     if (eqasc2uni((unsigned char *)\"after\", tmp.chars, 5)) return 2;",
          "3800: compileRule (FileInfo * nested,",
          "3801:       CharacterClass **characterClasses,",
          "3802:       TranslationTableCharacterAttributes *characterClassAttribute,",
          "3803:       short opcodeLengths[],",
          "3804:       TranslationTableOffset *newRuleOffset,",
          "3805:       TranslationTableRule **newRule,",
          "3806:       RuleName **ruleNames,",
          "3807:       TranslationTableHeader **table)",
          "3808: {",
          "3809:   int lastToken = 0;",
          "3810:   int ok = 1;",
          "3811:   CharsString token;",
          "3812:   TranslationTableOpcode opcode;",
          "3813:   CharsString ruleChars;",
          "3814:   CharsString ruleDots;",
          "3815:   CharsString cells;",
          "3816:   CharsString scratchPad;",
          "3817:   CharsString emphClass;",
          "3818:   TranslationTableCharacterAttributes after = 0;",
          "3819:   TranslationTableCharacterAttributes before = 0;",
          "3821:   widechar *patterns = NULL;",
          "3822:   int k, i;",
          "3823:   int noback, nofor;",
          "3824:   noback = nofor = 0;",
          "3825:   TranslationTableOffset tmp_offset;",
          "3827:   if (!getToken (nested, &token, NULL, &lastToken))",
          "3829:   if (token.chars[0] == '#' || token.chars[0] == '<')",
          "3831:   if (nested->lineNumber == 1 && (eqasc2uni ((unsigned char *) \"ISO\",",
          "3832:           token.chars, 3) ||",
          "3833:       eqasc2uni ((unsigned char *) \"UTF-8\",",
          "3834:           token.chars, 5)))",
          "3835:     {",
          "3836:       compileHyphenation (nested, &token, &lastToken, table);",
          "3837:       return 1;",
          "3838:     }",
          "3839:   opcode = getOpcode (nested, &token, opcodeLengths);",
          "3841:   switch (opcode)",
          "3843:     case CTO_None:",
          "3844:       break;",
          "3845:     case CTO_IncludeFile:",
          "3846:       {",
          "3847:  CharsString includedFile;",
          "3848:  if (getToken (nested, &token, \"include file name\", &lastToken))",
          "3849:    if (parseChars (nested, &includedFile, &token))",
          "3850:      if (!includeFile (nested, &includedFile, characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, table))",
          "3851:        ok = 0;",
          "3852:  break;",
          "3853:       }",
          "3854:     case CTO_Locale:",
          "3855:       break;",
          "3856:     case CTO_Undefined:",
          "3857:       tmp_offset = (*table)->undefined;",
          "3858:       ok =",
          "3859:  compileBrailleIndicator (nested, \"undefined character opcode\",",
          "3860:      CTO_Undefined, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3861:       (*table)->undefined = tmp_offset;",
          "3862:       break;",
          "3864:     case CTO_Match:",
          "3865:       {",
          "3866:  CharsString ptn_before, ptn_after;",
          "3867:  TranslationTableOffset offset;",
          "3868:  int len, mrk;",
          "3870:  size_t patternsByteSize = sizeof(*patterns) * 27720;",
          "3871:  patterns = (widechar*) malloc(patternsByteSize);",
          "3872:  if(!patterns)",
          "3873:    _lou_outOfMemory();",
          "3874:  memset(patterns, 0xffff, patternsByteSize);",
          "3876:  noback = 1;",
          "3877:  getCharacters(nested, &ptn_before, &lastToken);",
          "3878:  getRuleCharsText(nested, &ruleChars, &lastToken);",
          "3879:  getCharacters(nested, &ptn_after, &lastToken);",
          "3880:  getRuleDotsPattern(nested, &ruleDots, &lastToken);",
          "3882:  if(!addRule(nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "3883:    ok = 0;",
          "3885:  if(ptn_before.chars[0] == '-' && ptn_before.length == 1)",
          "3886:    len = _lou_pattern_compile(&ptn_before.chars[0], 0, &patterns[1], 13841, *table);",
          "3887:  else",
          "3888:    len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length, &patterns[1], 13841, *table);",
          "3889:  if(!len)",
          "3890:    {",
          "3891:      ok = 0;",
          "3892:      break;",
          "3893:    }",
          "3894:  mrk = patterns[0] = len + 1;",
          "3895:  _lou_pattern_reverse(&patterns[1]);",
          "3897:  if(ptn_after.chars[0] == '-' && ptn_after.length == 1)",
          "3898:    len = _lou_pattern_compile(&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table);",
          "3899:  else",
          "3900:    len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length, &patterns[mrk], 13841, *table);",
          "3901:  if(!len)",
          "3902:    {",
          "3903:      ok = 0;",
          "3904:      break;",
          "3905:    }",
          "3906:  len += mrk;",
          "3908:  if(!allocateSpaceInTable(nested, &offset, len * sizeof(widechar), table))",
          "3909:    {",
          "3910:      ok = 0;",
          "3911:      break;",
          "3912:    }",
          "3917:  memcpy(&(*table)->ruleArea[offset], patterns, len * sizeof(widechar));",
          "3918:  (*newRule)->patterns = offset;",
          "3920:  break;",
          "3921:       }",
          "3923:     case CTO_BackMatch:",
          "3924:       {",
          "3925:  CharsString ptn_before, ptn_after;",
          "3926:  TranslationTableOffset offset;",
          "3927:  int len, mrk;",
          "3929:  size_t patternsByteSize = sizeof(*patterns) * 27720;",
          "3930:  patterns = (widechar*) malloc(patternsByteSize);",
          "3931:  if(!patterns)",
          "3932:    _lou_outOfMemory();",
          "3933:  memset(patterns, 0xffff, patternsByteSize);",
          "3935:  nofor = 1;",
          "3936:  getCharacters(nested, &ptn_before, &lastToken);",
          "3937:  getRuleCharsText(nested, &ruleChars, &lastToken);",
          "3938:  getCharacters(nested, &ptn_after, &lastToken);",
          "3939:  getRuleDotsPattern(nested, &ruleDots, &lastToken);",
          "3941:  if(!addRule(nested, opcode, &ruleChars, &ruleDots, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "3942:    ok = 0;",
          "3944:  if(ptn_before.chars[0] == '-' && ptn_before.length == 1)",
          "3945:    len = _lou_pattern_compile(&ptn_before.chars[0], 0, &patterns[1], 13841, *table);",
          "3946:  else",
          "3947:    len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length, &patterns[1], 13841, *table);",
          "3948:  if(!len)",
          "3949:    {",
          "3950:      ok = 0;",
          "3951:      break;",
          "3952:    }",
          "3953:  mrk = patterns[0] = len + 1;",
          "3954:  _lou_pattern_reverse(&patterns[1]);",
          "3956:  if(ptn_after.chars[0] == '-' && ptn_after.length == 1)",
          "3957:    len = _lou_pattern_compile(&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table);",
          "3958:  else",
          "3959:    len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length, &patterns[mrk], 13841, *table);",
          "3960:  if(!len)",
          "3961:    {",
          "3962:      ok = 0;",
          "3963:      break;",
          "3964:    }",
          "3965:  len += mrk;",
          "3967:  if(!allocateSpaceInTable(nested, &offset, len * sizeof(widechar), table))",
          "3968:    {",
          "3969:      ok = 0;",
          "3970:      break;",
          "3971:    }",
          "3976:  memcpy(&(*table)->ruleArea[offset], patterns, len * sizeof(widechar));",
          "3977:  (*newRule)->patterns = offset;",
          "3979:  break;",
          "3980:       }",
          "3982:     case CTO_BegCapsPhrase:",
          "3983:       tmp_offset = (*table)->emphRules[capsRule][begPhraseOffset];",
          "3984:       ok =",
          "3985:  compileBrailleIndicator (nested, \"first word capital sign\",",
          "3986:      CTO_BegCapsPhraseRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3987:       (*table)->emphRules[capsRule][begPhraseOffset] = tmp_offset;",
          "3988:       break;",
          "3989:     case CTO_EndCapsPhrase:",
          "3991:    case 1: // before",
          "3992:     if ((*table)->emphRules[capsRule][endPhraseAfterOffset]) {",
          "3993:      compileError (nested, \"Capital sign after last word already defined.\");",
          "3994:      ok = 0;",
          "3995:      break;",
          "3996:     }",
          "3997:     tmp_offset = (*table)->emphRules[capsRule][endPhraseBeforeOffset];",
          "3998:     ok =",
          "3999:      compileBrailleIndicator (nested, \"capital sign before last word\",",
          "4000:       CTO_EndCapsPhraseBeforeRule, &tmp_offset,",
          "4001:       &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4002:     (*table)->emphRules[capsRule][endPhraseBeforeOffset] = tmp_offset;",
          "4003:     break;",
          "4004:    case 2: // after",
          "4005:     if ((*table)->emphRules[capsRule][endPhraseBeforeOffset]) {",
          "4006:      compileError (nested, \"Capital sign before last word already defined.\");",
          "4007:      ok = 0;",
          "4008:      break;",
          "4009:     }",
          "4010:     tmp_offset = (*table)->emphRules[capsRule][endPhraseAfterOffset];",
          "4011:     ok =",
          "4012:      compileBrailleIndicator (nested, \"capital sign after last word\",",
          "4013:       CTO_EndCapsPhraseAfterRule, &tmp_offset,",
          "4014:       &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4015:     (*table)->emphRules[capsRule][endPhraseAfterOffset] = tmp_offset;",
          "4017:    default: // error",
          "4018:     compileError (nested, \"Invalid lastword indicator location.\");",
          "4022:       break;",
          "4023:    case CTO_BegCaps:",
          "4024:  tmp_offset = (*table)->emphRules[capsRule][begOffset];",
          "4025:       ok =",
          "4026:  compileBrailleIndicator (nested, \"first letter capital sign\",",
          "4027:      CTO_BegCapsRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4028:  (*table)->emphRules[capsRule][begOffset] = tmp_offset;",
          "4030:    case CTO_EndCaps:",
          "4031:  tmp_offset = (*table)->emphRules[capsRule][endOffset];",
          "4032:       ok =",
          "4033:  compileBrailleIndicator (nested, \"last letter capital sign\",",
          "4034:      CTO_EndCapsRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4035:  (*table)->emphRules[capsRule][endOffset] = tmp_offset;",
          "4036:       break;",
          "4037:    case CTO_CapsLetter:",
          "4038:  tmp_offset = (*table)->emphRules[capsRule][letterOffset];",
          "4039:       ok =",
          "4040:  compileBrailleIndicator (nested, \"single letter capital sign\",",
          "4041:      CTO_CapsLetterRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4042:  (*table)->emphRules[capsRule][letterOffset] = tmp_offset;",
          "4043:       break;",
          "4044:     case CTO_BegCapsWord:",
          "4045:  tmp_offset = (*table)->emphRules[capsRule][begWordOffset];",
          "4046:       ok =",
          "4047:  compileBrailleIndicator (nested, \"capital word\", CTO_BegCapsWordRule,",
          "4048:      &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4049:  (*table)->emphRules[capsRule][begWordOffset] = tmp_offset;",
          "4050:       break;",
          "4051:  case CTO_EndCapsWord:",
          "4052:  tmp_offset = (*table)->emphRules[capsRule][endWordOffset];",
          "4053:   ok = compileBrailleIndicator(nested, \"capital word stop\",",
          "4054:      CTO_EndCapsWordRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4055:  (*table)->emphRules[capsRule][endWordOffset] = tmp_offset;",
          "4056:       break;",
          "4057:     case CTO_LenCapsPhrase:",
          "4058:       ok = (*table)->emphRules[capsRule][lenPhraseOffset] = compileNumber (nested, &lastToken);",
          "4059:       break;",
          "4071:     case CTO_EmphClass:",
          "4072:       if (getToken(nested, &token, \"emphasis class\", &lastToken))",
          "4073:  if (parseChars(nested, &emphClass, &token))",
          "4074:    {",
          "4075:      char * s = malloc(sizeof(char) * (emphClass.length + 1));",
          "4076:      for (k = 0; k < emphClass.length; k++)",
          "4077:        s[k] = (char)emphClass.chars[k];",
          "4078:      s[k++] = '\\0';",
          "4079:      for (i = 0; (*table)->emphClasses[i]; i++)",
          "4080:        if (strcmp(s, (*table)->emphClasses[i]) == 0)",
          "4081:   {",
          "4082:     _lou_logMessage (LOG_WARN, \"Duplicate emphasis class: %s\", s);",
          "4083:     warningCount++;",
          "4084:     free(s);",
          "4085:     return 1;",
          "4086:   }",
          "4087:      if (i < MAX_EMPH_CLASSES)",
          "4088:        {",
          "4089:   switch (i)",
          "4090:     {",
          "4107:     case 0:",
          "4108:       if (strcmp(s, \"italic\") != 0)",
          "4109:         {",
          "4110:    _lou_logMessage (LOG_ERROR, \"First emphasis class must be \\\"italic\\\" but got %s\", s);",
          "4111:    errorCount++;",
          "4112:    free(s);",
          "4113:    return 0;",
          "4114:         }",
          "4115:       break;",
          "4116:     case 1:",
          "4117:       if (strcmp(s, \"underline\") != 0)",
          "4118:         {",
          "4119:    _lou_logMessage (LOG_ERROR, \"Second emphasis class must be \\\"underline\\\" but got %s\", s);",
          "4120:    errorCount++;",
          "4121:    free(s);",
          "4122:    return 0;",
          "4123:         }",
          "4124:       break;",
          "4125:     case 2:",
          "4126:       if (strcmp(s, \"bold\") != 0)",
          "4127:         {",
          "4128:    _lou_logMessage (LOG_ERROR, \"Third emphasis class must be \\\"bold\\\" but got %s\", s);",
          "4129:    errorCount++;",
          "4130:    free(s);",
          "4131:    return 0;",
          "4132:         }",
          "4133:       break;",
          "4134:     }",
          "4135:   (*table)->emphClasses[i] = s;",
          "4136:   (*table)->emphClasses[i+1] = NULL;",
          "4137:   ok = 1;",
          "4139:        }",
          "4140:      else",
          "4141:        {",
          "4142:   _lou_logMessage (LOG_ERROR, \"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);",
          "4143:   errorCount++;",
          "4144:   free(s);",
          "4145:   ok = 0;",
          "4147:        }",
          "4148:    }",
          "4149:       compileError (nested, \"emphclass must be followed by a valid class name.\");",
          "4150:       ok = 0;",
          "4151:       break;",
          "4152:     case CTO_EmphLetter:",
          "4153:     case CTO_BegEmphWord:",
          "4154:     case CTO_EndEmphWord:",
          "4155:     case CTO_BegEmph:",
          "4156:     case CTO_EndEmph:",
          "4157:     case CTO_BegEmphPhrase:",
          "4158:     case CTO_EndEmphPhrase:",
          "4159:     case CTO_LenEmphPhrase:",
          "4160:       ok = 0;",
          "4161:       if (getToken(nested, &token, \"emphasis class\", &lastToken))",
          "4162:  if (parseChars(nested, &emphClass, &token))",
          "4163:    {",
          "4164:      char * s = malloc(sizeof(char) * (emphClass.length + 1));",
          "4165:      for (k = 0; k < emphClass.length; k++)",
          "4166:        s[k] = (char)emphClass.chars[k];",
          "4167:      s[k++] = '\\0';",
          "4168:      for (i = 0; (*table)->emphClasses[i]; i++)",
          "4169:        if (strcmp(s, (*table)->emphClasses[i]) == 0)",
          "4170:    break;",
          "4171:      if (!(*table)->emphClasses[i])",
          "4172:        {",
          "4173:   _lou_logMessage (LOG_ERROR, \"Emphasis class %s not declared\", s);",
          "4174:   errorCount++;",
          "4175:   free(s);",
          "4177:        }",
          "4178:   i++; // in table->emphRules the first index is used for caps",
          "4179:   if (opcode == CTO_EmphLetter) {",
          "4180:    tmp_offset = (*table)->emphRules[i][letterOffset];",
          "4181:    ok = compileBrailleIndicator (nested, \"single letter\",",
          "4182:     CTO_Emph1LetterRule + letterOffset + (8 * i),",
          "4183:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4184:    (*table)->emphRules[i][letterOffset] = tmp_offset;",
          "4185:   }",
          "4186:   else if (opcode == CTO_BegEmphWord) {",
          "4187:    tmp_offset = (*table)->emphRules[i][begWordOffset];",
          "4188:    ok = compileBrailleIndicator (nested, \"word\",",
          "4189:     CTO_Emph1LetterRule + begWordOffset + (8 * i),",
          "4190:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4191:    (*table)->emphRules[i][begWordOffset] = tmp_offset;",
          "4192:   }",
          "4193:   else if (opcode == CTO_EndEmphWord) {",
          "4194:    tmp_offset = (*table)->emphRules[i][endWordOffset];",
          "4195:    ok = compileBrailleIndicator(nested, \"word stop\",",
          "4196:     CTO_Emph1LetterRule + endWordOffset + (8 * i),",
          "4197:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4198:    (*table)->emphRules[i][endWordOffset] = tmp_offset;",
          "4199:   }",
          "4200:   else if (opcode == CTO_BegEmph) {",
          "4202:     if ((*table)->emphRules[i][begWordOffset] || (*table)->emphRules[i][begPhraseOffset]) {",
          "4203:       compileError (nested, \"Cannot define emphasis for both no context and word or phrase context, i.e. cannot have both begemph and begemphword or begemphphrase.\");",
          "4204:       ok = 0;",
          "4205:       break;",
          "4206:     }",
          "4207:    tmp_offset = (*table)->emphRules[i][begOffset];",
          "4208:    ok = compileBrailleIndicator (nested, \"first letter\",",
          "4209:     CTO_Emph1LetterRule + begOffset + (8 * i),",
          "4210:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4211:    (*table)->emphRules[i][begOffset] = tmp_offset;",
          "4212:   }",
          "4213:   else if (opcode == CTO_EndEmph) {",
          "4214:     if ((*table)->emphRules[i][endWordOffset] || (*table)->emphRules[i][endPhraseBeforeOffset] || (*table)->emphRules[i][endPhraseAfterOffset]) {",
          "4215:       compileError (nested, \"Cannot define emphasis for both no context and word or phrase context, i.e. cannot have both endemph and endemphword or endemphphrase.\");",
          "4216:       ok = 0;",
          "4217:       break;",
          "4218:     }",
          "4219:    tmp_offset = (*table)->emphRules[i][endOffset];",
          "4220:    ok = compileBrailleIndicator (nested, \"last letter\",",
          "4221:     CTO_Emph1LetterRule + endOffset + (8 * i),",
          "4223:    (*table)->emphRules[i][endOffset] = tmp_offset;",
          "4224:   }",
          "4225:   else if (opcode == CTO_BegEmphPhrase) {",
          "4226:    tmp_offset = (*table)->emphRules[i][begPhraseOffset];",
          "4227:    ok = compileBrailleIndicator (nested, \"first word\",",
          "4228:     CTO_Emph1LetterRule + begPhraseOffset + (8 * i),",
          "4230:    (*table)->emphRules[i][begPhraseOffset] = tmp_offset;",
          "4231:   }",
          "4232:   else if (opcode == CTO_EndEmphPhrase)",
          "4233:    switch (compileBeforeAfter(nested, &lastToken)) {",
          "4234:     case 1: // before",
          "4235:      if ((*table)->emphRules[i][endPhraseAfterOffset]) {",
          "4236:       compileError (nested, \"last word after already defined.\");",
          "4237:       ok = 0;",
          "4238:       break;",
          "4240:      tmp_offset = (*table)->emphRules[i][endPhraseBeforeOffset];",
          "4241:      ok = compileBrailleIndicator (nested, \"last word before\",",
          "4242:       CTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),",
          "4243:       &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4244:      (*table)->emphRules[i][endPhraseBeforeOffset] = tmp_offset;",
          "4245:      break;",
          "4246:     case 2: // after",
          "4247:      if ((*table)->emphRules[i][endPhraseBeforeOffset]) {",
          "4248:       compileError (nested, \"last word before already defined.\");",
          "4249:       ok = 0;",
          "4252:      tmp_offset = (*table)->emphRules[i][endPhraseAfterOffset];",
          "4253:      ok = compileBrailleIndicator (nested, \"last word after\",",
          "4254:       CTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),",
          "4255:       &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4256:      (*table)->emphRules[i][endPhraseAfterOffset] = tmp_offset;",
          "4258:     default: // error",
          "4259:      compileError (nested, \"Invalid lastword indicator location.\");",
          "4263:   else if (opcode == CTO_LenEmphPhrase)",
          "4264:    ok = (*table)->emphRules[i][lenPhraseOffset] = compileNumber (nested, &lastToken);",
          "4265:   free(s);",
          "4266:    }",
          "4267:  break;",
          "4269:     case CTO_LetterSign:",
          "4270:       tmp_offset = (*table)->letterSign;",
          "4271:       ok =",
          "4272:  compileBrailleIndicator (nested, \"letter sign\", CTO_LetterRule,",
          "4273:      &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4274:        (*table)->letterSign = tmp_offset;",
          "4275:       break;",
          "4276:     case CTO_NoLetsignBefore:",
          "4277:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4278:  {",
          "4279:    if (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNSIZE)",
          "4280:      {",
          "4281:        compileError (nested, \"More than %d characters\", LETSIGNSIZE);",
          "4282:        ok = 0;",
          "4283:        break;",
          "4284:      }",
          "4285:    for (k = 0; k < ruleChars.length; k++)",
          "4286:      (*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =",
          "4287:        ruleChars.chars[k];",
          "4288:  }",
          "4289:       break;",
          "4290:     case CTO_NoLetsign:",
          "4291:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4292:  {",
          "4293:    if (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE)",
          "4294:      {",
          "4295:        compileError (nested, \"More than %d characters\", LETSIGNSIZE);",
          "4296:        ok = 0;",
          "4297:        break;",
          "4298:      }",
          "4299:    for (k = 0; k < ruleChars.length; k++)",
          "4300:      (*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];",
          "4301:  }",
          "4302:       break;",
          "4303:     case CTO_NoLetsignAfter:",
          "4304:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4305:  {",
          "4306:    if (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNSIZE)",
          "4307:      {",
          "4308:        compileError (nested, \"More than %d characters\", LETSIGNSIZE);",
          "4309:        ok = 0;",
          "4310:        break;",
          "4311:      }",
          "4312:    for (k = 0; k < ruleChars.length; k++)",
          "4313:      (*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =",
          "4314:        ruleChars.chars[k];",
          "4315:  }",
          "4316:       break;",
          "4317:     case CTO_NumberSign:",
          "4318:       tmp_offset = (*table)->numberSign;",
          "4319:       ok =",
          "4320:  compileBrailleIndicator (nested, \"number sign\", CTO_NumberRule,",
          "4321:      &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4322:       (*table)->numberSign = tmp_offset;",
          "4323:       break;",
          "4329:   if(!getToken(nested, &ruleChars, \"attribute number\", &lastToken))",
          "4330:   {",
          "4337:   switch(ruleChars.chars[0])",
          "4338:   {",
          "4339:   case '0':  k = 0;  break;",
          "4340:   case '1':  k = 1;  break;",
          "4341:   case '2':  k = 2;  break;",
          "4342:   case '3':  k = 3;  break;",
          "4343:   case '4':  k = 4;  break;",
          "4344:   case '5':  k = 5;  break;",
          "4345:   case '6':  k = 6;  break;",
          "4346:   case '7':  k = 7;  break;",
          "4348:   if(k == -1)",
          "4349:   {",
          "4355:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4356:   {",
          "4357:    for(i = 0; i < ruleChars.length; i++)",
          "4358:    {",
          "4360:     if(c)",
          "4362:     else",
          "4363:     {",
          "",
          "[Added Lines]",
          "528: unknownDots(widechar dots) {",
          "529:  static char buffer[20];",
          "530:  int k = 1;",
          "531:  buffer[0] = '\\\\';",
          "532:  for (int mappingPos = 0; dotMapping[mappingPos].key; mappingPos++) {",
          "533:   if (dots & dotMapping[mappingPos].key) buffer[k++] = dotMapping[mappingPos].value;",
          "534:  }",
          "535:  buffer[k++] = '/';",
          "536:  buffer[k] = 0;",
          "537:  return buffer;",
          "544: charactersDefined(",
          "545:   FileInfo *nested, TranslationTableRule *newRule, TranslationTableHeader *table) {",
          "548:  int noErrors = 1;",
          "549:  int k;",
          "550:  if ((newRule->opcode >= CTO_Space && newRule->opcode <= CTO_LitDigit) ||",
          "551:    newRule->opcode == CTO_SwapDd || newRule->opcode == CTO_Replace ||",
          "552:    newRule->opcode == CTO_MultInd || newRule->opcode == CTO_Repeated ||",
          "553:    ((newRule->opcode >= CTO_Context && newRule->opcode <= CTO_Pass4) &&",
          "554:      newRule->opcode != CTO_Correct) ||",
          "555:    newRule->opcode == CTO_Match)",
          "556:   return 1;",
          "557:  for (k = 0; k < newRule->charslen; k++)",
          "558:   if (!compile_findCharOrDots(newRule->charsdots[k], 0, table)) {",
          "559:    compileError(nested, \"Character %s is not defined\",",
          "560:      _lou_showString(&newRule->charsdots[k], 1));",
          "561:    noErrors = 0;",
          "562:   }",
          "563:  if (!(newRule->opcode == CTO_Correct || newRule->opcode == CTO_SwapCc ||",
          "564:     newRule->opcode == CTO_SwapCd)",
          "566:    &&",
          "567:    !(newRule->opcode >= CTO_CapsLetterRule &&",
          "568:      newRule->opcode <= CTO_EndEmph10PhraseAfterRule)) {",
          "569:   for (k = newRule->charslen; k < newRule->charslen + newRule->dotslen; k++)",
          "570:    if (!compile_findCharOrDots(newRule->charsdots[k], 1, table)) {",
          "571:     compileError(nested, \"Dot pattern %s is not defined.\",",
          "572:       unknownDots(newRule->charsdots[k]));",
          "573:     noErrors = 0;",
          "574:    }",
          "575:  }",
          "576:  return noErrors;",
          "580: getPartName(int actionPart) {",
          "581:  return actionPart ? \"action\" : \"test\";",
          "585: passFindCharacters(FileInfo *nested, int actionPart, widechar *instructions, int end,",
          "586:   widechar **characters, int *length) {",
          "587:  int IC = 0;",
          "588:  int finding = !actionPart;",
          "593:  while (IC < end) {",
          "594:   widechar instruction = instructions[IC];",
          "596:   switch (instruction) {",
          "597:   case pass_string:",
          "598:   case pass_dots: {",
          "599:    int count = instructions[IC + 1];",
          "600:    IC += 2;",
          "602:    if (finding) {",
          "605:     return 1;",
          "606:    }",
          "608:    IC += count;",
          "609:    continue;",
          "610:   }",
          "612:   case pass_attributes:",
          "613:    IC += 5;",
          "614:    goto NO_CHARACTERS;",
          "616:   case pass_swap:",
          "618:    if (!actionPart != !finding) IC += 2;",
          "621:   case pass_groupstart:",
          "622:   case pass_groupend:",
          "623:   case pass_groupreplace:",
          "624:    IC += 3;",
          "626:   NO_CHARACTERS : {",
          "627:    if (finding) return 1;",
          "628:    continue;",
          "631:   case pass_eq:",
          "632:   case pass_lt:",
          "633:   case pass_gt:",
          "634:   case pass_lteq:",
          "635:   case pass_gteq:",
          "636:    IC += 3;",
          "637:    continue;",
          "639:   case pass_lookback:",
          "640:    IC += 2;",
          "641:    continue;",
          "643:   case pass_not:",
          "644:   case pass_startReplace:",
          "645:   case pass_endReplace:",
          "646:   case pass_first:",
          "647:   case pass_last:",
          "648:   case pass_copy:",
          "649:   case pass_omit:",
          "650:   case pass_plus:",
          "651:   case pass_hyphen:",
          "652:    IC += 1;",
          "653:    continue;",
          "655:   case pass_endTest:",
          "656:    if (finding) goto NOT_FOUND;",
          "657:    finding = 1;",
          "658:    IC += 1;",
          "659:    continue;",
          "661:   default:",
          "662:    compileError(nested, \"unhandled %s suboperand: \\\\x%02x\",",
          "663:      getPartName(actionPart), instruction);",
          "664:    return 0;",
          "665:   }",
          "669:  compileError(nested,",
          "670:    \"characters, dots, attributes, or class swap not found in %s part\",",
          "671:    getPartName(actionPart));",
          "673:  return 0;",
          "679: addForwardRuleWithSingleChar(FileInfo *nested, TranslationTableOffset *newRuleOffset,",
          "680:   TranslationTableRule *newRule, TranslationTableHeader *table) {",
          "682:  TranslationTableRule *currentRule;",
          "683:  TranslationTableOffset *currentOffsetPtr;",
          "684:  TranslationTableCharacter *character;",
          "685:  int m = 0;",
          "686:  if (newRule->opcode == CTO_CompDots || newRule->opcode == CTO_Comp6) return;",
          "687:  if (newRule->opcode >= CTO_Pass2 && newRule->opcode <= CTO_Pass4) m = 1;",
          "688:  character = definedCharOrDots(nested, newRule->charsdots[0], m, table);",
          "689:  if (m != 1 && character->attributes & CTC_Letter &&",
          "690:    (newRule->opcode == CTO_WholeWord || newRule->opcode == CTO_LargeSign)) {",
          "691:   if (table->noLetsignCount < LETSIGNSIZE)",
          "692:    table->noLetsign[table->noLetsignCount++] = newRule->charsdots[0];",
          "693:  }",
          "694:  if (newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow)",
          "695:   character->definitionRule = *newRuleOffset;",
          "696:  currentOffsetPtr = &character->otherRules;",
          "697:  while (*currentOffsetPtr) {",
          "698:   currentRule = (TranslationTableRule *)&table->ruleArea[*currentOffsetPtr];",
          "699:   if (currentRule->charslen == 0) break;",
          "700:   if (currentRule->opcode >= CTO_Space && currentRule->opcode < CTO_UpLow)",
          "701:    if (!(newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow)) break;",
          "702:   currentOffsetPtr = &currentRule->charsnext;",
          "703:  }",
          "704:  newRule->charsnext = *currentOffsetPtr;",
          "709: addForwardRuleWithMultipleChars(TranslationTableOffset *newRuleOffset,",
          "710:   TranslationTableRule *newRule, TranslationTableHeader *table) {",
          "712:  TranslationTableRule *currentRule = NULL;",
          "713:  TranslationTableOffset *currentOffsetPtr =",
          "714:    &table->forRules[_lou_stringHash(&newRule->charsdots[0])];",
          "715:  while (*currentOffsetPtr) {",
          "716:   currentRule = (TranslationTableRule *)&table->ruleArea[*currentOffsetPtr];",
          "717:   if (newRule->charslen > currentRule->charslen) break;",
          "718:   if (newRule->charslen == currentRule->charslen)",
          "719:    if ((currentRule->opcode == CTO_Always) && (newRule->opcode != CTO_Always))",
          "720:     break;",
          "721:   currentOffsetPtr = &currentRule->charsnext;",
          "722:  }",
          "723:  newRule->charsnext = *currentOffsetPtr;",
          "728: addBackwardRuleWithSingleCell(FileInfo *nested, widechar cell,",
          "729:   TranslationTableOffset *newRuleOffset, TranslationTableRule *newRule,",
          "730:   TranslationTableHeader *table) {",
          "732:  TranslationTableRule *currentRule;",
          "733:  TranslationTableOffset *currentOffsetPtr;",
          "734:  TranslationTableCharacter *dots;",
          "735:  if (newRule->opcode == CTO_SwapCc || newRule->opcode == CTO_Repeated ||",
          "736:    (newRule->opcode == CTO_Always && newRule->charslen == 1))",
          "738:  dots = definedCharOrDots(nested, cell, 1, table);",
          "739:  if (newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow)",
          "740:   dots->definitionRule = *newRuleOffset;",
          "741:  currentOffsetPtr = &dots->otherRules;",
          "742:  while (*currentOffsetPtr) {",
          "743:   currentRule = (TranslationTableRule *)&table->ruleArea[*currentOffsetPtr];",
          "744:   if (newRule->charslen > currentRule->charslen || currentRule->dotslen == 0) break;",
          "745:   if (currentRule->opcode >= CTO_Space && currentRule->opcode < CTO_UpLow)",
          "746:    if (!(newRule->opcode >= CTO_Space && newRule->opcode < CTO_UpLow)) break;",
          "747:   currentOffsetPtr = &currentRule->dotsnext;",
          "748:  }",
          "749:  newRule->dotsnext = *currentOffsetPtr;",
          "754: addBackwardRuleWithMultipleCells(widechar *cells, int count,",
          "755:   TranslationTableOffset *newRuleOffset, TranslationTableRule *newRule,",
          "756:   TranslationTableHeader *table) {",
          "758:  TranslationTableRule *currentRule = NULL;",
          "759:  TranslationTableOffset *currentOffsetPtr = &table->backRules[_lou_stringHash(cells)];",
          "760:  if (newRule->opcode == CTO_SwapCc) return;",
          "761:  while (*currentOffsetPtr) {",
          "762:   int currentLength;",
          "763:   int newLength;",
          "764:   currentRule = (TranslationTableRule *)&table->ruleArea[*currentOffsetPtr];",
          "765:   currentLength = currentRule->dotslen + currentRule->charslen;",
          "766:   newLength = count + newRule->charslen;",
          "767:   if (newLength > currentLength) break;",
          "768:   if (currentLength == newLength)",
          "769:    if ((currentRule->opcode == CTO_Always) && (newRule->opcode != CTO_Always))",
          "770:     break;",
          "771:   currentOffsetPtr = &currentRule->dotsnext;",
          "772:  }",
          "773:  newRule->dotsnext = *currentOffsetPtr;",
          "778: addForwardPassRule(TranslationTableOffset *newRuleOffset, TranslationTableRule *newRule,",
          "779:   TranslationTableHeader *table) {",
          "780:  TranslationTableOffset *currentOffsetPtr;",
          "781:  TranslationTableRule *currentRule;",
          "782:  switch (newRule->opcode) {",
          "783:  case CTO_Correct:",
          "784:   currentOffsetPtr = &table->forPassRules[0];",
          "785:   break;",
          "786:  case CTO_Context:",
          "787:   currentOffsetPtr = &table->forPassRules[1];",
          "788:   break;",
          "789:  case CTO_Pass2:",
          "790:   currentOffsetPtr = &table->forPassRules[2];",
          "791:   break;",
          "792:  case CTO_Pass3:",
          "793:   currentOffsetPtr = &table->forPassRules[3];",
          "794:   break;",
          "795:  case CTO_Pass4:",
          "796:   currentOffsetPtr = &table->forPassRules[4];",
          "797:   break;",
          "798:  default:",
          "799:   return 0;",
          "800:  }",
          "801:  while (*currentOffsetPtr) {",
          "802:   currentRule = (TranslationTableRule *)&table->ruleArea[*currentOffsetPtr];",
          "803:   if (newRule->charslen > currentRule->charslen) break;",
          "804:   currentOffsetPtr = &currentRule->charsnext;",
          "805:  }",
          "806:  newRule->charsnext = *currentOffsetPtr;",
          "808:  return 1;",
          "812: addBackwardPassRule(TranslationTableOffset *newRuleOffset, TranslationTableRule *newRule,",
          "813:   TranslationTableHeader *table) {",
          "814:  TranslationTableOffset *currentOffsetPtr;",
          "815:  TranslationTableRule *currentRule;",
          "816:  switch (newRule->opcode) {",
          "817:  case CTO_Correct:",
          "818:   currentOffsetPtr = &table->backPassRules[0];",
          "819:   break;",
          "820:  case CTO_Context:",
          "821:   currentOffsetPtr = &table->backPassRules[1];",
          "822:   break;",
          "823:  case CTO_Pass2:",
          "824:   currentOffsetPtr = &table->backPassRules[2];",
          "825:   break;",
          "826:  case CTO_Pass3:",
          "827:   currentOffsetPtr = &table->backPassRules[3];",
          "828:   break;",
          "829:  case CTO_Pass4:",
          "830:   currentOffsetPtr = &table->backPassRules[4];",
          "831:   break;",
          "832:  default:",
          "833:   return 0;",
          "834:  }",
          "835:  while (*currentOffsetPtr) {",
          "836:   currentRule = (TranslationTableRule *)&table->ruleArea[*currentOffsetPtr];",
          "837:   if (newRule->charslen > currentRule->charslen) break;",
          "838:   currentOffsetPtr = &currentRule->dotsnext;",
          "839:  }",
          "840:  newRule->dotsnext = *currentOffsetPtr;",
          "842:  return 1;",
          "845: static int",
          "846: addRule(FileInfo *nested, TranslationTableOpcode opcode, CharsString *ruleChars,",
          "847:   CharsString *ruleDots, TranslationTableCharacterAttributes after,",
          "848:   TranslationTableCharacterAttributes before, TranslationTableOffset *newRuleOffset,",
          "849:   TranslationTableRule **newRule, int noback, int nofor,",
          "850:   TranslationTableHeader **table) {",
          "853:  int ruleSize = sizeof(TranslationTableRule) - (DEFAULTRULESIZE * CHARSIZE);",
          "854:  if (ruleChars) ruleSize += CHARSIZE * ruleChars->length;",
          "855:  if (ruleDots) ruleSize += CHARSIZE * ruleDots->length;",
          "856:  if (!allocateSpaceInTable(nested, newRuleOffset, ruleSize, table)) return 0;",
          "857:  TranslationTableRule *rule =",
          "858:    (TranslationTableRule *)&(*table)->ruleArea[*newRuleOffset];",
          "860:  rule->opcode = opcode;",
          "861:  rule->after = after;",
          "862:  rule->before = before;",
          "863:  if (ruleChars)",
          "864:   memcpy(&rule->charsdots[0], &ruleChars->chars[0],",
          "865:     CHARSIZE * (rule->charslen = ruleChars->length));",
          "866:  else",
          "867:   rule->charslen = 0;",
          "868:  if (ruleDots)",
          "869:   memcpy(&rule->charsdots[rule->charslen], &ruleDots->chars[0],",
          "870:     CHARSIZE * (rule->dotslen = ruleDots->length));",
          "871:  else",
          "872:   rule->dotslen = 0;",
          "873:  if (!charactersDefined(nested, rule, *table)) return 0;",
          "876:  if (opcode == CTO_SwapCc || opcode == CTO_SwapCd || opcode == CTO_SwapDd) return 1;",
          "877:  if (opcode >= CTO_Context && opcode <= CTO_Pass4)",
          "878:   if (!(opcode == CTO_Context && rule->charslen > 0)) {",
          "879:    if (!nofor)",
          "880:     if (!addForwardPassRule(newRuleOffset, rule, *table)) return 0;",
          "881:    if (!noback)",
          "882:     if (!addBackwardPassRule(newRuleOffset, rule, *table)) return 0;",
          "883:    return 1;",
          "884:   }",
          "885:  if (!nofor) {",
          "886:   if (rule->charslen == 1)",
          "887:    addForwardRuleWithSingleChar(nested, newRuleOffset, rule, *table);",
          "888:   else if (rule->charslen > 1)",
          "889:    addForwardRuleWithMultipleChars(newRuleOffset, rule, *table);",
          "891:  if (!noback) {",
          "892:   widechar *cells;",
          "893:   int count;",
          "895:   if (rule->opcode == CTO_Context) {",
          "896:    cells = &rule->charsdots[0];",
          "897:    count = rule->charslen;",
          "898:   } else {",
          "899:    cells = &rule->charsdots[rule->charslen];",
          "900:    count = rule->dotslen;",
          "901:   }",
          "903:   if (count == 1)",
          "904:    addBackwardRuleWithSingleCell(nested, *cells, newRuleOffset, rule, *table);",
          "905:   else if (count > 1)",
          "906:    addBackwardRuleWithMultipleCells(cells, count, newRuleOffset, rule, *table);",
          "907:  }",
          "908:  return 1;",
          "912: findCharacterClass(const CharsString *name, CharacterClass *characterClasses) {",
          "914:  const CharacterClass *class = characterClasses;",
          "915:  while (class) {",
          "916:   if ((name->length == class->length) &&",
          "917:     (memcmp(&name->chars[0], class->name, CHARSIZE * name->length) == 0))",
          "918:    return class;",
          "919:   class = class->next;",
          "920:  }",
          "921:  return NULL;",
          "925: addCharacterClass(FileInfo *nested, const widechar *name, int length,",
          "926:   CharacterClass **characterClasses,",
          "927:   TranslationTableCharacterAttributes *characterClassAttribute) {",
          "929:  CharacterClass *class;",
          "930:  if (*characterClassAttribute) {",
          "931:   if (!(class = malloc(sizeof(*class) + CHARSIZE * (length - 1))))",
          "932:    _lou_outOfMemory();",
          "933:   else {",
          "934:    memset(class, 0, sizeof(*class));",
          "935:    memcpy(class->name, name, CHARSIZE * (class->length = length));",
          "936:    class->attribute = *characterClassAttribute;",
          "938:    class->next = *characterClasses;",
          "940:    return class;",
          "941:   }",
          "943:  compileError(nested, \"character class table overflow.\");",
          "944:  return NULL;",
          "948: deallocateCharacterClasses(CharacterClass **characterClasses) {",
          "949:  while (*characterClasses) {",
          "950:   CharacterClass *class = *characterClasses;",
          "952:   if (class) free(class);",
          "953:  }",
          "957: allocateCharacterClasses(CharacterClass **characterClasses,",
          "958:   TranslationTableCharacterAttributes *characterClassAttribute) {",
          "960:  int k = 0;",
          "963:  while (characterClassNames[k]) {",
          "964:   widechar wname[MAXSTRING];",
          "965:   int length = (int)strlen(characterClassNames[k]);",
          "966:   int kk;",
          "967:   for (kk = 0; kk < length; kk++) wname[kk] = (widechar)characterClassNames[k][kk];",
          "968:   if (!addCharacterClass(",
          "969:      NULL, wname, length, characterClasses, characterClassAttribute)) {",
          "970:    deallocateCharacterClasses(characterClasses);",
          "971:    return 0;",
          "972:   }",
          "973:   k++;",
          "975:  return 1;",
          "979: getOpcode(FileInfo *nested, const CharsString *token, short opcodeLengths[]) {",
          "980:  static TranslationTableOpcode lastOpcode = 0;",
          "981:  TranslationTableOpcode opcode = lastOpcode;",
          "983:  do {",
          "984:   if (token->length == opcodeLengths[opcode])",
          "985:    if (eqasc2uni((unsigned char *)opcodeNames[opcode], &token->chars[0],",
          "986:       token->length)) {",
          "987:     lastOpcode = opcode;",
          "988:     return opcode;",
          "989:    }",
          "990:   opcode++;",
          "991:   if (opcode >= CTO_None) opcode = 0;",
          "992:  } while (opcode != lastOpcode);",
          "993:  compileError(nested, \"opcode %s not defined.\",",
          "994:    _lou_showString(&token->chars[0], token->length));",
          "995:  return CTO_None;",
          "999: _lou_findOpcodeNumber(const char *toFind) {",
          "1001:  static TranslationTableOpcode lastOpcode = 0;",
          "1002:  TranslationTableOpcode opcode = lastOpcode;",
          "1003:  int length = (int)strlen(toFind);",
          "1004:  do {",
          "1005:   if (length == gOpcodeLengths[opcode] &&",
          "1006:     strcasecmp(toFind, opcodeNames[opcode]) == 0) {",
          "1007:    lastOpcode = opcode;",
          "1008:    return opcode;",
          "1009:   }",
          "1010:   opcode++;",
          "1011:   if (opcode >= CTO_None) opcode = 0;",
          "1012:  } while (opcode != lastOpcode);",
          "1013:  return CTO_None;",
          "1017: _lou_findOpcodeName(TranslationTableOpcode opcode) {",
          "1018:  static char scratchBuf[MAXSTRING];",
          "1020:  if (opcode < 0 || opcode >= CTO_None) {",
          "1021:   sprintf(scratchBuf, \"%d\", opcode);",
          "1022:   return scratchBuf;",
          "1023:  }",
          "1024:  return opcodeNames[opcode];",
          "1028: hexValue(FileInfo *nested, const widechar *digits, int length) {",
          "1029:  int k;",
          "1030:  unsigned int binaryValue = 0;",
          "1031:  for (k = 0; k < length; k++) {",
          "1032:   unsigned int hexDigit = 0;",
          "1033:   if (digits[k] >= '0' && digits[k] <= '9')",
          "1034:    hexDigit = digits[k] - '0';",
          "1035:   else if (digits[k] >= 'a' && digits[k] <= 'f')",
          "1036:    hexDigit = digits[k] - 'a' + 10;",
          "1037:   else if (digits[k] >= 'A' && digits[k] <= 'F')",
          "1038:    hexDigit = digits[k] - 'A' + 10;",
          "1039:   else {",
          "1040:    compileError(nested, \"invalid %d-digit hexadecimal number\", length);",
          "1041:    return (widechar)0xffffffff;",
          "1042:   }",
          "1043:   binaryValue |= hexDigit << (4 * (length - 1 - k));",
          "1045:  return (widechar)binaryValue;",
          "1049: static const unsigned int first0Bit[MAXBYTES] = { 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC,",
          "1050:  0XFE };",
          "1053: parseChars(FileInfo *nested, CharsString *result, CharsString *token) {",
          "1054:  int in = 0;",
          "1055:  int out = 0;",
          "1056:  int lastOutSize = 0;",
          "1057:  int lastIn;",
          "1058:  unsigned int ch = 0;",
          "1059:  int numBytes = 0;",
          "1060:  unsigned int utf32 = 0;",
          "1061:  int k;",
          "1062:  while (in < token->length) {",
          "1063:   ch = token->chars[in++] & 0xff;",
          "1064:   if (ch < 128) {",
          "1066:     switch (ch = token->chars[in]) {",
          "1067:     case '\\\\':",
          "1068:      break;",
          "1069:     case 'e':",
          "1070:      ch = 0x1b;",
          "1071:      break;",
          "1072:     case 'f':",
          "1073:      ch = 12;",
          "1074:      break;",
          "1075:     case 'n':",
          "1076:      ch = 10;",
          "1077:      break;",
          "1078:     case 'r':",
          "1079:      ch = 13;",
          "1080:      break;",
          "1081:     case 's':",
          "1082:      ch = ' ';",
          "1083:      break;",
          "1084:     case 't':",
          "1085:      ch = 9;",
          "1086:      break;",
          "1087:     case 'v':",
          "1088:      ch = 11;",
          "1089:      break;",
          "1090:     case 'w':",
          "1091:      ch = ENDSEGMENT;",
          "1092:      break;",
          "1093:     case 34:",
          "1094:      ch = QUOTESUB;",
          "1095:      break;",
          "1096:     case 'X':",
          "1097:     case 'x':",
          "1098:      if (token->length - in > 4) {",
          "1099:       ch = hexValue(nested, &token->chars[in + 1], 4);",
          "1100:       in += 4;",
          "1101:      }",
          "1102:      break;",
          "1103:     case 'y':",
          "1104:     case 'Y':",
          "1105:      if (CHARSIZE == 2) {",
          "1106:      not32:",
          "1107:       compileError(nested,",
          "1108:         \"liblouis has not been compiled for 32-bit Unicode\");",
          "1109:       break;",
          "1110:      }",
          "1111:      if (token->length - in > 5) {",
          "1112:       ch = hexValue(nested, &token->chars[in + 1], 5);",
          "1113:       in += 5;",
          "1114:      }",
          "1115:      break;",
          "1116:     case 'z':",
          "1117:     case 'Z':",
          "1118:      if (CHARSIZE == 2) goto not32;",
          "1119:      if (token->length - in > 8) {",
          "1120:       ch = hexValue(nested, &token->chars[in + 1], 8);",
          "1121:       in += 8;",
          "1122:      }",
          "1123:      break;",
          "1124:     default:",
          "1125:      compileError(nested, \"invalid escape sequence '\\\\%c'\", ch);",
          "1126:      break;",
          "1127:     }",
          "1128:     in++;",
          "1129:    }",
          "1130:    result->chars[out++] = (widechar)ch;",
          "1131:    if (out >= MAXSTRING) {",
          "1132:     result->length = out;",
          "1133:     return 1;",
          "1134:    }",
          "1135:    continue;",
          "1136:   }",
          "1137:   lastOutSize = out;",
          "1138:   lastIn = in;",
          "1139:   for (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--)",
          "1140:    if (ch >= first0Bit[numBytes]) break;",
          "1141:   utf32 = ch & (0XFF - first0Bit[numBytes]);",
          "1142:   for (k = 0; k < numBytes; k++) {",
          "1143:    if (in >= MAXSTRING) break;",
          "1144:    if (token->chars[in] < 128 || (token->chars[in] & 0x0040)) {",
          "1145:     compileWarning(nested, \"invalid UTF-8. Assuming Latin-1.\");",
          "1146:     result->chars[out++] = token->chars[lastIn];",
          "1147:     in = lastIn + 1;",
          "1148:     continue;",
          "1149:    }",
          "1150:    utf32 = (utf32 << 6) + (token->chars[in++] & 0x3f);",
          "1151:   }",
          "1152:   if (CHARSIZE == 2 && utf32 > 0xffff) utf32 = 0xffff;",
          "1153:   result->chars[out++] = (widechar)utf32;",
          "1154:   if (out >= MAXSTRING) {",
          "1155:    result->length = lastOutSize;",
          "1156:    return 1;",
          "1159:  result->length = out;",
          "1160:  return 1;",
          "1164: _lou_extParseChars(const char *inString, widechar *outString) {",
          "1166:  CharsString wideIn;",
          "1167:  CharsString result;",
          "1168:  int k;",
          "1169:  for (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];",
          "1170:  wideIn.chars[k] = 0;",
          "1171:  wideIn.length = k;",
          "1172:  parseChars(NULL, &result, &wideIn);",
          "1173:  if (errorCount) {",
          "1174:   errorCount = 0;",
          "1175:   return 0;",
          "1176:  }",
          "1177:  for (k = 0; k < result.length; k++) outString[k] = result.chars[k];",
          "1178:  return result.length;",
          "1182: parseDots(FileInfo *nested, CharsString *cells, const CharsString *token) {",
          "1185:  int cellCount = 0;",
          "1186:  int index;",
          "1187:  int start = 0;",
          "1189:  for (index = 0; index < token->length; index++) {",
          "1190:   int started = index != start;",
          "1191:   widechar character = token->chars[index];",
          "1193:    {",
          "1194:     int dot;",
          "1195:    case '1':",
          "1196:     dot = B1;",
          "1197:     goto haveDot;",
          "1198:    case '2':",
          "1199:     dot = B2;",
          "1200:     goto haveDot;",
          "1201:    case '3':",
          "1202:     dot = B3;",
          "1203:     goto haveDot;",
          "1204:    case '4':",
          "1205:     dot = B4;",
          "1206:     goto haveDot;",
          "1207:    case '5':",
          "1208:     dot = B5;",
          "1209:     goto haveDot;",
          "1210:    case '6':",
          "1211:     dot = B6;",
          "1212:     goto haveDot;",
          "1213:    case '7':",
          "1214:     dot = B7;",
          "1215:     goto haveDot;",
          "1216:    case '8':",
          "1217:     dot = B8;",
          "1218:     goto haveDot;",
          "1219:    case '9':",
          "1220:     dot = B9;",
          "1221:     goto haveDot;",
          "1222:    case 'a':",
          "1223:    case 'A':",
          "1224:     dot = B10;",
          "1225:     goto haveDot;",
          "1226:    case 'b':",
          "1227:    case 'B':",
          "1228:     dot = B11;",
          "1229:     goto haveDot;",
          "1230:    case 'c':",
          "1231:    case 'C':",
          "1232:     dot = B12;",
          "1233:     goto haveDot;",
          "1234:    case 'd':",
          "1235:    case 'D':",
          "1236:     dot = B13;",
          "1237:     goto haveDot;",
          "1238:    case 'e':",
          "1239:    case 'E':",
          "1240:     dot = B14;",
          "1241:     goto haveDot;",
          "1242:    case 'f':",
          "1243:    case 'F':",
          "1244:     dot = B15;",
          "1245:    haveDot:",
          "1246:     if (started && !cell) goto invalid;",
          "1247:     if (cell & dot) {",
          "1248:      compileError(nested, \"dot specified more than once.\");",
          "1249:      return 0;",
          "1250:     }",
          "1251:     cell |= dot;",
          "1252:     break;",
          "1253:    }",
          "1255:    if (started) goto invalid;",
          "1256:    break;",
          "1258:    if (!started) {",
          "1259:     compileError(nested, \"missing cell specification.\");",
          "1260:     return 0;",
          "1261:    }",
          "1262:    cells->chars[cellCount++] = cell | B16;",
          "1263:    cell = 0;",
          "1264:    start = index + 1;",
          "1265:    break;",
          "1266:   default:",
          "1267:   invalid:",
          "1268:    compileError(",
          "1269:      nested, \"invalid dot number %s.\", _lou_showString(&character, 1));",
          "1270:    return 0;",
          "1271:   }",
          "1272:  }",
          "1273:  if (index == start) {",
          "1274:   compileError(nested, \"missing cell specification.\");",
          "1278:  cells->length = cellCount;",
          "1279:  return 1;",
          "1283: _lou_extParseDots(const char *inString, widechar *outString) {",
          "1285:  CharsString wideIn;",
          "1286:  CharsString result;",
          "1287:  int k;",
          "1288:  for (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];",
          "1289:  wideIn.chars[k] = 0;",
          "1290:  wideIn.length = k;",
          "1291:  parseDots(NULL, &result, &wideIn);",
          "1292:  if (errorCount) {",
          "1293:   errorCount = 0;",
          "1294:   return 0;",
          "1295:  }",
          "1296:  for (k = 0; k < result.length; k++) outString[k] = result.chars[k];",
          "1297:  outString[k] = 0;",
          "1298:  return result.length;",
          "1302: getCharacters(FileInfo *nested, CharsString *characters, int *lastToken) {",
          "1304:  CharsString token;",
          "1305:  if (getToken(nested, &token, \"characters\", lastToken))",
          "1306:   if (parseChars(nested, characters, &token)) return 1;",
          "1307:  return 0;",
          "1311: getRuleCharsText(FileInfo *nested, CharsString *ruleChars, int *lastToken) {",
          "1312:  CharsString token;",
          "1313:  if (getToken(nested, &token, \"Characters operand\", lastToken))",
          "1314:   if (parseChars(nested, ruleChars, &token)) return 1;",
          "1315:  return 0;",
          "1319: getRuleDotsText(FileInfo *nested, CharsString *ruleDots, int *lastToken) {",
          "1320:  CharsString token;",
          "1321:  if (getToken(nested, &token, \"characters\", lastToken))",
          "1322:   if (parseChars(nested, ruleDots, &token)) return 1;",
          "1323:  return 0;",
          "1327: getRuleDotsPattern(FileInfo *nested, CharsString *ruleDots, int *lastToken) {",
          "1329:  CharsString token;",
          "1330:  if (getToken(nested, &token, \"Dots operand\", lastToken)) {",
          "1331:   if (token.length == 1 && token.chars[0] == '=') {",
          "1332:    ruleDots->length = 0;",
          "1333:    return 1;",
          "1334:   }",
          "1335:   if (parseDots(nested, ruleDots, &token)) return 1;",
          "1337:  return 0;",
          "1341: getCharacterClass(FileInfo *nested, const CharacterClass **class,",
          "1342:   CharacterClass *characterClasses, int *lastToken) {",
          "1343:  CharsString token;",
          "1344:  if (getToken(nested, &token, \"character class name\", lastToken)) {",
          "1345:   if ((*class = findCharacterClass(&token, characterClasses))) return 1;",
          "1346:   compileError(nested, \"character class not defined.\");",
          "1347:  }",
          "1348:  return 0;",
          "1352:  struct RuleName *next;",
          "1353:  TranslationTableOffset ruleOffset;",
          "1354:  widechar length;",
          "1355:  widechar name[1];",
          "1358: static int",
          "1359: includeFile(FileInfo *nested, CharsString *includedFile,",
          "1360:   CharacterClass **characterClasses,",
          "1361:   TranslationTableCharacterAttributes *characterClassAttribute,",
          "1362:   short opcodeLengths[], TranslationTableOffset *newRuleOffset,",
          "1363:   TranslationTableRule **newRule, RuleName **ruleNames,",
          "1364:   TranslationTableHeader **table);",
          "1369: findRuleName(const CharsString *name, RuleName *ruleNames) {",
          "1370:  const struct RuleName *nameRule = ruleNames;",
          "1371:  while (nameRule) {",
          "1372:   if ((name->length == nameRule->length) &&",
          "1373:     (memcmp(&name->chars[0], nameRule->name, CHARSIZE * name->length) == 0))",
          "1374:    return nameRule->ruleOffset;",
          "1375:   nameRule = nameRule->next;",
          "1376:  }",
          "1377:  return 0;",
          "1381: addRuleName(FileInfo *nested, CharsString *name, TranslationTableOffset *newRuleOffset,",
          "1382:   RuleName **ruleNames, TranslationTableHeader *table) {",
          "1383:  int k;",
          "1384:  struct RuleName *nameRule;",
          "1385:  if (!(nameRule = malloc(sizeof(*nameRule) + CHARSIZE * (name->length - 1)))) {",
          "1386:   compileError(nested, \"not enough memory\");",
          "1387:   _lou_outOfMemory();",
          "1389:  memset(nameRule, 0, sizeof(*nameRule));",
          "1390:  for (k = 0; k < name->length; k++) {",
          "1391:   TranslationTableCharacter *ch =",
          "1392:     definedCharOrDots(nested, name->chars[k], 0, table);",
          "1393:   if (!(ch->attributes & CTC_Letter)) {",
          "1394:    compileError(nested, \"a name may contain only letters\");",
          "1395:    return 0;",
          "1396:   }",
          "1397:   nameRule->name[k] = name->chars[k];",
          "1398:  }",
          "1399:  nameRule->length = name->length;",
          "1400:  nameRule->ruleOffset = *newRuleOffset;",
          "1401:  nameRule->next = *ruleNames;",
          "1403:  return 1;",
          "1407: deallocateRuleNames(RuleName **ruleNames) {",
          "1408:  while (*ruleNames) {",
          "1409:   struct RuleName *nameRule = *ruleNames;",
          "1411:   if (nameRule) free(nameRule);",
          "1412:  }",
          "1416: compileSwapDots(FileInfo *nested, CharsString *source, CharsString *dest,",
          "1417:   TranslationTableHeader *table) {",
          "1418:  int k = 0;",
          "1419:  int kk = 0;",
          "1420:  CharsString dotsSource;",
          "1421:  CharsString dotsDest;",
          "1422:  dest->length = 0;",
          "1423:  dotsSource.length = 0;",
          "1424:  while (k <= source->length) {",
          "1425:   if (source->chars[k] != ',' && k != source->length)",
          "1426:    dotsSource.chars[dotsSource.length++] = source->chars[k];",
          "1427:   else {",
          "1428:    if (!parseDots(nested, &dotsDest, &dotsSource)) return 0;",
          "1429:    dest->chars[dest->length++] = dotsDest.length + 1;",
          "1430:    for (kk = 0; kk < dotsDest.length; kk++)",
          "1431:     dest->chars[dest->length++] = dotsDest.chars[kk];",
          "1432:    dotsSource.length = 0;",
          "1433:   }",
          "1434:   k++;",
          "1436:  return 1;",
          "1440: compileSwap(FileInfo *nested, TranslationTableOpcode opcode, int *lastToken,",
          "1441:   TranslationTableOffset *newRuleOffset, TranslationTableRule **newRule, int noback,",
          "1442:   int nofor, RuleName **ruleNames, TranslationTableHeader **table) {",
          "1443:  CharsString ruleChars;",
          "1444:  CharsString ruleDots;",
          "1445:  CharsString name;",
          "1446:  CharsString matches;",
          "1447:  CharsString replacements;",
          "1448:  if (!getToken(nested, &name, \"name operand\", lastToken)) return 0;",
          "1449:  if (!getToken(nested, &matches, \"matches operand\", lastToken)) return 0;",
          "1450:  if (!getToken(nested, &replacements, \"replacements operand\", lastToken)) return 0;",
          "1451:  if (opcode == CTO_SwapCc || opcode == CTO_SwapCd) {",
          "1452:   if (!parseChars(nested, &ruleChars, &matches)) return 0;",
          "1453:  } else {",
          "1454:   if (!compileSwapDots(nested, &matches, &ruleChars, *table)) return 0;",
          "1455:  }",
          "1456:  if (opcode == CTO_SwapCc) {",
          "1457:   if (!parseChars(nested, &ruleDots, &replacements)) return 0;",
          "1458:  } else {",
          "1459:   if (!compileSwapDots(nested, &replacements, &ruleDots, *table)) return 0;",
          "1460:  }",
          "1461:  if (!addRule(nested, opcode, &ruleChars, &ruleDots, 0, 0, newRuleOffset, newRule,",
          "1462:     noback, nofor, table))",
          "1463:   return 0;",
          "1464:  if (!addRuleName(nested, &name, newRuleOffset, ruleNames, *table)) return 0;",
          "1465:  return 1;",
          "1469: getNumber(widechar *source, widechar *dest) {",
          "1471:  int k = 0;",
          "1473:  while (source[k] >= '0' && source[k] <= '9') *dest = 10 * *dest + (source[k++] - '0');",
          "1474:  return k;",
          "1480: passGetAttributes(CharsString *passLine, int *passLinepos,",
          "1481:   TranslationTableCharacterAttributes *passAttributes, FileInfo *passNested) {",
          "1482:  int more = 1;",
          "1484:  while (more) {",
          "1485:   switch (passLine->chars[*passLinepos]) {",
          "1486:   case pass_any:",
          "1488:    break;",
          "1489:   case pass_digit:",
          "1491:    break;",
          "1492:   case pass_litDigit:",
          "1494:    break;",
          "1495:   case pass_letter:",
          "1497:    break;",
          "1498:   case pass_math:",
          "1500:    break;",
          "1501:   case pass_punctuation:",
          "1503:    break;",
          "1504:   case pass_sign:",
          "1506:    break;",
          "1507:   case pass_space:",
          "1509:    break;",
          "1510:   case pass_uppercase:",
          "1512:    break;",
          "1513:   case pass_lowercase:",
          "1515:    break;",
          "1516:   case pass_class1:",
          "1518:    break;",
          "1519:   case pass_class2:",
          "1521:    break;",
          "1522:   case pass_class3:",
          "1524:    break;",
          "1525:   case pass_class4:",
          "1527:    break;",
          "1528:   default:",
          "1529:    more = 0;",
          "1530:    break;",
          "1531:   }",
          "1532:   if (more) (*passLinepos)++;",
          "1534:  if (!*passAttributes) {",
          "1535:   compileError(passNested, \"missing attribute\");",
          "1536:   (*passLinepos)--;",
          "1537:   return 0;",
          "1538:  }",
          "1539:  return 1;",
          "1543: passGetEmphasis(CharsString *passLine, int *passLinepos, FileInfo *passNested) {",
          "1544:  static widechar passEmphasis;",
          "1545:  int more = 1;",
          "1547:  passEmphasis = 0;",
          "1548:  while (more) {",
          "1549:   switch (passLine->chars[*passLinepos]) {",
          "1550:   case 'i':",
          "1551:    passEmphasis |= italic;",
          "1552:    break;",
          "1553:   case 'b':",
          "1554:    passEmphasis |= bold;",
          "1555:    break;",
          "1556:   case 'u':",
          "1557:    passEmphasis |= underline;",
          "1558:    break;",
          "1559:   case 'c':",
          "1560:    passEmphasis |= computer_braille;",
          "1561:    break;",
          "1562:   default:",
          "1563:    more = 0;",
          "1564:    break;",
          "1565:   }",
          "1566:   if (more) (*passLinepos)++;",
          "1567:  }",
          "1568:  if (!passEmphasis) {",
          "1569:   compileError(passNested, \"emphasis indicators expected\");",
          "1570:   (*passLinepos)--;",
          "1571:   return 0;",
          "1572:  }",
          "1573:  return 1;",
          "1577: passGetDots(CharsString *passLine, int *passLinepos, CharsString *passHoldString,",
          "1578:   FileInfo *passNested) {",
          "1579:  CharsString collectDots;",
          "1580:  collectDots.length = 0;",
          "1581:  while (*passLinepos < passLine->length &&",
          "1582:    (passLine->chars[*passLinepos] == '-' ||",
          "1583:      (passLine->chars[*passLinepos] >= '0' &&",
          "1584:        passLine->chars[*passLinepos] <= '9') ||",
          "1585:      ((passLine->chars[*passLinepos] | 32) >= 'a' &&",
          "1586:        (passLine->chars[*passLinepos] | 32) <= 'f')))",
          "1587:   collectDots.chars[collectDots.length++] = passLine->chars[(*passLinepos)++];",
          "1588:  if (!parseDots(passNested, passHoldString, &collectDots)) return 0;",
          "1589:  return 1;",
          "1593: passGetString(CharsString *passLine, int *passLinepos, CharsString *passHoldString,",
          "1594:   FileInfo *passNested) {",
          "1595:  passHoldString->length = 0;",
          "1596:  while (1) {",
          "1597:   if ((*passLinepos >= passLine->length) || !passLine->chars[*passLinepos]) {",
          "1598:    compileError(passNested, \"unterminated string\");",
          "1599:    return 0;",
          "1600:   }",
          "1601:   if (passLine->chars[*passLinepos] == 34) break;",
          "1602:   if (passLine->chars[*passLinepos] == QUOTESUB)",
          "1603:    passHoldString->chars[passHoldString->length++] = 34;",
          "1604:   else",
          "1605:    passHoldString->chars[passHoldString->length++] =",
          "1606:      passLine->chars[*passLinepos];",
          "1607:   (*passLinepos)++;",
          "1609:  passHoldString->chars[passHoldString->length] = 0;",
          "1610:  (*passLinepos)++;",
          "1611:  return 1;",
          "1615: passGetNumber(CharsString *passLine, int *passLinepos, widechar *passHoldNumber) {",
          "1618:  while ((*passLinepos < passLine->length) && (passLine->chars[*passLinepos] >= '0') &&",
          "1619:    (passLine->chars[*passLinepos] <= '9'))",
          "1621:     10 * (*passHoldNumber) + (passLine->chars[(*passLinepos)++] - '0');",
          "1622:  return 1;",
          "1626: passGetVariableNumber(FileInfo *nested, CharsString *passLine, int *passLinepos,",
          "1627:   widechar *passHoldNumber) {",
          "1628:  if (!passGetNumber(passLine, passLinepos, passHoldNumber)) return 0;",
          "1629:  if ((*passHoldNumber >= 0) && (*passHoldNumber < NUMVAR)) return 1;",
          "1630:  compileError(nested, \"variable number out of range\");",
          "1631:  return 0;",
          "1635: passGetName(CharsString *passLine, int *passLinepos, CharsString *passHoldString,",
          "1636:   FileInfo *passNested, TranslationTableHeader *table) {",
          "1637:  TranslationTableCharacterAttributes attr;",
          "1638:  passHoldString->length = 0;",
          "1639:  do {",
          "1640:   attr = definedCharOrDots(passNested, passLine->chars[*passLinepos], 0,",
          "1641:     table)->attributes;",
          "1642:   if (passHoldString->length == 0) {",
          "1643:    if (!(attr & CTC_Letter)) {",
          "1644:     (*passLinepos)++;",
          "1645:     continue;",
          "1646:    }",
          "1647:   }",
          "1648:   if (!(attr & CTC_Letter)) break;",
          "1649:   passHoldString->chars[passHoldString->length++] = passLine->chars[*passLinepos];",
          "1650:   (*passLinepos)++;",
          "1651:  } while (*passLinepos < passLine->length);",
          "1652:  return 1;",
          "1656: passIsKeyword(const char *token, CharsString *passLine, int *passLinepos) {",
          "1657:  int k;",
          "1658:  int length = (int)strlen(token);",
          "1659:  int ch = passLine->chars[*passLinepos + length + 1];",
          "1660:  if (((ch | 32) >= 'a' && (ch | 32) <= 'z') || (ch >= '0' && ch <= '9')) return 0;",
          "1661:  for (k = 0; k < length && passLine->chars[*passLinepos + k + 1] == (widechar)token[k];",
          "1662:    k++)",
          "1663:   ;",
          "1664:  if (k == length) {",
          "1666:   return 1;",
          "1667:  }",
          "1668:  return 0;",
          "1671: struct PassName {",
          "1672:  struct PassName *next;",
          "1673:  int varnum;",
          "1674:  widechar length;",
          "1675:  widechar name[1];",
          "1681: passFindName(const CharsString *name, FileInfo *passNested,",
          "1682:   TranslationTableOpcode *passOpcode) {",
          "1683:  const struct PassName *curname = passNames;",
          "1684:  CharsString augmentedName;",
          "1685:  for (augmentedName.length = 0; augmentedName.length < name->length;",
          "1686:    augmentedName.length++)",
          "1687:   augmentedName.chars[augmentedName.length] = name->chars[augmentedName.length];",
          "1688:  augmentedName.chars[augmentedName.length++] = *passOpcode;",
          "1689:  while (curname) {",
          "1690:   if ((augmentedName.length == curname->length) &&",
          "1691:     (memcmp(&augmentedName.chars[0], curname->name,",
          "1692:        CHARSIZE * name->length) == 0))",
          "1693:    return curname->varnum;",
          "1694:   curname = curname->next;",
          "1695:  }",
          "1696:  compileError(passNested, \"name not found\");",
          "1697:  return 0;",
          "1701: passAddName(CharsString *name, int var, TranslationTableOpcode *passOpcode) {",
          "1702:  int k;",
          "1703:  struct PassName *curname;",
          "1704:  CharsString augmentedName;",
          "1705:  for (augmentedName.length = 0; augmentedName.length < name->length;",
          "1706:    augmentedName.length++)",
          "1707:   augmentedName.chars[augmentedName.length] = name->chars[augmentedName.length];",
          "1708:  augmentedName.chars[augmentedName.length++] = *passOpcode;",
          "1709:  if (!(curname = malloc(sizeof(*curname) + CHARSIZE * (augmentedName.length - 1)))) {",
          "1710:   _lou_outOfMemory();",
          "1711:  }",
          "1712:  memset(curname, 0, sizeof(*curname));",
          "1713:  for (k = 0; k < augmentedName.length; k++) {",
          "1714:   curname->name[k] = augmentedName.chars[k];",
          "1715:  }",
          "1716:  curname->length = augmentedName.length;",
          "1717:  curname->varnum = var;",
          "1718:  curname->next = passNames;",
          "1719:  passNames = curname;",
          "1720:  return 1;",
          "1724: passGetScriptToken(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1725:   CharsString *passHoldString, widechar *passHoldNumber, FileInfo *passNested,",
          "1726:   TranslationTableHeader *table) {",
          "1727:  while (*passLinepos < passLine->length) {",
          "1729:   switch (passLine->chars[*passLinepos]) {",
          "1730:   case '\\\"':",
          "1731:    (*passLinepos)++;",
          "1732:    if (passGetString(passLine, passLinepos, passHoldString, passNested))",
          "1733:     return pass_string;",
          "1734:    return pass_invalidToken;",
          "1735:   case '@':",
          "1736:    (*passLinepos)++;",
          "1737:    if (passGetDots(passLine, passLinepos, passHoldString, passNested))",
          "1738:     return pass_dots;",
          "1739:    return pass_invalidToken;",
          "1742:    return pass_noMoreTokens;",
          "1743:   case '!':",
          "1744:    if (passLine->chars[*passLinepos + 1] == '=') {",
          "1746:     return pass_noteq;",
          "1747:    }",
          "1748:    (*passLinepos)++;",
          "1749:    return pass_not;",
          "1750:   case '-':",
          "1751:    (*passLinepos)++;",
          "1752:    return pass_hyphen;",
          "1753:   case '=':",
          "1754:    (*passLinepos)++;",
          "1755:    return pass_eq;",
          "1756:   case '<':",
          "1757:    (*passLinepos)++;",
          "1758:    if (passLine->chars[*passLinepos] == '=') {",
          "1759:     (*passLinepos)++;",
          "1760:     return pass_lteq;",
          "1761:    }",
          "1762:    return pass_lt;",
          "1763:   case '>':",
          "1764:    (*passLinepos)++;",
          "1765:    if (passLine->chars[*passLinepos] == '=') {",
          "1766:     (*passLinepos)++;",
          "1767:     return pass_gteq;",
          "1768:    }",
          "1769:    return pass_gt;",
          "1770:   case '+':",
          "1771:    (*passLinepos)++;",
          "1772:    return pass_plus;",
          "1773:   case '(':",
          "1774:    (*passLinepos)++;",
          "1775:    return pass_leftParen;",
          "1776:   case ')':",
          "1777:    (*passLinepos)++;",
          "1778:    return pass_rightParen;",
          "1779:   case ',':",
          "1780:    (*passLinepos)++;",
          "1781:    return pass_comma;",
          "1782:   case '&':",
          "1783:    if (passLine->chars[ *passLinepos = 1] == '&') {",
          "1785:     return pass_and;",
          "1786:    }",
          "1787:    return pass_invalidToken;",
          "1788:   case '|':",
          "1789:    if (passLine->chars[*passLinepos + 1] == '|') {",
          "1791:     return pass_or;",
          "1792:    }",
          "1793:    return pass_invalidToken;",
          "1794:   case 'a':",
          "1795:    if (passIsKeyword(\"ttr\", passLine, passLinepos)) return pass_attributes;",
          "1796:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1797:    return pass_nameFound;",
          "1798:   case 'b':",
          "1799:    if (passIsKeyword(\"ack\", passLine, passLinepos)) return pass_lookback;",
          "1800:    if (passIsKeyword(\"ool\", passLine, passLinepos)) return pass_boolean;",
          "1801:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1802:    return pass_nameFound;",
          "1803:   case 'c':",
          "1804:    if (passIsKeyword(\"lass\", passLine, passLinepos)) return pass_class;",
          "1805:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1806:    return pass_nameFound;",
          "1807:   case 'd':",
          "1808:    if (passIsKeyword(\"ef\", passLine, passLinepos)) return pass_define;",
          "1809:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1810:    return pass_nameFound;",
          "1811:   case 'e':",
          "1812:    if (passIsKeyword(\"mph\", passLine, passLinepos)) return pass_emphasis;",
          "1813:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1814:    return pass_nameFound;",
          "1815:   case 'f':",
          "1816:    if (passIsKeyword(\"ind\", passLine, passLinepos)) return pass_search;",
          "1817:    if (passIsKeyword(\"irst\", passLine, passLinepos)) return pass_first;",
          "1818:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1819:    return pass_nameFound;",
          "1820:   case 'g':",
          "1821:    if (passIsKeyword(\"roup\", passLine, passLinepos)) return pass_group;",
          "1822:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1823:    return pass_nameFound;",
          "1824:   case 'i':",
          "1825:    if (passIsKeyword(\"f\", passLine, passLinepos)) return pass_if;",
          "1826:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1827:    return pass_nameFound;",
          "1828:   case 'l':",
          "1829:    if (passIsKeyword(\"ast\", passLine, passLinepos)) return pass_last;",
          "1830:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1831:    return pass_nameFound;",
          "1832:   case 'm':",
          "1833:    if (passIsKeyword(\"ark\", passLine, passLinepos)) return pass_mark;",
          "1834:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1835:    return pass_nameFound;",
          "1836:   case 'r':",
          "1837:    if (passIsKeyword(\"epgroup\", passLine, passLinepos)) return pass_repGroup;",
          "1838:    if (passIsKeyword(\"epcopy\", passLine, passLinepos)) return pass_copy;",
          "1839:    if (passIsKeyword(\"epomit\", passLine, passLinepos)) return pass_omit;",
          "1840:    if (passIsKeyword(\"ep\", passLine, passLinepos)) return pass_replace;",
          "1841:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1842:    return pass_nameFound;",
          "1843:   case 's':",
          "1844:    if (passIsKeyword(\"cript\", passLine, passLinepos)) return pass_script;",
          "1845:    if (passIsKeyword(\"wap\", passLine, passLinepos)) return pass_swap;",
          "1846:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1847:    return pass_nameFound;",
          "1848:   case 't':",
          "1849:    if (passIsKeyword(\"hen\", passLine, passLinepos)) return pass_then;",
          "1850:    passGetName(passLine, passLinepos, passHoldString, passNested, table);",
          "1851:    return pass_nameFound;",
          "1852:   default:",
          "1853:    if (passLine->chars[*passLinepos] <= 32) {",
          "1854:     (*passLinepos)++;",
          "1855:     break;",
          "1856:    }",
          "1857:    if (passLine->chars[*passLinepos] >= '0' &&",
          "1858:      passLine->chars[*passLinepos] <= '9') {",
          "1859:     passGetNumber(passLine, passLinepos, passHoldNumber);",
          "1860:     return pass_numberFound;",
          "1861:    } else {",
          "1862:     if (!passGetName(",
          "1863:        passLine, passLinepos, passHoldString, passNested, table))",
          "1864:      return pass_invalidToken;",
          "1865:     else",
          "1866:      return pass_nameFound;",
          "1867:    }",
          "1868:   }",
          "1870:  return pass_noMoreTokens;",
          "1874: passIsLeftParen(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1875:   CharsString *passHoldString, FileInfo *passNested,",
          "1876:   TranslationTableHeader *table) {",
          "1877:  widechar passHoldNumber;",
          "1878:  pass_Codes passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos,",
          "1879:    passHoldString, &passHoldNumber, passNested, table);",
          "1880:  if (passCode != pass_leftParen) {",
          "1881:   compileError(passNested, \"'(' expected\");",
          "1882:   return 0;",
          "1883:  }",
          "1884:  return 1;",
          "1888: passIsName(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1889:   CharsString *passHoldString, FileInfo *passNested,",
          "1890:   TranslationTableHeader *table) {",
          "1891:  widechar passHoldNumber;",
          "1892:  pass_Codes passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos,",
          "1893:    passHoldString, &passHoldNumber, passNested, table);",
          "1894:  if (passCode != pass_nameFound) {",
          "1895:   compileError(passNested, \"a name expected\");",
          "1896:   return 0;",
          "1897:  }",
          "1898:  return 1;",
          "1902: passIsComma(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1903:   CharsString *passHoldString, FileInfo *passNested,",
          "1904:   TranslationTableHeader *table) {",
          "1905:  widechar passHoldNumber;",
          "1906:  pass_Codes passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos,",
          "1907:    passHoldString, &passHoldNumber, passNested, table);",
          "1908:  if (passCode != pass_comma) {",
          "1909:   compileError(passNested, \"',' expected\");",
          "1910:   return 0;",
          "1911:  }",
          "1912:  return 1;",
          "1916: passIsNumber(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1917:   CharsString *passHoldString, widechar *passHoldNumber, FileInfo *passNested,",
          "1918:   TranslationTableHeader *table) {",
          "1919:  pass_Codes passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos,",
          "1920:    passHoldString, passHoldNumber, passNested, table);",
          "1921:  if (passCode != pass_numberFound) {",
          "1922:   compileError(passNested, \"a number expected\");",
          "1923:   return 0;",
          "1924:  }",
          "1925:  return 1;",
          "1929: passIsRightParen(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1930:   CharsString *passHoldString, FileInfo *passNested,",
          "1931:   TranslationTableHeader *table) {",
          "1932:  widechar passHoldNumber;",
          "1933:  pass_Codes passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos,",
          "1934:    passHoldString, &passHoldNumber, passNested, table);",
          "1935:  if (passCode != pass_rightParen) {",
          "1936:   compileError(passNested, \"')' expected\");",
          "1937:   return 0;",
          "1938:  }",
          "1939:  return 1;",
          "1943: passGetRange(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1944:   CharsString *passHoldString, FileInfo *passNested, widechar *passInstructions,",
          "1945:   int *passIC, TranslationTableHeader *table) {",
          "1946:  widechar passHoldNumber;",
          "1947:  pass_Codes passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos,",
          "1948:    passHoldString, &passHoldNumber, passNested, table);",
          "1949:  if (!(passCode == pass_comma || passCode == pass_rightParen)) {",
          "1950:   compileError(passNested, \"invalid range\");",
          "1951:   return 0;",
          "1952:  }",
          "1953:  if (passCode == pass_rightParen) {",
          "1954:   passInstructions[(*passIC)++] = 1;",
          "1955:   passInstructions[(*passIC)++] = 1;",
          "1956:   return 1;",
          "1957:  }",
          "1958:  if (!passIsNumber(passLine, passLinepos, passPrevLinepos, passHoldString,",
          "1959:     &passHoldNumber, passNested, table))",
          "1960:   return 0;",
          "1961:  passInstructions[(*passIC)++] = passHoldNumber;",
          "1962:  passCode = passGetScriptToken(passLine, passLinepos, passPrevLinepos, passHoldString,",
          "1963:    &passHoldNumber, passNested, table);",
          "1964:  if (!(passCode == pass_comma || passCode == pass_rightParen)) {",
          "1965:   compileError(passNested, \"invalid range\");",
          "1966:   return 0;",
          "1967:  }",
          "1968:  if (passCode == pass_rightParen) {",
          "1969:   passInstructions[(*passIC)++] = passHoldNumber;",
          "1970:   return 1;",
          "1971:  }",
          "1972:  if (!passIsNumber(passLine, passLinepos, passPrevLinepos, passHoldString,",
          "1973:     &passHoldNumber, passNested, table))",
          "1974:   return 0;",
          "1975:  passInstructions[(*passIC)++] = passHoldNumber;",
          "1976:  if (!passIsRightParen(passLine, passLinepos, passPrevLinepos, passHoldString,",
          "1977:     passNested, table))",
          "1978:   return 0;",
          "1979:  return 1;",
          "1983: passInsertAttributes(CharsString *passLine, int *passLinepos, int *passPrevLinepos,",
          "1984:   CharsString *passHoldString, TranslationTableCharacterAttributes *passAttributes,",
          "1985:   FileInfo *passNested, widechar *passInstructions, int *passIC,",
          "1986:   TranslationTableHeader *table) {",
          "1987:  passInstructions[(*passIC)++] = pass_attributes;",
          "1988:  passInstructions[(*passIC)++] = *passAttributes >> 16;",
          "1989:  passInstructions[(*passIC)++] = *passAttributes & 0xffff;",
          "1990:  if (!passGetRange(passLine, passLinepos, passPrevLinepos, passHoldString, passNested,",
          "1991:     passInstructions, passIC, table))",
          "1992:   return 0;",
          "1993:  return 1;",
          "1997: wantsString(TranslationTableOpcode opcode, int actionPart, int nofor) {",
          "1998:  if (opcode == CTO_Correct) return 1;",
          "1999:  if (opcode != CTO_Context) return 0;",
          "2000:  return !nofor == !actionPart;",
          "2004: verifyStringOrDots(FileInfo *nested, TranslationTableOpcode opcode, int isString,",
          "2005:   int actionPart, int nofor) {",
          "2006:  if (!wantsString(opcode, actionPart, nofor) == !isString) return 1;",
          "2008:  compileError(nested, \"%s are not allowed in the %s part of a %s translation %s rule.\",",
          "2009:    isString ? \"strings\" : \"dots\", getPartName(actionPart),",
          "2010:    nofor ? \"backward\" : \"forward\", _lou_findOpcodeName(opcode));",
          "2012:  return 0;",
          "2016: compilePassOpcode(FileInfo *nested, TranslationTableOpcode opcode,",
          "2017:   CharacterClass *characterClasses, TranslationTableOffset *newRuleOffset,",
          "2018:   TranslationTableRule **newRule, int noback, int nofor, RuleName *ruleNames,",
          "2019:   TranslationTableHeader **table) {",
          "2020:  static CharsString passRuleChars;",
          "2021:  static CharsString passRuleDots;",
          "2023:  widechar passSubOp;",
          "2024:  const CharacterClass *class;",
          "2025:  TranslationTableOffset ruleOffset = 0;",
          "2026:  TranslationTableRule *rule = NULL;",
          "2027:  int k;",
          "2028:  int kk = 0;",
          "2029:  pass_Codes passCode;",
          "2030:  int endTest = 0;",
          "2031:  int isScript = 1;",
          "2032:  widechar *passInstructions = passRuleDots.chars;",
          "2034:  passRuleChars.length = 0;",
          "2035:  FileInfo *passNested = nested;",
          "2036:  TranslationTableOpcode passOpcode = opcode;",
          "2037:  CharsString passHoldString;",
          "2038:  widechar passHoldNumber;",
          "2039:  CharsString passLine;",
          "2040:  int passLinepos = 0;",
          "2041:  int passPrevLinepos;",
          "2042:  TranslationTableCharacterAttributes passAttributes;",
          "2043:  passHoldString.length = 0;",
          "2044:  for (k = nested->linepos; k < nested->linelen; k++)",
          "2045:   passHoldString.chars[passHoldString.length++] = nested->line[k];",
          "2046:  if (!eqasc2uni((unsigned char *)\"script\", passHoldString.chars, 6)) {",
          "2047:   isScript = 0;",
          "2049:   for (k = 0; k < passHoldString.length && passHoldString.chars[k] > 32; k++)",
          "2050:    ;",
          "2051:   if (k < passHoldString.length)",
          "2052:    passHoldString.chars[k] = SEPCHAR;",
          "2053:   else {",
          "2054:    compileError(passNested, \"Invalid multipass operands\");",
          "2055:    return 0;",
          "2057:  }",
          "2058:  parseChars(passNested, &passLine, &passHoldString);",
          "2059:  if (isScript) {",
          "2060:   int more = 1;",
          "2061:   passCode = passGetScriptToken(&passLine, &passLinepos, &passPrevLinepos,",
          "2062:     &passHoldString, &passHoldNumber, passNested, *table);",
          "2063:   if (passCode != pass_script) {",
          "2064:    compileError(passNested, \"Invalid multipass statement\");",
          "2065:    return 0;",
          "2068:   while (more) {",
          "2069:    passCode = passGetScriptToken(&passLine, &passLinepos, &passPrevLinepos,",
          "2070:      &passHoldString, &passHoldNumber, passNested, *table);",
          "2071:    switch (passCode) {",
          "2072:    case pass_define:",
          "2073:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2074:        &passHoldString, passNested, *table))",
          "2075:      return 0;",
          "2076:     if (!passIsName(&passLine, &passLinepos, &passPrevLinepos,",
          "2077:        &passHoldString, passNested, *table))",
          "2078:      return 0;",
          "2079:     if (!passIsComma(&passLine, &passLinepos, &passPrevLinepos,",
          "2080:        &passHoldString, passNested, *table))",
          "2081:      return 0;",
          "2082:     if (!passIsNumber(&passLine, &passLinepos, &passPrevLinepos,",
          "2083:        &passHoldString, &passHoldNumber, passNested, *table))",
          "2084:      return 0;",
          "2085:     if (!passIsRightParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2086:        &passHoldString, passNested, *table))",
          "2087:      return 0;",
          "2088:     passAddName(&passHoldString, passHoldNumber, &passOpcode);",
          "2089:     break;",
          "2090:    case pass_if:",
          "2091:     more = 0;",
          "2092:     break;",
          "2093:    default:",
          "2094:     compileError(passNested, \"invalid definition in declarative part\");",
          "2095:     return 0;",
          "2096:    }",
          "2099:   more = 1;",
          "2100:   while (more) {",
          "2101:    passCode = passGetScriptToken(&passLine, &passLinepos, &passPrevLinepos,",
          "2102:      &passHoldString, &passHoldNumber, passNested, *table);",
          "2103:    passSubOp = passCode;",
          "2104:    switch (passCode) {",
          "2105:    case pass_not:",
          "2106:     passInstructions[passIC++] = pass_not;",
          "2107:     break;",
          "2108:    case pass_first:",
          "2109:     passInstructions[passIC++] = pass_first;",
          "2110:     break;",
          "2111:    case pass_last:",
          "2112:     passInstructions[passIC++] = pass_last;",
          "2113:     break;",
          "2114:    case pass_search:",
          "2115:     passInstructions[passIC++] = pass_search;",
          "2116:     break;",
          "2117:    case pass_string:",
          "2118:     if (!verifyStringOrDots(nested, opcode, 1, 0, nofor)) {",
          "2119:      return 0;",
          "2120:     }",
          "2121:     passInstructions[passIC++] = pass_string;",
          "2122:     goto ifDoCharsDots;",
          "2123:    case pass_dots:",
          "2124:     if (!verifyStringOrDots(nested, opcode, 0, 0, nofor)) {",
          "2125:      return 0;",
          "2126:     }",
          "2127:     passInstructions[passIC++] = pass_dots;",
          "2128:    ifDoCharsDots:",
          "2129:     passInstructions[passIC++] = passHoldString.length;",
          "2130:     for (kk = 0; kk < passHoldString.length; kk++)",
          "2131:      passInstructions[passIC++] = passHoldString.chars[kk];",
          "2132:     break;",
          "2133:    case pass_attributes:",
          "2134:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2135:        &passHoldString, passNested, *table))",
          "2136:      return 0;",
          "2137:     if (!passGetAttributes(",
          "2138:        &passLine, &passLinepos, &passAttributes, passNested))",
          "2139:      return 0;",
          "2140:     if (!passInsertAttributes(&passLine, &passLinepos, &passPrevLinepos,",
          "2141:        &passHoldString, &passAttributes, passNested,",
          "2142:        passInstructions, &passIC, *table))",
          "2143:      return 0;",
          "2144:     break;",
          "2145:    case pass_emphasis:",
          "2146:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2147:        &passHoldString, passNested, *table))",
          "2148:      return 0;",
          "2149:     if (!passGetEmphasis(&passLine, &passLinepos, passNested)) return 0;",
          "2151:     break;",
          "2152:    case pass_lookback:",
          "2153:     passInstructions[passIC++] = pass_lookback;",
          "2154:     passCode = passGetScriptToken(&passLine, &passLinepos, &passPrevLinepos,",
          "2155:       &passHoldString, &passHoldNumber, passNested, *table);",
          "2156:     if (passCode != pass_leftParen) {",
          "2157:      passInstructions[passIC++] = 1;",
          "2158:      passLinepos = passPrevLinepos;",
          "2159:      break;",
          "2160:     }",
          "2161:     if (!passIsNumber(&passLine, &passLinepos, &passPrevLinepos,",
          "2162:        &passHoldString, &passHoldNumber, passNested, *table))",
          "2163:      return 0;",
          "2164:     if (!passIsRightParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2165:        &passHoldString, passNested, *table))",
          "2166:      return 0;",
          "2167:     passInstructions[passIC] = passHoldNumber;",
          "2168:     break;",
          "2169:    case pass_group:",
          "2170:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2171:        &passHoldString, passNested, *table))",
          "2172:      return 0;",
          "2173:     break;",
          "2174:    case pass_mark:",
          "2175:     passInstructions[passIC++] = pass_startReplace;",
          "2176:     passInstructions[passIC++] = pass_endReplace;",
          "2177:     break;",
          "2178:    case pass_replace:",
          "2179:     passInstructions[passIC++] = pass_startReplace;",
          "2180:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2181:        &passHoldString, passNested, *table))",
          "2182:      return 0;",
          "2183:     break;",
          "2184:    case pass_rightParen:",
          "2185:     passInstructions[passIC++] = pass_endReplace;",
          "2186:     break;",
          "2187:    case pass_groupstart:",
          "2188:    case pass_groupend:",
          "2189:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2190:        &passHoldString, passNested, *table))",
          "2191:      return 0;",
          "2192:     if (!passGetName(",
          "2193:        &passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2194:      return 0;",
          "2195:     if (!passIsRightParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2196:        &passHoldString, passNested, *table))",
          "2197:      return 0;",
          "2198:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2199:     if (ruleOffset)",
          "2200:      rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];",
          "2201:     if (rule && rule->opcode == CTO_Grouping) {",
          "2202:      passInstructions[passIC++] = passSubOp;",
          "2203:      passInstructions[passIC++] = ruleOffset >> 16;",
          "2204:      passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2205:      break;",
          "2206:     } else {",
          "2207:      compileError(passNested, \"%s is not a grouping name\",",
          "2208:        _lou_showString(",
          "2209:          &passHoldString.chars[0], passHoldString.length));",
          "2210:      return 0;",
          "2211:     }",
          "2212:     break;",
          "2213:    case pass_class:",
          "2214:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2215:        &passHoldString, passNested, *table))",
          "2216:      return 0;",
          "2217:     if (!passGetName(",
          "2218:        &passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2219:      return 0;",
          "2220:     if (!passIsRightParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2221:        &passHoldString, passNested, *table))",
          "2222:      return 0;",
          "2223:     if (!(class = findCharacterClass(&passHoldString, characterClasses)))",
          "2224:      return 0;",
          "2225:     passAttributes = class->attribute;",
          "2226:     passInsertAttributes(&passLine, &passLinepos, &passPrevLinepos,",
          "2227:       &passHoldString, &passAttributes, passNested, passInstructions,",
          "2228:       &passIC, *table);",
          "2229:     break;",
          "2230:    case pass_swap:",
          "2231:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2232:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2233:        &passHoldString, passNested, *table))",
          "2234:      return 0;",
          "2235:     if (!passGetName(",
          "2236:        &passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2237:      return 0;",
          "2238:     if (!passIsRightParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2239:        &passHoldString, passNested, *table))",
          "2240:      return 0;",
          "2241:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2242:     if (ruleOffset)",
          "2243:      rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];",
          "2244:     if (rule && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||",
          "2245:          rule->opcode == CTO_SwapDd)) {",
          "2246:      passInstructions[passIC++] = pass_swap;",
          "2247:      passInstructions[passIC++] = ruleOffset >> 16;",
          "2248:      passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2249:      if (!passGetRange(&passLine, &passLinepos, &passPrevLinepos,",
          "2250:         &passHoldString, passNested, passInstructions, &passIC,",
          "2252:       return 0;",
          "2253:      break;",
          "2254:     }",
          "2255:     compileError(passNested, \"%s is not a swap name.\",",
          "2256:       _lou_showString(&passHoldString.chars[0], passHoldString.length));",
          "2257:     return 0;",
          "2258:    case pass_nameFound:",
          "2259:     passHoldNumber = passFindName(&passHoldString, passNested, &passOpcode);",
          "2260:     passCode = passGetScriptToken(&passLine, &passLinepos, &passPrevLinepos,",
          "2261:       &passHoldString, &passHoldNumber, passNested, *table);",
          "2262:     if (!(passCode == pass_eq || passCode == pass_lt || passCode == pass_gt ||",
          "2263:        passCode == pass_noteq || passCode == pass_lteq ||",
          "2264:        passCode == pass_gteq)) {",
          "2265:      compileError(nested, \"invalid comparison operator in if part\");",
          "2266:      return 0;",
          "2267:     }",
          "2268:     passInstructions[passIC++] = passCode;",
          "2269:     passInstructions[passIC++] = passHoldNumber;",
          "2270:     if (!passIsNumber(&passLine, &passLinepos, &passPrevLinepos,",
          "2271:        &passHoldString, &passHoldNumber, passNested, *table))",
          "2272:      return 0;",
          "2273:     passInstructions[passIC++] = passHoldNumber;",
          "2274:     break;",
          "2275:    case pass_then:",
          "2276:     passInstructions[passIC++] = pass_endTest;",
          "2277:     more = 0;",
          "2278:     break;",
          "2279:    default:",
          "2280:     compileError(passNested, \"invalid choice in if part\");",
          "2281:     return 0;",
          "2282:    }",
          "2286:   more = 1;",
          "2287:   while (more) {",
          "2288:    passCode = passGetScriptToken(&passLine, &passLinepos, &passPrevLinepos,",
          "2289:      &passHoldString, &passHoldNumber, passNested, *table);",
          "2290:    passSubOp = passCode;",
          "2291:    switch (passCode) {",
          "2292:    case pass_string:",
          "2293:     if (!verifyStringOrDots(nested, opcode, 1, 1, nofor)) {",
          "2294:      return 0;",
          "2295:     }",
          "2296:     passInstructions[passIC++] = pass_string;",
          "2297:     goto thenDoCharsDots;",
          "2298:    case pass_dots:",
          "2299:     if (!verifyStringOrDots(nested, opcode, 0, 1, nofor)) {",
          "2300:      return 0;",
          "2301:     }",
          "2302:     passInstructions[passIC++] = pass_dots;",
          "2303:    thenDoCharsDots:",
          "2304:     passInstructions[passIC++] = passHoldString.length;",
          "2305:     for (kk = 0; kk < passHoldString.length; kk++)",
          "2306:      passInstructions[passIC++] = passHoldString.chars[kk];",
          "2307:     break;",
          "2308:    case pass_nameFound:",
          "2309:     passHoldNumber = passFindName(&passHoldString, passNested, &passOpcode);",
          "2310:     passCode = passGetScriptToken(&passLine, &passLinepos, &passPrevLinepos,",
          "2311:       &passHoldString, &passHoldNumber, passNested, *table);",
          "2312:     if (!(passCode == pass_plus || passCode == pass_hyphen ||",
          "2313:        passCode == pass_eq)) {",
          "2314:      compileError(nested, \"Invalid variable operator in then part\");",
          "2315:      return 0;",
          "2316:     }",
          "2317:     passInstructions[passIC++] = passCode;",
          "2318:     passInstructions[passIC++] = passHoldNumber;",
          "2319:     if (!passIsNumber(&passLine, &passLinepos, &passPrevLinepos,",
          "2320:        &passHoldString, &passHoldNumber, passNested, *table))",
          "2321:      return 0;",
          "2322:     passInstructions[passIC++] = passHoldNumber;",
          "2323:     break;",
          "2324:    case pass_copy:",
          "2325:     passInstructions[passIC++] = pass_copy;",
          "2326:     break;",
          "2327:    case pass_omit:",
          "2328:     passInstructions[passIC++] = pass_omit;",
          "2329:     break;",
          "2330:    case pass_swap:",
          "2331:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2332:     if (!passIsLeftParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2333:        &passHoldString, passNested, *table))",
          "2334:      return 0;",
          "2335:     if (!passGetName(",
          "2336:        &passLine, &passLinepos, &passHoldString, passNested, *table))",
          "2337:      return 0;",
          "2338:     if (!passIsRightParen(&passLine, &passLinepos, &passPrevLinepos,",
          "2339:        &passHoldString, passNested, *table))",
          "2340:      return 0;",
          "2341:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2342:     if (ruleOffset)",
          "2343:      rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];",
          "2344:     if (rule && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||",
          "2345:          rule->opcode == CTO_SwapDd)) {",
          "2346:      passInstructions[passIC++] = pass_swap;",
          "2347:      passInstructions[passIC++] = ruleOffset >> 16;",
          "2348:      passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2349:      if (!passGetRange(&passLine, &passLinepos, &passPrevLinepos,",
          "2350:         &passHoldString, passNested, passInstructions, &passIC,",
          "2352:       return 0;",
          "2353:      break;",
          "2354:     }",
          "2355:     compileError(passNested, \"%s is not a swap name.\",",
          "2356:       _lou_showString(&passHoldString.chars[0], passHoldString.length));",
          "2357:     return 0;",
          "2358:    case pass_noMoreTokens:",
          "2359:     more = 0;",
          "2360:     break;",
          "2361:    default:",
          "2362:     compileError(passNested, \"invalid action in then part\");",
          "2363:     return 0;",
          "2364:    }",
          "2366:  } else {",
          "2370:   for (k = 0; k < passLine.length && passLine.chars[k] != SEPCHAR; k++)",
          "2371:    ;",
          "2372:   endTest = k;",
          "2373:   passLine.chars[endTest] = pass_endTest;",
          "2374:   passLinepos = 0;",
          "2375:   while (passLinepos <= endTest) {",
          "2376:    switch ((passSubOp = passLine.chars[passLinepos])) {",
          "2377:    case pass_lookback:",
          "2378:     passInstructions[passIC++] = pass_lookback;",
          "2379:     passLinepos++;",
          "2380:     passGetNumber(&passLine, &passLinepos, &passHoldNumber);",
          "2381:     if (passHoldNumber == 0) passHoldNumber = 1;",
          "2382:     passInstructions[passIC++] = passHoldNumber;",
          "2383:     break;",
          "2384:    case pass_not:",
          "2385:     passInstructions[passIC++] = pass_not;",
          "2386:     passLinepos++;",
          "2387:     break;",
          "2388:    case pass_first:",
          "2389:     passInstructions[passIC++] = pass_first;",
          "2390:     passLinepos++;",
          "2391:     break;",
          "2392:    case pass_last:",
          "2393:     passInstructions[passIC++] = pass_last;",
          "2394:     passLinepos++;",
          "2395:     break;",
          "2396:    case pass_search:",
          "2397:     passInstructions[passIC++] = pass_search;",
          "2398:     passLinepos++;",
          "2399:     break;",
          "2400:    case pass_string:",
          "2401:     if (!verifyStringOrDots(nested, opcode, 1, 0, nofor)) {",
          "2402:      return 0;",
          "2403:     }",
          "2404:     passLinepos++;",
          "2405:     passInstructions[passIC++] = pass_string;",
          "2406:     passGetString(&passLine, &passLinepos, &passHoldString, passNested);",
          "2407:     goto testDoCharsDots;",
          "2408:    case pass_dots:",
          "2409:     if (!verifyStringOrDots(nested, opcode, 0, 0, nofor)) {",
          "2410:      return 0;",
          "2411:     }",
          "2412:     passLinepos++;",
          "2413:     passInstructions[passIC++] = pass_dots;",
          "2414:     passGetDots(&passLine, &passLinepos, &passHoldString, passNested);",
          "2415:    testDoCharsDots:",
          "2416:     if (passHoldString.length == 0) return 0;",
          "2417:     passInstructions[passIC++] = passHoldString.length;",
          "2418:     for (kk = 0; kk < passHoldString.length; kk++)",
          "2419:      passInstructions[passIC++] = passHoldString.chars[kk];",
          "2420:     break;",
          "2421:    case pass_startReplace:",
          "2422:     passInstructions[passIC++] = pass_startReplace;",
          "2423:     passLinepos++;",
          "2424:     break;",
          "2425:    case pass_endReplace:",
          "2426:     passInstructions[passIC++] = pass_endReplace;",
          "2427:     passLinepos++;",
          "2428:     break;",
          "2429:    case pass_variable:",
          "2430:     passLinepos++;",
          "2431:     if (!passGetVariableNumber(",
          "2432:        nested, &passLine, &passLinepos, &passHoldNumber))",
          "2433:      return 0;",
          "2434:     switch (passLine.chars[passLinepos]) {",
          "2435:     case pass_eq:",
          "2436:      passInstructions[passIC++] = pass_eq;",
          "2437:      goto doComp;",
          "2438:     case pass_lt:",
          "2439:      if (passLine.chars[passLinepos + 1] == pass_eq) {",
          "2440:       passLinepos++;",
          "2441:       passInstructions[passIC++] = pass_lteq;",
          "2442:      } else",
          "2443:       passInstructions[passIC++] = pass_lt;",
          "2444:      goto doComp;",
          "2445:     case pass_gt:",
          "2446:      if (passLine.chars[passLinepos + 1] == pass_eq) {",
          "2447:       passLinepos++;",
          "2448:       passInstructions[passIC++] = pass_gteq;",
          "2449:      } else",
          "2450:       passInstructions[passIC++] = pass_gt;",
          "2451:     doComp:",
          "2452:      passInstructions[passIC++] = passHoldNumber;",
          "2453:      passLinepos++;",
          "2454:      passGetNumber(&passLine, &passLinepos, &passHoldNumber);",
          "2455:      passInstructions[passIC++] = passHoldNumber;",
          "2456:      break;",
          "2457:     default:",
          "2458:      compileError(passNested, \"incorrect comparison operator\");",
          "2459:      return 0;",
          "2460:     }",
          "2461:     break;",
          "2462:    case pass_attributes:",
          "2463:     passLinepos++;",
          "2464:     if (!passGetAttributes(",
          "2465:        &passLine, &passLinepos, &passAttributes, passNested))",
          "2466:      return 0;",
          "2467:    insertAttributes:",
          "2468:     passInstructions[passIC++] = pass_attributes;",
          "2469:     passInstructions[passIC++] = passAttributes >> 16;",
          "2470:     passInstructions[passIC++] = passAttributes & 0xffff;",
          "2471:    getRange:",
          "2472:     if (passLine.chars[passLinepos] == pass_until) {",
          "2473:      passLinepos++;",
          "2474:      passInstructions[passIC++] = 1;",
          "2475:      passInstructions[passIC++] = 0xffff;",
          "2476:      break;",
          "2477:     }",
          "2478:     passGetNumber(&passLine, &passLinepos, &passHoldNumber);",
          "2479:     if (passHoldNumber == 0) {",
          "2480:      passHoldNumber = passInstructions[passIC++] = 1;",
          "2482:      break;",
          "2483:     }",
          "2484:     passInstructions[passIC++] = passHoldNumber;",
          "2485:     if (passLine.chars[passLinepos] != pass_hyphen) {",
          "2486:      passInstructions[passIC++] = passHoldNumber;",
          "2487:      break;",
          "2488:     }",
          "2489:     passLinepos++;",
          "2490:     passGetNumber(&passLine, &passLinepos, &passHoldNumber);",
          "2491:     if (passHoldNumber == 0) {",
          "2492:      compileError(passNested, \"invalid range\");",
          "2493:      return 0;",
          "2494:     }",
          "2495:     passInstructions[passIC++] = passHoldNumber;",
          "2496:     break;",
          "2497:    case pass_groupstart:",
          "2498:    case pass_groupend:",
          "2499:     passLinepos++;",
          "2500:     passGetName(&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "2501:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2502:     if (ruleOffset)",
          "2503:      rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];",
          "2504:     if (rule && rule->opcode == CTO_Grouping) {",
          "2505:      passInstructions[passIC++] = passSubOp;",
          "2506:      passInstructions[passIC++] = ruleOffset >> 16;",
          "2507:      passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2508:      break;",
          "2509:     } else {",
          "2510:      compileError(passNested, \"%s is not a grouping name\",",
          "2511:        _lou_showString(",
          "2512:          &passHoldString.chars[0], passHoldString.length));",
          "2513:      return 0;",
          "2514:     }",
          "2515:     break;",
          "2516:    case pass_swap:",
          "2517:     passGetName(&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "2518:     if ((class = findCharacterClass(&passHoldString, characterClasses))) {",
          "2519:      passAttributes = class->attribute;",
          "2520:      goto insertAttributes;",
          "2521:     }",
          "2522:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2523:     if (ruleOffset)",
          "2524:      rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];",
          "2525:     if (rule && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||",
          "2526:          rule->opcode == CTO_SwapDd)) {",
          "2527:      passInstructions[passIC++] = pass_swap;",
          "2528:      passInstructions[passIC++] = ruleOffset >> 16;",
          "2529:      passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2530:      goto getRange;",
          "2531:     }",
          "2532:     compileError(passNested, \"%s is neither a class name nor a swap name.\",",
          "2533:       _lou_showString(&passHoldString.chars[0], passHoldString.length));",
          "2534:     return 0;",
          "2535:    case pass_endTest:",
          "2536:     passInstructions[passIC++] = pass_endTest;",
          "2537:     passLinepos++;",
          "2538:     break;",
          "2539:    default:",
          "2540:     compileError(passNested, \"incorrect operator '%c ' in test part\",",
          "2541:       passLine.chars[passLinepos]);",
          "2542:     return 0;",
          "2543:    }",
          "2548:   while (passLinepos < passLine.length && passLine.chars[passLinepos] <= 32)",
          "2549:    passLinepos++;",
          "2550:   while (passLinepos < passLine.length && passLine.chars[passLinepos] > 32) {",
          "2551:    switch ((passSubOp = passLine.chars[passLinepos])) {",
          "2552:    case pass_string:",
          "2553:     if (!verifyStringOrDots(nested, opcode, 1, 1, nofor)) {",
          "2554:      return 0;",
          "2555:     }",
          "2556:     passLinepos++;",
          "2557:     passInstructions[passIC++] = pass_string;",
          "2558:     passGetString(&passLine, &passLinepos, &passHoldString, passNested);",
          "2559:     goto actionDoCharsDots;",
          "2560:    case pass_dots:",
          "2561:     if (!verifyStringOrDots(nested, opcode, 0, 1, nofor)) {",
          "2562:      return 0;",
          "2563:     }",
          "2564:     passLinepos++;",
          "2565:     passGetDots(&passLine, &passLinepos, &passHoldString, passNested);",
          "2566:     passInstructions[passIC++] = pass_dots;",
          "2567:    actionDoCharsDots:",
          "2568:     if (passHoldString.length == 0) return 0;",
          "2569:     passInstructions[passIC++] = passHoldString.length;",
          "2570:     for (kk = 0; kk < passHoldString.length; kk++)",
          "2571:      passInstructions[passIC++] = passHoldString.chars[kk];",
          "2572:     break;",
          "2573:    case pass_variable:",
          "2574:     passLinepos++;",
          "2575:     if (!passGetVariableNumber(",
          "2576:        nested, &passLine, &passLinepos, &passHoldNumber))",
          "2577:      return 0;",
          "2578:     switch (passLine.chars[passLinepos]) {",
          "2579:     case pass_eq:",
          "2580:      passInstructions[passIC++] = pass_eq;",
          "2581:      passInstructions[passIC++] = passHoldNumber;",
          "2582:      passLinepos++;",
          "2583:      passGetNumber(&passLine, &passLinepos, &passHoldNumber);",
          "2584:      passInstructions[passIC++] = passHoldNumber;",
          "2585:      break;",
          "2586:     case pass_plus:",
          "2587:     case pass_hyphen:",
          "2588:      passInstructions[passIC++] = passLine.chars[passLinepos++];",
          "2589:      passInstructions[passIC++] = passHoldNumber;",
          "2590:      break;",
          "2591:     default:",
          "2592:      compileError(",
          "2593:        passNested, \"incorrect variable operator in action part\");",
          "2594:      return 0;",
          "2595:     }",
          "2596:     break;",
          "2597:    case pass_copy:",
          "2598:     passInstructions[passIC++] = pass_copy;",
          "2599:     passLinepos++;",
          "2600:     break;",
          "2601:    case pass_omit:",
          "2602:     passInstructions[passIC++] = pass_omit;",
          "2603:     passLinepos++;",
          "2604:     break;",
          "2605:    case pass_groupreplace:",
          "2606:    case pass_groupstart:",
          "2607:    case pass_groupend:",
          "2608:     passLinepos++;",
          "2609:     passGetName(&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "2610:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2611:     if (ruleOffset)",
          "2612:      rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];",
          "2613:     if (rule && rule->opcode == CTO_Grouping) {",
          "2614:      passInstructions[passIC++] = passSubOp;",
          "2615:      passInstructions[passIC++] = ruleOffset >> 16;",
          "2616:      passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2617:      break;",
          "2618:     }",
          "2619:     compileError(passNested, \"%s is not a grouping name\",",
          "2620:       _lou_showString(&passHoldString.chars[0], passHoldString.length));",
          "2621:     return 0;",
          "2622:    case pass_swap:",
          "2623:     passLinepos++;",
          "2624:     passGetName(&passLine, &passLinepos, &passHoldString, passNested, *table);",
          "2625:     ruleOffset = findRuleName(&passHoldString, ruleNames);",
          "2626:     if (ruleOffset)",
          "2627:      rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];",
          "2628:     if (rule && (rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||",
          "2629:          rule->opcode == CTO_SwapDd)) {",
          "2630:      passInstructions[passIC++] = pass_swap;",
          "2631:      passInstructions[passIC++] = ruleOffset >> 16;",
          "2632:      passInstructions[passIC++] = ruleOffset & 0xffff;",
          "2633:      break;",
          "2634:     }",
          "2635:     compileError(passNested, \"%s is not a swap name.\",",
          "2636:       _lou_showString(&passHoldString.chars[0], passHoldString.length));",
          "2637:     return 0;",
          "2638:     break;",
          "2639:    default:",
          "2640:     compileError(passNested, \"incorrect operator in action part\");",
          "2641:     return 0;",
          "2642:    }",
          "2647:  passRuleDots.length = passIC;",
          "2650:   widechar *characters;",
          "2651:   int length;",
          "2652:   int found = passFindCharacters(passNested, 0, passInstructions,",
          "2653:     passRuleDots.length, &characters, &length);",
          "2655:   if (!found) return 0;",
          "2657:   if (characters) {",
          "2658:    for (k = 0; k < length; k += 1) passRuleChars.chars[k] = characters[k];",
          "2659:    passRuleChars.length = k;",
          "2663:  if (!addRule(passNested, opcode, &passRuleChars, &passRuleDots, 0, 0, newRuleOffset,",
          "2664:     newRule, noback, nofor, table))",
          "2666:  return 1;",
          "2672: compileBrailleIndicator(FileInfo *nested, char *ermsg, TranslationTableOpcode opcode,",
          "2673:   TranslationTableOffset *rule, int *lastToken,",
          "2674:   TranslationTableOffset *newRuleOffset, TranslationTableRule **newRule, int noback,",
          "2675:   int nofor, TranslationTableHeader **table) {",
          "2676:  CharsString token;",
          "2677:  CharsString cells;",
          "2678:  if (getToken(nested, &token, ermsg, lastToken))",
          "2679:   if (parseDots(nested, &cells, &token))",
          "2680:    if (!addRule(nested, opcode, NULL, &cells, 0, 0, newRuleOffset, newRule,",
          "2681:       noback, nofor, table))",
          "2682:     return 0;",
          "2684:  return 1;",
          "2688: compileNumber(FileInfo *nested, int *lastToken) {",
          "2689:  CharsString token;",
          "2690:  widechar dest;",
          "2691:  if (!getToken(nested, &token, \"number\", lastToken)) return 0;",
          "2692:  getNumber(&token.chars[0], &dest);",
          "2693:  if (!(dest > 0)) {",
          "2694:   compileError(nested, \"a nonzero positive number is required\");",
          "2695:   return 0;",
          "2696:  }",
          "2697:  return dest;",
          "2701: compileGrouping(FileInfo *nested, int *lastToken, TranslationTableOffset *newRuleOffset,",
          "2702:   TranslationTableRule **newRule, int noback, int nofor, RuleName **ruleNames,",
          "2703:   TranslationTableHeader **table) {",
          "2704:  int k;",
          "2705:  CharsString name;",
          "2706:  CharsString groupChars;",
          "2707:  CharsString groupDots;",
          "2708:  CharsString dotsParsed;",
          "2709:  TranslationTableCharacter *charsDotsPtr;",
          "2710:  widechar endChar;",
          "2711:  widechar endDots;",
          "2712:  if (!getToken(nested, &name, \"name operand\", lastToken)) return 0;",
          "2713:  if (!getRuleCharsText(nested, &groupChars, lastToken)) return 0;",
          "2714:  if (!getToken(nested, &groupDots, \"dots operand\", lastToken)) return 0;",
          "2715:  for (k = 0; k < groupDots.length && groupDots.chars[k] != ','; k++)",
          "2716:   ;",
          "2717:  if (k == groupDots.length) {",
          "2718:   compileError(",
          "2719:     nested, \"Dots operand must consist of two cells separated by a comma\");",
          "2720:   return 0;",
          "2721:  }",
          "2722:  groupDots.chars[k] = '-';",
          "2723:  if (!parseDots(nested, &dotsParsed, &groupDots)) return 0;",
          "2724:  if (groupChars.length != 2 || dotsParsed.length != 2) {",
          "2725:   compileError(nested,",
          "2726:     \"two Unicode characters and two cells separated by a comma are needed.\");",
          "2727:   return 0;",
          "2728:  }",
          "2729:  charsDotsPtr = addCharOrDots(nested, groupChars.chars[0], 0, table);",
          "2730:  charsDotsPtr->attributes |= CTC_Math;",
          "2731:  charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "2732:  charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "2733:  charsDotsPtr = addCharOrDots(nested, groupChars.chars[1], 0, table);",
          "2734:  charsDotsPtr->attributes |= CTC_Math;",
          "2735:  charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "2736:  charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "2737:  charsDotsPtr = addCharOrDots(nested, dotsParsed.chars[0], 1, table);",
          "2738:  charsDotsPtr->attributes |= CTC_Math;",
          "2739:  charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "2740:  charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "2741:  charsDotsPtr = addCharOrDots(nested, dotsParsed.chars[1], 1, table);",
          "2742:  charsDotsPtr->attributes |= CTC_Math;",
          "2743:  charsDotsPtr->uppercase = charsDotsPtr->realchar;",
          "2744:  charsDotsPtr->lowercase = charsDotsPtr->realchar;",
          "2745:  if (!addRule(nested, CTO_Grouping, &groupChars, &dotsParsed, 0, 0, newRuleOffset,",
          "2746:     newRule, noback, nofor, table))",
          "2747:   return 0;",
          "2748:  if (!addRuleName(nested, &name, newRuleOffset, ruleNames, *table)) return 0;",
          "2749:  putCharAndDots(nested, groupChars.chars[0], dotsParsed.chars[0], table);",
          "2750:  putCharAndDots(nested, groupChars.chars[1], dotsParsed.chars[1], table);",
          "2751:  endChar = groupChars.chars[1];",
          "2752:  endDots = dotsParsed.chars[1];",
          "2753:  groupChars.length = dotsParsed.length = 1;",
          "2754:  if (!addRule(nested, CTO_Math, &groupChars, &dotsParsed, 0, 0, newRuleOffset, newRule,",
          "2755:     noback, nofor, table))",
          "2756:   return 0;",
          "2757:  groupChars.chars[0] = endChar;",
          "2758:  dotsParsed.chars[0] = endDots;",
          "2759:  if (!addRule(nested, CTO_Math, &groupChars, &dotsParsed, 0, 0, newRuleOffset, newRule,",
          "2760:     noback, nofor, table))",
          "2761:   return 0;",
          "2762:  return 1;",
          "2766: compileUplow(FileInfo *nested, int *lastToken, TranslationTableOffset *newRuleOffset,",
          "2767:   TranslationTableRule **newRule, int noback, int nofor,",
          "2768:   TranslationTableHeader **table) {",
          "2769:  int k;",
          "2770:  TranslationTableCharacter *upperChar;",
          "2771:  TranslationTableCharacter *lowerChar;",
          "2772:  TranslationTableCharacter *upperCell = NULL;",
          "2773:  TranslationTableCharacter *lowerCell = NULL;",
          "2774:  CharsString ruleChars;",
          "2775:  CharsString ruleDots;",
          "2776:  CharsString upperDots;",
          "2777:  CharsString lowerDots;",
          "2778:  int haveLowerDots = 0;",
          "2779:  TranslationTableCharacterAttributes attr;",
          "2780:  if (!getRuleCharsText(nested, &ruleChars, lastToken)) return 0;",
          "2781:  if (!getToken(nested, &ruleDots, \"dots operand\", lastToken)) return 0;",
          "2782:  for (k = 0; k < ruleDots.length && ruleDots.chars[k] != ','; k++)",
          "2783:   ;",
          "2784:  if (k == ruleDots.length) {",
          "2785:   if (!parseDots(nested, &upperDots, &ruleDots)) return 0;",
          "2786:   lowerDots.length = upperDots.length;",
          "2787:   for (k = 0; k < upperDots.length; k++) lowerDots.chars[k] = upperDots.chars[k];",
          "2788:   lowerDots.chars[k] = 0;",
          "2789:  } else {",
          "2790:   haveLowerDots = ruleDots.length;",
          "2791:   ruleDots.length = k;",
          "2792:   if (!parseDots(nested, &upperDots, &ruleDots)) return 0;",
          "2793:   ruleDots.length = 0;",
          "2794:   k++;",
          "2795:   for (; k < haveLowerDots; k++)",
          "2796:    ruleDots.chars[ruleDots.length++] = ruleDots.chars[k];",
          "2797:   if (!parseDots(nested, &lowerDots, &ruleDots)) return 0;",
          "2798:  }",
          "2799:  if (ruleChars.length != 2 || upperDots.length < 1) {",
          "2800:   compileError(nested,",
          "2801:     \"Exactly two Unicode characters and at least one cell are required.\");",
          "2802:   return 0;",
          "2803:  }",
          "2804:  if (haveLowerDots && lowerDots.length < 1) {",
          "2805:   compileError(nested, \"at least one cell is required after the comma.\");",
          "2806:   return 0;",
          "2807:  }",
          "2808:  upperChar = addCharOrDots(nested, ruleChars.chars[0], 0, table);",
          "2809:  upperChar->attributes |= CTC_Letter | CTC_UpperCase;",
          "2810:  upperChar->uppercase = ruleChars.chars[0];",
          "2811:  upperChar->lowercase = ruleChars.chars[1];",
          "2812:  lowerChar = addCharOrDots(nested, ruleChars.chars[1], 0, table);",
          "2813:  lowerChar->attributes |= CTC_Letter | CTC_LowerCase;",
          "2814:  lowerChar->uppercase = ruleChars.chars[0];",
          "2815:  lowerChar->lowercase = ruleChars.chars[1];",
          "2816:  for (k = 0; k < upperDots.length; k++)",
          "2817:   if (!compile_findCharOrDots(upperDots.chars[k], 1, *table)) {",
          "2818:    attr = CTC_Letter | CTC_UpperCase;",
          "2819:    upperCell = addCharOrDots(nested, upperDots.chars[k], 1, table);",
          "2820:    upperCell->attributes |= attr;",
          "2821:    upperCell->uppercase = upperCell->realchar;",
          "2822:   }",
          "2823:  if (haveLowerDots) {",
          "2824:   for (k = 0; k < lowerDots.length; k++)",
          "2825:    if (!compile_findCharOrDots(lowerDots.chars[k], 1, *table)) {",
          "2826:     attr = CTC_Letter | CTC_LowerCase;",
          "2827:     lowerCell = addCharOrDots(nested, lowerDots.chars[k], 1, table);",
          "2828:     if (lowerDots.length != 1) attr = CTC_Space;",
          "2829:     lowerCell->attributes |= attr;",
          "2830:     lowerCell->lowercase = lowerCell->realchar;",
          "2831:    }",
          "2832:  } else if (upperCell != NULL && upperDots.length == 1)",
          "2833:   upperCell->attributes |= CTC_LowerCase;",
          "2834:  if (lowerDots.length == 1)",
          "2835:   putCharAndDots(nested, ruleChars.chars[1], lowerDots.chars[0], table);",
          "2836:  if (upperCell != NULL) upperCell->lowercase = lowerDots.chars[0];",
          "2837:  if (lowerCell != NULL) lowerCell->uppercase = upperDots.chars[0];",
          "2838:  if (upperDots.length == 1)",
          "2839:   putCharAndDots(nested, ruleChars.chars[0], upperDots.chars[0], table);",
          "2840:  ruleChars.length = 1;",
          "2841:  ruleChars.chars[2] = ruleChars.chars[0];",
          "2842:  ruleChars.chars[0] = ruleChars.chars[1];",
          "2843:  if (!addRule(nested, CTO_LowerCase, &ruleChars, &lowerDots, 0, 0, newRuleOffset,",
          "2844:     newRule, noback, nofor, table))",
          "2845:   return 0;",
          "2846:  ruleChars.chars[0] = ruleChars.chars[2];",
          "2847:  if (!addRule(nested, CTO_UpperCase, &ruleChars, &upperDots, 0, 0, newRuleOffset,",
          "2848:     newRule, noback, nofor, table))",
          "2849:   return 0;",
          "2850:  return 1;",
          "2856:  int numStates;",
          "2857:  HyphenationState *states;",
          "2864:  struct HyphenHashEntry *next;",
          "2865:  CharsString *key;",
          "2866:  int val;",
          "2869: typedef struct HyphenHashTab { HyphenHashEntry *entries[HYPHENHASHSIZE]; } HyphenHashTab;",
          "2873: hyphenStringHash(const CharsString *s) {",
          "2874:  int k;",
          "2875:  unsigned int h = 0, g;",
          "2876:  for (k = 0; k < s->length; k++) {",
          "2877:   h = (h << 4) + s->chars[k];",
          "2878:   if ((g = h & 0xf0000000)) {",
          "2879:    h = h ^ (g >> 24);",
          "2880:    h = h ^ g;",
          "2881:   }",
          "2883:  return h;",
          "2887: hyphenHashNew(void) {",
          "2888:  HyphenHashTab *hashTab;",
          "2889:  if (!(hashTab = malloc(sizeof(HyphenHashTab)))) _lou_outOfMemory();",
          "2890:  memset(hashTab, 0, sizeof(HyphenHashTab));",
          "2891:  return hashTab;",
          "2895: hyphenHashFree(HyphenHashTab *hashTab) {",
          "2896:  int i;",
          "2897:  HyphenHashEntry *e, *next;",
          "2898:  for (i = 0; i < HYPHENHASHSIZE; i++)",
          "2899:   for (e = hashTab->entries[i]; e; e = next) {",
          "2900:    next = e->next;",
          "2901:    free(e->key);",
          "2902:    free(e);",
          "2903:   }",
          "2904:  free(hashTab);",
          "2909: hyphenHashInsert(HyphenHashTab *hashTab, const CharsString *key, int val) {",
          "2910:  int i, j;",
          "2911:  HyphenHashEntry *e;",
          "2912:  i = hyphenStringHash(key) % HYPHENHASHSIZE;",
          "2913:  if (!(e = malloc(sizeof(HyphenHashEntry)))) _lou_outOfMemory();",
          "2914:  e->next = hashTab->entries[i];",
          "2915:  e->key = malloc((key->length + 1) * CHARSIZE);",
          "2916:  if (!e->key) _lou_outOfMemory();",
          "2917:  e->key->length = key->length;",
          "2918:  for (j = 0; j < key->length; j++) e->key->chars[j] = key->chars[j];",
          "2919:  e->val = val;",
          "2920:  hashTab->entries[i] = e;",
          "2925: hyphenHashLookup(HyphenHashTab *hashTab, const CharsString *key) {",
          "2926:  int i, j;",
          "2927:  HyphenHashEntry *e;",
          "2928:  if (key->length == 0) return 0;",
          "2929:  i = hyphenStringHash(key) % HYPHENHASHSIZE;",
          "2930:  for (e = hashTab->entries[i]; e; e = e->next) {",
          "2931:   if (key->length != e->key->length) continue;",
          "2932:   for (j = 0; j < key->length; j++)",
          "2933:    if (key->chars[j] != e->key->chars[j]) break;",
          "2934:   if (j == key->length) return e->val;",
          "2935:  }",
          "2936:  return DEFAULTSTATE;",
          "2940: hyphenGetNewState(HyphenDict *dict, HyphenHashTab *hashTab, const CharsString *string) {",
          "2941:  hyphenHashInsert(hashTab, string, dict->numStates);",
          "2943:  if (!(dict->numStates & (dict->numStates - 1)))",
          "2944:   dict->states =",
          "2945:     realloc(dict->states, (dict->numStates << 1) * sizeof(HyphenationState));",
          "2946:  if (!dict->states) _lou_outOfMemory();",
          "2947:  dict->states[dict->numStates].hyphenPattern = 0;",
          "2948:  dict->states[dict->numStates].fallbackState = DEFAULTSTATE;",
          "2949:  dict->states[dict->numStates].numTrans = 0;",
          "2950:  dict->states[dict->numStates].trans.pointer = NULL;",
          "2951:  return dict->numStates++;",
          "2957: hyphenAddTrans(HyphenDict *dict, int state1, int state2, widechar ch) {",
          "2958:  int numTrans;",
          "2959:  numTrans = dict->states[state1].numTrans;",
          "2960:  if (numTrans == 0)",
          "2961:   dict->states[state1].trans.pointer = malloc(sizeof(HyphenationTrans));",
          "2962:  else if (!(numTrans & (numTrans - 1)))",
          "2963:   dict->states[state1].trans.pointer = realloc(dict->states[state1].trans.pointer,",
          "2964:     (numTrans << 1) * sizeof(HyphenationTrans));",
          "2965:  dict->states[state1].trans.pointer[numTrans].ch = ch;",
          "2966:  dict->states[state1].trans.pointer[numTrans].newState = state2;",
          "2967:  dict->states[state1].numTrans++;",
          "2971: compileHyphenation(FileInfo *nested, CharsString *encoding, int *lastToken,",
          "2972:   TranslationTableHeader **table) {",
          "2973:  CharsString hyph;",
          "2974:  HyphenationTrans *holdPointer;",
          "2975:  HyphenHashTab *hashTab;",
          "2976:  CharsString word;",
          "2977:  char pattern[MAXSTRING];",
          "2978:  unsigned int stateNum = 0, lastState = 0;",
          "2979:  int i, j, k = encoding->length;",
          "2980:  widechar ch;",
          "2981:  int found;",
          "2982:  HyphenHashEntry *e;",
          "2983:  HyphenDict dict;",
          "2984:  TranslationTableOffset holdOffset;",
          "2987:  reserveSpaceInTable(nested, 250000, table);",
          "2988:  hashTab = hyphenHashNew();",
          "2989:  dict.numStates = 1;",
          "2990:  dict.states = malloc(sizeof(HyphenationState));",
          "2991:  if (!dict.states) _lou_outOfMemory();",
          "2992:  dict.states[0].hyphenPattern = 0;",
          "2993:  dict.states[0].fallbackState = DEFAULTSTATE;",
          "2994:  dict.states[0].numTrans = 0;",
          "2995:  dict.states[0].trans.pointer = NULL;",
          "2996:  do {",
          "2997:   if (encoding->chars[0] == 'I') {",
          "2998:    if (!getToken(nested, &hyph, NULL, lastToken)) continue;",
          "2999:   } else {",
          "3001:    if (!getToken(nested, &word, NULL, lastToken)) continue;",
          "3002:    parseChars(nested, &hyph, &word);",
          "3003:   }",
          "3004:   if (hyph.length == 0 || hyph.chars[0] == '#' || hyph.chars[0] == '%' ||",
          "3005:     hyph.chars[0] == '<')",
          "3007:   for (i = 0; i < hyph.length; i++)",
          "3008:    definedCharOrDots(nested, hyph.chars[i], 0, *table);",
          "3009:   j = 0;",
          "3010:   pattern[j] = '0';",
          "3011:   for (i = 0; i < hyph.length; i++) {",
          "3012:    if (hyph.chars[i] >= '0' && hyph.chars[i] <= '9')",
          "3013:     pattern[j] = (char)hyph.chars[i];",
          "3014:    else {",
          "3015:     word.chars[j] = hyph.chars[i];",
          "3016:     pattern[++j] = '0';",
          "3017:    }",
          "3018:   }",
          "3019:   word.chars[j] = 0;",
          "3020:   word.length = j;",
          "3021:   pattern[j + 1] = 0;",
          "3022:   for (i = 0; pattern[i] == '0'; i++)",
          "3023:    ;",
          "3024:   found = hyphenHashLookup(hashTab, &word);",
          "3025:   if (found != DEFAULTSTATE)",
          "3026:    stateNum = found;",
          "3027:   else",
          "3028:    stateNum = hyphenGetNewState(&dict, hashTab, &word);",
          "3029:   k = j + 2 - i;",
          "3030:   if (k > 0) {",
          "3031:    allocateSpaceInTable(nested, &dict.states[stateNum].hyphenPattern, k, table);",
          "3032:    memcpy(&(*table)->ruleArea[dict.states[stateNum].hyphenPattern], &pattern[i],",
          "3033:      k);",
          "3034:   }",
          "3036:   while (found == DEFAULTSTATE) {",
          "3037:    lastState = stateNum;",
          "3038:    ch = word.chars[word.length-- - 1];",
          "3039:    found = hyphenHashLookup(hashTab, &word);",
          "3040:    if (found != DEFAULTSTATE)",
          "3041:     stateNum = found;",
          "3042:    else",
          "3043:     stateNum = hyphenGetNewState(&dict, hashTab, &word);",
          "3044:    hyphenAddTrans(&dict, stateNum, lastState, ch);",
          "3045:   }",
          "3046:  } while (_lou_getALine(nested));",
          "3048:  for (i = 0; i < HYPHENHASHSIZE; i++) {",
          "3049:   for (e = hashTab->entries[i]; e; e = e->next) {",
          "3050:    for (j = 1; j <= e->key->length; j++) {",
          "3051:     word.length = 0;",
          "3052:     for (k = j; k < e->key->length; k++)",
          "3053:      word.chars[word.length++] = e->key->chars[k];",
          "3054:     stateNum = hyphenHashLookup(hashTab, &word);",
          "3055:     if (stateNum != DEFAULTSTATE) break;",
          "3056:    }",
          "3057:    if (e->val) dict.states[e->val].fallbackState = stateNum;",
          "3058:   }",
          "3060:  hyphenHashFree(hashTab);",
          "3062:  for (i = 0; i < dict.numStates; i++) {",
          "3063:   if (dict.states[i].numTrans == 0)",
          "3064:    dict.states[i].trans.offset = 0;",
          "3065:   else {",
          "3066:    holdPointer = dict.states[i].trans.pointer;",
          "3067:    allocateSpaceInTable(nested, &dict.states[i].trans.offset,",
          "3068:      dict.states[i].numTrans * sizeof(HyphenationTrans), table);",
          "3069:    memcpy(&(*table)->ruleArea[dict.states[i].trans.offset], holdPointer,",
          "3070:      dict.states[i].numTrans * sizeof(HyphenationTrans));",
          "3071:    free(holdPointer);",
          "3072:   }",
          "3074:  allocateSpaceInTable(",
          "3075:    nested, &holdOffset, dict.numStates * sizeof(HyphenationState), table);",
          "3076:  (*table)->hyphenStatesArray = holdOffset;",
          "3078:  memcpy(&(*table)->ruleArea[(*table)->hyphenStatesArray], &dict.states[0],",
          "3079:    dict.numStates * sizeof(HyphenationState));",
          "3080:  free(dict.states);",
          "3081:  return 1;",
          "3085: compileCharDef(FileInfo *nested, TranslationTableOpcode opcode,",
          "3086:   TranslationTableCharacterAttributes attributes, int *lastToken,",
          "3087:   TranslationTableOffset *newRuleOffset, TranslationTableRule **newRule, int noback,",
          "3088:   int nofor, TranslationTableHeader **table) {",
          "3089:  CharsString ruleChars;",
          "3090:  CharsString ruleDots;",
          "3091:  TranslationTableCharacter *character;",
          "3092:  TranslationTableCharacter *cell = NULL;",
          "3093:  int k;",
          "3094:  if (!getRuleCharsText(nested, &ruleChars, lastToken)) return 0;",
          "3095:  if (!getRuleDotsPattern(nested, &ruleDots, lastToken)) return 0;",
          "3096:  if (ruleChars.length != 1) {",
          "3097:   compileError(nested, \"Exactly one character is required.\");",
          "3098:   return 0;",
          "3099:  }",
          "3100:  if (ruleDots.length < 1) {",
          "3101:   compileError(nested, \"At least one cell is required.\");",
          "3102:   return 0;",
          "3103:  }",
          "3104:  if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;",
          "3105:  character = addCharOrDots(nested, ruleChars.chars[0], 0, table);",
          "3106:  character->attributes |= attributes;",
          "3107:  character->uppercase = character->lowercase = character->realchar;",
          "3108:  for (k = ruleDots.length - 1; k >= 0; k -= 1) {",
          "3109:   cell = compile_findCharOrDots(ruleDots.chars[k], 1, *table);",
          "3110:   if (!cell) {",
          "3111:    cell = addCharOrDots(nested, ruleDots.chars[k], 1, table);",
          "3112:    cell->uppercase = cell->lowercase = cell->realchar;",
          "3113:   }",
          "3114:  }",
          "3115:  if (ruleDots.length == 1) {",
          "3116:   cell->attributes |= attributes;",
          "3117:   putCharAndDots(nested, ruleChars.chars[0], ruleDots.chars[0], table);",
          "3119:  if (!addRule(nested, opcode, &ruleChars, &ruleDots, 0, 0, newRuleOffset, newRule,",
          "3120:     noback, nofor, table))",
          "3121:   return 0;",
          "3122:  return 1;",
          "3126: compileBeforeAfter(FileInfo *nested, int *lastToken) {",
          "3132:    if (eqasc2uni((unsigned char *)\"before\", tmp.chars, 6)) return 1;",
          "3133:    if (eqasc2uni((unsigned char *)\"after\", tmp.chars, 5)) return 2;",
          "3139: compileRule(FileInfo *nested, CharacterClass **characterClasses,",
          "3140:   TranslationTableCharacterAttributes *characterClassAttribute,",
          "3141:   short opcodeLengths[], TranslationTableOffset *newRuleOffset,",
          "3142:   TranslationTableRule **newRule, RuleName **ruleNames,",
          "3143:   TranslationTableHeader **table) {",
          "3144:  int lastToken = 0;",
          "3145:  int ok = 1;",
          "3146:  CharsString token;",
          "3147:  TranslationTableOpcode opcode;",
          "3148:  CharsString ruleChars;",
          "3149:  CharsString ruleDots;",
          "3150:  CharsString cells;",
          "3151:  CharsString scratchPad;",
          "3152:  CharsString emphClass;",
          "3153:  TranslationTableCharacterAttributes after = 0;",
          "3154:  TranslationTableCharacterAttributes before = 0;",
          "3156:  widechar *patterns = NULL;",
          "3157:  int k, i;",
          "3158:  int noback, nofor;",
          "3159:  noback = nofor = 0;",
          "3160:  TranslationTableOffset tmp_offset;",
          "3164:  if (nested->lineNumber == 1 &&",
          "3165:    (eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||",
          "3166:      eqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {",
          "3167:   compileHyphenation(nested, &token, &lastToken, table);",
          "3168:   return 1;",
          "3169:  }",
          "3170:  opcode = getOpcode(nested, &token, opcodeLengths);",
          "3173:  case CTO_None:",
          "3174:   break;",
          "3175:  case CTO_IncludeFile: {",
          "3176:   CharsString includedFile;",
          "3177:   if (getToken(nested, &token, \"include file name\", &lastToken))",
          "3178:    if (parseChars(nested, &includedFile, &token))",
          "3179:     if (!includeFile(nested, &includedFile, characterClasses,",
          "3180:        characterClassAttribute, opcodeLengths, newRuleOffset,",
          "3181:        newRule, ruleNames, table))",
          "3182:      ok = 0;",
          "3183:   break;",
          "3184:  }",
          "3185:  case CTO_Locale:",
          "3186:   break;",
          "3187:  case CTO_Undefined:",
          "3188:   tmp_offset = (*table)->undefined;",
          "3189:   ok = compileBrailleIndicator(nested, \"undefined character opcode\", CTO_Undefined,",
          "3190:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3191:   (*table)->undefined = tmp_offset;",
          "3192:   break;",
          "3194:  case CTO_Match: {",
          "3195:   CharsString ptn_before, ptn_after;",
          "3196:   TranslationTableOffset offset;",
          "3197:   int len, mrk;",
          "3199:   size_t patternsByteSize = sizeof(*patterns) * 27720;",
          "3200:   patterns = (widechar *)malloc(patternsByteSize);",
          "3201:   if (!patterns) _lou_outOfMemory();",
          "3202:   memset(patterns, 0xffff, patternsByteSize);",
          "3204:   noback = 1;",
          "3205:   getCharacters(nested, &ptn_before, &lastToken);",
          "3206:   getRuleCharsText(nested, &ruleChars, &lastToken);",
          "3207:   getCharacters(nested, &ptn_after, &lastToken);",
          "3208:   getRuleDotsPattern(nested, &ruleDots, &lastToken);",
          "3210:   if (!addRule(nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset,",
          "3211:      newRule, noback, nofor, table))",
          "3212:    ok = 0;",
          "3214:   if (ptn_before.chars[0] == '-' && ptn_before.length == 1)",
          "3215:    len = _lou_pattern_compile(",
          "3216:      &ptn_before.chars[0], 0, &patterns[1], 13841, *table);",
          "3217:   else",
          "3218:    len = _lou_pattern_compile(",
          "3219:      &ptn_before.chars[0], ptn_before.length, &patterns[1], 13841, *table);",
          "3220:   if (!len) {",
          "3221:    ok = 0;",
          "3222:    break;",
          "3223:   }",
          "3224:   mrk = patterns[0] = len + 1;",
          "3225:   _lou_pattern_reverse(&patterns[1]);",
          "3227:   if (ptn_after.chars[0] == '-' && ptn_after.length == 1)",
          "3228:    len = _lou_pattern_compile(",
          "3229:      &ptn_after.chars[0], 0, &patterns[mrk], 13841, *table);",
          "3230:   else",
          "3231:    len = _lou_pattern_compile(",
          "3232:      &ptn_after.chars[0], ptn_after.length, &patterns[mrk], 13841, *table);",
          "3233:   if (!len) {",
          "3234:    ok = 0;",
          "3235:    break;",
          "3236:   }",
          "3237:   len += mrk;",
          "3239:   if (!allocateSpaceInTable(nested, &offset, len * sizeof(widechar), table)) {",
          "3240:    ok = 0;",
          "3241:    break;",
          "3242:   }",
          "3247:   memcpy(&(*table)->ruleArea[offset], patterns, len * sizeof(widechar));",
          "3248:   (*newRule)->patterns = offset;",
          "3250:   break;",
          "3251:  }",
          "3253:  case CTO_BackMatch: {",
          "3254:   CharsString ptn_before, ptn_after;",
          "3255:   TranslationTableOffset offset;",
          "3256:   int len, mrk;",
          "3258:   size_t patternsByteSize = sizeof(*patterns) * 27720;",
          "3259:   patterns = (widechar *)malloc(patternsByteSize);",
          "3260:   if (!patterns) _lou_outOfMemory();",
          "3261:   memset(patterns, 0xffff, patternsByteSize);",
          "3263:   nofor = 1;",
          "3264:   getCharacters(nested, &ptn_before, &lastToken);",
          "3265:   getRuleCharsText(nested, &ruleChars, &lastToken);",
          "3266:   getCharacters(nested, &ptn_after, &lastToken);",
          "3267:   getRuleDotsPattern(nested, &ruleDots, &lastToken);",
          "3269:   if (!addRule(nested, opcode, &ruleChars, &ruleDots, 0, 0, newRuleOffset, newRule,",
          "3270:      noback, nofor, table))",
          "3271:    ok = 0;",
          "3273:   if (ptn_before.chars[0] == '-' && ptn_before.length == 1)",
          "3274:    len = _lou_pattern_compile(",
          "3275:      &ptn_before.chars[0], 0, &patterns[1], 13841, *table);",
          "3276:   else",
          "3277:    len = _lou_pattern_compile(",
          "3278:      &ptn_before.chars[0], ptn_before.length, &patterns[1], 13841, *table);",
          "3279:   if (!len) {",
          "3280:    ok = 0;",
          "3281:    break;",
          "3282:   }",
          "3283:   mrk = patterns[0] = len + 1;",
          "3284:   _lou_pattern_reverse(&patterns[1]);",
          "3286:   if (ptn_after.chars[0] == '-' && ptn_after.length == 1)",
          "3287:    len = _lou_pattern_compile(",
          "3288:      &ptn_after.chars[0], 0, &patterns[mrk], 13841, *table);",
          "3289:   else",
          "3290:    len = _lou_pattern_compile(",
          "3291:      &ptn_after.chars[0], ptn_after.length, &patterns[mrk], 13841, *table);",
          "3292:   if (!len) {",
          "3293:    ok = 0;",
          "3294:    break;",
          "3295:   }",
          "3296:   len += mrk;",
          "3298:   if (!allocateSpaceInTable(nested, &offset, len * sizeof(widechar), table)) {",
          "3299:    ok = 0;",
          "3300:    break;",
          "3301:   }",
          "3306:   memcpy(&(*table)->ruleArea[offset], patterns, len * sizeof(widechar));",
          "3307:   (*newRule)->patterns = offset;",
          "3309:   break;",
          "3310:  }",
          "3312:  case CTO_BegCapsPhrase:",
          "3313:   tmp_offset = (*table)->emphRules[capsRule][begPhraseOffset];",
          "3314:   ok = compileBrailleIndicator(nested, \"first word capital sign\",",
          "3315:     CTO_BegCapsPhraseRule, &tmp_offset, &lastToken, newRuleOffset, newRule,",
          "3316:     noback, nofor, table);",
          "3317:   (*table)->emphRules[capsRule][begPhraseOffset] = tmp_offset;",
          "3318:   break;",
          "3319:  case CTO_EndCapsPhrase:",
          "3321:   case 1:  // before",
          "3322:    if ((*table)->emphRules[capsRule][endPhraseAfterOffset]) {",
          "3323:     compileError(nested, \"Capital sign after last word already defined.\");",
          "3324:     ok = 0;",
          "3326:    }",
          "3327:    tmp_offset = (*table)->emphRules[capsRule][endPhraseBeforeOffset];",
          "3328:    ok = compileBrailleIndicator(nested, \"capital sign before last word\",",
          "3329:      CTO_EndCapsPhraseBeforeRule, &tmp_offset, &lastToken, newRuleOffset,",
          "3330:      newRule, noback, nofor, table);",
          "3331:    (*table)->emphRules[capsRule][endPhraseBeforeOffset] = tmp_offset;",
          "3332:    break;",
          "3333:   case 2:  // after",
          "3334:    if ((*table)->emphRules[capsRule][endPhraseBeforeOffset]) {",
          "3335:     compileError(nested, \"Capital sign before last word already defined.\");",
          "3338:    }",
          "3339:    tmp_offset = (*table)->emphRules[capsRule][endPhraseAfterOffset];",
          "3340:    ok = compileBrailleIndicator(nested, \"capital sign after last word\",",
          "3341:      CTO_EndCapsPhraseAfterRule, &tmp_offset, &lastToken, newRuleOffset,",
          "3342:      newRule, noback, nofor, table);",
          "3343:    (*table)->emphRules[capsRule][endPhraseAfterOffset] = tmp_offset;",
          "3344:    break;",
          "3345:   default:  // error",
          "3346:    compileError(nested, \"Invalid lastword indicator location.\");",
          "3347:    ok = 0;",
          "3348:    break;",
          "3351:  case CTO_BegCaps:",
          "3352:   tmp_offset = (*table)->emphRules[capsRule][begOffset];",
          "3353:   ok = compileBrailleIndicator(nested, \"first letter capital sign\", CTO_BegCapsRule,",
          "3354:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3355:   (*table)->emphRules[capsRule][begOffset] = tmp_offset;",
          "3357:  case CTO_EndCaps:",
          "3358:   tmp_offset = (*table)->emphRules[capsRule][endOffset];",
          "3359:   ok = compileBrailleIndicator(nested, \"last letter capital sign\", CTO_EndCapsRule,",
          "3360:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3361:   (*table)->emphRules[capsRule][endOffset] = tmp_offset;",
          "3363:  case CTO_CapsLetter:",
          "3364:   tmp_offset = (*table)->emphRules[capsRule][letterOffset];",
          "3365:   ok = compileBrailleIndicator(nested, \"single letter capital sign\",",
          "3366:     CTO_CapsLetterRule, &tmp_offset, &lastToken, newRuleOffset, newRule,",
          "3367:     noback, nofor, table);",
          "3368:   (*table)->emphRules[capsRule][letterOffset] = tmp_offset;",
          "3370:  case CTO_BegCapsWord:",
          "3371:   tmp_offset = (*table)->emphRules[capsRule][begWordOffset];",
          "3372:   ok = compileBrailleIndicator(nested, \"capital word\", CTO_BegCapsWordRule,",
          "3374:   (*table)->emphRules[capsRule][begWordOffset] = tmp_offset;",
          "3375:   break;",
          "3376:  case CTO_EndCapsWord:",
          "3377:   tmp_offset = (*table)->emphRules[capsRule][endWordOffset];",
          "3378:   ok = compileBrailleIndicator(nested, \"capital word stop\", CTO_EndCapsWordRule,",
          "3380:   (*table)->emphRules[capsRule][endWordOffset] = tmp_offset;",
          "3381:   break;",
          "3382:  case CTO_LenCapsPhrase:",
          "3383:   ok = (*table)->emphRules[capsRule][lenPhraseOffset] =",
          "3384:     compileNumber(nested, &lastToken);",
          "3385:   break;",
          "3398:  case CTO_EmphClass:",
          "3399:   if (getToken(nested, &token, \"emphasis class\", &lastToken))",
          "3400:    if (parseChars(nested, &emphClass, &token)) {",
          "3401:     char *s = malloc(sizeof(char) * (emphClass.length + 1));",
          "3402:     for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];",
          "3403:     s[k++] = '\\0';",
          "3404:     for (i = 0; (*table)->emphClasses[i]; i++)",
          "3405:      if (strcmp(s, (*table)->emphClasses[i]) == 0) {",
          "3406:       _lou_logMessage(LOG_WARN, \"Duplicate emphasis class: %s\", s);",
          "3407:       warningCount++;",
          "3408:       free(s);",
          "3409:       return 1;",
          "3411:     if (i < MAX_EMPH_CLASSES) {",
          "3412:      switch (i) {",
          "3437:      case 0:",
          "3438:       if (strcmp(s, \"italic\") != 0) {",
          "3439:        _lou_logMessage(LOG_ERROR,",
          "3440:          \"First emphasis class must be \\\"italic\\\" but got %s\",",
          "3441:          s);",
          "3442:        errorCount++;",
          "3443:        free(s);",
          "3444:        return 0;",
          "3445:       }",
          "3446:       break;",
          "3447:      case 1:",
          "3448:       if (strcmp(s, \"underline\") != 0) {",
          "3449:        _lou_logMessage(LOG_ERROR,",
          "3450:          \"Second emphasis class must be \\\"underline\\\" but got \"",
          "3451:          \"%s\",",
          "3452:          s);",
          "3453:        errorCount++;",
          "3454:        free(s);",
          "3455:        return 0;",
          "3456:       }",
          "3457:       break;",
          "3458:      case 2:",
          "3459:       if (strcmp(s, \"bold\") != 0) {",
          "3460:        _lou_logMessage(LOG_ERROR,",
          "3461:          \"Third emphasis class must be \\\"bold\\\" but got %s\",",
          "3462:          s);",
          "3463:        errorCount++;",
          "3464:        free(s);",
          "3465:        return 0;",
          "3466:       }",
          "3469:      (*table)->emphClasses[i] = s;",
          "3470:      (*table)->emphClasses[i + 1] = NULL;",
          "3471:      ok = 1;",
          "3473:     } else {",
          "3474:      _lou_logMessage(LOG_ERROR,",
          "3475:        \"Max number of emphasis classes (%i) reached\",",
          "3476:        MAX_EMPH_CLASSES);",
          "3477:      errorCount++;",
          "3478:      free(s);",
          "3481:     }",
          "3482:    }",
          "3483:   compileError(nested, \"emphclass must be followed by a valid class name.\");",
          "3484:   ok = 0;",
          "3485:   break;",
          "3486:  case CTO_EmphLetter:",
          "3487:  case CTO_BegEmphWord:",
          "3488:  case CTO_EndEmphWord:",
          "3489:  case CTO_BegEmph:",
          "3490:  case CTO_EndEmph:",
          "3491:  case CTO_BegEmphPhrase:",
          "3492:  case CTO_EndEmphPhrase:",
          "3493:  case CTO_LenEmphPhrase:",
          "3494:   ok = 0;",
          "3495:   if (getToken(nested, &token, \"emphasis class\", &lastToken))",
          "3496:    if (parseChars(nested, &emphClass, &token)) {",
          "3497:     char *s = malloc(sizeof(char) * (emphClass.length + 1));",
          "3498:     for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];",
          "3499:     s[k++] = '\\0';",
          "3500:     for (i = 0; (*table)->emphClasses[i]; i++)",
          "3501:      if (strcmp(s, (*table)->emphClasses[i]) == 0) break;",
          "3502:     if (!(*table)->emphClasses[i]) {",
          "3503:      _lou_logMessage(LOG_ERROR, \"Emphasis class %s not declared\", s);",
          "3504:      errorCount++;",
          "3505:      free(s);",
          "3506:      break;",
          "3507:     }",
          "3508:     i++;  // in table->emphRules the first index is used for caps",
          "3509:     if (opcode == CTO_EmphLetter) {",
          "3510:      tmp_offset = (*table)->emphRules[i][letterOffset];",
          "3511:      ok = compileBrailleIndicator(nested, \"single letter\",",
          "3512:        CTO_Emph1LetterRule + letterOffset + (8 * i), &tmp_offset,",
          "3513:        &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3514:      (*table)->emphRules[i][letterOffset] = tmp_offset;",
          "3515:     } else if (opcode == CTO_BegEmphWord) {",
          "3516:      tmp_offset = (*table)->emphRules[i][begWordOffset];",
          "3517:      ok = compileBrailleIndicator(nested, \"word\",",
          "3518:        CTO_Emph1LetterRule + begWordOffset + (8 * i), &tmp_offset,",
          "3519:        &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3520:      (*table)->emphRules[i][begWordOffset] = tmp_offset;",
          "3521:     } else if (opcode == CTO_EndEmphWord) {",
          "3522:      tmp_offset = (*table)->emphRules[i][endWordOffset];",
          "3523:      ok = compileBrailleIndicator(nested, \"word stop\",",
          "3524:        CTO_Emph1LetterRule + endWordOffset + (8 * i), &tmp_offset,",
          "3525:        &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3526:      (*table)->emphRules[i][endWordOffset] = tmp_offset;",
          "3527:     } else if (opcode == CTO_BegEmph) {",
          "3530:      if ((*table)->emphRules[i][begWordOffset] ||",
          "3531:        (*table)->emphRules[i][begPhraseOffset]) {",
          "3532:       compileError(nested,",
          "3533:         \"Cannot define emphasis for both no context and word or \"",
          "3534:         \"phrase context, i.e. cannot have both begemph and \"",
          "3535:         \"begemphword or begemphphrase.\");",
          "3536:       ok = 0;",
          "3537:       break;",
          "3538:      }",
          "3539:      tmp_offset = (*table)->emphRules[i][begOffset];",
          "3540:      ok = compileBrailleIndicator(nested, \"first letter\",",
          "3541:        CTO_Emph1LetterRule + begOffset + (8 * i), &tmp_offset,",
          "3542:        &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3543:      (*table)->emphRules[i][begOffset] = tmp_offset;",
          "3544:     } else if (opcode == CTO_EndEmph) {",
          "3545:      if ((*table)->emphRules[i][endWordOffset] ||",
          "3546:        (*table)->emphRules[i][endPhraseBeforeOffset] ||",
          "3547:        (*table)->emphRules[i][endPhraseAfterOffset]) {",
          "3548:       compileError(nested,",
          "3549:         \"Cannot define emphasis for both no context and word or \"",
          "3550:         \"phrase context, i.e. cannot have both endemph and \"",
          "3551:         \"endemphword or endemphphrase.\");",
          "3552:       ok = 0;",
          "3553:       break;",
          "3554:      }",
          "3555:      tmp_offset = (*table)->emphRules[i][endOffset];",
          "3556:      ok = compileBrailleIndicator(nested, \"last letter\",",
          "3557:        CTO_Emph1LetterRule + endOffset + (8 * i), &tmp_offset,",
          "3558:        &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3559:      (*table)->emphRules[i][endOffset] = tmp_offset;",
          "3560:     } else if (opcode == CTO_BegEmphPhrase) {",
          "3561:      tmp_offset = (*table)->emphRules[i][begPhraseOffset];",
          "3562:      ok = compileBrailleIndicator(nested, \"first word\",",
          "3563:        CTO_Emph1LetterRule + begPhraseOffset + (8 * i), &tmp_offset,",
          "3564:        &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3565:      (*table)->emphRules[i][begPhraseOffset] = tmp_offset;",
          "3566:     } else if (opcode == CTO_EndEmphPhrase)",
          "3567:      switch (compileBeforeAfter(nested, &lastToken)) {",
          "3568:      case 1:  // before",
          "3569:       if ((*table)->emphRules[i][endPhraseAfterOffset]) {",
          "3570:        compileError(nested, \"last word after already defined.\");",
          "3571:        ok = 0;",
          "3572:        break;",
          "3573:       }",
          "3574:       tmp_offset = (*table)->emphRules[i][endPhraseBeforeOffset];",
          "3575:       ok = compileBrailleIndicator(nested, \"last word before\",",
          "3576:         CTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),",
          "3577:         &tmp_offset, &lastToken, newRuleOffset, newRule, noback,",
          "3578:         nofor, table);",
          "3579:       (*table)->emphRules[i][endPhraseBeforeOffset] = tmp_offset;",
          "3580:       break;",
          "3581:      case 2:  // after",
          "3582:       if ((*table)->emphRules[i][endPhraseBeforeOffset]) {",
          "3583:        compileError(nested, \"last word before already defined.\");",
          "3584:        ok = 0;",
          "3585:        break;",
          "3586:       }",
          "3587:       tmp_offset = (*table)->emphRules[i][endPhraseAfterOffset];",
          "3588:       ok = compileBrailleIndicator(nested, \"last word after\",",
          "3589:         CTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),",
          "3590:         &tmp_offset, &lastToken, newRuleOffset, newRule, noback,",
          "3591:         nofor, table);",
          "3592:       (*table)->emphRules[i][endPhraseAfterOffset] = tmp_offset;",
          "3593:       break;",
          "3594:      default:  // error",
          "3595:       compileError(nested, \"Invalid lastword indicator location.\");",
          "3596:       ok = 0;",
          "3597:       break;",
          "3598:      }",
          "3599:     else if (opcode == CTO_LenEmphPhrase)",
          "3600:      ok = (*table)->emphRules[i][lenPhraseOffset] =",
          "3601:        compileNumber(nested, &lastToken);",
          "3602:     free(s);",
          "3603:    }",
          "3604:   break;",
          "3606:  case CTO_LetterSign:",
          "3607:   tmp_offset = (*table)->letterSign;",
          "3608:   ok = compileBrailleIndicator(nested, \"letter sign\", CTO_LetterRule, &tmp_offset,",
          "3609:     &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3610:   (*table)->letterSign = tmp_offset;",
          "3611:   break;",
          "3612:  case CTO_NoLetsignBefore:",
          "3613:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3614:    if (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNSIZE) {",
          "3615:     compileError(nested, \"More than %d characters\", LETSIGNSIZE);",
          "3616:     ok = 0;",
          "3617:     break;",
          "3618:    }",
          "3619:    for (k = 0; k < ruleChars.length; k++)",
          "3620:     (*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =",
          "3621:       ruleChars.chars[k];",
          "3622:   }",
          "3623:   break;",
          "3624:  case CTO_NoLetsign:",
          "3625:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3626:    if (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {",
          "3627:     compileError(nested, \"More than %d characters\", LETSIGNSIZE);",
          "3628:     ok = 0;",
          "3629:     break;",
          "3631:    for (k = 0; k < ruleChars.length; k++)",
          "3632:     (*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];",
          "3633:   }",
          "3634:   break;",
          "3635:  case CTO_NoLetsignAfter:",
          "3636:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3637:    if (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNSIZE) {",
          "3638:     compileError(nested, \"More than %d characters\", LETSIGNSIZE);",
          "3639:     ok = 0;",
          "3640:     break;",
          "3641:    }",
          "3642:    for (k = 0; k < ruleChars.length; k++)",
          "3643:     (*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =",
          "3644:       ruleChars.chars[k];",
          "3645:   }",
          "3646:   break;",
          "3647:  case CTO_NumberSign:",
          "3648:   tmp_offset = (*table)->numberSign;",
          "3649:   ok = compileBrailleIndicator(nested, \"number sign\", CTO_NumberRule, &tmp_offset,",
          "3650:     &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3651:   (*table)->numberSign = tmp_offset;",
          "3652:   break;",
          "3658:   if (!getToken(nested, &ruleChars, \"attribute number\", &lastToken)) {",
          "3665:   switch (ruleChars.chars[0]) {",
          "3666:   case '0':",
          "3667:    k = 0;",
          "3668:    break;",
          "3669:   case '1':",
          "3670:    k = 1;",
          "3671:    break;",
          "3672:   case '2':",
          "3673:    k = 2;",
          "3674:    break;",
          "3675:   case '3':",
          "3676:    k = 3;",
          "3677:    break;",
          "3678:   case '4':",
          "3679:    k = 4;",
          "3680:    break;",
          "3681:   case '5':",
          "3682:    k = 5;",
          "3683:    break;",
          "3684:   case '6':",
          "3685:    k = 6;",
          "3686:    break;",
          "3687:   case '7':",
          "3688:    k = 7;",
          "3689:    break;",
          "3691:   if (k == -1) {",
          "3697:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3698:    for (i = 0; i < ruleChars.length; i++) {",
          "3700:     if (c)",
          "3702:     else {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4370:   break;",
          "4372:  case CTO_NumericModeChars:",
          "4374:   c = NULL;",
          "4375:   ok = 1;",
          "4380:     c = compile_findCharOrDots(ruleChars.chars[k], 0, *table);",
          "4382:      c->attributes |= CTC_NumericMode;",
          "4385:      compileError(nested, \"Numeric mode character undefined\");",
          "4386:      ok = 0;",
          "4387:      break;",
          "4388:     }",
          "4389:    }",
          "4390:    (*table)->usesNumericMode = 1;",
          "4392:   break;",
          "4394:  case CTO_NumericNoContractChars:",
          "4396:   c = NULL;",
          "4397:   ok = 1;",
          "4402:     c = compile_findCharOrDots(ruleChars.chars[k], 0, *table);",
          "4404:      c->attributes |= CTC_NumericNoContract;",
          "4407:      compileError(nested, \"Numeric no contraction character undefined\");",
          "4408:      ok = 0;",
          "4409:      break;",
          "4410:     }",
          "4411:    }",
          "4412:    (*table)->usesNumericMode = 1;",
          "4414:   break;",
          "4416:  case CTO_NoContractSign:",
          "4422:   break;",
          "4424:  case CTO_SeqDelimiter:",
          "4426:   c = NULL;",
          "4427:   ok = 1;",
          "4432:     c = compile_findCharOrDots(ruleChars.chars[k], 0, *table);",
          "4434:      c->attributes |= CTC_SeqDelimiter;",
          "4437:      compileError(nested, \"Sequence delimiter character undefined\");",
          "4438:      ok = 0;",
          "4439:      break;",
          "",
          "[Removed Lines]",
          "4376:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4377:   {",
          "4378:    for(k = 0; k < ruleChars.length; k++)",
          "4379:    {",
          "4381:     if(c)",
          "4383:     else",
          "4384:     {",
          "4391:   }",
          "4398:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4399:   {",
          "4400:    for(k = 0; k < ruleChars.length; k++)",
          "4401:    {",
          "4403:     if(c)",
          "4405:     else",
          "4406:     {",
          "4413:   }",
          "4418:       tmp_offset = (*table)->noContractSign;",
          "4419:   ok = compileBrailleIndicator",
          "4420:    (nested, \"no contractions sign\", CTO_NoContractRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4421:       (*table)->noContractSign = tmp_offset;",
          "4428:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4429:   {",
          "4430:    for(k = 0; k < ruleChars.length; k++)",
          "4431:    {",
          "4433:     if(c)",
          "4435:     else",
          "4436:     {",
          "",
          "[Added Lines]",
          "3715:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3716:    for (k = 0; k < ruleChars.length; k++) {",
          "3718:     if (c)",
          "3720:     else {",
          "3727:   }",
          "3734:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3735:    for (k = 0; k < ruleChars.length; k++) {",
          "3737:     if (c)",
          "3739:     else {",
          "3746:   }",
          "3751:   tmp_offset = (*table)->noContractSign;",
          "3752:   ok = compileBrailleIndicator(nested, \"no contractions sign\", CTO_NoContractRule,",
          "3753:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3754:   (*table)->noContractSign = tmp_offset;",
          "3761:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3762:    for (k = 0; k < ruleChars.length; k++) {",
          "3764:     if (c)",
          "3766:     else {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4442:    (*table)->usesSequences = 1;",
          "4443:   }",
          "4444:   break;",
          "4446:  case CTO_SeqBeforeChars:",
          "4448:   c = NULL;",
          "4449:   ok = 1;",
          "4454:     c = compile_findCharOrDots(ruleChars.chars[k], 0, *table);",
          "4456:      c->attributes |= CTC_SeqBefore;",
          "4459:      compileError(nested, \"Sequence before character undefined\");",
          "4460:      ok = 0;",
          "4461:      break;",
          "4462:     }",
          "4463:    }",
          "4465:   break;",
          "4467:  case CTO_SeqAfterChars:",
          "4469:   c = NULL;",
          "4470:   ok = 1;",
          "4475:     c = compile_findCharOrDots(ruleChars.chars[k], 0, *table);",
          "4477:      c->attributes |= CTC_SeqAfter;",
          "4480:      compileError(nested, \"Sequence after character undefined\");",
          "4481:      ok = 0;",
          "4482:      break;",
          "4483:     }",
          "4484:    }",
          "4486:   break;",
          "4488:  case CTO_SeqAfterPattern:",
          "4495:     ok = 0;",
          "4496:     break;",
          "4497:    }",
          "4501:    (*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;",
          "4503:   break;",
          "4514:  case CTO_CapsModeChars:",
          "4516:   c = NULL;",
          "4517:   ok = 1;",
          "4522:     c = compile_findCharOrDots(ruleChars.chars[k], 0, *table);",
          "4524:      c->attributes |= CTC_CapsMode;",
          "4527:      compileError(nested, \"Capital mode character undefined\");",
          "4528:      ok = 0;",
          "4529:      break;",
          "4530:     }",
          "4531:    }",
          "4533:   break;",
          "4784:  }",
          "4794:  }",
          "4876:   ok = 0;",
          "4891: }",
          "4893: int EXPORT_CALL",
          "4914:  }",
          "4929: }",
          "4931: static int",
          "4957: }",
          "4959: static int",
          "4980: }",
          "4982: static int",
          "5000: }",
          "",
          "[Removed Lines]",
          "4450:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4451:   {",
          "4452:    for(k = 0; k < ruleChars.length; k++)",
          "4453:    {",
          "4455:     if(c)",
          "4457:     else",
          "4458:     {",
          "4464:   }",
          "4471:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4472:   {",
          "4473:    for(k = 0; k < ruleChars.length; k++)",
          "4474:    {",
          "4476:     if(c)",
          "4478:     else",
          "4479:     {",
          "4485:   }",
          "4490:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4491:   {",
          "4492:    if(((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE)",
          "4493:    {",
          "4494:     compileError (nested, \"More than %d characters\", SEQPATTERNSIZE);",
          "4498:    for(k = 0; k < ruleChars.length; k++)",
          "4499:     (*table)->seqPatterns[(*table)->seqPatternsCount++] =",
          "4500:      ruleChars.chars[k];",
          "4502:   }",
          "4504:     case CTO_SeqAfterExpression:",
          "4506:       if (getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4507:  {",
          "4508:    for((*table)->seqAfterExpressionLength = 0; (*table)->seqAfterExpressionLength < ruleChars.length; (*table)->seqAfterExpressionLength++)",
          "4509:      (*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = ruleChars.chars[(*table)->seqAfterExpressionLength];",
          "4510:    (*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;",
          "4511:  }",
          "4512:       break;",
          "4518:   if(getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4519:   {",
          "4520:    for(k = 0; k < ruleChars.length; k++)",
          "4521:    {",
          "4523:     if(c)",
          "4525:     else",
          "4526:     {",
          "4532:   }",
          "4535:     case CTO_BegComp:",
          "4536:       tmp_offset = (*table)->begComp;",
          "4537:       ok =",
          "4538:  compileBrailleIndicator (nested, \"begin computer braille\",",
          "4539:      CTO_BegCompRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4540:       (*table)->begComp = tmp_offset;",
          "4541:       break;",
          "4542:     case CTO_EndComp:",
          "4543:       tmp_offset = (*table)->endComp;",
          "4544:       ok =",
          "4545:  compileBrailleIndicator (nested, \"end computer braslle\",",
          "4546:      CTO_EndCompRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4547:       (*table)->endComp = tmp_offset;",
          "4548:       break;",
          "4549:     case CTO_Syllable:",
          "4550:       (*table)->syllables = 1;",
          "4551:     case CTO_Always:",
          "4552:     case CTO_NoCross:",
          "4553:     case CTO_LargeSign:",
          "4554:     case CTO_WholeWord:",
          "4555:     case CTO_PartWord:",
          "4556:     case CTO_JoinNum:",
          "4557:     case CTO_JoinableWord:",
          "4558:     case CTO_LowWord:",
          "4559:     case CTO_SuffixableWord:",
          "4560:     case CTO_PrefixableWord:",
          "4561:     case CTO_BegWord:",
          "4562:     case CTO_BegMidWord:",
          "4563:     case CTO_MidWord:",
          "4564:     case CTO_MidEndWord:",
          "4565:     case CTO_EndWord:",
          "4566:     case CTO_PrePunc:",
          "4567:     case CTO_PostPunc:",
          "4568:     case CTO_BegNum:",
          "4569:     case CTO_MidNum:",
          "4570:     case CTO_EndNum:",
          "4571:     case CTO_Repeated:",
          "4572:     case CTO_RepWord:",
          "4573:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4574:  if (getRuleDotsPattern (nested, &ruleDots, &lastToken))",
          "4575:    if (!addRule (nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "4576:      ok = 0;",
          "4583:       break;",
          "4584:     case CTO_CompDots:",
          "4585:     case CTO_Comp6:",
          "4586:       if (!getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4587:  return 0;",
          "4588:       if (ruleChars.length != 1 || ruleChars.chars[0] > 255)",
          "4589:  {",
          "4590:    compileError (nested,",
          "4591:    \"first operand must be 1 character and < 256\");",
          "4592:    return 0;",
          "4593:  }",
          "4594:       if (!getRuleDotsPattern (nested, &ruleDots, &lastToken))",
          "4595:  return 0;",
          "4596:       if (!addRule (nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "4597:  ok = 0;",
          "4598:       (*table)->compdotsPattern[ruleChars.chars[0]] = *newRuleOffset;",
          "4599:       break;",
          "4600:     case CTO_ExactDots:",
          "4601:       if (!getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4602:  return 0;",
          "4603:       if (ruleChars.chars[0] != '@')",
          "4604:  {",
          "4605:    compileError (nested, \"The operand must begin with an at sign (@)\");",
          "4606:    return 0;",
          "4607:  }",
          "4608:       for (k = 1; k < ruleChars.length; k++)",
          "4609:  scratchPad.chars[k - 1] = ruleChars.chars[k];",
          "4610:       scratchPad.length = ruleChars.length - 1;",
          "4611:       if (!parseDots (nested, &ruleDots, &scratchPad))",
          "4612:  return 0;",
          "4613:       if (!addRule (nested, opcode, &ruleChars, &ruleDots, before, after, newRuleOffset, newRule, noback, nofor, table))",
          "4614:  ok = 0;",
          "4615:       break;",
          "4616:     case CTO_CapsNoCont:",
          "4617:       ruleChars.length = 1;",
          "4618:       ruleChars.chars[0] = 'a';",
          "4619:       if (!addRule",
          "4620:    (nested, CTO_CapsNoContRule, &ruleChars, NULL, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "4621:  ok = 0;",
          "4622:       (*table)->capsNoCont = *newRuleOffset;",
          "4623:       break;",
          "4624:     case CTO_Replace:",
          "4625:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4626:  {",
          "4627:    if (lastToken)",
          "4628:      ruleDots.length = ruleDots.chars[0] = 0;",
          "4629:    else",
          "4630:      {",
          "4631:        getRuleDotsText (nested, &ruleDots, &lastToken);",
          "4632:        if (ruleDots.chars[0] == '#')",
          "4633:   ruleDots.length = ruleDots.chars[0] = 0;",
          "4634:        else if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')",
          "4635:   memcpy (&ruleDots.chars[0], &ruleDots.chars[1],",
          "4636:    ruleDots.length-- * CHARSIZE);",
          "4637:      }",
          "4638:  }",
          "4639:       for (k = 0; k < ruleChars.length; k++)",
          "4640:  addCharOrDots (nested, ruleChars.chars[k], 0, table);",
          "4641:       for (k = 0; k < ruleDots.length; k++)",
          "4642:  addCharOrDots (nested, ruleDots.chars[k], 0, table);",
          "4643:       if (!addRule (nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "4644:  ok = 0;",
          "4645:       break;",
          "4646:     case CTO_Correct:",
          "4647:       (*table)->corrections = 1;",
          "4648:       goto doPass;",
          "4649:     case CTO_Pass2:",
          "4650:       if ((*table)->numPasses < 2)",
          "4651:  (*table)->numPasses = 2;",
          "4652:       goto doPass;",
          "4653:     case CTO_Pass3:",
          "4654:       if ((*table)->numPasses < 3)",
          "4655:  (*table)->numPasses = 3;",
          "4656:       goto doPass;",
          "4657:     case CTO_Pass4:",
          "4658:       if ((*table)->numPasses < 4)",
          "4659:  (*table)->numPasses = 4;",
          "4660:     doPass:",
          "4661:     case CTO_Context:",
          "4662:       if (!(nofor || noback))",
          "4663:         {",
          "4664:    compileError(nested, \"%s or %s must be specified.\",",
          "4665:           _lou_findOpcodeName(CTO_NoFor),",
          "4666:           _lou_findOpcodeName(CTO_NoBack));",
          "4667:    ok = 0;",
          "4668:    break;",
          "4669:  }",
          "4670:       if (!compilePassOpcode (nested, opcode, *characterClasses, newRuleOffset, newRule, noback, nofor, *ruleNames, table))",
          "4671:  ok = 0;",
          "4672:       break;",
          "4673:     case CTO_Contraction:",
          "4674:     case CTO_NoCont:",
          "4675:     case CTO_CompBrl:",
          "4676:     case CTO_Literal:",
          "4677:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4678:  if (!addRule (nested, opcode, &ruleChars, NULL, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "4679:    ok = 0;",
          "4680:       break;",
          "4681:     case CTO_MultInd:",
          "4682:       {",
          "4683:  int t;",
          "4684:  ruleChars.length = 0;",
          "4685:  if (getToken (nested, &token, \"multiple braille indicators\", &lastToken) &&",
          "4686:      parseDots (nested, &cells, &token))",
          "4687:    {",
          "4688:      while ((t = getToken (nested, &token, \"multind opcodes\", &lastToken)))",
          "4689:        {",
          "4690:   opcode = getOpcode (nested, &token, opcodeLengths);",
          "4691:   if (opcode >= CTO_CapsLetter && opcode < CTO_MultInd)",
          "4692:     ruleChars.chars[ruleChars.length++] = (widechar) opcode;",
          "4693:   else",
          "4694:     {",
          "4695:       compileError (nested, \"Not a braille indicator opcode.\");",
          "4696:       ok = 0;",
          "4697:     }",
          "4698:   if (t == 2)",
          "4699:     break;",
          "4700:        }",
          "4701:    }",
          "4702:  else",
          "4703:    ok = 0;",
          "4704:  if (!addRule (nested, CTO_MultInd, &ruleChars, &cells, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "4705:    ok = 0;",
          "4706:  break;",
          "4707:       }",
          "4709:     case CTO_Class:",
          "4710:       {",
          "4711:  CharsString characters;",
          "4712:  const CharacterClass *class;",
          "4713:  if (!*characterClasses)",
          "4714:    {",
          "4715:      if (!allocateCharacterClasses (characterClasses, characterClassAttribute))",
          "4716:        ok = 0;",
          "4717:    }",
          "4718:  if (getToken (nested, &token, \"character class name\", &lastToken))",
          "4719:    {",
          "4720:      if ((class = findCharacterClass (&token, *characterClasses)))",
          "4721:        {",
          "4722:   compileError (nested, \"character class already defined.\");",
          "4723:        }",
          "4724:      else",
          "4725:        if ((class =",
          "4726:      addCharacterClass (nested, &token.chars[0], token.length, characterClasses, characterClassAttribute)))",
          "4727:        {",
          "4728:   if (getCharacters (nested, &characters, &lastToken))",
          "4729:     {",
          "4730:       int index;",
          "4731:       for (index = 0; index < characters.length; ++index)",
          "4732:         {",
          "4733:    TranslationTableRule *defRule;",
          "4734:    TranslationTableCharacter *character =",
          "4735:      definedCharOrDots",
          "4736:      (nested, characters.chars[index], 0, *table);",
          "4737:    character->attributes |= class->attribute;",
          "4738:    defRule = (TranslationTableRule *)",
          "4739:      & (*table)->ruleArea[character->definitionRule];",
          "4740:    if (defRule->dotslen == 1)",
          "4741:      {",
          "4742:        character = definedCharOrDots",
          "4743:          (nested,",
          "4744:           defRule->charsdots[defRule->charslen], 1, *table);",
          "4745:        character->attributes |= class->attribute;",
          "4746:      }",
          "4747:         }",
          "4748:     }",
          "4749:        }",
          "4750:    }",
          "4751:  break;",
          "4752:       }",
          "4754:       {",
          "4755:  TranslationTableCharacterAttributes *attributes;",
          "4756:  const CharacterClass *class;",
          "4757:     case CTO_After:",
          "4758:  attributes = &after;",
          "4759:  goto doClass;",
          "4760:     case CTO_Before:",
          "4761:  attributes = &before;",
          "4762:       doClass:",
          "4764:  if (!*characterClasses)",
          "4765:    {",
          "4766:      if (!allocateCharacterClasses (characterClasses, characterClassAttribute))",
          "4767:        ok = 0;",
          "4768:    }",
          "4769:  if (getCharacterClass (nested, &class, *characterClasses, &lastToken))",
          "4770:    {",
          "4772:      goto doOpcode;",
          "4773:    }",
          "4774:  break;",
          "4775:       }",
          "4777:     case CTO_NoBack:",
          "4778:       if (nofor)",
          "4779:         {",
          "4780:    compileError(nested, \"%s already specified.\",",
          "4781:                         _lou_findOpcodeName(CTO_NoFor));",
          "4782:    ok = 0;",
          "4783:    break;",
          "4785:       noback = 1;",
          "4786:       goto doOpcode;",
          "4787:     case CTO_NoFor:",
          "4788:       if (noback)",
          "4789:         {",
          "4790:    compileError(nested, \"%s already specified.\",",
          "4791:           _lou_findOpcodeName(CTO_NoBack));",
          "4792:    ok = 0;",
          "4793:    break;",
          "4795:       nofor = 1;",
          "4796:       goto doOpcode;",
          "4798:     case CTO_EmpMatchBefore:",
          "4799:       before |= CTC_EmpMatch;",
          "4800:       goto doOpcode;",
          "4801:     case CTO_EmpMatchAfter:",
          "4802:       after |= CTC_EmpMatch;",
          "4803:       goto doOpcode;",
          "4805:     case CTO_SwapCc:",
          "4806:     case CTO_SwapCd:",
          "4807:     case CTO_SwapDd:",
          "4808:       if (!compileSwap (nested, opcode, &lastToken, newRuleOffset, newRule, noback, nofor, ruleNames, table))",
          "4809:  ok = 0;",
          "4810:       break;",
          "4811:     case CTO_Hyphen:",
          "4812:     case CTO_DecPoint:",
          "4815:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4816:  if (getRuleDotsPattern (nested, &ruleDots, &lastToken))",
          "4817:    {",
          "4818:      if (ruleChars.length != 1 || ruleDots.length < 1)",
          "4819:        {",
          "4820:   compileError (nested,",
          "4821:          \"One Unicode character and at least one cell are required.\");",
          "4822:   ok = 0;",
          "4823:        }",
          "4824:      if (!addRule",
          "4825:   (nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset, newRule, noback, nofor, table))",
          "4826:        ok = 0;",
          "4833:    }",
          "4834:       break;",
          "4835:     case CTO_Space:",
          "4836:       compileCharDef (nested, opcode, CTC_Space, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4837:       break;",
          "4838:     case CTO_Digit:",
          "4839:       compileCharDef (nested, opcode, CTC_Digit, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4840:       break;",
          "4841:     case CTO_LitDigit:",
          "4842:       compileCharDef (nested, opcode, CTC_LitDigit, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4843:       break;",
          "4844:     case CTO_Punctuation:",
          "4845:       compileCharDef (nested, opcode, CTC_Punctuation, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4846:       break;",
          "4847:     case CTO_Math:",
          "4848:       compileCharDef (nested, opcode, CTC_Math, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4849:       break;",
          "4850:     case CTO_Sign:",
          "4851:       compileCharDef (nested, opcode, CTC_Sign, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4852:       break;",
          "4853:     case CTO_Letter:",
          "4854:       compileCharDef (nested, opcode, CTC_Letter, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4855:       break;",
          "4856:     case CTO_UpperCase:",
          "4857:       compileCharDef (nested, opcode, CTC_UpperCase, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4858:       break;",
          "4859:     case CTO_LowerCase:",
          "4860:       compileCharDef (nested, opcode, CTC_LowerCase, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4861:       break;",
          "4862:     case CTO_Grouping:",
          "4863:       ok = compileGrouping (nested, &lastToken, newRuleOffset, newRule, noback, nofor, ruleNames, table);",
          "4864:       break;",
          "4865:     case CTO_UpLow:",
          "4866:       ok = compileUplow (nested, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4867:       break;",
          "4868:     case CTO_Display:",
          "4869:       if (getRuleCharsText (nested, &ruleChars, &lastToken))",
          "4870:  if (getRuleDotsPattern (nested, &ruleDots, &lastToken))",
          "4871:    {",
          "4872:      if (ruleChars.length != 1 || ruleDots.length != 1)",
          "4873:        {",
          "4874:   compileError (nested,",
          "4875:          \"Exactly one character and one cell are required.\");",
          "4877:        }",
          "4878:      putCharAndDots (nested, ruleChars.chars[0], ruleDots.chars[0], table);",
          "4879:    }",
          "4880:       break;",
          "4881:     default:",
          "4882:       compileError (nested, \"unimplemented opcode.\");",
          "4883:       ok = 0;",
          "4884:       break;",
          "4885:     }",
          "4887:   if (patterns != NULL)",
          "4888:     free(patterns);",
          "4890:   return ok;",
          "4894: lou_readCharFromFile (const char *fileName, int *mode)",
          "4895: {",
          "4898:   int ch;",
          "4899:   static FileInfo nested;",
          "4900:   if (fileName == NULL)",
          "4901:     return 0;",
          "4902:   if (*mode == 1)",
          "4903:     {",
          "4905:       nested.fileName = fileName;",
          "4906:       nested.encoding = noEncoding;",
          "4907:       nested.status = 0;",
          "4908:       nested.lineNumber = 0;",
          "4909:       if (!(nested.in = fopen (nested.fileName, \"r\")))",
          "4910:  {",
          "4911:    _lou_logMessage (LOG_ERROR, \"Cannot open file '%s'\", nested.fileName);",
          "4913:    return EOF;",
          "4915:     }",
          "4916:   if (nested.in == NULL)",
          "4917:     {",
          "4919:       return EOF;",
          "4920:     }",
          "4921:   ch = getAChar (&nested);",
          "4922:   if (ch == EOF)",
          "4923:     {",
          "4924:       fclose (nested.in);",
          "4925:       nested.in = NULL;",
          "4927:     }",
          "4928:   return ch;",
          "4932: compileString (const char *inString,",
          "4933:         CharacterClass **characterClasses,",
          "4934:         TranslationTableCharacterAttributes *characterClassAttribute,",
          "4935:         short opcodeLengths[],",
          "4936:         TranslationTableOffset *newRuleOffset,",
          "4937:         TranslationTableRule **newRule,",
          "4938:         RuleName **ruleNames,",
          "4939:         TranslationTableHeader **table)",
          "4940: {",
          "4942:   int k;",
          "4943:   FileInfo nested;",
          "4944:   if (inString == NULL)",
          "4945:     return 0;",
          "4946:   memset(&nested, 0, sizeof(nested));",
          "4947:   nested.fileName = inString;",
          "4948:   nested.encoding = noEncoding;",
          "4949:   nested.lineNumber = 1;",
          "4950:   nested.status = 0;",
          "4951:   nested.linepos = 0;",
          "4952:   for (k = 0; inString[k]; k++)",
          "4953:     nested.line[k] = inString[k];",
          "4954:   nested.line[k] = 0;",
          "4955:   nested.linelen = k;",
          "4956:   return compileRule (&nested, characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, table);",
          "4960: makeDoubleRule (TranslationTableOpcode opcode, TranslationTableOffset",
          "4962:   TranslationTableOffset *newRuleOffset,",
          "4963:   TranslationTableRule **newRule,",
          "4964:   int noback, int nofor,",
          "4965:   TranslationTableHeader **table)",
          "4966: {",
          "4967:   CharsString dots;",
          "4968:   TranslationTableRule *rule;",
          "4969:   if (!*singleRule || *doubleRule)",
          "4970:     return 1;",
          "4971:   rule = (TranslationTableRule *) &(*table)->ruleArea[*singleRule];",
          "4972:   memcpy (dots.chars, &rule->charsdots[0], rule->dotslen * CHARSIZE);",
          "4973:   memcpy (&dots.chars[rule->dotslen], &rule->charsdots[0],",
          "4974:    rule->dotslen * CHARSIZE);",
          "4975:   dots.length = 2 * rule->dotslen;",
          "4976:   if (!addRule (NULL, opcode, NULL, &dots, 0, 0, newRuleOffset, newRule, noback, nofor, table))",
          "4977:     return 0;",
          "4979:   return 1;",
          "4983: setDefaults (TranslationTableHeader *table)",
          "4984: {",
          "4987:   if (!table->emphRules[emph1Rule][lenPhraseOffset])",
          "4988:     table->emphRules[emph1Rule][lenPhraseOffset] = 4;",
          "4991:   if (!table->emphRules[emph2Rule][lenPhraseOffset])",
          "4992:     table->emphRules[emph2Rule][lenPhraseOffset] = 4;",
          "4995:   if (!table->emphRules[emph3Rule][lenPhraseOffset])",
          "4996:     table->emphRules[emph3Rule][lenPhraseOffset] = 4;",
          "4997:   if (table->numPasses == 0)",
          "4998:     table->numPasses = 1;",
          "4999:   return 1;",
          "",
          "[Added Lines]",
          "3780:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3781:    for (k = 0; k < ruleChars.length; k++) {",
          "3783:     if (c)",
          "3785:     else {",
          "3791:   }",
          "3798:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3799:    for (k = 0; k < ruleChars.length; k++) {",
          "3801:     if (c)",
          "3803:     else {",
          "3809:   }",
          "3814:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3815:    if (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {",
          "3816:     compileError(nested, \"More than %d characters\", SEQPATTERNSIZE);",
          "3820:    for (k = 0; k < ruleChars.length; k++)",
          "3821:     (*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];",
          "3823:   }",
          "3824:   break;",
          "3825:  case CTO_SeqAfterExpression:",
          "3827:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3828:    for ((*table)->seqAfterExpressionLength = 0;",
          "3829:      (*table)->seqAfterExpressionLength < ruleChars.length;",
          "3830:      (*table)->seqAfterExpressionLength++)",
          "3831:     (*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =",
          "3832:       ruleChars.chars[(*table)->seqAfterExpressionLength];",
          "3833:    (*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;",
          "3834:   }",
          "3841:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3842:    for (k = 0; k < ruleChars.length; k++) {",
          "3844:     if (c)",
          "3846:     else {",
          "3852:   }",
          "3853:   break;",
          "3855:  case CTO_BegComp:",
          "3856:   tmp_offset = (*table)->begComp;",
          "3857:   ok = compileBrailleIndicator(nested, \"begin computer braille\", CTO_BegCompRule,",
          "3858:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3859:   (*table)->begComp = tmp_offset;",
          "3860:   break;",
          "3861:  case CTO_EndComp:",
          "3862:   tmp_offset = (*table)->endComp;",
          "3863:   ok = compileBrailleIndicator(nested, \"end computer braslle\", CTO_EndCompRule,",
          "3864:     &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "3865:   (*table)->endComp = tmp_offset;",
          "3866:   break;",
          "3867:  case CTO_Syllable:",
          "3868:   (*table)->syllables = 1;",
          "3869:  case CTO_Always:",
          "3870:  case CTO_NoCross:",
          "3871:  case CTO_LargeSign:",
          "3872:  case CTO_WholeWord:",
          "3873:  case CTO_PartWord:",
          "3874:  case CTO_JoinNum:",
          "3875:  case CTO_JoinableWord:",
          "3876:  case CTO_LowWord:",
          "3877:  case CTO_SuffixableWord:",
          "3878:  case CTO_PrefixableWord:",
          "3879:  case CTO_BegWord:",
          "3880:  case CTO_BegMidWord:",
          "3881:  case CTO_MidWord:",
          "3882:  case CTO_MidEndWord:",
          "3883:  case CTO_EndWord:",
          "3884:  case CTO_PrePunc:",
          "3885:  case CTO_PostPunc:",
          "3886:  case CTO_BegNum:",
          "3887:  case CTO_MidNum:",
          "3888:  case CTO_EndNum:",
          "3889:  case CTO_Repeated:",
          "3890:  case CTO_RepWord:",
          "3891:   if (getRuleCharsText(nested, &ruleChars, &lastToken))",
          "3892:    if (getRuleDotsPattern(nested, &ruleDots, &lastToken))",
          "3893:     if (!addRule(nested, opcode, &ruleChars, &ruleDots, after, before,",
          "3894:        newRuleOffset, newRule, noback, nofor, table))",
          "3895:      ok = 0;",
          "3902:   break;",
          "3903:  case CTO_CompDots:",
          "3904:  case CTO_Comp6:",
          "3905:   if (!getRuleCharsText(nested, &ruleChars, &lastToken)) return 0;",
          "3906:   if (ruleChars.length != 1 || ruleChars.chars[0] > 255) {",
          "3907:    compileError(nested, \"first operand must be 1 character and < 256\");",
          "3908:    return 0;",
          "3909:   }",
          "3910:   if (!getRuleDotsPattern(nested, &ruleDots, &lastToken)) return 0;",
          "3911:   if (!addRule(nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset,",
          "3912:      newRule, noback, nofor, table))",
          "3913:    ok = 0;",
          "3914:   (*table)->compdotsPattern[ruleChars.chars[0]] = *newRuleOffset;",
          "3915:   break;",
          "3916:  case CTO_ExactDots:",
          "3917:   if (!getRuleCharsText(nested, &ruleChars, &lastToken)) return 0;",
          "3918:   if (ruleChars.chars[0] != '@') {",
          "3919:    compileError(nested, \"The operand must begin with an at sign (@)\");",
          "3920:    return 0;",
          "3921:   }",
          "3922:   for (k = 1; k < ruleChars.length; k++)",
          "3923:    scratchPad.chars[k - 1] = ruleChars.chars[k];",
          "3924:   scratchPad.length = ruleChars.length - 1;",
          "3925:   if (!parseDots(nested, &ruleDots, &scratchPad)) return 0;",
          "3926:   if (!addRule(nested, opcode, &ruleChars, &ruleDots, before, after, newRuleOffset,",
          "3927:      newRule, noback, nofor, table))",
          "3928:    ok = 0;",
          "3929:   break;",
          "3930:  case CTO_CapsNoCont:",
          "3931:   ruleChars.length = 1;",
          "3932:   ruleChars.chars[0] = 'a';",
          "3933:   if (!addRule(nested, CTO_CapsNoContRule, &ruleChars, NULL, after, before,",
          "3934:      newRuleOffset, newRule, noback, nofor, table))",
          "3935:    ok = 0;",
          "3936:   (*table)->capsNoCont = *newRuleOffset;",
          "3937:   break;",
          "3938:  case CTO_Replace:",
          "3939:   if (getRuleCharsText(nested, &ruleChars, &lastToken)) {",
          "3940:    if (lastToken)",
          "3941:     ruleDots.length = ruleDots.chars[0] = 0;",
          "3942:    else {",
          "3943:     getRuleDotsText(nested, &ruleDots, &lastToken);",
          "3944:     if (ruleDots.chars[0] == '#')",
          "3945:      ruleDots.length = ruleDots.chars[0] = 0;",
          "3946:     else if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')",
          "3947:      memcpy(&ruleDots.chars[0], &ruleDots.chars[1],",
          "3948:        ruleDots.length-- * CHARSIZE);",
          "3949:    }",
          "3950:   }",
          "3951:   for (k = 0; k < ruleChars.length; k++)",
          "3952:    addCharOrDots(nested, ruleChars.chars[k], 0, table);",
          "3953:   for (k = 0; k < ruleDots.length; k++)",
          "3954:    addCharOrDots(nested, ruleDots.chars[k], 0, table);",
          "3955:   if (!addRule(nested, opcode, &ruleChars, &ruleDots, after, before, newRuleOffset,",
          "3956:      newRule, noback, nofor, table))",
          "3957:    ok = 0;",
          "3958:   break;",
          "3959:  case CTO_Correct:",
          "3960:   (*table)->corrections = 1;",
          "3961:   goto doPass;",
          "3962:  case CTO_Pass2:",
          "3963:   if ((*table)->numPasses < 2) (*table)->numPasses = 2;",
          "3964:   goto doPass;",
          "3965:  case CTO_Pass3:",
          "3966:   if ((*table)->numPasses < 3) (*table)->numPasses = 3;",
          "3967:   goto doPass;",
          "3968:  case CTO_Pass4:",
          "3969:   if ((*table)->numPasses < 4) (*table)->numPasses = 4;",
          "3970:  doPass:",
          "3971:  case CTO_Context:",
          "3972:   if (!(nofor || noback)) {",
          "3973:    compileError(nested, \"%s or %s must be specified.\",",
          "3974:      _lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));",
          "3975:    ok = 0;",
          "3976:    break;",
          "3977:   }",
          "3978:   if (!compilePassOpcode(nested, opcode, *characterClasses, newRuleOffset, newRule,",
          "3979:      noback, nofor, *ruleNames, table))",
          "3980:    ok = 0;",
          "3981:   break;",
          "3982:  case CTO_Contraction:",
          "3983:  case CTO_NoCont:",
          "3984:  case CTO_CompBrl:",
          "3985:  case CTO_Literal:",
          "3986:   if (getRuleCharsText(nested, &ruleChars, &lastToken))",
          "3987:    if (!addRule(nested, opcode, &ruleChars, NULL, after, before, newRuleOffset,",
          "3988:       newRule, noback, nofor, table))",
          "3989:     ok = 0;",
          "3990:   break;",
          "3991:  case CTO_MultInd: {",
          "3992:   int t;",
          "3993:   ruleChars.length = 0;",
          "3994:   if (getToken(nested, &token, \"multiple braille indicators\", &lastToken) &&",
          "3995:     parseDots(nested, &cells, &token)) {",
          "3996:    while ((t = getToken(nested, &token, \"multind opcodes\", &lastToken))) {",
          "3997:     opcode = getOpcode(nested, &token, opcodeLengths);",
          "3998:     if (opcode >= CTO_CapsLetter && opcode < CTO_MultInd)",
          "3999:      ruleChars.chars[ruleChars.length++] = (widechar)opcode;",
          "4000:     else {",
          "4001:      compileError(nested, \"Not a braille indicator opcode.\");",
          "4002:      ok = 0;",
          "4003:     }",
          "4004:     if (t == 2) break;",
          "4005:    }",
          "4006:   } else",
          "4007:    ok = 0;",
          "4008:   if (!addRule(nested, CTO_MultInd, &ruleChars, &cells, after, before,",
          "4009:      newRuleOffset, newRule, noback, nofor, table))",
          "4010:    ok = 0;",
          "4014:  case CTO_Class: {",
          "4015:   CharsString characters;",
          "4016:   const CharacterClass *class;",
          "4017:   if (!*characterClasses) {",
          "4018:    if (!allocateCharacterClasses(characterClasses, characterClassAttribute))",
          "4019:     ok = 0;",
          "4020:   }",
          "4021:   if (getToken(nested, &token, \"character class name\", &lastToken)) {",
          "4022:    if ((class = findCharacterClass(&token, *characterClasses))) {",
          "4023:     compileError(nested, \"character class already defined.\");",
          "4024:    } else if ((class = addCharacterClass(nested, &token.chars[0], token.length,",
          "4025:         characterClasses, characterClassAttribute))) {",
          "4026:     if (getCharacters(nested, &characters, &lastToken)) {",
          "4027:      int index;",
          "4028:      for (index = 0; index < characters.length; ++index) {",
          "4029:       TranslationTableRule *defRule;",
          "4030:       TranslationTableCharacter *character = definedCharOrDots(",
          "4031:         nested, characters.chars[index], 0, *table);",
          "4032:       character->attributes |= class->attribute;",
          "4033:       defRule = (TranslationTableRule *)&(",
          "4035:       if (defRule->dotslen == 1) {",
          "4036:        character = definedCharOrDots(nested,",
          "4037:          defRule->charsdots[defRule->charslen], 1, *table);",
          "4038:        character->attributes |= class->attribute;",
          "4039:       }",
          "4040:      }",
          "4041:     }",
          "4042:    }",
          "4043:   }",
          "4044:   break;",
          "4047:   {",
          "4048:    TranslationTableCharacterAttributes *attributes;",
          "4049:    const CharacterClass *class;",
          "4050:   case CTO_After:",
          "4051:    attributes = &after;",
          "4052:    goto doClass;",
          "4053:   case CTO_Before:",
          "4054:    attributes = &before;",
          "4055:   doClass:",
          "4057:    if (!*characterClasses) {",
          "4058:     if (!allocateCharacterClasses(characterClasses, characterClassAttribute))",
          "4059:      ok = 0;",
          "4060:    }",
          "4061:    if (getCharacterClass(nested, &class, *characterClasses, &lastToken)) {",
          "4063:     goto doOpcode;",
          "4064:    }",
          "4065:    break;",
          "4066:   }",
          "4068:  case CTO_NoBack:",
          "4069:   if (nofor) {",
          "4070:    compileError(nested, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));",
          "4071:    ok = 0;",
          "4072:    break;",
          "4073:   }",
          "4074:   noback = 1;",
          "4075:   goto doOpcode;",
          "4076:  case CTO_NoFor:",
          "4077:   if (noback) {",
          "4078:    compileError(",
          "4079:      nested, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));",
          "4080:    ok = 0;",
          "4081:    break;",
          "4082:   }",
          "4083:   nofor = 1;",
          "4084:   goto doOpcode;",
          "4086:  case CTO_EmpMatchBefore:",
          "4087:   before |= CTC_EmpMatch;",
          "4088:   goto doOpcode;",
          "4089:  case CTO_EmpMatchAfter:",
          "4090:   after |= CTC_EmpMatch;",
          "4091:   goto doOpcode;",
          "4093:  case CTO_SwapCc:",
          "4094:  case CTO_SwapCd:",
          "4095:  case CTO_SwapDd:",
          "4096:   if (!compileSwap(nested, opcode, &lastToken, newRuleOffset, newRule, noback,",
          "4097:      nofor, ruleNames, table))",
          "4098:    ok = 0;",
          "4099:   break;",
          "4100:  case CTO_Hyphen:",
          "4101:  case CTO_DecPoint:",
          "4104:   if (getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4105:    if (getRuleDotsPattern(nested, &ruleDots, &lastToken)) {",
          "4106:     if (ruleChars.length != 1 || ruleDots.length < 1) {",
          "4107:      compileError(nested,",
          "4108:        \"One Unicode character and at least one cell are required.\");",
          "4109:      ok = 0;",
          "4110:     }",
          "4111:     if (!addRule(nested, opcode, &ruleChars, &ruleDots, after, before,",
          "4112:        newRuleOffset, newRule, noback, nofor, table))",
          "4113:      ok = 0;",
          "4121:    }",
          "4122:   break;",
          "4123:  case CTO_Space:",
          "4124:   compileCharDef(nested, opcode, CTC_Space, &lastToken, newRuleOffset, newRule,",
          "4125:     noback, nofor, table);",
          "4126:   break;",
          "4127:  case CTO_Digit:",
          "4128:   compileCharDef(nested, opcode, CTC_Digit, &lastToken, newRuleOffset, newRule,",
          "4129:     noback, nofor, table);",
          "4130:   break;",
          "4131:  case CTO_LitDigit:",
          "4132:   compileCharDef(nested, opcode, CTC_LitDigit, &lastToken, newRuleOffset, newRule,",
          "4133:     noback, nofor, table);",
          "4134:   break;",
          "4135:  case CTO_Punctuation:",
          "4136:   compileCharDef(nested, opcode, CTC_Punctuation, &lastToken, newRuleOffset,",
          "4137:     newRule, noback, nofor, table);",
          "4138:   break;",
          "4139:  case CTO_Math:",
          "4140:   compileCharDef(nested, opcode, CTC_Math, &lastToken, newRuleOffset, newRule,",
          "4141:     noback, nofor, table);",
          "4142:   break;",
          "4143:  case CTO_Sign:",
          "4144:   compileCharDef(nested, opcode, CTC_Sign, &lastToken, newRuleOffset, newRule,",
          "4145:     noback, nofor, table);",
          "4146:   break;",
          "4147:  case CTO_Letter:",
          "4148:   compileCharDef(nested, opcode, CTC_Letter, &lastToken, newRuleOffset, newRule,",
          "4149:     noback, nofor, table);",
          "4150:   break;",
          "4151:  case CTO_UpperCase:",
          "4152:   compileCharDef(nested, opcode, CTC_UpperCase, &lastToken, newRuleOffset, newRule,",
          "4153:     noback, nofor, table);",
          "4154:   break;",
          "4155:  case CTO_LowerCase:",
          "4156:   compileCharDef(nested, opcode, CTC_LowerCase, &lastToken, newRuleOffset, newRule,",
          "4157:     noback, nofor, table);",
          "4158:   break;",
          "4159:  case CTO_Grouping:",
          "4160:   ok = compileGrouping(nested, &lastToken, newRuleOffset, newRule, noback, nofor,",
          "4161:     ruleNames, table);",
          "4162:   break;",
          "4163:  case CTO_UpLow:",
          "4164:   ok = compileUplow(",
          "4165:     nested, &lastToken, newRuleOffset, newRule, noback, nofor, table);",
          "4166:   break;",
          "4167:  case CTO_Display:",
          "4168:   if (getRuleCharsText(nested, &ruleChars, &lastToken))",
          "4169:    if (getRuleDotsPattern(nested, &ruleDots, &lastToken)) {",
          "4170:     if (ruleChars.length != 1 || ruleDots.length != 1) {",
          "4171:      compileError(",
          "4172:        nested, \"Exactly one character and one cell are required.\");",
          "4173:      ok = 0;",
          "4174:     }",
          "4175:     putCharAndDots(nested, ruleChars.chars[0], ruleDots.chars[0], table);",
          "4176:    }",
          "4177:   break;",
          "4178:  default:",
          "4179:   compileError(nested, \"unimplemented opcode.\");",
          "4181:   break;",
          "4182:  }",
          "4184:  if (patterns != NULL) free(patterns);",
          "4186:  return ok;",
          "4190: lou_readCharFromFile(const char *fileName, int *mode) {",
          "4193:  int ch;",
          "4194:  static FileInfo nested;",
          "4195:  if (fileName == NULL) return 0;",
          "4196:  if (*mode == 1) {",
          "4198:   nested.fileName = fileName;",
          "4199:   nested.encoding = noEncoding;",
          "4200:   nested.status = 0;",
          "4201:   nested.lineNumber = 0;",
          "4202:   if (!(nested.in = fopen(nested.fileName, \"r\"))) {",
          "4203:    _lou_logMessage(LOG_ERROR, \"Cannot open file '%s'\", nested.fileName);",
          "4205:    return EOF;",
          "4206:   }",
          "4207:  }",
          "4208:  if (nested.in == NULL) {",
          "4210:   return EOF;",
          "4212:  ch = getAChar(&nested);",
          "4213:  if (ch == EOF) {",
          "4214:   fclose(nested.in);",
          "4215:   nested.in = NULL;",
          "4217:  }",
          "4218:  return ch;",
          "4222: compileString(const char *inString, CharacterClass **characterClasses,",
          "4223:   TranslationTableCharacterAttributes *characterClassAttribute,",
          "4224:   short opcodeLengths[], TranslationTableOffset *newRuleOffset,",
          "4225:   TranslationTableRule **newRule, RuleName **ruleNames,",
          "4226:   TranslationTableHeader **table) {",
          "4228:  int k;",
          "4229:  FileInfo nested;",
          "4230:  if (inString == NULL) return 0;",
          "4231:  memset(&nested, 0, sizeof(nested));",
          "4232:  nested.fileName = inString;",
          "4233:  nested.encoding = noEncoding;",
          "4234:  nested.lineNumber = 1;",
          "4235:  nested.status = 0;",
          "4236:  nested.linepos = 0;",
          "4237:  for (k = 0; inString[k]; k++) nested.line[k] = inString[k];",
          "4238:  nested.line[k] = 0;",
          "4239:  nested.linelen = k;",
          "4240:  return compileRule(&nested, characterClasses, characterClassAttribute, opcodeLengths,",
          "4241:    newRuleOffset, newRule, ruleNames, table);",
          "4245: makeDoubleRule(TranslationTableOpcode opcode, TranslationTableOffset *singleRule,",
          "4246:   TranslationTableOffset *doubleRule, TranslationTableOffset *newRuleOffset,",
          "4247:   TranslationTableRule **newRule, int noback, int nofor,",
          "4248:   TranslationTableHeader **table) {",
          "4249:  CharsString dots;",
          "4250:  TranslationTableRule *rule;",
          "4251:  if (!*singleRule || *doubleRule) return 1;",
          "4252:  rule = (TranslationTableRule *)&(*table)->ruleArea[*singleRule];",
          "4253:  memcpy(dots.chars, &rule->charsdots[0], rule->dotslen * CHARSIZE);",
          "4254:  memcpy(&dots.chars[rule->dotslen], &rule->charsdots[0], rule->dotslen * CHARSIZE);",
          "4255:  dots.length = 2 * rule->dotslen;",
          "4256:  if (!addRule(NULL, opcode, NULL, &dots, 0, 0, newRuleOffset, newRule, noback, nofor,",
          "4257:     table))",
          "4258:   return 0;",
          "4260:  return 1;",
          "4264: setDefaults(TranslationTableHeader *table) {",
          "4268:  if (!table->emphRules[emph1Rule][lenPhraseOffset])",
          "4269:   table->emphRules[emph1Rule][lenPhraseOffset] = 4;",
          "4273:  if (!table->emphRules[emph2Rule][lenPhraseOffset])",
          "4274:   table->emphRules[emph2Rule][lenPhraseOffset] = 4;",
          "4278:  if (!table->emphRules[emph3Rule][lenPhraseOffset])",
          "4279:   table->emphRules[emph3Rule][lenPhraseOffset] = 4;",
          "4280:  if (table->numPasses == 0) table->numPasses = 1;",
          "4281:  return 1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5031: static char *",
          "5056:  }",
          "5067:   return tableFile;",
          "5068:  }",
          "5102:   }",
          "5105:  }",
          "5110: }",
          "5112: char *EXPORT_CALL",
          "5126: #ifdef _WIN32",
          "5133: #else",
          "5135: #endif",
          "5140: }",
          "",
          "[Removed Lines]",
          "5032: resolveSubtable (const char *table, const char *base, const char *searchPath)",
          "5033: {",
          "5034:   char *tableFile;",
          "5035:   static struct stat info;",
          "5037:   if (table == NULL || table[0] == '\\0')",
          "5038:     return NULL;",
          "5039:   tableFile = (char *) malloc (MAXSTRING * sizeof(char) * 2);",
          "5044:   if (base)",
          "5045:     {",
          "5046:       int k;",
          "5047:       strcpy (tableFile, base);",
          "5048:       k = (int)strlen (tableFile);",
          "5049:       while (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\\\') k--;",
          "5050:       tableFile[++k] = '\\0';",
          "5051:       strcat (tableFile, table);",
          "5052:       if (stat (tableFile, &info) == 0 && !(info.st_mode & S_IFDIR))",
          "5053:  {",
          "5054:   _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "5055:   return tableFile;",
          "5057:     }",
          "5063:   strcpy (tableFile, table);",
          "5064:   if (stat (tableFile, &info) == 0 && !(info.st_mode & S_IFDIR))",
          "5065:  {",
          "5066:   _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "5073:   if (searchPath[0] != '\\0')",
          "5074:     {",
          "5075:       char *dir;",
          "5076:       int last;",
          "5077:       char *cp;",
          "5078:       char *searchPath_copy = strdup (searchPath);",
          "5079:       for (dir = searchPath_copy; ; dir = cp + 1)",
          "5080:  {",
          "5081:    for (cp = dir; *cp != '\\0' && *cp != ','; cp++)",
          "5082:      ;",
          "5083:    last = (*cp == '\\0');",
          "5085:    if (dir == cp)",
          "5086:      dir = \".\";",
          "5087:    sprintf (tableFile, \"%s%c%s\", dir, DIR_SEP, table);",
          "5088:    if (stat (tableFile, &info) == 0 && !(info.st_mode & S_IFDIR))",
          "5089:   {",
          "5090:    _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "5091:    free(searchPath_copy);",
          "5092:    return tableFile;",
          "5093:   }",
          "5094:    if (last)",
          "5095:      break;",
          "5096:    sprintf (tableFile, \"%s%c%s%c%s%c%s\", dir, DIR_SEP, \"liblouis\", DIR_SEP, \"tables\", DIR_SEP, table);",
          "5097:    if (stat (tableFile, &info) == 0 && !(info.st_mode & S_IFDIR))",
          "5098:   {",
          "5099:    _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "5100:    free(searchPath_copy);",
          "5101:    return tableFile;",
          "5103:    if (last)",
          "5104:      break;",
          "5106:       free(searchPath_copy);",
          "5107:     }",
          "5108:   free (tableFile);",
          "5109:   return NULL;",
          "5113: _lou_getTablePath()",
          "5114: {",
          "5115:   char searchPath[MAXSTRING];",
          "5116:   char *path;",
          "5117:   char *cp;",
          "5118:   cp = searchPath;",
          "5119:   path = getenv (\"LOUIS_TABLEPATH\");",
          "5120:   if (path != NULL && path[0] != '\\0')",
          "5121:     cp += sprintf (cp, \",%s\", path);",
          "5122:   path = lou_getDataPath ();",
          "5123:   if (path != NULL && path[0] != '\\0')",
          "5124:     cp += sprintf (cp, \",%s%c%s%c%s\", path, DIR_SEP, \"liblouis\", DIR_SEP,",
          "5125:      \"tables\");",
          "5127:   path = lou_getProgramPath ();",
          "5128:   if (path != NULL) {",
          "5129:     if(path[0] != '\\0')",
          "5130:       cp += sprintf (cp, \",%s%s\", path, \"\\\\share\\\\liblouis\\\\tables\");",
          "5131:     free(path);",
          "5132:   }",
          "5134:   cp += sprintf (cp, \",%s\", TABLESDIR);",
          "5136:   if (searchPath[0] != '\\0')",
          "5137:     return strdup(&searchPath[1]);",
          "5138:   else",
          "5139:     return strdup(\".\");",
          "",
          "[Added Lines]",
          "4314: resolveSubtable(const char *table, const char *base, const char *searchPath) {",
          "4315:  char *tableFile;",
          "4316:  static struct stat info;",
          "4318:  if (table == NULL || table[0] == '\\0') return NULL;",
          "4319:  tableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2);",
          "4324:  if (base) {",
          "4325:   int k;",
          "4326:   strcpy(tableFile, base);",
          "4327:   k = (int)strlen(tableFile);",
          "4328:   while (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\\\') k--;",
          "4329:   tableFile[++k] = '\\0';",
          "4330:   strcat(tableFile, table);",
          "4331:   if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {",
          "4332:    _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "4333:    return tableFile;",
          "4334:   }",
          "4341:  strcpy(tableFile, table);",
          "4342:  if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {",
          "4343:   _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "4350:  if (searchPath[0] != '\\0') {",
          "4351:   char *dir;",
          "4352:   int last;",
          "4353:   char *cp;",
          "4354:   char *searchPath_copy = strdup(searchPath);",
          "4355:   for (dir = searchPath_copy;; dir = cp + 1) {",
          "4356:    for (cp = dir; *cp != '\\0' && *cp != ','; cp++)",
          "4357:     ;",
          "4358:    last = (*cp == '\\0');",
          "4360:    if (dir == cp) dir = \".\";",
          "4361:    sprintf(tableFile, \"%s%c%s\", dir, DIR_SEP, table);",
          "4362:    if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {",
          "4363:     _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "4364:     free(searchPath_copy);",
          "4365:     return tableFile;",
          "4366:    }",
          "4367:    if (last) break;",
          "4368:    sprintf(tableFile, \"%s%c%s%c%s%c%s\", dir, DIR_SEP, \"liblouis\", DIR_SEP,",
          "4369:      \"tables\", DIR_SEP, table);",
          "4370:    if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {",
          "4371:     _lou_logMessage(LOG_DEBUG, \"found table %s\", tableFile);",
          "4372:     free(searchPath_copy);",
          "4373:     return tableFile;",
          "4374:    }",
          "4375:    if (last) break;",
          "4377:   free(searchPath_copy);",
          "4379:  free(tableFile);",
          "4380:  return NULL;",
          "4384: _lou_getTablePath() {",
          "4385:  char searchPath[MAXSTRING];",
          "4386:  char *path;",
          "4387:  char *cp;",
          "4388:  cp = searchPath;",
          "4389:  path = getenv(\"LOUIS_TABLEPATH\");",
          "4390:  if (path != NULL && path[0] != '\\0') cp += sprintf(cp, \",%s\", path);",
          "4391:  path = lou_getDataPath();",
          "4392:  if (path != NULL && path[0] != '\\0')",
          "4393:   cp += sprintf(cp, \",%s%c%s%c%s\", path, DIR_SEP, \"liblouis\", DIR_SEP, \"tables\");",
          "4395:  path = lou_getProgramPath();",
          "4396:  if (path != NULL) {",
          "4397:   if (path[0] != '\\0')",
          "4398:    cp += sprintf(cp, \",%s%s\", path, \"\\\\share\\\\liblouis\\\\tables\");",
          "4399:   free(path);",
          "4400:  }",
          "4402:  cp += sprintf(cp, \",%s\", TABLESDIR);",
          "4404:  if (searchPath[0] != '\\0')",
          "4405:   return strdup(&searchPath[1]);",
          "4406:  else",
          "4407:   return strdup(\".\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5156: char **EXPORT_CALL",
          "5196:  }",
          "5206: }",
          "5211: static char **",
          "5228: }",
          "5230: char **EXPORT_CALL",
          "5234: }",
          "",
          "[Removed Lines]",
          "5157: _lou_defaultTableResolver (const char *tableList, const char *base)",
          "5158: {",
          "5159:   char * searchPath;",
          "5160:   char **tableFiles;",
          "5161:   char *subTable;",
          "5162:   char *tableList_copy;",
          "5163:   char *cp;",
          "5164:   int last;",
          "5165:   int k;",
          "5168:   searchPath = _lou_getTablePath();",
          "5171:   k = 0;",
          "5172:   for (cp = (char *)tableList; *cp != '\\0'; cp++)",
          "5173:     if (*cp == ',')",
          "5174:       k++;",
          "5175:   tableFiles = (char **) malloc ((k + 2) * sizeof(char *));",
          "5178:   k = 0;",
          "5179:   tableList_copy = strdup (tableList);",
          "5180:   for (subTable = tableList_copy; ; subTable = cp + 1)",
          "5181:     {",
          "5182:       for (cp = subTable; *cp != '\\0' && *cp != ','; cp++);",
          "5183:       last = (*cp == '\\0');",
          "5185:       if (!(tableFiles[k++] = resolveSubtable (subTable, base, searchPath)))",
          "5186:  {",
          "5187:    char *path;",
          "5188:    _lou_logMessage (LOG_ERROR, \"Cannot resolve table '%s'\", subTable);",
          "5189:    path = getenv (\"LOUIS_TABLEPATH\");",
          "5190:    if (path != NULL && path[0] != '\\0')",
          "5191:      _lou_logMessage (LOG_ERROR, \"LOUIS_TABLEPATH=%s\", path);",
          "5192:    free(searchPath);",
          "5193:    free(tableList_copy);",
          "5194:    free (tableFiles);",
          "5195:    return NULL;",
          "5197:       if (k == 1)",
          "5198:  base = subTable;",
          "5199:       if (last)",
          "5200:  break;",
          "5201:     }",
          "5202:   free(searchPath);",
          "5203:   free(tableList_copy);",
          "5204:   tableFiles[k] = NULL;",
          "5205:   return tableFiles;",
          "5208: static char ** (EXPORT_CALL *tableResolver) (const char *tableList, const char *base) =",
          "5209:   &_lou_defaultTableResolver;",
          "5212: copyStringArray(char ** array)",
          "5213: {",
          "5214:   int len;",
          "5215:   char ** copy;",
          "5216:   if (!array)",
          "5217:     return NULL;",
          "5218:   len = 0;",
          "5219:   while (array[len]) len++;",
          "5220:   copy = malloc((len + 1) * sizeof(char *));",
          "5221:   copy[len] = NULL;",
          "5222:   while (len)",
          "5223:     {",
          "5224:       len--;",
          "5225:       copy[len] = strdup (array[len]);",
          "5226:     }",
          "5227:   return copy;",
          "5231: _lou_resolveTable (const char *tableList, const char *base)",
          "5232: {",
          "5233:   return copyStringArray((*tableResolver) (tableList, base));",
          "",
          "[Added Lines]",
          "4425: _lou_defaultTableResolver(const char *tableList, const char *base) {",
          "4426:  char *searchPath;",
          "4427:  char **tableFiles;",
          "4428:  char *subTable;",
          "4429:  char *tableList_copy;",
          "4430:  char *cp;",
          "4431:  int last;",
          "4432:  int k;",
          "4435:  searchPath = _lou_getTablePath();",
          "4438:  k = 0;",
          "4439:  for (cp = (char *)tableList; *cp != '\\0'; cp++)",
          "4440:   if (*cp == ',') k++;",
          "4441:  tableFiles = (char **)malloc((k + 2) * sizeof(char *));",
          "4444:  k = 0;",
          "4445:  tableList_copy = strdup(tableList);",
          "4446:  for (subTable = tableList_copy;; subTable = cp + 1) {",
          "4447:   for (cp = subTable; *cp != '\\0' && *cp != ','; cp++)",
          "4448:    ;",
          "4449:   last = (*cp == '\\0');",
          "4451:   if (!(tableFiles[k++] = resolveSubtable(subTable, base, searchPath))) {",
          "4452:    char *path;",
          "4453:    _lou_logMessage(LOG_ERROR, \"Cannot resolve table '%s'\", subTable);",
          "4454:    path = getenv(\"LOUIS_TABLEPATH\");",
          "4455:    if (path != NULL && path[0] != '\\0')",
          "4456:     _lou_logMessage(LOG_ERROR, \"LOUIS_TABLEPATH=%s\", path);",
          "4457:    free(searchPath);",
          "4458:    free(tableList_copy);",
          "4459:    free(tableFiles);",
          "4460:    return NULL;",
          "4461:   }",
          "4462:   if (k == 1) base = subTable;",
          "4463:   if (last) break;",
          "4465:  free(searchPath);",
          "4466:  free(tableList_copy);",
          "4467:  tableFiles[k] = NULL;",
          "4468:  return tableFiles;",
          "4471: static char **(EXPORT_CALL *tableResolver)(",
          "4472:   const char *tableList, const char *base) = &_lou_defaultTableResolver;",
          "4475: copyStringArray(char **array) {",
          "4476:  int len;",
          "4477:  char **copy;",
          "4478:  if (!array) return NULL;",
          "4479:  len = 0;",
          "4480:  while (array[len]) len++;",
          "4481:  copy = malloc((len + 1) * sizeof(char *));",
          "4482:  copy[len] = NULL;",
          "4483:  while (len) {",
          "4484:   len--;",
          "4485:   copy[len] = strdup(array[len]);",
          "4486:  }",
          "4487:  return copy;",
          "4491: _lou_resolveTable(const char *tableList, const char *base) {",
          "4492:  return copyStringArray((*tableResolver)(tableList, base));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5242: void EXPORT_CALL",
          "5246: }",
          "5248: static int fileCount = 0;",
          "",
          "[Removed Lines]",
          "5243: lou_registerTableResolver (char ** (EXPORT_CALL *resolver) (const char *tableList, const char *base))",
          "5244: {",
          "5245:   tableResolver = resolver;",
          "",
          "[Added Lines]",
          "4502: lou_registerTableResolver(",
          "4503:   char **(EXPORT_CALL *resolver)(const char *tableList, const char *base)) {",
          "4504:  tableResolver = resolver;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "5254: static int",
          "5281: }",
          "5287: free_tablefiles(char **tables) {",
          "5293: }",
          "",
          "[Removed Lines]",
          "5255: compileFile (const char *fileName,",
          "5256:       CharacterClass **characterClasses,",
          "5257:       TranslationTableCharacterAttributes *characterClassAttribute,",
          "5258:       short opcodeLengths[],",
          "5259:       TranslationTableOffset *newRuleOffset,",
          "5260:       TranslationTableRule **newRule,",
          "5261:       RuleName **ruleNames,",
          "5262:       TranslationTableHeader **table)",
          "5263: {",
          "5264:   FileInfo nested;",
          "5265:   fileCount++;",
          "5266:   nested.fileName = fileName;",
          "5267:   nested.encoding = noEncoding;",
          "5268:   nested.status = 0;",
          "5269:   nested.lineNumber = 0;",
          "5270:   if ((nested.in = fopen (nested.fileName, \"rb\")))",
          "5271:     {",
          "5272:       while (_lou_getALine (&nested))",
          "5273:  compileRule (&nested, characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, table);",
          "5274:       fclose (nested.in);",
          "5275:       return 1;",
          "5276:     }",
          "5277:   else",
          "5278:     _lou_logMessage (LOG_ERROR, \"Cannot open table '%s'\", nested.fileName);",
          "5279:   errorCount++;",
          "5280:   return 0;",
          "5286: static void",
          "5288:   char **table;",
          "5289:   if (!tables) return;",
          "5290:   for (table = tables; *table; table++)",
          "5291:     free(*table);",
          "5292:   free(tables);",
          "",
          "[Added Lines]",
          "4514: compileFile(const char *fileName, CharacterClass **characterClasses,",
          "4515:   TranslationTableCharacterAttributes *characterClassAttribute,",
          "4516:   short opcodeLengths[], TranslationTableOffset *newRuleOffset,",
          "4517:   TranslationTableRule **newRule, RuleName **ruleNames,",
          "4518:   TranslationTableHeader **table) {",
          "4519:  FileInfo nested;",
          "4520:  fileCount++;",
          "4521:  nested.fileName = fileName;",
          "4522:  nested.encoding = noEncoding;",
          "4523:  nested.status = 0;",
          "4524:  nested.lineNumber = 0;",
          "4525:  if ((nested.in = fopen(nested.fileName, \"rb\"))) {",
          "4526:   while (_lou_getALine(&nested))",
          "4527:    compileRule(&nested, characterClasses, characterClassAttribute, opcodeLengths,",
          "4528:      newRuleOffset, newRule, ruleNames, table);",
          "4529:   fclose(nested.in);",
          "4530:   return 1;",
          "4531:  } else",
          "4532:   _lou_logMessage(LOG_ERROR, \"Cannot open table '%s'\", nested.fileName);",
          "4533:  errorCount++;",
          "4534:  return 0;",
          "4540: static void",
          "4542:  char **table;",
          "4543:  if (!tables) return;",
          "4544:  for (table = tables; *table; table++) free(*table);",
          "4545:  free(tables);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "5299: static int",
          "5332: }",
          "",
          "[Removed Lines]",
          "5300: includeFile (FileInfo * nested, CharsString * includedFile,",
          "5301:       CharacterClass **characterClasses,",
          "5302:       TranslationTableCharacterAttributes *characterClassAttribute,",
          "5303:       short opcodeLengths[],",
          "5304:       TranslationTableOffset *newRuleOffset,",
          "5305:       TranslationTableRule **newRule,",
          "5306:       RuleName **ruleNames,",
          "5307:       TranslationTableHeader **table)",
          "5308: {",
          "5309:   int k;",
          "5310:   char includeThis[MAXSTRING];",
          "5311:   char **tableFiles;",
          "5312:   int rv;",
          "5313:   for (k = 0; k < includedFile->length; k++)",
          "5314:     includeThis[k] = (char) includedFile->chars[k];",
          "5315:   includeThis[k] = 0;",
          "5316:   tableFiles = _lou_resolveTable (includeThis, nested->fileName);",
          "5317:   if (tableFiles == NULL)",
          "5318:     {",
          "5319:       errorCount++;",
          "5320:       return 0;",
          "5321:     }",
          "5322:   if (tableFiles[1] != NULL)",
          "5323:     {",
          "5324:       errorCount++;",
          "5325:       free_tablefiles(tableFiles);",
          "5326:       _lou_logMessage (LOG_ERROR, \"Table list not supported in include statement: 'include %s'\", includeThis);",
          "5327:       return 0;",
          "5328:     }",
          "5329:   rv = compileFile (*tableFiles, characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, table);",
          "5330:   free_tablefiles(tableFiles);",
          "5331:   return rv;",
          "",
          "[Added Lines]",
          "4553: includeFile(FileInfo *nested, CharsString *includedFile,",
          "4554:   CharacterClass **characterClasses,",
          "4555:   TranslationTableCharacterAttributes *characterClassAttribute,",
          "4556:   short opcodeLengths[], TranslationTableOffset *newRuleOffset,",
          "4557:   TranslationTableRule **newRule, RuleName **ruleNames,",
          "4558:   TranslationTableHeader **table) {",
          "4559:  int k;",
          "4560:  char includeThis[MAXSTRING];",
          "4561:  char **tableFiles;",
          "4562:  int rv;",
          "4563:  for (k = 0; k < includedFile->length; k++)",
          "4564:   includeThis[k] = (char)includedFile->chars[k];",
          "4565:  includeThis[k] = 0;",
          "4566:  tableFiles = _lou_resolveTable(includeThis, nested->fileName);",
          "4567:  if (tableFiles == NULL) {",
          "4568:   errorCount++;",
          "4569:   return 0;",
          "4570:  }",
          "4571:  if (tableFiles[1] != NULL) {",
          "4572:   errorCount++;",
          "4573:   free_tablefiles(tableFiles);",
          "4574:   _lou_logMessage(LOG_ERROR,",
          "4575:     \"Table list not supported in include statement: 'include %s'\",",
          "4576:     includeThis);",
          "4577:   return 0;",
          "4578:  }",
          "4579:  rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,",
          "4580:    opcodeLengths, newRuleOffset, newRule, ruleNames, table);",
          "4581:  free_tablefiles(tableFiles);",
          "4582:  return rv;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "5338: static TranslationTableHeader *",
          "5385: cleanup:",
          "5407: }",
          "5409: static ChainEntry *lastTrans = NULL;",
          "5410: char *EXPORT_CALL",
          "5419: }",
          "5422: char const **EXPORT_CALL",
          "5447: }",
          "5450: void *EXPORT_CALL",
          "5481:  }",
          "5505: }",
          "5507: int EXPORT_CALL",
          "5513: }",
          "5515: formtype EXPORT_CALL",
          "5516: lou_getTypeformForEmphClass(const char *tableList, const char *emphClass) {",
          "5517:  int i;",
          "5518:  TranslationTableHeader *table = lou_getTable(tableList);",
          "5521:  for (i = 0; table->emphClasses[i]; i++)",
          "5524:  return 0;",
          "5525: }",
          "",
          "[Removed Lines]",
          "5339: compileTranslationTable (const char *tableList,",
          "5340:     CharacterClass **characterClasses,",
          "5341:     TranslationTableCharacterAttributes *characterClassAttribute,",
          "5342:     short opcodeLengths[],",
          "5343:     TranslationTableOffset *newRuleOffset,",
          "5344:     TranslationTableRule **newRule,",
          "5345:     RuleName **ruleNames)",
          "5346: {",
          "5347:   TranslationTableHeader *table = NULL;",
          "5348:   char **tableFiles;",
          "5349:   char **subTable;",
          "5350:   errorCount = warningCount = fileCount = 0;",
          "5353:   if (tableList == NULL)",
          "5354:     return NULL;",
          "5355:   if (!opcodeLengths[0])",
          "5356:     {",
          "5357:       TranslationTableOpcode opcode;",
          "5358:       for (opcode = 0; opcode < CTO_None; opcode++)",
          "5359:  opcodeLengths[opcode] = (short) strlen (opcodeNames[opcode]);",
          "5360:     }",
          "5361:   allocateHeader (NULL, &table);",
          "5364:   table->emphClasses[0] = NULL;",
          "5368:   compileString (\"space \\\\s 0\", characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, &table);",
          "5369:   compileString (\"noback sign \\\\x0000 0\", characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, &table);",
          "5370:   compileString (\"space \\\\x00a0 a unbreakable space\", characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, &table);",
          "5371:   compileString (\"space \\\\x001b 1b escape\", characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, &table);",
          "5372:   compileString (\"space \\\\xffff 123456789abcdef ENDSEGMENT\", characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, &table);",
          "5375:   if (!(tableFiles = _lou_resolveTable (tableList, NULL)))",
          "5376:     {",
          "5377:       errorCount++;",
          "5378:       goto cleanup;",
          "5379:     }",
          "5380:   for (subTable = tableFiles; *subTable; subTable++)",
          "5381:     if (!compileFile (*subTable, characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, &table))",
          "5382:       goto cleanup;",
          "5386:   free_tablefiles(tableFiles);",
          "5387:   if (*characterClasses)",
          "5388:     deallocateCharacterClasses (characterClasses);",
          "5389:   if (*ruleNames)",
          "5390:     deallocateRuleNames (ruleNames);",
          "5391:   if (warningCount)",
          "5392:     _lou_logMessage (LOG_WARN, \"%d warnings issued\", warningCount);",
          "5393:   if (!errorCount)",
          "5394:     {",
          "5395:       setDefaults (table);",
          "5396:       table->tableSize = tableSize;",
          "5397:       table->bytesUsed = tableUsed;",
          "5398:     }",
          "5399:   else",
          "5400:     {",
          "5401:       _lou_logMessage (LOG_ERROR, \"%d errors found.\", errorCount);",
          "5402:       if (table)",
          "5403:  free (table);",
          "5404:       table = NULL;",
          "5405:     }",
          "5406:   return table;",
          "5411: _lou_getLastTableList (void)",
          "5412: {",
          "5413:   static char scratchBuf[MAXSTRING];",
          "5414:   if (lastTrans == NULL)",
          "5415:     return NULL;",
          "5416:   strncpy (scratchBuf, lastTrans->tableList, lastTrans->tableListLength);",
          "5417:   scratchBuf[lastTrans->tableListLength] = 0;",
          "5418:   return scratchBuf;",
          "5423: lou_getEmphClasses(const char* tableList)",
          "5424: {",
          "5425:   const char *names[MAX_EMPH_CLASSES + 1];",
          "5426:   unsigned int count = 0;",
          "5427:   const TranslationTableHeader *table = lou_getTable(tableList);",
          "5428:   if (!table) return NULL;",
          "5430:   while (count < MAX_EMPH_CLASSES)",
          "5431:     {",
          "5432:       char const* name = table->emphClasses[count];",
          "5433:       if (!name) break;",
          "5434:       names[count++] = name;",
          "5435:     }",
          "5436:   names[count++] = NULL;",
          "5438:   {",
          "5439:     unsigned int size = count * sizeof(names[0]);",
          "5440:     char const* * result = malloc(size);",
          "5441:     if (!result) return NULL;",
          "5444:     memcpy((void*)result, names, size);",
          "5445:     return result;",
          "5446:   }",
          "5451: lou_getTable (const char *tableList)",
          "5452: {",
          "5454:   int tableListLen;",
          "5455:   ChainEntry *currentEntry = NULL;",
          "5456:   ChainEntry *lastEntry = NULL;",
          "5457:   TranslationTableHeader *newTable;",
          "5458:   if (tableList == NULL || *tableList == 0)",
          "5459:     return NULL;",
          "5460:   errorCount = fileCount = 0;",
          "5461:   tableListLen = (int)strlen (tableList);",
          "5463:   if (lastTrans != NULL)",
          "5464:     if (tableListLen == lastTrans->tableListLength && (memcmp",
          "5465:              (&lastTrans->tableList[0],",
          "5466:        tableList,",
          "5467:        tableListLen)) == 0)",
          "5468:       return (gTable = lastTrans->table);",
          "5470:   currentEntry = tableChain;",
          "5471:   while (currentEntry != NULL)",
          "5472:     {",
          "5473:       if (tableListLen == currentEntry->tableListLength && (memcmp",
          "5474:            (&currentEntry->tableList[0],",
          "5475:             tableList,",
          "5476:             tableListLen))",
          "5477:    == 0)",
          "5478:  {",
          "5479:    lastTrans = currentEntry;",
          "5480:    return (gTable = currentEntry->table);",
          "5482:       lastEntry = currentEntry;",
          "5483:       currentEntry = currentEntry->next;",
          "5484:     }",
          "5485:   if ((newTable = compileTranslationTable (tableList, &gCharacterClasses, &gCharacterClassAttribute, gOpcodeLengths, &gNewRuleOffset, &gNewRule, &gRuleNames)))",
          "5486:     {",
          "5488:       int entrySize = sizeof (ChainEntry) + tableListLen;",
          "5489:       ChainEntry *newEntry = malloc (entrySize);",
          "5490:       if (!newEntry)",
          "5491:  _lou_outOfMemory ();",
          "5492:       if (tableChain == NULL)",
          "5493:  tableChain = newEntry;",
          "5494:       else",
          "5495:  lastEntry->next = newEntry;",
          "5496:       newEntry->next = NULL;",
          "5497:       newEntry->table = newTable;",
          "5498:       newEntry->tableListLength = tableListLen;",
          "5499:       memcpy (&newEntry->tableList[0], tableList, tableListLen);",
          "5500:       lastTrans = newEntry;",
          "5501:       return (gTable = newEntry->table);",
          "5502:     }",
          "5503:   _lou_logMessage (LOG_ERROR, \"%s could not be found\", tableList);",
          "5504:   return NULL;",
          "5508: lou_checkTable (const char *tableList)",
          "5509: {",
          "5510:   if (lou_getTable(tableList))",
          "5511:     return 1;",
          "5512:   return 0;",
          "5519:  if (!table)",
          "5520:   return 0;",
          "5522:   if (strcmp(emphClass, table->emphClasses[i]) == 0)",
          "5523:    return italic << i;",
          "",
          "[Added Lines]",
          "4590: compileTranslationTable(const char *tableList, CharacterClass **characterClasses,",
          "4591:   TranslationTableCharacterAttributes *characterClassAttribute,",
          "4592:   short opcodeLengths[], TranslationTableOffset *newRuleOffset,",
          "4593:   TranslationTableRule **newRule, RuleName **ruleNames) {",
          "4594:  TranslationTableHeader *table = NULL;",
          "4595:  char **tableFiles;",
          "4596:  char **subTable;",
          "4597:  errorCount = warningCount = fileCount = 0;",
          "4600:  if (tableList == NULL) return NULL;",
          "4601:  if (!opcodeLengths[0]) {",
          "4602:   TranslationTableOpcode opcode;",
          "4603:   for (opcode = 0; opcode < CTO_None; opcode++)",
          "4604:    opcodeLengths[opcode] = (short)strlen(opcodeNames[opcode]);",
          "4605:  }",
          "4606:  allocateHeader(NULL, &table);",
          "4609:  table->emphClasses[0] = NULL;",
          "4613:  compileString(\"space \\\\s 0\", characterClasses, characterClassAttribute, opcodeLengths,",
          "4614:    newRuleOffset, newRule, ruleNames, &table);",
          "4615:  compileString(\"noback sign \\\\x0000 0\", characterClasses, characterClassAttribute,",
          "4616:    opcodeLengths, newRuleOffset, newRule, ruleNames, &table);",
          "4617:  compileString(\"space \\\\x00a0 a unbreakable space\", characterClasses,",
          "4618:    characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames,",
          "4619:    &table);",
          "4620:  compileString(\"space \\\\x001b 1b escape\", characterClasses, characterClassAttribute,",
          "4621:    opcodeLengths, newRuleOffset, newRule, ruleNames, &table);",
          "4622:  compileString(\"space \\\\xffff 123456789abcdef ENDSEGMENT\", characterClasses,",
          "4623:    characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames,",
          "4624:    &table);",
          "4627:  if (!(tableFiles = _lou_resolveTable(tableList, NULL))) {",
          "4628:   errorCount++;",
          "4629:   goto cleanup;",
          "4630:  }",
          "4631:  for (subTable = tableFiles; *subTable; subTable++)",
          "4632:   if (!compileFile(*subTable, characterClasses, characterClassAttribute,",
          "4633:      opcodeLengths, newRuleOffset, newRule, ruleNames, &table))",
          "4634:    goto cleanup;",
          "4638:  free_tablefiles(tableFiles);",
          "4639:  if (*characterClasses) deallocateCharacterClasses(characterClasses);",
          "4640:  if (*ruleNames) deallocateRuleNames(ruleNames);",
          "4641:  if (warningCount) _lou_logMessage(LOG_WARN, \"%d warnings issued\", warningCount);",
          "4642:  if (!errorCount) {",
          "4643:   setDefaults(table);",
          "4644:   table->tableSize = tableSize;",
          "4645:   table->bytesUsed = tableUsed;",
          "4646:  } else {",
          "4647:   _lou_logMessage(LOG_ERROR, \"%d errors found.\", errorCount);",
          "4648:   if (table) free(table);",
          "4649:   table = NULL;",
          "4650:  }",
          "4651:  return table;",
          "4656: _lou_getLastTableList(void) {",
          "4657:  static char scratchBuf[MAXSTRING];",
          "4658:  if (lastTrans == NULL) return NULL;",
          "4659:  strncpy(scratchBuf, lastTrans->tableList, lastTrans->tableListLength);",
          "4660:  scratchBuf[lastTrans->tableListLength] = 0;",
          "4661:  return scratchBuf;",
          "4666: lou_getEmphClasses(const char *tableList) {",
          "4667:  const char *names[MAX_EMPH_CLASSES + 1];",
          "4668:  unsigned int count = 0;",
          "4669:  const TranslationTableHeader *table = lou_getTable(tableList);",
          "4670:  if (!table) return NULL;",
          "4672:  while (count < MAX_EMPH_CLASSES) {",
          "4673:   char const *name = table->emphClasses[count];",
          "4674:   if (!name) break;",
          "4675:   names[count++] = name;",
          "4676:  }",
          "4677:  names[count++] = NULL;",
          "4679:  {",
          "4680:   unsigned int size = count * sizeof(names[0]);",
          "4681:   char const **result = malloc(size);",
          "4682:   if (!result) return NULL;",
          "4685:   memcpy((void *)result, names, size);",
          "4686:   return result;",
          "4687:  }",
          "4692: lou_getTable(const char *tableList) {",
          "4694:  int tableListLen;",
          "4695:  ChainEntry *currentEntry = NULL;",
          "4696:  ChainEntry *lastEntry = NULL;",
          "4697:  TranslationTableHeader *newTable;",
          "4698:  if (tableList == NULL || *tableList == 0) return NULL;",
          "4699:  errorCount = fileCount = 0;",
          "4700:  tableListLen = (int)strlen(tableList);",
          "4702:  if (lastTrans != NULL)",
          "4703:   if (tableListLen == lastTrans->tableListLength &&",
          "4704:     (memcmp(&lastTrans->tableList[0], tableList, tableListLen)) == 0)",
          "4705:    return (gTable = lastTrans->table);",
          "4707:  currentEntry = tableChain;",
          "4708:  while (currentEntry != NULL) {",
          "4709:   if (tableListLen == currentEntry->tableListLength &&",
          "4710:     (memcmp(&currentEntry->tableList[0], tableList, tableListLen)) == 0) {",
          "4711:    lastTrans = currentEntry;",
          "4712:    return (gTable = currentEntry->table);",
          "4713:   }",
          "4714:   lastEntry = currentEntry;",
          "4715:   currentEntry = currentEntry->next;",
          "4716:  }",
          "4717:  if ((newTable = compileTranslationTable(tableList, &gCharacterClasses,",
          "4718:      &gCharacterClassAttribute, gOpcodeLengths, &gNewRuleOffset, &gNewRule,",
          "4719:      &gRuleNames))) {",
          "4721:   int entrySize = sizeof(ChainEntry) + tableListLen;",
          "4722:   ChainEntry *newEntry = malloc(entrySize);",
          "4723:   if (!newEntry) _lou_outOfMemory();",
          "4724:   if (tableChain == NULL)",
          "4725:    tableChain = newEntry;",
          "4726:   else",
          "4727:    lastEntry->next = newEntry;",
          "4728:   newEntry->next = NULL;",
          "4729:   newEntry->table = newTable;",
          "4730:   newEntry->tableListLength = tableListLen;",
          "4731:   memcpy(&newEntry->tableList[0], tableList, tableListLen);",
          "4732:   lastTrans = newEntry;",
          "4733:   return (gTable = newEntry->table);",
          "4735:  _lou_logMessage(LOG_ERROR, \"%s could not be found\", tableList);",
          "4736:  return NULL;",
          "4740: lou_checkTable(const char *tableList) {",
          "4741:  if (lou_getTable(tableList)) return 1;",
          "4742:  return 0;",
          "4749:  if (!table) return 0;",
          "4751:   if (strcmp(emphClass, table->emphClasses[i]) == 0) return italic << i;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "5540: static int sizeSrcMapping = 0;",
          "5541: static int sizePrevSrcMapping = 0;",
          "5542: void *EXPORT_CALL",
          "5568:   wordBuffer = malloc((srcmax + 4) * sizeof(unsigned int));",
          "5571:   return wordBuffer;",
          "5577:   emphasisBuffer = malloc((srcmax + 4) * sizeof(unsigned int));",
          "5580:   return emphasisBuffer;",
          "5586:   transNoteBuffer = malloc((srcmax + 4) * sizeof(unsigned int));",
          "5589:   return transNoteBuffer;",
          "5600:  }",
          "5611:  }",
          "5622:  }",
          "5663: }",
          "5665: void EXPORT_CALL",
          "5684:  }",
          "5693:  wordBuffer = NULL;",
          "5696:  emphasisBuffer = NULL;",
          "5699:  transNoteBuffer = NULL;",
          "5722: }",
          "5724: char *EXPORT_CALL",
          "5729: }",
          "5731: int EXPORT_CALL",
          "5735: }",
          "5737: int EXPORT_CALL",
          "5747: }",
          "",
          "[Removed Lines]",
          "5543: _lou_allocMem (AllocBuf buffer, int srcmax, int destmax)",
          "5544: {",
          "5545:   if (srcmax < 1024)",
          "5546:     srcmax = 1024;",
          "5547:   if (destmax < 1024)",
          "5548:     destmax = 1024;",
          "5549:   switch (buffer)",
          "5550:     {",
          "5551:     case alloc_typebuf:",
          "5552:       if (destmax > sizeTypebuf)",
          "5553:  {",
          "5554:    if (typebuf != NULL)",
          "5555:      free (typebuf);",
          "5557:    typebuf = malloc ((destmax + 4) * sizeof (formtype));",
          "5558:    if (!typebuf)",
          "5559:      _lou_outOfMemory ();",
          "5560:    sizeTypebuf = destmax;",
          "5561:  }",
          "5562:       return typebuf;",
          "5564:     case alloc_wordBuffer:",
          "5566:   if(wordBuffer != NULL)",
          "5567:    free(wordBuffer);",
          "5569:   if(!wordBuffer)",
          "5570:    _lou_outOfMemory();",
          "5573:     case alloc_emphasisBuffer:",
          "5575:   if(emphasisBuffer != NULL)",
          "5576:    free(emphasisBuffer);",
          "5578:   if(!emphasisBuffer)",
          "5579:    _lou_outOfMemory();",
          "5582:     case alloc_transNoteBuffer:",
          "5584:   if(transNoteBuffer != NULL)",
          "5585:    free(transNoteBuffer);",
          "5587:   if(!transNoteBuffer)",
          "5588:    _lou_outOfMemory();",
          "5591:     case alloc_destSpacing:",
          "5592:       if (destmax > sizeDestSpacing)",
          "5593:  {",
          "5594:    if (destSpacing != NULL)",
          "5595:      free (destSpacing);",
          "5596:    destSpacing = malloc (destmax + 4);",
          "5597:    if (!destSpacing)",
          "5598:      _lou_outOfMemory ();",
          "5599:    sizeDestSpacing = destmax;",
          "5601:       return destSpacing;",
          "5602:     case alloc_passbuf1:",
          "5603:       if (destmax > sizePassbuf1)",
          "5604:  {",
          "5605:    if (passbuf1 != NULL)",
          "5606:      free (passbuf1);",
          "5607:    passbuf1 = malloc ((destmax + 4) * CHARSIZE);",
          "5608:    if (!passbuf1)",
          "5609:      _lou_outOfMemory ();",
          "5610:    sizePassbuf1 = destmax;",
          "5612:       return passbuf1;",
          "5613:     case alloc_passbuf2:",
          "5614:       if (destmax > sizePassbuf2)",
          "5615:  {",
          "5616:    if (passbuf2 != NULL)",
          "5617:      free (passbuf2);",
          "5618:    passbuf2 = malloc ((destmax + 4) * CHARSIZE);",
          "5619:    if (!passbuf2)",
          "5620:      _lou_outOfMemory ();",
          "5621:    sizePassbuf2 = destmax;",
          "5623:       return passbuf2;",
          "5624:     case alloc_srcMapping:",
          "5625:       {",
          "5626:  int mapSize;",
          "5627:  if (srcmax >= destmax)",
          "5628:    mapSize = srcmax;",
          "5629:  else",
          "5630:    mapSize = destmax;",
          "5631:  if (mapSize > sizeSrcMapping)",
          "5632:    {",
          "5633:      if (srcMapping != NULL)",
          "5634:        free (srcMapping);",
          "5635:      srcMapping = malloc ((mapSize + 4) * sizeof (int));",
          "5636:      if (!srcMapping)",
          "5637:        _lou_outOfMemory ();",
          "5638:      sizeSrcMapping = mapSize;",
          "5639:    }",
          "5640:       }",
          "5641:       return srcMapping;",
          "5642:     case alloc_prevSrcMapping:",
          "5643:       {",
          "5644:  int mapSize;",
          "5645:  if (srcmax >= destmax)",
          "5646:    mapSize = srcmax;",
          "5647:  else",
          "5648:    mapSize = destmax;",
          "5649:  if (mapSize > sizePrevSrcMapping)",
          "5650:    {",
          "5651:      if (prevSrcMapping != NULL)",
          "5652:        free (prevSrcMapping);",
          "5653:      prevSrcMapping = malloc ((mapSize + 4) * sizeof (int));",
          "5654:      if (!prevSrcMapping)",
          "5655:        _lou_outOfMemory ();",
          "5656:      sizePrevSrcMapping = mapSize;",
          "5657:    }",
          "5658:       }",
          "5659:       return prevSrcMapping;",
          "5660:     default:",
          "5661:       return NULL;",
          "5662:     }",
          "5666: lou_free (void)",
          "5667: {",
          "5668:   ChainEntry *currentEntry;",
          "5669:   ChainEntry *previousEntry;",
          "5670:   lou_logEnd();",
          "5671:   if (tableChain != NULL)",
          "5672:     {",
          "5673:       currentEntry = tableChain;",
          "5674:       while (currentEntry)",
          "5675:  {",
          "5676:    int i;",
          "5677:    TranslationTableHeader *t = (TranslationTableHeader *)currentEntry->table;",
          "5678:    for (i = 0; t->emphClasses[i]; i++)",
          "5679:      free(t->emphClasses[i]);",
          "5680:    free (t);",
          "5681:    previousEntry = currentEntry;",
          "5682:    currentEntry = currentEntry->next;",
          "5683:    free (previousEntry);",
          "5685:       tableChain = NULL;",
          "5686:       lastTrans = NULL;",
          "5687:     }",
          "5688:   if (typebuf != NULL)",
          "5689:     free (typebuf);",
          "5690:   typebuf = NULL;",
          "5691:  if(wordBuffer != NULL)",
          "5692:   free(wordBuffer);",
          "5694:  if(emphasisBuffer != NULL)",
          "5695:   free(emphasisBuffer);",
          "5697:  if(transNoteBuffer != NULL)",
          "5698:   free(transNoteBuffer);",
          "5700:   sizeTypebuf = 0;",
          "5701:   if (destSpacing != NULL)",
          "5702:     free (destSpacing);",
          "5703:   destSpacing = NULL;",
          "5704:   sizeDestSpacing = 0;",
          "5705:   if (passbuf1 != NULL)",
          "5706:     free (passbuf1);",
          "5707:   passbuf1 = NULL;",
          "5708:   sizePassbuf1 = 0;",
          "5709:   if (passbuf2 != NULL)",
          "5710:     free (passbuf2);",
          "5711:   passbuf2 = NULL;",
          "5712:   sizePassbuf2 = 0;",
          "5713:   if (srcMapping != NULL)",
          "5714:     free (srcMapping);",
          "5715:   srcMapping = NULL;",
          "5716:   sizeSrcMapping = 0;",
          "5717:   if (prevSrcMapping != NULL)",
          "5718:     free (prevSrcMapping);",
          "5719:   prevSrcMapping = NULL;",
          "5720:   sizePrevSrcMapping = 0;",
          "5721:   gOpcodeLengths[0] = 0;",
          "5725: lou_version (void)",
          "5726: {",
          "5727:   static char *version = PACKAGE_VERSION;",
          "5728:   return version;",
          "5732: lou_charSize (void)",
          "5733: {",
          "5734:   return CHARSIZE;",
          "5738: lou_compileString (const char *tableList, const char *inString)",
          "5739: {",
          "5740:   int r;",
          "5741:   TranslationTableHeader *table = lou_getTable (tableList);",
          "5742:   if (!table)",
          "5743:     return 0;",
          "5744:   r = compileString (inString, &gCharacterClasses, &gCharacterClassAttribute, gOpcodeLengths, &gNewRuleOffset, &gNewRule, &gRuleNames, &table);",
          "5745:   gTable = table;",
          "5746:   return r;",
          "",
          "[Added Lines]",
          "4771: _lou_allocMem(AllocBuf buffer, int srcmax, int destmax) {",
          "4772:  if (srcmax < 1024) srcmax = 1024;",
          "4773:  if (destmax < 1024) destmax = 1024;",
          "4774:  switch (buffer) {",
          "4775:  case alloc_typebuf:",
          "4776:   if (destmax > sizeTypebuf) {",
          "4777:    if (typebuf != NULL) free(typebuf);",
          "4779:    typebuf = malloc((destmax + 4) * sizeof(formtype));",
          "4780:    if (!typebuf) _lou_outOfMemory();",
          "4781:    sizeTypebuf = destmax;",
          "4782:   }",
          "4783:   return typebuf;",
          "4785:  case alloc_wordBuffer:",
          "4787:   if (wordBuffer != NULL) free(wordBuffer);",
          "4789:   if (!wordBuffer) _lou_outOfMemory();",
          "4792:  case alloc_emphasisBuffer:",
          "4794:   if (emphasisBuffer != NULL) free(emphasisBuffer);",
          "4796:   if (!emphasisBuffer) _lou_outOfMemory();",
          "4799:  case alloc_transNoteBuffer:",
          "4801:   if (transNoteBuffer != NULL) free(transNoteBuffer);",
          "4803:   if (!transNoteBuffer) _lou_outOfMemory();",
          "4806:  case alloc_destSpacing:",
          "4807:   if (destmax > sizeDestSpacing) {",
          "4808:    if (destSpacing != NULL) free(destSpacing);",
          "4809:    destSpacing = malloc(destmax + 4);",
          "4810:    if (!destSpacing) _lou_outOfMemory();",
          "4811:    sizeDestSpacing = destmax;",
          "4812:   }",
          "4813:   return destSpacing;",
          "4814:  case alloc_passbuf1:",
          "4815:   if (destmax > sizePassbuf1) {",
          "4816:    if (passbuf1 != NULL) free(passbuf1);",
          "4817:    passbuf1 = malloc((destmax + 4) * CHARSIZE);",
          "4818:    if (!passbuf1) _lou_outOfMemory();",
          "4819:    sizePassbuf1 = destmax;",
          "4820:   }",
          "4821:   return passbuf1;",
          "4822:  case alloc_passbuf2:",
          "4823:   if (destmax > sizePassbuf2) {",
          "4824:    if (passbuf2 != NULL) free(passbuf2);",
          "4825:    passbuf2 = malloc((destmax + 4) * CHARSIZE);",
          "4826:    if (!passbuf2) _lou_outOfMemory();",
          "4827:    sizePassbuf2 = destmax;",
          "4828:   }",
          "4829:   return passbuf2;",
          "4830:  case alloc_srcMapping: {",
          "4831:   int mapSize;",
          "4832:   if (srcmax >= destmax)",
          "4833:    mapSize = srcmax;",
          "4834:   else",
          "4835:    mapSize = destmax;",
          "4836:   if (mapSize > sizeSrcMapping) {",
          "4837:    if (srcMapping != NULL) free(srcMapping);",
          "4838:    srcMapping = malloc((mapSize + 4) * sizeof(int));",
          "4839:    if (!srcMapping) _lou_outOfMemory();",
          "4840:    sizeSrcMapping = mapSize;",
          "4841:   }",
          "4843:   return srcMapping;",
          "4844:  case alloc_prevSrcMapping: {",
          "4845:   int mapSize;",
          "4846:   if (srcmax >= destmax)",
          "4847:    mapSize = srcmax;",
          "4848:   else",
          "4849:    mapSize = destmax;",
          "4850:   if (mapSize > sizePrevSrcMapping) {",
          "4851:    if (prevSrcMapping != NULL) free(prevSrcMapping);",
          "4852:    prevSrcMapping = malloc((mapSize + 4) * sizeof(int));",
          "4853:    if (!prevSrcMapping) _lou_outOfMemory();",
          "4854:    sizePrevSrcMapping = mapSize;",
          "4855:   }",
          "4857:   return prevSrcMapping;",
          "4858:  default:",
          "4859:   return NULL;",
          "4864: lou_free(void) {",
          "4865:  ChainEntry *currentEntry;",
          "4866:  ChainEntry *previousEntry;",
          "4867:  lou_logEnd();",
          "4868:  if (tableChain != NULL) {",
          "4869:   currentEntry = tableChain;",
          "4870:   while (currentEntry) {",
          "4871:    int i;",
          "4872:    TranslationTableHeader *t = (TranslationTableHeader *)currentEntry->table;",
          "4873:    for (i = 0; t->emphClasses[i]; i++) free(t->emphClasses[i]);",
          "4874:    free(t);",
          "4875:    previousEntry = currentEntry;",
          "4876:    currentEntry = currentEntry->next;",
          "4877:    free(previousEntry);",
          "4878:   }",
          "4879:   tableChain = NULL;",
          "4880:   lastTrans = NULL;",
          "4882:  if (typebuf != NULL) free(typebuf);",
          "4883:  typebuf = NULL;",
          "4884:  if (wordBuffer != NULL) free(wordBuffer);",
          "4886:  if (emphasisBuffer != NULL) free(emphasisBuffer);",
          "4888:  if (transNoteBuffer != NULL) free(transNoteBuffer);",
          "4890:  sizeTypebuf = 0;",
          "4891:  if (destSpacing != NULL) free(destSpacing);",
          "4892:  destSpacing = NULL;",
          "4893:  sizeDestSpacing = 0;",
          "4894:  if (passbuf1 != NULL) free(passbuf1);",
          "4895:  passbuf1 = NULL;",
          "4896:  sizePassbuf1 = 0;",
          "4897:  if (passbuf2 != NULL) free(passbuf2);",
          "4898:  passbuf2 = NULL;",
          "4899:  sizePassbuf2 = 0;",
          "4900:  if (srcMapping != NULL) free(srcMapping);",
          "4901:  srcMapping = NULL;",
          "4902:  sizeSrcMapping = 0;",
          "4903:  if (prevSrcMapping != NULL) free(prevSrcMapping);",
          "4904:  prevSrcMapping = NULL;",
          "4905:  sizePrevSrcMapping = 0;",
          "4906:  gOpcodeLengths[0] = 0;",
          "4910: lou_version(void) {",
          "4911:  static char *version = PACKAGE_VERSION;",
          "4912:  return version;",
          "4916: lou_charSize(void) {",
          "4917:  return CHARSIZE;",
          "4921: lou_compileString(const char *tableList, const char *inString) {",
          "4922:  int r;",
          "4923:  TranslationTableHeader *table = lou_getTable(tableList);",
          "4924:  if (!table) return 0;",
          "4925:  r = compileString(inString, &gCharacterClasses, &gCharacterClassAttribute,",
          "4926:    gOpcodeLengths, &gNewRuleOffset, &gNewRule, &gRuleNames, &table);",
          "4927:  gTable = table;",
          "4928:  return r;",
          "",
          "---------------"
        ],
        "liblouis/internal.h||liblouis/internal.h": [
          "File: liblouis/internal.h -> liblouis/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "80: #define B16 0X8000",
          "82: typedef struct intCharTupple {",
          "85: } intCharTupple;",
          "90: const static intCharTupple dotMapping[] = {",
          "107: };",
          "",
          "[Removed Lines]",
          "83:   int key;",
          "84:   char value;",
          "91:   {B1, '1'},",
          "92:   {B2, '2'},",
          "93:   {B3, '3'},",
          "94:   {B4, '4'},",
          "95:   {B5, '5'},",
          "96:   {B6, '6'},",
          "97:   {B7, '7'},",
          "98:   {B8, '8'},",
          "99:   {B9, '9'},",
          "100:   {B10, 'A'},",
          "101:   {B11, 'B'},",
          "102:   {B12, 'C'},",
          "103:   {B13, 'D'},",
          "104:   {B14, 'E'},",
          "105:   {B15, 'F'},",
          "106:   0,",
          "",
          "[Added Lines]",
          "83:  int key;",
          "84:  char value;",
          "91:  { B1, '1' }, { B2, '2' }, { B3, '3' }, { B4, '4' }, { B5, '5' }, { B6, '6' },",
          "92:  { B7, '7' }, { B8, '8' }, { B9, '9' }, { B10, 'A' }, { B11, 'B' }, { B12, 'C' },",
          "93:  { B13, 'D' }, { B14, 'E' }, { B15, 'F' }, 0,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112: #define MAXPASS 4",
          "113: #define MAXSTRING 2048",
          "118: typedef unsigned int TranslationTableOffset;",
          "119: #define OFFSETSIZE sizeof(TranslationTableOffset)",
          "121: typedef enum {",
          "151: } TranslationTableCharacterAttribute;",
          "153: typedef enum {",
          "218: } pass_Codes;",
          "220: typedef unsigned int TranslationTableCharacterAttributes;",
          "222: typedef struct {",
          "226: } CharOrDots;",
          "228: typedef struct {",
          "236: } TranslationTableCharacter;",
          "472: } TranslationTableOpcode;",
          "474: typedef struct {",
          "485: } TranslationTableRule;",
          "488: {",
          "491: } HyphenationTrans;",
          "493: typedef union {",
          "496: } PointOff;",
          "499: {",
          "504: } HyphenationState;",
          "560: } TranslationTableHeader;",
          "562: typedef enum {",
          "572: } AllocBuf;",
          "574: typedef enum {",
          "586: } EmphRuleNumber;",
          "588: typedef enum {",
          "598: } EmphCodeOffset;",
          "601: typedef enum { noEncoding, bigEndian, littleEndian, ascii8 } EncodingType;",
          "603: typedef struct {",
          "613: } FileInfo;",
          "",
          "[Removed Lines]",
          "115: #define MAX_EMPH_CLASSES \\",
          "116:   10 // {emph_1...emph_10} in typeforms enum (liblouis.h)",
          "122:   CTC_Space = 0x1,",
          "123:   CTC_Letter = 0x2,",
          "124:   CTC_Digit = 0x4,",
          "125:   CTC_Punctuation = 0x8,",
          "126:   CTC_UpperCase = 0x10,",
          "127:   CTC_LowerCase = 0x20,",
          "128:   CTC_Math = 0x40,",
          "129:   CTC_Sign = 0x80,",
          "130:   CTC_LitDigit = 0x100,",
          "131:   CTC_Class1 = 0x200,",
          "132:   CTC_Class2 = 0x400,",
          "133:   CTC_Class3 = 0x800,",
          "134:   CTC_Class4 = 0x1000,",
          "135:   CTC_SeqDelimiter = 0x2000,",
          "136:   CTC_SeqBefore = 0x4000,",
          "137:   CTC_SeqAfter = 0x8000,",
          "138:   CTC_UserDefined0 = 0x10000,",
          "139:   CTC_UserDefined1 = 0x20000,",
          "140:   CTC_UserDefined2 = 0x40000,",
          "141:   CTC_UserDefined3 = 0x80000,",
          "142:   CTC_UserDefined4 = 0x100000,",
          "143:   CTC_UserDefined5 = 0x200000,",
          "144:   CTC_UserDefined6 = 0x400000,",
          "145:   CTC_UserDefined7 = 0x800000,",
          "146:   CTC_CapsMode = 0x1000000,",
          "147:   CTC_NumericMode = 0x2000000,",
          "148:   CTC_NumericNoContract = 0x4000000,",
          "149:   CTC_EndOfInput = 0x8000000, // only used by pattern matcher",
          "150:   CTC_EmpMatch = 0x10000000,  // only used in TranslationTableRule->before and TranslationTableRule->after",
          "154:   pass_first = '`',",
          "155:   pass_last = '~',",
          "156:   pass_lookback = '_',",
          "157:   pass_string = '\\\"',",
          "158:   pass_dots = '@',",
          "159:   pass_omit = '?',",
          "160:   pass_startReplace = '[',",
          "161:   pass_endReplace = ']',",
          "162:   pass_startGroup = '{',",
          "163:   pass_endGroup = '}',",
          "164:   pass_variable = '#',",
          "165:   pass_not = '!',",
          "166:   pass_search = '/',",
          "167:   pass_any = 'a',",
          "168:   pass_digit = 'd',",
          "169:   pass_litDigit = 'D',",
          "170:   pass_letter = 'l',",
          "171:   pass_math = 'm',",
          "172:   pass_punctuation = 'p',",
          "173:   pass_sign = 'S',",
          "174:   pass_space = 's',",
          "175:   pass_uppercase = 'U',",
          "176:   pass_lowercase = 'u',",
          "177:   pass_class1 = 'w',",
          "178:   pass_class2 = 'x',",
          "179:   pass_class3 = 'y',",
          "180:   pass_class4 = 'z',",
          "181:   pass_attributes = '$',",
          "182:   pass_groupstart = '{',",
          "183:   pass_groupend = '}',",
          "184:   pass_groupreplace = ';',",
          "185:   pass_swap = '%',",
          "186:   pass_hyphen = '-',",
          "187:   pass_until = '.',",
          "188:   pass_eq = '=',",
          "189:   pass_lt = '<',",
          "190:   pass_gt = '>',",
          "191:   pass_endTest = 32,",
          "192:   pass_plus = '+',",
          "193:   pass_copy = '*',",
          "194:   pass_leftParen = '(',",
          "195:   pass_rightParen = ')',",
          "196:   pass_comma = ',',",
          "197:   pass_lteq = 130,",
          "198:   pass_gteq = 131,",
          "199:   pass_invalidToken = 132,",
          "200:   pass_noteq = 133,",
          "201:   pass_and = 134,",
          "202:   pass_or = 135,",
          "203:   pass_nameFound = 136,",
          "204:   pass_numberFound = 137,",
          "205:   pass_boolean = 138,",
          "206:   pass_class = 139,",
          "207:   pass_define = 140,",
          "208:   pass_emphasis = 141,",
          "209:   pass_group = 142,",
          "210:   pass_mark = 143,",
          "211:   pass_repGroup = 143,",
          "212:   pass_script = 144,",
          "213:   pass_noMoreTokens = 145,",
          "214:   pass_replace = 146,",
          "215:   pass_if = 147,",
          "216:   pass_then = 148,",
          "217:   pass_all = 255",
          "223:   TranslationTableOffset next;",
          "224:   widechar lookFor;",
          "225:   widechar found;",
          "229:   TranslationTableOffset next;",
          "230:   TranslationTableOffset definitionRule;",
          "231:   TranslationTableOffset otherRules;",
          "232:   TranslationTableCharacterAttributes attributes;",
          "233:   widechar realchar;",
          "234:   widechar uppercase;",
          "235:   widechar lowercase;",
          "239:                CTO_IncludeFile,",
          "241:                CTO_Undefined,",
          "243:                CTO_CapsLetter,",
          "244:                CTO_BegCapsWord,",
          "245:                CTO_EndCapsWord,",
          "246:                CTO_BegCaps,",
          "247:                CTO_EndCaps,",
          "248:                CTO_BegCapsPhrase,",
          "249:                CTO_EndCapsPhrase,",
          "250:                CTO_LenCapsPhrase,",
          "252:                CTO_LetterSign,",
          "253:                CTO_NoLetsignBefore,",
          "254:                CTO_NoLetsign,",
          "255:                CTO_NoLetsignAfter,",
          "256:                CTO_NumberSign,",
          "257:                CTO_NumericModeChars,",
          "258:                CTO_NumericNoContractChars,",
          "259:                CTO_SeqDelimiter,",
          "260:                CTO_SeqBeforeChars,",
          "261:                CTO_SeqAfterChars,",
          "262:                CTO_SeqAfterPattern,",
          "263:                CTO_SeqAfterExpression,",
          "264:                CTO_EmphClass,",
          "267:                CTO_EmphLetter,",
          "268:                CTO_BegEmphWord,",
          "269:                CTO_EndEmphWord,",
          "270:                CTO_BegEmph,",
          "271:                CTO_EndEmph,",
          "272:                CTO_BegEmphPhrase,",
          "273:                CTO_EndEmphPhrase,",
          "274:                CTO_LenEmphPhrase,",
          "277:                CTO_CapsModeChars,",
          "279:                CTO_BegComp,",
          "280:                CTO_CompBegEmph1,",
          "281:                CTO_CompEndEmph1,",
          "282:                CTO_CompBegEmph2,",
          "283:                CTO_CompEndEmph2,",
          "284:                CTO_CompBegEmph3,",
          "285:                CTO_CompEndEmph3,",
          "286:                CTO_CompCapSign,",
          "287:                CTO_CompBegCaps,",
          "288:                CTO_CompEndCaps,",
          "289:                CTO_EndComp,",
          "290:                CTO_NoContractSign,",
          "291:                CTO_MultInd,",
          "292:                CTO_CompDots,",
          "293:                CTO_Comp6,",
          "297:                CTO_NoBack,",
          "298:                CTO_NoFor,",
          "299:                CTO_EmpMatchBefore,",
          "300:                CTO_EmpMatchAfter,",
          "301:                CTO_SwapCc,",
          "302:                CTO_SwapCd,",
          "303:                CTO_SwapDd,",
          "304:                CTO_Space,",
          "305:                CTO_Digit,",
          "306:                CTO_Punctuation,",
          "307:                CTO_Math,",
          "308:                CTO_Sign,",
          "309:                CTO_Letter,",
          "310:                CTO_UpperCase,",
          "311:                CTO_LowerCase,",
          "312:                CTO_Grouping,",
          "313:                CTO_UpLow,",
          "314:                CTO_LitDigit,",
          "315:                CTO_Display,",
          "316:                CTO_Replace,",
          "317:                CTO_Context,",
          "318:                CTO_Correct,",
          "319:                CTO_Pass2,",
          "320:                CTO_Pass3,",
          "321:                CTO_Pass4,",
          "322:                CTO_Repeated,",
          "323:                CTO_RepWord,",
          "324:                CTO_CapsNoCont,",
          "325:                CTO_Always,",
          "326:                CTO_ExactDots,",
          "327:                CTO_NoCross,",
          "328:                CTO_Syllable,",
          "329:                CTO_NoCont,",
          "330:                CTO_CompBrl,",
          "331:                CTO_Literal,",
          "332:                CTO_LargeSign,",
          "333:                CTO_WholeWord,",
          "334:                CTO_PartWord,",
          "335:                CTO_JoinNum,",
          "336:                CTO_JoinableWord,",
          "337:                CTO_LowWord,",
          "338:                CTO_Contraction,",
          "351:                CTO_DecPoint,",
          "352:                CTO_Hyphen,",
          "355:                CTO_NoBreak,",
          "356:                CTO_Match,",
          "357:                CTO_BackMatch,",
          "358:                CTO_Attribute,",
          "359:                CTO_None,",
          "362:                CTO_LetterRule,",
          "363:                CTO_NumberRule,",
          "364:                CTO_NoContractRule,",
          "369:                CTO_CapsLetterRule,",
          "370:                CTO_BegCapsWordRule,",
          "371:                CTO_EndCapsWordRule,",
          "372:                CTO_BegCapsRule,",
          "373:                CTO_EndCapsRule,",
          "374:                CTO_BegCapsPhraseRule,",
          "375:                CTO_EndCapsPhraseBeforeRule,",
          "376:                CTO_EndCapsPhraseAfterRule,",
          "377:                CTO_Emph1LetterRule,",
          "378:                CTO_BegEmph1WordRule,",
          "379:                CTO_EndEmph1WordRule,",
          "380:                CTO_BegEmph1Rule,",
          "381:                CTO_EndEmph1Rule,",
          "382:                CTO_BegEmph1PhraseRule,",
          "383:                CTO_EndEmph1PhraseBeforeRule,",
          "384:                CTO_EndEmph1PhraseAfterRule,",
          "385:                CTO_Emph2LetterRule,",
          "386:                CTO_BegEmph2WordRule,",
          "387:                CTO_EndEmph2WordRule,",
          "388:                CTO_BegEmph2Rule,",
          "389:                CTO_EndEmph2Rule,",
          "390:                CTO_BegEmph2PhraseRule,",
          "391:                CTO_EndEmph2PhraseBeforeRule,",
          "392:                CTO_EndEmph2PhraseAfterRule,",
          "393:                CTO_Emph3LetterRule,",
          "394:                CTO_BegEmph3WordRule,",
          "395:                CTO_EndEmph3WordRule,",
          "396:                CTO_BegEmph3Rule,",
          "397:                CTO_EndEmph3Rule,",
          "398:                CTO_BegEmph3PhraseRule,",
          "399:                CTO_EndEmph3PhraseBeforeRule,",
          "400:                CTO_EndEmph3PhraseAfterRule,",
          "401:                CTO_Emph4LetterRule,",
          "402:                CTO_BegEmph4WordRule,",
          "403:                CTO_EndEmph4WordRule,",
          "404:                CTO_BegEmph4Rule,",
          "405:                CTO_EndEmph4Rule,",
          "406:                CTO_BegEmph4PhraseRule,",
          "407:                CTO_EndEmph4PhraseBeforeRule,",
          "408:                CTO_EndEmph4PhraseAfterRule,",
          "409:                CTO_Emph5LetterRule,",
          "410:                CTO_BegEmph5WordRule,",
          "411:                CTO_EndEmph5WordRule,",
          "412:                CTO_BegEmph5Rule,",
          "413:                CTO_EndEmph5Rule,",
          "414:                CTO_BegEmph5PhraseRule,",
          "415:                CTO_EndEmph5PhraseBeforeRule,",
          "416:                CTO_EndEmph5PhraseAfterRule,",
          "417:                CTO_Emph6LetterRule,",
          "418:                CTO_BegEmph6WordRule,",
          "419:                CTO_EndEmph6WordRule,",
          "420:                CTO_BegEmph6Rule,",
          "421:                CTO_EndEmph6Rule,",
          "422:                CTO_BegEmph6PhraseRule,",
          "423:                CTO_EndEmph6PhraseBeforeRule,",
          "424:                CTO_EndEmph6PhraseAfterRule,",
          "425:                CTO_Emph7LetterRule,",
          "426:                CTO_BegEmph7WordRule,",
          "427:                CTO_EndEmph7WordRule,",
          "428:                CTO_BegEmph7Rule,",
          "429:                CTO_EndEmph7Rule,",
          "430:                CTO_BegEmph7PhraseRule,",
          "431:                CTO_EndEmph7PhraseBeforeRule,",
          "432:                CTO_EndEmph7PhraseAfterRule,",
          "433:                CTO_Emph8LetterRule,",
          "434:                CTO_BegEmph8WordRule,",
          "435:                CTO_EndEmph8WordRule,",
          "436:                CTO_BegEmph8Rule,",
          "437:                CTO_EndEmph8Rule,",
          "438:                CTO_BegEmph8PhraseRule,",
          "439:                CTO_EndEmph8PhraseBeforeRule,",
          "440:                CTO_EndEmph8PhraseAfterRule,",
          "441:                CTO_Emph9LetterRule,",
          "442:                CTO_BegEmph9WordRule,",
          "443:                CTO_EndEmph9WordRule,",
          "444:                CTO_BegEmph9Rule,",
          "445:                CTO_EndEmph9Rule,",
          "446:                CTO_BegEmph9PhraseRule,",
          "447:                CTO_EndEmph9PhraseBeforeRule,",
          "448:                CTO_EndEmph9PhraseAfterRule,",
          "449:                CTO_Emph10LetterRule,",
          "450:                CTO_BegEmph10WordRule,",
          "451:                CTO_EndEmph10WordRule,",
          "452:                CTO_BegEmph10Rule,",
          "453:                CTO_EndEmph10Rule,",
          "454:                CTO_BegEmph10PhraseRule,",
          "455:                CTO_EndEmph10PhraseBeforeRule,",
          "456:                CTO_EndEmph10PhraseAfterRule,",
          "459:                CTO_BegCompRule,",
          "460:                CTO_CompBegEmph1Rule,",
          "461:                CTO_CompEndEmph1Rule,",
          "462:                CTO_CompBegEmph2Rule,",
          "463:                CTO_CompEndEmrh2Rule,",
          "464:                CTO_CompBegEmph3Rule,",
          "465:                CTO_CompEndEmph3Rule,",
          "466:                CTO_CompCapSignRule,",
          "467:                CTO_CompBegCapsRule,",
          "468:                CTO_CompEndCapsRule,",
          "469:                CTO_EndCompRule,",
          "470:                CTO_CapsNoContRule,",
          "471:                CTO_All",
          "477:   TranslationTableCharacterAttributes",
          "489:   widechar ch;",
          "490:   widechar newState;",
          "494:   HyphenationTrans *pointer;",
          "495:   TranslationTableOffset offset;",
          "500:   PointOff trans;",
          "501:   TranslationTableOffset hyphenPattern;",
          "502:   widechar fallbackState;",
          "503:   widechar numTrans;",
          "510:   int capsNoCont;",
          "511:   int numPasses;",
          "512:   int corrections;",
          "513:   int syllables;",
          "514:   int usesSequences;",
          "515:   int usesNumericMode;",
          "516:   TranslationTableOffset tableSize;",
          "517:   TranslationTableOffset bytesUsed;",
          "518:   TranslationTableOffset undefined;",
          "519:   TranslationTableOffset letterSign;",
          "520:   TranslationTableOffset numberSign;",
          "521:   TranslationTableOffset noContractSign;",
          "522:   widechar seqPatterns[SEQPATTERNSIZE];",
          "523:   char *emphClasses[MAX_EMPH_CLASSES + 1];",
          "524:   int seqPatternsCount;",
          "525:   widechar seqAfterExpression[SEQPATTERNSIZE];",
          "526:   int seqAfterExpressionLength;",
          "529:   TranslationTableOffset emphRules[MAX_EMPH_CLASSES + 1][9];",
          "531:   TranslationTableOffset begComp;",
          "532:   TranslationTableOffset compBegEmph1;",
          "533:   TranslationTableOffset compEndEmph1;",
          "534:   TranslationTableOffset compBegEmph2;",
          "535:   TranslationTableOffset compEndEmph2;",
          "536:   TranslationTableOffset compBegEmph3;",
          "537:   TranslationTableOffset compEndEmph3;",
          "538:   TranslationTableOffset compCapSign;",
          "539:   TranslationTableOffset compBegCaps;",
          "540:   TranslationTableOffset compEndCaps;",
          "541:   TranslationTableOffset endComp;",
          "542:   TranslationTableOffset hyphenStatesArray;",
          "543:   widechar noLetsignBefore[LETSIGNSIZE];",
          "544:   int noLetsignBeforeCount;",
          "545:   widechar noLetsign[LETSIGNSIZE];",
          "546:   int noLetsignCount;",
          "547:   widechar noLetsignAfter[LETSIGNSIZE];",
          "548:   int noLetsignAfterCount;",
          "551:   TranslationTableOffset charToDots[HASHNUM];",
          "552:   TranslationTableOffset dotsToChar[HASHNUM];",
          "553:   TranslationTableOffset compdotsPattern[256];",
          "554:   TranslationTableOffset swapDefinitions[NUMSWAPS];",
          "555:   TranslationTableOffset forPassRules[MAXPASS + 1];",
          "556:   TranslationTableOffset backPassRules[MAXPASS + 1];",
          "563:   alloc_typebuf,",
          "564:   alloc_wordBuffer,",
          "565:   alloc_emphasisBuffer,",
          "566:   alloc_transNoteBuffer,",
          "567:   alloc_destSpacing,",
          "568:   alloc_passbuf1,",
          "569:   alloc_passbuf2,",
          "570:   alloc_srcMapping,",
          "571:   alloc_prevSrcMapping",
          "575:   capsRule = 0,",
          "576:   emph1Rule = 1,",
          "577:   emph2Rule = 2,",
          "578:   emph3Rule = 3,",
          "579:   emph4Rule = 4,",
          "580:   emph5Rule = 5,",
          "581:   emph6Rule = 6,",
          "582:   emph7Rule = 7,",
          "583:   emph8Rule = 8,",
          "584:   emph9Rule = 9,",
          "585:   emph10Rule = 10",
          "589:   begPhraseOffset = 0,",
          "590:   endPhraseBeforeOffset = 1,",
          "591:   endPhraseAfterOffset = 2,",
          "592:   begOffset = 3,",
          "593:   endOffset = 4,",
          "594:   letterOffset = 5,",
          "595:   begWordOffset = 6,",
          "596:   endWordOffset = 7,",
          "597:   lenPhraseOffset = 8",
          "604:   const char *fileName;",
          "605:   FILE *in;",
          "606:   int lineNumber;",
          "607:   EncodingType encoding;",
          "608:   int status;",
          "609:   int linelen;",
          "610:   int linepos;",
          "611:   int checkencoding[2];",
          "612:   widechar line[MAXSTRING];",
          "",
          "[Added Lines]",
          "102: #define MAX_EMPH_CLASSES 10  // {emph_1...emph_10} in typeforms enum (liblouis.h)",
          "108:  CTC_Space = 0x1,",
          "109:  CTC_Letter = 0x2,",
          "110:  CTC_Digit = 0x4,",
          "111:  CTC_Punctuation = 0x8,",
          "112:  CTC_UpperCase = 0x10,",
          "113:  CTC_LowerCase = 0x20,",
          "114:  CTC_Math = 0x40,",
          "115:  CTC_Sign = 0x80,",
          "116:  CTC_LitDigit = 0x100,",
          "117:  CTC_Class1 = 0x200,",
          "118:  CTC_Class2 = 0x400,",
          "119:  CTC_Class3 = 0x800,",
          "120:  CTC_Class4 = 0x1000,",
          "121:  CTC_SeqDelimiter = 0x2000,",
          "122:  CTC_SeqBefore = 0x4000,",
          "123:  CTC_SeqAfter = 0x8000,",
          "124:  CTC_UserDefined0 = 0x10000,",
          "125:  CTC_UserDefined1 = 0x20000,",
          "126:  CTC_UserDefined2 = 0x40000,",
          "127:  CTC_UserDefined3 = 0x80000,",
          "128:  CTC_UserDefined4 = 0x100000,",
          "129:  CTC_UserDefined5 = 0x200000,",
          "130:  CTC_UserDefined6 = 0x400000,",
          "131:  CTC_UserDefined7 = 0x800000,",
          "132:  CTC_CapsMode = 0x1000000,",
          "133:  CTC_NumericMode = 0x2000000,",
          "134:  CTC_NumericNoContract = 0x4000000,",
          "135:  CTC_EndOfInput = 0x8000000,  // only used by pattern matcher",
          "136:  CTC_EmpMatch = 0x10000000,   // only used in TranslationTableRule->before and",
          "141:  pass_first = '`',",
          "142:  pass_last = '~',",
          "143:  pass_lookback = '_',",
          "144:  pass_string = '\\\"',",
          "145:  pass_dots = '@',",
          "146:  pass_omit = '?',",
          "147:  pass_startReplace = '[',",
          "148:  pass_endReplace = ']',",
          "149:  pass_startGroup = '{',",
          "150:  pass_endGroup = '}',",
          "151:  pass_variable = '#',",
          "152:  pass_not = '!',",
          "153:  pass_search = '/',",
          "154:  pass_any = 'a',",
          "155:  pass_digit = 'd',",
          "156:  pass_litDigit = 'D',",
          "157:  pass_letter = 'l',",
          "158:  pass_math = 'm',",
          "159:  pass_punctuation = 'p',",
          "160:  pass_sign = 'S',",
          "161:  pass_space = 's',",
          "162:  pass_uppercase = 'U',",
          "163:  pass_lowercase = 'u',",
          "164:  pass_class1 = 'w',",
          "165:  pass_class2 = 'x',",
          "166:  pass_class3 = 'y',",
          "167:  pass_class4 = 'z',",
          "168:  pass_attributes = '$',",
          "169:  pass_groupstart = '{',",
          "170:  pass_groupend = '}',",
          "171:  pass_groupreplace = ';',",
          "172:  pass_swap = '%',",
          "173:  pass_hyphen = '-',",
          "174:  pass_until = '.',",
          "175:  pass_eq = '=',",
          "176:  pass_lt = '<',",
          "177:  pass_gt = '>',",
          "178:  pass_endTest = 32,",
          "179:  pass_plus = '+',",
          "180:  pass_copy = '*',",
          "181:  pass_leftParen = '(',",
          "182:  pass_rightParen = ')',",
          "183:  pass_comma = ',',",
          "184:  pass_lteq = 130,",
          "185:  pass_gteq = 131,",
          "186:  pass_invalidToken = 132,",
          "187:  pass_noteq = 133,",
          "188:  pass_and = 134,",
          "189:  pass_or = 135,",
          "190:  pass_nameFound = 136,",
          "191:  pass_numberFound = 137,",
          "192:  pass_boolean = 138,",
          "193:  pass_class = 139,",
          "194:  pass_define = 140,",
          "195:  pass_emphasis = 141,",
          "196:  pass_group = 142,",
          "197:  pass_mark = 143,",
          "198:  pass_repGroup = 143,",
          "199:  pass_script = 144,",
          "200:  pass_noMoreTokens = 145,",
          "201:  pass_replace = 146,",
          "202:  pass_if = 147,",
          "203:  pass_then = 148,",
          "204:  pass_all = 255",
          "210:  TranslationTableOffset next;",
          "211:  widechar lookFor;",
          "212:  widechar found;",
          "216:  TranslationTableOffset next;",
          "217:  TranslationTableOffset definitionRule;",
          "218:  TranslationTableOffset otherRules;",
          "219:  TranslationTableCharacterAttributes attributes;",
          "220:  widechar realchar;",
          "221:  widechar uppercase;",
          "222:  widechar lowercase;",
          "226:  CTO_IncludeFile,",
          "228:  CTO_Undefined,",
          "230:  CTO_CapsLetter,",
          "231:  CTO_BegCapsWord,",
          "232:  CTO_EndCapsWord,",
          "233:  CTO_BegCaps,",
          "234:  CTO_EndCaps,",
          "235:  CTO_BegCapsPhrase,",
          "236:  CTO_EndCapsPhrase,",
          "237:  CTO_LenCapsPhrase,",
          "239:  CTO_LetterSign,",
          "240:  CTO_NoLetsignBefore,",
          "241:  CTO_NoLetsign,",
          "242:  CTO_NoLetsignAfter,",
          "243:  CTO_NumberSign,",
          "244:  CTO_NumericModeChars,",
          "245:  CTO_NumericNoContractChars,",
          "246:  CTO_SeqDelimiter,",
          "247:  CTO_SeqBeforeChars,",
          "248:  CTO_SeqAfterChars,",
          "249:  CTO_SeqAfterPattern,",
          "250:  CTO_SeqAfterExpression,",
          "251:  CTO_EmphClass,",
          "254:  CTO_EmphLetter,",
          "255:  CTO_BegEmphWord,",
          "256:  CTO_EndEmphWord,",
          "257:  CTO_BegEmph,",
          "258:  CTO_EndEmph,",
          "259:  CTO_BegEmphPhrase,",
          "260:  CTO_EndEmphPhrase,",
          "261:  CTO_LenEmphPhrase,",
          "264:  CTO_CapsModeChars,",
          "266:  CTO_BegComp,",
          "267:  CTO_CompBegEmph1,",
          "268:  CTO_CompEndEmph1,",
          "269:  CTO_CompBegEmph2,",
          "270:  CTO_CompEndEmph2,",
          "271:  CTO_CompBegEmph3,",
          "272:  CTO_CompEndEmph3,",
          "273:  CTO_CompCapSign,",
          "274:  CTO_CompBegCaps,",
          "275:  CTO_CompEndCaps,",
          "276:  CTO_EndComp,",
          "277:  CTO_NoContractSign,",
          "278:  CTO_MultInd,",
          "279:  CTO_CompDots,",
          "280:  CTO_Comp6,",
          "284:  CTO_NoBack,",
          "285:  CTO_NoFor,",
          "286:  CTO_EmpMatchBefore,",
          "287:  CTO_EmpMatchAfter,",
          "288:  CTO_SwapCc,",
          "289:  CTO_SwapCd,",
          "290:  CTO_SwapDd,",
          "291:  CTO_Space,",
          "292:  CTO_Digit,",
          "293:  CTO_Punctuation,",
          "294:  CTO_Math,",
          "295:  CTO_Sign,",
          "296:  CTO_Letter,",
          "297:  CTO_UpperCase,",
          "298:  CTO_LowerCase,",
          "299:  CTO_Grouping,",
          "300:  CTO_UpLow,",
          "301:  CTO_LitDigit,",
          "302:  CTO_Display,",
          "303:  CTO_Replace,",
          "304:  CTO_Context,",
          "305:  CTO_Correct,",
          "306:  CTO_Pass2,",
          "307:  CTO_Pass3,",
          "308:  CTO_Pass4,",
          "309:  CTO_Repeated,",
          "310:  CTO_RepWord,",
          "311:  CTO_CapsNoCont,",
          "312:  CTO_Always,",
          "313:  CTO_ExactDots,",
          "314:  CTO_NoCross,",
          "315:  CTO_Syllable,",
          "316:  CTO_NoCont,",
          "317:  CTO_CompBrl,",
          "318:  CTO_Literal,",
          "319:  CTO_LargeSign,",
          "320:  CTO_WholeWord,",
          "321:  CTO_PartWord,",
          "322:  CTO_JoinNum,",
          "323:  CTO_JoinableWord,",
          "324:  CTO_LowWord,",
          "325:  CTO_Contraction,",
          "338:  CTO_DecPoint,",
          "339:  CTO_Hyphen,",
          "342:  CTO_NoBreak,",
          "343:  CTO_Match,",
          "344:  CTO_BackMatch,",
          "345:  CTO_Attribute,",
          "346:  CTO_None,",
          "349:  CTO_LetterRule,",
          "350:  CTO_NumberRule,",
          "351:  CTO_NoContractRule,",
          "356:  CTO_CapsLetterRule,",
          "357:  CTO_BegCapsWordRule,",
          "358:  CTO_EndCapsWordRule,",
          "359:  CTO_BegCapsRule,",
          "360:  CTO_EndCapsRule,",
          "361:  CTO_BegCapsPhraseRule,",
          "362:  CTO_EndCapsPhraseBeforeRule,",
          "363:  CTO_EndCapsPhraseAfterRule,",
          "364:  CTO_Emph1LetterRule,",
          "365:  CTO_BegEmph1WordRule,",
          "366:  CTO_EndEmph1WordRule,",
          "367:  CTO_BegEmph1Rule,",
          "368:  CTO_EndEmph1Rule,",
          "369:  CTO_BegEmph1PhraseRule,",
          "370:  CTO_EndEmph1PhraseBeforeRule,",
          "371:  CTO_EndEmph1PhraseAfterRule,",
          "372:  CTO_Emph2LetterRule,",
          "373:  CTO_BegEmph2WordRule,",
          "374:  CTO_EndEmph2WordRule,",
          "375:  CTO_BegEmph2Rule,",
          "376:  CTO_EndEmph2Rule,",
          "377:  CTO_BegEmph2PhraseRule,",
          "378:  CTO_EndEmph2PhraseBeforeRule,",
          "379:  CTO_EndEmph2PhraseAfterRule,",
          "380:  CTO_Emph3LetterRule,",
          "381:  CTO_BegEmph3WordRule,",
          "382:  CTO_EndEmph3WordRule,",
          "383:  CTO_BegEmph3Rule,",
          "384:  CTO_EndEmph3Rule,",
          "385:  CTO_BegEmph3PhraseRule,",
          "386:  CTO_EndEmph3PhraseBeforeRule,",
          "387:  CTO_EndEmph3PhraseAfterRule,",
          "388:  CTO_Emph4LetterRule,",
          "389:  CTO_BegEmph4WordRule,",
          "390:  CTO_EndEmph4WordRule,",
          "391:  CTO_BegEmph4Rule,",
          "392:  CTO_EndEmph4Rule,",
          "393:  CTO_BegEmph4PhraseRule,",
          "394:  CTO_EndEmph4PhraseBeforeRule,",
          "395:  CTO_EndEmph4PhraseAfterRule,",
          "396:  CTO_Emph5LetterRule,",
          "397:  CTO_BegEmph5WordRule,",
          "398:  CTO_EndEmph5WordRule,",
          "399:  CTO_BegEmph5Rule,",
          "400:  CTO_EndEmph5Rule,",
          "401:  CTO_BegEmph5PhraseRule,",
          "402:  CTO_EndEmph5PhraseBeforeRule,",
          "403:  CTO_EndEmph5PhraseAfterRule,",
          "404:  CTO_Emph6LetterRule,",
          "405:  CTO_BegEmph6WordRule,",
          "406:  CTO_EndEmph6WordRule,",
          "407:  CTO_BegEmph6Rule,",
          "408:  CTO_EndEmph6Rule,",
          "409:  CTO_BegEmph6PhraseRule,",
          "410:  CTO_EndEmph6PhraseBeforeRule,",
          "411:  CTO_EndEmph6PhraseAfterRule,",
          "412:  CTO_Emph7LetterRule,",
          "413:  CTO_BegEmph7WordRule,",
          "414:  CTO_EndEmph7WordRule,",
          "415:  CTO_BegEmph7Rule,",
          "416:  CTO_EndEmph7Rule,",
          "417:  CTO_BegEmph7PhraseRule,",
          "418:  CTO_EndEmph7PhraseBeforeRule,",
          "419:  CTO_EndEmph7PhraseAfterRule,",
          "420:  CTO_Emph8LetterRule,",
          "421:  CTO_BegEmph8WordRule,",
          "422:  CTO_EndEmph8WordRule,",
          "423:  CTO_BegEmph8Rule,",
          "424:  CTO_EndEmph8Rule,",
          "425:  CTO_BegEmph8PhraseRule,",
          "426:  CTO_EndEmph8PhraseBeforeRule,",
          "427:  CTO_EndEmph8PhraseAfterRule,",
          "428:  CTO_Emph9LetterRule,",
          "429:  CTO_BegEmph9WordRule,",
          "430:  CTO_EndEmph9WordRule,",
          "431:  CTO_BegEmph9Rule,",
          "432:  CTO_EndEmph9Rule,",
          "433:  CTO_BegEmph9PhraseRule,",
          "434:  CTO_EndEmph9PhraseBeforeRule,",
          "435:  CTO_EndEmph9PhraseAfterRule,",
          "436:  CTO_Emph10LetterRule,",
          "437:  CTO_BegEmph10WordRule,",
          "438:  CTO_EndEmph10WordRule,",
          "439:  CTO_BegEmph10Rule,",
          "440:  CTO_EndEmph10Rule,",
          "441:  CTO_BegEmph10PhraseRule,",
          "442:  CTO_EndEmph10PhraseBeforeRule,",
          "443:  CTO_EndEmph10PhraseAfterRule,",
          "446:  CTO_BegCompRule,",
          "447:  CTO_CompBegEmph1Rule,",
          "448:  CTO_CompEndEmph1Rule,",
          "449:  CTO_CompBegEmph2Rule,",
          "450:  CTO_CompEndEmrh2Rule,",
          "451:  CTO_CompBegEmph3Rule,",
          "452:  CTO_CompEndEmph3Rule,",
          "453:  CTO_CompCapSignRule,",
          "454:  CTO_CompBegCapsRule,",
          "455:  CTO_CompEndCapsRule,",
          "456:  CTO_EndCompRule,",
          "457:  CTO_CapsNoContRule,",
          "458:  CTO_All",
          "475:  widechar ch;",
          "476:  widechar newState;",
          "480:  HyphenationTrans *pointer;",
          "481:  TranslationTableOffset offset;",
          "486:  PointOff trans;",
          "487:  TranslationTableOffset hyphenPattern;",
          "488:  widechar fallbackState;",
          "489:  widechar numTrans;",
          "496:  int capsNoCont;",
          "497:  int numPasses;",
          "498:  int corrections;",
          "499:  int syllables;",
          "500:  int usesSequences;",
          "501:  int usesNumericMode;",
          "502:  TranslationTableOffset tableSize;",
          "503:  TranslationTableOffset bytesUsed;",
          "504:  TranslationTableOffset undefined;",
          "505:  TranslationTableOffset letterSign;",
          "506:  TranslationTableOffset numberSign;",
          "507:  TranslationTableOffset noContractSign;",
          "508:  widechar seqPatterns[SEQPATTERNSIZE];",
          "509:  char *emphClasses[MAX_EMPH_CLASSES + 1];",
          "510:  int seqPatternsCount;",
          "511:  widechar seqAfterExpression[SEQPATTERNSIZE];",
          "512:  int seqAfterExpressionLength;",
          "515:  TranslationTableOffset emphRules[MAX_EMPH_CLASSES + 1][9];",
          "517:  TranslationTableOffset begComp;",
          "518:  TranslationTableOffset compBegEmph1;",
          "519:  TranslationTableOffset compEndEmph1;",
          "520:  TranslationTableOffset compBegEmph2;",
          "521:  TranslationTableOffset compEndEmph2;",
          "522:  TranslationTableOffset compBegEmph3;",
          "523:  TranslationTableOffset compEndEmph3;",
          "524:  TranslationTableOffset compCapSign;",
          "525:  TranslationTableOffset compBegCaps;",
          "526:  TranslationTableOffset compEndCaps;",
          "527:  TranslationTableOffset endComp;",
          "528:  TranslationTableOffset hyphenStatesArray;",
          "529:  widechar noLetsignBefore[LETSIGNSIZE];",
          "530:  int noLetsignBeforeCount;",
          "531:  widechar noLetsign[LETSIGNSIZE];",
          "532:  int noLetsignCount;",
          "533:  widechar noLetsignAfter[LETSIGNSIZE];",
          "534:  int noLetsignAfterCount;",
          "537:  TranslationTableOffset charToDots[HASHNUM];",
          "538:  TranslationTableOffset dotsToChar[HASHNUM];",
          "539:  TranslationTableOffset compdotsPattern[256];",
          "540:  TranslationTableOffset swapDefinitions[NUMSWAPS];",
          "541:  TranslationTableOffset forPassRules[MAXPASS + 1];",
          "542:  TranslationTableOffset backPassRules[MAXPASS + 1];",
          "549:  alloc_typebuf,",
          "550:  alloc_wordBuffer,",
          "551:  alloc_emphasisBuffer,",
          "552:  alloc_transNoteBuffer,",
          "553:  alloc_destSpacing,",
          "554:  alloc_passbuf1,",
          "555:  alloc_passbuf2,",
          "556:  alloc_srcMapping,",
          "557:  alloc_prevSrcMapping",
          "561:  capsRule = 0,",
          "562:  emph1Rule = 1,",
          "563:  emph2Rule = 2,",
          "564:  emph3Rule = 3,",
          "565:  emph4Rule = 4,",
          "566:  emph5Rule = 5,",
          "567:  emph6Rule = 6,",
          "568:  emph7Rule = 7,",
          "569:  emph8Rule = 8,",
          "570:  emph9Rule = 9,",
          "571:  emph10Rule = 10",
          "575:  begPhraseOffset = 0,",
          "576:  endPhraseBeforeOffset = 1,",
          "577:  endPhraseAfterOffset = 2,",
          "578:  begOffset = 3,",
          "579:  endOffset = 4,",
          "580:  letterOffset = 5,",
          "581:  begWordOffset = 6,",
          "582:  endWordOffset = 7,",
          "583:  lenPhraseOffset = 8",
          "589:  const char *fileName;",
          "590:  FILE *in;",
          "591:  int lineNumber;",
          "592:  EncodingType encoding;",
          "593:  int status;",
          "594:  int linelen;",
          "595:  int linepos;",
          "596:  int checkencoding[2];",
          "597:  widechar line[MAXSTRING];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "622: char *EXPORT_CALL _lou_getTablePath(void);",
          "627: char **EXPORT_CALL _lou_resolveTable(const char *tableList, const char *base);",
          "632: char **EXPORT_CALL _lou_defaultTableResolver (const char *tableList, const char *base);",
          "634: char *EXPORT_CALL _lou_getLastTableList(void);",
          "640: widechar EXPORT_CALL _lou_getDotsForChar(widechar c);",
          "646: widechar EXPORT_CALL _lou_getCharFromDots(widechar d);",
          "",
          "[Added Lines]",
          "607: char *EXPORT_CALL",
          "608: _lou_getTablePath(void);",
          "613: char **EXPORT_CALL",
          "614: _lou_resolveTable(const char *tableList, const char *base);",
          "619: char **EXPORT_CALL",
          "620: _lou_defaultTableResolver(const char *tableList, const char *base);",
          "622: char *EXPORT_CALL",
          "623: _lou_getLastTableList(void);",
          "629: widechar EXPORT_CALL",
          "630: _lou_getDotsForChar(widechar c);",
          "636: widechar EXPORT_CALL",
          "637: _lou_getCharFromDots(widechar d);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "655: void *EXPORT_CALL _lou_allocMem(AllocBuf buffer, int srcmax, int destmax);",
          "660: int EXPORT_CALL _lou_stringHash(const widechar *c);",
          "665: int EXPORT_CALL _lou_charHash(widechar c);",
          "671: char *EXPORT_CALL _lou_showString(widechar const *chars, int length);",
          "677: char *EXPORT_CALL _lou_showDots(widechar const *dots, int length);",
          "684: char *EXPORT_CALL _lou_showAttributes(TranslationTableCharacterAttributes a);",
          "691: TranslationTableOpcode EXPORT_CALL _lou_findOpcodeNumber(const char *tofind);",
          "698: const char *EXPORT_CALL _lou_findOpcodeName(TranslationTableOpcode opcode);",
          "",
          "[Added Lines]",
          "646: void *EXPORT_CALL",
          "647: _lou_allocMem(AllocBuf buffer, int srcmax, int destmax);",
          "652: int EXPORT_CALL",
          "653: _lou_stringHash(const widechar *c);",
          "658: int EXPORT_CALL",
          "659: _lou_charHash(widechar c);",
          "665: char *EXPORT_CALL",
          "666: _lou_showString(widechar const *chars, int length);",
          "672: char *EXPORT_CALL",
          "673: _lou_showDots(widechar const *dots, int length);",
          "680: char *EXPORT_CALL",
          "681: _lou_showAttributes(TranslationTableCharacterAttributes a);",
          "688: TranslationTableOpcode EXPORT_CALL",
          "689: _lou_findOpcodeNumber(const char *tofind);",
          "696: const char *EXPORT_CALL",
          "697: _lou_findOpcodeName(TranslationTableOpcode opcode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "710: int EXPORT_CALL _lou_extParseChars(const char *inString, widechar *outString);",
          "",
          "[Added Lines]",
          "709: int EXPORT_CALL",
          "710: _lou_extParseChars(const char *inString, widechar *outString);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "757: #ifdef DEBUG",
          "760: #endif",
          "775: extern int translation_direction;",
          "",
          "[Removed Lines]",
          "721: int EXPORT_CALL _lou_extParseDots(const char *inString, widechar *outString);",
          "723: int EXPORT_CALL _lou_translateWithTracing(const char *tableList, const widechar *inbuf,",
          "724:                          int *inlen, widechar *outbuf, int *outlen,",
          "725:                          formtype *typeform, char *spacing, int *outputPos,",
          "726:                          int *inputPos, int *cursorPos, int mode,",
          "727:                          const TranslationTableRule **rules, int *rulesLen);",
          "729: int EXPORT_CALL _lou_backTranslateWithTracing(const char *tableList, const widechar *inbuf,",
          "730:                              int *inlen, widechar *outbuf, int *outlen,",
          "731:                              formtype *typeform, char *spacing, int *outputPos,",
          "732:                              int *inputPos, int *cursorPos, int mode,",
          "733:                              const TranslationTableRule **rules, int *rulesLen);",
          "735: void EXPORT_CALL _lou_resetPassVariables (void);",
          "737: int EXPORT_CALL _lou_handlePassVariableTest (const widechar *instructions,",
          "738:         int *IC, int *itsTrue);",
          "740: int EXPORT_CALL _lou_handlePassVariableAction (const widechar *instructions,",
          "741:           int *IC);",
          "743: int EXPORT_CALL _lou_pattern_compile(const widechar *input, const int input_max,",
          "744:     widechar *expr_data, const int expr_max, const TranslationTableHeader *t);",
          "746: void EXPORT_CALL _lou_pattern_reverse(widechar *expr_data);",
          "748: int EXPORT_CALL _lou_pattern_check(const widechar *input, const int input_start, const int",
          "749:     input_minmax, const int input_dir, const widechar *expr_data,",
          "750:     const TranslationTableHeader *t);",
          "755: int EXPORT_CALL _lou_getALine(FileInfo *info);",
          "759: void EXPORT_CALL _lou_debugHook(void);",
          "765: void EXPORT_CALL _lou_outOfMemory(void);",
          "770: void EXPORT_CALL _lou_logWidecharBuf(logLevels level, const char *msg, const widechar *wbuf,",
          "771:                     int wlen);",
          "773: void EXPORT_CALL _lou_logMessage(logLevels level, const char *format, ...);",
          "",
          "[Added Lines]",
          "721: int EXPORT_CALL",
          "722: _lou_extParseDots(const char *inString, widechar *outString);",
          "724: int EXPORT_CALL",
          "725: _lou_translateWithTracing(const char *tableList, const widechar *inbuf, int *inlen,",
          "726:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "727:   int *inputPos, int *cursorPos, int mode, const TranslationTableRule **rules,",
          "728:   int *rulesLen);",
          "730: int EXPORT_CALL",
          "731: _lou_backTranslateWithTracing(const char *tableList, const widechar *inbuf, int *inlen,",
          "732:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "733:   int *inputPos, int *cursorPos, int mode, const TranslationTableRule **rules,",
          "734:   int *rulesLen);",
          "736: void EXPORT_CALL",
          "737: _lou_resetPassVariables(void);",
          "739: int EXPORT_CALL",
          "740: _lou_handlePassVariableTest(const widechar *instructions, int *IC, int *itsTrue);",
          "742: int EXPORT_CALL",
          "743: _lou_handlePassVariableAction(const widechar *instructions, int *IC);",
          "745: int EXPORT_CALL",
          "746: _lou_pattern_compile(const widechar *input, const int input_max, widechar *expr_data,",
          "747:   const int expr_max, const TranslationTableHeader *t);",
          "749: void EXPORT_CALL",
          "750: _lou_pattern_reverse(widechar *expr_data);",
          "752: int EXPORT_CALL",
          "753: _lou_pattern_check(const widechar *input, const int input_start, const int input_minmax,",
          "754:   const int input_dir, const widechar *expr_data, const TranslationTableHeader *t);",
          "759: int EXPORT_CALL",
          "760: _lou_getALine(FileInfo *info);",
          "764: void EXPORT_CALL",
          "765: _lou_debugHook(void);",
          "771: void EXPORT_CALL",
          "772: _lou_outOfMemory(void);",
          "777: void EXPORT_CALL",
          "778: _lou_logWidecharBuf(logLevels level, const char *msg, const widechar *wbuf, int wlen);",
          "780: void EXPORT_CALL",
          "781: _lou_logMessage(logLevels level, const char *format, ...);",
          "",
          "---------------"
        ],
        "liblouis/liblouis.h.in||liblouis/liblouis.h.in": [
          "File: liblouis/liblouis.h.in -> liblouis/liblouis.h.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: typedef unsigned short formtype;",
          "44: #ifdef _MSC_VER",
          "50: #else",
          "52: #endif",
          "54: #ifdef __EMSCRIPTEN__",
          "",
          "[Removed Lines]",
          "45:   #ifdef _EXPORTING",
          "46:     #define LIBLOUIS_API __declspec(dllexport)",
          "47:   #else",
          "48:     #define LIBLOUIS_API __declspec(dllimport)",
          "49:   #endif",
          "51:   #define LIBLOUIS_API",
          "",
          "[Added Lines]",
          "45: #ifdef _EXPORTING",
          "46: #define LIBLOUIS_API __declspec(dllexport)",
          "48: #define LIBLOUIS_API __declspec(dllimport)",
          "49: #endif",
          "50: #else",
          "51: #define LIBLOUIS_API",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57: #elif defined(_WIN32)",
          "58: #define EXPORT_CALL __stdcall",
          "59: LIBLOUIS_API",
          "61: #else",
          "62: #define EXPORT_CALL",
          "63: #endif",
          "65: typedef enum {",
          "83: } typeforms;",
          "86: #define underline emph_2",
          "89: #define comp_emph_1 emph_1",
          "90: #define comp_emph_2 emph_2",
          "",
          "[Removed Lines]",
          "60: char *EXPORT_CALL lou_getProgramPath(void);",
          "66:   plain_text = 0x0000,",
          "67:   emph_1 = 0x0001,",
          "68:   emph_2 = 0x0002,",
          "69:   emph_3 = 0x0004,",
          "70:   emph_4 = 0x0008,",
          "71:   emph_5 = 0x0010,",
          "72:   emph_6 = 0x0020,",
          "73:   emph_7 = 0x0040,",
          "74:   emph_8 = 0x0080,",
          "75:   emph_9 = 0x0100,",
          "76:   emph_10 = 0x0200,",
          "77:   computer_braille = 0x0400,",
          "78:   no_translate = 0x0800,",
          "79:   no_contract = 0x1000,",
          "85: #define italic    emph_1",
          "87: #define bold      emph_3",
          "",
          "[Added Lines]",
          "60: char *EXPORT_CALL",
          "61: lou_getProgramPath(void);",
          "67:  plain_text = 0x0000,",
          "68:  emph_1 = 0x0001,",
          "69:  emph_2 = 0x0002,",
          "70:  emph_3 = 0x0004,",
          "71:  emph_4 = 0x0008,",
          "72:  emph_5 = 0x0010,",
          "73:  emph_6 = 0x0020,",
          "74:  emph_7 = 0x0040,",
          "75:  emph_8 = 0x0080,",
          "76:  emph_9 = 0x0100,",
          "77:  emph_10 = 0x0200,",
          "78:  computer_braille = 0x0400,",
          "79:  no_translate = 0x0800,",
          "80:  no_contract = 0x1000,",
          "86: #define italic emph_1",
          "88: #define bold emph_3",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95: #define EMPH_NAME_UNDERLINE \"underline\"",
          "97: typedef enum {",
          "107: } translationModes;",
          "109: LIBLOUIS_API",
          "115: LIBLOUIS_API",
          "118: LIBLOUIS_API",
          "125: LIBLOUIS_API",
          "131: LIBLOUIS_API",
          "140: LIBLOUIS_API",
          "143: LIBLOUIS_API",
          "146: LIBLOUIS_API",
          "149: LIBLOUIS_API",
          "156: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "98:   noContractions = 1,",
          "99:   compbrlAtCursor = 2,",
          "100:   dotsIO = 4,",
          "101:   comp8Dots = 8,",
          "102:   pass1Only = 16,",
          "103:   compbrlLeftCursor = 32,",
          "104:   ucBrl = 64,",
          "105:   noUndefinedDots = 128,",
          "106:   partialTrans = 256",
          "110: char *EXPORT_CALL lou_version(void);",
          "116: int EXPORT_CALL lou_charSize(void);",
          "119: int EXPORT_CALL lou_translateString(const char *tableList,",
          "120:                                     const widechar *inbuf, int *inlen,",
          "121:                                     widechar *outbuf, int *outlen,",
          "122:                                     formtype *typeform, char *spacing,",
          "123:                                     int mode);",
          "126: int EXPORT_CALL lou_translate(const char *tableList, const widechar *inbuf,",
          "127:                               int *inlen, widechar *outbuf, int *outlen,",
          "128:                               formtype *typeform, char *spacing, int *outputPos,",
          "129:                               int *inputPos, int *cursorPos, int mode);",
          "132: int EXPORT_CALL lou_translatePrehyphenated(const char *tableList,",
          "133:                                            const widechar *inbuf, int *inlen,",
          "134:                                            widechar *outbuf, int *outlen,",
          "135:                                            formtype *typeform, char *spacing,",
          "136:                                            int *outputPos, int *inputPos,",
          "137:                                            int *cursorPos, char *inputHyphens,",
          "138:                                            char *outputHyphens, int mode);",
          "141: int EXPORT_CALL lou_hyphenate(const char *tableList, const widechar *inbuf,",
          "142:                               int inlen, char *hyphens, int mode);",
          "144: int EXPORT_CALL lou_dotsToChar(const char *tableList, widechar *inbuf,",
          "145:                                widechar *outbuf, int length, int mode);",
          "147: int EXPORT_CALL lou_charToDots(const char *tableList, const widechar *inbuf,",
          "148:                                widechar *outbuf, int length, int mode);",
          "150: int EXPORT_CALL lou_backTranslateString(const char *tableList,",
          "151:                                         const widechar *inbuf, int *inlen,",
          "152:                                         widechar *outbuf, int *outlen,",
          "153:                                         formtype *typeform, char *spacing,",
          "154:                                         int mode);",
          "157: int EXPORT_CALL lou_backTranslate(const char *tableList, const widechar *inbuf,",
          "158:                                   int *inlen, widechar *outbuf, int *outlen,",
          "159:                                   formtype *typeform, char *spacing,",
          "160:                                   int *outputPos, int *inputPos, int *cursorPos,",
          "161:                                   int mode);",
          "",
          "[Added Lines]",
          "99:  noContractions = 1,",
          "100:  compbrlAtCursor = 2,",
          "101:  dotsIO = 4,",
          "102:  comp8Dots = 8,",
          "103:  pass1Only = 16,",
          "104:  compbrlLeftCursor = 32,",
          "105:  ucBrl = 64,",
          "106:  noUndefinedDots = 128,",
          "107:  partialTrans = 256",
          "111: char *EXPORT_CALL",
          "112: lou_version(void);",
          "118: int EXPORT_CALL",
          "119: lou_charSize(void);",
          "122: int EXPORT_CALL",
          "123: lou_translateString(const char *tableList, const widechar *inbuf, int *inlen,",
          "124:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode);",
          "127: int EXPORT_CALL",
          "128: lou_translate(const char *tableList, const widechar *inbuf, int *inlen, widechar *outbuf,",
          "129:   int *outlen, formtype *typeform, char *spacing, int *outputPos, int *inputPos,",
          "130:   int *cursorPos, int mode);",
          "133: int EXPORT_CALL",
          "134: lou_translatePrehyphenated(const char *tableList, const widechar *inbuf, int *inlen,",
          "135:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "136:   int *inputPos, int *cursorPos, char *inputHyphens, char *outputHyphens, int mode);",
          "139: int EXPORT_CALL",
          "140: lou_hyphenate(",
          "141:   const char *tableList, const widechar *inbuf, int inlen, char *hyphens, int mode);",
          "143: int EXPORT_CALL",
          "144: lou_dotsToChar(",
          "145:   const char *tableList, widechar *inbuf, widechar *outbuf, int length, int mode);",
          "147: int EXPORT_CALL",
          "148: lou_charToDots(const char *tableList, const widechar *inbuf, widechar *outbuf, int length,",
          "149:   int mode);",
          "151: int EXPORT_CALL",
          "152: lou_backTranslateString(const char *tableList, const widechar *inbuf, int *inlen,",
          "153:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode);",
          "156: int EXPORT_CALL",
          "157: lou_backTranslate(const char *tableList, const widechar *inbuf, int *inlen,",
          "158:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "159:   int *inputPos, int *cursorPos, int mode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "169: void EXPORT_CALL lou_logPrint(const char *format, ...);",
          "",
          "[Added Lines]",
          "167: void EXPORT_CALL",
          "168: lou_logPrint(const char *format, ...);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "179: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "180: void EXPORT_CALL lou_logFile(const char *filename);",
          "",
          "[Added Lines]",
          "179: void EXPORT_CALL",
          "180: lou_logFile(const char *filename);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "188: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "189: int EXPORT_CALL lou_readCharFromFile(const char *fileName, int *mode);",
          "",
          "[Added Lines]",
          "189: int EXPORT_CALL",
          "190: lou_readCharFromFile(const char *fileName, int *mode);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "197: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "198: void EXPORT_CALL lou_logEnd(void);",
          "",
          "[Added Lines]",
          "199: void EXPORT_CALL",
          "200: lou_logEnd(void);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "209: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "210: void *EXPORT_CALL lou_getTable(const char *tableList);",
          "",
          "[Added Lines]",
          "212: void *EXPORT_CALL",
          "213: lou_getTable(const char *tableList);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "218: LIBLOUIS_API",
          "223: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "219: int EXPORT_CALL lou_checkTable(const char *tableList);",
          "224: void EXPORT_CALL lou_registerTableResolver(",
          "225:     char **(EXPORT_CALL *resolver)(const char *table, const char *base));",
          "",
          "[Added Lines]",
          "222: int EXPORT_CALL",
          "223: lou_checkTable(const char *tableList);",
          "228: void EXPORT_CALL",
          "229: lou_registerTableResolver(",
          "230:   char **(EXPORT_CALL *resolver)(const char *table, const char *base));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "240: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "241: int EXPORT_CALL lou_compileString(const char *tableList, const char *inString);",
          "",
          "[Added Lines]",
          "246: int EXPORT_CALL",
          "247: lou_compileString(const char *tableList, const char *inString);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "249: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "250: formtype EXPORT_CALL lou_getTypeformForEmphClass(const char *tableList, const char *emphClass);",
          "",
          "[Added Lines]",
          "256: formtype EXPORT_CALL",
          "257: lou_getTypeformForEmphClass(const char *tableList, const char *emphClass);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "258: LIBLOUIS_API",
          "265: LIBLOUIS_API",
          "270: LIBLOUIS_API",
          "273: typedef enum {",
          "281: } logLevels;",
          "283: typedef void (*logcallback)(logLevels level, const char *message);",
          "",
          "[Removed Lines]",
          "259: char const **EXPORT_CALL lou_getEmphClasses(const char *tableList);",
          "266: char *EXPORT_CALL lou_setDataPath(const char *path);",
          "271: char *EXPORT_CALL lou_getDataPath(void);",
          "274:   LOG_ALL = 0,",
          "275:   LOG_DEBUG = 10000,",
          "276:   LOG_INFO = 20000,",
          "277:   LOG_WARN = 30000,",
          "278:   LOG_ERROR = 40000,",
          "279:   LOG_FATAL = 50000,",
          "280:   LOG_OFF = 60000",
          "",
          "[Added Lines]",
          "266: char const **EXPORT_CALL",
          "267: lou_getEmphClasses(const char *tableList);",
          "274: char *EXPORT_CALL",
          "275: lou_setDataPath(const char *path);",
          "280: char *EXPORT_CALL",
          "281: lou_getDataPath(void);",
          "284:  LOG_ALL = 0,",
          "285:  LOG_DEBUG = 10000,",
          "286:  LOG_INFO = 20000,",
          "287:  LOG_WARN = 30000,",
          "288:  LOG_ERROR = 40000,",
          "289:  LOG_FATAL = 50000,",
          "290:  LOG_OFF = 60000",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "289: LIBLOUIS_API",
          "295: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "290: void EXPORT_CALL lou_registerLogCallback(logcallback callback);",
          "296: void EXPORT_CALL lou_setLogLevel(logLevels level);",
          "",
          "[Added Lines]",
          "300: void EXPORT_CALL",
          "301: lou_registerLogCallback(logcallback callback);",
          "307: void EXPORT_CALL",
          "308: lou_setLogLevel(logLevels level);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "311: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "312: void EXPORT_CALL lou_indexTables(const char **tables);",
          "",
          "[Added Lines]",
          "324: void EXPORT_CALL",
          "325: lou_indexTables(const char **tables);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "324: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "325: char *EXPORT_CALL lou_findTable(const char *query);",
          "",
          "[Added Lines]",
          "338: char *EXPORT_CALL",
          "339: lou_findTable(const char *query);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "334: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "335: const char * EXPORT_CALL lou_getTableInfo(const char *table, const char *key);",
          "",
          "[Added Lines]",
          "349: const char *EXPORT_CALL",
          "350: lou_getTableInfo(const char *table, const char *key);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "347: LIBLOUIS_API",
          "",
          "[Removed Lines]",
          "348: const char **EXPORT_CALL lou_listTables();",
          "",
          "[Added Lines]",
          "363: const char **EXPORT_CALL",
          "364: lou_listTables();",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "358: LIBLOUIS_API",
          "361: #ifdef __cplusplus",
          "362: }",
          "",
          "[Removed Lines]",
          "359: void EXPORT_CALL lou_free(void);",
          "",
          "[Added Lines]",
          "375: void EXPORT_CALL",
          "376: lou_free(void);",
          "",
          "---------------"
        ],
        "liblouis/logging.c||liblouis/logging.c": [
          "File: liblouis/logging.c -> liblouis/logging.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include \"internal.h\"",
          "62:  p++;",
          "64:  p++;",
          "69:   else",
          "71:   p++;",
          "76: }",
          "81: }",
          "83: static logcallback logCallbackFunction = defaultLogCallback;",
          "90: }",
          "92: static logLevels logLevel = LOG_INFO;",
          "96: }",
          "106: #ifdef _WIN32",
          "108: #endif",
          "124: }",
          "127: static FILE *logFile = NULL;",
          "128: static char initialLogFileName[256] = \"\";",
          "130: void EXPORT_CALL",
          "135:   fclose(logFile);",
          "136:   logFile = NULL;",
          "137:  }",
          "150: }",
          "152: void EXPORT_CALL",
          "155: #ifndef __SYMBIAN32__",
          "168: #endif",
          "169: }",
          "172: void EXPORT_CALL",
          "178: }",
          "",
          "[Removed Lines]",
          "35: void EXPORT_CALL _lou_logWidecharBuf(logLevels level, const char *msg, const widechar *wbuf, int wlen)",
          "36: {",
          "45:   int logBufSize = (wlen * ((sizeof(widechar) * 3) + 3)) + 3 + (int)strlen(msg);",
          "46:   char *logMsg = malloc(logBufSize);",
          "47:   char *p = logMsg;",
          "48:   char *formatString;",
          "49:   int i = 0;",
          "50:   if (sizeof(widechar) == 2)",
          "51:     formatString = \"0x%04X \";",
          "52:   else",
          "53:     formatString = \"0x%08X \";",
          "54:   for (i = 0; i < (int) strlen(msg); i++)",
          "55:     logMsg[i] = msg[i];",
          "56:   p += strlen(msg);",
          "57:   for (i = 0; i < wlen; i++)",
          "58:     {",
          "59:       p += sprintf(p, formatString, wbuf[i]);",
          "60:     }",
          "65:  for(i = 0; i < wlen; i++)",
          "66:  {",
          "67:   if(wbuf[i] & 0xff00)",
          "72:  }",
          "74:   _lou_logMessage(level, \"%s\", logMsg);",
          "75:   free(logMsg);",
          "78: static void defaultLogCallback(logLevels level, const char *message)",
          "79: {",
          "80:   lou_logPrint(\"%s\", message); // lou_logPrint takes formatting, protect against % in message",
          "84: void EXPORT_CALL lou_registerLogCallback(logcallback callback)",
          "85: {",
          "86:   if (callback == NULL)",
          "87:     logCallbackFunction = defaultLogCallback;",
          "88:   else",
          "89:     logCallbackFunction = callback;",
          "93: void EXPORT_CALL lou_setLogLevel(logLevels level)",
          "94: {",
          "95:   logLevel = level;",
          "98: void EXPORT_CALL _lou_logMessage(logLevels level, const char *format, ...)",
          "99: {",
          "100:   if (format == NULL)",
          "101:       return;",
          "102:   if (level < logLevel)",
          "103:       return;",
          "104:   if (logCallbackFunction != NULL)",
          "105:     {",
          "107:       double f = 2.3; // Needed to force VC++ runtime floating point support",
          "109:       char *s;",
          "110:       size_t len;",
          "111:       va_list argp;",
          "112:       va_start(argp, format);",
          "113:       len = vsnprintf(0, 0, format, argp);",
          "114:       va_end(argp);",
          "115:       if ((s = malloc(len+1)) != 0)",
          "116:         {",
          "117:           va_start(argp, format);",
          "118:           vsnprintf(s, len+1, format, argp);",
          "119:           va_end(argp);",
          "120:           logCallbackFunction(level, s);",
          "121:           free(s);",
          "122:         }",
          "123:     }",
          "131: lou_logFile (const char *fileName)",
          "132: {",
          "133:  if(logFile)",
          "134:  {",
          "138:   if (fileName == NULL || fileName[0] == 0)",
          "139:     return;",
          "140:   if (initialLogFileName[0] == 0)",
          "141:     strcpy (initialLogFileName, fileName);",
          "142:   logFile = fopen (fileName, \"a\");",
          "143:   if (logFile == NULL && initialLogFileName[0] != 0)",
          "144:     logFile = fopen (initialLogFileName, \"a\");",
          "145:   if (logFile == NULL)",
          "146:     {",
          "147:       fprintf (stderr, \"Cannot open log file %s\\n\", fileName);",
          "148:       logFile = stderr;",
          "149:     }",
          "153: lou_logPrint (const char *format, ...)",
          "154: {",
          "156:   va_list argp;",
          "157:   if (format == NULL)",
          "158:     return;",
          "159:   if (logFile == NULL)",
          "160:     logFile = fopen (initialLogFileName, \"a\");",
          "161:   if (logFile == NULL)",
          "162:     logFile = stderr;",
          "163:   va_start (argp, format);",
          "164:   vfprintf (logFile, format, argp);",
          "165:   fprintf (logFile, \"\\n\");",
          "166:   fflush(logFile);",
          "167:   va_end (argp);",
          "173: lou_logEnd (void)",
          "174: {",
          "175:   if (logFile != NULL && logFile != stderr)",
          "176:     fclose (logFile);",
          "177:   logFile = NULL;",
          "",
          "[Added Lines]",
          "35: void EXPORT_CALL",
          "36: _lou_logWidecharBuf(logLevels level, const char *msg, const widechar *wbuf, int wlen) {",
          "45:  int logBufSize = (wlen * ((sizeof(widechar) * 3) + 3)) + 3 + (int)strlen(msg);",
          "46:  char *logMsg = malloc(logBufSize);",
          "47:  char *p = logMsg;",
          "48:  char *formatString;",
          "49:  int i = 0;",
          "50:  if (sizeof(widechar) == 2)",
          "51:   formatString = \"0x%04X \";",
          "52:  else",
          "53:   formatString = \"0x%08X \";",
          "54:  for (i = 0; i < (int)strlen(msg); i++) logMsg[i] = msg[i];",
          "55:  p += strlen(msg);",
          "56:  for (i = 0; i < wlen; i++) {",
          "57:   p += sprintf(p, formatString, wbuf[i]);",
          "58:  }",
          "63:  for (i = 0; i < wlen; i++) {",
          "64:   if (wbuf[i] & 0xff00)",
          "69:  }",
          "71:  _lou_logMessage(level, \"%s\", logMsg);",
          "72:  free(logMsg);",
          "75: static void",
          "76: defaultLogCallback(logLevels level, const char *message) {",
          "77:  lou_logPrint(\"%s\",",
          "78:    message);  // lou_logPrint takes formatting, protect against % in message",
          "82: void EXPORT_CALL",
          "83: lou_registerLogCallback(logcallback callback) {",
          "84:  if (callback == NULL)",
          "85:   logCallbackFunction = defaultLogCallback;",
          "86:  else",
          "87:   logCallbackFunction = callback;",
          "91: void EXPORT_CALL",
          "92: lou_setLogLevel(logLevels level) {",
          "93:  logLevel = level;",
          "96: void EXPORT_CALL",
          "97: _lou_logMessage(logLevels level, const char *format, ...) {",
          "98:  if (format == NULL) return;",
          "99:  if (level < logLevel) return;",
          "100:  if (logCallbackFunction != NULL) {",
          "102:   double f = 2.3;  // Needed to force VC++ runtime floating point support",
          "104:   char *s;",
          "105:   size_t len;",
          "106:   va_list argp;",
          "107:   va_start(argp, format);",
          "108:   len = vsnprintf(0, 0, format, argp);",
          "109:   va_end(argp);",
          "110:   if ((s = malloc(len + 1)) != 0) {",
          "111:    va_start(argp, format);",
          "112:    vsnprintf(s, len + 1, format, argp);",
          "113:    va_end(argp);",
          "114:    logCallbackFunction(level, s);",
          "115:    free(s);",
          "116:   }",
          "117:  }",
          "124: lou_logFile(const char *fileName) {",
          "125:  if (logFile) {",
          "129:  if (fileName == NULL || fileName[0] == 0) return;",
          "130:  if (initialLogFileName[0] == 0) strcpy(initialLogFileName, fileName);",
          "131:  logFile = fopen(fileName, \"a\");",
          "132:  if (logFile == NULL && initialLogFileName[0] != 0)",
          "133:   logFile = fopen(initialLogFileName, \"a\");",
          "134:  if (logFile == NULL) {",
          "135:   fprintf(stderr, \"Cannot open log file %s\\n\", fileName);",
          "136:   logFile = stderr;",
          "137:  }",
          "141: lou_logPrint(const char *format, ...) {",
          "143:  va_list argp;",
          "144:  if (format == NULL) return;",
          "145:  if (logFile == NULL) logFile = fopen(initialLogFileName, \"a\");",
          "146:  if (logFile == NULL) logFile = stderr;",
          "147:  va_start(argp, format);",
          "148:  vfprintf(logFile, format, argp);",
          "149:  fprintf(logFile, \"\\n\");",
          "150:  fflush(logFile);",
          "151:  va_end(argp);",
          "157: lou_logEnd(void) {",
          "158:  if (logFile != NULL && logFile != stderr) fclose(logFile);",
          "159:  logFile = NULL;",
          "",
          "---------------"
        ],
        "liblouis/lou_backTranslateString.c||liblouis/lou_backTranslateString.c": [
          "File: liblouis/lou_backTranslateString.c -> liblouis/lou_backTranslateString.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"internal.h\"",
          "45: int EXPORT_CALL",
          "52: }",
          "54: int EXPORT_CALL",
          "63: }",
          "65: static int",
          "119:  }",
          "128: }",
          "130: int EXPORT_CALL",
          "223:  else",
          "231: }",
          "233: static TranslationTableCharacter *",
          "266: }",
          "268: static int",
          "281: }",
          "283: static int",
          "293: }",
          "295: static void",
          "303: }",
          "305: static void",
          "314: }",
          "317: static int",
          "337: }",
          "339: static int",
          "380:  }",
          "385: }",
          "386: static int",
          "397: }",
          "399: static int",
          "476: }",
          "481: static int",
          "533: }",
          "535: static void",
          "678:    break;",
          "680:    break;",
          "684:    return;",
          "688:    break;",
          "788:       break;",
          "793:       break;",
          "796:     }",
          "800:   }",
          "803:  }",
          "805: }",
          "807: static int",
          "834: }",
          "836: static int",
          "872:  }",
          "885:  }",
          "888: }",
          "890: static int",
          "939: }",
          "941: static int",
          "970: }",
          "972: static int",
          "991: }",
          "993: static int",
          "1012: }",
          "1014: static int",
          "1027: }",
          "1029: static int",
          "1110:    break;",
          "1134:  }",
          "1136: failure:",
          "1138: }",
          "1140: static int",
          "1316:   }",
          "1347: failure:",
          "1366: static int",
          "1376: }",
          "1378: static int",
          "1398:  }",
          "1414:  }",
          "1426: }",
          "1428: static int",
          "1457:  }",
          "1459:  return curSrc;",
          "1492: }",
          "1494: static int",
          "1576:   }",
          "1589:   }",
          "1613:  }",
          "1619: }",
          "1621: static int",
          "1658:  }",
          "1662: }",
          "1664: static int",
          "1740: }",
          "1742: static void",
          "1755: }",
          "1757: static int",
          "1808:  }",
          "1811: failure:",
          "1819: }",
          "",
          "[Removed Lines]",
          "36: static int backTranslateString (const TranslationTableHeader *table,",
          "37:     int *src, int srcmax, int *dest, int destmax, int mode, int currentPass, const widechar *currentInput, widechar *currentOutput, char *spacebuf, int *srcMapping, int *outputPositions, int *inputPositions, int *cursorPosition, int *cursorStatus, const TranslationTableRule **appliedRules, int *appliedRulesCount, int maxAppliedRules);",
          "38: static int makeCorrections (const TranslationTableHeader *table,",
          "39:        int *src, int srcmax, int *dest, int destmax, int mode, int currentPass, const widechar *currentInput, widechar *currentOutput, int *srcMapping, int *outputPositions, int *inputPositions, int *cursorPosition, int *cursorStatus, const TranslationTableRule **appliedRules, int *appliedRulesCount, int maxAppliedRules);",
          "40: static int translatePass (const TranslationTableHeader *table,",
          "41:      int *src, int srcmax, int *dest, int destmax, int mode, int currentPass, const widechar *currentInput, widechar *currentOutput, int *srcMapping, int *outputPositions, int *inputPositions, int *cursorPosition, int *cursorStatus, const TranslationTableRule **appliedRules, int *appliedRulesCount, int maxAppliedRules);",
          "42: static void passSelectRule (const TranslationTableHeader *table,",
          "43:        int src, int srcmax, int currentPass, const widechar *currentInput, TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule, int *passSrc, const widechar **passInstructions, int *passIC, int *startMatch, int *startReplace, int *endReplace);",
          "46: lou_backTranslateString (const char *tableList, const widechar * inbuf,",
          "47:     int *inlen, widechar * outbuf, int *outlen,",
          "48:     formtype *typeform, char *spacing, int modex)",
          "49: {",
          "50:   return lou_backTranslate (tableList, inbuf, inlen, outbuf, outlen,",
          "51:        typeform, spacing, NULL, NULL, NULL, modex);",
          "55: lou_backTranslate (const char *tableList, const widechar *inbuf,",
          "56:      int *inlen, widechar * outbuf, int *outlen,",
          "57:      formtype *typeform, char *spacing, int *outputPos,",
          "58:      int *inputPos, int *cursorPos, int modex)",
          "59: {",
          "60:   return _lou_backTranslateWithTracing(tableList, inbuf, inlen, outbuf, outlen,",
          "61:       typeform, spacing, outputPos, inputPos,",
          "62:       cursorPos, modex, NULL, NULL);",
          "66: doPasses (widechar * outbuf,",
          "67:    const TranslationTableHeader *table,",
          "68:    int *src, int *srcmax,",
          "69:    int *dest,",
          "70:    int destmax,",
          "71:    int mode,",
          "72:    const widechar *currentInput,",
          "73:    widechar *passbuf1, widechar *passbuf2,",
          "74:    char *spacebuf,",
          "75:    int *srcMapping,",
          "76:    int *outputPositions, int *inputPositions,",
          "77:    int *cursorPosition, int *cursorStatus,",
          "78:    const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "79:    int maxAppliedRules)",
          "80: {",
          "81:   int currentPass;",
          "82:   widechar *currentOutput;",
          "83:   int firstPass = table->numPasses;",
          "84:   int lastPass = 1;",
          "86:   if (table->corrections)",
          "87:     lastPass -= 1;",
          "89:   if (mode & pass1Only)",
          "90:     {",
          "91:       firstPass = 1;",
          "92:       lastPass = 1;",
          "93:     }",
          "95:   currentPass = firstPass;",
          "97:   while (1)",
          "98:     {",
          "99:       currentOutput = (currentPass == lastPass)? outbuf:",
          "100:                       (currentInput == passbuf1)? passbuf2:",
          "101:         passbuf1;",
          "103:       switch (currentPass)",
          "104:         {",
          "105:    case 1:",
          "106:      if (!backTranslateString(table, src, *srcmax, dest, destmax, mode, currentPass, currentInput, currentOutput, spacebuf, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, appliedRules, appliedRulesCount, maxAppliedRules))",
          "107:        return 0;",
          "108:      break;",
          "110:    case 0:",
          "111:      if (!makeCorrections(table, src, *srcmax, dest, destmax, mode, currentPass, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, appliedRules, appliedRulesCount, maxAppliedRules))",
          "112:        return 0;",
          "113:      break;",
          "115:    default:",
          "116:      if (!translatePass(table, src, *srcmax, dest, destmax, mode, currentPass, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, appliedRules, appliedRulesCount, maxAppliedRules))",
          "117:        return 0;",
          "118:      break;",
          "121:       if (currentPass == lastPass)",
          "122:  return 1;",
          "124:       currentInput = currentOutput;",
          "126:       currentPass -= 1;",
          "127:     }",
          "131: _lou_backTranslateWithTracing (const char *tableList, const widechar * inbuf,",
          "132:      int *inlen, widechar * outbuf,",
          "133:      int *outlen, formtype *typeform,",
          "134:      char *spacing, int *outputPos,",
          "135:      int *inputPos, int *cursorPos, int modex,",
          "136:      const TranslationTableRule **rules, int *rulesLen)",
          "137: {",
          "138:   int srcmax;",
          "139:   int src;",
          "140:   int dest;",
          "141:   int destmax;",
          "142:   int mode;",
          "143:   widechar *passbuf1 = NULL;",
          "144:   widechar *passbuf2 = NULL;",
          "145:   unsigned char *typebuf = NULL;",
          "146:   char *spacebuf;",
          "147:   int *srcMapping = NULL;",
          "148:   int *outputPositions;",
          "149:   int *inputPositions;",
          "150:   int cursorPosition;",
          "151:   int cursorStatus;",
          "152:   const TranslationTableRule **appliedRules;",
          "153:   int maxAppliedRules;",
          "154:   int appliedRulesCount;",
          "155:   int k;",
          "156:   int goodTrans = 1;",
          "157:   if (tableList == NULL || inbuf == NULL || inlen == NULL || outbuf ==",
          "158:       NULL || outlen == NULL)",
          "159:     return 0;",
          "160:   const TranslationTableHeader *table = lou_getTable (tableList);",
          "161:   if (table == NULL)",
          "162:     return 0;",
          "163:   srcmax = 0;",
          "164:   while (srcmax < *inlen && inbuf[srcmax])",
          "165:     srcmax++;",
          "166:   destmax = *outlen;",
          "167:   typebuf = (unsigned char *) typeform;",
          "168:   spacebuf = spacing;",
          "169:   outputPositions = outputPos;",
          "170:   if (outputPos != NULL)",
          "171:     for (k = 0; k < srcmax; k++)",
          "172:       outputPos[k] = -1;",
          "173:   inputPositions = inputPos;",
          "174:   if (cursorPos != NULL)",
          "175:     cursorPosition = *cursorPos;",
          "176:   else",
          "177:     cursorPosition = -1;",
          "178:   cursorStatus = 0;",
          "179:   mode = modex;",
          "180:   if (!(passbuf1 = _lou_allocMem (alloc_passbuf1, srcmax, destmax)))",
          "181:     return 0;",
          "182:   if (typebuf != NULL)",
          "183:     memset (typebuf, '0', destmax);",
          "184:   if (spacebuf != NULL)",
          "185:     memset (spacebuf, '*', destmax);",
          "186:   for (k = 0; k < srcmax; k++)",
          "187:     if ((mode & dotsIO))",
          "188:       passbuf1[k] = inbuf[k] | 0x8000;",
          "189:     else",
          "190:       passbuf1[k] = _lou_getDotsForChar (inbuf[k]);",
          "191:   passbuf1[srcmax] = _lou_getDotsForChar (' ');",
          "192:   if (!(srcMapping = _lou_allocMem (alloc_srcMapping, srcmax, destmax)))",
          "193:     return 0;",
          "194:   for (k = 0; k <= srcmax; k++)",
          "195:     srcMapping[k] = k;",
          "196:   srcMapping[srcmax] = srcmax;",
          "197:   if ((!(mode & pass1Only)) && (table->numPasses > 1 || table->corrections))",
          "198:     {",
          "199:       if (!(passbuf2 = _lou_allocMem (alloc_passbuf2, srcmax, destmax)))",
          "200:  return 0;",
          "201:     }",
          "202:   appliedRulesCount = 0;",
          "203:   if (rules != NULL && rulesLen != NULL)",
          "204:     {",
          "205:       appliedRules = rules;",
          "206:       maxAppliedRules = *rulesLen;",
          "207:     }",
          "208:   else",
          "209:     {",
          "210:       appliedRules = NULL;",
          "211:       maxAppliedRules = 0;",
          "212:     }",
          "213:   goodTrans = doPasses(outbuf, table, &src, &srcmax, &dest, destmax, mode, passbuf1, passbuf1, passbuf2, spacebuf, srcMapping, outputPositions, inputPositions, &cursorPosition, &cursorStatus, appliedRules, &appliedRulesCount, maxAppliedRules);",
          "214:   if (src < *inlen)",
          "217:   if (outputPos != NULL)",
          "218:     {",
          "219:       int lastpos = 0;",
          "220:       for (k = 0; k < *inlen; k++)",
          "221:  if (outputPos[k] == -1)",
          "222:    outputPos[k] = lastpos;",
          "224:    lastpos = outputPos[k];",
          "225:     }",
          "226:   if (cursorPos != NULL)",
          "228:   if (rulesLen != NULL)",
          "230:   return goodTrans;",
          "234: back_findCharOrDots (widechar c, int m,",
          "235:        const TranslationTableHeader *table)",
          "236: {",
          "239:   static TranslationTableCharacter noChar =",
          "240:     { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "241:   static TranslationTableCharacter noDots =",
          "242:     { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "243:   TranslationTableCharacter *notFound;",
          "244:   TranslationTableCharacter *character;",
          "245:   TranslationTableOffset bucket;",
          "246:   unsigned long int makeHash = (unsigned long int) c % HASHNUM;",
          "247:   if (m == 0)",
          "248:     {",
          "249:       bucket = table->characters[makeHash];",
          "250:       notFound = &noChar;",
          "251:     }",
          "252:   else",
          "253:     {",
          "254:       bucket = table->dots[makeHash];",
          "255:       notFound = &noDots;",
          "256:     }",
          "257:   while (bucket)",
          "258:     {",
          "259:       character = (TranslationTableCharacter *) & table->ruleArea[bucket];",
          "260:       if (character->realchar == c)",
          "261:  return character;",
          "262:       bucket = character->next;",
          "263:     }",
          "264:   notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "265:   return notFound;",
          "269: checkAttr (const widechar c, const TranslationTableCharacterAttributes",
          "270:     a, int m,",
          "271:     const TranslationTableHeader *table)",
          "272: {",
          "273:   static widechar prevc = 0;",
          "274:   static TranslationTableCharacterAttributes preva = 0;",
          "275:   if (c != prevc)",
          "276:     {",
          "277:       preva = (back_findCharOrDots (c, m, table))->attributes;",
          "278:       prevc = c;",
          "279:     }",
          "280:   return ((preva & a) ? 1 : 0);",
          "284: compareDots (const widechar * address1, const widechar * address2, int count)",
          "285: {",
          "286:   int k;",
          "287:   if (!count)",
          "288:     return 0;",
          "289:   for (k = 0; k < count; k++)",
          "290:     if (address1[k] != address2[k])",
          "291:       return 0;",
          "292:   return 1;",
          "296: back_setBefore (const TranslationTableHeader *table,",
          "297:   int dest,",
          "298:   widechar *currentOutput,",
          "299:   TranslationTableCharacterAttributes *beforeAttributes)",
          "300: {",
          "301:   widechar before = (dest == 0) ? ' ' : currentOutput[dest - 1];",
          "306: back_setAfter (int length,",
          "307:         const TranslationTableHeader *table,",
          "308:         int src, int srcmax,",
          "309:         const widechar *currentInput,",
          "310:         TranslationTableCharacterAttributes *afterAttributes)",
          "311: {",
          "312:   widechar after = (src + length < srcmax) ? currentInput[src + length] : ' ';",
          "318: isBegWord (const TranslationTableHeader *table,",
          "319:     int dest,",
          "320:     widechar *currentOutput)",
          "321: {",
          "324:   int k;",
          "325:   if (dest == 0)",
          "326:     return 1;",
          "327:   for (k = dest - 1; k >= 0; k--)",
          "328:     {",
          "329:       const TranslationTableCharacter *ch =",
          "330:  back_findCharOrDots (currentOutput[k], 0, table);",
          "331:       if (ch->attributes & CTC_Space)",
          "332:  break;",
          "333:       if (ch->attributes & (CTC_Letter | CTC_Digit | CTC_Math | CTC_Sign))",
          "334:  return 0;",
          "335:     }",
          "336:   return 1;",
          "340: isEndWord (const TranslationTableHeader *table,",
          "341:     int src, int srcmax,",
          "342:     int mode,",
          "343:     const widechar *currentInput,",
          "344:     int currentDotslen)",
          "345: {",
          "346:   if (mode & partialTrans)",
          "347:     return 0;",
          "349:   int k;",
          "350:   const TranslationTableCharacter *dots;",
          "351:   TranslationTableOffset testRuleOffset;",
          "352:   TranslationTableRule *testRule;",
          "353:   for (k = src + currentDotslen; k < srcmax; k++)",
          "354:     {",
          "355:       int postpuncFound = 0;",
          "356:       int TranslationFound = 0;",
          "357:       dots = back_findCharOrDots (currentInput[k], 1, table);",
          "358:       testRuleOffset = dots->otherRules;",
          "359:       if (dots->attributes & CTC_Space)",
          "360:  break;",
          "361:       if (dots->attributes & CTC_Letter)",
          "362:  return 0;",
          "363:       while (testRuleOffset)",
          "364:  {",
          "365:    testRule =",
          "366:      (TranslationTableRule *) & table->ruleArea[testRuleOffset];",
          "371:    if (testRule->charslen > 1",
          "372:        && testRule->opcode != CTO_BegWord",
          "373:        && testRule->opcode != CTO_MidWord)",
          "374:      TranslationFound = 1;",
          "375:    if (testRule->opcode == CTO_PostPunc)",
          "376:      postpuncFound = 1;",
          "377:    if (testRule->opcode == CTO_Hyphen)",
          "378:      return 1;",
          "379:    testRuleOffset = testRule->dotsnext;",
          "381:       if (TranslationFound && !postpuncFound)",
          "382:  return 0;",
          "383:     }",
          "384:   return 1;",
          "387: findBrailleIndicatorRule (TranslationTableOffset offset,",
          "388:      const TranslationTableHeader *table,",
          "389:      int *currentDotslen, TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule)",
          "390: {",
          "391:   if (!offset)",
          "392:     return 0;",
          "396:   return 1;",
          "400: handleMultind (const TranslationTableHeader *table,",
          "401:         int *currentDotslen, TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule,",
          "402:         int *doingMultind,",
          "403:         const TranslationTableRule *multindRule)",
          "404: {",
          "406:   int found = 0;",
          "407:   if (!*doingMultind)",
          "408:     return 0;",
          "409:   switch (multindRule->charsdots[multindRule->charslen - *doingMultind])",
          "410:     {",
          "411:     case CTO_CapsLetterRule: // FIXME: make sure this works",
          "412:       found = findBrailleIndicatorRule (table->emphRules[capsRule][letterOffset], table, currentDotslen, currentOpcode, currentRule);",
          "413:       break;",
          "422:     case CTO_BegCapsWordRule:",
          "423:       found = findBrailleIndicatorRule (table->emphRules[capsRule][begWordOffset], table, currentDotslen, currentOpcode, currentRule);",
          "424:       break;",
          "425:     case CTO_EndCapsWordRule:",
          "426:       found = findBrailleIndicatorRule (table->emphRules[capsRule][endWordOffset], table, currentDotslen, currentOpcode, currentRule);",
          "427:       break;",
          "428:     case CTO_LetterSign:",
          "429:       found = findBrailleIndicatorRule (table->letterSign, table, currentDotslen, currentOpcode, currentRule);",
          "430:       break;",
          "431:     case CTO_NoContractSign:",
          "432:       found = findBrailleIndicatorRule (table->noContractSign, table, currentDotslen, currentOpcode, currentRule);",
          "433:       break;",
          "434:     case CTO_NumberSign:",
          "435:       found = findBrailleIndicatorRule (table->numberSign, table, currentDotslen, currentOpcode, currentRule);",
          "436:       break;",
          "437:     case CTO_EndEmph1PhraseBeforeRule:",
          "438:       found = findBrailleIndicatorRule (table->emphRules[emph1Rule][endPhraseBeforeOffset], table, currentDotslen, currentOpcode, currentRule);",
          "439:       break;",
          "440:     case CTO_BegEmph1Rule:",
          "441:       found = findBrailleIndicatorRule (table->emphRules[emph1Rule][begOffset], table, currentDotslen, currentOpcode, currentRule);",
          "442:       break;",
          "443:     case CTO_EndEmph1Rule:",
          "444:       found = findBrailleIndicatorRule (table->emphRules[emph1Rule][endOffset], table, currentDotslen, currentOpcode, currentRule);",
          "445:       break;",
          "446:     case CTO_EndEmph2PhraseBeforeRule:",
          "447:       found = findBrailleIndicatorRule (table->emphRules[emph2Rule][endPhraseBeforeOffset], table, currentDotslen, currentOpcode, currentRule);",
          "448:       break;",
          "449:     case CTO_BegEmph2Rule:",
          "450:       found = findBrailleIndicatorRule (table->emphRules[emph2Rule][begOffset], table, currentDotslen, currentOpcode, currentRule);",
          "451:       break;",
          "452:     case CTO_EndEmph2Rule:",
          "453:       found = findBrailleIndicatorRule (table->emphRules[emph2Rule][endOffset], table, currentDotslen, currentOpcode, currentRule);",
          "454:       break;",
          "455:     case CTO_EndEmph3PhraseBeforeRule:",
          "456:       found = findBrailleIndicatorRule (table->emphRules[emph3Rule][endPhraseBeforeOffset], table, currentDotslen, currentOpcode, currentRule);",
          "457:       break;",
          "458:     case CTO_BegEmph3Rule:",
          "459:       found = findBrailleIndicatorRule (table->emphRules[emph3Rule][begOffset], table, currentDotslen, currentOpcode, currentRule);",
          "460:       break;",
          "461:     case CTO_EndEmph3Rule:",
          "462:       found = findBrailleIndicatorRule (table->emphRules[emph3Rule][endOffset], table, currentDotslen, currentOpcode, currentRule);",
          "463:       break;",
          "464:     case CTO_BegComp:",
          "465:       found = findBrailleIndicatorRule (table->begComp, table, currentDotslen, currentOpcode, currentRule);",
          "466:       break;",
          "467:     case CTO_EndComp:",
          "468:       found = findBrailleIndicatorRule (table->endComp, table, currentDotslen, currentOpcode, currentRule);",
          "469:       break;",
          "470:     default:",
          "471:       found = 0;",
          "472:       break;",
          "473:     }",
          "474:   (*doingMultind)--;",
          "475:   return found;",
          "478: static int back_passDoTest (const TranslationTableHeader *table, int src, int srcmax, const widechar *currentInput, TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule, int *passSrc, const widechar **passInstructions, int *passIC, int *startMatch, int *startReplace, int *endReplace);",
          "479: static int back_passDoAction (const TranslationTableHeader *table, int src, int srcmax, int *dest, int destmax, int mode, const widechar *currentInput, widechar *currentOutput, int *srcMapping, int *outputPositions, int *inputPositions, int *cursorPosition, int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase, TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule, int passSrc, const widechar *passInstructions, int passIC, int startMatch, int startReplace, int *endReplace);",
          "482: findBackPassRule (const TranslationTableHeader *table,",
          "483:     int src, int srcmax,",
          "484:     int currentPass,",
          "485:     const widechar *currentInput,",
          "486:     TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule,",
          "487:     int *passSrc,",
          "488:     const widechar **passInstructions, int *passIC,",
          "489:     int *startMatch, int *startReplace, int *endReplace)",
          "490: {",
          "491:   TranslationTableOffset ruleOffset;",
          "492:   ruleOffset = table->backPassRules[currentPass];",
          "494:   while (ruleOffset)",
          "495:     {",
          "499:       switch (*currentOpcode)",
          "500:         {",
          "501:  case CTO_Correct:",
          "502:    if (currentPass != 0)",
          "503:      goto NEXT_RULE;",
          "504:    break;",
          "505:  case CTO_Context:",
          "506:    if (currentPass != 1)",
          "507:      goto NEXT_RULE;",
          "508:    break;",
          "509:  case CTO_Pass2:",
          "510:    if (currentPass != 2)",
          "511:      goto NEXT_RULE;",
          "512:    break;",
          "513:  case CTO_Pass3:",
          "514:    if (currentPass != 3)",
          "515:      goto NEXT_RULE;",
          "516:    break;",
          "517:  case CTO_Pass4:",
          "518:    if (currentPass != 4)",
          "519:      goto NEXT_RULE;",
          "520:    break;",
          "521:  default:",
          "522:    goto NEXT_RULE;",
          "523:  }",
          "525:       if (back_passDoTest(table, src, srcmax, currentInput, *currentOpcode, *currentRule, passSrc, passInstructions, passIC, startMatch, startReplace, endReplace))",
          "526:  return 1;",
          "528:     NEXT_RULE:",
          "529:       ruleOffset = (*currentRule)->dotsnext;",
          "530:     }",
          "532:   return 0;",
          "536: back_selectRule (const TranslationTableHeader *table,",
          "537:    int src, int srcmax,",
          "538:    int dest,",
          "539:    int mode,",
          "540:    const widechar *currentInput,",
          "541:    widechar *currentOutput,",
          "542:    int itsANumber, int itsALetter,",
          "543:    int *currentDotslen, TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule,",
          "544:    TranslationTableOpcode previousOpcode,",
          "545:    int *doingMultind, const TranslationTableRule **multindRule,",
          "546:    TranslationTableCharacterAttributes beforeAttributes,",
          "547:    int *passSrc, const widechar **passInstructions, int *passIC,",
          "548:    int *startMatch, int *startReplace, int *endReplace)",
          "549: {",
          "551:   int length = srcmax - src;",
          "552:   TranslationTableOffset ruleOffset = 0;",
          "553:   static TranslationTableRule pseudoRule = { 0 };",
          "554:   unsigned long int makeHash = 0;",
          "555:   const TranslationTableCharacter *dots =",
          "556:     back_findCharOrDots (currentInput[src], 1, table);",
          "557:   int tryThis;",
          "558:   if (handleMultind (table, currentDotslen, currentOpcode, currentRule, doingMultind, *multindRule))",
          "559:     return;",
          "560:   for (tryThis = 0; tryThis < 3; tryThis++)",
          "561:     {",
          "562:       switch (tryThis)",
          "563:  {",
          "564:  case 0:",
          "565:    if (length < 2 || (itsANumber && (dots->attributes & CTC_LitDigit)))",
          "566:      break;",
          "568:    makeHash = (unsigned long int) dots->realchar << 8;",
          "569:    makeHash += (unsigned long int) (back_findCharOrDots",
          "570:         (currentInput[src + 1],",
          "571:          1, table))->realchar;",
          "572:    makeHash %= HASHNUM;",
          "573:    ruleOffset = table->backRules[makeHash];",
          "574:    break;",
          "575:  case 1:",
          "576:    if (!(length >= 1))",
          "577:      break;",
          "578:    length = 1;",
          "579:    ruleOffset = dots->otherRules;",
          "580:    break;",
          "585:    pseudoRule.charsdots[0] = currentInput[src];",
          "586:    pseudoRule.charslen = 0;",
          "587:    return;",
          "588:    break;",
          "589:  }",
          "590:       while (ruleOffset)",
          "591:  {",
          "592:    const widechar *currentDots;",
          "594:      (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "596:    if (*currentOpcode == CTO_Context)",
          "597:      {",
          "598:        currentDots = &(*currentRule)->charsdots[0];",
          "600:      }",
          "601:    else",
          "602:      {",
          "603:        currentDots = &(*currentRule)->charsdots[(*currentRule)->charslen];",
          "605:      }",
          "606:    if (((*currentDotslen <= length) &&",
          "607:         compareDots(&currentInput[src], currentDots, *currentDotslen)))",
          "608:      {",
          "609:        TranslationTableCharacterAttributes afterAttributes;",
          "611:        back_setAfter (*currentDotslen, table, src, srcmax, currentInput, &afterAttributes);",
          "612:        if ((!((*currentRule)->after & ~CTC_EmpMatch) || (beforeAttributes",
          "613:         & (*currentRule)->after)) &&",
          "614:     (!((*currentRule)->before & ~CTC_EmpMatch) || (afterAttributes",
          "615:          & (*currentRule)->before)))",
          "616:   {",
          "617:     switch (*currentOpcode)",
          "619:       case CTO_Context:",
          "620:         if (back_passDoTest(table, src, srcmax, currentInput, *currentOpcode, *currentRule, passSrc, passInstructions, passIC, startMatch, startReplace, endReplace))",
          "621:           return;",
          "622:         break;",
          "623:       case CTO_Space:",
          "624:       case CTO_Digit:",
          "625:       case CTO_Letter:",
          "626:       case CTO_UpperCase:",
          "627:       case CTO_LowerCase:",
          "628:       case CTO_Punctuation:",
          "629:       case CTO_Math:",
          "630:       case CTO_Sign:",
          "631:       case CTO_ExactDots:",
          "632:       case CTO_NoCross:",
          "633:       case CTO_Repeated:",
          "634:       case CTO_Replace:",
          "635:       case CTO_Hyphen:",
          "636:         return;",
          "637:       case CTO_LitDigit:",
          "638:         if (itsANumber)",
          "639:    return;",
          "640:         break;",
          "641:       case CTO_CapsLetterRule:",
          "642:       case CTO_BegCapsRule:",
          "643:       case CTO_EndCapsRule:",
          "644:       case CTO_BegCapsWordRule:",
          "645:       case CTO_EndCapsWordRule:",
          "646:       case CTO_BegEmph1Rule:",
          "647:       case CTO_EndEmph1Rule:",
          "648:       case CTO_BegEmph2Rule:",
          "649:       case CTO_EndEmph2Rule:",
          "650:       case CTO_BegEmph3Rule:",
          "651:       case CTO_EndEmph3Rule:",
          "652:       case CTO_NumberRule:",
          "653:       case CTO_BegCompRule:",
          "654:       case CTO_EndCompRule:",
          "655:         return;",
          "656:       case CTO_LetterRule:",
          "657:       case CTO_NoContractRule:",
          "664:         if (!(beforeAttributes & CTC_Letter)",
          "665:        && (afterAttributes & (CTC_Letter | CTC_Sign)))",
          "666:    return;",
          "667:         break;",
          "668:       case CTO_MultInd:",
          "671:         if (handleMultind (table, currentDotslen, currentOpcode, currentRule, doingMultind, *multindRule))",
          "672:    return;",
          "673:         break;",
          "674:       case CTO_LargeSign:",
          "675:         return;",
          "676:       case CTO_WholeWord:",
          "677:         if (mode & partialTrans)",
          "679:         if (itsALetter || itsANumber)",
          "681:       case CTO_Contraction:",
          "682:         if ((beforeAttributes & (CTC_Space | CTC_Punctuation))",
          "683:      && ((afterAttributes & CTC_Space) || isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen)))",
          "685:         break;",
          "686:       case CTO_LowWord:",
          "687:         if (mode & partialTrans)",
          "689:         if ((beforeAttributes & CTC_Space) && (afterAttributes",
          "690:             & CTC_Space) &&",
          "691:      (previousOpcode != CTO_JoinableWord))",
          "692:    return;",
          "693:         break;",
          "694:       case CTO_JoinNum:",
          "695:       case CTO_JoinableWord:",
          "696:         if ((beforeAttributes & (CTC_Space |",
          "697:             CTC_Punctuation))",
          "698:      && (!(afterAttributes & CTC_Space) || mode & partialTrans))",
          "699:    return;",
          "700:         break;",
          "701:       case CTO_SuffixableWord:",
          "702:         if (beforeAttributes & (CTC_Space | CTC_Punctuation))",
          "703:    return;",
          "704:         break;",
          "705:       case CTO_PrefixableWord:",
          "706:         if ((beforeAttributes & (CTC_Space | CTC_Letter |",
          "707:             CTC_Punctuation))",
          "708:      && isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen))",
          "709:    return;",
          "710:         break;",
          "711:       case CTO_BegWord:",
          "712:         if ((beforeAttributes & (CTC_Space | CTC_Punctuation))",
          "713:      && (!isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen)))",
          "714:    return;",
          "715:         break;",
          "716:       case CTO_BegMidWord:",
          "717:         if ((beforeAttributes & (CTC_Letter | CTC_Space |",
          "718:             CTC_Punctuation))",
          "719:      && (!isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen)))",
          "720:    return;",
          "721:         break;",
          "722:       case CTO_PartWord:",
          "723:         if (!(beforeAttributes &",
          "724:         CTC_LitDigit) && (beforeAttributes & CTC_Letter ||",
          "725:         !isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen)))",
          "726:    return;",
          "727:         break;",
          "728:       case CTO_MidWord:",
          "729:         if (beforeAttributes & CTC_Letter && !isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen))",
          "730:    return;",
          "731:         break;",
          "732:       case CTO_MidEndWord:",
          "733:         if ((beforeAttributes & CTC_Letter))",
          "734:    return;",
          "735:         break;",
          "736:       case CTO_EndWord:",
          "737:         if ((beforeAttributes & CTC_Letter) && isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen))",
          "738:    return;",
          "739:         break;",
          "740:       case CTO_BegNum:",
          "741:         if (beforeAttributes & (CTC_Space | CTC_Punctuation)",
          "742:      && (afterAttributes & (CTC_LitDigit | CTC_Sign)))",
          "743:    return;",
          "744:         break;",
          "745:       case CTO_MidNum:",
          "746:         if (beforeAttributes & CTC_Digit &&",
          "747:      afterAttributes & CTC_LitDigit)",
          "748:    return;",
          "749:         break;",
          "750:       case CTO_EndNum:",
          "751:         if (itsANumber && !(afterAttributes & CTC_LitDigit))",
          "752:    return;",
          "753:         break;",
          "754:       case CTO_DecPoint:",
          "755:         if (afterAttributes & (CTC_Digit | CTC_LitDigit))",
          "756:    return;",
          "757:         break;",
          "758:       case CTO_PrePunc:",
          "759:         if (isBegWord (table, dest, currentOutput))",
          "760:    return;",
          "761:         break;",
          "763:       case CTO_PostPunc:",
          "764:         if (isEndWord (table, src, srcmax, mode, currentInput, *currentDotslen))",
          "765:    return;",
          "766:         break;",
          "767:       case CTO_Always:",
          "768:       if ((beforeAttributes & CTC_LitDigit) &&",
          "769:       (afterAttributes & CTC_LitDigit) &&",
          "770:       (*currentRule)->charslen > 1)",
          "771:       break;",
          "772:       return;",
          "774:     case CTO_BackMatch:",
          "775:     {",
          "776:      widechar *patterns, *pattern;",
          "783:      patterns = (widechar*)&table->ruleArea[(*currentRule)->patterns];",
          "786:      pattern = &patterns[1];",
          "787:      if(!_lou_pattern_check(currentInput, src - 1, -1, -1, pattern, table))",
          "791:      pattern = &patterns[patterns[0]];",
          "792:      if(!_lou_pattern_check(currentInput, src + (*currentRule)->dotslen, srcmax, 1, pattern, table))",
          "795:      return;",
          "797:       default:",
          "798:         break;",
          "799:       }",
          "802:    ruleOffset = (*currentRule)->dotsnext;",
          "804:     }",
          "808: putchars (const widechar * chars, int count,",
          "809:    const TranslationTableHeader *table,",
          "810:    int *dest,",
          "811:    int destmax,",
          "812:    widechar *currentOutput,",
          "813:    int *nextUpper,",
          "814:    int allUpper, int allUpperPhrase)",
          "815: {",
          "816:   int k = 0;",
          "817:   if (!count || (*dest + count) > destmax)",
          "818:     return 0;",
          "819:   if (*nextUpper)",
          "820:     {",
          "821:       currentOutput[(*dest)++] =",
          "822:  (back_findCharOrDots (chars[k++], 0, table))->uppercase;",
          "824:     }",
          "825:   if (!allUpper && !allUpperPhrase)",
          "826:     {",
          "827:       memcpy (&currentOutput[*dest], &chars[k], CHARSIZE * (count - k));",
          "829:     }",
          "830:   else",
          "831:     for (; k < count; k++)",
          "832:       currentOutput[(*dest)++] = (back_findCharOrDots (chars[k], 0, table))->uppercase;",
          "833:   return 1;",
          "837: back_updatePositions (const widechar * outChars, int inLength, int outLength,",
          "838:         const TranslationTableHeader *table,",
          "839:         int src, int srcmax,",
          "840:         int *dest,",
          "841:         int destmax,",
          "842:         widechar *currentOutput,",
          "843:         int *srcMapping,",
          "844:         int *outputPositions, int *inputPositions,",
          "845:         int *cursorPosition, int *cursorStatus,",
          "846:         int *nextUpper,",
          "847:         int allUpper, int allUpperPhrase)",
          "848: {",
          "849:   int k;",
          "850:   if ((*dest + outLength) > destmax || (src + inLength) > srcmax)",
          "851:     return 0;",
          "852:   if (!*cursorStatus && *cursorPosition >= src &&",
          "854:     {",
          "857:     }",
          "858:   if (inputPositions != NULL || outputPositions != NULL)",
          "859:     {",
          "860:       if (outLength <= inLength)",
          "861:  {",
          "862:    for (k = 0; k < outLength; k++)",
          "863:      {",
          "864:        if (inputPositions != NULL)",
          "865:   inputPositions[*dest + k] = srcMapping[src + k];",
          "866:        if (outputPositions != NULL)",
          "867:   outputPositions[srcMapping[src + k]] = *dest + k;",
          "868:      }",
          "869:    for (k = outLength; k < inLength; k++)",
          "870:      if (outputPositions != NULL)",
          "871:        outputPositions[srcMapping[src + k]] = *dest + outLength - 1;",
          "873:       else",
          "874:  {",
          "875:    for (k = 0; k < inLength; k++)",
          "876:      {",
          "877:        if (inputPositions != NULL)",
          "878:   inputPositions[*dest + k] = srcMapping[src + k];",
          "879:        if (outputPositions != NULL)",
          "880:   outputPositions[srcMapping[src + k]] = *dest + k;",
          "881:      }",
          "882:    for (k = inLength; k < outLength; k++)",
          "883:      if (inputPositions != NULL)",
          "884:        inputPositions[*dest + k] = srcMapping[src + inLength - 1];",
          "886:     }",
          "887:   return putchars (outChars, outLength, table, dest, destmax, currentOutput, nextUpper, allUpper, allUpperPhrase);",
          "891: undefinedDots (widechar dots,",
          "892:         int *dest,",
          "893:         int destmax,",
          "894:         int mode,",
          "895:         widechar *currentOutput)",
          "896: {",
          "897:   if (mode & noUndefinedDots)",
          "898:     return 1;",
          "900:   widechar buffer[20];",
          "901:   int k = 1;",
          "902:   buffer[0] = '\\\\';",
          "903:   if ((dots & B1))",
          "904:     buffer[k++] = '1';",
          "905:   if ((dots & B2))",
          "906:     buffer[k++] = '2';",
          "907:   if ((dots & B3))",
          "908:     buffer[k++] = '3';",
          "909:   if ((dots & B4))",
          "910:     buffer[k++] = '4';",
          "911:   if ((dots & B5))",
          "912:     buffer[k++] = '5';",
          "913:   if ((dots & B6))",
          "914:     buffer[k++] = '6';",
          "915:   if ((dots & B7))",
          "916:     buffer[k++] = '7';",
          "917:   if ((dots & B8))",
          "918:     buffer[k++] = '8';",
          "919:   if ((dots & B9))",
          "920:     buffer[k++] = '9';",
          "921:   if ((dots & B10))",
          "922:     buffer[k++] = 'A';",
          "923:   if ((dots & B11))",
          "924:     buffer[k++] = 'B';",
          "925:   if ((dots & B12))",
          "926:     buffer[k++] = 'C';",
          "927:   if ((dots & B13))",
          "928:     buffer[k++] = 'D';",
          "929:   if ((dots & B14))",
          "930:     buffer[k++] = 'E';",
          "931:   if ((dots & B15))",
          "932:     buffer[k++] = 'F';",
          "933:   buffer[k++] = '/';",
          "934:   if ((*dest + k) > destmax)",
          "935:     return 0;",
          "936:   memcpy (&currentOutput[*dest], buffer, k * CHARSIZE);",
          "938:   return 1;",
          "942: putCharacter (widechar dots,",
          "943:        const TranslationTableHeader *table,",
          "944:        int src, int srcmax,",
          "945:        int *dest,",
          "946:        int destmax,",
          "947:        int mode,",
          "948:        widechar *currentOutput,",
          "949:        int *srcMapping,",
          "950:        int *outputPositions, int *inputPositions,",
          "951:        int *cursorPosition, int *cursorStatus,",
          "952:        int *nextUpper,",
          "953:        int allUpper, int allUpperPhrase)",
          "954: {",
          "956:   TranslationTableOffset offset =",
          "957:     (back_findCharOrDots (dots, 1, table))->definitionRule;",
          "958:   if (offset)",
          "959:     {",
          "960:       widechar c;",
          "961:       const TranslationTableRule *rule =",
          "962:         (TranslationTableRule *) &table->ruleArea[offset];",
          "963:       if (rule->charslen)",
          "964:  return back_updatePositions (&rule->charsdots[0],",
          "965:          rule->dotslen, rule->charslen, table, src, srcmax, dest, destmax, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase);",
          "966:       c = _lou_getCharFromDots(dots);",
          "967:       return back_updatePositions (&c, 1, 1, table, src, srcmax, dest, destmax, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase);",
          "968:     }",
          "969:   return undefinedDots (dots, dest, destmax, mode, currentOutput);",
          "973: putCharacters (const widechar * characters, int count,",
          "974:         const TranslationTableHeader *table,",
          "975:         int src, int srcmax,",
          "976:         int *dest,",
          "977:         int destmax,",
          "978:         int mode,",
          "979:         widechar *currentOutput,",
          "980:         int *srcMapping,",
          "981:         int *outputPositions, int *inputPositions,",
          "982:         int *cursorPosition, int *cursorStatus,",
          "983:         int *nextUpper,",
          "984:         int allUpper, int allUpperPhrase)",
          "985: {",
          "986:   int k;",
          "987:   for (k = 0; k < count; k++)",
          "988:     if (!putCharacter (characters[k], table, src, srcmax, dest, destmax, mode, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase))",
          "989:       return 0;",
          "990:   return 1;",
          "994: insertSpace (const TranslationTableHeader *table,",
          "995:       int src, int srcmax,",
          "996:       int *dest,",
          "997:       int destmax,",
          "998:       widechar *currentOutput,",
          "999:       char *spacebuf,",
          "1000:       int *srcMapping,",
          "1001:       int *outputPositions, int *inputPositions,",
          "1002:       int *cursorPosition, int *cursorStatus,",
          "1003:       int *nextUpper,",
          "1004:       int allUpper, int allUpperPhrase)",
          "1005: {",
          "1006:   widechar c = ' ';",
          "1007:   if (!back_updatePositions (&c, 1, 1, table, src, srcmax, dest, destmax, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase))",
          "1008:     return 0;",
          "1009:   if (spacebuf)",
          "1010:     spacebuf[*dest - 1] = '1';",
          "1011:   return 1;",
          "1015: compareChars (const widechar * address1, const widechar * address2, int",
          "1016:        count, int m,",
          "1017:        const TranslationTableHeader *table)",
          "1018: {",
          "1019:   int k;",
          "1020:   if (!count)",
          "1021:     return 0;",
          "1022:   for (k = 0; k < count; k++)",
          "1023:     if ((back_findCharOrDots (address1[k], m, table))->lowercase !=",
          "1024:  (back_findCharOrDots (address2[k], m, table))->lowercase)",
          "1025:       return 0;",
          "1026:   return 1;",
          "1030: makeCorrections (const TranslationTableHeader *table,",
          "1031:    int *src,",
          "1032:    int srcmax,",
          "1033:    int *dest,",
          "1034:    int destmax,",
          "1035:    int mode,",
          "1036:    int currentPass,",
          "1037:    const widechar *currentInput,",
          "1038:    widechar *currentOutput,",
          "1039:    int *srcMapping,",
          "1040:    int *outputPositions, int *inputPositions,",
          "1041:    int *cursorPosition, int *cursorStatus,",
          "1042:    const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "1043:    int maxAppliedRules)",
          "1044: {",
          "1045:   int nextUpper = 0;",
          "1046:   int allUpper = 0;",
          "1047:   int allUpperPhrase = 0;",
          "1048:   if (!table->corrections)",
          "1049:     return 1;",
          "1052:   _lou_resetPassVariables();",
          "1053:   while (*src < srcmax)",
          "1054:     {",
          "1055:       TranslationTableOpcode currentOpcode;",
          "1057:       int passSrc;",
          "1058:       const widechar *passInstructions;",
          "1060:       int startMatch;",
          "1061:       int startReplace;",
          "1062:       int endReplace;",
          "1063:       int length = srcmax - *src;",
          "1064:       const TranslationTableCharacter *character = back_findCharOrDots",
          "1065:  (currentInput[*src], 0, table);",
          "1066:       const TranslationTableCharacter *character2;",
          "1067:       int tryThis = 0;",
          "1068:       if (!findBackPassRule (table, *src, srcmax, currentPass, currentInput, &currentOpcode, &currentRule, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace))",
          "1069:  while (tryThis < 3)",
          "1070:    {",
          "1071:      TranslationTableOffset ruleOffset = 0;",
          "1072:      unsigned long int makeHash = 0;",
          "1073:      switch (tryThis)",
          "1074:        {",
          "1075:        case 0:",
          "1076:   if (!(length >= 2))",
          "1077:     break;",
          "1078:   makeHash = (unsigned long int) character->lowercase << 8;",
          "1079:   character2 = back_findCharOrDots (currentInput[*src + 1], 0, table);",
          "1080:   makeHash += (unsigned long int) character2->lowercase;",
          "1081:   makeHash %= HASHNUM;",
          "1082:   ruleOffset = table->forRules[makeHash];",
          "1083:   break;",
          "1084:        case 1:",
          "1085:   if (!(length >= 1))",
          "1086:     break;",
          "1087:   length = 1;",
          "1088:   ruleOffset = character->otherRules;",
          "1089:   break;",
          "1091:   currentOpcode = CTO_Always;",
          "1092:   ruleOffset = 0;",
          "1093:   break;",
          "1094:        }",
          "1095:      while (ruleOffset)",
          "1096:        {",
          "1097:   currentRule =",
          "1098:     (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "1099:   currentOpcode = currentRule->opcode;",
          "1100:   int currentCharslen = currentRule->charslen;",
          "1101:   if (tryThis == 1 || (currentCharslen <= length &&",
          "1102:          compareChars (&currentRule->",
          "1103:          charsdots[0],",
          "1104:          &currentInput[*src],",
          "1105:          currentCharslen, 0, table)))",
          "1106:     {",
          "1107:       if (currentOpcode == CTO_Correct && back_passDoTest (table, *src, srcmax, currentInput, currentOpcode, currentRule, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace))",
          "1108:         {",
          "1109:    tryThis = 4;",
          "1111:         }",
          "1112:     }",
          "1113:   ruleOffset = currentRule->dotsnext;",
          "1114:        }",
          "1115:      tryThis++;",
          "1116:    }",
          "1117:       switch (currentOpcode)",
          "1118:  {",
          "1119:  case CTO_Always:",
          "1120:    if (*dest >= destmax)",
          "1121:      goto failure;",
          "1122:    srcMapping[*dest] = srcMapping[*src];",
          "1123:    currentOutput[(*dest)++] = currentInput[(*src)++];",
          "1124:    break;",
          "1125:  case CTO_Correct:",
          "1126:    if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)",
          "1127:      appliedRules[(*appliedRulesCount)++] = currentRule;",
          "1128:    if (!back_passDoAction (table, *src, srcmax, dest, destmax, mode, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase, currentOpcode, currentRule, passSrc, passInstructions, passIC, startMatch, startReplace, &endReplace))",
          "1129:      goto failure;",
          "1131:    break;",
          "1132:  default:",
          "1133:    break;",
          "1135:     }",
          "1137:   return 1;",
          "1141: backTranslateString (const TranslationTableHeader *table,",
          "1142:        int *src,",
          "1143:        int srcmax,",
          "1144:        int *dest,",
          "1145:        int destmax,",
          "1146:        int mode,",
          "1147:        int currentPass,",
          "1148:        const widechar *currentInput,",
          "1149:        widechar *currentOutput,",
          "1150:        char *spacebuf,",
          "1151:        int *srcMapping,",
          "1152:        int *outputPositions, int *inputPositions,",
          "1153:        int *cursorPosition, int *cursorStatus,",
          "1154:        const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "1155:        int maxAppliedRules)",
          "1156: {",
          "1157:   int nextUpper;",
          "1158:   int allUpper;",
          "1159:   int allUpperPhrase;",
          "1160:   int itsANumber;",
          "1161:   int itsALetter;",
          "1163:   int srcword = 0;",
          "1165:   TranslationTableOpcode previousOpcode;",
          "1166:   int doingMultind = 0;",
          "1167:   const TranslationTableRule *multindRule;",
          "1168:   _lou_resetPassVariables();",
          "1169:   translation_direction = 0;",
          "1170:   nextUpper = allUpper = allUpperPhrase = itsANumber = itsALetter = 0;",
          "1171:   previousOpcode = CTO_None;",
          "1173:   while (*src < srcmax)",
          "1174:     {",
          "1177:       TranslationTableOpcode currentOpcode;",
          "1179:       TranslationTableCharacterAttributes beforeAttributes;",
          "1180:       int passSrc;",
          "1181:       const widechar *passInstructions;",
          "1183:       int startMatch;",
          "1184:       int startReplace;",
          "1185:       int endReplace;",
          "1186:       back_setBefore (table, *dest, currentOutput, &beforeAttributes);",
          "1187:       back_selectRule (table, *src, srcmax, *dest, mode, currentInput, currentOutput, itsANumber, itsALetter, &currentDotslen, &currentOpcode, &currentRule, previousOpcode, &doingMultind, &multindRule, beforeAttributes, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace);",
          "1188:       if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)",
          "1189:  appliedRules[(*appliedRulesCount)++] = currentRule;",
          "1191:       switch (currentOpcode)",
          "1192:  {",
          "1193:  case CTO_Hyphen:",
          "1194:      itsANumber = 0;",
          "1195:    break;",
          "1196:  case CTO_LargeSign:",
          "1197:    if (previousOpcode == CTO_LargeSign)",
          "1198:      if (!insertSpace (table, *src, srcmax, dest, destmax, currentOutput, spacebuf, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase))",
          "1199:        goto failure;",
          "1200:    break;",
          "1201:  case CTO_CapsLetterRule:",
          "1202:    nextUpper = 1;",
          "1204:    continue;",
          "1205:    break;",
          "1206:  case CTO_BegCapsWordRule:",
          "1207:    allUpper = 1;",
          "1209:    continue;",
          "1210:    break;",
          "1211:  case CTO_BegCapsRule:",
          "1212:    allUpperPhrase = 1;",
          "1214:    continue;",
          "1215:    break;",
          "1216:  case CTO_EndCapsWordRule:",
          "1217:    allUpper = 0;",
          "1219:    continue;",
          "1220:    break;",
          "1221:  case CTO_EndCapsRule:",
          "1222:    allUpperPhrase = 0;",
          "1224:    continue;",
          "1225:    break;",
          "1226:  case CTO_LetterRule:",
          "1227:  case CTO_NoContractRule:",
          "1228:    itsALetter = 1;",
          "1229:    itsANumber = 0;",
          "1231:    continue;",
          "1232:    break;",
          "1233:  case CTO_NumberRule:",
          "1234:    itsANumber = 1;",
          "1236:    continue;",
          "1237:    break;",
          "1238:  case CTO_BegEmph1Rule:",
          "1240:    continue;",
          "1241:    break;",
          "1242:  case CTO_BegEmph2Rule:",
          "1244:    continue;",
          "1245:    break;",
          "1246:  case CTO_BegEmph3Rule:",
          "1248:    continue;",
          "1249:    break;",
          "1250:  case CTO_EndEmph1Rule:",
          "1251:  case CTO_EndEmph2Rule:",
          "1252:  case CTO_EndEmph3Rule:",
          "1254:    continue;",
          "1255:    break;",
          "1256:  case CTO_BegCompRule:",
          "1258:    continue;",
          "1259:    break;",
          "1260:  case CTO_EndCompRule:",
          "1262:    continue;",
          "1263:    break;",
          "1265:  default:",
          "1266:    break;",
          "1267:  }",
          "1270:       switch (currentOpcode)",
          "1271:  {",
          "1272:  case CTO_Context:",
          "1273:    if (!back_passDoAction(table, *src, srcmax, dest, destmax, mode, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase, currentOpcode, currentRule, passSrc, passInstructions, passIC, startMatch, startReplace, &endReplace))",
          "1274:      return 0;",
          "1276:    break;",
          "1277:  case CTO_Replace:",
          "1279:    if (!putCharacters",
          "1280:        (&currentRule->charsdots[0], currentRule->charslen, table, *src, srcmax, dest, destmax, mode, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase))",
          "1281:      goto failure;",
          "1282:    break;",
          "1283:  case CTO_None:",
          "1284:    if (!undefinedDots (currentInput[*src], dest, destmax, mode, currentOutput))",
          "1285:      goto failure;",
          "1286:    (*src)++;",
          "1287:    break;",
          "1288:  case CTO_BegNum:",
          "1289:    itsANumber = 1;",
          "1290:    goto insertChars;",
          "1291:  case CTO_EndNum:",
          "1292:    itsANumber = 0;",
          "1293:    goto insertChars;",
          "1294:  case CTO_Space:",
          "1295:    itsALetter = itsANumber = allUpper = nextUpper = 0;",
          "1296:    goto insertChars;",
          "1297:  default:",
          "1298:  insertChars:",
          "1299:    if (currentRule->charslen)",
          "1300:      {",
          "1301:        if (!back_updatePositions",
          "1302:     (&currentRule->charsdots[0],",
          "1303:      currentRule->dotslen, currentRule->charslen, table, *src, srcmax, dest, destmax, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase))",
          "1304:   goto failure;",
          "1306:      }",
          "1307:    else",
          "1308:      {",
          "1309:        int srclim = *src + currentDotslen;",
          "1310:        while (1)",
          "1311:   {",
          "1312:     if (!putCharacter (currentInput[*src], table, *src, srcmax, dest, destmax, mode, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase))",
          "1313:       goto failure;",
          "1314:     if (++(*src) == srclim)",
          "1315:       break;",
          "1317:      }",
          "1318:  }",
          "1321:       switch (currentOpcode)",
          "1322:  {",
          "1323:  case CTO_JoinNum:",
          "1324:  case CTO_JoinableWord:",
          "1325:    if (!insertSpace (table, *src, srcmax, dest, destmax, currentOutput, spacebuf, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase))",
          "1326:      goto failure;",
          "1327:    break;",
          "1328:  default:",
          "1329:    passSelectRule(table, *src, srcmax, currentPass, currentInput, &currentOpcode, &currentRule, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace);",
          "1330:    if (currentOpcode == CTO_Context)",
          "1331:      {",
          "1332:        back_passDoAction(table, *src, srcmax, dest, destmax, mode, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase, currentOpcode, currentRule, passSrc, passInstructions, passIC, startMatch, startReplace, &endReplace);",
          "1334:      }",
          "1335:    break;",
          "1336:  }",
          "1337:       if (((*src > 0) && checkAttr (currentInput[*src - 1], CTC_Space, 1, table)",
          "1338:     && (currentOpcode != CTO_JoinableWord)))",
          "1339:  {",
          "1340:    srcword = *src;",
          "1341:    destword = *dest;",
          "1342:  }",
          "1343:       if ((currentOpcode >= CTO_Always && currentOpcode <= CTO_None) ||",
          "1344:    (currentOpcode >= CTO_Digit && currentOpcode <= CTO_LitDigit))",
          "1345:  previousOpcode = currentOpcode;",
          "1349:   if (destword != 0 && *src < srcmax && !checkAttr (currentInput[*src],",
          "1350:          CTC_Space, 1, table))",
          "1351:     {",
          "1354:     }",
          "1355:   if (*src < srcmax)",
          "1356:     {",
          "1357:       while (checkAttr (currentInput[*src], CTC_Space, 1, table))",
          "1358:  if (++(*src) == srcmax)",
          "1359:    break;",
          "1360:     }",
          "1361:   return 1;",
          "1367: matchcurrentInput (const widechar *currentInput,",
          "1368:      int passSrc, const widechar *passInstructions, int passIC)",
          "1369: {",
          "1370:   int k;",
          "1371:   int kk = passSrc;",
          "1372:   for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)",
          "1373:     if (passInstructions[k] != currentInput[kk++])",
          "1374:       return 0;",
          "1375:   return 1;",
          "1379: back_swapTest (const TranslationTableHeader *table,",
          "1380:         const widechar *currentInput,",
          "1381:         int *passSrc,",
          "1382:         const widechar *passInstructions, int passIC)",
          "1383: {",
          "1384:   int curLen;",
          "1385:   int curTest;",
          "1386:   int curSrc = *passSrc;",
          "1387:   TranslationTableOffset swapRuleOffset;",
          "1388:   TranslationTableRule *swapRule;",
          "1389:   swapRuleOffset =",
          "1390:     (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];",
          "1391:   swapRule = (TranslationTableRule *) & table->ruleArea[swapRuleOffset];",
          "1392:   for (curLen = 0; curLen < passInstructions[passIC] + 3; curLen++)",
          "1393:     {",
          "1394:       for (curTest = 0; curTest < swapRule->charslen; curTest++)",
          "1395:  {",
          "1396:    if (currentInput[curSrc] == swapRule->charsdots[curTest])",
          "1397:      break;",
          "1399:       if (curTest == swapRule->charslen)",
          "1400:  return 0;",
          "1401:       curSrc++;",
          "1402:     }",
          "1403:   if (passInstructions[passIC + 2] == passInstructions[passIC + 3])",
          "1404:     {",
          "1406:       return 1;",
          "1407:     }",
          "1408:   while (curLen < passInstructions[passIC + 4])",
          "1409:     {",
          "1410:       for (curTest = 0; curTest < swapRule->charslen; curTest++)",
          "1411:  {",
          "1412:    if (currentInput[curSrc] != swapRule->charsdots[curTest])",
          "1413:      break;",
          "1415:       if (curTest < swapRule->charslen)",
          "1416:  if (curTest < swapRule->charslen)",
          "1417:    {",
          "1419:      return 1;",
          "1420:    }",
          "1421:       curSrc++;",
          "1422:       curLen++;",
          "1423:     }",
          "1425:   return 1;",
          "1429: back_swapReplace (int startSrc, int maxLen,",
          "1430:     const TranslationTableHeader *table,",
          "1431:     int *dest,",
          "1432:     int destmax,",
          "1433:     const widechar *currentInput,",
          "1434:     widechar *currentOutput,",
          "1435:     int *srcMapping,",
          "1436:     const widechar *passInstructions, int passIC)",
          "1437: {",
          "1438:   TranslationTableOffset swapRuleOffset;",
          "1439:   TranslationTableRule *swapRule;",
          "1440:   widechar *replacements;",
          "1441:   int curRep;",
          "1442:   int curPos;",
          "1443:   int lastPos = 0;",
          "1444:   int lastRep = 0;",
          "1445:   int curTest;",
          "1446:   int curSrc = startSrc;",
          "1447:   swapRuleOffset =",
          "1448:     (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];",
          "1449:   swapRule = (TranslationTableRule *) & table->ruleArea[swapRuleOffset];",
          "1450:   replacements = &swapRule->charsdots[swapRule->charslen];",
          "1451:   while (curSrc < maxLen)",
          "1452:     {",
          "1453:       for (curTest = 0; curTest < swapRule->charslen; curTest++)",
          "1454:  {",
          "1455:    if (currentInput[curSrc] == swapRule->charsdots[curTest])",
          "1456:      break;",
          "1458:       if (curTest == swapRule->charslen)",
          "1460:       if (curTest >= lastRep)",
          "1461:  {",
          "1462:    curPos = lastPos;",
          "1463:    curRep = lastRep;",
          "1464:  }",
          "1465:       else",
          "1466:  {",
          "1467:    curPos = 0;",
          "1468:    curRep = 0;",
          "1469:  }",
          "1470:       while (curPos < swapRule->dotslen)",
          "1471:  {",
          "1472:    if (curRep == curTest)",
          "1473:      {",
          "1474:        int k;",
          "1475:        if ((*dest + replacements[curPos] - 1) >= destmax)",
          "1476:   return 0;",
          "1477:        for (k = *dest + replacements[curPos] - 2; k >= *dest; --k)",
          "1478:   srcMapping[k] = srcMapping[curSrc];",
          "1479:        memcpy (&currentOutput[*dest], &replacements[curPos + 1],",
          "1480:         (replacements[curPos] - 1) * CHARSIZE);",
          "1482:        lastPos = curPos;",
          "1483:        lastRep = curRep;",
          "1484:        break;",
          "1485:      }",
          "1486:    curRep++;",
          "1487:    curPos += replacements[curPos];",
          "1488:  }",
          "1489:       curSrc++;",
          "1490:     }",
          "1491:   return curSrc;",
          "1495: back_passDoTest (const TranslationTableHeader *table,",
          "1496:    int src, int srcmax,",
          "1497:    const widechar *currentInput,",
          "1498:    TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,",
          "1499:    int *passSrc, const widechar **passInstructions, int *passIC,",
          "1500:    int *startMatch, int *startReplace, int *endReplace)",
          "1501: {",
          "1502:   int k;",
          "1503:   int m;",
          "1504:   int not = 0;",
          "1505:   TranslationTableCharacterAttributes attributes;",
          "1511:   if (currentOpcode == CTO_Correct)",
          "1512:     m = 0;",
          "1513:   else",
          "1514:     m = 1;",
          "1515:   while (*passIC < currentRule->dotslen)",
          "1516:     {",
          "1517:       int itsTrue = 1;",
          "1518:       if (*passSrc > srcmax)",
          "1519:  return 0;",
          "1520:       switch ((*passInstructions)[*passIC])",
          "1521:  {",
          "1522:  case pass_first:",
          "1523:    if (*passSrc != 0)",
          "1524:      itsTrue = 0;",
          "1525:    (*passIC)++;",
          "1526:    break;",
          "1527:  case pass_last:",
          "1528:    if (*passSrc != srcmax)",
          "1529:      itsTrue = 0;",
          "1530:    (*passIC)++;",
          "1531:    break;",
          "1532:  case pass_lookback:",
          "1534:    if (*passSrc < 0)",
          "1535:      {",
          "1537:        itsTrue = 0;",
          "1538:      }",
          "1540:    break;",
          "1541:  case pass_not:",
          "1542:    not = !not;",
          "1543:    (*passIC)++;",
          "1544:    continue;",
          "1545:  case pass_string:",
          "1546:  case pass_dots:",
          "1547:    itsTrue = matchcurrentInput (currentInput, *passSrc, *passInstructions, *passIC);",
          "1550:    break;",
          "1551:  case pass_startReplace:",
          "1553:    (*passIC)++;",
          "1554:    break;",
          "1555:  case pass_endReplace:",
          "1557:    (*passIC)++;",
          "1558:    break;",
          "1559:  case pass_attributes:",
          "1560:    attributes = ((*passInstructions)[*passIC + 1] << 16) |",
          "1561:          (*passInstructions)[*passIC + 2];",
          "1562:    for (k = 0;",
          "1563:         k < (*passInstructions)[*passIC + 3];",
          "1564:         k++)",
          "1565:      {",
          "1566:        if (*passSrc >= srcmax)",
          "1567:          {",
          "1568:     itsTrue = 0;",
          "1569:     break;",
          "1570:   }",
          "1571:        if (!(back_findCharOrDots(currentInput[*passSrc],",
          "1572:      m, table)->attributes & attributes))",
          "1573:   {",
          "1574:     itsTrue = 0;",
          "1575:     break;",
          "1577:        (*passSrc)++;",
          "1578:      }",
          "1579:    if (itsTrue)",
          "1580:      {",
          "1581:        for (k = (*passInstructions)[*passIC + 3];",
          "1582:      k < (*passInstructions)[*passIC + 4] && *passSrc < srcmax;",
          "1583:      k++)",
          "1584:   {",
          "1585:     if (!(back_findCharOrDots (currentInput[*passSrc],",
          "1586:           m, table)->attributes & attributes))",
          "1587:       break;",
          "1588:     (*passSrc)++;",
          "1590:      }",
          "1592:    break;",
          "1593:  case pass_swap:",
          "1594:    itsTrue = back_swapTest (table, currentInput, passSrc, *passInstructions, *passIC);",
          "1596:    break;",
          "1597:  case pass_endTest: {",
          "1598:    int endMatch;",
          "1599:    (*passIC)++;",
          "1600:    endMatch = *passSrc;",
          "1601:    if (*startReplace == -1)",
          "1602:      {",
          "1605:      }",
          "1606:    return 1;",
          "1607:    break;",
          "1608:  }",
          "1609:  default:",
          "1610:           if (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue))",
          "1611:             break;",
          "1612:    return 0;",
          "1614:       if ((!not && !itsTrue) || (not && itsTrue))",
          "1615:  return 0;",
          "1616:       not = 0;",
          "1617:     }",
          "1618:   return 1;",
          "1622: copyCharacters (int from, int to,",
          "1623:   const TranslationTableHeader *table,",
          "1624:   int src, int srcmax,",
          "1625:   int *dest,",
          "1626:   int destmax,",
          "1627:   int mode,",
          "1628:   const widechar *currentInput,",
          "1629:   widechar *currentOutput,",
          "1630:   int *srcMapping,",
          "1631:   int *outputPositions, int *inputPositions,",
          "1632:   int *cursorPosition, int *cursorStatus,",
          "1633:   int *nextUpper,",
          "1634:   int allUpper,",
          "1635:   int allUpperPhrase,",
          "1636:   TranslationTableOpcode currentOpcode)",
          "1637: {",
          "1638:   if (currentOpcode == CTO_Context)",
          "1639:     {",
          "1640:       while (from < to)",
          "1641:  if (!putCharacter(currentInput[from++], table, src, srcmax, dest, destmax, mode, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase))",
          "1642:    return 0;",
          "1643:     }",
          "1644:   else",
          "1645:     {",
          "1646:       int count = to - from;",
          "1648:       if (count > 0)",
          "1649:         {",
          "1650:    if ((*dest + count) > destmax)",
          "1651:      return 0;",
          "1653:    memmove(&srcMapping[*dest], &srcMapping[from],",
          "1654:     count * sizeof(*srcMapping));",
          "1655:    memcpy(&currentOutput[*dest], &currentInput[from],",
          "1656:           count * sizeof(*currentOutput));",
          "1659:     }",
          "1661:   return 1;",
          "1665: back_passDoAction (const TranslationTableHeader *table,",
          "1666:      int src, int srcmax,",
          "1667:      int *dest,",
          "1668:      int destmax,",
          "1669:      int mode,",
          "1670:      const widechar *currentInput,",
          "1671:      widechar *currentOutput,",
          "1672:      int *srcMapping,",
          "1673:      int *outputPositions, int *inputPositions,",
          "1674:      int *cursorPosition, int *cursorStatus,",
          "1675:      int *nextUpper,",
          "1676:      int allUpper, int allUpperPhrase,",
          "1677:      TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,",
          "1678:      int passSrc, const widechar *passInstructions, int passIC,",
          "1679:      int startMatch, int startReplace,",
          "1680:      int *endReplace)",
          "1681: {",
          "1682:   int k;",
          "1684:   int srcInitial = startMatch;",
          "1685:   int srcStart = startReplace;",
          "1686:   int srcEnd = *endReplace;",
          "1687:   int destInitial = *dest;",
          "1688:   int destStart;",
          "1690:   if (!copyCharacters(srcInitial, srcStart, table, src, srcmax, dest, destmax, mode, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase, currentOpcode))",
          "1691:     return 0;",
          "1692:   destStart = *dest;",
          "1694:   while (passIC < currentRule->dotslen)",
          "1695:     switch (passInstructions[passIC])",
          "1696:       {",
          "1697:       case pass_string:",
          "1698:       case pass_dots:",
          "1699:  if ((*dest + passInstructions[passIC + 1]) > destmax)",
          "1700:    return 0;",
          "1701:  for (k = 0; k < passInstructions[passIC + 1]; ++k)",
          "1702:    srcMapping[*dest + k] = startMatch;",
          "1703:  memcpy(&currentOutput[*dest], &passInstructions[passIC + 2],",
          "1704:         passInstructions[passIC + 1] * sizeof(*currentOutput));",
          "1706:  passIC += passInstructions[passIC + 1] + 2;",
          "1707:  break;",
          "1708:       case pass_swap:",
          "1709:  if (!back_swapReplace (startReplace, *endReplace - startReplace, table, dest, destmax, currentInput, currentOutput, srcMapping, passInstructions, passIC))",
          "1710:    return 0;",
          "1711:  passIC += 3;",
          "1712:  break;",
          "1713:       case pass_omit:",
          "1714:  passIC++;",
          "1715:  break;",
          "1716:       case pass_copy:",
          "1717:  {",
          "1718:    int count = destStart - destInitial;",
          "1720:    if (count > 0)",
          "1721:      {",
          "1722:        memmove(&currentOutput[destInitial], &currentOutput[destStart],",
          "1723:         count * sizeof(*currentOutput));",
          "1725:        destStart = destInitial;",
          "1726:      }",
          "1727:  }",
          "1729:         if (!copyCharacters(srcStart, srcEnd, table, src, srcmax, dest, destmax, mode, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase, currentOpcode))",
          "1730:           return 0;",
          "1732:  passIC++;",
          "1733:  break;",
          "1734:       default:",
          "1735:  if (_lou_handlePassVariableAction(passInstructions, &passIC))",
          "1736:    break;",
          "1737:  return 0;",
          "1738:       }",
          "1739:   return 1;",
          "1743: passSelectRule (const TranslationTableHeader *table,",
          "1744:   int src, int srcmax,",
          "1745:   int currentPass,",
          "1746:   const widechar *currentInput,",
          "1747:   TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule,",
          "1748:   int *passSrc, const widechar **passInstructions, int *passIC,",
          "1749:   int *startMatch, int *startReplace, int *endReplace)",
          "1750: {",
          "1751:   if (!findBackPassRule (table, src, srcmax, currentPass, currentInput, currentOpcode, currentRule, passSrc, passInstructions, passIC, startMatch, startReplace, endReplace))",
          "1752:     {",
          "1754:     }",
          "1758: translatePass (const TranslationTableHeader *table,",
          "1759:         int *src,",
          "1760:         int srcmax,",
          "1761:         int *dest,",
          "1762:         int destmax,",
          "1763:         int mode,",
          "1764:         int currentPass,",
          "1765:         const widechar *currentInput,",
          "1766:         widechar *currentOutput,",
          "1767:         int *srcMapping,",
          "1768:         int *outputPositions, int *inputPositions,",
          "1769:         int *cursorPosition, int *cursorStatus,",
          "1770:         const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "1771:         int maxAppliedRules)",
          "1772: {",
          "1773:   int nextUpper = 0;",
          "1774:   int allUpper = 0;",
          "1775:   int allUpperPhrase = 0;",
          "1777:   _lou_resetPassVariables();",
          "1778:   while (*src < srcmax)",
          "1780:       TranslationTableOpcode currentOpcode;",
          "1782:       int passSrc;",
          "1783:       const widechar *passInstructions;",
          "1785:       int startMatch;",
          "1786:       int startReplace;",
          "1787:       int endReplace;",
          "1788:       passSelectRule (table, *src, srcmax, currentPass, currentInput, &currentOpcode, &currentRule, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace);",
          "1789:       switch (currentOpcode)",
          "1790:  {",
          "1791:  case CTO_Pass2:",
          "1792:  case CTO_Pass3:",
          "1793:  case CTO_Pass4:",
          "1794:    if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)",
          "1795:      appliedRules[(*appliedRulesCount)++] = currentRule;",
          "1796:    if (!back_passDoAction (table, *src, srcmax, dest, destmax, mode, currentInput, currentOutput, srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus, &nextUpper, allUpper, allUpperPhrase, currentOpcode, currentRule, passSrc, passInstructions, passIC, startMatch, startReplace, &endReplace))",
          "1797:      goto failure;",
          "1799:    break;",
          "1800:  case CTO_Always:",
          "1801:    if ((*dest + 1) > destmax)",
          "1802:      goto failure;",
          "1803:    srcMapping[*dest] = srcMapping[*src];",
          "1804:    currentOutput[(*dest)++] = currentInput[(*src)++];",
          "1805:    break;",
          "1806:  default:",
          "1807:    goto failure;",
          "1809:     }",
          "1810:   srcMapping[*dest] = srcMapping[*src];",
          "1812:   if (*src < srcmax)",
          "1813:     {",
          "1814:       while (checkAttr (currentInput[*src], CTC_Space, 1, table))",
          "1815:  if (++(*src) == srcmax)",
          "1816:    break;",
          "1817:     }",
          "1818:   return 1;",
          "",
          "[Added Lines]",
          "36: static int",
          "37: backTranslateString(const TranslationTableHeader *table, int *src, int srcmax, int *dest,",
          "38:   int destmax, int mode, int currentPass, const widechar *currentInput,",
          "39:   widechar *currentOutput, char *spacebuf, int *srcMapping, int *outputPositions,",
          "40:   int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "41:   const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "42:   int maxAppliedRules);",
          "43: static int",
          "44: makeCorrections(const TranslationTableHeader *table, int *src, int srcmax, int *dest,",
          "45:   int destmax, int mode, int currentPass, const widechar *currentInput,",
          "46:   widechar *currentOutput, int *srcMapping, int *outputPositions,",
          "47:   int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "48:   const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "49:   int maxAppliedRules);",
          "50: static int",
          "51: translatePass(const TranslationTableHeader *table, int *src, int srcmax, int *dest,",
          "52:   int destmax, int mode, int currentPass, const widechar *currentInput,",
          "53:   widechar *currentOutput, int *srcMapping, int *outputPositions,",
          "54:   int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "55:   const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "56:   int maxAppliedRules);",
          "57: static void",
          "58: passSelectRule(const TranslationTableHeader *table, int src, int srcmax, int currentPass,",
          "59:   const widechar *currentInput, TranslationTableOpcode *currentOpcode,",
          "60:   const TranslationTableRule **currentRule, int *passSrc,",
          "61:   const widechar **passInstructions, int *passIC, int *startMatch,",
          "62:   int *startReplace, int *endReplace);",
          "65: lou_backTranslateString(const char *tableList, const widechar *inbuf, int *inlen,",
          "66:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int modex) {",
          "67:  return lou_backTranslate(tableList, inbuf, inlen, outbuf, outlen, typeform, spacing,",
          "68:    NULL, NULL, NULL, modex);",
          "72: lou_backTranslate(const char *tableList, const widechar *inbuf, int *inlen,",
          "73:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "74:   int *inputPos, int *cursorPos, int modex) {",
          "75:  return _lou_backTranslateWithTracing(tableList, inbuf, inlen, outbuf, outlen,",
          "76:    typeform, spacing, outputPos, inputPos, cursorPos, modex, NULL, NULL);",
          "80: doPasses(widechar *outbuf, const TranslationTableHeader *table, int *src, int *srcmax,",
          "81:   int *dest, int destmax, int mode, const widechar *currentInput,",
          "82:   widechar *passbuf1, widechar *passbuf2, char *spacebuf, int *srcMapping,",
          "83:   int *outputPositions, int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "84:   const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "85:   int maxAppliedRules) {",
          "86:  int currentPass;",
          "87:  widechar *currentOutput;",
          "88:  int firstPass = table->numPasses;",
          "89:  int lastPass = 1;",
          "91:  if (table->corrections) lastPass -= 1;",
          "93:  if (mode & pass1Only) {",
          "94:   firstPass = 1;",
          "95:   lastPass = 1;",
          "98:  currentPass = firstPass;",
          "100:  while (1) {",
          "101:   currentOutput = (currentPass == lastPass)",
          "102:     ? outbuf",
          "103:     : (currentInput == passbuf1) ? passbuf2 : passbuf1;",
          "105:   switch (currentPass) {",
          "106:   case 1:",
          "107:    if (!backTranslateString(table, src, *srcmax, dest, destmax, mode,",
          "108:       currentPass, currentInput, currentOutput, spacebuf, srcMapping,",
          "109:       outputPositions, inputPositions, cursorPosition, cursorStatus,",
          "110:       appliedRules, appliedRulesCount, maxAppliedRules))",
          "111:     return 0;",
          "112:    break;",
          "114:   case 0:",
          "115:    if (!makeCorrections(table, src, *srcmax, dest, destmax, mode, currentPass,",
          "116:       currentInput, currentOutput, srcMapping, outputPositions,",
          "117:       inputPositions, cursorPosition, cursorStatus, appliedRules,",
          "118:       appliedRulesCount, maxAppliedRules))",
          "119:     return 0;",
          "120:    break;",
          "122:   default:",
          "123:    if (!translatePass(table, src, *srcmax, dest, destmax, mode, currentPass,",
          "124:       currentInput, currentOutput, srcMapping, outputPositions,",
          "125:       inputPositions, cursorPosition, cursorStatus, appliedRules,",
          "126:       appliedRulesCount, maxAppliedRules))",
          "127:     return 0;",
          "128:    break;",
          "129:   }",
          "131:   if (currentPass == lastPass) return 1;",
          "133:   currentInput = currentOutput;",
          "135:   currentPass -= 1;",
          "136:  }",
          "140: _lou_backTranslateWithTracing(const char *tableList, const widechar *inbuf, int *inlen,",
          "141:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "142:   int *inputPos, int *cursorPos, int modex, const TranslationTableRule **rules,",
          "143:   int *rulesLen) {",
          "144:  int srcmax;",
          "145:  int src;",
          "146:  int dest;",
          "147:  int destmax;",
          "148:  int mode;",
          "149:  widechar *passbuf1 = NULL;",
          "150:  widechar *passbuf2 = NULL;",
          "151:  unsigned char *typebuf = NULL;",
          "152:  char *spacebuf;",
          "153:  int *srcMapping = NULL;",
          "154:  int *outputPositions;",
          "155:  int *inputPositions;",
          "156:  int cursorPosition;",
          "157:  int cursorStatus;",
          "158:  const TranslationTableRule **appliedRules;",
          "159:  int maxAppliedRules;",
          "160:  int appliedRulesCount;",
          "161:  int k;",
          "162:  int goodTrans = 1;",
          "163:  if (tableList == NULL || inbuf == NULL || inlen == NULL || outbuf == NULL ||",
          "164:    outlen == NULL)",
          "165:   return 0;",
          "166:  const TranslationTableHeader *table = lou_getTable(tableList);",
          "167:  if (table == NULL) return 0;",
          "168:  srcmax = 0;",
          "169:  while (srcmax < *inlen && inbuf[srcmax]) srcmax++;",
          "170:  destmax = *outlen;",
          "171:  typebuf = (unsigned char *)typeform;",
          "172:  spacebuf = spacing;",
          "173:  outputPositions = outputPos;",
          "174:  if (outputPos != NULL)",
          "175:   for (k = 0; k < srcmax; k++) outputPos[k] = -1;",
          "176:  inputPositions = inputPos;",
          "177:  if (cursorPos != NULL)",
          "178:   cursorPosition = *cursorPos;",
          "180:   cursorPosition = -1;",
          "181:  cursorStatus = 0;",
          "182:  mode = modex;",
          "183:  if (!(passbuf1 = _lou_allocMem(alloc_passbuf1, srcmax, destmax))) return 0;",
          "184:  if (typebuf != NULL) memset(typebuf, '0', destmax);",
          "185:  if (spacebuf != NULL) memset(spacebuf, '*', destmax);",
          "186:  for (k = 0; k < srcmax; k++)",
          "187:   if ((mode & dotsIO))",
          "188:    passbuf1[k] = inbuf[k] | 0x8000;",
          "189:   else",
          "190:    passbuf1[k] = _lou_getDotsForChar(inbuf[k]);",
          "191:  passbuf1[srcmax] = _lou_getDotsForChar(' ');",
          "192:  if (!(srcMapping = _lou_allocMem(alloc_srcMapping, srcmax, destmax))) return 0;",
          "193:  for (k = 0; k <= srcmax; k++) srcMapping[k] = k;",
          "194:  srcMapping[srcmax] = srcmax;",
          "195:  if ((!(mode & pass1Only)) && (table->numPasses > 1 || table->corrections)) {",
          "196:   if (!(passbuf2 = _lou_allocMem(alloc_passbuf2, srcmax, destmax))) return 0;",
          "197:  }",
          "198:  appliedRulesCount = 0;",
          "199:  if (rules != NULL && rulesLen != NULL) {",
          "200:   appliedRules = rules;",
          "201:   maxAppliedRules = *rulesLen;",
          "202:  } else {",
          "203:   appliedRules = NULL;",
          "204:   maxAppliedRules = 0;",
          "205:  }",
          "206:  goodTrans = doPasses(outbuf, table, &src, &srcmax, &dest, destmax, mode, passbuf1,",
          "207:    passbuf1, passbuf2, spacebuf, srcMapping, outputPositions, inputPositions,",
          "208:    &cursorPosition, &cursorStatus, appliedRules, &appliedRulesCount,",
          "209:    maxAppliedRules);",
          "210:  if (src < *inlen) *inlen = srcMapping[src];",
          "212:  if (outputPos != NULL) {",
          "213:   int lastpos = 0;",
          "214:   for (k = 0; k < *inlen; k++)",
          "215:    if (outputPos[k] == -1)",
          "216:     outputPos[k] = lastpos;",
          "217:    else",
          "218:     lastpos = outputPos[k];",
          "219:  }",
          "220:  if (cursorPos != NULL) *cursorPos = cursorPosition;",
          "221:  if (rulesLen != NULL) *rulesLen = appliedRulesCount;",
          "222:  return goodTrans;",
          "226: back_findCharOrDots(widechar c, int m, const TranslationTableHeader *table) {",
          "229:  static TranslationTableCharacter noChar = { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "230:  static TranslationTableCharacter noDots = { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "231:  TranslationTableCharacter *notFound;",
          "232:  TranslationTableCharacter *character;",
          "233:  TranslationTableOffset bucket;",
          "234:  unsigned long int makeHash = (unsigned long int)c % HASHNUM;",
          "235:  if (m == 0) {",
          "236:   bucket = table->characters[makeHash];",
          "237:   notFound = &noChar;",
          "238:  } else {",
          "239:   bucket = table->dots[makeHash];",
          "240:   notFound = &noDots;",
          "241:  }",
          "242:  while (bucket) {",
          "243:   character = (TranslationTableCharacter *)&table->ruleArea[bucket];",
          "244:   if (character->realchar == c) return character;",
          "245:   bucket = character->next;",
          "246:  }",
          "247:  notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "248:  return notFound;",
          "252: checkAttr(const widechar c, const TranslationTableCharacterAttributes a, int m,",
          "253:   const TranslationTableHeader *table) {",
          "254:  static widechar prevc = 0;",
          "255:  static TranslationTableCharacterAttributes preva = 0;",
          "256:  if (c != prevc) {",
          "257:   preva = (back_findCharOrDots(c, m, table))->attributes;",
          "258:   prevc = c;",
          "259:  }",
          "260:  return ((preva & a) ? 1 : 0);",
          "264: compareDots(const widechar *address1, const widechar *address2, int count) {",
          "265:  int k;",
          "266:  if (!count) return 0;",
          "267:  for (k = 0; k < count; k++)",
          "268:   if (address1[k] != address2[k]) return 0;",
          "269:  return 1;",
          "273: back_setBefore(const TranslationTableHeader *table, int dest, widechar *currentOutput,",
          "274:   TranslationTableCharacterAttributes *beforeAttributes) {",
          "275:  widechar before = (dest == 0) ? ' ' : currentOutput[dest - 1];",
          "280: back_setAfter(int length, const TranslationTableHeader *table, int src, int srcmax,",
          "281:   const widechar *currentInput,",
          "282:   TranslationTableCharacterAttributes *afterAttributes) {",
          "283:  widechar after = (src + length < srcmax) ? currentInput[src + length] : ' ';",
          "288: isBegWord(const TranslationTableHeader *table, int dest, widechar *currentOutput) {",
          "291:  int k;",
          "292:  if (dest == 0) return 1;",
          "293:  for (k = dest - 1; k >= 0; k--) {",
          "294:   const TranslationTableCharacter *ch =",
          "295:     back_findCharOrDots(currentOutput[k], 0, table);",
          "296:   if (ch->attributes & CTC_Space) break;",
          "297:   if (ch->attributes & (CTC_Letter | CTC_Digit | CTC_Math | CTC_Sign)) return 0;",
          "298:  }",
          "299:  return 1;",
          "303: isEndWord(const TranslationTableHeader *table, int src, int srcmax, int mode,",
          "304:   const widechar *currentInput, int currentDotslen) {",
          "305:  if (mode & partialTrans) return 0;",
          "307:  int k;",
          "308:  const TranslationTableCharacter *dots;",
          "309:  TranslationTableOffset testRuleOffset;",
          "310:  TranslationTableRule *testRule;",
          "311:  for (k = src + currentDotslen; k < srcmax; k++) {",
          "312:   int postpuncFound = 0;",
          "313:   int TranslationFound = 0;",
          "314:   dots = back_findCharOrDots(currentInput[k], 1, table);",
          "315:   testRuleOffset = dots->otherRules;",
          "316:   if (dots->attributes & CTC_Space) break;",
          "317:   if (dots->attributes & CTC_Letter) return 0;",
          "318:   while (testRuleOffset) {",
          "319:    testRule = (TranslationTableRule *)&table->ruleArea[testRuleOffset];",
          "324:    if (testRule->charslen > 1 && testRule->opcode != CTO_BegWord &&",
          "325:      testRule->opcode != CTO_MidWord)",
          "326:     TranslationFound = 1;",
          "327:    if (testRule->opcode == CTO_PostPunc) postpuncFound = 1;",
          "328:    if (testRule->opcode == CTO_Hyphen) return 1;",
          "329:    testRuleOffset = testRule->dotsnext;",
          "330:   }",
          "331:   if (TranslationFound && !postpuncFound) return 0;",
          "333:  return 1;",
          "336: findBrailleIndicatorRule(TranslationTableOffset offset,",
          "337:   const TranslationTableHeader *table, int *currentDotslen,",
          "338:   TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule) {",
          "339:  if (!offset) return 0;",
          "343:  return 1;",
          "347: handleMultind(const TranslationTableHeader *table, int *currentDotslen,",
          "348:   TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule,",
          "349:   int *doingMultind, const TranslationTableRule *multindRule) {",
          "351:  int found = 0;",
          "352:  if (!*doingMultind) return 0;",
          "353:  switch (multindRule->charsdots[multindRule->charslen - *doingMultind]) {",
          "354:  case CTO_CapsLetterRule:  // FIXME: make sure this works",
          "355:   found = findBrailleIndicatorRule(table->emphRules[capsRule][letterOffset], table,",
          "356:     currentDotslen, currentOpcode, currentRule);",
          "357:   break;",
          "366:  case CTO_BegCapsWordRule:",
          "367:   found = findBrailleIndicatorRule(table->emphRules[capsRule][begWordOffset], table,",
          "368:     currentDotslen, currentOpcode, currentRule);",
          "369:   break;",
          "370:  case CTO_EndCapsWordRule:",
          "371:   found = findBrailleIndicatorRule(table->emphRules[capsRule][endWordOffset], table,",
          "372:     currentDotslen, currentOpcode, currentRule);",
          "373:   break;",
          "374:  case CTO_LetterSign:",
          "375:   found = findBrailleIndicatorRule(",
          "376:     table->letterSign, table, currentDotslen, currentOpcode, currentRule);",
          "377:   break;",
          "378:  case CTO_NoContractSign:",
          "379:   found = findBrailleIndicatorRule(",
          "380:     table->noContractSign, table, currentDotslen, currentOpcode, currentRule);",
          "381:   break;",
          "382:  case CTO_NumberSign:",
          "383:   found = findBrailleIndicatorRule(",
          "384:     table->numberSign, table, currentDotslen, currentOpcode, currentRule);",
          "385:   break;",
          "386:  case CTO_EndEmph1PhraseBeforeRule:",
          "387:   found = findBrailleIndicatorRule(",
          "388:     table->emphRules[emph1Rule][endPhraseBeforeOffset], table, currentDotslen,",
          "389:     currentOpcode, currentRule);",
          "390:   break;",
          "391:  case CTO_BegEmph1Rule:",
          "392:   found = findBrailleIndicatorRule(table->emphRules[emph1Rule][begOffset], table,",
          "393:     currentDotslen, currentOpcode, currentRule);",
          "394:   break;",
          "395:  case CTO_EndEmph1Rule:",
          "396:   found = findBrailleIndicatorRule(table->emphRules[emph1Rule][endOffset], table,",
          "397:     currentDotslen, currentOpcode, currentRule);",
          "398:   break;",
          "399:  case CTO_EndEmph2PhraseBeforeRule:",
          "400:   found = findBrailleIndicatorRule(",
          "401:     table->emphRules[emph2Rule][endPhraseBeforeOffset], table, currentDotslen,",
          "402:     currentOpcode, currentRule);",
          "403:   break;",
          "404:  case CTO_BegEmph2Rule:",
          "405:   found = findBrailleIndicatorRule(table->emphRules[emph2Rule][begOffset], table,",
          "406:     currentDotslen, currentOpcode, currentRule);",
          "407:   break;",
          "408:  case CTO_EndEmph2Rule:",
          "409:   found = findBrailleIndicatorRule(table->emphRules[emph2Rule][endOffset], table,",
          "410:     currentDotslen, currentOpcode, currentRule);",
          "411:   break;",
          "412:  case CTO_EndEmph3PhraseBeforeRule:",
          "413:   found = findBrailleIndicatorRule(",
          "414:     table->emphRules[emph3Rule][endPhraseBeforeOffset], table, currentDotslen,",
          "415:     currentOpcode, currentRule);",
          "416:   break;",
          "417:  case CTO_BegEmph3Rule:",
          "418:   found = findBrailleIndicatorRule(table->emphRules[emph3Rule][begOffset], table,",
          "419:     currentDotslen, currentOpcode, currentRule);",
          "420:   break;",
          "421:  case CTO_EndEmph3Rule:",
          "422:   found = findBrailleIndicatorRule(table->emphRules[emph3Rule][endOffset], table,",
          "423:     currentDotslen, currentOpcode, currentRule);",
          "424:   break;",
          "425:  case CTO_BegComp:",
          "426:   found = findBrailleIndicatorRule(",
          "427:     table->begComp, table, currentDotslen, currentOpcode, currentRule);",
          "428:   break;",
          "429:  case CTO_EndComp:",
          "430:   found = findBrailleIndicatorRule(",
          "431:     table->endComp, table, currentDotslen, currentOpcode, currentRule);",
          "432:   break;",
          "433:  default:",
          "434:   found = 0;",
          "435:   break;",
          "436:  }",
          "437:  (*doingMultind)--;",
          "438:  return found;",
          "441: static int",
          "442: back_passDoTest(const TranslationTableHeader *table, int src, int srcmax,",
          "443:   const widechar *currentInput, TranslationTableOpcode currentOpcode,",
          "444:   const TranslationTableRule *currentRule, int *passSrc,",
          "445:   const widechar **passInstructions, int *passIC, int *startMatch,",
          "446:   int *startReplace, int *endReplace);",
          "447: static int",
          "448: back_passDoAction(const TranslationTableHeader *table, int src, int srcmax, int *dest,",
          "449:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "450:   int *srcMapping, int *outputPositions, int *inputPositions, int *cursorPosition,",
          "451:   int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase,",
          "452:   TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,",
          "453:   int passSrc, const widechar *passInstructions, int passIC, int startMatch,",
          "454:   int startReplace, int *endReplace);",
          "457: findBackPassRule(const TranslationTableHeader *table, int src, int srcmax,",
          "458:   int currentPass, const widechar *currentInput,",
          "459:   TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule,",
          "460:   int *passSrc, const widechar **passInstructions, int *passIC, int *startMatch,",
          "461:   int *startReplace, int *endReplace) {",
          "462:  TranslationTableOffset ruleOffset;",
          "463:  ruleOffset = table->backPassRules[currentPass];",
          "465:  while (ruleOffset) {",
          "469:   switch (*currentOpcode) {",
          "470:   case CTO_Correct:",
          "471:    if (currentPass != 0) goto NEXT_RULE;",
          "472:    break;",
          "473:   case CTO_Context:",
          "474:    if (currentPass != 1) goto NEXT_RULE;",
          "475:    break;",
          "476:   case CTO_Pass2:",
          "477:    if (currentPass != 2) goto NEXT_RULE;",
          "478:    break;",
          "479:   case CTO_Pass3:",
          "480:    if (currentPass != 3) goto NEXT_RULE;",
          "481:    break;",
          "482:   case CTO_Pass4:",
          "483:    if (currentPass != 4) goto NEXT_RULE;",
          "484:    break;",
          "485:   default:",
          "486:    goto NEXT_RULE;",
          "487:   }",
          "489:   if (back_passDoTest(table, src, srcmax, currentInput, *currentOpcode,",
          "491:      startReplace, endReplace))",
          "492:    return 1;",
          "494:  NEXT_RULE:",
          "495:   ruleOffset = (*currentRule)->dotsnext;",
          "496:  }",
          "498:  return 0;",
          "502: back_selectRule(const TranslationTableHeader *table, int src, int srcmax, int dest,",
          "503:   int mode, const widechar *currentInput, widechar *currentOutput, int itsANumber,",
          "504:   int itsALetter, int *currentDotslen, TranslationTableOpcode *currentOpcode,",
          "505:   const TranslationTableRule **currentRule, TranslationTableOpcode previousOpcode,",
          "506:   int *doingMultind, const TranslationTableRule **multindRule,",
          "507:   TranslationTableCharacterAttributes beforeAttributes, int *passSrc,",
          "508:   const widechar **passInstructions, int *passIC, int *startMatch,",
          "509:   int *startReplace, int *endReplace) {",
          "511:  int length = srcmax - src;",
          "512:  TranslationTableOffset ruleOffset = 0;",
          "513:  static TranslationTableRule pseudoRule = { 0 };",
          "514:  unsigned long int makeHash = 0;",
          "515:  const TranslationTableCharacter *dots =",
          "516:    back_findCharOrDots(currentInput[src], 1, table);",
          "517:  int tryThis;",
          "518:  if (handleMultind(table, currentDotslen, currentOpcode, currentRule, doingMultind,",
          "520:   return;",
          "521:  for (tryThis = 0; tryThis < 3; tryThis++) {",
          "522:   switch (tryThis) {",
          "523:   case 0:",
          "524:    if (length < 2 || (itsANumber && (dots->attributes & CTC_LitDigit))) break;",
          "526:    makeHash = (unsigned long int)dots->realchar << 8;",
          "527:    makeHash += (unsigned long int)(back_findCharOrDots(",
          "528:              currentInput[src + 1], 1, table))",
          "529:         ->realchar;",
          "530:    makeHash %= HASHNUM;",
          "531:    ruleOffset = table->backRules[makeHash];",
          "533:   case 1:",
          "534:    if (!(length >= 1)) break;",
          "535:    length = 1;",
          "536:    ruleOffset = dots->otherRules;",
          "542:    pseudoRule.charsdots[0] = currentInput[src];",
          "543:    pseudoRule.charslen = 0;",
          "546:   }",
          "547:   while (ruleOffset) {",
          "548:    const widechar *currentDots;",
          "551:    if (*currentOpcode == CTO_Context) {",
          "552:     currentDots = &(*currentRule)->charsdots[0];",
          "554:    } else {",
          "555:     currentDots = &(*currentRule)->charsdots[(*currentRule)->charslen];",
          "557:    }",
          "558:    if (((*currentDotslen <= length) &&",
          "559:       compareDots(&currentInput[src], currentDots, *currentDotslen))) {",
          "560:     TranslationTableCharacterAttributes afterAttributes;",
          "562:     back_setAfter(*currentDotslen, table, src, srcmax, currentInput,",
          "563:       &afterAttributes);",
          "564:     if ((!((*currentRule)->after & ~CTC_EmpMatch) ||",
          "565:        (beforeAttributes & (*currentRule)->after)) &&",
          "566:       (!((*currentRule)->before & ~CTC_EmpMatch) ||",
          "567:         (afterAttributes & (*currentRule)->before))) {",
          "569:      case CTO_Context:",
          "570:       if (back_passDoTest(table, src, srcmax, currentInput,",
          "572:          passInstructions, passIC, startMatch, startReplace,",
          "573:          endReplace))",
          "574:        return;",
          "576:      case CTO_Space:",
          "577:      case CTO_Digit:",
          "578:      case CTO_Letter:",
          "579:      case CTO_UpperCase:",
          "580:      case CTO_LowerCase:",
          "581:      case CTO_Punctuation:",
          "582:      case CTO_Math:",
          "583:      case CTO_Sign:",
          "584:      case CTO_ExactDots:",
          "585:      case CTO_NoCross:",
          "586:      case CTO_Repeated:",
          "587:      case CTO_Replace:",
          "588:      case CTO_Hyphen:",
          "589:       return;",
          "590:      case CTO_LitDigit:",
          "591:       if (itsANumber) return;",
          "592:       break;",
          "593:      case CTO_CapsLetterRule:",
          "594:      case CTO_BegCapsRule:",
          "595:      case CTO_EndCapsRule:",
          "596:      case CTO_BegCapsWordRule:",
          "597:      case CTO_EndCapsWordRule:",
          "598:      case CTO_BegEmph1Rule:",
          "599:      case CTO_EndEmph1Rule:",
          "600:      case CTO_BegEmph2Rule:",
          "601:      case CTO_EndEmph2Rule:",
          "602:      case CTO_BegEmph3Rule:",
          "603:      case CTO_EndEmph3Rule:",
          "604:      case CTO_NumberRule:",
          "605:      case CTO_BegCompRule:",
          "606:      case CTO_EndCompRule:",
          "607:       return;",
          "608:      case CTO_LetterRule:",
          "609:      case CTO_NoContractRule:",
          "619:       if (!(beforeAttributes & CTC_Letter) &&",
          "620:         (afterAttributes & (CTC_Letter | CTC_Sign)))",
          "621:        return;",
          "622:       break;",
          "623:      case CTO_MultInd:",
          "626:       if (handleMultind(table, currentDotslen, currentOpcode,",
          "627:          currentRule, doingMultind, *multindRule))",
          "628:        return;",
          "629:       break;",
          "630:      case CTO_LargeSign:",
          "631:       return;",
          "632:      case CTO_WholeWord:",
          "633:       if (mode & partialTrans) break;",
          "634:       if (itsALetter || itsANumber) break;",
          "635:      case CTO_Contraction:",
          "636:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&",
          "637:         ((afterAttributes & CTC_Space) ||",
          "638:           isEndWord(table, src, srcmax, mode, currentInput,",
          "640:        return;",
          "641:       break;",
          "642:      case CTO_LowWord:",
          "643:       if (mode & partialTrans) break;",
          "644:       if ((beforeAttributes & CTC_Space) &&",
          "645:         (afterAttributes & CTC_Space) &&",
          "646:         (previousOpcode != CTO_JoinableWord))",
          "647:        return;",
          "648:       break;",
          "649:      case CTO_JoinNum:",
          "650:      case CTO_JoinableWord:",
          "651:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&",
          "652:         (!(afterAttributes & CTC_Space) || mode & partialTrans))",
          "653:        return;",
          "654:       break;",
          "655:      case CTO_SuffixableWord:",
          "656:       if (beforeAttributes & (CTC_Space | CTC_Punctuation)) return;",
          "657:       break;",
          "658:      case CTO_PrefixableWord:",
          "659:       if ((beforeAttributes &",
          "660:          (CTC_Space | CTC_Letter | CTC_Punctuation)) &&",
          "661:         isEndWord(table, src, srcmax, mode, currentInput,",
          "663:        return;",
          "664:       break;",
          "665:      case CTO_BegWord:",
          "666:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&",
          "667:         (!isEndWord(table, src, srcmax, mode, currentInput,",
          "669:        return;",
          "670:       break;",
          "671:      case CTO_BegMidWord:",
          "672:       if ((beforeAttributes &",
          "673:          (CTC_Letter | CTC_Space | CTC_Punctuation)) &&",
          "674:         (!isEndWord(table, src, srcmax, mode, currentInput,",
          "676:        return;",
          "677:       break;",
          "678:      case CTO_PartWord:",
          "679:       if (!(beforeAttributes & CTC_LitDigit) &&",
          "680:         (beforeAttributes & CTC_Letter ||",
          "681:           !isEndWord(table, src, srcmax, mode, currentInput,",
          "683:        return;",
          "684:       break;",
          "685:      case CTO_MidWord:",
          "686:       if (beforeAttributes & CTC_Letter &&",
          "687:         !isEndWord(table, src, srcmax, mode, currentInput,",
          "689:        return;",
          "690:       break;",
          "691:      case CTO_MidEndWord:",
          "692:       if ((beforeAttributes & CTC_Letter)) return;",
          "693:       break;",
          "694:      case CTO_EndWord:",
          "695:       if ((beforeAttributes & CTC_Letter) &&",
          "696:         isEndWord(table, src, srcmax, mode, currentInput,",
          "698:        return;",
          "699:       break;",
          "700:      case CTO_BegNum:",
          "701:       if (beforeAttributes & (CTC_Space | CTC_Punctuation) &&",
          "702:         (afterAttributes & (CTC_LitDigit | CTC_Sign)))",
          "703:        return;",
          "704:       break;",
          "705:      case CTO_MidNum:",
          "706:       if (beforeAttributes & CTC_Digit &&",
          "707:         afterAttributes & CTC_LitDigit)",
          "708:        return;",
          "709:       break;",
          "710:      case CTO_EndNum:",
          "711:       if (itsANumber && !(afterAttributes & CTC_LitDigit)) return;",
          "712:       break;",
          "713:      case CTO_DecPoint:",
          "714:       if (afterAttributes & (CTC_Digit | CTC_LitDigit)) return;",
          "715:       break;",
          "716:      case CTO_PrePunc:",
          "717:       if (isBegWord(table, dest, currentOutput)) return;",
          "720:      case CTO_PostPunc:",
          "721:       if (isEndWord(table, src, srcmax, mode, currentInput,",
          "723:        return;",
          "724:       break;",
          "725:      case CTO_Always:",
          "726:       if ((beforeAttributes & CTC_LitDigit) &&",
          "727:         (afterAttributes & CTC_LitDigit) &&",
          "728:         (*currentRule)->charslen > 1)",
          "729:        break;",
          "730:       return;",
          "732:      case CTO_BackMatch: {",
          "733:       widechar *patterns, *pattern;",
          "740:       patterns = (widechar *)&table->ruleArea[(*currentRule)->patterns];",
          "743:       pattern = &patterns[1];",
          "744:       if (!_lou_pattern_check(",
          "745:          currentInput, src - 1, -1, -1, pattern, table))",
          "746:        break;",
          "749:       pattern = &patterns[patterns[0]];",
          "750:       if (!_lou_pattern_check(currentInput,",
          "751:          src + (*currentRule)->dotslen, srcmax, 1, pattern,",
          "752:          table))",
          "753:        break;",
          "755:       return;",
          "756:      }",
          "757:      default:",
          "758:       break;",
          "759:      }",
          "762:    ruleOffset = (*currentRule)->dotsnext;",
          "768: putchars(const widechar *chars, int count, const TranslationTableHeader *table, int *dest,",
          "769:   int destmax, widechar *currentOutput, int *nextUpper, int allUpper,",
          "770:   int allUpperPhrase) {",
          "771:  int k = 0;",
          "772:  if (!count || (*dest + count) > destmax) return 0;",
          "773:  if (*nextUpper) {",
          "774:   currentOutput[(*dest)++] = (back_findCharOrDots(chars[k++], 0, table))->uppercase;",
          "776:  }",
          "777:  if (!allUpper && !allUpperPhrase) {",
          "778:   memcpy(&currentOutput[*dest], &chars[k], CHARSIZE * (count - k));",
          "780:  } else",
          "781:   for (; k < count; k++)",
          "782:    currentOutput[(*dest)++] =",
          "783:      (back_findCharOrDots(chars[k], 0, table))->uppercase;",
          "784:  return 1;",
          "788: back_updatePositions(const widechar *outChars, int inLength, int outLength,",
          "789:   const TranslationTableHeader *table, int src, int srcmax, int *dest, int destmax,",
          "790:   widechar *currentOutput, int *srcMapping, int *outputPositions,",
          "791:   int *inputPositions, int *cursorPosition, int *cursorStatus, int *nextUpper,",
          "792:   int allUpper, int allUpperPhrase) {",
          "793:  int k;",
          "794:  if ((*dest + outLength) > destmax || (src + inLength) > srcmax) return 0;",
          "795:  if (!*cursorStatus && *cursorPosition >= src && *cursorPosition < (src + inLength)) {",
          "799:  if (inputPositions != NULL || outputPositions != NULL) {",
          "800:   if (outLength <= inLength) {",
          "801:    for (k = 0; k < outLength; k++) {",
          "802:     if (inputPositions != NULL)",
          "803:      inputPositions[*dest + k] = srcMapping[src + k];",
          "804:     if (outputPositions != NULL)",
          "805:      outputPositions[srcMapping[src + k]] = *dest + k;",
          "806:    }",
          "807:    for (k = outLength; k < inLength; k++)",
          "808:     if (outputPositions != NULL)",
          "809:      outputPositions[srcMapping[src + k]] = *dest + outLength - 1;",
          "810:   } else {",
          "811:    for (k = 0; k < inLength; k++) {",
          "812:     if (inputPositions != NULL)",
          "813:      inputPositions[*dest + k] = srcMapping[src + k];",
          "814:     if (outputPositions != NULL)",
          "815:      outputPositions[srcMapping[src + k]] = *dest + k;",
          "816:    }",
          "817:    for (k = inLength; k < outLength; k++)",
          "818:     if (inputPositions != NULL)",
          "819:      inputPositions[*dest + k] = srcMapping[src + inLength - 1];",
          "820:   }",
          "822:  return putchars(outChars, outLength, table, dest, destmax, currentOutput, nextUpper,",
          "823:    allUpper, allUpperPhrase);",
          "827: undefinedDots(widechar dots, int *dest, int destmax, int mode, widechar *currentOutput) {",
          "828:  if (mode & noUndefinedDots) return 1;",
          "830:  widechar buffer[20];",
          "831:  int k = 1;",
          "832:  buffer[0] = '\\\\';",
          "833:  if ((dots & B1)) buffer[k++] = '1';",
          "834:  if ((dots & B2)) buffer[k++] = '2';",
          "835:  if ((dots & B3)) buffer[k++] = '3';",
          "836:  if ((dots & B4)) buffer[k++] = '4';",
          "837:  if ((dots & B5)) buffer[k++] = '5';",
          "838:  if ((dots & B6)) buffer[k++] = '6';",
          "839:  if ((dots & B7)) buffer[k++] = '7';",
          "840:  if ((dots & B8)) buffer[k++] = '8';",
          "841:  if ((dots & B9)) buffer[k++] = '9';",
          "842:  if ((dots & B10)) buffer[k++] = 'A';",
          "843:  if ((dots & B11)) buffer[k++] = 'B';",
          "844:  if ((dots & B12)) buffer[k++] = 'C';",
          "845:  if ((dots & B13)) buffer[k++] = 'D';",
          "846:  if ((dots & B14)) buffer[k++] = 'E';",
          "847:  if ((dots & B15)) buffer[k++] = 'F';",
          "848:  buffer[k++] = '/';",
          "849:  if ((*dest + k) > destmax) return 0;",
          "850:  memcpy(&currentOutput[*dest], buffer, k * CHARSIZE);",
          "852:  return 1;",
          "856: putCharacter(widechar dots, const TranslationTableHeader *table, int src, int srcmax,",
          "857:   int *dest, int destmax, int mode, widechar *currentOutput, int *srcMapping,",
          "858:   int *outputPositions, int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "859:   int *nextUpper, int allUpper, int allUpperPhrase) {",
          "861:  TranslationTableOffset offset = (back_findCharOrDots(dots, 1, table))->definitionRule;",
          "862:  if (offset) {",
          "863:   widechar c;",
          "864:   const TranslationTableRule *rule =",
          "865:     (TranslationTableRule *)&table->ruleArea[offset];",
          "866:   if (rule->charslen)",
          "867:    return back_updatePositions(&rule->charsdots[0], rule->dotslen,",
          "868:      rule->charslen, table, src, srcmax, dest, destmax, currentOutput,",
          "869:      srcMapping, outputPositions, inputPositions, cursorPosition,",
          "870:      cursorStatus, nextUpper, allUpper, allUpperPhrase);",
          "871:   c = _lou_getCharFromDots(dots);",
          "872:   return back_updatePositions(&c, 1, 1, table, src, srcmax, dest, destmax,",
          "873:     currentOutput, srcMapping, outputPositions, inputPositions,",
          "874:     cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase);",
          "875:  }",
          "876:  return undefinedDots(dots, dest, destmax, mode, currentOutput);",
          "880: putCharacters(const widechar *characters, int count, const TranslationTableHeader *table,",
          "881:   int src, int srcmax, int *dest, int destmax, int mode, widechar *currentOutput,",
          "882:   int *srcMapping, int *outputPositions, int *inputPositions, int *cursorPosition,",
          "883:   int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase) {",
          "884:  int k;",
          "885:  for (k = 0; k < count; k++)",
          "886:   if (!putCharacter(characters[k], table, src, srcmax, dest, destmax, mode,",
          "887:      currentOutput, srcMapping, outputPositions, inputPositions,",
          "888:      cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase))",
          "889:    return 0;",
          "890:  return 1;",
          "894: insertSpace(const TranslationTableHeader *table, int src, int srcmax, int *dest,",
          "895:   int destmax, widechar *currentOutput, char *spacebuf, int *srcMapping,",
          "896:   int *outputPositions, int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "897:   int *nextUpper, int allUpper, int allUpperPhrase) {",
          "898:  widechar c = ' ';",
          "899:  if (!back_updatePositions(&c, 1, 1, table, src, srcmax, dest, destmax, currentOutput,",
          "900:     srcMapping, outputPositions, inputPositions, cursorPosition, cursorStatus,",
          "901:     nextUpper, allUpper, allUpperPhrase))",
          "902:   return 0;",
          "903:  if (spacebuf) spacebuf[*dest - 1] = '1';",
          "904:  return 1;",
          "908: compareChars(const widechar *address1, const widechar *address2, int count, int m,",
          "909:   const TranslationTableHeader *table) {",
          "910:  int k;",
          "911:  if (!count) return 0;",
          "912:  for (k = 0; k < count; k++)",
          "913:   if ((back_findCharOrDots(address1[k], m, table))->lowercase !=",
          "914:     (back_findCharOrDots(address2[k], m, table))->lowercase)",
          "915:    return 0;",
          "916:  return 1;",
          "920: makeCorrections(const TranslationTableHeader *table, int *src, int srcmax, int *dest,",
          "921:   int destmax, int mode, int currentPass, const widechar *currentInput,",
          "922:   widechar *currentOutput, int *srcMapping, int *outputPositions,",
          "923:   int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "924:   const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "925:   int maxAppliedRules) {",
          "926:  int nextUpper = 0;",
          "927:  int allUpper = 0;",
          "928:  int allUpperPhrase = 0;",
          "929:  if (!table->corrections) return 1;",
          "932:  _lou_resetPassVariables();",
          "933:  while (*src < srcmax) {",
          "934:   TranslationTableOpcode currentOpcode;",
          "936:   int passSrc;",
          "937:   const widechar *passInstructions;",
          "939:   int startMatch;",
          "940:   int startReplace;",
          "941:   int endReplace;",
          "942:   int length = srcmax - *src;",
          "943:   const TranslationTableCharacter *character =",
          "944:     back_findCharOrDots(currentInput[*src], 0, table);",
          "945:   const TranslationTableCharacter *character2;",
          "946:   int tryThis = 0;",
          "947:   if (!findBackPassRule(table, *src, srcmax, currentPass, currentInput,",
          "948:      &currentOpcode, &currentRule, &passSrc, &passInstructions, &passIC,",
          "949:      &startMatch, &startReplace, &endReplace))",
          "950:    while (tryThis < 3) {",
          "951:     TranslationTableOffset ruleOffset = 0;",
          "952:     unsigned long int makeHash = 0;",
          "953:     switch (tryThis) {",
          "954:     case 0:",
          "955:      if (!(length >= 2)) break;",
          "956:      makeHash = (unsigned long int)character->lowercase << 8;",
          "957:      character2 = back_findCharOrDots(currentInput[*src + 1], 0, table);",
          "958:      makeHash += (unsigned long int)character2->lowercase;",
          "959:      makeHash %= HASHNUM;",
          "960:      ruleOffset = table->forRules[makeHash];",
          "961:      break;",
          "962:     case 1:",
          "963:      if (!(length >= 1)) break;",
          "964:      length = 1;",
          "965:      ruleOffset = character->otherRules;",
          "966:      break;",
          "968:      currentOpcode = CTO_Always;",
          "969:      ruleOffset = 0;",
          "970:      break;",
          "971:     }",
          "972:     while (ruleOffset) {",
          "973:      currentRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];",
          "974:      currentOpcode = currentRule->opcode;",
          "975:      int currentCharslen = currentRule->charslen;",
          "976:      if (tryThis == 1 || (currentCharslen <= length &&",
          "977:             compareChars(&currentRule->charsdots[0],",
          "978:               &currentInput[*src],",
          "979:               currentCharslen, 0, table))) {",
          "980:       if (currentOpcode == CTO_Correct &&",
          "981:         back_passDoTest(table, *src, srcmax, currentInput,",
          "982:           currentOpcode, currentRule, &passSrc,",
          "983:           &passInstructions, &passIC, &startMatch,",
          "984:           &startReplace, &endReplace)) {",
          "985:        tryThis = 4;",
          "986:        break;",
          "987:       }",
          "988:      }",
          "989:      ruleOffset = currentRule->dotsnext;",
          "990:     }",
          "991:     tryThis++;",
          "992:    }",
          "993:   switch (currentOpcode) {",
          "994:   case CTO_Always:",
          "995:    if (*dest >= destmax) goto failure;",
          "996:    srcMapping[*dest] = srcMapping[*src];",
          "997:    currentOutput[(*dest)++] = currentInput[(*src)++];",
          "999:   case CTO_Correct:",
          "1000:    if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)",
          "1001:     appliedRules[(*appliedRulesCount)++] = currentRule;",
          "1002:    if (!back_passDoAction(table, *src, srcmax, dest, destmax, mode, currentInput,",
          "1003:       currentOutput, srcMapping, outputPositions, inputPositions,",
          "1004:       cursorPosition, cursorStatus, &nextUpper, allUpper,",
          "1005:       allUpperPhrase, currentOpcode, currentRule, passSrc,",
          "1006:       passInstructions, passIC, startMatch, startReplace, &endReplace))",
          "1007:     goto failure;",
          "1009:    break;",
          "1010:   default:",
          "1011:    break;",
          "1012:   }",
          "1015:  return 1;",
          "1019: backTranslateString(const TranslationTableHeader *table, int *src, int srcmax, int *dest,",
          "1020:   int destmax, int mode, int currentPass, const widechar *currentInput,",
          "1021:   widechar *currentOutput, char *spacebuf, int *srcMapping, int *outputPositions,",
          "1022:   int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "1023:   const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "1024:   int maxAppliedRules) {",
          "1025:  int nextUpper;",
          "1026:  int allUpper;",
          "1027:  int allUpperPhrase;",
          "1028:  int itsANumber;",
          "1029:  int itsALetter;",
          "1031:  int srcword = 0;",
          "1033:  TranslationTableOpcode previousOpcode;",
          "1034:  int doingMultind = 0;",
          "1035:  const TranslationTableRule *multindRule;",
          "1036:  _lou_resetPassVariables();",
          "1037:  translation_direction = 0;",
          "1038:  nextUpper = allUpper = allUpperPhrase = itsANumber = itsALetter = 0;",
          "1039:  previousOpcode = CTO_None;",
          "1041:  while (*src < srcmax) {",
          "1044:   TranslationTableOpcode currentOpcode;",
          "1046:   TranslationTableCharacterAttributes beforeAttributes;",
          "1047:   int passSrc;",
          "1048:   const widechar *passInstructions;",
          "1050:   int startMatch;",
          "1051:   int startReplace;",
          "1052:   int endReplace;",
          "1053:   back_setBefore(table, *dest, currentOutput, &beforeAttributes);",
          "1054:   back_selectRule(table, *src, srcmax, *dest, mode, currentInput, currentOutput,",
          "1055:     itsANumber, itsALetter, &currentDotslen, &currentOpcode, &currentRule,",
          "1056:     previousOpcode, &doingMultind, &multindRule, beforeAttributes, &passSrc,",
          "1057:     &passInstructions, &passIC, &startMatch, &startReplace, &endReplace);",
          "1058:   if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)",
          "1059:    appliedRules[(*appliedRulesCount)++] = currentRule;",
          "1061:   switch (currentOpcode) {",
          "1062:   case CTO_Hyphen:",
          "1063:    itsANumber = 0;",
          "1064:    break;",
          "1065:   case CTO_LargeSign:",
          "1066:    if (previousOpcode == CTO_LargeSign)",
          "1067:     if (!insertSpace(table, *src, srcmax, dest, destmax, currentOutput,",
          "1068:        spacebuf, srcMapping, outputPositions, inputPositions,",
          "1069:        cursorPosition, cursorStatus, &nextUpper, allUpper,",
          "1070:        allUpperPhrase))",
          "1071:      goto failure;",
          "1072:    break;",
          "1073:   case CTO_CapsLetterRule:",
          "1074:    nextUpper = 1;",
          "1076:    continue;",
          "1077:    break;",
          "1078:   case CTO_BegCapsWordRule:",
          "1079:    allUpper = 1;",
          "1081:    continue;",
          "1082:    break;",
          "1083:   case CTO_BegCapsRule:",
          "1084:    allUpperPhrase = 1;",
          "1086:    continue;",
          "1087:    break;",
          "1088:   case CTO_EndCapsWordRule:",
          "1089:    allUpper = 0;",
          "1091:    continue;",
          "1092:    break;",
          "1093:   case CTO_EndCapsRule:",
          "1094:    allUpperPhrase = 0;",
          "1096:    continue;",
          "1097:    break;",
          "1098:   case CTO_LetterRule:",
          "1099:   case CTO_NoContractRule:",
          "1100:    itsALetter = 1;",
          "1101:    itsANumber = 0;",
          "1103:    continue;",
          "1104:    break;",
          "1105:   case CTO_NumberRule:",
          "1106:    itsANumber = 1;",
          "1108:    continue;",
          "1109:    break;",
          "1110:   case CTO_BegEmph1Rule:",
          "1112:    continue;",
          "1113:    break;",
          "1114:   case CTO_BegEmph2Rule:",
          "1116:    continue;",
          "1117:    break;",
          "1118:   case CTO_BegEmph3Rule:",
          "1120:    continue;",
          "1121:    break;",
          "1122:   case CTO_EndEmph1Rule:",
          "1123:   case CTO_EndEmph2Rule:",
          "1124:   case CTO_EndEmph3Rule:",
          "1126:    continue;",
          "1127:    break;",
          "1128:   case CTO_BegCompRule:",
          "1130:    continue;",
          "1131:    break;",
          "1132:   case CTO_EndCompRule:",
          "1134:    continue;",
          "1135:    break;",
          "1137:   default:",
          "1138:    break;",
          "1139:   }",
          "1142:   switch (currentOpcode) {",
          "1143:   case CTO_Context:",
          "1144:    if (!back_passDoAction(table, *src, srcmax, dest, destmax, mode, currentInput,",
          "1145:       currentOutput, srcMapping, outputPositions, inputPositions,",
          "1146:       cursorPosition, cursorStatus, &nextUpper, allUpper,",
          "1147:       allUpperPhrase, currentOpcode, currentRule, passSrc,",
          "1148:       passInstructions, passIC, startMatch, startReplace, &endReplace))",
          "1149:     return 0;",
          "1151:    break;",
          "1152:   case CTO_Replace:",
          "1154:    if (!putCharacters(&currentRule->charsdots[0], currentRule->charslen, table,",
          "1156:       outputPositions, inputPositions, cursorPosition, cursorStatus,",
          "1157:       &nextUpper, allUpper, allUpperPhrase))",
          "1158:     goto failure;",
          "1159:    break;",
          "1160:   case CTO_None:",
          "1161:    if (!undefinedDots(currentInput[*src], dest, destmax, mode, currentOutput))",
          "1162:     goto failure;",
          "1163:    (*src)++;",
          "1164:    break;",
          "1165:   case CTO_BegNum:",
          "1166:    itsANumber = 1;",
          "1167:    goto insertChars;",
          "1168:   case CTO_EndNum:",
          "1169:    itsANumber = 0;",
          "1170:    goto insertChars;",
          "1171:   case CTO_Space:",
          "1172:    itsALetter = itsANumber = allUpper = nextUpper = 0;",
          "1173:    goto insertChars;",
          "1174:   default:",
          "1175:   insertChars:",
          "1176:    if (currentRule->charslen) {",
          "1177:     if (!back_updatePositions(&currentRule->charsdots[0],",
          "1178:        currentRule->dotslen, currentRule->charslen, table, *src,",
          "1179:        srcmax, dest, destmax, currentOutput, srcMapping,",
          "1180:        outputPositions, inputPositions, cursorPosition, cursorStatus,",
          "1181:        &nextUpper, allUpper, allUpperPhrase))",
          "1182:      goto failure;",
          "1184:    } else {",
          "1185:     int srclim = *src + currentDotslen;",
          "1186:     while (1) {",
          "1187:      if (!putCharacter(currentInput[*src], table, *src, srcmax, dest,",
          "1188:         destmax, mode, currentOutput, srcMapping, outputPositions,",
          "1189:         inputPositions, cursorPosition, cursorStatus, &nextUpper,",
          "1190:         allUpper, allUpperPhrase))",
          "1191:       goto failure;",
          "1192:      if (++(*src) == srclim) break;",
          "1193:     }",
          "1194:    }",
          "1198:   switch (currentOpcode) {",
          "1199:   case CTO_JoinNum:",
          "1200:   case CTO_JoinableWord:",
          "1201:    if (!insertSpace(table, *src, srcmax, dest, destmax, currentOutput, spacebuf,",
          "1202:       srcMapping, outputPositions, inputPositions, cursorPosition,",
          "1203:       cursorStatus, &nextUpper, allUpper, allUpperPhrase))",
          "1204:     goto failure;",
          "1205:    break;",
          "1206:   default:",
          "1207:    passSelectRule(table, *src, srcmax, currentPass, currentInput, &currentOpcode,",
          "1208:      &currentRule, &passSrc, &passInstructions, &passIC, &startMatch,",
          "1209:      &startReplace, &endReplace);",
          "1210:    if (currentOpcode == CTO_Context) {",
          "1211:     back_passDoAction(table, *src, srcmax, dest, destmax, mode, currentInput,",
          "1212:       currentOutput, srcMapping, outputPositions, inputPositions,",
          "1213:       cursorPosition, cursorStatus, &nextUpper, allUpper,",
          "1214:       allUpperPhrase, currentOpcode, currentRule, passSrc,",
          "1215:       passInstructions, passIC, startMatch, startReplace, &endReplace);",
          "1217:    }",
          "1218:    break;",
          "1219:   }",
          "1220:   if (((*src > 0) && checkAttr(currentInput[*src - 1], CTC_Space, 1, table) &&",
          "1221:      (currentOpcode != CTO_JoinableWord))) {",
          "1222:    srcword = *src;",
          "1223:    destword = *dest;",
          "1224:   }",
          "1225:   if ((currentOpcode >= CTO_Always && currentOpcode <= CTO_None) ||",
          "1226:     (currentOpcode >= CTO_Digit && currentOpcode <= CTO_LitDigit))",
          "1227:    previousOpcode = currentOpcode;",
          "1231:  if (destword != 0 && *src < srcmax &&",
          "1232:    !checkAttr(currentInput[*src], CTC_Space, 1, table)) {",
          "1235:  }",
          "1236:  if (*src < srcmax) {",
          "1237:   while (checkAttr(currentInput[*src], CTC_Space, 1, table))",
          "1238:    if (++(*src) == srcmax) break;",
          "1239:  }",
          "1240:  return 1;",
          "1246: matchcurrentInput(const widechar *currentInput, int passSrc,",
          "1247:   const widechar *passInstructions, int passIC) {",
          "1248:  int k;",
          "1249:  int kk = passSrc;",
          "1250:  for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)",
          "1251:   if (passInstructions[k] != currentInput[kk++]) return 0;",
          "1252:  return 1;",
          "1256: back_swapTest(const TranslationTableHeader *table, const widechar *currentInput,",
          "1257:   int *passSrc, const widechar *passInstructions, int passIC) {",
          "1258:  int curLen;",
          "1259:  int curTest;",
          "1260:  int curSrc = *passSrc;",
          "1261:  TranslationTableOffset swapRuleOffset;",
          "1262:  TranslationTableRule *swapRule;",
          "1263:  swapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];",
          "1264:  swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];",
          "1265:  for (curLen = 0; curLen < passInstructions[passIC] + 3; curLen++) {",
          "1266:   for (curTest = 0; curTest < swapRule->charslen; curTest++) {",
          "1267:    if (currentInput[curSrc] == swapRule->charsdots[curTest]) break;",
          "1268:   }",
          "1269:   if (curTest == swapRule->charslen) return 0;",
          "1270:   curSrc++;",
          "1272:  if (passInstructions[passIC + 2] == passInstructions[passIC + 3]) {",
          "1274:   return 1;",
          "1276:  while (curLen < passInstructions[passIC + 4]) {",
          "1277:   for (curTest = 0; curTest < swapRule->charslen; curTest++) {",
          "1278:    if (currentInput[curSrc] != swapRule->charsdots[curTest]) break;",
          "1279:   }",
          "1280:   if (curTest < swapRule->charslen)",
          "1281:    if (curTest < swapRule->charslen) {",
          "1283:     return 1;",
          "1284:    }",
          "1285:   curSrc++;",
          "1286:   curLen++;",
          "1287:  }",
          "1289:  return 1;",
          "1293: back_swapReplace(int startSrc, int maxLen, const TranslationTableHeader *table, int *dest,",
          "1294:   int destmax, const widechar *currentInput, widechar *currentOutput,",
          "1295:   int *srcMapping, const widechar *passInstructions, int passIC) {",
          "1296:  TranslationTableOffset swapRuleOffset;",
          "1297:  TranslationTableRule *swapRule;",
          "1298:  widechar *replacements;",
          "1299:  int curRep;",
          "1300:  int curPos;",
          "1301:  int lastPos = 0;",
          "1302:  int lastRep = 0;",
          "1303:  int curTest;",
          "1304:  int curSrc = startSrc;",
          "1305:  swapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];",
          "1306:  swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];",
          "1307:  replacements = &swapRule->charsdots[swapRule->charslen];",
          "1308:  while (curSrc < maxLen) {",
          "1309:   for (curTest = 0; curTest < swapRule->charslen; curTest++) {",
          "1310:    if (currentInput[curSrc] == swapRule->charsdots[curTest]) break;",
          "1311:   }",
          "1312:   if (curTest == swapRule->charslen) return curSrc;",
          "1313:   if (curTest >= lastRep) {",
          "1314:    curPos = lastPos;",
          "1315:    curRep = lastRep;",
          "1316:   } else {",
          "1317:    curPos = 0;",
          "1318:    curRep = 0;",
          "1319:   }",
          "1320:   while (curPos < swapRule->dotslen) {",
          "1321:    if (curRep == curTest) {",
          "1322:     int k;",
          "1323:     if ((*dest + replacements[curPos] - 1) >= destmax) return 0;",
          "1324:     for (k = *dest + replacements[curPos] - 2; k >= *dest; --k)",
          "1325:      srcMapping[k] = srcMapping[curSrc];",
          "1326:     memcpy(&currentOutput[*dest], &replacements[curPos + 1],",
          "1327:       (replacements[curPos] - 1) * CHARSIZE);",
          "1329:     lastPos = curPos;",
          "1330:     lastRep = curRep;",
          "1331:     break;",
          "1332:    }",
          "1333:    curRep++;",
          "1334:    curPos += replacements[curPos];",
          "1335:   }",
          "1336:   curSrc++;",
          "1342: back_passDoTest(const TranslationTableHeader *table, int src, int srcmax,",
          "1343:   const widechar *currentInput, TranslationTableOpcode currentOpcode,",
          "1344:   const TranslationTableRule *currentRule, int *passSrc,",
          "1345:   const widechar **passInstructions, int *passIC, int *startMatch,",
          "1346:   int *startReplace, int *endReplace) {",
          "1347:  int k;",
          "1348:  int m;",
          "1349:  int not = 0;",
          "1350:  TranslationTableCharacterAttributes attributes;",
          "1356:  if (currentOpcode == CTO_Correct)",
          "1357:   m = 0;",
          "1358:  else",
          "1359:   m = 1;",
          "1360:  while (*passIC < currentRule->dotslen) {",
          "1361:   int itsTrue = 1;",
          "1362:   if (*passSrc > srcmax) return 0;",
          "1363:   switch ((*passInstructions)[*passIC]) {",
          "1364:   case pass_first:",
          "1365:    if (*passSrc != 0) itsTrue = 0;",
          "1366:    (*passIC)++;",
          "1367:    break;",
          "1368:   case pass_last:",
          "1369:    if (*passSrc != srcmax) itsTrue = 0;",
          "1370:    (*passIC)++;",
          "1371:    break;",
          "1372:   case pass_lookback:",
          "1374:    if (*passSrc < 0) {",
          "1376:     itsTrue = 0;",
          "1377:    }",
          "1379:    break;",
          "1380:   case pass_not:",
          "1381:    not = !not;",
          "1382:    (*passIC)++;",
          "1383:    continue;",
          "1384:   case pass_string:",
          "1385:   case pass_dots:",
          "1386:    itsTrue =",
          "1387:      matchcurrentInput(currentInput, *passSrc, *passInstructions, *passIC);",
          "1390:    break;",
          "1391:   case pass_startReplace:",
          "1393:    (*passIC)++;",
          "1394:    break;",
          "1395:   case pass_endReplace:",
          "1397:    (*passIC)++;",
          "1398:    break;",
          "1399:   case pass_attributes:",
          "1400:    attributes = ((*passInstructions)[*passIC + 1] << 16) |",
          "1401:      (*passInstructions)[*passIC + 2];",
          "1402:    for (k = 0; k < (*passInstructions)[*passIC + 3]; k++) {",
          "1403:     if (*passSrc >= srcmax) {",
          "1404:      itsTrue = 0;",
          "1405:      break;",
          "1406:     }",
          "1407:     if (!(back_findCharOrDots(currentInput[*passSrc], m, table)->attributes &",
          "1408:        attributes)) {",
          "1409:      itsTrue = 0;",
          "1410:      break;",
          "1411:     }",
          "1412:     (*passSrc)++;",
          "1413:    }",
          "1414:    if (itsTrue) {",
          "1415:     for (k = (*passInstructions)[*passIC + 3];",
          "1416:       k < (*passInstructions)[*passIC + 4] && *passSrc < srcmax; k++) {",
          "1417:      if (!(back_findCharOrDots(currentInput[*passSrc], m,",
          "1418:           table)->attributes &",
          "1419:         attributes))",
          "1420:       break;",
          "1421:      (*passSrc)++;",
          "1422:     }",
          "1423:    }",
          "1425:    break;",
          "1426:   case pass_swap:",
          "1427:    itsTrue = back_swapTest(",
          "1428:      table, currentInput, passSrc, *passInstructions, *passIC);",
          "1430:    break;",
          "1431:   case pass_endTest: {",
          "1432:    int endMatch;",
          "1433:    (*passIC)++;",
          "1434:    endMatch = *passSrc;",
          "1435:    if (*startReplace == -1) {",
          "1438:    }",
          "1439:    return 1;",
          "1440:    break;",
          "1442:   default:",
          "1443:    if (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue)) break;",
          "1444:    return 0;",
          "1446:   if ((!not&&!itsTrue) || (not&&itsTrue)) return 0;",
          "1447:   not = 0;",
          "1449:  return 1;",
          "1453: copyCharacters(int from, int to, const TranslationTableHeader *table, int src, int srcmax,",
          "1454:   int *dest, int destmax, int mode, const widechar *currentInput,",
          "1455:   widechar *currentOutput, int *srcMapping, int *outputPositions,",
          "1456:   int *inputPositions, int *cursorPosition, int *cursorStatus, int *nextUpper,",
          "1457:   int allUpper, int allUpperPhrase, TranslationTableOpcode currentOpcode) {",
          "1458:  if (currentOpcode == CTO_Context) {",
          "1459:   while (from < to)",
          "1460:    if (!putCharacter(currentInput[from++], table, src, srcmax, dest, destmax,",
          "1461:       mode, currentOutput, srcMapping, outputPositions, inputPositions,",
          "1462:       cursorPosition, cursorStatus, nextUpper, allUpper,",
          "1463:       allUpperPhrase))",
          "1464:     return 0;",
          "1465:  } else {",
          "1466:   int count = to - from;",
          "1468:   if (count > 0) {",
          "1469:    if ((*dest + count) > destmax) return 0;",
          "1471:    memmove(&srcMapping[*dest], &srcMapping[from], count * sizeof(*srcMapping));",
          "1472:    memcpy(&currentOutput[*dest], &currentInput[from],",
          "1473:      count * sizeof(*currentOutput));",
          "1475:   }",
          "1478:  return 1;",
          "1482: back_passDoAction(const TranslationTableHeader *table, int src, int srcmax, int *dest,",
          "1483:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "1484:   int *srcMapping, int *outputPositions, int *inputPositions, int *cursorPosition,",
          "1485:   int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase,",
          "1486:   TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,",
          "1487:   int passSrc, const widechar *passInstructions, int passIC, int startMatch,",
          "1488:   int startReplace, int *endReplace) {",
          "1489:  int k;",
          "1491:  int srcInitial = startMatch;",
          "1492:  int srcStart = startReplace;",
          "1493:  int srcEnd = *endReplace;",
          "1494:  int destInitial = *dest;",
          "1495:  int destStart;",
          "1497:  if (!copyCharacters(srcInitial, srcStart, table, src, srcmax, dest, destmax, mode,",
          "1498:     currentInput, currentOutput, srcMapping, outputPositions, inputPositions,",
          "1499:     cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase,",
          "1500:     currentOpcode))",
          "1501:   return 0;",
          "1502:  destStart = *dest;",
          "1504:  while (passIC < currentRule->dotslen) switch (passInstructions[passIC]) {",
          "1505:   case pass_string:",
          "1506:   case pass_dots:",
          "1507:    if ((*dest + passInstructions[passIC + 1]) > destmax) return 0;",
          "1508:    for (k = 0; k < passInstructions[passIC + 1]; ++k)",
          "1509:     srcMapping[*dest + k] = startMatch;",
          "1510:    memcpy(&currentOutput[*dest], &passInstructions[passIC + 2],",
          "1511:      passInstructions[passIC + 1] * sizeof(*currentOutput));",
          "1513:    passIC += passInstructions[passIC + 1] + 2;",
          "1514:    break;",
          "1515:   case pass_swap:",
          "1516:    if (!back_swapReplace(startReplace, *endReplace - startReplace, table, dest,",
          "1517:       destmax, currentInput, currentOutput, srcMapping,",
          "1518:       passInstructions, passIC))",
          "1519:     return 0;",
          "1520:    passIC += 3;",
          "1521:    break;",
          "1522:   case pass_omit:",
          "1523:    passIC++;",
          "1524:    break;",
          "1525:   case pass_copy: {",
          "1526:    int count = destStart - destInitial;",
          "1528:    if (count > 0) {",
          "1529:     memmove(&currentOutput[destInitial], &currentOutput[destStart],",
          "1530:       count * sizeof(*currentOutput));",
          "1532:     destStart = destInitial;",
          "1533:    }",
          "1534:   }",
          "1536:    if (!copyCharacters(srcStart, srcEnd, table, src, srcmax, dest, destmax, mode,",
          "1537:       currentInput, currentOutput, srcMapping, outputPositions,",
          "1538:       inputPositions, cursorPosition, cursorStatus, nextUpper, allUpper,",
          "1539:       allUpperPhrase, currentOpcode))",
          "1540:     return 0;",
          "1542:    passIC++;",
          "1543:    break;",
          "1544:   default:",
          "1545:    if (_lou_handlePassVariableAction(passInstructions, &passIC)) break;",
          "1546:    return 0;",
          "1547:   }",
          "1548:  return 1;",
          "1552: passSelectRule(const TranslationTableHeader *table, int src, int srcmax, int currentPass,",
          "1553:   const widechar *currentInput, TranslationTableOpcode *currentOpcode,",
          "1554:   const TranslationTableRule **currentRule, int *passSrc,",
          "1555:   const widechar **passInstructions, int *passIC, int *startMatch,",
          "1556:   int *startReplace, int *endReplace) {",
          "1557:  if (!findBackPassRule(table, src, srcmax, currentPass, currentInput, currentOpcode,",
          "1558:     currentRule, passSrc, passInstructions, passIC, startMatch, startReplace,",
          "1559:     endReplace)) {",
          "1561:  }",
          "1565: translatePass(const TranslationTableHeader *table, int *src, int srcmax, int *dest,",
          "1566:   int destmax, int mode, int currentPass, const widechar *currentInput,",
          "1567:   widechar *currentOutput, int *srcMapping, int *outputPositions,",
          "1568:   int *inputPositions, int *cursorPosition, int *cursorStatus,",
          "1569:   const TranslationTableRule **appliedRules, int *appliedRulesCount,",
          "1570:   int maxAppliedRules) {",
          "1571:  int nextUpper = 0;",
          "1572:  int allUpper = 0;",
          "1573:  int allUpperPhrase = 0;",
          "1575:  _lou_resetPassVariables();",
          "1577:   TranslationTableOpcode currentOpcode;",
          "1579:   int passSrc;",
          "1580:   const widechar *passInstructions;",
          "1582:   int startMatch;",
          "1583:   int startReplace;",
          "1584:   int endReplace;",
          "1585:   passSelectRule(table, *src, srcmax, currentPass, currentInput, &currentOpcode,",
          "1586:     &currentRule, &passSrc, &passInstructions, &passIC, &startMatch,",
          "1587:     &startReplace, &endReplace);",
          "1588:   switch (currentOpcode) {",
          "1589:   case CTO_Pass2:",
          "1590:   case CTO_Pass3:",
          "1591:   case CTO_Pass4:",
          "1592:    if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)",
          "1593:     appliedRules[(*appliedRulesCount)++] = currentRule;",
          "1594:    if (!back_passDoAction(table, *src, srcmax, dest, destmax, mode, currentInput,",
          "1595:       currentOutput, srcMapping, outputPositions, inputPositions,",
          "1596:       cursorPosition, cursorStatus, &nextUpper, allUpper,",
          "1597:       allUpperPhrase, currentOpcode, currentRule, passSrc,",
          "1598:       passInstructions, passIC, startMatch, startReplace, &endReplace))",
          "1599:     goto failure;",
          "1601:    break;",
          "1602:   case CTO_Always:",
          "1603:    if ((*dest + 1) > destmax) goto failure;",
          "1604:    srcMapping[*dest] = srcMapping[*src];",
          "1605:    currentOutput[(*dest)++] = currentInput[(*src)++];",
          "1606:    break;",
          "1607:   default:",
          "1608:    goto failure;",
          "1609:   }",
          "1611:  srcMapping[*dest] = srcMapping[*src];",
          "1613:  if (*src < srcmax) {",
          "1614:   while (checkAttr(currentInput[*src], CTC_Space, 1, table))",
          "1615:    if (++(*src) == srcmax) break;",
          "1616:  }",
          "1617:  return 1;",
          "",
          "---------------"
        ],
        "liblouis/lou_translateString.c||liblouis/lou_translateString.c": [
          "File: liblouis/lou_translateString.c -> liblouis/lou_translateString.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #define SYLLABLE_MARKER_1 0x2000",
          "40: #define SYLLABLE_MARKER_2 0x4000",
          "115: static const TranslationTableRule **appliedRules;",
          "116: static int maxAppliedRules;",
          "117: static int appliedRulesCount;",
          "119: static TranslationTableCharacter *",
          "152: }",
          "154: static int",
          "167: }",
          "169: static int",
          "171:   const TranslationTableCharacterAttributes a, int m,",
          "177: }",
          "179: static int",
          "207: }",
          "209: static int",
          "222: }",
          "224: static int",
          "311:    break;",
          "339:  }",
          "353: failure:",
          "356: }",
          "358: static int",
          "369: }",
          "371: static int",
          "421:  }",
          "429:  }",
          "434:  }",
          "440: }",
          "442: static int",
          "495:  }",
          "498: }",
          "500: static int",
          "557:  }",
          "564: }",
          "566: static int",
          "609:  }",
          "618: }",
          "620: static int",
          "705:    }",
          "753:   }",
          "764:  }",
          "768: }",
          "770: static int",
          "882:   }",
          "932:  }",
          "934:  return 0;",
          "938: }",
          "940: static int",
          "978:  }",
          "982: }",
          "984: static int",
          "1088: }",
          "1090: static void",
          "1105: }",
          "1107: static int",
          "1168:  }",
          "1178: }",
          "1206: int EXPORT_CALL",
          "1216: }",
          "1218: int EXPORT_CALL",
          "1227: }",
          "1229: int EXPORT_CALL",
          "1296:    typebuf[k] = typeform[k];",
          "1299:   }",
          "1305:   memset(wordBuffer, 0, (srcmax + 4) * sizeof(unsigned int));",
          "1306:  else",
          "1307:   return 0;",
          "1309:   memset(emphasisBuffer, 0, (srcmax + 4) * sizeof(unsigned int));",
          "1310:  else",
          "1311:   return 0;",
          "1313:   memset(transNoteBuffer, 0, (srcmax + 4) * sizeof(unsigned int));",
          "1314:  else",
          "1315:   return 0;",
          "1347:  }",
          "1437:  }",
          "1460:  }",
          "1473:  }",
          "1493: }",
          "1495: int EXPORT_CALL",
          "1515:  }",
          "1531:   }",
          "1538:  }",
          "1543: }",
          "1545: static int",
          "1598:   }",
          "1619:  }",
          "1625: }",
          "1643: static int",
          "1715:  }",
          "1719: }",
          "1721: static int",
          "1768: }",
          "1771: static void",
          "1783: }",
          "1785: static void",
          "1798: }",
          "1800: static int",
          "1809: }",
          "1811: static int",
          "1856:  }",
          "1860: }",
          "1862: static int",
          "1883: }",
          "1935:  }",
          "1965:   ok = 0;",
          "2046: }",
          "2048: static int",
          "2066:  return 1;",
          "2071: }",
          "2073: static int",
          "2094:  return 0;",
          "2097: }",
          "2099: static int",
          "2182:   }",
          "2185:  }",
          "2188: }",
          "2190: static int",
          "2214: }",
          "2216: static int",
          "2227:  return 0;",
          "2228: }",
          "2230: static int",
          "2236:  int i, j, s, match;",
          "2246:    return 0;",
          "2247:   break;",
          "2248:  }",
          "2256:    match = 0;",
          "2265:        match = 1;",
          "2268:        match = -1;",
          "2269:        j = i - 1;",
          "2270:       }",
          "2271:      }",
          "2280:       i = j;",
          "2281:       break;",
          "2282:      }",
          "2283:     }",
          "2291:        match = 1;",
          "2294:        match = -1;",
          "2295:        j = i - 1;",
          "2296:       }",
          "2297:      }",
          "2298:     }",
          "2305:       match = 0;",
          "2306:       j = i - 1;",
          "2307:      }",
          "2308:     }",
          "2309:    }",
          "2310:   }",
          "2315:    return 0;",
          "2316:   break;",
          "2317:  }",
          "2319:  return 1;",
          "2320: }",
          "2322: static void",
          "2339:   TranslationTableCharacterAttributes beforeAttributes,",
          "2351:  TranslationTableOffset ruleOffset = 0;",
          "2448:       break;",
          "2480:       break;",
          "2485:        return;",
          "2650:       break;",
          "2652:       break;",
          "2675:  }",
          "2677: }",
          "2679: static int",
          "2718: }",
          "2720: static int",
          "2738:  const TranslationTableRule *rule = NULL;",
          "",
          "[Removed Lines]",
          "41: #define CAPSEMPH          0x8000",
          "43: #define EMPHASIS 0x3fff // all typeform bits that can be used",
          "46: #define WORD_CHAR         0x00000001",
          "47: #define WORD_RESET        0x00000002",
          "48: #define WORD_STOP         0x00000004",
          "49: #define WORD_WHOLE        0x00000008",
          "50: #define LAST_WORD_AFTER   0x01000000",
          "53: #define CAPS_BEGIN        0x00000010",
          "54: #define CAPS_END          0x00000020",
          "55: #define CAPS_WORD         0x00000040",
          "56: #define CAPS_SYMBOL       0x00000080",
          "57: #define CAPS_EMPHASIS     0x000000f0",
          "58: #define EMPHASIS_BEGIN    0x00000100",
          "59: #define EMPHASIS_END      0x00000200",
          "60: #define EMPHASIS_WORD     0x00000400",
          "61: #define EMPHASIS_SYMBOL   0x00000800",
          "62: #define EMPHASIS_MASK     0x00000f00",
          "63: #define COMPBRL_BEGIN     0x10000000",
          "64: #define COMPBRL_END       0x20000000",
          "67: #define TRANSNOTE_BEGIN    0x00000001",
          "68: #define TRANSNOTE_END      0x00000002",
          "69: #define TRANSNOTE_WORD     0x00000004",
          "70: #define TRANSNOTE_SYMBOL   0x00000008",
          "71: #define TRANSNOTE_MASK     0x0000000f",
          "73: static int putCharacter (widechar c,",
          "74:     const TranslationTableHeader *table,",
          "75:     int *src, int *dest,",
          "76:     int srcmax, int destmax,",
          "77:     int mode,",
          "78:     const widechar *currentInput,",
          "79:     widechar *currentOutput,",
          "80:     int *srcMapping,",
          "81:     int *prevSrcMapping,",
          "82:     unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "83:     const TranslationTableRule **transRule,",
          "84:     int *inputPositions,",
          "85:     int *outputPositions,",
          "86:     int *cursorPosition, int *cursorStatus,",
          "87:     int compbrlStart, int compbrlEnd);",
          "88: static int passDoTest (const TranslationTableHeader *table,",
          "89:          int src, int srcmax,",
          "90:          const widechar *currentInput,",
          "91:          int transOpcode,",
          "92:          const TranslationTableRule *transRule,",
          "93:          int *passCharDots, int *passSrc, const widechar **passInstructions, int *passIC, int *startMatch, int *startReplace, int *endReplace,",
          "94:          TranslationTableRule **groupingRule, widechar *groupingOp);",
          "95: static int passDoAction (const TranslationTableHeader *table,",
          "96:     int *src, int *dest, int *srcmax,",
          "97:     int destmax,",
          "98:     int mode,",
          "99:     const widechar *currentInput,",
          "100:     widechar *currentOutput,",
          "101:     int *srcMapping,",
          "102:     int *prevSrcMapping,",
          "103:     unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "104:     int transOpcode,",
          "105:     const TranslationTableRule **transRule,",
          "106:     int passCharDots, int passSrc, const widechar *passInstructions, int startMatch, int startReplace,",
          "107:     int *passIC,",
          "108:     int *endReplace,",
          "109:     int *inputPositions,",
          "110:     int *outputPositions,",
          "111:     int *cursorPosition, int *cursorStatus,",
          "112:     int compbrlStart, int compbrlEnd,",
          "113:     TranslationTableRule *groupingRule, widechar groupingOp);",
          "120: findCharOrDots (widechar c, int m,",
          "121:   const TranslationTableHeader *table)",
          "122: {",
          "125:   static TranslationTableCharacter noChar =",
          "126:     { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "127:   static TranslationTableCharacter noDots =",
          "128:     { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "129:   TranslationTableCharacter *notFound;",
          "130:   TranslationTableCharacter *character;",
          "131:   TranslationTableOffset bucket;",
          "132:   unsigned long int makeHash = (unsigned long int) c % HASHNUM;",
          "133:   if (m == 0)",
          "134:     {",
          "135:       bucket = table->characters[makeHash];",
          "136:       notFound = &noChar;",
          "137:     }",
          "138:   else",
          "139:     {",
          "140:       bucket = table->dots[makeHash];",
          "141:       notFound = &noDots;",
          "142:     }",
          "143:   while (bucket)",
          "144:     {",
          "145:       character = (TranslationTableCharacter *) & table->ruleArea[bucket];",
          "146:       if (character->realchar == c)",
          "147:  return character;",
          "148:       bucket = character->next;",
          "149:     }",
          "150:   notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "151:   return notFound;",
          "155: checkAttr (const widechar c, const TranslationTableCharacterAttributes",
          "156:     a, int m,",
          "157:     const TranslationTableHeader *table)",
          "158: {",
          "159:   static widechar prevc = 0;",
          "160:   static TranslationTableCharacterAttributes preva = 0;",
          "161:   if (c != prevc)",
          "162:     {",
          "163:       preva = (findCharOrDots (c, m, table))->attributes;",
          "164:       prevc = c;",
          "165:     }",
          "166:   return ((preva & a) ? 1 : 0);",
          "170: checkAttr_safe (const widechar *currentInput, int src,",
          "172:   const TranslationTableHeader *table,",
          "173:   int srcmax",
          "174:   )",
          "175: {",
          "176:   return ((src < srcmax) ? checkAttr(currentInput[src], a, m, table) : 0);",
          "180: findForPassRule (const TranslationTableHeader *table,",
          "181:    int src, int srcmax,",
          "182:    int currentPass,",
          "183:    const widechar *currentInput,",
          "184:    int *transOpcode, const TranslationTableRule **transRule,",
          "185:    int *transCharslen,",
          "186:    int *passCharDots, int *passSrc, widechar const **passInstructions, int *passIC, int *startMatch, int *startReplace, int *endReplace,",
          "187:    TranslationTableRule **groupingRule, widechar *groupingOp)",
          "188: {",
          "189:   int save_transCharslen = *transCharslen;",
          "190:   const TranslationTableRule *save_transRule = *transRule;",
          "191:   TranslationTableOpcode save_transOpcode = *transOpcode;",
          "192:   TranslationTableOffset ruleOffset;",
          "193:   ruleOffset = table->forPassRules[currentPass];",
          "195:   while (ruleOffset)",
          "196:     {",
          "199:       if (passDoTest (table, src, srcmax, currentInput, *transOpcode, *transRule, passCharDots, passSrc, passInstructions, passIC, startMatch, startReplace, endReplace, groupingRule, groupingOp))",
          "200:  return 1;",
          "201:       ruleOffset = (*transRule)->charsnext;",
          "202:     }",
          "206:   return 0;",
          "210: compareChars (const widechar * address1, const widechar * address2, int",
          "211:        count, int m,",
          "212:        const TranslationTableHeader *table)",
          "213: {",
          "214:   int k;",
          "215:   if (!count)",
          "216:     return 0;",
          "217:   for (k = 0; k < count; k++)",
          "218:     if ((findCharOrDots (address1[k], m, table))->lowercase !=",
          "219:  (findCharOrDots (address2[k], m, table))->lowercase)",
          "220:       return 0;",
          "221:   return 1;",
          "225: makeCorrections (const TranslationTableHeader *table,",
          "226:    int *dest, int *srcmax,",
          "227:    int destmax,",
          "228:    int mode,",
          "229:    const widechar *currentInput,",
          "230:    widechar *currentOutput,",
          "231:    int *srcMapping,",
          "232:    int *prevSrcMapping,",
          "233:    formtype *typebuf,",
          "234:    unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "235:    int *realInlen,",
          "236:    int *srcIncremented,",
          "237:    int *inputPositions,",
          "238:    int *outputPositions,",
          "239:    int *cursorPosition, int *cursorStatus,",
          "240:    int compbrlStart, int compbrlEnd)",
          "241: {",
          "242:   int src;",
          "243:   int transOpcode;",
          "244:   const TranslationTableRule *transRule;",
          "245:   int transCharslen;",
          "246:   int passCharDots;",
          "247:   int passSrc;",
          "248:   const widechar *passInstructions;",
          "250:   int startMatch;",
          "251:   int startReplace;",
          "252:   int endReplace;",
          "253:   TranslationTableRule *groupingRule;",
          "254:   widechar groupingOp;",
          "255:   if (!table->corrections)",
          "256:     return 1;",
          "257:   src = 0;",
          "260:   _lou_resetPassVariables();",
          "261:   while (src < *srcmax)",
          "262:     {",
          "263:       int length = *srcmax - src;",
          "264:       const TranslationTableCharacter *character = findCharOrDots",
          "265:  (currentInput[src], 0, table);",
          "266:       const TranslationTableCharacter *character2;",
          "267:       int tryThis = 0;",
          "268:       if (!findForPassRule (table, src, *srcmax, 0, currentInput, &transOpcode, &transRule, &transCharslen, &passCharDots, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace, &groupingRule, &groupingOp))",
          "269:  while (tryThis < 3)",
          "270:    {",
          "271:      TranslationTableOffset ruleOffset = 0;",
          "272:      unsigned long int makeHash = 0;",
          "273:      switch (tryThis)",
          "274:        {",
          "275:        case 0:",
          "276:   if (!(length >= 2))",
          "277:     break;",
          "278:   makeHash = (unsigned long int) character->lowercase << 8;",
          "279:   character2 = findCharOrDots (currentInput[src + 1], 0, table);",
          "280:   makeHash += (unsigned long int) character2->lowercase;",
          "281:   makeHash %= HASHNUM;",
          "282:   ruleOffset = table->forRules[makeHash];",
          "283:   break;",
          "284:        case 1:",
          "285:   if (!(length >= 1))",
          "286:     break;",
          "287:   length = 1;",
          "288:   ruleOffset = character->otherRules;",
          "289:   break;",
          "291:   transOpcode = CTO_Always;",
          "292:   ruleOffset = 0;",
          "293:   break;",
          "294:        }",
          "295:      while (ruleOffset)",
          "296:        {",
          "297:   transRule =",
          "298:     (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "299:   transOpcode = transRule->opcode;",
          "300:   transCharslen = transRule->charslen;",
          "301:   if (tryThis == 1 || (transCharslen <= length &&",
          "302:          compareChars (&transRule->",
          "303:          charsdots[0],",
          "304:          &currentInput[src],",
          "305:          transCharslen, 0, table)))",
          "306:     {",
          "307:       if (*srcIncremented && transOpcode == CTO_Correct &&",
          "308:    passDoTest (table, src, *srcmax, currentInput, transOpcode, transRule, &passCharDots, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace, &groupingRule, &groupingOp))",
          "309:         {",
          "310:    tryThis = 4;",
          "312:         }",
          "313:     }",
          "314:   ruleOffset = transRule->charsnext;",
          "315:        }",
          "316:      tryThis++;",
          "317:    }",
          "320:       switch (transOpcode)",
          "321:  {",
          "322:  case CTO_Always:",
          "323:    if (*dest >= destmax)",
          "324:      goto failure;",
          "325:    srcMapping[*dest] = prevSrcMapping[src];",
          "326:    currentOutput[(*dest)++] = currentInput[src++];",
          "327:    break;",
          "328:  case CTO_Correct:",
          "329:    if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "330:      appliedRules[appliedRulesCount++] = transRule;",
          "331:    if (!passDoAction (table, &src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transOpcode, &transRule, passCharDots, passSrc, passInstructions, startMatch, startReplace, &passIC, &endReplace, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd, groupingRule, groupingOp))",
          "332:      goto failure;",
          "333:    if (endReplace == src)",
          "335:    src = endReplace;",
          "336:    break;",
          "337:  default:",
          "338:    break;",
          "340:     }",
          "342:   { // We have to transform typebuf accordingly",
          "343:     int pos;",
          "344:     formtype *typebuf_temp;",
          "345:     if ((typebuf_temp = malloc (*dest * sizeof (formtype))) == NULL)",
          "346:       _lou_outOfMemory ();",
          "347:     for (pos = 0; pos < *dest; pos++)",
          "348:       typebuf_temp[pos] = typebuf[srcMapping[pos]];",
          "349:     memcpy (typebuf, typebuf_temp, *dest * sizeof (formtype));",
          "350:     free (typebuf_temp);",
          "351:   }",
          "355:   return 1;",
          "359: matchCurrentInput (const widechar *currentInput,",
          "360:      int passSrc, const widechar *passInstructions, int passIC)",
          "361: {",
          "362:   int k;",
          "363:   int kk = passSrc;",
          "364:   for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)",
          "365:     if (currentInput[kk] == ENDSEGMENT || passInstructions[k] !=",
          "366:  currentInput[kk++])",
          "367:       return 0;",
          "368:   return 1;",
          "372: swapTest (int swapIC, int *callSrc,",
          "373:    const TranslationTableHeader *table,",
          "374:    const widechar *currentInput,",
          "375:    const widechar *passInstructions)",
          "376: {",
          "377:   int curLen;",
          "378:   int curTest;",
          "379:   int curSrc = *callSrc;",
          "380:   TranslationTableOffset swapRuleOffset;",
          "381:   TranslationTableRule *swapRule;",
          "382:   swapRuleOffset =",
          "383:     (passInstructions[swapIC + 1] << 16) | passInstructions[swapIC + 2];",
          "384:   swapRule = (TranslationTableRule *) & table->ruleArea[swapRuleOffset];",
          "385:   for (curLen = 0; curLen < passInstructions[swapIC + 3]; curLen++)",
          "386:     {",
          "387:       if (swapRule->opcode == CTO_SwapDd)",
          "388:  {",
          "389:    for (curTest = 1; curTest < swapRule->charslen; curTest += 2)",
          "390:      {",
          "391:        if (currentInput[curSrc] == swapRule->charsdots[curTest])",
          "392:   break;",
          "393:      }",
          "394:  }",
          "395:       else",
          "396:  {",
          "397:    for (curTest = 0; curTest < swapRule->charslen; curTest++)",
          "398:      {",
          "399:        if (currentInput[curSrc] == swapRule->charsdots[curTest])",
          "400:   break;",
          "401:      }",
          "402:  }",
          "403:       if (curTest >= swapRule->charslen)",
          "404:  return 0;",
          "405:       curSrc++;",
          "406:     }",
          "407:   if (passInstructions[swapIC + 3] == passInstructions[swapIC + 4])",
          "408:     {",
          "410:       return 1;",
          "411:     }",
          "412:   while (curLen < passInstructions[swapIC + 4])",
          "413:     {",
          "414:       if (swapRule->opcode == CTO_SwapDd)",
          "415:  {",
          "416:    for (curTest = 1; curTest < swapRule->charslen; curTest += 2)",
          "417:      {",
          "418:        if (currentInput[curSrc] == swapRule->charsdots[curTest])",
          "419:   break;",
          "420:      }",
          "422:       else",
          "423:  {",
          "424:    for (curTest = 0; curTest < swapRule->charslen; curTest++)",
          "425:      {",
          "426:        if (currentInput[curSrc] == swapRule->charsdots[curTest])",
          "427:   break;",
          "428:      }",
          "430:       if (curTest >= swapRule->charslen)",
          "431:  {",
          "433:    return 1;",
          "435:       curSrc++;",
          "436:       curLen++;",
          "437:     }",
          "439:   return 1;",
          "443: swapReplace (int start, int end,",
          "444:       const TranslationTableHeader *table,",
          "445:       int *dest,",
          "446:       int destmax,",
          "447:       const widechar *currentInput,",
          "448:       widechar *currentOutput,",
          "449:       int *srcMapping,",
          "450:       int *prevSrcMapping,",
          "451:       const widechar *passInstructions, int passIC)",
          "452: {",
          "453:   TranslationTableOffset swapRuleOffset;",
          "454:   TranslationTableRule *swapRule;",
          "455:   widechar *replacements;",
          "456:   int curRep;",
          "457:   int curPos;",
          "458:   int curTest;",
          "459:   int curSrc;",
          "460:   swapRuleOffset =",
          "461:     (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];",
          "462:   swapRule = (TranslationTableRule *) & table->ruleArea[swapRuleOffset];",
          "463:   replacements = &swapRule->charsdots[swapRule->charslen];",
          "464:   for (curSrc = start; curSrc < end; curSrc++)",
          "465:     {",
          "466:       for (curTest = 0; curTest < swapRule->charslen; curTest++)",
          "467:  if (currentInput[curSrc] == swapRule->charsdots[curTest])",
          "468:    break;",
          "469:       if (curTest == swapRule->charslen)",
          "470:  continue;",
          "471:       curPos = 0;",
          "472:       for (curRep = 0; curRep < curTest; curRep++)",
          "473:  if (swapRule->opcode == CTO_SwapCc)",
          "474:    curPos++;",
          "475:  else",
          "476:    curPos += replacements[curPos];",
          "477:       if (swapRule->opcode == CTO_SwapCc)",
          "478:  {",
          "479:    if ((*dest + 1) > destmax)",
          "480:      return 0;",
          "481:    srcMapping[*dest] = prevSrcMapping[curSrc];",
          "482:    currentOutput[(*dest)++] = replacements[curPos];",
          "483:  }",
          "484:       else",
          "485:  {",
          "486:    int l = replacements[curPos] - 1;",
          "487:    int d = *dest + l;",
          "488:    if (d > destmax)",
          "489:      return 0;",
          "490:    while (--d >= *dest)",
          "491:      srcMapping[d] = prevSrcMapping[curSrc];",
          "492:    memcpy (&currentOutput[*dest], &replacements[curPos + 1],",
          "493:     l * sizeof(*currentOutput));",
          "496:     }",
          "497:   return 1;",
          "501: replaceGrouping (const TranslationTableHeader *table,",
          "502:    int *dest,",
          "503:    int srcmax,",
          "504:    const widechar *currentInput,",
          "505:    widechar *currentOutput,",
          "506:    int *srcMapping,",
          "507:    int *prevSrcMapping,",
          "508:    int transOpcode,",
          "509:    int passCharDots, const widechar *passInstructions, int passIC, int startReplace,",
          "510:    TranslationTableRule *groupingRule, widechar groupingOp)",
          "511: {",
          "512:   widechar startCharDots = groupingRule->charsdots[2 * passCharDots];",
          "513:   widechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];",
          "514:   widechar *curin = (widechar *) currentInput;",
          "515:   int curPos;",
          "516:   int level = 0;",
          "517:   TranslationTableOffset replaceOffset = passInstructions[passIC + 1] <<",
          "518:     16 | (passInstructions[passIC + 2] & 0xff);",
          "519:   TranslationTableRule *replaceRule = (TranslationTableRule *) &",
          "520:     table->ruleArea[replaceOffset];",
          "521:   widechar replaceStart = replaceRule->charsdots[2 * passCharDots];",
          "522:   widechar replaceEnd = replaceRule->charsdots[2 * passCharDots + 1];",
          "523:   if (groupingOp == pass_groupstart)",
          "524:     {",
          "525:       curin[startReplace] = replaceStart;",
          "526:       for (curPos = startReplace + 1; curPos < srcmax; curPos++)",
          "527:  {",
          "528:    if (currentInput[curPos] == startCharDots)",
          "529:      level--;",
          "530:    if (currentInput[curPos] == endCharDots)",
          "531:      level++;",
          "532:    if (level == 1)",
          "533:      break;",
          "534:  }",
          "535:       if (curPos == srcmax)",
          "536:  return 0;",
          "537:       curin[curPos] = replaceEnd;",
          "538:     }",
          "539:   else",
          "540:     {",
          "541:       if (transOpcode == CTO_Context)",
          "542:  {",
          "543:    startCharDots = groupingRule->charsdots[2];",
          "544:    endCharDots = groupingRule->charsdots[3];",
          "545:    replaceStart = replaceRule->charsdots[2];",
          "546:    replaceEnd = replaceRule->charsdots[3];",
          "547:  }",
          "548:       currentOutput[*dest] = replaceEnd;",
          "549:       for (curPos = *dest - 1; curPos >= 0; curPos--)",
          "550:  {",
          "551:    if (currentOutput[curPos] == endCharDots)",
          "552:      level--;",
          "553:    if (currentOutput[curPos] == startCharDots)",
          "554:      level++;",
          "555:    if (level == 1)",
          "556:      break;",
          "558:       if (curPos < 0)",
          "559:  return 0;",
          "560:       currentOutput[curPos] = replaceStart;",
          "561:       (*dest)++;",
          "562:     }",
          "563:   return 1;",
          "567: removeGrouping (int *dest,",
          "568:   int *srcmax,",
          "569:   const widechar *currentInput,",
          "570:   widechar *currentOutput,",
          "571:   int *srcMapping,",
          "572:   int *prevSrcMapping,",
          "573:   int passCharDots, int startReplace, int endReplace,",
          "574:   TranslationTableRule *groupingRule, widechar groupingOp)",
          "575: {",
          "576:   widechar startCharDots = groupingRule->charsdots[2 * passCharDots];",
          "577:   widechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];",
          "578:   widechar *curin = (widechar *) currentInput;",
          "579:   int curPos;",
          "580:   int level = 0;",
          "581:   if (groupingOp == pass_groupstart)",
          "582:     {",
          "583:       for (curPos = startReplace + 1; curPos < *srcmax; curPos++)",
          "584:  {",
          "585:    if (currentInput[curPos] == startCharDots)",
          "586:      level--;",
          "587:    if (currentInput[curPos] == endCharDots)",
          "588:      level++;",
          "589:    if (level == 1)",
          "590:      break;",
          "591:  }",
          "592:       if (curPos == *srcmax)",
          "593:  return 0;",
          "594:       curPos++;",
          "595:       for (; curPos < *srcmax; curPos++)",
          "596:  curin[curPos - 1] = curin[curPos];",
          "597:       (*srcmax)--;",
          "598:     }",
          "599:   else",
          "600:     {",
          "601:       for (curPos = *dest - 1; curPos >= 0; curPos--)",
          "602:  {",
          "603:    if (currentOutput[curPos] == endCharDots)",
          "604:      level--;",
          "605:    if (currentOutput[curPos] == startCharDots)",
          "606:      level++;",
          "607:    if (level == 1)",
          "608:      break;",
          "610:       if (curPos < 0)",
          "611:  return 0;",
          "612:       curPos++;",
          "613:       for (; curPos < *dest; curPos++)",
          "614:  currentOutput[curPos - 1] = currentOutput[curPos];",
          "615:       (*dest)--;",
          "616:     }",
          "617:   return 1;",
          "621: doPassSearch (const TranslationTableHeader *table,",
          "622:        int srcmax,",
          "623:        const widechar *currentInput,",
          "624:        const TranslationTableRule *transRule,",
          "625:        int passCharDots, int passSrc, const widechar *passInstructions, int passIC,",
          "626:        int *searchIC, int *searchSrc,",
          "627:        TranslationTableRule *groupingRule, widechar groupingOp)",
          "628: {",
          "629:   int level = 0;",
          "630:   int k, kk;",
          "631:   int not = 0;",
          "632:   TranslationTableOffset ruleOffset;",
          "633:   TranslationTableRule *rule;",
          "634:   TranslationTableCharacterAttributes attributes;",
          "635:   int stepper = passSrc;",
          "636:   while (stepper < srcmax)",
          "637:     {",
          "640:       while (*searchIC < transRule->dotslen)",
          "641:  {",
          "642:    int itsTrue = 1;",
          "643:    if (*searchSrc > srcmax)",
          "644:      return 0;",
          "645:    switch (passInstructions[*searchIC])",
          "646:      {",
          "647:      case pass_lookback:",
          "649:        if (*searchSrc < 0)",
          "650:          {",
          "652:            itsTrue = 0;",
          "653:          }",
          "655:        break;",
          "656:      case pass_not:",
          "657:        not = !not;",
          "658:        (*searchIC)++;",
          "659:        continue;",
          "660:      case pass_string:",
          "661:      case pass_dots:",
          "662:        kk = *searchSrc;",
          "663:        for (k = *searchIC + 2;",
          "664:      k < *searchIC + 2 + passInstructions[*searchIC + 1]; k++)",
          "665:   if (currentInput[kk] == ENDSEGMENT || passInstructions[k] !=",
          "666:       currentInput[kk++])",
          "667:     {",
          "668:       itsTrue = 0;",
          "669:       break;",
          "670:     }",
          "673:        break;",
          "674:      case pass_startReplace:",
          "675:        (*searchIC)++;",
          "676:        break;",
          "677:      case pass_endReplace:",
          "678:        (*searchIC)++;",
          "679:        break;",
          "680:      case pass_attributes:",
          "681:        attributes =",
          "682:   (passInstructions[*searchIC + 1] << 16) |",
          "683:   passInstructions[*searchIC + 2];",
          "684:        for (k = 0; k < passInstructions[*searchIC + 3]; k++)",
          "685:   {",
          "686:     if (currentInput[*searchSrc] == ENDSEGMENT)",
          "687:       itsTrue = 0;",
          "688:     else",
          "689:       itsTrue =",
          "690:         ((findCharOrDots (currentInput[(*searchSrc)++],",
          "691:       passCharDots, table)->",
          "692:     attributes & attributes) ? 1 : 0);",
          "693:     if (!itsTrue)",
          "694:       break;",
          "695:   }",
          "696:        if (itsTrue)",
          "697:   {",
          "698:     for (k = passInstructions[*searchIC + 3]; k <",
          "699:          passInstructions[*searchIC + 4]; k++)",
          "700:       {",
          "701:         if (currentInput[*searchSrc] == ENDSEGMENT)",
          "702:    {",
          "703:      itsTrue = 0;",
          "704:      break;",
          "706:         if (!",
          "707:      (findCharOrDots (currentInput[*searchSrc],",
          "708:         passCharDots, table)->",
          "709:       attributes & attributes))",
          "710:    break;",
          "711:         (*searchSrc)++;",
          "712:       }",
          "713:   }",
          "715:        break;",
          "716:      case pass_groupstart:",
          "717:      case pass_groupend:",
          "718:        ruleOffset = (passInstructions[*searchIC + 1] << 16) |",
          "719:   passInstructions[*searchIC + 2];",
          "720:        rule = (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "721:        if (passInstructions[*searchIC] == pass_groupstart)",
          "722:   itsTrue =",
          "723:     (currentInput[*searchSrc] == rule->charsdots[2 *",
          "724:              passCharDots]) ?",
          "725:     1 : 0;",
          "726:        else",
          "727:   itsTrue =",
          "728:     (currentInput[*searchSrc] == rule->charsdots[2 *",
          "729:              passCharDots +",
          "730:              1]) ? 1 : 0;",
          "731:        if (groupingRule != NULL && groupingOp == pass_groupstart",
          "732:     && rule == groupingRule)",
          "733:   {",
          "734:     if (currentInput[*searchSrc] == rule->charsdots[2 *",
          "735:          passCharDots])",
          "736:       level--;",
          "737:     else if (currentInput[*searchSrc] ==",
          "738:       rule->charsdots[2 * passCharDots + 1])",
          "739:       level++;",
          "740:   }",
          "741:        (*searchSrc)++;",
          "743:        break;",
          "744:      case pass_swap:",
          "745:        itsTrue = swapTest (*searchIC, searchSrc, table, currentInput, passInstructions);",
          "747:        break;",
          "748:      case pass_endTest:",
          "749:        if (itsTrue)",
          "750:   {",
          "751:     if ((groupingRule && level == 1) || !groupingRule)",
          "752:       return 1;",
          "755:        break;",
          "756:      default:",
          "757:               if (_lou_handlePassVariableTest(passInstructions, searchIC, &itsTrue))",
          "758:                 break;",
          "759:        break;",
          "760:      }",
          "761:    if ((!not && !itsTrue) || (not && itsTrue))",
          "762:      break;",
          "763:    not = 0;",
          "765:       stepper++;",
          "766:     }",
          "767:   return 0;",
          "771: passDoTest (const TranslationTableHeader *table,",
          "772:      int src, int srcmax,",
          "773:      const widechar *currentInput,",
          "774:      int transOpcode,",
          "775:      const TranslationTableRule *transRule,",
          "776:      int *passCharDots, int *passSrc, widechar const **passInstructions, int *passIC, int *startMatch, int *startReplace, int *endReplace,",
          "777:      TranslationTableRule **groupingRule, widechar *groupingOp)",
          "778: {",
          "779:   int endMatch;",
          "780:   int searchIC, searchSrc;",
          "781:   int k;",
          "782:   int not = 0;",
          "783:   TranslationTableOffset ruleOffset = 0;",
          "784:   TranslationTableRule *rule = NULL;",
          "785:   TranslationTableCharacterAttributes attributes = 0;",
          "792:   if (transOpcode == CTO_Context || transOpcode == CTO_Correct)",
          "794:   else",
          "796:   while (*passIC < transRule->dotslen)",
          "797:     {",
          "798:       int itsTrue = 1;",
          "799:       if (*passSrc > srcmax)",
          "800:  return 0;",
          "801:       switch ((*passInstructions)[*passIC])",
          "802:  {",
          "803:  case pass_first:",
          "804:    if (*passSrc != 0)",
          "805:      itsTrue = 0;",
          "806:    (*passIC)++;",
          "807:    break;",
          "808:  case pass_last:",
          "809:    if (*passSrc != srcmax)",
          "810:      itsTrue = 0;",
          "811:    (*passIC)++;",
          "812:    break;",
          "813:  case pass_lookback:",
          "815:    if (*passSrc < 0)",
          "816:      {",
          "817:        searchSrc = 0;",
          "818:        itsTrue = 0;",
          "819:      }",
          "821:    break;",
          "822:  case pass_not:",
          "823:    not = !not;",
          "824:    (*passIC)++;",
          "825:    continue;",
          "826:  case pass_string:",
          "827:  case pass_dots:",
          "828:    itsTrue = matchCurrentInput (currentInput, *passSrc, *passInstructions, *passIC);",
          "831:    break;",
          "832:  case pass_startReplace:",
          "834:    (*passIC)++;",
          "835:    break;",
          "836:  case pass_endReplace:",
          "838:    (*passIC)++;",
          "839:    break;",
          "840:  case pass_attributes:",
          "841:    attributes = ((*passInstructions)[*passIC + 1] << 16) |",
          "842:          (*passInstructions)[*passIC + 2];",
          "843:    for (k = 0;",
          "844:         k < (*passInstructions)[*passIC + 3];",
          "845:         k++)",
          "846:      {",
          "847:        if (*passSrc >= srcmax)",
          "848:          {",
          "849:     itsTrue = 0;",
          "850:     break;",
          "851:   }",
          "852:        if (currentInput[*passSrc] == ENDSEGMENT)",
          "853:   {",
          "854:     itsTrue = 0;",
          "855:     break;",
          "856:   }",
          "857:        if (!(findCharOrDots(currentInput[*passSrc],",
          "859:   {",
          "860:     itsTrue = 0;",
          "861:     break;",
          "862:   }",
          "864:      }",
          "865:    if (itsTrue)",
          "866:      {",
          "867:        for (k = (*passInstructions)[*passIC + 3];",
          "868:      k < (*passInstructions)[*passIC + 4] && *passSrc < srcmax;",
          "869:      k++)",
          "870:   {",
          "871:     if (currentInput[*passSrc] == ENDSEGMENT)",
          "872:       {",
          "873:         itsTrue = 0;",
          "874:         break;",
          "875:       }",
          "876:     if (!(findCharOrDots(currentInput[*passSrc],",
          "878:       {",
          "879:         break;",
          "880:       }",
          "883:      }",
          "885:    break;",
          "886:  case pass_groupstart:",
          "887:  case pass_groupend:",
          "888:    ruleOffset = ((*passInstructions)[*passIC + 1] << 16) |",
          "889:      (*passInstructions)[*passIC + 2];",
          "890:    rule = (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "891:    if (*passIC == 0 || (*passIC > 0 && (*passInstructions)[*passIC - 1] ==",
          "892:          pass_startReplace))",
          "893:      {",
          "896:      }",
          "897:    if ((*passInstructions)[*passIC] == pass_groupstart)",
          "898:      itsTrue = (currentInput[*passSrc] == rule->charsdots[2 *",
          "900:        ? 1 : 0;",
          "901:    else",
          "902:      itsTrue = (currentInput[*passSrc] == rule->charsdots[2 *",
          "904:         1]) ? 1 : 0;",
          "905:    (*passSrc)++;",
          "907:    break;",
          "908:  case pass_swap:",
          "909:    itsTrue = swapTest (*passIC, passSrc, table, currentInput, *passInstructions);",
          "911:    break;",
          "912:  case pass_search:",
          "913:    itsTrue = doPassSearch (table, srcmax, currentInput, transRule, *passCharDots, *passSrc, *passInstructions, *passIC, &searchIC, &searchSrc, *groupingRule, *groupingOp);",
          "914:    if ((!not && !itsTrue) || (not && itsTrue))",
          "915:      return 0;",
          "918:  case pass_endTest:",
          "919:    (*passIC)++;",
          "920:    endMatch = *passSrc;",
          "921:    if (*startReplace == -1)",
          "922:      {",
          "925:      }",
          "926:    return 1;",
          "927:    break;",
          "928:  default:",
          "929:           if (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue))",
          "930:             break;",
          "931:    return 0;",
          "933:       if ((!not && !itsTrue) || (not && itsTrue))",
          "935:       not = 0;",
          "936:     }",
          "937:   return 0;",
          "941: copyCharacters (int from, int to,",
          "942:   const TranslationTableHeader *table,",
          "943:   int *src, int *dest,",
          "944:   int srcmax, int destmax,",
          "945:   int mode,",
          "946:   const widechar *currentInput,",
          "947:   widechar *currentOutput,",
          "948:   int *srcMapping,",
          "949:   int *prevSrcMapping,",
          "950:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "951:   int transOpcode,",
          "952:   const TranslationTableRule **transRule,",
          "953:   int *inputPositions,",
          "954:   int *outputPositions,",
          "955:   int *cursorPosition, int *cursorStatus,",
          "956:   int compbrlStart, int compbrlEnd)",
          "957: {",
          "958:   if (transOpcode == CTO_Context)",
          "959:     {",
          "960:       while (from < to)",
          "961:  if (!putCharacter(currentInput[from++], table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "962:    return 0;",
          "963:     }",
          "964:   else",
          "965:     {",
          "966:       int count = to - from;",
          "968:       if (count > 0)",
          "969:         {",
          "970:    if ((*dest + count) > destmax)",
          "971:      return 0;",
          "973:    memmove(&srcMapping[*dest], &prevSrcMapping[from],",
          "974:     count * sizeof(*srcMapping));",
          "975:    memcpy(&currentOutput[*dest], &currentInput[from],",
          "976:           count * sizeof(*currentOutput));",
          "979:     }",
          "981:   return 1;",
          "985: passDoAction (const TranslationTableHeader *table,",
          "986:        int *src, int *dest, int *srcmax,",
          "987:        int destmax,",
          "988:        int mode,",
          "989:        const widechar *currentInput,",
          "990:        widechar *currentOutput,",
          "991:        int *srcMapping,",
          "992:        int *prevSrcMapping,",
          "993:        unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "994:        int transOpcode,",
          "995:        const TranslationTableRule **transRule,",
          "996:        int passCharDots, int passSrc, const widechar *passInstructions, int startMatch, int startReplace,",
          "997:        int *passIC,",
          "998:        int *endReplace,",
          "999:        int *inputPositions,",
          "1000:        int *outputPositions,",
          "1001:        int *cursorPosition, int *cursorStatus,",
          "1002:        int compbrlStart, int compbrlEnd,",
          "1003:        TranslationTableRule *groupingRule, widechar groupingOp)",
          "1004: {",
          "1005:   int k;",
          "1006:   TranslationTableOffset ruleOffset = 0;",
          "1007:   TranslationTableRule *rule = NULL;",
          "1009:   int srcInitial = startMatch;",
          "1010:   int srcStart = startReplace;",
          "1011:   int srcEnd = *endReplace;",
          "1012:   int destInitial = *dest;",
          "1013:   int destStart;",
          "1015:   if (!copyCharacters(srcInitial, srcStart, table, src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transOpcode, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "1016:     return 0;",
          "1017:   destStart = *dest;",
          "1019:   while (*passIC < (*transRule)->dotslen)",
          "1020:     switch (passInstructions[*passIC])",
          "1021:       {",
          "1022:       case pass_string:",
          "1023:       case pass_dots:",
          "1024:  if ((*dest + passInstructions[*passIC + 1]) > destmax)",
          "1025:    return 0;",
          "1026:  for (k = 0; k < passInstructions[*passIC + 1]; ++k)",
          "1027:    srcMapping[*dest + k] = prevSrcMapping[startReplace];",
          "1028:  memcpy (&currentOutput[*dest], &passInstructions[*passIC + 2],",
          "1029:   passInstructions[*passIC + 1] * CHARSIZE);",
          "1032:  break;",
          "1033:       case pass_groupstart:",
          "1034:  ruleOffset = (passInstructions[*passIC + 1] << 16) |",
          "1035:    passInstructions[*passIC + 2];",
          "1036:  rule = (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "1037:  srcMapping[*dest] = prevSrcMapping[startMatch];",
          "1038:  currentOutput[(*dest)++] = rule->charsdots[2 * passCharDots];",
          "1040:  break;",
          "1041:       case pass_groupend:",
          "1042:  ruleOffset = (passInstructions[*passIC + 1] << 16) |",
          "1043:    passInstructions[*passIC + 2];",
          "1044:  rule = (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "1045:  srcMapping[*dest] = prevSrcMapping[startMatch];",
          "1046:  currentOutput[(*dest)++] = rule->charsdots[2 * passCharDots + 1];",
          "1048:  break;",
          "1049:       case pass_swap:",
          "1050:  if (!swapReplace (startReplace, *endReplace, table, dest, destmax, currentInput, currentOutput, srcMapping, prevSrcMapping, passInstructions, *passIC))",
          "1051:    return 0;",
          "1053:  break;",
          "1054:       case pass_groupreplace:",
          "1055:  if (!groupingRule || !replaceGrouping (table, dest, *srcmax, currentInput, currentOutput, srcMapping, prevSrcMapping, transOpcode, passCharDots, passInstructions, *passIC, startReplace, groupingRule, groupingOp))",
          "1056:    return 0;",
          "1058:  break;",
          "1059:       case pass_omit:",
          "1060:  if (groupingRule)",
          "1061:    removeGrouping (dest, srcmax, currentInput, currentOutput, srcMapping, prevSrcMapping, passCharDots, startReplace, *endReplace, groupingRule, groupingOp);",
          "1062:  (*passIC)++;",
          "1063:  break;",
          "1064:       case pass_copy:",
          "1065:  {",
          "1066:    int count = destStart - destInitial;",
          "1068:    if (count > 0)",
          "1069:      {",
          "1070:        memmove(&currentOutput[destInitial], &currentOutput[destStart],",
          "1071:         count * sizeof(*currentOutput));",
          "1073:        destStart = destInitial;",
          "1074:      }",
          "1075:  }",
          "1077:         if (!copyCharacters(srcStart, srcEnd, table, src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transOpcode, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "1078:           return 0;",
          "1080:  (*passIC)++;",
          "1081:  break;",
          "1082:       default:",
          "1083:         if (_lou_handlePassVariableAction(passInstructions, passIC))",
          "1084:           break;",
          "1085:  return 0;",
          "1086:       }",
          "1087:   return 1;",
          "1091: passSelectRule (const TranslationTableHeader *table,",
          "1092:   int src, int srcmax,",
          "1093:   int currentPass,",
          "1094:   const widechar *currentInput,",
          "1095:   int *transOpcode,",
          "1096:   const TranslationTableRule **transRule,",
          "1097:   int *transCharslen,",
          "1098:   int *passCharDots, int *passSrc, widechar const **passInstructions, int *passIC, int *startMatch, int *startReplace, int *endReplace,",
          "1099:   TranslationTableRule **groupingRule, widechar *groupingOp)",
          "1100: {",
          "1101:   if (!findForPassRule (table, src, srcmax, currentPass, currentInput, transOpcode, transRule, transCharslen, passCharDots, passSrc, passInstructions, passIC, startMatch, startReplace, endReplace, groupingRule, groupingOp))",
          "1102:     {",
          "1104:     }",
          "1108: translatePass (const TranslationTableHeader *table,",
          "1109:         int *dest, int *srcmax,",
          "1110:         int destmax,",
          "1111:         int mode,",
          "1112:         int currentPass,",
          "1113:         const widechar *currentInput,",
          "1114:         widechar *currentOutput,",
          "1115:         int *srcMapping,",
          "1116:         int *prevSrcMapping,",
          "1117:         unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1118:         int *srcIncremented,",
          "1119:         int *inputPositions,",
          "1120:         int *outputPositions,",
          "1121:         int *cursorPosition, int *cursorStatus,",
          "1122:         int compbrlStart, int compbrlEnd)",
          "1123: {",
          "1124:   int src;",
          "1125:   int transOpcode;",
          "1126:   int prevTransOpcode;",
          "1127:   const TranslationTableRule *transRule;",
          "1128:   int transCharslen;",
          "1129:   int passCharDots;",
          "1130:   int passSrc;",
          "1131:   const widechar *passInstructions;",
          "1133:   int startMatch;",
          "1134:   int startReplace;",
          "1135:   int endReplace;",
          "1136:   TranslationTableRule *groupingRule;",
          "1137:   widechar groupingOp;",
          "1138:   prevTransOpcode = CTO_None;",
          "1139:   src = *dest = 0;",
          "1141:   _lou_resetPassVariables();",
          "1142:   while (src < *srcmax)",
          "1144:       passSelectRule (table, src, *srcmax, currentPass, currentInput, &transOpcode, &transRule, &transCharslen, &passCharDots, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace, &groupingRule, &groupingOp);",
          "1146:       switch (transOpcode)",
          "1147:  {",
          "1148:  case CTO_Context:",
          "1149:  case CTO_Pass2:",
          "1150:  case CTO_Pass3:",
          "1151:  case CTO_Pass4:",
          "1152:    if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "1153:      appliedRules[appliedRulesCount++] = transRule;",
          "1154:    if (!passDoAction (table, &src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transOpcode, &transRule, passCharDots, passSrc, passInstructions, startMatch, startReplace, &passIC, &endReplace, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd, groupingRule, groupingOp))",
          "1155:      goto failure;",
          "1156:    if (endReplace == src)",
          "1158:    src = endReplace;",
          "1159:    break;",
          "1160:  case CTO_Always:",
          "1161:    if ((*dest + 1) > destmax)",
          "1162:      goto failure;",
          "1163:    srcMapping[*dest] = prevSrcMapping[src];",
          "1164:    currentOutput[(*dest)++] = currentInput[src++];",
          "1165:    break;",
          "1166:  default:",
          "1167:    goto failure;",
          "1169:     }",
          "1170:   srcMapping[*dest] = prevSrcMapping[src];",
          "1171: failure:if (src < *srcmax)",
          "1172:     {",
          "1173:       while (checkAttr (currentInput[src], CTC_Space, 1, table))",
          "1174:  if (++src == *srcmax)",
          "1175:    break;",
          "1176:     }",
          "1177:   return 1;",
          "1181: #define MIN(a,b) (((a)<(b))?(a):(b))",
          "1183: static int translateString (const TranslationTableHeader *table,",
          "1184:        int *dest, int *srcmax,",
          "1185:        int destmax,",
          "1186:        int mode,",
          "1187:        int currentPass,",
          "1188:        const widechar *currentInput,",
          "1189:        widechar *currentOutput,",
          "1190:        int *srcMapping,",
          "1191:        int *prevSrcMapping,",
          "1192:        formtype *typebuf,",
          "1193:        unsigned char *srcSpacing,",
          "1194:        unsigned char *destSpacing,",
          "1195:        unsigned int *wordBuffer,",
          "1196:        unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1197:        int haveEmphasis,",
          "1198:        int *realInlen,",
          "1199:        int *srcIncremented,",
          "1200:        int *inputPositions,",
          "1201:        int *outputPositions,",
          "1202:        int *cursorPosition,",
          "1203:        int *cursorStatus,",
          "1204:        int compbrlStart, int compbrlEnd);",
          "1207: lou_translateString (const char *tableList, const widechar",
          "1209:        int *inlen, widechar * outbuf, int *outlen,",
          "1210:        formtype",
          "1212: {",
          "1213:   return",
          "1214:     lou_translate (tableList, inbufx, inlen, outbuf, outlen, typeform,",
          "1215:      spacing, NULL, NULL, NULL, mode);",
          "1219: lou_translate (const char *tableList, const widechar * inbufx,",
          "1220:         int *inlen, widechar * outbuf, int *outlen,",
          "1221:         formtype *typeform, char *spacing, int *outputPos,",
          "1222:         int *inputPos, int *cursorPos, int mode)",
          "1223: {",
          "1224:   return _lou_translateWithTracing (tableList, inbufx, inlen, outbuf, outlen,",
          "1225:           typeform, spacing, outputPos, inputPos, cursorPos,",
          "1226:           mode, NULL, NULL);",
          "1230: _lou_translateWithTracing (const char *tableList, const widechar * inbufx,",
          "1231:         int *inlen, widechar * outbuf, int *outlen,",
          "1232:         formtype *typeform, char *spacing, int *outputPos,",
          "1233:         int *inputPos, int *cursorPos, int mode,",
          "1234:         const TranslationTableRule **rules, int *rulesLen)",
          "1235: {",
          "1248:   const TranslationTableHeader *table;",
          "1249:   int srcmax;",
          "1250:   int destmax;",
          "1251:   int dest;",
          "1252:   const widechar *currentInput;",
          "1253:   widechar *currentOutput;",
          "1254:   widechar *passbuf1;",
          "1255:   widechar *passbuf2;",
          "1256:   int *srcMapping;",
          "1257:   int *prevSrcMapping;",
          "1258:   formtype *typebuf;",
          "1259:   unsigned char *srcSpacing;",
          "1260:   unsigned char *destSpacing;",
          "1261:   unsigned int *wordBuffer;",
          "1262:   unsigned int *emphasisBuffer;",
          "1263:   unsigned int *transNoteBuffer;",
          "1264:   int *inputPositions;",
          "1265:   int *outputPositions;",
          "1266:   int cursorPosition;",
          "1267:   int cursorStatus;",
          "1268:   int haveEmphasis;",
          "1269:   int compbrlStart;",
          "1270:   int compbrlEnd;",
          "1271:   int k;",
          "1272:   int goodTrans = 1;",
          "1273:   int realInlen;",
          "1274:   int srcIncremented;",
          "1275:   if (tableList == NULL || inbufx == NULL || inlen == NULL || outbuf ==",
          "1276:       NULL || outlen == NULL)",
          "1277:     return 0;",
          "1278:   _lou_logMessage(LOG_ALL, \"Performing translation: tableList=%s, inlen=%d\", tableList, *inlen);",
          "1279:   _lou_logWidecharBuf(LOG_ALL, \"Inbuf=\", inbufx, *inlen);",
          "1281:   table = lou_getTable (tableList);",
          "1282:   if (table == NULL || *inlen < 0 || *outlen < 0)",
          "1283:     return 0;",
          "1284:   currentInput = (widechar *) inbufx;",
          "1285:   srcmax = 0;",
          "1286:   while (srcmax < *inlen && currentInput[srcmax])",
          "1287:     srcmax++;",
          "1288:   destmax = *outlen;",
          "1289:   haveEmphasis = 0;",
          "1290:   if (!(typebuf = _lou_allocMem (alloc_typebuf, srcmax, destmax)))",
          "1291:     return 0;",
          "1292:   if (typeform != NULL)",
          "1293:     {",
          "1294:       for (k = 0; k < srcmax; k++)",
          "1295:   {",
          "1297:    if(typebuf[k] & EMPHASIS)",
          "1298:     haveEmphasis = 1;",
          "1300:     }",
          "1301:   else",
          "1302:     memset (typebuf, 0, srcmax * sizeof (formtype));",
          "1304:  if((wordBuffer = _lou_allocMem(alloc_wordBuffer, srcmax, destmax)))",
          "1308:  if((emphasisBuffer = _lou_allocMem(alloc_emphasisBuffer, srcmax, destmax)))",
          "1312:  if((transNoteBuffer = _lou_allocMem(alloc_transNoteBuffer, srcmax, destmax)))",
          "1317:   if (!(spacing == NULL || *spacing == 'X'))",
          "1318:     srcSpacing = (unsigned char *) spacing;",
          "1319:   else",
          "1320:     srcSpacing = NULL;",
          "1321:   outputPositions = outputPos;",
          "1322:   if (outputPos != NULL)",
          "1323:     for (k = 0; k < srcmax; k++)",
          "1324:       outputPos[k] = -1;",
          "1325:   inputPositions = inputPos;",
          "1326:   if (cursorPos != NULL && *cursorPos >= 0)",
          "1327:     {",
          "1328:       cursorStatus = 0;",
          "1329:       cursorPosition = *cursorPos;",
          "1330:       if ((mode & (compbrlAtCursor | compbrlLeftCursor)))",
          "1331:  {",
          "1332:    compbrlStart = cursorPosition;",
          "1333:    if (checkAttr (currentInput[compbrlStart], CTC_Space, 0, table))",
          "1334:      compbrlEnd = compbrlStart + 1;",
          "1335:    else",
          "1336:      {",
          "1337:        while (compbrlStart >= 0 && !checkAttr",
          "1338:        (currentInput[compbrlStart], CTC_Space, 0, table))",
          "1339:   compbrlStart--;",
          "1340:        compbrlStart++;",
          "1341:        compbrlEnd = cursorPosition;",
          "1342:        if (!(mode & compbrlLeftCursor))",
          "1343:   while (compbrlEnd < srcmax && !checkAttr",
          "1344:          (currentInput[compbrlEnd], CTC_Space, 0, table))",
          "1345:     compbrlEnd++;",
          "1346:      }",
          "1348:     }",
          "1349:   else",
          "1350:     {",
          "1351:       cursorPosition = -1;",
          "1353:     }",
          "1354:   if (!(passbuf1 = _lou_allocMem (alloc_passbuf1, srcmax, destmax)))",
          "1355:     return 0;",
          "1356:   if (!(srcMapping = _lou_allocMem (alloc_srcMapping, srcmax, destmax)))",
          "1357:     return 0;",
          "1358:   if (!",
          "1359:       (prevSrcMapping =",
          "1360:        _lou_allocMem (alloc_prevSrcMapping, srcmax, destmax)))",
          "1361:     return 0;",
          "1362:   for (k = 0; k <= srcmax; k++)",
          "1363:     srcMapping[k] = k;",
          "1364:   srcMapping[srcmax] = srcmax;",
          "1365:   if ((!(mode & pass1Only)) && (table->numPasses > 1 || table->corrections))",
          "1366:     {",
          "1367:       if (!(passbuf2 = _lou_allocMem (alloc_passbuf2, srcmax, destmax)))",
          "1368:  return 0;",
          "1369:     }",
          "1370:   if (srcSpacing != NULL)",
          "1371:     {",
          "1372:       if (!(destSpacing = _lou_allocMem (alloc_destSpacing, srcmax,",
          "1373:           destmax)))",
          "1374:  goodTrans = 0;",
          "1375:       else",
          "1376:  memset (destSpacing, '*', destmax);",
          "1377:     }",
          "1378:   else",
          "1379:     destSpacing = NULL;",
          "1380:   appliedRulesCount = 0;",
          "1381:   if (rules != NULL && rulesLen != NULL)",
          "1382:     {",
          "1383:       appliedRules = rules;",
          "1384:       maxAppliedRules = *rulesLen;",
          "1385:     }",
          "1386:   else",
          "1387:     {",
          "1388:       appliedRules = NULL;",
          "1389:       maxAppliedRules = 0;",
          "1390:     }",
          "1391:   int currentPass = 0;",
          "1392:   if ((mode & pass1Only))",
          "1393:     {",
          "1394:       currentOutput = passbuf1;",
          "1395:       memcpy (prevSrcMapping, srcMapping, destmax * sizeof (int));",
          "1396:       goodTrans = translateString (table, &dest, &srcmax, destmax, mode, currentPass, currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf, srcSpacing, destSpacing, wordBuffer, emphasisBuffer, transNoteBuffer, haveEmphasis, &realInlen, &srcIncremented, inputPositions, outputPositions, &cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);",
          "1398:     }",
          "1399:   while (currentPass <= table->numPasses && goodTrans)",
          "1400:     {",
          "1401:       memcpy (prevSrcMapping, srcMapping, destmax * sizeof (int));",
          "1402:       switch (currentPass)",
          "1403:  {",
          "1404:  case 0:",
          "1405:    if (table->corrections)",
          "1406:      {",
          "1407:        currentOutput = passbuf2;",
          "1408:        goodTrans = makeCorrections (table, &dest, &srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf, emphasisBuffer, transNoteBuffer, &realInlen, &srcIncremented, inputPositions, outputPositions, &cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);",
          "1409:        currentInput = passbuf2;",
          "1410:        srcmax = dest;",
          "1411:      }",
          "1412:    break;",
          "1413:  case 1:",
          "1414:    currentOutput = passbuf1;",
          "1415:    goodTrans = translateString (table, &dest, &srcmax, destmax, mode, currentPass, currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf, srcSpacing, destSpacing, wordBuffer, emphasisBuffer, transNoteBuffer, haveEmphasis, &realInlen, &srcIncremented, inputPositions, outputPositions, &cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);",
          "1416:    break;",
          "1417:  case 2:",
          "1418:    srcmax = dest;",
          "1419:    currentInput = passbuf1;",
          "1420:    currentOutput = passbuf2;",
          "1421:    goodTrans = translatePass (table, &dest, &srcmax, destmax, mode, currentPass, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &srcIncremented, inputPositions, outputPositions, &cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);",
          "1422:    break;",
          "1423:  case 3:",
          "1424:    srcmax = dest;",
          "1425:    currentInput = passbuf2;",
          "1426:    currentOutput = passbuf1;",
          "1427:    goodTrans = translatePass (table, &dest, &srcmax, destmax, mode, currentPass, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &srcIncremented, inputPositions, outputPositions, &cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);",
          "1428:    break;",
          "1429:  case 4:",
          "1430:    srcmax = dest;",
          "1431:    currentInput = passbuf1;",
          "1432:    currentOutput = passbuf2;",
          "1433:    goodTrans = translatePass (table, &dest, &srcmax, destmax, mode, currentPass, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &srcIncremented, inputPositions, outputPositions, &cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);",
          "1434:    break;",
          "1435:  default:",
          "1436:    break;",
          "1438:       currentPass++;",
          "1439:     }",
          "1440:   if (goodTrans)",
          "1441:     {",
          "1442:       for (k = 0; k < dest; k++)",
          "1443:  {",
          "1444:    if (typeform != NULL)",
          "1445:      {",
          "1446:        if ((currentOutput[k] & (B7 | B8)))",
          "1447:   typeform[k] = '8';",
          "1448:        else",
          "1449:   typeform[k] = '0';",
          "1450:      }",
          "1451:    if ((mode & dotsIO))",
          "1452:      {",
          "1453:        if ((mode & ucBrl))",
          "1454:   outbuf[k] = ((currentOutput[k] & 0xff) | 0x2800);",
          "1455:        else",
          "1456:   outbuf[k] = currentOutput[k];",
          "1457:      }",
          "1458:    else",
          "1459:      outbuf[k] = _lou_getCharFromDots (currentOutput[k]);",
          "1463:       if (inputPositions != NULL)",
          "1464:  memcpy (inputPositions, srcMapping, dest * sizeof (int));",
          "1465:       if (outputPos != NULL)",
          "1466:  {",
          "1467:    int lastpos = 0;",
          "1468:    for (k = 0; k < *inlen; k++)",
          "1469:      if (outputPos[k] == -1)",
          "1470:        outputPos[k] = lastpos;",
          "1471:      else",
          "1472:        lastpos = outputPos[k];",
          "1474:     }",
          "1475:   if (destSpacing != NULL)",
          "1476:     {",
          "1477:       memcpy (srcSpacing, destSpacing, srcmax);",
          "1478:       srcSpacing[srcmax] = 0;",
          "1479:     }",
          "1480:   if (cursorPos != NULL && *cursorPos != -1)",
          "1481:     {",
          "1482:       if (outputPos != NULL)",
          "1484:       else",
          "1486:     }",
          "1487:   if (rulesLen != NULL)",
          "1489:   _lou_logMessage(LOG_ALL, \"Translation complete: outlen=%d\", *outlen);",
          "1490:   _lou_logWidecharBuf(LOG_ALL, \"Outbuf=\", (const widechar *)outbuf, *outlen);",
          "1492:   return goodTrans;",
          "1496: lou_translatePrehyphenated (const char *tableList,",
          "1497:        const widechar * inbufx, int *inlen,",
          "1498:        widechar * outbuf, int *outlen,",
          "1499:        formtype *typeform, char *spacing,",
          "1500:        int *outputPos, int *inputPos, int *cursorPos,",
          "1501:        char *inputHyphens, char *outputHyphens,",
          "1502:        int mode)",
          "1503: {",
          "1504:   int rv = 1;",
          "1505:   int *alloc_inputPos = NULL;",
          "1506:   if (inputHyphens != NULL)",
          "1507:     {",
          "1508:       if (outputHyphens == NULL)",
          "1509:  return 0;",
          "1510:       if (inputPos == NULL)",
          "1511:  {",
          "1512:    if ((alloc_inputPos = malloc (*outlen * sizeof (int))) == NULL)",
          "1513:      _lou_outOfMemory ();",
          "1514:    inputPos = alloc_inputPos;",
          "1516:     }",
          "1517:   if (lou_translate (tableList, inbufx, inlen, outbuf, outlen, typeform,",
          "1518:        spacing, outputPos, inputPos, cursorPos, mode))",
          "1519:     {",
          "1520:       if (inputHyphens != NULL)",
          "1521:  {",
          "1522:    int inpos = 0;",
          "1523:    int outpos;",
          "1524:    for (outpos = 0; outpos < *outlen; outpos++)",
          "1525:      {",
          "1526:        int new_inpos = inputPos[outpos];",
          "1527:        if (new_inpos < inpos)",
          "1528:   {",
          "1529:     rv = 0;",
          "1530:     break;",
          "1532:        if (new_inpos > inpos)",
          "1533:   outputHyphens[outpos] = inputHyphens[new_inpos];",
          "1534:        else",
          "1535:   outputHyphens[outpos] = '0';",
          "1536:        inpos = new_inpos;",
          "1537:      }",
          "1539:     }",
          "1540:   if (alloc_inputPos != NULL)",
          "1541:     free (alloc_inputPos);",
          "1542:   return rv;",
          "1546: hyphenate (const widechar * word, int wordSize, char *hyphens,",
          "1547:     const TranslationTableHeader *table)",
          "1548: {",
          "1549:   widechar *prepWord;",
          "1550:   int i, k, limit;",
          "1551:   int stateNum;",
          "1552:   widechar ch;",
          "1553:   HyphenationState *statesArray = (HyphenationState *)",
          "1554:     & table->ruleArea[table->hyphenStatesArray];",
          "1555:   HyphenationState *currentState;",
          "1556:   HyphenationTrans *transitionsArray;",
          "1557:   char *hyphenPattern;",
          "1558:   int patternOffset;",
          "1559:   if (!table->hyphenStatesArray || (wordSize + 3) > MAXSTRING)",
          "1560:     return 0;",
          "1561:   prepWord = (widechar *) calloc (wordSize + 3, sizeof (widechar));",
          "1564:   prepWord[0] = '.';",
          "1565:   for (i = 0; i < wordSize; i++)",
          "1566:     {",
          "1567:       prepWord[i + 1] = (findCharOrDots (word[i], 0, table))->lowercase;",
          "1568:       hyphens[i] = '0';",
          "1569:     }",
          "1570:   prepWord[wordSize + 1] = '.';",
          "1573:   stateNum = 0;",
          "1576:   for (i = 0; i < wordSize + 2; i++)",
          "1577:     {",
          "1578:       ch = prepWord[i];",
          "1579:       while (1)",
          "1580:  {",
          "1581:    if (stateNum == 0xffff)",
          "1582:      {",
          "1583:        stateNum = 0;",
          "1584:        goto nextLetter;",
          "1585:      }",
          "1586:    currentState = &statesArray[stateNum];",
          "1587:    if (currentState->trans.offset)",
          "1588:      {",
          "1589:        transitionsArray = (HyphenationTrans *) &",
          "1590:   table->ruleArea[currentState->trans.offset];",
          "1591:        for (k = 0; k < currentState->numTrans; k++)",
          "1592:   {",
          "1593:     if (transitionsArray[k].ch == ch)",
          "1594:       {",
          "1595:         stateNum = transitionsArray[k].newState;",
          "1596:         goto stateFound;",
          "1597:       }",
          "1599:      }",
          "1600:    stateNum = currentState->fallbackState;",
          "1601:  }",
          "1602:     stateFound:",
          "1603:       currentState = &statesArray[stateNum];",
          "1604:       if (currentState->hyphenPattern)",
          "1605:  {",
          "1606:    hyphenPattern =",
          "1607:      (char *) &table->ruleArea[currentState->hyphenPattern];",
          "1608:    patternOffset = i + 1 - (int)strlen (hyphenPattern);",
          "1613:    limit = MIN ((int)strlen (hyphenPattern), wordSize - patternOffset);",
          "1614:    for (k = 0; k < limit; k++)",
          "1615:      {",
          "1616:        if (hyphens[patternOffset + k] < hyphenPattern[k])",
          "1617:   hyphens[patternOffset + k] = hyphenPattern[k];",
          "1618:      }",
          "1620:     nextLetter:;",
          "1621:     }",
          "1622:   hyphens[wordSize] = 0;",
          "1623:   free (prepWord);",
          "1624:   return 1;",
          "1627: static int doCompTrans (int start, int end,",
          "1628:    const TranslationTableHeader *table,",
          "1629:    int *src, int *dest,",
          "1630:    int srcmax, int destmax,",
          "1631:    int mode,",
          "1632:    const widechar *currentInput,",
          "1633:    widechar *currentOutput,",
          "1634:    int *srcMapping,",
          "1635:    int *prevSrcMapping,",
          "1636:    unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1637:    const TranslationTableRule **transRule,",
          "1638:    int *inputPositions,",
          "1639:    int *outputPositions,",
          "1640:    int *cursorPosition, int *cursorStatus,",
          "1641:    int compbrlStart, int compbrlEnd);",
          "1644: for_updatePositions (const widechar * outChars, int inLength, int outLength, int shift,",
          "1645:        const TranslationTableHeader *table,",
          "1646:        int *src, int *dest,",
          "1647:        int srcmax, int destmax,",
          "1648:        int mode,",
          "1649:        const widechar *currentInput,",
          "1650:        widechar *currentOutput,",
          "1651:        int *srcMapping,",
          "1652:        int *prevSrcMapping,",
          "1653:        unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1654:        const TranslationTableRule **transRule,",
          "1655:        int *inputPositions,",
          "1656:        int *outputPositions,",
          "1657:        int *cursorPosition, int *cursorStatus,",
          "1658:        int compbrlStart, int compbrlEnd)",
          "1659: {",
          "1660:   int k;",
          "1661:   if ((*dest + outLength) > destmax || (*src + inLength) > srcmax)",
          "1662:     return 0;",
          "1663:   memcpy (&currentOutput[*dest], outChars, outLength * CHARSIZE);",
          "1664:   if (!*cursorStatus)",
          "1665:     {",
          "1666:       if ((mode & (compbrlAtCursor | compbrlLeftCursor)))",
          "1667:  {",
          "1668:    if (*src >= compbrlStart)",
          "1669:      {",
          "1671:        return doCompTrans (compbrlStart, compbrlEnd, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "1672:      }",
          "1673:  }",
          "1674:       else if (*cursorPosition >= *src && *cursorPosition < (*src + inLength))",
          "1675:  {",
          "1678:  }",
          "1679:       else if (currentInput[*cursorPosition] == 0 &&",
          "1681:  {",
          "1684:  }",
          "1685:     }",
          "1686:   else if (*cursorStatus == 2 && *cursorPosition == *src)",
          "1688:   if (inputPositions != NULL || outputPositions != NULL)",
          "1689:     {",
          "1690:       if (outLength <= inLength)",
          "1691:  {",
          "1692:    for (k = 0; k < outLength; k++)",
          "1693:      {",
          "1694:        if (inputPositions != NULL)",
          "1695:   srcMapping[*dest + k] = prevSrcMapping[*src] + shift;",
          "1696:        if (outputPositions != NULL)",
          "1697:   outputPositions[prevSrcMapping[*src + k]] = *dest;",
          "1698:      }",
          "1699:    for (k = outLength; k < inLength; k++)",
          "1700:      if (outputPositions != NULL)",
          "1701:        outputPositions[prevSrcMapping[*src + k]] = *dest;",
          "1702:  }",
          "1703:       else",
          "1704:  {",
          "1705:    for (k = 0; k < inLength; k++)",
          "1706:      {",
          "1707:        if (inputPositions != NULL)",
          "1708:   srcMapping[*dest + k] = prevSrcMapping[*src] + shift;",
          "1709:        if (outputPositions != NULL)",
          "1710:   outputPositions[prevSrcMapping[*src + k]] = *dest;",
          "1711:      }",
          "1712:    for (k = inLength; k < outLength; k++)",
          "1713:      if (inputPositions != NULL)",
          "1714:        srcMapping[*dest + k] = prevSrcMapping[*src] + shift;",
          "1716:     }",
          "1718:   return 1;",
          "1722: syllableBreak (const TranslationTableHeader *table,",
          "1723:         int src, int srcmax,",
          "1724:         const widechar *currentInput,",
          "1725:         int transCharslen)",
          "1726: {",
          "1727:   int wordStart = 0;",
          "1728:   int wordEnd = 0;",
          "1729:   int wordSize = 0;",
          "1730:   int k = 0;",
          "1731:   char *hyphens = NULL;",
          "1732:   for (wordStart = src; wordStart >= 0; wordStart--)",
          "1733:     if (!((findCharOrDots (currentInput[wordStart], 0, table))->attributes &",
          "1734:    CTC_Letter))",
          "1735:       {",
          "1736:  wordStart++;",
          "1737:  break;",
          "1738:       }",
          "1739:   if (wordStart < 0)",
          "1740:     wordStart = 0;",
          "1741:   for (wordEnd = src; wordEnd < srcmax; wordEnd++)",
          "1742:     if (!((findCharOrDots (currentInput[wordEnd], 0, table))->attributes &",
          "1743:    CTC_Letter))",
          "1744:       {",
          "1745:  wordEnd--;",
          "1746:  break;",
          "1747:       }",
          "1748:   if (wordEnd == srcmax)",
          "1749:     wordEnd--;",
          "1753:   wordSize = wordEnd - wordStart + 1;",
          "1754:   hyphens = (char *) calloc (wordSize + 1, sizeof (char));",
          "1755:   if (!hyphenate (&currentInput[wordStart], wordSize, hyphens, table))",
          "1756:     {",
          "1757:       free (hyphens);",
          "1758:       return 0;",
          "1759:     }",
          "1760:   for (k = src - wordStart + 1; k < (src - wordStart + transCharslen); k++)",
          "1761:     if (hyphens[k] & 1)",
          "1762:       {",
          "1763:  free (hyphens);",
          "1764:  return 1;",
          "1765:       }",
          "1766:   free (hyphens);",
          "1767:   return 0;",
          "1772: setBefore (const TranslationTableHeader *table,",
          "1773:     int src,",
          "1774:     const widechar *currentInput,",
          "1775:     TranslationTableCharacterAttributes *beforeAttributes)",
          "1776: {",
          "1777:   widechar before;",
          "1778:   if (src >= 2 && currentInput[src - 1] == ENDSEGMENT)",
          "1779:     before = currentInput[src - 2];",
          "1780:   else",
          "1781:     before = (src == 0) ? ' ' : currentInput[src - 1];",
          "1786: setAfter (int length,",
          "1787:    const TranslationTableHeader *table,",
          "1788:    int src, int srcmax,",
          "1789:    const widechar *currentInput,",
          "1790:    TranslationTableCharacterAttributes *afterAttributes)",
          "1791: {",
          "1792:   widechar after;",
          "1793:   if ((src + length + 2) < srcmax && currentInput[src + 1] == ENDSEGMENT)",
          "1794:     after = currentInput[src + 2];",
          "1795:   else",
          "1796:     after = (src + length < srcmax) ? currentInput[src + length] : ' ';",
          "1801: brailleIndicatorDefined (TranslationTableOffset offset,",
          "1802:     const TranslationTableHeader *table,",
          "1803:     const TranslationTableRule **indicRule)",
          "1804: {",
          "1805:   if (!offset)",
          "1806:     return 0;",
          "1808:   return 1;",
          "1812: validMatch (const TranslationTableHeader *table,",
          "1813:      int src,",
          "1814:      const widechar *currentInput,",
          "1815:      formtype *typebuf,",
          "1816:      const TranslationTableRule *transRule,",
          "1817:      int transCharslen)",
          "1818: {",
          "1820:   TranslationTableCharacter *currentInputChar;",
          "1821:   TranslationTableCharacter *ruleChar;",
          "1822:   TranslationTableCharacterAttributes prevAttr = 0;",
          "1823:   int k;",
          "1824:   int kk = 0;",
          "1825:   if (!transCharslen)",
          "1826:     return 0;",
          "1827:   for (k = src; k < src + transCharslen; k++)",
          "1828:     {",
          "1829:       if (currentInput[k] == ENDSEGMENT)",
          "1830:  {",
          "1831:    if (k == src && transCharslen == 1)",
          "1832:      return 1;",
          "1833:    else",
          "1834:      return 0;",
          "1835:  }",
          "1836:       currentInputChar = findCharOrDots (currentInput[k], 0, table);",
          "1837:       if (k == src)",
          "1838:  prevAttr = currentInputChar->attributes;",
          "1839:       ruleChar = findCharOrDots (transRule->charsdots[kk++], 0, table);",
          "1840:       if ((currentInputChar->lowercase != ruleChar->lowercase))",
          "1841:  return 0;",
          "1842:       if (typebuf != NULL && (typebuf[src] & CAPSEMPH) == 0 &&",
          "1843:    (typebuf[k] | typebuf[src]) != typebuf[src])",
          "1844:  return 0;",
          "1845:       if (currentInputChar->attributes != CTC_Letter)",
          "1846:  {",
          "1847:    if (k != (src + 1) && (prevAttr &",
          "1848:      CTC_Letter)",
          "1849:        && (currentInputChar->attributes & CTC_Letter)",
          "1850:        &&",
          "1851:        ((currentInputChar->",
          "1852:   attributes & (CTC_LowerCase | CTC_UpperCase |",
          "1853:          CTC_Letter)) !=",
          "1854:         (prevAttr & (CTC_LowerCase | CTC_UpperCase | CTC_Letter))))",
          "1855:      return 0;",
          "1857:       prevAttr = currentInputChar->attributes;",
          "1858:     }",
          "1859:   return 1;",
          "1863: doCompEmph (const TranslationTableHeader *table,",
          "1864:      int *src, int *dest,",
          "1865:      int srcmax, int destmax,",
          "1866:      int mode,",
          "1867:      const widechar *currentInput,",
          "1868:      widechar *currentOutput,",
          "1869:      int *srcMapping,",
          "1870:      int *prevSrcMapping,",
          "1871:      formtype *typebuf,",
          "1872:      unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1873:      const TranslationTableRule **transRule,",
          "1874:      int *inputPositions,",
          "1875:      int *outputPositions,",
          "1876:      int *cursorPosition, int *cursorStatus,",
          "1877:      int compbrlStart, int compbrlEnd)",
          "1878: {",
          "1879:   int endEmph;",
          "1880:   for (endEmph = *src; (typebuf[endEmph] & computer_braille) && endEmph",
          "1881:        <= srcmax; endEmph++);",
          "1882:   return doCompTrans (*src, endEmph, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "1885: static int",
          "1886: insertBrailleIndicators (int finish,",
          "1887:     const TranslationTableHeader *table,",
          "1888:     int *src, int *dest,",
          "1889:     int srcmax, int destmax,",
          "1890:     int mode,",
          "1891:     const widechar *currentInput,",
          "1892:     widechar *currentOutput,",
          "1893:     int *srcMapping,",
          "1894:     int *prevSrcMapping,",
          "1895:     formtype *typebuf,",
          "1896:     int haveEmphasis,",
          "1897:     unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1898:     int transOpcode, int prevTransOpcode,",
          "1899:     const TranslationTableRule **transRule,",
          "1900:     int *inputPositions,",
          "1901:     int *outputPositions,",
          "1902:     int *cursorPosition, int *cursorStatus,",
          "1903:     int compbrlStart, int compbrlEnd,",
          "1904:     TranslationTableCharacterAttributes beforeAttributes,",
          "1905:     int *prevType, int *curType, int *prevTypeform,",
          "1906:     int prevSrc)",
          "1907: {",
          "1909:   typedef enum",
          "1910:   {",
          "1911:     checkNothing,",
          "1912:     checkBeginTypeform,",
          "1913:     checkEndTypeform,",
          "1914:     checkNumber,",
          "1915:     checkLetter",
          "1916:   } checkThis;",
          "1917:   checkThis checkWhat = checkNothing;",
          "1918:   int ok = 0;",
          "1919:   int k;",
          "1920:     {",
          "1921:       if (*src == prevSrc && !finish)",
          "1922:  return 1;",
          "1923:       if (*src != prevSrc)",
          "1924:  {",
          "1925:    if (haveEmphasis && (typebuf[*src] & EMPHASIS) != *prevTypeform)",
          "1926:      {",
          "1929:        checkWhat = checkEndTypeform;",
          "1930:      }",
          "1931:    else if (!finish)",
          "1932:      checkWhat = checkNothing;",
          "1933:    else",
          "1934:      checkWhat = checkNumber;",
          "1936:       if (finish == 1)",
          "1937:  checkWhat = checkNumber;",
          "1938:     }",
          "1939:   do",
          "1940:     {",
          "1941:       const TranslationTableRule *indicRule;",
          "1942:       ok = 0;",
          "1943:       switch (checkWhat)",
          "1944:  {",
          "1945:  case checkNothing:",
          "1946:    ok = 0;",
          "1947:    break;",
          "1948:  case checkBeginTypeform:",
          "1949:    if (haveEmphasis)",
          "1950:    {",
          "1951:   ok = 0;",
          "1953:    }",
          "1954:    if (*curType == plain_text)",
          "1955:      {",
          "1956:        if (!finish)",
          "1957:   checkWhat = checkNothing;",
          "1958:        else",
          "1959:   checkWhat = checkNumber;",
          "1960:      }",
          "1961:    break;",
          "1962:  case checkEndTypeform:",
          "1963:    if (haveEmphasis)",
          "1964:    {",
          "1967:    }",
          "1968:    if (*prevType == plain_text)",
          "1969:      {",
          "1970:        checkWhat = checkBeginTypeform;",
          "1972:      }",
          "1973:    break;",
          "1974:  case checkNumber:",
          "1975:    if (brailleIndicatorDefined(table->numberSign, table, &indicRule) &&",
          "1976:        checkAttr_safe (currentInput, *src, CTC_Digit, 0, table, srcmax) &&",
          "1977:        (prevTransOpcode == CTO_ExactDots",
          "1978:         || !(beforeAttributes & CTC_Digit))",
          "1979:        && prevTransOpcode != CTO_MidNum)",
          "1980:      {",
          "1981:        ok = !table->usesNumericMode;",
          "1982:        checkWhat = checkNothing;",
          "1983:      }",
          "1984:    else",
          "1985:      checkWhat = checkLetter;",
          "1986:    break;",
          "1987:  case checkLetter:",
          "1988:    if (!brailleIndicatorDefined (table->letterSign, table, &indicRule))",
          "1989:      {",
          "1990:        ok = 0;",
          "1991:        checkWhat = checkNothing;",
          "1992:        break;",
          "1993:      }",
          "1994:    if (transOpcode == CTO_Contraction)",
          "1995:      {",
          "1996:        ok = 1;",
          "1997:        checkWhat = checkNothing;",
          "1998:        break;",
          "1999:      }",
          "2000:      if ((checkAttr_safe (currentInput, *src, CTC_Letter, 0, table, srcmax)",
          "2001:         && !(beforeAttributes & CTC_Letter))",
          "2002:        && (!checkAttr_safe (currentInput, *src + 1, CTC_Letter, 0, table, srcmax)",
          "2003:     || (beforeAttributes & CTC_Digit)))",
          "2004:      {",
          "2005:        ok = 1;",
          "2006:        if (*src > 0)",
          "2007:   for (k = 0; k < table->noLetsignBeforeCount; k++)",
          "2008:     if (currentInput[*src - 1] == table->noLetsignBefore[k])",
          "2009:       {",
          "2010:         ok = 0;",
          "2011:         break;",
          "2012:       }",
          "2013:        for (k = 0; k < table->noLetsignCount; k++)",
          "2014:   if (currentInput[*src] == table->noLetsign[k])",
          "2015:     {",
          "2016:       ok = 0;",
          "2017:       break;",
          "2018:     }",
          "2019:        if ((*src + 1) < srcmax)",
          "2020:   for (k = 0; k < table->noLetsignAfterCount; k++)",
          "2021:     if (currentInput[*src + 1] == table->noLetsignAfter[k])",
          "2022:       {",
          "2023:         ok = 0;",
          "2024:         break;",
          "2025:       }",
          "2026:      }",
          "2027:    checkWhat = checkNothing;",
          "2028:    break;",
          "2030:  default:",
          "2031:    ok = 0;",
          "2032:    checkWhat = checkNothing;",
          "2033:    break;",
          "2034:  }",
          "2035:       if (ok && indicRule != NULL)",
          "2036:  {",
          "2037:    if (!for_updatePositions",
          "2038:        (&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2039:      return 0;",
          "2040:    if (*cursorStatus == 2)",
          "2041:      checkWhat = checkNothing;",
          "2042:  }",
          "2043:     }",
          "2044:   while (checkWhat != checkNothing);",
          "2045:   return 1;",
          "2049: onlyLettersBehind (const TranslationTableHeader *table,",
          "2050:      int src,",
          "2051:      const widechar *currentInput,",
          "2052:      TranslationTableCharacterAttributes beforeAttributes)",
          "2053: {",
          "2055:   int k;",
          "2056:   if (!(beforeAttributes & CTC_Space))",
          "2057:     return 0;",
          "2058:   for (k = src - 2; k >= 0; k--)",
          "2059:     {",
          "2060:       TranslationTableCharacterAttributes attr = (findCharOrDots",
          "2061:         (currentInput[k],",
          "2062:          0, table))->attributes;",
          "2063:       if ((attr & CTC_Space))",
          "2064:  continue;",
          "2065:       if ((attr & CTC_Letter))",
          "2067:       else",
          "2068:  return 0;",
          "2069:     }",
          "2070:   return 1;",
          "2074: onlyLettersAhead (const TranslationTableHeader *table,",
          "2075:     int src, int srcmax,",
          "2076:     const widechar *currentInput,",
          "2077:     int transCharslen,",
          "2078:     TranslationTableCharacterAttributes afterAttributes)",
          "2079: {",
          "2081:   int k;",
          "2082:   if (!(afterAttributes & CTC_Space))",
          "2083:     return 0;",
          "2084:   for (k = src + transCharslen + 1; k < srcmax; k++)",
          "2085:     {",
          "2086:       TranslationTableCharacterAttributes attr = (findCharOrDots",
          "2087:         (currentInput[k],",
          "2088:          0, table))->attributes;",
          "2089:       if ((attr & CTC_Space))",
          "2090:  continue;",
          "2091:       if ((attr & (CTC_Letter | CTC_LitDigit)))",
          "2092:  return 1;",
          "2093:       else",
          "2095:     }",
          "2096:   return 0;",
          "2100: noCompbrlAhead (const TranslationTableHeader *table,",
          "2101:   int src, int srcmax,",
          "2102:   int mode,",
          "2103:   const widechar *currentInput,",
          "2104:   int transOpcode,",
          "2105:   int transCharslen,",
          "2106:   int cursorPosition)",
          "2107: {",
          "2108:   int start = src + transCharslen;",
          "2109:   int end;",
          "2110:   int curSrc;",
          "2111:   if (start >= srcmax)",
          "2112:     return 1;",
          "2113:   while (start < srcmax && checkAttr (currentInput[start], CTC_Space, 0, table))",
          "2114:     start++;",
          "2115:   if (start == srcmax || (transOpcode == CTO_JoinableWord && (!checkAttr",
          "2116:              (currentInput",
          "2117:               [start],",
          "2118:               CTC_Letter |",
          "2119:               CTC_Digit, 0, table)",
          "2120:              ||",
          "2121:              !checkAttr",
          "2122:              (currentInput",
          "2123:               [start - 1],",
          "2124:               CTC_Space,",
          "2125:               0, table))))",
          "2126:     return 1;",
          "2127:   end = start;",
          "2128:   while (end < srcmax && !checkAttr (currentInput[end], CTC_Space, 0, table))",
          "2129:     end++;",
          "2130:   if ((mode & (compbrlAtCursor | compbrlLeftCursor)) && cursorPosition",
          "2131:       >= start && cursorPosition < end)",
          "2132:     return 0;",
          "2134:   for (curSrc = start; curSrc < end; curSrc++)",
          "2135:     {",
          "2136:       int length = srcmax - curSrc;",
          "2137:       int tryThis;",
          "2138:       const TranslationTableCharacter *character1;",
          "2139:       const TranslationTableCharacter *character2;",
          "2140:       int k;",
          "2141:       character1 = findCharOrDots (currentInput[curSrc], 0, table);",
          "2142:       for (tryThis = 0; tryThis < 2; tryThis++)",
          "2143:  {",
          "2144:    TranslationTableOffset ruleOffset = 0;",
          "2145:    TranslationTableRule *testRule;",
          "2146:    unsigned long int makeHash = 0;",
          "2147:    switch (tryThis)",
          "2148:      {",
          "2149:      case 0:",
          "2150:        if (!(length >= 2))",
          "2151:   break;",
          "2153:        makeHash = (unsigned long int) character1->lowercase << 8;",
          "2154:        character2 = findCharOrDots (currentInput[curSrc + 1], 0, table);",
          "2155:        makeHash += (unsigned long int) character2->lowercase;",
          "2156:        makeHash %= HASHNUM;",
          "2157:        ruleOffset = table->forRules[makeHash];",
          "2158:        break;",
          "2159:      case 1:",
          "2160:        if (!(length >= 1))",
          "2161:   break;",
          "2162:        length = 1;",
          "2163:        ruleOffset = character1->otherRules;",
          "2164:        break;",
          "2165:      }",
          "2166:    while (ruleOffset)",
          "2167:      {",
          "2168:        testRule =",
          "2169:   (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "2170:        for (k = 0; k < testRule->charslen; k++)",
          "2171:   {",
          "2172:     character1 = findCharOrDots (testRule->charsdots[k], 0, table);",
          "2173:     character2 = findCharOrDots (currentInput[curSrc + k], 0, table);",
          "2174:     if (character1->lowercase != character2->lowercase)",
          "2175:       break;",
          "2176:   }",
          "2177:        if (tryThis == 1 || k == testRule->charslen)",
          "2178:   {",
          "2179:     if (testRule->opcode == CTO_CompBrl",
          "2180:         || testRule->opcode == CTO_Literal)",
          "2181:       return 0;",
          "2183:        ruleOffset = testRule->charsnext;",
          "2184:      }",
          "2186:     }",
          "2187:   return 1;",
          "2191: isRepeatedWord (const TranslationTableHeader *table,",
          "2192:   int src, int srcmax,",
          "2193:   const widechar *currentInput,",
          "2194:   int transCharslen,",
          "2195:   const widechar **repwordStart, int *repwordLength)",
          "2196: {",
          "2197:   int start;",
          "2198:   if (src == 0 || !checkAttr (currentInput[src - 1], CTC_Letter, 0, table))",
          "2199:     return 0;",
          "2200:   if ((src + transCharslen) >= srcmax || !checkAttr (currentInput[src +",
          "2201:           transCharslen],",
          "2202:            CTC_Letter, 0, table))",
          "2203:     return 0;",
          "2204:   for (start = src - 2;",
          "2205:        start >= 0 && checkAttr (currentInput[start], CTC_Letter, 0, table); start--);",
          "2206:   start++;",
          "2209:   if (compareChars (*repwordStart, &currentInput[src",
          "2210:       + transCharslen],",
          "2212:     return 1;",
          "2213:   return 0;",
          "2217: checkEmphasisChange(const int skip,",
          "2218:       int src,",
          "2219:       unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2220:       const TranslationTableRule *transRule",
          "2221: )",
          "2222: {",
          "2223:  int i;",
          "2224:  for(i = src + (skip + 1); i < src + transRule->charslen; i++)",
          "2225:  if(emphasisBuffer[i] || transNoteBuffer[i])",
          "2226:   return 1;",
          "2231: inSequence(const TranslationTableHeader *table,",
          "2232:     int src, int srcmax,",
          "2233:     const widechar *currentInput,",
          "2234:     const TranslationTableRule *transRule)",
          "2235: {",
          "2241:  for(i = src - 1; i >= 0; i--)",
          "2242:  {",
          "2243:   if(checkAttr(currentInput[i], CTC_SeqBefore, 0, table))",
          "2244:    continue;",
          "2245:   if(!(checkAttr(currentInput[i], CTC_Space | CTC_SeqDelimiter, 0, table)))",
          "2251:  for(i = src + transRule->charslen; i < srcmax; i++)",
          "2252:  {",
          "2254:   if(table->seqPatternsCount)",
          "2255:   {",
          "2257:    for(j = i, s = 0; j <= srcmax && s < table->seqPatternsCount; j++, s++)",
          "2258:    {",
          "2260:     if(match == 1)",
          "2261:     {",
          "2262:      if(table->seqPatterns[s])",
          "2263:      {",
          "2264:       if(currentInput[j] == table->seqPatterns[s])",
          "2266:       else",
          "2267:       {",
          "2274:      else",
          "2275:      {",
          "2277:       if(j >= srcmax)",
          "2278:        return 1;",
          "2286:     else if(match == 0)",
          "2287:     {",
          "2288:      if(table->seqPatterns[s])",
          "2289:      {",
          "2290:       if(currentInput[j] == table->seqPatterns[s])",
          "2292:       else",
          "2293:       {",
          "2301:     else if(match == -1)",
          "2302:     {",
          "2303:      if(!table->seqPatterns[s])",
          "2304:      {",
          "2312:   if(checkAttr(currentInput[i], CTC_SeqAfter, 0, table))",
          "2313:    continue;",
          "2314:   if(!(checkAttr(currentInput[i], CTC_Space | CTC_SeqDelimiter, 0, table)))",
          "2323: for_selectRule (const TranslationTableHeader *table,",
          "2324:   int src, int dest, int srcmax, int destmax,",
          "2325:   int mode,",
          "2326:   const widechar *currentInput,",
          "2327:   formtype *typebuf,",
          "2328:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2329:   int *transOpcode,",
          "2330:   int prevTransOpcode,",
          "2331:   const TranslationTableRule **transRule,",
          "2332:   int *transCharslen,",
          "2333:   int *passCharDots, int *passSrc, widechar const **passInstructions, int *passIC, int *startMatch, int *startReplace, int *endReplace,",
          "2334:   int srcIncremented,",
          "2335:   int cursorPosition,",
          "2336:   const widechar **repwordStart, int *repwordLength,",
          "2337:   int dontContract,",
          "2338:   int compbrlStart, int compbrlEnd,",
          "2340:   TranslationTableCharacter **curCharDef,",
          "2341:   TranslationTableRule **groupingRule, widechar *groupingOp)",
          "2342: {",
          "2344:   static TranslationTableRule pseudoRule = {",
          "2345:     0",
          "2346:   };",
          "2347:   int length = srcmax - src;",
          "2348:   int tryThis;",
          "2349:   const TranslationTableCharacter *character2;",
          "2350:   int k;",
          "2353:   for (tryThis = 0; tryThis < 3; tryThis++)",
          "2354:     {",
          "2355:       unsigned long int makeHash = 0;",
          "2356:       switch (tryThis)",
          "2357:  {",
          "2358:  case 0:",
          "2359:    if (!(length >= 2))",
          "2360:      break;",
          "2362:    makeHash = (unsigned long int) (*curCharDef)->lowercase << 8;",
          "2363:    character2 = findCharOrDots (currentInput[src + 1], 0, table);",
          "2364:    makeHash += (unsigned long int) character2->lowercase;",
          "2365:    makeHash %= HASHNUM;",
          "2366:    ruleOffset = table->forRules[makeHash];",
          "2367:    break;",
          "2368:  case 1:",
          "2369:    if (!(length >= 1))",
          "2370:      break;",
          "2371:    length = 1;",
          "2372:    ruleOffset = (*curCharDef)->otherRules;",
          "2373:    break;",
          "2378:    pseudoRule.charsdots[0] = currentInput[src];",
          "2379:    pseudoRule.dotslen = 0;",
          "2380:    return;",
          "2381:    break;",
          "2382:  }",
          "2383:       while (ruleOffset)",
          "2384:  {",
          "2388:    if (tryThis == 1 || ((*transCharslen <= length) && validMatch (table, src, currentInput, typebuf, *transRule, *transCharslen)))",
          "2389:      {",
          "2390:        TranslationTableCharacterAttributes afterAttributes;",
          "2392:    if((*transRule)->before & CTC_EmpMatch)",
          "2393:    {",
          "2394:     if(   emphasisBuffer[src]",
          "2395:        || transNoteBuffer[src])",
          "2396:      break;",
          "2397:    }",
          "2400:    if((*transRule)->after & CTC_EmpMatch)",
          "2401:    {",
          "2402:     if(   emphasisBuffer[src + *transCharslen]",
          "2403:        || transNoteBuffer[src + *transCharslen])",
          "2404:      break;",
          "2405:    }",
          "2408:        setAfter (*transCharslen, table, src, srcmax, currentInput, &afterAttributes);",
          "2409:        if ((!((*transRule)->after & ~CTC_EmpMatch) || (beforeAttributes",
          "2410:       & (*transRule)->after)) &&",
          "2411:     (!((*transRule)->before & ~CTC_EmpMatch) || (afterAttributes",
          "2412:        & (*transRule)->before)))",
          "2413:   switch (*transOpcode)",
          "2415:     case CTO_Space:",
          "2416:     case CTO_Letter:",
          "2417:     case CTO_UpperCase:",
          "2418:     case CTO_LowerCase:",
          "2419:     case CTO_Digit:",
          "2420:     case CTO_LitDigit:",
          "2421:     case CTO_Punctuation:",
          "2422:     case CTO_Math:",
          "2423:     case CTO_Sign:",
          "2424:     case CTO_Hyphen:",
          "2425:     case CTO_Replace:",
          "2426:     case CTO_CompBrl:",
          "2427:     case CTO_Literal:",
          "2428:       return;",
          "2429:     case CTO_Repeated:",
          "2430:       if ((mode & (compbrlAtCursor | compbrlLeftCursor))",
          "2431:    && src >= compbrlStart && src <= compbrlEnd)",
          "2432:         break;",
          "2433:       return;",
          "2434:     case CTO_RepWord:",
          "2435:       if (dontContract || (mode & noContractions))",
          "2436:         break;",
          "2437:       if (isRepeatedWord (table, src, srcmax, currentInput, *transCharslen, repwordStart, repwordLength))",
          "2438:         return;",
          "2439:       break;",
          "2440:     case CTO_NoCont:",
          "2441:       if (dontContract || (mode & noContractions))",
          "2442:         break;",
          "2443:       return;",
          "2444:     case CTO_Syllable:",
          "2446:     case CTO_Always:",
          "2447:      if(checkEmphasisChange(0, src, emphasisBuffer, transNoteBuffer, *transRule))",
          "2449:       if (dontContract || (mode & noContractions))",
          "2450:         break;",
          "2451:       return;",
          "2452:     case CTO_ExactDots:",
          "2453:       return;",
          "2454:     case CTO_NoCross:",
          "2455:       if (dontContract || (mode & noContractions))",
          "2456:         break;",
          "2457:       if (syllableBreak (table, src, srcmax, currentInput, *transCharslen))",
          "2458:         break;",
          "2459:       return;",
          "2460:     case CTO_Context:",
          "2461:       if (!srcIncremented || !passDoTest (table, src, srcmax, currentInput, *transOpcode, *transRule, passCharDots, passSrc, passInstructions, passIC, startMatch, startReplace, endReplace, groupingRule, groupingOp))",
          "2462:         break;",
          "2463:       return;",
          "2464:     case CTO_LargeSign:",
          "2465:       if (dontContract || (mode & noContractions))",
          "2466:         break;",
          "2467:       if (!((beforeAttributes & (CTC_Space",
          "2468:             | CTC_Punctuation))",
          "2469:      || onlyLettersBehind (table, src, currentInput, beforeAttributes))",
          "2470:    || !((afterAttributes & CTC_Space)",
          "2471:         || prevTransOpcode == CTO_LargeSign)",
          "2472:    || (afterAttributes & CTC_Letter)",
          "2473:    || !noCompbrlAhead (table, src, srcmax, mode, currentInput, *transOpcode, *transCharslen, cursorPosition))",
          "2475:       return;",
          "2476:     case CTO_WholeWord:",
          "2477:       if (dontContract || (mode & noContractions))",
          "2478:         break;",
          "2479:      if(checkEmphasisChange(0, src, emphasisBuffer, transNoteBuffer, *transRule))",
          "2481:     case CTO_Contraction:",
          "2482:      if(table->usesSequences)",
          "2483:      {",
          "2484:       if(inSequence(table, src, srcmax, currentInput, *transRule))",
          "2486:      }",
          "2487:      else",
          "2488:      {",
          "2489:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation))",
          "2490:    && (afterAttributes & (CTC_Space | CTC_Punctuation)))",
          "2491:         return;",
          "2492:      }",
          "2493:       break;",
          "2494:     case CTO_PartWord:",
          "2495:       if (dontContract || (mode & noContractions))",
          "2496:         break;",
          "2497:       if ((beforeAttributes & CTC_Letter)",
          "2498:    || (afterAttributes & CTC_Letter))",
          "2499:         return;",
          "2500:       break;",
          "2501:     case CTO_JoinNum:",
          "2502:       if (dontContract || (mode & noContractions))",
          "2503:         break;",
          "2504:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation))",
          "2505:    &&",
          "2506:    (afterAttributes & CTC_Space) &&",
          "2507:    (dest + (*transRule)->dotslen < destmax))",
          "2508:         {",
          "2509:    int cursrc = src + *transCharslen + 1;",
          "2510:    while (cursrc < srcmax)",
          "2511:      {",
          "2512:        if (!checkAttr",
          "2513:     (currentInput[cursrc], CTC_Space, 0, table))",
          "2514:          {",
          "2515:     if (checkAttr",
          "2516:         (currentInput[cursrc], CTC_Digit, 0, table))",
          "2517:       return;",
          "2518:     break;",
          "2519:          }",
          "2520:        cursrc++;",
          "2521:      }",
          "2522:         }",
          "2523:       break;",
          "2524:     case CTO_LowWord:",
          "2525:       if (dontContract || (mode & noContractions))",
          "2526:         break;",
          "2527:       if ((beforeAttributes & CTC_Space)",
          "2528:    && (afterAttributes & CTC_Space)",
          "2529:    && (prevTransOpcode != CTO_JoinableWord))",
          "2530:         return;",
          "2531:       break;",
          "2532:     case CTO_JoinableWord:",
          "2533:       if (dontContract || (mode & noContractions))",
          "2534:         break;",
          "2535:       if (beforeAttributes & (CTC_Space | CTC_Punctuation)",
          "2536:    && onlyLettersAhead (table, src, srcmax, currentInput, *transCharslen, afterAttributes) && noCompbrlAhead (table, src, srcmax, mode, currentInput, *transOpcode, *transCharslen, cursorPosition))",
          "2537:         return;",
          "2538:       break;",
          "2539:     case CTO_SuffixableWord:",
          "2540:       if (dontContract || (mode & noContractions))",
          "2541:         break;",
          "2542:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation))",
          "2543:    && (afterAttributes &",
          "2544:        (CTC_Space | CTC_Letter | CTC_Punctuation)))",
          "2545:         return;",
          "2546:       break;",
          "2547:     case CTO_PrefixableWord:",
          "2548:       if (dontContract || (mode & noContractions))",
          "2549:         break;",
          "2550:       if ((beforeAttributes &",
          "2551:     (CTC_Space | CTC_Letter | CTC_Punctuation))",
          "2552:    && (afterAttributes & (CTC_Space | CTC_Punctuation)))",
          "2553:         return;",
          "2554:       break;",
          "2555:     case CTO_BegWord:",
          "2556:       if (dontContract || (mode & noContractions))",
          "2557:         break;",
          "2558:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation))",
          "2559:    && (afterAttributes & CTC_Letter))",
          "2560:         return;",
          "2561:       break;",
          "2562:     case CTO_BegMidWord:",
          "2563:       if (dontContract || (mode & noContractions))",
          "2564:         break;",
          "2565:       if ((beforeAttributes &",
          "2566:     (CTC_Letter | CTC_Space | CTC_Punctuation))",
          "2567:    && (afterAttributes & CTC_Letter))",
          "2568:         return;",
          "2569:       break;",
          "2570:     case CTO_MidWord:",
          "2571:       if (dontContract || (mode & noContractions))",
          "2572:         break;",
          "2573:       if (beforeAttributes & CTC_Letter",
          "2574:    && afterAttributes & CTC_Letter)",
          "2575:         return;",
          "2576:       break;",
          "2577:     case CTO_MidEndWord:",
          "2578:       if (dontContract || (mode & noContractions))",
          "2579:         break;",
          "2580:       if (beforeAttributes & CTC_Letter",
          "2581:    && afterAttributes & (CTC_Letter | CTC_Space |",
          "2582:            CTC_Punctuation))",
          "2583:         return;",
          "2584:       break;",
          "2585:     case CTO_EndWord:",
          "2586:       if (dontContract || (mode & noContractions))",
          "2587:         break;",
          "2588:       if (beforeAttributes & CTC_Letter",
          "2589:    && afterAttributes & (CTC_Space | CTC_Punctuation))",
          "2590:         return;",
          "2591:       break;",
          "2592:     case CTO_BegNum:",
          "2593:       if (beforeAttributes & (CTC_Space | CTC_Punctuation)",
          "2594:    && afterAttributes & CTC_Digit)",
          "2595:         return;",
          "2596:       break;",
          "2597:     case CTO_MidNum:",
          "2598:       if (prevTransOpcode != CTO_ExactDots",
          "2599:    && beforeAttributes & CTC_Digit",
          "2600:    && afterAttributes & CTC_Digit)",
          "2601:         return;",
          "2602:       break;",
          "2603:     case CTO_EndNum:",
          "2604:       if (beforeAttributes & CTC_Digit &&",
          "2605:    prevTransOpcode != CTO_ExactDots)",
          "2606:         return;",
          "2607:       break;",
          "2608:     case CTO_DecPoint:",
          "2609:       if (!(afterAttributes & CTC_Digit))",
          "2610:         break;",
          "2611:       if (beforeAttributes & CTC_Digit)",
          "2613:       return;",
          "2614:     case CTO_PrePunc:",
          "2615:       if (!checkAttr (currentInput[src], CTC_Punctuation, 0, table)",
          "2616:    || (src > 0",
          "2617:        && checkAttr (currentInput[src - 1], CTC_Letter,",
          "2618:        0, table)))",
          "2619:         break;",
          "2620:       for (k = src + *transCharslen; k < srcmax; k++)",
          "2621:         {",
          "2622:    if (checkAttr",
          "2623:        (currentInput[k], (CTC_Letter | CTC_Digit), 0, table))",
          "2624:      return;",
          "2625:    if (checkAttr (currentInput[k], CTC_Space, 0, table))",
          "2626:      break;",
          "2627:         }",
          "2628:       break;",
          "2629:     case CTO_PostPunc:",
          "2630:       if (!checkAttr (currentInput[src], CTC_Punctuation, 0, table)",
          "2631:    || (src < (srcmax - 1)",
          "2632:        && checkAttr (currentInput[src + 1], CTC_Letter,",
          "2633:        0, table)))",
          "2634:         break;",
          "2635:       for (k = src; k >= 0; k--)",
          "2636:         {",
          "2637:    if (checkAttr",
          "2638:        (currentInput[k], (CTC_Letter | CTC_Digit), 0, table))",
          "2639:      return;",
          "2640:    if (checkAttr (currentInput[k], CTC_Space, 0, table))",
          "2641:      break;",
          "2642:         }",
          "2643:       break;",
          "2645:     case CTO_Match:",
          "2646:     {",
          "2647:      widechar *patterns, *pattern;",
          "2649:      if(dontContract || (mode & noContractions))",
          "2651:      if(checkEmphasisChange(0, src, emphasisBuffer, transNoteBuffer, *transRule))",
          "2654:      patterns = (widechar*)&table->ruleArea[(*transRule)->patterns];",
          "2657:      pattern = &patterns[1];",
          "2658:      if(!_lou_pattern_check(currentInput, src - 1, -1, -1, pattern, table))",
          "2659:       break;",
          "2662:      pattern = &patterns[patterns[0]];",
          "2663:      if(!_lou_pattern_check(currentInput, src + (*transRule)->charslen, srcmax, 1, pattern, table))",
          "2664:       break;",
          "2666:      return;",
          "2667:     }",
          "2669:     default:",
          "2670:       break;",
          "2671:     }",
          "2672:      }",
          "2674:    ruleOffset = (*transRule)->charsnext;",
          "2676:     }",
          "2680: undefinedCharacter (widechar c,",
          "2681:       const TranslationTableHeader *table,",
          "2682:       int *src, int *dest,",
          "2683:       int srcmax, int destmax,",
          "2684:       int mode,",
          "2685:       const widechar *currentInput,",
          "2686:       widechar *currentOutput,",
          "2687:       int *srcMapping,",
          "2688:       int *prevSrcMapping,",
          "2689:       unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2690:       const TranslationTableRule **transRule,",
          "2691:       int *inputPositions,",
          "2692:       int *outputPositions,",
          "2693:       int *cursorPosition, int *cursorStatus,",
          "2694:       int compbrlStart, int compbrlEnd)",
          "2695: {",
          "2697:   int k;",
          "2698:   char *display;",
          "2699:   widechar displayDots[20];",
          "2700:   if (table->undefined)",
          "2701:     {",
          "2702:       TranslationTableRule *rule = (TranslationTableRule *)",
          "2703:  & table->ruleArea[table->undefined];",
          "2704:       if (!for_updatePositions",
          "2705:    (&rule->charsdots[rule->charslen],",
          "2706:     rule->charslen, rule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "2707:     transRule,",
          "2708:     inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2709:  return 0;",
          "2710:       return 1;",
          "2711:     }",
          "2712:   display = _lou_showString (&c, 1);",
          "2713:   for (k = 0; k < (int) strlen (display); k++)",
          "2714:     displayDots[k] = _lou_getDotsForChar (display[k]);",
          "2715:   if (!for_updatePositions (displayDots, 1, (int)strlen(display), 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2716:     return 0;",
          "2717:   return 1;",
          "2721: putCharacter (widechar character,",
          "2722:        const TranslationTableHeader *table,",
          "2723:        int *src, int *dest,",
          "2724:        int srcmax, int destmax,",
          "2725:        int mode,",
          "2726:        const widechar *currentInput,",
          "2727:        widechar *currentOutput,",
          "2728:        int *srcMapping,",
          "2729:        int *prevSrcMapping,",
          "2730:        unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2731:        const TranslationTableRule **transRule,",
          "2732:        int *inputPositions,",
          "2733:        int *outputPositions,",
          "2734:        int *cursorPosition, int *cursorStatus,",
          "2735:        int compbrlStart, int compbrlEnd)",
          "2736: {",
          "2739:   TranslationTableCharacter *chardef = NULL;",
          "2740:   TranslationTableOffset offset;",
          "2741:   widechar d;",
          "2742:   if (*cursorStatus == 2)",
          "2743:     return 1;",
          "2744:   chardef = (findCharOrDots (character, 0, table));",
          "2745:   if ((chardef->attributes & CTC_Letter) && (chardef->attributes &",
          "2746:           CTC_UpperCase))",
          "2747:     chardef = findCharOrDots (chardef->lowercase, 0, table);",
          "2751:   offset = chardef->definitionRule;",
          "",
          "[Added Lines]",
          "41: #define CAPSEMPH 0x8000",
          "43: #define EMPHASIS 0x3fff  // all typeform bits that can be used",
          "46: #define WORD_CHAR 0x00000001",
          "47: #define WORD_RESET 0x00000002",
          "48: #define WORD_STOP 0x00000004",
          "49: #define WORD_WHOLE 0x00000008",
          "50: #define LAST_WORD_AFTER 0x01000000",
          "53: #define CAPS_BEGIN 0x00000010",
          "54: #define CAPS_END 0x00000020",
          "55: #define CAPS_WORD 0x00000040",
          "56: #define CAPS_SYMBOL 0x00000080",
          "57: #define CAPS_EMPHASIS 0x000000f0",
          "58: #define EMPHASIS_BEGIN 0x00000100",
          "59: #define EMPHASIS_END 0x00000200",
          "60: #define EMPHASIS_WORD 0x00000400",
          "61: #define EMPHASIS_SYMBOL 0x00000800",
          "62: #define EMPHASIS_MASK 0x00000f00",
          "63: #define COMPBRL_BEGIN 0x10000000",
          "64: #define COMPBRL_END 0x20000000",
          "67: #define TRANSNOTE_BEGIN 0x00000001",
          "68: #define TRANSNOTE_END 0x00000002",
          "69: #define TRANSNOTE_WORD 0x00000004",
          "70: #define TRANSNOTE_SYMBOL 0x00000008",
          "71: #define TRANSNOTE_MASK 0x0000000f",
          "73: static int",
          "74: putCharacter(widechar c, const TranslationTableHeader *table, int *src, int *dest,",
          "75:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "76:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "77:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "78:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "79:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd);",
          "80: static int",
          "81: passDoTest(const TranslationTableHeader *table, int src, int srcmax,",
          "82:   const widechar *currentInput, int transOpcode,",
          "83:   const TranslationTableRule *transRule, int *passCharDots, int *passSrc,",
          "84:   const widechar **passInstructions, int *passIC, int *startMatch,",
          "85:   int *startReplace, int *endReplace, TranslationTableRule **groupingRule,",
          "86:   widechar *groupingOp);",
          "87: static int",
          "88: passDoAction(const TranslationTableHeader *table, int *src, int *dest, int *srcmax,",
          "89:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "90:   int *srcMapping, int *prevSrcMapping, unsigned int *emphasisBuffer,",
          "91:   unsigned int *transNoteBuffer, int transOpcode,",
          "92:   const TranslationTableRule **transRule, int passCharDots, int passSrc,",
          "93:   const widechar *passInstructions, int startMatch, int startReplace, int *passIC,",
          "94:   int *endReplace, int *inputPositions, int *outputPositions, int *cursorPosition,",
          "95:   int *cursorStatus, int compbrlStart, int compbrlEnd,",
          "96:   TranslationTableRule *groupingRule, widechar groupingOp);",
          "103: findCharOrDots(widechar c, int m, const TranslationTableHeader *table) {",
          "106:  static TranslationTableCharacter noChar = { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "107:  static TranslationTableCharacter noDots = { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "108:  TranslationTableCharacter *notFound;",
          "109:  TranslationTableCharacter *character;",
          "110:  TranslationTableOffset bucket;",
          "111:  unsigned long int makeHash = (unsigned long int)c % HASHNUM;",
          "112:  if (m == 0) {",
          "113:   bucket = table->characters[makeHash];",
          "114:   notFound = &noChar;",
          "115:  } else {",
          "116:   bucket = table->dots[makeHash];",
          "117:   notFound = &noDots;",
          "118:  }",
          "119:  while (bucket) {",
          "120:   character = (TranslationTableCharacter *)&table->ruleArea[bucket];",
          "121:   if (character->realchar == c) return character;",
          "122:   bucket = character->next;",
          "123:  }",
          "124:  notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "125:  return notFound;",
          "129: checkAttr(const widechar c, const TranslationTableCharacterAttributes a, int m,",
          "130:   const TranslationTableHeader *table) {",
          "131:  static widechar prevc = 0;",
          "132:  static TranslationTableCharacterAttributes preva = 0;",
          "133:  if (c != prevc) {",
          "134:   preva = (findCharOrDots(c, m, table))->attributes;",
          "135:   prevc = c;",
          "136:  }",
          "137:  return ((preva & a) ? 1 : 0);",
          "141: checkAttr_safe(const widechar *currentInput, int src,",
          "143:   const TranslationTableHeader *table, int srcmax) {",
          "144:  return ((src < srcmax) ? checkAttr(currentInput[src], a, m, table) : 0);",
          "148: findForPassRule(const TranslationTableHeader *table, int src, int srcmax, int currentPass,",
          "149:   const widechar *currentInput, int *transOpcode,",
          "150:   const TranslationTableRule **transRule, int *transCharslen, int *passCharDots,",
          "151:   int *passSrc, widechar const **passInstructions, int *passIC, int *startMatch,",
          "152:   int *startReplace, int *endReplace, TranslationTableRule **groupingRule,",
          "153:   widechar *groupingOp) {",
          "154:  int save_transCharslen = *transCharslen;",
          "155:  const TranslationTableRule *save_transRule = *transRule;",
          "156:  TranslationTableOpcode save_transOpcode = *transOpcode;",
          "157:  TranslationTableOffset ruleOffset;",
          "158:  ruleOffset = table->forPassRules[currentPass];",
          "160:  while (ruleOffset) {",
          "163:   if (passDoTest(table, src, srcmax, currentInput, *transOpcode, *transRule,",
          "164:      passCharDots, passSrc, passInstructions, passIC, startMatch,",
          "165:      startReplace, endReplace, groupingRule, groupingOp))",
          "166:    return 1;",
          "167:   ruleOffset = (*transRule)->charsnext;",
          "168:  }",
          "172:  return 0;",
          "176: compareChars(const widechar *address1, const widechar *address2, int count, int m,",
          "177:   const TranslationTableHeader *table) {",
          "178:  int k;",
          "179:  if (!count) return 0;",
          "180:  for (k = 0; k < count; k++)",
          "181:   if ((findCharOrDots(address1[k], m, table))->lowercase !=",
          "182:     (findCharOrDots(address2[k], m, table))->lowercase)",
          "183:    return 0;",
          "184:  return 1;",
          "188: makeCorrections(const TranslationTableHeader *table, int *dest, int *srcmax, int destmax,",
          "189:   int mode, const widechar *currentInput, widechar *currentOutput, int *srcMapping,",
          "190:   int *prevSrcMapping, formtype *typebuf, unsigned int *emphasisBuffer,",
          "191:   unsigned int *transNoteBuffer, int *realInlen, int *srcIncremented,",
          "192:   int *inputPositions, int *outputPositions, int *cursorPosition, int *cursorStatus,",
          "193:   int compbrlStart, int compbrlEnd) {",
          "194:  int src;",
          "195:  int transOpcode;",
          "196:  const TranslationTableRule *transRule;",
          "197:  int transCharslen;",
          "198:  int passCharDots;",
          "199:  int passSrc;",
          "200:  const widechar *passInstructions;",
          "202:  int startMatch;",
          "203:  int startReplace;",
          "204:  int endReplace;",
          "205:  TranslationTableRule *groupingRule;",
          "206:  widechar groupingOp;",
          "207:  if (!table->corrections) return 1;",
          "208:  src = 0;",
          "211:  _lou_resetPassVariables();",
          "212:  while (src < *srcmax) {",
          "213:   int length = *srcmax - src;",
          "214:   const TranslationTableCharacter *character =",
          "215:     findCharOrDots(currentInput[src], 0, table);",
          "216:   const TranslationTableCharacter *character2;",
          "217:   int tryThis = 0;",
          "218:   if (!findForPassRule(table, src, *srcmax, 0, currentInput, &transOpcode,",
          "219:      &transRule, &transCharslen, &passCharDots, &passSrc,",
          "220:      &passInstructions, &passIC, &startMatch, &startReplace, &endReplace,",
          "221:      &groupingRule, &groupingOp))",
          "222:    while (tryThis < 3) {",
          "223:     TranslationTableOffset ruleOffset = 0;",
          "224:     unsigned long int makeHash = 0;",
          "225:     switch (tryThis) {",
          "226:     case 0:",
          "227:      if (!(length >= 2)) break;",
          "228:      makeHash = (unsigned long int)character->lowercase << 8;",
          "229:      character2 = findCharOrDots(currentInput[src + 1], 0, table);",
          "230:      makeHash += (unsigned long int)character2->lowercase;",
          "231:      makeHash %= HASHNUM;",
          "232:      ruleOffset = table->forRules[makeHash];",
          "233:      break;",
          "234:     case 1:",
          "235:      if (!(length >= 1)) break;",
          "236:      length = 1;",
          "237:      ruleOffset = character->otherRules;",
          "238:      break;",
          "240:      transOpcode = CTO_Always;",
          "241:      ruleOffset = 0;",
          "242:      break;",
          "243:     }",
          "244:     while (ruleOffset) {",
          "245:      transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];",
          "246:      transOpcode = transRule->opcode;",
          "247:      transCharslen = transRule->charslen;",
          "248:      if (tryThis == 1 || (transCharslen <= length &&",
          "249:             compareChars(&transRule->charsdots[0],",
          "250:               &currentInput[src], transCharslen,",
          "251:               0, table))) {",
          "252:       if (*srcIncremented && transOpcode == CTO_Correct &&",
          "253:         passDoTest(table, src, *srcmax, currentInput, transOpcode,",
          "254:           transRule, &passCharDots, &passSrc,",
          "255:           &passInstructions, &passIC, &startMatch,",
          "256:           &startReplace, &endReplace, &groupingRule,",
          "257:           &groupingOp)) {",
          "258:        tryThis = 4;",
          "259:        break;",
          "260:       }",
          "261:      }",
          "262:      ruleOffset = transRule->charsnext;",
          "263:     }",
          "264:     tryThis++;",
          "265:    }",
          "268:   switch (transOpcode) {",
          "269:   case CTO_Always:",
          "270:    if (*dest >= destmax) goto failure;",
          "271:    srcMapping[*dest] = prevSrcMapping[src];",
          "272:    currentOutput[(*dest)++] = currentInput[src++];",
          "274:   case CTO_Correct:",
          "275:    if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "276:     appliedRules[appliedRulesCount++] = transRule;",
          "277:    if (!passDoAction(table, &src, dest, srcmax, destmax, mode, currentInput,",
          "278:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "279:       transNoteBuffer, transOpcode, &transRule, passCharDots, passSrc,",
          "280:       passInstructions, startMatch, startReplace, &passIC, &endReplace,",
          "281:       inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "282:       compbrlStart, compbrlEnd, groupingRule, groupingOp))",
          "283:     goto failure;",
          "284:    if (endReplace == src) *srcIncremented = 0;",
          "285:    src = endReplace;",
          "286:    break;",
          "287:   default:",
          "288:    break;",
          "289:   }",
          "290:  }",
          "292:  {  // We have to transform typebuf accordingly",
          "293:   int pos;",
          "294:   formtype *typebuf_temp;",
          "295:   if ((typebuf_temp = malloc(*dest * sizeof(formtype))) == NULL) _lou_outOfMemory();",
          "296:   for (pos = 0; pos < *dest; pos++) typebuf_temp[pos] = typebuf[srcMapping[pos]];",
          "297:   memcpy(typebuf, typebuf_temp, *dest * sizeof(formtype));",
          "298:   free(typebuf_temp);",
          "303:  return 1;",
          "307: matchCurrentInput(const widechar *currentInput, int passSrc,",
          "308:   const widechar *passInstructions, int passIC) {",
          "309:  int k;",
          "310:  int kk = passSrc;",
          "311:  for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)",
          "312:   if (currentInput[kk] == ENDSEGMENT || passInstructions[k] != currentInput[kk++])",
          "313:    return 0;",
          "314:  return 1;",
          "318: swapTest(int swapIC, int *callSrc, const TranslationTableHeader *table,",
          "319:   const widechar *currentInput, const widechar *passInstructions) {",
          "320:  int curLen;",
          "321:  int curTest;",
          "322:  int curSrc = *callSrc;",
          "323:  TranslationTableOffset swapRuleOffset;",
          "324:  TranslationTableRule *swapRule;",
          "325:  swapRuleOffset = (passInstructions[swapIC + 1] << 16) | passInstructions[swapIC + 2];",
          "326:  swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];",
          "327:  for (curLen = 0; curLen < passInstructions[swapIC + 3]; curLen++) {",
          "328:   if (swapRule->opcode == CTO_SwapDd) {",
          "329:    for (curTest = 1; curTest < swapRule->charslen; curTest += 2) {",
          "330:     if (currentInput[curSrc] == swapRule->charsdots[curTest]) break;",
          "331:    }",
          "332:   } else {",
          "333:    for (curTest = 0; curTest < swapRule->charslen; curTest++) {",
          "334:     if (currentInput[curSrc] == swapRule->charsdots[curTest]) break;",
          "335:    }",
          "336:   }",
          "337:   if (curTest >= swapRule->charslen) return 0;",
          "338:   curSrc++;",
          "340:  if (passInstructions[swapIC + 3] == passInstructions[swapIC + 4]) {",
          "342:   return 1;",
          "344:  while (curLen < passInstructions[swapIC + 4]) {",
          "345:   if (swapRule->opcode == CTO_SwapDd) {",
          "346:    for (curTest = 1; curTest < swapRule->charslen; curTest += 2) {",
          "347:     if (currentInput[curSrc] == swapRule->charsdots[curTest]) break;",
          "348:    }",
          "349:   } else {",
          "350:    for (curTest = 0; curTest < swapRule->charslen; curTest++) {",
          "351:     if (currentInput[curSrc] == swapRule->charsdots[curTest]) break;",
          "352:    }",
          "353:   }",
          "354:   if (curTest >= swapRule->charslen) {",
          "356:    return 1;",
          "357:   }",
          "358:   curSrc++;",
          "359:   curLen++;",
          "362:  return 1;",
          "366: swapReplace(int start, int end, const TranslationTableHeader *table, int *dest,",
          "367:   int destmax, const widechar *currentInput, widechar *currentOutput,",
          "368:   int *srcMapping, int *prevSrcMapping, const widechar *passInstructions,",
          "369:   int passIC) {",
          "370:  TranslationTableOffset swapRuleOffset;",
          "371:  TranslationTableRule *swapRule;",
          "372:  widechar *replacements;",
          "373:  int curRep;",
          "374:  int curPos;",
          "375:  int curTest;",
          "376:  int curSrc;",
          "377:  swapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];",
          "378:  swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];",
          "379:  replacements = &swapRule->charsdots[swapRule->charslen];",
          "380:  for (curSrc = start; curSrc < end; curSrc++) {",
          "381:   for (curTest = 0; curTest < swapRule->charslen; curTest++)",
          "382:    if (currentInput[curSrc] == swapRule->charsdots[curTest]) break;",
          "383:   if (curTest == swapRule->charslen) continue;",
          "384:   curPos = 0;",
          "385:   for (curRep = 0; curRep < curTest; curRep++)",
          "386:    if (swapRule->opcode == CTO_SwapCc)",
          "387:     curPos++;",
          "388:    else",
          "389:     curPos += replacements[curPos];",
          "390:   if (swapRule->opcode == CTO_SwapCc) {",
          "391:    if ((*dest + 1) > destmax) return 0;",
          "392:    srcMapping[*dest] = prevSrcMapping[curSrc];",
          "393:    currentOutput[(*dest)++] = replacements[curPos];",
          "394:   } else {",
          "395:    int l = replacements[curPos] - 1;",
          "396:    int d = *dest + l;",
          "397:    if (d > destmax) return 0;",
          "398:    while (--d >= *dest) srcMapping[d] = prevSrcMapping[curSrc];",
          "399:    memcpy(&currentOutput[*dest], &replacements[curPos + 1],",
          "400:      l * sizeof(*currentOutput));",
          "402:   }",
          "404:  return 1;",
          "408: replaceGrouping(const TranslationTableHeader *table, int *dest, int srcmax,",
          "409:   const widechar *currentInput, widechar *currentOutput, int *srcMapping,",
          "410:   int *prevSrcMapping, int transOpcode, int passCharDots,",
          "411:   const widechar *passInstructions, int passIC, int startReplace,",
          "412:   TranslationTableRule *groupingRule, widechar groupingOp) {",
          "413:  widechar startCharDots = groupingRule->charsdots[2 * passCharDots];",
          "414:  widechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];",
          "415:  widechar *curin = (widechar *)currentInput;",
          "416:  int curPos;",
          "417:  int level = 0;",
          "418:  TranslationTableOffset replaceOffset =",
          "419:    passInstructions[passIC + 1] << 16 | (passInstructions[passIC + 2] & 0xff);",
          "420:  TranslationTableRule *replaceRule =",
          "421:    (TranslationTableRule *)&table->ruleArea[replaceOffset];",
          "422:  widechar replaceStart = replaceRule->charsdots[2 * passCharDots];",
          "423:  widechar replaceEnd = replaceRule->charsdots[2 * passCharDots + 1];",
          "424:  if (groupingOp == pass_groupstart) {",
          "425:   curin[startReplace] = replaceStart;",
          "426:   for (curPos = startReplace + 1; curPos < srcmax; curPos++) {",
          "427:    if (currentInput[curPos] == startCharDots) level--;",
          "428:    if (currentInput[curPos] == endCharDots) level++;",
          "429:    if (level == 1) break;",
          "430:   }",
          "431:   if (curPos == srcmax) return 0;",
          "432:   curin[curPos] = replaceEnd;",
          "433:  } else {",
          "434:   if (transOpcode == CTO_Context) {",
          "435:    startCharDots = groupingRule->charsdots[2];",
          "436:    endCharDots = groupingRule->charsdots[3];",
          "437:    replaceStart = replaceRule->charsdots[2];",
          "438:    replaceEnd = replaceRule->charsdots[3];",
          "439:   }",
          "440:   currentOutput[*dest] = replaceEnd;",
          "441:   for (curPos = *dest - 1; curPos >= 0; curPos--) {",
          "442:    if (currentOutput[curPos] == endCharDots) level--;",
          "443:    if (currentOutput[curPos] == startCharDots) level++;",
          "444:    if (level == 1) break;",
          "445:   }",
          "446:   if (curPos < 0) return 0;",
          "447:   currentOutput[curPos] = replaceStart;",
          "448:   (*dest)++;",
          "450:  return 1;",
          "454: removeGrouping(int *dest, int *srcmax, const widechar *currentInput,",
          "455:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping, int passCharDots,",
          "456:   int startReplace, int endReplace, TranslationTableRule *groupingRule,",
          "457:   widechar groupingOp) {",
          "458:  widechar startCharDots = groupingRule->charsdots[2 * passCharDots];",
          "459:  widechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];",
          "460:  widechar *curin = (widechar *)currentInput;",
          "461:  int curPos;",
          "462:  int level = 0;",
          "463:  if (groupingOp == pass_groupstart) {",
          "464:   for (curPos = startReplace + 1; curPos < *srcmax; curPos++) {",
          "465:    if (currentInput[curPos] == startCharDots) level--;",
          "466:    if (currentInput[curPos] == endCharDots) level++;",
          "467:    if (level == 1) break;",
          "468:   }",
          "469:   if (curPos == *srcmax) return 0;",
          "470:   curPos++;",
          "471:   for (; curPos < *srcmax; curPos++) curin[curPos - 1] = curin[curPos];",
          "472:   (*srcmax)--;",
          "473:  } else {",
          "474:   for (curPos = *dest - 1; curPos >= 0; curPos--) {",
          "475:    if (currentOutput[curPos] == endCharDots) level--;",
          "476:    if (currentOutput[curPos] == startCharDots) level++;",
          "477:    if (level == 1) break;",
          "478:   }",
          "479:   if (curPos < 0) return 0;",
          "480:   curPos++;",
          "481:   for (; curPos < *dest; curPos++)",
          "482:    currentOutput[curPos - 1] = currentOutput[curPos];",
          "483:   (*dest)--;",
          "485:  return 1;",
          "489: doPassSearch(const TranslationTableHeader *table, int srcmax,",
          "490:   const widechar *currentInput, const TranslationTableRule *transRule,",
          "491:   int passCharDots, int passSrc, const widechar *passInstructions, int passIC,",
          "492:   int *searchIC, int *searchSrc, TranslationTableRule *groupingRule,",
          "493:   widechar groupingOp) {",
          "494:  int level = 0;",
          "495:  int k, kk;",
          "496:  int not = 0;",
          "497:  TranslationTableOffset ruleOffset;",
          "498:  TranslationTableRule *rule;",
          "499:  TranslationTableCharacterAttributes attributes;",
          "500:  int stepper = passSrc;",
          "501:  while (stepper < srcmax) {",
          "504:   while (*searchIC < transRule->dotslen) {",
          "505:    int itsTrue = 1;",
          "506:    if (*searchSrc > srcmax) return 0;",
          "507:    switch (passInstructions[*searchIC]) {",
          "508:    case pass_lookback:",
          "510:     if (*searchSrc < 0) {",
          "512:      itsTrue = 0;",
          "513:     }",
          "515:     break;",
          "516:    case pass_not:",
          "517:     not = !not;",
          "518:     (*searchIC)++;",
          "519:     continue;",
          "520:    case pass_string:",
          "521:    case pass_dots:",
          "522:     kk = *searchSrc;",
          "523:     for (k = *searchIC + 2;",
          "524:       k < *searchIC + 2 + passInstructions[*searchIC + 1]; k++)",
          "525:      if (currentInput[kk] == ENDSEGMENT ||",
          "526:        passInstructions[k] != currentInput[kk++]) {",
          "527:       itsTrue = 0;",
          "528:       break;",
          "529:      }",
          "532:     break;",
          "533:    case pass_startReplace:",
          "534:     (*searchIC)++;",
          "535:     break;",
          "536:    case pass_endReplace:",
          "537:     (*searchIC)++;",
          "538:     break;",
          "539:    case pass_attributes:",
          "540:     attributes = (passInstructions[*searchIC + 1] << 16) |",
          "541:       passInstructions[*searchIC + 2];",
          "542:     for (k = 0; k < passInstructions[*searchIC + 3]; k++) {",
          "543:      if (currentInput[*searchSrc] == ENDSEGMENT)",
          "544:       itsTrue = 0;",
          "545:      else",
          "546:       itsTrue = ((findCharOrDots(currentInput[(*searchSrc)++],",
          "547:            passCharDots,",
          "548:            table)->attributes &",
          "549:              attributes)",
          "550:           ? 1",
          "551:           : 0);",
          "552:      if (!itsTrue) break;",
          "553:     }",
          "554:     if (itsTrue) {",
          "555:      for (k = passInstructions[*searchIC + 3];",
          "556:        k < passInstructions[*searchIC + 4]; k++) {",
          "557:       if (currentInput[*searchSrc] == ENDSEGMENT) {",
          "558:        itsTrue = 0;",
          "559:        break;",
          "560:       }",
          "561:       if (!(findCharOrDots(currentInput[*searchSrc], passCharDots,",
          "562:            table)->attributes &",
          "563:          attributes))",
          "564:        break;",
          "565:       (*searchSrc)++;",
          "566:      }",
          "567:     }",
          "569:     break;",
          "570:    case pass_groupstart:",
          "571:    case pass_groupend:",
          "572:     ruleOffset = (passInstructions[*searchIC + 1] << 16) |",
          "573:       passInstructions[*searchIC + 2];",
          "574:     rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];",
          "575:     if (passInstructions[*searchIC] == pass_groupstart)",
          "576:      itsTrue = (currentInput[*searchSrc] ==",
          "577:            rule->charsdots[2 * passCharDots])",
          "578:        ? 1",
          "579:        : 0;",
          "580:     else",
          "581:      itsTrue = (currentInput[*searchSrc] ==",
          "582:            rule->charsdots[2 * passCharDots + 1])",
          "583:        ? 1",
          "584:        : 0;",
          "585:     if (groupingRule != NULL && groupingOp == pass_groupstart &&",
          "586:       rule == groupingRule) {",
          "587:      if (currentInput[*searchSrc] == rule->charsdots[2 * passCharDots])",
          "588:       level--;",
          "589:      else if (currentInput[*searchSrc] ==",
          "590:        rule->charsdots[2 * passCharDots + 1])",
          "591:       level++;",
          "592:     }",
          "593:     (*searchSrc)++;",
          "595:     break;",
          "596:    case pass_swap:",
          "597:     itsTrue = swapTest(",
          "600:     break;",
          "601:    case pass_endTest:",
          "602:     if (itsTrue) {",
          "603:      if ((groupingRule && level == 1) || !groupingRule) return 1;",
          "604:     }",
          "606:     break;",
          "607:    default:",
          "608:     if (_lou_handlePassVariableTest(passInstructions, searchIC, &itsTrue))",
          "609:      break;",
          "610:     break;",
          "612:    if ((!not&&!itsTrue) || (not&&itsTrue)) break;",
          "613:    not = 0;",
          "615:   stepper++;",
          "617:  return 0;",
          "621: passDoTest(const TranslationTableHeader *table, int src, int srcmax,",
          "622:   const widechar *currentInput, int transOpcode,",
          "623:   const TranslationTableRule *transRule, int *passCharDots, int *passSrc,",
          "624:   widechar const **passInstructions, int *passIC, int *startMatch,",
          "625:   int *startReplace, int *endReplace, TranslationTableRule **groupingRule,",
          "626:   widechar *groupingOp) {",
          "627:  int endMatch;",
          "628:  int searchIC, searchSrc;",
          "629:  int k;",
          "630:  int not = 0;",
          "631:  TranslationTableOffset ruleOffset = 0;",
          "632:  TranslationTableRule *rule = NULL;",
          "633:  TranslationTableCharacterAttributes attributes = 0;",
          "640:  if (transOpcode == CTO_Context || transOpcode == CTO_Correct)",
          "642:  else",
          "644:  while (*passIC < transRule->dotslen) {",
          "645:   int itsTrue = 1;",
          "646:   if (*passSrc > srcmax) return 0;",
          "647:   switch ((*passInstructions)[*passIC]) {",
          "648:   case pass_first:",
          "649:    if (*passSrc != 0) itsTrue = 0;",
          "650:    (*passIC)++;",
          "651:    break;",
          "652:   case pass_last:",
          "653:    if (*passSrc != srcmax) itsTrue = 0;",
          "654:    (*passIC)++;",
          "655:    break;",
          "656:   case pass_lookback:",
          "658:    if (*passSrc < 0) {",
          "659:     searchSrc = 0;",
          "660:     itsTrue = 0;",
          "661:    }",
          "663:    break;",
          "664:   case pass_not:",
          "665:    not = !not;",
          "666:    (*passIC)++;",
          "667:    continue;",
          "668:   case pass_string:",
          "669:   case pass_dots:",
          "670:    itsTrue =",
          "671:      matchCurrentInput(currentInput, *passSrc, *passInstructions, *passIC);",
          "674:    break;",
          "675:   case pass_startReplace:",
          "677:    (*passIC)++;",
          "678:    break;",
          "679:   case pass_endReplace:",
          "681:    (*passIC)++;",
          "682:    break;",
          "683:   case pass_attributes:",
          "684:    attributes = ((*passInstructions)[*passIC + 1] << 16) |",
          "685:      (*passInstructions)[*passIC + 2];",
          "686:    for (k = 0; k < (*passInstructions)[*passIC + 3]; k++) {",
          "687:     if (*passSrc >= srcmax) {",
          "688:      itsTrue = 0;",
          "689:      break;",
          "690:     }",
          "691:     if (currentInput[*passSrc] == ENDSEGMENT) {",
          "692:      itsTrue = 0;",
          "693:      break;",
          "694:     }",
          "695:     if (!(findCharOrDots(currentInput[*passSrc], *passCharDots,",
          "696:          table)->attributes &",
          "697:        attributes)) {",
          "698:      itsTrue = 0;",
          "699:      break;",
          "700:     }",
          "702:    }",
          "703:    if (itsTrue) {",
          "704:     for (k = (*passInstructions)[*passIC + 3];",
          "705:       k < (*passInstructions)[*passIC + 4] && *passSrc < srcmax; k++) {",
          "706:      if (currentInput[*passSrc] == ENDSEGMENT) {",
          "707:       itsTrue = 0;",
          "708:       break;",
          "709:      }",
          "710:      if (!(findCharOrDots(currentInput[*passSrc], *passCharDots,",
          "711:           table)->attributes &",
          "712:         attributes)) {",
          "713:       break;",
          "714:      }",
          "716:     }",
          "717:    }",
          "719:    break;",
          "720:   case pass_groupstart:",
          "721:   case pass_groupend:",
          "722:    ruleOffset = ((*passInstructions)[*passIC + 1] << 16) |",
          "723:      (*passInstructions)[*passIC + 2];",
          "724:    rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];",
          "725:    if (*passIC == 0 ||",
          "726:      (*passIC > 0 &&",
          "727:        (*passInstructions)[*passIC - 1] == pass_startReplace)) {",
          "730:    }",
          "731:    if ((*passInstructions)[*passIC] == pass_groupstart)",
          "732:     itsTrue = (currentInput[*passSrc] == rule->charsdots[2 * *passCharDots])",
          "733:       ? 1",
          "734:       : 0;",
          "735:    else",
          "736:     itsTrue =",
          "737:       (currentInput[*passSrc] == rule->charsdots[2 * *passCharDots + 1])",
          "738:       ? 1",
          "739:       : 0;",
          "740:    (*passSrc)++;",
          "742:    break;",
          "743:   case pass_swap:",
          "744:    itsTrue = swapTest(*passIC, passSrc, table, currentInput, *passInstructions);",
          "746:    break;",
          "747:   case pass_search:",
          "748:    itsTrue = doPassSearch(table, srcmax, currentInput, transRule, *passCharDots,",
          "751:    if ((!not&&!itsTrue) || (not&&itsTrue)) return 0;",
          "754:   case pass_endTest:",
          "755:    (*passIC)++;",
          "756:    endMatch = *passSrc;",
          "757:    if (*startReplace == -1) {",
          "760:    }",
          "761:    return 1;",
          "762:    break;",
          "763:   default:",
          "764:    if (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue)) break;",
          "765:    return 0;",
          "767:   if ((!not&&!itsTrue) || (not&&itsTrue)) return 0;",
          "768:   not = 0;",
          "774: copyCharacters(int from, int to, const TranslationTableHeader *table, int *src, int *dest,",
          "775:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "776:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "777:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer, int transOpcode,",
          "778:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "779:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "780:  if (transOpcode == CTO_Context) {",
          "781:   while (from < to)",
          "782:    if (!putCharacter(currentInput[from++], table, src, dest, srcmax, destmax,",
          "783:       mode, currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "784:       emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "785:       outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "786:       compbrlEnd))",
          "787:     return 0;",
          "788:  } else {",
          "789:   int count = to - from;",
          "791:   if (count > 0) {",
          "792:    if ((*dest + count) > destmax) return 0;",
          "794:    memmove(&srcMapping[*dest], &prevSrcMapping[from],",
          "795:      count * sizeof(*srcMapping));",
          "796:    memcpy(&currentOutput[*dest], &currentInput[from],",
          "797:      count * sizeof(*currentOutput));",
          "799:   }",
          "802:  return 1;",
          "806: passDoAction(const TranslationTableHeader *table, int *src, int *dest, int *srcmax,",
          "807:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "808:   int *srcMapping, int *prevSrcMapping, unsigned int *emphasisBuffer,",
          "809:   unsigned int *transNoteBuffer, int transOpcode,",
          "810:   const TranslationTableRule **transRule, int passCharDots, int passSrc,",
          "811:   const widechar *passInstructions, int startMatch, int startReplace, int *passIC,",
          "812:   int *endReplace, int *inputPositions, int *outputPositions, int *cursorPosition,",
          "813:   int *cursorStatus, int compbrlStart, int compbrlEnd,",
          "814:   TranslationTableRule *groupingRule, widechar groupingOp) {",
          "815:  int k;",
          "816:  TranslationTableOffset ruleOffset = 0;",
          "817:  TranslationTableRule *rule = NULL;",
          "819:  int srcInitial = startMatch;",
          "820:  int srcStart = startReplace;",
          "821:  int srcEnd = *endReplace;",
          "822:  int destInitial = *dest;",
          "823:  int destStart;",
          "825:  if (!copyCharacters(srcInitial, srcStart, table, src, dest, *srcmax, destmax, mode,",
          "826:     currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "827:     transNoteBuffer, transOpcode, transRule, inputPositions, outputPositions,",
          "828:     cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "829:   return 0;",
          "830:  destStart = *dest;",
          "832:  while (*passIC < (*transRule)->dotslen) switch (passInstructions[*passIC]) {",
          "833:   case pass_string:",
          "834:   case pass_dots:",
          "835:    if ((*dest + passInstructions[*passIC + 1]) > destmax) return 0;",
          "836:    for (k = 0; k < passInstructions[*passIC + 1]; ++k)",
          "837:     srcMapping[*dest + k] = prevSrcMapping[startReplace];",
          "838:    memcpy(&currentOutput[*dest], &passInstructions[*passIC + 2],",
          "839:      passInstructions[*passIC + 1] * CHARSIZE);",
          "842:    break;",
          "843:   case pass_groupstart:",
          "844:    ruleOffset =",
          "845:      (passInstructions[*passIC + 1] << 16) | passInstructions[*passIC + 2];",
          "846:    rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];",
          "847:    srcMapping[*dest] = prevSrcMapping[startMatch];",
          "848:    currentOutput[(*dest)++] = rule->charsdots[2 * passCharDots];",
          "850:    break;",
          "851:   case pass_groupend:",
          "852:    ruleOffset =",
          "853:      (passInstructions[*passIC + 1] << 16) | passInstructions[*passIC + 2];",
          "854:    rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];",
          "855:    srcMapping[*dest] = prevSrcMapping[startMatch];",
          "856:    currentOutput[(*dest)++] = rule->charsdots[2 * passCharDots + 1];",
          "858:    break;",
          "859:   case pass_swap:",
          "860:    if (!swapReplace(startReplace, *endReplace, table, dest, destmax,",
          "861:       currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "862:       passInstructions, *passIC))",
          "863:     return 0;",
          "865:    break;",
          "866:   case pass_groupreplace:",
          "867:    if (!groupingRule ||",
          "868:      !replaceGrouping(table, dest, *srcmax, currentInput, currentOutput,",
          "869:        srcMapping, prevSrcMapping, transOpcode, passCharDots,",
          "870:        passInstructions, *passIC, startReplace, groupingRule,",
          "871:        groupingOp))",
          "872:     return 0;",
          "874:    break;",
          "875:   case pass_omit:",
          "876:    if (groupingRule)",
          "877:     removeGrouping(dest, srcmax, currentInput, currentOutput, srcMapping,",
          "878:       prevSrcMapping, passCharDots, startReplace, *endReplace,",
          "879:       groupingRule, groupingOp);",
          "880:    (*passIC)++;",
          "881:    break;",
          "882:   case pass_copy: {",
          "883:    int count = destStart - destInitial;",
          "885:    if (count > 0) {",
          "886:     memmove(&currentOutput[destInitial], &currentOutput[destStart],",
          "887:       count * sizeof(*currentOutput));",
          "889:     destStart = destInitial;",
          "890:    }",
          "891:   }",
          "893:    if (!copyCharacters(srcStart, srcEnd, table, src, dest, *srcmax, destmax,",
          "894:       mode, currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "895:       emphasisBuffer, transNoteBuffer, transOpcode, transRule,",
          "896:       inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "897:       compbrlStart, compbrlEnd))",
          "898:     return 0;",
          "900:    (*passIC)++;",
          "901:    break;",
          "902:   default:",
          "903:    if (_lou_handlePassVariableAction(passInstructions, passIC)) break;",
          "904:    return 0;",
          "905:   }",
          "906:  return 1;",
          "910: passSelectRule(const TranslationTableHeader *table, int src, int srcmax, int currentPass,",
          "911:   const widechar *currentInput, int *transOpcode,",
          "912:   const TranslationTableRule **transRule, int *transCharslen, int *passCharDots,",
          "913:   int *passSrc, widechar const **passInstructions, int *passIC, int *startMatch,",
          "914:   int *startReplace, int *endReplace, TranslationTableRule **groupingRule,",
          "915:   widechar *groupingOp) {",
          "916:  if (!findForPassRule(table, src, srcmax, currentPass, currentInput, transOpcode,",
          "917:     transRule, transCharslen, passCharDots, passSrc, passInstructions, passIC,",
          "918:     startMatch, startReplace, endReplace, groupingRule, groupingOp)) {",
          "920:  }",
          "924: translatePass(const TranslationTableHeader *table, int *dest, int *srcmax, int destmax,",
          "925:   int mode, int currentPass, const widechar *currentInput, widechar *currentOutput,",
          "926:   int *srcMapping, int *prevSrcMapping, unsigned int *emphasisBuffer,",
          "927:   unsigned int *transNoteBuffer, int *srcIncremented, int *inputPositions,",
          "928:   int *outputPositions, int *cursorPosition, int *cursorStatus, int compbrlStart,",
          "929:   int compbrlEnd) {",
          "930:  int src;",
          "931:  int transOpcode;",
          "932:  int prevTransOpcode;",
          "933:  const TranslationTableRule *transRule;",
          "934:  int transCharslen;",
          "935:  int passCharDots;",
          "936:  int passSrc;",
          "937:  const widechar *passInstructions;",
          "939:  int startMatch;",
          "940:  int startReplace;",
          "941:  int endReplace;",
          "942:  TranslationTableRule *groupingRule;",
          "943:  widechar groupingOp;",
          "944:  prevTransOpcode = CTO_None;",
          "945:  src = *dest = 0;",
          "947:  _lou_resetPassVariables();",
          "949:   passSelectRule(table, src, *srcmax, currentPass, currentInput, &transOpcode,",
          "950:     &transRule, &transCharslen, &passCharDots, &passSrc, &passInstructions,",
          "951:     &passIC, &startMatch, &startReplace, &endReplace, &groupingRule,",
          "952:     &groupingOp);",
          "954:   switch (transOpcode) {",
          "955:   case CTO_Context:",
          "956:   case CTO_Pass2:",
          "957:   case CTO_Pass3:",
          "958:   case CTO_Pass4:",
          "959:    if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "960:     appliedRules[appliedRulesCount++] = transRule;",
          "961:    if (!passDoAction(table, &src, dest, srcmax, destmax, mode, currentInput,",
          "962:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "963:       transNoteBuffer, transOpcode, &transRule, passCharDots, passSrc,",
          "964:       passInstructions, startMatch, startReplace, &passIC, &endReplace,",
          "965:       inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "966:       compbrlStart, compbrlEnd, groupingRule, groupingOp))",
          "967:     goto failure;",
          "968:    if (endReplace == src) *srcIncremented = 0;",
          "969:    src = endReplace;",
          "970:    break;",
          "971:   case CTO_Always:",
          "972:    if ((*dest + 1) > destmax) goto failure;",
          "973:    srcMapping[*dest] = prevSrcMapping[src];",
          "974:    currentOutput[(*dest)++] = currentInput[src++];",
          "975:    break;",
          "976:   default:",
          "977:    goto failure;",
          "978:   }",
          "980:  srcMapping[*dest] = prevSrcMapping[src];",
          "981: failure:",
          "982:  if (src < *srcmax) {",
          "983:   while (checkAttr(currentInput[src], CTC_Space, 1, table))",
          "984:    if (++src == *srcmax) break;",
          "985:  }",
          "986:  return 1;",
          "989: #define MIN(a, b) (((a) < (b)) ? (a) : (b))",
          "991: static int",
          "992: translateString(const TranslationTableHeader *table, int *dest, int *srcmax, int destmax,",
          "993:   int mode, int currentPass, const widechar *currentInput, widechar *currentOutput,",
          "994:   int *srcMapping, int *prevSrcMapping, formtype *typebuf,",
          "995:   unsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,",
          "996:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer, int haveEmphasis,",
          "997:   int *realInlen, int *srcIncremented, int *inputPositions, int *outputPositions,",
          "998:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd);",
          "1001: lou_translateString(const char *tableList, const widechar *inbufx, int *inlen,",
          "1002:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode) {",
          "1003:  return lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,",
          "1004:    NULL, NULL, NULL, mode);",
          "1008: lou_translate(const char *tableList, const widechar *inbufx, int *inlen, widechar *outbuf,",
          "1009:   int *outlen, formtype *typeform, char *spacing, int *outputPos, int *inputPos,",
          "1010:   int *cursorPos, int mode) {",
          "1011:  return _lou_translateWithTracing(tableList, inbufx, inlen, outbuf, outlen, typeform,",
          "1012:    spacing, outputPos, inputPos, cursorPos, mode, NULL, NULL);",
          "1016: _lou_translateWithTracing(const char *tableList, const widechar *inbufx, int *inlen,",
          "1017:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "1018:   int *inputPos, int *cursorPos, int mode, const TranslationTableRule **rules,",
          "1019:   int *rulesLen) {",
          "1032:  const TranslationTableHeader *table;",
          "1033:  int srcmax;",
          "1034:  int destmax;",
          "1035:  int dest;",
          "1036:  const widechar *currentInput;",
          "1037:  widechar *currentOutput;",
          "1038:  widechar *passbuf1;",
          "1039:  widechar *passbuf2;",
          "1040:  int *srcMapping;",
          "1041:  int *prevSrcMapping;",
          "1042:  formtype *typebuf;",
          "1043:  unsigned char *srcSpacing;",
          "1044:  unsigned char *destSpacing;",
          "1045:  unsigned int *wordBuffer;",
          "1046:  unsigned int *emphasisBuffer;",
          "1047:  unsigned int *transNoteBuffer;",
          "1048:  int *inputPositions;",
          "1049:  int *outputPositions;",
          "1050:  int cursorPosition;",
          "1051:  int cursorStatus;",
          "1052:  int haveEmphasis;",
          "1053:  int compbrlStart;",
          "1054:  int compbrlEnd;",
          "1055:  int k;",
          "1056:  int goodTrans = 1;",
          "1057:  int realInlen;",
          "1058:  int srcIncremented;",
          "1059:  if (tableList == NULL || inbufx == NULL || inlen == NULL || outbuf == NULL ||",
          "1060:    outlen == NULL)",
          "1061:   return 0;",
          "1062:  _lou_logMessage(",
          "1063:    LOG_ALL, \"Performing translation: tableList=%s, inlen=%d\", tableList, *inlen);",
          "1064:  _lou_logWidecharBuf(LOG_ALL, \"Inbuf=\", inbufx, *inlen);",
          "1066:  table = lou_getTable(tableList);",
          "1067:  if (table == NULL || *inlen < 0 || *outlen < 0) return 0;",
          "1068:  currentInput = (widechar *)inbufx;",
          "1069:  srcmax = 0;",
          "1070:  while (srcmax < *inlen && currentInput[srcmax]) srcmax++;",
          "1071:  destmax = *outlen;",
          "1072:  haveEmphasis = 0;",
          "1073:  if (!(typebuf = _lou_allocMem(alloc_typebuf, srcmax, destmax))) return 0;",
          "1074:  if (typeform != NULL) {",
          "1075:   for (k = 0; k < srcmax; k++) {",
          "1077:    if (typebuf[k] & EMPHASIS) haveEmphasis = 1;",
          "1079:  } else",
          "1080:   memset(typebuf, 0, srcmax * sizeof(formtype));",
          "1082:  if ((wordBuffer = _lou_allocMem(alloc_wordBuffer, srcmax, destmax)))",
          "1086:  if ((emphasisBuffer = _lou_allocMem(alloc_emphasisBuffer, srcmax, destmax)))",
          "1090:  if ((transNoteBuffer = _lou_allocMem(alloc_transNoteBuffer, srcmax, destmax)))",
          "1095:  if (!(spacing == NULL || *spacing == 'X'))",
          "1096:   srcSpacing = (unsigned char *)spacing;",
          "1097:  else",
          "1098:   srcSpacing = NULL;",
          "1099:  outputPositions = outputPos;",
          "1100:  if (outputPos != NULL)",
          "1101:   for (k = 0; k < srcmax; k++) outputPos[k] = -1;",
          "1102:  inputPositions = inputPos;",
          "1103:  if (cursorPos != NULL && *cursorPos >= 0) {",
          "1104:   cursorStatus = 0;",
          "1105:   cursorPosition = *cursorPos;",
          "1106:   if ((mode & (compbrlAtCursor | compbrlLeftCursor))) {",
          "1107:    compbrlStart = cursorPosition;",
          "1108:    if (checkAttr(currentInput[compbrlStart], CTC_Space, 0, table))",
          "1109:     compbrlEnd = compbrlStart + 1;",
          "1110:    else {",
          "1111:     while (compbrlStart >= 0 &&",
          "1112:       !checkAttr(currentInput[compbrlStart], CTC_Space, 0, table))",
          "1113:      compbrlStart--;",
          "1114:     compbrlStart++;",
          "1115:     compbrlEnd = cursorPosition;",
          "1116:     if (!(mode & compbrlLeftCursor))",
          "1117:      while (compbrlEnd < srcmax &&",
          "1118:        !checkAttr(currentInput[compbrlEnd], CTC_Space, 0, table))",
          "1119:       compbrlEnd++;",
          "1120:    }",
          "1121:   }",
          "1122:  } else {",
          "1123:   cursorPosition = -1;",
          "1126:  if (!(passbuf1 = _lou_allocMem(alloc_passbuf1, srcmax, destmax))) return 0;",
          "1127:  if (!(srcMapping = _lou_allocMem(alloc_srcMapping, srcmax, destmax))) return 0;",
          "1128:  if (!(prevSrcMapping = _lou_allocMem(alloc_prevSrcMapping, srcmax, destmax)))",
          "1129:   return 0;",
          "1130:  for (k = 0; k <= srcmax; k++) srcMapping[k] = k;",
          "1131:  srcMapping[srcmax] = srcmax;",
          "1132:  if ((!(mode & pass1Only)) && (table->numPasses > 1 || table->corrections)) {",
          "1133:   if (!(passbuf2 = _lou_allocMem(alloc_passbuf2, srcmax, destmax))) return 0;",
          "1134:  }",
          "1135:  if (srcSpacing != NULL) {",
          "1136:   if (!(destSpacing = _lou_allocMem(alloc_destSpacing, srcmax, destmax)))",
          "1137:    goodTrans = 0;",
          "1138:   else",
          "1139:    memset(destSpacing, '*', destmax);",
          "1140:  } else",
          "1141:   destSpacing = NULL;",
          "1142:  appliedRulesCount = 0;",
          "1143:  if (rules != NULL && rulesLen != NULL) {",
          "1144:   appliedRules = rules;",
          "1145:   maxAppliedRules = *rulesLen;",
          "1146:  } else {",
          "1147:   appliedRules = NULL;",
          "1148:   maxAppliedRules = 0;",
          "1149:  }",
          "1150:  int currentPass = 0;",
          "1151:  if ((mode & pass1Only)) {",
          "1152:   currentOutput = passbuf1;",
          "1153:   memcpy(prevSrcMapping, srcMapping, destmax * sizeof(int));",
          "1154:   goodTrans = translateString(table, &dest, &srcmax, destmax, mode, currentPass,",
          "1155:     currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf,",
          "1156:     srcSpacing, destSpacing, wordBuffer, emphasisBuffer, transNoteBuffer,",
          "1157:     haveEmphasis, &realInlen, &srcIncremented, inputPositions,",
          "1158:     outputPositions, &cursorPosition, &cursorStatus, compbrlStart,",
          "1159:     compbrlEnd);",
          "1161:  }",
          "1162:  while (currentPass <= table->numPasses && goodTrans) {",
          "1163:   memcpy(prevSrcMapping, srcMapping, destmax * sizeof(int));",
          "1164:   switch (currentPass) {",
          "1165:   case 0:",
          "1166:    if (table->corrections) {",
          "1167:     currentOutput = passbuf2;",
          "1168:     goodTrans = makeCorrections(table, &dest, &srcmax, destmax, mode,",
          "1169:       currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf,",
          "1170:       emphasisBuffer, transNoteBuffer, &realInlen, &srcIncremented,",
          "1171:       inputPositions, outputPositions, &cursorPosition, &cursorStatus,",
          "1172:       compbrlStart, compbrlEnd);",
          "1173:     currentInput = passbuf2;",
          "1174:     srcmax = dest;",
          "1175:    }",
          "1176:    break;",
          "1177:   case 1:",
          "1178:    currentOutput = passbuf1;",
          "1179:    goodTrans = translateString(table, &dest, &srcmax, destmax, mode, currentPass,",
          "1180:      currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf,",
          "1181:      srcSpacing, destSpacing, wordBuffer, emphasisBuffer, transNoteBuffer,",
          "1182:      haveEmphasis, &realInlen, &srcIncremented, inputPositions,",
          "1183:      outputPositions, &cursorPosition, &cursorStatus, compbrlStart,",
          "1184:      compbrlEnd);",
          "1185:    break;",
          "1186:   case 2:",
          "1187:    srcmax = dest;",
          "1188:    currentInput = passbuf1;",
          "1189:    currentOutput = passbuf2;",
          "1190:    goodTrans = translatePass(table, &dest, &srcmax, destmax, mode, currentPass,",
          "1191:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "1192:      emphasisBuffer, transNoteBuffer, &srcIncremented, inputPositions,",
          "1193:      outputPositions, &cursorPosition, &cursorStatus, compbrlStart,",
          "1194:      compbrlEnd);",
          "1195:    break;",
          "1196:   case 3:",
          "1197:    srcmax = dest;",
          "1198:    currentInput = passbuf2;",
          "1199:    currentOutput = passbuf1;",
          "1200:    goodTrans = translatePass(table, &dest, &srcmax, destmax, mode, currentPass,",
          "1201:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "1202:      emphasisBuffer, transNoteBuffer, &srcIncremented, inputPositions,",
          "1203:      outputPositions, &cursorPosition, &cursorStatus, compbrlStart,",
          "1204:      compbrlEnd);",
          "1205:    break;",
          "1206:   case 4:",
          "1207:    srcmax = dest;",
          "1208:    currentInput = passbuf1;",
          "1209:    currentOutput = passbuf2;",
          "1210:    goodTrans = translatePass(table, &dest, &srcmax, destmax, mode, currentPass,",
          "1211:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "1212:      emphasisBuffer, transNoteBuffer, &srcIncremented, inputPositions,",
          "1213:      outputPositions, &cursorPosition, &cursorStatus, compbrlStart,",
          "1214:      compbrlEnd);",
          "1215:    break;",
          "1216:   default:",
          "1217:    break;",
          "1218:   }",
          "1219:   currentPass++;",
          "1221:  if (goodTrans) {",
          "1222:   for (k = 0; k < dest; k++) {",
          "1223:    if (typeform != NULL) {",
          "1224:     if ((currentOutput[k] & (B7 | B8)))",
          "1225:      typeform[k] = '8';",
          "1226:     else",
          "1227:      typeform[k] = '0';",
          "1228:    }",
          "1229:    if ((mode & dotsIO)) {",
          "1230:     if ((mode & ucBrl))",
          "1231:      outbuf[k] = ((currentOutput[k] & 0xff) | 0x2800);",
          "1232:     else",
          "1233:      outbuf[k] = currentOutput[k];",
          "1234:    } else",
          "1235:     outbuf[k] = _lou_getCharFromDots(currentOutput[k]);",
          "1236:   }",
          "1239:   if (inputPositions != NULL)",
          "1240:    memcpy(inputPositions, srcMapping, dest * sizeof(int));",
          "1241:   if (outputPos != NULL) {",
          "1242:    int lastpos = 0;",
          "1243:    for (k = 0; k < *inlen; k++)",
          "1244:     if (outputPos[k] == -1)",
          "1245:      outputPos[k] = lastpos;",
          "1246:     else",
          "1247:      lastpos = outputPos[k];",
          "1248:   }",
          "1250:  if (destSpacing != NULL) {",
          "1251:   memcpy(srcSpacing, destSpacing, srcmax);",
          "1252:   srcSpacing[srcmax] = 0;",
          "1253:  }",
          "1254:  if (cursorPos != NULL && *cursorPos != -1) {",
          "1255:   if (outputPos != NULL)",
          "1257:   else",
          "1260:  if (rulesLen != NULL) *rulesLen = appliedRulesCount;",
          "1261:  _lou_logMessage(LOG_ALL, \"Translation complete: outlen=%d\", *outlen);",
          "1262:  _lou_logWidecharBuf(LOG_ALL, \"Outbuf=\", (const widechar *)outbuf, *outlen);",
          "1264:  return goodTrans;",
          "1268: lou_translatePrehyphenated(const char *tableList, const widechar *inbufx, int *inlen,",
          "1269:   widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,",
          "1270:   int *inputPos, int *cursorPos, char *inputHyphens, char *outputHyphens,",
          "1271:   int mode) {",
          "1272:  int rv = 1;",
          "1273:  int *alloc_inputPos = NULL;",
          "1274:  if (inputHyphens != NULL) {",
          "1275:   if (outputHyphens == NULL) return 0;",
          "1276:   if (inputPos == NULL) {",
          "1277:    if ((alloc_inputPos = malloc(*outlen * sizeof(int))) == NULL)",
          "1278:     _lou_outOfMemory();",
          "1279:    inputPos = alloc_inputPos;",
          "1280:   }",
          "1282:  if (lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,",
          "1283:     outputPos, inputPos, cursorPos, mode)) {",
          "1284:   if (inputHyphens != NULL) {",
          "1285:    int inpos = 0;",
          "1286:    int outpos;",
          "1287:    for (outpos = 0; outpos < *outlen; outpos++) {",
          "1288:     int new_inpos = inputPos[outpos];",
          "1289:     if (new_inpos < inpos) {",
          "1290:      rv = 0;",
          "1291:      break;",
          "1292:     }",
          "1293:     if (new_inpos > inpos)",
          "1294:      outputHyphens[outpos] = inputHyphens[new_inpos];",
          "1295:     else",
          "1296:      outputHyphens[outpos] = '0';",
          "1297:     inpos = new_inpos;",
          "1298:    }",
          "1301:  if (alloc_inputPos != NULL) free(alloc_inputPos);",
          "1302:  return rv;",
          "1306: hyphenate(const widechar *word, int wordSize, char *hyphens,",
          "1307:   const TranslationTableHeader *table) {",
          "1308:  widechar *prepWord;",
          "1309:  int i, k, limit;",
          "1310:  int stateNum;",
          "1311:  widechar ch;",
          "1312:  HyphenationState *statesArray =",
          "1313:    (HyphenationState *)&table->ruleArea[table->hyphenStatesArray];",
          "1314:  HyphenationState *currentState;",
          "1315:  HyphenationTrans *transitionsArray;",
          "1316:  char *hyphenPattern;",
          "1317:  int patternOffset;",
          "1318:  if (!table->hyphenStatesArray || (wordSize + 3) > MAXSTRING) return 0;",
          "1319:  prepWord = (widechar *)calloc(wordSize + 3, sizeof(widechar));",
          "1322:  prepWord[0] = '.';",
          "1323:  for (i = 0; i < wordSize; i++) {",
          "1324:   prepWord[i + 1] = (findCharOrDots(word[i], 0, table))->lowercase;",
          "1325:   hyphens[i] = '0';",
          "1326:  }",
          "1327:  prepWord[wordSize + 1] = '.';",
          "1330:  stateNum = 0;",
          "1333:  for (i = 0; i < wordSize + 2; i++) {",
          "1334:   ch = prepWord[i];",
          "1335:   while (1) {",
          "1336:    if (stateNum == 0xffff) {",
          "1337:     stateNum = 0;",
          "1338:     goto nextLetter;",
          "1339:    }",
          "1340:    currentState = &statesArray[stateNum];",
          "1341:    if (currentState->trans.offset) {",
          "1342:     transitionsArray =",
          "1343:       (HyphenationTrans *)&table->ruleArea[currentState->trans.offset];",
          "1344:     for (k = 0; k < currentState->numTrans; k++) {",
          "1345:      if (transitionsArray[k].ch == ch) {",
          "1346:       stateNum = transitionsArray[k].newState;",
          "1347:       goto stateFound;",
          "1348:      }",
          "1349:     }",
          "1350:    }",
          "1351:    stateNum = currentState->fallbackState;",
          "1353:  stateFound:",
          "1354:   currentState = &statesArray[stateNum];",
          "1355:   if (currentState->hyphenPattern) {",
          "1356:    hyphenPattern = (char *)&table->ruleArea[currentState->hyphenPattern];",
          "1357:    patternOffset = i + 1 - (int)strlen(hyphenPattern);",
          "1362:    limit = MIN((int)strlen(hyphenPattern), wordSize - patternOffset);",
          "1363:    for (k = 0; k < limit; k++) {",
          "1364:     if (hyphens[patternOffset + k] < hyphenPattern[k])",
          "1365:      hyphens[patternOffset + k] = hyphenPattern[k];",
          "1366:    }",
          "1367:   }",
          "1368:  nextLetter:;",
          "1370:  hyphens[wordSize] = 0;",
          "1371:  free(prepWord);",
          "1372:  return 1;",
          "1375: static int",
          "1376: doCompTrans(int start, int end, const TranslationTableHeader *table, int *src, int *dest,",
          "1377:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "1378:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "1379:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1380:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "1381:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd);",
          "1384: for_updatePositions(const widechar *outChars, int inLength, int outLength, int shift,",
          "1385:   const TranslationTableHeader *table, int *src, int *dest, int srcmax, int destmax,",
          "1386:   int mode, const widechar *currentInput, widechar *currentOutput, int *srcMapping,",
          "1387:   int *prevSrcMapping, unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1388:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "1389:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "1390:  int k;",
          "1391:  if ((*dest + outLength) > destmax || (*src + inLength) > srcmax) return 0;",
          "1392:  memcpy(&currentOutput[*dest], outChars, outLength * CHARSIZE);",
          "1393:  if (!*cursorStatus) {",
          "1394:   if ((mode & (compbrlAtCursor | compbrlLeftCursor))) {",
          "1395:    if (*src >= compbrlStart) {",
          "1397:     return doCompTrans(compbrlStart, compbrlEnd, table, src, dest, srcmax,",
          "1398:       destmax, mode, currentInput, currentOutput, srcMapping,",
          "1399:       prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule,",
          "1400:       inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "1401:       compbrlStart, compbrlEnd);",
          "1402:    }",
          "1403:   } else if (*cursorPosition >= *src && *cursorPosition < (*src + inLength)) {",
          "1406:   } else if (currentInput[*cursorPosition] == 0 &&",
          "1410:   }",
          "1411:  } else if (*cursorStatus == 2 && *cursorPosition == *src)",
          "1413:  if (inputPositions != NULL || outputPositions != NULL) {",
          "1414:   if (outLength <= inLength) {",
          "1415:    for (k = 0; k < outLength; k++) {",
          "1416:     if (inputPositions != NULL)",
          "1417:      srcMapping[*dest + k] = prevSrcMapping[*src] + shift;",
          "1418:     if (outputPositions != NULL)",
          "1419:      outputPositions[prevSrcMapping[*src + k]] = *dest;",
          "1420:    }",
          "1421:    for (k = outLength; k < inLength; k++)",
          "1422:     if (outputPositions != NULL)",
          "1423:      outputPositions[prevSrcMapping[*src + k]] = *dest;",
          "1424:   } else {",
          "1425:    for (k = 0; k < inLength; k++) {",
          "1426:     if (inputPositions != NULL)",
          "1427:      srcMapping[*dest + k] = prevSrcMapping[*src] + shift;",
          "1428:     if (outputPositions != NULL)",
          "1429:      outputPositions[prevSrcMapping[*src + k]] = *dest;",
          "1430:    }",
          "1431:    for (k = inLength; k < outLength; k++)",
          "1432:     if (inputPositions != NULL)",
          "1433:      srcMapping[*dest + k] = prevSrcMapping[*src] + shift;",
          "1434:   }",
          "1437:  return 1;",
          "1441: syllableBreak(const TranslationTableHeader *table, int src, int srcmax,",
          "1442:   const widechar *currentInput, int transCharslen) {",
          "1443:  int wordStart = 0;",
          "1444:  int wordEnd = 0;",
          "1445:  int wordSize = 0;",
          "1446:  int k = 0;",
          "1447:  char *hyphens = NULL;",
          "1448:  for (wordStart = src; wordStart >= 0; wordStart--)",
          "1449:   if (!((findCharOrDots(currentInput[wordStart], 0, table))->attributes &",
          "1450:      CTC_Letter)) {",
          "1451:    wordStart++;",
          "1452:    break;",
          "1453:   }",
          "1454:  if (wordStart < 0) wordStart = 0;",
          "1455:  for (wordEnd = src; wordEnd < srcmax; wordEnd++)",
          "1456:   if (!((findCharOrDots(currentInput[wordEnd], 0, table))->attributes &",
          "1457:      CTC_Letter)) {",
          "1458:    wordEnd--;",
          "1459:    break;",
          "1460:   }",
          "1461:  if (wordEnd == srcmax) wordEnd--;",
          "1465:  wordSize = wordEnd - wordStart + 1;",
          "1466:  hyphens = (char *)calloc(wordSize + 1, sizeof(char));",
          "1467:  if (!hyphenate(&currentInput[wordStart], wordSize, hyphens, table)) {",
          "1468:   free(hyphens);",
          "1469:   return 0;",
          "1470:  }",
          "1471:  for (k = src - wordStart + 1; k < (src - wordStart + transCharslen); k++)",
          "1472:   if (hyphens[k] & 1) {",
          "1473:    free(hyphens);",
          "1474:    return 1;",
          "1475:   }",
          "1476:  free(hyphens);",
          "1477:  return 0;",
          "1481: setBefore(const TranslationTableHeader *table, int src, const widechar *currentInput,",
          "1482:   TranslationTableCharacterAttributes *beforeAttributes) {",
          "1483:  widechar before;",
          "1484:  if (src >= 2 && currentInput[src - 1] == ENDSEGMENT)",
          "1485:   before = currentInput[src - 2];",
          "1486:  else",
          "1487:   before = (src == 0) ? ' ' : currentInput[src - 1];",
          "1492: setAfter(int length, const TranslationTableHeader *table, int src, int srcmax,",
          "1493:   const widechar *currentInput,",
          "1494:   TranslationTableCharacterAttributes *afterAttributes) {",
          "1495:  widechar after;",
          "1496:  if ((src + length + 2) < srcmax && currentInput[src + 1] == ENDSEGMENT)",
          "1497:   after = currentInput[src + 2];",
          "1498:  else",
          "1499:   after = (src + length < srcmax) ? currentInput[src + length] : ' ';",
          "1504: brailleIndicatorDefined(TranslationTableOffset offset,",
          "1505:   const TranslationTableHeader *table, const TranslationTableRule **indicRule) {",
          "1506:  if (!offset) return 0;",
          "1508:  return 1;",
          "1512: validMatch(const TranslationTableHeader *table, int src, const widechar *currentInput,",
          "1513:   formtype *typebuf, const TranslationTableRule *transRule, int transCharslen) {",
          "1515:  TranslationTableCharacter *currentInputChar;",
          "1516:  TranslationTableCharacter *ruleChar;",
          "1517:  TranslationTableCharacterAttributes prevAttr = 0;",
          "1518:  int k;",
          "1519:  int kk = 0;",
          "1520:  if (!transCharslen) return 0;",
          "1521:  for (k = src; k < src + transCharslen; k++) {",
          "1522:   if (currentInput[k] == ENDSEGMENT) {",
          "1523:    if (k == src && transCharslen == 1)",
          "1524:     return 1;",
          "1525:    else",
          "1526:     return 0;",
          "1527:   }",
          "1528:   currentInputChar = findCharOrDots(currentInput[k], 0, table);",
          "1529:   if (k == src) prevAttr = currentInputChar->attributes;",
          "1530:   ruleChar = findCharOrDots(transRule->charsdots[kk++], 0, table);",
          "1531:   if ((currentInputChar->lowercase != ruleChar->lowercase)) return 0;",
          "1532:   if (typebuf != NULL && (typebuf[src] & CAPSEMPH) == 0 &&",
          "1533:     (typebuf[k] | typebuf[src]) != typebuf[src])",
          "1534:    return 0;",
          "1535:   if (currentInputChar->attributes != CTC_Letter) {",
          "1536:    if (k != (src + 1) && (prevAttr & CTC_Letter) &&",
          "1537:      (currentInputChar->attributes & CTC_Letter) &&",
          "1538:      ((currentInputChar->attributes &",
          "1539:         (CTC_LowerCase | CTC_UpperCase | CTC_Letter)) !=",
          "1540:        (prevAttr & (CTC_LowerCase | CTC_UpperCase | CTC_Letter))))",
          "1541:     return 0;",
          "1542:   }",
          "1543:   prevAttr = currentInputChar->attributes;",
          "1545:  return 1;",
          "1549: doCompEmph(const TranslationTableHeader *table, int *src, int *dest, int srcmax,",
          "1550:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "1551:   int *srcMapping, int *prevSrcMapping, formtype *typebuf,",
          "1552:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1553:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "1554:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "1555:  int endEmph;",
          "1556:  for (endEmph = *src; (typebuf[endEmph] & computer_braille) && endEmph <= srcmax;",
          "1557:    endEmph++)",
          "1558:   ;",
          "1559:  return doCompTrans(*src, endEmph, table, src, dest, srcmax, destmax, mode,",
          "1560:    currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "1561:    transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition,",
          "1562:    cursorStatus, compbrlStart, compbrlEnd);",
          "1565: static int",
          "1566: insertBrailleIndicators(int finish, const TranslationTableHeader *table, int *src,",
          "1567:   int *dest, int srcmax, int destmax, int mode, const widechar *currentInput,",
          "1568:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping, formtype *typebuf,",
          "1569:   int haveEmphasis, unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "1570:   int transOpcode, int prevTransOpcode, const TranslationTableRule **transRule,",
          "1571:   int *inputPositions, int *outputPositions, int *cursorPosition, int *cursorStatus,",
          "1572:   int compbrlStart, int compbrlEnd,",
          "1573:   TranslationTableCharacterAttributes beforeAttributes, int *prevType, int *curType,",
          "1574:   int *prevTypeform, int prevSrc) {",
          "1576:  typedef enum {",
          "1577:   checkNothing,",
          "1578:   checkBeginTypeform,",
          "1579:   checkEndTypeform,",
          "1580:   checkNumber,",
          "1581:   checkLetter",
          "1582:  } checkThis;",
          "1583:  checkThis checkWhat = checkNothing;",
          "1584:  int ok = 0;",
          "1585:  int k;",
          "1586:  {",
          "1587:   if (*src == prevSrc && !finish) return 1;",
          "1588:   if (*src != prevSrc) {",
          "1589:    if (haveEmphasis && (typebuf[*src] & EMPHASIS) != *prevTypeform) {",
          "1592:     checkWhat = checkEndTypeform;",
          "1593:    } else if (!finish)",
          "1594:     checkWhat = checkNothing;",
          "1595:    else",
          "1596:     checkWhat = checkNumber;",
          "1597:   }",
          "1598:   if (finish == 1) checkWhat = checkNumber;",
          "1600:  do {",
          "1601:   const TranslationTableRule *indicRule;",
          "1603:   switch (checkWhat) {",
          "1604:   case checkNothing:",
          "1605:    ok = 0;",
          "1606:    break;",
          "1607:   case checkBeginTypeform:",
          "1608:    if (haveEmphasis) {",
          "1609:     ok = 0;",
          "1611:    }",
          "1612:    if (*curType == plain_text) {",
          "1613:     if (!finish)",
          "1614:      checkWhat = checkNothing;",
          "1615:     else",
          "1616:      checkWhat = checkNumber;",
          "1617:    }",
          "1618:    break;",
          "1619:   case checkEndTypeform:",
          "1620:    if (haveEmphasis) {",
          "1621:     ok = 0;",
          "1623:    }",
          "1624:    if (*prevType == plain_text) {",
          "1625:     checkWhat = checkBeginTypeform;",
          "1627:    }",
          "1628:    break;",
          "1629:   case checkNumber:",
          "1630:    if (brailleIndicatorDefined(table->numberSign, table, &indicRule) &&",
          "1631:      checkAttr_safe(currentInput, *src, CTC_Digit, 0, table, srcmax) &&",
          "1632:      (prevTransOpcode == CTO_ExactDots ||",
          "1633:        !(beforeAttributes & CTC_Digit)) &&",
          "1634:      prevTransOpcode != CTO_MidNum) {",
          "1635:     ok = !table->usesNumericMode;",
          "1636:     checkWhat = checkNothing;",
          "1637:    } else",
          "1638:     checkWhat = checkLetter;",
          "1639:    break;",
          "1640:   case checkLetter:",
          "1641:    if (!brailleIndicatorDefined(table->letterSign, table, &indicRule)) {",
          "1642:     ok = 0;",
          "1643:     checkWhat = checkNothing;",
          "1644:     break;",
          "1645:    }",
          "1646:    if (transOpcode == CTO_Contraction) {",
          "1647:     ok = 1;",
          "1648:     checkWhat = checkNothing;",
          "1649:     break;",
          "1650:    }",
          "1651:    if ((checkAttr_safe(currentInput, *src, CTC_Letter, 0, table, srcmax) &&",
          "1652:       !(beforeAttributes & CTC_Letter)) &&",
          "1653:      (!checkAttr_safe(",
          "1654:         currentInput, *src + 1, CTC_Letter, 0, table, srcmax) ||",
          "1655:        (beforeAttributes & CTC_Digit))) {",
          "1656:     ok = 1;",
          "1657:     if (*src > 0)",
          "1658:      for (k = 0; k < table->noLetsignBeforeCount; k++)",
          "1659:       if (currentInput[*src - 1] == table->noLetsignBefore[k]) {",
          "1660:        ok = 0;",
          "1661:        break;",
          "1662:       }",
          "1663:     for (k = 0; k < table->noLetsignCount; k++)",
          "1664:      if (currentInput[*src] == table->noLetsign[k]) {",
          "1665:       ok = 0;",
          "1666:       break;",
          "1667:      }",
          "1668:     if ((*src + 1) < srcmax)",
          "1669:      for (k = 0; k < table->noLetsignAfterCount; k++)",
          "1670:       if (currentInput[*src + 1] == table->noLetsignAfter[k]) {",
          "1671:        ok = 0;",
          "1672:        break;",
          "1673:       }",
          "1674:    }",
          "1675:    checkWhat = checkNothing;",
          "1676:    break;",
          "1678:   default:",
          "1679:    ok = 0;",
          "1680:    checkWhat = checkNothing;",
          "1681:    break;",
          "1682:   }",
          "1683:   if (ok && indicRule != NULL) {",
          "1684:    if (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,",
          "1685:       table, src, dest, srcmax, destmax, mode, currentInput,",
          "1686:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "1687:       transNoteBuffer, transRule, inputPositions, outputPositions,",
          "1688:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "1689:     return 0;",
          "1690:    if (*cursorStatus == 2) checkWhat = checkNothing;",
          "1691:   }",
          "1692:  } while (checkWhat != checkNothing);",
          "1693:  return 1;",
          "1697: onlyLettersBehind(const TranslationTableHeader *table, int src,",
          "1698:   const widechar *currentInput,",
          "1699:   TranslationTableCharacterAttributes beforeAttributes) {",
          "1701:  int k;",
          "1702:  if (!(beforeAttributes & CTC_Space)) return 0;",
          "1703:  for (k = src - 2; k >= 0; k--) {",
          "1704:   TranslationTableCharacterAttributes attr =",
          "1705:     (findCharOrDots(currentInput[k], 0, table))->attributes;",
          "1706:   if ((attr & CTC_Space)) continue;",
          "1707:   if ((attr & CTC_Letter))",
          "1708:    return 1;",
          "1709:   else",
          "1710:    return 0;",
          "1711:  }",
          "1716: onlyLettersAhead(const TranslationTableHeader *table, int src, int srcmax,",
          "1717:   const widechar *currentInput, int transCharslen,",
          "1718:   TranslationTableCharacterAttributes afterAttributes) {",
          "1720:  int k;",
          "1721:  if (!(afterAttributes & CTC_Space)) return 0;",
          "1722:  for (k = src + transCharslen + 1; k < srcmax; k++) {",
          "1723:   TranslationTableCharacterAttributes attr =",
          "1724:     (findCharOrDots(currentInput[k], 0, table))->attributes;",
          "1725:   if ((attr & CTC_Space)) continue;",
          "1726:   if ((attr & (CTC_Letter | CTC_LitDigit)))",
          "1727:    return 1;",
          "1728:   else",
          "1729:    return 0;",
          "1730:  }",
          "1735: noCompbrlAhead(const TranslationTableHeader *table, int src, int srcmax, int mode,",
          "1736:   const widechar *currentInput, int transOpcode, int transCharslen,",
          "1737:   int cursorPosition) {",
          "1738:  int start = src + transCharslen;",
          "1739:  int end;",
          "1740:  int curSrc;",
          "1741:  if (start >= srcmax) return 1;",
          "1742:  while (start < srcmax && checkAttr(currentInput[start], CTC_Space, 0, table)) start++;",
          "1743:  if (start == srcmax ||",
          "1744:    (transOpcode == CTO_JoinableWord &&",
          "1745:      (!checkAttr(currentInput[start], CTC_Letter | CTC_Digit, 0, table) ||",
          "1746:        !checkAttr(currentInput[start - 1], CTC_Space, 0, table))))",
          "1747:   return 1;",
          "1748:  end = start;",
          "1749:  while (end < srcmax && !checkAttr(currentInput[end], CTC_Space, 0, table)) end++;",
          "1750:  if ((mode & (compbrlAtCursor | compbrlLeftCursor)) && cursorPosition >= start &&",
          "1751:    cursorPosition < end)",
          "1752:   return 0;",
          "1754:  for (curSrc = start; curSrc < end; curSrc++) {",
          "1755:   int length = srcmax - curSrc;",
          "1756:   int tryThis;",
          "1757:   const TranslationTableCharacter *character1;",
          "1758:   const TranslationTableCharacter *character2;",
          "1759:   int k;",
          "1760:   character1 = findCharOrDots(currentInput[curSrc], 0, table);",
          "1761:   for (tryThis = 0; tryThis < 2; tryThis++) {",
          "1762:    TranslationTableOffset ruleOffset = 0;",
          "1763:    TranslationTableRule *testRule;",
          "1764:    unsigned long int makeHash = 0;",
          "1765:    switch (tryThis) {",
          "1766:    case 0:",
          "1767:     if (!(length >= 2)) break;",
          "1769:     makeHash = (unsigned long int)character1->lowercase << 8;",
          "1770:     character2 = findCharOrDots(currentInput[curSrc + 1], 0, table);",
          "1771:     makeHash += (unsigned long int)character2->lowercase;",
          "1772:     makeHash %= HASHNUM;",
          "1773:     ruleOffset = table->forRules[makeHash];",
          "1774:     break;",
          "1775:    case 1:",
          "1776:     if (!(length >= 1)) break;",
          "1777:     length = 1;",
          "1778:     ruleOffset = character1->otherRules;",
          "1779:     break;",
          "1780:    }",
          "1781:    while (ruleOffset) {",
          "1782:     testRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];",
          "1783:     for (k = 0; k < testRule->charslen; k++) {",
          "1784:      character1 = findCharOrDots(testRule->charsdots[k], 0, table);",
          "1785:      character2 = findCharOrDots(currentInput[curSrc + k], 0, table);",
          "1786:      if (character1->lowercase != character2->lowercase) break;",
          "1787:     }",
          "1788:     if (tryThis == 1 || k == testRule->charslen) {",
          "1789:      if (testRule->opcode == CTO_CompBrl ||",
          "1790:        testRule->opcode == CTO_Literal)",
          "1791:       return 0;",
          "1792:     }",
          "1793:     ruleOffset = testRule->charsnext;",
          "1794:    }",
          "1797:  return 1;",
          "1801: isRepeatedWord(const TranslationTableHeader *table, int src, int srcmax,",
          "1802:   const widechar *currentInput, int transCharslen, const widechar **repwordStart,",
          "1803:   int *repwordLength) {",
          "1804:  int start;",
          "1805:  if (src == 0 || !checkAttr(currentInput[src - 1], CTC_Letter, 0, table)) return 0;",
          "1806:  if ((src + transCharslen) >= srcmax ||",
          "1807:    !checkAttr(currentInput[src + transCharslen], CTC_Letter, 0, table))",
          "1808:   return 0;",
          "1809:  for (start = src - 2;",
          "1810:    start >= 0 && checkAttr(currentInput[start], CTC_Letter, 0, table); start--)",
          "1811:   ;",
          "1812:  start++;",
          "1815:  if (compareChars(*repwordStart, &currentInput[src + transCharslen], *repwordLength, 0,",
          "1816:     table))",
          "1817:   return 1;",
          "1818:  return 0;",
          "1822: checkEmphasisChange(const int skip, int src, unsigned int *emphasisBuffer,",
          "1823:   unsigned int *transNoteBuffer, const TranslationTableRule *transRule) {",
          "1824:  int i;",
          "1825:  for (i = src + (skip + 1); i < src + transRule->charslen; i++)",
          "1826:   if (emphasisBuffer[i] || transNoteBuffer[i]) return 1;",
          "1831: inSequence(const TranslationTableHeader *table, int src, int srcmax,",
          "1832:   const widechar *currentInput, const TranslationTableRule *transRule) {",
          "1838:  for (i = src - 1; i >= 0; i--) {",
          "1839:   if (checkAttr(currentInput[i], CTC_SeqBefore, 0, table)) continue;",
          "1840:   if (!(checkAttr(currentInput[i], CTC_Space | CTC_SeqDelimiter, 0, table)))",
          "1846:  for (i = src + transRule->charslen; i < srcmax; i++) {",
          "1848:   if (table->seqPatternsCount) {",
          "1850:    for (j = i, s = 0; j <= srcmax && s < table->seqPatternsCount; j++, s++) {",
          "1852:     if (match == 1) {",
          "1853:      if (table->seqPatterns[s]) {",
          "1854:       if (currentInput[j] == table->seqPatterns[s])",
          "1856:       else {",
          "1863:      else {",
          "1865:       if (j >= srcmax) return 1;",
          "1873:     else if (match == 0) {",
          "1874:      if (table->seqPatterns[s]) {",
          "1875:       if (currentInput[j] == table->seqPatterns[s])",
          "1877:       else {",
          "1885:     else if (match == -1) {",
          "1886:      if (!table->seqPatterns[s]) {",
          "1894:   if (checkAttr(currentInput[i], CTC_SeqAfter, 0, table)) continue;",
          "1895:   if (!(checkAttr(currentInput[i], CTC_Space | CTC_SeqDelimiter, 0, table)))",
          "1904: for_selectRule(const TranslationTableHeader *table, int src, int dest, int srcmax,",
          "1905:   int destmax, int mode, const widechar *currentInput, formtype *typebuf,",
          "1906:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer, int *transOpcode,",
          "1907:   int prevTransOpcode, const TranslationTableRule **transRule, int *transCharslen,",
          "1908:   int *passCharDots, int *passSrc, widechar const **passInstructions, int *passIC,",
          "1909:   int *startMatch, int *startReplace, int *endReplace, int srcIncremented,",
          "1910:   int cursorPosition, const widechar **repwordStart, int *repwordLength,",
          "1911:   int dontContract, int compbrlStart, int compbrlEnd,",
          "1913:   TranslationTableCharacter **curCharDef, TranslationTableRule **groupingRule,",
          "1914:   widechar *groupingOp) {",
          "1916:  static TranslationTableRule pseudoRule = { 0 };",
          "1917:  int length = srcmax - src;",
          "1918:  int tryThis;",
          "1919:  const TranslationTableCharacter *character2;",
          "1920:  int k;",
          "1923:  for (tryThis = 0; tryThis < 3; tryThis++) {",
          "1924:   unsigned long int makeHash = 0;",
          "1925:   switch (tryThis) {",
          "1926:   case 0:",
          "1927:    if (!(length >= 2)) break;",
          "1929:    makeHash = (unsigned long int)(*curCharDef)->lowercase << 8;",
          "1930:    character2 = findCharOrDots(currentInput[src + 1], 0, table);",
          "1931:    makeHash += (unsigned long int)character2->lowercase;",
          "1932:    makeHash %= HASHNUM;",
          "1933:    ruleOffset = table->forRules[makeHash];",
          "1934:    break;",
          "1935:   case 1:",
          "1936:    if (!(length >= 1)) break;",
          "1937:    length = 1;",
          "1938:    ruleOffset = (*curCharDef)->otherRules;",
          "1939:    break;",
          "1944:    pseudoRule.charsdots[0] = currentInput[src];",
          "1945:    pseudoRule.dotslen = 0;",
          "1946:    return;",
          "1947:    break;",
          "1948:   }",
          "1949:   while (ruleOffset) {",
          "1953:    if (tryThis == 1 || ((*transCharslen <= length) &&",
          "1954:           validMatch(table, src, currentInput, typebuf,",
          "1956:     TranslationTableCharacterAttributes afterAttributes;",
          "1958:     if ((*transRule)->before & CTC_EmpMatch) {",
          "1959:      if (emphasisBuffer[src] || transNoteBuffer[src]) break;",
          "1960:     }",
          "1963:     if ((*transRule)->after & CTC_EmpMatch) {",
          "1964:      if (emphasisBuffer[src + *transCharslen] ||",
          "1965:        transNoteBuffer[src + *transCharslen])",
          "1966:       break;",
          "1967:     }",
          "1970:     setAfter(*transCharslen, table, src, srcmax, currentInput,",
          "1971:       &afterAttributes);",
          "1972:     if ((!((*transRule)->after & ~CTC_EmpMatch) ||",
          "1973:        (beforeAttributes & (*transRule)->after)) &&",
          "1974:       (!((*transRule)->before & ~CTC_EmpMatch) ||",
          "1975:         (afterAttributes & (*transRule)->before)))",
          "1977:      case CTO_Space:",
          "1978:      case CTO_Letter:",
          "1979:      case CTO_UpperCase:",
          "1980:      case CTO_LowerCase:",
          "1981:      case CTO_Digit:",
          "1982:      case CTO_LitDigit:",
          "1983:      case CTO_Punctuation:",
          "1984:      case CTO_Math:",
          "1985:      case CTO_Sign:",
          "1986:      case CTO_Hyphen:",
          "1987:      case CTO_Replace:",
          "1988:      case CTO_CompBrl:",
          "1989:      case CTO_Literal:",
          "1990:       return;",
          "1991:      case CTO_Repeated:",
          "1992:       if ((mode & (compbrlAtCursor | compbrlLeftCursor)) &&",
          "1993:         src >= compbrlStart && src <= compbrlEnd)",
          "1994:        break;",
          "1995:       return;",
          "1996:      case CTO_RepWord:",
          "1997:       if (dontContract || (mode & noContractions)) break;",
          "1998:       if (isRepeatedWord(table, src, srcmax, currentInput,",
          "2000:        return;",
          "2002:      case CTO_NoCont:",
          "2003:       if (dontContract || (mode & noContractions)) break;",
          "2004:       return;",
          "2005:      case CTO_Syllable:",
          "2007:      case CTO_Always:",
          "2008:       if (checkEmphasisChange(",
          "2009:          0, src, emphasisBuffer, transNoteBuffer, *transRule))",
          "2010:        break;",
          "2011:       if (dontContract || (mode & noContractions)) break;",
          "2012:       return;",
          "2013:      case CTO_ExactDots:",
          "2014:       return;",
          "2015:      case CTO_NoCross:",
          "2016:       if (dontContract || (mode & noContractions)) break;",
          "2017:       if (syllableBreak(",
          "2018:          table, src, srcmax, currentInput, *transCharslen))",
          "2019:        break;",
          "2020:       return;",
          "2021:      case CTO_Context:",
          "2022:       if (!srcIncremented ||",
          "2023:         !passDoTest(table, src, srcmax, currentInput,",
          "2025:           passInstructions, passIC, startMatch,",
          "2026:           startReplace, endReplace, groupingRule,",
          "2027:           groupingOp))",
          "2028:        break;",
          "2029:       return;",
          "2030:      case CTO_LargeSign:",
          "2031:       if (dontContract || (mode & noContractions)) break;",
          "2032:       if (!((beforeAttributes & (CTC_Space | CTC_Punctuation)) ||",
          "2033:          onlyLettersBehind(table, src, currentInput,",
          "2034:            beforeAttributes)) ||",
          "2035:         !((afterAttributes & CTC_Space) ||",
          "2036:           prevTransOpcode == CTO_LargeSign) ||",
          "2037:         (afterAttributes & CTC_Letter) ||",
          "2038:         !noCompbrlAhead(table, src, srcmax, mode, currentInput,",
          "2041:       return;",
          "2042:      case CTO_WholeWord:",
          "2043:       if (dontContract || (mode & noContractions)) break;",
          "2044:       if (checkEmphasisChange(",
          "2045:          0, src, emphasisBuffer, transNoteBuffer, *transRule))",
          "2046:        break;",
          "2047:      case CTO_Contraction:",
          "2048:       if (table->usesSequences) {",
          "2049:        if (inSequence(table, src, srcmax, currentInput, *transRule))",
          "2050:         return;",
          "2051:       } else {",
          "2052:        if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&",
          "2053:          (afterAttributes & (CTC_Space | CTC_Punctuation)))",
          "2054:         return;",
          "2055:       }",
          "2057:      case CTO_PartWord:",
          "2058:       if (dontContract || (mode & noContractions)) break;",
          "2059:       if ((beforeAttributes & CTC_Letter) ||",
          "2060:         (afterAttributes & CTC_Letter))",
          "2061:        return;",
          "2062:       break;",
          "2063:      case CTO_JoinNum:",
          "2064:       if (dontContract || (mode & noContractions)) break;",
          "2065:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&",
          "2066:         (afterAttributes & CTC_Space) &&",
          "2067:         (dest + (*transRule)->dotslen < destmax)) {",
          "2068:        int cursrc = src + *transCharslen + 1;",
          "2069:        while (cursrc < srcmax) {",
          "2070:         if (!checkAttr(",
          "2071:            currentInput[cursrc], CTC_Space, 0, table)) {",
          "2072:          if (checkAttr(currentInput[cursrc], CTC_Digit, 0,",
          "2073:             table))",
          "2074:           return;",
          "2075:          break;",
          "2076:         }",
          "2077:         cursrc++;",
          "2078:        }",
          "2079:       }",
          "2080:       break;",
          "2081:      case CTO_LowWord:",
          "2082:       if (dontContract || (mode & noContractions)) break;",
          "2083:       if ((beforeAttributes & CTC_Space) &&",
          "2084:         (afterAttributes & CTC_Space) &&",
          "2085:         (prevTransOpcode != CTO_JoinableWord))",
          "2086:        return;",
          "2087:       break;",
          "2088:      case CTO_JoinableWord:",
          "2089:       if (dontContract || (mode & noContractions)) break;",
          "2090:       if (beforeAttributes & (CTC_Space | CTC_Punctuation) &&",
          "2091:         onlyLettersAhead(table, src, srcmax, currentInput,",
          "2093:         noCompbrlAhead(table, src, srcmax, mode, currentInput,",
          "2095:        return;",
          "2096:       break;",
          "2097:      case CTO_SuffixableWord:",
          "2098:       if (dontContract || (mode & noContractions)) break;",
          "2099:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&",
          "2100:         (afterAttributes &",
          "2101:           (CTC_Space | CTC_Letter | CTC_Punctuation)))",
          "2102:        return;",
          "2103:       break;",
          "2104:      case CTO_PrefixableWord:",
          "2105:       if (dontContract || (mode & noContractions)) break;",
          "2106:       if ((beforeAttributes &",
          "2107:          (CTC_Space | CTC_Letter | CTC_Punctuation)) &&",
          "2108:         (afterAttributes & (CTC_Space | CTC_Punctuation)))",
          "2109:        return;",
          "2110:       break;",
          "2111:      case CTO_BegWord:",
          "2112:       if (dontContract || (mode & noContractions)) break;",
          "2113:       if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&",
          "2114:         (afterAttributes & CTC_Letter))",
          "2115:        return;",
          "2116:       break;",
          "2117:      case CTO_BegMidWord:",
          "2118:       if (dontContract || (mode & noContractions)) break;",
          "2119:       if ((beforeAttributes &",
          "2120:          (CTC_Letter | CTC_Space | CTC_Punctuation)) &&",
          "2121:         (afterAttributes & CTC_Letter))",
          "2122:        return;",
          "2123:       break;",
          "2124:      case CTO_MidWord:",
          "2125:       if (dontContract || (mode & noContractions)) break;",
          "2126:       if (beforeAttributes & CTC_Letter && afterAttributes & CTC_Letter)",
          "2127:        return;",
          "2128:       break;",
          "2129:      case CTO_MidEndWord:",
          "2130:       if (dontContract || (mode & noContractions)) break;",
          "2131:       if (beforeAttributes & CTC_Letter &&",
          "2132:         afterAttributes &",
          "2133:           (CTC_Letter | CTC_Space | CTC_Punctuation))",
          "2134:        return;",
          "2135:       break;",
          "2136:      case CTO_EndWord:",
          "2137:       if (dontContract || (mode & noContractions)) break;",
          "2138:       if (beforeAttributes & CTC_Letter &&",
          "2139:         afterAttributes & (CTC_Space | CTC_Punctuation))",
          "2140:        return;",
          "2141:       break;",
          "2142:      case CTO_BegNum:",
          "2143:       if (beforeAttributes & (CTC_Space | CTC_Punctuation) &&",
          "2144:         afterAttributes & CTC_Digit)",
          "2145:        return;",
          "2146:       break;",
          "2147:      case CTO_MidNum:",
          "2148:       if (prevTransOpcode != CTO_ExactDots &&",
          "2149:         beforeAttributes & CTC_Digit &&",
          "2150:         afterAttributes & CTC_Digit)",
          "2153:      case CTO_EndNum:",
          "2154:       if (beforeAttributes & CTC_Digit &&",
          "2155:         prevTransOpcode != CTO_ExactDots)",
          "2156:        return;",
          "2157:       break;",
          "2158:      case CTO_DecPoint:",
          "2159:       if (!(afterAttributes & CTC_Digit)) break;",
          "2160:       if (beforeAttributes & CTC_Digit) *transOpcode = CTO_MidNum;",
          "2161:       return;",
          "2162:      case CTO_PrePunc:",
          "2163:       if (!checkAttr(currentInput[src], CTC_Punctuation, 0, table) ||",
          "2164:         (src > 0 && checkAttr(currentInput[src - 1], CTC_Letter,",
          "2165:              0, table)))",
          "2166:        break;",
          "2167:       for (k = src + *transCharslen; k < srcmax; k++) {",
          "2168:        if (checkAttr(currentInput[k], (CTC_Letter | CTC_Digit), 0,",
          "2169:           table))",
          "2170:         return;",
          "2171:        if (checkAttr(currentInput[k], CTC_Space, 0, table)) break;",
          "2172:       }",
          "2173:       break;",
          "2174:      case CTO_PostPunc:",
          "2175:       if (!checkAttr(currentInput[src], CTC_Punctuation, 0, table) ||",
          "2176:         (src < (srcmax - 1) && checkAttr(currentInput[src + 1],",
          "2177:                   CTC_Letter, 0, table)))",
          "2178:        break;",
          "2179:       for (k = src; k >= 0; k--) {",
          "2180:        if (checkAttr(currentInput[k], (CTC_Letter | CTC_Digit), 0,",
          "2181:           table))",
          "2182:         return;",
          "2183:        if (checkAttr(currentInput[k], CTC_Space, 0, table)) break;",
          "2184:       }",
          "2187:      case CTO_Match: {",
          "2188:       widechar *patterns, *pattern;",
          "2190:       if (dontContract || (mode & noContractions)) break;",
          "2191:       if (checkEmphasisChange(",
          "2192:          0, src, emphasisBuffer, transNoteBuffer, *transRule))",
          "2193:        break;",
          "2195:       patterns = (widechar *)&table->ruleArea[(*transRule)->patterns];",
          "2198:       pattern = &patterns[1];",
          "2199:       if (!_lou_pattern_check(",
          "2200:          currentInput, src - 1, -1, -1, pattern, table))",
          "2201:        break;",
          "2204:       pattern = &patterns[patterns[0]];",
          "2205:       if (!_lou_pattern_check(currentInput,",
          "2206:          src + (*transRule)->charslen, srcmax, 1, pattern,",
          "2207:          table))",
          "2208:        break;",
          "2210:       return;",
          "2211:      }",
          "2213:      default:",
          "2214:       break;",
          "2215:      }",
          "2216:    }",
          "2218:    ruleOffset = (*transRule)->charsnext;",
          "2219:   }",
          "2224: undefinedCharacter(widechar c, const TranslationTableHeader *table, int *src, int *dest,",
          "2225:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "2226:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "2227:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2228:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "2229:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "2231:  int k;",
          "2232:  char *display;",
          "2233:  widechar displayDots[20];",
          "2234:  if (table->undefined) {",
          "2235:   TranslationTableRule *rule =",
          "2236:     (TranslationTableRule *)&table->ruleArea[table->undefined];",
          "2237:   if (!for_updatePositions(&rule->charsdots[rule->charslen], rule->charslen,",
          "2238:      rule->dotslen, 0, table, src, dest, srcmax, destmax, mode,",
          "2239:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "2240:      emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "2241:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "2242:      compbrlEnd))",
          "2243:    return 0;",
          "2244:   return 1;",
          "2245:  }",
          "2246:  display = _lou_showString(&c, 1);",
          "2247:  for (k = 0; k < (int)strlen(display); k++)",
          "2248:   displayDots[k] = _lou_getDotsForChar(display[k]);",
          "2249:  if (!for_updatePositions(displayDots, 1, (int)strlen(display), 0, table, src, dest,",
          "2250:     srcmax, destmax, mode, currentInput, currentOutput, srcMapping,",
          "2251:     prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule,",
          "2252:     inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "2253:     compbrlStart, compbrlEnd))",
          "2254:   return 0;",
          "2255:  return 1;",
          "2259: putCharacter(widechar character, const TranslationTableHeader *table, int *src, int *dest,",
          "2260:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "2261:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "2262:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2263:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "2264:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "2267:  TranslationTableCharacter *chardef = NULL;",
          "2268:  TranslationTableOffset offset;",
          "2269:  widechar d;",
          "2270:  if (*cursorStatus == 2) return 1;",
          "2271:  chardef = (findCharOrDots(character, 0, table));",
          "2272:  if ((chardef->attributes & CTC_Letter) && (chardef->attributes & CTC_UpperCase))",
          "2273:   chardef = findCharOrDots(chardef->lowercase, 0, table);",
          "2277:  offset = chardef->definitionRule;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2773: }",
          "2775: static int",
          "2799: }",
          "2801: static int",
          "2840: }",
          "2842: static int",
          "2873: }",
          "2875: static int",
          "2911:  }",
          "2922:  }",
          "2938: }",
          "2940: static int",
          "2964: }",
          "2966: static int",
          "3035:   }",
          "3060:  }",
          "3063: }",
          "3065: static void",
          "3075:  int in_word = 0, in_emp = 0, word_start = -1, word_whole = 0, word_stop;",
          "3076:  int i;",
          "3082:   wordBuffer[i] &= ~WORD_WHOLE;",
          "3096:    }",
          "3127:     }",
          "3129:    }",
          "3141:    }",
          "3154:       buffer[word_start] |= bit_symbol;",
          "3158:    }",
          "3164:  }",
          "3169:   buffer[i] &= ~bit_end;",
          "3177:      buffer[word_start] |= bit_symbol;",
          "3182:  }",
          "3183: }",
          "3185: static void",
          "3203:  int i;",
          "3204:  const TranslationTableRule *indicRule;",
          "3213:  buffer[pass_start] |= bit_begin;",
          "3216:   buffer[pass_end] |= bit_end;",
          "3218:   buffer[word_start] |= bit_end;",
          "3219: }",
          "3221: static void",
          "3237:  unsigned int word_cnt = 0;",
          "3238:  int pass_start = -1, pass_end = -1, word_start = -1, in_word = 0, in_pass = 0;",
          "3239:  int i;",
          "3270:     }",
          "3272:    }",
          "3296:    }",
          "3299:  }",
          "3320:   }",
          "3321:  }",
          "3322: }",
          "3324: static void",
          "3332:  int i;",
          "3343:  }",
          "3344: }",
          "3346: static void",
          "3355:  const unsigned int bit_begin = CAPS_BEGIN;",
          "3356:  const unsigned int bit_end = CAPS_END;",
          "3357:  const unsigned int bit_symbol = CAPS_SYMBOL;",
          "3366:    buffer[i] &= ~bit_end;",
          "3372:     buffer[i] &= ~bit_begin;",
          "3373:     inEmphasis = 1;",
          "3374:    }",
          "3377:     if (typebuf[i] & CAPSEMPH)",
          "3382:  }",
          "3383: }",
          "3385: static void",
          "3398:  int i, j;",
          "3502:      }",
          "3511:      }",
          "3520:      }",
          "3525:     }",
          "3537:    }",
          "3538:   }",
          "3540:  }",
          "3548:    buffer[word_start] |= bit_symbol;",
          "3549:    buffer[word_start] &= ~bit_word;",
          "3550:    wordBuffer[word_start] &= ~WORD_WHOLE;",
          "3551:    buffer[i] &= ~(bit_end | bit_word);",
          "3552:   }",
          "3556:  }",
          "3557: }",
          "3559: static void",
          "3573:  int caps_start = -1, last_caps = -1, caps_cnt = 0;",
          "3575:  int i, j;",
          "3581:    wordBuffer[i] |= WORD_CHAR;",
          "3585:    last_caps = i;",
          "3586:    caps_cnt = 0;",
          "3587:   }",
          "3593:    caps_cnt++;",
          "3601:     emphasisBuffer[caps_start] |= CAPS_BEGIN;",
          "3603:      emphasisBuffer[i] |= CAPS_END;",
          "3604:     else",
          "3605:      emphasisBuffer[last_caps] |= CAPS_END;",
          "",
          "[Removed Lines]",
          "2763:   if (offset)",
          "2764:     {",
          "2765:       rule = (TranslationTableRule *)",
          "2766:  & table->ruleArea[offset];",
          "2767:       if (rule->dotslen)",
          "2768:  return for_updatePositions (&rule->charsdots[1], 1, rule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2769:  d = _lou_getDotsForChar (character);",
          "2770:  return for_updatePositions (&d, 1, 1, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2771:     }",
          "2772:   return undefinedCharacter (character, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2776: putCharacters (const widechar * characters, int count,",
          "2777:         const TranslationTableHeader *table,",
          "2778:         int *src, int *dest,",
          "2779:         int srcmax, int destmax,",
          "2780:         int mode,",
          "2781:         const widechar *currentInput,",
          "2782:         widechar *currentOutput,",
          "2783:         int *srcMapping,",
          "2784:         int *prevSrcMapping,",
          "2785:         unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2786:         const TranslationTableRule **transRule,",
          "2787:         int *inputPositions,",
          "2788:         int *outputPositions,",
          "2789:         int *cursorPosition, int *cursorStatus,",
          "2790:         int compbrlStart, int compbrlEnd)",
          "2791: {",
          "2794:   int k;",
          "2795:   for (k = 0; k < count; k++)",
          "2796:     if (!putCharacter (characters[k], table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2797:       return 0;",
          "2798:   return 1;",
          "2802: doCompbrl (const TranslationTableHeader *table,",
          "2803:     int *src, int *dest,",
          "2804:     int srcmax, int destmax,",
          "2805:     int mode,",
          "2806:     const widechar *currentInput,",
          "2807:     widechar *currentOutput,",
          "2808:     int *srcMapping,",
          "2809:     int *prevSrcMapping,",
          "2810:     unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2811:     const TranslationTableRule **transRule,",
          "2812:     int *inputPositions,",
          "2813:     int *outputPositions,",
          "2814:     int *cursorPosition, int *cursorStatus,",
          "2815:     int destword, int srcword,",
          "2816:     int compbrlStart, int compbrlEnd)",
          "2817: {",
          "2819:   int stringStart, stringEnd;",
          "2820:   if (checkAttr (currentInput[*src], CTC_Space, 0, table))",
          "2821:     return 1;",
          "2822:   if (destword)",
          "2823:     {",
          "2826:     }",
          "2827:   else",
          "2828:     {",
          "2831:     }",
          "2832:   for (stringStart = *src; stringStart >= 0; stringStart--)",
          "2833:     if (checkAttr (currentInput[stringStart], CTC_Space, 0, table))",
          "2834:       break;",
          "2835:   stringStart++;",
          "2836:   for (stringEnd = *src; stringEnd < srcmax; stringEnd++)",
          "2837:     if (checkAttr (currentInput[stringEnd], CTC_Space, 0, table))",
          "2838:       break;",
          "2839:   return doCompTrans (stringStart, stringEnd, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2843: putCompChar (widechar character,",
          "2844:       const TranslationTableHeader *table,",
          "2845:       int *src, int *dest,",
          "2846:       int srcmax, int destmax,",
          "2847:       int mode,",
          "2848:       const widechar *currentInput,",
          "2849:       widechar *currentOutput,",
          "2850:       int *srcMapping,",
          "2851:       int *prevSrcMapping,",
          "2852:       unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2853:       const TranslationTableRule **transRule,",
          "2854:       int *inputPositions,",
          "2855:       int *outputPositions,",
          "2856:       int *cursorPosition, int *cursorStatus,",
          "2857:       int compbrlStart, int compbrlEnd)",
          "2858: {",
          "2860:   widechar d;",
          "2861:   TranslationTableOffset offset = (findCharOrDots",
          "2862:        (character, 0, table))->definitionRule;",
          "2863:   if (offset)",
          "2864:     {",
          "2865:       const TranslationTableRule *rule = (TranslationTableRule *)",
          "2866:  & table->ruleArea[offset];",
          "2867:       if (rule->dotslen)",
          "2868:  return for_updatePositions (&rule->charsdots[1], 1, rule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2869:  d = _lou_getDotsForChar (character);",
          "2870:  return for_updatePositions (&d, 1, 1, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2871:     }",
          "2872:   return undefinedCharacter (character, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2876: doCompTrans (int start, int end,",
          "2877:       const TranslationTableHeader *table,",
          "2878:       int *src, int *dest,",
          "2879:       int srcmax, int destmax,",
          "2880:       int mode,",
          "2881:       const widechar *currentInput,",
          "2882:       widechar *currentOutput,",
          "2883:       int *srcMapping,",
          "2884:       int *prevSrcMapping,",
          "2885:       unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2886:       const TranslationTableRule **transRule,",
          "2887:       int *inputPositions,",
          "2888:       int *outputPositions,",
          "2889:       int *cursorPosition, int *cursorStatus,",
          "2890:       int compbrlStart, int compbrlEnd)",
          "2891: {",
          "2892:   const TranslationTableRule *indicRule;",
          "2893:   int k;",
          "2894:   int haveEndsegment = 0;",
          "2895:   if (*cursorStatus != 2 && brailleIndicatorDefined (table->begComp, table, &indicRule))",
          "2896:     if (!for_updatePositions",
          "2897:  (&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2898:       return 0;",
          "2899:   for (k = start; k < end; k++)",
          "2900:     {",
          "2901:       TranslationTableOffset compdots = 0;",
          "2905:       emphasisBuffer[k] = 0;",
          "2906:       transNoteBuffer[k] = 0;",
          "2907:       if (currentInput[k] == ENDSEGMENT)",
          "2908:  {",
          "2909:    haveEndsegment = 1;",
          "2910:    continue;",
          "2913:       if (currentInput[k] < 256)",
          "2914:  compdots = table->compdotsPattern[currentInput[k]];",
          "2915:       if (compdots != 0)",
          "2916:  {",
          "2918:    if (!for_updatePositions",
          "2919:        (&(*transRule)->charsdots[(*transRule)->charslen],",
          "2920:         (*transRule)->charslen, (*transRule)->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2921:      return 0;",
          "2923:       else if (!putCompChar (currentInput[k], table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2924:  return 0;",
          "2925:     }",
          "2926:   if (*cursorStatus != 2 && brailleIndicatorDefined (table->endComp, table, &indicRule))",
          "2927:     if (!for_updatePositions",
          "2928:  (&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2929:       return 0;",
          "2931:   if (haveEndsegment)",
          "2932:     {",
          "2933:       widechar endSegment = ENDSEGMENT;",
          "2934:       if (!for_updatePositions (&endSegment, 0, 1, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "2935:  return 0;",
          "2936:     }",
          "2937:   return 1;",
          "2941: doNocont (const TranslationTableHeader *table,",
          "2942:    int *src, int *dest,",
          "2943:    int mode,",
          "2944:    const widechar *currentInput,",
          "2945:    int destword, int srcword,",
          "2946:    int *dontContract)",
          "2947: {",
          "2949:   if (checkAttr (currentInput[*src], CTC_Space, 0, table) || *dontContract",
          "2950:       || (mode & noContractions))",
          "2951:     return 1;",
          "2952:   if (destword)",
          "2953:     {",
          "2956:     }",
          "2957:   else",
          "2958:     {",
          "2961:     }",
          "2963:   return 1;",
          "2967: markSyllables (const TranslationTableHeader *table,",
          "2968:         int srcmax,",
          "2969:         const widechar *currentInput,",
          "2970:         formtype *typebuf,",
          "2971:         int *transOpcode,",
          "2972:         const TranslationTableRule **transRule,",
          "2973:         int *transCharslen)",
          "2974: {",
          "2975:   int src;",
          "2976:   int k;",
          "2977:   int currentMark = 0;",
          "2978:   int const syllable_marks[] = {SYLLABLE_MARKER_1, SYLLABLE_MARKER_2};",
          "2979:   int syllable_mark_selector = 0;",
          "2981:   if (typebuf == NULL || !table->syllables)",
          "2982:     return 1;",
          "2983:   src = 0;",
          "2984:   while (src < srcmax)",
          "2986:       int length = srcmax - src;",
          "2987:       const TranslationTableCharacter *character = findCharOrDots",
          "2988:  (currentInput[src], 0, table);",
          "2989:       const TranslationTableCharacter *character2;",
          "2990:       int tryThis = 0;",
          "2991:       while (tryThis < 3)",
          "2992:  {",
          "2993:    TranslationTableOffset ruleOffset = 0;",
          "2994:    unsigned long int makeHash = 0;",
          "2995:    switch (tryThis)",
          "2996:      {",
          "2997:      case 0:",
          "2998:        if (!(length >= 2))",
          "2999:   break;",
          "3000:        makeHash = (unsigned long int) character->lowercase << 8;",
          "3002:        character2 = findCharOrDots (currentInput[src + 1], 0, table);",
          "3003:        makeHash += (unsigned long int) character2->lowercase;",
          "3004:        makeHash %= HASHNUM;",
          "3005:        ruleOffset = table->forRules[makeHash];",
          "3006:        break;",
          "3007:      case 1:",
          "3008:        if (!(length >= 1))",
          "3009:   break;",
          "3010:        length = 1;",
          "3011:        ruleOffset = character->otherRules;",
          "3012:        break;",
          "3015:        ruleOffset = 0;",
          "3016:        break;",
          "3017:      }",
          "3018:    while (ruleOffset)",
          "3019:      {",
          "3021:   (TranslationTableRule *) & table->ruleArea[ruleOffset];",
          "3024:        if (tryThis == 1 || (*transCharslen <= length &&",
          "3025:        compareChars (&(*transRule)->",
          "3026:        charsdots[0],",
          "3027:        &currentInput[src],",
          "3029:   {",
          "3030:     if (*transOpcode == CTO_Syllable)",
          "3031:       {",
          "3032:         tryThis = 4;",
          "3033:         break;",
          "3034:       }",
          "3036:        ruleOffset = (*transRule)->charsnext;",
          "3037:      }",
          "3038:    tryThis++;",
          "3039:  }",
          "3040:       switch (*transOpcode)",
          "3041:  {",
          "3042:  case CTO_Always:",
          "3043:    if (src >= srcmax)",
          "3044:      return 0;",
          "3045:    typebuf[src++] |= currentMark;",
          "3046:    break;",
          "3047:  case CTO_Syllable:",
          "3050:    currentMark = syllable_marks[syllable_mark_selector];",
          "3051:    syllable_mark_selector = (syllable_mark_selector + 1) % 2;",
          "3053:    if ((src + *transCharslen) > srcmax)",
          "3054:      return 0;",
          "3055:    for (k = 0; k < *transCharslen; k++)",
          "3056:      typebuf[src++] |= currentMark;",
          "3057:    break;",
          "3058:  default:",
          "3059:    break;",
          "3061:     }",
          "3062:   return 1;",
          "3066: resolveEmphasisWords(",
          "3067:  unsigned int *buffer,",
          "3068:  const unsigned int bit_begin,",
          "3069:  const unsigned int bit_end,",
          "3070:  const unsigned int bit_word,",
          "3071:  const unsigned int bit_symbol,",
          "3072:  int srcmax,",
          "3073:  unsigned int *wordBuffer)",
          "3074: {",
          "3078:  for(i = 0; i < srcmax; i++)",
          "3079:  {",
          "3085:   if(!in_emp)",
          "3086:   if(buffer[i] & bit_begin)",
          "3087:   {",
          "3088:    in_emp = 1;",
          "3089:    buffer[i] &= ~bit_begin;",
          "3092:    if(in_word)",
          "3093:    {",
          "3094:     word_start = i;",
          "3095:     word_whole = 0;",
          "3099:    if(!(wordBuffer[i] & WORD_CHAR))",
          "3100:     word_start = -1;",
          "3101:   }",
          "3104:   if(in_emp)",
          "3105:   if(buffer[i] & bit_end)",
          "3106:   {",
          "3107:    in_emp = 0;",
          "3108:    buffer[i] &= ~bit_end;",
          "3110:    if(in_word && word_start >= 0)",
          "3111:    {",
          "3113:     word_stop = bit_end | bit_word;",
          "3114:     if(wordBuffer[i] & WORD_CHAR)",
          "3115:      word_whole = 0;",
          "3116:     else",
          "3117:      word_stop = 0;",
          "3121:     if(bit_symbol && word_start + 1 == i)",
          "3122:      buffer[word_start] |= bit_symbol;",
          "3123:     else",
          "3124:     {",
          "3125:      buffer[word_start] |= bit_word;",
          "3126:      buffer[i] |= word_stop;",
          "3128:     wordBuffer[word_start] |= word_whole;",
          "3130:   }",
          "3133:   if(!in_word)",
          "3134:   if(wordBuffer[i] & WORD_CHAR)",
          "3135:   {",
          "3136:    in_word = 1;",
          "3137:    if(in_emp)",
          "3138:    {",
          "3139:     word_whole = WORD_WHOLE;",
          "3140:     word_start = i;",
          "3142:   }",
          "3145:   if(in_word)",
          "3146:   if(!(wordBuffer[i] & WORD_CHAR))",
          "3147:   {",
          "3149:    if(in_emp && word_start >= 0)",
          "3150:    {",
          "3153:     if(bit_symbol && word_start + 1 == i)",
          "3155:     else",
          "3156:      buffer[word_start] |= bit_word;",
          "3157:     wordBuffer[word_start] |= word_whole;",
          "3160:    in_word = 0;",
          "3161:    word_whole = 0;",
          "3162:    word_start = -1;",
          "3163:   }",
          "3167:  if(in_emp)",
          "3168:  {",
          "3171:   if(in_word)",
          "3172:   if(word_start >= 0)",
          "3173:   {",
          "3176:    if(bit_symbol && word_start + 1 == i)",
          "3178:    else",
          "3179:     buffer[word_start] |= bit_word;",
          "3180:    wordBuffer[word_start] |= word_whole;",
          "3181:   }",
          "3186: convertToPassage(",
          "3187:  const int pass_start,",
          "3188:  const int pass_end,",
          "3189:  const int word_start,",
          "3190:  unsigned int *buffer,",
          "3191:  const EmphRuleNumber emphRule,",
          "3192:  const unsigned int bit_begin,",
          "3193:  const unsigned int bit_end,",
          "3194:  const unsigned int bit_word,",
          "3195:  const unsigned int bit_symbol,",
          "3196:  const TranslationTableHeader *table,",
          "3197:  unsigned int *wordBuffer,",
          "3198:  int *inputPositions,",
          "3199:  int *outputPositions,",
          "3200:  int *cursorPosition, int *cursorStatus,",
          "3201:  int compbrlStart, int compbrlEnd)",
          "3202: {",
          "3206:  for(i = pass_start; i <= pass_end; i++)",
          "3207:  if(wordBuffer[i] & WORD_WHOLE)",
          "3208:  {",
          "3209:   buffer[i] &= ~(bit_symbol | bit_word);",
          "3210:   wordBuffer[i] &= ~WORD_WHOLE;",
          "3211:  }",
          "3214:  if(brailleIndicatorDefined(table->emphRules[emphRule][endOffset], table, &indicRule)",
          "3215:     || brailleIndicatorDefined(table->emphRules[emphRule][endPhraseAfterOffset], table, &indicRule))",
          "3217:  else if(brailleIndicatorDefined(table->emphRules[emphRule][endPhraseBeforeOffset], table, &indicRule))",
          "3222: resolveEmphasisPassages(",
          "3223:  unsigned int *buffer,",
          "3224:  const EmphRuleNumber emphRule,",
          "3225:  const unsigned int bit_begin,",
          "3226:  const unsigned int bit_end,",
          "3227:  const unsigned int bit_word,",
          "3228:  const unsigned int bit_symbol,",
          "3229:  const TranslationTableHeader *table,",
          "3230:  int srcmax,",
          "3231:  unsigned int *wordBuffer,",
          "3232:  int *inputPositions,",
          "3233:  int *outputPositions,",
          "3234:  int *cursorPosition, int *cursorStatus,",
          "3235:  int compbrlStart, int compbrlEnd)",
          "3236: {",
          "3241:  for(i = 0; i < srcmax; i++)",
          "3242:  {",
          "3244:   if(!in_word)",
          "3245:   if(wordBuffer[i] & WORD_CHAR)",
          "3246:   {",
          "3247:    in_word = 1;",
          "3248:    if(wordBuffer[i] & WORD_WHOLE)",
          "3249:    {",
          "3250:     if(!in_pass)",
          "3251:     {",
          "3252:      in_pass = 1;",
          "3253:      pass_start = i;",
          "3254:      pass_end = -1;",
          "3255:      word_cnt = 1;",
          "3256:     }",
          "3257:     else",
          "3258:      word_cnt++;",
          "3259:     word_start = i;",
          "3260:     continue;",
          "3261:    }",
          "3262:    else if(in_pass)",
          "3263:    {",
          "3264:     if(word_cnt >= table->emphRules[emphRule][lenPhraseOffset])",
          "3265:     if(pass_end >= 0)",
          "3266:     {",
          "3267:      convertToPassage(",
          "3268:       pass_start, pass_end, word_start, buffer, emphRule,",
          "3269:       bit_begin, bit_end, bit_word, bit_symbol, table, wordBuffer, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3271:     in_pass = 0;",
          "3273:   }",
          "3276:   if(in_word)",
          "3277:   if(!(wordBuffer[i] & WORD_CHAR))",
          "3278:   {",
          "3279:    in_word = 0;",
          "3280:    if(in_pass)",
          "3281:     pass_end = i;",
          "3282:   }",
          "3284:   if(in_pass)",
          "3285:   if(buffer[i] & bit_begin",
          "3286:      || buffer[i] & bit_end",
          "3287:      || buffer[i] & bit_word",
          "3288:      || buffer[i] & bit_symbol)",
          "3289:   {",
          "3290:    if(word_cnt >= table->emphRules[emphRule][lenPhraseOffset])",
          "3291:    if(pass_end >= 0)",
          "3292:    {",
          "3293:     convertToPassage(",
          "3294:      pass_start, pass_end, word_start, buffer, emphRule,",
          "3295:      bit_begin, bit_end, bit_word, bit_symbol, table, wordBuffer, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3297:    in_pass = 0;",
          "3298:   }",
          "3301:  if(in_pass)",
          "3302:  {",
          "3303:   if(word_cnt >= table->emphRules[emphRule][lenPhraseOffset])",
          "3304:   {",
          "3305:   if(pass_end >= 0)",
          "3306:   {",
          "3307:   if(in_word)",
          "3308:   {",
          "3309:    convertToPassage(",
          "3310:     pass_start, i, word_start, buffer, emphRule,",
          "3311:     bit_begin, bit_end, bit_word, bit_symbol, table, wordBuffer, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3312:   }",
          "3313:   else",
          "3314:   {",
          "3315:    convertToPassage(",
          "3316:     pass_start, pass_end, word_start, buffer, emphRule,",
          "3317:     bit_begin, bit_end, bit_word, bit_symbol, table, wordBuffer, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3318:   }",
          "3319:   }",
          "3325: resolveEmphasisSingleSymbols(",
          "3326:  unsigned int *buffer,",
          "3327:  const unsigned int bit_begin,",
          "3328:  const unsigned int bit_end,",
          "3329:  const unsigned int bit_symbol,",
          "3330:  int srcmax)",
          "3331: {",
          "3334:  for(i = 0; i < srcmax; i++)",
          "3335:  {",
          "3336:   if(buffer[i] & bit_begin)",
          "3337:   if(buffer[i + 1] & bit_end)",
          "3338:   {",
          "3339:    buffer[i] &= ~bit_begin;",
          "3340:    buffer[i + 1] &= ~bit_end;",
          "3341:    buffer[i] |= bit_symbol;",
          "3342:   }",
          "3347: resolveEmphasisAllCapsSymbols(",
          "3348:  unsigned int *buffer,",
          "3349:  formtype *typebuf,",
          "3350:  int srcmax)",
          "3351: {",
          "3359:  int inEmphasis=0, i;",
          "3361:  for(i = 0; i < srcmax; i++)",
          "3362:  {",
          "3363:   if (buffer[i] & bit_end)",
          "3364:   {",
          "3365:    inEmphasis=0;",
          "3367:   }",
          "3368:   else",
          "3369:   {",
          "3370:    if(buffer[i] & bit_begin)",
          "3371:    {",
          "3375:    if (inEmphasis)",
          "3376:    {",
          "3379:       buffer[i] |= bit_symbol;",
          "3386: resolveEmphasisResets(",
          "3387:  unsigned int *buffer,",
          "3388:  const unsigned int bit_begin,",
          "3389:  const unsigned int bit_end,",
          "3390:  const unsigned int bit_word,",
          "3391:  const unsigned int bit_symbol,",
          "3392:  const TranslationTableHeader *table,",
          "3393:  int srcmax,",
          "3394:  const widechar *currentInput,",
          "3395:  unsigned int *wordBuffer)",
          "3396: {",
          "3397:  int in_word = 0, in_pass = 0, word_start = -1, word_reset = 0, orig_reset = -1, letter_cnt = 0;",
          "3400:  for(i = 0; i < srcmax; i++)",
          "3401:  {",
          "3402:   if(in_pass)",
          "3403:   if(buffer[i] & bit_end)",
          "3404:    in_pass = 0;",
          "3406:   if(!in_pass)",
          "3407:   {",
          "3408:   if(buffer[i] & bit_begin)",
          "3409:    in_pass = 1;",
          "3410:   else",
          "3411:   {",
          "3412:    if(!in_word)",
          "3413:    {",
          "3414:    if(buffer[i] & bit_word)",
          "3415:    {",
          "3418:     if(wordBuffer[i] & WORD_RESET || !checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "3419:     {",
          "3421:      if(wordBuffer[i + 1] & WORD_CHAR)",
          "3422:      {",
          "3423:       buffer[i + 1] |= bit_word;",
          "3424:       if(wordBuffer[i] & WORD_WHOLE)",
          "3425:        wordBuffer[i + 1] |= WORD_WHOLE;",
          "3426:      }",
          "3427:      buffer[i] &= ~bit_word;",
          "3428:      wordBuffer[i] &= ~WORD_WHOLE;",
          "3431:      if(checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "3432:       buffer[i] |= bit_symbol;",
          "3434:      continue;",
          "3435:     }",
          "3437:     in_word = 1;",
          "3438:     word_start = i;",
          "3439:     letter_cnt = 0;",
          "3440:     word_reset = 0;",
          "3441:    }",
          "3445:    else if(buffer[i] & bit_symbol)",
          "3446:    {",
          "3447:    if(wordBuffer[i] & WORD_RESET || !checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "3448:     buffer[i] &= ~bit_symbol;",
          "3449:    }",
          "3450:    }",
          "3452:    if(in_word)",
          "3453:    {",
          "3456:    if(!(wordBuffer[i] & WORD_CHAR)",
          "3457:       || (buffer[i] & bit_word && buffer[i] & bit_end))",
          "3458:    {",
          "3459:     in_word = 0;",
          "3462:     if(bit_symbol && letter_cnt == 1)",
          "3463:     {",
          "3464:      buffer[word_start] |= bit_symbol;",
          "3465:      buffer[word_start] &= ~bit_word;",
          "3466:      wordBuffer[word_start] &= ~WORD_WHOLE;",
          "3467:      buffer[i] &= ~(bit_end | bit_word);",
          "3468:     }",
          "3472:     if(word_reset || wordBuffer[i] & WORD_RESET || !checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "3473:      buffer[i] &= ~(bit_end | bit_word);",
          "3476:     if(i == word_start)",
          "3477:     {",
          "3478:      wordBuffer[word_start] &= ~WORD_WHOLE;",
          "3479:      buffer[i] &= ~(bit_end | bit_word);",
          "3480:     }",
          "3481:     orig_reset = -1;",
          "3482:    }",
          "3483:    else",
          "3484:    {",
          "3486:     if(wordBuffer[i] & WORD_RESET || !checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "3487:     {",
          "3488:      if(!checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "3489:      {",
          "3490:      if(checkAttr(currentInput[i], CTC_CapsMode, 0, table)) {",
          "3492:       orig_reset = i;",
          "3493:       continue;",
          "3494:      }",
          "3495:      else if(orig_reset >= 0) {",
          "3497:       for (j = orig_reset; j < i; j++)",
          "3498:        buffer[j] &= ~bit_word;",
          "3500:       orig_reset = -1;",
          "3501:      }",
          "3505:      if(bit_symbol && letter_cnt == 1)",
          "3506:      {",
          "3507:       buffer[word_start] |= bit_symbol;",
          "3508:       buffer[word_start] &= ~bit_word;",
          "3509:       wordBuffer[word_start] &= ~WORD_WHOLE;",
          "3514:      if(checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "3515:      {",
          "3516:       word_reset = 0;",
          "3517:       word_start = i;",
          "3518:       letter_cnt = 1;",
          "3519:       buffer[i] |= bit_word;",
          "3521:      else",
          "3522:       word_reset = 1;",
          "3524:      continue;",
          "3527:     if(word_reset)",
          "3528:     {",
          "3529:      word_reset = 0;",
          "3530:      word_start = i;",
          "3531:      letter_cnt = 0;",
          "3532:      buffer[i] |= bit_word;",
          "3533:     }",
          "3535:     letter_cnt++;",
          "3536:    }",
          "3539:   }",
          "3543:  if(in_word)",
          "3544:  {",
          "3546:   if(bit_symbol && letter_cnt == 1)",
          "3547:   {",
          "3554:   if(word_reset)",
          "3555:    buffer[i] &= ~(bit_end | bit_word);",
          "3560: markEmphases(const TranslationTableHeader *table,",
          "3561:       int srcmax,",
          "3562:       const widechar *currentInput,",
          "3563:       formtype *typebuf,",
          "3564:       unsigned int *wordBuffer,",
          "3565:       unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3566:       int haveEmphasis,",
          "3567:       int *inputPositions,",
          "3568:       int *outputPositions,",
          "3569:       int *cursorPosition, int *cursorStatus,",
          "3570:       int compbrlStart, int compbrlEnd)",
          "3571: {",
          "3574:  int emph_start[10] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};",
          "3577:  for(i = 0; i < srcmax; i++)",
          "3578:  {",
          "3579:   if(!checkAttr(currentInput[i], CTC_Space, 0, table))",
          "3580:   {",
          "3582:   }",
          "3583:   else if(caps_cnt > 0)",
          "3584:   {",
          "3589:   if(checkAttr(currentInput[i], CTC_UpperCase, 0, table))",
          "3590:   {",
          "3591:    if(caps_start < 0)",
          "3592:     caps_start = i;",
          "3594:   }",
          "3595:   else if(caps_start >= 0)",
          "3596:   {",
          "3598:    if(checkAttr(currentInput[i], CTC_Letter, 0, table)",
          "3599:      && checkAttr(currentInput[i], CTC_LowerCase, 0, table))",
          "3600:    {",
          "3602:     if(caps_cnt > 0)",
          "",
          "[Added Lines]",
          "2289:  if (offset) {",
          "2290:   rule = (TranslationTableRule *)&table->ruleArea[offset];",
          "2291:   if (rule->dotslen)",
          "2292:    return for_updatePositions(&rule->charsdots[1], 1, rule->dotslen, 0, table,",
          "2293:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "2294:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "2295:      transRule, inputPositions, outputPositions, cursorPosition,",
          "2296:      cursorStatus, compbrlStart, compbrlEnd);",
          "2297:   d = _lou_getDotsForChar(character);",
          "2298:   return for_updatePositions(&d, 1, 1, 0, table, src, dest, srcmax, destmax, mode,",
          "2299:     currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "2300:     transNoteBuffer, transRule, inputPositions, outputPositions,",
          "2301:     cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2302:  }",
          "2303:  return undefinedCharacter(character, table, src, dest, srcmax, destmax, mode,",
          "2304:    currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "2305:    transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition,",
          "2306:    cursorStatus, compbrlStart, compbrlEnd);",
          "2310: putCharacters(const widechar *characters, int count, const TranslationTableHeader *table,",
          "2311:   int *src, int *dest, int srcmax, int destmax, int mode,",
          "2312:   const widechar *currentInput, widechar *currentOutput, int *srcMapping,",
          "2313:   int *prevSrcMapping, unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2314:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "2315:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "2318:  int k;",
          "2319:  for (k = 0; k < count; k++)",
          "2320:   if (!putCharacter(characters[k], table, src, dest, srcmax, destmax, mode,",
          "2321:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "2322:      emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "2323:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "2324:      compbrlEnd))",
          "2325:    return 0;",
          "2326:  return 1;",
          "2330: doCompbrl(const TranslationTableHeader *table, int *src, int *dest, int srcmax,",
          "2331:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "2332:   int *srcMapping, int *prevSrcMapping, unsigned int *emphasisBuffer,",
          "2333:   unsigned int *transNoteBuffer, const TranslationTableRule **transRule,",
          "2334:   int *inputPositions, int *outputPositions, int *cursorPosition, int *cursorStatus,",
          "2335:   int destword, int srcword, int compbrlStart, int compbrlEnd) {",
          "2337:  int stringStart, stringEnd;",
          "2338:  if (checkAttr(currentInput[*src], CTC_Space, 0, table)) return 1;",
          "2339:  if (destword) {",
          "2342:  } else {",
          "2345:  }",
          "2346:  for (stringStart = *src; stringStart >= 0; stringStart--)",
          "2347:   if (checkAttr(currentInput[stringStart], CTC_Space, 0, table)) break;",
          "2348:  stringStart++;",
          "2349:  for (stringEnd = *src; stringEnd < srcmax; stringEnd++)",
          "2350:   if (checkAttr(currentInput[stringEnd], CTC_Space, 0, table)) break;",
          "2351:  return doCompTrans(stringStart, stringEnd, table, src, dest, srcmax, destmax, mode,",
          "2352:    currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "2353:    transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition,",
          "2354:    cursorStatus, compbrlStart, compbrlEnd);",
          "2358: putCompChar(widechar character, const TranslationTableHeader *table, int *src, int *dest,",
          "2359:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "2360:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "2361:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2362:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "2363:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "2365:  widechar d;",
          "2366:  TranslationTableOffset offset = (findCharOrDots(character, 0, table))->definitionRule;",
          "2367:  if (offset) {",
          "2368:   const TranslationTableRule *rule =",
          "2369:     (TranslationTableRule *)&table->ruleArea[offset];",
          "2370:   if (rule->dotslen)",
          "2371:    return for_updatePositions(&rule->charsdots[1], 1, rule->dotslen, 0, table,",
          "2372:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "2373:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "2374:      transRule, inputPositions, outputPositions, cursorPosition,",
          "2375:      cursorStatus, compbrlStart, compbrlEnd);",
          "2376:   d = _lou_getDotsForChar(character);",
          "2377:   return for_updatePositions(&d, 1, 1, 0, table, src, dest, srcmax, destmax, mode,",
          "2378:     currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "2379:     transNoteBuffer, transRule, inputPositions, outputPositions,",
          "2380:     cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2381:  }",
          "2382:  return undefinedCharacter(character, table, src, dest, srcmax, destmax, mode,",
          "2383:    currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "2384:    transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition,",
          "2385:    cursorStatus, compbrlStart, compbrlEnd);",
          "2389: doCompTrans(int start, int end, const TranslationTableHeader *table, int *src, int *dest,",
          "2390:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "2391:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "2392:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "2393:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "2394:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "2395:  const TranslationTableRule *indicRule;",
          "2396:  int k;",
          "2397:  int haveEndsegment = 0;",
          "2398:  if (*cursorStatus != 2 && brailleIndicatorDefined(table->begComp, table, &indicRule))",
          "2399:   if (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,",
          "2400:      table, src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "2401:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "2402:      transRule, inputPositions, outputPositions, cursorPosition,",
          "2403:      cursorStatus, compbrlStart, compbrlEnd))",
          "2404:    return 0;",
          "2405:  for (k = start; k < end; k++) {",
          "2406:   TranslationTableOffset compdots = 0;",
          "2410:   emphasisBuffer[k] = 0;",
          "2411:   transNoteBuffer[k] = 0;",
          "2412:   if (currentInput[k] == ENDSEGMENT) {",
          "2413:    haveEndsegment = 1;",
          "2414:    continue;",
          "2415:   }",
          "2417:   if (currentInput[k] < 256) compdots = table->compdotsPattern[currentInput[k]];",
          "2418:   if (compdots != 0) {",
          "2420:    if (!for_updatePositions(&(*transRule)->charsdots[(*transRule)->charslen],",
          "2421:       (*transRule)->charslen, (*transRule)->dotslen, 0, table, src,",
          "2422:       dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "2423:       srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "2424:       transRule, inputPositions, outputPositions, cursorPosition,",
          "2425:       cursorStatus, compbrlStart, compbrlEnd))",
          "2426:     return 0;",
          "2427:   } else if (!putCompChar(currentInput[k], table, src, dest, srcmax, destmax, mode,",
          "2428:          currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "2429:          emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "2430:          outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "2431:          compbrlEnd))",
          "2432:    return 0;",
          "2434:  if (*cursorStatus != 2 && brailleIndicatorDefined(table->endComp, table, &indicRule))",
          "2435:   if (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,",
          "2436:      table, src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "2437:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "2438:      transRule, inputPositions, outputPositions, cursorPosition,",
          "2439:      cursorStatus, compbrlStart, compbrlEnd))",
          "2440:    return 0;",
          "2442:  if (haveEndsegment) {",
          "2443:   widechar endSegment = ENDSEGMENT;",
          "2444:   if (!for_updatePositions(&endSegment, 0, 1, 0, table, src, dest, srcmax, destmax,",
          "2445:      mode, currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "2446:      emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "2447:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "2448:      compbrlEnd))",
          "2449:    return 0;",
          "2451:  return 1;",
          "2455: doNocont(const TranslationTableHeader *table, int *src, int *dest, int mode,",
          "2456:   const widechar *currentInput, int destword, int srcword, int *dontContract) {",
          "2458:  if (checkAttr(currentInput[*src], CTC_Space, 0, table) || *dontContract ||",
          "2459:    (mode & noContractions))",
          "2460:   return 1;",
          "2461:  if (destword) {",
          "2464:  } else {",
          "2467:  }",
          "2469:  return 1;",
          "2473: markSyllables(const TranslationTableHeader *table, int srcmax,",
          "2474:   const widechar *currentInput, formtype *typebuf, int *transOpcode,",
          "2475:   const TranslationTableRule **transRule, int *transCharslen) {",
          "2476:  int src;",
          "2477:  int k;",
          "2478:  int currentMark = 0;",
          "2479:  int const syllable_marks[] = { SYLLABLE_MARKER_1, SYLLABLE_MARKER_2 };",
          "2480:  int syllable_mark_selector = 0;",
          "2482:  if (typebuf == NULL || !table->syllables) return 1;",
          "2483:  src = 0;",
          "2485:   int length = srcmax - src;",
          "2486:   const TranslationTableCharacter *character =",
          "2487:     findCharOrDots(currentInput[src], 0, table);",
          "2488:   const TranslationTableCharacter *character2;",
          "2489:   int tryThis = 0;",
          "2490:   while (tryThis < 3) {",
          "2491:    TranslationTableOffset ruleOffset = 0;",
          "2492:    unsigned long int makeHash = 0;",
          "2493:    switch (tryThis) {",
          "2494:    case 0:",
          "2495:     if (!(length >= 2)) break;",
          "2496:     makeHash = (unsigned long int)character->lowercase << 8;",
          "2498:     character2 = findCharOrDots(currentInput[src + 1], 0, table);",
          "2499:     makeHash += (unsigned long int)character2->lowercase;",
          "2500:     makeHash %= HASHNUM;",
          "2501:     ruleOffset = table->forRules[makeHash];",
          "2502:     break;",
          "2503:    case 1:",
          "2504:     if (!(length >= 1)) break;",
          "2505:     length = 1;",
          "2506:     ruleOffset = character->otherRules;",
          "2507:     break;",
          "2510:     ruleOffset = 0;",
          "2511:     break;",
          "2512:    }",
          "2513:    while (ruleOffset) {",
          "2517:     if (tryThis == 1 ||",
          "2518:       (*transCharslen <= length &&",
          "2519:         compareChars(&(*transRule)->charsdots[0],",
          "2520:           &currentInput[src], *transCharslen, 0, table))) {",
          "2521:      if (*transOpcode == CTO_Syllable) {",
          "2522:       tryThis = 4;",
          "2523:       break;",
          "2524:      }",
          "2525:     }",
          "2526:     ruleOffset = (*transRule)->charsnext;",
          "2527:    }",
          "2528:    tryThis++;",
          "2529:   }",
          "2530:   switch (*transOpcode) {",
          "2531:   case CTO_Always:",
          "2532:    if (src >= srcmax) return 0;",
          "2533:    typebuf[src++] |= currentMark;",
          "2534:    break;",
          "2535:   case CTO_Syllable:",
          "2538:    currentMark = syllable_marks[syllable_mark_selector];",
          "2539:    syllable_mark_selector = (syllable_mark_selector + 1) % 2;",
          "2541:    if ((src + *transCharslen) > srcmax) return 0;",
          "2542:    for (k = 0; k < *transCharslen; k++) typebuf[src++] |= currentMark;",
          "2543:    break;",
          "2544:   default:",
          "2545:    break;",
          "2548:  return 1;",
          "2552: resolveEmphasisWords(unsigned int *buffer, const unsigned int bit_begin,",
          "2553:   const unsigned int bit_end, const unsigned int bit_word,",
          "2554:   const unsigned int bit_symbol, int srcmax, unsigned int *wordBuffer) {",
          "2558:  for (i = 0; i < srcmax; i++) {",
          "2564:   if (!in_emp)",
          "2565:    if (buffer[i] & bit_begin) {",
          "2566:     in_emp = 1;",
          "2567:     buffer[i] &= ~bit_begin;",
          "2570:     if (in_word) {",
          "2571:      word_start = i;",
          "2572:      word_whole = 0;",
          "2573:     }",
          "2576:     if (!(wordBuffer[i] & WORD_CHAR)) word_start = -1;",
          "2580:   if (in_emp)",
          "2581:    if (buffer[i] & bit_end) {",
          "2582:     in_emp = 0;",
          "2583:     buffer[i] &= ~bit_end;",
          "2585:     if (in_word && word_start >= 0) {",
          "2587:      word_stop = bit_end | bit_word;",
          "2588:      if (wordBuffer[i] & WORD_CHAR)",
          "2589:       word_whole = 0;",
          "2590:      else",
          "2591:       word_stop = 0;",
          "2595:      if (bit_symbol && word_start + 1 == i)",
          "2596:       buffer[word_start] |= bit_symbol;",
          "2597:      else {",
          "2598:       buffer[word_start] |= bit_word;",
          "2599:       buffer[i] |= word_stop;",
          "2600:      }",
          "2601:      wordBuffer[word_start] |= word_whole;",
          "2606:   if (!in_word)",
          "2607:    if (wordBuffer[i] & WORD_CHAR) {",
          "2608:     in_word = 1;",
          "2609:     if (in_emp) {",
          "2610:      word_whole = WORD_WHOLE;",
          "2611:      word_start = i;",
          "2612:     }",
          "2616:   if (in_word)",
          "2617:    if (!(wordBuffer[i] & WORD_CHAR)) {",
          "2619:     if (in_emp && word_start >= 0) {",
          "2622:      if (bit_symbol && word_start + 1 == i)",
          "2624:      else",
          "2625:       buffer[word_start] |= bit_word;",
          "2626:      wordBuffer[word_start] |= word_whole;",
          "2627:     }",
          "2629:     in_word = 0;",
          "2630:     word_whole = 0;",
          "2631:     word_start = -1;",
          "2636:  if (in_emp) {",
          "2639:   if (in_word)",
          "2640:    if (word_start >= 0) {",
          "2643:     if (bit_symbol && word_start + 1 == i)",
          "2645:     else",
          "2646:      buffer[word_start] |= bit_word;",
          "2647:     wordBuffer[word_start] |= word_whole;",
          "2648:    }",
          "2653: convertToPassage(const int pass_start, const int pass_end, const int word_start,",
          "2654:   unsigned int *buffer, const EmphRuleNumber emphRule, const unsigned int bit_begin,",
          "2655:   const unsigned int bit_end, const unsigned int bit_word,",
          "2656:   const unsigned int bit_symbol, const TranslationTableHeader *table,",
          "2657:   unsigned int *wordBuffer, int *inputPositions, int *outputPositions,",
          "2658:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "2662:  for (i = pass_start; i <= pass_end; i++)",
          "2663:   if (wordBuffer[i] & WORD_WHOLE) {",
          "2664:    buffer[i] &= ~(bit_symbol | bit_word);",
          "2665:    wordBuffer[i] &= ~WORD_WHOLE;",
          "2666:   }",
          "2669:  if (brailleIndicatorDefined(",
          "2670:     table->emphRules[emphRule][endOffset], table, &indicRule) ||",
          "2671:    brailleIndicatorDefined(",
          "2672:      table->emphRules[emphRule][endPhraseAfterOffset], table, &indicRule))",
          "2674:  else if (brailleIndicatorDefined(table->emphRules[emphRule][endPhraseBeforeOffset],",
          "2675:       table, &indicRule))",
          "2680: resolveEmphasisPassages(unsigned int *buffer, const EmphRuleNumber emphRule,",
          "2681:   const unsigned int bit_begin, const unsigned int bit_end,",
          "2682:   const unsigned int bit_word, const unsigned int bit_symbol,",
          "2683:   const TranslationTableHeader *table, int srcmax, unsigned int *wordBuffer,",
          "2684:   int *inputPositions, int *outputPositions, int *cursorPosition, int *cursorStatus,",
          "2685:   int compbrlStart, int compbrlEnd) {",
          "2690:  for (i = 0; i < srcmax; i++) {",
          "2692:   if (!in_word)",
          "2693:    if (wordBuffer[i] & WORD_CHAR) {",
          "2694:     in_word = 1;",
          "2695:     if (wordBuffer[i] & WORD_WHOLE) {",
          "2696:      if (!in_pass) {",
          "2697:       in_pass = 1;",
          "2698:       pass_start = i;",
          "2699:       pass_end = -1;",
          "2700:       word_cnt = 1;",
          "2701:      } else",
          "2702:       word_cnt++;",
          "2703:      word_start = i;",
          "2704:      continue;",
          "2705:     } else if (in_pass) {",
          "2706:      if (word_cnt >= table->emphRules[emphRule][lenPhraseOffset])",
          "2707:       if (pass_end >= 0) {",
          "2708:        convertToPassage(pass_start, pass_end, word_start, buffer,",
          "2709:          emphRule, bit_begin, bit_end, bit_word, bit_symbol,",
          "2710:          table, wordBuffer, inputPositions, outputPositions,",
          "2711:          cursorPosition, cursorStatus, compbrlStart,",
          "2712:          compbrlEnd);",
          "2713:       }",
          "2714:      in_pass = 0;",
          "2719:   if (in_word)",
          "2720:    if (!(wordBuffer[i] & WORD_CHAR)) {",
          "2721:     in_word = 0;",
          "2722:     if (in_pass) pass_end = i;",
          "2723:    }",
          "2725:   if (in_pass)",
          "2726:    if (buffer[i] & bit_begin || buffer[i] & bit_end || buffer[i] & bit_word ||",
          "2727:      buffer[i] & bit_symbol) {",
          "2728:     if (word_cnt >= table->emphRules[emphRule][lenPhraseOffset])",
          "2729:      if (pass_end >= 0) {",
          "2730:       convertToPassage(pass_start, pass_end, word_start, buffer,",
          "2731:         emphRule, bit_begin, bit_end, bit_word, bit_symbol, table,",
          "2732:         wordBuffer, inputPositions, outputPositions,",
          "2733:         cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "2734:      }",
          "2735:     in_pass = 0;",
          "2739:  if (in_pass) {",
          "2740:   if (word_cnt >= table->emphRules[emphRule][lenPhraseOffset]) {",
          "2741:    if (pass_end >= 0) {",
          "2742:     if (in_word) {",
          "2743:      convertToPassage(pass_start, i, word_start, buffer, emphRule,",
          "2744:        bit_begin, bit_end, bit_word, bit_symbol, table, wordBuffer,",
          "2745:        inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "2746:        compbrlStart, compbrlEnd);",
          "2747:     } else {",
          "2748:      convertToPassage(pass_start, pass_end, word_start, buffer, emphRule,",
          "2749:        bit_begin, bit_end, bit_word, bit_symbol, table, wordBuffer,",
          "2750:        inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "2751:        compbrlStart, compbrlEnd);",
          "2752:     }",
          "2753:    }",
          "2759: resolveEmphasisSingleSymbols(unsigned int *buffer, const unsigned int bit_begin,",
          "2760:   const unsigned int bit_end, const unsigned int bit_symbol, int srcmax) {",
          "2763:  for (i = 0; i < srcmax; i++) {",
          "2764:   if (buffer[i] & bit_begin)",
          "2765:    if (buffer[i + 1] & bit_end) {",
          "2766:     buffer[i] &= ~bit_begin;",
          "2767:     buffer[i + 1] &= ~bit_end;",
          "2768:     buffer[i] |= bit_symbol;",
          "2769:    }",
          "2774: resolveEmphasisAllCapsSymbols(unsigned int *buffer, formtype *typebuf, int srcmax) {",
          "2783:  int inEmphasis = 0, i;",
          "2785:  for (i = 0; i < srcmax; i++) {",
          "2786:   if (buffer[i] & bit_end) {",
          "2787:    inEmphasis = 0;",
          "2789:   } else {",
          "2790:    if (buffer[i] & bit_begin) {",
          "2794:    if (inEmphasis) {",
          "2798:      buffer[i] |= bit_symbol;",
          "2805: resolveEmphasisResets(unsigned int *buffer, const unsigned int bit_begin,",
          "2806:   const unsigned int bit_end, const unsigned int bit_word,",
          "2807:   const unsigned int bit_symbol, const TranslationTableHeader *table, int srcmax,",
          "2808:   const widechar *currentInput, unsigned int *wordBuffer) {",
          "2809:  int in_word = 0, in_pass = 0, word_start = -1, word_reset = 0, orig_reset = -1,",
          "2810:   letter_cnt = 0;",
          "2813:  for (i = 0; i < srcmax; i++) {",
          "2814:   if (in_pass)",
          "2815:    if (buffer[i] & bit_end) in_pass = 0;",
          "2817:   if (!in_pass) {",
          "2818:    if (buffer[i] & bit_begin)",
          "2819:     in_pass = 1;",
          "2820:    else {",
          "2821:     if (!in_word) {",
          "2822:      if (buffer[i] & bit_word) {",
          "2825:       if (wordBuffer[i] & WORD_RESET ||",
          "2826:         !checkAttr(currentInput[i], CTC_Letter, 0, table)) {",
          "2828:        if (wordBuffer[i + 1] & WORD_CHAR) {",
          "2829:         buffer[i + 1] |= bit_word;",
          "2830:         if (wordBuffer[i] & WORD_WHOLE)",
          "2831:          wordBuffer[i + 1] |= WORD_WHOLE;",
          "2832:        }",
          "2833:        buffer[i] &= ~bit_word;",
          "2834:        wordBuffer[i] &= ~WORD_WHOLE;",
          "2837:        if (checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "2838:         buffer[i] |= bit_symbol;",
          "2840:        continue;",
          "2841:       }",
          "2843:       in_word = 1;",
          "2844:       word_start = i;",
          "2845:       letter_cnt = 0;",
          "2846:       word_reset = 0;",
          "2851:      else if (buffer[i] & bit_symbol) {",
          "2852:       if (wordBuffer[i] & WORD_RESET ||",
          "2853:         !checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "2854:        buffer[i] &= ~bit_symbol;",
          "2856:     }",
          "2858:     if (in_word) {",
          "2861:      if (!(wordBuffer[i] & WORD_CHAR) ||",
          "2862:        (buffer[i] & bit_word && buffer[i] & bit_end)) {",
          "2863:       in_word = 0;",
          "2866:       if (bit_symbol && letter_cnt == 1) {",
          "2867:        buffer[word_start] |= bit_symbol;",
          "2868:        buffer[word_start] &= ~bit_word;",
          "2869:        wordBuffer[word_start] &= ~WORD_WHOLE;",
          "2870:        buffer[i] &= ~(bit_end | bit_word);",
          "2871:       }",
          "2875:       if (word_reset || wordBuffer[i] & WORD_RESET ||",
          "2876:         !checkAttr(currentInput[i], CTC_Letter, 0, table))",
          "2877:        buffer[i] &= ~(bit_end | bit_word);",
          "2880:       if (i == word_start) {",
          "2881:        wordBuffer[word_start] &= ~WORD_WHOLE;",
          "2882:        buffer[i] &= ~(bit_end | bit_word);",
          "2883:       }",
          "2884:       orig_reset = -1;",
          "2885:      } else {",
          "2887:       if (wordBuffer[i] & WORD_RESET ||",
          "2888:         !checkAttr(currentInput[i], CTC_Letter, 0, table)) {",
          "2889:        if (!checkAttr(currentInput[i], CTC_Letter, 0, table)) {",
          "2890:         if (checkAttr(currentInput[i], CTC_CapsMode, 0, table)) {",
          "2892:          orig_reset = i;",
          "2893:          continue;",
          "2894:         } else if (orig_reset >= 0) {",
          "2896:          for (j = orig_reset; j < i; j++)",
          "2897:           buffer[j] &= ~bit_word;",
          "2899:          orig_reset = -1;",
          "2900:         }",
          "2901:        }",
          "2904:        if (bit_symbol && letter_cnt == 1) {",
          "2905:         buffer[word_start] |= bit_symbol;",
          "2906:         buffer[word_start] &= ~bit_word;",
          "2907:         wordBuffer[word_start] &= ~WORD_WHOLE;",
          "2909:        }",
          "2912:        if (checkAttr(currentInput[i], CTC_Letter, 0, table)) {",
          "2913:         word_reset = 0;",
          "2914:         word_start = i;",
          "2915:         letter_cnt = 1;",
          "2916:         buffer[i] |= bit_word;",
          "2917:        } else",
          "2918:         word_reset = 1;",
          "2920:        continue;",
          "2921:       }",
          "2923:       if (word_reset) {",
          "2924:        word_reset = 0;",
          "2925:        word_start = i;",
          "2926:        letter_cnt = 0;",
          "2927:        buffer[i] |= bit_word;",
          "2928:       }",
          "2930:       letter_cnt++;",
          "2938:  if (in_word) {",
          "2940:   if (bit_symbol && letter_cnt == 1) {",
          "2947:   if (word_reset) buffer[i] &= ~(bit_end | bit_word);",
          "2952: markEmphases(const TranslationTableHeader *table, int srcmax,",
          "2953:   const widechar *currentInput, formtype *typebuf, unsigned int *wordBuffer,",
          "2954:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer, int haveEmphasis,",
          "2955:   int *inputPositions, int *outputPositions, int *cursorPosition, int *cursorStatus,",
          "2956:   int compbrlStart, int compbrlEnd) {",
          "2959:  int emph_start[10] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };",
          "2962:  for (i = 0; i < srcmax; i++) {",
          "2963:   if (!checkAttr(currentInput[i], CTC_Space, 0, table)) {",
          "2965:   } else if (caps_cnt > 0) {",
          "2970:   if (checkAttr(currentInput[i], CTC_UpperCase, 0, table)) {",
          "2971:    if (caps_start < 0) caps_start = i;",
          "2973:   } else if (caps_start >= 0) {",
          "2975:    if (checkAttr(currentInput[i], CTC_Letter, 0, table) &&",
          "2976:      checkAttr(currentInput[i], CTC_LowerCase, 0, table)) {",
          "2978:     if (caps_cnt > 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3608:     caps_cnt = 0;",
          "3609:    }",
          "3610:   }",
          "3626:      emphasisBuffer[emph_start[j]] |= EMPHASIS_BEGIN << (j * 4);",
          "3627:      emphasisBuffer[i] |= EMPHASIS_END << (j * 4);",
          "3631:      transNoteBuffer[emph_start[j]] |= TRANSNOTE_BEGIN << ((j - 5) * 4);",
          "3632:      transNoteBuffer[i] |= TRANSNOTE_END << ((j - 5) * 4);",
          "3633:     }",
          "",
          "[Removed Lines]",
          "3612:   if(!haveEmphasis)",
          "3613:    continue;",
          "3615:   for (j = 0; j < 10; j++)",
          "3616:   {",
          "3617:    if(typebuf[i] & (italic << j))",
          "3618:    {",
          "3619:     if(emph_start[j] < 0)",
          "3620:      emph_start[j] = i;",
          "3621:    }",
          "3622:    else if(emph_start[j] >= 0)",
          "3623:    {",
          "3624:     if (j < 5)",
          "3625:     {",
          "3628:     }",
          "3629:     else",
          "3630:     {",
          "",
          "[Added Lines]",
          "2988:   if (!haveEmphasis) continue;",
          "2990:   for (j = 0; j < 10; j++) {",
          "2991:    if (typebuf[i] & (italic << j)) {",
          "2992:     if (emph_start[j] < 0) emph_start[j] = i;",
          "2993:    } else if (emph_start[j] >= 0) {",
          "2994:     if (j < 5) {",
          "2997:     } else {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3635:    }",
          "3636:   }",
          "3637:  }",
          "3642:   emphasisBuffer[caps_start] |= CAPS_BEGIN;",
          "3644:    emphasisBuffer[srcmax] |= CAPS_END;",
          "3645:   else",
          "3646:    emphasisBuffer[last_caps] |= CAPS_END;",
          "3647:  }",
          "3657:      emphasisBuffer[emph_start[j]] |= EMPHASIS_BEGIN << (j * 4);",
          "3658:      emphasisBuffer[srcmax] |= EMPHASIS_END << (j * 4);",
          "3662:      transNoteBuffer[emph_start[j]] |= TRANSNOTE_BEGIN << ((j - 5) * 4);",
          "3663:      transNoteBuffer[srcmax] |= TRANSNOTE_END << ((j - 5) * 4);",
          "3664:     }",
          "3665:    }",
          "3666:   }",
          "3667:  }",
          "3683:     if (inCaps) typebuf[i] |= no_contract;",
          "3684:    }",
          "3685:   }",
          "3686:  }",
          "3701:   else",
          "3704:  }",
          "3715:    if (table->emphRules[emph1Rule + j][lenPhraseOffset])",
          "3716:     resolveEmphasisPassages(emphasisBuffer, emph1Rule + j,",
          "3730:    if (table->emphRules[emph6Rule + j][lenPhraseOffset])",
          "3731:     resolveEmphasisPassages(transNoteBuffer, j + 6,",
          "3738:  }",
          "3739: }",
          "3741: static void",
          "3764:   const TranslationTableRule *indicRule;",
          "3768:  }",
          "3769: }",
          "3771: static void",
          "3794:  const TranslationTableRule *indicRule;",
          "3812:  }",
          "3813: }",
          "3815: static void",
          "3839:   const TranslationTableRule *indicRule;",
          "3857:   }",
          "3858:  }",
          "3859: }",
          "3861: static int",
          "3877:  return cnt;",
          "3878: }",
          "3880: static int",
          "3893:   int i, cnt = 1;",
          "3899:   return cnt;",
          "3903:   int i, cnt = 1;",
          "3912:   return cnt;",
          "3913:  }",
          "3914:  return 0;",
          "3915: }",
          "3917: static void",
          "3936:  int type_counts[10];",
          "3937:  int i, j, min, max;",
          "3945:    const TranslationTableRule *indicRule;",
          "3949:   }",
          "3959:   }",
          "3960:   return;",
          "3961:  }",
          "",
          "[Removed Lines]",
          "3640:  if(caps_start >= 0)",
          "3641:  {",
          "3643:   if(caps_cnt > 0)",
          "3649:  if(haveEmphasis)",
          "3650:  {",
          "3651:   for(j = 0; j < 10; j++)",
          "3652:   {",
          "3653:    if(emph_start[j] >= 0)",
          "3654:    {",
          "3655:     if (j < 5)",
          "3656:     {",
          "3659:     }",
          "3660:     else",
          "3661:     {",
          "3670:  if (table->capsNoCont)",
          "3671:  {",
          "3672:   int inCaps=0;",
          "3673:   for(i = 0; i < srcmax; i++)",
          "3674:   {",
          "3675:    if (emphasisBuffer[i] & CAPS_END)",
          "3676:    {",
          "3677:     inCaps=0;",
          "3678:    }",
          "3679:    else",
          "3680:    {",
          "3681:     if ((emphasisBuffer[i] & CAPS_BEGIN) && !(emphasisBuffer[i+1] & CAPS_END))",
          "3682:      inCaps=1;",
          "3688:  if(table->emphRules[capsRule][begWordOffset]) {",
          "3689:    resolveEmphasisWords(emphasisBuffer,",
          "3690:           CAPS_BEGIN, CAPS_END, CAPS_WORD, CAPS_SYMBOL, srcmax, wordBuffer);",
          "3691:    if (table->emphRules[capsRule][lenPhraseOffset])",
          "3692:      resolveEmphasisPassages(emphasisBuffer,",
          "3693:         capsRule, CAPS_BEGIN, CAPS_END, CAPS_WORD, CAPS_SYMBOL, table, srcmax, wordBuffer, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3694:    resolveEmphasisResets(emphasisBuffer,",
          "3695:     CAPS_BEGIN, CAPS_END, CAPS_WORD, CAPS_SYMBOL, table, srcmax, currentInput, wordBuffer);",
          "3696:  }",
          "3697:  else if(table->emphRules[capsRule][letterOffset])",
          "3698:  {",
          "3700:     resolveEmphasisAllCapsSymbols(emphasisBuffer, typebuf, srcmax);",
          "3702:     resolveEmphasisSingleSymbols(emphasisBuffer,",
          "3703:      CAPS_BEGIN, CAPS_END, CAPS_SYMBOL, srcmax);",
          "3706:  if(!haveEmphasis)",
          "3707:   return;",
          "3709:  for (j = 0; j < 5; j++)",
          "3710:  {",
          "3711:   if(table->emphRules[emph1Rule + j][begWordOffset]) {",
          "3712:    resolveEmphasisWords(emphasisBuffer,",
          "3713:     EMPHASIS_BEGIN << (j * 4), EMPHASIS_END << (j * 4),",
          "3714:     EMPHASIS_WORD << (j * 4), EMPHASIS_SYMBOL << (j * 4), srcmax, wordBuffer);",
          "3717:      EMPHASIS_BEGIN << (j * 4), EMPHASIS_END << (j * 4),",
          "3718:      EMPHASIS_WORD << (j * 4), EMPHASIS_SYMBOL << (j * 4), table, srcmax, wordBuffer, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3719:   } else if(table->emphRules[emph1Rule + j][letterOffset])",
          "3720:    resolveEmphasisSingleSymbols(emphasisBuffer,",
          "3721:     EMPHASIS_BEGIN << (j * 4), EMPHASIS_END << (j * 4),",
          "3722:     EMPHASIS_SYMBOL << (j * 4), srcmax);",
          "3723:  }",
          "3724:  for (j = 0; j < 5; j++)",
          "3725:  {",
          "3726:   if(table->emphRules[emph6Rule + j][begWordOffset]) {",
          "3727:    resolveEmphasisWords(transNoteBuffer,",
          "3728:     TRANSNOTE_BEGIN << (j * 4), TRANSNOTE_END << (j * 4),",
          "3729:     TRANSNOTE_WORD << (j * 4), TRANSNOTE_SYMBOL << (j * 4), srcmax, wordBuffer);",
          "3732:      TRANSNOTE_BEGIN << (j * 4), TRANSNOTE_END << (j * 4),",
          "3733:      TRANSNOTE_WORD << (j * 4), TRANSNOTE_SYMBOL << (j * 4), table, srcmax, wordBuffer, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3734:   } else if(table->emphRules[emph6Rule + j][letterOffset])",
          "3735:    resolveEmphasisSingleSymbols(transNoteBuffer,",
          "3736:     TRANSNOTE_BEGIN << (j * 4), TRANSNOTE_END << (j * 4),",
          "3737:     TRANSNOTE_SYMBOL << (j * 4), srcmax);",
          "3742: insertEmphasisSymbol(",
          "3743:  unsigned int *buffer,",
          "3744:  const int at,",
          "3745:  const EmphRuleNumber emphRule,",
          "3746:  const unsigned int bit_symbol,",
          "3747:  const TranslationTableHeader *table,",
          "3748:  int *src, int *dest,",
          "3749:  int srcmax, int destmax,",
          "3750:  int mode,",
          "3751:  const widechar *currentInput,",
          "3752:  widechar *currentOutput,",
          "3753:  int *srcMapping,",
          "3754:  int *prevSrcMapping,",
          "3755:  unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3756:  const TranslationTableRule **transRule,",
          "3757:  int *inputPositions,",
          "3758:  int *outputPositions,",
          "3759:  int *cursorPosition, int *cursorStatus,",
          "3760:  int compbrlStart, int compbrlEnd)",
          "3761: {",
          "3762:  if(buffer[at] & bit_symbol)",
          "3763:  {",
          "3765:   if(brailleIndicatorDefined(table->emphRules[emphRule][letterOffset], table, &indicRule))",
          "3766:    for_updatePositions(",
          "3767:     &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3772: insertEmphasisBegin(",
          "3773:  unsigned int *buffer,",
          "3774:  const int at,",
          "3775:  const EmphRuleNumber emphRule,",
          "3776:  const unsigned int bit_begin,",
          "3777:  const unsigned int bit_end,",
          "3778:  const unsigned int bit_word,",
          "3779:  const TranslationTableHeader *table,",
          "3780:  int *src, int *dest,",
          "3781:  int srcmax, int destmax,",
          "3782:  int mode,",
          "3783:  const widechar *currentInput,",
          "3784:  widechar *currentOutput,",
          "3785:  int *srcMapping,",
          "3786:  int *prevSrcMapping,",
          "3787:  unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3788:  const TranslationTableRule **transRule,",
          "3789:  int *inputPositions,",
          "3790:  int *outputPositions,",
          "3791:  int *cursorPosition, int *cursorStatus,",
          "3792:  int compbrlStart, int compbrlEnd)",
          "3793: {",
          "3795:  if(buffer[at] & bit_begin)",
          "3796:  {",
          "3797:   if(brailleIndicatorDefined(table->emphRules[emphRule][begPhraseOffset], table, &indicRule))",
          "3798:    for_updatePositions(",
          "3799:     &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3800:   else if(brailleIndicatorDefined(table->emphRules[emphRule][begOffset], table, &indicRule))",
          "3801:    for_updatePositions(",
          "3802:     &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3803:  }",
          "3805:  if(buffer[at] & bit_word",
          "3807:     && !(buffer[at] & bit_end))",
          "3808:  {",
          "3809:   if(brailleIndicatorDefined(table->emphRules[emphRule][begWordOffset], table, &indicRule))",
          "3810:    for_updatePositions(",
          "3811:     &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3816: insertEmphasisEnd(",
          "3817:  unsigned int *buffer,",
          "3818:  const int at,",
          "3819:  const EmphRuleNumber emphRule,",
          "3820:  const unsigned int bit_end,",
          "3821:  const unsigned int bit_word,",
          "3822:  const TranslationTableHeader *table,",
          "3823:  int *src, int *dest,",
          "3824:  int srcmax, int destmax,",
          "3825:  int mode,",
          "3826:  const widechar *currentInput,",
          "3827:  widechar *currentOutput,",
          "3828:  int *srcMapping,",
          "3829:  int *prevSrcMapping,",
          "3830:  unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3831:  const TranslationTableRule **transRule,",
          "3832:  int *inputPositions,",
          "3833:  int *outputPositions,",
          "3834:  int *cursorPosition, int *cursorStatus,",
          "3835:  int compbrlStart, int compbrlEnd)",
          "3836: {",
          "3837:  if(buffer[at] & bit_end)",
          "3838:  {",
          "3840:   if(buffer[at] & bit_word)",
          "3841:   {",
          "3842:    if(brailleIndicatorDefined(table->emphRules[emphRule][endWordOffset], table, &indicRule))",
          "3843:     for_updatePositions(",
          "3844:      &indicRule->charsdots[0], 0, indicRule->dotslen, -1, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3845:   }",
          "3846:   else",
          "3847:   {",
          "3848:    if(brailleIndicatorDefined(table->emphRules[emphRule][endOffset], table, &indicRule))",
          "3849:     for_updatePositions(",
          "3850:      &indicRule->charsdots[0], 0, indicRule->dotslen, -1, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3851:    else if(brailleIndicatorDefined(table->emphRules[emphRule][endPhraseAfterOffset], table, &indicRule))",
          "3852:     for_updatePositions(",
          "3853:      &indicRule->charsdots[0], 0, indicRule->dotslen, -1, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3854:    else if(brailleIndicatorDefined(table->emphRules[emphRule][endPhraseBeforeOffset], table, &indicRule))",
          "3855:     for_updatePositions(",
          "3856:      &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3862: endCount(",
          "3863:  unsigned int *buffer,",
          "3864:  const int at,",
          "3865:  const unsigned int bit_end,",
          "3866:  const unsigned int bit_begin,",
          "3867:  const unsigned int bit_word)",
          "3868: {",
          "3869:  int i, cnt = 1;",
          "3870:  if(!(buffer[at] & bit_end))",
          "3871:   return 0;",
          "3872:  for(i = at - 1; i >= 0; i--)",
          "3873:  if(buffer[i] & bit_begin || buffer[i] & bit_word)",
          "3874:   break;",
          "3875:  else",
          "3876:   cnt++;",
          "3881: beginCount(",
          "3882:  unsigned int *buffer,",
          "3883:  const int at,",
          "3884:  const unsigned int bit_end,",
          "3885:  const unsigned int bit_begin,",
          "3886:  const unsigned int bit_word,",
          "3887:  const TranslationTableHeader *table,",
          "3888:  int srcmax,",
          "3889:  const widechar *currentInput)",
          "3890: {",
          "3891:  if(buffer[at] & bit_begin)",
          "3892:  {",
          "3894:   for(i = at + 1; i < srcmax; i++)",
          "3895:   if(buffer[i] & bit_end)",
          "3896:    break;",
          "3897:   else",
          "3898:    cnt++;",
          "3900:  }",
          "3901:  else if(buffer[at] & bit_word)",
          "3902:  {",
          "3904:   for(i = at + 1; i < srcmax; i++)",
          "3905:   if(buffer[i] & bit_end)",
          "3906:    break;",
          "3908:   else if(checkAttr(currentInput[i], CTC_SeqDelimiter | CTC_Space, 0, table))",
          "3909:    break;",
          "3910:   else",
          "3911:    cnt++;",
          "3918: insertEmphasesAt(const int at,",
          "3919:    const TranslationTableHeader *table,",
          "3920:    int *src, int *dest,",
          "3921:    int srcmax, int destmax,",
          "3922:    int mode,",
          "3923:    const widechar *currentInput,",
          "3924:    widechar *currentOutput,",
          "3925:    int *srcMapping,",
          "3926:    int *prevSrcMapping,",
          "3927:    unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3928:    int haveEmphasis,",
          "3929:    int transOpcode,",
          "3930:    const TranslationTableRule **transRule,",
          "3931:    int *inputPositions,",
          "3932:    int *outputPositions,",
          "3933:    int *cursorPosition, int *cursorStatus,",
          "3934:    int compbrlStart, int compbrlEnd)",
          "3935: {",
          "3940:  if(!haveEmphasis)",
          "3941:  {",
          "3943:   if(transOpcode == CTO_Contraction)",
          "3944:   {",
          "3946:    if(brailleIndicatorDefined(table->noContractSign, table, &indicRule))",
          "3947:     for_updatePositions(",
          "3948:      &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3951:   if(emphasisBuffer[at] & CAPS_EMPHASIS)",
          "3952:   {",
          "3953:    insertEmphasisEnd(",
          "3954:     emphasisBuffer, at, capsRule, CAPS_END, CAPS_WORD, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3955:    insertEmphasisBegin(",
          "3956:     emphasisBuffer, at, capsRule, CAPS_BEGIN, CAPS_END, CAPS_WORD, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3957:    insertEmphasisSymbol(",
          "3958:     emphasisBuffer, at, capsRule, CAPS_SYMBOL, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "",
          "[Added Lines]",
          "3007:  if (caps_start >= 0) {",
          "3009:   if (caps_cnt > 0)",
          "3015:  if (haveEmphasis) {",
          "3016:   for (j = 0; j < 10; j++) {",
          "3017:    if (emph_start[j] >= 0) {",
          "3018:     if (j < 5) {",
          "3021:     } else {",
          "3030:  if (table->capsNoCont) {",
          "3031:   int inCaps = 0;",
          "3032:   for (i = 0; i < srcmax; i++) {",
          "3033:    if (emphasisBuffer[i] & CAPS_END) {",
          "3034:     inCaps = 0;",
          "3035:    } else {",
          "3036:     if ((emphasisBuffer[i] & CAPS_BEGIN) &&",
          "3037:       !(emphasisBuffer[i + 1] & CAPS_END))",
          "3038:      inCaps = 1;",
          "3044:  if (table->emphRules[capsRule][begWordOffset]) {",
          "3045:   resolveEmphasisWords(emphasisBuffer, CAPS_BEGIN, CAPS_END, CAPS_WORD, CAPS_SYMBOL,",
          "3046:     srcmax, wordBuffer);",
          "3047:   if (table->emphRules[capsRule][lenPhraseOffset])",
          "3048:    resolveEmphasisPassages(emphasisBuffer, capsRule, CAPS_BEGIN, CAPS_END,",
          "3049:      CAPS_WORD, CAPS_SYMBOL, table, srcmax, wordBuffer, inputPositions,",
          "3050:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "3051:      compbrlEnd);",
          "3052:   resolveEmphasisResets(emphasisBuffer, CAPS_BEGIN, CAPS_END, CAPS_WORD,",
          "3053:     CAPS_SYMBOL, table, srcmax, currentInput, wordBuffer);",
          "3054:  } else if (table->emphRules[capsRule][letterOffset]) {",
          "3056:    resolveEmphasisAllCapsSymbols(emphasisBuffer, typebuf, srcmax);",
          "3058:    resolveEmphasisSingleSymbols(",
          "3059:      emphasisBuffer, CAPS_BEGIN, CAPS_END, CAPS_SYMBOL, srcmax);",
          "3062:  if (!haveEmphasis) return;",
          "3064:  for (j = 0; j < 5; j++) {",
          "3065:   if (table->emphRules[emph1Rule + j][begWordOffset]) {",
          "3066:    resolveEmphasisWords(emphasisBuffer, EMPHASIS_BEGIN << (j * 4),",
          "3067:      EMPHASIS_END << (j * 4), EMPHASIS_WORD << (j * 4),",
          "3068:      EMPHASIS_SYMBOL << (j * 4), srcmax, wordBuffer);",
          "3071:       EMPHASIS_BEGIN << (j * 4), EMPHASIS_END << (j * 4),",
          "3072:       EMPHASIS_WORD << (j * 4), EMPHASIS_SYMBOL << (j * 4), table,",
          "3073:       srcmax, wordBuffer, inputPositions, outputPositions,",
          "3074:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3075:   } else if (table->emphRules[emph1Rule + j][letterOffset])",
          "3076:    resolveEmphasisSingleSymbols(emphasisBuffer, EMPHASIS_BEGIN << (j * 4),",
          "3077:      EMPHASIS_END << (j * 4), EMPHASIS_SYMBOL << (j * 4), srcmax);",
          "3078:  }",
          "3079:  for (j = 0; j < 5; j++) {",
          "3080:   if (table->emphRules[emph6Rule + j][begWordOffset]) {",
          "3081:    resolveEmphasisWords(transNoteBuffer, TRANSNOTE_BEGIN << (j * 4),",
          "3082:      TRANSNOTE_END << (j * 4), TRANSNOTE_WORD << (j * 4),",
          "3083:      TRANSNOTE_SYMBOL << (j * 4), srcmax, wordBuffer);",
          "3086:       TRANSNOTE_BEGIN << (j * 4), TRANSNOTE_END << (j * 4),",
          "3087:       TRANSNOTE_WORD << (j * 4), TRANSNOTE_SYMBOL << (j * 4), table,",
          "3088:       srcmax, wordBuffer, inputPositions, outputPositions,",
          "3089:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3090:   } else if (table->emphRules[emph6Rule + j][letterOffset])",
          "3091:    resolveEmphasisSingleSymbols(transNoteBuffer, TRANSNOTE_BEGIN << (j * 4),",
          "3092:      TRANSNOTE_END << (j * 4), TRANSNOTE_SYMBOL << (j * 4), srcmax);",
          "3097: insertEmphasisSymbol(unsigned int *buffer, const int at, const EmphRuleNumber emphRule,",
          "3098:   const unsigned int bit_symbol, const TranslationTableHeader *table, int *src,",
          "3099:   int *dest, int srcmax, int destmax, int mode, const widechar *currentInput,",
          "3100:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "3101:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3102:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "3103:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "3104:  if (buffer[at] & bit_symbol) {",
          "3106:   if (brailleIndicatorDefined(",
          "3107:      table->emphRules[emphRule][letterOffset], table, &indicRule))",
          "3108:    for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table,",
          "3109:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3110:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3111:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3112:      cursorStatus, compbrlStart, compbrlEnd);",
          "3117: insertEmphasisBegin(unsigned int *buffer, const int at, const EmphRuleNumber emphRule,",
          "3118:   const unsigned int bit_begin, const unsigned int bit_end,",
          "3119:   const unsigned int bit_word, const TranslationTableHeader *table, int *src,",
          "3120:   int *dest, int srcmax, int destmax, int mode, const widechar *currentInput,",
          "3121:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "3122:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3123:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "3124:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "3126:  if (buffer[at] & bit_begin) {",
          "3127:   if (brailleIndicatorDefined(",
          "3128:      table->emphRules[emphRule][begPhraseOffset], table, &indicRule))",
          "3129:    for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table,",
          "3130:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3131:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3132:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3133:      cursorStatus, compbrlStart, compbrlEnd);",
          "3134:   else if (brailleIndicatorDefined(",
          "3135:        table->emphRules[emphRule][begOffset], table, &indicRule))",
          "3136:    for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table,",
          "3137:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3138:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3139:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3140:      cursorStatus, compbrlStart, compbrlEnd);",
          "3141:  }",
          "3143:  if (buffer[at] & bit_word",
          "3145:    && !(buffer[at] & bit_end)) {",
          "3146:   if (brailleIndicatorDefined(",
          "3147:      table->emphRules[emphRule][begWordOffset], table, &indicRule))",
          "3148:    for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table,",
          "3149:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3150:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3151:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3152:      cursorStatus, compbrlStart, compbrlEnd);",
          "3157: insertEmphasisEnd(unsigned int *buffer, const int at, const EmphRuleNumber emphRule,",
          "3158:   const unsigned int bit_end, const unsigned int bit_word,",
          "3159:   const TranslationTableHeader *table, int *src, int *dest, int srcmax, int destmax,",
          "3160:   int mode, const widechar *currentInput, widechar *currentOutput, int *srcMapping,",
          "3161:   int *prevSrcMapping, unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "3162:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "3163:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "3164:  if (buffer[at] & bit_end) {",
          "3166:   if (buffer[at] & bit_word) {",
          "3167:    if (brailleIndicatorDefined(",
          "3168:       table->emphRules[emphRule][endWordOffset], table, &indicRule))",
          "3169:     for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,",
          "3170:       table, src, dest, srcmax, destmax, mode, currentInput,",
          "3171:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3172:       transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3173:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3174:   } else {",
          "3175:    if (brailleIndicatorDefined(",
          "3176:       table->emphRules[emphRule][endOffset], table, &indicRule))",
          "3177:     for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,",
          "3178:       table, src, dest, srcmax, destmax, mode, currentInput,",
          "3179:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3180:       transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3181:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3182:    else if (brailleIndicatorDefined(",
          "3183:         table->emphRules[emphRule][endPhraseAfterOffset], table,",
          "3184:         &indicRule))",
          "3185:     for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,",
          "3186:       table, src, dest, srcmax, destmax, mode, currentInput,",
          "3187:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3188:       transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3189:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3190:    else if (brailleIndicatorDefined(",
          "3191:         table->emphRules[emphRule][endPhraseBeforeOffset], table,",
          "3192:         &indicRule))",
          "3193:     for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,",
          "3194:       table, src, dest, srcmax, destmax, mode, currentInput,",
          "3195:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3196:       transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3197:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3203: endCount(unsigned int *buffer, const int at, const unsigned int bit_end,",
          "3204:   const unsigned int bit_begin, const unsigned int bit_word) {",
          "3205:  int i, cnt = 1;",
          "3206:  if (!(buffer[at] & bit_end)) return 0;",
          "3207:  for (i = at - 1; i >= 0; i--)",
          "3208:   if (buffer[i] & bit_begin || buffer[i] & bit_word)",
          "3209:    break;",
          "3210:   else",
          "3211:    cnt++;",
          "3216: beginCount(unsigned int *buffer, const int at, const unsigned int bit_end,",
          "3217:   const unsigned int bit_begin, const unsigned int bit_word,",
          "3218:   const TranslationTableHeader *table, int srcmax, const widechar *currentInput) {",
          "3219:  if (buffer[at] & bit_begin) {",
          "3221:   for (i = at + 1; i < srcmax; i++)",
          "3222:    if (buffer[i] & bit_end)",
          "3223:     break;",
          "3224:    else",
          "3225:     cnt++;",
          "3227:  } else if (buffer[at] & bit_word) {",
          "3229:   for (i = at + 1; i < srcmax; i++)",
          "3230:    if (buffer[i] & bit_end) break;",
          "3232:    else if (checkAttr(currentInput[i], CTC_SeqDelimiter | CTC_Space, 0, table))",
          "3233:     break;",
          "3234:    else",
          "3235:     cnt++;",
          "3242: insertEmphasesAt(const int at, const TranslationTableHeader *table, int *src, int *dest,",
          "3243:   int srcmax, int destmax, int mode, const widechar *currentInput,",
          "3244:   widechar *currentOutput, int *srcMapping, int *prevSrcMapping,",
          "3245:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer, int haveEmphasis,",
          "3246:   int transOpcode, const TranslationTableRule **transRule, int *inputPositions,",
          "3247:   int *outputPositions, int *cursorPosition, int *cursorStatus, int compbrlStart,",
          "3248:   int compbrlEnd) {",
          "3253:  if (!haveEmphasis) {",
          "3255:   if (transOpcode == CTO_Contraction) {",
          "3257:    if (brailleIndicatorDefined(table->noContractSign, table, &indicRule))",
          "3258:     for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,",
          "3259:       table, src, dest, srcmax, destmax, mode, currentInput,",
          "3260:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3261:       transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3262:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3265:   if (emphasisBuffer[at] & CAPS_EMPHASIS) {",
          "3266:    insertEmphasisEnd(emphasisBuffer, at, capsRule, CAPS_END, CAPS_WORD, table,",
          "3267:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3268:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3269:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3270:      cursorStatus, compbrlStart, compbrlEnd);",
          "3271:    insertEmphasisBegin(emphasisBuffer, at, capsRule, CAPS_BEGIN, CAPS_END,",
          "3272:      CAPS_WORD, table, src, dest, srcmax, destmax, mode, currentInput,",
          "3273:      currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3274:      transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3275:      cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3276:    insertEmphasisSymbol(emphasisBuffer, at, capsRule, CAPS_SYMBOL, table, src,",
          "3277:      dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping,",
          "3278:      prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule,",
          "3279:      inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "3280:      compbrlStart, compbrlEnd);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3973:  for (i = 0; i < 10; i++)",
          "3974:   if (i < 5)",
          "3978:   else",
          "3985:   min = -1;",
          "3992:   type_counts[min] = 0;",
          "3993:   if (min < 5)",
          "3997:   else",
          "4001:  }",
          "4004:  for (i = 0; i < 10; i++)",
          "4005:   if (i < 5)",
          "4007:   else",
          "4012:   max = 9;",
          "4018:   type_counts[max] = 0;",
          "4019:   if (max >= 5)",
          "4023:   else",
          "4027:  }",
          "4042:   const TranslationTableRule *indicRule;",
          "4046:  }",
          "4054:  }",
          "4056: }",
          "4058: static void",
          "4077:  int at;",
          "4083: }",
          "4085: static void",
          "4103:  int i;",
          "4104:  const TranslationTableRule *indicRule;",
          "4127:      break;",
          "4130:      break;",
          "4131:    }",
          "4132:   }",
          "4133:  }",
          "4145:   }",
          "4146:  }",
          "4147: }",
          "4149: static int",
          "4211:  pre_src = 0;",
          "4234:    widechar c = _lou_getDotsForChar(currentInput[src]);",
          "4238:     goto failure;",
          "4239:    src++;",
          "4241:    pre_src = src;",
          "4242:    continue;",
          "4243:   }",
          "4270:   if (table->usesNumericMode)",
          "4293:    dontContract = 0;",
          "4494:  transOpcode = CTO_Space;",
          "4497: failure:",
          "4514: int EXPORT_CALL",
          "4518: #define HYPHSTRING 100",
          "4584:  }",
          "4588:  }",
          "4596: }",
          "4598: int EXPORT_CALL",
          "4619: }",
          "4621: int EXPORT_CALL",
          "4639: }",
          "",
          "[Removed Lines]",
          "3969:  if(emphasisBuffer[at] & CAPS_EMPHASIS)",
          "3970:   insertEmphasisEnd(emphasisBuffer, at, capsRule, CAPS_END, CAPS_WORD, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3975:    type_counts[i]",
          "3976:     = endCount(emphasisBuffer, at,",
          "3977:      EMPHASIS_END << (i * 4), EMPHASIS_BEGIN << (i * 4), EMPHASIS_WORD << (i * 4));",
          "3979:    type_counts[i]",
          "3980:     = endCount(transNoteBuffer, at,",
          "3981:      TRANSNOTE_END << ((i - 5) * 4), TRANSNOTE_BEGIN << ((i - 5) * 4), TRANSNOTE_WORD << ((i - 5) * 4));",
          "3983:  for(i = 0; i < 10; i++)",
          "3984:  {",
          "3986:   for(j = 0; j < 10; j++)",
          "3987:   if(type_counts[j] > 0)",
          "3988:   if(min < 0 || type_counts[j] < type_counts[min])",
          "3989:    min = j;",
          "3990:   if(min < 0)",
          "3991:    break;",
          "3994:    insertEmphasisEnd(",
          "3995:     emphasisBuffer, at, emph1Rule + min,",
          "3996:      EMPHASIS_END << (min * 4), EMPHASIS_WORD << (min * 4), table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3998:    insertEmphasisEnd(",
          "3999:     transNoteBuffer, at, emph1Rule + min,",
          "4000:      TRANSNOTE_END << ((min - 5) * 4), TRANSNOTE_WORD << ((min - 5) * 4), table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4006:    type_counts[i] = beginCount(emphasisBuffer, at, EMPHASIS_END << (i * 4), EMPHASIS_BEGIN << (i * 4), EMPHASIS_WORD << (i * 4), table, srcmax, currentInput);",
          "4008:    type_counts[i] = beginCount(transNoteBuffer, at, TRANSNOTE_END << ((i - 5) * 4), TRANSNOTE_BEGIN << ((i - 5) * 4), TRANSNOTE_WORD << ((i - 5) * 4), table, srcmax, currentInput);",
          "4010:  for(i = 9; i >= 0; i--)",
          "4011:  {",
          "4013:   for(j = 9; j >= 0; j--)",
          "4014:   if(type_counts[max] < type_counts[j])",
          "4015:    max = j;",
          "4016:   if(!type_counts[max])",
          "4017:    break;",
          "4020:    insertEmphasisBegin(",
          "4021:     transNoteBuffer, at, emph1Rule + max,",
          "4022:      TRANSNOTE_BEGIN << ((max - 5) * 4), TRANSNOTE_END << ((max - 5) * 4), TRANSNOTE_WORD << ((max - 5) * 4), table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4024:    insertEmphasisBegin(",
          "4025:     emphasisBuffer, at, emph1Rule + max,",
          "4026:      EMPHASIS_BEGIN << (max * 4), EMPHASIS_END << (max * 4), EMPHASIS_WORD << (max * 4), table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4030:  for(i = 4; i >= 0; i--)",
          "4031:   if(transNoteBuffer[at] & (TRANSNOTE_MASK << (i * 4)))",
          "4032:    insertEmphasisSymbol(",
          "4033:     transNoteBuffer, at, emph6Rule + i, TRANSNOTE_SYMBOL << (i * 4), table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4034:  for(i = 4; i >= 0; i--)",
          "4035:   if(emphasisBuffer[at] & (EMPHASIS_MASK << (i * 4)))",
          "4036:    insertEmphasisSymbol(",
          "4037:     emphasisBuffer, at, emph1Rule + i, EMPHASIS_SYMBOL << (i * 4), table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4040:  if(transOpcode == CTO_Contraction)",
          "4041:  {",
          "4043:   if(brailleIndicatorDefined(table->noContractSign, table, &indicRule))",
          "4044:    for_updatePositions(",
          "4045:     &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4049:  if(emphasisBuffer[at] & CAPS_EMPHASIS)",
          "4050:  {",
          "4051:   insertEmphasisBegin(emphasisBuffer, at, capsRule, CAPS_BEGIN, CAPS_END, CAPS_WORD, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4052:   insertEmphasisSymbol(",
          "4053:    emphasisBuffer, at, capsRule, CAPS_SYMBOL, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4059: insertEmphases(const TranslationTableHeader *table,",
          "4060:         int *src, int *dest,",
          "4061:         int srcmax, int destmax,",
          "4062:         int mode,",
          "4063:         const widechar *currentInput,",
          "4064:         widechar *currentOutput,",
          "4065:         int *srcMapping,",
          "4066:         int *prevSrcMapping,",
          "4067:         unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "4068:         int haveEmphasis,",
          "4069:         int transOpcode,",
          "4070:         const TranslationTableRule **transRule,",
          "4071:         int *inputPositions,",
          "4072:         int *outputPositions,",
          "4073:         int *cursorPosition, int *cursorStatus,",
          "4074:         int *pre_src,",
          "4075:         int compbrlStart, int compbrlEnd)",
          "4076: {",
          "4079:  for(at = *pre_src; at <= *src; at++)",
          "4080:   insertEmphasesAt(at, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, haveEmphasis, transOpcode, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4086: checkNumericMode(const TranslationTableHeader *table,",
          "4087:    int *src, int *dest,",
          "4088:    int srcmax, int destmax,",
          "4089:    int mode,",
          "4090:    const widechar *currentInput,",
          "4091:    widechar *currentOutput,",
          "4092:    int *srcMapping,",
          "4093:    int *prevSrcMapping,",
          "4094:    unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "4095:    const TranslationTableRule **transRule,",
          "4096:    int *inputPositions,",
          "4097:    int *outputPositions,",
          "4098:    int *cursorPosition, int *cursorStatus,",
          "4099:    int *dontContract,",
          "4100:    int compbrlStart, int compbrlEnd,",
          "4101:    int *numericMode)",
          "4102: {",
          "4105:  if(!brailleIndicatorDefined(table->numberSign, table, &indicRule))",
          "4106:   return;",
          "4109:  if(!*numericMode)",
          "4110:  {",
          "4111:   if(checkAttr(currentInput[*src], CTC_Digit | CTC_LitDigit, 0, table))",
          "4112:   {",
          "4115:    for_updatePositions(",
          "4116:     &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4117:   }",
          "4118:   else if(checkAttr(currentInput[*src], CTC_NumericMode, 0, table))",
          "4119:   {",
          "4120:    for(i = *src + 1; i < srcmax; i++)",
          "4121:    {",
          "4122:     if(checkAttr(currentInput[i], CTC_Digit | CTC_LitDigit, 0, table))",
          "4123:     {",
          "4125:      for_updatePositions(",
          "4126:       &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4128:     }",
          "4129:     else if(!checkAttr(currentInput[i], CTC_NumericMode, 0, table))",
          "4136:  else",
          "4137:  {",
          "4138:   if(!checkAttr(currentInput[*src], CTC_Digit | CTC_LitDigit | CTC_NumericMode, 0, table))",
          "4139:   {",
          "4141:    if(brailleIndicatorDefined(table->noContractSign, table, &indicRule))",
          "4142:    if(checkAttr(currentInput[*src], CTC_NumericNoContract, 0, table))",
          "4143:      for_updatePositions(",
          "4144:       &indicRule->charsdots[0], 0, indicRule->dotslen, 0, table, src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4150: translateString (const TranslationTableHeader *table,",
          "4151:    int *dest, int *srcmax,",
          "4152:    int destmax,",
          "4153:    int mode,",
          "4154:    int currentPass,",
          "4155:    const widechar *currentInput,",
          "4156:    widechar *currentOutput,",
          "4157:    int *srcMapping,",
          "4158:    int *prevSrcMapping,",
          "4159:    formtype *typebuf,",
          "4160:    unsigned char *srcSpacing,",
          "4161:    unsigned char *destSpacing,",
          "4162:    unsigned int *wordBuffer,",
          "4163:    unsigned int *emphasisBuffer, unsigned int *transNoteBuffer,",
          "4164:    int haveEmphasis,",
          "4165:    int *realInlen,",
          "4166:    int *srcIncremented,",
          "4167:    int *inputPositions,",
          "4168:    int *outputPositions,",
          "4169:    int *cursorPosition, int *cursorStatus,",
          "4170:    int compbrlStart, int compbrlEnd)",
          "4171: {",
          "4172:   int src;",
          "4173:   int transOpcode;",
          "4174:   int prevTransOpcode;",
          "4175:   const TranslationTableRule *transRule;",
          "4176:   int transCharslen;",
          "4177:   int passCharDots;",
          "4178:   int passSrc;",
          "4179:   const widechar *passInstructions;",
          "4181:   int startMatch;",
          "4182:   int startReplace;",
          "4183:   int endReplace;",
          "4184:   TranslationTableRule *groupingRule;",
          "4185:   widechar groupingOp;",
          "4186:   int numericMode;",
          "4187:   int dontContract;",
          "4188:   int destword;",
          "4189:   int srcword;",
          "4190:   int pre_src;",
          "4191:   TranslationTableCharacter *curCharDef;",
          "4192:   const widechar *repwordStart;",
          "4193:   int repwordLength;",
          "4194:   int curType;",
          "4195:   int prevType;",
          "4196:   int prevTypeform;",
          "4197:   int prevSrc;",
          "4199:   int k;",
          "4200:   translation_direction = 1;",
          "4201:   markSyllables (table, *srcmax, currentInput, typebuf, &transOpcode, &transRule, &transCharslen);",
          "4202:   numericMode = 0;",
          "4203:   srcword = 0;",
          "4205:   dontContract = 0;",
          "4206:   prevTransOpcode = CTO_None;",
          "4207:   prevType = curType = prevTypeform = plain_text;",
          "4208:   prevSrc = -1;",
          "4209:   src = *dest = 0;",
          "4212:   _lou_resetPassVariables();",
          "4213:   if (typebuf && table->emphRules[capsRule][letterOffset])",
          "4214:     for (k = 0; k < *srcmax; k++)",
          "4215:       if (checkAttr (currentInput[k], CTC_UpperCase, 0, table))",
          "4216:         typebuf[k] |= CAPSEMPH;",
          "4218:  markEmphases(table, *srcmax, currentInput, typebuf, wordBuffer, emphasisBuffer, transNoteBuffer, haveEmphasis, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4220:   while (src < *srcmax)",
          "4222:       TranslationTableCharacterAttributes beforeAttributes;",
          "4223:       setBefore (table, src, currentInput, &beforeAttributes);",
          "4224:       if (!insertBrailleIndicators (0, table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf, haveEmphasis, emphasisBuffer, transNoteBuffer, transOpcode, prevTransOpcode, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd, beforeAttributes, &prevType, &curType, &prevTypeform, prevSrc))",
          "4225:         goto failure;",
          "4226:       if (src >= *srcmax)",
          "4227:         break;",
          "4230:   if(!dontContract)",
          "4231:    dontContract = typebuf[src] & no_contract;",
          "4232:   if(typebuf[src] & no_translate)",
          "4233:   {",
          "4235:    if(currentInput[src] < 32 || currentInput[src] > 126)",
          "4236:     goto failure;",
          "4237:    if(!for_updatePositions(&c, 1, 1, 0, table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "4244:   for_selectRule (table, src, *dest, *srcmax, destmax, mode, currentInput, typebuf, emphasisBuffer, transNoteBuffer, &transOpcode, prevTransOpcode, &transRule, &transCharslen, &passCharDots, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace, *srcIncremented, *cursorPosition, &repwordStart, &repwordLength, dontContract, compbrlStart, compbrlEnd, beforeAttributes, &curCharDef, &groupingRule, &groupingOp);",
          "4246:       if (transOpcode != CTO_Context)",
          "4247:  if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "4248:    appliedRules[appliedRulesCount++] = transRule;",
          "4250:       prevSrc = src;",
          "4252:         {",
          "4253:         case CTO_CompBrl:",
          "4254:         case CTO_Literal:",
          "4255:           if (!doCompbrl (table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, destword, srcword, compbrlStart, compbrlEnd))",
          "4256:             goto failure;",
          "4257:           continue;",
          "4258:         default:",
          "4259:           break;",
          "4260:         }",
          "4261:       if (!insertBrailleIndicators (1, table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf, haveEmphasis, emphasisBuffer, transNoteBuffer, transOpcode, prevTransOpcode, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd, beforeAttributes, &prevType, &curType, &prevTypeform, prevSrc))",
          "4262:         goto failure;",
          "4269:   insertEmphases(table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, haveEmphasis, transOpcode, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, &pre_src, compbrlStart, compbrlEnd);",
          "4271:    checkNumericMode(table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, &dontContract, compbrlStart, compbrlEnd, &numericMode);",
          "4273:       if (transOpcode == CTO_Context || findForPassRule (table, src, *srcmax, currentPass, currentInput, &transOpcode, &transRule, &transCharslen, &passCharDots, &passSrc, &passInstructions, &passIC, &startMatch, &startReplace, &endReplace, &groupingRule, &groupingOp))",
          "4274:         switch (transOpcode)",
          "4275:           {",
          "4276:           case CTO_Context:",
          "4277:             if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "4278:               appliedRules[appliedRulesCount++] = transRule;",
          "4279:             if (!passDoAction (table, &src, dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transOpcode, &transRule, passCharDots, passSrc, passInstructions, startMatch, startReplace, &passIC, &endReplace, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd, groupingRule, groupingOp))",
          "4280:               goto failure;",
          "4281:             if (endReplace == src)",
          "4283:             src = endReplace;",
          "4284:             continue;",
          "4285:           default:",
          "4286:             break;",
          "4287:           }",
          "4292:   if(checkAttr(currentInput[src], CTC_SeqDelimiter | CTC_Space, 0, table))",
          "4295:       switch (transOpcode)",
          "4296:         {",
          "4297:         case CTO_EndNum:",
          "4298:           if (table->letterSign && checkAttr (currentInput[src],",
          "4299:                   CTC_Letter, 0, table))",
          "4300:             (*dest)--;",
          "4301:           break;",
          "4302:         case CTO_Repeated:",
          "4303:         case CTO_Space:",
          "4304:           dontContract = 0;",
          "4305:           break;",
          "4306:         case CTO_LargeSign:",
          "4307:           if (prevTransOpcode == CTO_LargeSign)",
          "4308:           {",
          "4309:             int hasEndSegment = 0;",
          "4310:             while (*dest > 0 && checkAttr (currentOutput[*dest - 1], CTC_Space, 1, table))",
          "4311:             {",
          "4312:               if (currentOutput[*dest - 1] == ENDSEGMENT)",
          "4313:               {",
          "4314:                 hasEndSegment = 1;",
          "4315:               }",
          "4316:               (*dest)--;",
          "4317:             }",
          "4318:             if (hasEndSegment != 0)",
          "4319:             {",
          "4320:               currentOutput[*dest] = 0xffff;",
          "4321:               (*dest)++;",
          "4322:             }",
          "4323:           }",
          "4324:           break;",
          "4325:         case CTO_DecPoint:",
          "4326:           if (!table->usesNumericMode && table->numberSign)",
          "4327:             {",
          "4328:               TranslationTableRule *numRule = (TranslationTableRule *)",
          "4329:          &table->ruleArea[table->numberSign];",
          "4330:               if (!for_updatePositions",
          "4331:            (&numRule->charsdots[numRule->charslen],",
          "4332:             numRule->charslen, numRule->dotslen, 0, table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "4333:          goto failure;",
          "4334:             }",
          "4335:           transOpcode = CTO_MidNum;",
          "4336:           break;",
          "4337:         case CTO_NoCont:",
          "4338:           if (!dontContract)",
          "4339:             doNocont (table, &src, dest, mode, currentInput, destword, srcword, &dontContract);",
          "4340:           continue;",
          "4341:         default:",
          "4342:           break;",
          "4346:       switch (transOpcode)",
          "4347:         {",
          "4348:         case CTO_Replace:",
          "4349:           src += transCharslen;",
          "4350:           if (!putCharacters",
          "4351:               (&transRule->charsdots[transCharslen], transRule->dotslen, table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "4352:             goto failure;",
          "4353:           break;",
          "4354:         case CTO_None:",
          "4355:           if (!undefinedCharacter (currentInput[src], table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "4356:             goto failure;",
          "4357:           src++;",
          "4358:           break;",
          "4359:         case CTO_UpperCase:",
          "4362:           if (!",
          "4363:               (mode & (compbrlAtCursor | compbrlLeftCursor) && src >=",
          "4364:                compbrlStart",
          "4365:                && src <= compbrlEnd) && (transRule->dotslen == 1",
          "4366:              && table->emphRules[capsRule][letterOffset]))",
          "4367:             {",
          "4368:               putCharacter (curCharDef->lowercase, table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "4369:               src++;",
          "4370:               break;",
          "4371:             }",
          "4379:         default:",
          "4380:           if (*cursorStatus == 2)",
          "4382:           else",
          "4383:             {",
          "4384:               if (transRule->dotslen)",
          "4385:          {",
          "4386:            if (!for_updatePositions",
          "4387:                (&transRule->charsdots[transCharslen],",
          "4388:                 transCharslen, transRule->dotslen, 0, table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "4389:              goto failure;",
          "4390:          }",
          "4391:               else",
          "4392:          {",
          "4393:            for (k = 0; k < transCharslen; k++)",
          "4394:              {",
          "4395:                if (!putCharacter (currentInput[src], table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "4396:           goto failure;",
          "4397:                src++;",
          "4398:              }",
          "4399:          }",
          "4400:               if (*cursorStatus == 2)",
          "4402:               else if (transRule->dotslen)",
          "4403:          src += transCharslen;",
          "4404:             }",
          "4405:           break;",
          "4406:         }",
          "4409:       switch (transOpcode)",
          "4410:         {",
          "4411:         case CTO_Repeated:",
          "4412:           {",
          "4414:             int srclim = *srcmax - transCharslen;",
          "4415:             if (mode & (compbrlAtCursor | compbrlLeftCursor) &&",
          "4416:          compbrlStart < srclim)",
          "4418:               srclim = compbrlStart - 1;",
          "4419:             while ((src <= srclim)",
          "4420:             && compareChars (&transRule->charsdots[0],",
          "4421:                &currentInput[src], transCharslen, 0, table))",
          "4422:               {",
          "4424:          if (outputPositions != NULL)",
          "4425:            {",
          "4426:              int tcc;",
          "4427:              for (tcc = 0; tcc < transCharslen; tcc++)",
          "4428:                outputPositions[prevSrcMapping[src + tcc]] = *dest - 1;",
          "4429:            }",
          "4430:          if (!*cursorStatus && src <= *cursorPosition",
          "4431:              && *cursorPosition < src + transCharslen)",
          "4432:            {",
          "4435:            }",
          "4436:          src += transCharslen;",
          "4437:               }",
          "4438:             break;",
          "4439:           }",
          "4440:         case CTO_RepWord:",
          "4441:           {",
          "4443:             int srclim = *srcmax - transCharslen;",
          "4444:             if (mode & (compbrlAtCursor | compbrlLeftCursor) &&",
          "4445:          compbrlStart < srclim)",
          "4447:               srclim = compbrlStart - 1;",
          "4448:             while ((src <= srclim)",
          "4449:             && compareChars (repwordStart,",
          "4450:                &currentInput[src], repwordLength, 0, table))",
          "4451:               {",
          "4453:          if (outputPositions != NULL)",
          "4454:            {",
          "4455:              int tcc;",
          "4456:              for (tcc = 0; tcc < transCharslen; tcc++)",
          "4457:                outputPositions[prevSrcMapping[src + tcc]] = *dest - 1;",
          "4458:            }",
          "4459:          if (!*cursorStatus && src <= *cursorPosition",
          "4460:              && *cursorPosition < src + transCharslen)",
          "4461:            {",
          "4464:            }",
          "4465:          src += repwordLength + transCharslen;",
          "4466:               }",
          "4467:             src -= transCharslen;",
          "4468:             break;",
          "4469:           }",
          "4470:         case CTO_JoinNum:",
          "4471:         case CTO_JoinableWord:",
          "4472:           while (src < *srcmax",
          "4473:           && checkAttr (currentInput[src], CTC_Space, 0, table) &&",
          "4474:           currentInput[src] != ENDSEGMENT)",
          "4475:             src++;",
          "4476:           break;",
          "4477:         default:",
          "4478:           break;",
          "4479:         }",
          "4480:       if (((src > 0) && checkAttr (currentInput[src - 1], CTC_Space, 0, table)",
          "4481:            && (transOpcode != CTO_JoinableWord)))",
          "4482:         {",
          "4483:           srcword = src;",
          "4484:           destword = *dest;",
          "4485:         }",
          "4486:       if (srcSpacing != NULL && srcSpacing[src] >= '0' && srcSpacing[src] <=",
          "4487:           '9')",
          "4488:         destSpacing[*dest] = srcSpacing[src];",
          "4489:       if ((transOpcode >= CTO_Always && transOpcode <= CTO_None) ||",
          "4490:           (transOpcode >= CTO_Digit && transOpcode <= CTO_LitDigit))",
          "4491:         prevTransOpcode = transOpcode;",
          "4492:     }",
          "4495:  insertEmphases(table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput, srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, haveEmphasis, transOpcode, &transRule, inputPositions, outputPositions, cursorPosition, cursorStatus, &pre_src, compbrlStart, compbrlEnd);",
          "4498:   if (destword != 0 && src < *srcmax",
          "4499:       && !checkAttr (currentInput[src], CTC_Space, 0, table))",
          "4500:     {",
          "4501:       src = srcword;",
          "4503:     }",
          "4504:   if (src < *srcmax)",
          "4505:     {",
          "4506:       while (checkAttr (currentInput[src], CTC_Space, 0, table))",
          "4507:         if (++src == *srcmax)",
          "4508:           break;",
          "4509:     }",
          "4511:   return 1;",
          "4515: lou_hyphenate (const char *tableList, const widechar",
          "4517: {",
          "4519:   const TranslationTableHeader *table;",
          "4520:   widechar workingBuffer[HYPHSTRING];",
          "4521:   int k, kk;",
          "4522:   int wordStart;",
          "4523:   int wordEnd;",
          "4524:   table = lou_getTable (tableList);",
          "4525:   if (table == NULL || inbuf == NULL || hyphens",
          "4526:       == NULL || table->hyphenStatesArray == 0 || inlen >= HYPHSTRING)",
          "4527:     return 0;",
          "4528:   if (mode != 0)",
          "4529:     {",
          "4530:       k = inlen;",
          "4531:       kk = HYPHSTRING;",
          "4532:       if (!lou_backTranslate (tableList, inbuf, &k,",
          "4533:          &workingBuffer[0],",
          "4534:          &kk, NULL, NULL, NULL, NULL, NULL, 0))",
          "4535:  return 0;",
          "4536:     }",
          "4537:   else",
          "4538:     {",
          "4539:       memcpy (&workingBuffer[0], inbuf, CHARSIZE * inlen);",
          "4540:       kk = inlen;",
          "4541:     }",
          "4542:   for (wordStart = 0; wordStart < kk; wordStart++)",
          "4543:     if (((findCharOrDots (workingBuffer[wordStart], 0, table))->attributes &",
          "4544:   CTC_Letter))",
          "4545:       break;",
          "4546:   if (wordStart == kk)",
          "4547:     return 0;",
          "4548:   for (wordEnd = kk - 1; wordEnd >= 0; wordEnd--)",
          "4549:     if (((findCharOrDots (workingBuffer[wordEnd], 0, table))->attributes &",
          "4550:   CTC_Letter))",
          "4551:       break;",
          "4552:   for (k = wordStart; k <= wordEnd; k++)",
          "4553:     {",
          "4554:       TranslationTableCharacter *c = findCharOrDots (workingBuffer[k], 0, table);",
          "4555:       if (!(c->attributes & CTC_Letter))",
          "4556:  return 0;",
          "4557:     }",
          "4558:   if (!hyphenate",
          "4559:       (&workingBuffer[wordStart], wordEnd - wordStart + 1,",
          "4560:        &hyphens[wordStart], table))",
          "4561:     return 0;",
          "4562:   for (k = 0; k <= wordStart; k++)",
          "4563:     hyphens[k] = '0';",
          "4564:   if (mode != 0)",
          "4565:     {",
          "4566:       widechar workingBuffer2[HYPHSTRING];",
          "4567:       int outputPos[HYPHSTRING];",
          "4568:       char hyphens2[HYPHSTRING];",
          "4569:       kk = wordEnd - wordStart + 1;",
          "4570:       k = HYPHSTRING;",
          "4571:       if (!lou_translate (tableList, &workingBuffer[wordStart], &kk,",
          "4572:      &workingBuffer2[0], &k, NULL,",
          "4573:      NULL, &outputPos[0], NULL, NULL, 0))",
          "4574:  return 0;",
          "4575:       for (kk = 0; kk < k; kk++)",
          "4576:  {",
          "4577:    int hyphPos = outputPos[kk];",
          "4578:    if (hyphPos > k || hyphPos < 0)",
          "4579:      break;",
          "4580:    if (hyphens[wordStart + kk] & 1)",
          "4581:      hyphens2[hyphPos] = '1';",
          "4582:    else",
          "4583:      hyphens2[hyphPos] = '0';",
          "4585:       for (kk = wordStart; kk < wordStart + k; kk++)",
          "4586:  if (hyphens2[kk] == '0')",
          "4587:    hyphens[kk] = hyphens2[kk];",
          "4589:   for (k = 0; k < inlen; k++)",
          "4590:     if (hyphens[k] & 1)",
          "4591:       hyphens[k] = '1';",
          "4592:     else",
          "4593:       hyphens[k] = '0';",
          "4594:   hyphens[inlen] = 0;",
          "4595:   return 1;",
          "4599: lou_dotsToChar (const char *tableList, widechar * inbuf, widechar * outbuf,",
          "4600:   int length, int mode)",
          "4601: {",
          "4602:   const TranslationTableHeader *table;",
          "4603:   int k;",
          "4604:   widechar dots;",
          "4605:   if (tableList == NULL || inbuf == NULL || outbuf == NULL)",
          "4606:     return 0;",
          "4608:   table = lou_getTable (tableList);",
          "4609:   if (table == NULL || length <= 0)",
          "4610:     return 0;",
          "4611:   for (k = 0; k < length; k++)",
          "4612:     {",
          "4613:       dots = inbuf[k];",
          "4615:  dots = (dots & 0x00ff) | B16;",
          "4616:       outbuf[k] = _lou_getCharFromDots (dots);",
          "4617:     }",
          "4618:   return 1;",
          "4622: lou_charToDots (const char *tableList, const widechar * inbuf, widechar *",
          "4623:   outbuf, int length, int mode)",
          "4624: {",
          "4625:   const TranslationTableHeader *table;",
          "4626:   int k;",
          "4627:   if (tableList == NULL || inbuf == NULL || outbuf == NULL)",
          "4628:     return 0;",
          "4630:   table = lou_getTable (tableList);",
          "4631:   if (table == NULL || length <= 0)",
          "4632:     return 0;",
          "4633:   for (k = 0; k < length; k++)",
          "4634:     if ((mode & ucBrl))",
          "4635:       outbuf[k] = ((_lou_getDotsForChar (inbuf[k]) & 0xff) | 0x2800);",
          "4636:     else",
          "4637:       outbuf[k] = _lou_getDotsForChar (inbuf[k]);",
          "4638:   return 1;",
          "",
          "[Added Lines]",
          "3291:  if (emphasisBuffer[at] & CAPS_EMPHASIS)",
          "3292:   insertEmphasisEnd(emphasisBuffer, at, capsRule, CAPS_END, CAPS_WORD, table, src,",
          "3293:     dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping,",
          "3294:     prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule,",
          "3295:     inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "3296:     compbrlStart, compbrlEnd);",
          "3301:    type_counts[i] = endCount(emphasisBuffer, at, EMPHASIS_END << (i * 4),",
          "3302:      EMPHASIS_BEGIN << (i * 4), EMPHASIS_WORD << (i * 4));",
          "3304:    type_counts[i] = endCount(transNoteBuffer, at, TRANSNOTE_END << ((i - 5) * 4),",
          "3305:      TRANSNOTE_BEGIN << ((i - 5) * 4), TRANSNOTE_WORD << ((i - 5) * 4));",
          "3307:  for (i = 0; i < 10; i++) {",
          "3309:   for (j = 0; j < 10; j++)",
          "3310:    if (type_counts[j] > 0)",
          "3311:     if (min < 0 || type_counts[j] < type_counts[min]) min = j;",
          "3312:   if (min < 0) break;",
          "3315:    insertEmphasisEnd(emphasisBuffer, at, emph1Rule + min,",
          "3316:      EMPHASIS_END << (min * 4), EMPHASIS_WORD << (min * 4), table, src,",
          "3317:      dest, srcmax, destmax, mode, currentInput, currentOutput, srcMapping,",
          "3318:      prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule,",
          "3319:      inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "3320:      compbrlStart, compbrlEnd);",
          "3322:    insertEmphasisEnd(transNoteBuffer, at, emph1Rule + min,",
          "3323:      TRANSNOTE_END << ((min - 5) * 4), TRANSNOTE_WORD << ((min - 5) * 4),",
          "3324:      table, src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3325:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3326:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3327:      cursorStatus, compbrlStart, compbrlEnd);",
          "3333:    type_counts[i] = beginCount(emphasisBuffer, at, EMPHASIS_END << (i * 4),",
          "3334:      EMPHASIS_BEGIN << (i * 4), EMPHASIS_WORD << (i * 4), table, srcmax,",
          "3335:      currentInput);",
          "3337:    type_counts[i] = beginCount(transNoteBuffer, at,",
          "3338:      TRANSNOTE_END << ((i - 5) * 4), TRANSNOTE_BEGIN << ((i - 5) * 4),",
          "3339:      TRANSNOTE_WORD << ((i - 5) * 4), table, srcmax, currentInput);",
          "3341:  for (i = 9; i >= 0; i--) {",
          "3343:   for (j = 9; j >= 0; j--)",
          "3344:    if (type_counts[max] < type_counts[j]) max = j;",
          "3345:   if (!type_counts[max]) break;",
          "3348:    insertEmphasisBegin(transNoteBuffer, at, emph1Rule + max,",
          "3349:      TRANSNOTE_BEGIN << ((max - 5) * 4), TRANSNOTE_END << ((max - 5) * 4),",
          "3350:      TRANSNOTE_WORD << ((max - 5) * 4), table, src, dest, srcmax, destmax,",
          "3351:      mode, currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "3352:      emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "3353:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "3354:      compbrlEnd);",
          "3356:    insertEmphasisBegin(emphasisBuffer, at, emph1Rule + max,",
          "3357:      EMPHASIS_BEGIN << (max * 4), EMPHASIS_END << (max * 4),",
          "3358:      EMPHASIS_WORD << (max * 4), table, src, dest, srcmax, destmax, mode,",
          "3359:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "3360:      emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "3361:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "3362:      compbrlEnd);",
          "3366:  for (i = 4; i >= 0; i--)",
          "3367:   if (transNoteBuffer[at] & (TRANSNOTE_MASK << (i * 4)))",
          "3368:    insertEmphasisSymbol(transNoteBuffer, at, emph6Rule + i,",
          "3369:      TRANSNOTE_SYMBOL << (i * 4), table, src, dest, srcmax, destmax, mode,",
          "3370:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "3371:      emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "3372:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "3373:      compbrlEnd);",
          "3374:  for (i = 4; i >= 0; i--)",
          "3375:   if (emphasisBuffer[at] & (EMPHASIS_MASK << (i * 4)))",
          "3376:    insertEmphasisSymbol(emphasisBuffer, at, emph1Rule + i,",
          "3377:      EMPHASIS_SYMBOL << (i * 4), table, src, dest, srcmax, destmax, mode,",
          "3378:      currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "3379:      emphasisBuffer, transNoteBuffer, transRule, inputPositions,",
          "3380:      outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "3381:      compbrlEnd);",
          "3384:  if (transOpcode == CTO_Contraction) {",
          "3386:   if (brailleIndicatorDefined(table->noContractSign, table, &indicRule))",
          "3387:    for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table,",
          "3388:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3389:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3390:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3391:      cursorStatus, compbrlStart, compbrlEnd);",
          "3395:  if (emphasisBuffer[at] & CAPS_EMPHASIS) {",
          "3396:   insertEmphasisBegin(emphasisBuffer, at, capsRule, CAPS_BEGIN, CAPS_END, CAPS_WORD,",
          "3397:     table, src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3398:     srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule,",
          "3399:     inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "3400:     compbrlStart, compbrlEnd);",
          "3401:   insertEmphasisSymbol(emphasisBuffer, at, capsRule, CAPS_SYMBOL, table, src, dest,",
          "3402:     srcmax, destmax, mode, currentInput, currentOutput, srcMapping,",
          "3403:     prevSrcMapping, emphasisBuffer, transNoteBuffer, transRule,",
          "3404:     inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "3405:     compbrlStart, compbrlEnd);",
          "3410: insertEmphases(const TranslationTableHeader *table, int *src, int *dest, int srcmax,",
          "3411:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "3412:   int *srcMapping, int *prevSrcMapping, unsigned int *emphasisBuffer,",
          "3413:   unsigned int *transNoteBuffer, int haveEmphasis, int transOpcode,",
          "3414:   const TranslationTableRule **transRule, int *inputPositions, int *outputPositions,",
          "3415:   int *cursorPosition, int *cursorStatus, int *pre_src, int compbrlStart,",
          "3416:   int compbrlEnd) {",
          "3419:  for (at = *pre_src; at <= *src; at++)",
          "3420:   insertEmphasesAt(at, table, src, dest, srcmax, destmax, mode, currentInput,",
          "3421:     currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3422:     transNoteBuffer, haveEmphasis, transOpcode, transRule, inputPositions,",
          "3423:     outputPositions, cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3429: checkNumericMode(const TranslationTableHeader *table, int *src, int *dest, int srcmax,",
          "3430:   int destmax, int mode, const widechar *currentInput, widechar *currentOutput,",
          "3431:   int *srcMapping, int *prevSrcMapping, unsigned int *emphasisBuffer,",
          "3432:   unsigned int *transNoteBuffer, const TranslationTableRule **transRule,",
          "3433:   int *inputPositions, int *outputPositions, int *cursorPosition, int *cursorStatus,",
          "3434:   int *dontContract, int compbrlStart, int compbrlEnd, int *numericMode) {",
          "3437:  if (!brailleIndicatorDefined(table->numberSign, table, &indicRule)) return;",
          "3440:  if (!*numericMode) {",
          "3441:   if (checkAttr(currentInput[*src], CTC_Digit | CTC_LitDigit, 0, table)) {",
          "3444:    for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, table,",
          "3445:      src, dest, srcmax, destmax, mode, currentInput, currentOutput,",
          "3446:      srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3447:      transRule, inputPositions, outputPositions, cursorPosition,",
          "3448:      cursorStatus, compbrlStart, compbrlEnd);",
          "3449:   } else if (checkAttr(currentInput[*src], CTC_NumericMode, 0, table)) {",
          "3450:    for (i = *src + 1; i < srcmax; i++) {",
          "3451:     if (checkAttr(currentInput[i], CTC_Digit | CTC_LitDigit, 0, table)) {",
          "3453:      for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,",
          "3454:        0, table, src, dest, srcmax, destmax, mode, currentInput,",
          "3455:        currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3456:        transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3457:        cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3459:     } else if (!checkAttr(currentInput[i], CTC_NumericMode, 0, table))",
          "3466:  else {",
          "3467:   if (!checkAttr(currentInput[*src], CTC_Digit | CTC_LitDigit | CTC_NumericMode, 0,",
          "3468:      table)) {",
          "3470:    if (brailleIndicatorDefined(table->noContractSign, table, &indicRule))",
          "3471:     if (checkAttr(currentInput[*src], CTC_NumericNoContract, 0, table))",
          "3472:      for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,",
          "3473:        0, table, src, dest, srcmax, destmax, mode, currentInput,",
          "3474:        currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3475:        transNoteBuffer, transRule, inputPositions, outputPositions,",
          "3476:        cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3482: translateString(const TranslationTableHeader *table, int *dest, int *srcmax, int destmax,",
          "3483:   int mode, int currentPass, const widechar *currentInput, widechar *currentOutput,",
          "3484:   int *srcMapping, int *prevSrcMapping, formtype *typebuf,",
          "3485:   unsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,",
          "3486:   unsigned int *emphasisBuffer, unsigned int *transNoteBuffer, int haveEmphasis,",
          "3487:   int *realInlen, int *srcIncremented, int *inputPositions, int *outputPositions,",
          "3488:   int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {",
          "3489:  int src;",
          "3490:  int transOpcode;",
          "3491:  int prevTransOpcode;",
          "3492:  const TranslationTableRule *transRule;",
          "3493:  int transCharslen;",
          "3494:  int passCharDots;",
          "3495:  int passSrc;",
          "3496:  const widechar *passInstructions;",
          "3498:  int startMatch;",
          "3499:  int startReplace;",
          "3500:  int endReplace;",
          "3501:  TranslationTableRule *groupingRule;",
          "3502:  widechar groupingOp;",
          "3503:  int numericMode;",
          "3504:  int dontContract;",
          "3505:  int destword;",
          "3506:  int srcword;",
          "3507:  int pre_src;",
          "3508:  TranslationTableCharacter *curCharDef;",
          "3509:  const widechar *repwordStart;",
          "3510:  int repwordLength;",
          "3511:  int curType;",
          "3512:  int prevType;",
          "3513:  int prevTypeform;",
          "3514:  int prevSrc;",
          "3516:  int k;",
          "3517:  translation_direction = 1;",
          "3518:  markSyllables(table, *srcmax, currentInput, typebuf, &transOpcode, &transRule,",
          "3519:    &transCharslen);",
          "3520:  numericMode = 0;",
          "3521:  srcword = 0;",
          "3523:  dontContract = 0;",
          "3524:  prevTransOpcode = CTO_None;",
          "3525:  prevType = curType = prevTypeform = plain_text;",
          "3526:  prevSrc = -1;",
          "3527:  src = *dest = 0;",
          "3530:  _lou_resetPassVariables();",
          "3531:  if (typebuf && table->emphRules[capsRule][letterOffset])",
          "3532:   for (k = 0; k < *srcmax; k++)",
          "3533:    if (checkAttr(currentInput[k], CTC_UpperCase, 0, table))",
          "3534:     typebuf[k] |= CAPSEMPH;",
          "3536:  markEmphases(table, *srcmax, currentInput, typebuf, wordBuffer, emphasisBuffer,",
          "3537:    transNoteBuffer, haveEmphasis, inputPositions, outputPositions,",
          "3538:    cursorPosition, cursorStatus, compbrlStart, compbrlEnd);",
          "3541:   TranslationTableCharacterAttributes beforeAttributes;",
          "3542:   setBefore(table, src, currentInput, &beforeAttributes);",
          "3543:   if (!insertBrailleIndicators(0, table, &src, dest, *srcmax, destmax, mode,",
          "3544:      currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf,",
          "3545:      haveEmphasis, emphasisBuffer, transNoteBuffer, transOpcode,",
          "3546:      prevTransOpcode, &transRule, inputPositions, outputPositions,",
          "3547:      cursorPosition, cursorStatus, compbrlStart, compbrlEnd,",
          "3548:      beforeAttributes, &prevType, &curType, &prevTypeform, prevSrc))",
          "3549:    goto failure;",
          "3550:   if (src >= *srcmax) break;",
          "3553:   if (!dontContract) dontContract = typebuf[src] & no_contract;",
          "3554:   if (typebuf[src] & no_translate) {",
          "3556:    if (currentInput[src] < 32 || currentInput[src] > 126) goto failure;",
          "3557:    if (!for_updatePositions(&c, 1, 1, 0, table, &src, dest, *srcmax, destmax,",
          "3558:       mode, currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "3559:       emphasisBuffer, transNoteBuffer, &transRule, inputPositions,",
          "3560:       outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "3561:       compbrlEnd))",
          "3568:   for_selectRule(table, src, *dest, *srcmax, destmax, mode, currentInput, typebuf,",
          "3569:     emphasisBuffer, transNoteBuffer, &transOpcode, prevTransOpcode,",
          "3570:     &transRule, &transCharslen, &passCharDots, &passSrc, &passInstructions,",
          "3571:     &passIC, &startMatch, &startReplace, &endReplace, *srcIncremented,",
          "3573:     compbrlStart, compbrlEnd, beforeAttributes, &curCharDef, &groupingRule,",
          "3574:     &groupingOp);",
          "3576:   if (transOpcode != CTO_Context)",
          "3577:    if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "3578:     appliedRules[appliedRulesCount++] = transRule;",
          "3580:   prevSrc = src;",
          "3582:   {",
          "3583:   case CTO_CompBrl:",
          "3584:   case CTO_Literal:",
          "3585:    if (!doCompbrl(table, &src, dest, *srcmax, destmax, mode, currentInput,",
          "3586:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3587:       transNoteBuffer, &transRule, inputPositions, outputPositions,",
          "3588:       cursorPosition, cursorStatus, destword, srcword, compbrlStart,",
          "3589:       compbrlEnd))",
          "3590:     goto failure;",
          "3591:    continue;",
          "3592:   default:",
          "3593:    break;",
          "3594:   }",
          "3595:   if (!insertBrailleIndicators(1, table, &src, dest, *srcmax, destmax, mode,",
          "3596:      currentInput, currentOutput, srcMapping, prevSrcMapping, typebuf,",
          "3597:      haveEmphasis, emphasisBuffer, transNoteBuffer, transOpcode,",
          "3598:      prevTransOpcode, &transRule, inputPositions, outputPositions,",
          "3599:      cursorPosition, cursorStatus, compbrlStart, compbrlEnd,",
          "3600:      beforeAttributes, &prevType, &curType, &prevTypeform, prevSrc))",
          "3601:    goto failure;",
          "3608:   insertEmphases(table, &src, dest, *srcmax, destmax, mode, currentInput,",
          "3609:     currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3610:     transNoteBuffer, haveEmphasis, transOpcode, &transRule, inputPositions,",
          "3611:     outputPositions, cursorPosition, cursorStatus, &pre_src, compbrlStart,",
          "3612:     compbrlEnd);",
          "3614:    checkNumericMode(table, &src, dest, *srcmax, destmax, mode, currentInput,",
          "3615:      currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3616:      transNoteBuffer, &transRule, inputPositions, outputPositions,",
          "3617:      cursorPosition, cursorStatus, &dontContract, compbrlStart, compbrlEnd,",
          "3618:      &numericMode);",
          "3620:   if (transOpcode == CTO_Context ||",
          "3621:     findForPassRule(table, src, *srcmax, currentPass, currentInput,",
          "3622:       &transOpcode, &transRule, &transCharslen, &passCharDots, &passSrc,",
          "3623:       &passInstructions, &passIC, &startMatch, &startReplace,",
          "3624:       &endReplace, &groupingRule, &groupingOp))",
          "3625:    switch (transOpcode) {",
          "3626:    case CTO_Context:",
          "3627:     if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)",
          "3628:      appliedRules[appliedRulesCount++] = transRule;",
          "3629:     if (!passDoAction(table, &src, dest, srcmax, destmax, mode, currentInput,",
          "3630:        currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3631:        transNoteBuffer, transOpcode, &transRule, passCharDots,",
          "3632:        passSrc, passInstructions, startMatch, startReplace, &passIC,",
          "3633:        &endReplace, inputPositions, outputPositions, cursorPosition,",
          "3634:        cursorStatus, compbrlStart, compbrlEnd, groupingRule,",
          "3635:        groupingOp))",
          "3636:      goto failure;",
          "3637:     if (endReplace == src) *srcIncremented = 0;",
          "3638:     src = endReplace;",
          "3639:     continue;",
          "3640:    default:",
          "3641:     break;",
          "3642:    }",
          "3647:   if (checkAttr(currentInput[src], CTC_SeqDelimiter | CTC_Space, 0, table))",
          "3648:    dontContract = 0;",
          "3650:   switch (transOpcode) {",
          "3651:   case CTO_EndNum:",
          "3652:    if (table->letterSign && checkAttr(currentInput[src], CTC_Letter, 0, table))",
          "3653:     (*dest)--;",
          "3654:    break;",
          "3655:   case CTO_Repeated:",
          "3656:   case CTO_Space:",
          "3658:    break;",
          "3659:   case CTO_LargeSign:",
          "3660:    if (prevTransOpcode == CTO_LargeSign) {",
          "3661:     int hasEndSegment = 0;",
          "3662:     while (*dest > 0 &&",
          "3663:       checkAttr(currentOutput[*dest - 1], CTC_Space, 1, table)) {",
          "3664:      if (currentOutput[*dest - 1] == ENDSEGMENT) {",
          "3665:       hasEndSegment = 1;",
          "3666:      }",
          "3667:      (*dest)--;",
          "3668:     }",
          "3669:     if (hasEndSegment != 0) {",
          "3670:      currentOutput[*dest] = 0xffff;",
          "3671:      (*dest)++;",
          "3672:     }",
          "3673:    }",
          "3674:    break;",
          "3675:   case CTO_DecPoint:",
          "3676:    if (!table->usesNumericMode && table->numberSign) {",
          "3677:     TranslationTableRule *numRule =",
          "3678:       (TranslationTableRule *)&table->ruleArea[table->numberSign];",
          "3679:     if (!for_updatePositions(&numRule->charsdots[numRule->charslen],",
          "3680:        numRule->charslen, numRule->dotslen, 0, table, &src, dest,",
          "3682:        srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer,",
          "3683:        &transRule, inputPositions, outputPositions, cursorPosition,",
          "3684:        cursorStatus, compbrlStart, compbrlEnd))",
          "3685:      goto failure;",
          "3686:    }",
          "3687:    transOpcode = CTO_MidNum;",
          "3688:    break;",
          "3689:   case CTO_NoCont:",
          "3690:    if (!dontContract)",
          "3691:     doNocont(table, &src, dest, mode, currentInput, destword, srcword,",
          "3692:       &dontContract);",
          "3693:    continue;",
          "3694:   default:",
          "3695:    break;",
          "3699:   switch (transOpcode) {",
          "3700:   case CTO_Replace:",
          "3701:    src += transCharslen;",
          "3702:    if (!putCharacters(&transRule->charsdots[transCharslen], transRule->dotslen,",
          "3703:       table, &src, dest, *srcmax, destmax, mode, currentInput,",
          "3704:       currentOutput, srcMapping, prevSrcMapping, emphasisBuffer,",
          "3705:       transNoteBuffer, &transRule, inputPositions, outputPositions,",
          "3706:       cursorPosition, cursorStatus, compbrlStart, compbrlEnd))",
          "3707:     goto failure;",
          "3708:    break;",
          "3709:   case CTO_None:",
          "3710:    if (!undefinedCharacter(currentInput[src], table, &src, dest, *srcmax,",
          "3711:       destmax, mode, currentInput, currentOutput, srcMapping,",
          "3712:       prevSrcMapping, emphasisBuffer, transNoteBuffer, &transRule,",
          "3713:       inputPositions, outputPositions, cursorPosition, cursorStatus,",
          "3714:       compbrlStart, compbrlEnd))",
          "3715:     goto failure;",
          "3716:    src++;",
          "3717:    break;",
          "3718:   case CTO_UpperCase:",
          "3721:    if (!(mode & (compbrlAtCursor | compbrlLeftCursor) && src >= compbrlStart &&",
          "3722:       src <= compbrlEnd) &&",
          "3723:      (transRule->dotslen == 1 &&",
          "3724:        table->emphRules[capsRule][letterOffset])) {",
          "3725:     putCharacter(curCharDef->lowercase, table, &src, dest, *srcmax, destmax,",
          "3726:       mode, currentInput, currentOutput, srcMapping, prevSrcMapping,",
          "3727:       emphasisBuffer, transNoteBuffer, &transRule, inputPositions,",
          "3728:       outputPositions, cursorPosition, cursorStatus, compbrlStart,",
          "3729:       compbrlEnd);",
          "3730:     src++;",
          "3731:     break;",
          "3732:    }",
          "3740:   default:",
          "3741:    if (*cursorStatus == 2)",
          "3743:    else {",
          "3744:     if (transRule->dotslen) {",
          "3745:      if (!for_updatePositions(&transRule->charsdots[transCharslen],",
          "3746:         transCharslen, transRule->dotslen, 0, table, &src, dest,",
          "3748:         srcMapping, prevSrcMapping, emphasisBuffer,",
          "3749:         transNoteBuffer, &transRule, inputPositions,",
          "3750:         outputPositions, cursorPosition, cursorStatus,",
          "3751:         compbrlStart, compbrlEnd))",
          "3752:       goto failure;",
          "3753:     } else {",
          "3754:      for (k = 0; k < transCharslen; k++) {",
          "3755:       if (!putCharacter(currentInput[src], table, &src, dest, *srcmax,",
          "3756:          destmax, mode, currentInput, currentOutput,",
          "3757:          srcMapping, prevSrcMapping, emphasisBuffer,",
          "3758:          transNoteBuffer, &transRule, inputPositions,",
          "3759:          outputPositions, cursorPosition, cursorStatus,",
          "3760:          compbrlStart, compbrlEnd))",
          "3761:        goto failure;",
          "3762:       src++;",
          "3763:      }",
          "3764:     }",
          "3765:     if (*cursorStatus == 2)",
          "3767:     else if (transRule->dotslen)",
          "3768:      src += transCharslen;",
          "3769:    }",
          "3770:    break;",
          "3771:   }",
          "3774:   switch (transOpcode) {",
          "3775:   case CTO_Repeated: {",
          "3777:    int srclim = *srcmax - transCharslen;",
          "3778:    if (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)",
          "3780:     srclim = compbrlStart - 1;",
          "3781:    while ((src <= srclim) &&",
          "3782:      compareChars(&transRule->charsdots[0], &currentInput[src],",
          "3783:        transCharslen, 0, table)) {",
          "3785:     if (outputPositions != NULL) {",
          "3786:      int tcc;",
          "3787:      for (tcc = 0; tcc < transCharslen; tcc++)",
          "3788:       outputPositions[prevSrcMapping[src + tcc]] = *dest - 1;",
          "3789:     }",
          "3790:     if (!*cursorStatus && src <= *cursorPosition &&",
          "3794:     }",
          "3795:     src += transCharslen;",
          "3796:    }",
          "3797:    break;",
          "3798:   }",
          "3799:   case CTO_RepWord: {",
          "3801:    int srclim = *srcmax - transCharslen;",
          "3802:    if (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)",
          "3804:     srclim = compbrlStart - 1;",
          "3805:    while ((src <= srclim) && compareChars(repwordStart, &currentInput[src],",
          "3806:              repwordLength, 0, table)) {",
          "3808:     if (outputPositions != NULL) {",
          "3809:      int tcc;",
          "3810:      for (tcc = 0; tcc < transCharslen; tcc++)",
          "3811:       outputPositions[prevSrcMapping[src + tcc]] = *dest - 1;",
          "3812:     }",
          "3813:     if (!*cursorStatus && src <= *cursorPosition &&",
          "3817:     }",
          "3818:     src += repwordLength + transCharslen;",
          "3819:    }",
          "3820:    src -= transCharslen;",
          "3821:    break;",
          "3822:   }",
          "3823:   case CTO_JoinNum:",
          "3824:   case CTO_JoinableWord:",
          "3825:    while (src < *srcmax && checkAttr(currentInput[src], CTC_Space, 0, table) &&",
          "3826:      currentInput[src] != ENDSEGMENT)",
          "3827:     src++;",
          "3828:    break;",
          "3829:   default:",
          "3830:    break;",
          "3831:   }",
          "3832:   if (((src > 0) && checkAttr(currentInput[src - 1], CTC_Space, 0, table) &&",
          "3833:      (transOpcode != CTO_JoinableWord))) {",
          "3834:    srcword = src;",
          "3835:    destword = *dest;",
          "3836:   }",
          "3837:   if (srcSpacing != NULL && srcSpacing[src] >= '0' && srcSpacing[src] <= '9')",
          "3838:    destSpacing[*dest] = srcSpacing[src];",
          "3839:   if ((transOpcode >= CTO_Always && transOpcode <= CTO_None) ||",
          "3840:     (transOpcode >= CTO_Digit && transOpcode <= CTO_LitDigit))",
          "3841:    prevTransOpcode = transOpcode;",
          "3842:  }",
          "3845:  insertEmphases(table, &src, dest, *srcmax, destmax, mode, currentInput, currentOutput,",
          "3846:    srcMapping, prevSrcMapping, emphasisBuffer, transNoteBuffer, haveEmphasis,",
          "3847:    transOpcode, &transRule, inputPositions, outputPositions, cursorPosition,",
          "3848:    cursorStatus, &pre_src, compbrlStart, compbrlEnd);",
          "3851:  if (destword != 0 && src < *srcmax &&",
          "3852:    !checkAttr(currentInput[src], CTC_Space, 0, table)) {",
          "3853:   src = srcword;",
          "3855:  }",
          "3856:  if (src < *srcmax) {",
          "3857:   while (checkAttr(currentInput[src], CTC_Space, 0, table))",
          "3858:    if (++src == *srcmax) break;",
          "3859:  }",
          "3861:  return 1;",
          "3865: lou_hyphenate(const char *tableList, const widechar *inbuf, int inlen, char *hyphens,",
          "3866:   int mode) {",
          "3868:  const TranslationTableHeader *table;",
          "3869:  widechar workingBuffer[HYPHSTRING];",
          "3870:  int k, kk;",
          "3871:  int wordStart;",
          "3872:  int wordEnd;",
          "3873:  table = lou_getTable(tableList);",
          "3874:  if (table == NULL || inbuf == NULL || hyphens == NULL ||",
          "3875:    table->hyphenStatesArray == 0 || inlen >= HYPHSTRING)",
          "3876:   return 0;",
          "3877:  if (mode != 0) {",
          "3878:   k = inlen;",
          "3879:   kk = HYPHSTRING;",
          "3880:   if (!lou_backTranslate(tableList, inbuf, &k, &workingBuffer[0], &kk, NULL, NULL,",
          "3881:      NULL, NULL, NULL, 0))",
          "3882:    return 0;",
          "3883:  } else {",
          "3884:   memcpy(&workingBuffer[0], inbuf, CHARSIZE * inlen);",
          "3885:   kk = inlen;",
          "3886:  }",
          "3887:  for (wordStart = 0; wordStart < kk; wordStart++)",
          "3888:   if (((findCharOrDots(workingBuffer[wordStart], 0, table))->attributes &",
          "3889:      CTC_Letter))",
          "3890:    break;",
          "3891:  if (wordStart == kk) return 0;",
          "3892:  for (wordEnd = kk - 1; wordEnd >= 0; wordEnd--)",
          "3893:   if (((findCharOrDots(workingBuffer[wordEnd], 0, table))->attributes & CTC_Letter))",
          "3894:    break;",
          "3895:  for (k = wordStart; k <= wordEnd; k++) {",
          "3896:   TranslationTableCharacter *c = findCharOrDots(workingBuffer[k], 0, table);",
          "3897:   if (!(c->attributes & CTC_Letter)) return 0;",
          "3899:  if (!hyphenate(&workingBuffer[wordStart], wordEnd - wordStart + 1,",
          "3900:     &hyphens[wordStart], table))",
          "3901:   return 0;",
          "3902:  for (k = 0; k <= wordStart; k++) hyphens[k] = '0';",
          "3903:  if (mode != 0) {",
          "3904:   widechar workingBuffer2[HYPHSTRING];",
          "3905:   int outputPos[HYPHSTRING];",
          "3906:   char hyphens2[HYPHSTRING];",
          "3907:   kk = wordEnd - wordStart + 1;",
          "3908:   k = HYPHSTRING;",
          "3909:   if (!lou_translate(tableList, &workingBuffer[wordStart], &kk, &workingBuffer2[0],",
          "3910:      &k, NULL, NULL, &outputPos[0], NULL, NULL, 0))",
          "3911:    return 0;",
          "3912:   for (kk = 0; kk < k; kk++) {",
          "3913:    int hyphPos = outputPos[kk];",
          "3914:    if (hyphPos > k || hyphPos < 0) break;",
          "3915:    if (hyphens[wordStart + kk] & 1)",
          "3916:     hyphens2[hyphPos] = '1';",
          "3917:    else",
          "3918:     hyphens2[hyphPos] = '0';",
          "3919:   }",
          "3920:   for (kk = wordStart; kk < wordStart + k; kk++)",
          "3921:    if (hyphens2[kk] == '0') hyphens[kk] = hyphens2[kk];",
          "3923:  for (k = 0; k < inlen; k++)",
          "3924:   if (hyphens[k] & 1)",
          "3925:    hyphens[k] = '1';",
          "3926:   else",
          "3927:    hyphens[k] = '0';",
          "3928:  hyphens[inlen] = 0;",
          "3929:  return 1;",
          "3933: lou_dotsToChar(",
          "3934:   const char *tableList, widechar *inbuf, widechar *outbuf, int length, int mode) {",
          "3935:  const TranslationTableHeader *table;",
          "3936:  int k;",
          "3937:  widechar dots;",
          "3938:  if (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;",
          "3940:  table = lou_getTable(tableList);",
          "3941:  if (table == NULL || length <= 0) return 0;",
          "3942:  for (k = 0; k < length; k++) {",
          "3943:   dots = inbuf[k];",
          "3945:    dots = (dots & 0x00ff) | B16;",
          "3946:   outbuf[k] = _lou_getCharFromDots(dots);",
          "3947:  }",
          "3948:  return 1;",
          "3952: lou_charToDots(const char *tableList, const widechar *inbuf, widechar *outbuf, int length,",
          "3953:   int mode) {",
          "3954:  const TranslationTableHeader *table;",
          "3955:  int k;",
          "3956:  if (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;",
          "3958:  table = lou_getTable(tableList);",
          "3959:  if (table == NULL || length <= 0) return 0;",
          "3960:  for (k = 0; k < length; k++)",
          "3961:   if ((mode & ucBrl))",
          "3962:    outbuf[k] = ((_lou_getDotsForChar(inbuf[k]) & 0xff) | 0x2800);",
          "3963:   else",
          "3964:    outbuf[k] = _lou_getDotsForChar(inbuf[k]);",
          "3965:  return 1;",
          "",
          "---------------"
        ],
        "liblouis/maketable.c||liblouis/maketable.c": [
          "File: liblouis/maketable.c -> liblouis/maketable.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: static const TranslationTableHeader *table;",
          "29:  table = lou_getTable(tableList);",
          "30: }",
          "33:  static unsigned long int hash;",
          "34:  static TranslationTableOffset offset;",
          "35:  static TranslationTableCharacter *character;",
          "37:  offset = table->characters[hash];",
          "38:  while (offset) {",
          "39:   character = (TranslationTableCharacter *)&table->ruleArea[offset];",
          "43:  return 0;",
          "44: }",
          "47:  static unsigned long int hash;",
          "48:  static TranslationTableOffset offset;",
          "49:  static TranslationTableCharacter *character;",
          "51:  offset = table->characters[hash];",
          "52:  while (offset) {",
          "53:   character = (TranslationTableCharacter *)&table->ruleArea[offset];",
          "57:  return c;",
          "58: }",
          "61:  int length;",
          "62:  widechar *dots;",
          "63:  int i;",
          "64:  for (length = 0; braille[length]; length++)",
          "65:   ;",
          "66:  dots = (widechar *)malloc((length + 1) * sizeof(widechar));",
          "69:  strcpy(pattern, _lou_showDots(dots, length));",
          "70:  free(dots);",
          "71: }",
          "74:  int k, l;",
          "75:  switch (rule->opcode) {",
          "76:  case CTO_Context:",
          "",
          "[Removed Lines]",
          "28: extern void loadTable(const char *tableList) {",
          "32: extern int isLetter(widechar c) {",
          "36:  hash = (unsigned long int) c % HASHNUM;",
          "40:   if (character->realchar == c)",
          "41:    return character->attributes & CTC_Letter;",
          "42:   offset = character->next; }",
          "46: extern widechar toLowercase(widechar c) {",
          "50:  hash = (unsigned long int) c % HASHNUM;",
          "54:   if (character->realchar == c)",
          "55:    return character->lowercase;",
          "56:   offset = character->next; }",
          "60: extern void toDotPattern(widechar *braille, char *pattern) {",
          "67:  for (i = 0; i < length; i++)",
          "68:   dots[i] = _lou_getDotsForChar(braille[i]);",
          "73: extern int printRule(TranslationTableRule *rule, widechar *rule_string) {",
          "",
          "[Added Lines]",
          "28: extern void",
          "29: loadTable(const char *tableList) {",
          "33: extern int",
          "34: isLetter(widechar c) {",
          "38:  hash = (unsigned long int)c % HASHNUM;",
          "42:   if (character->realchar == c) return character->attributes & CTC_Letter;",
          "43:   offset = character->next;",
          "44:  }",
          "48: extern widechar",
          "49: toLowercase(widechar c) {",
          "53:  hash = (unsigned long int)c % HASHNUM;",
          "57:   if (character->realchar == c) return character->lowercase;",
          "58:   offset = character->next;",
          "59:  }",
          "63: extern void",
          "64: toDotPattern(widechar *braille, char *pattern) {",
          "71:  for (i = 0; i < length; i++) dots[i] = _lou_getDotsForChar(braille[i]);",
          "76: extern int",
          "77: printRule(TranslationTableRule *rule, widechar *rule_string) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:  default:",
          "85:   l = 0;",
          "86:   const char *opcode = _lou_findOpcodeName(rule->opcode);",
          "89:   rule_string[l++] = ' ';",
          "92:   rule_string[l++] = ' ';",
          "93:   for (k = 0; k < rule->dotslen; k++)",
          "94:    rule_string[l++] = _lou_getCharFromDots(rule->charsdots[rule->charslen + k]);",
          "95:   rule_string[l++] = '\\0';",
          "97: }",
          "99: #define DEBUG 0",
          "101: #if DEBUG",
          "106: #else",
          "107: #define debug(fmt, ...)",
          "108: #endif",
          "115:  unsigned long int hash;",
          "116:  TranslationTableOffset offset;",
          "117:  TranslationTableRule *rule;",
          "",
          "[Removed Lines]",
          "87:   for (k = 0; k < strlen(opcode); k++)",
          "88:    rule_string[l++] = opcode[k];",
          "90:   for (k = 0; k < rule->charslen; k++)",
          "91:    rule_string[l++] = rule->charsdots[k];",
          "96:   return 1; }",
          "102: #define debug(fmt, ...) do {                                 \\",
          "103:   if (DEBUG)                                                 \\",
          "104:     printf(\"%*s\" fmt \"\\n\", debug_indent, \"\", ##__VA_ARGS__); \\",
          "105: } while(0)",
          "110: static int find_matching_rules(widechar *text,",
          "111:                                int text_len,",
          "112:                                widechar *braille,",
          "113:                                int braille_len,",
          "114:                                char *data) {",
          "",
          "[Added Lines]",
          "91:   for (k = 0; k < strlen(opcode); k++) rule_string[l++] = opcode[k];",
          "93:   for (k = 0; k < rule->charslen; k++) rule_string[l++] = rule->charsdots[k];",
          "98:   return 1;",
          "99:  }",
          "105: #define debug(fmt, ...)                                                     \\",
          "106:  do {                                                                    \\",
          "107:   if (DEBUG) printf(\"%*s\" fmt \"\\n\", debug_indent, \"\", ##__VA_ARGS__); \\",
          "108:  } while (0)",
          "113: static int",
          "114: find_matching_rules(",
          "115:   widechar *text, int text_len, widechar *braille, int braille_len, char *data) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "123:  int debug_indent = 0;",
          "124:  if (initial_text_len == 0) {",
          "125:   initial_text_len = text_len;",
          "128:   printf(\" <=> \");",
          "133:   debug_indent = initial_text_len - text_len;",
          "134: #endif",
          "137:  if (text_len == 0 && braille_len == 0) {",
          "140:   data[-1] = '$';",
          "144:  data_save = (char *)malloc(text_len * sizeof(char));",
          "145:  memcpy(data_save, data, text_len);",
          "148:  for (hash_len = 2; hash_len >= 1; hash_len--) {",
          "149:   offset = 0;",
          "150:   switch (hash_len) {",
          "151:   case 2:",
          "156:    hash %= HASHNUM;",
          "157:    offset = table->forRules[hash];",
          "158:    break;",
          "159:   case 1:",
          "161:    offset = table->characters[hash];",
          "162:    while (offset) {",
          "163:     character = (TranslationTableCharacter *)&table->ruleArea[offset];",
          "164:     if (character->realchar == text[0]) {",
          "165:      offset = character->otherRules;",
          "169:   while (offset) {",
          "170:    rule = (TranslationTableRule *)&table->ruleArea[offset];",
          "171: #if DEBUG",
          "172:    widechar print_string[128];",
          "173:    printRule(rule, print_string);",
          "174:    printf(\"%*s=> \", debug_indent, \"\");",
          "177:    printf(\"\\n\");",
          "178: #endif",
          "185:    switch (rule->opcode) {",
          "186:    case CTO_WholeWord:",
          "189:     goto next_rule;",
          "190:    case CTO_BegWord:",
          "193:     goto next_rule;",
          "194:    case CTO_EndWord:",
          "197:     goto next_rule;",
          "198:    case CTO_NoCross:",
          "199:     for (k = 0; k < rule->charslen - 1; k++)",
          "202:     break;",
          "203:    case CTO_Letter:",
          "204:    case CTO_UpperCase:",
          "",
          "[Removed Lines]",
          "126:   for (k = 0; k < text_len; k++)",
          "127:    printf(\"%c\", text[k]);",
          "129:   for (k = 0; k < braille_len; k++)",
          "130:    printf(\"%c\", braille[k]);",
          "131:   printf(\"\\n\"); }",
          "132:  else",
          "138:   if (data[-1] != '1')",
          "139:    return 0;",
          "141:   return 1; }",
          "152:    if (text_len < 2)",
          "153:     break;",
          "154:    hash = (unsigned long int) toLowercase(text[0]) << 8;",
          "155:    hash += (unsigned long int) toLowercase(text[1]);",
          "160:    hash = (unsigned long int) text[0] % HASHNUM;",
          "166:      break; }",
          "167:     else",
          "168:      offset = character->next; }}",
          "175:    for (k = 0; print_string[k]; k++)",
          "176:     printf(\"%c\", print_string[k]);",
          "181:    if (rule->charslen == 0 || rule->dotslen == 0)",
          "182:     goto next_rule;",
          "183:    if (rule->charslen > text_len)",
          "184:     goto next_rule;",
          "187:     if (data[-1] == '^' && rule->charslen == text_len)",
          "188:      break;",
          "191:     if (data[-1] == '^')",
          "192:      break;",
          "195:     if (rule->charslen == text_len)",
          "196:      break;",
          "200:      if (data[k + 1] == '>')",
          "201:       goto next_rule;",
          "",
          "[Added Lines]",
          "127:   for (k = 0; k < text_len; k++) printf(\"%c\", text[k]);",
          "129:   for (k = 0; k < braille_len; k++) printf(\"%c\", braille[k]);",
          "130:   printf(\"\\n\");",
          "131:  } else",
          "137:   if (data[-1] != '1') return 0;",
          "139:   return 1;",
          "140:  }",
          "151:    if (text_len < 2) break;",
          "152:    hash = (unsigned long int)toLowercase(text[0]) << 8;",
          "153:    hash += (unsigned long int)toLowercase(text[1]);",
          "158:    hash = (unsigned long int)text[0] % HASHNUM;",
          "164:      break;",
          "165:     } else",
          "166:      offset = character->next;",
          "167:    }",
          "168:   }",
          "175:    for (k = 0; print_string[k]; k++) printf(\"%c\", print_string[k]);",
          "180:    if (rule->charslen == 0 || rule->dotslen == 0) goto next_rule;",
          "181:    if (rule->charslen > text_len) goto next_rule;",
          "184:     if (data[-1] == '^' && rule->charslen == text_len) break;",
          "187:     if (data[-1] == '^') break;",
          "190:     if (rule->charslen == text_len) break;",
          "194:      if (data[k + 1] == '>') goto next_rule;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "207:    case CTO_Always:",
          "208:     break;",
          "209:    default:",
          "211:    for (k = 0; k < rule->charslen; k++)",
          "214:    debug(\"** rule selected **\");",
          "220:     goto inhibit;",
          "221:    for (k = 0; k < rule->dotslen; k++)",
          "223:      goto inhibit;",
          "226:    switch (rule->opcode) {",
          "228:     break;",
          "229:    default:",
          "230:     k = 0;",
          "",
          "[Removed Lines]",
          "210:     goto next_rule; }",
          "212:     if (rule->charsdots[k] != text[k])",
          "213:      goto next_rule;",
          "217:    if (rule->dotslen > braille_len",
          "218:        || rule->charslen == text_len && rule->dotslen < braille_len",
          "219:        || rule->dotslen == braille_len && rule->charslen < text_len)",
          "222:     if (_lou_getCharFromDots(rule->charsdots[rule->charslen + k]) != braille[k])",
          "227:    case CTO_NoCross: // deferred: see success",
          "",
          "[Added Lines]",
          "203:     goto next_rule;",
          "204:    }",
          "206:     if (rule->charsdots[k] != text[k]) goto next_rule;",
          "210:    if (rule->dotslen > braille_len ||",
          "211:      rule->charslen == text_len && rule->dotslen < braille_len ||",
          "212:      rule->dotslen == braille_len && rule->charslen < text_len)",
          "215:     if (_lou_getCharFromDots(rule->charsdots[rule->charslen + k]) !=",
          "216:       braille[k])",
          "221:    case CTO_NoCross:  // deferred: see success",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "232:      if (data[k + 1] == '>' || data[k + 1] == '|') {",
          "233:       data[k++] = '1';",
          "234:       memset(&data[k], '-', text_len - k);",
          "237:       data[k++] = '0';",
          "238:      else",
          "240:    if (data[rule->charslen] == '>' || data[rule->charslen] == '|') {",
          "241:     data[rule->charslen - 1] = '1';",
          "244:     data[rule->charslen - 1] = '0';",
          "245:    else",
          "246:     data[rule->charslen - 1] = 'x';",
          "247:    debug(\"%s\", data);",
          "250:    switch (data[rule->charslen - 1]) {",
          "251:    case 'x':",
          "252:     data[rule->charslen - 1] = '0';",
          "253:     debug(\"%s\", data);",
          "254:     if (find_matching_rules(&text[rule->charslen], text_len - rule->charslen,",
          "259:      data[rule->charslen - 1] = '1';",
          "260:      debug(\"%s\", data);",
          "261:      memset(&data[rule->charslen], '-', text_len - rule->charslen);",
          "266:       data[rule->charslen - 1] = 'x';",
          "267:      else",
          "269:      debug(\"%s\", data);",
          "270:      free(data_tmp);",
          "273:      data[rule->charslen - 1] = '1';",
          "274:      memset(&data[rule->charslen], '-', text_len - rule->charslen);",
          "276:    case '0':",
          "277:    case '1':",
          "278:     if (find_matching_rules(&text[rule->charslen], text_len - rule->charslen,",
          "284:    debug(\"** rule inhibited **\");",
          "285:    switch (rule->opcode) {",
          "286:    case CTO_NoCross:",
          "289:     data[rule->charslen - 1] = '>';",
          "290:     debug(\"%s\", data);",
          "291:     goto next_rule;",
          "292:    default:",
          "297:    switch (rule->opcode) {",
          "298:    case CTO_NoCross:",
          "299:     memset(data, '0', rule->charslen - 1);",
          "301:    free(data_save);",
          "302:    return 1;",
          "309:  memcpy(data, data_save, text_len);",
          "310:  free(data_save);",
          "",
          "[Removed Lines]",
          "235:       break; }",
          "236:      else if (data[k] == 's')",
          "239:       data[k++] = 'x'; }}",
          "242:     memset(&data[rule->charslen], '-', text_len - rule->charslen); }",
          "243:    else if (data[rule->charslen - 1] == '|')",
          "255:                             &braille[rule->dotslen], braille_len - rule->dotslen,",
          "256:                             &data[rule->charslen])) {",
          "257:      char *data_tmp = (char *)malloc((text_len - rule->charslen + 1) * sizeof(char));",
          "258:      memcpy(data_tmp, &data[rule->charslen - 1], text_len - rule->charslen + 1);",
          "262:      if (find_matching_rules(&text[rule->charslen], text_len - rule->charslen,",
          "263:                              &braille[rule->dotslen], braille_len - rule->dotslen,",
          "264:                              &data[rule->charslen])",
          "265:          && memcmp(&data_tmp[1], &data[rule->charslen], text_len - rule->charslen) == 0)",
          "268:       memcpy(&data[rule->charslen - 1], data_tmp, text_len - rule->charslen + 1);",
          "271:      goto success; }",
          "272:     else {",
          "275:      debug(\"%s\", data); }",
          "279:                             &braille[rule->dotslen], braille_len - rule->dotslen,",
          "280:                             &data[rule->charslen]))",
          "281:      goto success; }",
          "283:     inhibit:",
          "287:     if (rule->charslen < 2)",
          "288:      goto abort;",
          "293:     goto abort; }",
          "295:     success:",
          "300:     debug(\"%s\", data); }",
          "304:     next_rule:",
          "305:    offset = rule->charsnext; }}",
          "307:   abort:",
          "",
          "[Added Lines]",
          "229:       break;",
          "230:      } else if (data[k] == 's')",
          "233:       data[k++] = 'x';",
          "234:     }",
          "235:    }",
          "238:     memset(&data[rule->charslen], '-', text_len - rule->charslen);",
          "239:    } else if (data[rule->charslen - 1] == '|')",
          "251:        &braille[rule->dotslen], braille_len - rule->dotslen,",
          "252:        &data[rule->charslen])) {",
          "253:      char *data_tmp = (char *)malloc(",
          "254:        (text_len - rule->charslen + 1) * sizeof(char));",
          "255:      memcpy(data_tmp, &data[rule->charslen - 1],",
          "256:        text_len - rule->charslen + 1);",
          "260:      if (find_matching_rules(&text[rule->charslen],",
          "261:         text_len - rule->charslen, &braille[rule->dotslen],",
          "262:         braille_len - rule->dotslen, &data[rule->charslen]) &&",
          "263:        memcmp(&data_tmp[1], &data[rule->charslen],",
          "264:          text_len - rule->charslen) == 0)",
          "267:       memcpy(&data[rule->charslen - 1], data_tmp,",
          "268:         text_len - rule->charslen + 1);",
          "271:      goto success;",
          "272:     } else {",
          "275:      debug(\"%s\", data);",
          "276:     }",
          "280:        &braille[rule->dotslen], braille_len - rule->dotslen,",
          "281:        &data[rule->charslen]))",
          "282:      goto success;",
          "283:    }",
          "285:   inhibit:",
          "289:     if (rule->charslen < 2) goto abort;",
          "294:     goto abort;",
          "295:    }",
          "297:   success:",
          "302:     debug(\"%s\", data);",
          "303:    }",
          "307:   next_rule:",
          "308:    offset = rule->charsnext;",
          "309:   }",
          "310:  }",
          "312: abort:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "312:  return 0;",
          "313: }",
          "316:  int text_len, braille_len;",
          "317:  for (text_len = 0; text[text_len]; text_len++)",
          "318:   ;",
          "319:  for (braille_len = 0; braille[braille_len]; braille_len++)",
          "320:   ;",
          "323:  hyphen_string[0] = '^';",
          "324:  hyphen_string[text_len + 1] = '\\0';",
          "325:  memset(&hyphen_string[1], '-', text_len);",
          "326:  return find_matching_rules(text, text_len, braille, braille_len, &hyphen_string[1]);",
          "327: }",
          "330:  int text_len, rules_len;",
          "331:  unsigned long int hash;",
          "332:  TranslationTableOffset offset;",
          "",
          "[Removed Lines]",
          "315: extern int suggestChunks(widechar *text, widechar *braille, char *hyphen_string) {",
          "321:  if (text_len == 0 || braille_len == 0)",
          "322:   return 0;",
          "329: extern void findRelevantRules(widechar *text, widechar **rules_str) {",
          "",
          "[Added Lines]",
          "320: extern int",
          "321: suggestChunks(widechar *text, widechar *braille, char *hyphen_string) {",
          "327:  if (text_len == 0 || braille_len == 0) return 0;",
          "334: extern void",
          "335: findRelevantRules(widechar *text, widechar **rules_str) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "338:   ;",
          "339:  for (rules_len = 0; rules_str[rules_len]; rules_len++)",
          "340:   ;",
          "342:  m = n = 0;",
          "343:  while (text[n]) {",
          "344:   for (hash_len = 2; hash_len >= 1; hash_len--) {",
          "345:    offset = 0;",
          "346:    switch (hash_len) {",
          "347:    case 2:",
          "352:     hash %= HASHNUM;",
          "353:     offset = table->forRules[hash];",
          "354:     break;",
          "355:    case 1:",
          "357:     offset = table->characters[hash];",
          "358:     while (offset) {",
          "359:      character = (TranslationTableCharacter *)&table->ruleArea[offset];",
          "360:      if (character->realchar == text[0]) {",
          "361:       offset = character->otherRules;",
          "365:    while (offset) {",
          "366:     rule = (TranslationTableRule *)&table->ruleArea[offset];",
          "367:     switch (rule->opcode) {",
          "",
          "[Removed Lines]",
          "341:  rules = (TranslationTableRule **)malloc((rules_len + 1) * sizeof(TranslationTableRule *));",
          "348:     if (text_len - n < 2)",
          "349:      break;",
          "350:     hash = (unsigned long int) toLowercase(text[n]) << 8;",
          "351:     hash += (unsigned long int) toLowercase(text[n+1]);",
          "356:     hash = (unsigned long int) text[n] % HASHNUM;",
          "362:       break; }",
          "363:      else",
          "364:       offset = character->next; }}",
          "",
          "[Added Lines]",
          "347:  rules = (TranslationTableRule **)malloc(",
          "348:    (rules_len + 1) * sizeof(TranslationTableRule *));",
          "355:     if (text_len - n < 2) break;",
          "356:     hash = (unsigned long int)toLowercase(text[n]) << 8;",
          "357:     hash += (unsigned long int)toLowercase(text[n + 1]);",
          "362:     hash = (unsigned long int)text[n] % HASHNUM;",
          "368:       break;",
          "369:      } else",
          "370:       offset = character->next;",
          "371:     }",
          "372:    }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "372:     case CTO_NoCross:",
          "373:      break;",
          "374:     default:",
          "379:      goto next_rule;",
          "380:     for (k = 0; k < rule->charslen; k++)",
          "383:     rules[m++] = rule;",
          "390:  rules_str[m--] = NULL;",
          "393:  free(rules);",
          "394: }",
          "",
          "[Removed Lines]",
          "375:      goto next_rule; }",
          "376:     if (rule->charslen == 0",
          "377:         || rule->dotslen == 0",
          "378:         || rule->charslen > text_len - n)",
          "381:      if (rule->charsdots[k] != text[n+k])",
          "382:       goto next_rule;",
          "384:     if (m == rules_len)",
          "385:      goto finish;",
          "386:      next_rule:",
          "387:     offset = rule->charsnext; }}",
          "388:   n++; }",
          "389:   finish:",
          "391:  for (; m >= 0; m--)",
          "392:   printRule(rules[m], rules_str[m]);",
          "",
          "[Added Lines]",
          "383:      goto next_rule;",
          "384:     }",
          "385:     if (rule->charslen == 0 || rule->dotslen == 0 ||",
          "386:       rule->charslen > text_len - n)",
          "389:      if (rule->charsdots[k] != text[n + k]) goto next_rule;",
          "391:     if (m == rules_len) goto finish;",
          "392:    next_rule:",
          "393:     offset = rule->charsnext;",
          "394:    }",
          "395:   }",
          "396:   n++;",
          "397:  }",
          "398: finish:",
          "400:  for (; m >= 0; m--) printRule(rules[m], rules_str[m]);",
          "",
          "---------------"
        ],
        "liblouis/metadata.c||liblouis/metadata.c": [
          "File: liblouis/metadata.c -> liblouis/metadata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: } List;",
          "",
          "[Removed Lines]",
          "39: typedef struct List",
          "40: {",
          "41:   void * head;",
          "42:   void (* free)(void *);",
          "43:   struct List * tail;",
          "",
          "[Added Lines]",
          "39: typedef struct List {",
          "40:  void *head;",
          "41:  void (*free)(void *);",
          "42:  struct List *tail;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55: static List *",
          "98:  }",
          "109: }",
          "114: static void",
          "124: }",
          "129: static List *",
          "141: }",
          "146: static int",
          "154: }",
          "159: static void **",
          "171: }",
          "179: } Feature;",
          "185: } FeatureWithImportance;",
          "191: } TableMeta;",
          "",
          "[Removed Lines]",
          "56: list_conj(List * list,",
          "57:    void * x,",
          "58:    int (* cmp)(void *, void *),",
          "59:    void * (* dup)(void *),",
          "60:    void (* free)(void *))",
          "61: {",
          "62:   if (!list)",
          "63:     {",
          "64:       list = malloc(sizeof(List));",
          "65:       list->head = dup ? dup(x) : x;",
          "66:       list->free = free;",
          "67:       list->tail = NULL;",
          "68:       return list;",
          "69:     }",
          "70:   else if (!cmp)",
          "71:     {",
          "72:       List * l = malloc(sizeof(List));",
          "73:       l->head = dup ? dup(x) : x;",
          "74:       l->free = free;",
          "75:       l->tail = list;",
          "76:       return l;",
          "77:     }",
          "78:   else",
          "79:     {",
          "80:       List * l1 = list;",
          "81:       List * l2 = NULL;",
          "82:       while (l1)",
          "83:  {",
          "84:    int c = cmp(l1->head, x);",
          "85:    if (c > 0)",
          "86:      break;",
          "87:    else if (c < 0)",
          "88:      {",
          "89:        l2 = l1;",
          "90:        l1 = l2->tail;",
          "91:      }",
          "92:    else",
          "93:      {",
          "94:        if (x != l1->head && !dup && free)",
          "95:   free(x);",
          "96:        return list;",
          "97:      }",
          "99:       List * l3 = malloc(sizeof(List));",
          "100:       l3->head = dup? dup(x) : x;",
          "101:       l3->free = free;",
          "102:       l3->tail = l1;",
          "103:       if (!l2)",
          "104:  list = l3;",
          "105:       else",
          "106:  l2->tail = l3;",
          "107:       return list;",
          "108:     }",
          "115: list_free(List * list)",
          "116: {",
          "117:   if (list)",
          "118:     {",
          "119:       if (list->free)",
          "120:  list->free(list->head);",
          "121:       list_free(list->tail);",
          "122:       free(list);",
          "123:     }",
          "130: list_sort(List * list, int (* cmp)(void *, void *))",
          "131: {",
          "132:   List * newList = NULL;",
          "133:   List * l;",
          "134:   for (l = list; l; l = l->tail)",
          "135:     {",
          "136:       newList = list_conj(newList, l->head, cmp, NULL, l->free);",
          "137:       l->free = NULL;",
          "138:     }",
          "139:   list_free(list);",
          "140:   return newList;",
          "147: list_size(List * list)",
          "148: {",
          "149:   int len = 0;",
          "150:   List * l;",
          "151:   for (l = list; l; l = l->tail)",
          "152:     len++;",
          "153:   return len;",
          "160: list_toArray(List * list, void * (* dup)(void *))",
          "161: {",
          "162:   void ** array;",
          "163:   List * l;",
          "164:   int i;",
          "165:   array = malloc((1 + list_size(list)) * sizeof(void *));",
          "166:   i = 0;",
          "167:   for (l = list; l; l = l->tail)",
          "168:     array[i++] = dup ? dup(l->head) : l->head;",
          "169:   array[i] = NULL;",
          "170:   return array;",
          "175: typedef struct",
          "176: {",
          "177:   char * key;",
          "178:   char * val;",
          "181: typedef struct",
          "182: {",
          "183:   Feature feature;",
          "184:   int importance;",
          "187: typedef struct",
          "188: {",
          "189:   char * name;",
          "190:   List * features;",
          "",
          "[Added Lines]",
          "55: list_conj(List *list, void *x, int (*cmp)(void *, void *), void *(*dup)(void *),",
          "56:   void (*free)(void *)) {",
          "57:  if (!list) {",
          "58:   list = malloc(sizeof(List));",
          "59:   list->head = dup ? dup(x) : x;",
          "60:   list->free = free;",
          "61:   list->tail = NULL;",
          "62:   return list;",
          "63:  } else if (!cmp) {",
          "64:   List *l = malloc(sizeof(List));",
          "65:   l->head = dup ? dup(x) : x;",
          "66:   l->free = free;",
          "67:   l->tail = list;",
          "68:   return l;",
          "69:  } else {",
          "70:   List *l1 = list;",
          "71:   List *l2 = NULL;",
          "72:   while (l1) {",
          "73:    int c = cmp(l1->head, x);",
          "74:    if (c > 0)",
          "75:     break;",
          "76:    else if (c < 0) {",
          "77:     l2 = l1;",
          "78:     l1 = l2->tail;",
          "79:    } else {",
          "80:     if (x != l1->head && !dup && free) free(x);",
          "81:     return list;",
          "82:    }",
          "83:   }",
          "84:   List *l3 = malloc(sizeof(List));",
          "85:   l3->head = dup ? dup(x) : x;",
          "86:   l3->free = free;",
          "87:   l3->tail = l1;",
          "88:   if (!l2)",
          "89:    list = l3;",
          "90:   else",
          "91:    l2->tail = l3;",
          "92:   return list;",
          "100: list_free(List *list) {",
          "101:  if (list) {",
          "102:   if (list->free) list->free(list->head);",
          "103:   list_free(list->tail);",
          "104:   free(list);",
          "105:  }",
          "112: list_sort(List *list, int (*cmp)(void *, void *)) {",
          "113:  List *newList = NULL;",
          "114:  List *l;",
          "115:  for (l = list; l; l = l->tail) {",
          "116:   newList = list_conj(newList, l->head, cmp, NULL, l->free);",
          "117:   l->free = NULL;",
          "118:  }",
          "119:  list_free(list);",
          "120:  return newList;",
          "127: list_size(List *list) {",
          "128:  int len = 0;",
          "129:  List *l;",
          "130:  for (l = list; l; l = l->tail) len++;",
          "131:  return len;",
          "138: list_toArray(List *list, void *(*dup)(void *)) {",
          "139:  void **array;",
          "140:  List *l;",
          "141:  int i;",
          "142:  array = malloc((1 + list_size(list)) * sizeof(void *));",
          "143:  i = 0;",
          "144:  for (l = list; l; l = l->tail) array[i++] = dup ? dup(l->head) : l->head;",
          "145:  array[i] = NULL;",
          "146:  return array;",
          "151: typedef struct {",
          "152:  char *key;",
          "153:  char *val;",
          "156: typedef struct {",
          "157:  Feature feature;",
          "158:  int importance;",
          "161: typedef struct {",
          "162:  char *name;",
          "163:  List *features;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "198: static Feature",
          "206: }",
          "211: static void",
          "220: }",
          "",
          "[Removed Lines]",
          "199: feature_new(const char * key, const char * val)",
          "200: {",
          "201:   static char * YES = \"yes\";",
          "202:   Feature f;",
          "203:   f.key = strdup(key);",
          "204:   f.val = strdup(val ? val : YES);",
          "205:   return f;",
          "212: feature_free(Feature * f)",
          "213: {",
          "214:   if (f)",
          "215:     {",
          "216:       free(f->key);",
          "217:       free(f->val);",
          "218:       free(f);",
          "219:     }",
          "",
          "[Added Lines]",
          "172: feature_new(const char *key, const char *val) {",
          "173:  static char *YES = \"yes\";",
          "174:  Feature f;",
          "175:  f.key = strdup(key);",
          "176:  f.val = strdup(val ? val : YES);",
          "177:  return f;",
          "184: feature_free(Feature *f) {",
          "185:  if (f) {",
          "186:   free(f->key);",
          "187:   free(f->val);",
          "188:   free(f);",
          "189:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "227: static int",
          "231: }",
          "",
          "[Removed Lines]",
          "228: cmpKeys(Feature * f1, Feature * f2)",
          "229: {",
          "230:   return strcmp(f1->key, f2->key);",
          "",
          "[Added Lines]",
          "198: cmpKeys(Feature *f1, Feature *f2) {",
          "199:  return strcmp(f1->key, f2->key);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "245: static int",
          "282:  }",
          "310:  }",
          "313: }",
          "318: static int",
          "326: }",
          "331: static int",
          "335: }",
          "",
          "[Removed Lines]",
          "246: matchFeatureLists(const List * query, const List * tableFeatures, int fuzzy)",
          "247: {",
          "248:   static int POS_MATCH = 10;",
          "249:   static int NEG_MATCH = -100;",
          "250:   static int UNDEFINED = -20;",
          "251:   static int EXTRA = -1;",
          "252:   static int POS_MATCH_FUZZY = 10;",
          "253:   static int NEG_MATCH_FUZZY = -25;",
          "254:   static int UNDEFINED_FUZZY = -5;",
          "255:   static int EXTRA_FUZZY = -1;",
          "256:   int posMatch, negMatch, undefined, extra;",
          "257:   if (!fuzzy)",
          "258:     {",
          "259:       posMatch = POS_MATCH;",
          "260:       negMatch = NEG_MATCH;",
          "261:       undefined = UNDEFINED;",
          "262:       extra = EXTRA;",
          "263:     }",
          "264:   else",
          "265:     {",
          "266:       posMatch = POS_MATCH_FUZZY;",
          "267:       negMatch = NEG_MATCH_FUZZY;",
          "268:       undefined = UNDEFINED_FUZZY;",
          "269:       extra = EXTRA_FUZZY;",
          "270:     }",
          "271:   int quotient = 0;",
          "272:   const List * l1 = query;",
          "273:   const List * l2 = tableFeatures;",
          "274:   while (1)",
          "275:     {",
          "276:       if (!l1)",
          "277:  {",
          "278:    if (!l2)",
          "279:      break;",
          "280:    quotient += extra;",
          "281:    l2 = l2->tail;",
          "283:       else if (!l2)",
          "284:  {",
          "285:    quotient += undefined;",
          "286:    l1 = l1->tail;",
          "287:  }",
          "288:       else",
          "289:  {",
          "290:    int cmp = cmpKeys(l1->head, l2->head);",
          "291:    if (cmp < 0)",
          "292:      {",
          "293:        quotient += undefined;",
          "294:        l1 = l1->tail;",
          "295:      }",
          "296:    else if (cmp > 0)",
          "297:      {",
          "298:        quotient += extra;",
          "299:        l2 = l2->tail;",
          "300:      }",
          "301:    else",
          "302:      {",
          "303:        if (strcmp(((Feature *)l1->head)->val, ((Feature *)l2->head)->val) == 0)",
          "304:   quotient += posMatch;",
          "305:        else",
          "306:   quotient += negMatch;",
          "307:        l1 = l1->tail;",
          "308:        l2 = l2->tail;",
          "309:      }",
          "311:     }",
          "312:   return quotient;",
          "319: isIdentChar(char c)",
          "320: {",
          "321:   return (c >= '0' && c <= '9')",
          "322:       || (c >= 'A' && c <= 'Z')",
          "323:       || (c >= 'a' && c <= 'z')",
          "324:       || c == '-'",
          "325:       || c == '_';",
          "332: isSpace(char c)",
          "333: {",
          "334:   return c == ' ' || c == '\\t';",
          "",
          "[Added Lines]",
          "216: matchFeatureLists(const List *query, const List *tableFeatures, int fuzzy) {",
          "217:  static int POS_MATCH = 10;",
          "218:  static int NEG_MATCH = -100;",
          "219:  static int UNDEFINED = -20;",
          "220:  static int EXTRA = -1;",
          "221:  static int POS_MATCH_FUZZY = 10;",
          "222:  static int NEG_MATCH_FUZZY = -25;",
          "223:  static int UNDEFINED_FUZZY = -5;",
          "224:  static int EXTRA_FUZZY = -1;",
          "225:  int posMatch, negMatch, undefined, extra;",
          "226:  if (!fuzzy) {",
          "227:   posMatch = POS_MATCH;",
          "228:   negMatch = NEG_MATCH;",
          "229:   undefined = UNDEFINED;",
          "230:   extra = EXTRA;",
          "231:  } else {",
          "232:   posMatch = POS_MATCH_FUZZY;",
          "233:   negMatch = NEG_MATCH_FUZZY;",
          "234:   undefined = UNDEFINED_FUZZY;",
          "235:   extra = EXTRA_FUZZY;",
          "237:  int quotient = 0;",
          "238:  const List *l1 = query;",
          "239:  const List *l2 = tableFeatures;",
          "240:  while (1) {",
          "241:   if (!l1) {",
          "242:    if (!l2) break;",
          "243:    quotient += extra;",
          "244:    l2 = l2->tail;",
          "245:   } else if (!l2) {",
          "246:    quotient += undefined;",
          "247:    l1 = l1->tail;",
          "248:   } else {",
          "249:    int cmp = cmpKeys(l1->head, l2->head);",
          "250:    if (cmp < 0) {",
          "251:     quotient += undefined;",
          "252:     l1 = l1->tail;",
          "253:    } else if (cmp > 0) {",
          "254:     quotient += extra;",
          "255:     l2 = l2->tail;",
          "256:    } else {",
          "257:     if (strcmp(((Feature *)l1->head)->val, ((Feature *)l2->head)->val) == 0)",
          "258:      quotient += posMatch;",
          "259:     else",
          "260:      quotient += negMatch;",
          "261:     l1 = l1->tail;",
          "262:     l2 = l2->tail;",
          "263:    }",
          "264:   }",
          "266:  return quotient;",
          "273: isIdentChar(char c) {",
          "274:  return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||",
          "275:    c == '-' || c == '_';",
          "282: isSpace(char c) {",
          "283:  return c == ' ' || c == '\\t';",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "341: static List *",
          "395:  }",
          "407:  }",
          "423: }",
          "428: static char *",
          "437: }",
          "442: static List *",
          "530:     }",
          "553:   }",
          "573: }",
          "577: void EXPORT_CALL",
          "591:  }",
          "595: }",
          "",
          "[Removed Lines]",
          "342: parseQuery(const char * query)",
          "343: {",
          "344:   List * features = NULL;",
          "345:   const char * key = NULL;",
          "346:   const char * val = NULL;",
          "347:   size_t keySize = 0;",
          "348:   size_t valSize = 0;",
          "349:   const char * c;",
          "350:   int pos = 0;",
          "351:   while (1)",
          "352:     {",
          "353:       c = &query[pos++];",
          "354:       if (isSpace(*c) || (*c == '\\n') | (*c == '\\0'))",
          "355:  {",
          "356:    if (key)",
          "357:      {",
          "358:        char * k = malloc(keySize + 1);",
          "359:        k[keySize] = '\\0';",
          "360:        memcpy(k, key, keySize);",
          "361:        char * v = NULL;",
          "362:        if (val)",
          "363:          {",
          "364:            v = malloc(valSize + 1);",
          "365:            v[valSize] = '\\0';",
          "366:            memcpy(v, val, valSize);",
          "367:          }",
          "368:        FeatureWithImportance f = { feature_new(k, v), 0 };",
          "369:        _lou_logMessage(LOG_DEBUG, \"Query has feature '%s:%s'\", f.feature.key, f.feature.val);",
          "370:        features = list_conj(features, memcpy(malloc(sizeof(f)), &f, sizeof(f)),",
          "371:        NULL, NULL, (void (*)(void *))feature_free);",
          "372:        free(k);",
          "373:        free(v);",
          "374:        key = val = NULL;",
          "375:        keySize = valSize = 0;",
          "376:      }",
          "377:    if (*c == '\\0')",
          "378:      break;",
          "379:  }",
          "380:       else if (*c == ':')",
          "381:  {",
          "382:    if (!key || val)",
          "383:      goto compile_error;",
          "384:    else",
          "385:      {",
          "386:        c = &query[pos++];",
          "387:        if (isIdentChar(*c))",
          "388:   {",
          "389:     val = c;",
          "390:     valSize = 1;",
          "391:   }",
          "392:        else",
          "393:   goto compile_error;",
          "394:      }",
          "396:       else if (isIdentChar(*c))",
          "397:  {",
          "398:    if (val)",
          "399:      valSize++;",
          "400:    else if (key)",
          "401:      keySize++;",
          "402:    else",
          "403:      {",
          "404:        key = c;",
          "405:        keySize = 1;",
          "406:      }",
          "408:       else",
          "409:  goto compile_error;",
          "410:     }",
          "411:   int k = 1;",
          "412:   List * l;",
          "413:   for (l = features; l; l = l->tail)",
          "414:     {",
          "415:       FeatureWithImportance * f = l->head;",
          "416:       f->importance = k++;",
          "417:     }",
          "418:   return list_sort(features, (int (*)(void *, void *))cmpKeys);",
          "419:  compile_error:",
          "420:   _lou_logMessage(LOG_ERROR, \"Unexpected character '%c' at position %d\", c, pos);",
          "421:   list_free(features);",
          "422:   return NULL;",
          "429: widestrToStr(const widechar * str, size_t n)",
          "430: {",
          "431:   char * result = malloc((1 + n) * sizeof(char));",
          "432:   size_t k;",
          "433:   for (k = 0; k < n; k++)",
          "434:     result[k] = (char) str[k];",
          "435:   result[k] = '\\0';",
          "436:   return result;",
          "443: analyzeTable(const char * table, int activeOnly)",
          "444: {",
          "445:   static char fileName[MAXSTRING];",
          "446:   char ** resolved;",
          "447:   List * features = NULL;",
          "448:   FileInfo info;",
          "449:   int k;",
          "450:   resolved = _lou_resolveTable(table, NULL);",
          "451:   if (resolved == NULL)",
          "452:     {",
          "453:       _lou_logMessage(LOG_ERROR, \"Cannot resolve table '%s'\", table);",
          "454:       return NULL;",
          "455:     }",
          "456:   sprintf(fileName, \"%s\", *resolved);",
          "457:   k = 0;",
          "458:   for (k = 0; resolved[k]; k++)",
          "459:     free(resolved[k]);",
          "460:   free(resolved);",
          "461:   if (k > 1)",
          "462:     {",
          "463:       _lou_logMessage(LOG_ERROR, \"Table '%s' resolves to more than one file\", table);",
          "464:       return NULL;",
          "465:     }",
          "466:   info.fileName = fileName;",
          "467:   info.encoding = noEncoding;",
          "468:   info.status = 0;",
          "469:   info.lineNumber = 0;",
          "470:   if ((info.in = fopen(info.fileName, \"rb\")))",
          "471:     {",
          "472:       while (_lou_getALine(&info))",
          "473:  {",
          "474:    if (info.linelen == 0);",
          "475:    else if (info.line[0] == '#')",
          "476:      {",
          "477:        if (info.linelen >= 2 && (info.line[1] == '+' || (!activeOnly && info.line[1] == '-')))",
          "478:   {",
          "479:     int active = (info.line[1] == '+');",
          "480:     widechar * key = NULL;",
          "481:     widechar * val = NULL;",
          "482:     size_t keySize = 0;",
          "483:     size_t valSize = 0;",
          "484:     info.linepos = 2;",
          "485:     if (info.linepos < info.linelen && isIdentChar((char) info.line[info.linepos]))",
          "486:       {",
          "487:         key = &info.line[info.linepos];",
          "488:         keySize = 1;",
          "489:         info.linepos++;",
          "490:         while (info.linepos < info.linelen && isIdentChar((char) info.line[info.linepos]))",
          "491:    {",
          "492:      keySize++;",
          "493:      info.linepos++;",
          "494:    }",
          "495:         if (info.linepos < info.linelen && info.line[info.linepos] == ':')",
          "496:    {",
          "497:      info.linepos++;",
          "498:      while (info.linepos < info.linelen && isSpace((char) info.line[info.linepos]))",
          "499:        info.linepos++;",
          "500:      if (info.linepos < info.linelen",
          "501:          && (!active || isIdentChar((char) info.line[info.linepos])))",
          "502:        {",
          "503:          val = &info.line[info.linepos];",
          "504:          valSize = 1;",
          "505:          info.linepos++;",
          "506:          while (info.linepos < info.linelen",
          "507:          && (!active || isIdentChar((char) info.line[info.linepos])))",
          "508:     {",
          "509:       valSize++;",
          "510:       info.linepos++;",
          "511:     }",
          "512:        }",
          "513:      else",
          "514:        goto compile_error;",
          "515:    }",
          "516:         if (info.linepos == info.linelen)",
          "517:    {",
          "518:      char * k = widestrToStr(key, keySize);",
          "519:      char * v = val ? widestrToStr(val, valSize) : NULL;",
          "520:      if (!active) {",
          "522:        int i = 0;",
          "523:        int j = 0;",
          "524:        int space = 1;",
          "525:        while (v[i]) {",
          "526:          if (isSpace(v[i])) {",
          "527:     if (!space) {",
          "528:       v[j++] = ' ';",
          "529:       space = 1;",
          "531:          } else {",
          "532:     v[j++] = v[i];",
          "533:     space = 0;",
          "534:          }",
          "535:          i++;",
          "536:        }",
          "537:        if (j > 0 && v[j-1] == ' ')",
          "538:          j--;",
          "539:        v[j] = '\\0';",
          "540:      }",
          "541:      Feature f = feature_new(k, v);",
          "542:      _lou_logMessage(LOG_DEBUG, \"Table has feature '%s:%s'\", f.key, f.val);",
          "543:      features = list_conj(features, memcpy(malloc(sizeof(f)), &f, sizeof(f)),",
          "544:             NULL, NULL, (void (*)(void *))feature_free);",
          "545:      free(k);",
          "546:      free(v);",
          "547:    }",
          "548:         else",
          "549:    goto compile_error;",
          "550:       }",
          "551:     else",
          "552:       goto compile_error;",
          "554:      }",
          "555:    else",
          "556:      break;",
          "557:  }",
          "558:       fclose(info.in);",
          "559:     }",
          "560:   else",
          "561:     _lou_logMessage (LOG_ERROR, \"Cannot open table '%s'\", info.fileName);",
          "562:   return list_sort(features, (int (*)(void *, void *))cmpKeys);",
          "563:  compile_error:",
          "564:   if (info.linepos < info.linelen)",
          "565:     _lou_logMessage(LOG_ERROR, \"Unexpected character '%c' on line %d, column %d\",",
          "566:         info.line[info.linepos],",
          "567:         info.lineNumber,",
          "568:         info.linepos);",
          "569:   else",
          "570:     _lou_logMessage(LOG_ERROR, \"Unexpected newline on line %d\", info.lineNumber);",
          "571:   list_free(features);",
          "572:   return NULL;",
          "575: static List * tableIndex = NULL;",
          "578: lou_indexTables(const char ** tables)",
          "579: {",
          "580:   const char ** table;",
          "581:   list_free(tableIndex);",
          "582:   tableIndex = NULL;",
          "583:   for (table = tables; *table; table++)",
          "584:     {",
          "585:       _lou_logMessage(LOG_DEBUG, \"Analyzing table %s\", *table);",
          "586:       List * features = analyzeTable(*table, 1);",
          "587:       if (features)",
          "588:  {",
          "589:    TableMeta m = { strdup(*table), features };",
          "590:    tableIndex = list_conj(tableIndex, memcpy(malloc(sizeof(m)), &m, sizeof(m)), NULL, NULL, free);",
          "592:     }",
          "593:   if (!tableIndex)",
          "594:     _lou_logMessage(LOG_WARN, \"No tables were indexed\");",
          "",
          "[Added Lines]",
          "291: parseQuery(const char *query) {",
          "292:  List *features = NULL;",
          "293:  const char *key = NULL;",
          "294:  const char *val = NULL;",
          "295:  size_t keySize = 0;",
          "296:  size_t valSize = 0;",
          "297:  const char *c;",
          "298:  int pos = 0;",
          "299:  while (1) {",
          "300:   c = &query[pos++];",
          "301:   if (isSpace(*c) || (*c == '\\n') | (*c == '\\0')) {",
          "302:    if (key) {",
          "303:     char *k = malloc(keySize + 1);",
          "304:     k[keySize] = '\\0';",
          "305:     memcpy(k, key, keySize);",
          "306:     char *v = NULL;",
          "307:     if (val) {",
          "308:      v = malloc(valSize + 1);",
          "309:      v[valSize] = '\\0';",
          "310:      memcpy(v, val, valSize);",
          "311:     }",
          "312:     FeatureWithImportance f = { feature_new(k, v), 0 };",
          "313:     _lou_logMessage(LOG_DEBUG, \"Query has feature '%s:%s'\", f.feature.key,",
          "314:       f.feature.val);",
          "315:     features = list_conj(features, memcpy(malloc(sizeof(f)), &f, sizeof(f)),",
          "316:       NULL, NULL, (void (*)(void *))feature_free);",
          "317:     free(k);",
          "318:     free(v);",
          "319:     key = val = NULL;",
          "320:     keySize = valSize = 0;",
          "321:    }",
          "322:    if (*c == '\\0') break;",
          "323:   } else if (*c == ':') {",
          "324:    if (!key || val)",
          "325:     goto compile_error;",
          "326:    else {",
          "327:     c = &query[pos++];",
          "328:     if (isIdentChar(*c)) {",
          "329:      val = c;",
          "330:      valSize = 1;",
          "331:     } else",
          "332:      goto compile_error;",
          "333:    }",
          "334:   } else if (isIdentChar(*c)) {",
          "335:    if (val)",
          "336:     valSize++;",
          "337:    else if (key)",
          "338:     keySize++;",
          "339:    else {",
          "340:     key = c;",
          "341:     keySize = 1;",
          "342:    }",
          "343:   } else",
          "344:    goto compile_error;",
          "346:  int k = 1;",
          "347:  List *l;",
          "348:  for (l = features; l; l = l->tail) {",
          "349:   FeatureWithImportance *f = l->head;",
          "350:   f->importance = k++;",
          "352:  return list_sort(features, (int (*)(void *, void *))cmpKeys);",
          "353: compile_error:",
          "354:  _lou_logMessage(LOG_ERROR, \"Unexpected character '%c' at position %d\", c, pos);",
          "355:  list_free(features);",
          "356:  return NULL;",
          "363: widestrToStr(const widechar *str, size_t n) {",
          "364:  char *result = malloc((1 + n) * sizeof(char));",
          "365:  size_t k;",
          "366:  for (k = 0; k < n; k++) result[k] = (char)str[k];",
          "367:  result[k] = '\\0';",
          "368:  return result;",
          "375: analyzeTable(const char *table, int activeOnly) {",
          "376:  static char fileName[MAXSTRING];",
          "377:  char **resolved;",
          "378:  List *features = NULL;",
          "379:  FileInfo info;",
          "380:  int k;",
          "381:  resolved = _lou_resolveTable(table, NULL);",
          "382:  if (resolved == NULL) {",
          "383:   _lou_logMessage(LOG_ERROR, \"Cannot resolve table '%s'\", table);",
          "384:   return NULL;",
          "385:  }",
          "386:  sprintf(fileName, \"%s\", *resolved);",
          "387:  k = 0;",
          "388:  for (k = 0; resolved[k]; k++) free(resolved[k]);",
          "389:  free(resolved);",
          "390:  if (k > 1) {",
          "391:   _lou_logMessage(LOG_ERROR, \"Table '%s' resolves to more than one file\", table);",
          "392:   return NULL;",
          "393:  }",
          "394:  info.fileName = fileName;",
          "395:  info.encoding = noEncoding;",
          "396:  info.status = 0;",
          "397:  info.lineNumber = 0;",
          "398:  if ((info.in = fopen(info.fileName, \"rb\"))) {",
          "399:   while (_lou_getALine(&info)) {",
          "400:    if (info.linelen == 0)",
          "401:     ;",
          "402:    else if (info.line[0] == '#') {",
          "403:     if (info.linelen >= 2 &&",
          "404:       (info.line[1] == '+' || (!activeOnly && info.line[1] == '-'))) {",
          "405:      int active = (info.line[1] == '+');",
          "406:      widechar *key = NULL;",
          "407:      widechar *val = NULL;",
          "408:      size_t keySize = 0;",
          "409:      size_t valSize = 0;",
          "410:      info.linepos = 2;",
          "411:      if (info.linepos < info.linelen &&",
          "412:        isIdentChar((char)info.line[info.linepos])) {",
          "413:       key = &info.line[info.linepos];",
          "414:       keySize = 1;",
          "415:       info.linepos++;",
          "416:       while (info.linepos < info.linelen &&",
          "417:         isIdentChar((char)info.line[info.linepos])) {",
          "418:        keySize++;",
          "419:        info.linepos++;",
          "420:       }",
          "421:       if (info.linepos < info.linelen &&",
          "422:         info.line[info.linepos] == ':') {",
          "423:        info.linepos++;",
          "424:        while (info.linepos < info.linelen &&",
          "425:          isSpace((char)info.line[info.linepos]))",
          "426:         info.linepos++;",
          "427:        if (info.linepos < info.linelen &&",
          "428:          (!active ||",
          "429:            isIdentChar((char)info.line[info.linepos]))) {",
          "430:         val = &info.line[info.linepos];",
          "431:         valSize = 1;",
          "432:         info.linepos++;",
          "433:         while (info.linepos < info.linelen &&",
          "434:           (!active ||",
          "435:             isIdentChar(",
          "436:               (char)info.line[info.linepos]))) {",
          "437:          valSize++;",
          "438:          info.linepos++;",
          "439:         }",
          "440:        } else",
          "441:         goto compile_error;",
          "442:       }",
          "443:       if (info.linepos == info.linelen) {",
          "444:        char *k = widestrToStr(key, keySize);",
          "445:        char *v = val ? widestrToStr(val, valSize) : NULL;",
          "446:        if (!active) {",
          "448:         int i = 0;",
          "449:         int j = 0;",
          "450:         int space = 1;",
          "451:         while (v[i]) {",
          "452:          if (isSpace(v[i])) {",
          "453:           if (!space) {",
          "454:            v[j++] = ' ';",
          "455:            space = 1;",
          "456:           }",
          "457:          } else {",
          "458:           v[j++] = v[i];",
          "459:           space = 0;",
          "460:          }",
          "461:          i++;",
          "462:         }",
          "463:         if (j > 0 && v[j - 1] == ' ') j--;",
          "464:         v[j] = '\\0';",
          "465:        }",
          "466:        Feature f = feature_new(k, v);",
          "467:        _lou_logMessage(",
          "468:          LOG_DEBUG, \"Table has feature '%s:%s'\", f.key, f.val);",
          "469:        features = list_conj(features,",
          "470:          memcpy(malloc(sizeof(f)), &f, sizeof(f)), NULL, NULL,",
          "471:          (void (*)(void *))feature_free);",
          "472:        free(k);",
          "473:        free(v);",
          "474:       } else",
          "475:        goto compile_error;",
          "476:      } else",
          "477:       goto compile_error;",
          "479:    } else",
          "480:     break;",
          "482:   fclose(info.in);",
          "483:  } else",
          "484:   _lou_logMessage(LOG_ERROR, \"Cannot open table '%s'\", info.fileName);",
          "485:  return list_sort(features, (int (*)(void *, void *))cmpKeys);",
          "486: compile_error:",
          "487:  if (info.linepos < info.linelen)",
          "488:   _lou_logMessage(LOG_ERROR, \"Unexpected character '%c' on line %d, column %d\",",
          "489:     info.line[info.linepos], info.lineNumber, info.linepos);",
          "490:  else",
          "491:   _lou_logMessage(LOG_ERROR, \"Unexpected newline on line %d\", info.lineNumber);",
          "492:  list_free(features);",
          "493:  return NULL;",
          "496: static List *tableIndex = NULL;",
          "499: lou_indexTables(const char **tables) {",
          "500:  const char **table;",
          "501:  list_free(tableIndex);",
          "502:  tableIndex = NULL;",
          "503:  for (table = tables; *table; table++) {",
          "504:   _lou_logMessage(LOG_DEBUG, \"Analyzing table %s\", *table);",
          "505:   List *features = analyzeTable(*table, 1);",
          "506:   if (features) {",
          "507:    TableMeta m = { strdup(*table), features };",
          "508:    tableIndex = list_conj(tableIndex, memcpy(malloc(sizeof(m)), &m, sizeof(m)),",
          "509:      NULL, NULL, free);",
          "510:   }",
          "512:  if (!tableIndex) _lou_logMessage(LOG_WARN, \"No tables were indexed\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "600: #ifdef _MSC_VER",
          "601: static List *",
          "628: }",
          "630: static List *",
          "654: }",
          "661: static List *",
          "683: }",
          "685: static void",
          "699: }",
          "718:  }",
          "730: }",
          "748: }",
          "767: }",
          "",
          "[Removed Lines]",
          "602: listDir(List * list, char * dirName)",
          "603: {",
          "604:   static char glob[MAXSTRING];",
          "605:   static char fileName[MAXSTRING];",
          "606:   WIN32_FIND_DATA ffd;",
          "607:   HANDLE hFind;",
          "608:   sprintf(glob, \"%s%c%c\", dirName, DIR_SEP, '*');",
          "609:   hFind = FindFirstFileA(glob, &ffd);",
          "610:   if (hFind == INVALID_HANDLE_VALUE)",
          "611:   {",
          "612:     _lou_logMessage(LOG_WARN, \"%s is not a directory\", dirName);",
          "613:   }",
          "614:   else",
          "615:   {",
          "616:     do",
          "617:     {",
          "618:       if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)",
          "619:       {",
          "620:         sprintf(fileName, \"%s%c%s\", dirName, DIR_SEP, ffd.cFileName);",
          "621:         list = list_conj(list, strdup(fileName), NULL, NULL, free);",
          "622:       }",
          "623:     }",
          "624:     while (FindNextFileA(hFind, &ffd));",
          "625:     FindClose(hFind);",
          "626:   }",
          "627:   return list;",
          "631: listDir(List * list, char * dirName)",
          "632: {",
          "633:   static char fileName[MAXSTRING];",
          "634:   struct stat info;",
          "635:   DIR * dir;",
          "636:   struct dirent * file;",
          "637:   if ((dir = opendir(dirName)))",
          "638:   {",
          "639:     while ((file = readdir(dir)))",
          "640:     {",
          "641:       sprintf(fileName, \"%s%c%s\", dirName, DIR_SEP, file->d_name);",
          "642:       if (stat(fileName, &info) == 0 && !(info.st_mode & S_IFDIR))",
          "643:       {",
          "644:         list = list_conj(list, strdup(fileName), NULL, NULL, free);",
          "645:       }",
          "646:     }",
          "647:     closedir(dir);",
          "648:   }",
          "649:   else",
          "650:   {",
          "651:     _lou_logMessage(LOG_WARN, \"%s is not a directory\", dirName);",
          "652:   }",
          "653:   return list;",
          "662: listFiles(char * searchPath)",
          "663: {",
          "664:   List * list = NULL;",
          "665:   char * dirName;",
          "666:   int pos = 0;",
          "667:   int n;",
          "668:   while (1)",
          "669:     {",
          "670:       for (n = 0; searchPath[pos + n] != '\\0' && searchPath[pos + n] != ','; n++);",
          "671:       dirName = malloc(n + 1);",
          "672:       dirName[n] = '\\0';",
          "673:       memcpy(dirName, &searchPath[pos], n);",
          "674:       list = listDir(list, dirName);",
          "675:       free(dirName);",
          "676:       pos += n;",
          "677:       if (searchPath[pos] == '\\0')",
          "678:  break;",
          "679:       else",
          "680:  pos++;",
          "681:     }",
          "682:   return list;",
          "686: indexTablePath()",
          "687: {",
          "688:   char * searchPath;",
          "689:   List * tables;",
          "690:   const char ** tablesArray;",
          "691:   _lou_logMessage(LOG_WARN, \"Tables have not been indexed yet. Indexing LOUIS_TABLEPATH.\");",
          "692:   searchPath = _lou_getTablePath();",
          "693:   tables = listFiles(searchPath);",
          "694:   tablesArray = (const char **)list_toArray(tables, NULL);",
          "695:   lou_indexTables(tablesArray);",
          "696:   free(searchPath);",
          "697:   list_free(tables);",
          "698:   free((char **) tablesArray);",
          "701: char * EXPORT_CALL",
          "702: lou_findTable(const char * query)",
          "703: {",
          "704:   if (!tableIndex)",
          "705:     indexTablePath();",
          "706:   List * queryFeatures = parseQuery(query);",
          "707:   int bestQuotient = 0;",
          "708:   char * bestMatch = NULL;",
          "709:   List * l;",
          "710:   for (l = tableIndex; l; l = l->tail)",
          "711:     {",
          "712:       TableMeta * table = l->head;",
          "713:       int q = matchFeatureLists(queryFeatures, table->features, 0);",
          "714:       if (q > bestQuotient)",
          "715:  {",
          "716:    bestQuotient = q;",
          "717:    bestMatch = strdup(table->name);",
          "719:     }",
          "720:   if (bestMatch)",
          "721:      {",
          "722:        _lou_logMessage(LOG_INFO, \"Best match: %s (%d)\", bestMatch, bestQuotient);",
          "723:        return bestMatch;",
          "724:      }",
          "725:   else",
          "726:     {",
          "727:       _lou_logMessage(LOG_INFO, \"No table could be found for query '%s'\", query);",
          "728:       return NULL;",
          "729:     }",
          "732: const char * EXPORT_CALL",
          "733: lou_getTableInfo(const char *table, const char *key)",
          "734: {",
          "735:   const char *value = NULL;",
          "736:   List * features = analyzeTable(table, 0);",
          "737:   List * l;",
          "738:   for (l = features; l; l = l->tail)",
          "739:     {",
          "740:       Feature * f = l->head;",
          "741:       if (strcmp(f->key, key) == 0) {",
          "742:  value = strdup(f->val);",
          "743:  list_free(features);",
          "744:  break;",
          "745:       }",
          "746:     }",
          "747:   return value;",
          "750: const char ** EXPORT_CALL",
          "751: lou_listTables()",
          "752: {",
          "753:   const char ** tablesArray;",
          "754:   List * tables = NULL;",
          "755:   List * l;",
          "756:   if (!tableIndex)",
          "757:     indexTablePath();",
          "758:   for (l = tableIndex; l; l = l->tail)",
          "759:     {",
          "760:       TableMeta * table = l->head;",
          "761:       tables = list_conj(tables, strdup(table->name),",
          "762:     (int (*)(void *, void *))strcmp, NULL, NULL);",
          "763:     }",
          "764:   tablesArray = (const char **)list_toArray(tables, NULL);",
          "765:   list_free(tables);",
          "766:   return tablesArray;",
          "",
          "[Added Lines]",
          "520: listDir(List *list, char *dirName) {",
          "521:  static char glob[MAXSTRING];",
          "522:  static char fileName[MAXSTRING];",
          "523:  WIN32_FIND_DATA ffd;",
          "524:  HANDLE hFind;",
          "525:  sprintf(glob, \"%s%c%c\", dirName, DIR_SEP, '*');",
          "526:  hFind = FindFirstFileA(glob, &ffd);",
          "527:  if (hFind == INVALID_HANDLE_VALUE) {",
          "528:   _lou_logMessage(LOG_WARN, \"%s is not a directory\", dirName);",
          "529:  } else {",
          "530:   do {",
          "531:    if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {",
          "532:     sprintf(fileName, \"%s%c%s\", dirName, DIR_SEP, ffd.cFileName);",
          "533:     list = list_conj(list, strdup(fileName), NULL, NULL, free);",
          "534:    }",
          "535:   } while (FindNextFileA(hFind, &ffd));",
          "536:   FindClose(hFind);",
          "537:  }",
          "538:  return list;",
          "542: listDir(List *list, char *dirName) {",
          "543:  static char fileName[MAXSTRING];",
          "544:  struct stat info;",
          "545:  DIR *dir;",
          "546:  struct dirent *file;",
          "547:  if ((dir = opendir(dirName))) {",
          "548:   while ((file = readdir(dir))) {",
          "549:    sprintf(fileName, \"%s%c%s\", dirName, DIR_SEP, file->d_name);",
          "550:    if (stat(fileName, &info) == 0 && !(info.st_mode & S_IFDIR)) {",
          "551:     list = list_conj(list, strdup(fileName), NULL, NULL, free);",
          "552:    }",
          "553:   }",
          "554:   closedir(dir);",
          "555:  } else {",
          "556:   _lou_logMessage(LOG_WARN, \"%s is not a directory\", dirName);",
          "557:  }",
          "558:  return list;",
          "567: listFiles(char *searchPath) {",
          "568:  List *list = NULL;",
          "569:  char *dirName;",
          "570:  int pos = 0;",
          "571:  int n;",
          "572:  while (1) {",
          "573:   for (n = 0; searchPath[pos + n] != '\\0' && searchPath[pos + n] != ','; n++)",
          "574:    ;",
          "575:   dirName = malloc(n + 1);",
          "576:   dirName[n] = '\\0';",
          "577:   memcpy(dirName, &searchPath[pos], n);",
          "578:   list = listDir(list, dirName);",
          "579:   free(dirName);",
          "580:   pos += n;",
          "581:   if (searchPath[pos] == '\\0')",
          "582:    break;",
          "583:   else",
          "584:    pos++;",
          "585:  }",
          "586:  return list;",
          "590: indexTablePath() {",
          "591:  char *searchPath;",
          "592:  List *tables;",
          "593:  const char **tablesArray;",
          "594:  _lou_logMessage(",
          "595:    LOG_WARN, \"Tables have not been indexed yet. Indexing LOUIS_TABLEPATH.\");",
          "596:  searchPath = _lou_getTablePath();",
          "597:  tables = listFiles(searchPath);",
          "598:  tablesArray = (const char **)list_toArray(tables, NULL);",
          "599:  lou_indexTables(tablesArray);",
          "600:  free(searchPath);",
          "601:  list_free(tables);",
          "602:  free((char **)tablesArray);",
          "605: char *EXPORT_CALL",
          "606: lou_findTable(const char *query) {",
          "607:  if (!tableIndex) indexTablePath();",
          "608:  List *queryFeatures = parseQuery(query);",
          "609:  int bestQuotient = 0;",
          "610:  char *bestMatch = NULL;",
          "611:  List *l;",
          "612:  for (l = tableIndex; l; l = l->tail) {",
          "613:   TableMeta *table = l->head;",
          "614:   int q = matchFeatureLists(queryFeatures, table->features, 0);",
          "615:   if (q > bestQuotient) {",
          "616:    bestQuotient = q;",
          "617:    bestMatch = strdup(table->name);",
          "618:   }",
          "619:  }",
          "620:  if (bestMatch) {",
          "621:   _lou_logMessage(LOG_INFO, \"Best match: %s (%d)\", bestMatch, bestQuotient);",
          "622:   return bestMatch;",
          "623:  } else {",
          "624:   _lou_logMessage(LOG_INFO, \"No table could be found for query '%s'\", query);",
          "625:   return NULL;",
          "629: const char *EXPORT_CALL",
          "630: lou_getTableInfo(const char *table, const char *key) {",
          "631:  const char *value = NULL;",
          "632:  List *features = analyzeTable(table, 0);",
          "633:  List *l;",
          "634:  for (l = features; l; l = l->tail) {",
          "635:   Feature *f = l->head;",
          "636:   if (strcmp(f->key, key) == 0) {",
          "637:    value = strdup(f->val);",
          "638:    list_free(features);",
          "639:    break;",
          "640:   }",
          "641:  }",
          "642:  return value;",
          "645: const char **EXPORT_CALL",
          "646: lou_listTables() {",
          "647:  const char **tablesArray;",
          "648:  List *tables = NULL;",
          "649:  List *l;",
          "650:  if (!tableIndex) indexTablePath();",
          "651:  for (l = tableIndex; l; l = l->tail) {",
          "652:   TableMeta *table = l->head;",
          "653:   tables = list_conj(",
          "654:     tables, strdup(table->name), (int (*)(void *, void *))strcmp, NULL, NULL);",
          "655:  }",
          "656:  tablesArray = (const char **)list_toArray(tables, NULL);",
          "657:  list_free(tables);",
          "658:  return tablesArray;",
          "",
          "---------------"
        ],
        "liblouis/pattern.c||liblouis/pattern.c": [
          "File: liblouis/pattern.c -> liblouis/pattern.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: int translation_direction = 1;",
          "38: static TranslationTableCharacter *",
          "70: }",
          "72: static TranslationTableCharacter *",
          "104: }",
          "106: static int",
          "116:   else",
          "121: }",
          "127:  PTN_ERROR,",
          "129:  PTN_START,",
          "",
          "[Removed Lines]",
          "39: back_findCharOrDots (widechar c, int m)",
          "40: {",
          "43:   static TranslationTableCharacter noChar =",
          "44:     { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "45:   static TranslationTableCharacter noDots =",
          "46:     { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "47:   TranslationTableCharacter *notFound;",
          "48:   TranslationTableCharacter *character;",
          "49:   TranslationTableOffset bucket;",
          "50:   unsigned long int makeHash = (unsigned long int) c % HASHNUM;",
          "51:   if (m == 0)",
          "52:     {",
          "53:       bucket = table->characters[makeHash];",
          "54:       notFound = &noChar;",
          "55:     }",
          "56:   else",
          "57:     {",
          "58:       bucket = table->dots[makeHash];",
          "59:       notFound = &noDots;",
          "60:     }",
          "61:   while (bucket)",
          "62:     {",
          "63:       character = (TranslationTableCharacter *) & table->ruleArea[bucket];",
          "64:       if (character->realchar == c)",
          "65:  return character;",
          "66:       bucket = character->next;",
          "67:     }",
          "68:   notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "69:   return notFound;",
          "73: findCharOrDots (widechar c, int m)",
          "74: {",
          "77:   static TranslationTableCharacter noChar =",
          "78:     { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "79:   static TranslationTableCharacter noDots =",
          "80:     { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "81:   TranslationTableCharacter *notFound;",
          "82:   TranslationTableCharacter *character;",
          "83:   TranslationTableOffset bucket;",
          "84:   unsigned long int makeHash = (unsigned long int) c % HASHNUM;",
          "85:   if (m == 0)",
          "86:     {",
          "87:       bucket = table->characters[makeHash];",
          "88:       notFound = &noChar;",
          "89:     }",
          "90:   else",
          "91:     {",
          "92:       bucket = table->dots[makeHash];",
          "93:       notFound = &noDots;",
          "94:     }",
          "95:   while (bucket)",
          "96:     {",
          "97:       character = (TranslationTableCharacter *) & table->ruleArea[bucket];",
          "98:       if (character->realchar == c)",
          "99:  return character;",
          "100:       bucket = character->next;",
          "101:     }",
          "102:   notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "103:   return notFound;",
          "107: checkAttr (const widechar c, const TranslationTableCharacterAttributes",
          "108:     a, int m)",
          "109: {",
          "110:   static widechar prevc = 0;",
          "111:   static TranslationTableCharacterAttributes preva = 0;",
          "112:   if (c != prevc)",
          "113:     {",
          "114:   if(translation_direction)",
          "115:    preva = (findCharOrDots (c, 0))->attributes;",
          "117:    preva = (back_findCharOrDots (c, 1))->attributes;",
          "118:       prevc = c;",
          "119:     }",
          "120:   return ((preva & a) ? 1 : 0);",
          "125: enum pattern_type",
          "126: {",
          "",
          "[Added Lines]",
          "39: back_findCharOrDots(widechar c, int m) {",
          "42:  static TranslationTableCharacter noChar = { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "43:  static TranslationTableCharacter noDots = { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "44:  TranslationTableCharacter *notFound;",
          "45:  TranslationTableCharacter *character;",
          "46:  TranslationTableOffset bucket;",
          "47:  unsigned long int makeHash = (unsigned long int)c % HASHNUM;",
          "48:  if (m == 0) {",
          "49:   bucket = table->characters[makeHash];",
          "50:   notFound = &noChar;",
          "51:  } else {",
          "52:   bucket = table->dots[makeHash];",
          "53:   notFound = &noDots;",
          "54:  }",
          "55:  while (bucket) {",
          "56:   character = (TranslationTableCharacter *)&table->ruleArea[bucket];",
          "57:   if (character->realchar == c) return character;",
          "58:   bucket = character->next;",
          "59:  }",
          "60:  notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "61:  return notFound;",
          "65: findCharOrDots(widechar c, int m) {",
          "68:  static TranslationTableCharacter noChar = { 0, 0, 0, CTC_Space, 32, 32, 32 };",
          "69:  static TranslationTableCharacter noDots = { 0, 0, 0, CTC_Space, B16, B16, B16 };",
          "70:  TranslationTableCharacter *notFound;",
          "71:  TranslationTableCharacter *character;",
          "72:  TranslationTableOffset bucket;",
          "73:  unsigned long int makeHash = (unsigned long int)c % HASHNUM;",
          "74:  if (m == 0) {",
          "75:   bucket = table->characters[makeHash];",
          "76:   notFound = &noChar;",
          "77:  } else {",
          "78:   bucket = table->dots[makeHash];",
          "79:   notFound = &noDots;",
          "80:  }",
          "81:  while (bucket) {",
          "82:   character = (TranslationTableCharacter *)&table->ruleArea[bucket];",
          "83:   if (character->realchar == c) return character;",
          "84:   bucket = character->next;",
          "85:  }",
          "86:  notFound->realchar = notFound->uppercase = notFound->lowercase = c;",
          "87:  return notFound;",
          "91: checkAttr(const widechar c, const TranslationTableCharacterAttributes a, int m) {",
          "92:  static widechar prevc = 0;",
          "93:  static TranslationTableCharacterAttributes preva = 0;",
          "94:  if (c != prevc) {",
          "95:   if (translation_direction)",
          "96:    preva = (findCharOrDots(c, 0))->attributes;",
          "98:    preva = (back_findCharOrDots(c, 1))->attributes;",
          "99:   prevc = c;",
          "100:  }",
          "101:  return ((preva & a) ? 1 : 0);",
          "106: enum pattern_type {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:  PTN_END = 0xffff,",
          "146: };",
          "166: #ifdef CHECK_OUTPUT_DEFINED",
          "",
          "[Removed Lines]",
          "148: #define EXPR_TYPE_IN(at, buffer)        (buffer[(at) + 0])",
          "149: #define EXPR_PRV_IN(at, buffer)         (buffer[(at) + 1])",
          "150: #define EXPR_NXT_IN(at, buffer)         (buffer[(at) + 2])",
          "151: #define EXPR_DATA_0_IN(at, buffer)      (buffer[(at) + 3])",
          "152: #define EXPR_DATA_1_IN(at, buffer)      (buffer[(at) + 4])",
          "153: #define EXPR_DATA_2_IN(at, buffer)      (buffer[(at) + 5])",
          "154: #define EXPR_DATA_IN(at, buffer)        ((widechar*)&buffer[(at) + 3])",
          "155: #define EXPR_CONST_DATA_IN(at, buffer)  ((const widechar*)&buffer[(at) + 3])",
          "157: #define EXPR_TYPE(at)        EXPR_TYPE_IN((at), expr_data)",
          "158: #define EXPR_PRV(at)         EXPR_PRV_IN((at), expr_data)",
          "159: #define EXPR_NXT(at)         EXPR_NXT_IN((at), expr_data)",
          "160: #define EXPR_DATA_0(at)      EXPR_DATA_0_IN((at), expr_data)",
          "161: #define EXPR_DATA_1(at)      EXPR_DATA_1_IN((at), expr_data)",
          "162: #define EXPR_DATA_2(at)      EXPR_DATA_2_IN((at), expr_data)",
          "163: #define EXPR_DATA(at)        EXPR_DATA_IN((at), expr_data)",
          "164: #define EXPR_CONST_DATA(at)  EXPR_CONST_DATA_IN((at), expr_data)",
          "",
          "[Added Lines]",
          "128: #define EXPR_TYPE_IN(at, buffer) (buffer[(at) + 0])",
          "129: #define EXPR_PRV_IN(at, buffer) (buffer[(at) + 1])",
          "130: #define EXPR_NXT_IN(at, buffer) (buffer[(at) + 2])",
          "131: #define EXPR_DATA_0_IN(at, buffer) (buffer[(at) + 3])",
          "132: #define EXPR_DATA_1_IN(at, buffer) (buffer[(at) + 4])",
          "133: #define EXPR_DATA_2_IN(at, buffer) (buffer[(at) + 5])",
          "134: #define EXPR_DATA_IN(at, buffer) ((widechar *)&buffer[(at) + 3])",
          "135: #define EXPR_CONST_DATA_IN(at, buffer) ((const widechar *)&buffer[(at) + 3])",
          "137: #define EXPR_TYPE(at) EXPR_TYPE_IN((at), expr_data)",
          "138: #define EXPR_PRV(at) EXPR_PRV_IN((at), expr_data)",
          "139: #define EXPR_NXT(at) EXPR_NXT_IN((at), expr_data)",
          "140: #define EXPR_DATA_0(at) EXPR_DATA_0_IN((at), expr_data)",
          "141: #define EXPR_DATA_1(at) EXPR_DATA_1_IN((at), expr_data)",
          "142: #define EXPR_DATA_2(at) EXPR_DATA_2_IN((at), expr_data)",
          "143: #define EXPR_DATA(at) EXPR_DATA_IN((at), expr_data)",
          "144: #define EXPR_CONST_DATA(at) EXPR_CONST_DATA_IN((at), expr_data)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171: #endif",
          "175: #define RETURN 2",
          "181: #else",
          "185: #endif",
          "189:  widechar type;",
          "190:  widechar prv;",
          "191:  widechar nxt;",
          "",
          "[Removed Lines]",
          "173: #define START  0",
          "174: #define CALL   1",
          "176: #define SHOW   3",
          "178: #define CHECK_OUTPUT(type, ret, line, msg) \\",
          "179:  { do_output(type, ret, line, input[*input_crs], input_minmax, *input_crs, input_dir, expr_data, expr_crs, not, loop_crs, loop_cnts, msg); }",
          "183: #define CHECK_OUTPUT(type, ret, line, msg) { ; }",
          "187: struct expression",
          "188: {",
          "",
          "[Added Lines]",
          "153: #define START 0",
          "154: #define CALL 1",
          "156: #define SHOW 3",
          "158: #define CHECK_OUTPUT(type, ret, line, msg)                                      \\",
          "159:  {                                                                           \\",
          "160:   do_output(type, ret, line, input[*input_crs], input_minmax, *input_crs, \\",
          "161:     input_dir, expr_data, expr_crs, not, loop_crs, loop_cnts, msg); \\",
          "162:  }",
          "166: #define CHECK_OUTPUT(type, ret, line, msg) \\",
          "167:  { ; }",
          "171: struct expression {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "202: static char spaces[] = \"..............................\";",
          "203: static int space = 30;",
          "207:  int i;",
          "214:   printf(\"%s%d\", &spaces[space], expr_crs);",
          "224:   case PTN_START:",
          "226:    printf(\"START\\t%d\\t%d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));",
          "",
          "[Removed Lines]",
          "205: static void pattern_output_expression(const widechar *expr_data, int expr_crs)",
          "206: {",
          "209:  if(expr_crs == PTN_END)",
          "210:   return;",
          "212:  while(EXPR_TYPE(expr_crs) != PTN_END)",
          "213:  {",
          "215:   if(expr_crs < 100)",
          "216:    printf(\" \");",
          "217:   if(expr_crs < 10)",
          "218:    printf(\" \");",
          "219:   for(i = 0; i < 13 - (30 - space); i++)",
          "220:    printf(\" \");",
          "222:   switch(EXPR_TYPE(expr_crs))",
          "223:   {",
          "",
          "[Added Lines]",
          "188: static void",
          "189: pattern_output_expression(const widechar *expr_data, int expr_crs) {",
          "192:  if (expr_crs == PTN_END) return;",
          "194:  while (EXPR_TYPE(expr_crs) != PTN_END) {",
          "196:   if (expr_crs < 100) printf(\" \");",
          "197:   if (expr_crs < 10) printf(\" \");",
          "198:   for (i = 0; i < 13 - (30 - space); i++) printf(\" \");",
          "200:   switch (EXPR_TYPE(expr_crs)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "229:   case PTN_GROUP:",
          "232:    space--;",
          "235:    pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs));",
          "236:    space++;",
          "239:    break;",
          "241:   case PTN_NOT:",
          "244:    space--;",
          "247:    pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs));",
          "248:    space++;",
          "251:    break;",
          "253:   case PTN_ONE_MORE:",
          "256:    space--;",
          "259:    pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs));",
          "260:    space++;",
          "263:    break;",
          "265:   case PTN_ZERO_MORE:",
          "268:    space--;",
          "271:    pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs));",
          "272:    space++;",
          "275:    break;",
          "277:   case PTN_OPTIONAL:",
          "280:    space--;",
          "283:    pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs));",
          "284:    space++;",
          "287:    break;",
          "289:   case PTN_ALTERNATE:",
          "292:    space--;",
          "295:    pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs));",
          "296:    pattern_output_expression(expr_data, EXPR_DATA_1(expr_crs));",
          "297:    space++;",
          "300:    break;",
          "302:   case PTN_ANY:",
          "",
          "[Removed Lines]",
          "231:    printf(\"(    \\t%d\\t%d\\t-> %d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs));",
          "233:    if(space < 0)",
          "234:     space = 0;",
          "237:    if(space > 30)",
          "238:     space = 30;",
          "243:    printf(\"!    \\t%d\\t%d\\t-> %d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs));",
          "245:    if(space < 0)",
          "246:     space = 0;",
          "249:    if(space > 30)",
          "250:     space = 30;",
          "255:    printf(\"+    \\t%d\\t%d\\t-> %d\\t#%d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));",
          "257:    if(space < 0)",
          "258:     space = 0;",
          "261:    if(space > 30)",
          "262:     space = 30;",
          "267:    printf(\"*    \\t%d\\t%d\\t-> %d\\t#%d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));",
          "269:    if(space < 0)",
          "270:     space = 0;",
          "273:    if(space > 30)",
          "274:     space = 30;",
          "279:    printf(\"?    \\t%d\\t%d\\t-> %d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs));",
          "281:    if(space < 0)",
          "282:     space = 0;",
          "285:    if(space > 30)",
          "286:     space = 30;",
          "291:    printf(\"|    \\t%d\\t%d\\t-> %d\\t-> %d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));",
          "293:    if(space < 0)",
          "294:     space = 0;",
          "298:    if(space > 30)",
          "299:     space = 30;",
          "",
          "[Added Lines]",
          "208:    printf(\"(    \\t%d\\t%d\\t-> %d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),",
          "209:      EXPR_DATA_0(expr_crs));",
          "211:    if (space < 0) space = 0;",
          "214:    if (space > 30) space = 30;",
          "219:    printf(\"!    \\t%d\\t%d\\t-> %d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),",
          "220:      EXPR_DATA_0(expr_crs));",
          "222:    if (space < 0) space = 0;",
          "225:    if (space > 30) space = 30;",
          "230:    printf(\"+    \\t%d\\t%d\\t-> %d\\t#%d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),",
          "231:      EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));",
          "233:    if (space < 0) space = 0;",
          "236:    if (space > 30) space = 30;",
          "241:    printf(\"*    \\t%d\\t%d\\t-> %d\\t#%d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),",
          "242:      EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));",
          "244:    if (space < 0) space = 0;",
          "247:    if (space > 30) space = 30;",
          "252:    printf(\"?    \\t%d\\t%d\\t-> %d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),",
          "253:      EXPR_DATA_0(expr_crs));",
          "255:    if (space < 0) space = 0;",
          "258:    if (space > 30) space = 30;",
          "263:    printf(\"|    \\t%d\\t%d\\t-> %d\\t-> %d\\n\", EXPR_PRV(expr_crs),",
          "264:      EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));",
          "266:    if (space < 0) space = 0;",
          "270:    if (space > 30) space = 30;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "307:   case PTN_ATTRIBUTES:",
          "309:    printf(\"%%    \\t%d\\t%d\\t\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));",
          "329:    puts(\"\");",
          "330:    break;",
          "332:   case PTN_CHARS:",
          "334:    printf(\"[]   \\t%d\\t%d\\t\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));",
          "336:     printf(\"%c\", EXPR_CONST_DATA(expr_crs)[i + 1]);",
          "337:    puts(\"\");",
          "338:    break;",
          "",
          "[Removed Lines]",
          "310:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined0 >> 16))  printf(\"0\");",
          "311:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined1 >> 16))  printf(\"1\");",
          "312:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined2 >> 16))  printf(\"2\");",
          "313:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined3 >> 16))  printf(\"3\");",
          "314:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined4 >> 16))  printf(\"4\");",
          "315:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined5 >> 16))  printf(\"5\");",
          "316:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined6 >> 16))  printf(\"6\");",
          "317:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined7 >> 16))  printf(\"7\");",
          "318:    if(EXPR_DATA_0(expr_crs) & (CTC_EndOfInput >> 16))    printf(\"^\");",
          "319:    if(EXPR_DATA_1(expr_crs) & CTC_Space)         printf(\"_\");",
          "320:    if(EXPR_DATA_1(expr_crs) & CTC_Digit)         printf(\"#\");",
          "321:    if(EXPR_DATA_1(expr_crs) & CTC_Letter)        printf(\"a\");",
          "322:    if(EXPR_DATA_1(expr_crs) & CTC_UpperCase)     printf(\"u\");",
          "323:    if(EXPR_DATA_1(expr_crs) & CTC_LowerCase)     printf(\"l\");",
          "324:    if(EXPR_DATA_1(expr_crs) & CTC_Punctuation)   printf(\".\");",
          "325:    if(EXPR_DATA_1(expr_crs) & CTC_Sign)          printf(\"$\");",
          "326:    if(EXPR_DATA_1(expr_crs) & CTC_SeqDelimiter)  printf(\"~\");",
          "327:    if(EXPR_DATA_1(expr_crs) & CTC_SeqBefore)     printf(\"<\");",
          "328:    if(EXPR_DATA_1(expr_crs) & CTC_SeqAfter)      printf(\">\");",
          "335:    for(i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "[Added Lines]",
          "281:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined0 >> 16)) printf(\"0\");",
          "282:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined1 >> 16)) printf(\"1\");",
          "283:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined2 >> 16)) printf(\"2\");",
          "284:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined3 >> 16)) printf(\"3\");",
          "285:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined4 >> 16)) printf(\"4\");",
          "286:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined5 >> 16)) printf(\"5\");",
          "287:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined6 >> 16)) printf(\"6\");",
          "288:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined7 >> 16)) printf(\"7\");",
          "289:    if (EXPR_DATA_0(expr_crs) & (CTC_EndOfInput >> 16)) printf(\"^\");",
          "290:    if (EXPR_DATA_1(expr_crs) & CTC_Space) printf(\"_\");",
          "291:    if (EXPR_DATA_1(expr_crs) & CTC_Digit) printf(\"#\");",
          "292:    if (EXPR_DATA_1(expr_crs) & CTC_Letter) printf(\"a\");",
          "293:    if (EXPR_DATA_1(expr_crs) & CTC_UpperCase) printf(\"u\");",
          "294:    if (EXPR_DATA_1(expr_crs) & CTC_LowerCase) printf(\"l\");",
          "295:    if (EXPR_DATA_1(expr_crs) & CTC_Punctuation) printf(\".\");",
          "296:    if (EXPR_DATA_1(expr_crs) & CTC_Sign) printf(\"$\");",
          "297:    if (EXPR_DATA_1(expr_crs) & CTC_SeqDelimiter) printf(\"~\");",
          "298:    if (EXPR_DATA_1(expr_crs) & CTC_SeqBefore) printf(\"<\");",
          "299:    if (EXPR_DATA_1(expr_crs) & CTC_SeqAfter) printf(\">\");",
          "306:    for (i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "340:   case PTN_HOOK:",
          "342:    printf(\"@    \\t%d\\t%d\\t\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));",
          "344:     printf(\"%c\", EXPR_CONST_DATA(expr_crs)[i + 1]);",
          "345:    puts(\"\");",
          "346:    break;",
          "",
          "[Removed Lines]",
          "343:    for(i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "[Added Lines]",
          "314:    for (i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "353:   default:",
          "356:    break;",
          "357:   }",
          "",
          "[Removed Lines]",
          "355:    printf(\"%d?    \\t%d\\t%d\\n\", EXPR_TYPE(expr_crs), EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));",
          "",
          "[Added Lines]",
          "326:    printf(\"%d?    \\t%d\\t%d\\n\", EXPR_TYPE(expr_crs), EXPR_PRV(expr_crs),",
          "327:      EXPR_NXT(expr_crs));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "360:  }",
          "362:  printf(\"%s%d\", &spaces[space], expr_crs);",
          "369:  printf(\"END\\t%d\\t%d\\n\", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));",
          "370:  fflush(stdout);",
          "371:  return;",
          "372: }",
          "376:  printf(\"%d    \\tlength\\n\", expr_data[0]);",
          "377:  printf(\"%d    \\tloops\\n\", expr_data[1]);",
          "379:   pattern_output_expression(expr_data, 2);",
          "380: }",
          "384:  int i;",
          "395:   case PTN_GROUP:",
          "",
          "[Removed Lines]",
          "363:  if(expr_crs < 100)",
          "364:   printf(\" \");",
          "365:  if(expr_crs < 10)",
          "366:   printf(\" \");",
          "367:  for(i = 0; i < 13 - (30 - space); i++)",
          "368:   printf(\" \");",
          "374: static void pattern_output(const widechar *expr_data)",
          "375: {",
          "378:  if(expr_data[0] > 0 && expr_data[0] != PTN_END)",
          "382: static void pattern_print_expression(const widechar *expr_data, int expr_crs)",
          "383: {",
          "386:  if(expr_crs == PTN_END)",
          "387:   return;",
          "389:  while(EXPR_TYPE(expr_crs) != PTN_END)",
          "390:  {",
          "391:   switch(EXPR_TYPE(expr_crs))",
          "392:   {",
          "393:   case PTN_START:  break;",
          "",
          "[Added Lines]",
          "335:  if (expr_crs < 100) printf(\" \");",
          "336:  if (expr_crs < 10) printf(\" \");",
          "337:  for (i = 0; i < 13 - (30 - space); i++) printf(\" \");",
          "343: static void",
          "344: pattern_output(const widechar *expr_data) {",
          "347:  if (expr_data[0] > 0 && expr_data[0] != PTN_END)",
          "351: static void",
          "352: pattern_print_expression(const widechar *expr_data, int expr_crs) {",
          "355:  if (expr_crs == PTN_END) return;",
          "357:  while (EXPR_TYPE(expr_crs) != PTN_END) {",
          "358:   switch (EXPR_TYPE(expr_crs)) {",
          "359:   case PTN_START:",
          "360:    break;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "438:   case PTN_ATTRIBUTES:",
          "440:    printf(\"%%[\");",
          "460:    printf(\"]\");",
          "461:    break;",
          "463:   case PTN_CHARS:",
          "466:     printf(\"%c\", EXPR_DATA_1(expr_crs));",
          "469:     printf(\"[\");",
          "471:      printf(\"%c\", EXPR_CONST_DATA(expr_crs)[i + 1]);",
          "472:     printf(\"]\");",
          "473:    }",
          "",
          "[Removed Lines]",
          "441:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined0 >> 16))  printf(\"0\");",
          "442:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined1 >> 16))  printf(\"1\");",
          "443:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined2 >> 16))  printf(\"2\");",
          "444:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined3 >> 16))  printf(\"3\");",
          "445:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined4 >> 16))  printf(\"4\");",
          "446:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined5 >> 16))  printf(\"5\");",
          "447:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined6 >> 16))  printf(\"6\");",
          "448:    if(EXPR_DATA_0(expr_crs) & (CTC_UserDefined7 >> 16))  printf(\"7\");",
          "449:    if(EXPR_DATA_0(expr_crs) & (CTC_EndOfInput >> 16))    printf(\"^\");",
          "450:    if(EXPR_DATA_1(expr_crs) & CTC_Space)         printf(\"_\");",
          "451:    if(EXPR_DATA_1(expr_crs) & CTC_Digit)         printf(\"#\");",
          "452:    if(EXPR_DATA_1(expr_crs) & CTC_Letter)        printf(\"a\");",
          "453:    if(EXPR_DATA_1(expr_crs) & CTC_UpperCase)     printf(\"u\");",
          "454:    if(EXPR_DATA_1(expr_crs) & CTC_LowerCase)     printf(\"l\");",
          "455:    if(EXPR_DATA_1(expr_crs) & CTC_Punctuation)   printf(\".\");",
          "456:    if(EXPR_DATA_1(expr_crs) & CTC_Sign)          printf(\"$\");",
          "457:    if(EXPR_DATA_1(expr_crs) & CTC_SeqDelimiter)  printf(\"~\");",
          "458:    if(EXPR_DATA_1(expr_crs) & CTC_SeqBefore)     printf(\"<\");",
          "459:    if(EXPR_DATA_1(expr_crs) & CTC_SeqAfter)      printf(\">\");",
          "465:    if(EXPR_DATA_0(expr_crs) == 1)",
          "467:    else",
          "468:    {",
          "470:     for(i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "[Added Lines]",
          "408:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined0 >> 16)) printf(\"0\");",
          "409:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined1 >> 16)) printf(\"1\");",
          "410:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined2 >> 16)) printf(\"2\");",
          "411:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined3 >> 16)) printf(\"3\");",
          "412:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined4 >> 16)) printf(\"4\");",
          "413:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined5 >> 16)) printf(\"5\");",
          "414:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined6 >> 16)) printf(\"6\");",
          "415:    if (EXPR_DATA_0(expr_crs) & (CTC_UserDefined7 >> 16)) printf(\"7\");",
          "416:    if (EXPR_DATA_0(expr_crs) & (CTC_EndOfInput >> 16)) printf(\"^\");",
          "417:    if (EXPR_DATA_1(expr_crs) & CTC_Space) printf(\"_\");",
          "418:    if (EXPR_DATA_1(expr_crs) & CTC_Digit) printf(\"#\");",
          "419:    if (EXPR_DATA_1(expr_crs) & CTC_Letter) printf(\"a\");",
          "420:    if (EXPR_DATA_1(expr_crs) & CTC_UpperCase) printf(\"u\");",
          "421:    if (EXPR_DATA_1(expr_crs) & CTC_LowerCase) printf(\"l\");",
          "422:    if (EXPR_DATA_1(expr_crs) & CTC_Punctuation) printf(\".\");",
          "423:    if (EXPR_DATA_1(expr_crs) & CTC_Sign) printf(\"$\");",
          "424:    if (EXPR_DATA_1(expr_crs) & CTC_SeqDelimiter) printf(\"~\");",
          "425:    if (EXPR_DATA_1(expr_crs) & CTC_SeqBefore) printf(\"<\");",
          "426:    if (EXPR_DATA_1(expr_crs) & CTC_SeqAfter) printf(\">\");",
          "432:    if (EXPR_DATA_0(expr_crs) == 1)",
          "434:    else {",
          "436:     for (i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "476:   case PTN_HOOK:",
          "478:    printf(\"@[\");",
          "480:     printf(\"%c\", EXPR_CONST_DATA(expr_crs)[i + 1]);",
          "481:    printf(\"]\");",
          "482:    break;",
          "",
          "[Removed Lines]",
          "479:    for(i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "[Added Lines]",
          "445:    for (i = 0; i < EXPR_DATA_0(expr_crs); i++)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "495:  return;",
          "496: }",
          "501:   pattern_print_expression(expr_data, 2);",
          "502:  puts(\"\");",
          "503: }",
          "505: #ifdef CHECK_OUTPUT_DEFINED",
          "514: }",
          "520: }",
          "541:  case START:",
          "543:   space--;",
          "545:   printf(\"|%s()  \", &spaces[space]);",
          "546:   break;",
          "",
          "[Removed Lines]",
          "498: static void pattern_print(const widechar *expr_data)",
          "499: {",
          "500:  if(expr_data[0] > 0 && expr_data[0] != PTN_END)",
          "507: static void do_padd(const int value)",
          "508: {",
          "509:  if(value < 100000) printf(\" \");",
          "510:  if(value < 10000) printf(\" \");",
          "511:  if(value < 1000) printf(\" \");",
          "512:  if(value < 100) printf(\" \");",
          "513:  if(value < 10) printf(\" \");",
          "516: static void do_pad(const int value)",
          "517: {",
          "518:  if(value < 100) printf(\" \");",
          "519:  if(value < 10) printf(\" \");",
          "522: static void do_output(",
          "523:  const int type,",
          "524:  const int ret,",
          "525:  const int line,",
          "527:  const int input,",
          "528:  const int input_minmax,",
          "529:  const int input_crs,",
          "530:  const int input_dir,",
          "531:  const widechar *expr_data,",
          "532:  const int expr_crs,",
          "533:  const int not,",
          "534:  const int loop_crs,",
          "535:  const int *loop_cnts,",
          "537:  const char *msg)",
          "538: {",
          "539:  switch(type)",
          "540:  {",
          "544:   if(space < 0) space = 0;",
          "",
          "[Added Lines]",
          "464: static void",
          "465: pattern_print(const widechar *expr_data) {",
          "466:  if (expr_data[0] > 0 && expr_data[0] != PTN_END)",
          "473: static void",
          "474: do_padd(const int value) {",
          "475:  if (value < 100000) printf(\" \");",
          "476:  if (value < 10000) printf(\" \");",
          "477:  if (value < 1000) printf(\" \");",
          "478:  if (value < 100) printf(\" \");",
          "479:  if (value < 10) printf(\" \");",
          "482: static void",
          "483: do_pad(const int value) {",
          "484:  if (value < 100) printf(\" \");",
          "485:  if (value < 10) printf(\" \");",
          "488: static void",
          "489: do_output(const int type, const int ret, const int line,",
          "491:   const int input, const int input_minmax, const int input_crs, const int input_dir,",
          "492:   const widechar *expr_data, const int expr_crs, const int not, const int loop_crs,",
          "493:   const int *loop_cnts,",
          "495:   const char *msg) {",
          "496:  switch (type) {",
          "500:   if (space < 0) space = 0;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "555:   printf(\"|%s<%d  \", &spaces[space], ret);",
          "556:   space++;",
          "558:   break;",
          "560:  case SHOW:",
          "",
          "[Removed Lines]",
          "557:   if(space > 31) space = 31;",
          "",
          "[Added Lines]",
          "513:   if (space > 31) space = 31;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "566:  printf(\"%d \", line);",
          "567:  do_padd(line);",
          "586:  }",
          "587:  printf(\"%d \", expr_crs);",
          "588:  do_padd(expr_crs);",
          "591:   printf(\"%c \", input);",
          "592:  else",
          "593:   printf(\"_ \");",
          "596:   printf(\"#   \");",
          "599:   printf(\"%d \", input_crs);",
          "600:   do_pad(input_crs);",
          "601:  }",
          "604:   printf(\"<\");",
          "605:  else",
          "606:   printf(\">\");",
          "607:  printf(\"%d \", input_minmax);",
          "608:  do_pad(input_minmax);",
          "611:   printf(\"!   \");",
          "612:  else",
          "613:   printf(\"    \");",
          "617:   printf(\"%d \", loop_crs);",
          "618:   do_pad(loop_crs);",
          "619:   printf(\"%d \", loop_cnts[EXPR_DATA_1(loop_crs)]);",
          "620:   do_pad(loop_cnts[EXPR_DATA_1(loop_crs)]);",
          "623:   printf(\"-   -   \");",
          "626:   printf(\"%d \", loop_cnts[EXPR_DATA_1(expr_crs)]);",
          "627:   do_pad(loop_cnts[EXPR_DATA_1(expr_crs)]);",
          "630:   printf(\"-   \");",
          "634:  puts(\"\");",
          "635: }",
          "",
          "[Removed Lines]",
          "569:  switch(expr_data[expr_crs])",
          "570:  {",
          "571:  case PTN_ERROR:         printf(\"# \");   break;",
          "572:  case PTN_START:         printf(\"> \");   break;",
          "573:  case PTN_END_OF_INPUT:  printf(\"^ \");   break;",
          "574:  case PTN_ALTERNATE:     printf(\"| \");   break;",
          "575:  case PTN_OPTIONAL:      printf(\"? \");   break;",
          "576:  case PTN_ONE_MORE:      printf(\"+ \");   break;",
          "577:  case PTN_ZERO_MORE:     printf(\"* \");   break;",
          "578:  case PTN_NOT:           printf(\"! \");   break;",
          "579:  case PTN_GROUP:         printf(\"( \");   break;",
          "580:  case PTN_ANY:           printf(\". \");   break;",
          "581:  case PTN_ATTRIBUTES:    printf(\"%% \");  break;",
          "582:  case PTN_CHARS:         printf(\"[ \");   break;",
          "583:  case PTN_HOOK:          printf(\"@ \");   break;",
          "584:  case PTN_END:           printf(\"< \");   break;",
          "585:  default:                printf(\"  \");   break;",
          "590:  if(input > 31 && input < 127)",
          "595:  if(input_crs * input_dir >= input_minmax * input_dir)",
          "597:  else",
          "598:  {",
          "603:  if(input_dir > 0)",
          "610:  if(not)",
          "615:  if(loop_crs)",
          "616:  {",
          "621:  }",
          "622:  else",
          "624:  if(EXPR_TYPE(expr_crs) == PTN_ONE_MORE || EXPR_TYPE(expr_crs) == PTN_ZERO_MORE)",
          "625:  {",
          "628:  }",
          "629:  else",
          "632:  if(msg)",
          "633:   printf(\"%s\", msg);",
          "",
          "[Added Lines]",
          "525:  switch (expr_data[expr_crs]) {",
          "526:  case PTN_ERROR:",
          "527:   printf(\"# \");",
          "528:   break;",
          "529:  case PTN_START:",
          "530:   printf(\"> \");",
          "531:   break;",
          "532:  case PTN_END_OF_INPUT:",
          "533:   printf(\"^ \");",
          "534:   break;",
          "535:  case PTN_ALTERNATE:",
          "536:   printf(\"| \");",
          "537:   break;",
          "538:  case PTN_OPTIONAL:",
          "539:   printf(\"? \");",
          "540:   break;",
          "541:  case PTN_ONE_MORE:",
          "542:   printf(\"+ \");",
          "543:   break;",
          "544:  case PTN_ZERO_MORE:",
          "545:   printf(\"* \");",
          "546:   break;",
          "547:  case PTN_NOT:",
          "548:   printf(\"! \");",
          "549:   break;",
          "550:  case PTN_GROUP:",
          "551:   printf(\"( \");",
          "552:   break;",
          "553:  case PTN_ANY:",
          "554:   printf(\". \");",
          "555:   break;",
          "556:  case PTN_ATTRIBUTES:",
          "557:   printf(\"%% \");",
          "558:   break;",
          "559:  case PTN_CHARS:",
          "560:   printf(\"[ \");",
          "561:   break;",
          "562:  case PTN_HOOK:",
          "563:   printf(\"@ \");",
          "564:   break;",
          "565:  case PTN_END:",
          "566:   printf(\"< \");",
          "567:   break;",
          "568:  default:",
          "569:   printf(\"  \");",
          "570:   break;",
          "575:  if (input > 31 && input < 127)",
          "580:  if (input_crs * input_dir >= input_minmax * input_dir)",
          "582:  else {",
          "587:  if (input_dir > 0)",
          "594:  if (not)",
          "599:  if (loop_crs) {",
          "604:  } else",
          "606:  if (EXPR_TYPE(expr_crs) == PTN_ONE_MORE || EXPR_TYPE(expr_crs) == PTN_ZERO_MORE) {",
          "609:  } else",
          "612:  if (msg) printf(\"%s\", msg);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "657:  widechar *data;",
          "658:  int expr_start, expr_end, expr_sub, expr_crs_prv;",
          "659:  int input_end;",
          "660:  int attrs0, attrs1;",
          "661:  int set, esc, nest, i;",
          "665:  case '(':",
          "670:   (*input_crs)++;",
          "675:   nest = esc = 0;",
          "680:     esc = 1;",
          "681:     continue;",
          "682:    }",
          "685:     nest++;",
          "689:      nest--;",
          "690:     else",
          "691:      break;",
          "",
          "[Removed Lines]",
          "641: static int pattern_compile_1(const widechar *input,",
          "642:                              const int input_max,",
          "643:                              int *input_crs,",
          "644:                              widechar *expr_data,",
          "645:                              const int expr_max,",
          "646:                              widechar *expr_crs,",
          "647:                              widechar *loop_cnts);",
          "649: static int pattern_compile_expression(const widechar *input,",
          "650:                                       const int input_max,",
          "651:                                       int *input_crs,",
          "652:                                       widechar *expr_data,",
          "653:                                       const int expr_max,",
          "654:                                       widechar *expr_crs,",
          "655:                                       widechar *loop_cnts)",
          "656: {",
          "663:  switch(input[*input_crs])",
          "664:  {",
          "667:   if(*expr_crs + 10 >= expr_max)",
          "668:    return 0;",
          "671:   if(*input_crs >= input_max)",
          "672:    return 0;",
          "676:   for(input_end = *input_crs; input_end < input_max; input_end++)",
          "677:   {",
          "678:    if(input[input_end] == '\\\\' && !esc)",
          "679:    {",
          "684:    if(input[input_end] == '(' && !esc)",
          "686:    else if(input[input_end] == ')' && !esc)",
          "687:    {",
          "688:     if(nest)",
          "",
          "[Added Lines]",
          "620: static int",
          "621: pattern_compile_1(const widechar *input, const int input_max, int *input_crs,",
          "622:   widechar *expr_data, const int expr_max, widechar *expr_crs, widechar *loop_cnts);",
          "624: static int",
          "625: pattern_compile_expression(const widechar *input, const int input_max, int *input_crs,",
          "626:   widechar *expr_data, const int expr_max, widechar *expr_crs,",
          "627:   widechar *loop_cnts) {",
          "634:  switch (input[*input_crs]) {",
          "637:   if (*expr_crs + 10 >= expr_max) return 0;",
          "640:   if (*input_crs >= input_max) return 0;",
          "644:   for (input_end = *input_crs; input_end < input_max; input_end++) {",
          "645:    if (input[input_end] == '\\\\' && !esc) {",
          "650:    if (input[input_end] == '(' && !esc)",
          "652:    else if (input[input_end] == ')' && !esc) {",
          "653:     if (nest)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "694:    esc = 0;",
          "695:   }",
          "699:   EXPR_TYPE(*expr_crs) = PTN_GROUP;",
          "",
          "[Removed Lines]",
          "696:   if(input_end >= input_max)",
          "697:    return 0;",
          "",
          "[Added Lines]",
          "661:   if (input_end >= input_max) return 0;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "706:   EXPR_TYPE(expr_sub) = PTN_ERROR;",
          "707:   EXPR_PRV(expr_sub) = PTN_END;",
          "708:   EXPR_NXT(expr_sub) = PTN_END;",
          "710:    return 0;",
          "711:   (*input_crs)++;",
          "",
          "[Removed Lines]",
          "709:   if(!pattern_compile_1(input, input_end, input_crs, expr_data, expr_max, expr_crs, loop_cnts))",
          "",
          "[Added Lines]",
          "673:   if (!pattern_compile_1(input, input_end, input_crs, expr_data, expr_max, expr_crs,",
          "674:      loop_cnts))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "719:  case '!':",
          "724:   (*input_crs)++;",
          "725:   EXPR_TYPE(*expr_crs) = PTN_NOT;",
          "",
          "[Removed Lines]",
          "721:   if(*expr_crs + 10 >= expr_max)",
          "722:    return 0;",
          "",
          "[Added Lines]",
          "686:   if (*expr_crs + 10 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "740:   EXPR_PRV(expr_sub) = expr_start;",
          "741:   EXPR_NXT(expr_sub) = PTN_END;",
          "744:    return 0;",
          "746:   EXPR_NXT(expr_sub) = *expr_crs;",
          "",
          "[Removed Lines]",
          "743:   if(!pattern_compile_expression(input, input_max, input_crs, expr_data, expr_max, expr_crs, loop_cnts))",
          "",
          "[Added Lines]",
          "707:   if (!pattern_compile_expression(input, input_max, input_crs, expr_data, expr_max,",
          "708:      expr_crs, loop_cnts))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "756:  case '+':",
          "760:   EXPR_TYPE(*expr_crs) = PTN_ONE_MORE;",
          "761:   EXPR_DATA_1(*expr_crs) = (*loop_cnts)++;",
          "762:   (*input_crs)++;",
          "",
          "[Removed Lines]",
          "758:   if(*expr_crs + 4 >= expr_max)",
          "759:    return 0;",
          "",
          "[Added Lines]",
          "723:   if (*expr_crs + 4 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "765:  case '*':",
          "769:   EXPR_TYPE(*expr_crs) = PTN_ZERO_MORE;",
          "770:   EXPR_DATA_1(*expr_crs) = (*loop_cnts)++;",
          "771:   (*input_crs)++;",
          "",
          "[Removed Lines]",
          "767:   if(*expr_crs + 4 >= expr_max)",
          "768:    return 0;",
          "",
          "[Added Lines]",
          "731:   if (*expr_crs + 4 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "774:  case '?':",
          "778:   EXPR_TYPE(*expr_crs) = PTN_OPTIONAL;",
          "779:   (*input_crs)++;",
          "780:   return *expr_crs += 4;",
          "782:  case '|':",
          "786:   EXPR_TYPE(*expr_crs) = PTN_ALTERNATE;",
          "787:   (*input_crs)++;",
          "788:   return *expr_crs += 5;",
          "790:  case '.':",
          "794:   EXPR_TYPE(*expr_crs) = PTN_ANY;",
          "795:   (*input_crs)++;",
          "796:   return *expr_crs += 3;",
          "798:  case '%':",
          "803:   (*input_crs)++;",
          "810:    set = 1;",
          "811:    (*input_crs)++;",
          "820:    set = 0;",
          "821:    input_end = *input_crs + 1;",
          "822:   }",
          "",
          "[Removed Lines]",
          "776:   if(*expr_crs + 4 >= expr_max)",
          "777:    return 0;",
          "784:   if(*expr_crs + 5 >= expr_max)",
          "785:    return 0;",
          "792:   if(*expr_crs + 3 >= expr_max)",
          "793:    return 0;",
          "800:   if(*expr_crs + 5 >= expr_max)",
          "801:    return 0;",
          "804:   if(*input_crs >= input_max)",
          "805:    return 0;",
          "808:   if(input[*input_crs] == '[')",
          "809:   {",
          "812:    for(input_end = *input_crs; input_end < input_max; input_end++)",
          "813:    if(input[input_end] == ']')",
          "814:     break;",
          "815:    if(input_end >= input_max)",
          "816:     return 0;",
          "817:   }",
          "818:   else",
          "819:   {",
          "",
          "[Added Lines]",
          "739:   if (*expr_crs + 4 >= expr_max) return 0;",
          "746:   if (*expr_crs + 5 >= expr_max) return 0;",
          "753:   if (*expr_crs + 3 >= expr_max) return 0;",
          "760:   if (*expr_crs + 5 >= expr_max) return 0;",
          "763:   if (*input_crs >= input_max) return 0;",
          "766:   if (input[*input_crs] == '[') {",
          "769:    for (input_end = *input_crs; input_end < input_max; input_end++)",
          "770:     if (input[input_end] == ']') break;",
          "771:    if (input_end >= input_max) return 0;",
          "772:   } else {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "824:   EXPR_TYPE(*expr_crs) = PTN_ATTRIBUTES;",
          "826:   attrs0 = attrs1 = 0;",
          "853:   }",
          "854:   EXPR_DATA_0(*expr_crs) = attrs1;",
          "855:   EXPR_DATA_1(*expr_crs) = attrs0;",
          "859:   return *expr_crs += 5;",
          "861:  case '[':",
          "863:   (*input_crs)++;",
          "868:   esc = 0;",
          "873:     esc = 1;",
          "874:     continue;",
          "875:    }",
          "879:    esc = 0;",
          "880:   }",
          "887:   EXPR_TYPE(*expr_crs) = PTN_CHARS;",
          "889:   esc = 0;",
          "890:   data = EXPR_DATA(*expr_crs);",
          "895:     esc = 1;",
          "896:     continue;",
          "897:    }",
          "",
          "[Removed Lines]",
          "827:   for( ; (*input_crs) < input_end; (*input_crs)++) {",
          "828:   switch(input[*input_crs])",
          "829:   {",
          "830:   case '_':  attrs0 |= CTC_Space;         break;",
          "831:   case '#':  attrs0 |= CTC_Digit;         break;",
          "832:   case 'a':  attrs0 |= CTC_Letter;        break;",
          "833:   case 'u':  attrs0 |= CTC_UpperCase;     break;",
          "834:   case 'l':  attrs0 |= CTC_LowerCase;     break;",
          "835:   case '.':  attrs0 |= CTC_Punctuation;   break;",
          "836:   case '$':  attrs0 |= CTC_Sign;          break;",
          "837:   case '~':  attrs0 |= CTC_SeqDelimiter;  break;",
          "838:   case '<':  attrs0 |= CTC_SeqBefore;     break;",
          "839:   case '>':  attrs0 |= CTC_SeqAfter;      break;",
          "841:   case '0':  attrs1 |= (CTC_UserDefined0 >> 16);  break;",
          "842:   case '1':  attrs1 |= (CTC_UserDefined1 >> 16);  break;",
          "843:   case '2':  attrs1 |= (CTC_UserDefined2 >> 16);  break;",
          "844:   case '3':  attrs1 |= (CTC_UserDefined3 >> 16);  break;",
          "845:   case '4':  attrs1 |= (CTC_UserDefined4 >> 16);  break;",
          "846:   case '5':  attrs1 |= (CTC_UserDefined5 >> 16);  break;",
          "847:   case '6':  attrs1 |= (CTC_UserDefined6 >> 16);  break;",
          "848:   case '7':  attrs1 |= (CTC_UserDefined7 >> 16);  break;",
          "849:   case '^':  attrs1 |= (CTC_EndOfInput >> 16);    break;",
          "851:   default:  return 0;",
          "852:   }",
          "857:   if(set)",
          "858:    (*input_crs)++;",
          "864:   if(*input_crs >= input_max)",
          "865:    return 0;",
          "869:   for(input_end = *input_crs; input_end < input_max; input_end++)",
          "870:   {",
          "871:    if(input[input_end] == '\\\\' && !esc)",
          "872:    {",
          "877:    if(input[input_end] == ']' && !esc)",
          "878:     break;",
          "881:   if(input_end >= input_max)",
          "882:    return 0;",
          "884:   if(*expr_crs + 4 + (input_end - *input_crs) >= expr_max)",
          "885:    return 0;",
          "891:   for(i = 1; *input_crs < input_end; (*input_crs)++)",
          "892:   {",
          "893:    if(input[*input_crs] == '\\\\' && !esc)",
          "894:    {",
          "",
          "[Added Lines]",
          "780:   for (; (*input_crs) < input_end; (*input_crs)++) {",
          "781:    switch (input[*input_crs]) {",
          "782:    case '_':",
          "783:     attrs0 |= CTC_Space;",
          "784:     break;",
          "785:    case '#':",
          "786:     attrs0 |= CTC_Digit;",
          "787:     break;",
          "788:    case 'a':",
          "789:     attrs0 |= CTC_Letter;",
          "790:     break;",
          "791:    case 'u':",
          "792:     attrs0 |= CTC_UpperCase;",
          "793:     break;",
          "794:    case 'l':",
          "795:     attrs0 |= CTC_LowerCase;",
          "796:     break;",
          "797:    case '.':",
          "798:     attrs0 |= CTC_Punctuation;",
          "799:     break;",
          "800:    case '$':",
          "801:     attrs0 |= CTC_Sign;",
          "802:     break;",
          "803:    case '~':",
          "804:     attrs0 |= CTC_SeqDelimiter;",
          "805:     break;",
          "806:    case '<':",
          "807:     attrs0 |= CTC_SeqBefore;",
          "808:     break;",
          "809:    case '>':",
          "810:     attrs0 |= CTC_SeqAfter;",
          "811:     break;",
          "813:    case '0':",
          "814:     attrs1 |= (CTC_UserDefined0 >> 16);",
          "815:     break;",
          "816:    case '1':",
          "817:     attrs1 |= (CTC_UserDefined1 >> 16);",
          "818:     break;",
          "819:    case '2':",
          "820:     attrs1 |= (CTC_UserDefined2 >> 16);",
          "821:     break;",
          "822:    case '3':",
          "823:     attrs1 |= (CTC_UserDefined3 >> 16);",
          "824:     break;",
          "825:    case '4':",
          "826:     attrs1 |= (CTC_UserDefined4 >> 16);",
          "827:     break;",
          "828:    case '5':",
          "829:     attrs1 |= (CTC_UserDefined5 >> 16);",
          "830:     break;",
          "831:    case '6':",
          "832:     attrs1 |= (CTC_UserDefined6 >> 16);",
          "833:     break;",
          "834:    case '7':",
          "835:     attrs1 |= (CTC_UserDefined7 >> 16);",
          "836:     break;",
          "837:    case '^':",
          "838:     attrs1 |= (CTC_EndOfInput >> 16);",
          "839:     break;",
          "841:    default:",
          "842:     return 0;",
          "843:    }",
          "848:   if (set) (*input_crs)++;",
          "854:   if (*input_crs >= input_max) return 0;",
          "858:   for (input_end = *input_crs; input_end < input_max; input_end++) {",
          "859:    if (input[input_end] == '\\\\' && !esc) {",
          "864:    if (input[input_end] == ']' && !esc) break;",
          "867:   if (input_end >= input_max) return 0;",
          "869:   if (*expr_crs + 4 + (input_end - *input_crs) >= expr_max) return 0;",
          "875:   for (i = 1; *input_crs < input_end; (*input_crs)++) {",
          "876:    if (input[*input_crs] == '\\\\' && !esc) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "906:  case '@':",
          "908:   (*input_crs)++;",
          "915:    set = 1;",
          "916:    (*input_crs)++;",
          "925:    set = 0;",
          "926:    input_end = *input_crs + 1;",
          "927:   }",
          "932:   EXPR_TYPE(*expr_crs) = PTN_HOOK;",
          "934:   esc = 0;",
          "935:   data = EXPR_DATA(*expr_crs);",
          "940:     esc = 1;",
          "941:     continue;",
          "942:    }",
          "",
          "[Removed Lines]",
          "909:   if(*input_crs >= input_max)",
          "910:    return 0;",
          "913:   if(input[*input_crs] == '[')",
          "914:   {",
          "917:    for(input_end = *input_crs; input_end < input_max; input_end++)",
          "918:    if(input[input_end] == ']')",
          "919:     break;",
          "920:    if(input_end >= input_max)",
          "921:     return 0;",
          "922:   }",
          "923:   else",
          "924:   {",
          "929:   if(*expr_crs + 4 + (input_end - *input_crs) >= expr_max)",
          "930:    return 0;",
          "936:   for(i = 1; *input_crs < input_end; (*input_crs)++)",
          "937:   {",
          "938:    if(input[*input_crs] == '\\\\' && !esc)",
          "939:    {",
          "",
          "[Added Lines]",
          "891:   if (*input_crs >= input_max) return 0;",
          "894:   if (input[*input_crs] == '[') {",
          "897:    for (input_end = *input_crs; input_end < input_max; input_end++)",
          "898:     if (input[input_end] == ']') break;",
          "899:    if (input_end >= input_max) return 0;",
          "900:   } else {",
          "905:   if (*expr_crs + 4 + (input_end - *input_crs) >= expr_max) return 0;",
          "911:   for (i = 1; *input_crs < input_end; (*input_crs)++) {",
          "912:    if (input[*input_crs] == '\\\\' && !esc) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "945:    data[i++] = (widechar)input[*input_crs];",
          "946:   }",
          "947:   data[0] = i - 1;",
          "950:   return *expr_crs += 4 + data[0];",
          "952:  case '^':",
          "953:  case '$':",
          "957:   EXPR_TYPE(*expr_crs) = PTN_END_OF_INPUT;",
          "958:   (*input_crs)++;",
          "959:   return *expr_crs += 3;",
          "",
          "[Removed Lines]",
          "948:   if(set)",
          "949:    (*input_crs)++;",
          "955:   if(*expr_crs + 3 >= expr_max)",
          "956:    return 0;",
          "",
          "[Added Lines]",
          "921:   if (set) (*input_crs)++;",
          "927:   if (*expr_crs + 3 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "961:  case '\\\\':",
          "963:   (*input_crs)++;",
          "967:  default:",
          "971:   EXPR_TYPE(*expr_crs) = PTN_CHARS;",
          "972:   EXPR_DATA_0(*expr_crs) = 1;",
          "973:   EXPR_DATA_1(*expr_crs) = (widechar)input[*input_crs];",
          "974:   (*input_crs)++;",
          "975:   return *expr_crs += 5;",
          "976:  }",
          "978: }",
          "989:  int expr_group, expr_alt, expr_end;",
          "998:  expr_alt = *expr_crs;",
          "",
          "[Removed Lines]",
          "964:   if(*input_crs >= input_max)",
          "965:    return 0;",
          "969:   if(*expr_crs + 5 >= expr_max)",
          "970:    return 0;",
          "980: static int pattern_insert_alternate(const widechar *input,",
          "981:                                     const int input_max,",
          "982:                                     int *input_crs,",
          "983:                                     widechar *expr_data,",
          "984:                                     const int expr_max,",
          "985:                                     widechar *expr_crs,",
          "986:                                     widechar *loop_cnts,",
          "987:                                     int expr_insert)",
          "988: {",
          "991:  if(EXPR_TYPE(*expr_crs) == PTN_START)",
          "992:   return 0;",
          "994:  if(*expr_crs + 12 >= expr_max)",
          "995:   return 0;",
          "",
          "[Added Lines]",
          "935:   if (*input_crs >= input_max) return 0;",
          "939:   if (*expr_crs + 5 >= expr_max) return 0;",
          "948: static int",
          "949: pattern_insert_alternate(const widechar *input, const int input_max, int *input_crs,",
          "950:   widechar *expr_data, const int expr_max, widechar *expr_crs, widechar *loop_cnts,",
          "951:   int expr_insert) {",
          "954:  if (EXPR_TYPE(*expr_crs) == PTN_START) return 0;",
          "956:  if (*expr_crs + 12 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1012:  EXPR_TYPE(*expr_crs) = PTN_ERROR;",
          "1013:  EXPR_PRV(*expr_crs) = PTN_END;",
          "1014:  EXPR_NXT(*expr_crs) = PTN_END;",
          "1016:   return 0;",
          "1017:  expr_end = *expr_crs;",
          "1018:  EXPR_NXT(expr_end) = expr_group;",
          "1024:  EXPR_TYPE(*expr_crs) = PTN_END;",
          "1025:  EXPR_NXT(*expr_crs) = PTN_END;",
          "",
          "[Removed Lines]",
          "1015:  if(!pattern_compile_1(input, input_max, input_crs, expr_data, expr_max, expr_crs, loop_cnts))",
          "1021:  if(*expr_crs + 3 >= expr_max)",
          "1022:   return 0;",
          "",
          "[Added Lines]",
          "976:  if (!pattern_compile_1(",
          "977:     input, input_max, input_crs, expr_data, expr_max, expr_crs, loop_cnts))",
          "983:  if (*expr_crs + 3 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1059:  int expr_crs_prv;",
          "1064:  expr_crs_prv = *expr_crs;",
          "",
          "[Removed Lines]",
          "1051: static int pattern_compile_1(const widechar *input,",
          "1052:                              const int input_max,",
          "1053:                              int *input_crs,",
          "1054:                              widechar *expr_data,",
          "1055:                              const int expr_max,",
          "1056:                              widechar *expr_crs,",
          "1057:                              widechar *loop_cnts)",
          "1058: {",
          "1061:  if(*expr_crs + 6 >= expr_max)",
          "1062:   return 0;",
          "",
          "[Added Lines]",
          "1012: static int",
          "1013: pattern_compile_1(const widechar *input, const int input_max, int *input_crs,",
          "1014:   widechar *expr_data, const int expr_max, widechar *expr_crs,",
          "1015:   widechar *loop_cnts) {",
          "1018:  if (*expr_crs + 6 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1074:  EXPR_PRV(*expr_crs) = expr_crs_prv;",
          "1075:  EXPR_NXT(*expr_crs) = PTN_END;",
          "1079:   expr_crs_prv = *expr_crs;",
          "1081:    return 0;",
          "1086:   EXPR_NXT(expr_crs_prv) = *expr_crs;",
          "1087:   EXPR_TYPE(*expr_crs) = PTN_END;",
          "1088:   EXPR_PRV(*expr_crs) = expr_crs_prv;",
          "",
          "[Removed Lines]",
          "1077:  while(*input_crs < input_max)",
          "1078:  {",
          "1080:   if(!pattern_compile_expression(input, input_max, input_crs, expr_data, expr_max, expr_crs, loop_cnts))",
          "1084:   if(*expr_crs + 3 >= expr_max)",
          "1085:    return 0;",
          "",
          "[Added Lines]",
          "1033:  while (*input_crs < input_max) {",
          "1035:   if (!pattern_compile_expression(input, input_max, input_crs, expr_data, expr_max,",
          "1036:      expr_crs, loop_cnts))",
          "1040:   if (*expr_crs + 3 >= expr_max) return 0;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1109:  int expr_start, expr_end, expr_prv, expr_sub;",
          "1116:     return 0;",
          "1117:   }",
          "1128:    expr_sub = EXPR_PRV(expr_at);",
          "1131:    expr_prv = EXPR_PRV(expr_sub);",
          "",
          "[Removed Lines]",
          "1107: static int pattern_compile_2(widechar *expr_data, int expr_at, const int expr_max, widechar *expr_crs)",
          "1108: {",
          "1111:  while(EXPR_TYPE(expr_at) != PTN_END)",
          "1112:  {",
          "1113:   if(EXPR_TYPE(expr_at) == PTN_GROUP || EXPR_TYPE(expr_at) == PTN_NOT)",
          "1114:   {",
          "1115:    if(!pattern_compile_2(expr_data, EXPR_DATA_0(expr_at), expr_max, expr_crs))",
          "1119:   if(   EXPR_TYPE(expr_at) == PTN_ZERO_MORE",
          "1120:      || EXPR_TYPE(expr_at) == PTN_ONE_MORE",
          "1121:      || EXPR_TYPE(expr_at) == PTN_OPTIONAL)",
          "1122:   {",
          "1123:    if(*expr_crs + 6 >= expr_max)",
          "1124:     return 0;",
          "1129:    if(EXPR_TYPE(expr_sub) == PTN_START)",
          "1130:     return 0;",
          "",
          "[Added Lines]",
          "1062: static int",
          "1063: pattern_compile_2(",
          "1064:   widechar *expr_data, int expr_at, const int expr_max, widechar *expr_crs) {",
          "1067:  while (EXPR_TYPE(expr_at) != PTN_END) {",
          "1068:   if (EXPR_TYPE(expr_at) == PTN_GROUP || EXPR_TYPE(expr_at) == PTN_NOT) {",
          "1069:    if (!pattern_compile_2(expr_data, EXPR_DATA_0(expr_at), expr_max, expr_crs))",
          "1073:   if (EXPR_TYPE(expr_at) == PTN_ZERO_MORE || EXPR_TYPE(expr_at) == PTN_ONE_MORE ||",
          "1074:     EXPR_TYPE(expr_at) == PTN_OPTIONAL) {",
          "1075:    if (*expr_crs + 6 >= expr_max) return 0;",
          "1080:    if (EXPR_TYPE(expr_sub) == PTN_START) return 0;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1167:  int expr_mrk, expr_start, expr_end, expr_sub_start, expr_sub_end;",
          "1178:     return 0;",
          "1179:   }",
          "1188:    expr_mrk = EXPR_PRV(expr_at);",
          "1191:    expr_sub_end = expr_mrk;",
          "1194:    expr_sub_start = EXPR_NXT(expr_mrk);",
          "",
          "[Removed Lines]",
          "1165: static int pattern_compile_3(widechar *expr_data, int expr_at, const int expr_max, widechar *expr_crs)",
          "1166: {",
          "1169:  while(EXPR_TYPE(expr_at) != PTN_END)",
          "1170:  {",
          "1171:   if(   EXPR_TYPE(expr_at) == PTN_GROUP",
          "1172:      || EXPR_TYPE(expr_at) == PTN_NOT",
          "1173:      || EXPR_TYPE(expr_at) == PTN_OPTIONAL",
          "1174:      || EXPR_TYPE(expr_at) == PTN_ZERO_MORE",
          "1175:      || EXPR_TYPE(expr_at) == PTN_ONE_MORE)",
          "1176:   {",
          "1177:    if(!pattern_compile_3(expr_data, EXPR_DATA_0(expr_at), expr_max, expr_crs))",
          "1181:   if(EXPR_TYPE(expr_at) == PTN_ALTERNATE)",
          "1182:   {",
          "1183:    if(*expr_crs + 12 >= expr_max)",
          "1184:     return 0;",
          "1189:    if(EXPR_TYPE(expr_mrk) == PTN_START)",
          "1190:     return 0;",
          "1192:    while(EXPR_TYPE(expr_mrk) != PTN_START)",
          "1193:     expr_mrk = EXPR_PRV(expr_mrk);",
          "",
          "[Added Lines]",
          "1115: static int",
          "1116: pattern_compile_3(",
          "1117:   widechar *expr_data, int expr_at, const int expr_max, widechar *expr_crs) {",
          "1120:  while (EXPR_TYPE(expr_at) != PTN_END) {",
          "1121:   if (EXPR_TYPE(expr_at) == PTN_GROUP || EXPR_TYPE(expr_at) == PTN_NOT ||",
          "1122:     EXPR_TYPE(expr_at) == PTN_OPTIONAL ||",
          "1123:     EXPR_TYPE(expr_at) == PTN_ZERO_MORE ||",
          "1124:     EXPR_TYPE(expr_at) == PTN_ONE_MORE) {",
          "1125:    if (!pattern_compile_3(expr_data, EXPR_DATA_0(expr_at), expr_max, expr_crs))",
          "1129:   if (EXPR_TYPE(expr_at) == PTN_ALTERNATE) {",
          "1130:    if (*expr_crs + 12 >= expr_max) return 0;",
          "1135:    if (EXPR_TYPE(expr_mrk) == PTN_START) return 0;",
          "1137:    while (EXPR_TYPE(expr_mrk) != PTN_START) expr_mrk = EXPR_PRV(expr_mrk);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1220:    expr_mrk = EXPR_NXT(expr_at);",
          "1222:     return 0;",
          "1223:    expr_sub_start = expr_mrk;",
          "1225:     expr_mrk = EXPR_NXT(expr_mrk);",
          "1226:    expr_sub_end = EXPR_PRV(expr_mrk);",
          "",
          "[Removed Lines]",
          "1221:    if(EXPR_TYPE(expr_mrk) == PTN_END || EXPR_TYPE(expr_mrk) == PTN_ALTERNATE)",
          "1224:    while(EXPR_TYPE(expr_mrk) != PTN_END && EXPR_TYPE(expr_mrk) != PTN_ALTERNATE)",
          "",
          "[Added Lines]",
          "1165:    if (EXPR_TYPE(expr_mrk) == PTN_END || EXPR_TYPE(expr_mrk) == PTN_ALTERNATE)",
          "1168:    while (EXPR_TYPE(expr_mrk) != PTN_END && EXPR_TYPE(expr_mrk) != PTN_ALTERNATE)",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1254:     return 0;",
          "1255:   }",
          "",
          "[Removed Lines]",
          "1253:    if(!pattern_compile_3(expr_data, EXPR_DATA_1(expr_at), expr_max, expr_crs))",
          "",
          "[Added Lines]",
          "1197:    if (!pattern_compile_3(expr_data, EXPR_DATA_1(expr_at), expr_max, expr_crs))",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1260:  return 1;",
          "1261: }",
          "1265:  int input_crs;",
          "1267:  table = t;",
          "",
          "[Removed Lines]",
          "1263: int EXPORT_CALL _lou_pattern_compile(const widechar *input, const int input_max, widechar *expr_data, const int expr_max, const TranslationTableHeader *t)",
          "1264: {",
          "",
          "[Added Lines]",
          "1207: int EXPORT_CALL",
          "1208: _lou_pattern_compile(const widechar *input, const int input_max, widechar *expr_data,",
          "1209:   const int expr_max, const TranslationTableHeader *t) {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1269:  expr_data[0] = 2;",
          "1270:  expr_data[1] = 0;",
          "1273:   return 0;",
          "1276:  expr_data[0] += 3;",
          "1284:  return expr_data[0];",
          "1285: }",
          "1293:  widechar expr_swap;",
          "1297:  case PTN_ALTERNATE:",
          "1299:   pattern_reverse_expression(expr_data, EXPR_DATA_0(expr_at));",
          "",
          "[Removed Lines]",
          "1272:  if(!pattern_compile_1(input, input_max, &input_crs, expr_data, expr_max, &expr_data[0], &expr_data[1]))",
          "1278:  if(!pattern_compile_2(expr_data, 2, expr_max, &expr_data[0]))",
          "1279:   return 0;",
          "1281:  if(!pattern_compile_3(expr_data, 2, expr_max, &expr_data[0]))",
          "1282:   return 0;",
          "1289: static void pattern_reverse_expression(widechar *expr_data, const int expr_start);",
          "1291: static void pattern_reverse_branch(widechar *expr_data, const int expr_at)",
          "1292: {",
          "1295:  switch(EXPR_TYPE(expr_at))",
          "1296:  {",
          "",
          "[Added Lines]",
          "1217:  if (!pattern_compile_1(input, input_max, &input_crs, expr_data, expr_max,",
          "1218:     &expr_data[0], &expr_data[1]))",
          "1224:  if (!pattern_compile_2(expr_data, 2, expr_max, &expr_data[0])) return 0;",
          "1226:  if (!pattern_compile_3(expr_data, 2, expr_max, &expr_data[0])) return 0;",
          "1233: static void",
          "1234: pattern_reverse_expression(widechar *expr_data, const int expr_start);",
          "1236: static void",
          "1237: pattern_reverse_branch(widechar *expr_data, const int expr_at) {",
          "1240:  switch (EXPR_TYPE(expr_at)) {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1311:  }",
          "1312: }",
          "1316:  widechar expr_end, expr_crs, expr_prv;",
          "1318:  expr_end = EXPR_NXT(expr_start);",
          "1328:  expr_crs = EXPR_PRV(expr_end);",
          "1329:  expr_prv = EXPR_PRV(expr_crs);",
          "1332:  EXPR_NXT(expr_start) = expr_crs;",
          "1337:  pattern_reverse_branch(expr_data, expr_crs);",
          "1342:   expr_crs = expr_prv;",
          "1343:   expr_prv = EXPR_PRV(expr_prv);",
          "",
          "[Removed Lines]",
          "1314: static void pattern_reverse_expression(widechar *expr_data, const int expr_start)",
          "1315: {",
          "1321:  if(EXPR_TYPE(expr_end) == PTN_END)",
          "1322:   return;",
          "1325:  while(EXPR_TYPE(expr_end) != PTN_END)",
          "1326:   expr_end = EXPR_NXT(expr_end);",
          "1333:  EXPR_PRV(expr_crs)   = expr_start;",
          "1334:  EXPR_NXT(expr_crs)   = expr_prv;",
          "1339:  while(expr_prv != expr_start)",
          "1340:  {",
          "",
          "[Added Lines]",
          "1258: static void",
          "1259: pattern_reverse_expression(widechar *expr_data, const int expr_start) {",
          "1265:  if (EXPR_TYPE(expr_end) == PTN_END) return;",
          "1268:  while (EXPR_TYPE(expr_end) != PTN_END) expr_end = EXPR_NXT(expr_end);",
          "1275:  EXPR_PRV(expr_crs) = expr_start;",
          "1276:  EXPR_NXT(expr_crs) = expr_prv;",
          "1281:  while (expr_prv != expr_start) {",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1356:  EXPR_PRV(expr_end) = expr_crs;",
          "1357: }",
          "1361:  pattern_reverse_expression(expr_data, 2);",
          "1362: }",
          "1368:  int expr_cnt, i;",
          "1370:  expr_cnt = expr_data[0] + 1;",
          "1378:  return 1;",
          "1379: }",
          "1383:  int attrs;",
          "1385:  attrs = ((expr_data[0] << 16) | expr_data[1]) & ~(CTC_EndOfInput | CTC_EmpMatch);",
          "1388:  return 1;",
          "1389: }",
          "1405:  int input_crs_prv, input_start, attrs, ret, i;",
          "1406:  const widechar *data;",
          "",
          "[Removed Lines]",
          "1359: void EXPORT_CALL _lou_pattern_reverse(widechar *expr_data)",
          "1360: {",
          "1366: static int pattern_check_chars(const widechar input_char, const widechar *expr_data)",
          "1367: {",
          "1372:  for(i = 1; i < expr_cnt; i++)",
          "1373:  if(input_char == expr_data[i])",
          "1374:   break;",
          "1376:  if(i == expr_cnt)",
          "1377:   return 0;",
          "1381: static int pattern_check_attrs(const widechar input_char, const widechar *expr_data)",
          "1382: {",
          "1386:  if(!checkAttr(input_char, attrs, 0))",
          "1387:   return 0;",
          "1391: static int pattern_check_expression(",
          "1392:  const widechar * const input,",
          "1393:  int *input_crs,",
          "1394:  const int input_minmax,",
          "1395:  const int input_dir,",
          "1396:  const widechar * const expr_data,",
          "1397:  int (*hook)(const widechar input, const int data_len),",
          "1398:  widechar *hook_data,",
          "1399:  const int hook_max,",
          "1400:  int expr_crs,",
          "1401:  int not,",
          "1402:  int loop_crs,",
          "1403:  int *loop_cnts)",
          "1404: {",
          "",
          "[Added Lines]",
          "1300: void EXPORT_CALL",
          "1301: _lou_pattern_reverse(widechar *expr_data) {",
          "1307: static int",
          "1308: pattern_check_chars(const widechar input_char, const widechar *expr_data) {",
          "1313:  for (i = 1; i < expr_cnt; i++)",
          "1314:   if (input_char == expr_data[i]) break;",
          "1316:  if (i == expr_cnt) return 0;",
          "1320: static int",
          "1321: pattern_check_attrs(const widechar input_char, const widechar *expr_data) {",
          "1325:  if (!checkAttr(input_char, attrs, 0)) return 0;",
          "1329: static int",
          "1330: pattern_check_expression(const widechar *const input, int *input_crs,",
          "1331:   const int input_minmax, const int input_dir, const widechar *const expr_data,",
          "1332:   int (*hook)(const widechar input, const int data_len), widechar *hook_data,",
          "1333:   const int hook_max, int expr_crs, int not, int loop_crs, int *loop_cnts) {",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1413:  CHECK_OUTPUT(START, 0, __LINE__, \"check start\")",
          "1436:   }",
          "1443:    case PTN_ATTRIBUTES:",
          "1445:     attrs = (EXPR_DATA_0(expr_crs) << 16);",
          "1451:       return 0;",
          "1452:      }",
          "1454:      return 1;",
          "1455:     }",
          "1457:     return 0;",
          "1459:    case PTN_ANY:",
          "",
          "[Removed Lines]",
          "1415:  while(!(EXPR_TYPE(expr_crs) == PTN_END && EXPR_TYPE(expr_crs) == PTN_END))",
          "1416:  {",
          "1418:   if(EXPR_TYPE(expr_crs) == PTN_END_OF_INPUT)",
          "1419:   {",
          "1420:   if(*input_crs * input_dir >= input_minmax * input_dir)",
          "1421:   {",
          "1422:    if(not)",
          "1423:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"end of input failed:  no input and not \")",
          "1424:    else",
          "1425:     CHECK_OUTPUT(RETURN, 1, __LINE__, \"end of input passed:  no input\")",
          "1426:    return !not;",
          "1427:   }",
          "1428:   else",
          "1429:   {",
          "1430:    if(not)",
          "1431:     CHECK_OUTPUT(RETURN, 1, __LINE__, \"end of input passed:  input and not\")",
          "1432:    else",
          "1433:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"end of input failed:  input\")",
          "1434:    return not;",
          "1435:   }",
          "1439:   if(*input_crs * input_dir >= input_minmax * input_dir)",
          "1440:   {",
          "1441:    switch(EXPR_TYPE(expr_crs))",
          "1442:    {",
          "1446:     if(attrs & CTC_EndOfInput)",
          "1447:     {",
          "1448:      if(not)",
          "1449:      {",
          "1450:       CHECK_OUTPUT(RETURN, 0, __LINE__, \"attributes failed:  end of input attribute:  not\")",
          "1453:      CHECK_OUTPUT(RETURN, 1, __LINE__, \"attributes passed:  end of input attribute\")",
          "1456:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"attributes failed:  no end of input attribute\")",
          "",
          "[Added Lines]",
          "1344:  while (!(EXPR_TYPE(expr_crs) == PTN_END && EXPR_TYPE(expr_crs) == PTN_END)) {",
          "1346:   if (EXPR_TYPE(expr_crs) == PTN_END_OF_INPUT) {",
          "1347:    if (*input_crs * input_dir >= input_minmax * input_dir) {",
          "1348:     if (not)",
          "1349:      CHECK_OUTPUT(RETURN, 0, __LINE__,",
          "1350:        \"end of input failed:  no input and not \")",
          "1351:     else",
          "1352:      CHECK_OUTPUT(RETURN, 1, __LINE__, \"end of input passed:  no input\")",
          "1353:     return !not;",
          "1354:    } else {",
          "1355:     if (not)",
          "1356:      CHECK_OUTPUT(",
          "1357:        RETURN, 1, __LINE__, \"end of input passed:  input and not\")",
          "1358:     else",
          "1359:      CHECK_OUTPUT(RETURN, 0, __LINE__, \"end of input failed:  input\")",
          "1360:     return not;",
          "1361:    }",
          "1365:   if (*input_crs * input_dir >= input_minmax * input_dir) {",
          "1366:    switch (EXPR_TYPE(expr_crs)) {",
          "1370:     if (attrs & CTC_EndOfInput) {",
          "1371:      if (not) {",
          "1372:       CHECK_OUTPUT(RETURN, 0, __LINE__,",
          "1373:         \"attributes failed:  end of input attribute:  not\")",
          "1376:      CHECK_OUTPUT(RETURN, 1, __LINE__,",
          "1377:        \"attributes passed:  end of input attribute\")",
          "1380:     CHECK_OUTPUT(RETURN, 0, __LINE__,",
          "1381:       \"attributes failed:  no end of input attribute\")",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1466:    CHECK_OUTPUT(SHOW, 0, __LINE__, \"no input\")",
          "1467:   }",
          "1472:   case PTN_START:",
          "",
          "[Removed Lines]",
          "1469:   switch(EXPR_TYPE(expr_crs))",
          "1470:   {",
          "",
          "[Added Lines]",
          "1394:   switch (EXPR_TYPE(expr_crs)) {",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1495:   case PTN_ZERO_MORE:",
          "1500:     loop_cnts[EXPR_DATA_1(loop_crs)]++;",
          "1501:     CHECK_OUTPUT(SHOW, 0, __LINE__, \"loop again\")",
          "1508:      CHECK_OUTPUT(SHOW, 0, __LINE__, \"loop already running\")",
          "1509:      goto loop_next;",
          "1510:     }",
          "",
          "[Removed Lines]",
          "1498:    if(expr_crs == loop_crs)",
          "1499:    {",
          "1502:    }",
          "1503:    else",
          "1504:    {",
          "1506:     if(loop_cnts[EXPR_DATA_1(expr_crs)])",
          "1507:     {",
          "",
          "[Added Lines]",
          "1422:    if (expr_crs == loop_crs) {",
          "1425:    } else {",
          "1427:     if (loop_cnts[EXPR_DATA_1(expr_crs)]) {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1519:    input_crs_prv = *input_crs;",
          "1523:     CHECK_OUTPUT(RETURN, 1, __LINE__, \"loop passed\")",
          "1524:     return 1;",
          "1525:    }",
          "",
          "[Removed Lines]",
          "1520:    ret = pattern_check_expression(input, input_crs, input_minmax, input_dir, expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not, loop_crs, loop_cnts);",
          "1521:    if(ret)",
          "1522:    {",
          "",
          "[Added Lines]",
          "1440:    ret = pattern_check_expression(input, input_crs, input_minmax, input_dir,",
          "1441:      expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not,",
          "1442:      loop_crs, loop_cnts);",
          "1443:    if (ret) {",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1530:    loop_cnts[EXPR_DATA_1(loop_crs)]--;",
          "1535:      CHECK_OUTPUT(RETURN, 0, __LINE__, \"loop+ failed\")",
          "1536:      return 0;",
          "1539:      CHECK_OUTPUT(SHOW, 0, __LINE__, \"loop+ passed\")",
          "1540:    }",
          "1544:    expr_crs = EXPR_NXT(expr_crs);",
          "1545:    CHECK_OUTPUT(SHOW, 0, __LINE__, \"loop next\")",
          "1546:    break;",
          "",
          "[Removed Lines]",
          "1531:    if(EXPR_TYPE(expr_crs) == PTN_ONE_MORE)",
          "1532:    {",
          "1533:     if(loop_cnts[EXPR_DATA_1(loop_crs)] < 1)",
          "1534:     {",
          "1537:     }",
          "1538:     else",
          "1543:    loop_next:",
          "",
          "[Added Lines]",
          "1452:    if (EXPR_TYPE(expr_crs) == PTN_ONE_MORE) {",
          "1453:     if (loop_cnts[EXPR_DATA_1(loop_crs)] < 1) {",
          "1456:     } else",
          "1461:   loop_next:",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1554:    CHECK_OUTPUT(CALL, 0, __LINE__, \"option start\")",
          "1557:     CHECK_OUTPUT(RETURN, 1, __LINE__, \"option passed\")",
          "1558:     return 1;",
          "1559:    }",
          "",
          "[Removed Lines]",
          "1555:    if(pattern_check_expression(input, input_crs, input_minmax, input_dir, expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not, loop_crs, loop_cnts))",
          "1556:    {",
          "",
          "[Added Lines]",
          "1473:    if (pattern_check_expression(input, input_crs, input_minmax, input_dir,",
          "1474:       expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not,",
          "1475:       loop_crs, loop_cnts)) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1574:    CHECK_OUTPUT(CALL, 0, __LINE__, \"or 1 start\")",
          "1577:     CHECK_OUTPUT(RETURN, 1, __LINE__, \"or 1 passed\")",
          "1578:     return 1;",
          "1579:    }",
          "",
          "[Removed Lines]",
          "1575:    if(pattern_check_expression(input, input_crs, input_minmax, input_dir, expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not, loop_crs, loop_cnts))",
          "1576:    {",
          "",
          "[Added Lines]",
          "1494:    if (pattern_check_expression(input, input_crs, input_minmax, input_dir,",
          "1495:       expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not,",
          "1496:       loop_crs, loop_cnts)) {",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1595:   case PTN_ATTRIBUTES:",
          "1597:    ret = pattern_check_attrs(input[*input_crs], EXPR_CONST_DATA(expr_crs));",
          "1600:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"attributes failed:  not\");",
          "1601:     return 0;",
          "1602:    }",
          "1605:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"attributes failed\");",
          "1606:     return 0;",
          "1607:    }",
          "",
          "[Removed Lines]",
          "1598:    if(ret && not)",
          "1599:    {",
          "1603:    if(!ret && !not)",
          "1604:    {",
          "",
          "[Added Lines]",
          "1518:    if (ret && not) {",
          "1522:    if (!ret && !not) {",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1613:   case PTN_CHARS:",
          "1615:    ret = pattern_check_chars(input[*input_crs], EXPR_CONST_DATA(expr_crs));",
          "1618:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"chars failed:  not\");",
          "1619:     return 0;",
          "1620:    }",
          "1623:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"chars failed\");",
          "1624:     return 0;",
          "1625:    }",
          "",
          "[Removed Lines]",
          "1616:    if(ret && not)",
          "1617:    {",
          "1621:    if(!ret && !not)",
          "1622:    {",
          "",
          "[Added Lines]",
          "1534:    if (ret && not) {",
          "1538:    if (!ret && !not) {",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1631:   case PTN_HOOK:",
          "1635:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"hook failed:  NULL\");",
          "1636:     return 0;",
          "1637:    }",
          "1640:    data = EXPR_CONST_DATA(expr_crs);",
          "1645:    ret = hook(input[*input_crs], data[0]);",
          "1648:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"hook failed:  not\");",
          "1649:     return 0;",
          "1650:    }",
          "1653:     CHECK_OUTPUT(RETURN, 0, __LINE__, \"hook failed\");",
          "1654:     return 0;",
          "1655:    }",
          "",
          "[Removed Lines]",
          "1633:    if(hook == NULL)",
          "1634:    {",
          "1641:    for(i = 0; i < data[0]; i++)",
          "1642:     hook_data[i] = data[i + 1];",
          "1646:    if(ret && not)",
          "1647:    {",
          "1651:    if(!ret && !not)",
          "1652:    {",
          "",
          "[Added Lines]",
          "1549:    if (hook == NULL) {",
          "1556:    for (i = 0; i < data[0]; i++) hook_data[i] = data[i + 1];",
          "1560:    if (ret && not) {",
          "1564:    if (!ret && !not) {",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1658:    expr_crs = EXPR_NXT(expr_crs);",
          "1659:    break;",
          "1663:   default:",
          "",
          "[Removed Lines]",
          "1661:   case PTN_END:  break;",
          "",
          "[Added Lines]",
          "1573:   case PTN_END:",
          "1574:    break;",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1667:   }",
          "1672:    CHECK_OUTPUT(SHOW, 0, __LINE__, \"end\")",
          "1678:    expr_crs = EXPR_NXT(expr_crs);",
          "1683:     CHECK_OUTPUT(SHOW, 0, __LINE__, \"end loop\")",
          "1688:      CHECK_OUTPUT(RETURN, 0, __LINE__, \"loop failed:  did not consume\")",
          "1689:      return 0;",
          "1690:     }",
          "",
          "[Removed Lines]",
          "1670:   while(EXPR_TYPE(expr_crs) == PTN_END)",
          "1671:   {",
          "1675:    if(EXPR_NXT(expr_crs) == PTN_END)",
          "1676:     break;",
          "1681:    if(EXPR_TYPE(expr_crs) == PTN_ZERO_MORE || EXPR_TYPE(expr_crs) == PTN_ONE_MORE)",
          "1682:    {",
          "1686:     if(*input_crs == input_start)",
          "1687:     {",
          "",
          "[Added Lines]",
          "1583:   while (EXPR_TYPE(expr_crs) == PTN_END) {",
          "1587:    if (EXPR_NXT(expr_crs) == PTN_END) break;",
          "1592:    if (EXPR_TYPE(expr_crs) == PTN_ZERO_MORE ||",
          "1593:      EXPR_TYPE(expr_crs) == PTN_ONE_MORE) {",
          "1597:     if (*input_crs == input_start) {",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1694:    }",
          "1700:    expr_crs = EXPR_NXT(expr_crs);",
          "",
          "[Removed Lines]",
          "1697:    if(EXPR_TYPE(expr_crs) == PTN_NOT)",
          "1698:     not = !not;",
          "",
          "[Added Lines]",
          "1607:    if (EXPR_TYPE(expr_crs) == PTN_NOT) not = !not;",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1709:  return 1;",
          "1710: }",
          "1722:  int input_crs, ret, *loop_cnts;",
          "1724:  input_crs = input_start;",
          "1725:  loop_cnts = malloc(expr_data[1] * sizeof(int));",
          "1726:  memset(loop_cnts, 0, expr_data[1] * sizeof(int));",
          "1728:  free(loop_cnts);",
          "1729:  return ret;",
          "1730: }",
          "1740: #ifdef CHECK_OUTPUT_DEFINED",
          "1741:  pattern_output(expr_data);",
          "1742: #endif",
          "1743:  table = t;",
          "1745: }",
          "",
          "[Removed Lines]",
          "1712: static int pattern_check_hook(",
          "1713:  const widechar *input,",
          "1714:  const int input_start,",
          "1715:  const int input_minmax,",
          "1716:  const int input_dir,",
          "1717:  const widechar *expr_data,",
          "1718:  int (*hook)(const widechar input, const int data_len),",
          "1719:  widechar *hook_data,",
          "1720:  const int hook_max)",
          "1721: {",
          "1727:  ret = pattern_check_expression(input, &input_crs, input_minmax, input_dir, expr_data, hook, hook_data, hook_max, 2, 0, 0, loop_cnts);",
          "1732: int EXPORT_CALL _lou_pattern_check(",
          "1733:  const widechar *input,",
          "1734:  const int input_start,",
          "1735:  const int input_minmax,",
          "1736:  const int input_dir,",
          "1737:  const widechar *expr_data,",
          "1738:  const TranslationTableHeader *t)",
          "1739: {",
          "1744:  return pattern_check_hook(input, input_start, input_minmax, input_dir, expr_data, NULL, NULL, 0);",
          "",
          "[Added Lines]",
          "1621: static int",
          "1622: pattern_check_hook(const widechar *input, const int input_start, const int input_minmax,",
          "1623:   const int input_dir, const widechar *expr_data,",
          "1624:   int (*hook)(const widechar input, const int data_len), widechar *hook_data,",
          "1625:   const int hook_max) {",
          "1631:  ret = pattern_check_expression(input, &input_crs, input_minmax, input_dir, expr_data,",
          "1632:    hook, hook_data, hook_max, 2, 0, 0, loop_cnts);",
          "1637: int EXPORT_CALL",
          "1638: _lou_pattern_check(const widechar *input, const int input_start, const int input_minmax,",
          "1639:   const int input_dir, const widechar *expr_data, const TranslationTableHeader *t) {",
          "1644:  return pattern_check_hook(",
          "1645:    input, input_start, input_minmax, input_dir, expr_data, NULL, NULL, 0);",
          "",
          "---------------"
        ],
        "liblouis/utils.c||liblouis/utils.c": [
          "File: liblouis/utils.c -> liblouis/utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #include <shlobj.h>",
          "50: static void *",
          "56: }",
          "58: static char *",
          "65: }",
          "67: char *EXPORT_CALL",
          "107:  }",
          "118: }",
          "119: #endif",
          "122: int EXPORT_CALL",
          "129: }",
          "131: int EXPORT_CALL",
          "136: }",
          "138: char *EXPORT_CALL",
          "192:  }",
          "197: }",
          "202: char *EXPORT_CALL",
          "218: }",
          "223: const static intCharTupple attributeMapping[] = {",
          "238: };",
          "",
          "[Removed Lines]",
          "51: reallocWrapper (void *address, size_t size)",
          "52: {",
          "53:   if (!(address = realloc (address, size)) && size)",
          "54:     _lou_outOfMemory ();",
          "55:   return address;",
          "59: strdupWrapper (const char *string)",
          "60: {",
          "61:   char *address = strdup (string);",
          "62:   if (!address)",
          "63:     _lou_outOfMemory ();",
          "64:   return address;",
          "68: lou_getProgramPath (void)",
          "69: {",
          "70:   char *path = NULL;",
          "71:   HMODULE handle;",
          "73:   if ((handle = GetModuleHandle (NULL)))",
          "74:     {",
          "75:       DWORD size = 0X80;",
          "76:       char *buffer = NULL;",
          "78:       while (1)",
          "79:  {",
          "80:    buffer = reallocWrapper (buffer, size <<= 1);",
          "82:    {",
          "85:   DWORD length = GetModuleFileNameA (handle, buffer, size);",
          "87:      if (!length)",
          "88:        {",
          "89:   printf (\"GetModuleFileName\\n\");",
          "90:   exit (3);",
          "91:        }",
          "93:      if (length < size)",
          "94:        {",
          "95:   buffer[length] = 0;",
          "96:   path = strdupWrapper (buffer);",
          "98:   while (length > 0)",
          "99:     if (path[--length] == '\\\\')",
          "100:       break;",
          "102:   strncpy (path, path, length + 1);",
          "103:   path[length + 1] = '\\0';",
          "104:   break;",
          "105:        }",
          "106:    }",
          "109:       free (buffer);",
          "110:     }",
          "111:   else",
          "112:     {",
          "113:       printf (\"GetModuleHandle\\n\");",
          "114:       exit (3);",
          "115:     }",
          "117:   return path;",
          "123: _lou_stringHash (const widechar * c)",
          "124: {",
          "126:   unsigned long int makeHash = (((unsigned long int) c[0] << 8) +",
          "127:     (unsigned long int) c[1]) % HASHNUM;",
          "128:   return (int) makeHash;",
          "132: _lou_charHash (widechar c)",
          "133: {",
          "134:   unsigned long int makeHash = (unsigned long int) c % HASHNUM;",
          "135:   return (int) makeHash;",
          "139: _lou_showString (widechar const *chars, int length)",
          "140: {",
          "143:   int charPos;",
          "144:   int bufPos = 0;",
          "145:   static char scratchBuf[MAXSTRING];",
          "146:   scratchBuf[bufPos++] = '\\'';",
          "147:   for (charPos = 0; charPos < length && bufPos < (MAXSTRING-2); charPos++)",
          "148:     {",
          "149:       if (chars[charPos] >= 32 && chars[charPos] < 127)",
          "150:  scratchBuf[bufPos++] = (char) chars[charPos];",
          "151:       else",
          "152:  {",
          "153:    char hexbuf[20];",
          "154:    int hexLength;",
          "155:    char escapeLetter;",
          "157:    int leadingZeros;",
          "158:    int hexPos;",
          "159:    hexLength = sprintf (hexbuf, \"%x\", chars[charPos]);",
          "160:    switch (hexLength)",
          "161:      {",
          "162:      case 1:",
          "163:      case 2:",
          "164:      case 3:",
          "165:      case 4:",
          "166:        escapeLetter = 'x';",
          "167:        leadingZeros = 4 - hexLength;",
          "168:        break;",
          "169:      case 5:",
          "170:        escapeLetter = 'y';",
          "171:        leadingZeros = 0;",
          "172:        break;",
          "173:      case 6:",
          "174:      case 7:",
          "175:      case 8:",
          "176:        escapeLetter = 'z';",
          "177:        leadingZeros = 8 - hexLength;",
          "178:        break;",
          "179:      default:",
          "180:        escapeLetter = '?';",
          "181:        leadingZeros = 0;",
          "182:        break;",
          "183:      }",
          "184:    if ((bufPos + leadingZeros + hexLength + 4) >= (MAXSTRING-2))",
          "185:      break;",
          "186:    scratchBuf[bufPos++] = '\\\\';",
          "187:    scratchBuf[bufPos++] = escapeLetter;",
          "188:    for (hexPos = 0; hexPos < leadingZeros; hexPos++)",
          "189:      scratchBuf[bufPos++] = '0';",
          "190:    for (hexPos = 0; hexPos < hexLength; hexPos++)",
          "191:      scratchBuf[bufPos++] = hexbuf[hexPos];",
          "193:     }",
          "194:   scratchBuf[bufPos++] = '\\'';",
          "195:   scratchBuf[bufPos] = 0;",
          "196:   return scratchBuf;",
          "203: _lou_showDots (widechar const *dots, int length) {",
          "204:   int bufPos = 0;",
          "205:   static char scratchBuf[MAXSTRING];",
          "206:   for (int dotsPos = 0; dotsPos < length && bufPos < (MAXSTRING-1); dotsPos++) {",
          "207:     for (int mappingPos = 0; dotMapping[mappingPos].key; mappingPos++) {",
          "208:       if ((dots[dotsPos] & dotMapping[mappingPos].key) && (bufPos < (MAXSTRING-1)))",
          "209:  scratchBuf[bufPos++] = dotMapping[mappingPos].value;",
          "210:     }",
          "211:     if ((dots[dotsPos] == B16) && (bufPos < (MAXSTRING-1)))",
          "212:       scratchBuf[bufPos++] = '0';",
          "213:     if ((dotsPos != length - 1) && (bufPos < (MAXSTRING-1)))",
          "214:       scratchBuf[bufPos++] = '-';",
          "215:   }",
          "216:   scratchBuf[bufPos] = 0;",
          "217:   return scratchBuf;",
          "224:   {CTC_Space, 's'},",
          "225:   {CTC_Letter, 'l'},",
          "226:   {CTC_Digit, 'd'},",
          "227:   {CTC_Punctuation, 'p'},",
          "228:   {CTC_UpperCase, 'U'},",
          "229:   {CTC_LowerCase, 'u'},",
          "230:   {CTC_Math, 'm'},",
          "231:   {CTC_Sign, 'S'},",
          "232:   {CTC_LitDigit, 'D'},",
          "233:   {CTC_Class1, 'w'},",
          "234:   {CTC_Class2, 'x'},",
          "235:   {CTC_Class3, 'y'},",
          "236:   {CTC_Class4, 'z'},",
          "237:   0,",
          "",
          "[Added Lines]",
          "51: reallocWrapper(void *address, size_t size) {",
          "52:  if (!(address = realloc(address, size)) && size) _lou_outOfMemory();",
          "53:  return address;",
          "57: strdupWrapper(const char *string) {",
          "58:  char *address = strdup(string);",
          "59:  if (!address) _lou_outOfMemory();",
          "60:  return address;",
          "64: lou_getProgramPath(void) {",
          "65:  char *path = NULL;",
          "66:  HMODULE handle;",
          "68:  if ((handle = GetModuleHandle(NULL))) {",
          "69:   DWORD size = 0X80;",
          "70:   char *buffer = NULL;",
          "72:   while (1) {",
          "73:    buffer = reallocWrapper(buffer, size <<= 1);",
          "75:    {",
          "79:     DWORD length = GetModuleFileNameA(handle, buffer, size);",
          "81:     if (!length) {",
          "82:      printf(\"GetModuleFileName\\n\");",
          "83:      exit(3);",
          "84:     }",
          "86:     if (length < size) {",
          "87:      buffer[length] = 0;",
          "88:      path = strdupWrapper(buffer);",
          "90:      while (length > 0)",
          "91:       if (path[--length] == '\\\\') break;",
          "93:      strncpy(path, path, length + 1);",
          "94:      path[length + 1] = '\\0';",
          "95:      break;",
          "96:     }",
          "97:    }",
          "98:   }",
          "100:   free(buffer);",
          "101:  } else {",
          "102:   printf(\"GetModuleHandle\\n\");",
          "103:   exit(3);",
          "106:  return path;",
          "112: _lou_stringHash(const widechar *c) {",
          "114:  unsigned long int makeHash =",
          "115:    (((unsigned long int)c[0] << 8) + (unsigned long int)c[1]) % HASHNUM;",
          "116:  return (int)makeHash;",
          "120: _lou_charHash(widechar c) {",
          "121:  unsigned long int makeHash = (unsigned long int)c % HASHNUM;",
          "122:  return (int)makeHash;",
          "126: _lou_showString(widechar const *chars, int length) {",
          "129:  int charPos;",
          "130:  int bufPos = 0;",
          "131:  static char scratchBuf[MAXSTRING];",
          "132:  scratchBuf[bufPos++] = '\\'';",
          "133:  for (charPos = 0; charPos < length && bufPos < (MAXSTRING - 2); charPos++) {",
          "134:   if (chars[charPos] >= 32 && chars[charPos] < 127)",
          "135:    scratchBuf[bufPos++] = (char)chars[charPos];",
          "136:   else {",
          "137:    char hexbuf[20];",
          "138:    int hexLength;",
          "139:    char escapeLetter;",
          "141:    int leadingZeros;",
          "142:    int hexPos;",
          "143:    hexLength = sprintf(hexbuf, \"%x\", chars[charPos]);",
          "144:    switch (hexLength) {",
          "145:    case 1:",
          "146:    case 2:",
          "147:    case 3:",
          "148:    case 4:",
          "149:     escapeLetter = 'x';",
          "150:     leadingZeros = 4 - hexLength;",
          "151:     break;",
          "152:    case 5:",
          "153:     escapeLetter = 'y';",
          "154:     leadingZeros = 0;",
          "155:     break;",
          "156:    case 6:",
          "157:    case 7:",
          "158:    case 8:",
          "159:     escapeLetter = 'z';",
          "160:     leadingZeros = 8 - hexLength;",
          "161:     break;",
          "162:    default:",
          "163:     escapeLetter = '?';",
          "164:     leadingZeros = 0;",
          "165:     break;",
          "166:    }",
          "167:    if ((bufPos + leadingZeros + hexLength + 4) >= (MAXSTRING - 2)) break;",
          "168:    scratchBuf[bufPos++] = '\\\\';",
          "169:    scratchBuf[bufPos++] = escapeLetter;",
          "170:    for (hexPos = 0; hexPos < leadingZeros; hexPos++) scratchBuf[bufPos++] = '0';",
          "171:    for (hexPos = 0; hexPos < hexLength; hexPos++)",
          "172:     scratchBuf[bufPos++] = hexbuf[hexPos];",
          "173:   }",
          "175:  scratchBuf[bufPos++] = '\\'';",
          "176:  scratchBuf[bufPos] = 0;",
          "177:  return scratchBuf;",
          "184: _lou_showDots(widechar const *dots, int length) {",
          "185:  int bufPos = 0;",
          "186:  static char scratchBuf[MAXSTRING];",
          "187:  for (int dotsPos = 0; dotsPos < length && bufPos < (MAXSTRING - 1); dotsPos++) {",
          "188:   for (int mappingPos = 0; dotMapping[mappingPos].key; mappingPos++) {",
          "189:    if ((dots[dotsPos] & dotMapping[mappingPos].key) &&",
          "190:      (bufPos < (MAXSTRING - 1)))",
          "191:     scratchBuf[bufPos++] = dotMapping[mappingPos].value;",
          "192:   }",
          "193:   if ((dots[dotsPos] == B16) && (bufPos < (MAXSTRING - 1)))",
          "194:    scratchBuf[bufPos++] = '0';",
          "195:   if ((dotsPos != length - 1) && (bufPos < (MAXSTRING - 1)))",
          "196:    scratchBuf[bufPos++] = '-';",
          "197:  }",
          "198:  scratchBuf[bufPos] = 0;",
          "199:  return scratchBuf;",
          "206:  { CTC_Space, 's' }, { CTC_Letter, 'l' }, { CTC_Digit, 'd' }, { CTC_Punctuation, 'p' },",
          "207:  { CTC_UpperCase, 'U' }, { CTC_LowerCase, 'u' }, { CTC_Math, 'm' }, { CTC_Sign, 'S' },",
          "208:  { CTC_LitDigit, 'D' }, { CTC_Class1, 'w' }, { CTC_Class2, 'x' }, { CTC_Class3, 'y' },",
          "209:  { CTC_Class4, 'z' }, 0,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244: char *EXPORT_CALL",
          "254: }",
          "256: void EXPORT_CALL",
          "261: }",
          "263: #ifdef DEBUG",
          "264: void EXPORT_CALL",
          "269: }",
          "270: #endif",
          "",
          "[Removed Lines]",
          "245: _lou_showAttributes (TranslationTableCharacterAttributes a) {",
          "246:   int bufPos = 0;",
          "247:   static char scratchBuf[MAXSTRING];",
          "248:   for (int mappingPos = 0; attributeMapping[mappingPos].key; mappingPos++) {",
          "249:     if ((a & attributeMapping[mappingPos].key) && bufPos < (MAXSTRING - 1))",
          "250:       scratchBuf[bufPos++] = attributeMapping[mappingPos].value;",
          "251:   }",
          "252:   scratchBuf[bufPos] = 0;",
          "253:   return scratchBuf;",
          "257: _lou_outOfMemory (void)",
          "258: {",
          "259:   _lou_logMessage(LOG_FATAL, \"liblouis: Insufficient memory\\n\");",
          "260:   exit (3);",
          "265: _lou_debugHook (void)",
          "266: {",
          "267:   char *hook = \"debug hook\";",
          "268:   printf (\"%s\\n\", hook);",
          "",
          "[Added Lines]",
          "217: _lou_showAttributes(TranslationTableCharacterAttributes a) {",
          "218:  int bufPos = 0;",
          "219:  static char scratchBuf[MAXSTRING];",
          "220:  for (int mappingPos = 0; attributeMapping[mappingPos].key; mappingPos++) {",
          "221:   if ((a & attributeMapping[mappingPos].key) && bufPos < (MAXSTRING - 1))",
          "222:    scratchBuf[bufPos++] = attributeMapping[mappingPos].value;",
          "223:  }",
          "224:  scratchBuf[bufPos] = 0;",
          "225:  return scratchBuf;",
          "229: _lou_outOfMemory(void) {",
          "230:  _lou_logMessage(LOG_FATAL, \"liblouis: Insufficient memory\\n\");",
          "231:  exit(3);",
          "236: _lou_debugHook(void) {",
          "237:  char *hook = \"debug hook\";",
          "238:  printf(\"%s\\n\", hook);",
          "",
          "---------------"
        ],
        "tools/brl_checks.c||tools/brl_checks.c": [
          "File: tools/brl_checks.c -> tools/brl_checks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #include \"brl_checks.h\"",
          "26: #include \"unistr.h\"",
          "37: }",
          "44: }",
          "50: #ifdef WIDECHARS_ARE_UCS4",
          "52: #else",
          "54: #endif",
          "57: }",
          "69: }",
          "77: }",
          "84: }",
          "92: }",
          "101: }",
          "109: }",
          "116: }",
          "124: }",
          "133: }",
          "141: }",
          "210: #ifdef WIDECHARS_ARE_UCS4",
          "213: #else",
          "216: #endif",
          "242: }",
          "280: }",
          "326: }",
          "367: }",
          "404: }",
          "",
          "[Removed Lines]",
          "28: int check_full(const char *tableList, const char *str,",
          "29:                const formtype *typeform, const char *expected,",
          "30:                int mode, const int *cursorPos, int direction, int diagnostics);",
          "32: void print_int_array(const char *prefix, int *pos_list, int len) {",
          "33:   int i;",
          "34:   fprintf(stderr, \"%s \", prefix);",
          "35:   for (i = 0; i < len; i++) fprintf(stderr, \"%d \", pos_list[i]);",
          "36:   fprintf(stderr, \"\\n\");",
          "39: void print_typeform(const formtype *typeform, int len) {",
          "40:   int i;",
          "41:   fprintf(stderr, \"Typeform:  \");",
          "42:   for (i = 0; i < len; i++) fprintf(stderr, \"%hi\", typeform[i]);",
          "43:   fprintf(stderr, \"\\n\");",
          "46: void print_widechars(widechar *buffer, int length) {",
          "47:   uint8_t *result_buf;",
          "48:   size_t result_len;",
          "51:   result_buf = u32_to_u8(buffer, length, NULL, &result_len);",
          "53:   result_buf = u16_to_u8(buffer, length, NULL, &result_len);",
          "55:   fprintf(stderr, \"%.*s\", (int)result_len, result_buf);",
          "56:   free(result_buf);",
          "63: formtype *convert_typeform(const char *typeform_string) {",
          "64:   int len = strlen(typeform_string);",
          "65:   formtype *typeform = malloc(len * sizeof(formtype));",
          "66:   int i;",
          "67:   for (i = 0; i < len; i++) typeform[i] = typeform_string[i] - '0';",
          "68:   return typeform;",
          "71: void update_typeform(const char *typeform_string, formtype *typeform,",
          "72:                      const typeforms kind) {",
          "73:   int len = strlen(typeform_string);",
          "74:   int i;",
          "75:   for (i = 0; i < len; i++)",
          "76:     if (typeform_string[i] != ' ') typeform[i] |= kind;",
          "81: int check_translation(const char *tableList, const char *str,",
          "82:                       const formtype *typeform, const char *expected) {",
          "83:   return check_translation_full(tableList, str, typeform, expected, 0, 0);",
          "88: int check_translation_with_mode(const char *tableList, const char *str,",
          "89:                                 const formtype *typeform, const char *expected,",
          "90:                                 int mode) {",
          "91:   return check_translation_full(tableList, str, typeform, expected, mode, 0);",
          "96: int check_translation_with_cursorpos(const char *tableList, const char *str,",
          "97:                                      const formtype *typeform,",
          "98:                                      const char *expected,",
          "99:                                      const int *cursorPos) {",
          "100:   return check_translation_full(tableList, str, typeform, expected, 0, cursorPos);",
          "105: int check_translation_full(const char *tableList, const char *str,",
          "106:                            const formtype *typeform, const char *expected,",
          "107:                            int mode, const int *cursorPos) {",
          "108:   return check_full(tableList, str, typeform, expected, mode, cursorPos, 0, 1);",
          "113: int check_backtranslation(const char *tableList, const char *str,",
          "114:                           const formtype *typeform, const char *expected) {",
          "115:   return check_backtranslation_full(tableList, str, typeform, expected, 0, 0);",
          "120: int check_backtranslation_with_mode(const char *tableList, const char *str,",
          "121:                                     const formtype *typeform,",
          "122:                                     const char *expected, int mode) {",
          "123:   return check_backtranslation_full(tableList, str, typeform, expected, mode, 0);",
          "128: int check_backtranslation_with_cursorpos(const char *tableList, const char *str,",
          "129:                                          const formtype *typeform,",
          "130:                                          const char *expected,",
          "131:                                          const int *cursorPos) {",
          "132:   return check_backtranslation_full(tableList, str, typeform, expected, 0, cursorPos);",
          "137: int check_backtranslation_full(const char *tableList, const char *str,",
          "138:                                const formtype *typeform, const char *expected,",
          "139:                                int mode, const int *cursorPos) {",
          "140:   return check_full(tableList, str, typeform, expected, mode, cursorPos, 1, 1);",
          "146: int check_full(const char *tableList, const char *str,",
          "147:                const formtype *typeform, const char *expected,",
          "148:                int mode, const int *cursorPos, int direction, int diagnostics) {",
          "149:   widechar *inbuf, *outbuf, *expectedbuf;",
          "150:   int inlen = strlen(str);",
          "151:   int outlen = inlen * 10;",
          "152:   int expectedlen = strlen(expected);",
          "153:   int i, retval = 0;",
          "154:   int funcStatus = 0;",
          "155:   formtype *typeformbuf = NULL;",
          "156:   int *cursorPosbuf = NULL;",
          "158:   inbuf = malloc(sizeof(widechar) * inlen);",
          "159:   outbuf = malloc(sizeof(widechar) * outlen);",
          "160:   expectedbuf = malloc(sizeof(widechar) * expectedlen);",
          "161:   if (typeform != NULL) {",
          "162:     typeformbuf = malloc(outlen * sizeof(formtype));",
          "163:     memcpy(typeformbuf, typeform, outlen * sizeof(formtype));",
          "164:   }",
          "165:   if (cursorPos != NULL) {",
          "166:     cursorPosbuf = malloc(sizeof(int));",
          "167:     memcpy(cursorPosbuf, cursorPos, sizeof(int));",
          "168:   }",
          "169:   inlen = _lou_extParseChars(str, inbuf);",
          "170:   if (!inlen) {",
          "171:     fprintf(stderr, \"Cannot parse input string.\\n\");",
          "172:     retval = 1;",
          "173:     goto fail;",
          "174:   }",
          "175:   if (direction == 0) {",
          "176:     funcStatus = lou_translate(tableList, inbuf, &inlen, outbuf, &outlen,",
          "177:                                typeformbuf, NULL, NULL, NULL, cursorPosbuf, mode);",
          "178:   } else {",
          "179:     funcStatus = lou_backTranslate(tableList, inbuf, &inlen, outbuf, &outlen,",
          "180:                                    typeformbuf, NULL, NULL, NULL, cursorPosbuf, mode);",
          "181:   }",
          "182:   if (!funcStatus) {",
          "183:     fprintf(stderr, \"Translation failed.\\n\");",
          "184:     retval = 1;",
          "185:     goto fail;",
          "186:   }",
          "188:   expectedlen = _lou_extParseChars(expected, expectedbuf);",
          "189:   for (i = 0; i < outlen && i < expectedlen && expectedbuf[i] == outbuf[i]; i++)",
          "190:     ;",
          "191:   if (i < outlen || i < expectedlen) {",
          "192:     retval = 1;",
          "193:     if (diagnostics) {",
          "194:       outbuf[outlen] = 0;",
          "195:       fprintf(stderr, \"Input:    '%s'\\n\", str);",
          "199:       if (typeform != NULL) print_typeform(typeform, inlen);",
          "200:       if (cursorPos != NULL) fprintf(stderr, \"Cursor:   %d\\n\", *cursorPos);",
          "201:       fprintf(stderr, \"Expected: '%s' (length %d)\\n\", expected, expectedlen);",
          "202:       fprintf(stderr, \"Received: '\");",
          "203:       print_widechars(outbuf, outlen);",
          "204:       fprintf(stderr, \"' (length %d)\\n\", outlen);",
          "206:       uint8_t *expected_utf8;",
          "207:       uint8_t *out_utf8;",
          "208:       size_t expected_utf8_len;",
          "209:       size_t out_utf8_len;",
          "211:       expected_utf8 = u32_to_u8(&expectedbuf[i], 1, NULL, &expected_utf8_len);",
          "212:       out_utf8 = u32_to_u8(&outbuf[i], 1, NULL, &out_utf8_len);",
          "214:       expected_utf8 = u16_to_u8(&expectedbuf[i], 1, NULL, &expected_utf8_len);",
          "215:       out_utf8 = u16_to_u8(&outbuf[i], 1, NULL, &out_utf8_len);",
          "218:       if (i < outlen && i < expectedlen) {",
          "219:         fprintf(stderr, \"Diff:     Expected '%.*s' but received '%.*s' in index %d\\n\",",
          "220:           (int)expected_utf8_len, expected_utf8, (int)out_utf8_len, out_utf8, i);",
          "221:       } else if (i < expectedlen) {",
          "222:         fprintf(stderr,",
          "223:           \"Diff:     Expected '%.*s' but received nothing in index %d\\n\",",
          "224:           (int)expected_utf8_len, expected_utf8, i);",
          "225:       } else {",
          "226:         fprintf(stderr,",
          "227:           \"Diff:     Expected nothing but received '%.*s' in index %d\\n\",",
          "228:           (int)out_utf8_len, out_utf8, i);",
          "229:       }",
          "230:       free(expected_utf8);",
          "231:       free(out_utf8);",
          "232:     }",
          "233:   }",
          "235:  fail:",
          "236:   free(inbuf);",
          "237:   free(outbuf);",
          "238:   free(expectedbuf);",
          "239:   free(typeformbuf);",
          "240:   free(cursorPosbuf);",
          "241:   return retval;",
          "244: int check_inpos(const char *tableList, const char *str,",
          "245:                 const int *expected_poslist) {",
          "246:   widechar *inbuf;",
          "247:   widechar *outbuf;",
          "248:   int *inpos;",
          "249:   int inlen;",
          "250:   int outlen;",
          "251:   int i, retval = 0;",
          "253:   inlen = strlen(str) * 2;",
          "254:   outlen = inlen;",
          "255:   inbuf = malloc(sizeof(widechar) * inlen);",
          "256:   outbuf = malloc(sizeof(widechar) * outlen);",
          "257:   inpos = malloc(sizeof(int) * inlen);",
          "258:   for (i = 0; i < inlen; i++) {",
          "259:     inbuf[i] = str[i];",
          "260:   }",
          "261:   if (!lou_translate(tableList, inbuf, &inlen, outbuf, &outlen, NULL, NULL, NULL,",
          "262:        inpos, NULL, 0)) {",
          "263:     fprintf(stderr, \"Translation failed.\\n\");",
          "264:     retval = 1;",
          "265:     goto fail;",
          "266:   }",
          "267:   for (i = 0; i < outlen; i++) {",
          "268:     if (expected_poslist[i] != inpos[i]) {",
          "269:       fprintf(stderr, \"Expected %d, received %d in index %d\\n\",",
          "270:               expected_poslist[i], inpos[i], i);",
          "271:       retval = 1;",
          "272:     }",
          "273:   }",
          "275:  fail:",
          "276:   free(inbuf);",
          "277:   free(outbuf);",
          "278:   free(inpos);",
          "279:   return retval;",
          "282: int check_outpos(const char *tableList, const char *str,",
          "283:                  const int *expected_poslist) {",
          "284:   widechar *inbuf;",
          "285:   widechar *outbuf;",
          "286:   int *inpos, *outpos;",
          "287:   int origInlen, inlen;",
          "288:   int outlen;",
          "289:   int i, retval = 0;",
          "291:   origInlen = inlen = strlen(str);",
          "292:   outlen = inlen * 2;",
          "293:   inbuf = malloc(sizeof(widechar) * inlen);",
          "294:   outbuf = malloc(sizeof(widechar) * outlen);",
          "296:   inpos = malloc(sizeof(int) * outlen);",
          "297:   outpos = malloc(sizeof(int) * inlen);",
          "298:   for (i = 0; i < inlen; i++) {",
          "299:     inbuf[i] = str[i];",
          "300:   }",
          "301:   if (!lou_translate(tableList, inbuf, &inlen, outbuf, &outlen, NULL, NULL, outpos,",
          "302:        inpos, NULL, 0)) {",
          "303:     fprintf(stderr, \"Translation failed.\\n\");",
          "304:     retval = 1;",
          "305:     goto fail;",
          "306:   }",
          "307:   if (inlen != origInlen) {",
          "308:     fprintf(stderr, \"original inlen %d and returned inlen %d differ\\n\",",
          "309:             origInlen, inlen);",
          "310:   }",
          "312:   for (i = 0; i < inlen; i++) {",
          "313:     if (expected_poslist[i] != outpos[i]) {",
          "314:       fprintf(stderr, \"Expected %d, received %d in index %d\\n\",",
          "315:               expected_poslist[i], outpos[i], i);",
          "316:       retval = 1;",
          "317:     }",
          "318:   }",
          "320:  fail:",
          "321:   free(inbuf);",
          "322:   free(outbuf);",
          "323:   free(inpos);",
          "324:   free(outpos);",
          "325:   return retval;",
          "328: int check_cursor_pos(const char *tableList, const char *str,",
          "329:                      const int *expected_pos) {",
          "330:   widechar *inbuf;",
          "331:   widechar *outbuf;",
          "332:   int *inpos, *outpos;",
          "333:   int inlen = strlen(str);",
          "334:   int outlen = inlen;",
          "335:   int cursor_pos;",
          "336:   int i, retval = 0;",
          "338:   inbuf = malloc(sizeof(widechar) * inlen);",
          "339:   outbuf = malloc(sizeof(widechar) * inlen);",
          "340:   inpos = malloc(sizeof(int) * inlen);",
          "341:   outpos = malloc(sizeof(int) * inlen);",
          "342:   inlen = _lou_extParseChars(str, inbuf);",
          "344:   for (i = 0; i < inlen; i++) {",
          "345:     cursor_pos = i;",
          "346:     if (!lou_translate(tableList, inbuf, &inlen, outbuf, &outlen, NULL, NULL, NULL,",
          "347:          NULL, &cursor_pos, compbrlAtCursor)) {",
          "348:       fprintf(stderr, \"Translation failed.\\n\");",
          "349:       retval = 1;",
          "350:       goto fail;",
          "351:     }",
          "352:     if (expected_pos[i] != cursor_pos) {",
          "353:       fprintf(stderr,",
          "354:               \"string='%s' cursor=%d ('%c') expected=%d received=%d ('%c')\\n\",",
          "355:               str, i, str[i], expected_pos[i], cursor_pos,",
          "356:               (char)outbuf[cursor_pos]);",
          "357:       retval = 1;",
          "358:     }",
          "359:   }",
          "361:  fail:",
          "362:   free(inbuf);",
          "363:   free(outbuf);",
          "364:   free(inpos);",
          "365:   free(outpos);",
          "366:   return retval;",
          "371: int check_hyphenation(const char *tableList, const char *str,",
          "372:                       const char *expected) {",
          "373:   widechar *inbuf;",
          "374:   char *hyphens = NULL;",
          "375:   int inlen = strlen(str);",
          "376:   int retval = 0;",
          "378:   inbuf = malloc(sizeof(widechar) * inlen);",
          "379:   inlen = _lou_extParseChars(str, inbuf);",
          "380:   if (!inlen) {",
          "381:     fprintf(stderr, \"Cannot parse input string.\\n\");",
          "382:     retval = 1;",
          "383:     goto fail;",
          "384:   }",
          "385:   hyphens = calloc(inlen + 1, sizeof(char));",
          "387:   if (!lou_hyphenate(tableList, inbuf, inlen, hyphens, 0)) {",
          "388:     fprintf(stderr, \"Hyphenation failed.\\n\");",
          "389:     retval = 1;",
          "390:     goto fail;",
          "391:   }",
          "393:   if (strcmp(expected, hyphens)) {",
          "394:     fprintf(stderr, \"Input:    '%s'\\n\", str);",
          "395:     fprintf(stderr, \"Expected: '%s'\\n\", expected);",
          "396:     fprintf(stderr, \"Received: '%s'\\n\", hyphens);",
          "397:     retval = 1;",
          "398:   }",
          "400:  fail:",
          "401:   free(inbuf);",
          "402:   free(hyphens);",
          "403:   return retval;",
          "",
          "[Added Lines]",
          "28: int",
          "29: check_full(const char *tableList, const char *str, const formtype *typeform,",
          "30:   const char *expected, int mode, const int *cursorPos, int direction,",
          "31:   int diagnostics);",
          "33: void",
          "34: print_int_array(const char *prefix, int *pos_list, int len) {",
          "35:  int i;",
          "36:  fprintf(stderr, \"%s \", prefix);",
          "37:  for (i = 0; i < len; i++) fprintf(stderr, \"%d \", pos_list[i]);",
          "38:  fprintf(stderr, \"\\n\");",
          "41: void",
          "42: print_typeform(const formtype *typeform, int len) {",
          "43:  int i;",
          "44:  fprintf(stderr, \"Typeform:  \");",
          "45:  for (i = 0; i < len; i++) fprintf(stderr, \"%hi\", typeform[i]);",
          "46:  fprintf(stderr, \"\\n\");",
          "49: void",
          "50: print_widechars(widechar *buffer, int length) {",
          "51:  uint8_t *result_buf;",
          "52:  size_t result_len;",
          "55:  result_buf = u32_to_u8(buffer, length, NULL, &result_len);",
          "57:  result_buf = u16_to_u8(buffer, length, NULL, &result_len);",
          "59:  fprintf(stderr, \"%.*s\", (int)result_len, result_buf);",
          "60:  free(result_buf);",
          "67: formtype *",
          "68: convert_typeform(const char *typeform_string) {",
          "69:  int len = strlen(typeform_string);",
          "70:  formtype *typeform = malloc(len * sizeof(formtype));",
          "71:  int i;",
          "72:  for (i = 0; i < len; i++) typeform[i] = typeform_string[i] - '0';",
          "73:  return typeform;",
          "76: void",
          "77: update_typeform(const char *typeform_string, formtype *typeform, const typeforms kind) {",
          "78:  int len = strlen(typeform_string);",
          "79:  int i;",
          "80:  for (i = 0; i < len; i++)",
          "81:   if (typeform_string[i] != ' ') typeform[i] |= kind;",
          "86: int",
          "87: check_translation(const char *tableList, const char *str, const formtype *typeform,",
          "88:   const char *expected) {",
          "89:  return check_translation_full(tableList, str, typeform, expected, 0, 0);",
          "94: int",
          "95: check_translation_with_mode(const char *tableList, const char *str,",
          "96:   const formtype *typeform, const char *expected, int mode) {",
          "97:  return check_translation_full(tableList, str, typeform, expected, mode, 0);",
          "102: int",
          "103: check_translation_with_cursorpos(const char *tableList, const char *str,",
          "104:   const formtype *typeform, const char *expected, const int *cursorPos) {",
          "105:  return check_translation_full(tableList, str, typeform, expected, 0, cursorPos);",
          "110: int",
          "111: check_translation_full(const char *tableList, const char *str, const formtype *typeform,",
          "112:   const char *expected, int mode, const int *cursorPos) {",
          "113:  return check_full(tableList, str, typeform, expected, mode, cursorPos, 0, 1);",
          "118: int",
          "119: check_backtranslation(const char *tableList, const char *str, const formtype *typeform,",
          "120:   const char *expected) {",
          "121:  return check_backtranslation_full(tableList, str, typeform, expected, 0, 0);",
          "126: int",
          "127: check_backtranslation_with_mode(const char *tableList, const char *str,",
          "128:   const formtype *typeform, const char *expected, int mode) {",
          "129:  return check_backtranslation_full(tableList, str, typeform, expected, mode, 0);",
          "134: int",
          "135: check_backtranslation_with_cursorpos(const char *tableList, const char *str,",
          "136:   const formtype *typeform, const char *expected, const int *cursorPos) {",
          "137:  return check_backtranslation_full(tableList, str, typeform, expected, 0, cursorPos);",
          "142: int",
          "143: check_backtranslation_full(const char *tableList, const char *str,",
          "144:   const formtype *typeform, const char *expected, int mode, const int *cursorPos) {",
          "145:  return check_full(tableList, str, typeform, expected, mode, cursorPos, 1, 1);",
          "151: int",
          "152: check_full(const char *tableList, const char *str, const formtype *typeform,",
          "153:   const char *expected, int mode, const int *cursorPos, int direction,",
          "154:   int diagnostics) {",
          "155:  widechar *inbuf, *outbuf, *expectedbuf;",
          "156:  int inlen = strlen(str);",
          "157:  int outlen = inlen * 10;",
          "158:  int expectedlen = strlen(expected);",
          "159:  int i, retval = 0;",
          "160:  int funcStatus = 0;",
          "161:  formtype *typeformbuf = NULL;",
          "162:  int *cursorPosbuf = NULL;",
          "164:  inbuf = malloc(sizeof(widechar) * inlen);",
          "165:  outbuf = malloc(sizeof(widechar) * outlen);",
          "166:  expectedbuf = malloc(sizeof(widechar) * expectedlen);",
          "167:  if (typeform != NULL) {",
          "168:   typeformbuf = malloc(outlen * sizeof(formtype));",
          "169:   memcpy(typeformbuf, typeform, outlen * sizeof(formtype));",
          "170:  }",
          "171:  if (cursorPos != NULL) {",
          "172:   cursorPosbuf = malloc(sizeof(int));",
          "173:   memcpy(cursorPosbuf, cursorPos, sizeof(int));",
          "174:  }",
          "175:  inlen = _lou_extParseChars(str, inbuf);",
          "176:  if (!inlen) {",
          "177:   fprintf(stderr, \"Cannot parse input string.\\n\");",
          "178:   retval = 1;",
          "179:   goto fail;",
          "180:  }",
          "181:  if (direction == 0) {",
          "182:   funcStatus = lou_translate(tableList, inbuf, &inlen, outbuf, &outlen, typeformbuf,",
          "183:     NULL, NULL, NULL, cursorPosbuf, mode);",
          "184:  } else {",
          "185:   funcStatus = lou_backTranslate(tableList, inbuf, &inlen, outbuf, &outlen,",
          "186:     typeformbuf, NULL, NULL, NULL, cursorPosbuf, mode);",
          "187:  }",
          "188:  if (!funcStatus) {",
          "189:   fprintf(stderr, \"Translation failed.\\n\");",
          "190:   retval = 1;",
          "191:   goto fail;",
          "192:  }",
          "194:  expectedlen = _lou_extParseChars(expected, expectedbuf);",
          "195:  for (i = 0; i < outlen && i < expectedlen && expectedbuf[i] == outbuf[i]; i++)",
          "196:   ;",
          "197:  if (i < outlen || i < expectedlen) {",
          "198:   retval = 1;",
          "199:   if (diagnostics) {",
          "200:    outbuf[outlen] = 0;",
          "201:    fprintf(stderr, \"Input:    '%s'\\n\", str);",
          "205:    if (typeform != NULL) print_typeform(typeform, inlen);",
          "206:    if (cursorPos != NULL) fprintf(stderr, \"Cursor:   %d\\n\", *cursorPos);",
          "207:    fprintf(stderr, \"Expected: '%s' (length %d)\\n\", expected, expectedlen);",
          "208:    fprintf(stderr, \"Received: '\");",
          "209:    print_widechars(outbuf, outlen);",
          "210:    fprintf(stderr, \"' (length %d)\\n\", outlen);",
          "212:    uint8_t *expected_utf8;",
          "213:    uint8_t *out_utf8;",
          "214:    size_t expected_utf8_len;",
          "215:    size_t out_utf8_len;",
          "217:    expected_utf8 = u32_to_u8(&expectedbuf[i], 1, NULL, &expected_utf8_len);",
          "218:    out_utf8 = u32_to_u8(&outbuf[i], 1, NULL, &out_utf8_len);",
          "220:    expected_utf8 = u16_to_u8(&expectedbuf[i], 1, NULL, &expected_utf8_len);",
          "221:    out_utf8 = u16_to_u8(&outbuf[i], 1, NULL, &out_utf8_len);",
          "224:    if (i < outlen && i < expectedlen) {",
          "225:     fprintf(stderr,",
          "226:       \"Diff:     Expected '%.*s' but received '%.*s' in index %d\\n\",",
          "227:       (int)expected_utf8_len, expected_utf8, (int)out_utf8_len,",
          "228:       out_utf8, i);",
          "229:    } else if (i < expectedlen) {",
          "230:     fprintf(stderr,",
          "231:       \"Diff:     Expected '%.*s' but received nothing in index %d\\n\",",
          "232:       (int)expected_utf8_len, expected_utf8, i);",
          "233:    } else {",
          "234:     fprintf(stderr,",
          "235:       \"Diff:     Expected nothing but received '%.*s' in index %d\\n\",",
          "236:       (int)out_utf8_len, out_utf8, i);",
          "237:    }",
          "238:    free(expected_utf8);",
          "239:    free(out_utf8);",
          "240:   }",
          "241:  }",
          "243: fail:",
          "244:  free(inbuf);",
          "245:  free(outbuf);",
          "246:  free(expectedbuf);",
          "247:  free(typeformbuf);",
          "248:  free(cursorPosbuf);",
          "249:  return retval;",
          "252: int",
          "253: check_inpos(const char *tableList, const char *str, const int *expected_poslist) {",
          "254:  widechar *inbuf;",
          "255:  widechar *outbuf;",
          "256:  int *inpos;",
          "257:  int inlen;",
          "258:  int outlen;",
          "259:  int i, retval = 0;",
          "261:  inlen = strlen(str) * 2;",
          "262:  outlen = inlen;",
          "263:  inbuf = malloc(sizeof(widechar) * inlen);",
          "264:  outbuf = malloc(sizeof(widechar) * outlen);",
          "265:  inpos = malloc(sizeof(int) * inlen);",
          "266:  for (i = 0; i < inlen; i++) {",
          "267:   inbuf[i] = str[i];",
          "268:  }",
          "269:  if (!lou_translate(tableList, inbuf, &inlen, outbuf, &outlen, NULL, NULL, NULL, inpos,",
          "270:     NULL, 0)) {",
          "271:   fprintf(stderr, \"Translation failed.\\n\");",
          "272:   retval = 1;",
          "273:   goto fail;",
          "274:  }",
          "275:  for (i = 0; i < outlen; i++) {",
          "276:   if (expected_poslist[i] != inpos[i]) {",
          "277:    fprintf(stderr, \"Expected %d, received %d in index %d\\n\", expected_poslist[i],",
          "278:      inpos[i], i);",
          "279:    retval = 1;",
          "280:   }",
          "281:  }",
          "283: fail:",
          "284:  free(inbuf);",
          "285:  free(outbuf);",
          "286:  free(inpos);",
          "287:  return retval;",
          "290: int",
          "291: check_outpos(const char *tableList, const char *str, const int *expected_poslist) {",
          "292:  widechar *inbuf;",
          "293:  widechar *outbuf;",
          "294:  int *inpos, *outpos;",
          "295:  int origInlen, inlen;",
          "296:  int outlen;",
          "297:  int i, retval = 0;",
          "299:  origInlen = inlen = strlen(str);",
          "300:  outlen = inlen * 2;",
          "301:  inbuf = malloc(sizeof(widechar) * inlen);",
          "302:  outbuf = malloc(sizeof(widechar) * outlen);",
          "304:  inpos = malloc(sizeof(int) * outlen);",
          "305:  outpos = malloc(sizeof(int) * inlen);",
          "306:  for (i = 0; i < inlen; i++) {",
          "307:   inbuf[i] = str[i];",
          "308:  }",
          "309:  if (!lou_translate(tableList, inbuf, &inlen, outbuf, &outlen, NULL, NULL, outpos,",
          "310:     inpos, NULL, 0)) {",
          "311:   fprintf(stderr, \"Translation failed.\\n\");",
          "312:   retval = 1;",
          "313:   goto fail;",
          "314:  }",
          "315:  if (inlen != origInlen) {",
          "316:   fprintf(stderr, \"original inlen %d and returned inlen %d differ\\n\", origInlen,",
          "317:     inlen);",
          "318:  }",
          "320:  for (i = 0; i < inlen; i++) {",
          "321:   if (expected_poslist[i] != outpos[i]) {",
          "322:    fprintf(stderr, \"Expected %d, received %d in index %d\\n\", expected_poslist[i],",
          "323:      outpos[i], i);",
          "324:    retval = 1;",
          "325:   }",
          "326:  }",
          "328: fail:",
          "329:  free(inbuf);",
          "330:  free(outbuf);",
          "331:  free(inpos);",
          "332:  free(outpos);",
          "333:  return retval;",
          "336: int",
          "337: check_cursor_pos(const char *tableList, const char *str, const int *expected_pos) {",
          "338:  widechar *inbuf;",
          "339:  widechar *outbuf;",
          "340:  int *inpos, *outpos;",
          "341:  int inlen = strlen(str);",
          "342:  int outlen = inlen;",
          "343:  int cursor_pos;",
          "344:  int i, retval = 0;",
          "346:  inbuf = malloc(sizeof(widechar) * inlen);",
          "347:  outbuf = malloc(sizeof(widechar) * inlen);",
          "348:  inpos = malloc(sizeof(int) * inlen);",
          "349:  outpos = malloc(sizeof(int) * inlen);",
          "350:  inlen = _lou_extParseChars(str, inbuf);",
          "352:  for (i = 0; i < inlen; i++) {",
          "353:   cursor_pos = i;",
          "354:   if (!lou_translate(tableList, inbuf, &inlen, outbuf, &outlen, NULL, NULL, NULL,",
          "355:      NULL, &cursor_pos, compbrlAtCursor)) {",
          "356:    fprintf(stderr, \"Translation failed.\\n\");",
          "357:    retval = 1;",
          "358:    goto fail;",
          "359:   }",
          "360:   if (expected_pos[i] != cursor_pos) {",
          "361:    fprintf(stderr,",
          "362:      \"string='%s' cursor=%d ('%c') expected=%d received=%d ('%c')\\n\", str,",
          "363:      i, str[i], expected_pos[i], cursor_pos, (char)outbuf[cursor_pos]);",
          "364:    retval = 1;",
          "365:   }",
          "366:  }",
          "368: fail:",
          "369:  free(inbuf);",
          "370:  free(outbuf);",
          "371:  free(inpos);",
          "372:  free(outpos);",
          "373:  return retval;",
          "378: int",
          "379: check_hyphenation(const char *tableList, const char *str, const char *expected) {",
          "380:  widechar *inbuf;",
          "381:  char *hyphens = NULL;",
          "382:  int inlen = strlen(str);",
          "383:  int retval = 0;",
          "385:  inbuf = malloc(sizeof(widechar) * inlen);",
          "386:  inlen = _lou_extParseChars(str, inbuf);",
          "387:  if (!inlen) {",
          "388:   fprintf(stderr, \"Cannot parse input string.\\n\");",
          "389:   retval = 1;",
          "390:   goto fail;",
          "391:  }",
          "392:  hyphens = calloc(inlen + 1, sizeof(char));",
          "394:  if (!lou_hyphenate(tableList, inbuf, inlen, hyphens, 0)) {",
          "395:   fprintf(stderr, \"Hyphenation failed.\\n\");",
          "396:   retval = 1;",
          "397:   goto fail;",
          "398:  }",
          "400:  if (strcmp(expected, hyphens)) {",
          "401:   fprintf(stderr, \"Input:    '%s'\\n\", str);",
          "402:   fprintf(stderr, \"Expected: '%s'\\n\", expected);",
          "403:   fprintf(stderr, \"Received: '%s'\\n\", hyphens);",
          "404:   retval = 1;",
          "405:  }",
          "407: fail:",
          "408:  free(inbuf);",
          "409:  free(hyphens);",
          "410:  return retval;",
          "",
          "---------------"
        ],
        "tools/brl_checks.h||tools/brl_checks.h": [
          "File: tools/brl_checks.h -> tools/brl_checks.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"liblouis.h\"",
          "",
          "[Removed Lines]",
          "25: int check_inpos(const char *tableList, const char *str, const int *expected_poslist);",
          "27: int check_outpos(const char *tableList, const char *str, const int *expected_poslist);",
          "32: int check_cursor_pos(const char *tableList, const char *str, const int *expected_pos);",
          "36: int check_translation(const char *tableList, const char *str,",
          "37:                       const formtype *typeform, const char *expected);",
          "41: int check_translation_with_mode(const char *tableList, const char *str,",
          "42:                                 const formtype *typeform, const char *expected,",
          "43:                                 int mode);",
          "47: int check_translation_with_cursorpos(const char *tableList, const char *str,",
          "48:                                      const formtype *typeform,",
          "49:                                      const char *expected,",
          "50:                                      const int *cursorPos);",
          "54: int check_translation_full(const char *tableList, const char *str,",
          "55:                            const formtype *typeform, const char *expected,",
          "56:                            int mode, const int *cursorPos);",
          "60: int check_backtranslation(const char *tableList, const char *str,",
          "61:                           const formtype *typeform, const char *expected);",
          "65: int check_backtranslation_with_mode(const char *tableList, const char *str,",
          "66:                                     const formtype *typeform,",
          "67:                                     const char *expected, int mode);",
          "71: int check_backtranslation_with_cursorpos(const char *tableList, const char *str,",
          "72:                                          const formtype *typeform,",
          "73:                                          const char *expected,",
          "74:                                          const int *cursorPos);",
          "78: int check_backtranslation_full(const char *tableList, const char *str,",
          "79:                                const formtype *typeform, const char *expected,",
          "80:                                int mode, const int *cursorPos);",
          "86: int check_full(const char *tableList, const char *str,",
          "87:                const formtype *typeform, const char *expected,",
          "88:                int mode, const int *cursorPos, int direction, int diagnostics);",
          "92: int check_hyphenation(const char *tableList, const char *str, const char *expected);",
          "98: formtype * convert_typeform(const char* typeform_string);",
          "100: void update_typeform(const char* typeform_string, formtype* typeform, typeforms kind);",
          "",
          "[Added Lines]",
          "25: int",
          "26: check_inpos(const char *tableList, const char *str, const int *expected_poslist);",
          "28: int",
          "29: check_outpos(const char *tableList, const char *str, const int *expected_poslist);",
          "34: int",
          "35: check_cursor_pos(const char *tableList, const char *str, const int *expected_pos);",
          "39: int",
          "40: check_translation(const char *tableList, const char *str, const formtype *typeform,",
          "41:   const char *expected);",
          "45: int",
          "46: check_translation_with_mode(const char *tableList, const char *str,",
          "47:   const formtype *typeform, const char *expected, int mode);",
          "51: int",
          "52: check_translation_with_cursorpos(const char *tableList, const char *str,",
          "53:   const formtype *typeform, const char *expected, const int *cursorPos);",
          "57: int",
          "58: check_translation_full(const char *tableList, const char *str, const formtype *typeform,",
          "59:   const char *expected, int mode, const int *cursorPos);",
          "63: int",
          "64: check_backtranslation(const char *tableList, const char *str, const formtype *typeform,",
          "65:   const char *expected);",
          "69: int",
          "70: check_backtranslation_with_mode(const char *tableList, const char *str,",
          "71:   const formtype *typeform, const char *expected, int mode);",
          "75: int",
          "76: check_backtranslation_with_cursorpos(const char *tableList, const char *str,",
          "77:   const formtype *typeform, const char *expected, const int *cursorPos);",
          "81: int",
          "82: check_backtranslation_full(const char *tableList, const char *str,",
          "83:   const formtype *typeform, const char *expected, int mode, const int *cursorPos);",
          "89: int",
          "90: check_full(const char *tableList, const char *str, const formtype *typeform,",
          "91:   const char *expected, int mode, const int *cursorPos, int direction,",
          "92:   int diagnostics);",
          "96: int",
          "97: check_hyphenation(const char *tableList, const char *str, const char *expected);",
          "103: formtype *",
          "104: convert_typeform(const char *typeform_string);",
          "106: void",
          "107: update_typeform(const char *typeform_string, formtype *typeform, typeforms kind);",
          "",
          "---------------"
        ],
        "tools/lou_allround.c||tools/lou_allround.c": [
          "File: tools/lou_allround.c -> tools/lou_allround.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"unistr.h\"",
          "33: #include \"version-etc.h\"",
          "40: };",
          "42: const char version_etc_copyright[] =",
          "45: #define AUTHORS \"John J. Boyer\"",
          "47: static void",
          "54: This program tests every capability of the liblouis library. It is\\n\\",
          "58:   -h, --help          display this help and exit\\n\\",
          "64: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "66: #endif",
          "67: #ifdef PACKAGE_URL",
          "69: #endif",
          "70: }",
          "",
          "[Removed Lines]",
          "35: static const struct option longopts[] =",
          "36: {",
          "37:   { \"help\", no_argument, NULL, 'h' },",
          "38:   { \"version\", no_argument, NULL, 'v' },",
          "39:   { NULL, 0, NULL, 0 },",
          "43:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "48: print_help (void)",
          "49: {",
          "50:   printf (\"\\",
          "51: Usage: %s [OPTIONS]\\n\", program_name);",
          "53:   fputs (\"\\",
          "55: completely interactive. \\n\\n\", stdout);",
          "57:   fputs (\"\\",
          "59:   -v, --version       display version information and exit\\n\", stdout);",
          "61:   printf (\"\\n\");",
          "62:   printf (\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "65:   printf (\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "68:   printf (\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "[Added Lines]",
          "35: static const struct option longopts[] = {",
          "36:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "37:  { NULL, 0, NULL, 0 },",
          "41:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "46: print_help(void) {",
          "47:  printf(\"\\",
          "48: Usage: %s [OPTIONS]\\n\",",
          "49:    program_name);",
          "51:  fputs(\"\\",
          "53: completely interactive. \\n\\n\",",
          "54:    stdout);",
          "56:  fputs(\"\\",
          "58:   -v, --version       display version information and exit\\n\",",
          "59:    stdout);",
          "61:  printf(\"\\n\");",
          "62:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "65:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "68:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "88: static char enteredSpacing[BUFSIZE];",
          "90: static int",
          "105: }",
          "107: static int",
          "115: }",
          "117: static void",
          "126: }",
          "128: static int",
          "260: }",
          "262: int",
          "336: #ifdef WIDECHARS_ARE_UCS4",
          "338: #else",
          "340: #endif",
          "349: #ifdef WIDECHARS_ARE_UCS4",
          "351: #else",
          "353: #endif",
          "404:   else",
          "407: #ifdef WIDECHARS_ARE_UCS4",
          "409: #else",
          "411: #endif",
          "442: #ifdef WIDECHARS_ARE_UCS4",
          "444: #else",
          "446: #endif",
          "483: }",
          "",
          "[Removed Lines]",
          "91: getInput (void)",
          "92: {",
          "93:   int inputLength;",
          "94:   inputBuffer[0] = 0;",
          "95:   if(!fgets (inputBuffer, sizeof (inputBuffer), stdin))",
          "96:     exit(EXIT_FAILURE);",
          "97:   inputLength = strlen (inputBuffer) - 1;",
          "99:     {",
          "100:       lou_free();",
          "101:       exit (EXIT_SUCCESS);",
          "102:     }",
          "103:   inputBuffer[inputLength] = 0;",
          "104:   return inputLength;",
          "108: getYN (void)",
          "109: {",
          "110:   printf (\"? y/n: \");",
          "111:   getInput ();",
          "112:   if (inputBuffer[0] == 'y')",
          "113:     return 1;",
          "114:   return 0;",
          "118: paramLetters (void)",
          "119: {",
          "120:   printf (\"Press one of the letters in parentheses, then enter.\\n\");",
          "121:   printf",
          "122:     (\"(t)able, (r)un, (m)ode, (c)ursor, (e)mphasis, (s)pacing, (h)elp,\\n\");",
          "123:   printf",
          "124:     (\"(q)uit, (f)orward-only, (b)ack-only, show-(p)ositions m(i)nimal.\\n\");",
          "125:   printf (\"test-(l)engths.\\n\");",
          "129: getCommands (void)",
          "130: {",
          "131:   paramLetters ();",
          "132:   do",
          "133:     {",
          "134:       printf (\"Command: \");",
          "135:       getInput ();",
          "136:       switch (inputBuffer[0])",
          "137:  {",
          "138:  case 0:",
          "139:    break;",
          "140:  case 't':",
          "141:    do",
          "142:      {",
          "143:        printf (\"Enter the name of a table: \");",
          "144:        getInput ();",
          "145:        strcpy (table, inputBuffer);",
          "146:      }",
          "147:    while ((validTable = lou_getTable (table)) == NULL);",
          "148:    break;",
          "149:  case 'r':",
          "150:    if (validTable == NULL)",
          "151:      {",
          "152:        printf (\"You must enter a valid table name.\\n\");",
          "153:        inputBuffer[0] = 0;",
          "154:      }",
          "155:    break;",
          "156:  case 'm':",
          "157:    printf (\"Reset mode\");",
          "158:    if (getYN ())",
          "159:      mode = 0;",
          "160:    printf (\"No contractions\");",
          "161:    mode |= getYN ();",
          "162:    printf (\"Computer braille at cursor\");",
          "163:    mode |= 2 * getYN ();",
          "164:    printf (\"Dots input and output\");",
          "165:    mode |= 4 * getYN ();",
          "166:    printf (\"8-dot computer braille\");",
          "167:    mode |= 8 * getYN ();",
          "168:    printf (\"Pass1 only\");",
          "169:    mode |= 16 * getYN ();",
          "170:    break;",
          "171:  case 'l':",
          "172:    printf (\"Do you want to test input and output lengths\");",
          "173:    showSizes = getYN ();",
          "174:    if (!showSizes)",
          "175:      {",
          "176:        outputSize = BUFSIZE;",
          "177:        break;",
          "178:      }",
          "179:    printf (\"Enter a maximum output size: \");",
          "180:    getInput ();",
          "181:    outputSize = atoi (inputBuffer);",
          "182:    if (outputSize < 0 || outputSize > BUFSIZE)",
          "183:      {",
          "184:        printf (\"Output size must be from 0 tu %d.\\n\", BUFSIZE);",
          "185:        outputSize = BUFSIZE;",
          "186:        showSizes = 0;",
          "187:      }",
          "188:    break;",
          "189:  case 'c':",
          "190:    printf (\"Enter a cursor position: \");",
          "191:    getInput ();",
          "192:    enteredCursorPos = atoi (inputBuffer);",
          "193:    if (enteredCursorPos < -1 || enteredCursorPos > outputSize)",
          "194:      {",
          "195:        printf (\"Cursor position must be from -1 to %d.\\n\", outputSize);",
          "196:        enteredCursorPos = -1;",
          "197:      }",
          "198:    break;",
          "199:  case 'e':",
          "200:    printf (\"(Enter an x to cancel emphasis.)\\n\");",
          "201:    printf (\"Enter an emphasis string: \");",
          "202:    getInput ();",
          "203:    strcpy (enteredEmphasis, inputBuffer);",
          "204:    break;",
          "205:  case 's':",
          "206:    printf (\"(Enter an x to cancel spacing.)\\n\");",
          "207:    printf (\"Enter a spacing string: \");",
          "208:    getInput ();",
          "209:    strcpy (enteredSpacing, inputBuffer);",
          "210:    break;",
          "211:  case 'h':",
          "212:    printf (\"Commands: action\\n\");",
          "213:    printf (\"(t)able: Enter a table name\\n\");",
          "214:    printf (\"(r)un: run the translation/back-translation loop\\n\");",
          "215:    printf (\"(m)ode: Enter a mode parameter\\n\");",
          "216:    printf (\"(c)ursor: Enter a cursor position\\n\");",
          "217:    printf (\"(e)mphasis: Enter an emphasis string\\n\");",
          "218:    printf (\"(s)pacing: Enter a spacing string\\n\");",
          "219:    printf (\"(h)elp: print this page\\n\");",
          "220:    printf (\"(q)uit: leave the program\\n\");",
          "221:    printf (\"(f)orward-only: do only forward translation\\n\");",
          "222:    printf (\"(b)ack-only: do only back-translation\\n\");",
          "223:    printf (\"show-(p)ositions: show input and output positions\\n\");",
          "224:    printf",
          "225:      (\"m(i)nimal: test translator and back-translator with minimal parameters\\n\");",
          "226:    printf (\"test-(l)engths: test accuracy of returned lengths\\n\");",
          "227:    printf (\"\\n\");",
          "228:    paramLetters ();",
          "229:    break;",
          "230:  case 'q':",
          "231:    lou_free();",
          "232:    exit (EXIT_SUCCESS);",
          "233:  case 'f':",
          "234:    printf (\"Do only forward translation\");",
          "235:    forwardOnly = getYN ();",
          "236:    break;",
          "237:  case 'b':",
          "238:    printf (\"Do only backward translation\");",
          "239:    backOnly = getYN ();",
          "240:    break;",
          "241:  case 'p':",
          "242:    printf (\"Show input and output positions\");",
          "243:    showPositions = getYN ();",
          "244:    break;",
          "245:  case 'i':",
          "246:    printf",
          "247:      (\"Test translation/back-translation loop with minimal parameters\");",
          "248:    minimalist = getYN ();",
          "249:    break;",
          "250:  default:",
          "251:    printf (\"Bad choice.\\n\");",
          "252:    break;",
          "253:  }",
          "254:       if (forwardOnly && backOnly)",
          "255:  printf",
          "256:    (\"You cannot specify both forward-only and backward-only translation.\\n\");",
          "257:     }",
          "258:   while (inputBuffer[0] != 'r');",
          "259:   return 1;",
          "263: main (int argc, char **argv)",
          "264: {",
          "265:   char *charbuf;",
          "266:   size_t charlen;",
          "267:   widechar inbuf[BUFSIZE];",
          "268:   widechar transbuf[BUFSIZE];",
          "269:   widechar outbuf[BUFSIZE];",
          "270:   int outputPos[BUFSIZE];",
          "271:   int inputPos[BUFSIZE];",
          "272:   int inlen;",
          "273:   int translen;",
          "274:   int outlen;",
          "275:   int cursorPos = -1;",
          "276:   int realInlen = 0;",
          "277:   int k;",
          "278:   int optc;",
          "280:   set_program_name (argv[0]);",
          "282:   while ((optc = getopt_long (argc, argv, \"hv\", longopts, NULL)) != -1) {",
          "283:     switch (optc)",
          "284:       {",
          "286:       case 'v':",
          "287:         version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *) NULL);",
          "288:         exit (EXIT_SUCCESS);",
          "289:         break;",
          "290:       case 'h':",
          "291:         print_help ();",
          "292:         exit (EXIT_SUCCESS);",
          "293:         break;",
          "294:       default:",
          "295:  fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "296:    program_name);",
          "297:  exit (EXIT_FAILURE);",
          "298:         break;",
          "299:       }",
          "300:   }",
          "302:   if (optind < argc)",
          "303:     {",
          "305:       fprintf (stderr, \"%s: extra operand: %s\\n\",",
          "306:         program_name, argv[optind]);",
          "307:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "308:                program_name);",
          "309:       exit (EXIT_FAILURE);",
          "310:     }",
          "312:   validTable = NULL;",
          "313:   enteredCursorPos = -1;",
          "314:   mode = 0;",
          "315:   while (1)",
          "316:     {",
          "317:       getCommands ();",
          "318:       printf (\"Type something, press enter, and view the results.\\n\");",
          "319:       printf (\"A blank line returns to command entry.\\n\");",
          "320:       if (minimalist)",
          "321:  while (1)",
          "322:    {",
          "323:      translen = outputSize;",
          "324:      outlen = outputSize;",
          "325:      inlen = getInput ();",
          "326:      if (inlen == 0)",
          "327:        break;",
          "328:      if (!(realInlen = _lou_extParseChars (inputBuffer, inbuf)))",
          "329:        break;",
          "330:      inlen = realInlen;",
          "331:      if (!lou_translateString (table, inbuf, &inlen, transbuf,",
          "332:           &translen, NULL, NULL, 0))",
          "333:        break;",
          "334:      transbuf[translen] = 0;",
          "335:      printf (\"Translation:\\n\");",
          "337:      charbuf = u32_to_u8(transbuf, translen, NULL, &charlen);",
          "339:      charbuf = u16_to_u8(transbuf, translen, NULL, &charlen);",
          "341:      printf (\"%.*s\\n\", (int)charlen, charbuf);",
          "342:      free(charbuf);",
          "343:      if (showSizes)",
          "344:        printf (\"input length = %d; output length = %d\\n\", inlen,",
          "345:         translen);",
          "346:      lou_backTranslateString (table, transbuf, &translen, outbuf,",
          "347:          &outlen, NULL, NULL, 0);",
          "348:      printf (\"Back-translation:\\n\");",
          "350:      charbuf = u32_to_u8(outbuf, outlen, NULL, &charlen);",
          "352:      charbuf = u16_to_u8(outbuf, outlen, NULL, &charlen);",
          "354:      printf (\"%.*s\\n\", (int)charlen, charbuf);",
          "355:      free(charbuf);",
          "356:      if (showSizes)",
          "357:        printf (\"input length = %d; output length = %d.\\n\", translen,",
          "358:         outlen);",
          "359:      if (outlen == realInlen)",
          "360:        {",
          "361:   for (k = 0; k < realInlen; k++)",
          "362:     if (inbuf[k] != outbuf[k])",
          "363:       break;",
          "364:   if (k == realInlen)",
          "365:     printf (\"Perfect roundtrip!\\n\");",
          "366:        }",
          "367:    }",
          "368:       else",
          "369:  while (1)",
          "370:    {",
          "371:              memset(emphasis, 0, sizeof(formtype) * BUFSIZE);",
          "372:      for (k = 0; k < strlen (enteredEmphasis); k++)",
          "373:        emphasis[k] = (formtype) enteredEmphasis[k] - '0';",
          "374:      emphasis[k] = 0;",
          "375:      strcpy (spacing, enteredSpacing);",
          "376:      cursorPos = enteredCursorPos;",
          "377:      inlen = getInput ();",
          "378:      if (inlen == 0)",
          "379:        break;",
          "380:      outlen = outputSize;",
          "381:      if (backOnly)",
          "382:        {",
          "383:      if (!(translen = _lou_extParseChars (inputBuffer, transbuf)))",
          "384:        break;",
          "385:      inlen = realInlen;",
          "386:        }",
          "387:      else",
          "388:        {",
          "389:   translen = outputSize;",
          "390:      if (!(realInlen = _lou_extParseChars (inputBuffer, inbuf)))",
          "391:        break;",
          "392:      inlen = realInlen;",
          "393:   if (!lou_translate (table, inbuf, &inlen, transbuf,",
          "394:         &translen, emphasis, spacing,",
          "395:         &outputPos[0], &inputPos[0], &cursorPos,",
          "396:         mode))",
          "397:     break;",
          "398:   transbuf[translen] = 0;",
          "399:   if (mode & dotsIO)",
          "400:     {",
          "401:       printf (\"Translation dot patterns:\\n\");",
          "402:       printf (\"%s\\n\", _lou_showDots (transbuf, translen));",
          "403:     }",
          "405:     {",
          "406:       printf (\"Translation:\\n\");",
          "408:       charbuf = u32_to_u8(transbuf, translen, NULL, &charlen);",
          "410:       charbuf = u16_to_u8(transbuf, translen, NULL, &charlen);",
          "412:       printf (\"%.*s\\n\", (int)charlen, charbuf);",
          "413:       free(charbuf);",
          "414:       if (showSizes)",
          "415:         printf (\"input length = %d; output length = %d\\n\",",
          "416:          inlen, translen);",
          "417:     }",
          "418:        }",
          "419:      if (cursorPos != -1)",
          "420:        printf (\"Cursor position: %d\\n\", cursorPos);",
          "421:      if (enteredSpacing[0])",
          "422:        printf (\"Returned spacing: %s\\n\", spacing);",
          "423:      if (showPositions)",
          "424:        {",
          "425:   printf (\"Output positions:\\n\");",
          "426:   for (k = 0; k < inlen; k++)",
          "427:     printf (\"%d \", outputPos[k]);",
          "428:   printf (\"\\n\");",
          "429:   printf (\"Input positions:\\n\");",
          "430:   for (k = 0; k < translen; k++)",
          "431:     printf (\"%d \", inputPos[k]);",
          "432:   printf (\"\\n\");",
          "433:        }",
          "434:      if (!forwardOnly)",
          "435:        {",
          "436:   if (!lou_backTranslate (table, transbuf, &translen,",
          "437:      outbuf, &outlen,",
          "438:      emphasis, spacing, &outputPos[0],",
          "439:      &inputPos[0], &cursorPos, mode))",
          "440:     break;",
          "441:   printf (\"Back-translation:\\n\");",
          "443:   charbuf = u32_to_u8(outbuf, outlen, NULL, &charlen);",
          "445:   charbuf = u16_to_u8(outbuf, outlen, NULL, &charlen);",
          "447:   printf (\"%.*s\\n\", (int)charlen, charbuf);",
          "448:   free(charbuf);",
          "449:   if (showSizes)",
          "450:     printf (\"input length = %d; output length = %d\\n\",",
          "451:      translen, outlen);",
          "452:   if (cursorPos != -1)",
          "453:     printf (\"Cursor position: %d\\n\", cursorPos);",
          "454:   if (enteredSpacing[0])",
          "455:     printf (\"Returned spacing: %s\\n\", spacing);",
          "456:   if (showPositions)",
          "457:     {",
          "458:       printf (\"Output positions:\\n\");",
          "459:       for (k = 0; k < translen; k++)",
          "460:         printf (\"%d \", outputPos[k]);",
          "461:       printf (\"\\n\");",
          "462:       printf (\"Input positions:\\n\");",
          "463:       for (k = 0; k < outlen; k++)",
          "464:         printf (\"%d \", inputPos[k]);",
          "465:       printf (\"\\n\");",
          "466:     }",
          "467:        }",
          "468:      if (!(forwardOnly || backOnly))",
          "469:        {",
          "470:   if (outlen == realInlen)",
          "471:     {",
          "472:       for (k = 0; k < realInlen; k++)",
          "473:         if (inbuf[k] != outbuf[k])",
          "474:    break;",
          "475:       if (k == realInlen)",
          "476:         printf (\"Perfect roundtrip!\\n\");",
          "477:     }",
          "478:        }",
          "479:    }",
          "480:     }",
          "481:   lou_free ();",
          "482:   exit (EXIT_SUCCESS);",
          "",
          "[Added Lines]",
          "91: getInput(void) {",
          "92:  int inputLength;",
          "93:  inputBuffer[0] = 0;",
          "94:  if (!fgets(inputBuffer, sizeof(inputBuffer), stdin)) exit(EXIT_FAILURE);",
          "95:  inputLength = strlen(inputBuffer) - 1;",
          "97:  {",
          "98:   lou_free();",
          "99:   exit(EXIT_SUCCESS);",
          "100:  }",
          "101:  inputBuffer[inputLength] = 0;",
          "102:  return inputLength;",
          "106: getYN(void) {",
          "107:  printf(\"? y/n: \");",
          "108:  getInput();",
          "109:  if (inputBuffer[0] == 'y') return 1;",
          "110:  return 0;",
          "114: paramLetters(void) {",
          "115:  printf(\"Press one of the letters in parentheses, then enter.\\n\");",
          "116:  printf(\"(t)able, (r)un, (m)ode, (c)ursor, (e)mphasis, (s)pacing, (h)elp,\\n\");",
          "117:  printf(\"(q)uit, (f)orward-only, (b)ack-only, show-(p)ositions m(i)nimal.\\n\");",
          "118:  printf(\"test-(l)engths.\\n\");",
          "122: getCommands(void) {",
          "123:  paramLetters();",
          "124:  do {",
          "125:   printf(\"Command: \");",
          "126:   getInput();",
          "127:   switch (inputBuffer[0]) {",
          "128:   case 0:",
          "129:    break;",
          "130:   case 't':",
          "131:    do {",
          "132:     printf(\"Enter the name of a table: \");",
          "133:     getInput();",
          "134:     strcpy(table, inputBuffer);",
          "135:    } while ((validTable = lou_getTable(table)) == NULL);",
          "136:    break;",
          "137:   case 'r':",
          "138:    if (validTable == NULL) {",
          "139:     printf(\"You must enter a valid table name.\\n\");",
          "140:     inputBuffer[0] = 0;",
          "141:    }",
          "142:    break;",
          "143:   case 'm':",
          "144:    printf(\"Reset mode\");",
          "145:    if (getYN()) mode = 0;",
          "146:    printf(\"No contractions\");",
          "147:    mode |= getYN();",
          "148:    printf(\"Computer braille at cursor\");",
          "149:    mode |= 2 * getYN();",
          "150:    printf(\"Dots input and output\");",
          "151:    mode |= 4 * getYN();",
          "152:    printf(\"8-dot computer braille\");",
          "153:    mode |= 8 * getYN();",
          "154:    printf(\"Pass1 only\");",
          "155:    mode |= 16 * getYN();",
          "156:    break;",
          "157:   case 'l':",
          "158:    printf(\"Do you want to test input and output lengths\");",
          "159:    showSizes = getYN();",
          "160:    if (!showSizes) {",
          "161:     outputSize = BUFSIZE;",
          "162:     break;",
          "163:    }",
          "164:    printf(\"Enter a maximum output size: \");",
          "165:    getInput();",
          "166:    outputSize = atoi(inputBuffer);",
          "167:    if (outputSize < 0 || outputSize > BUFSIZE) {",
          "168:     printf(\"Output size must be from 0 tu %d.\\n\", BUFSIZE);",
          "169:     outputSize = BUFSIZE;",
          "170:     showSizes = 0;",
          "171:    }",
          "172:    break;",
          "173:   case 'c':",
          "174:    printf(\"Enter a cursor position: \");",
          "175:    getInput();",
          "176:    enteredCursorPos = atoi(inputBuffer);",
          "177:    if (enteredCursorPos < -1 || enteredCursorPos > outputSize) {",
          "178:     printf(\"Cursor position must be from -1 to %d.\\n\", outputSize);",
          "179:     enteredCursorPos = -1;",
          "180:    }",
          "181:    break;",
          "182:   case 'e':",
          "183:    printf(\"(Enter an x to cancel emphasis.)\\n\");",
          "184:    printf(\"Enter an emphasis string: \");",
          "185:    getInput();",
          "186:    strcpy(enteredEmphasis, inputBuffer);",
          "187:    break;",
          "188:   case 's':",
          "189:    printf(\"(Enter an x to cancel spacing.)\\n\");",
          "190:    printf(\"Enter a spacing string: \");",
          "191:    getInput();",
          "192:    strcpy(enteredSpacing, inputBuffer);",
          "193:    break;",
          "194:   case 'h':",
          "195:    printf(\"Commands: action\\n\");",
          "196:    printf(\"(t)able: Enter a table name\\n\");",
          "197:    printf(\"(r)un: run the translation/back-translation loop\\n\");",
          "198:    printf(\"(m)ode: Enter a mode parameter\\n\");",
          "199:    printf(\"(c)ursor: Enter a cursor position\\n\");",
          "200:    printf(\"(e)mphasis: Enter an emphasis string\\n\");",
          "201:    printf(\"(s)pacing: Enter a spacing string\\n\");",
          "202:    printf(\"(h)elp: print this page\\n\");",
          "203:    printf(\"(q)uit: leave the program\\n\");",
          "204:    printf(\"(f)orward-only: do only forward translation\\n\");",
          "205:    printf(\"(b)ack-only: do only back-translation\\n\");",
          "206:    printf(\"show-(p)ositions: show input and output positions\\n\");",
          "207:    printf(\"m(i)nimal: test translator and back-translator with minimal \"",
          "208:        \"parameters\\n\");",
          "209:    printf(\"test-(l)engths: test accuracy of returned lengths\\n\");",
          "210:    printf(\"\\n\");",
          "211:    paramLetters();",
          "212:    break;",
          "213:   case 'q':",
          "214:    lou_free();",
          "215:    exit(EXIT_SUCCESS);",
          "216:   case 'f':",
          "217:    printf(\"Do only forward translation\");",
          "218:    forwardOnly = getYN();",
          "219:    break;",
          "220:   case 'b':",
          "221:    printf(\"Do only backward translation\");",
          "222:    backOnly = getYN();",
          "223:    break;",
          "224:   case 'p':",
          "225:    printf(\"Show input and output positions\");",
          "226:    showPositions = getYN();",
          "227:    break;",
          "228:   case 'i':",
          "229:    printf(\"Test translation/back-translation loop with minimal parameters\");",
          "230:    minimalist = getYN();",
          "231:    break;",
          "232:   default:",
          "233:    printf(\"Bad choice.\\n\");",
          "234:    break;",
          "235:   }",
          "236:   if (forwardOnly && backOnly)",
          "237:    printf(\"You cannot specify both forward-only and backward-only \"",
          "238:        \"translation.\\n\");",
          "239:  } while (inputBuffer[0] != 'r');",
          "240:  return 1;",
          "244: main(int argc, char **argv) {",
          "245:  char *charbuf;",
          "246:  size_t charlen;",
          "247:  widechar inbuf[BUFSIZE];",
          "248:  widechar transbuf[BUFSIZE];",
          "249:  widechar outbuf[BUFSIZE];",
          "250:  int outputPos[BUFSIZE];",
          "251:  int inputPos[BUFSIZE];",
          "252:  int inlen;",
          "253:  int translen;",
          "254:  int outlen;",
          "255:  int cursorPos = -1;",
          "256:  int realInlen = 0;",
          "257:  int k;",
          "258:  int optc;",
          "260:  set_program_name(argv[0]);",
          "262:  while ((optc = getopt_long(argc, argv, \"hv\", longopts, NULL)) != -1) {",
          "263:   switch (optc) {",
          "265:   case 'v':",
          "266:    version_etc(",
          "267:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "268:    exit(EXIT_SUCCESS);",
          "269:    break;",
          "270:   case 'h':",
          "271:    print_help();",
          "272:    exit(EXIT_SUCCESS);",
          "273:    break;",
          "274:   default:",
          "275:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "276:    exit(EXIT_FAILURE);",
          "277:    break;",
          "278:   }",
          "279:  }",
          "281:  if (optind < argc) {",
          "283:   fprintf(stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind]);",
          "284:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "285:   exit(EXIT_FAILURE);",
          "286:  }",
          "288:  validTable = NULL;",
          "289:  enteredCursorPos = -1;",
          "290:  mode = 0;",
          "291:  while (1) {",
          "292:   getCommands();",
          "293:   printf(\"Type something, press enter, and view the results.\\n\");",
          "294:   printf(\"A blank line returns to command entry.\\n\");",
          "295:   if (minimalist)",
          "296:    while (1) {",
          "297:     translen = outputSize;",
          "298:     outlen = outputSize;",
          "299:     inlen = getInput();",
          "300:     if (inlen == 0) break;",
          "301:     if (!(realInlen = _lou_extParseChars(inputBuffer, inbuf))) break;",
          "302:     inlen = realInlen;",
          "303:     if (!lou_translateString(",
          "304:        table, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0))",
          "305:      break;",
          "306:     transbuf[translen] = 0;",
          "307:     printf(\"Translation:\\n\");",
          "309:     charbuf = u32_to_u8(transbuf, translen, NULL, &charlen);",
          "311:     charbuf = u16_to_u8(transbuf, translen, NULL, &charlen);",
          "313:     printf(\"%.*s\\n\", (int)charlen, charbuf);",
          "314:     free(charbuf);",
          "315:     if (showSizes)",
          "316:      printf(\"input length = %d; output length = %d\\n\", inlen, translen);",
          "317:     lou_backTranslateString(",
          "318:       table, transbuf, &translen, outbuf, &outlen, NULL, NULL, 0);",
          "319:     printf(\"Back-translation:\\n\");",
          "321:     charbuf = u32_to_u8(outbuf, outlen, NULL, &charlen);",
          "323:     charbuf = u16_to_u8(outbuf, outlen, NULL, &charlen);",
          "325:     printf(\"%.*s\\n\", (int)charlen, charbuf);",
          "326:     free(charbuf);",
          "327:     if (showSizes)",
          "328:      printf(\"input length = %d; output length = %d.\\n\", translen, outlen);",
          "329:     if (outlen == realInlen) {",
          "330:      for (k = 0; k < realInlen; k++)",
          "331:       if (inbuf[k] != outbuf[k]) break;",
          "332:      if (k == realInlen) printf(\"Perfect roundtrip!\\n\");",
          "333:     }",
          "334:    }",
          "336:    while (1) {",
          "337:     memset(emphasis, 0, sizeof(formtype) * BUFSIZE);",
          "338:     for (k = 0; k < strlen(enteredEmphasis); k++)",
          "339:      emphasis[k] = (formtype)enteredEmphasis[k] - '0';",
          "340:     emphasis[k] = 0;",
          "341:     strcpy(spacing, enteredSpacing);",
          "342:     cursorPos = enteredCursorPos;",
          "343:     inlen = getInput();",
          "344:     if (inlen == 0) break;",
          "345:     outlen = outputSize;",
          "346:     if (backOnly) {",
          "347:      if (!(translen = _lou_extParseChars(inputBuffer, transbuf))) break;",
          "348:      inlen = realInlen;",
          "349:     } else {",
          "350:      translen = outputSize;",
          "351:      if (!(realInlen = _lou_extParseChars(inputBuffer, inbuf))) break;",
          "352:      inlen = realInlen;",
          "353:      if (!lou_translate(table, inbuf, &inlen, transbuf, &translen,",
          "354:         emphasis, spacing, &outputPos[0], &inputPos[0],",
          "355:         &cursorPos, mode))",
          "356:       break;",
          "357:      transbuf[translen] = 0;",
          "358:      if (mode & dotsIO) {",
          "359:       printf(\"Translation dot patterns:\\n\");",
          "360:       printf(\"%s\\n\", _lou_showDots(transbuf, translen));",
          "361:      } else {",
          "362:       printf(\"Translation:\\n\");",
          "364:       charbuf = u32_to_u8(transbuf, translen, NULL, &charlen);",
          "366:       charbuf = u16_to_u8(transbuf, translen, NULL, &charlen);",
          "368:       printf(\"%.*s\\n\", (int)charlen, charbuf);",
          "369:       free(charbuf);",
          "370:       if (showSizes)",
          "371:        printf(\"input length = %d; output length = %d\\n\", inlen,",
          "372:          translen);",
          "373:      }",
          "374:     }",
          "375:     if (cursorPos != -1) printf(\"Cursor position: %d\\n\", cursorPos);",
          "376:     if (enteredSpacing[0]) printf(\"Returned spacing: %s\\n\", spacing);",
          "377:     if (showPositions) {",
          "378:      printf(\"Output positions:\\n\");",
          "379:      for (k = 0; k < inlen; k++) printf(\"%d \", outputPos[k]);",
          "380:      printf(\"\\n\");",
          "381:      printf(\"Input positions:\\n\");",
          "382:      for (k = 0; k < translen; k++) printf(\"%d \", inputPos[k]);",
          "383:      printf(\"\\n\");",
          "384:     }",
          "385:     if (!forwardOnly) {",
          "386:      if (!lou_backTranslate(table, transbuf, &translen, outbuf, &outlen,",
          "387:         emphasis, spacing, &outputPos[0], &inputPos[0],",
          "388:         &cursorPos, mode))",
          "389:       break;",
          "390:      printf(\"Back-translation:\\n\");",
          "392:      charbuf = u32_to_u8(outbuf, outlen, NULL, &charlen);",
          "394:      charbuf = u16_to_u8(outbuf, outlen, NULL, &charlen);",
          "396:      printf(\"%.*s\\n\", (int)charlen, charbuf);",
          "397:      free(charbuf);",
          "398:      if (showSizes)",
          "399:       printf(\"input length = %d; output length = %d\\n\", translen,",
          "400:         outlen);",
          "401:      if (cursorPos != -1) printf(\"Cursor position: %d\\n\", cursorPos);",
          "402:      if (enteredSpacing[0]) printf(\"Returned spacing: %s\\n\", spacing);",
          "403:      if (showPositions) {",
          "404:       printf(\"Output positions:\\n\");",
          "405:       for (k = 0; k < translen; k++) printf(\"%d \", outputPos[k]);",
          "406:       printf(\"\\n\");",
          "407:       printf(\"Input positions:\\n\");",
          "408:       for (k = 0; k < outlen; k++) printf(\"%d \", inputPos[k]);",
          "409:       printf(\"\\n\");",
          "410:      }",
          "411:     }",
          "412:     if (!(forwardOnly || backOnly)) {",
          "413:      if (outlen == realInlen) {",
          "414:       for (k = 0; k < realInlen; k++)",
          "415:        if (inbuf[k] != outbuf[k]) break;",
          "416:       if (k == realInlen) printf(\"Perfect roundtrip!\\n\");",
          "417:      }",
          "418:     }",
          "419:    }",
          "420:  }",
          "421:  lou_free();",
          "422:  exit(EXIT_SUCCESS);",
          "",
          "---------------"
        ],
        "tools/lou_checkhyphens.c||tools/lou_checkhyphens.c": [
          "File: tools/lou_checkhyphens.c -> tools/lou_checkhyphens.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3:    Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by",
          "4:    The BRLTTY Team",
          "7:    ViewPlus Technologies, Inc. www.viewplus.com and",
          "8:    JJB Software, Inc. www.jjb-software.com",
          "",
          "[Removed Lines]",
          "6:    Copyright (C) 2004, 2005, 2006, 2009",
          "",
          "[Added Lines]",
          "6:    Copyright (C) 2004, 2005, 2006, 2009",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:    it under the terms of the GNU General Public License as published by",
          "12:    the Free Software Foundation, either version 3 of the License, or",
          "13:    (at your option) any later version.",
          "15:    This program is distributed in the hope that it will be useful,",
          "16:    but WITHOUT ANY WARRANTY; without even the implied warranty of",
          "17:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
          "18:    GNU General Public License for more details.",
          "20:    You should have received a copy of the GNU General Public License",
          "21:    along with this program.  If not, see <http://www.gnu.org/licenses/>.",
          "25: #include <stdio.h>",
          "26: #include <string.h>",
          "27: #include <stdlib.h>",
          "",
          "[Removed Lines]",
          "24: # include <config.h>",
          "",
          "[Added Lines]",
          "24: #include <config.h>",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "31: #include \"progname.h\"",
          "32: #include \"version-etc.h\"",
          "39: };",
          "41: const char version_etc_copyright[] =",
          "44: #define AUTHORS \"John J. Boyer\"",
          "46: static void",
          "53: Check the accuracy of hyphenation in Braille translation for both\\n\\",
          "57:   -h, --help          display this help and exit\\n\\",
          "63: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "65: #endif",
          "66: #ifdef PACKAGE_URL",
          "68: #endif",
          "69: }",
          "",
          "[Removed Lines]",
          "34: static const struct option longopts[] =",
          "35: {",
          "36:   { \"help\", no_argument, NULL, 'h' },",
          "37:   { \"version\", no_argument, NULL, 'v' },",
          "38:   { NULL, 0, NULL, 0 },",
          "42:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "47: print_help (void)",
          "48: {",
          "49:   printf (\"\\",
          "50: Usage: %s [OPTIONS]\\n\", program_name);",
          "52:   fputs (\"\\",
          "54: translated and untranslated words.\\n\\n\", stdout);",
          "56:   fputs (\"\\",
          "58:   -v, --version       display version information and exit\\n\", stdout);",
          "60:   printf (\"\\n\");",
          "61:   printf (\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "64:   printf (\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "67:   printf (\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "[Added Lines]",
          "34: static const struct option longopts[] = {",
          "35:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "36:  { NULL, 0, NULL, 0 },",
          "40:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "45: print_help(void) {",
          "46:  printf(\"\\",
          "47: Usage: %s [OPTIONS]\\n\",",
          "48:    program_name);",
          "50:  fputs(\"\\",
          "52: translated and untranslated words.\\n\\n\",",
          "53:    stdout);",
          "55:  fputs(\"\\",
          "57:   -v, --version       display version information and exit\\n\",",
          "58:    stdout);",
          "60:  printf(\"\\n\");",
          "61:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "64:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "67:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "76: static char table[BUFSIZE];",
          "78: static int",
          "90: }",
          "92: static void",
          "97: }",
          "99: static int",
          "122:   }",
          "159: }",
          "161: int",
          "230:  }",
          "234: }",
          "",
          "[Removed Lines]",
          "79: getInput (void)",
          "80: {",
          "81:   int inputLength;",
          "82:   inputBuffer[0] = 0;",
          "83:   if(!fgets (inputBuffer, sizeof (inputBuffer), stdin))",
          "84:     exit(EXIT_FAILURE);",
          "85:   inputLength = strlen (inputBuffer) - 1;",
          "87:     exit (0);",
          "88:   inputBuffer[inputLength] = 0;",
          "89:   return inputLength;",
          "93: paramLetters (void)",
          "94: {",
          "95:   printf (\"Press one of the letters in parentheses, then enter.\\n\");",
          "96:   printf (\"(t)able, tr(a)nslated, (u)ntranslated, (r)un, (h)elp, (q)uit\\n\");",
          "100: getCommands (void)",
          "101: {",
          "102:   paramLetters ();",
          "103:   do",
          "104:     {",
          "105:       printf (\"Command: \");",
          "106:       getInput ();",
          "107:       switch (inputBuffer[0])",
          "108:  {",
          "109:  case 0:",
          "110:    break;",
          "111:  case 't':",
          "112:    do",
          "113:      {",
          "114:        printf (\"Enter the name of a table or a list: \");",
          "115:        getInput ();",
          "116:        strcpy (table, inputBuffer);",
          "117:        validTable = lou_getTable (table);",
          "118:        if (validTable != NULL && validTable->hyphenStatesArray == 0)",
          "119:   {",
          "120:     printf (\"No hyphenation table.\\n\");",
          "121:     validTable = NULL;",
          "123:      }",
          "124:    while (validTable == NULL);",
          "125:    break;",
          "126:  case 'a':",
          "127:    mode = 1;",
          "128:    break;",
          "129:  case 'u':",
          "130:    mode = 0;",
          "131:    break;",
          "132:  case 'r':",
          "133:    if (validTable == NULL)",
          "134:      {",
          "135:        printf (\"You must enter a valid table name or list.\\n\");",
          "136:        inputBuffer[0] = 0;",
          "137:      }",
          "138:    break;",
          "139:  case 'h':",
          "140:    printf (\"Commands: action\\n\");",
          "141:    printf (\"(t)able: Enter a table name or list\\n\");",
          "142:    printf (\"(r)un: run the hyphenation test loop\\n\");",
          "143:    printf (\"tr(a)nslated: translated input\\n\");",
          "144:    printf (\"(u)ntranslated: untranslated input\\n\");",
          "145:    printf (\"(h)elp: print this page\\n\");",
          "146:    printf (\"(q)uit: leave the program\\n\");",
          "147:    printf (\"\\n\");",
          "148:    paramLetters ();",
          "149:    break;",
          "150:  case 'q':",
          "151:    exit (0);",
          "152:  default:",
          "153:    printf (\"Bad choice.\\n\");",
          "154:    break;",
          "155:  }",
          "156:     }",
          "157:   while (inputBuffer[0] != 'r');",
          "158:   return 1;",
          "162: main (int argc, char **argv)",
          "163: {",
          "164:   widechar inbuf[BUFSIZE];",
          "165:   char hyphens[BUFSIZE];",
          "166:   int inlen;",
          "167:   int k;",
          "168:   int optc;",
          "170:   set_program_name (argv[0]);",
          "172:   while ((optc = getopt_long (argc, argv, \"hv\", longopts, NULL)) != -1)",
          "173:     switch (optc)",
          "174:       {",
          "176:       case 'v':",
          "177:         version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *) NULL);",
          "178:         exit (EXIT_SUCCESS);",
          "179:         break;",
          "180:       case 'h':",
          "181:         print_help ();",
          "182:         exit (EXIT_SUCCESS);",
          "183:         break;",
          "184:       default:",
          "185:  fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "186:    program_name);",
          "187:  exit (EXIT_FAILURE);",
          "188:         break;",
          "189:       }",
          "191:   if (optind < argc)",
          "192:     {",
          "194:       fprintf (stderr, \"%s: extra operand: %s\\n\",",
          "195:         program_name, argv[optind]);",
          "196:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "197:                program_name);",
          "198:       exit (EXIT_FAILURE);",
          "199:     }",
          "201:   validTable = NULL;",
          "202:   mode = 0;",
          "204:   while (1)",
          "205:     {",
          "206:       getCommands ();",
          "207:       printf (\"Type something, press enter, and view the results.\\n\");",
          "208:       printf (\"A blank line returns to command entry.\\n\");",
          "209:       while (1)",
          "210:  {",
          "211:    inlen = getInput ();",
          "212:    if (inlen == 0)",
          "213:      break;",
          "214:    for (k = 0; k < inlen; k++)",
          "215:      inbuf[k] = inputBuffer[k];",
          "216:    if (!lou_hyphenate (table, inbuf, inlen, hyphens, mode))",
          "217:      {",
          "218:        printf (\"Hyphenation error\\n\");",
          "219:        continue;",
          "220:      }",
          "221:    printf (\"Hyphenation mask: %s\\n\", hyphens);",
          "222:    printf (\"Hyphenated word: \");",
          "223:    for (k = 0; k < inlen; k++)",
          "224:      {",
          "225:        if (hyphens[k] == '1')",
          "226:   printf (\"-\");",
          "227:        printf (\"%c\", inbuf[k]);",
          "228:      }",
          "229:    printf (\"\\n\");",
          "231:     }",
          "232:   lou_free ();",
          "233:   return 0;",
          "",
          "[Added Lines]",
          "79: getInput(void) {",
          "80:  int inputLength;",
          "81:  inputBuffer[0] = 0;",
          "82:  if (!fgets(inputBuffer, sizeof(inputBuffer), stdin)) exit(EXIT_FAILURE);",
          "83:  inputLength = strlen(inputBuffer) - 1;",
          "85:   exit(0);",
          "86:  inputBuffer[inputLength] = 0;",
          "87:  return inputLength;",
          "91: paramLetters(void) {",
          "92:  printf(\"Press one of the letters in parentheses, then enter.\\n\");",
          "93:  printf(\"(t)able, tr(a)nslated, (u)ntranslated, (r)un, (h)elp, (q)uit\\n\");",
          "97: getCommands(void) {",
          "98:  paramLetters();",
          "99:  do {",
          "100:   printf(\"Command: \");",
          "101:   getInput();",
          "102:   switch (inputBuffer[0]) {",
          "103:   case 0:",
          "104:    break;",
          "105:   case 't':",
          "106:    do {",
          "107:     printf(\"Enter the name of a table or a list: \");",
          "108:     getInput();",
          "109:     strcpy(table, inputBuffer);",
          "110:     validTable = lou_getTable(table);",
          "111:     if (validTable != NULL && validTable->hyphenStatesArray == 0) {",
          "112:      printf(\"No hyphenation table.\\n\");",
          "113:      validTable = NULL;",
          "114:     }",
          "115:    } while (validTable == NULL);",
          "116:    break;",
          "117:   case 'a':",
          "118:    mode = 1;",
          "119:    break;",
          "120:   case 'u':",
          "121:    mode = 0;",
          "122:    break;",
          "123:   case 'r':",
          "124:    if (validTable == NULL) {",
          "125:     printf(\"You must enter a valid table name or list.\\n\");",
          "126:     inputBuffer[0] = 0;",
          "127:    }",
          "128:    break;",
          "129:   case 'h':",
          "130:    printf(\"Commands: action\\n\");",
          "131:    printf(\"(t)able: Enter a table name or list\\n\");",
          "132:    printf(\"(r)un: run the hyphenation test loop\\n\");",
          "133:    printf(\"tr(a)nslated: translated input\\n\");",
          "134:    printf(\"(u)ntranslated: untranslated input\\n\");",
          "135:    printf(\"(h)elp: print this page\\n\");",
          "136:    printf(\"(q)uit: leave the program\\n\");",
          "137:    printf(\"\\n\");",
          "138:    paramLetters();",
          "139:    break;",
          "140:   case 'q':",
          "141:    exit(0);",
          "142:   default:",
          "143:    printf(\"Bad choice.\\n\");",
          "144:    break;",
          "146:  } while (inputBuffer[0] != 'r');",
          "147:  return 1;",
          "151: main(int argc, char **argv) {",
          "152:  widechar inbuf[BUFSIZE];",
          "153:  char hyphens[BUFSIZE];",
          "154:  int inlen;",
          "155:  int k;",
          "156:  int optc;",
          "158:  set_program_name(argv[0]);",
          "160:  while ((optc = getopt_long(argc, argv, \"hv\", longopts, NULL)) != -1) switch (optc) {",
          "162:   case 'v':",
          "163:    version_etc(",
          "164:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "165:    exit(EXIT_SUCCESS);",
          "166:    break;",
          "167:   case 'h':",
          "168:    print_help();",
          "169:    exit(EXIT_SUCCESS);",
          "170:    break;",
          "171:   default:",
          "172:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "173:    exit(EXIT_FAILURE);",
          "174:    break;",
          "175:   }",
          "177:  if (optind < argc) {",
          "179:   fprintf(stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind]);",
          "180:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "181:   exit(EXIT_FAILURE);",
          "182:  }",
          "184:  validTable = NULL;",
          "185:  mode = 0;",
          "187:  while (1) {",
          "188:   getCommands();",
          "189:   printf(\"Type something, press enter, and view the results.\\n\");",
          "190:   printf(\"A blank line returns to command entry.\\n\");",
          "191:   while (1) {",
          "192:    inlen = getInput();",
          "193:    if (inlen == 0) break;",
          "194:    for (k = 0; k < inlen; k++) inbuf[k] = inputBuffer[k];",
          "195:    if (!lou_hyphenate(table, inbuf, inlen, hyphens, mode)) {",
          "196:     printf(\"Hyphenation error\\n\");",
          "197:     continue;",
          "198:    }",
          "199:    printf(\"Hyphenation mask: %s\\n\", hyphens);",
          "200:    printf(\"Hyphenated word: \");",
          "201:    for (k = 0; k < inlen; k++) {",
          "202:     if (hyphens[k] == '1') printf(\"-\");",
          "203:     printf(\"%c\", inbuf[k]);",
          "204:    }",
          "205:    printf(\"\\n\");",
          "206:   }",
          "208:  lou_free();",
          "209:  return 0;",
          "",
          "---------------"
        ],
        "tools/lou_checktable.c||tools/lou_checktable.c": [
          "File: tools/lou_checktable.c -> tools/lou_checktable.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:    it under the terms of the GNU General Public License as published by",
          "12:    the Free Software Foundation, either version 3 of the License, or",
          "13:    (at your option) any later version.",
          "15:    This program is distributed in the hope that it will be useful,",
          "16:    but WITHOUT ANY WARRANTY; without even the implied warranty of",
          "17:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
          "18:    GNU General Public License for more details.",
          "20:    You should have received a copy of the GNU General Public License",
          "21:    along with this program.  If not, see <http://www.gnu.org/licenses/>.",
          "25: #include <stdio.h>",
          "26: #include <string.h>",
          "27: #include <stdlib.h>",
          "",
          "[Removed Lines]",
          "24: # include <config.h>",
          "",
          "[Added Lines]",
          "24: #include <config.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: #include \"progname.h\"",
          "31: #include \"version-etc.h\"",
          "39: };",
          "41: const char version_etc_copyright[] =",
          "44: #define AUTHORS \"John J. Boyer\"",
          "46: static int quiet_flag = 0;",
          "48: static void",
          "55: Test a Braille translation table. If the table contains errors,\\n\\",
          "56: appropriate messages are displayed. If there are no errors the\\n\\",
          "57: message \\\"no errors found.\\\" is shown unless you specify the --quiet\\n\\",
          "61:   -h, --help          display this help and exit\\n\\",
          "62:   -v, --version       display version information and exit\\n\\",
          "68: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "70: #endif",
          "71: #ifdef PACKAGE_URL",
          "73: #endif",
          "74: }",
          "76: int",
          "129: }",
          "",
          "[Removed Lines]",
          "33: static const struct option longopts[] =",
          "34: {",
          "35:   { \"help\", no_argument, NULL, 'h' },",
          "36:   { \"version\", no_argument, NULL, 'v' },",
          "37:   { \"quiet\", no_argument, NULL, 'q' },",
          "38:   { NULL, 0, NULL, 0 },",
          "42:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "49: print_help (void)",
          "50: {",
          "51:   printf (\"\\",
          "52: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\", program_name);",
          "54:   fputs (\"\\",
          "58: option.\\n\", stdout);",
          "60:   fputs (\"\\",
          "63:   -q, --quiet         do not write to standard error if there are no errors.\\n\", stdout);",
          "65:   printf (\"\\n\");",
          "66:   printf (\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "69:   printf (\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "72:   printf (\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "77: main (int argc, char **argv)",
          "78: {",
          "79:   const TranslationTableHeader *table;",
          "80:   int optc;",
          "82:   set_program_name (argv[0]);",
          "84:   while ((optc = getopt_long (argc, argv, \"hvq\", longopts, NULL)) != -1)",
          "85:     switch (optc)",
          "86:       {",
          "88:       case 'v':",
          "89:         version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *) NULL);",
          "90:         exit (EXIT_SUCCESS);",
          "91:         break;",
          "92:       case 'h':",
          "93:         print_help ();",
          "94:         exit (EXIT_SUCCESS);",
          "95:         break;",
          "96:       case 'q':",
          "97:  quiet_flag = 1;",
          "98:         break;",
          "99:       default:",
          "100:  fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "101:    program_name);",
          "102:  exit (EXIT_FAILURE);",
          "103:         break;",
          "104:       }",
          "106:   if (optind != argc - 1)",
          "107:     {",
          "109:       if (optind < argc - 1)",
          "110:  fprintf (stderr, \"%s: extra operand: %s\\n\",",
          "111:    program_name, argv[optind + 1]);",
          "112:       else",
          "113:  fprintf (stderr, \"%s: no table specified\\n\",",
          "114:    program_name);",
          "115:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "116:                program_name);",
          "117:       exit (EXIT_FAILURE);",
          "118:     }",
          "120:   if (!(table = lou_getTable (argv[optind])))",
          "121:     {",
          "122:       lou_free ();",
          "123:       exit (EXIT_FAILURE);",
          "124:     }",
          "125:   if (quiet_flag == 0)",
          "126:     fprintf (stderr, \"No errors found.\\n\");",
          "127:   lou_free ();",
          "128:   exit (EXIT_SUCCESS);",
          "",
          "[Added Lines]",
          "33: static const struct option longopts[] = {",
          "34:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "35:  { \"quiet\", no_argument, NULL, 'q' }, { NULL, 0, NULL, 0 },",
          "39:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "46: print_help(void) {",
          "47:  printf(\"\\",
          "48: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\",",
          "49:    program_name);",
          "51:  fputs(\"\\",
          "55: option.\\n\",",
          "56:    stdout);",
          "58:  fputs(\"\\",
          "61:   -q, --quiet         do not write to standard error if there are no errors.\\n\",",
          "62:    stdout);",
          "64:  printf(\"\\n\");",
          "65:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "68:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "71:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "76: main(int argc, char **argv) {",
          "77:  const TranslationTableHeader *table;",
          "78:  int optc;",
          "80:  set_program_name(argv[0]);",
          "82:  while ((optc = getopt_long(argc, argv, \"hvq\", longopts, NULL)) != -1) switch (optc) {",
          "84:   case 'v':",
          "85:    version_etc(",
          "86:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "87:    exit(EXIT_SUCCESS);",
          "88:    break;",
          "89:   case 'h':",
          "90:    print_help();",
          "91:    exit(EXIT_SUCCESS);",
          "92:    break;",
          "93:   case 'q':",
          "94:    quiet_flag = 1;",
          "95:    break;",
          "96:   default:",
          "97:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "98:    exit(EXIT_FAILURE);",
          "99:    break;",
          "100:   }",
          "102:  if (optind != argc - 1) {",
          "104:   if (optind < argc - 1)",
          "105:    fprintf(stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind + 1]);",
          "106:   else",
          "107:    fprintf(stderr, \"%s: no table specified\\n\", program_name);",
          "108:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "109:   exit(EXIT_FAILURE);",
          "110:  }",
          "112:  if (!(table = lou_getTable(argv[optind]))) {",
          "113:   lou_free();",
          "114:   exit(EXIT_FAILURE);",
          "115:  }",
          "116:  if (quiet_flag == 0) fprintf(stderr, \"No errors found.\\n\");",
          "117:  lou_free();",
          "118:  exit(EXIT_SUCCESS);",
          "",
          "---------------"
        ],
        "tools/lou_checkyaml.c||tools/lou_checkyaml.c": [
          "File: tools/lou_checkyaml.c -> tools/lou_checkyaml.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4:    Copyright (C) 2017 Bert Frees",
          "6:    This program is free software: you can redistribute it and/or modify",
          "",
          "[Removed Lines]",
          "3:    Copyright (C) 2015, 2016 Christian Egli, Swiss Library for the Blind, Visually Impaired and Print Disabled",
          "",
          "[Added Lines]",
          "3:    Copyright (C) 2015, 2016 Christian Egli, Swiss Library for the Blind, Visually Impaired",
          "4:    and Print Disabled",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: #include \"version-etc.h\"",
          "32: #include \"brl_checks.h\"",
          "39: };",
          "41: const char version_etc_copyright[] =",
          "44: #define AUTHORS \"Christian Egli\"",
          "46: static void",
          "53: Run the tests defined in the YAML_TEST_FILE. Return 0 if all tests pass\\n\\",
          "54: or 1 if any of the tests fail. The details of failing tests are printed\\n\\",
          "58:   -h, --help          display this help and exit\\n\\",
          "64: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "66: #endif",
          "67: #ifdef PACKAGE_URL",
          "69: #endif",
          "70: }",
          "",
          "[Removed Lines]",
          "34: static const struct option longopts[] =",
          "35: {",
          "36:   { \"help\", no_argument, NULL, 'h' },",
          "37:   { \"version\", no_argument, NULL, 'v' },",
          "38:   { NULL, 0, NULL, 0 },",
          "42:   \"Copyright %s %d Swiss Library for the Blind, Visually Impaired and Print Disabled\";",
          "47: print_help (void)",
          "48: {",
          "49:   printf (\"\\",
          "50: Usage: %s YAML_TEST_FILE\\n\", program_name);",
          "52:   fputs (\"\\",
          "55: to stderr.\\n\\n\", stdout);",
          "57:   fputs (\"\\",
          "59:   -v, --version       display version information and exit\\n\", stdout);",
          "61:   printf (\"\\n\");",
          "62:   printf (\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "65:   printf (\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "68:   printf (\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "[Added Lines]",
          "35: static const struct option longopts[] = {",
          "36:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "37:  { NULL, 0, NULL, 0 },",
          "41:   \"Copyright %s %d Swiss Library for the Blind, Visually Impaired and Print \"",
          "42:   \"Disabled\";",
          "47: print_help(void) {",
          "48:  printf(\"\\",
          "49: Usage: %s YAML_TEST_FILE\\n\",",
          "50:    program_name);",
          "52:  fputs(\"\\",
          "55: to stderr.\\n\\n\",",
          "56:    stdout);",
          "58:  fputs(\"\\",
          "60:   -v, --version       display version information and exit\\n\",",
          "61:    stdout);",
          "63:  printf(\"\\n\");",
          "64:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "67:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "70:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "74: #ifdef HAVE_LIBYAML",
          "75: #include <yaml.h>",
          "87: yaml_parser_t parser;",
          "88: yaml_event_t event;",
          "",
          "[Removed Lines]",
          "77: const char* event_names[] = {\"YAML_NO_EVENT\", \"YAML_STREAM_START_EVENT\", \"YAML_STREAM_END_EVENT\",",
          "78:         \"YAML_DOCUMENT_START_EVENT\", \"YAML_DOCUMENT_END_EVENT\",",
          "79:         \"YAML_ALIAS_EVENT\", \"YAML_SCALAR_EVENT\",",
          "80:         \"YAML_SEQUENCE_START_EVENT\", \"YAML_SEQUENCE_END_EVENT\",",
          "81:         \"YAML_MAPPING_START_EVENT\", \"YAML_MAPPING_END_EVENT\"};",
          "82: const char* encoding_names[] = {\"YAML_ANY_ENCODING\", \"YAML_UTF8_ENCODING\",",
          "83:     \"YAML_UTF16LE_ENCODING\", \"YAML_UTF16BE_ENCODING\"};",
          "85: const char * inline_table_prefix = \"checkyaml_inline_\";",
          "",
          "[Added Lines]",
          "79: const char *event_names[] = { \"YAML_NO_EVENT\", \"YAML_STREAM_START_EVENT\",",
          "80:  \"YAML_STREAM_END_EVENT\", \"YAML_DOCUMENT_START_EVENT\", \"YAML_DOCUMENT_END_EVENT\",",
          "81:  \"YAML_ALIAS_EVENT\", \"YAML_SCALAR_EVENT\", \"YAML_SEQUENCE_START_EVENT\",",
          "82:  \"YAML_SEQUENCE_END_EVENT\", \"YAML_MAPPING_START_EVENT\", \"YAML_MAPPING_END_EVENT\" };",
          "83: const char *encoding_names[] = { \"YAML_ANY_ENCODING\", \"YAML_UTF8_ENCODING\",",
          "84:  \"YAML_UTF16LE_ENCODING\", \"YAML_UTF16BE_ENCODING\" };",
          "86: const char *inline_table_prefix = \"checkyaml_inline_\";",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "93: int errors = 0;",
          "94: int count = 0;",
          "98: void",
          "101: }",
          "103: void",
          "106: }",
          "108: void",
          "113: }",
          "115: char *",
          "174:  }",
          "184: }",
          "186: void",
          "227: }",
          "229: int",
          "242: }",
          "244: translationModes",
          "287: }",
          "289: int *",
          "326: }",
          "328: void",
          "341: }",
          "388: }",
          "390: void",
          "430: }",
          "433: int",
          "434: my_strlen_utf8_c(char *s) {",
          "441: }",
          "443: void",
          "444: read_test(yaml_parser_t *parser, char **tables, int direction, int hyphenation) {",
          "539: }",
          "541: void",
          "542: read_tests(yaml_parser_t *parser, char **tables, int direction, int hyphenation) {",
          "569: }",
          "",
          "[Removed Lines]",
          "96: static char const** emph_classes = NULL;",
          "99: simple_error (const char *msg, yaml_parser_t *parser, yaml_event_t *event) {",
          "100:   error_at_line(EXIT_FAILURE, 0, file_name, event->start_mark.line ? event->start_mark.line + 1 : parser->problem_mark.line + 1, \"%s\", msg);",
          "104: yaml_parse_error (yaml_parser_t *parser) {",
          "105:   error_at_line(EXIT_FAILURE, 0, file_name, parser->problem_mark.line + 1, \"%s\", parser->problem);",
          "109: yaml_error (yaml_event_type_t expected, yaml_event_t *event) {",
          "110:   error_at_line(EXIT_FAILURE, 0, file_name, event->start_mark.line + 1,",
          "111:   \"Expected %s (actual %s)\",",
          "112:   event_names[expected], event_names[event->type]);",
          "116: read_table (yaml_event_t *start_event, yaml_parser_t *parser) {",
          "117:   char *table = NULL;",
          "118:   if (start_event->type != YAML_SCALAR_EVENT ||",
          "119:       strcmp((const char *)start_event->data.scalar.value, \"table\"))",
          "120:     return 0;",
          "122:   table = malloc(sizeof(char) * MAXSTRING);",
          "123:   table[0] = '\\0';",
          "124:   yaml_event_t event;",
          "125:   if (!yaml_parser_parse(parser, &event) ||",
          "126:       !(event.type == YAML_SEQUENCE_START_EVENT ||",
          "127:  event.type == YAML_SCALAR_EVENT))",
          "128:     error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "129:     \"Expected %s or %s (actual %s)\",",
          "130:     event_names[YAML_SEQUENCE_START_EVENT],",
          "131:     event_names[YAML_SCALAR_EVENT],",
          "132:     event_names[event.type]);",
          "134:   if (event.type == YAML_SEQUENCE_START_EVENT) {",
          "135:     yaml_event_delete(&event);",
          "136:     int done = 0;",
          "137:     char *p = table;",
          "138:     while (!done) {",
          "139:       if (!yaml_parser_parse(parser, &event)) {",
          "140:  yaml_parse_error(parser);",
          "141:       }",
          "142:       if (event.type == YAML_SEQUENCE_END_EVENT) {",
          "143:  done = 1;",
          "144:       } else if (event.type == YAML_SCALAR_EVENT ) {",
          "145:  if (table != p) strcat(p++, \",\");",
          "146:  strcat(p, (const char *)event.data.scalar.value);",
          "147:  p += event.data.scalar.length;",
          "148:       }",
          "149:       yaml_event_delete(&event);",
          "150:     }",
          "151:     if (!lou_getTable(table))",
          "152:       error_at_line(EXIT_FAILURE, 0, file_name, start_event->start_mark.line + 1,",
          "153:       \"Table %s not valid\", table);",
          "154:   } else { // YAML_SCALAR_EVENT",
          "155:     yaml_char_t *p = event.data.scalar.value;",
          "156:     if (*p) while (p[1]) p++;",
          "157:     if (*p == 10 || *p == 13) {",
          "161:       sprintf(table, \"%s%d\", inline_table_prefix, rand());",
          "162:       p = event.data.scalar.value;",
          "163:       yaml_char_t *line_start = p;",
          "164:       int line_len = 0;",
          "165:       while (*p) {",
          "166:  if (*p == 10 || *p == 13) {",
          "167:    char *line = strndup((const char *)line_start, line_len);",
          "168:    lou_compileString(table, line);",
          "169:    free(line);",
          "170:    line_start = p + 1;",
          "171:    line_len = 0;",
          "172:  } else {",
          "173:    line_len++;",
          "175:  p++;",
          "176:       }",
          "177:     } else {",
          "178:       strcat(table, (const char *)event.data.scalar.value);",
          "179:     }",
          "180:     yaml_event_delete(&event);",
          "181:   }",
          "182:   emph_classes = lou_getEmphClasses(table); // get declared emphasis classes",
          "183:   return table;",
          "187: read_flags (yaml_parser_t *parser, int *direction, int *hyphenation) {",
          "188:   yaml_event_t event;",
          "189:   int parse_error = 1;",
          "194:   if (!yaml_parser_parse(parser, &event) ||",
          "195:       (event.type != YAML_MAPPING_START_EVENT))",
          "196:     yaml_error(YAML_MAPPING_START_EVENT, &event);",
          "198:   yaml_event_delete(&event);",
          "200:   while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "201:   (event.type == YAML_SCALAR_EVENT)) {",
          "202:     if (!strcmp((const char *)event.data.scalar.value, \"testmode\")) {",
          "203:       yaml_event_delete(&event);",
          "204:       if (!yaml_parser_parse(parser, &event) ||",
          "205:    (event.type != YAML_SCALAR_EVENT))",
          "206:  yaml_error(YAML_SCALAR_EVENT, &event);",
          "207:       if (!strcmp((const char *)event.data.scalar.value, \"forward\")) {",
          "209:       } else if (!strcmp((const char *)event.data.scalar.value, \"backward\")) {",
          "211:       } else if (!strcmp((const char *)event.data.scalar.value, \"hyphenate\")) {",
          "213:       } else {",
          "214:  error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "215:         \"Testmode '%s' not supported\\n\", event.data.scalar.value);",
          "216:       }",
          "217:     } else {",
          "218:       error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "219:       \"Flag '%s' not supported\\n\", event.data.scalar.value);",
          "220:     }",
          "221:   }",
          "222:   if (!parse_error)",
          "223:     yaml_parse_error(parser);",
          "224:   if (event.type != YAML_MAPPING_END_EVENT)",
          "225:     yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "226:   yaml_event_delete(&event);",
          "230: read_xfail (yaml_parser_t *parser) {",
          "231:   yaml_event_t event;",
          "233:   int xfail = 1;",
          "234:   if (!yaml_parser_parse(parser, &event) ||",
          "235:       (event.type != YAML_SCALAR_EVENT))",
          "236:     yaml_error(YAML_SCALAR_EVENT, &event);",
          "237:   if (!strcmp((const char *)event.data.scalar.value, \"false\") ||",
          "238:       !strcmp((const char *)event.data.scalar.value, \"off\"))",
          "239:     xfail = 0;",
          "240:   yaml_event_delete(&event);",
          "241:   return xfail;",
          "245: read_mode (yaml_parser_t *parser) {",
          "246:   yaml_event_t event;",
          "247:   translationModes mode = 0;",
          "248:   int parse_error = 1;",
          "250:   if (!yaml_parser_parse(parser, &event) ||",
          "251:       (event.type != YAML_SEQUENCE_START_EVENT))",
          "252:     yaml_error(YAML_SEQUENCE_START_EVENT, &event);",
          "253:   yaml_event_delete(&event);",
          "255:   while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "256:   (event.type == YAML_SCALAR_EVENT)) {",
          "257:     if (!strcmp((const char *)event.data.scalar.value, \"noContractions\")) {",
          "258:       mode |= noContractions;",
          "259:     } else if (!strcmp((const char *)event.data.scalar.value, \"compbrlAtCursor\")) {",
          "260:       mode |= compbrlAtCursor;",
          "261:     } else if (!strcmp((const char *)event.data.scalar.value, \"dotsIO\")) {",
          "262:       mode |= dotsIO;",
          "263:     } else if (!strcmp((const char *)event.data.scalar.value, \"comp8Dots\")) {",
          "264:       mode |= comp8Dots;",
          "265:     } else if (!strcmp((const char *)event.data.scalar.value, \"pass1Only\")) {",
          "266:       mode |= pass1Only;",
          "267:     } else if (!strcmp((const char *)event.data.scalar.value, \"compbrlLeftCursor\")) {",
          "268:       mode |= compbrlLeftCursor;",
          "269:     } else if (!strcmp((const char *)event.data.scalar.value, \"ucBrl\")) {",
          "270:       mode |= ucBrl;",
          "271:     } else if (!strcmp((const char *)event.data.scalar.value, \"noUndefinedDots\")) {",
          "272:       mode |= noUndefinedDots;",
          "273:     } else if (!strcmp((const char *)event.data.scalar.value, \"partialTrans\")) {",
          "274:       mode |= partialTrans;",
          "275:     } else {",
          "276:       error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "277:       \"Mode '%s' not supported\\n\", event.data.scalar.value);",
          "278:     }",
          "279:     yaml_event_delete(&event);",
          "280:   }",
          "281:   if (!parse_error)",
          "282:     yaml_parse_error(parser);",
          "283:   if (event.type != YAML_SEQUENCE_END_EVENT)",
          "284:     yaml_error(YAML_SEQUENCE_END_EVENT, &event);",
          "285:   yaml_event_delete(&event);",
          "286:   return mode;",
          "290: read_cursorPos (yaml_parser_t *parser, int len) {",
          "291:   int *pos = malloc(sizeof(int) * len);",
          "292:   int i = 0;",
          "293:   yaml_event_t event;",
          "294:   int parse_error = 1;",
          "295:   char *tail;",
          "297:   if (!yaml_parser_parse(parser, &event) ||",
          "298:       (event.type != YAML_SEQUENCE_START_EVENT))",
          "299:     yaml_error(YAML_SEQUENCE_START_EVENT, &event);",
          "300:   yaml_event_delete(&event);",
          "302:   while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "303:   (event.type == YAML_SCALAR_EVENT)) {",
          "304:     errno = 0;",
          "305:     int val = strtol((const char *)event.data.scalar.value, &tail, 0);",
          "306:     if (errno != 0)",
          "307:       error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "308:       \"Not a valid cursor position '%s'. Must be a number\\n\",",
          "309:       event.data.scalar.value);",
          "310:     if ((const char *)event.data.scalar.value == tail)",
          "311:       error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "312:       \"No digits found in cursor position '%s'. Must be a number\\n\",",
          "313:       event.data.scalar.value);",
          "314:     pos[i++] = val;",
          "315:     yaml_event_delete(&event);",
          "316:   }",
          "317:   if (i != len)",
          "318:     error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "319:     \"Too many or too few cursor positions (%i) for word of length %i\\n\", i, len);",
          "320:   if (!parse_error)",
          "321:     yaml_parse_error(parser);",
          "322:   if (event.type != YAML_SEQUENCE_END_EVENT)",
          "323:     yaml_error(YAML_SEQUENCE_END_EVENT, &event);",
          "324:   yaml_event_delete(&event);",
          "325:   return pos;",
          "329: read_typeform_string(yaml_parser_t *parser, formtype* typeform, typeforms kind, int len) {",
          "330:   yaml_event_t event;",
          "331:   int typeform_len;",
          "333:   if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SCALAR_EVENT))",
          "334:     yaml_error(YAML_SCALAR_EVENT, &event);",
          "335:   typeform_len = strlen((const char *)event.data.scalar.value);",
          "336:   if (typeform_len != len)",
          "337:     error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "338:     \"Too many or too typeforms (%i) for word of length %i\\n\", typeform_len, len);",
          "339:   update_typeform((const char *)event.data.scalar.value, typeform, kind);",
          "340:   yaml_event_delete(&event);",
          "343: formtype*",
          "344: read_typeforms (yaml_parser_t *parser, int len) {",
          "345:   yaml_event_t event;",
          "346:   formtype *typeform = calloc(len, sizeof(formtype));",
          "347:   int parse_error = 1;",
          "349:   if (!yaml_parser_parse(parser, &event) ||",
          "350:       (event.type != YAML_MAPPING_START_EVENT))",
          "351:     yaml_error(YAML_MAPPING_START_EVENT, &event);",
          "352:   yaml_event_delete(&event);",
          "354:   while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "355:   (event.type == YAML_SCALAR_EVENT)) {",
          "356:     if (strcmp((const char *)event.data.scalar.value, \"computer_braille\") == 0) {",
          "357:       yaml_event_delete(&event);",
          "358:       read_typeform_string(parser, typeform, computer_braille, len);",
          "359:     } else if (strcmp((const char *)event.data.scalar.value, \"no_translate\") == 0) {",
          "360:       yaml_event_delete(&event);",
          "361:       read_typeform_string(parser, typeform, no_translate, len);",
          "362:     } else if (strcmp((const char *)event.data.scalar.value, \"no_contract\") == 0) {",
          "363:       yaml_event_delete(&event);",
          "364:       read_typeform_string(parser, typeform, no_contract, len);",
          "365:     } else {",
          "366:       int i;",
          "367:       typeforms kind = plain_text;",
          "368:       for (i = 0; emph_classes[i]; i++) {",
          "369:         if (strcmp((const char *)event.data.scalar.value, emph_classes[i]) == 0) {",
          "370:           yaml_event_delete(&event);",
          "371:           kind = italic << i;",
          "372:           if (kind > emph_10)",
          "373:             error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "374:                           \"Typeform '%s' was not declared\\n\", event.data.scalar.value);",
          "375:           read_typeform_string(parser, typeform, kind, len);",
          "376:           break;",
          "377:         }",
          "378:       }",
          "379:     }",
          "380:   }",
          "381:   if (!parse_error)",
          "382:     yaml_parse_error(parser);",
          "384:   if (event.type != YAML_MAPPING_END_EVENT)",
          "385:     yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "386:   yaml_event_delete(&event);",
          "387:   return typeform;",
          "391: read_options (yaml_parser_t *parser, int len,",
          "392:        int *xfail, translationModes *mode,",
          "393:        formtype **typeform, int **cursorPos) {",
          "394:   yaml_event_t event;",
          "395:   char *option_name;",
          "396:   int parse_error = 1;",
          "403:   while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "404:   (event.type == YAML_SCALAR_EVENT)) {",
          "405:     option_name = strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "407:     if (!strcmp(option_name, \"xfail\")) {",
          "408:       yaml_event_delete(&event);",
          "410:     } else if (!strcmp(option_name, \"mode\")) {",
          "411:       yaml_event_delete(&event);",
          "413:     } else if (!strcmp(option_name, \"typeform\")) {",
          "414:       yaml_event_delete(&event);",
          "416:     } else if (!strcmp(option_name, \"cursorPos\")) {",
          "417:       yaml_event_delete(&event);",
          "419:     } else {",
          "420:       error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "421:       \"Unsupported option %s\", option_name);",
          "422:     }",
          "423:     free(option_name);",
          "424:   }",
          "425:   if (!parse_error)",
          "426:     yaml_parse_error(parser);",
          "427:   if (event.type != YAML_MAPPING_END_EVENT)",
          "428:     yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "429:   yaml_event_delete(&event);",
          "435:    int i = 0, j = 0;",
          "436:    while (s[i]) {",
          "437:      if ((s[i] & 0xc0) != 0x80) j++;",
          "438:      i++;",
          "439:    }",
          "440:    return j;",
          "445:   yaml_event_t event;",
          "446:   char *description = NULL;",
          "447:   char *word;",
          "448:   char *translation;",
          "449:   int xfail = 0;",
          "450:   translationModes mode = 0;",
          "451:   formtype *typeform = NULL;",
          "452:   int *cursorPos = NULL;",
          "454:   if (!yaml_parser_parse(parser, &event) ||",
          "455:       (event.type != YAML_SCALAR_EVENT))",
          "456:     simple_error(\"Word expected\", parser, &event);",
          "458:   word = strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "459:   yaml_event_delete(&event);",
          "461:   if (!yaml_parser_parse(parser, &event) ||",
          "462:       (event.type != YAML_SCALAR_EVENT))",
          "463:     simple_error(\"Translation expected\", parser, &event);",
          "465:   translation = strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "466:   yaml_event_delete(&event);",
          "468:   if (!yaml_parser_parse(parser, &event))",
          "469:     yaml_parse_error(parser);",
          "472:   if (event.type == YAML_SCALAR_EVENT) {",
          "473:     description = word;",
          "474:     word = translation;",
          "475:     translation = strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "476:     yaml_event_delete(&event);",
          "478:     if (!yaml_parser_parse(parser, &event))",
          "479:       yaml_parse_error(parser);",
          "480:   }",
          "482:   if (event.type == YAML_MAPPING_START_EVENT) {",
          "483:     yaml_event_delete(&event);",
          "484:     read_options(parser, my_strlen_utf8_c(word), &xfail, &mode, &typeform, &cursorPos);",
          "486:     if (!yaml_parser_parse(parser, &event) ||",
          "487:  (event.type != YAML_SEQUENCE_END_EVENT))",
          "488:       yaml_error(YAML_SEQUENCE_END_EVENT, &event);",
          "489:   } else if (event.type != YAML_SEQUENCE_END_EVENT) {",
          "490:     error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "491:     \"Expected %s or %s (actual %s)\",",
          "492:     event_names[YAML_MAPPING_START_EVENT],",
          "493:     event_names[YAML_SEQUENCE_END_EVENT],",
          "494:     event_names[event.type]);",
          "495:   }",
          "497:   char **table = tables;",
          "498:   while (*table) {",
          "499:     if (cursorPos) {",
          "500:       if (xfail != check_cursor_pos(*table, word, cursorPos)) {",
          "501:  if (description)",
          "502:    fprintf(stderr, \"%s\\n\", description);",
          "503:  error_at_line(0, 0, file_name, event.start_mark.line + 1,",
          "504:         (xfail ? \"Unexpected Pass\" :\"Failure\"));",
          "505:  errors++;",
          "506:       }",
          "507:     } else if (hyphenation) {",
          "508:       if (xfail != check_hyphenation(*table, word, translation)) {",
          "509:  if (description)",
          "510:    fprintf(stderr, \"%s\\n\", description);",
          "511:  error_at_line(0, 0, file_name, event.start_mark.line + 1,",
          "512:         (xfail ? \"Unexpected Pass\" :\"Failure\"));",
          "513:  errors++;",
          "514:       }",
          "515:     } else {",
          "521:       if (xfail != check_full(*table, word, typeform,",
          "522:        translation, translation_mode, NULL, direction, !xfail)) {",
          "523:  if (description)",
          "524:    fprintf(stderr, \"%s\\n\", description);",
          "525:  error_at_line(0, 0, file_name, event.start_mark.line + 1,",
          "526:         (xfail ? \"Unexpected Pass\" :\"Failure\"));",
          "527:  errors++;",
          "528:       }",
          "529:     }",
          "530:     table++;",
          "531:   }",
          "532:   yaml_event_delete(&event);",
          "533:   count++;",
          "534:   free(description);",
          "535:   free(word);",
          "536:   free(translation);",
          "537:   free(typeform);",
          "538:   free(cursorPos);",
          "543:   yaml_event_t event;",
          "544:   if (!yaml_parser_parse(parser, &event) ||",
          "545:       (event.type != YAML_SEQUENCE_START_EVENT))",
          "546:     yaml_error(YAML_SEQUENCE_START_EVENT, &event);",
          "548:   yaml_event_delete(&event);",
          "550:   int done = 0;",
          "551:   while (!done) {",
          "552:     if (!yaml_parser_parse(parser, &event)) {",
          "553:       yaml_parse_error(parser);",
          "554:     }",
          "555:     if (event.type == YAML_SEQUENCE_END_EVENT) {",
          "556:       done = 1;",
          "557:       yaml_event_delete(&event);",
          "558:     } else if (event.type == YAML_SEQUENCE_START_EVENT) {",
          "559:       yaml_event_delete(&event);",
          "560:       read_test(parser, tables, direction, hyphenation);",
          "561:     } else {",
          "562:       error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "563:       \"Expected %s or %s (actual %s)\",",
          "564:       event_names[YAML_SEQUENCE_END_EVENT],",
          "565:       event_names[YAML_SEQUENCE_START_EVENT],",
          "566:       event_names[event.type]);",
          "567:     }",
          "568:   }",
          "",
          "[Added Lines]",
          "97: static char const **emph_classes = NULL;",
          "100: simple_error(const char *msg, yaml_parser_t *parser, yaml_event_t *event) {",
          "101:  error_at_line(EXIT_FAILURE, 0, file_name,",
          "102:    event->start_mark.line ? event->start_mark.line + 1",
          "103:            : parser->problem_mark.line + 1,",
          "104:    \"%s\", msg);",
          "108: yaml_parse_error(yaml_parser_t *parser) {",
          "109:  error_at_line(EXIT_FAILURE, 0, file_name, parser->problem_mark.line + 1, \"%s\",",
          "110:    parser->problem);",
          "114: yaml_error(yaml_event_type_t expected, yaml_event_t *event) {",
          "115:  error_at_line(EXIT_FAILURE, 0, file_name, event->start_mark.line + 1,",
          "116:    \"Expected %s (actual %s)\", event_names[expected], event_names[event->type]);",
          "120: read_table(yaml_event_t *start_event, yaml_parser_t *parser) {",
          "121:  char *table = NULL;",
          "122:  if (start_event->type != YAML_SCALAR_EVENT ||",
          "123:    strcmp((const char *)start_event->data.scalar.value, \"table\"))",
          "124:   return 0;",
          "126:  table = malloc(sizeof(char) * MAXSTRING);",
          "127:  table[0] = '\\0';",
          "128:  yaml_event_t event;",
          "129:  if (!yaml_parser_parse(parser, &event) ||",
          "130:    !(event.type == YAML_SEQUENCE_START_EVENT || event.type == YAML_SCALAR_EVENT))",
          "131:   error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "132:     \"Expected %s or %s (actual %s)\", event_names[YAML_SEQUENCE_START_EVENT],",
          "133:     event_names[YAML_SCALAR_EVENT], event_names[event.type]);",
          "135:  if (event.type == YAML_SEQUENCE_START_EVENT) {",
          "136:   yaml_event_delete(&event);",
          "137:   int done = 0;",
          "138:   char *p = table;",
          "139:   while (!done) {",
          "140:    if (!yaml_parser_parse(parser, &event)) {",
          "141:     yaml_parse_error(parser);",
          "142:    }",
          "143:    if (event.type == YAML_SEQUENCE_END_EVENT) {",
          "144:     done = 1;",
          "145:    } else if (event.type == YAML_SCALAR_EVENT) {",
          "146:     if (table != p) strcat(p++, \",\");",
          "147:     strcat(p, (const char *)event.data.scalar.value);",
          "148:     p += event.data.scalar.length;",
          "149:    }",
          "150:    yaml_event_delete(&event);",
          "151:   }",
          "152:   if (!lou_getTable(table))",
          "153:    error_at_line(EXIT_FAILURE, 0, file_name, start_event->start_mark.line + 1,",
          "154:      \"Table %s not valid\", table);",
          "155:  } else {  // YAML_SCALAR_EVENT",
          "156:   yaml_char_t *p = event.data.scalar.value;",
          "157:   if (*p)",
          "158:    while (p[1]) p++;",
          "159:   if (*p == 10 || *p == 13) {",
          "163:    sprintf(table, \"%s%d\", inline_table_prefix, rand());",
          "164:    p = event.data.scalar.value;",
          "165:    yaml_char_t *line_start = p;",
          "166:    int line_len = 0;",
          "167:    while (*p) {",
          "168:     if (*p == 10 || *p == 13) {",
          "169:      char *line = strndup((const char *)line_start, line_len);",
          "170:      lou_compileString(table, line);",
          "171:      free(line);",
          "172:      line_start = p + 1;",
          "173:      line_len = 0;",
          "174:     } else {",
          "175:      line_len++;",
          "176:     }",
          "177:     p++;",
          "178:    }",
          "179:   } else {",
          "180:    strcat(table, (const char *)event.data.scalar.value);",
          "181:   }",
          "182:   yaml_event_delete(&event);",
          "184:  emph_classes = lou_getEmphClasses(table);  // get declared emphasis classes",
          "185:  return table;",
          "189: read_flags(yaml_parser_t *parser, int *direction, int *hyphenation) {",
          "190:  yaml_event_t event;",
          "191:  int parse_error = 1;",
          "196:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_MAPPING_START_EVENT))",
          "197:   yaml_error(YAML_MAPPING_START_EVENT, &event);",
          "199:  yaml_event_delete(&event);",
          "201:  while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "202:    (event.type == YAML_SCALAR_EVENT)) {",
          "203:   if (!strcmp((const char *)event.data.scalar.value, \"testmode\")) {",
          "204:    yaml_event_delete(&event);",
          "205:    if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SCALAR_EVENT))",
          "206:     yaml_error(YAML_SCALAR_EVENT, &event);",
          "207:    if (!strcmp((const char *)event.data.scalar.value, \"forward\")) {",
          "209:    } else if (!strcmp((const char *)event.data.scalar.value, \"backward\")) {",
          "211:    } else if (!strcmp((const char *)event.data.scalar.value, \"hyphenate\")) {",
          "213:    } else {",
          "214:     error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "215:       \"Testmode '%s' not supported\\n\", event.data.scalar.value);",
          "216:    }",
          "217:   } else {",
          "218:    error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "219:      \"Flag '%s' not supported\\n\", event.data.scalar.value);",
          "220:   }",
          "221:  }",
          "222:  if (!parse_error) yaml_parse_error(parser);",
          "223:  if (event.type != YAML_MAPPING_END_EVENT) yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "224:  yaml_event_delete(&event);",
          "228: read_xfail(yaml_parser_t *parser) {",
          "229:  yaml_event_t event;",
          "231:  int xfail = 1;",
          "232:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SCALAR_EVENT))",
          "233:   yaml_error(YAML_SCALAR_EVENT, &event);",
          "234:  if (!strcmp((const char *)event.data.scalar.value, \"false\") ||",
          "235:    !strcmp((const char *)event.data.scalar.value, \"off\"))",
          "236:   xfail = 0;",
          "237:  yaml_event_delete(&event);",
          "238:  return xfail;",
          "242: read_mode(yaml_parser_t *parser) {",
          "243:  yaml_event_t event;",
          "244:  translationModes mode = 0;",
          "245:  int parse_error = 1;",
          "247:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SEQUENCE_START_EVENT))",
          "248:   yaml_error(YAML_SEQUENCE_START_EVENT, &event);",
          "249:  yaml_event_delete(&event);",
          "251:  while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "252:    (event.type == YAML_SCALAR_EVENT)) {",
          "253:   if (!strcmp((const char *)event.data.scalar.value, \"noContractions\")) {",
          "254:    mode |= noContractions;",
          "255:   } else if (!strcmp((const char *)event.data.scalar.value, \"compbrlAtCursor\")) {",
          "256:    mode |= compbrlAtCursor;",
          "257:   } else if (!strcmp((const char *)event.data.scalar.value, \"dotsIO\")) {",
          "258:    mode |= dotsIO;",
          "259:   } else if (!strcmp((const char *)event.data.scalar.value, \"comp8Dots\")) {",
          "260:    mode |= comp8Dots;",
          "261:   } else if (!strcmp((const char *)event.data.scalar.value, \"pass1Only\")) {",
          "262:    mode |= pass1Only;",
          "263:   } else if (!strcmp((const char *)event.data.scalar.value, \"compbrlLeftCursor\")) {",
          "264:    mode |= compbrlLeftCursor;",
          "265:   } else if (!strcmp((const char *)event.data.scalar.value, \"ucBrl\")) {",
          "266:    mode |= ucBrl;",
          "267:   } else if (!strcmp((const char *)event.data.scalar.value, \"noUndefinedDots\")) {",
          "268:    mode |= noUndefinedDots;",
          "269:   } else if (!strcmp((const char *)event.data.scalar.value, \"partialTrans\")) {",
          "270:    mode |= partialTrans;",
          "271:   } else {",
          "272:    error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "273:      \"Mode '%s' not supported\\n\", event.data.scalar.value);",
          "274:   }",
          "275:   yaml_event_delete(&event);",
          "276:  }",
          "277:  if (!parse_error) yaml_parse_error(parser);",
          "278:  if (event.type != YAML_SEQUENCE_END_EVENT)",
          "279:   yaml_error(YAML_SEQUENCE_END_EVENT, &event);",
          "280:  yaml_event_delete(&event);",
          "281:  return mode;",
          "285: read_cursorPos(yaml_parser_t *parser, int len) {",
          "286:  int *pos = malloc(sizeof(int) * len);",
          "287:  int i = 0;",
          "288:  yaml_event_t event;",
          "289:  int parse_error = 1;",
          "290:  char *tail;",
          "292:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SEQUENCE_START_EVENT))",
          "293:   yaml_error(YAML_SEQUENCE_START_EVENT, &event);",
          "294:  yaml_event_delete(&event);",
          "296:  while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "297:    (event.type == YAML_SCALAR_EVENT)) {",
          "298:   errno = 0;",
          "299:   int val = strtol((const char *)event.data.scalar.value, &tail, 0);",
          "300:   if (errno != 0)",
          "301:    error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "302:      \"Not a valid cursor position '%s'. Must be a number\\n\",",
          "303:      event.data.scalar.value);",
          "304:   if ((const char *)event.data.scalar.value == tail)",
          "305:    error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "306:      \"No digits found in cursor position '%s'. Must be a number\\n\",",
          "307:      event.data.scalar.value);",
          "308:   pos[i++] = val;",
          "309:   yaml_event_delete(&event);",
          "310:  }",
          "311:  if (i != len)",
          "312:   error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "313:     \"Too many or too few cursor positions (%i) for word of length %i\\n\", i,",
          "314:     len);",
          "315:  if (!parse_error) yaml_parse_error(parser);",
          "316:  if (event.type != YAML_SEQUENCE_END_EVENT)",
          "317:   yaml_error(YAML_SEQUENCE_END_EVENT, &event);",
          "318:  yaml_event_delete(&event);",
          "319:  return pos;",
          "323: read_typeform_string(yaml_parser_t *parser, formtype *typeform, typeforms kind, int len) {",
          "324:  yaml_event_t event;",
          "325:  int typeform_len;",
          "327:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SCALAR_EVENT))",
          "328:   yaml_error(YAML_SCALAR_EVENT, &event);",
          "329:  typeform_len = strlen((const char *)event.data.scalar.value);",
          "330:  if (typeform_len != len)",
          "331:   error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "332:     \"Too many or too typeforms (%i) for word of length %i\\n\", typeform_len,",
          "333:     len);",
          "334:  update_typeform((const char *)event.data.scalar.value, typeform, kind);",
          "335:  yaml_event_delete(&event);",
          "338: formtype *",
          "339: read_typeforms(yaml_parser_t *parser, int len) {",
          "340:  yaml_event_t event;",
          "341:  formtype *typeform = calloc(len, sizeof(formtype));",
          "342:  int parse_error = 1;",
          "344:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_MAPPING_START_EVENT))",
          "345:   yaml_error(YAML_MAPPING_START_EVENT, &event);",
          "346:  yaml_event_delete(&event);",
          "348:  while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "349:    (event.type == YAML_SCALAR_EVENT)) {",
          "350:   if (strcmp((const char *)event.data.scalar.value, \"computer_braille\") == 0) {",
          "351:    yaml_event_delete(&event);",
          "352:    read_typeform_string(parser, typeform, computer_braille, len);",
          "353:   } else if (strcmp((const char *)event.data.scalar.value, \"no_translate\") == 0) {",
          "354:    yaml_event_delete(&event);",
          "355:    read_typeform_string(parser, typeform, no_translate, len);",
          "356:   } else if (strcmp((const char *)event.data.scalar.value, \"no_contract\") == 0) {",
          "357:    yaml_event_delete(&event);",
          "358:    read_typeform_string(parser, typeform, no_contract, len);",
          "359:   } else {",
          "360:    int i;",
          "361:    typeforms kind = plain_text;",
          "362:    for (i = 0; emph_classes[i]; i++) {",
          "363:     if (strcmp((const char *)event.data.scalar.value, emph_classes[i]) == 0) {",
          "364:      yaml_event_delete(&event);",
          "365:      kind = italic << i;",
          "366:      if (kind > emph_10)",
          "367:       error_at_line(EXIT_FAILURE, 0, file_name,",
          "368:         event.start_mark.line + 1,",
          "369:         \"Typeform '%s' was not declared\\n\",",
          "370:         event.data.scalar.value);",
          "371:      read_typeform_string(parser, typeform, kind, len);",
          "372:      break;",
          "373:     }",
          "374:    }",
          "375:   }",
          "376:  }",
          "377:  if (!parse_error) yaml_parse_error(parser);",
          "379:  if (event.type != YAML_MAPPING_END_EVENT) yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "380:  yaml_event_delete(&event);",
          "381:  return typeform;",
          "385: read_options(yaml_parser_t *parser, int len, int *xfail, translationModes *mode,",
          "386:   formtype **typeform, int **cursorPos) {",
          "387:  yaml_event_t event;",
          "388:  char *option_name;",
          "389:  int parse_error = 1;",
          "396:  while ((parse_error = yaml_parser_parse(parser, &event)) &&",
          "397:    (event.type == YAML_SCALAR_EVENT)) {",
          "398:   option_name =",
          "399:     strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "401:   if (!strcmp(option_name, \"xfail\")) {",
          "402:    yaml_event_delete(&event);",
          "404:   } else if (!strcmp(option_name, \"mode\")) {",
          "405:    yaml_event_delete(&event);",
          "407:   } else if (!strcmp(option_name, \"typeform\")) {",
          "408:    yaml_event_delete(&event);",
          "410:   } else if (!strcmp(option_name, \"cursorPos\")) {",
          "411:    yaml_event_delete(&event);",
          "413:   } else {",
          "414:    error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "415:      \"Unsupported option %s\", option_name);",
          "416:   }",
          "417:   free(option_name);",
          "418:  }",
          "419:  if (!parse_error) yaml_parse_error(parser);",
          "420:  if (event.type != YAML_MAPPING_END_EVENT) yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "421:  yaml_event_delete(&event);",
          "427:  int i = 0, j = 0;",
          "428:  while (s[i]) {",
          "429:   if ((s[i] & 0xc0) != 0x80) j++;",
          "430:   i++;",
          "431:  }",
          "432:  return j;",
          "437:  yaml_event_t event;",
          "438:  char *description = NULL;",
          "439:  char *word;",
          "440:  char *translation;",
          "441:  int xfail = 0;",
          "442:  translationModes mode = 0;",
          "443:  formtype *typeform = NULL;",
          "444:  int *cursorPos = NULL;",
          "446:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SCALAR_EVENT))",
          "447:   simple_error(\"Word expected\", parser, &event);",
          "449:  word = strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "450:  yaml_event_delete(&event);",
          "452:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SCALAR_EVENT))",
          "453:   simple_error(\"Translation expected\", parser, &event);",
          "455:  translation =",
          "456:    strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "457:  yaml_event_delete(&event);",
          "459:  if (!yaml_parser_parse(parser, &event)) yaml_parse_error(parser);",
          "462:  if (event.type == YAML_SCALAR_EVENT) {",
          "463:   description = word;",
          "464:   word = translation;",
          "465:   translation =",
          "466:     strndup((const char *)event.data.scalar.value, event.data.scalar.length);",
          "467:   yaml_event_delete(&event);",
          "469:   if (!yaml_parser_parse(parser, &event)) yaml_parse_error(parser);",
          "470:  }",
          "472:  if (event.type == YAML_MAPPING_START_EVENT) {",
          "473:   yaml_event_delete(&event);",
          "474:   read_options(",
          "475:     parser, my_strlen_utf8_c(word), &xfail, &mode, &typeform, &cursorPos);",
          "477:   if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SEQUENCE_END_EVENT))",
          "478:    yaml_error(YAML_SEQUENCE_END_EVENT, &event);",
          "479:  } else if (event.type != YAML_SEQUENCE_END_EVENT) {",
          "480:   error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "481:     \"Expected %s or %s (actual %s)\", event_names[YAML_MAPPING_START_EVENT],",
          "482:     event_names[YAML_SEQUENCE_END_EVENT], event_names[event.type]);",
          "483:  }",
          "485:  char **table = tables;",
          "486:  while (*table) {",
          "487:   if (cursorPos) {",
          "488:    if (xfail != check_cursor_pos(*table, word, cursorPos)) {",
          "489:     if (description) fprintf(stderr, \"%s\\n\", description);",
          "490:     error_at_line(0, 0, file_name, event.start_mark.line + 1,",
          "491:       (xfail ? \"Unexpected Pass\" : \"Failure\"));",
          "492:     errors++;",
          "493:    }",
          "494:   } else if (hyphenation) {",
          "495:    if (xfail != check_hyphenation(*table, word, translation)) {",
          "496:     if (description) fprintf(stderr, \"%s\\n\", description);",
          "497:     error_at_line(0, 0, file_name, event.start_mark.line + 1,",
          "498:       (xfail ? \"Unexpected Pass\" : \"Failure\"));",
          "499:     errors++;",
          "500:    }",
          "501:   } else {",
          "507:    if (xfail != check_full(*table, word, typeform, translation, translation_mode,",
          "508:          NULL, direction, !xfail)) {",
          "509:     if (description) fprintf(stderr, \"%s\\n\", description);",
          "510:     error_at_line(0, 0, file_name, event.start_mark.line + 1,",
          "511:       (xfail ? \"Unexpected Pass\" : \"Failure\"));",
          "512:     errors++;",
          "513:    }",
          "514:   }",
          "515:   table++;",
          "516:  }",
          "517:  yaml_event_delete(&event);",
          "518:  count++;",
          "519:  free(description);",
          "520:  free(word);",
          "521:  free(translation);",
          "522:  free(typeform);",
          "523:  free(cursorPos);",
          "528:  yaml_event_t event;",
          "529:  if (!yaml_parser_parse(parser, &event) || (event.type != YAML_SEQUENCE_START_EVENT))",
          "530:   yaml_error(YAML_SEQUENCE_START_EVENT, &event);",
          "532:  yaml_event_delete(&event);",
          "534:  int done = 0;",
          "535:  while (!done) {",
          "536:   if (!yaml_parser_parse(parser, &event)) {",
          "537:    yaml_parse_error(parser);",
          "538:   }",
          "539:   if (event.type == YAML_SEQUENCE_END_EVENT) {",
          "540:    done = 1;",
          "541:    yaml_event_delete(&event);",
          "542:   } else if (event.type == YAML_SEQUENCE_START_EVENT) {",
          "543:    yaml_event_delete(&event);",
          "544:    read_test(parser, tables, direction, hyphenation);",
          "545:   } else {",
          "546:    error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "547:      \"Expected %s or %s (actual %s)\", event_names[YAML_SEQUENCE_END_EVENT],",
          "548:      event_names[YAML_SEQUENCE_START_EVENT], event_names[event.type]);",
          "549:   }",
          "550:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "575: static char **",
          "576: customTableResolver(const char *tableList, const char *base) {",
          "581: }",
          "585: int",
          "586: main(int argc, char *argv[]) {",
          "620: #ifdef WITHOUT_YAML",
          "623: #else",
          "624: #ifndef HAVE_LIBYAML",
          "630: #ifndef WITHOUT_YAML",
          "631: #ifdef HAVE_LIBYAML",
          "708:  yaml_event_delete(&event);",
          "",
          "[Removed Lines]",
          "577:   static char * dummy_table[1];",
          "578:   if (strncmp(tableList, inline_table_prefix, strlen(inline_table_prefix)) == 0)",
          "579:     return dummy_table;",
          "580:   return _lou_defaultTableResolver(tableList, base);",
          "583: #endif // HAVE_LIBYAML",
          "587:   int optc;",
          "589:   set_program_name (argv[0]);",
          "591:   while ((optc = getopt_long (argc, argv, \"hv\", longopts, NULL)) != -1)",
          "592:     switch (optc) {",
          "594:     case 'v':",
          "595:       version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *) NULL);",
          "596:       exit (EXIT_SUCCESS);",
          "597:       break;",
          "598:     case 'h':",
          "599:       print_help ();",
          "600:       exit (EXIT_SUCCESS);",
          "601:       break;",
          "602:     default:",
          "603:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "604:         program_name);",
          "605:       exit (EXIT_FAILURE);",
          "606:       break;",
          "607:     }",
          "609:   if (optind != argc - 1) {",
          "611:     if (optind < argc - 1)",
          "612:       fprintf (stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind + 1]);",
          "613:     else",
          "614:       fprintf (stderr, \"%s: no YAML test file specified\\n\", program_name);",
          "616:     fprintf (stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "617:     exit (EXIT_FAILURE);",
          "618:   }",
          "621:   fprintf(stderr, \"Skipping tests for %s as yaml was disabled in configure with --without-yaml\\n\", argv[1]);",
          "622:   return EXIT_SKIPPED;",
          "625:   fprintf(stderr, \"Skipping tests for %s as libyaml was not found\\n\", argv[1]);",
          "626:   return EXIT_SKIPPED;",
          "627: #endif // not HAVE_LIBYAML",
          "628: #endif // WITHOUT_YAML",
          "633:   FILE *file;",
          "634:   yaml_parser_t parser;",
          "635:   yaml_event_t event;",
          "637:   file_name = argv[1];",
          "638:   file = fopen(file_name, \"rb\");",
          "639:   if (!file)",
          "640:     {",
          "641:       fprintf(stderr, \"%s: file not found: %s\\n\", program_name, file_name);",
          "642:       exit(3);",
          "643:     }",
          "646:   char *dir_name = strdup(file_name);",
          "647:   int i = strlen(dir_name);",
          "648:   while (i > 0) {",
          "649:     if (dir_name[i - 1] == '/' || dir_name[i - 1] == '\\\\') {",
          "650:       i--;",
          "651:       break;",
          "652:     }",
          "653:     i--;",
          "654:   }",
          "655:   dir_name[i] = '\\0';",
          "659:   chdir(dir_name);",
          "662:   lou_registerTableResolver(&customTableResolver);",
          "664:   assert(yaml_parser_initialize(&parser));",
          "666:   yaml_parser_set_input_file(&parser, file);",
          "668:   if (!yaml_parser_parse(&parser, &event) ||",
          "669:       (event.type != YAML_STREAM_START_EVENT)) {",
          "670:     yaml_error(YAML_STREAM_START_EVENT, &event);",
          "671:   }",
          "673:   if (event.data.stream_start.encoding != YAML_UTF8_ENCODING)",
          "674:     error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "675:     \"UTF-8 encoding expected (actual %s)\",",
          "676:     encoding_names[event.data.stream_start.encoding]);",
          "677:   yaml_event_delete(&event);",
          "679:   if (!yaml_parser_parse(&parser, &event) ||",
          "680:       (event.type != YAML_DOCUMENT_START_EVENT)) {",
          "681:     yaml_error(YAML_DOCUMENT_START_EVENT, &event);",
          "682:   }",
          "683:   yaml_event_delete(&event);",
          "685:   if (!yaml_parser_parse(&parser, &event) ||",
          "686:       (event.type != YAML_MAPPING_START_EVENT)) {",
          "687:     yaml_error(YAML_MAPPING_START_EVENT, &event);",
          "688:   }",
          "689:   yaml_event_delete(&event);",
          "691:   if (!yaml_parser_parse(&parser, &event))",
          "692:     simple_error(\"table expected\", &parser, &event);",
          "694:   int MAXTABLES = 10;",
          "695:   char *tables[MAXTABLES + 1];",
          "696:   while ((tables[0] = read_table(&event, &parser))) {",
          "697:     yaml_event_delete(&event);",
          "698:     int k = 1;",
          "699:     while (1) {",
          "700:       if (!yaml_parser_parse(&parser, &event))",
          "701:  error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "702:         \"Expected table or %s (actual %s)\",",
          "703:         event_names[YAML_SCALAR_EVENT],",
          "704:         event_names[event.type]);",
          "705:       if ((tables[k++] = read_table(&event, &parser))) {",
          "706:  if (k == MAXTABLES)",
          "707:    exit (EXIT_FAILURE);",
          "709:       } else",
          "710:  break;",
          "711:     }",
          "713:     if (event.type != YAML_SCALAR_EVENT)",
          "714:       yaml_error(YAML_SCALAR_EVENT, &event);",
          "716:     int direction = 0;",
          "717:     int hyphenation = 0;",
          "718:     if (!strcmp((const char *)event.data.scalar.value, \"flags\")) {",
          "719:       yaml_event_delete(&event);",
          "720:       read_flags(&parser, &direction, &hyphenation);",
          "722:       if (!yaml_parser_parse(&parser, &event) ||",
          "723:    (event.type != YAML_SCALAR_EVENT) ||",
          "724:    strcmp((const char *)event.data.scalar.value, \"tests\")) {",
          "725:  simple_error(\"tests expected\", &parser, &event);",
          "726:       }",
          "727:       yaml_event_delete(&event);",
          "728:       read_tests(&parser, tables, direction, hyphenation);",
          "730:     } else if (!strcmp((const char *)event.data.scalar.value, \"tests\")) {",
          "731:       yaml_event_delete(&event);",
          "732:       read_tests(&parser, tables, direction, hyphenation);",
          "733:     } else {",
          "734:       simple_error(\"flags or tests expected\", &parser, &event);",
          "735:     }",
          "737:     char **p = tables;",
          "738:     while (*p)",
          "739:       free(*(p++));",
          "741:     if (!yaml_parser_parse(&parser, &event))",
          "742:       error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "743:       \"Expected table or %s (actual %s)\",",
          "744:       event_names[YAML_MAPPING_END_EVENT],",
          "745:       event_names[event.type]);",
          "746:   }",
          "747:   if (event.type != YAML_MAPPING_END_EVENT)",
          "748:     yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "749:   yaml_event_delete(&event);",
          "751:   if (!yaml_parser_parse(&parser, &event) ||",
          "752:       (event.type != YAML_DOCUMENT_END_EVENT)) {",
          "753:     yaml_error(YAML_DOCUMENT_END_EVENT, &event);",
          "754:   }",
          "755:   yaml_event_delete(&event);",
          "757:   if (!yaml_parser_parse(&parser, &event) ||",
          "758:       (event.type != YAML_STREAM_END_EVENT)) {",
          "759:     yaml_error(YAML_STREAM_END_EVENT, &event);",
          "760:   }",
          "761:   yaml_event_delete(&event);",
          "763:   yaml_parser_delete(&parser);",
          "765:   free(emph_classes);",
          "766:   lou_free();",
          "768:   assert(!fclose(file));",
          "770:   printf(\"%s (%d tests, %d failure%s)\\n\", (errors ? \"FAILURE\" : \"SUCCESS\"),",
          "771:   count, errors, ((errors != 1) ? \"s\" : \"\"));",
          "773:   return errors ? 1 : 0;",
          "775: #endif // HAVE_LIBYAML",
          "776: #endif // not WITHOUT_YAML",
          "777: }",
          "",
          "[Added Lines]",
          "559:  static char *dummy_table[1];",
          "560:  if (strncmp(tableList, inline_table_prefix, strlen(inline_table_prefix)) == 0)",
          "561:   return dummy_table;",
          "562:  return _lou_defaultTableResolver(tableList, base);",
          "565: #endif  // HAVE_LIBYAML",
          "569:  int optc;",
          "571:  set_program_name(argv[0]);",
          "573:  while ((optc = getopt_long(argc, argv, \"hv\", longopts, NULL)) != -1) switch (optc) {",
          "575:   case 'v':",
          "576:    version_etc(",
          "577:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "578:    exit(EXIT_SUCCESS);",
          "579:    break;",
          "580:   case 'h':",
          "581:    print_help();",
          "582:    exit(EXIT_SUCCESS);",
          "583:    break;",
          "584:   default:",
          "585:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "586:    exit(EXIT_FAILURE);",
          "587:    break;",
          "588:   }",
          "590:  if (optind != argc - 1) {",
          "592:   if (optind < argc - 1)",
          "593:    fprintf(stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind + 1]);",
          "594:   else",
          "595:    fprintf(stderr, \"%s: no YAML test file specified\\n\", program_name);",
          "597:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "598:   exit(EXIT_FAILURE);",
          "599:  }",
          "602:  fprintf(stderr,",
          "603:    \"Skipping tests for %s as yaml was disabled in configure with \"",
          "604:    \"--without-yaml\\n\",",
          "605:    argv[1]);",
          "606:  return EXIT_SKIPPED;",
          "609:  fprintf(stderr, \"Skipping tests for %s as libyaml was not found\\n\", argv[1]);",
          "610:  return EXIT_SKIPPED;",
          "611: #endif  // not HAVE_LIBYAML",
          "612: #endif  // WITHOUT_YAML",
          "617:  FILE *file;",
          "618:  yaml_parser_t parser;",
          "619:  yaml_event_t event;",
          "621:  file_name = argv[1];",
          "622:  file = fopen(file_name, \"rb\");",
          "623:  if (!file) {",
          "624:   fprintf(stderr, \"%s: file not found: %s\\n\", program_name, file_name);",
          "625:   exit(3);",
          "626:  }",
          "628:  char *dir_name = strdup(file_name);",
          "629:  int i = strlen(dir_name);",
          "630:  while (i > 0) {",
          "631:   if (dir_name[i - 1] == '/' || dir_name[i - 1] == '\\\\') {",
          "632:    i--;",
          "633:    break;",
          "634:   }",
          "635:   i--;",
          "636:  }",
          "637:  dir_name[i] = '\\0';",
          "641:  chdir(dir_name);",
          "644:  lou_registerTableResolver(&customTableResolver);",
          "646:  assert(yaml_parser_initialize(&parser));",
          "648:  yaml_parser_set_input_file(&parser, file);",
          "650:  if (!yaml_parser_parse(&parser, &event) || (event.type != YAML_STREAM_START_EVENT)) {",
          "651:   yaml_error(YAML_STREAM_START_EVENT, &event);",
          "652:  }",
          "654:  if (event.data.stream_start.encoding != YAML_UTF8_ENCODING)",
          "655:   error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "656:     \"UTF-8 encoding expected (actual %s)\",",
          "657:     encoding_names[event.data.stream_start.encoding]);",
          "660:  if (!yaml_parser_parse(&parser, &event) ||",
          "661:    (event.type != YAML_DOCUMENT_START_EVENT)) {",
          "662:   yaml_error(YAML_DOCUMENT_START_EVENT, &event);",
          "663:  }",
          "664:  yaml_event_delete(&event);",
          "666:  if (!yaml_parser_parse(&parser, &event) || (event.type != YAML_MAPPING_START_EVENT)) {",
          "667:   yaml_error(YAML_MAPPING_START_EVENT, &event);",
          "668:  }",
          "669:  yaml_event_delete(&event);",
          "671:  if (!yaml_parser_parse(&parser, &event))",
          "672:   simple_error(\"table expected\", &parser, &event);",
          "674:  int MAXTABLES = 10;",
          "675:  char *tables[MAXTABLES + 1];",
          "676:  while ((tables[0] = read_table(&event, &parser))) {",
          "677:   yaml_event_delete(&event);",
          "678:   int k = 1;",
          "679:   while (1) {",
          "680:    if (!yaml_parser_parse(&parser, &event))",
          "681:     error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "682:       \"Expected table or %s (actual %s)\",",
          "683:       event_names[YAML_SCALAR_EVENT], event_names[event.type]);",
          "684:    if ((tables[k++] = read_table(&event, &parser))) {",
          "685:     if (k == MAXTABLES) exit(EXIT_FAILURE);",
          "686:     yaml_event_delete(&event);",
          "687:    } else",
          "688:     break;",
          "689:   }",
          "691:   if (event.type != YAML_SCALAR_EVENT) yaml_error(YAML_SCALAR_EVENT, &event);",
          "693:   int direction = 0;",
          "694:   int hyphenation = 0;",
          "695:   if (!strcmp((const char *)event.data.scalar.value, \"flags\")) {",
          "696:    yaml_event_delete(&event);",
          "697:    read_flags(&parser, &direction, &hyphenation);",
          "699:    if (!yaml_parser_parse(&parser, &event) ||",
          "700:      (event.type != YAML_SCALAR_EVENT) ||",
          "701:      strcmp((const char *)event.data.scalar.value, \"tests\")) {",
          "702:     simple_error(\"tests expected\", &parser, &event);",
          "703:    }",
          "704:    yaml_event_delete(&event);",
          "705:    read_tests(&parser, tables, direction, hyphenation);",
          "707:   } else if (!strcmp((const char *)event.data.scalar.value, \"tests\")) {",
          "708:    yaml_event_delete(&event);",
          "709:    read_tests(&parser, tables, direction, hyphenation);",
          "710:   } else {",
          "711:    simple_error(\"flags or tests expected\", &parser, &event);",
          "712:   }",
          "714:   char **p = tables;",
          "715:   while (*p) free(*(p++));",
          "717:   if (!yaml_parser_parse(&parser, &event))",
          "718:    error_at_line(EXIT_FAILURE, 0, file_name, event.start_mark.line + 1,",
          "719:      \"Expected table or %s (actual %s)\",",
          "720:      event_names[YAML_MAPPING_END_EVENT], event_names[event.type]);",
          "721:  }",
          "722:  if (event.type != YAML_MAPPING_END_EVENT) yaml_error(YAML_MAPPING_END_EVENT, &event);",
          "723:  yaml_event_delete(&event);",
          "725:  if (!yaml_parser_parse(&parser, &event) || (event.type != YAML_DOCUMENT_END_EVENT)) {",
          "726:   yaml_error(YAML_DOCUMENT_END_EVENT, &event);",
          "727:  }",
          "728:  yaml_event_delete(&event);",
          "730:  if (!yaml_parser_parse(&parser, &event) || (event.type != YAML_STREAM_END_EVENT)) {",
          "731:   yaml_error(YAML_STREAM_END_EVENT, &event);",
          "732:  }",
          "733:  yaml_event_delete(&event);",
          "735:  yaml_parser_delete(&parser);",
          "737:  free(emph_classes);",
          "738:  lou_free();",
          "740:  assert(!fclose(file));",
          "742:  printf(\"%s (%d tests, %d failure%s)\\n\", (errors ? \"FAILURE\" : \"SUCCESS\"), count,",
          "743:    errors, ((errors != 1) ? \"s\" : \"\"));",
          "745:  return errors ? 1 : 0;",
          "747: #endif  // HAVE_LIBYAML",
          "748: #endif  // not WITHOUT_YAML",
          "749: }",
          "",
          "---------------"
        ],
        "tools/lou_compare.c||tools/lou_compare.c": [
          "File: tools/lou_compare.c -> tools/lou_compare.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #define S_IWUSR 0",
          "13: #endif",
          "17: static widechar inputText[BUF_MAX], output1Text[BUF_MAX], output2Text[BUF_MAX],",
          "21: static formtype emphasis[BUF_MAX];",
          "22: static formtype emp1[BUF_MAX], emp2[BUF_MAX];",
          "23: static const char table_default[] = \"en-ueb-g2.ctb\", *table = table_default;",
          "25: static FILE *input, *passFile;",
          "26: static int inputPos[BUF_MAX], outputPos[BUF_MAX];",
          "27: static int failFile, outFile;",
          "",
          "[Removed Lines]",
          "15: #define BUF_MAX  27720",
          "18:                 expectText[BUF_MAX], expectDots[BUF_MAX],",
          "19:                 empText[BUF_MAX], etnText[BUF_MAX], tmpText[BUF_MAX];",
          "20: static int inputLen, output1Len, output2Len, expectLen, empLen = 0, etnLen = 0, etnHave, tmpLen;",
          "24: static char *charText, inputLine[BUF_MAX], origInput[BUF_MAX], origEmp[BUF_MAX], origEtn[BUF_MAX];",
          "",
          "[Added Lines]",
          "15: #define BUF_MAX 27720",
          "18:   expectText[BUF_MAX], expectDots[BUF_MAX], empText[BUF_MAX], etnText[BUF_MAX],",
          "19:   tmpText[BUF_MAX];",
          "20: static int inputLen, output1Len, output2Len, expectLen, empLen = 0, etnLen = 0, etnHave,",
          "21:               tmpLen;",
          "25: static char *charText, inputLine[BUF_MAX], origInput[BUF_MAX], origEmp[BUF_MAX],",
          "26:   origEtn[BUF_MAX];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: static int blank_out = 0, blank_pass = 1, blank_fail = 0;",
          "30: static int out_more = 0, out_pos = 0, in_line = 0, paused = 0;",
          "37: widechar underText[BUF_MAX];",
          "38: char underLine[BUF_MAX];",
          "",
          "[Removed Lines]",
          "32: static unsigned short uni = 0xfeff, space = 0x0020, dash = 0x002d,",
          "33:                bar = 0x007c, plus = 0x002b, tab = 0x0009;",
          "34: static unsigned int nl = 0x000a000d;//TODO:  doall.pl chokes on ueb-08",
          "",
          "[Added Lines]",
          "34: static unsigned short uni = 0xfeff, space = 0x0020, dash = 0x002d, bar = 0x007c,",
          "35:        plus = 0x002b, tab = 0x0009;",
          "36: static unsigned int nl = 0x000a000d;  // TODO:  doall.pl chokes on ueb-08",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77: char directTransLine[BUF_MAX];",
          "78: int directTransLen;",
          "82:  char *crs = line;",
          "97: }",
          "101:  char *sft, *crs = line;",
          "106:    sft = crs;",
          "109:    sft[1] = 0;",
          "110:    sft--;",
          "113:     sft[1] = sft[0];",
          "114:     sft--;",
          "115:    }",
          "",
          "[Removed Lines]",
          "80: static void trimLine(char *line)",
          "81: {",
          "83:  while(*crs)",
          "84:  if(*crs == '\\n' || *crs == '\\r')",
          "85:  {",
          "87:   crs--;",
          "93:   return;",
          "94:  }",
          "95:  else",
          "96:   crs++;",
          "99: static void addSlashes(char *line)",
          "100: {",
          "102:  while(*crs)",
          "103:  {",
          "104:   if(*crs == '\\\\')",
          "105:   {",
          "107:    while(*sft)",
          "108:     sft++;",
          "111:    while(sft > crs)",
          "112:    {",
          "",
          "[Added Lines]",
          "82: static void",
          "83: trimLine(char *line) {",
          "85:  while (*crs)",
          "86:   if (*crs == '\\n' || *crs == '\\r') {",
          "88:    crs--;",
          "94:    return;",
          "95:   } else",
          "96:    crs++;",
          "99: static void",
          "100: addSlashes(char *line) {",
          "102:  while (*crs) {",
          "103:   if (*crs == '\\\\') {",
          "105:    while (*sft) sft++;",
          "108:    while (sft > crs) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "117:    crs++;",
          "118:   }",
          "119:   crs++;",
          "121: }",
          "125:  int i;",
          "129:   in_line++;",
          "130:   trimLine(inputLine);",
          "131:   strcpy(line, inputLine);",
          "135:    (*len)++;",
          "138:   }",
          "141:   return 1;",
          "145:   fprintf(stderr, \"ERROR:  unexpected on of file, #%d\\n\", in_line);",
          "146:   return 0;",
          "147:  }",
          "148: }",
          "152:  tmpLen = _lou_extParseChars(token, tmpText);",
          "153:  write(file, tmpText, tmpLen * 2);",
          "156:  write(file, text, len * 2);",
          "157:  write(file, &nl, 2);",
          "158: }",
          "162:  int result;",
          "163:  int i;",
          "166:  input = stdin;",
          "189:  passFile = fopen(\"pass.txt\", \"w\");",
          "190:  outFile = open(\"output.txt\", O_TRUNC | O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);",
          "191:  write(outFile, &uni, 2);",
          "193:  failFile = open(\"fail.txt\", O_TRUNC | O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);",
          "194:  write(failFile, &uni, 2);",
          "197:  memset(emphasis, 0, BUF_MAX);",
          "201:   in_line++;",
          "202:   trimLine(inputLine);",
          "211:    continue;",
          "212:   }",
          "215:    paused = 1;",
          "216:    continue;",
          "217:   }",
          "228:     write(failFile, &nl, 2);",
          "229:     blank_fail = 1;",
          "230:    }",
          "233:     write(outFile, &nl, 2);",
          "234:     blank_out = 1;",
          "235:    }",
          "236:    continue;",
          "249:   }",
          "254:     continue;",
          "256:    inputLen = _lou_extParseChars(inputLine, inputText);",
          "261:      blank_pass = 1;",
          "263:     }",
          "265:     write(outFile, inputText, inputLen * 2);",
          "266:     write(outFile, &nl, 2);",
          "267:     blank_out = 0;",
          "",
          "[Removed Lines]",
          "120:  }",
          "123: static int inputEmphasis(typeforms type, char *line, widechar *text, int *len)",
          "124: {",
          "127:  if(fgets(inputLine, BUF_MAX - 97, input))",
          "128:  {",
          "133:   for(i = 0; inputLine[i]; i++)",
          "134:   {",
          "136:    if(inputLine[i] != ' ')",
          "137:     emphasis[i] |= type;",
          "139:   if(*len)",
          "142:  }",
          "143:  else",
          "144:  {",
          "150: static void outputEmphasis(const int file, const int one_line, const char *token, const widechar *text, const int len)",
          "151: {",
          "154:  if(!one_line)",
          "155:   write(file, &nl, 2);",
          "160: int main(int argn, char **args)",
          "161: {",
          "165:  result = 0;",
          "168:  for(i = 1; args[i]; i++)",
          "169:  if(args[i][0] == '-' && args[i][1] == 'f')",
          "170:  {",
          "171:   i++;",
          "172:   input = fopen(args[i], \"r\");",
          "173:   if(!input)",
          "174:   {",
          "175:    fprintf(stderr, \"ERROR:  cannot open input file %s\\n\", args[i]);",
          "176:    return 1;",
          "177:   }",
          "178:  }",
          "179:  else if(args[i][0] == '-' && args[i][1] == 't')",
          "180:  {",
          "181:   i++;",
          "182:   table = args[i];",
          "183:  }",
          "184:  else if(args[i][0] == '-' && args[i][1] == 'm')",
          "185:   out_more = 1;",
          "186:  else if(args[i][0] == '-' && args[i][1] == 'p')",
          "187:   out_pos = 1;",
          "199:  while(fgets(inputLine, BUF_MAX - 97, input))",
          "200:  {",
          "204:   if(!strncmp(\"~end\", inputLine, 4))",
          "205:    break;",
          "207:   if(paused)",
          "208:   {",
          "209:    if(!strncmp(\"~start\", inputLine, 6))",
          "210:     paused = 0;",
          "213:   if(!strncmp(\"~stop\", inputLine, 5))",
          "214:   {",
          "219:   if(!inputLine[0])",
          "220:   {",
          "226:    if(!blank_fail)",
          "227:    {",
          "231:    if(!blank_out)",
          "232:    {",
          "237:   }",
          "239:   if(!strncmp(\"~force\", inputLine, 6))",
          "240:   {",
          "241:   if(fgets(inputLine, BUF_MAX - 97, input))",
          "242:   {",
          "243:    in_line++;",
          "244:    trimLine(inputLine);",
          "245:    goto force_inputLine;",
          "246:   }",
          "247:   else",
          "248:    continue;",
          "251:   if(inputLine[0] == '#')",
          "252:   {",
          "253:    if(inputLine[1] == '#')",
          "255:    addSlashes(inputLine);",
          "257:    if(inputLine[1] != '~')",
          "258:    {",
          "259:     if(!blank_pass)",
          "260:     {",
          "",
          "[Added Lines]",
          "116:  }",
          "119: static int",
          "120: inputEmphasis(typeforms type, char *line, widechar *text, int *len) {",
          "123:  if (fgets(inputLine, BUF_MAX - 97, input)) {",
          "128:   for (i = 0; inputLine[i]; i++) {",
          "130:    if (inputLine[i] != ' ') emphasis[i] |= type;",
          "132:   if (*len) *len = _lou_extParseChars(line, text);",
          "134:  } else {",
          "140: static void",
          "141: outputEmphasis(const int file, const int one_line, const char *token,",
          "142:   const widechar *text, const int len) {",
          "145:  if (!one_line) write(file, &nl, 2);",
          "150: int",
          "151: main(int argn, char **args) {",
          "155:  result = 0;",
          "158:  for (i = 1; args[i]; i++)",
          "159:   if (args[i][0] == '-' && args[i][1] == 'f') {",
          "160:    i++;",
          "161:    input = fopen(args[i], \"r\");",
          "162:    if (!input) {",
          "163:     fprintf(stderr, \"ERROR:  cannot open input file %s\\n\", args[i]);",
          "164:     return 1;",
          "165:    }",
          "166:   } else if (args[i][0] == '-' && args[i][1] == 't') {",
          "167:    i++;",
          "168:    table = args[i];",
          "169:   } else if (args[i][0] == '-' && args[i][1] == 'm')",
          "170:    out_more = 1;",
          "171:   else if (args[i][0] == '-' && args[i][1] == 'p')",
          "172:    out_pos = 1;",
          "184:  while (fgets(inputLine, BUF_MAX - 97, input)) {",
          "188:   if (!strncmp(\"~end\", inputLine, 4)) break;",
          "190:   if (paused) {",
          "191:    if (!strncmp(\"~start\", inputLine, 6)) paused = 0;",
          "194:   if (!strncmp(\"~stop\", inputLine, 5)) {",
          "199:   if (!inputLine[0]) {",
          "205:    if (!blank_fail) {",
          "209:    if (!blank_out) {",
          "216:   if (!strncmp(\"~force\", inputLine, 6)) {",
          "217:    if (fgets(inputLine, BUF_MAX - 97, input)) {",
          "218:     in_line++;",
          "219:     trimLine(inputLine);",
          "220:     goto force_inputLine;",
          "221:    } else",
          "223:   }",
          "225:   if (inputLine[0] == '#') {",
          "226:    if (inputLine[1] == '#') continue;",
          "227:    addSlashes(inputLine);",
          "229:    if (inputLine[1] != '~') {",
          "230:     if (!blank_pass) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "270:    write(failFile, &nl, 2);",
          "271:    blank_fail = 0;",
          "272:    continue;",
          "294:   }",
          "295:   }",
          "313:     }",
          "314:    }",
          "326:   }",
          "327:   }",
          "343:   }",
          "351:   }",
          "359:   }",
          "367:   }",
          "374:   }",
          "381:   }",
          "388:   }",
          "395:   }",
          "403:   }",
          "411:   }",
          "419:   }",
          "421:   memcpy(emp1, emphasis, BUF_MAX * sizeof(formtype));",
          "422:   memcpy(emp2, emphasis, BUF_MAX * sizeof(formtype));",
          "426:   strcpy(origInput, inputLine);",
          "429:   inputLen = _lou_extParseChars(inputLine, inputText);",
          "431:   expectLen = 0;",
          "434:    in_line++;",
          "435:    trimLine(inputLine);",
          "440:     expectLen = _lou_extParseChars(inputLine, expectText);",
          "441:    }",
          "442:   }",
          "444:   i = inputLen;",
          "445:   output1Len = BUF_MAX;",
          "458:   inputLen = i;",
          "462:    output2Len = BUF_MAX;",
          "475:    inputLen = i;",
          "476:   }",
          "482:     write(outFile, empText, empLen * 2);",
          "483:     write(outFile, &nl, 2);",
          "484:    }",
          "487:     write(outFile, etnText, etnLen * 2);",
          "488:     write(outFile, &nl, 2);",
          "489:    }",
          "502:     outputEmphasis(outFile, 0, \"~trans_note_1\", tnote1Text, tnote1Len);",
          "504:     outputEmphasis(outFile, 0, \"~trans_note_2\", tnote2Text, tnote2Len);",
          "506:     outputEmphasis(outFile, 0, \"~trans_note_3\", tnote3Text, tnote3Len);",
          "508:     outputEmphasis(outFile, 0, \"~trans_note_4\", tnote4Text, tnote4Len);",
          "510:     outputEmphasis(outFile, 0, \"~trans_note_5\", tnote5Text, tnote5Len);",
          "513:     outputEmphasis(outFile, 0, \"~no_contract\", noContractText, noContractLen);",
          "518:    write(outFile, inputText, inputLen * 2);",
          "521:     char buf[7];",
          "522:     write(outFile, &nl, 2);",
          "540:    }",
          "541:    write(outFile, &nl, 2);",
          "543:    write(outFile, output1Text, output1Len * 2);",
          "546:     char buf[7];",
          "547:     write(outFile, &nl, 2);",
          "565:    }",
          "566:    write(outFile, &nl, 2);",
          "570:     write(outFile, output2Text, output2Len * 2);",
          "571:     write(outFile, &nl, 2);",
          "572:    }",
          "574:    write(outFile, &nl, 2);",
          "575:    blank_out = 0;",
          "580:    result = 1;",
          "582:    fail_cnt++;",
          "584:    write(failFile, tmpText, tmpLen * 2);",
          "585:    write(failFile, inputText, inputLen * 2);",
          "586:    write(failFile, &nl, 2);",
          "589:     tmpLen = _lou_extParseChars(\"emp:    \", tmpText);",
          "590:     write(failFile, tmpText, tmpLen * 2);",
          "591:     write(failFile, empText, empLen * 2);",
          "592:     write(failFile, &nl, 2);",
          "593:    }",
          "596:     tmpLen = _lou_extParseChars(\"etn:    \", tmpText);",
          "597:     write(failFile, tmpText, tmpLen * 2);",
          "598:     write(failFile, etnText, etnLen * 2);",
          "599:     write(failFile, &nl, 2);",
          "600:    }",
          "626:     outputEmphasis(failFile, 1, \"nocont:  \", noContractText, noContractLen);",
          "632:    write(failFile, tmpText, tmpLen * 2);",
          "633:    write(failFile, expectText, expectLen * 2);",
          "634:    write(failFile, &nl, 2);",
          "638:     tmpLen = _lou_extParseChars(\"        \", tmpText);",
          "639:     write(failFile, tmpText, tmpLen * 2);",
          "641:      write(failFile, tmpText, expectLen * 2);",
          "644:      tmpLen = _lou_extParseChars(\"FAIL\", tmpText);",
          "645:      write(failFile, tmpText, tmpLen * 2);",
          "646:     }",
          "647:     write(failFile, &nl, 2);",
          "648:    }",
          "651:    write(failFile, tmpText, tmpLen * 2);",
          "652:    write(failFile, output1Text, output1Len * 2);",
          "653:    write(failFile, &nl, 2);",
          "657:     tmpLen = _lou_extParseChars(\"        \", tmpText);",
          "658:     write(failFile, tmpText, tmpLen * 2);",
          "659:     write(failFile, output2Text, output2Len * 2);",
          "660:     write(failFile, &nl, 2);",
          "661:    }",
          "663:    blank_fail = 0;",
          "667:    pass_cnt++;",
          "668:    printf(\"%s\\n\", origInput);",
          "669:    fprintf(passFile, \"%s\\n\", origInput);",
          "670:    blank_pass = 0;",
          "671:   }",
          "674:   memset(emphasis, 0, BUF_MAX);",
          "683:  }",
          "687:   float percent = (float)pass_cnt / (float)(pass_cnt + fail_cnt);",
          "688:   printf(\"%f%%\\t%d\\t%d\\n\", percent, pass_cnt, fail_cnt);",
          "689:  }",
          "691:  fclose(passFile);",
          "692:  close(outFile);",
          "693:  close(failFile);",
          "695:  return result;",
          "696: }",
          "",
          "[Removed Lines]",
          "273:   }",
          "275:   if(!strncmp(\"~emp\", inputLine, 4))",
          "276:   {",
          "277:   if(fgets(inputLine, BUF_MAX - 97, input))",
          "278:   {",
          "279:    in_line++;",
          "280:    trimLine(inputLine);",
          "281:    strcpy(origEmp, inputLine);",
          "282:    memset(emphasis, 0, BUF_MAX);",
          "283:    for(empLen = 0; inputLine[empLen]; empLen++)",
          "284:     emphasis[empLen] = inputLine[empLen] - '0';",
          "285:    emphasis[empLen] = 0;",
          "286:    if(empLen)",
          "287:     empLen = _lou_extParseChars(origEmp, empText);",
          "288:    continue;",
          "289:   }",
          "290:   else",
          "291:   {",
          "292:    fprintf(stderr, \"ERROR:  unexpected on of file, #%d\\n\", in_line);",
          "293:    return 1;",
          "298:   if(!strncmp(\"~etn\", inputLine, 4))",
          "299:   {",
          "300:   if(fgets(inputLine, BUF_MAX - 97, input))",
          "301:   {",
          "302:    in_line++;",
          "303:    trimLine(inputLine);",
          "304:    strcpy(origEtn, inputLine);",
          "305:    etnLen = etnHave = 0;",
          "306:    for(i = 0; inputLine[i]; i++)",
          "307:    {",
          "308:     etnLen++;",
          "309:     if(inputLine[i] - '0')",
          "310:     {",
          "311:      etnHave = 1;",
          "312:      emphasis[i] |= (inputLine[i] - '0') << 8;",
          "316:    if(etnHave)",
          "317:     etnLen = _lou_extParseChars(origEtn, etnText);",
          "318:    else",
          "319:     etnLen = 0;",
          "320:    continue;",
          "321:   }",
          "322:   else",
          "323:   {",
          "324:    fprintf(stderr, \"ERROR:  unexpected on of file, #%d\\n\", in_line);",
          "325:    return 1;",
          "329:   if(!strncmp(\"~under\", inputLine, 6))",
          "330:   {",
          "331:   if(inputEmphasis(underline, underLine, underText, &underLen))",
          "332:    continue;",
          "333:   else",
          "334:    return 1;",
          "335:   }",
          "337:   if(!strncmp(\"~bold\", inputLine, 5))",
          "338:   {",
          "339:   if(inputEmphasis(bold, boldLine, boldText, &boldLen))",
          "340:    continue;",
          "341:   else",
          "342:    return 1;",
          "345:   if(!strncmp(\"~italic\", inputLine, 7))",
          "346:   {",
          "347:   if(inputEmphasis(italic, italicLine, italicText, &italicLen))",
          "348:    continue;",
          "349:   else",
          "350:    return 1;",
          "353:   if(!strncmp(\"~script\", inputLine, 7))",
          "354:   {",
          "355:   if(inputEmphasis(emph_4, scriptLine, scriptText, &scriptLen))",
          "356:    continue;",
          "357:   else",
          "358:    return 1;",
          "361:   if(!strncmp(\"~trans_note_1\", inputLine, 13))",
          "362:   {",
          "363:   if(inputEmphasis(emph_6, tnote1Line, tnote1Text, &tnote1Len))",
          "364:    continue;",
          "365:   else",
          "366:    return 1;",
          "368:   if(!strncmp(\"~trans_note_2\", inputLine, 13))",
          "369:   {",
          "370:   if(inputEmphasis(emph_7, tnote2Line, tnote2Text, &tnote2Len))",
          "371:    continue;",
          "372:   else",
          "373:    return 1;",
          "375:   if(!strncmp(\"~trans_note_3\", inputLine, 13))",
          "376:   {",
          "377:   if(inputEmphasis(emph_8, tnote3Line, tnote3Text, &tnote3Len))",
          "378:    continue;",
          "379:   else",
          "380:    return 1;",
          "382:   if(!strncmp(\"~trans_note_4\", inputLine, 13))",
          "383:   {",
          "384:   if(inputEmphasis(emph_9, tnote4Line, tnote4Text, &tnote4Len))",
          "385:    continue;",
          "386:   else",
          "387:    return 1;",
          "389:   if(!strncmp(\"~trans_note_5\", inputLine, 13))",
          "390:   {",
          "391:   if(inputEmphasis(emph_10, tnote5Line, tnote5Text, &tnote5Len))",
          "392:    continue;",
          "393:   else",
          "394:    return 1;",
          "397:   if(!strncmp(\"~no_contract\", inputLine, 12))",
          "398:   {",
          "399:   if(inputEmphasis(no_contract, noContractLine, noContractText, &noContractLen))",
          "400:    continue;",
          "401:   else",
          "402:    return 1;",
          "405:   if(!strncmp(\"~direct_trans\", inputLine, 13))",
          "406:   {",
          "407:   if(inputEmphasis(computer_braille, directTransLine, directTransText, &directTransLen))",
          "408:    continue;",
          "409:   else",
          "410:    return 1;",
          "413:   if(!strncmp(\"~trans_note\", inputLine, 11))",
          "414:   {",
          "415:   if(inputEmphasis(emph_5, tnoteLine, tnoteText, &tnoteLen))",
          "416:    continue;",
          "417:   else",
          "418:    return 1;",
          "424:   force_inputLine:",
          "427:   addSlashes(inputLine);",
          "428:   memset(inputText, 0, BUF_MAX * sizeof(widechar));",
          "432:   if(fgets(inputLine, BUF_MAX - 97, input))",
          "433:   {",
          "437:    if(inputLine[0])",
          "438:    {",
          "439:     addSlashes(inputLine);",
          "446:   lou_translate(",
          "447:    table,",
          "448:    inputText,",
          "449:    &inputLen,",
          "450:    output1Text,",
          "451:    &output1Len,",
          "452:    emp1,",
          "453:    NULL,",
          "454:    inputPos,",
          "455:    outputPos,",
          "456:    NULL,",
          "457:    0);",
          "460:   if(out_more)",
          "461:   { i = inputLen;",
          "463:    lou_translate(",
          "464:     table,",
          "465:     inputText,",
          "466:     &inputLen,",
          "467:     output2Text,",
          "468:     &output2Len,",
          "469:     emp2,",
          "470:     NULL,",
          "471:     NULL,",
          "472:     NULL,",
          "473:     NULL,",
          "474:     dotsIO | ucBrl);",
          "478:   if(!expectLen)",
          "479:   {",
          "480:    if(empLen)",
          "481:    {",
          "485:    if(etnLen)",
          "486:    {",
          "490:    if(boldLen)",
          "491:     outputEmphasis(outFile, 0, \"~bold\", boldText, boldLen);",
          "492:    if(underLen)",
          "493:     outputEmphasis(outFile, 0, \"~under\", underText, underLen);",
          "494:    if(italicLen)",
          "495:     outputEmphasis(outFile, 0, \"~italic\", italicText, italicLen);",
          "496:    if(scriptLen)",
          "497:     outputEmphasis(outFile, 0, \"~script\", scriptText, scriptLen);",
          "498:    if(tnoteLen)",
          "499:     outputEmphasis(outFile, 0, \"~trans_note\", tnoteText, tnoteLen);",
          "501:    if(tnote1Len)",
          "503:    if(tnote2Len)",
          "505:    if(tnote3Len)",
          "507:    if(tnote4Len)",
          "509:    if(tnote5Len)",
          "512:    if(noContractLen)",
          "515:    if(directTransLen)",
          "516:     outputEmphasis(outFile, 0, \"~direct_trans\", directTransText, directTransLen);",
          "519:    if(out_pos)",
          "520:    {",
          "523:     for(i = 0; i < inputLen; i++)",
          "524:     if(inputPos[i] < 10)",
          "525:     {",
          "526:      buf[0] = inputPos[i] + '0';",
          "527:      buf[1] = 0;",
          "528:      tmpLen = _lou_extParseChars(buf, tmpText);",
          "529:      write(outFile, tmpText, tmpLen * 2);",
          "530:     }",
          "531:     else if(inputPos[i] < 36)",
          "532:     {",
          "533:      buf[0] = (inputPos[i] - 10) + 'a';",
          "534:      buf[1] = 0;",
          "535:      tmpLen = _lou_extParseChars(buf, tmpText);",
          "536:      write(outFile, tmpText, tmpLen * 2);",
          "537:     }",
          "538:     else",
          "539:      write(outFile, &plus, 2);",
          "544:    if(out_pos)",
          "545:    {",
          "548:     for(i = 0; i < output1Len; i++)",
          "549:     if(outputPos[i] < 10)",
          "550:     {",
          "551:      buf[0] = outputPos[i] + '0';",
          "552:      buf[1] = 0;",
          "553:      tmpLen = _lou_extParseChars(buf, tmpText);",
          "554:      write(outFile, tmpText, tmpLen * 2);",
          "555:     }",
          "556:     else if(outputPos[i] < 36)",
          "557:     {",
          "558:      buf[0] = (outputPos[i] - 10) + 'a';",
          "559:      buf[1] = 0;",
          "560:      tmpLen = _lou_extParseChars(buf, tmpText);",
          "561:      write(outFile, tmpText, tmpLen * 2);",
          "562:     }",
          "563:     else",
          "564:      write(outFile, &plus, 2);",
          "568:    if(out_more)",
          "569:    {",
          "576:   }",
          "577:   else if(   expectLen != output1Len",
          "578:           || memcmp(output1Text, expectText, expectLen * 2))",
          "579:   {",
          "583:     tmpLen = _lou_extParseChars(\"in:     \", tmpText);",
          "587:    if(empLen)",
          "588:    {",
          "594:    if(etnLen)",
          "595:    {",
          "601:    if(underLen)",
          "602:     outputEmphasis(failFile, 1, \"under:  \", underText, underLen);",
          "603:    if(boldLen)",
          "604:     outputEmphasis(failFile, 1, \"bold:   \", boldText, boldLen);",
          "605:    if(italicLen)",
          "606:     outputEmphasis(failFile, 1, \"ital:   \", italicText, italicLen);",
          "607:    if(scriptLen)",
          "608:     outputEmphasis(failFile, 1, \"scpt:   \", scriptText, scriptLen);",
          "609:    if(resetLen)",
          "610:     outputEmphasis(failFile, 1, \"wrst:   \", resetText, resetLen);",
          "611:    if(tnoteLen)",
          "612:     outputEmphasis(failFile, 1, \"tnote:  \", tnoteText, tnoteLen);",
          "614:    if(tnote1Len)",
          "615:     outputEmphasis(failFile, 1, \"note1:  \", tnote1Text, tnote1Len);",
          "616:    if(tnote2Len)",
          "617:     outputEmphasis(failFile, 1, \"note2:  \", tnote2Text, tnote2Len);",
          "618:    if(tnote3Len)",
          "619:     outputEmphasis(failFile, 1, \"note3:  \", tnote3Text, tnote3Len);",
          "620:    if(tnote4Len)",
          "621:     outputEmphasis(failFile, 1, \"note4:  \", tnote4Text, tnote4Len);",
          "622:    if(tnote5Len)",
          "623:     outputEmphasis(failFile, 1, \"note5:  \", tnote5Text, tnote5Len);",
          "625:    if(noContractLen)",
          "628:    if(directTransLen)",
          "629:     outputEmphasis(failFile, 1, \"~direct_trans\", directTransText, directTransLen);",
          "631:     tmpLen = _lou_extParseChars(\"ueb:    \", tmpText);",
          "636:    if(out_more)",
          "637:    {",
          "640:     if(lou_charToDots(\"en-ueb-g2.ctb\", expectText, tmpText, expectLen, ucBrl))",
          "642:     else",
          "643:     {",
          "650:     tmpLen = _lou_extParseChars(\"lou:    \", tmpText);",
          "655:    if(out_more)",
          "656:    {",
          "664:   }",
          "665:   else",
          "666:   {",
          "675:   tnote5Len =",
          "676:   tnote4Len =",
          "677:   tnote3Len =",
          "678:   tnote2Len =",
          "679:   tnote1Len =",
          "680:   tnoteLen =",
          "681:   resetLen =",
          "682:   scriptLen = italicLen = underLen = boldLen = empLen = etnLen = 0;",
          "685:  if(pass_cnt + fail_cnt)",
          "686:  {",
          "",
          "[Added Lines]",
          "245:   if (!strncmp(\"~emp\", inputLine, 4)) {",
          "246:    if (fgets(inputLine, BUF_MAX - 97, input)) {",
          "247:     in_line++;",
          "248:     trimLine(inputLine);",
          "249:     strcpy(origEmp, inputLine);",
          "250:     memset(emphasis, 0, BUF_MAX);",
          "251:     for (empLen = 0; inputLine[empLen]; empLen++)",
          "252:      emphasis[empLen] = inputLine[empLen] - '0';",
          "253:     emphasis[empLen] = 0;",
          "254:     if (empLen) empLen = _lou_extParseChars(origEmp, empText);",
          "255:     continue;",
          "256:    } else {",
          "257:     fprintf(stderr, \"ERROR:  unexpected on of file, #%d\\n\", in_line);",
          "258:     return 1;",
          "259:    }",
          "262:   if (!strncmp(\"~etn\", inputLine, 4)) {",
          "263:    if (fgets(inputLine, BUF_MAX - 97, input)) {",
          "264:     in_line++;",
          "265:     trimLine(inputLine);",
          "266:     strcpy(origEtn, inputLine);",
          "267:     etnLen = etnHave = 0;",
          "268:     for (i = 0; inputLine[i]; i++) {",
          "269:      etnLen++;",
          "270:      if (inputLine[i] - '0') {",
          "271:       etnHave = 1;",
          "272:       emphasis[i] |= (inputLine[i] - '0') << 8;",
          "273:      }",
          "276:     if (etnHave)",
          "277:      etnLen = _lou_extParseChars(origEtn, etnText);",
          "278:     else",
          "279:      etnLen = 0;",
          "280:     continue;",
          "281:    } else {",
          "282:     fprintf(stderr, \"ERROR:  unexpected on of file, #%d\\n\", in_line);",
          "283:     return 1;",
          "287:   if (!strncmp(\"~under\", inputLine, 6)) {",
          "288:    if (inputEmphasis(underline, underLine, underText, &underLen))",
          "289:     continue;",
          "290:    else",
          "291:     return 1;",
          "294:   if (!strncmp(\"~bold\", inputLine, 5)) {",
          "295:    if (inputEmphasis(bold, boldLine, boldText, &boldLen))",
          "296:     continue;",
          "297:    else",
          "298:     return 1;",
          "301:   if (!strncmp(\"~italic\", inputLine, 7)) {",
          "302:    if (inputEmphasis(italic, italicLine, italicText, &italicLen))",
          "303:     continue;",
          "304:    else",
          "305:     return 1;",
          "308:   if (!strncmp(\"~script\", inputLine, 7)) {",
          "309:    if (inputEmphasis(emph_4, scriptLine, scriptText, &scriptLen))",
          "310:     continue;",
          "311:    else",
          "312:     return 1;",
          "315:   if (!strncmp(\"~trans_note_1\", inputLine, 13)) {",
          "316:    if (inputEmphasis(emph_6, tnote1Line, tnote1Text, &tnote1Len))",
          "317:     continue;",
          "318:    else",
          "319:     return 1;",
          "321:   if (!strncmp(\"~trans_note_2\", inputLine, 13)) {",
          "322:    if (inputEmphasis(emph_7, tnote2Line, tnote2Text, &tnote2Len))",
          "323:     continue;",
          "324:    else",
          "325:     return 1;",
          "327:   if (!strncmp(\"~trans_note_3\", inputLine, 13)) {",
          "328:    if (inputEmphasis(emph_8, tnote3Line, tnote3Text, &tnote3Len))",
          "329:     continue;",
          "330:    else",
          "331:     return 1;",
          "333:   if (!strncmp(\"~trans_note_4\", inputLine, 13)) {",
          "334:    if (inputEmphasis(emph_9, tnote4Line, tnote4Text, &tnote4Len))",
          "335:     continue;",
          "336:    else",
          "337:     return 1;",
          "339:   if (!strncmp(\"~trans_note_5\", inputLine, 13)) {",
          "340:    if (inputEmphasis(emph_10, tnote5Line, tnote5Text, &tnote5Len))",
          "341:     continue;",
          "342:    else",
          "343:     return 1;",
          "346:   if (!strncmp(\"~no_contract\", inputLine, 12)) {",
          "347:    if (inputEmphasis(",
          "348:       no_contract, noContractLine, noContractText, &noContractLen))",
          "349:     continue;",
          "350:    else",
          "351:     return 1;",
          "354:   if (!strncmp(\"~direct_trans\", inputLine, 13)) {",
          "355:    if (inputEmphasis(computer_braille, directTransLine, directTransText,",
          "356:       &directTransLen))",
          "357:     continue;",
          "358:    else",
          "359:     return 1;",
          "362:   if (!strncmp(\"~trans_note\", inputLine, 11)) {",
          "363:    if (inputEmphasis(emph_5, tnoteLine, tnoteText, &tnoteLen))",
          "364:     continue;",
          "365:    else",
          "366:     return 1;",
          "372:  force_inputLine:",
          "375:   addSlashes(inputLine);",
          "376:   memset(inputText, 0, BUF_MAX * sizeof(widechar));",
          "380:   if (fgets(inputLine, BUF_MAX - 97, input)) {",
          "384:    if (inputLine[0]) {",
          "385:     addSlashes(inputLine);",
          "392:   lou_translate(table, inputText, &inputLen, output1Text, &output1Len, emp1, NULL,",
          "393:     inputPos, outputPos, NULL, 0);",
          "396:   if (out_more) {",
          "397:    i = inputLen;",
          "399:    lou_translate(table, inputText, &inputLen, output2Text, &output2Len, emp2,",
          "400:      NULL, NULL, NULL, NULL, dotsIO | ucBrl);",
          "404:   if (!expectLen) {",
          "405:    if (empLen) {",
          "409:    if (etnLen) {",
          "413:    if (boldLen) outputEmphasis(outFile, 0, \"~bold\", boldText, boldLen);",
          "414:    if (underLen) outputEmphasis(outFile, 0, \"~under\", underText, underLen);",
          "415:    if (italicLen) outputEmphasis(outFile, 0, \"~italic\", italicText, italicLen);",
          "416:    if (scriptLen) outputEmphasis(outFile, 0, \"~script\", scriptText, scriptLen);",
          "417:    if (tnoteLen) outputEmphasis(outFile, 0, \"~trans_note\", tnoteText, tnoteLen);",
          "419:    if (tnote1Len)",
          "421:    if (tnote2Len)",
          "423:    if (tnote3Len)",
          "425:    if (tnote4Len)",
          "427:    if (tnote5Len)",
          "430:    if (noContractLen)",
          "433:    if (directTransLen)",
          "434:     outputEmphasis(",
          "435:       outFile, 0, \"~direct_trans\", directTransText, directTransLen);",
          "438:    if (out_pos) {",
          "441:     for (i = 0; i < inputLen; i++)",
          "442:      if (inputPos[i] < 10) {",
          "443:       buf[0] = inputPos[i] + '0';",
          "444:       buf[1] = 0;",
          "445:       tmpLen = _lou_extParseChars(buf, tmpText);",
          "446:       write(outFile, tmpText, tmpLen * 2);",
          "447:      } else if (inputPos[i] < 36) {",
          "448:       buf[0] = (inputPos[i] - 10) + 'a';",
          "449:       buf[1] = 0;",
          "450:       tmpLen = _lou_extParseChars(buf, tmpText);",
          "451:       write(outFile, tmpText, tmpLen * 2);",
          "452:      } else",
          "453:       write(outFile, &plus, 2);",
          "458:    if (out_pos) {",
          "461:     for (i = 0; i < output1Len; i++)",
          "462:      if (outputPos[i] < 10) {",
          "463:       buf[0] = outputPos[i] + '0';",
          "464:       buf[1] = 0;",
          "465:       tmpLen = _lou_extParseChars(buf, tmpText);",
          "466:       write(outFile, tmpText, tmpLen * 2);",
          "467:      } else if (outputPos[i] < 36) {",
          "468:       buf[0] = (outputPos[i] - 10) + 'a';",
          "469:       buf[1] = 0;",
          "470:       tmpLen = _lou_extParseChars(buf, tmpText);",
          "471:       write(outFile, tmpText, tmpLen * 2);",
          "472:      } else",
          "473:       write(outFile, &plus, 2);",
          "477:    if (out_more) {",
          "484:   } else if (expectLen != output1Len ||",
          "485:     memcmp(output1Text, expectText, expectLen * 2)) {",
          "489:    tmpLen = _lou_extParseChars(\"in:     \", tmpText);",
          "493:    if (empLen) {",
          "499:    if (etnLen) {",
          "505:    if (underLen) outputEmphasis(failFile, 1, \"under:  \", underText, underLen);",
          "506:    if (boldLen) outputEmphasis(failFile, 1, \"bold:   \", boldText, boldLen);",
          "507:    if (italicLen) outputEmphasis(failFile, 1, \"ital:   \", italicText, italicLen);",
          "508:    if (scriptLen) outputEmphasis(failFile, 1, \"scpt:   \", scriptText, scriptLen);",
          "509:    if (resetLen) outputEmphasis(failFile, 1, \"wrst:   \", resetText, resetLen);",
          "510:    if (tnoteLen) outputEmphasis(failFile, 1, \"tnote:  \", tnoteText, tnoteLen);",
          "512:    if (tnote1Len) outputEmphasis(failFile, 1, \"note1:  \", tnote1Text, tnote1Len);",
          "513:    if (tnote2Len) outputEmphasis(failFile, 1, \"note2:  \", tnote2Text, tnote2Len);",
          "514:    if (tnote3Len) outputEmphasis(failFile, 1, \"note3:  \", tnote3Text, tnote3Len);",
          "515:    if (tnote4Len) outputEmphasis(failFile, 1, \"note4:  \", tnote4Text, tnote4Len);",
          "516:    if (tnote5Len) outputEmphasis(failFile, 1, \"note5:  \", tnote5Text, tnote5Len);",
          "518:    if (noContractLen)",
          "521:    if (directTransLen)",
          "522:     outputEmphasis(",
          "523:       failFile, 1, \"~direct_trans\", directTransText, directTransLen);",
          "525:    tmpLen = _lou_extParseChars(\"ueb:    \", tmpText);",
          "530:    if (out_more) {",
          "533:     if (lou_charToDots(",
          "534:        \"en-ueb-g2.ctb\", expectText, tmpText, expectLen, ucBrl))",
          "536:     else {",
          "543:    tmpLen = _lou_extParseChars(\"lou:    \", tmpText);",
          "548:    if (out_more) {",
          "556:   } else {",
          "565:   tnote5Len = tnote4Len = tnote3Len = tnote2Len = tnote1Len = tnoteLen = resetLen =",
          "566:     scriptLen = italicLen = underLen = boldLen = empLen = etnLen = 0;",
          "569:  if (pass_cnt + fail_cnt) {",
          "",
          "---------------"
        ],
        "tools/lou_debug.c||tools/lou_debug.c": [
          "File: tools/lou_debug.c -> tools/lou_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:    it under the terms of the GNU General Public License as published by",
          "12:    the Free Software Foundation, either version 3 of the License, or",
          "13:    (at your option) any later version.",
          "15:    This program is distributed in the hope that it will be useful,",
          "16:    but WITHOUT ANY WARRANTY; without even the implied warranty of",
          "17:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
          "18:    GNU General Public License for more details.",
          "20:    You should have received a copy of the GNU General Public License",
          "21:    along with this program.  If not, see <http://www.gnu.org/licenses/>.",
          "25: #include <stdio.h>",
          "26: #include <string.h>",
          "27: #include <stdlib.h>",
          "",
          "[Removed Lines]",
          "24: # include <config.h>",
          "",
          "[Added Lines]",
          "24: #include <config.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: #include \"unistr.h\"",
          "32: #include \"version-etc.h\"",
          "39: };",
          "41: const char version_etc_copyright[] =",
          "44: #define AUTHORS \"John J. Boyer\"",
          "46: static void",
          "53: Examine and debug Braille translation tables. This program allows you\\n\\",
          "54: to inspect liblouis translation tables and gather information about\\n\\",
          "55: them, such as forward and backward rules, characters and dot patterns,\\n\\",
          "56: specific opcodes, the size of a table, whether a hyphenation\\n\\",
          "57: table is used, how many passes the translation takes and much\\n\\",
          "61:   -h, --help          display this help and exit\\n\\",
          "67: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "69: #endif",
          "70: #ifdef PACKAGE_URL",
          "72: #endif",
          "73: }",
          "",
          "[Removed Lines]",
          "34: static const struct option longopts[] =",
          "35: {",
          "36:   { \"help\", no_argument, NULL, 'h' },",
          "37:   { \"version\", no_argument, NULL, 'v' },",
          "38:   { NULL, 0, NULL, 0 },",
          "42:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "47: print_help (void)",
          "48: {",
          "49:   printf (\"\\",
          "50: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\", program_name);",
          "52:   fputs (\"\\",
          "58: more.\\n\\n\", stdout);",
          "60:   fputs (\"\\",
          "62:   -v, --version       display version information and exit\\n\", stdout);",
          "64:   printf (\"\\n\");",
          "65:   printf (\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "68:   printf (\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "71:   printf (\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "[Added Lines]",
          "34: static const struct option longopts[] = {",
          "35:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "36:  { NULL, 0, NULL, 0 },",
          "40:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "45: print_help(void) {",
          "46:  printf(\"\\",
          "47: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\",",
          "48:    program_name);",
          "50:  fputs(\"\\",
          "56: more.\\n\\n\",",
          "57:    stdout);",
          "59:  fputs(\"\\",
          "61:   -v, --version       display version information and exit\\n\",",
          "62:    stdout);",
          "64:  printf(\"\\n\");",
          "65:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "68:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "71:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78: static char inputBuffer[BUFSIZE];",
          "80: static int",
          "92: }",
          "95: print_chars(const widechar *buffer, int length) {",
          "98: #ifdef WIDECHARS_ARE_UCS4",
          "100: #else",
          "102: #endif",
          "105: }",
          "107: static int",
          "144:  }",
          "148: }",
          "150: static int",
          "179: }",
          "181: static int",
          "212: }",
          "214: static int",
          "245: }",
          "247: static int",
          "277: }",
          "279: static int",
          "309: }",
          "311: static int",
          "321: }",
          "323: static int",
          "330: }",
          "332: static int",
          "384: }",
          "386: static char *",
          "392: }",
          "394: static int",
          "411: }",
          "413: static int",
          "444: }",
          "446: static int",
          "477: }",
          "479: static int",
          "502: }",
          "504: static void",
          "512: }",
          "514: static void",
          "518: }",
          "520: static int",
          "637: }",
          "639: static void",
          "648: }",
          "650: static void",
          "654: }",
          "656: static int",
          "710: }",
          "712: int",
          "760: }",
          "",
          "[Removed Lines]",
          "81: getInput (void)",
          "82: {",
          "83:   int inputLength;",
          "84:   inputBuffer[0] = 0;",
          "85:   if (!fgets (inputBuffer, sizeof (inputBuffer), stdin))",
          "86:     exit (EXIT_FAILURE);",
          "87:   inputLength = strlen (inputBuffer) - 1;",
          "89:     exit (EXIT_FAILURE);",
          "90:   inputBuffer[inputLength] = 0;",
          "91:   return inputLength;",
          "94: static char*",
          "96:   static uint8_t result_buf[BUFSIZE];",
          "97:   size_t result_len = BUFSIZE - 1;",
          "99:   u32_to_u8(buffer, length, result_buf, &result_len);",
          "101:   u16_to_u8(buffer, length, result_buf, &result_len);",
          "103:   result_buf[result_len] = 0;",
          "104:   return result_buf;",
          "108: printRule (TranslationTableRule * thisRule, int mode)",
          "109: {",
          "110:   printf (\"Rule: \");",
          "111:   printf (\"opcode=%s, \", _lou_findOpcodeName (thisRule->opcode));",
          "112:   if (thisRule->before)",
          "113:     printf (\"before=%x, \", thisRule->before);",
          "114:   if (thisRule->after)",
          "115:     printf (\"after=%x, \", thisRule->after);",
          "116:   switch (thisRule->opcode)",
          "117:     {",
          "118:     case CTO_Context:",
          "119:     case CTO_Correct:",
          "120:     case CTO_SwapCd:",
          "121:     case CTO_SwapDd:",
          "122:     case CTO_Pass2:",
          "123:     case CTO_Pass3:",
          "124:     case CTO_Pass4:",
          "125:       printf (\"code=%s \", print_chars(thisRule->charsdots, thisRule->charslen",
          "126:           + thisRule->dotslen));",
          "127:       break;",
          "128:     default:",
          "129:       if (mode == 0)",
          "130:  {",
          "131:    printf (\"chars=%s, \", print_chars(thisRule->charsdots,",
          "132:          thisRule->charslen));",
          "133:    printf (\"dots=%s, \",",
          "134:     _lou_showDots (&thisRule->charsdots[thisRule->charslen],",
          "135:        thisRule->dotslen));",
          "136:  }",
          "137:       else",
          "138:  {",
          "139:    printf (\"dots=%s, \",",
          "140:     _lou_showDots (&thisRule->charsdots[thisRule->charslen],",
          "141:        thisRule->dotslen));",
          "142:    printf (\"chars=%s, \", print_chars(thisRule->charsdots,",
          "143:          thisRule->charslen));",
          "145:       break;",
          "146:     }",
          "147:   return 1;",
          "151: printCharacter (TranslationTableCharacter * thisChar, int mode)",
          "152: {",
          "153:   TranslationTableRule *thisRule;",
          "154:   TranslationTableOffset nextRule;",
          "155:   if (mode == 0)",
          "156:     {",
          "157:       printf (\"Char: \");",
          "158:       printf (\"real=%s, \", print_chars(&thisChar->realchar, 1));",
          "159:       printf (\"upper=%s, \", print_chars(&thisChar->uppercase, 1));",
          "160:       printf (\"lower=%s, \", print_chars(&thisChar->lowercase, 1));",
          "161:     }",
          "162:   else",
          "163:     printf (\"Dots: real=%s, \", _lou_showDots (&thisChar->realchar, 1));",
          "164:   printf (\"attr=%s, \", _lou_showAttributes (thisChar->attributes));",
          "165:   nextRule = thisChar->otherRules;",
          "166:   while (nextRule)",
          "167:     {",
          "168:       thisRule = (TranslationTableRule *) & table->ruleArea[nextRule];",
          "169:       if (nextRule == thisChar->definitionRule)",
          "170:  printf (\"definition \");",
          "171:       printRule (thisRule, mode);",
          "172:       printf (\"\\n\");",
          "173:       if (mode == 0)",
          "174:  nextRule = thisRule->charsnext;",
          "175:       else",
          "176:  nextRule = thisRule->dotsnext;",
          "177:     }",
          "178:   return 1;",
          "182: show_characters (int startHash)",
          "183: {",
          "184:   int k;",
          "185:   TranslationTableCharacter *thisChar;",
          "186:   TranslationTableOffset nextChar;",
          "187:   printf (\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "188:   if (startHash < 0)",
          "189:     k = 0;",
          "190:   else",
          "191:     k = startHash;",
          "192:   for (; k < HASHNUM; k++)",
          "193:     if (table->characters[k])",
          "194:       {",
          "195:  printf (\"Hash=%d\\n\", k);",
          "196:  nextChar = table->characters[k];",
          "197:  while (nextChar)",
          "198:    {",
          "199:      thisChar =",
          "200:        (TranslationTableCharacter *) & table->ruleArea[nextChar];",
          "201:      printCharacter (thisChar, 0);",
          "202:      printf (\"=> \");",
          "203:      getInput ();",
          "204:      if (*inputBuffer == 'h')",
          "205:        break;",
          "206:      if (*inputBuffer == 'e')",
          "207:        return 1;",
          "208:      nextChar = thisChar->next;",
          "209:    }",
          "210:       }",
          "211:   return 1;",
          "215: show_dots (int startHash)",
          "216: {",
          "217:   int k;",
          "218:   TranslationTableCharacter *thisDots;",
          "219:   TranslationTableOffset nextDots;",
          "220:   printf (\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "221:   if (startHash < 0)",
          "222:     k = 0;",
          "223:   else",
          "224:     k = startHash;",
          "225:   for (; k < HASHNUM; k++)",
          "226:     if (table->dots[k])",
          "227:       {",
          "228:  printf (\"Hash=%d\\n\", k);",
          "229:  nextDots = table->dots[k];",
          "230:  while (nextDots)",
          "231:    {",
          "232:      thisDots =",
          "233:        (TranslationTableCharacter *) & table->ruleArea[nextDots];",
          "234:      printCharacter (thisDots, 1);",
          "235:      printf (\"=> \");",
          "236:      getInput ();",
          "237:      if (*inputBuffer == 'h')",
          "238:        break;",
          "239:      if (*inputBuffer == 'e')",
          "240:        return 1;",
          "241:      nextDots = thisDots->next;",
          "242:    }",
          "243:       }",
          "244:   return 1;",
          "248: show_forRules (int startHash)",
          "249: {",
          "250:   int k;",
          "251:   TranslationTableRule *thisRule;",
          "252:   TranslationTableOffset nextRule;",
          "253:   printf (\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "254:   if (startHash < 0)",
          "255:     k = 0;",
          "256:   else",
          "257:     k = startHash;",
          "258:   for (; k < HASHNUM; k++)",
          "259:     if (table->forRules[k])",
          "260:       {",
          "261:  printf (\"Hash=%d\\n\", k);",
          "262:  nextRule = table->forRules[k];",
          "263:  while (nextRule)",
          "264:    {",
          "265:      thisRule = (TranslationTableRule *) & table->ruleArea[nextRule];",
          "266:      printRule (thisRule, 0);",
          "267:      printf (\"=> \");",
          "268:      getInput ();",
          "269:      if (*inputBuffer == 'h')",
          "270:        break;",
          "271:      if (*inputBuffer == 'e')",
          "272:        return 1;",
          "273:      nextRule = thisRule->charsnext;",
          "274:    }",
          "275:       }",
          "276:   return 1;",
          "280: show_backRules (int startHash)",
          "281: {",
          "282:   int k;",
          "283:   TranslationTableRule *thisRule;",
          "284:   TranslationTableOffset nextRule;",
          "285:   printf (\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "286:   if (startHash < 0)",
          "287:     k = 0;",
          "288:   else",
          "289:     k = startHash;",
          "290:   for (; k < HASHNUM; k++)",
          "291:     if (table->backRules[k])",
          "292:       {",
          "293:  printf (\"Hash=%d\\n\", k);",
          "294:  nextRule = table->backRules[k];",
          "295:  while (nextRule)",
          "296:    {",
          "297:      thisRule = (TranslationTableRule *) & table->ruleArea[nextRule];",
          "298:      printRule (thisRule, 1);",
          "299:      printf (\"=> \");",
          "300:      getInput ();",
          "301:      if (*inputBuffer == 'h')",
          "302:        break;",
          "303:      if (*inputBuffer == 'e')",
          "304:        return 1;",
          "305:      nextRule = thisRule->dotsnext;",
          "306:    }",
          "307:       }",
          "308:   return 1;",
          "312: print_brailleIndicator (TranslationTableOffset offset, char *opcode)",
          "313: {",
          "314:   TranslationTableRule *thisRule;",
          "315:   if (!offset)",
          "316:     return 0;",
          "317:   thisRule = (TranslationTableRule *) & table->ruleArea[offset];",
          "318:   printf (\"%s %s\\n\", opcode,",
          "319:    _lou_showDots (&thisRule->charsdots[0], thisRule->dotslen));",
          "320:   return 1;",
          "324: print_phraseLength (TranslationTableOffset offset, char *opcode)",
          "325: {",
          "326:   if (!offset)",
          "327:     return 0;",
          "328:   printf (\"%s %d\\n\", opcode, offset);",
          "329:   return 1;",
          "333: show_brailleIndicators (void)",
          "334: {",
          "335:   char name[BUFSIZE];",
          "336:   char *emphNames[] = {\"begemphphrase %s\",",
          "337:          \"endemphphrase %s before\",",
          "338:          \"endemphphrase %s after\",",
          "339:          \"begemphword %s\",",
          "340:          \"endemphword %s\",",
          "341:          \"emphletter %s\",",
          "342:          \"begemph %s\",",
          "343:          \"endemph %s\",",
          "344:          NULL};",
          "345:   char *capsNames[] = {\"firstwordcaps\",",
          "346:          \"lastwordcapsbefore\",",
          "347:          \"lastwordcapsafter\",",
          "348:          \"begcaps\",",
          "349:          \"endcaps\",",
          "350:          \"capsletter\",",
          "351:          \"capsword\",",
          "352:          \"capswordstop\",",
          "353:          NULL};",
          "357:   for (EmphCodeOffset offset = 0; capsNames[offset]; offset++) {",
          "358:     print_brailleIndicator (table->emphRules[capsRule][offset],capsNames[offset]);",
          "359:   }",
          "360:   print_phraseLength (table->emphRules[capsRule][lenPhraseOffset], \"lencapsphrase\");",
          "361:   print_brailleIndicator (table->letterSign, \"letsign\");",
          "362:   print_brailleIndicator (table->numberSign, \"numsign\");",
          "364:   for (int i = 0; table->emphClasses[i]; i++) {",
          "365:     for (EmphCodeOffset offset = 0; emphNames[offset]; offset++) {",
          "366:       snprintf(name, BUFSIZE, emphNames[offset], table->emphClasses[i]);",
          "367:       print_brailleIndicator (table->emphRules[emph1Rule][offset], name);",
          "368:     }",
          "369:     snprintf(name, BUFSIZE, \"lenemphphrase %s\", table->emphClasses[i]);",
          "370:     print_phraseLength (table->emphRules[emph1Rule][lenPhraseOffset], name);",
          "371:   }",
          "372:   print_brailleIndicator (table->begComp, \"begcomp\");",
          "373:   print_brailleIndicator (table->compBegEmph1, \"compbegemph1\");",
          "374:   print_brailleIndicator (table->compEndEmph1, \"compendemph1\");",
          "375:   print_brailleIndicator (table->compBegEmph2, \"compbegemph2\");",
          "376:   print_brailleIndicator (table->compEndEmph2, \"compendemph2\");",
          "377:   print_brailleIndicator (table->compBegEmph3, \"compbegemph3\");",
          "378:   print_brailleIndicator (table->compEndEmph3, \"compendemph3\");",
          "379:   print_brailleIndicator (table->compCapSign, \"compcapsign\");",
          "380:   print_brailleIndicator (table->compBegCaps, \"compbegcaps\");",
          "381:   print_brailleIndicator (table->compEndCaps, \"compendcaps\");",
          "382:   print_brailleIndicator (table->endComp, \"endcomp\");",
          "383:   return 1;",
          "387: pickYN (int a)",
          "388: {",
          "389:   if (!a)",
          "390:     return \"no\";",
          "391:   return \"yes\";",
          "395: show_misc (void)",
          "396: {",
          "397:   printf (\"Table size: %d\\n\", table->tableSize);",
          "398:   printf (\"Bytes used: %d\\n\", table->bytesUsed);",
          "399:   printf (\"Number of passes: %d\\n\", table->numPasses);",
          "400:   printf (\"'correct' opcodes: %s\\n\", pickYN (table->corrections));",
          "401:   printf (\"'syllable' opcodes: %s\\n\", pickYN (table->syllables));",
          "402:   printf (\"'capsnocont' opcode: %s\\n\", pickYN (table->capsNoCont));",
          "403:   printf (\"Hyphenation table: %s\\n\", pickYN (table->hyphenStatesArray));",
          "404:   printf (\"noletsignbefore %s\\n\", print_chars(&table->noLetsignBefore[0],",
          "405:            table->noLetsignBeforeCount));",
          "406:   printf (\"noletsign %s\\n\", print_chars(&table->noLetsign[0],",
          "407:      table->noLetsignCount));",
          "408:   printf (\"noletsignafter %s\\n\", print_chars(&table->noLetsignAfter[0],",
          "409:           table->noLetsignAfterCount));",
          "410:   return 1;",
          "414: show_charMap (int startHash)",
          "415: {",
          "416:   int k;",
          "417:   CharOrDots *thisChar;",
          "418:   TranslationTableOffset nextChar;",
          "419:   printf (\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "420:   if (startHash < 0)",
          "421:     k = 0;",
          "422:   else",
          "423:     k = startHash;",
          "424:   for (; k < HASHNUM; k++)",
          "425:     if (table->charToDots[k])",
          "426:       {",
          "427:  printf (\"Hash=%d\\n\", k);",
          "428:  nextChar = table->charToDots[k];",
          "429:  while (nextChar)",
          "430:    {",
          "431:      thisChar = (CharOrDots *) & table->ruleArea[nextChar];",
          "432:      printf (\"Char: %s \", print_chars(&thisChar->lookFor, 1));",
          "433:      printf (\"dots=%s\\n\", _lou_showDots (&thisChar->found, 1));",
          "434:      printf (\"=> \");",
          "435:      getInput ();",
          "436:      if (*inputBuffer == 'h')",
          "437:        break;",
          "438:      if (*inputBuffer == 'e')",
          "439:        return 1;",
          "440:      nextChar = thisChar->next;",
          "441:    }",
          "442:       }",
          "443:   return 1;",
          "447: show_dotsMap (int startHash)",
          "448: {",
          "449:   int k;",
          "450:   CharOrDots *thisDots;",
          "451:   TranslationTableOffset nextDots;",
          "452:   printf (\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "453:   if (startHash < 0)",
          "454:     k = 0;",
          "455:   else",
          "456:     k = startHash;",
          "457:   for (; k < HASHNUM; k++)",
          "458:     if (table->dotsToChar[k])",
          "459:       {",
          "460:  printf (\"Hash=%d\\n\", k);",
          "461:  nextDots = table->dotsToChar[k];",
          "462:  while (nextDots)",
          "463:    {",
          "464:      thisDots = (CharOrDots *) & table->ruleArea[nextDots];",
          "465:      printf (\"Dots: %s \", _lou_showDots (&thisDots->lookFor, 1));",
          "466:      printf (\"char=%s\\n\", print_chars(&thisDots->found, 1));",
          "467:      printf (\"=> \");",
          "468:      getInput ();",
          "469:      if (*inputBuffer == 'h')",
          "470:        break;",
          "471:      if (*inputBuffer == 'e')",
          "472:        return 1;",
          "473:      nextDots = thisDots->next;",
          "474:    }",
          "475:       }",
          "476:   return 1;",
          "480: show_compDots (int startChar)",
          "481: {",
          "482:   widechar k;",
          "483:   printf (\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "484:   if (startChar < 0)",
          "485:     k = 0;",
          "486:   else",
          "487:     k = startChar;",
          "488:   for (; k < 256; k++)",
          "489:     if (table->compdotsPattern[k])",
          "490:       {",
          "491:  TranslationTableRule *thisRule = (TranslationTableRule *)",
          "492:    & table->ruleArea[table->compdotsPattern[k]];",
          "493:  printf (\"Char: %s \", print_chars(&k, 1));",
          "494:  printf (\"dots=%s\\n\",",
          "495:   _lou_showDots (&thisRule->charsdots[1], thisRule->dotslen));",
          "496:  printf (\"=> \");",
          "497:  getInput ();",
          "498:  if (*inputBuffer == 'e')",
          "499:    return 1;",
          "500:       }",
          "501:   return 1;",
          "505: part_paramLetters (void)",
          "506: {",
          "507:   printf (\"show particular hash chains.\\n\");",
          "508:   printf",
          "509:     (\"show-(f)orward-rules, show-(b)ackward-rules, show-(c)haracters, \\n\");",
          "510:   printf (\"show-(d)ot-patterns, show-(C)har-to-dots, show-(D)ots-tochar\\n\");",
          "511:   printf (\"(z)-compdots, (h)elp, e(x)it\\n\");",
          "515: particularHelp (void)",
          "516: {",
          "517:   part_paramLetters ();",
          "521: particular (void)",
          "522: {",
          "523:   int startHash;",
          "524:   widechar parsed[BUFSIZE];",
          "525:   part_paramLetters ();",
          "526:   do",
          "527:     {",
          "528:       printf (\"particular: \");",
          "529:       getInput ();",
          "530:       switch (inputBuffer[0])",
          "531:  {",
          "532:  case 0:",
          "533:    break;",
          "534:  case 'h':",
          "535:    particularHelp ();",
          "536:    break;",
          "537:  case 'c':",
          "538:    printf (\"-> \");",
          "539:    getInput ();",
          "540:    if (!_lou_extParseChars (inputBuffer, parsed))",
          "541:      break;",
          "542:    startHash = _lou_charHash (*parsed);",
          "543:    if (table->characters[startHash] == 0)",
          "544:      {",
          "545:        printf (\"Character not in table.\\n\");",
          "546:        break;",
          "547:      }",
          "548:    show_characters (startHash);",
          "549:    break;",
          "550:  case 'd':",
          "551:    printf (\"-> \");",
          "552:    getInput ();",
          "553:    if (!_lou_extParseDots (inputBuffer, parsed))",
          "554:      break;",
          "555:    startHash = _lou_charHash (*parsed);",
          "556:    if (table->dots[startHash] == 0)",
          "557:      {",
          "558:        printf (\"Dot pattern not in table.\\n\");",
          "559:        break;",
          "560:      }",
          "561:    show_dots (startHash);",
          "562:    break;",
          "563:  case 'C':",
          "564:    printf (\"-> \");",
          "565:    getInput ();",
          "566:    if (!_lou_extParseChars (inputBuffer, parsed))",
          "567:      break;",
          "568:    startHash = _lou_charHash (*parsed);",
          "569:    if (table->charToDots[startHash] == 0)",
          "570:      {",
          "571:        printf (\"Character not in table.\\n\");",
          "572:        break;",
          "573:      }",
          "574:    show_charMap (startHash);",
          "575:    break;",
          "576:  case 'D':",
          "577:    printf (\"-> \");",
          "578:    getInput ();",
          "579:    if (!_lou_extParseDots (inputBuffer, parsed))",
          "580:      break;",
          "581:    startHash = _lou_charHash (*parsed);",
          "582:    if (table->dotsToChar[startHash] == 0)",
          "583:      {",
          "584:        printf (\"Dot pattern not in table.\\n\");",
          "585:        break;",
          "586:      }",
          "587:    show_dotsMap (startHash);",
          "588:    break;",
          "589:  case 'f':",
          "590:    printf (\"-> \");",
          "591:    getInput ();",
          "592:    if (!_lou_extParseChars (inputBuffer, parsed))",
          "593:      break;",
          "594:    startHash = _lou_stringHash (parsed);",
          "595:    if (table->forRules[startHash] == 0)",
          "596:      {",
          "597:        printf (\"Character string not in table.\\n\");",
          "598:        break;",
          "599:      }",
          "600:    show_forRules (startHash);",
          "601:    break;",
          "602:  case 'b':",
          "603:    printf (\"-> \");",
          "604:    getInput ();",
          "605:    if (!_lou_extParseDots (inputBuffer, parsed))",
          "606:      break;",
          "607:    startHash = _lou_stringHash (parsed);",
          "608:    if (table->backRules[startHash] == 0)",
          "609:      {",
          "610:        printf (\"Dot pattern not in table.\\n\");",
          "611:        break;",
          "612:      }",
          "613:    show_backRules (startHash);",
          "614:    break;",
          "615:  case 'z':",
          "616:    printf (\"-> \");",
          "617:    getInput ();",
          "618:    if (!_lou_extParseChars (inputBuffer, parsed))",
          "619:      break;",
          "620:    startHash = _lou_charHash (*parsed);",
          "621:    if (*parsed > 255 || table->compdotsPattern[startHash] == 0)",
          "622:      {",
          "623:        printf (\"Character not in table.\\n\");",
          "624:        break;",
          "625:      }",
          "626:    show_compDots (startHash);",
          "627:    break;",
          "628:  case 'x':",
          "629:    return 1;",
          "630:  default:",
          "631:    printf (\"Bad choice.\\n\");",
          "632:    break;",
          "633:  }",
          "634:     }",
          "635:   while (inputBuffer[0] != 'x');",
          "636:   return 1;",
          "640: paramLetters (void)",
          "641: {",
          "642:   printf (\"Press one of the letters in parentheses, then enter.\\n\");",
          "643:   printf (\"show-(f)orward-rules, show-(b)ackward-rules, show-(c)haracters, \\n\");",
          "644:   printf (\"show-(d)ot-patterns, show-(C)har-to-dots, show-(D)ots-tochar\\n\");",
          "645:   printf (\"show-(m)isc, show-(z)-compdots\\n\");",
          "646:   printf (\"show-braille(i)ndicators, show-(p)articulars\\n\");",
          "647:   printf (\"(h)elp, (q)uit\\n\");",
          "651: commandHelp (void)",
          "652: {",
          "653:   paramLetters ();",
          "657: getCommands (void)",
          "658: {",
          "659:   paramLetters ();",
          "660:   do",
          "661:     {",
          "662:       printf (\"Command: \");",
          "663:       getInput ();",
          "664:       switch (inputBuffer[0])",
          "665:  {",
          "666:  case 0:",
          "667:    break;",
          "668:  case 'h':",
          "669:    commandHelp ();",
          "670:    break;",
          "671:  case 'C':",
          "672:    show_charMap (-1);",
          "673:    break;",
          "674:  case 'D':",
          "675:    show_dotsMap (-1);",
          "676:    break;",
          "677:  case 'z':",
          "678:    show_compDots (-1);",
          "679:    break;",
          "680:  case 'c':",
          "681:    show_characters (-1);",
          "682:    break;",
          "683:  case 'd':",
          "684:    show_dots (-1);",
          "685:    break;",
          "686:  case 'f':",
          "687:    show_forRules (-1);",
          "688:    break;",
          "689:  case 'b':",
          "690:    show_backRules (-1);",
          "691:    break;",
          "692:  case 'i':",
          "693:    show_brailleIndicators ();",
          "694:    break;",
          "695:  case 'm':",
          "696:    show_misc ();",
          "697:    break;",
          "698:  case 'p':",
          "699:    particular ();",
          "700:    break;",
          "701:  case 'q':",
          "702:    return 1;",
          "703:  default:",
          "704:    printf (\"Bad choice.\\n\");",
          "705:    break;",
          "706:  }",
          "707:     }",
          "708:   while (inputBuffer[0] != 'q');",
          "709:   return 1;",
          "713: main (int argc, char **argv)",
          "714: {",
          "715:   int optc;",
          "717:   set_program_name (argv[0]);",
          "719:   while ((optc = getopt_long (argc, argv, \"hv\", longopts, NULL)) != -1)",
          "720:     switch (optc)",
          "721:       {",
          "723:       case 'v':",
          "724:         version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *) NULL);",
          "725:         exit (EXIT_SUCCESS);",
          "726:         break;",
          "727:       case 'h':",
          "728:         print_help ();",
          "729:         exit (EXIT_SUCCESS);",
          "730:         break;",
          "731:       default:",
          "732:  fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "733:    program_name);",
          "734:  exit (EXIT_FAILURE);",
          "735:         break;",
          "736:       }",
          "738:   if (optind != argc - 1)",
          "739:     {",
          "741:       if (optind < argc - 1)",
          "742:  fprintf (stderr, \"%s: extra operand: %s\\n\",",
          "743:    program_name, argv[optind + 1]);",
          "744:       else",
          "745:  fprintf (stderr, \"%s: no table specified\\n\",",
          "746:    program_name);",
          "747:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "748:                program_name);",
          "749:       exit (EXIT_FAILURE);",
          "750:     }",
          "752:   if (!(table = lou_getTable (argv[optind])))",
          "753:     {",
          "754:       lou_free ();",
          "755:       exit (EXIT_FAILURE);",
          "756:     }",
          "757:   getCommands ();",
          "758:   lou_free ();",
          "759:   exit (EXIT_SUCCESS);",
          "",
          "[Added Lines]",
          "81: getInput(void) {",
          "82:  int inputLength;",
          "83:  inputBuffer[0] = 0;",
          "84:  if (!fgets(inputBuffer, sizeof(inputBuffer), stdin)) exit(EXIT_FAILURE);",
          "85:  inputLength = strlen(inputBuffer) - 1;",
          "87:   exit(EXIT_FAILURE);",
          "88:  inputBuffer[inputLength] = 0;",
          "89:  return inputLength;",
          "92: static char *",
          "94:  static uint8_t result_buf[BUFSIZE];",
          "95:  size_t result_len = BUFSIZE - 1;",
          "97:  u32_to_u8(buffer, length, result_buf, &result_len);",
          "99:  u16_to_u8(buffer, length, result_buf, &result_len);",
          "101:  result_buf[result_len] = 0;",
          "102:  return result_buf;",
          "106: printRule(TranslationTableRule *thisRule, int mode) {",
          "107:  printf(\"Rule: \");",
          "108:  printf(\"opcode=%s, \", _lou_findOpcodeName(thisRule->opcode));",
          "109:  if (thisRule->before) printf(\"before=%x, \", thisRule->before);",
          "110:  if (thisRule->after) printf(\"after=%x, \", thisRule->after);",
          "111:  switch (thisRule->opcode) {",
          "112:  case CTO_Context:",
          "113:  case CTO_Correct:",
          "114:  case CTO_SwapCd:",
          "115:  case CTO_SwapDd:",
          "116:  case CTO_Pass2:",
          "117:  case CTO_Pass3:",
          "118:  case CTO_Pass4:",
          "119:   printf(\"code=%s \",",
          "120:     print_chars(thisRule->charsdots, thisRule->charslen + thisRule->dotslen));",
          "121:   break;",
          "122:  default:",
          "123:   if (mode == 0) {",
          "124:    printf(\"chars=%s, \", print_chars(thisRule->charsdots, thisRule->charslen));",
          "125:    printf(\"dots=%s, \", _lou_showDots(&thisRule->charsdots[thisRule->charslen],",
          "126:           thisRule->dotslen));",
          "127:   } else {",
          "128:    printf(\"dots=%s, \", _lou_showDots(&thisRule->charsdots[thisRule->charslen],",
          "129:           thisRule->dotslen));",
          "130:    printf(\"chars=%s, \", print_chars(thisRule->charsdots, thisRule->charslen));",
          "131:   }",
          "132:   break;",
          "134:  return 1;",
          "138: printCharacter(TranslationTableCharacter *thisChar, int mode) {",
          "139:  TranslationTableRule *thisRule;",
          "140:  TranslationTableOffset nextRule;",
          "141:  if (mode == 0) {",
          "142:   printf(\"Char: \");",
          "143:   printf(\"real=%s, \", print_chars(&thisChar->realchar, 1));",
          "144:   printf(\"upper=%s, \", print_chars(&thisChar->uppercase, 1));",
          "145:   printf(\"lower=%s, \", print_chars(&thisChar->lowercase, 1));",
          "146:  } else",
          "147:   printf(\"Dots: real=%s, \", _lou_showDots(&thisChar->realchar, 1));",
          "148:  printf(\"attr=%s, \", _lou_showAttributes(thisChar->attributes));",
          "149:  nextRule = thisChar->otherRules;",
          "150:  while (nextRule) {",
          "151:   thisRule = (TranslationTableRule *)&table->ruleArea[nextRule];",
          "152:   if (nextRule == thisChar->definitionRule) printf(\"definition \");",
          "153:   printRule(thisRule, mode);",
          "154:   printf(\"\\n\");",
          "155:   if (mode == 0)",
          "156:    nextRule = thisRule->charsnext;",
          "157:   else",
          "158:    nextRule = thisRule->dotsnext;",
          "159:  }",
          "160:  return 1;",
          "164: show_characters(int startHash) {",
          "165:  int k;",
          "166:  TranslationTableCharacter *thisChar;",
          "167:  TranslationTableOffset nextChar;",
          "168:  printf(\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "169:  if (startHash < 0)",
          "170:   k = 0;",
          "171:  else",
          "172:   k = startHash;",
          "173:  for (; k < HASHNUM; k++)",
          "174:   if (table->characters[k]) {",
          "175:    printf(\"Hash=%d\\n\", k);",
          "176:    nextChar = table->characters[k];",
          "177:    while (nextChar) {",
          "178:     thisChar = (TranslationTableCharacter *)&table->ruleArea[nextChar];",
          "179:     printCharacter(thisChar, 0);",
          "180:     printf(\"=> \");",
          "181:     getInput();",
          "182:     if (*inputBuffer == 'h') break;",
          "183:     if (*inputBuffer == 'e') return 1;",
          "184:     nextChar = thisChar->next;",
          "185:    }",
          "186:   }",
          "187:  return 1;",
          "191: show_dots(int startHash) {",
          "192:  int k;",
          "193:  TranslationTableCharacter *thisDots;",
          "194:  TranslationTableOffset nextDots;",
          "195:  printf(\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "196:  if (startHash < 0)",
          "197:   k = 0;",
          "198:  else",
          "199:   k = startHash;",
          "200:  for (; k < HASHNUM; k++)",
          "201:   if (table->dots[k]) {",
          "202:    printf(\"Hash=%d\\n\", k);",
          "203:    nextDots = table->dots[k];",
          "204:    while (nextDots) {",
          "205:     thisDots = (TranslationTableCharacter *)&table->ruleArea[nextDots];",
          "206:     printCharacter(thisDots, 1);",
          "207:     printf(\"=> \");",
          "208:     getInput();",
          "209:     if (*inputBuffer == 'h') break;",
          "210:     if (*inputBuffer == 'e') return 1;",
          "211:     nextDots = thisDots->next;",
          "212:    }",
          "213:   }",
          "214:  return 1;",
          "218: show_forRules(int startHash) {",
          "219:  int k;",
          "220:  TranslationTableRule *thisRule;",
          "221:  TranslationTableOffset nextRule;",
          "222:  printf(\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "223:  if (startHash < 0)",
          "224:   k = 0;",
          "225:  else",
          "226:   k = startHash;",
          "227:  for (; k < HASHNUM; k++)",
          "228:   if (table->forRules[k]) {",
          "229:    printf(\"Hash=%d\\n\", k);",
          "230:    nextRule = table->forRules[k];",
          "231:    while (nextRule) {",
          "232:     thisRule = (TranslationTableRule *)&table->ruleArea[nextRule];",
          "233:     printRule(thisRule, 0);",
          "234:     printf(\"=> \");",
          "235:     getInput();",
          "236:     if (*inputBuffer == 'h') break;",
          "237:     if (*inputBuffer == 'e') return 1;",
          "238:     nextRule = thisRule->charsnext;",
          "239:    }",
          "240:   }",
          "241:  return 1;",
          "245: show_backRules(int startHash) {",
          "246:  int k;",
          "247:  TranslationTableRule *thisRule;",
          "248:  TranslationTableOffset nextRule;",
          "249:  printf(\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "250:  if (startHash < 0)",
          "251:   k = 0;",
          "252:  else",
          "253:   k = startHash;",
          "254:  for (; k < HASHNUM; k++)",
          "255:   if (table->backRules[k]) {",
          "256:    printf(\"Hash=%d\\n\", k);",
          "257:    nextRule = table->backRules[k];",
          "258:    while (nextRule) {",
          "259:     thisRule = (TranslationTableRule *)&table->ruleArea[nextRule];",
          "260:     printRule(thisRule, 1);",
          "261:     printf(\"=> \");",
          "262:     getInput();",
          "263:     if (*inputBuffer == 'h') break;",
          "264:     if (*inputBuffer == 'e') return 1;",
          "265:     nextRule = thisRule->dotsnext;",
          "266:    }",
          "267:   }",
          "268:  return 1;",
          "272: print_brailleIndicator(TranslationTableOffset offset, char *opcode) {",
          "273:  TranslationTableRule *thisRule;",
          "274:  if (!offset) return 0;",
          "275:  thisRule = (TranslationTableRule *)&table->ruleArea[offset];",
          "276:  printf(\"%s %s\\n\", opcode, _lou_showDots(&thisRule->charsdots[0], thisRule->dotslen));",
          "277:  return 1;",
          "281: print_phraseLength(TranslationTableOffset offset, char *opcode) {",
          "282:  if (!offset) return 0;",
          "283:  printf(\"%s %d\\n\", opcode, offset);",
          "284:  return 1;",
          "288: show_brailleIndicators(void) {",
          "289:  char name[BUFSIZE];",
          "290:  char *emphNames[] = { \"begemphphrase %s\", \"endemphphrase %s before\",",
          "291:   \"endemphphrase %s after\", \"begemphword %s\", \"endemphword %s\", \"emphletter %s\",",
          "292:   \"begemph %s\", \"endemph %s\", NULL };",
          "293:  char *capsNames[] = { \"firstwordcaps\", \"lastwordcapsbefore\", \"lastwordcapsafter\",",
          "294:   \"begcaps\", \"endcaps\", \"capsletter\", \"capsword\", \"capswordstop\", NULL };",
          "298:  for (EmphCodeOffset offset = 0; capsNames[offset]; offset++) {",
          "299:   print_brailleIndicator(table->emphRules[capsRule][offset], capsNames[offset]);",
          "300:  }",
          "301:  print_phraseLength(table->emphRules[capsRule][lenPhraseOffset], \"lencapsphrase\");",
          "302:  print_brailleIndicator(table->letterSign, \"letsign\");",
          "303:  print_brailleIndicator(table->numberSign, \"numsign\");",
          "305:  for (int i = 0; table->emphClasses[i]; i++) {",
          "306:   for (EmphCodeOffset offset = 0; emphNames[offset]; offset++) {",
          "307:    snprintf(name, BUFSIZE, emphNames[offset], table->emphClasses[i]);",
          "308:    print_brailleIndicator(table->emphRules[emph1Rule][offset], name);",
          "309:   }",
          "310:   snprintf(name, BUFSIZE, \"lenemphphrase %s\", table->emphClasses[i]);",
          "311:   print_phraseLength(table->emphRules[emph1Rule][lenPhraseOffset], name);",
          "312:  }",
          "313:  print_brailleIndicator(table->begComp, \"begcomp\");",
          "314:  print_brailleIndicator(table->compBegEmph1, \"compbegemph1\");",
          "315:  print_brailleIndicator(table->compEndEmph1, \"compendemph1\");",
          "316:  print_brailleIndicator(table->compBegEmph2, \"compbegemph2\");",
          "317:  print_brailleIndicator(table->compEndEmph2, \"compendemph2\");",
          "318:  print_brailleIndicator(table->compBegEmph3, \"compbegemph3\");",
          "319:  print_brailleIndicator(table->compEndEmph3, \"compendemph3\");",
          "320:  print_brailleIndicator(table->compCapSign, \"compcapsign\");",
          "321:  print_brailleIndicator(table->compBegCaps, \"compbegcaps\");",
          "322:  print_brailleIndicator(table->compEndCaps, \"compendcaps\");",
          "323:  print_brailleIndicator(table->endComp, \"endcomp\");",
          "324:  return 1;",
          "328: pickYN(int a) {",
          "329:  if (!a) return \"no\";",
          "330:  return \"yes\";",
          "334: show_misc(void) {",
          "335:  printf(\"Table size: %d\\n\", table->tableSize);",
          "336:  printf(\"Bytes used: %d\\n\", table->bytesUsed);",
          "337:  printf(\"Number of passes: %d\\n\", table->numPasses);",
          "338:  printf(\"'correct' opcodes: %s\\n\", pickYN(table->corrections));",
          "339:  printf(\"'syllable' opcodes: %s\\n\", pickYN(table->syllables));",
          "340:  printf(\"'capsnocont' opcode: %s\\n\", pickYN(table->capsNoCont));",
          "341:  printf(\"Hyphenation table: %s\\n\", pickYN(table->hyphenStatesArray));",
          "342:  printf(\"noletsignbefore %s\\n\",",
          "343:    print_chars(&table->noLetsignBefore[0], table->noLetsignBeforeCount));",
          "344:  printf(\"noletsign %s\\n\", print_chars(&table->noLetsign[0], table->noLetsignCount));",
          "345:  printf(\"noletsignafter %s\\n\",",
          "346:    print_chars(&table->noLetsignAfter[0], table->noLetsignAfterCount));",
          "347:  return 1;",
          "351: show_charMap(int startHash) {",
          "352:  int k;",
          "353:  CharOrDots *thisChar;",
          "354:  TranslationTableOffset nextChar;",
          "355:  printf(\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "356:  if (startHash < 0)",
          "357:   k = 0;",
          "358:  else",
          "359:   k = startHash;",
          "360:  for (; k < HASHNUM; k++)",
          "361:   if (table->charToDots[k]) {",
          "362:    printf(\"Hash=%d\\n\", k);",
          "363:    nextChar = table->charToDots[k];",
          "364:    while (nextChar) {",
          "365:     thisChar = (CharOrDots *)&table->ruleArea[nextChar];",
          "366:     printf(\"Char: %s \", print_chars(&thisChar->lookFor, 1));",
          "367:     printf(\"dots=%s\\n\", _lou_showDots(&thisChar->found, 1));",
          "368:     printf(\"=> \");",
          "369:     getInput();",
          "370:     if (*inputBuffer == 'h') break;",
          "371:     if (*inputBuffer == 'e') return 1;",
          "372:     nextChar = thisChar->next;",
          "373:    }",
          "374:   }",
          "375:  return 1;",
          "379: show_dotsMap(int startHash) {",
          "380:  int k;",
          "381:  CharOrDots *thisDots;",
          "382:  TranslationTableOffset nextDots;",
          "383:  printf(\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "384:  if (startHash < 0)",
          "385:   k = 0;",
          "386:  else",
          "387:   k = startHash;",
          "388:  for (; k < HASHNUM; k++)",
          "389:   if (table->dotsToChar[k]) {",
          "390:    printf(\"Hash=%d\\n\", k);",
          "391:    nextDots = table->dotsToChar[k];",
          "392:    while (nextDots) {",
          "393:     thisDots = (CharOrDots *)&table->ruleArea[nextDots];",
          "394:     printf(\"Dots: %s \", _lou_showDots(&thisDots->lookFor, 1));",
          "395:     printf(\"char=%s\\n\", print_chars(&thisDots->found, 1));",
          "396:     printf(\"=> \");",
          "397:     getInput();",
          "398:     if (*inputBuffer == 'h') break;",
          "399:     if (*inputBuffer == 'e') return 1;",
          "400:     nextDots = thisDots->next;",
          "401:    }",
          "402:   }",
          "403:  return 1;",
          "407: show_compDots(int startChar) {",
          "408:  widechar k;",
          "409:  printf(\"Press enter for next or (e)xit, next-(h)ash, then enter\\n\");",
          "410:  if (startChar < 0)",
          "411:   k = 0;",
          "412:  else",
          "413:   k = startChar;",
          "414:  for (; k < 256; k++)",
          "415:   if (table->compdotsPattern[k]) {",
          "416:    TranslationTableRule *thisRule =",
          "417:      (TranslationTableRule *)&table->ruleArea[table->compdotsPattern[k]];",
          "418:    printf(\"Char: %s \", print_chars(&k, 1));",
          "419:    printf(\"dots=%s\\n\",",
          "420:      _lou_showDots(&thisRule->charsdots[1], thisRule->dotslen));",
          "421:    printf(\"=> \");",
          "422:    getInput();",
          "423:    if (*inputBuffer == 'e') return 1;",
          "424:   }",
          "425:  return 1;",
          "429: part_paramLetters(void) {",
          "430:  printf(\"show particular hash chains.\\n\");",
          "431:  printf(\"show-(f)orward-rules, show-(b)ackward-rules, show-(c)haracters, \\n\");",
          "432:  printf(\"show-(d)ot-patterns, show-(C)har-to-dots, show-(D)ots-tochar\\n\");",
          "433:  printf(\"(z)-compdots, (h)elp, e(x)it\\n\");",
          "437: particularHelp(void) {",
          "438:  part_paramLetters();",
          "442: particular(void) {",
          "443:  int startHash;",
          "444:  widechar parsed[BUFSIZE];",
          "445:  part_paramLetters();",
          "446:  do {",
          "447:   printf(\"particular: \");",
          "448:   getInput();",
          "449:   switch (inputBuffer[0]) {",
          "450:   case 0:",
          "451:    break;",
          "452:   case 'h':",
          "453:    particularHelp();",
          "454:    break;",
          "455:   case 'c':",
          "456:    printf(\"-> \");",
          "457:    getInput();",
          "458:    if (!_lou_extParseChars(inputBuffer, parsed)) break;",
          "459:    startHash = _lou_charHash(*parsed);",
          "460:    if (table->characters[startHash] == 0) {",
          "461:     printf(\"Character not in table.\\n\");",
          "462:     break;",
          "463:    }",
          "464:    show_characters(startHash);",
          "465:    break;",
          "466:   case 'd':",
          "467:    printf(\"-> \");",
          "468:    getInput();",
          "469:    if (!_lou_extParseDots(inputBuffer, parsed)) break;",
          "470:    startHash = _lou_charHash(*parsed);",
          "471:    if (table->dots[startHash] == 0) {",
          "472:     printf(\"Dot pattern not in table.\\n\");",
          "473:     break;",
          "474:    }",
          "475:    show_dots(startHash);",
          "476:    break;",
          "477:   case 'C':",
          "478:    printf(\"-> \");",
          "479:    getInput();",
          "480:    if (!_lou_extParseChars(inputBuffer, parsed)) break;",
          "481:    startHash = _lou_charHash(*parsed);",
          "482:    if (table->charToDots[startHash] == 0) {",
          "483:     printf(\"Character not in table.\\n\");",
          "484:     break;",
          "485:    }",
          "486:    show_charMap(startHash);",
          "487:    break;",
          "488:   case 'D':",
          "489:    printf(\"-> \");",
          "490:    getInput();",
          "491:    if (!_lou_extParseDots(inputBuffer, parsed)) break;",
          "492:    startHash = _lou_charHash(*parsed);",
          "493:    if (table->dotsToChar[startHash] == 0) {",
          "494:     printf(\"Dot pattern not in table.\\n\");",
          "495:     break;",
          "496:    }",
          "497:    show_dotsMap(startHash);",
          "498:    break;",
          "499:   case 'f':",
          "500:    printf(\"-> \");",
          "501:    getInput();",
          "502:    if (!_lou_extParseChars(inputBuffer, parsed)) break;",
          "503:    startHash = _lou_stringHash(parsed);",
          "504:    if (table->forRules[startHash] == 0) {",
          "505:     printf(\"Character string not in table.\\n\");",
          "506:     break;",
          "507:    }",
          "508:    show_forRules(startHash);",
          "509:    break;",
          "510:   case 'b':",
          "511:    printf(\"-> \");",
          "512:    getInput();",
          "513:    if (!_lou_extParseDots(inputBuffer, parsed)) break;",
          "514:    startHash = _lou_stringHash(parsed);",
          "515:    if (table->backRules[startHash] == 0) {",
          "516:     printf(\"Dot pattern not in table.\\n\");",
          "517:     break;",
          "518:    }",
          "519:    show_backRules(startHash);",
          "520:    break;",
          "521:   case 'z':",
          "522:    printf(\"-> \");",
          "523:    getInput();",
          "524:    if (!_lou_extParseChars(inputBuffer, parsed)) break;",
          "525:    startHash = _lou_charHash(*parsed);",
          "526:    if (*parsed > 255 || table->compdotsPattern[startHash] == 0) {",
          "527:     printf(\"Character not in table.\\n\");",
          "528:     break;",
          "529:    }",
          "530:    show_compDots(startHash);",
          "531:    break;",
          "532:   case 'x':",
          "533:    return 1;",
          "534:   default:",
          "535:    printf(\"Bad choice.\\n\");",
          "536:    break;",
          "537:   }",
          "538:  } while (inputBuffer[0] != 'x');",
          "539:  return 1;",
          "543: paramLetters(void) {",
          "544:  printf(\"Press one of the letters in parentheses, then enter.\\n\");",
          "545:  printf(\"show-(f)orward-rules, show-(b)ackward-rules, show-(c)haracters, \\n\");",
          "546:  printf(\"show-(d)ot-patterns, show-(C)har-to-dots, show-(D)ots-tochar\\n\");",
          "547:  printf(\"show-(m)isc, show-(z)-compdots\\n\");",
          "548:  printf(\"show-braille(i)ndicators, show-(p)articulars\\n\");",
          "549:  printf(\"(h)elp, (q)uit\\n\");",
          "553: commandHelp(void) {",
          "554:  paramLetters();",
          "558: getCommands(void) {",
          "559:  paramLetters();",
          "560:  do {",
          "561:   printf(\"Command: \");",
          "562:   getInput();",
          "563:   switch (inputBuffer[0]) {",
          "564:   case 0:",
          "565:    break;",
          "566:   case 'h':",
          "567:    commandHelp();",
          "568:    break;",
          "569:   case 'C':",
          "570:    show_charMap(-1);",
          "571:    break;",
          "572:   case 'D':",
          "573:    show_dotsMap(-1);",
          "574:    break;",
          "575:   case 'z':",
          "576:    show_compDots(-1);",
          "577:    break;",
          "578:   case 'c':",
          "579:    show_characters(-1);",
          "580:    break;",
          "581:   case 'd':",
          "582:    show_dots(-1);",
          "583:    break;",
          "584:   case 'f':",
          "585:    show_forRules(-1);",
          "586:    break;",
          "587:   case 'b':",
          "588:    show_backRules(-1);",
          "589:    break;",
          "590:   case 'i':",
          "591:    show_brailleIndicators();",
          "592:    break;",
          "593:   case 'm':",
          "594:    show_misc();",
          "595:    break;",
          "596:   case 'p':",
          "597:    particular();",
          "598:    break;",
          "599:   case 'q':",
          "600:    return 1;",
          "601:   default:",
          "602:    printf(\"Bad choice.\\n\");",
          "603:    break;",
          "604:   }",
          "605:  } while (inputBuffer[0] != 'q');",
          "606:  return 1;",
          "610: main(int argc, char **argv) {",
          "611:  int optc;",
          "613:  set_program_name(argv[0]);",
          "615:  while ((optc = getopt_long(argc, argv, \"hv\", longopts, NULL)) != -1) switch (optc) {",
          "617:   case 'v':",
          "618:    version_etc(",
          "619:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "620:    exit(EXIT_SUCCESS);",
          "621:    break;",
          "622:   case 'h':",
          "623:    print_help();",
          "624:    exit(EXIT_SUCCESS);",
          "625:    break;",
          "626:   default:",
          "627:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "628:    exit(EXIT_FAILURE);",
          "629:    break;",
          "630:   }",
          "632:  if (optind != argc - 1) {",
          "634:   if (optind < argc - 1)",
          "635:    fprintf(stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind + 1]);",
          "636:   else",
          "637:    fprintf(stderr, \"%s: no table specified\\n\", program_name);",
          "638:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "639:   exit(EXIT_FAILURE);",
          "640:  }",
          "642:  if (!(table = lou_getTable(argv[optind]))) {",
          "643:   lou_free();",
          "644:   exit(EXIT_FAILURE);",
          "645:  }",
          "646:  getCommands();",
          "647:  lou_free();",
          "648:  exit(EXIT_SUCCESS);",
          "",
          "---------------"
        ],
        "tools/lou_tableinfo.c||tools/lou_tableinfo.c": [
          "File: tools/lou_tableinfo.c -> tools/lou_tableinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"progname.h\"",
          "24: #include \"version-etc.h\"",
          "31: };",
          "33: const char version_etc_copyright[] = \"Copyright %s %d Bert Frees\";",
          "",
          "[Removed Lines]",
          "26: static const struct option longopts[] =",
          "27: {",
          "28:   { \"help\", no_argument, NULL, 'h' },",
          "29:   { \"version\", no_argument, NULL, 'v' },",
          "30:   { NULL, 0, NULL, 0 },",
          "",
          "[Added Lines]",
          "26: static const struct option longopts[] = {",
          "27:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "28:  { NULL, 0, NULL, 0 },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35: #define AUTHORS \"Bert Frees\"",
          "37: static void",
          "44: Print all table metadata defined in TABLE, or a specific metadata field\\n\\",
          "45: if KEY is specified. Return 0 if the requested metadata could be found,\\n\\",
          "49:   -h, --help          display this help and exit\\n\\",
          "55: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "57: #endif",
          "58: #ifdef PACKAGE_URL",
          "60: #endif",
          "61: }",
          "63: int",
          "119: }",
          "",
          "[Removed Lines]",
          "38: print_help (void)",
          "39: {",
          "40:   printf (\"\\",
          "41: Usage: %s [KEY] TABLE\\n\", program_name);",
          "43:   fputs (\"\\",
          "46: 1 otherwise.\\n\\n\", stdout);",
          "48:   fputs (\"\\",
          "50:   -v, --version       display version information and exi\\n\", stdout);",
          "52:   printf (\"\\n\");",
          "53:   printf (\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "56:   printf (\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "59:   printf (\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "64: main (int argc, char **argv)",
          "65: {",
          "66:   int optc;",
          "67:   set_program_name (argv[0]);",
          "68:   while ((optc = getopt_long (argc, argv, \"hv\", longopts, NULL)) != -1)",
          "69:     switch (optc)",
          "70:       {",
          "72:       case 'v':",
          "73:         version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *) NULL);",
          "74:         exit (EXIT_SUCCESS);",
          "75:         break;",
          "76:       case 'h':",
          "77:         print_help ();",
          "78:         exit (EXIT_SUCCESS);",
          "79:         break;",
          "80:       default:",
          "81:         fprintf (stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "82:         exit (EXIT_FAILURE);",
          "83:         break;",
          "84:       }",
          "85:   if (optind > argc - 1)",
          "86:     {",
          "87:       fprintf (stderr, \"%s: no table specified\\n\", program_name);",
          "88:       fprintf (stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "89:       exit (EXIT_FAILURE);",
          "90:     }",
          "91:   else if (optind == argc - 1)",
          "92:     {",
          "93:       const char *table = argv[optind];",
          "94:       fprintf (stderr, \"Not supported yet\\n\");",
          "95:       exit (EXIT_FAILURE);",
          "96:     }",
          "97:   else if (optind == argc - 2)",
          "98:     {",
          "99:       const char *key  = argv[optind];",
          "100:       const char *table = argv[optind + 1];",
          "101:       const char *value = lou_getTableInfo(table, key);",
          "102:       if (value != NULL)",
          "103:         {",
          "104:           printf (\"%s\\n\", value);",
          "105:           exit (EXIT_SUCCESS);",
          "106:         }",
          "107:       else",
          "108:         {",
          "109:           fprintf (stderr, \"%s: no such field in %s\\n\", key, table);",
          "110:           exit (EXIT_FAILURE);",
          "111:         }",
          "112:     }",
          "113:   else",
          "114:     {",
          "115:       fprintf (stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind + 1]);",
          "116:       fprintf (stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "117:       exit (EXIT_FAILURE);",
          "118:     }",
          "",
          "[Added Lines]",
          "36: print_help(void) {",
          "37:  printf(\"\\",
          "38: Usage: %s [KEY] TABLE\\n\",",
          "39:    program_name);",
          "41:  fputs(\"\\",
          "44: 1 otherwise.\\n\\n\",",
          "45:    stdout);",
          "47:  fputs(\"\\",
          "49:   -v, --version       display version information and exi\\n\",",
          "50:    stdout);",
          "52:  printf(\"\\n\");",
          "53:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "56:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "59:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "64: main(int argc, char **argv) {",
          "65:  int optc;",
          "66:  set_program_name(argv[0]);",
          "67:  while ((optc = getopt_long(argc, argv, \"hv\", longopts, NULL)) != -1) switch (optc) {",
          "69:   case 'v':",
          "70:    version_etc(",
          "71:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "72:    exit(EXIT_SUCCESS);",
          "73:    break;",
          "74:   case 'h':",
          "75:    print_help();",
          "76:    exit(EXIT_SUCCESS);",
          "77:    break;",
          "78:   default:",
          "79:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "80:    exit(EXIT_FAILURE);",
          "81:    break;",
          "82:   }",
          "83:  if (optind > argc - 1) {",
          "84:   fprintf(stderr, \"%s: no table specified\\n\", program_name);",
          "85:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "86:   exit(EXIT_FAILURE);",
          "87:  } else if (optind == argc - 1) {",
          "88:   const char *table = argv[optind];",
          "89:   fprintf(stderr, \"Not supported yet\\n\");",
          "90:   exit(EXIT_FAILURE);",
          "91:  } else if (optind == argc - 2) {",
          "92:   const char *key = argv[optind];",
          "93:   const char *table = argv[optind + 1];",
          "94:   const char *value = lou_getTableInfo(table, key);",
          "95:   if (value != NULL) {",
          "96:    printf(\"%s\\n\", value);",
          "97:    exit(EXIT_SUCCESS);",
          "98:   } else {",
          "99:    fprintf(stderr, \"%s: no such field in %s\\n\", key, table);",
          "100:    exit(EXIT_FAILURE);",
          "101:   }",
          "102:  } else {",
          "103:   fprintf(stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind + 1]);",
          "104:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "105:   exit(EXIT_FAILURE);",
          "106:  }",
          "",
          "---------------"
        ],
        "tools/lou_trace.c||tools/lou_trace.c": [
          "File: tools/lou_trace.c -> tools/lou_trace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: static int backward_flag = 0;",
          "32: static const struct option longopts[] = {",
          "38: };",
          "40: const char version_etc_copyright[] =",
          "43: #define AUTHORS \"Bert Frees\"",
          "45: static void",
          "46: print_help(void) {",
          "50: Examine and debug Braille translation tables. This program allows you\\n\\",
          "51: to inspect liblouis translation tables by printing out the list of\\n\\",
          "54:   -h, --help          display this help and exit\\n\\",
          "55:   -v, --version       display version information and exit\\n\\",
          "56:   -f, --forward       forward translation using the given table\\n\\",
          "57:   -b, --backward      backward translation using the given table\\n\\",
          "58:                       If neither -f nor -b are specified forward translation\\n\\",
          "61: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "64: #endif",
          "65: #ifdef PACKAGE_URL",
          "67: #endif",
          "68: }",
          "",
          "[Removed Lines]",
          "33:   {\"help\", no_argument, NULL, 'h'},",
          "34:   {\"version\", no_argument, NULL, 'v'},",
          "35:   {\"forward\", no_argument, NULL, 'f'},",
          "36:   {\"backward\", no_argument, NULL, 'b'},",
          "37:   {NULL, 0, NULL, 0},",
          "41:   \"Copyright %s %d Swiss Library for the Blind, Visually Impaired and Print Disabled.\";",
          "47:   printf(\"\\",
          "48: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\", program_name);",
          "49:   fputs(\"\\",
          "52: applied translation rules for a given input.\\n\\n\", stdout);",
          "53:   fputs(\"\\",
          "59:                       is assumed\\n\", stdout);",
          "60:   printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "62:   printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER,",
          "63:   PACKAGE_PACKAGER_BUG_REPORTS);",
          "66:   printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "[Added Lines]",
          "33:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "34:  { \"forward\", no_argument, NULL, 'f' }, { \"backward\", no_argument, NULL, 'b' },",
          "35:  { NULL, 0, NULL, 0 },",
          "39:   \"Copyright %s %d Swiss Library for the Blind, Visually Impaired and Print \"",
          "40:   \"Disabled.\";",
          "46:  printf(\"\\",
          "47: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\",",
          "48:    program_name);",
          "49:  fputs(\"\\",
          "52: applied translation rules for a given input.\\n\\n\",",
          "53:    stdout);",
          "54:  fputs(\"\\",
          "60:                       is assumed\\n\",",
          "61:    stdout);",
          "62:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "64:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "67:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73: static char *",
          "74: get_input(void) {",
          "85: }",
          "87: static int",
          "90: }",
          "92: static char *",
          "96: #ifdef WIDECHARS_ARE_UCS4",
          "98: #else",
          "100: #endif",
          "103: }",
          "105: static char *",
          "110: }",
          "112: static char *",
          "113: print_number(widechar c) {",
          "117: }",
          "119: static char *",
          "120: print_attributes(unsigned int a) {",
          "124: }",
          "126: static void",
          "127: append_char(char *destination, int *length, char source) {",
          "129: }",
          "131: static void",
          "132: append_string(char *destination, int *length, char *source) {",
          "135: }",
          "137: static char *",
          "221: }",
          "223: static void",
          "246: }",
          "248: static void",
          "249: main_loop(int backward_translation, char *table) {",
          "281: }",
          "283: int",
          "284: main(int argc, char **argv) {",
          "337: }",
          "",
          "[Removed Lines]",
          "75:   static char input_buffer[BUFSIZE];",
          "76:   size_t input_length;",
          "77:   input_buffer[0] = 0;",
          "78:   if (!fgets(input_buffer, sizeof(input_buffer), stdin))",
          "79:     exit(EXIT_FAILURE);",
          "80:   input_length = strlen(input_buffer) - 1;",
          "81:   if (input_length < 0)",
          "82:     exit(0);",
          "83:   input_buffer[input_length] = 0;",
          "84:   return input_buffer;",
          "88: get_wide_input(widechar * buffer) {",
          "89:   return _lou_extParseChars(get_input(), buffer);",
          "93: print_chars(const widechar * buffer, int length) {",
          "94:   static uint8_t result_buf[BUFSIZE];",
          "95:   size_t result_len = BUFSIZE - 1;",
          "97:     u32_to_u8(buffer, length, result_buf, &result_len);",
          "99:     u16_to_u8(buffer, length, result_buf, &result_len);",
          "101:   result_buf[result_len] = 0;",
          "102:   return result_buf;",
          "106: print_dots(const widechar * buffer, int length) {",
          "107:   static char dots[BUFSIZE];",
          "108:   strcpy(dots, _lou_showDots(buffer, length));",
          "109:   return dots;",
          "114:   static char number[BUFSIZE];",
          "115:   sprintf(number, \"%d\", c);",
          "116:   return number;",
          "121:   static char attr[BUFSIZE];",
          "122:   strcpy(attr, _lou_showAttributes(a));",
          "123:   return attr;",
          "128:   destination[(*length)++] = source;",
          "133:   strcpy(&destination[(*length)], source);",
          "134:   (*length) += strlen(source);",
          "138: print_script(const widechar * buffer, int length) {",
          "139:   static char script[BUFSIZE];",
          "140:   int i = 0;",
          "141:   int j = 0;",
          "142:   while (i < length) {",
          "143:     switch (buffer[i]) {",
          "144:     case pass_first:",
          "145:     case pass_last:",
          "146:     case pass_not:",
          "147:     case pass_startReplace:",
          "148:     case pass_endReplace:",
          "149:     case pass_search:",
          "150:     case pass_copy:",
          "151:     case pass_omit:",
          "152:       append_char(script, &j, buffer[i++]);",
          "153:       break;",
          "154:     case pass_lookback:",
          "155:       append_char(script, &j, buffer[i++]);",
          "156:       if (buffer[i] > 1)",
          "157:  append_string(script, &j, print_number(buffer[i++]));",
          "158:       break;",
          "159:     case pass_string:",
          "160:       append_char(script, &j, buffer[i]);",
          "161:       append_string(script, &j, print_chars(&buffer[i + 2], buffer[i + 1]));",
          "162:       append_char(script, &j, buffer[i]);",
          "163:       i += (2 + buffer[i + 1]);",
          "164:       break;",
          "165:     case pass_dots:",
          "166:       append_char(script, &j, buffer[i++]);",
          "167:       append_string(script, &j, print_dots(&buffer[i + 1], buffer[i]));",
          "168:       i += (1 + buffer[i]);",
          "169:       break;",
          "170:     case pass_eq:",
          "171:     case pass_lt:",
          "172:     case pass_gt:",
          "173:     case pass_lteq:",
          "174:     case pass_gteq:",
          "175:       append_char(script, &j, '#');",
          "176:       append_string(script, &j, print_number(buffer[i + 1]));",
          "177:       append_char(script, &j, buffer[i]);",
          "178:       append_string(script, &j, print_number(buffer[i + 2]));",
          "179:       i += 3;",
          "180:       break;",
          "181:     case pass_hyphen:",
          "182:     case pass_plus:",
          "183:       append_char(script, &j, '#');",
          "184:       append_string(script, &j, print_number(buffer[i + 1]));",
          "185:       append_char(script, &j, buffer[i]);",
          "186:       i += 2;",
          "187:       break;",
          "188:     case pass_attributes:",
          "189:       append_char(script, &j, buffer[i]);",
          "190:       append_string(script, &j,",
          "191:       print_attributes(buffer[i + 1] << 16 | buffer[i + 2]));",
          "192:       i += 3;",
          "193:       if (buffer[i] == 1 && buffer[i + 1] == 1) {",
          "194:       } else if (buffer[i] == 1 && buffer[i + 1] == 0xffff)",
          "195:  append_char(script, &j, pass_until);",
          "196:       else if (buffer[i] == buffer[i + 1])",
          "197:  append_string(script, &j, print_number(buffer[i]));",
          "198:       else {",
          "199:  append_string(script, &j, print_number(buffer[i]));",
          "200:  append_char(script, &j, '-');",
          "201:  append_string(script, &j, print_number(buffer[i + 1]));",
          "202:       }",
          "203:       i += 2;",
          "204:       break;",
          "205:     case pass_endTest:",
          "206:       append_char(script, &j, '\\t');",
          "207:       i++;",
          "208:       break;",
          "209:     case pass_swap:",
          "210:     case pass_groupstart:",
          "211:     case pass_groupend:",
          "212:     case pass_groupreplace:",
          "214:     default:",
          "215:       i++;",
          "216:       break;",
          "217:     }",
          "218:   }",
          "219:   script[j] = 0;",
          "220:   return script;",
          "224: print_rule(const TranslationTableRule * rule) {",
          "225:   const char *opcode = _lou_findOpcodeName(rule->opcode);",
          "226:   char *chars;",
          "227:   char *dots;",
          "228:   char *script;",
          "229:   switch (rule->opcode) {",
          "230:   case CTO_Context:",
          "231:   case CTO_Correct:",
          "232:   case CTO_SwapCd:",
          "233:   case CTO_SwapDd:",
          "234:   case CTO_Pass2:",
          "235:   case CTO_Pass3:",
          "236:   case CTO_Pass4:",
          "237:     script = print_script(&rule->charsdots[rule->charslen], rule->dotslen);",
          "238:     printf(\"%s\\t%s\\n\", opcode, script);",
          "239:     break;",
          "240:   default:",
          "241:     chars = print_chars(rule->charsdots, rule->charslen);",
          "242:     dots = print_dots(&rule->charsdots[rule->charslen], rule->dotslen);",
          "243:     printf(\"%s\\t%s\\t%s\\n\", opcode, chars, dots);",
          "244:     break;",
          "245:   }",
          "250:   widechar inbuf[BUFSIZE];",
          "251:   widechar outbuf[BUFSIZE];",
          "252:   int inlen;",
          "253:   int outlen;",
          "254:   const TranslationTableRule **rules =",
          "255:     malloc(512 * sizeof(TranslationTableRule));",
          "256:   int ruleslen;",
          "257:   int i, j;",
          "258:   while (1) {",
          "259:     inlen = get_wide_input(inbuf);",
          "260:     outlen = BUFSIZE;",
          "261:     ruleslen = RULESSIZE;",
          "262:     if (backward_translation)",
          "263:       {",
          "264:  if (!_lou_backTranslateWithTracing(table, inbuf, &inlen, outbuf, &outlen,",
          "265:           NULL, NULL, NULL, NULL, NULL, 0, rules, &ruleslen))",
          "266:    break;",
          "267:       }",
          "268:     else",
          "269:       if (!_lou_translateWithTracing(table, inbuf, &inlen, outbuf, &outlen,",
          "270:     NULL, NULL, NULL, NULL, NULL, 0, rules, &ruleslen))",
          "271:  break;",
          "272:     printf(\"%s\\n\", print_chars(outbuf, outlen));",
          "273:     j = 0;",
          "274:     for (i = 0; i < ruleslen; i++) {",
          "275:       if (rules[i]->opcode < 0 || rules[i]->opcode >= CTO_None)",
          "276:         continue;",
          "277:       printf(\"%d.\\t\", ++j);",
          "278:       print_rule(rules[i]);",
          "279:     }",
          "280:   }",
          "285:   int optc;",
          "286:   char *table;",
          "287:   set_program_name(argv[0]);",
          "288:   while ((optc = getopt_long(argc, argv, \"hvfb\", longopts, NULL)) != -1) {",
          "289:     switch (optc) {",
          "290:     case 'v':",
          "291:       version_etc(stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS,",
          "292:     (char *) NULL);",
          "293:       exit(EXIT_SUCCESS);",
          "294:       break;",
          "295:     case 'h':",
          "296:       print_help();",
          "297:       exit(EXIT_SUCCESS);",
          "298:       break;",
          "299:     case 'f':",
          "300:       forward_flag = 1;",
          "301:       break;",
          "302:     case 'b':",
          "303:       backward_flag = 1;",
          "304:       break;",
          "305:     default:",
          "306:       fprintf(stderr, \"Try `%s --help' for more information.\\n\",",
          "307:        program_name);",
          "308:       exit(EXIT_FAILURE);",
          "309:       break;",
          "310:     }",
          "311:   }",
          "312:   if (forward_flag && backward_flag)",
          "313:     {",
          "314:       fprintf (stderr, \"%s: specify either -f or -b but not both\\n\",",
          "315:         program_name);",
          "316:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "317:                program_name);",
          "318:       exit (EXIT_FAILURE);",
          "319:     }",
          "320:   if (optind != argc - 1) {",
          "321:     if (optind < argc - 1)",
          "322:       fprintf(stderr, \"%s: extra operand: %s\\n\", program_name,",
          "323:        argv[optind + 1]);",
          "324:     else",
          "325:       fprintf(stderr, \"%s: no table specified\\n\", program_name);",
          "326:     fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "327:     exit(EXIT_FAILURE);",
          "328:   }",
          "329:   table = argv[optind];",
          "330:   if (!lou_getTable(table)) {",
          "331:     lou_free();",
          "332:     exit(EXIT_FAILURE);",
          "333:   }",
          "334:   main_loop(backward_flag, table);",
          "335:   lou_free();",
          "336:   exit(EXIT_SUCCESS);",
          "",
          "[Added Lines]",
          "76:  static char input_buffer[BUFSIZE];",
          "77:  size_t input_length;",
          "78:  input_buffer[0] = 0;",
          "79:  if (!fgets(input_buffer, sizeof(input_buffer), stdin)) exit(EXIT_FAILURE);",
          "80:  input_length = strlen(input_buffer) - 1;",
          "81:  if (input_length < 0) exit(0);",
          "82:  input_buffer[input_length] = 0;",
          "83:  return input_buffer;",
          "87: get_wide_input(widechar *buffer) {",
          "88:  return _lou_extParseChars(get_input(), buffer);",
          "92: print_chars(const widechar *buffer, int length) {",
          "93:  static uint8_t result_buf[BUFSIZE];",
          "94:  size_t result_len = BUFSIZE - 1;",
          "96:  u32_to_u8(buffer, length, result_buf, &result_len);",
          "98:  u16_to_u8(buffer, length, result_buf, &result_len);",
          "100:  result_buf[result_len] = 0;",
          "101:  return result_buf;",
          "105: print_dots(const widechar *buffer, int length) {",
          "106:  static char dots[BUFSIZE];",
          "107:  strcpy(dots, _lou_showDots(buffer, length));",
          "108:  return dots;",
          "113:  static char number[BUFSIZE];",
          "114:  sprintf(number, \"%d\", c);",
          "115:  return number;",
          "120:  static char attr[BUFSIZE];",
          "121:  strcpy(attr, _lou_showAttributes(a));",
          "122:  return attr;",
          "127:  destination[(*length)++] = source;",
          "132:  strcpy(&destination[(*length)], source);",
          "133:  (*length) += strlen(source);",
          "137: print_script(const widechar *buffer, int length) {",
          "138:  static char script[BUFSIZE];",
          "139:  int i = 0;",
          "140:  int j = 0;",
          "141:  while (i < length) {",
          "142:   switch (buffer[i]) {",
          "143:   case pass_first:",
          "144:   case pass_last:",
          "145:   case pass_not:",
          "146:   case pass_startReplace:",
          "147:   case pass_endReplace:",
          "148:   case pass_search:",
          "149:   case pass_copy:",
          "150:   case pass_omit:",
          "151:    append_char(script, &j, buffer[i++]);",
          "152:    break;",
          "153:   case pass_lookback:",
          "154:    append_char(script, &j, buffer[i++]);",
          "155:    if (buffer[i] > 1) append_string(script, &j, print_number(buffer[i++]));",
          "156:    break;",
          "157:   case pass_string:",
          "158:    append_char(script, &j, buffer[i]);",
          "159:    append_string(script, &j, print_chars(&buffer[i + 2], buffer[i + 1]));",
          "160:    append_char(script, &j, buffer[i]);",
          "161:    i += (2 + buffer[i + 1]);",
          "162:    break;",
          "163:   case pass_dots:",
          "164:    append_char(script, &j, buffer[i++]);",
          "165:    append_string(script, &j, print_dots(&buffer[i + 1], buffer[i]));",
          "166:    i += (1 + buffer[i]);",
          "167:    break;",
          "168:   case pass_eq:",
          "169:   case pass_lt:",
          "170:   case pass_gt:",
          "171:   case pass_lteq:",
          "172:   case pass_gteq:",
          "173:    append_char(script, &j, '#');",
          "174:    append_string(script, &j, print_number(buffer[i + 1]));",
          "175:    append_char(script, &j, buffer[i]);",
          "176:    append_string(script, &j, print_number(buffer[i + 2]));",
          "177:    i += 3;",
          "178:    break;",
          "179:   case pass_hyphen:",
          "180:   case pass_plus:",
          "181:    append_char(script, &j, '#');",
          "182:    append_string(script, &j, print_number(buffer[i + 1]));",
          "183:    append_char(script, &j, buffer[i]);",
          "184:    i += 2;",
          "185:    break;",
          "186:   case pass_attributes:",
          "187:    append_char(script, &j, buffer[i]);",
          "188:    append_string(",
          "189:      script, &j, print_attributes(buffer[i + 1] << 16 | buffer[i + 2]));",
          "190:    i += 3;",
          "191:    if (buffer[i] == 1 && buffer[i + 1] == 1) {",
          "192:    } else if (buffer[i] == 1 && buffer[i + 1] == 0xffff)",
          "193:     append_char(script, &j, pass_until);",
          "194:    else if (buffer[i] == buffer[i + 1])",
          "195:     append_string(script, &j, print_number(buffer[i]));",
          "196:    else {",
          "197:     append_string(script, &j, print_number(buffer[i]));",
          "198:     append_char(script, &j, '-');",
          "199:     append_string(script, &j, print_number(buffer[i + 1]));",
          "200:    }",
          "201:    i += 2;",
          "202:    break;",
          "203:   case pass_endTest:",
          "204:    append_char(script, &j, '\\t');",
          "205:    i++;",
          "206:    break;",
          "207:   case pass_swap:",
          "208:   case pass_groupstart:",
          "209:   case pass_groupend:",
          "210:   case pass_groupreplace:",
          "212:   default:",
          "213:    i++;",
          "214:    break;",
          "215:   }",
          "216:  }",
          "217:  script[j] = 0;",
          "218:  return script;",
          "222: print_rule(const TranslationTableRule *rule) {",
          "223:  const char *opcode = _lou_findOpcodeName(rule->opcode);",
          "224:  char *chars;",
          "225:  char *dots;",
          "226:  char *script;",
          "227:  switch (rule->opcode) {",
          "228:  case CTO_Context:",
          "229:  case CTO_Correct:",
          "230:  case CTO_SwapCd:",
          "231:  case CTO_SwapDd:",
          "232:  case CTO_Pass2:",
          "233:  case CTO_Pass3:",
          "234:  case CTO_Pass4:",
          "235:   script = print_script(&rule->charsdots[rule->charslen], rule->dotslen);",
          "236:   printf(\"%s\\t%s\\n\", opcode, script);",
          "237:   break;",
          "238:  default:",
          "239:   chars = print_chars(rule->charsdots, rule->charslen);",
          "240:   dots = print_dots(&rule->charsdots[rule->charslen], rule->dotslen);",
          "241:   printf(\"%s\\t%s\\t%s\\n\", opcode, chars, dots);",
          "242:   break;",
          "243:  }",
          "248:  widechar inbuf[BUFSIZE];",
          "249:  widechar outbuf[BUFSIZE];",
          "250:  int inlen;",
          "251:  int outlen;",
          "252:  const TranslationTableRule **rules = malloc(512 * sizeof(TranslationTableRule));",
          "253:  int ruleslen;",
          "254:  int i, j;",
          "255:  while (1) {",
          "256:   inlen = get_wide_input(inbuf);",
          "257:   outlen = BUFSIZE;",
          "258:   ruleslen = RULESSIZE;",
          "259:   if (backward_translation) {",
          "260:    if (!_lou_backTranslateWithTracing(table, inbuf, &inlen, outbuf, &outlen,",
          "261:       NULL, NULL, NULL, NULL, NULL, 0, rules, &ruleslen))",
          "262:     break;",
          "263:   } else if (!_lou_translateWithTracing(table, inbuf, &inlen, outbuf, &outlen, NULL,",
          "264:          NULL, NULL, NULL, NULL, 0, rules, &ruleslen))",
          "265:    break;",
          "266:   printf(\"%s\\n\", print_chars(outbuf, outlen));",
          "267:   j = 0;",
          "268:   for (i = 0; i < ruleslen; i++) {",
          "269:    if (rules[i]->opcode < 0 || rules[i]->opcode >= CTO_None) continue;",
          "270:    printf(\"%d.\\t\", ++j);",
          "271:    print_rule(rules[i]);",
          "272:   }",
          "273:  }",
          "278:  int optc;",
          "279:  char *table;",
          "280:  set_program_name(argv[0]);",
          "281:  while ((optc = getopt_long(argc, argv, \"hvfb\", longopts, NULL)) != -1) {",
          "282:   switch (optc) {",
          "283:   case 'v':",
          "284:    version_etc(",
          "285:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "286:    exit(EXIT_SUCCESS);",
          "287:    break;",
          "288:   case 'h':",
          "289:    print_help();",
          "290:    exit(EXIT_SUCCESS);",
          "291:    break;",
          "292:   case 'f':",
          "293:    forward_flag = 1;",
          "294:    break;",
          "295:   case 'b':",
          "296:    backward_flag = 1;",
          "297:    break;",
          "298:   default:",
          "299:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "300:    exit(EXIT_FAILURE);",
          "301:    break;",
          "302:   }",
          "303:  }",
          "304:  if (forward_flag && backward_flag) {",
          "305:   fprintf(stderr, \"%s: specify either -f or -b but not both\\n\", program_name);",
          "306:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "307:   exit(EXIT_FAILURE);",
          "308:  }",
          "309:  if (optind != argc - 1) {",
          "310:   if (optind < argc - 1)",
          "311:    fprintf(stderr, \"%s: extra operand: %s\\n\", program_name, argv[optind + 1]);",
          "312:   else",
          "313:    fprintf(stderr, \"%s: no table specified\\n\", program_name);",
          "314:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "315:   exit(EXIT_FAILURE);",
          "316:  }",
          "317:  table = argv[optind];",
          "318:  if (!lou_getTable(table)) {",
          "319:   lou_free();",
          "320:   exit(EXIT_FAILURE);",
          "321:  }",
          "322:  main_loop(backward_flag, table);",
          "323:  lou_free();",
          "324:  exit(EXIT_SUCCESS);",
          "",
          "---------------"
        ],
        "tools/lou_translate.c||tools/lou_translate.c": [
          "File: tools/lou_translate.c -> tools/lou_translate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: static FILE *input;",
          "49: };",
          "51: const char version_etc_copyright[] =",
          "54: #define AUTHORS \"John J. Boyer\"",
          "87: #ifdef WIDECHARS_ARE_UCS4",
          "89: #else",
          "91: #endif",
          "96: }",
          "98: static void",
          "105: Translate whatever is on standard input and print it on standard\\n\\",
          "106: output. It is intended for large-scale testing of the accuracy of\\n\\",
          "110: Options:\\n\\",
          "111:   -h, --help          display this help and exit\\n\\",
          "112:   -v, --version       display version information and exit\\n\\",
          "113:   -f, --forward       forward translation using the given table\\n\\",
          "114:   -b, --backward      backward translation using the given table\\n\\",
          "115:                       If neither -f nor -b are specified forward translation\\n\\",
          "118: Examples:\\n\\",
          "119:   lou_translate --forward en-us-g2.ctb < input.txt\\n\\",
          "120:   \\n\\",
          "",
          "[Removed Lines]",
          "42: static const struct option longopts[] =",
          "43: {",
          "44:   { \"help\", no_argument, NULL, 'h' },",
          "45:   { \"version\", no_argument, NULL, 'v' },",
          "46:   { \"forward\", no_argument, NULL, 'f' },",
          "47:   { \"backward\", no_argument, NULL, 'b' },",
          "48:   { NULL, 0, NULL, 0 },",
          "52:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "56: static void",
          "57: translate_input (int forward_translation, char *table_name)",
          "58: {",
          "59:   char charbuf[BUFSIZE];",
          "60:   char *outputbuf;",
          "61:   size_t outlen;",
          "62:   widechar inbuf[BUFSIZE];",
          "63:   widechar transbuf[BUFSIZE];",
          "64:   int inlen;",
          "65:   int translen;",
          "66:   int k;",
          "67:   int ch = 0;",
          "68:   int result;",
          "69:   while (1)",
          "70:     {",
          "71:       translen = BUFSIZE;",
          "72:       k = 0;",
          "73:       while ((ch = fgetc(input)) != '\\n' && ch != EOF && k < BUFSIZE-1)",
          "74:  charbuf[k++] = ch;",
          "75:       if (ch == EOF && k == 0)",
          "76:  break;",
          "77:       charbuf[k] = 0;",
          "78:       inlen = _lou_extParseChars (charbuf, inbuf);",
          "79:       if (forward_translation)",
          "80:    result = lou_translateString (table_name, inbuf, &inlen,",
          "81:           transbuf, &translen, NULL, NULL, 0);",
          "82:       else",
          "83:  result = lou_backTranslateString (table_name, inbuf, &inlen,",
          "84:        transbuf, &translen, NULL, NULL, 0);",
          "85:       if (!result)",
          "86:  break;",
          "88:       outputbuf = u32_to_u8(transbuf, translen, NULL, &outlen);",
          "90:       outputbuf = u16_to_u8(transbuf, translen, NULL, &outlen);",
          "92:       printf (ch == EOF ? \"%.*s\" : \"%.*s\\n\", (int)outlen, outputbuf);",
          "93:       free(outputbuf);",
          "94:     }",
          "95:   lou_free ();",
          "99: print_help (void)",
          "100: {",
          "101:   printf (\"\\",
          "102: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\", program_name);",
          "104:   fputs (\"\\",
          "107: Braille translation and back-translation.\\n\\n\", stdout);",
          "109:   fputs (\"\\",
          "116:                       is assumed\\n\", stdout);",
          "117:   fputs (\"\\",
          "",
          "[Added Lines]",
          "42: static const struct option longopts[] = {",
          "43:  { \"help\", no_argument, NULL, 'h' }, { \"version\", no_argument, NULL, 'v' },",
          "44:  { \"forward\", no_argument, NULL, 'f' }, { \"backward\", no_argument, NULL, 'b' },",
          "45:  { NULL, 0, NULL, 0 },",
          "49:   \"Copyright %s %d ViewPlus Technologies, Inc. and JJB Software, Inc.\";",
          "53: static void",
          "54: translate_input(int forward_translation, char *table_name) {",
          "55:  char charbuf[BUFSIZE];",
          "56:  char *outputbuf;",
          "57:  size_t outlen;",
          "58:  widechar inbuf[BUFSIZE];",
          "59:  widechar transbuf[BUFSIZE];",
          "60:  int inlen;",
          "61:  int translen;",
          "62:  int k;",
          "63:  int ch = 0;",
          "64:  int result;",
          "65:  while (1) {",
          "66:   translen = BUFSIZE;",
          "67:   k = 0;",
          "68:   while ((ch = fgetc(input)) != '\\n' && ch != EOF && k < BUFSIZE - 1)",
          "69:    charbuf[k++] = ch;",
          "70:   if (ch == EOF && k == 0) break;",
          "71:   charbuf[k] = 0;",
          "72:   inlen = _lou_extParseChars(charbuf, inbuf);",
          "73:   if (forward_translation)",
          "74:    result = lou_translateString(",
          "75:      table_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);",
          "76:   else",
          "77:    result = lou_backTranslateString(",
          "78:      table_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);",
          "79:   if (!result) break;",
          "81:   outputbuf = u32_to_u8(transbuf, translen, NULL, &outlen);",
          "83:   outputbuf = u16_to_u8(transbuf, translen, NULL, &outlen);",
          "85:   printf(ch == EOF ? \"%.*s\" : \"%.*s\\n\", (int)outlen, outputbuf);",
          "86:   free(outputbuf);",
          "87:  }",
          "88:  lou_free();",
          "92: print_help(void) {",
          "93:  printf(\"\\",
          "94: Usage: %s [OPTIONS] TABLE[,TABLE,...]\\n\",",
          "95:    program_name);",
          "97:  fputs(\"\\",
          "100: Braille translation and back-translation.\\n\\n\",",
          "101:    stdout);",
          "103:  fputs(\"\\",
          "110:                       is assumed\\n\",",
          "111:    stdout);",
          "112:  fputs(\"\\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:   \\n\\",
          "129:   echo \\\",! qk br{n fox\\\" | lou_translate --backward en-us-g2.ctb\\n\\",
          "130:   \\n\\",
          "135: #ifdef PACKAGE_PACKAGER_BUG_REPORTS",
          "137: #endif",
          "138: #ifdef PACKAGE_URL",
          "140: #endif",
          "141: }",
          "143: int",
          "209:  }",
          "211:   input = stdin;",
          "216: }",
          "",
          "[Removed Lines]",
          "131:   Do a backward translation with table en-us-g2.ctb.\\n\", stdout);",
          "132:   printf (\"\\n\");",
          "133:   printf (\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "136:   printf (\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "139:   printf (\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "144: main (int argc, char **argv)",
          "145: {",
          "146:   int optc;",
          "148:   set_program_name (argv[0]);",
          "150:   while ((optc = getopt_long (argc, argv, \"hvfb\", longopts, NULL)) != -1) {",
          "151:     switch (optc)",
          "152:       {",
          "154:       case 'v':",
          "155:         version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *) NULL);",
          "156:         exit (EXIT_SUCCESS);",
          "157:         break;",
          "158:       case 'h':",
          "159:         print_help ();",
          "160:         exit (EXIT_SUCCESS);",
          "161:         break;",
          "162:       case 'f':",
          "163:  forward_flag = 1;",
          "164:         break;",
          "165:       case 'b':",
          "166:  backward_flag = 1;",
          "167:         break;",
          "168:       default:",
          "169:  fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "170:    program_name);",
          "171:  exit (EXIT_FAILURE);",
          "172:         break;",
          "173:       }",
          "174:   }",
          "176:   if (forward_flag && backward_flag)",
          "177:     {",
          "178:       fprintf (stderr, \"%s: specify either -f or -b but not both\\n\",",
          "179:         program_name);",
          "180:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "181:                program_name);",
          "182:       exit (EXIT_FAILURE);",
          "183:     }",
          "198:  if(!argv[optind + 0])",
          "199:  {",
          "200:  fprintf (stderr, \"%s: no table specified\\n\",",
          "201:    program_name);",
          "202:       fprintf (stderr, \"Try `%s --help' for more information.\\n\",",
          "203:                program_name);",
          "204:       exit (EXIT_FAILURE);",
          "205:       }",
          "206:  if(argv[optind + 1])",
          "207:  {",
          "208:   input = fopen(argv[optind + 1], \"r\");",
          "210:  else",
          "214:   translate_input (!backward_flag, argv[optind]);",
          "215:   exit (EXIT_SUCCESS);",
          "",
          "[Added Lines]",
          "126:   Do a backward translation with table en-us-g2.ctb.\\n\",",
          "127:    stdout);",
          "128:  printf(\"\\n\");",
          "129:  printf(\"Report bugs to %s.\\n\", PACKAGE_BUGREPORT);",
          "132:  printf(\"Report %s bugs to: %s\\n\", PACKAGE_PACKAGER, PACKAGE_PACKAGER_BUG_REPORTS);",
          "135:  printf(\"%s home page: <%s>\\n\", PACKAGE_NAME, PACKAGE_URL);",
          "140: main(int argc, char **argv) {",
          "141:  int optc;",
          "143:  set_program_name(argv[0]);",
          "145:  while ((optc = getopt_long(argc, argv, \"hvfb\", longopts, NULL)) != -1) {",
          "146:   switch (optc) {",
          "148:   case 'v':",
          "149:    version_etc(",
          "150:      stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS, (char *)NULL);",
          "151:    exit(EXIT_SUCCESS);",
          "152:    break;",
          "153:   case 'h':",
          "154:    print_help();",
          "155:    exit(EXIT_SUCCESS);",
          "156:    break;",
          "157:   case 'f':",
          "158:    forward_flag = 1;",
          "159:    break;",
          "160:   case 'b':",
          "161:    backward_flag = 1;",
          "162:    break;",
          "163:   default:",
          "164:    fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "165:    exit(EXIT_FAILURE);",
          "166:    break;",
          "167:   }",
          "170:  if (forward_flag && backward_flag) {",
          "171:   fprintf(stderr, \"%s: specify either -f or -b but not both\\n\", program_name);",
          "172:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "173:   exit(EXIT_FAILURE);",
          "174:  }",
          "189:  if (!argv[optind + 0]) {",
          "190:   fprintf(stderr, \"%s: no table specified\\n\", program_name);",
          "191:   fprintf(stderr, \"Try `%s --help' for more information.\\n\", program_name);",
          "192:   exit(EXIT_FAILURE);",
          "193:  }",
          "194:  if (argv[optind + 1]) {",
          "195:   input = fopen(argv[optind + 1], \"r\");",
          "196:  } else",
          "200:  translate_input(!backward_flag, argv[optind]);",
          "201:  exit(EXIT_SUCCESS);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
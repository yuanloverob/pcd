{
  "cve_id": "CVE-2017-9353",
  "cve_desc": "In Wireshark 2.2.0 to 2.2.6, the IPv6 dissector could crash. This was addressed in epan/dissectors/packet-ipv6.c by validating an IPv6 address.",
  "repo": "wireshark/wireshark",
  "patch_hash": "0e53c857e5ecc0032941b2e8a048989099fb0043",
  "patch_info": {
    "commit_hash": "0e53c857e5ecc0032941b2e8a048989099fb0043",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/0e53c857e5ecc0032941b2e8a048989099fb0043",
    "files": [
      "epan/dissectors/packet-ipv6.c"
    ],
    "message": "packet-ipv6.c: dissect_routing6_rpl must have IPv6 addresses.\n\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1303\nBug: 13675\nChange-Id: Icadf8a57a25bbf9abaa9685f9e9c7a803204b7e5\nReviewed-on: https://code.wireshark.org/review/21527\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c": [
      "File: epan/dissectors/packet-ipv6.c -> epan/dissectors/packet-ipv6.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "943:     wmem_array_t *rpl_addr_vector = NULL;",
      "944:     guint i;",
      "947:     ip6_dst_addr = (const struct e_in6_addr *)pinfo->dst.data;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "947:     if ((pinfo->dst.type != AT_IPv6) || (pinfo->src.type != AT_IPv6))",
      "948:         return;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "40b2d475c2ad550c1a0f536d5eb30f2a7404c4f0",
      "candidate_info": {
        "commit_hash": "40b2d475c2ad550c1a0f536d5eb30f2a7404c4f0",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/40b2d475c2ad550c1a0f536d5eb30f2a7404c4f0",
        "files": [
          "epan/dissectors/packet-ipv6.c"
        ],
        "message": "packet-ipv6.c: dissect_routing6_rpl must have IPv6 addresses.\n\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1303\nBug: 13675\nChange-Id: Icadf8a57a25bbf9abaa9685f9e9c7a803204b7e5\nReviewed-on: https://code.wireshark.org/review/21527\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 0e53c857e5ecc0032941b2e8a048989099fb0043)\nReviewed-on: https://code.wireshark.org/review/21532",
        "before_after_code_files": [
          "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c"
          ],
          "candidate": [
            "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c": [
          "File: epan/dissectors/packet-ipv6.c -> epan/dissectors/packet-ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "889:     wmem_array_t *rpl_addr_vector = NULL;",
          "890:     guint i;",
          "893:     ip6_dst_addr = (const struct e_in6_addr *)pinfo->dst.data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "893:     if ((pinfo->dst.type != AT_IPv6) || (pinfo->src.type != AT_IPv6))",
          "894:         return;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20d0a90115fb650c852a5ff1a6c3e7cf488ad673",
      "candidate_info": {
        "commit_hash": "20d0a90115fb650c852a5ff1a6c3e7cf488ad673",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/20d0a90115fb650c852a5ff1a6c3e7cf488ad673",
        "files": [
          "epan/dissectors/packet-ip.h",
          "epan/dissectors/packet-ipv6.c"
        ],
        "message": "IPv6: Add routing extension header dissector table\n\nChange-Id: I1cf462179f8c6cf8c8c881d2cbda8ebe667d9055\nReviewed-on: https://code.wireshark.org/review/23362\nPetri-Dish: Jo\u00e3o Valverde <j@v6e.pt>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Jo\u00e3o Valverde <j@v6e.pt>",
        "before_after_code_files": [
          "epan/dissectors/packet-ip.h||epan/dissectors/packet-ip.h",
          "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c"
          ],
          "candidate": [
            "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-ip.h||epan/dissectors/packet-ip.h": [
          "File: epan/dissectors/packet-ip.h -> epan/dissectors/packet-ip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "89: #define WS_IP6_PTR(p)         ((ws_ip6 *)(((p) && *(guint8 *)(p) == 6) ? (p) : NULL))",
          "91: typedef ws_ip6 ipv6_tap_info_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91: struct ws_rthdr {",
          "92:     struct ip6_rthdr hdr;",
          "93:     proto_item *ti_len;",
          "94:     proto_item *ti_type;",
          "95:     proto_item *ti_segleft;",
          "96: };",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-ipv6.c||epan/dissectors/packet-ipv6.c": [
          "File: epan/dissectors/packet-ipv6.c -> epan/dissectors/packet-ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "120: static int proto_ipv6_fraghdr                   = -1;",
          "121: static int proto_ipv6_dstopts                   = -1;",
          "123: static int hf_ipv6_version                      = -1;",
          "124: static int hf_ip_version                        = -1;",
          "125: static int hf_ipv6_tclass                       = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "123: static int proto_ipv6_routing_rt0               = -1;",
          "124: static int proto_ipv6_routing_mipv6             = -1;",
          "125: static int proto_ipv6_routing_rpl               = -1;",
          "126: static int proto_ipv6_routing_srh               = -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "521: };",
          "523: static dissector_table_t ip_dissector_table;",
          "526: static gboolean ipv6_reassemble = TRUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "529: static dissector_table_t ipv6_routing_dissector_table;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "656: enum {",
          "660:     IPv6_RT_HEADER_RPL             = 3,",
          "661:     IPv6_RT_HEADER_SEGMENT_ROUTING = 4,",
          "662:     IPv6_RT_HEADER_EXP1            = 253,",
          "",
          "[Removed Lines]",
          "659:     IPv6_RT_HEADER_MobileIP        = 2,",
          "",
          "[Added Lines]",
          "665:     IPv6_RT_HEADER_MOBILE_IP       = 2,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "667: static const value_string routing_header_type[] = {",
          "668:     { IPv6_RT_HEADER_SOURCE_ROUTING,    \"Source Route\"     },",
          "669:     { IPv6_RT_HEADER_NIMROD,            \"Nimrod\"           },",
          "671:     { IPv6_RT_HEADER_RPL,               \"RPL Source Route\" },",
          "672:     { IPv6_RT_HEADER_SEGMENT_ROUTING,   \"Segment Routing\"  },",
          "673:     { IPv6_RT_HEADER_EXP1,              \"Experiment 1\"     },",
          "",
          "[Removed Lines]",
          "670:     { IPv6_RT_HEADER_MobileIP,          \"Type 2 Routing\"   },",
          "",
          "[Added Lines]",
          "676:     { IPv6_RT_HEADER_MOBILE_IP,         \"Type 2 Routing\"   },",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "857:     return FALSE;",
          "858: }",
          "866: static proto_item *",
          "867: _proto_tree_add_ipv6_vector_address(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint start,",
          "868:                             gint length, const struct e_in6_addr *value_ptr, int idx)",
          "",
          "[Removed Lines]",
          "860: struct rthdr_proto_item {",
          "861:     proto_item *len;",
          "862:     proto_item *type;",
          "863:     proto_item *segs;",
          "864: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "877: }",
          "883: {",
          "884:     proto_item *ti;",
          "885:     gint idx;",
          "886:     gint rt0_addr_count;",
          "887:     const struct e_in6_addr *addr = NULL;",
          "890:     offset += 4;",
          "894:                 \"IPv6 Routing Header extension header length must not be odd\");",
          "895:     }",
          "899:                 \"IPv6 Type 0 Routing Header segments left field must not exceed address count (%u)\", rt0_addr_count);",
          "900:     }",
          "902:     for (idx = 1; idx <= rt0_addr_count; idx++) {",
          "903:         addr = tvb_get_ptr_ipv6(tvb, offset);",
          "905:                             offset, IPv6_ADDR_SIZE, addr, idx);",
          "906:         offset += IPv6_ADDR_SIZE;",
          "907:         if (in6_is_addr_multicast(addr)) {",
          "",
          "[Removed Lines]",
          "880: static void",
          "881: dissect_routing6_rt0(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rthdr_tree,",
          "882:                         struct rthdr_proto_item *rthdr_ti, struct ip6_rthdr rt)",
          "889:     proto_tree_add_item(rthdr_tree, hf_ipv6_routing_src_reserved, tvb, offset, 4, ENC_NA);",
          "892:     if (rt.ip6r_len % 2 != 0) {",
          "893:         expert_add_info_format(pinfo, rthdr_ti->len, &ei_ipv6_routing_invalid_length,",
          "896:     rt0_addr_count = rt.ip6r_len / 2;",
          "897:     if (rt.ip6r_segleft > rt0_addr_count) {",
          "898:         expert_add_info_format(pinfo, rthdr_ti->segs, &ei_ipv6_routing_invalid_segleft,",
          "904:         ti = _proto_tree_add_ipv6_vector_address(rthdr_tree, hf_ipv6_routing_src_addr, tvb,",
          "",
          "[Added Lines]",
          "880: static int",
          "881: dissect_routing6_rt0(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "883:     struct ws_rthdr *rt = (struct ws_rthdr *)data;",
          "885:     int offset = 0;",
          "890:     proto_tree_add_item(tree, hf_ipv6_routing_src_reserved, tvb, offset, 4, ENC_NA);",
          "893:     if (rt->hdr.ip6r_len % 2 != 0) {",
          "894:         expert_add_info_format(pinfo, rt->ti_len, &ei_ipv6_routing_invalid_length,",
          "897:     rt0_addr_count = rt->hdr.ip6r_len / 2;",
          "898:     if (rt->hdr.ip6r_segleft > rt0_addr_count) {",
          "899:         expert_add_info_format(pinfo, rt->ti_segleft, &ei_ipv6_routing_invalid_segleft,",
          "905:         ti = _proto_tree_add_ipv6_vector_address(tree, hf_ipv6_routing_src_addr, tvb,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "909:         }",
          "910:     }",
          "913:         alloc_address_wmem_ipv6(pinfo->pool, &pinfo->dst, addr);",
          "914:     }",
          "915: }",
          "921: {",
          "922:     proto_item *ti;",
          "923:     const struct e_in6_addr *addr;",
          "926:     offset += 4;",
          "930:                 \"IPv6 Type 2 Routing Header extension header length must equal 2\");",
          "931:     }",
          "934:                 \"IPv6 Type 2 Routing Header segments left field must equal 1\");",
          "935:     }",
          "937:     addr = tvb_get_ptr_ipv6(tvb, offset);",
          "939:                         offset, IPv6_ADDR_SIZE, addr, 1);",
          "940:     if (in6_is_addr_multicast(addr)) {",
          "941:         expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_multicast_addr);",
          "942:     }",
          "945:         alloc_address_wmem_ipv6(pinfo->pool, &pinfo->dst, addr);",
          "946:     }",
          "947: }",
          "953: {",
          "955:     proto_item *ti;",
          "956:     guint8 cmprI, cmprE, cmprX, pad;",
          "957:     guint32 reserved;",
          "958:     gint idx;",
          "",
          "[Removed Lines]",
          "912:     if (addr != NULL && pinfo->dst.type == AT_IPv6 && rt.ip6r_segleft > 0) {",
          "918: static void",
          "919: dissect_routing6_mipv6(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rthdr_tree,",
          "920:                         struct rthdr_proto_item *rthdr_ti, struct ip6_rthdr rt)",
          "925:     proto_tree_add_item(rthdr_tree, hf_ipv6_routing_mipv6_reserved, tvb, offset, 4, ENC_NA);",
          "928:     if (rt.ip6r_len != 2) {",
          "929:         expert_add_info_format(pinfo, rthdr_ti->len, &ei_ipv6_routing_invalid_length,",
          "932:     if (rt.ip6r_segleft != 1) {",
          "933:         expert_add_info_format(pinfo, rthdr_ti->segs, &ei_ipv6_routing_invalid_segleft,",
          "938:     ti = _proto_tree_add_ipv6_vector_address(rthdr_tree, hf_ipv6_routing_mipv6_home_address, tvb,",
          "944:     if (pinfo->dst.type == AT_IPv6 && rt.ip6r_segleft > 0) {",
          "950: static void",
          "951: dissect_routing6_rpl(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rthdr_tree,",
          "952:                         struct rthdr_proto_item *rthdr_ti, struct ip6_rthdr rt)",
          "954:     proto_item *pi = proto_tree_get_parent(rthdr_tree);",
          "",
          "[Added Lines]",
          "913:     if (addr != NULL && pinfo->dst.type == AT_IPv6 && rt->hdr.ip6r_segleft > 0) {",
          "917:     expert_add_info(pinfo, rt->ti_type, &ei_ipv6_routing_deprecated);",
          "918:     return tvb_captured_length(tvb);",
          "922: static int",
          "923: dissect_routing6_mipv6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "925:     struct ws_rthdr *rt = (struct ws_rthdr *)data;",
          "927:     int offset = 0;",
          "930:     proto_tree_add_item(tree, hf_ipv6_routing_mipv6_reserved, tvb, offset, 4, ENC_NA);",
          "933:     if (rt->hdr.ip6r_len != 2) {",
          "934:         expert_add_info_format(pinfo, rt->ti_len, &ei_ipv6_routing_invalid_length,",
          "937:     if (rt->hdr.ip6r_segleft != 1) {",
          "938:         expert_add_info_format(pinfo, rt->ti_segleft, &ei_ipv6_routing_invalid_segleft,",
          "943:     ti = _proto_tree_add_ipv6_vector_address(tree, hf_ipv6_routing_mipv6_home_address, tvb,",
          "949:     if (pinfo->dst.type == AT_IPv6 && rt->hdr.ip6r_segleft > 0) {",
          "953:     return tvb_captured_length(tvb);",
          "957: static int",
          "958: dissect_routing6_rpl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "960:     struct ws_rthdr *rt = (struct ws_rthdr *)data;",
          "962:     int offset = 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "966:     if ((pinfo->dst.type != AT_IPv6) || (pinfo->src.type != AT_IPv6))",
          "970:     ip6_dst_addr = (const struct e_in6_addr *)pinfo->dst.data;",
          "",
          "[Removed Lines]",
          "967:         return;",
          "",
          "[Added Lines]",
          "974:         return 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "975:     if (in6_is_addr_multicast(ip6_dst_addr)) {",
          "977:     }",
          "983:     cmprI = tvb_get_guint8(tvb, offset) & 0xF0;",
          "984:     cmprE = tvb_get_guint8(tvb, offset) & 0x0F;",
          "",
          "[Removed Lines]",
          "976:         expert_add_info(pinfo, pi, &ei_ipv6_dst_addr_not_multicast);",
          "979:     proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_cmprI, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "980:     proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_cmprE, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "981:     ti = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_pad, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "",
          "[Added Lines]",
          "983:         expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_ipv6_dst_addr_not_multicast);",
          "986:     proto_tree_add_item(tree, hf_ipv6_routing_rpl_cmprI, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "987:     proto_tree_add_item(tree, hf_ipv6_routing_rpl_cmprE, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "988:     ti = proto_tree_add_item(tree, hf_ipv6_routing_rpl_pad, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "993:         expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_cmpri_cmpre_pad, \"When cmprI equals 0 and cmprE equals 0, pad MUST equal 0 but instead was %d\", pad);",
          "994:     }",
          "997:     reserved = tvb_get_bits32(tvb, ((offset + 1) * 8) + 4, 20, ENC_BIG_ENDIAN);",
          "999:     if (reserved != 0) {",
          "",
          "[Removed Lines]",
          "996:     ti = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "",
          "[Added Lines]",
          "1003:     ti = proto_tree_add_item(tree, hf_ipv6_routing_rpl_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1006:     rpl_addr_count = 0;",
          "1009:     }",
          "1011:     PROTO_ITEM_SET_GENERATED(ti);",
          "1012:     if (rpl_addr_count < 0) {",
          "1014:         expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_addr_count_ge0, \"Calculated total address count must be greater than or equal to 0, instead was %d\", rpl_addr_count);",
          "1015:     }",
          "1018:             \"IPv6 RPL Routing Header segments left field must not exceed address count (%d)\", rpl_addr_count);",
          "1019:     }",
          "",
          "[Removed Lines]",
          "1007:     if (rt.ip6r_len > 0) {",
          "1008:         rpl_addr_count = (((rt.ip6r_len * 8) - pad - (16 - cmprE)) / (16 - cmprI)) + 1;",
          "1010:     ti = proto_tree_add_int(rthdr_tree, hf_ipv6_routing_rpl_addr_count, tvb, offset, 2, rpl_addr_count);",
          "1016:     else if (rt.ip6r_segleft > (guint)rpl_addr_count) {",
          "1017:         expert_add_info_format(pinfo, rthdr_ti->segs, &ei_ipv6_routing_invalid_segleft,",
          "",
          "[Added Lines]",
          "1014:     if (rt->hdr.ip6r_len > 0) {",
          "1015:         rpl_addr_count = (((rt->hdr.ip6r_len * 8) - pad - (16 - cmprE)) / (16 - cmprI)) + 1;",
          "1017:     ti = proto_tree_add_int(tree, hf_ipv6_routing_rpl_addr_count, tvb, offset, 2, rpl_addr_count);",
          "1023:     else if (rt->hdr.ip6r_segleft > (guint)rpl_addr_count) {",
          "1024:         expert_add_info_format(pinfo, rt->ti_segleft, &ei_ipv6_routing_invalid_segleft,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1030:                 cmprX = 16 - cmprE;",
          "1031:             else",
          "1032:                 cmprX = 16 - cmprI;",
          "1035:             memcpy(&rpl_fulladdr, ip6_dst_addr, IPv6_ADDR_SIZE);",
          "1036:             tvb_memcpy(tvb, &rpl_fulladdr.bytes[16-cmprX], offset, cmprX);",
          "1038:                                 offset, cmprX, &rpl_fulladdr, idx);",
          "1039:             PROTO_ITEM_SET_GENERATED(ti);",
          "1040:             offset += cmprX;",
          "",
          "[Removed Lines]",
          "1033:             proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_addr, tvb, offset, cmprX, ENC_NA);",
          "1037:             ti = _proto_tree_add_ipv6_vector_address(rthdr_tree, hf_ipv6_routing_rpl_fulladdr, tvb,",
          "",
          "[Added Lines]",
          "1040:             proto_tree_add_item(tree, hf_ipv6_routing_rpl_addr, tvb, offset, cmprX, ENC_NA);",
          "1044:             ti = _proto_tree_add_ipv6_vector_address(tree, hf_ipv6_routing_rpl_fulladdr, tvb,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1067:                 wmem_array_append(rpl_addr_vector, &rpl_fulladdr, 1);",
          "1068:             }",
          "1071:                 alloc_address_wmem_ipv6(pinfo->pool, &pinfo->dst, &rpl_fulladdr);",
          "1072:             }",
          "1073:         }",
          "1074:     }",
          "1075: }",
          "1082: {",
          "1083:     proto_item *ti;",
          "1084:     gint offlim, offstart;",
          "1085:     gint idx;",
          "1086:     gint srh_first_seg, srh_addr_count;",
          "",
          "[Removed Lines]",
          "1070:             if (pinfo->dst.type == AT_IPv6 && rt.ip6r_segleft > 0) {",
          "1079: static void",
          "1080: dissect_routing6_srh(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rthdr_tree,",
          "1081:                         struct rthdr_proto_item *rthdr_ti, struct ip6_rthdr rt)",
          "",
          "[Added Lines]",
          "1077:             if (pinfo->dst.type == AT_IPv6 && rt->hdr.ip6r_segleft > 0) {",
          "1083:     return tvb_captured_length(tvb);",
          "1088: static int",
          "1089: dissect_routing6_srh(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "1091:     struct ws_rthdr *rt = (struct ws_rthdr *)data;",
          "1093:     int offset = 0;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1097:     };",
          "1099:     srh_first_seg = tvb_get_guint8(tvb, offset);",
          "1101:     offset += 1;",
          "1102:     srh_addr_count = srh_first_seg + 1;",
          "1106:                             ett_ipv6_routing_srh_flags, srh_flags, ENC_BIG_ENDIAN);",
          "1107:     expert_add_info_format(pinfo, ti, &ei_ipv6_routing_undecoded,",
          "1108:                 \"Dissection for SRH TLVs not yet implemented\");",
          "1109:     offset += 1;",
          "1112:     offset += 2;",
          "1116:                                \"IPv6 Type 4 Routing Header segments left field must not exceed first segment (%u)\", srh_first_seg);",
          "1117:     }",
          "",
          "[Removed Lines]",
          "1100:     proto_tree_add_item(rthdr_tree, hf_ipv6_routing_srh_first_seg, tvb, offset, 1, ENC_NA);",
          "1105:     ti = proto_tree_add_bitmask(rthdr_tree, tvb, offset, hf_ipv6_routing_srh_flags,",
          "1111:     proto_tree_add_item(rthdr_tree, hf_ipv6_routing_srh_reserved, tvb, offset, 2, ENC_NA);",
          "1114:     if (rt.ip6r_segleft > srh_first_seg) {",
          "1115:         expert_add_info_format(pinfo, rthdr_ti->segs, &ei_ipv6_routing_invalid_segleft,",
          "",
          "[Added Lines]",
          "1110:     proto_tree_add_item(tree, hf_ipv6_routing_srh_first_seg, tvb, offset, 1, ENC_NA);",
          "1115:     ti = proto_tree_add_bitmask(tree, tvb, offset, hf_ipv6_routing_srh_flags,",
          "1121:     proto_tree_add_item(tree, hf_ipv6_routing_srh_reserved, tvb, offset, 2, ENC_NA);",
          "1124:     if (rt->hdr.ip6r_segleft > srh_first_seg) {",
          "1125:         expert_add_info_format(pinfo, rt->ti_segleft, &ei_ipv6_routing_invalid_segleft,",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1124:     if (in6_is_addr_multicast(addr)) {",
          "1125:         expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_multicast_addr);",
          "1126:     }",
          "1128:                             offset, IPv6_ADDR_SIZE, addr, 0);",
          "1130:         proto_item_append_text(ti, \" [next segment]\");",
          "1131:     }",
          "1134:         alloc_address_wmem_ipv6(pinfo->pool, &pinfo->dst, addr);",
          "1135:     }",
          "",
          "[Removed Lines]",
          "1127:     ti = _proto_tree_add_ipv6_vector_address(rthdr_tree, hf_ipv6_routing_srh_addr, tvb,",
          "1129:     if (rt.ip6r_segleft == 1) {",
          "1133:     if (pinfo->dst.type == AT_IPv6 && rt.ip6r_segleft > 0) {",
          "",
          "[Added Lines]",
          "1137:     ti = _proto_tree_add_ipv6_vector_address(tree, hf_ipv6_routing_srh_addr, tvb,",
          "1139:     if (rt->hdr.ip6r_segleft == 1) {",
          "1143:     if (pinfo->dst.type == AT_IPv6 && rt->hdr.ip6r_segleft > 0) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1140:         if (in6_is_addr_multicast(addr)) {",
          "1141:             expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_multicast_addr);",
          "1142:         }",
          "1144:                             offset, IPv6_ADDR_SIZE, addr, idx);",
          "1146:             proto_item_append_text(ti, \" [next segment]\");",
          "1147:         }",
          "1148:     }",
          "1151:                             ett_ipv6_routing_srh_vect, &ti, \"Segments in Traversal Order\");",
          "1152:     PROTO_ITEM_SET_GENERATED(ti);",
          "1153:     offset -= IPv6_ADDR_SIZE;",
          "",
          "[Removed Lines]",
          "1143:         ti = _proto_tree_add_ipv6_vector_address(rthdr_tree, hf_ipv6_routing_srh_addr, tvb,",
          "1145:         if (idx == rt.ip6r_segleft - 1) {",
          "1150:     rthdr_srh_addr_tree = proto_tree_add_subtree_format(rthdr_tree, tvb, offstart, srh_addr_count * IPv6_ADDR_SIZE,",
          "",
          "[Added Lines]",
          "1153:         ti = _proto_tree_add_ipv6_vector_address(tree, hf_ipv6_routing_srh_addr, tvb,",
          "1155:         if (idx == rt->hdr.ip6r_segleft - 1) {",
          "1160:     rthdr_srh_addr_tree = proto_tree_add_subtree_format(tree, tvb, offstart, srh_addr_count * IPv6_ADDR_SIZE,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1155:         addr = tvb_get_ptr_ipv6(tvb, offset);",
          "1156:         ti = _proto_tree_add_ipv6_vector_address(rthdr_srh_addr_tree, hf_ipv6_routing_srh_addr, tvb,",
          "1157:                             offset, IPv6_ADDR_SIZE, addr, idx);",
          "1159:             proto_item_append_text(ti, \" [next segment]\");",
          "1160:         }",
          "1161:     }",
          "1176: }",
          "1178: static int",
          "1185:     int                offset = 0;",
          "1186:     tvbuff_t          *next_tvb;",
          "1188:     col_append_sep_str(pinfo->cinfo, COL_INFO, \" , \", \"IPv6 routing\");",
          "1203:     offset += 1;",
          "1207:     PROTO_ITEM_SET_GENERATED(ti);",
          "1208:     if (ipv6_exthdr_hide_len_oct_field) {",
          "1209:         PROTO_ITEM_SET_HIDDEN(ti);",
          "1211:     }",
          "1212:     offset += 1;",
          "1215:     offset += 1;",
          "1218:     offset += 1;",
          "1241:     }",
          "1247:     return tvb_captured_length(tvb);",
          "1248: }",
          "",
          "[Removed Lines]",
          "1158:         if (idx == rt.ip6r_segleft - 1) {",
          "1162: }",
          "1166: static void",
          "1167: dissect_routing6_unknown(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *rthdr_tree,",
          "1168:                         struct rthdr_proto_item *rthdr_ti _U_, struct ip6_rthdr rt)",
          "1169: {",
          "1170:     gint len;",
          "1171:     proto_item *ti;",
          "1173:     len = ((rt.ip6r_len + 1) << 3) - 4;",
          "1174:     ti = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_unknown_data, tvb, offset, len, ENC_NA);",
          "1175:     expert_add_info(pinfo, ti, &ei_ipv6_routing_undecoded);",
          "1179: dissect_routing6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data) {",
          "1180:     struct ip6_rthdr   rt;",
          "1181:     guint              len;",
          "1182:     proto_tree        *rthdr_tree, *root_tree;",
          "1183:     proto_item        *pi, *ti;",
          "1184:     struct rthdr_proto_item rthdr_ti;",
          "1190:     tvb_memcpy(tvb, (guint8 *)&rt, offset, sizeof(rt));",
          "1191:     len = (rt.ip6r_len + 1) << 3;",
          "1193:     root_tree = p_ipv6_pinfo_select_root(pinfo, tree);",
          "1194:     p_ipv6_pinfo_add_len(pinfo, len);",
          "1197:     pi = proto_tree_add_item(root_tree, proto_ipv6_routing, tvb, offset, len, ENC_NA);",
          "1198:     proto_item_append_text(pi, \" (%s)\", val_to_str(rt.ip6r_type, routing_header_type, \"Unknown type %u\"));",
          "1200:     rthdr_tree = proto_item_add_subtree(pi, ett_ipv6_routing_proto);",
          "1202:     proto_tree_add_item(rthdr_tree, hf_ipv6_routing_nxt, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1205:     rthdr_ti.len = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_len, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1206:     ti = proto_tree_add_uint(rthdr_tree, hf_ipv6_routing_len_oct, tvb, offset, 1, len);",
          "1210:         proto_item_append_text(rthdr_ti.len, \" (%d bytes)\", len);",
          "1214:     rthdr_ti.type = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1217:     rthdr_ti.segs = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_segleft, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1220:     switch (rt.ip6r_type) {",
          "1221:     case IPv6_RT_HEADER_SOURCE_ROUTING:",
          "1222:         dissect_routing6_rt0(tvb, offset, pinfo, rthdr_tree, &rthdr_ti, rt);",
          "1223:         expert_add_info(pinfo, rthdr_ti.type, &ei_ipv6_routing_deprecated);",
          "1224:         break;",
          "1225:     case IPv6_RT_HEADER_NIMROD:",
          "1226:         dissect_routing6_unknown(tvb, offset, pinfo, rthdr_tree, &rthdr_ti, rt);",
          "1227:         expert_add_info(pinfo, rthdr_ti.type, &ei_ipv6_routing_deprecated);",
          "1228:         break;",
          "1229:     case IPv6_RT_HEADER_MobileIP:",
          "1230:         dissect_routing6_mipv6(tvb, offset, pinfo, rthdr_tree, &rthdr_ti, rt);",
          "1231:         break;",
          "1232:     case IPv6_RT_HEADER_RPL:",
          "1233:         dissect_routing6_rpl(tvb, offset, pinfo, rthdr_tree, &rthdr_ti, rt);",
          "1234:         break;",
          "1235:     case IPv6_RT_HEADER_SEGMENT_ROUTING:",
          "1236:         dissect_routing6_srh(tvb, offset, pinfo, rthdr_tree, &rthdr_ti, rt);",
          "1237:         break;",
          "1238:     default:",
          "1239:         dissect_routing6_unknown(tvb, offset, pinfo, rthdr_tree, &rthdr_ti, rt);",
          "1240:         break;",
          "1243:     p_add_ipv6_nxt(pinfo, rt.ip6r_nxt);",
          "1245:     next_tvb = tvb_new_subset_remaining(tvb, len);",
          "1246:     ipv6_dissect_next(rt.ip6r_nxt, next_tvb, pinfo, tree, (ws_ip6 *)data);",
          "",
          "[Added Lines]",
          "1168:         if (idx == rt->hdr.ip6r_segleft - 1) {",
          "1173:     return tvb_captured_length(tvb);",
          "1178:     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
          "1179:     |  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |",
          "1180:     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
          "1181:     |                                                               |",
          "1182:     .                                                               .",
          "1183:     .                       type-specific data                      .",
          "1184:     .                                                               .",
          "1185:     |                                                               |",
          "1186:     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
          "1189: dissect_routing6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *_tree, void *data) {",
          "1190:     struct ws_rthdr    rt;",
          "1191:     guint              nxt, hdr_len, total_len;",
          "1192:     proto_tree        *rt_tree, *tree;",
          "1193:     proto_item        *pi, *ti, *ti_hdr_len, *ti_type, *ti_segs;",
          "1196:     int                type, type_len;",
          "1197:     dissector_handle_t type_dissector;",
          "1201:     tree = p_ipv6_pinfo_select_root(pinfo, _tree);",
          "1203:     pi = proto_tree_add_item(tree, proto_ipv6_routing, tvb, offset, -1, ENC_NA);",
          "1204:     rt_tree = proto_item_add_subtree(pi, ett_ipv6_routing_proto);",
          "1206:     proto_tree_add_item(rt_tree, hf_ipv6_routing_nxt, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1207:     nxt = tvb_get_guint8(tvb, offset);",
          "1210:     ti_hdr_len = proto_tree_add_item(rt_tree, hf_ipv6_routing_len, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1211:     hdr_len = tvb_get_guint8(tvb, offset);",
          "1213:           Hdr Ext Len         8-bit unsigned integer.  Length of the Routing",
          "1214:                               header in 8-octet units, not including the",
          "1215:                               first 8 octets.",
          "1217:     total_len = (hdr_len + 1) * 8;",
          "1218:     type_len = total_len - 4;",
          "1220:     proto_item_set_len(pi, total_len);",
          "1221:     ti = proto_tree_add_uint(rt_tree, hf_ipv6_routing_len_oct, tvb, offset, 1, total_len);",
          "1225:         proto_item_append_text(ti_hdr_len, \" (%d bytes)\", total_len);",
          "1227:     p_ipv6_pinfo_add_len(pinfo, total_len);",
          "1230:     ti_type = proto_tree_add_item(rt_tree, hf_ipv6_routing_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1231:     type = tvb_get_guint8(tvb, offset);",
          "1232:     proto_item_append_text(pi, \" (%s)\", val_to_str(type, routing_header_type, \"Unknown type %u\"));",
          "1235:     ti_segs = proto_tree_add_item(rt_tree, hf_ipv6_routing_segleft, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1238:     type_dissector = dissector_get_uint_handle(ipv6_routing_dissector_table, type);",
          "1239:     if (type_dissector != NULL) {",
          "1240:         tvb_memcpy(tvb, &(rt.hdr), 0, 4);",
          "1241:         rt.ti_len = ti_hdr_len;",
          "1242:         rt.ti_type = ti_type;",
          "1243:         rt.ti_segleft = ti_segs;",
          "1244:         call_dissector_with_data(type_dissector, tvb_new_subset_length(tvb, offset, type_len), pinfo, rt_tree, &rt);",
          "1245:     }",
          "1246:     else {",
          "1248:         ti = proto_tree_add_item(rt_tree, hf_ipv6_routing_unknown_data, tvb, offset, type_len, ENC_NA);",
          "1249:         expert_add_info(pinfo, ti, &ei_ipv6_routing_undecoded);",
          "1252:     p_add_ipv6_nxt(pinfo, nxt);",
          "1254:     next_tvb = tvb_new_subset_remaining(tvb, total_len);",
          "1255:     ipv6_dissect_next(nxt, next_tvb, pinfo, tree, (ws_ip6 *)data);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3530:     expert_ipv6_routing = expert_register_protocol(proto_ipv6_routing);",
          "3531:     expert_register_field_array(expert_ipv6_routing, ei_ipv6_routing, array_length(ei_ipv6_routing));",
          "3533:     proto_ipv6_fraghdr = proto_register_protocol(\"Fragment Header for IPv6\", \"IPv6 Fragment\", \"ipv6.fraghdr\");",
          "3534:     proto_register_field_array(proto_ipv6_fraghdr, hf_ipv6_fraghdr, array_length(hf_ipv6_fraghdr));",
          "3535:     proto_register_subtree_array(ett_ipv6_fraghdr, array_length(ett_ipv6_fraghdr));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3542:     ipv6_routing_dissector_table = register_dissector_table(\"ipv6.routing.type\", \"IPv6 Routing Type\",",
          "3543:                                                 proto_ipv6_routing, FT_UINT8, BASE_DEC);",
          "3545:     proto_ipv6_routing_rt0 = proto_register_protocol_in_name_only(\"IPv6 Routing Type - Source Route\", \"Source Route\", \"ipv6.routing.type.rt0\", proto_ipv6, FT_BYTES);",
          "3546:     proto_ipv6_routing_mipv6 = proto_register_protocol_in_name_only(\"IPv6 Routing Type - Type 2\", \"Type 2\", \"ipv6.routing.type.mipv6\", proto_ipv6, FT_BYTES);",
          "3547:     proto_ipv6_routing_rpl = proto_register_protocol_in_name_only(\"IPv6 Routing Type - RPL Source Route\", \"RPL Source Route\", \"ipv6.routing.type.mipv6\", proto_ipv6, FT_BYTES);",
          "3548:     proto_ipv6_routing_srh = proto_register_protocol_in_name_only(\"IPv6 Routing Types - Segment Routing\", \"Segment Routing\", \"ipv6.routing.type.srh\", proto_ipv6, FT_BYTES);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3602:     dissector_handle_t ipv6_dstopts_handle;",
          "3603:     capture_dissector_handle_t ipv6_cap_handle;",
          "3604:     capture_dissector_handle_t ipv6_ext_cap_handle;",
          "3606:     dissector_add_uint(\"ethertype\", ETHERTYPE_IPv6, ipv6_handle);",
          "3607:     dissector_add_uint(\"erf.types.type\", ERF_TYPE_IPV6, ipv6_handle);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3622:     dissector_handle_t h;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3658:     capture_dissector_add_uint(\"ip.proto\", IP_PROTO_FRAGMENT, ipv6_ext_cap_handle);",
          "3659:     ipv6_ext_cap_handle = create_capture_dissector_handle(capture_ipv6_exthdr, proto_ipv6_dstopts);",
          "3660:     capture_dissector_add_uint(\"ip.proto\", IP_PROTO_DSTOPTS, ipv6_ext_cap_handle);",
          "3661: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3680:     h = create_dissector_handle(dissect_routing6_rt0, proto_ipv6_routing_rt0);",
          "3681:     dissector_add_uint(\"ipv6.routing.type\", IPv6_RT_HEADER_SOURCE_ROUTING, h);",
          "3682:     h = create_dissector_handle(dissect_routing6_mipv6, proto_ipv6_routing_mipv6);",
          "3683:     dissector_add_uint(\"ipv6.routing.type\", IPv6_RT_HEADER_MOBILE_IP, h);",
          "3684:     h = create_dissector_handle(dissect_routing6_rpl, proto_ipv6_routing_rpl);",
          "3685:     dissector_add_uint(\"ipv6.routing.type\", IPv6_RT_HEADER_RPL, h);",
          "3686:     h = create_dissector_handle(dissect_routing6_srh, proto_ipv6_routing_srh);",
          "3687:     dissector_add_uint(\"ipv6.routing.type\", IPv6_RT_HEADER_SEGMENT_ROUTING, h);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2012-2375",
  "cve_desc": "The __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the NFSv4 implementation in the Linux kernel before 3.3.2 uses an incorrect length variable during a copy operation, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words in an FATTR4_ACL reply.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-4131.",
  "repo": "torvalds/linux",
  "patch_hash": "20e0fa98b751facf9a1101edaefbc19c82616a68",
  "patch_info": {
    "commit_hash": "20e0fa98b751facf9a1101edaefbc19c82616a68",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
    "files": [
      "fs/nfs/nfs4proc.c"
    ],
    "message": "Fix length of buffer copied in __nfs4_get_acl_uncached\n\n_copy_from_pages() used to copy data from the temporary buffer to the\nuser passed buffer is passed the wrong size parameter when copying\ndata. res.acl_len contains both the bitmap and acl lenghts while\nacl_len contains the acl length after adjusting for the bitmap size.\n\nSigned-off-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
    "before_after_code_files": [
      "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
    ]
  },
  "patch_diff": {
    "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
      "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3712:   if (acl_len > buflen)",
      "3713:    goto out_free;",
      "3714:   _copy_from_pages(buf, pages, res.acl_data_offset,",
      "3716:  }",
      "3717:  ret = acl_len;",
      "3718: out_free:",
      "",
      "[Removed Lines]",
      "3715:     res.acl_len);",
      "",
      "[Added Lines]",
      "3715:     acl_len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1f1ea6c2d9d8c0be9ec56454b05315273b5de8ce",
      "candidate_info": {
        "commit_hash": "1f1ea6c2d9d8c0be9ec56454b05315273b5de8ce",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1f1ea6c2d9d8c0be9ec56454b05315273b5de8ce",
        "files": [
          "fs/nfs/nfs4proc.c",
          "fs/nfs/nfs4xdr.c",
          "include/linux/nfs_xdr.h"
        ],
        "message": "NFSv4: Fix buffer overflow checking in __nfs4_get_acl_uncached\n\nPass the checks made by decode_getacl back to __nfs4_get_acl_uncached\nso that it knows if the acl has been truncated.\n\nThe current overflow checking is broken, resulting in Oopses on\nuser-triggered nfs4_getfacl calls, and is opaque to the point\nwhere several attempts at fixing it have failed.\nThis patch tries to clean up the code in addition to fixing the\nOopses by ensuring that the overflow checks are performed in\na single place (decode_getacl). If the overflow check failed,\nwe will still be able to report the acl length, but at least\nwe will no longer attempt to cache the acl or copy the\ntruncated contents to user space.\n\nReported-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nTested-by: Sachin Prabhu <sprabhu@redhat.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c",
          "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c",
          "include/linux/nfs_xdr.h||include/linux/nfs_xdr.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ],
          "candidate": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3739:  struct nfs4_cached_acl *acl;",
          "3740:  size_t buflen = sizeof(*acl) + acl_len;",
          "3743:   acl = kmalloc(buflen, GFP_KERNEL);",
          "3744:   if (acl == NULL)",
          "3745:    goto out;",
          "",
          "[Removed Lines]",
          "3742:  if (pages && buflen <= PAGE_SIZE) {",
          "",
          "[Added Lines]",
          "3742:  if (buflen <= PAGE_SIZE) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3784:  };",
          "3785:  unsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);",
          "3786:  int ret = -ENOMEM, i;",
          "",
          "[Removed Lines]",
          "3787:  size_t acl_len = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3807:  args.acl_len = npages * PAGE_SIZE;",
          "3808:  args.acl_pgbase = 0;",
          "3815:  dprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",",
          "3816:   __func__, buf, buflen, npages, args.acl_len);",
          "3817:  ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),",
          "",
          "[Removed Lines]",
          "3812:  if (buf == NULL)",
          "3813:   res.acl_flags |= NFS4_ACL_LEN_REQUEST;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3819:  if (ret)",
          "3820:   goto out_free;",
          "3829:   ret = -ERANGE;",
          "3834:  }",
          "3836: out_free:",
          "3837:  for (i = 0; i < npages; i++)",
          "3838:   if (pages[i])",
          "",
          "[Removed Lines]",
          "3822:  acl_len = res.acl_len;",
          "3823:  if (acl_len > args.acl_len)",
          "3824:   nfs4_write_cached_acl(inode, NULL, 0, acl_len);",
          "3825:  else",
          "3826:   nfs4_write_cached_acl(inode, pages, res.acl_data_offset,",
          "3827:           acl_len);",
          "3828:  if (buf) {",
          "3830:   if (acl_len > buflen)",
          "3831:    goto out_free;",
          "3832:   _copy_from_pages(buf, pages, res.acl_data_offset,",
          "3833:     acl_len);",
          "3835:  ret = acl_len;",
          "",
          "[Added Lines]",
          "3817:  if (res.acl_flags & NFS4_ACL_TRUNC) {",
          "3819:   if (buf == NULL)",
          "3820:    goto out_ok;",
          "3822:   goto out_free;",
          "3824:  nfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);",
          "3825:  if (buf)",
          "3826:   _copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);",
          "3827: out_ok:",
          "3828:  ret = res.acl_len;",
          "",
          "---------------"
        ],
        "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c": [
          "File: fs/nfs/nfs4xdr.c -> fs/nfs/nfs4xdr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5074:   res->acl_data_offset = xdr_stream_pos(xdr) - pg_offset;",
          "5078:   res->acl_len = attrlen;",
          "5084:    dprintk(\"NFS: acl reply: attrlen %u > page_len %u\\n\",",
          "5085:      attrlen, xdr->nwords << 2);",
          "5087:   }",
          "5088:  } else",
          "5089:   status = -EOPNOTSUPP;",
          "",
          "[Removed Lines]",
          "5079:   if (attrlen > (xdr->nwords << 2)) {",
          "5080:    if (res->acl_flags & NFS4_ACL_LEN_REQUEST) {",
          "5082:     goto out;",
          "5083:    }",
          "5086:    return -EINVAL;",
          "",
          "[Added Lines]",
          "5078:   if (res->acl_len > (xdr->nwords << 2) ||",
          "5079:       res->acl_len + res->acl_data_offset > xdr->buf->page_len) {",
          "5080:    res->acl_flags |= NFS4_ACL_TRUNC;",
          "",
          "---------------"
        ],
        "include/linux/nfs_xdr.h||include/linux/nfs_xdr.h": [
          "File: include/linux/nfs_xdr.h -> include/linux/nfs_xdr.h"
        ]
      }
    },
    {
      "candidate_hash": "bf118a342f10dafe44b14451a1392c3254629a1f",
      "candidate_info": {
        "commit_hash": "bf118a342f10dafe44b14451a1392c3254629a1f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "files": [
          "fs/nfs/nfs4proc.c",
          "fs/nfs/nfs4xdr.c",
          "include/linux/nfs_xdr.h",
          "include/linux/sunrpc/xdr.h",
          "net/sunrpc/xdr.c"
        ],
        "message": "NFSv4: include bitmap in nfsv4 get acl data\n\nThe NFSv4 bitmap size is unbounded: a server can return an arbitrary\nsized bitmap in an FATTR4_WORD0_ACL request.  Replace using the\nnfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server\nwith the inclusion of the bitmap (xdr length plus bitmasks) and the acl data\nxdr length to the (cached) acl page data.\n\nThis is a general solution to commit e5012d1f \"NFSv4.1: update\nnfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead\nwhen getting ACLs.\n\nFix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr\nwas called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.\n\nCc: stable@kernel.org\nSigned-off-by: Andy Adamson <andros@netapp.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c",
          "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c",
          "include/linux/nfs_xdr.h||include/linux/nfs_xdr.h",
          "include/linux/sunrpc/xdr.h||include/linux/sunrpc/xdr.h",
          "net/sunrpc/xdr.c||net/sunrpc/xdr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ],
          "candidate": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3427: #define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)",
          "3442: static int buf_to_pages_noslab(const void *buf, size_t buflen,",
          "3443:   struct page **pages, unsigned int *pgbase)",
          "3444: {",
          "",
          "[Removed Lines]",
          "3429: static void buf_to_pages(const void *buf, size_t buflen,",
          "3430:   struct page **pages, unsigned int *pgbase)",
          "3431: {",
          "3432:  const void *p = buf;",
          "3435:  p -= *pgbase;",
          "3436:  while (p < buf + buflen) {",
          "3438:   p += PAGE_CACHE_SIZE;",
          "3439:  }",
          "3440: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3535:  nfs4_set_cached_acl(inode, acl);",
          "3536: }",
          "3538: static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)",
          "3539: {",
          "3541:  struct nfs_getaclargs args = {",
          "3542:   .fh = NFS_FH(inode),",
          "3543:   .acl_pages = pages,",
          "",
          "[Removed Lines]",
          "3540:  struct page *pages[NFS4ACL_MAXPAGES];",
          "",
          "[Added Lines]",
          "3537:  struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3552:   .rpc_argp = &args,",
          "3553:   .rpc_resp = &res,",
          "3554:  };",
          "3571:  }",
          "3573:  if (ret)",
          "3574:   goto out_free;",
          "3577:  else",
          "3579:  if (buf) {",
          "3580:   ret = -ERANGE;",
          "3582:    goto out_free;",
          "3585:  }",
          "3587: out_free:",
          "3590:  return ret;",
          "3591: }",
          "",
          "[Removed Lines]",
          "3555:  struct page *localpage = NULL;",
          "3556:  int ret;",
          "3558:  if (buflen < PAGE_SIZE) {",
          "3561:   localpage = alloc_page(GFP_KERNEL);",
          "3562:   resp_buf = page_address(localpage);",
          "3563:   if (localpage == NULL)",
          "3564:    return -ENOMEM;",
          "3565:   args.acl_pages[0] = localpage;",
          "3566:   args.acl_pgbase = 0;",
          "3567:   args.acl_len = PAGE_SIZE;",
          "3568:  } else {",
          "3569:   resp_buf = buf;",
          "3570:   buf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);",
          "3572:  ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);",
          "3575:  if (res.acl_len > args.acl_len)",
          "3576:   nfs4_write_cached_acl(inode, NULL, res.acl_len);",
          "3578:   nfs4_write_cached_acl(inode, resp_buf, res.acl_len);",
          "3581:   if (res.acl_len > buflen)",
          "3583:   if (localpage)",
          "3584:    memcpy(buf, resp_buf, res.acl_len);",
          "3586:  ret = res.acl_len;",
          "3588:  if (localpage)",
          "3589:   __free_page(localpage);",
          "",
          "[Added Lines]",
          "3552:  int ret = -ENOMEM, npages, i, acl_len = 0;",
          "3554:  npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;",
          "3557:  if (npages == 0)",
          "3558:   npages = 1;",
          "3560:  for (i = 0; i < npages; i++) {",
          "3561:   pages[i] = alloc_page(GFP_KERNEL);",
          "3562:   if (!pages[i])",
          "3563:    goto out_free;",
          "3564:  }",
          "3565:  if (npages > 1) {",
          "3567:   args.acl_scratch = alloc_page(GFP_KERNEL);",
          "3568:   if (!args.acl_scratch)",
          "3569:    goto out_free;",
          "3571:  args.acl_len = npages * PAGE_SIZE;",
          "3572:  args.acl_pgbase = 0;",
          "3575:  if (buf == NULL)",
          "3576:   res.acl_flags |= NFS4_ACL_LEN_REQUEST;",
          "3577:  resp_buf = page_address(pages[0]);",
          "3579:  dprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",",
          "3580:   __func__, buf, buflen, npages, args.acl_len);",
          "3581:  ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),",
          "3582:         &msg, &args.seq_args, &res.seq_res, 0);",
          "3586:  acl_len = res.acl_len - res.acl_data_offset;",
          "3587:  if (acl_len > args.acl_len)",
          "3588:   nfs4_write_cached_acl(inode, NULL, acl_len);",
          "3590:   nfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,",
          "3591:           acl_len);",
          "3594:   if (acl_len > buflen)",
          "3596:   _copy_from_pages(buf, pages, res.acl_data_offset,",
          "3597:     res.acl_len);",
          "3599:  ret = acl_len;",
          "3601:  for (i = 0; i < npages; i++)",
          "3602:   if (pages[i])",
          "3603:    __free_page(pages[i]);",
          "3604:  if (args.acl_scratch)",
          "3605:   __free_page(args.acl_scratch);",
          "",
          "---------------"
        ],
        "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c": [
          "File: fs/nfs/nfs4xdr.c -> fs/nfs/nfs4xdr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2517:  encode_compound_hdr(xdr, req, &hdr);",
          "2518:  encode_sequence(xdr, &args->seq_args, &hdr);",
          "2519:  encode_putfh(xdr, args->fh, &hdr);",
          "2521:  encode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);",
          "2523:  xdr_inline_pages(&req->rq_rcv_buf, replen << 2,",
          "2524:   args->acl_pages, args->acl_pgbase, args->acl_len);",
          "2525:  encode_nops(&hdr);",
          "2526: }",
          "",
          "[Removed Lines]",
          "2520:  replen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;",
          "",
          "[Added Lines]",
          "2520:  replen = hdr.replen + op_decode_hdr_maxsz + 1;",
          "2525:  xdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4957: }",
          "4959: static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,",
          "4961: {",
          "4963:  uint32_t attrlen,",
          "4964:    bitmap[3] = {0};",
          "4965:  struct kvec *iov = req->rq_rcv_buf.head;",
          "4966:  int status;",
          "4969:  if ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)",
          "4970:   goto out;",
          "4971:  if ((status = decode_attr_bitmap(xdr, bitmap)) != 0)",
          "4972:   goto out;",
          "4973:  if ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)",
          "",
          "[Removed Lines]",
          "4960:   size_t *acl_len)",
          "4962:  __be32 *savep;",
          "",
          "[Added Lines]",
          "4962:     struct nfs_getaclres *res)",
          "4964:  __be32 *savep, *bm_p;",
          "4970:  res->acl_len = 0;",
          "4973:  bm_p = xdr->p;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4979:   size_t hdrlen;",
          "4980:   u32 recvd;",
          "4984:   hdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;",
          "4985:   recvd = req->rq_rcv_buf.len - hdrlen;",
          "4986:   if (attrlen > recvd) {",
          "4989:      attrlen, recvd);",
          "4990:    return -EINVAL;",
          "4991:   }",
          "4992:   xdr_read_pages(xdr, attrlen);",
          "4994:  } else",
          "4995:   status = -EOPNOTSUPP;",
          "",
          "[Removed Lines]",
          "4987:    dprintk(\"NFS: server cheating in getattr\"",
          "4988:      \" acl reply: attrlen %u > recvd %u\\n\",",
          "",
          "[Added Lines]",
          "4988:   xdr->p = bm_p;",
          "4989:   res->acl_data_offset = be32_to_cpup(bm_p) + 2;",
          "4990:   res->acl_data_offset <<= 2;",
          "4995:   attrlen += res->acl_data_offset;",
          "4998:    if (res->acl_flags & NFS4_ACL_LEN_REQUEST) {",
          "5000:     res->acl_len = attrlen;",
          "5001:     goto out;",
          "5002:    }",
          "5003:    dprintk(\"NFS: acl reply: attrlen %u > recvd %u\\n\",",
          "5008:   res->acl_len = attrlen;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6028:  status = decode_putfh(xdr);",
          "6029:  if (status)",
          "6030:   goto out;",
          "6033: out:",
          "6034:  return status;",
          "",
          "[Removed Lines]",
          "6031:  status = decode_getacl(xdr, rqstp, &res->acl_len);",
          "",
          "[Added Lines]",
          "6046:  status = decode_getacl(xdr, rqstp, res);",
          "",
          "---------------"
        ],
        "include/linux/nfs_xdr.h||include/linux/nfs_xdr.h": [
          "File: include/linux/nfs_xdr.h -> include/linux/nfs_xdr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "602:  size_t    acl_len;",
          "603:  unsigned int   acl_pgbase;",
          "604:  struct page **   acl_pages;",
          "605:  struct nfs4_sequence_args  seq_args;",
          "606: };",
          "608: struct nfs_getaclres {",
          "609:  size_t    acl_len;",
          "610:  struct nfs4_sequence_res seq_res;",
          "611: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "605:  struct page *   acl_scratch;",
          "613:  size_t    acl_data_offset;",
          "614:  int    acl_flags;",
          "",
          "---------------"
        ],
        "include/linux/sunrpc/xdr.h||include/linux/sunrpc/xdr.h": [
          "File: include/linux/sunrpc/xdr.h -> include/linux/sunrpc/xdr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:         struct xdr_array2_desc *desc);",
          "192: extern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,",
          "193:         struct xdr_array2_desc *desc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194: extern void _copy_from_pages(char *p, struct page **pages, size_t pgbase,",
          "195:         size_t len);",
          "",
          "---------------"
        ],
        "net/sunrpc/xdr.c||net/sunrpc/xdr.c": [
          "File: net/sunrpc/xdr.c -> net/sunrpc/xdr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "300: _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)",
          "301: {",
          "302:  struct page **pgfrom;",
          "",
          "[Removed Lines]",
          "299: static void",
          "",
          "[Added Lines]",
          "299: void",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "325:  } while ((len -= copy) != 0);",
          "326: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "327: EXPORT_SYMBOL_GPL(_copy_from_pages);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19924",
  "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
  "repo": "sqlite/sqlite",
  "patch_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
  "patch_info": {
    "commit_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/vdbeaux.c",
      "src/window.c"
    ],
    "message": "When an error occurs while rewriting the parser tree for window functions in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/vdbeaux.c||src/vdbeaux.c",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "376:   int addr;",
      "377:   CollSeq *p4;",
      "379:   if( isCommuted ){",
      "380:     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);",
      "381:   }else{",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:   if( pParse->nErr ) return 0;",
      "",
      "---------------"
    ],
    "src/vdbeaux.c||src/vdbeaux.c": [
      "File: src/vdbeaux.c -> src/vdbeaux.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1304: static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){",
      "1305:   assert( p->nOp>0 || p->aOp==0 );",
      "1307:   if( p->nOp ){",
      "1308:     assert( p->aOp );",
      "1309:     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
      "",
      "[Removed Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );",
      "",
      "[Added Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
      "1307:           || p->pParse->nErr>0 );",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "935:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
      "936:     if( pTab==0 ){",
      "938:     }",
      "940:     p->pSrc = 0;",
      "",
      "[Removed Lines]",
      "937:       return SQLITE_NOMEM;",
      "",
      "[Added Lines]",
      "937:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1039:     sqlite3DbFree(db, pTab);",
      "1040:   }",
      "1042:   return rc;",
      "1043: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1042:   if( rc && pParse->nErr==0 ){",
      "1043:     assert( pParse->db->mallocFailed );",
      "1044:     return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
      "1045:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4bec44bdfa1fea3374a8e262b6a8da6fc79f08b8",
      "candidate_info": {
        "commit_hash": "4bec44bdfa1fea3374a8e262b6a8da6fc79f08b8",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4bec44bdfa1fea3374a8e262b6a8da6fc79f08b8",
        "files": [
          "ext/misc/fossildelta.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Add the fossildelta.c extension in ext/misc with implementations of the Fossil delta functions.\n\nFossilOrigin-Name: b80cafa6f8a5c6ff1dc9efd2f670777ab131ace2df1eb431cedc8cfa901baf18",
        "before_after_code_files": [
          "ext/misc/fossildelta.c||ext/misc/fossildelta.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/fossildelta.c||ext/misc/fossildelta.c": [
          "File: ext/misc/fossildelta.c -> ext/misc/fossildelta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #include <string.h>",
          "16: #include <assert.h>",
          "17: #include <stdlib.h>",
          "18: #include \"sqlite3ext.h\"",
          "19: SQLITE_EXTENSION_INIT1",
          "24: typedef unsigned int u32;",
          "29: typedef short int s16;",
          "30: typedef unsigned short int u16;",
          "37: #define NHASH 16",
          "51: typedef struct hash hash;",
          "52: struct hash {",
          "56: };",
          "61: static void hash_init(hash *pHash, const char *z){",
          "62:   u16 a, b, i;",
          "63:   a = b = z[0];",
          "64:   for(i=1; i<NHASH; i++){",
          "65:     a += z[i];",
          "66:     b += a;",
          "67:   }",
          "68:   memcpy(pHash->z, z, NHASH);",
          "69:   pHash->a = a & 0xffff;",
          "70:   pHash->b = b & 0xffff;",
          "71:   pHash->i = 0;",
          "72: }",
          "77: static void hash_next(hash *pHash, int c){",
          "78:   u16 old = pHash->z[pHash->i];",
          "79:   pHash->z[pHash->i] = c;",
          "80:   pHash->i = (pHash->i+1)&(NHASH-1);",
          "81:   pHash->a = pHash->a - old + c;",
          "82:   pHash->b = pHash->b - NHASH*old + pHash->a;",
          "83: }",
          "88: static u32 hash_32bit(hash *pHash){",
          "89:   return (pHash->a & 0xffff) | (((u32)(pHash->b & 0xffff))<<16);",
          "90: }",
          "100: static u32 hash_once(const char *z){",
          "101:   u16 a, b, i;",
          "102:   a = b = z[0];",
          "103:   for(i=1; i<NHASH; i++){",
          "104:     a += z[i];",
          "105:     b += a;",
          "106:   }",
          "107:   return a | (((u32)b)<<16);",
          "108: }",
          "113: static void putInt(unsigned int v, char **pz){",
          "114:   static const char zDigits[] =",
          "115:     \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\";",
          "117:   int i, j;",
          "118:   char zBuf[20];",
          "119:   if( v==0 ){",
          "121:     return;",
          "122:   }",
          "123:   for(i=0; v>0; i++, v>>=6){",
          "124:     zBuf[i] = zDigits[v&0x3f];",
          "125:   }",
          "126:   for(j=i-1; j>=0; j--){",
          "128:   }",
          "129: }",
          "137: static unsigned int getInt(const char **pz, int *pLen){",
          "138:   static const signed char zValue[] = {",
          "139:     -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,",
          "140:     -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,",
          "141:     -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,",
          "142:      0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,",
          "143:     -1, 10, 11, 12, 13, 14, 15, 16,   17, 18, 19, 20, 21, 22, 23, 24,",
          "144:     25, 26, 27, 28, 29, 30, 31, 32,   33, 34, 35, -1, -1, -1, -1, 36,",
          "145:     -1, 37, 38, 39, 40, 41, 42, 43,   44, 45, 46, 47, 48, 49, 50, 51,",
          "146:     52, 53, 54, 55, 56, 57, 58, 59,   60, 61, 62, -1, -1, -1, 63, -1,",
          "147:   };",
          "148:   unsigned int v = 0;",
          "149:   int c;",
          "150:   unsigned char *z = (unsigned char*)*pz;",
          "151:   unsigned char *zStart = z;",
          "152:   while( (c = zValue[0x7f&*(z++)])>=0 ){",
          "153:      v = (v<<6) + c;",
          "154:   }",
          "155:   z--;",
          "158:   return v;",
          "159: }",
          "164: static int digit_count(int v){",
          "165:   unsigned int i, x;",
          "166:   for(i=1, x=64; v>=x; i++, x <<= 6){}",
          "167:   return i;",
          "168: }",
          "170: #ifdef __GNUC__",
          "171: # define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)",
          "172: #else",
          "173: # define GCC_VERSION 0",
          "174: #endif",
          "182: static unsigned int checksum(const char *zIn, size_t N){",
          "183:   static const int byteOrderTest = 1;",
          "184:   const unsigned char *z = (const unsigned char *)zIn;",
          "185:   const unsigned char *zEnd = (const unsigned char*)&zIn[N&~3];",
          "186:   unsigned sum = 0;",
          "188:   if( 0==*(char*)&byteOrderTest ){",
          "190:     while( z<zEnd ){",
          "191:       sum += *(unsigned*)z;",
          "192:       z += 4;",
          "193:     }",
          "194:   }else{",
          "196: #if GCC_VERSION>=4003000",
          "197:     while( z<zEnd ){",
          "198:       sum += __builtin_bswap32(*(unsigned*)z);",
          "199:       z += 4;",
          "200:     }",
          "201: #elif defined(_MSC_VER) && _MSC_VER>=1300",
          "202:     while( z<zEnd ){",
          "203:       sum += _byteswap_ulong(*(unsigned*)z);",
          "204:       z += 4;",
          "205:     }",
          "206: #else",
          "207:     unsigned sum0 = 0;",
          "208:     unsigned sum1 = 0;",
          "209:     unsigned sum2 = 0;",
          "210:     while(N >= 16){",
          "211:       sum0 += ((unsigned)z[0] + z[4] + z[8] + z[12]);",
          "212:       sum1 += ((unsigned)z[1] + z[5] + z[9] + z[13]);",
          "213:       sum2 += ((unsigned)z[2] + z[6] + z[10]+ z[14]);",
          "214:       sum  += ((unsigned)z[3] + z[7] + z[11]+ z[15]);",
          "215:       z += 16;",
          "216:       N -= 16;",
          "217:     }",
          "218:     while(N >= 4){",
          "219:       sum0 += z[0];",
          "220:       sum1 += z[1];",
          "221:       sum2 += z[2];",
          "222:       sum  += z[3];",
          "223:       z += 4;",
          "224:       N -= 4;",
          "225:     }",
          "226:     sum += (sum2 << 8) + (sum1 << 16) + (sum0 << 24);",
          "227: #endif",
          "228:   }",
          "229:   switch(N&3){",
          "230:     case 3:   sum += (z[2] << 8);",
          "231:     case 2:   sum += (z[1] << 16);",
          "232:     case 1:   sum += (z[0] << 24);",
          "233:     default:  ;",
          "234:   }",
          "235:   return sum;",
          "236: }",
          "299: static int delta_create(",
          "305: ){",
          "306:   int i, base;",
          "307:   char *zOrigDelta = zDelta;",
          "308:   hash h;",
          "316:   putInt(lenOut, &zDelta);",
          "323:   if( lenSrc<=NHASH ){",
          "324:     putInt(lenOut, &zDelta);",
          "326:     memcpy(zDelta, zOut, lenOut);",
          "327:     zDelta += lenOut;",
          "328:     putInt(checksum(zOut, lenOut), &zDelta);",
          "330:     return zDelta - zOrigDelta;",
          "331:   }",
          "336:   nHash = lenSrc/NHASH;",
          "337:   collide = sqlite3_malloc64( (sqlite3_int64)nHash*2*sizeof(int) );",
          "338:   memset(collide, -1, nHash*2*sizeof(int));",
          "339:   landmark = &collide[nHash];",
          "340:   for(i=0; i<lenSrc-NHASH; i+=NHASH){",
          "341:     int hv = hash_once(&zSrc[i]) % nHash;",
          "342:     collide[i/NHASH] = landmark[hv];",
          "343:     landmark[hv] = i/NHASH;",
          "344:   }",
          "350:   while( base+NHASH<lenOut ){",
          "351:     int iSrc, iBlock;",
          "352:     unsigned int bestCnt, bestOfst=0, bestLitsz=0;",
          "353:     hash_init(&h, &zOut[base]);",
          "355:     bestCnt = 0;",
          "356:     while( 1 ){",
          "357:       int hv;",
          "358:       int limit = 250;",
          "360:       hv = hash_32bit(&h) % nHash;",
          "361:       iBlock = landmark[hv];",
          "362:       while( iBlock>=0 && (limit--)>0 ){",
          "378:         int cnt, ofst, litsz;",
          "379:         int j, k, x, y;",
          "380:         int sz;",
          "381:         int limitX;",
          "385:         iSrc = iBlock*NHASH;",
          "386:         y = base+i;",
          "387:         limitX = ( lenSrc-iSrc <= lenOut-y ) ? lenSrc : iSrc + lenOut - y;",
          "388:         for(x=iSrc; x<limitX; x++, y++){",
          "389:           if( zSrc[x]!=zOut[y] ) break;",
          "390:         }",
          "391:         j = x - iSrc - 1;",
          "395:         for(k=1; k<iSrc && k<=i; k++){",
          "396:           if( zSrc[iSrc-k]!=zOut[base+i-k] ) break;",
          "397:         }",
          "398:         k--;",
          "401:         ofst = iSrc-k;",
          "402:         cnt = j+k+1;",
          "406:         sz = digit_count(i-k)+digit_count(cnt)+digit_count(ofst)+3;",
          "407:         if( cnt>=sz && cnt>bestCnt ){",
          "410:           bestCnt = cnt;",
          "411:           bestOfst = iSrc-k;",
          "412:           bestLitsz = litsz;",
          "413:         }",
          "416:         iBlock = collide[iBlock];",
          "417:       }",
          "422:       if( bestCnt>0 ){",
          "423:         if( bestLitsz>0 ){",
          "425:           putInt(bestLitsz,&zDelta);",
          "427:           memcpy(zDelta, &zOut[base], bestLitsz);",
          "428:           zDelta += bestLitsz;",
          "429:           base += bestLitsz;",
          "430:         }",
          "431:         base += bestCnt;",
          "432:         putInt(bestCnt, &zDelta);",
          "434:         putInt(bestOfst, &zDelta);",
          "436:         if( bestOfst + bestCnt -1 > lastRead ){",
          "437:           lastRead = bestOfst + bestCnt - 1;",
          "438:         }",
          "439:         bestCnt = 0;",
          "440:         break;",
          "441:       }",
          "444:       if( base+i+NHASH>=lenOut ){",
          "447:         putInt(lenOut-base, &zDelta);",
          "449:         memcpy(zDelta, &zOut[base], lenOut-base);",
          "450:         zDelta += lenOut-base;",
          "451:         base = lenOut;",
          "452:         break;",
          "453:       }",
          "456:       hash_next(&h, zOut[base+i+NHASH]);",
          "457:       i++;",
          "458:     }",
          "459:   }",
          "463:   if( base<lenOut ){",
          "464:     putInt(lenOut-base, &zDelta);",
          "466:     memcpy(zDelta, &zOut[base], lenOut-base);",
          "467:     zDelta += lenOut-base;",
          "468:   }",
          "470:   putInt(checksum(zOut, lenOut), &zDelta);",
          "472:   sqlite3_free(collide);",
          "473:   return zDelta - zOrigDelta;",
          "474: }",
          "485: static int delta_output_size(const char *zDelta, int lenDelta){",
          "486:   int size;",
          "487:   size = getInt(&zDelta, &lenDelta);",
          "488:   if( *zDelta!='\\n' ){",
          "490:     return -1;",
          "491:   }",
          "492:   return size;",
          "493: }",
          "516: static int delta_apply(",
          "522: ){",
          "523:   unsigned int limit;",
          "524:   unsigned int total = 0;",
          "525: #ifdef FOSSIL_ENABLE_DELTA_CKSUM_TEST",
          "526:   char *zOrigOut = zOut;",
          "527: #endif",
          "529:   limit = getInt(&zDelta, &lenDelta);",
          "530:   if( *zDelta!='\\n' ){",
          "532:     return -1;",
          "533:   }",
          "534:   zDelta++; lenDelta--;",
          "535:   while( *zDelta && lenDelta>0 ){",
          "536:     unsigned int cnt, ofst;",
          "537:     cnt = getInt(&zDelta, &lenDelta);",
          "538:     switch( zDelta[0] ){",
          "539:       case '@': {",
          "540:         zDelta++; lenDelta--;",
          "541:         ofst = getInt(&zDelta, &lenDelta);",
          "542:         if( lenDelta>0 && zDelta[0]!=',' ){",
          "544:           return -1;",
          "545:         }",
          "546:         zDelta++; lenDelta--;",
          "547:         total += cnt;",
          "548:         if( total>limit ){",
          "550:           return -1;",
          "551:         }",
          "552:         if( ofst+cnt > lenSrc ){",
          "554:           return -1;",
          "555:         }",
          "556:         memcpy(zOut, &zSrc[ofst], cnt);",
          "557:         zOut += cnt;",
          "558:         break;",
          "559:       }",
          "560:       case ':': {",
          "561:         zDelta++; lenDelta--;",
          "562:         total += cnt;",
          "563:         if( total>limit ){",
          "565:           return -1;",
          "566:         }",
          "567:         if( cnt>lenDelta ){",
          "569:           return -1;",
          "570:         }",
          "571:         memcpy(zOut, zDelta, cnt);",
          "572:         zOut += cnt;",
          "573:         zDelta += cnt;",
          "574:         lenDelta -= cnt;",
          "575:         break;",
          "576:       }",
          "577:       case ';': {",
          "578:         zDelta++; lenDelta--;",
          "579:         zOut[0] = 0;",
          "580: #ifdef FOSSIL_ENABLE_DELTA_CKSUM_TEST",
          "581:         if( cnt!=checksum(zOrigOut, total) ){",
          "583:           return -1;",
          "584:         }",
          "585: #endif",
          "586:         if( total!=limit ){",
          "588:           return -1;",
          "589:         }",
          "590:         return total;",
          "591:       }",
          "592:       default: {",
          "594:         return -1;",
          "595:       }",
          "596:     }",
          "597:   }",
          "599:   return -1;",
          "600: }",
          "607: static int delta_analyze(",
          "612: ){",
          "613:   unsigned int nInsert = 0;",
          "614:   unsigned int nCopy = 0;",
          "616:   (void)getInt(&zDelta, &lenDelta);",
          "617:   if( *zDelta!='\\n' ){",
          "619:     return -1;",
          "620:   }",
          "621:   zDelta++; lenDelta--;",
          "622:   while( *zDelta && lenDelta>0 ){",
          "623:     unsigned int cnt;",
          "624:     cnt = getInt(&zDelta, &lenDelta);",
          "625:     switch( zDelta[0] ){",
          "626:       case '@': {",
          "627:         zDelta++; lenDelta--;",
          "628:         (void)getInt(&zDelta, &lenDelta);",
          "629:         if( lenDelta>0 && zDelta[0]!=',' ){",
          "631:           return -1;",
          "632:         }",
          "633:         zDelta++; lenDelta--;",
          "634:         nCopy += cnt;",
          "635:         break;",
          "636:       }",
          "637:       case ':': {",
          "638:         zDelta++; lenDelta--;",
          "639:         nInsert += cnt;",
          "640:         if( cnt>lenDelta ){",
          "642:           return -1;",
          "643:         }",
          "644:         zDelta += cnt;",
          "645:         lenDelta -= cnt;",
          "646:         break;",
          "647:       }",
          "648:       case ';': {",
          "651:         return 0;",
          "652:       }",
          "653:       default: {",
          "655:         return -1;",
          "656:       }",
          "657:     }",
          "658:   }",
          "660:   return -1;",
          "661: }",
          "668: static void deltaCreateFunc(",
          "669:   sqlite3_context *context,",
          "670:   int argc,",
          "671:   sqlite3_value **argv",
          "672: ){",
          "677:   assert( argc==2 );",
          "678:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;",
          "679:   if( sqlite3_value_type(argv[1])==SQLITE_NULL ) return;",
          "680:   nOrig = sqlite3_value_bytes(argv[0]);",
          "681:   aOrig = (const char*)sqlite3_value_blob(argv[0]);",
          "682:   nNew = sqlite3_value_bytes(argv[1]);",
          "683:   aNew = (const char*)sqlite3_value_blob(argv[1]);",
          "684:   aOut = sqlite3_malloc64(nNew+70);",
          "685:   if( aOut==0 ){",
          "686:     sqlite3_result_error_nomem(context);",
          "687:   }else{",
          "688:     nOut = delta_create(aOrig, nOrig, aNew, nNew, aOut);",
          "689:     if( nOut<0 ){",
          "690:       sqlite3_free(aOut);",
          "691:       sqlite3_result_error(context, \"cannot create fossil delta\", -1);",
          "692:     }else{",
          "693:       sqlite3_result_blob(context, aOut, nOut, sqlite3_free);",
          "694:     }",
          "695:   }",
          "696: }",
          "703: static void deltaApplyFunc(",
          "704:   sqlite3_context *context,",
          "705:   int argc,",
          "706:   sqlite3_value **argv",
          "707: ){",
          "712:   assert( argc==2 );",
          "713:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;",
          "714:   if( sqlite3_value_type(argv[1])==SQLITE_NULL ) return;",
          "715:   nOrig = sqlite3_value_bytes(argv[0]);",
          "716:   aOrig = (const char*)sqlite3_value_blob(argv[0]);",
          "717:   nDelta = sqlite3_value_bytes(argv[1]);",
          "718:   aDelta = (const char*)sqlite3_value_blob(argv[1]);",
          "721:   nOut = delta_output_size(aDelta, nDelta);",
          "722:   if( nOut<0 ){",
          "723:     sqlite3_result_error(context, \"corrupt fossil delta\", -1);",
          "724:     return;",
          "725:   }",
          "726:   aOut = sqlite3_malloc64((sqlite3_int64)nOut+1);",
          "727:   if( aOut==0 ){",
          "728:     sqlite3_result_error_nomem(context);",
          "729:   }else{",
          "730:     nOut2 = delta_apply(aOrig, nOrig, aDelta, nDelta, aOut);",
          "731:     if( nOut2!=nOut ){",
          "732:       sqlite3_free(aOut);",
          "733:       sqlite3_result_error(context, \"corrupt fossil delta\", -1);",
          "734:     }else{",
          "735:       sqlite3_result_blob(context, aOut, nOut, sqlite3_free);",
          "736:     }",
          "737:   }",
          "738: }",
          "746: static void deltaOutputSizeFunc(",
          "747:   sqlite3_context *context,",
          "748:   int argc,",
          "749:   sqlite3_value **argv",
          "750: ){",
          "753:   assert( argc==1 );",
          "754:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;",
          "755:   nDelta = sqlite3_value_bytes(argv[0]);",
          "756:   aDelta = (const char*)sqlite3_value_blob(argv[0]);",
          "759:   nOut = delta_output_size(aDelta, nDelta);",
          "760:   if( nOut<0 ){",
          "761:     sqlite3_result_error(context, \"corrupt fossil delta\", -1);",
          "762:     return;",
          "763:   }else{",
          "764:     sqlite3_result_int(context, nOut);",
          "765:   }",
          "766: }",
          "769: #ifdef _WIN32",
          "770: __declspec(dllexport)",
          "771: #endif",
          "772: int sqlite3_fossildelta_init(",
          "773:   sqlite3 *db,",
          "774:   char **pzErrMsg,",
          "775:   const sqlite3_api_routines *pApi",
          "776: ){",
          "777:   int rc = SQLITE_OK;",
          "778:   SQLITE_EXTENSION_INIT2(pApi);",
          "780:   rc = sqlite3_create_function(db, \"delta_create\", 2, SQLITE_UTF8, 0,",
          "781:                                deltaCreateFunc, 0, 0);",
          "782:   if( rc==SQLITE_OK ){",
          "783:     rc = sqlite3_create_function(db, \"delta_apply\", 2, SQLITE_UTF8, 0,",
          "784:                                  deltaApplyFunc, 0, 0);",
          "785:   }",
          "786:   if( rc==SQLITE_OK ){",
          "787:     rc = sqlite3_create_function(db, \"delta_output_size\", 1, SQLITE_UTF8, 0,",
          "788:                                  deltaOutputSizeFunc, 0, 0);",
          "789:   }",
          "790:   return rc;",
          "791: }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 12517d1b15da46bc90bd95bb9c161d7f2ecdd7f28b1b3a5ed4397939ef986061",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58ed374370522f7da3ec6d81d3c968e172399bb1",
      "candidate_info": {
        "commit_hash": "58ed374370522f7da3ec6d81d3c968e172399bb1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/58ed374370522f7da3ec6d81d3c968e172399bb1",
        "files": [
          "ext/rtree/rtree6.test",
          "manifest",
          "manifest.uuid",
          "src/where.c"
        ],
        "message": "Fix a problem triggered by DELETE statements with WHERE clauses that use the OR-optimization on some virtual tables.\n\nFossilOrigin-Name: ecf5caa7e9825a8b03d15ee525ec68be78c55926ddfaca27a040a7614caf0e85",
        "before_after_code_files": [
          "ext/rtree/rtree6.test||ext/rtree/rtree6.test",
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/rtree/rtree6.test||ext/rtree/rtree6.test": [
          "File: ext/rtree/rtree6.test -> ext/rtree/rtree6.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:   set testdir [file join [file dirname [info script]] .. .. test]",
          "16: }",
          "17: source $testdir/tester.tcl",
          "19: ifcapable {!rtree || rtree_int_only} {",
          "20:   finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: set testprefix rtree6",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:     x1>0.5 AND x1>0.5 AND x1>0.5 AND x1>0.5 AND x1>1.1",
          "168: } {}",
          "170: expand_all_sql db",
          "171: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171: #-------------------------------------------------------------------------",
          "172: reset_db",
          "173: do_execsql_test 4.0 {",
          "174:   CREATE VIRTUAL TABLE t1 USING rtree(id,x0,x1,y0,y1);",
          "175: }",
          "176: do_execsql_test 4.1 {",
          "177:   DELETE FROM t1 WHERE x0>1 AND x1<2 OR y0<92;",
          "178: }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 0bf1550507d9d3c8a41f8a50db3a59bf808f0a4e24637dc0905d35579305eca7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4919:   if( (wctrlFlags & WHERE_ONEPASS_DESIRED)!=0 ){",
          "4920:     int wsFlags = pWInfo->a[0].pWLoop->wsFlags;",
          "4921:     int bOnerow = (wsFlags & WHERE_ONEROW)!=0;",
          "4922:     if( bOnerow || (",
          "4923:         0!=(wctrlFlags & WHERE_ONEPASS_MULTIROW)",
          "4925:      && (0==(wsFlags & WHERE_MULTI_OR) || (wctrlFlags & WHERE_DUPLICATES_OK))",
          "4926:     )){",
          "4927:       pWInfo->eOnePass = bOnerow ? ONEPASS_SINGLE : ONEPASS_MULTI;",
          "",
          "[Removed Lines]",
          "4924:      && 0==(wsFlags & WHERE_VIRTUALTABLE)",
          "",
          "[Added Lines]",
          "4922:     assert( !(wsFlags & WHERE_VIRTUALTABLE) || IsVirtual(pTabList->a[0].pTab) );",
          "4925:      && !IsVirtual(pTabList->a[0].pTab)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c6b24ab1b136b151c1d5c0d20cd9ab9991428750",
      "candidate_info": {
        "commit_hash": "c6b24ab1b136b151c1d5c0d20cd9ab9991428750",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c6b24ab1b136b151c1d5c0d20cd9ab9991428750",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c",
          "test/upsert1.test"
        ],
        "message": "Do not allow UPSERT of a view.\n\nFossilOrigin-Name: ebf897e861c19e214c57f1e73841b505182202cc8d7d39e24d5a1e5625e26b4a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c",
          "test/upsert1.test||test/upsert1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b7810062ec2489e1c5ca6638dbeb0892e4ce376c5c1834a31d1a332ebab8a871",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "949:               pTab->zName);",
          "950:       goto insert_cleanup;",
          "951:     }",
          "952:     if( sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget) ){",
          "953:       goto insert_cleanup;",
          "954:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "952:     if( pTab->pSelect ){",
          "953:       sqlite3ErrorMsg(pParse, \"cannot UPSERT a view\");",
          "954:       goto insert_cleanup;",
          "955:     }",
          "",
          "---------------"
        ],
        "test/upsert1.test||test/upsert1.test": [
          "File: test/upsert1.test -> test/upsert1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "221:   REINDEX;",
          "222: } {ok}",
          "224: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224: # 2019-12-06 gramfuzz find",
          "225: sqlite3 db :memory:",
          "226: do_execsql_test upsert1-900 {",
          "227:   CREATE VIEW t1(a) AS SELECT 1;",
          "228:   CREATE TRIGGER t1r1 INSTEAD OF INSERT ON t1 BEGIN",
          "229:      SELECT 2;",
          "230:   END;",
          "231: }",
          "232: do_catchsql_test upsert1-910 {",
          "233:   INSERT INTO t1 VALUES(3) ON CONFLICT(x) DO NOTHING;",
          "234: } {1 {cannot UPSERT a view}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fc4eeef9e7fb8f0a31aa84bf8dc875c6985422cd",
      "candidate_info": {
        "commit_hash": "fc4eeef9e7fb8f0a31aa84bf8dc875c6985422cd",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/fc4eeef9e7fb8f0a31aa84bf8dc875c6985422cd",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Fix compiler warnings on Windows.\n\nFossilOrigin-Name: 4978ee8b5405f958723b4ebbd4288bd08bff2b453da2d1c032d1ae904c2a3821",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 79c073878d56fc638b751b0e61295df182f7ee6f8ebd7319c1eeac1608abbac8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1090: #define PROGRESS_RESET   0x02         /* Reset the count when the progres",
          "",
          "[Added Lines]",
          "1090: #define SHELL_PROGRESS_RESET 0x02  /* Reset the count when the progres",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1800:   p->nProgress++;",
          "1801:   if( p->nProgress>=p->mxProgress && p->mxProgress>0 ){",
          "1802:     raw_printf(p->out, \"Progress limit reached (%u)\\n\", p->nProgress);",
          "1805:     return 1;",
          "1806:   }",
          "1808:     raw_printf(p->out, \"Progress %u\\n\", p->nProgress);",
          "1809:   }",
          "1810:   return 0;",
          "",
          "[Removed Lines]",
          "1803:     if( p->flgProgress & PROGRESS_RESET ) p->nProgress = 0;",
          "1804:     if( p->flgProgress & PROGRESS_ONCE ) p->mxProgress = 0;",
          "1807:   if( (p->flgProgress & PROGRESS_QUIET)==0 ){",
          "",
          "[Added Lines]",
          "1803:     if( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;",
          "1804:     if( p->flgProgress & SHELL_PROGRESS_ONCE ) p->mxProgress = 0;",
          "1807:   if( (p->flgProgress & SHELL_PROGRESS_QUIET)==0 ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7036:   if( c=='p' && n>=3 && strncmp(azArg[0], \"progress\", n)==0 ){",
          "7037:     int i;",
          "7039:     p->flgProgress = 0;",
          "7040:     p->mxProgress = 0;",
          "7041:     p->nProgress = 0;",
          "",
          "[Removed Lines]",
          "7038:     int n = 0;",
          "",
          "[Added Lines]",
          "7038:     int nn = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7045:         z++;",
          "7046:         if( z[0]=='-' ) z++;",
          "7047:         if( strcmp(z,\"quiet\")==0 || strcmp(z,\"q\")==0 ){",
          "7049:           continue;",
          "7050:         }",
          "7051:         if( strcmp(z,\"reset\")==0 ){",
          "7053:           continue;",
          "7054:         }",
          "7055:         if( strcmp(z,\"once\")==0 ){",
          "7057:           continue;",
          "7058:         }",
          "7059:         if( strcmp(z,\"limit\")==0 ){",
          "",
          "[Removed Lines]",
          "7048:           p->flgProgress |= PROGRESS_QUIET;",
          "7052:           p->flgProgress |= PROGRESS_RESET;",
          "7056:           p->flgProgress |= PROGRESS_ONCE;",
          "",
          "[Added Lines]",
          "7048:           p->flgProgress |= SHELL_PROGRESS_QUIET;",
          "7052:           p->flgProgress |= SHELL_PROGRESS_RESET;",
          "7056:           p->flgProgress |= SHELL_PROGRESS_ONCE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7070:         rc = 1;",
          "7071:         goto meta_command_exit;",
          "7072:       }else{",
          "7074:       }",
          "7075:     }",
          "7076:     open_db(p, 0);",
          "7078:   }else",
          "7080:   if( c=='p' && strncmp(azArg[0], \"prompt\", n)==0 ){",
          "",
          "[Removed Lines]",
          "7073:         n = (int)integerValue(z);",
          "7077:     sqlite3_progress_handler(p->db, n, progress_handler, p);",
          "",
          "[Added Lines]",
          "7073:         nn = (int)integerValue(z);",
          "7077:     sqlite3_progress_handler(p->db, nn, progress_handler, p);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8413:   open_db(p, 0);",
          "8414:   if( ShellHasFlag(p,SHFLG_Backslash) ) resolve_backslashes(zSql);",
          "8416:   BEGIN_TIMER;",
          "8417:   rc = shell_exec(p, zSql, &zErrMsg);",
          "8418:   END_TIMER;",
          "",
          "[Removed Lines]",
          "8415:   if( p->flgProgress & PROGRESS_RESET ) p->nProgress = 0;",
          "",
          "[Added Lines]",
          "8415:   if( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b1c479b61d5ae2d675f3ea6521a8abb6515e52af",
      "candidate_info": {
        "commit_hash": "b1c479b61d5ae2d675f3ea6521a8abb6515e52af",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b1c479b61d5ae2d675f3ea6521a8abb6515e52af",
        "files": [
          "ext/fts3/fts3.c",
          "manifest",
          "manifest.uuid",
          "test/fts3corrupt4.test"
        ],
        "message": "Fix an fts3 assert() that could fail when operating on a database containing corrupt records.\n\nFossilOrigin-Name: 7c52f5478f9ecf5c078208759143ae9de43c1bf191dfcd74acb8bd169d4dc883",
        "before_after_code_files": [
          "ext/fts3/fts3.c||ext/fts3/fts3.c",
          "manifest.uuid||manifest.uuid",
          "test/fts3corrupt4.test||test/fts3corrupt4.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts3/fts3.c||ext/fts3/fts3.c": [
          "File: ext/fts3/fts3.c -> ext/fts3/fts3.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2482: ){",
          "2484:   if( bDescIdx==0 || *pbFirst==0 ){",
          "2485:     iWrite = iVal - *piPrev;",
          "2486:   }else{",
          "2487:     iWrite = *piPrev - iVal;",
          "2488:   }",
          "2489:   assert( *pbFirst || *piPrev==0 );",
          "2490:   assert_fts3_nc( *pbFirst==0 || iWrite>0 );",
          "",
          "[Removed Lines]",
          "2483:   sqlite3_int64 iWrite;",
          "2491:   assert( *pbFirst==0 || iWrite>=0 );",
          "",
          "[Added Lines]",
          "2483:   sqlite3_uint64 iWrite;",
          "2485:     assert_fts3_nc( *pbFirst==0 || iVal>=*piPrev );",
          "2488:     assert_fts3_nc( *piPrev>=iVal );",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: bc6a43e7ee6353b9ef3dea4309c77e170a1c798eefcfaa7636bf5a93e51c47ee",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/fts3corrupt4.test||test/fts3corrupt4.test": [
          "File: test/fts3corrupt4.test -> test/fts3corrupt4.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "5546:   SELECT (matchinfo(null)) FROM t1 WHERE t1 MATCH 'ee*e*e*e*e*e*e*Re*e*e*e**'",
          "5547: } {1 {database disk image is malformed}}",
          "5549: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5549: #-------------------------------------------------------------------------",
          "5550: #",
          "5551: reset_db",
          "5552: do_execsql_test 31.0 {",
          "5553: CREATE VIRTUAL TABLE t1 USING fts3(a,b,c);",
          "5554: INSERT INTO t1_segdir VALUES(0,0,0,0,'0 592',X'00016dcb048ce6fbd3b2d68bfebf0101020200808080808080808020010202008080808080808080100102020080808080808080800801020200808080808080808004010202008080808080808080020102020080808080808080800101020200808080808080804001020200808080808080802001020200808080808080801001020200808080808080800801020200808080808080800401020200808080808080800201020200808080808080800101020200808080808080400102020080808080808020010202008080808080801001020200808080808080080102020080808080808004010202008080808080800201020200808080808080010102020080808080804001020200808080808020010202008080808080100102020080808080800801020200808080808004010202008080808080020102020080808080800101020200808080804001020200808080802001020200808080801001020200808080800801020200808080800401020200808080800201020200808080800101020200808080400102020080808020010202008080801001020200808080080102020080808004010202008080800201020200808080010102020080804001020200808020010202008080100102020080800801020200808004010202008080020102020080800101020200804001020200802001020200801001020200800801020200800401020200800201020200800101020200400102020020010202001001020200080102020004010202000201020200010102020001010202008080808080808080800101020200');",
          "5555: INSERT INTO t1_segdir VALUES(0,1,0,0,'0 18',X'00026d6d0d8ee6fbd3b2d68bfe7f01020200');",
          "5556: }",
          "5558: do_catchsql_test 31.1 {",
          "5559:   SELECT (matchinfo(t1, c ) ) FROM t1 WHERE t1 MATCH 'M*M*M*M*';",
          "5560: } {1 {database disk image is malformed}}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
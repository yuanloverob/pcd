{
  "cve_id": "CVE-2018-15836",
  "cve_desc": "In verify_signed_hash() in lib/liboswkeys/signatures.c in Openswan before 2.6.50.1, the RSA implementation does not verify the value of padding string during PKCS#1 v1.5 signature verification. Consequently, a remote attacker can forge signatures when small public exponents are being used. IKEv2 signature verification is affected when RAW RSA keys are used.",
  "repo": "xelerance/Openswan",
  "patch_hash": "9eaa6c2a823c1d2b58913506a15f9474bf857a3d",
  "patch_info": {
    "commit_hash": "9eaa6c2a823c1d2b58913506a15f9474bf857a3d",
    "repo": "xelerance/Openswan",
    "commit_url": "https://github.com/xelerance/Openswan/commit/9eaa6c2a823c1d2b58913506a15f9474bf857a3d",
    "files": [
      "lib/liboswkeys/signatures.c"
    ],
    "message": "wo#7449 . verify padding contents for IKEv2 RSA sig check\n\nSpecial thanks to Sze Yiu Chau of Purdue University (schau@purdue.edu)\nwho reported the issue.",
    "before_after_code_files": [
      "lib/liboswkeys/signatures.c||lib/liboswkeys/signatures.c"
    ]
  },
  "patch_diff": {
    "lib/liboswkeys/signatures.c||lib/liboswkeys/signatures.c": [
      "File: lib/liboswkeys/signatures.c -> lib/liboswkeys/signatures.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "157:  return \"3\"\"SIG padding does not check out\";",
      "158:     }",
      "164:     return NULL;",
      "",
      "[Removed Lines]",
      "160:     s += padlen + 3;",
      "161:     (*psig) = s;",
      "",
      "[Added Lines]",
      "161:     (*psig) = s + padlen + 3;",
      "164:     {",
      "165:         const u_char *p;",
      "166:         size_t cnt_ffs = 0;",
      "168:         for (p = s+2; p < s+padlen+2; p++)",
      "169:             if (*p == 0xFF)",
      "170:                 cnt_ffs ++;",
      "172:         if (cnt_ffs != padlen)",
      "173:             return \"4\" \"invalid Padding String\";",
      "174:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "937d24f88566702d72a549e9e8650320cb4f95cf",
      "candidate_info": {
        "commit_hash": "937d24f88566702d72a549e9e8650320cb4f95cf",
        "repo": "xelerance/Openswan",
        "commit_url": "https://github.com/xelerance/Openswan/commit/937d24f88566702d72a549e9e8650320cb4f95cf",
        "files": [
          "tests/unit/libopenswan/Makefile",
          "tests/unit/libopenswan/lo07-bleichenbacher-attack/.gitignore",
          "tests/unit/libopenswan/lo07-bleichenbacher-attack/Makefile",
          "tests/unit/libopenswan/lo07-bleichenbacher-attack/bleichenbacher-attack.c",
          "tests/unit/libopenswan/lo07-bleichenbacher-attack/description.txt",
          "tests/unit/libopenswan/lo07-bleichenbacher-attack/output.txt"
        ],
        "message": "wo#7449 . test case for Bleichenbacher-style signature forgery\n\nSpecial thanks to Sze Yiu Chau of Purdue University (schau@purdue.edu)\nwho reported the issue, and made major contributions towards defining\nthis test case.",
        "before_after_code_files": [
          "tests/unit/libopenswan/lo07-bleichenbacher-attack/bleichenbacher-attack.c||tests/unit/libopenswan/lo07-bleichenbacher-attack/bleichenbacher-attack.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/xelerance/Openswan/pull/330"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/unit/libopenswan/lo07-bleichenbacher-attack/bleichenbacher-attack.c||tests/unit/libopenswan/lo07-bleichenbacher-attack/bleichenbacher-attack.c": [
          "File: tests/unit/libopenswan/lo07-bleichenbacher-attack/bleichenbacher-attack.c -> tests/unit/libopenswan/lo07-bleichenbacher-attack/bleichenbacher-attack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #define DEBUG",
          "2: #include <stdlib.h>",
          "3: #include <stddef.h>",
          "4: #include <limits.h>",
          "5: #include \"openswan.h\"",
          "6: #include \"openswan/passert.h\"",
          "7: #include \"constants.h\"",
          "8: #include \"oswalloc.h\"",
          "9: #include \"oswlog.h\"",
          "10: #include \"secrets.h\"",
          "11: #include \"mpzfuncs.h\"",
          "12: #include \"id.h\"",
          "13: #include \"pluto/keys.h\"",
          "14: #include \"hexdump.c\"",
          "15: #include \"defs.h\"",
          "16: #include \"state.h\"",
          "17: #include \"packet.h\"",
          "19: struct spd_route;",
          "20: struct payload_digest;",
          "21: #include \"ikev2.h\"",
          "23: const char *progname;",
          "24: struct prng not_very_random;",
          "26: void whack_log(int mess_no, const char *message, ...)",
          "27: {",
          "28: }",
          "30: void exit_tool(int stat)",
          "31: {",
          "32:     exit(stat);",
          "33: }",
          "35: int attack(uint8_t low_exponent, size_t modulus_bit_len)",
          "36: {",
          "38:     uint8_t helloworldSHA1Bytes[] = {",
          "39:         0x2A, 0xAE, 0x6C, 0x35, 0xC9, 0x4F, 0xCF, 0xB4, 0x15, 0xDB,",
          "40:         0xE9, 0x5F, 0x40, 0x8B, 0x9C, 0xE9, 0x1E, 0xE8, 0x46, 0xED",
          "41:     };",
          "43:     uint8_t attackBytes[] = {",
          "45:         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "46:         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "47:         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "48:         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "49:         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "50:         0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xe7, 0x01, 0x3b,",
          "51:         0x05, 0xba, 0x96, 0x90, 0x7a, 0x1f, 0xd0, 0x34, 0x4e, 0x77, 0x75, 0xce, 0x9a, 0x6b, 0x9e, 0xbc,",
          "52:         0xb8, 0x0e, 0x72, 0x18, 0x1b, 0x48, 0x5e, 0x24, 0x9b, 0x96, 0x52, 0x4e, 0xca, 0xcc, 0xb8, 0x55",
          "53:     };",
          "56:     size_t modulus_byte_len = modulus_bit_len/8;",
          "57:     uint8_t modulusBytes[modulus_byte_len];",
          "60:     prng_bytes(&not_very_random, modulusBytes, modulus_byte_len);",
          "61:     printf(\"modulusBytes[%lu]:\\n\", modulus_byte_len);",
          "62:     hexdump(modulusBytes, 0, modulus_byte_len);",
          "65:     uint8_t pubExpBytes[] = {",
          "66:         low_exponent",
          "67:     };",
          "68:     printf(\"pubExpBytes[%lu]:\\n\", sizeof(pubExpBytes));",
          "69:     hexdump(pubExpBytes, 0, sizeof(pubExpBytes));",
          "72:     struct pubkey pk;",
          "73:     pk.u.rsa.k = sizeof(attackBytes);",
          "74:     n_to_mpz(&(pk.u.rsa.e), pubExpBytes, sizeof(pubExpBytes));",
          "75:     n_to_mpz(&(pk.u.rsa.n), modulusBytes, sizeof(modulusBytes));",
          "78:     struct state st;",
          "79:     memset(&st, 0, sizeof(struct state));",
          "81:     pb_stream sig_pbs;",
          "82:     sig_pbs.cur = attackBytes;",
          "83:     sig_pbs.roof = attackBytes+sizeof(attackBytes);",
          "84:     err_t e = NULL;",
          "86:     e = try_RSA_signature_v2(",
          "87:                              helloworldSHA1Bytes,            // const u_char hash_val[MAX_DIGEST_LEN]",
          "88:                              sizeof(helloworldSHA1Bytes),    // size_t hash_len",
          "89:                              &sig_pbs,                       // const pb_stream *sig_pbs",
          "90:                              &pk,                            // struct pubkey *kr",
          "91:                              &st                             // struct state *st",
          "92:                             );",
          "94:     printf(\"try_RSA_signature_v2: %s\\n\",",
          "95:            e ? e : \"OK\");",
          "97:     int rc = 0;",
          "98:     if (e)",
          "99:      rc = strtoul(e, NULL, 0);",
          "102:     if (rc && rc != ULONG_MAX)",
          "103:      return 0;",
          "105:     printf(\"ERROR: try_RSA_signature_v2() was fooled by our attack!\\n\");",
          "106:     return -1;",
          "107: }",
          "109: extern void load_oswcrypto(void);",
          "111: int main(int argc, char *argv[])",
          "112: {",
          "113:     int rc;",
          "115:     load_oswcrypto();",
          "117:     progname = argv[0];",
          "119:     prng_init(&not_very_random, \"01234567\", 8);",
          "121:     rc = attack(3, 1024);",
          "123:     exit(rc);",
          "124: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d28ef9e18903422a3d6cb912a8539ed8f0a24df5",
      "candidate_info": {
        "commit_hash": "d28ef9e18903422a3d6cb912a8539ed8f0a24df5",
        "repo": "xelerance/Openswan",
        "commit_url": "https://github.com/xelerance/Openswan/commit/d28ef9e18903422a3d6cb912a8539ed8f0a24df5",
        "files": [
          "tests/unit/libopenswan/Makefile",
          "tests/unit/libopenswan/lo06-verifybadsigs/.gitignore",
          "tests/unit/libopenswan/lo06-verifybadsigs/Makefile",
          "tests/unit/libopenswan/lo06-verifybadsigs/description.txt",
          "tests/unit/libopenswan/lo06-verifybadsigs/output.txt",
          "tests/unit/libopenswan/lo06-verifybadsigs/verifybadsigs.c"
        ],
        "message": "wo#7449 . added lo06-verifybadsigs test case\n\nThis unit test case is a clone of lo02-verifysigs.  However, instead of testing\nsuccessful sign/verify operation, it applies various corruptions to the signature\nand validates that verify_signed_hash() can handle the error.\n\nSpecial thanks to Sze Yiu Chau of Purdue University (schau@purdue.edu)\nwho reported the issue.",
        "before_after_code_files": [
          "tests/unit/libopenswan/lo06-verifybadsigs/verifybadsigs.c||tests/unit/libopenswan/lo06-verifybadsigs/verifybadsigs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/xelerance/Openswan/pull/330"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/unit/libopenswan/lo06-verifybadsigs/verifybadsigs.c||tests/unit/libopenswan/lo06-verifybadsigs/verifybadsigs.c": [
          "File: tests/unit/libopenswan/lo06-verifybadsigs/verifybadsigs.c -> tests/unit/libopenswan/lo06-verifybadsigs/verifybadsigs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #define DEBUG",
          "2: #include <stdlib.h>",
          "3: #include <stddef.h>",
          "4: #include \"openswan.h\"",
          "5: #include \"openswan/passert.h\"",
          "6: #include \"constants.h\"",
          "7: #include \"oswalloc.h\"",
          "8: #include \"oswlog.h\"",
          "9: #include \"secrets.h\"",
          "10: #include \"id.h\"",
          "11: #include \"pluto/keys.h\"",
          "12: #include \"hexdump.c\"",
          "13: #include \"oswcrypto.h\"",
          "14: #include \"mpzfuncs.h\"",
          "16: const char *progname;",
          "18: struct prng not_very_random;",
          "20: void exit_tool(int stat)",
          "21: {",
          "22:     exit(stat);",
          "23: }",
          "25: int count_secrets(struct secret *secret,",
          "26:                   struct private_key_stuff *pks,",
          "27:                   void *uservoid)",
          "28: {",
          "29:     int *pcount = (int *)uservoid;",
          "30:     (*pcount)++;",
          "32:     return 1;",
          "33: }",
          "35: static void hack_zero_first_pad_byte(u_char *sig_val, size_t sig_len)",
          "36: {",
          "37:     u_char *p = sig_val;",
          "38:     u_char *end = sig_val + sig_len;",
          "40:     assert(p[0] == 0x00);",
          "41:     assert(p[1] == 0x01);",
          "42:     assert(p[2] == 0xFF);",
          "44:     p[2] = 0;",
          "45: }",
          "47: static void hack_zero_last_pad_byte(u_char *sig_val, size_t sig_len)",
          "48: {",
          "49:     u_char *p = sig_val;",
          "50:     u_char *end = sig_val + sig_len;",
          "52:     assert(p[0] == 0x00);",
          "53:     assert(p[1] == 0x01);",
          "54:     assert(p[2] == 0xFF);",
          "56:     for (p+=2; *p==0xFF; p++);",
          "58:     assert(p<end);",
          "59:     assert(p[-1] == 0xFF);",
          "60:     assert(p[0] == 0x00);",
          "62:     p[-1] = 0;",
          "63: }",
          "65: static void hack_zero_all_pad_bytes(u_char *sig_val, size_t sig_len)",
          "66: {",
          "67:     u_char *p = sig_val;",
          "68:     u_char *end = sig_val + sig_len;",
          "70:     assert(p[0] == 0x00);",
          "71:     assert(p[1] == 0x01);",
          "72:     assert(p[2] == 0xFF);",
          "74:     for (p+=2; *p==0xFF; p++) *p = 0;",
          "76:     assert(p<end);",
          "77:     assert(p[0] == 0x00);",
          "78: }",
          "80: static void hack_remove_pad_add_trailing(u_char *sig_val, size_t sig_len)",
          "81: {",
          "82:     u_char *p = sig_val, *s;",
          "83:     u_char *end = sig_val + sig_len;",
          "84:     ssize_t rest, padlen;",
          "86:     assert(p[0] == 0x00);",
          "87:     assert(p[1] == 0x01);",
          "88:     assert(p[2] == 0xFF);",
          "90:     for (p+=2, s=p; *p==0xFF; p++);",
          "92:     assert(p<end);",
          "93:     assert(s[0] == 0xFF);       // s is the first byte of padding",
          "94:     assert(p[-1] == 0xFF);      // p-1 is last byte of padding",
          "95:     assert(p[0] == 0x00);       // p is the first byte after padding",
          "97:     rest = end-p;",
          "98:     padlen = p-s;",
          "100:     if (padlen>8) {",
          "101:         memmove(s+1, p-1, rest+1);      // keep 2 bytes of pad, shift rest down",
          "102:         memset(s+rest+2, 0xFF, padlen); // fill end with 0xFFs",
          "103:     }",
          "104: }",
          "106: struct hack {",
          "107:  const char *name;",
          "108:  void (*corrupt)(u_char *sig_val, size_t sig_len);",
          "109:         int expected_error;",
          "110: } hacks[] = {",
          "111:  { \"zero-first-pad-byte\",     hack_zero_first_pad_byte,     4 },",
          "112:  { \"zero-last-pad-byte\",      hack_zero_last_pad_byte,      4 },",
          "113:  { \"zero-all-pad-bytes\",      hack_zero_all_pad_bytes,      4 },",
          "114:         { \"remove-pad-add-trailing\", hack_remove_pad_add_trailing, 3 },",
          "115:  { NULL }",
          "116: };",
          "120: static void sign_hash_hack(struct hack *hack",
          "121:       , const struct private_key_stuff *pks",
          "122:       , const u_char *hash_val, size_t hash_len",
          "123:       , u_char *sig_val, size_t sig_len)",
          "124: {",
          "125:     chunk_t ch;",
          "126:     mpz_t t1;",
          "127:     size_t padlen;",
          "128:     u_char *p = sig_val;",
          "129:     const struct RSA_private_key *k = &pks->u.RSA_private_key;",
          "131:     DBG(DBG_CONTROL | DBG_CRYPT,",
          "132:  DBG_log(\"signing hash with RSA Key *%s\", pks->pub->u.rsa.keyid)",
          "133:         );",
          "138:     padlen = sig_len - 3 - hash_len;",
          "139:     memset(p, 0xFF, padlen);",
          "140:     p += padlen;",
          "142:     memcpy(p, hash_val, hash_len);",
          "143:     passert(p + hash_len - sig_val == (ptrdiff_t)sig_len);",
          "146:     printf(\"applying signature corruption '%s'\\n\", hack->name);",
          "147: #if 0",
          "148:     printf(\"before(%lu)...\\n\", sig_len);",
          "149:     hexdump(sig_val, 0, sig_len);",
          "150: #endif",
          "151:     hack->corrupt(sig_val, sig_len);",
          "152: #if 0",
          "153:     printf(\"after(%lu)...\\n\", sig_len);",
          "154:     hexdump(sig_val, 0, sig_len);",
          "155:     fflush(stdout);",
          "156: #endif",
          "167:     oswcrypto.rsa_mod_exp_crt(t1, t1, &k->p, &k->dP, &k->q, &k->dQ, &k->qInv);",
          "169:     ch = mpz_to_n(t1, sig_len);",
          "170:     memcpy(sig_val, ch.ptr, sig_len);",
          "171:     pfree(ch.ptr);",
          "173:     mpz_clear(t1);",
          "174: }",
          "176: void verify_sig_key_hack(struct hack *hack, const char *keyfile,",
          "177:     unsigned int keysize)",
          "178: {",
          "179:     struct secret *secrets = NULL;",
          "180:     char   thingtosign[64];",
          "181:     size_t signed_len;",
          "182:     char   signature_buf[8192];",
          "183:     int    count;",
          "184:     struct private_key_stuff *pks1;",
          "185:     char secretsfile[512];",
          "187:     printf(\"-----------------------------------------------\\n\"",
          "188:     \">>> %s(\\\"%s\\\", \\\"%s\\\", %u)\\n\",",
          "189:     __func__, hack->name, keyfile, keysize);",
          "190:     fflush(stdout);",
          "192:     memset(signature_buf, 0, sizeof(signature_buf));",
          "193:     snprintf(secretsfile, sizeof(secretsfile), \"../lo02-verifysigs/key-%s.secrets\", keyfile);",
          "195:     osw_load_preshared_secrets(&secrets, TRUE, secretsfile, NULL, NULL);",
          "196:     assert(secrets != NULL);",
          "197:     count = 0;",
          "198:     osw_foreach_secret(secrets, count_secrets, &count);",
          "199:     assert(count == 1);",
          "200:     pks1 = osw_get_pks(secrets);",
          "201:     assert(pks1->kind == PPK_RSA);",
          "202:     assert(keysize <= sizeof(signature_buf));",
          "205:     memcpy(thingtosign, der_digestinfo, der_digestinfo_len);",
          "206:     prng_bytes(&not_very_random, thingtosign+der_digestinfo_len, 16);",
          "207:     signed_len = 16+der_digestinfo_len;",
          "208:     printf(\"signed_len: %d\\n\", (int)signed_len);",
          "209:     hexdump(thingtosign, 0, signed_len);",
          "210:     fflush(stdout);",
          "212:     sign_hash_hack(hack, pks1, thingtosign, signed_len,",
          "213:      signature_buf, keysize);",
          "215:     printf(\"signature_buf: %d\\n\", (int)keysize);",
          "216:     hexdump(signature_buf, 0, sizeof(signature_buf));",
          "217:     fflush(stdout);",
          "221:     {",
          "223:         u_char *sig = NULL;",
          "224:         const u_char *sig_val = signature_buf;",
          "225:         size_t        sig_len = keysize;",
          "226:         size_t       hash_len = 16;",
          "227:         const struct RSA_public_key *k = &pks1->pub->u.rsa;",
          "228:         err_t err = NULL;",
          "229:         long num = 0;",
          "230:         char *end = NULL;",
          "232:         err = verify_signed_hash(k, s, sizeof(s), &sig, signed_len, sig_val, sig_len);",
          "233:         assert(err != NULL);",
          "235:         num = strtol(err, &end, 10);",
          "236:         assert(end>err);",
          "238:         printf(\"verify_signed_hash() returned=%ld, expected=%d\\n\",",
          "239:                num, hack->expected_error);",
          "240:         assert(num == hack->expected_error);",
          "242:         printf(\"<<< %s(\\\"%s\\\", \\\"%s\\\", %u) = (%ld) \\\"%s\\\"\\n\",",
          "243:                __func__, hack->name, keyfile, keysize, num, err);",
          "244:     }",
          "245: }",
          "247: void verify_sig_key(const char *keyfile, unsigned int keysize)",
          "248: {",
          "249:     typeof(*hacks) *hack;",
          "250:     for (hack=hacks; hack->name; hack++) {",
          "251:      verify_sig_key_hack(hack, keyfile, keysize);",
          "252:     }",
          "253: }",
          "255: extern void load_oswcrypto(void);",
          "257: int main(int argc, char *argv[])",
          "258: {",
          "259:     int i;",
          "260:     struct id one;",
          "262:     load_oswcrypto();",
          "263:     prng_init(&not_very_random, \"01234567\", 8);",
          "265:     progname = argv[0];",
          "267:     tool_init_log();",
          "269: #ifdef HAVE_LIBNSS",
          "270:     exit(1);",
          "271: #endif",
          "273:     set_debugging(DBG_CONTROL|DBG_CRYPT);",
          "274:     verify_sig_key(\"0512\", 512/8);",
          "275:     verify_sig_key(\"1024\", 1024/8);",
          "276:     verify_sig_key(\"2048\", 2048/8);",
          "277:     verify_sig_key(\"3072\", 3072/8);",
          "278:     verify_sig_key(\"4096\", 4096/8);",
          "279:     verify_sig_key(\"8192\", 8192/8);",
          "281:     printf(\"tests completed\\n\");",
          "283:     report_leaks();",
          "284:     tool_close_log();",
          "285:     exit(0);",
          "286: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
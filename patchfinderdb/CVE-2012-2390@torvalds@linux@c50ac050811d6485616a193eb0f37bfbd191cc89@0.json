{
  "cve_id": "CVE-2012-2390",
  "cve_desc": "Memory leak in mm/hugetlb.c in the Linux kernel before 3.4.2 allows local users to cause a denial of service (memory consumption or system crash) via invalid MAP_HUGETLB mmap operations.",
  "repo": "torvalds/linux",
  "patch_hash": "c50ac050811d6485616a193eb0f37bfbd191cc89",
  "patch_info": {
    "commit_hash": "c50ac050811d6485616a193eb0f37bfbd191cc89",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89",
    "files": [
      "mm/hugetlb.c"
    ],
    "message": "hugetlb: fix resv_map leak in error path\n\nWhen called for anonymous (non-shared) mappings, hugetlb_reserve_pages()\ndoes a resv_map_alloc().  It depends on code in hugetlbfs's\nvm_ops->close() to release that allocation.\n\nHowever, in the mmap() failure path, we do a plain unmap_region() without\nthe remove_vma() which actually calls vm_ops->close().\n\nThis is a decent fix.  This leak could get reintroduced if new code (say,\nafter hugetlb_reserve_pages() in hugetlbfs_file_mmap()) decides to return\nan error.  But, I think it would have to unroll the reservation anyway.\n\nChristoph's test case:\n\n\thttp://marc.info/?l=linux-mm&m=133728900729735\n\nThis patch applies to 3.4 and later.  A version for earlier kernels is at\nhttps://lkml.org/lkml/2012/5/22/418.\n\nSigned-off-by: Dave Hansen <dave@linux.vnet.ibm.com>\nAcked-by: Mel Gorman <mel@csn.ul.ie>\nAcked-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nReported-by: Christoph Lameter <cl@linux.com>\nTested-by: Christoph Lameter <cl@linux.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\t[2.6.32+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/hugetlb.c||mm/hugetlb.c"
    ]
  },
  "patch_diff": {
    "mm/hugetlb.c||mm/hugetlb.c": [
      "File: mm/hugetlb.c -> mm/hugetlb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2157:   kref_get(&reservations->refs);",
      "2158: }",
      "2160: static void hugetlb_vm_op_close(struct vm_area_struct *vma)",
      "2161: {",
      "2162:  struct hstate *h = hstate_vma(vma);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2160: static void resv_map_put(struct vm_area_struct *vma)",
      "2161: {",
      "2162:  struct resv_map *reservations = vma_resv_map(vma);",
      "2164:  if (!reservations)",
      "2165:   return;",
      "2166:  kref_put(&reservations->refs, resv_map_release);",
      "2167: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2173:   reserve = (end - start) -",
      "2174:    region_count(&reservations->regions, start, end);",
      "2178:   if (reserve) {",
      "2179:    hugetlb_acct_memory(h, -reserve);",
      "",
      "[Removed Lines]",
      "2176:   kref_put(&reservations->refs, resv_map_release);",
      "",
      "[Added Lines]",
      "2185:   resv_map_put(vma);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2991:   set_vma_resv_flags(vma, HPAGE_RESV_OWNER);",
      "2992:  }",
      "",
      "[Removed Lines]",
      "2994:  if (chg < 0)",
      "2995:   return chg;",
      "2998:  if (hugepage_subpool_get_pages(spool, chg))",
      "2999:   return -ENOSPC;",
      "",
      "[Added Lines]",
      "3003:  if (chg < 0) {",
      "3004:   ret = chg;",
      "3005:   goto out_err;",
      "3006:  }",
      "3009:  if (hugepage_subpool_get_pages(spool, chg)) {",
      "3010:   ret = -ENOSPC;",
      "3011:   goto out_err;",
      "3012:  }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3005:  ret = hugetlb_acct_memory(h, chg);",
      "3006:  if (ret < 0) {",
      "3007:   hugepage_subpool_put_pages(spool, chg);",
      "3009:  }",
      "",
      "[Removed Lines]",
      "3008:   return ret;",
      "",
      "[Added Lines]",
      "3021:   goto out_err;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3022:  if (!vma || vma->vm_flags & VM_MAYSHARE)",
      "3023:   region_add(&inode->i_mapping->private_list, from, to);",
      "3024:  return 0;",
      "3025: }",
      "3027: void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3038: out_err:",
      "3039:  resv_map_put(vma);",
      "3040:  return ret;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "90481622d75715bfcb68501280a917dbfe516029",
      "candidate_info": {
        "commit_hash": "90481622d75715bfcb68501280a917dbfe516029",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "files": [
          "fs/hugetlbfs/inode.c",
          "include/linux/hugetlb.h",
          "mm/hugetlb.c"
        ],
        "message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/hugetlbfs/inode.c||fs/hugetlbfs/inode.c",
          "include/linux/hugetlb.h||include/linux/hugetlb.h",
          "mm/hugetlb.c||mm/hugetlb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ],
          "candidate": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/hugetlbfs/inode.c||fs/hugetlbfs/inode.c": [
          "File: fs/hugetlbfs/inode.c -> fs/hugetlbfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "626:   spin_lock(&sbinfo->stat_lock);",
          "632:    buf->f_files = sbinfo->max_inodes;",
          "633:    buf->f_ffree = sbinfo->free_inodes;",
          "634:   }",
          "",
          "[Removed Lines]",
          "629:   if (sbinfo->max_blocks >= 0) {",
          "630:    buf->f_blocks = sbinfo->max_blocks;",
          "631:    buf->f_bavail = buf->f_bfree = sbinfo->free_blocks;",
          "",
          "[Added Lines]",
          "629:   if (sbinfo->spool) {",
          "630:    long free_pages;",
          "632:    spin_lock(&sbinfo->spool->lock);",
          "633:    buf->f_blocks = sbinfo->spool->max_hpages;",
          "634:    free_pages = sbinfo->spool->max_hpages",
          "635:     - sbinfo->spool->used_hpages;",
          "636:    buf->f_bavail = buf->f_bfree = free_pages;",
          "637:    spin_unlock(&sbinfo->spool->lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "645:  if (sbi) {",
          "646:   sb->s_fs_info = NULL;",
          "647:   kfree(sbi);",
          "648:  }",
          "649: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "654:   if (sbi->spool)",
          "655:    hugepage_put_subpool(sbi->spool);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "874:  sb->s_fs_info = sbinfo;",
          "875:  sbinfo->hstate = config.hstate;",
          "876:  spin_lock_init(&sbinfo->stat_lock);",
          "879:  sbinfo->max_inodes = config.nr_inodes;",
          "880:  sbinfo->free_inodes = config.nr_inodes;",
          "881:  sb->s_maxbytes = MAX_LFS_FILESIZE;",
          "882:  sb->s_blocksize = huge_page_size(config.hstate);",
          "883:  sb->s_blocksize_bits = huge_page_shift(config.hstate);",
          "",
          "[Removed Lines]",
          "877:  sbinfo->max_blocks = config.nr_blocks;",
          "878:  sbinfo->free_blocks = config.nr_blocks;",
          "",
          "[Added Lines]",
          "889:  sbinfo->spool = NULL;",
          "890:  if (config.nr_blocks != -1) {",
          "891:   sbinfo->spool = hugepage_new_subpool(config.nr_blocks);",
          "892:   if (!sbinfo->spool)",
          "893:    goto out_free;",
          "894:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "896:  sb->s_root = root;",
          "897:  return 0;",
          "898: out_free:",
          "899:  kfree(sbinfo);",
          "900:  return -ENOMEM;",
          "901: }",
          "931: static struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,",
          "932:  int flags, const char *dev_name, void *data)",
          "933: {",
          "",
          "[Removed Lines]",
          "903: int hugetlb_get_quota(struct address_space *mapping, long delta)",
          "904: {",
          "905:  int ret = 0;",
          "906:  struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);",
          "908:  if (sbinfo->free_blocks > -1) {",
          "909:   spin_lock(&sbinfo->stat_lock);",
          "910:   if (sbinfo->free_blocks - delta >= 0)",
          "911:    sbinfo->free_blocks -= delta;",
          "912:   else",
          "913:    ret = -ENOMEM;",
          "914:   spin_unlock(&sbinfo->stat_lock);",
          "915:  }",
          "917:  return ret;",
          "918: }",
          "920: void hugetlb_put_quota(struct address_space *mapping, long delta)",
          "921: {",
          "922:  struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);",
          "924:  if (sbinfo->free_blocks > -1) {",
          "925:   spin_lock(&sbinfo->stat_lock);",
          "926:   sbinfo->free_blocks += delta;",
          "927:   spin_unlock(&sbinfo->stat_lock);",
          "928:  }",
          "929: }",
          "",
          "[Added Lines]",
          "913:  if (sbinfo->spool)",
          "914:   kfree(sbinfo->spool);",
          "",
          "---------------"
        ],
        "include/linux/hugetlb.h||include/linux/hugetlb.h": [
          "File: include/linux/hugetlb.h -> include/linux/hugetlb.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include <linux/shm.h>",
          "15: #include <asm/tlbflush.h>",
          "17: int PageHuge(struct page *page);",
          "19: void reset_vma_resv_huge_pages(struct vm_area_struct *vma);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: struct hugepage_subpool {",
          "18:  spinlock_t lock;",
          "19:  long count;",
          "20:  long max_hpages, used_hpages;",
          "21: };",
          "23: struct hugepage_subpool *hugepage_new_subpool(long nr_blocks);",
          "24: void hugepage_put_subpool(struct hugepage_subpool *spool);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130: #ifdef CONFIG_HUGETLBFS",
          "131: struct hugetlbfs_sb_info {",
          "136:  spinlock_t stat_lock;",
          "137:  struct hstate *hstate;",
          "138: };",
          "140: static inline struct hugetlbfs_sb_info *HUGETLBFS_SB(struct super_block *sb)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:  struct hugepage_subpool *spool;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "146: extern const struct vm_operations_struct hugetlb_vm_ops;",
          "147: struct file *hugetlb_file_setup(const char *name, size_t size, vm_flags_t acct,",
          "148:     struct user_struct **user, int creat_flags);",
          "152: static inline int is_file_hugepages(struct file *file)",
          "153: {",
          "",
          "[Removed Lines]",
          "149: int hugetlb_get_quota(struct address_space *mapping, long delta);",
          "150: void hugetlb_put_quota(struct address_space *mapping, long delta);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mm/hugetlb.c||mm/hugetlb.c": [
          "File: mm/hugetlb.c -> mm/hugetlb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: static DEFINE_SPINLOCK(hugetlb_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)",
          "57: {",
          "58:  bool free = (spool->count == 0) && (spool->used_hpages == 0);",
          "60:  spin_unlock(&spool->lock);",
          "64:  if (free)",
          "65:   kfree(spool);",
          "66: }",
          "68: struct hugepage_subpool *hugepage_new_subpool(long nr_blocks)",
          "69: {",
          "70:  struct hugepage_subpool *spool;",
          "72:  spool = kmalloc(sizeof(*spool), GFP_KERNEL);",
          "73:  if (!spool)",
          "74:   return NULL;",
          "76:  spin_lock_init(&spool->lock);",
          "77:  spool->count = 1;",
          "78:  spool->max_hpages = nr_blocks;",
          "79:  spool->used_hpages = 0;",
          "81:  return spool;",
          "82: }",
          "84: void hugepage_put_subpool(struct hugepage_subpool *spool)",
          "85: {",
          "86:  spin_lock(&spool->lock);",
          "87:  BUG_ON(!spool->count);",
          "88:  spool->count--;",
          "89:  unlock_or_release_subpool(spool);",
          "90: }",
          "92: static int hugepage_subpool_get_pages(struct hugepage_subpool *spool,",
          "93:           long delta)",
          "94: {",
          "95:  int ret = 0;",
          "97:  if (!spool)",
          "98:   return 0;",
          "100:  spin_lock(&spool->lock);",
          "101:  if ((spool->used_hpages + delta) <= spool->max_hpages) {",
          "102:   spool->used_hpages += delta;",
          "103:  } else {",
          "104:   ret = -ENOMEM;",
          "105:  }",
          "106:  spin_unlock(&spool->lock);",
          "108:  return ret;",
          "109: }",
          "111: static void hugepage_subpool_put_pages(struct hugepage_subpool *spool,",
          "112:            long delta)",
          "113: {",
          "114:  if (!spool)",
          "115:   return;",
          "117:  spin_lock(&spool->lock);",
          "118:  spool->used_hpages -= delta;",
          "121:  unlock_or_release_subpool(spool);",
          "122: }",
          "124: static inline struct hugepage_subpool *subpool_inode(struct inode *inode)",
          "125: {",
          "126:  return HUGETLBFS_SB(inode->i_sb)->spool;",
          "127: }",
          "129: static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)",
          "130: {",
          "131:  return subpool_inode(vma->vm_file->f_dentry->d_inode);",
          "132: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "541:  struct hstate *h = page_hstate(page);",
          "542:  int nid = page_to_nid(page);",
          "546:  set_page_private(page, 0);",
          "547:  page->mapping = NULL;",
          "548:  BUG_ON(page_count(page));",
          "",
          "[Removed Lines]",
          "543:  struct address_space *mapping;",
          "545:  mapping = (struct address_space *) page_private(page);",
          "",
          "[Added Lines]",
          "621:  struct hugepage_subpool *spool =",
          "622:   (struct hugepage_subpool *)page_private(page);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "558:   enqueue_huge_page(h, page);",
          "559:  }",
          "560:  spin_unlock(&hugetlb_lock);",
          "563: }",
          "565: static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)",
          "",
          "[Removed Lines]",
          "561:  if (mapping)",
          "562:   hugetlb_put_quota(mapping, 1);",
          "",
          "[Added Lines]",
          "639:  hugepage_subpool_put_pages(spool, 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1030: static struct page *alloc_huge_page(struct vm_area_struct *vma,",
          "1031:         unsigned long addr, int avoid_reserve)",
          "1032: {",
          "1033:  struct hstate *h = hstate_vma(vma);",
          "1034:  struct page *page;",
          "1037:  long chg;",
          "1046:  chg = vma_needs_reservation(h, vma, addr);",
          "1047:  if (chg < 0)",
          "1048:   return ERR_PTR(-VM_FAULT_OOM);",
          "1049:  if (chg)",
          "1051:    return ERR_PTR(-VM_FAULT_SIGBUS);",
          "1053:  spin_lock(&hugetlb_lock);",
          "",
          "[Removed Lines]",
          "1035:  struct address_space *mapping = vma->vm_file->f_mapping;",
          "1036:  struct inode *inode = mapping->host;",
          "1050:   if (hugetlb_get_quota(inode->i_mapping, chg))",
          "",
          "[Added Lines]",
          "1111:  struct hugepage_subpool *spool = subpool_vma(vma);",
          "1128:   if (hugepage_subpool_get_pages(spool, chg))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1057:  if (!page) {",
          "1058:   page = alloc_buddy_huge_page(h, NUMA_NO_NODE);",
          "1059:   if (!page) {",
          "1061:    return ERR_PTR(-VM_FAULT_SIGBUS);",
          "1062:   }",
          "1063:  }",
          "1067:  vma_commit_reservation(h, vma, addr);",
          "",
          "[Removed Lines]",
          "1060:    hugetlb_put_quota(inode->i_mapping, chg);",
          "1065:  set_page_private(page, (unsigned long) mapping);",
          "",
          "[Added Lines]",
          "1138:    hugepage_subpool_put_pages(spool, chg);",
          "1143:  set_page_private(page, (unsigned long)spool);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2083: {",
          "2084:  struct hstate *h = hstate_vma(vma);",
          "2085:  struct resv_map *reservations = vma_resv_map(vma);",
          "2086:  unsigned long reserve;",
          "2087:  unsigned long start;",
          "2088:  unsigned long end;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2164:  struct hugepage_subpool *spool = subpool_vma(vma);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2099:   if (reserve) {",
          "2100:    hugetlb_acct_memory(h, -reserve);",
          "2102:   }",
          "2103:  }",
          "2104: }",
          "",
          "[Removed Lines]",
          "2101:    hugetlb_put_quota(vma->vm_file->f_mapping, reserve);",
          "",
          "[Added Lines]",
          "2180:    hugepage_subpool_put_pages(spool, reserve);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2332:  address = address & huge_page_mask(h);",
          "2333:  pgoff = vma_hugecache_offset(h, vma, address);",
          "",
          "[Removed Lines]",
          "2334:  mapping = (struct address_space *)page_private(page);",
          "",
          "[Added Lines]",
          "2413:  mapping = vma->vm_file->f_dentry->d_inode->i_mapping;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2884: {",
          "2885:  long ret, chg;",
          "2886:  struct hstate *h = hstate_inode(inode);",
          "2893:  if (vm_flags & VM_NORESERVE)",
          "2894:   return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2966:  struct hugepage_subpool *spool = subpool_inode(inode);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2915:  if (chg < 0)",
          "2916:   return chg;",
          "2920:   return -ENOSPC;",
          "2926:  ret = hugetlb_acct_memory(h, chg);",
          "2927:  if (ret < 0) {",
          "2929:   return ret;",
          "2930:  }",
          "",
          "[Removed Lines]",
          "2919:  if (hugetlb_get_quota(inode->i_mapping, chg))",
          "2928:   hugetlb_put_quota(inode->i_mapping, chg);",
          "",
          "[Added Lines]",
          "2999:  if (hugepage_subpool_get_pages(spool, chg))",
          "3008:   hugepage_subpool_put_pages(spool, chg);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2949: {",
          "2950:  struct hstate *h = hstate_inode(inode);",
          "2951:  long chg = region_truncate(&inode->i_mapping->private_list, offset);",
          "2953:  spin_lock(&inode->i_lock);",
          "2954:  inode->i_blocks -= (blocks_per_huge_page(h) * freed);",
          "2955:  spin_unlock(&inode->i_lock);",
          "2958:  hugetlb_acct_memory(h, -(chg - freed));",
          "2959: }",
          "",
          "[Removed Lines]",
          "2957:  hugetlb_put_quota(inode->i_mapping, (chg - freed));",
          "",
          "[Added Lines]",
          "3032:  struct hugepage_subpool *spool = subpool_inode(inode);",
          "3038:  hugepage_subpool_put_pages(spool, (chg - freed));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4523e1458566a0e8ecfaff90f380dd23acc44d27",
      "candidate_info": {
        "commit_hash": "4523e1458566a0e8ecfaff90f380dd23acc44d27",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4523e1458566a0e8ecfaff90f380dd23acc44d27",
        "files": [
          "mm/hugetlb.c"
        ],
        "message": "mm: fix vma_resv_map() NULL pointer\n\nhugetlb_reserve_pages() can be used for either normal file-backed\nhugetlbfs mappings, or MAP_HUGETLB.  In the MAP_HUGETLB, semi-anonymous\nmode, there is not a VMA around.  The new call to resv_map_put() assumed\nthat there was, and resulted in a NULL pointer dereference:\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000030\n  IP: vma_resv_map+0x9/0x30\n  PGD 141453067 PUD 1421e1067 PMD 0\n  Oops: 0000 [#1] PREEMPT SMP\n  ...\n  Pid: 14006, comm: trinity-child6 Not tainted 3.4.0+ #36\n  RIP: vma_resv_map+0x9/0x30\n  ...\n  Process trinity-child6 (pid: 14006, threadinfo ffff8801414e0000, task ffff8801414f26b0)\n  Call Trace:\n    resv_map_put+0xe/0x40\n    hugetlb_reserve_pages+0xa6/0x1d0\n    hugetlb_file_setup+0x102/0x2c0\n    newseg+0x115/0x360\n    ipcget+0x1ce/0x310\n    sys_shmget+0x5a/0x60\n    system_call_fastpath+0x16/0x1b\n\nThis was reported by Dave Jones, but was reproducible with the\nlibhugetlbfs test cases, so shame on me for not running them in the\nfirst place.\n\nWith this, the oops is gone, and the output of libhugetlbfs's\nrun_tests.py is identical to plain 3.4 again.\n\n[ Marked for stable, since this was introduced by commit c50ac050811d\n  (\"hugetlb: fix resv_map leak in error path\") which was also marked for\n  stable ]\n\nReported-by: Dave Jones <davej@redhat.com>\nCc: Mel Gorman <mel@csn.ul.ie>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: Christoph Lameter <cl@linux.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: <stable@vger.kernel.org>        [2.6.32+]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/hugetlb.c||mm/hugetlb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ],
          "candidate": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/hugetlb.c||mm/hugetlb.c": [
          "File: mm/hugetlb.c -> mm/hugetlb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3036:   region_add(&inode->i_mapping->private_list, from, to);",
          "3037:  return 0;",
          "3038: out_err:",
          "3040:  return ret;",
          "3041: }",
          "",
          "[Removed Lines]",
          "3039:  resv_map_put(vma);",
          "",
          "[Added Lines]",
          "3039:  if (vma)",
          "3040:   resv_map_put(vma);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-7264",
  "cve_desc": "The l2tp_ip_recvmsg function in net/l2tp/l2tp_ip.c in the Linux kernel before 3.12.4 updates a certain length value before ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel stack memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",
  "repo": "torvalds/linux",
  "patch_hash": "bceaa90240b6019ed73b49965eac7d167610be69",
  "patch_info": {
    "commit_hash": "bceaa90240b6019ed73b49965eac7d167610be69",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69",
    "files": [
      "net/ieee802154/dgram.c",
      "net/ipv4/ping.c",
      "net/ipv4/raw.c",
      "net/ipv4/udp.c",
      "net/ipv6/raw.c",
      "net/ipv6/udp.c",
      "net/l2tp/l2tp_ip.c",
      "net/phonet/datagram.c"
    ],
    "message": "inet: prevent leakage of uninitialized memory to user in recv syscalls\n\nOnly update *addr_len when we actually fill in sockaddr, otherwise we\ncan return uninitialized memory from the stack to the caller in the\nrecvfrom, recvmmsg and recvmsg syscalls. Drop the the (addr_len == NULL)\nchecks because we only get called with a valid addr_len pointer either\nfrom sock_common_recvmsg or inet_recvmsg.\n\nIf a blocking read waits on a socket which is concurrently shut down we\nnow return zero and set msg_msgnamelen to 0.\n\nReported-by: mpb <mpb.mail@gmail.com>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ieee802154/dgram.c||net/ieee802154/dgram.c",
      "net/ipv4/ping.c||net/ipv4/ping.c",
      "net/ipv4/raw.c||net/ipv4/raw.c",
      "net/ipv4/udp.c||net/ipv4/udp.c",
      "net/ipv6/raw.c||net/ipv6/raw.c",
      "net/ipv6/udp.c||net/ipv6/udp.c",
      "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c",
      "net/phonet/datagram.c||net/phonet/datagram.c"
    ]
  },
  "patch_diff": {
    "net/ieee802154/dgram.c||net/ieee802154/dgram.c": [
      "File: net/ieee802154/dgram.c -> net/ieee802154/dgram.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "315:  if (saddr) {",
      "316:   saddr->family = AF_IEEE802154;",
      "317:   saddr->addr = mac_cb(skb)->sa;",
      "322:  if (flags & MSG_TRUNC)",
      "323:   copied = skb->len;",
      "",
      "[Removed Lines]",
      "318:  }",
      "319:  if (addr_len)",
      "",
      "[Added Lines]",
      "319:  }",
      "",
      "---------------"
    ],
    "net/ipv4/ping.c||net/ipv4/ping.c": [
      "File: net/ipv4/ping.c -> net/ipv4/ping.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "830: {",
      "831:  struct inet_sock *isk = inet_sk(sk);",
      "832:  int family = sk->sk_family;",
      "835:  struct sk_buff *skb;",
      "836:  int copied, err;",
      "",
      "[Removed Lines]",
      "833:  struct sockaddr_in *sin;",
      "834:  struct sockaddr_in6 *sin6;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "841:  if (flags & MSG_OOB)",
      "842:   goto out;",
      "851:  if (flags & MSG_ERRQUEUE) {",
      "852:   if (family == AF_INET) {",
      "853:    return ip_recv_error(sk, msg, len);",
      "",
      "[Removed Lines]",
      "844:  if (addr_len) {",
      "845:   if (family == AF_INET)",
      "847:   else if (family == AF_INET6 && addr_len)",
      "849:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "879:  if (family == AF_INET) {",
      "881:   sin->sin_family = AF_INET;",
      "882:   sin->sin_port = 0 /* skb->h.uh->source */;",
      "883:   sin->sin_addr.s_addr = ip_hdr(skb)->saddr;",
      "884:   memset(sin->sin_zero, 0, sizeof(sin->sin_zero));",
      "886:   if (isk->cmsg_flags)",
      "887:    ip_cmsg_recv(msg, skb);",
      "",
      "[Removed Lines]",
      "880:   sin = (struct sockaddr_in *) msg->msg_name;",
      "",
      "[Added Lines]",
      "871:   struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "890:  } else if (family == AF_INET6) {",
      "891:   struct ipv6_pinfo *np = inet6_sk(sk);",
      "892:   struct ipv6hdr *ip6 = ipv6_hdr(skb);",
      "894:   sin6->sin6_family = AF_INET6;",
      "895:   sin6->sin6_port = 0;",
      "896:   sin6->sin6_addr = ip6->saddr;",
      "898:   sin6->sin6_flowinfo = 0;",
      "899:   if (np->sndflow)",
      "900:    sin6->sin6_flowinfo = ip6_flowinfo(ip6);",
      "902:   sin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,",
      "903:          IP6CB(skb)->iif);",
      "905:   if (inet6_sk(sk)->rxopt.all)",
      "906:    pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);",
      "",
      "[Removed Lines]",
      "893:   sin6 = (struct sockaddr_in6 *) msg->msg_name;",
      "",
      "[Added Lines]",
      "886:   struct sockaddr_in6 *sin6 =",
      "887:    (struct sockaddr_in6 *)msg->msg_name;",
      "",
      "---------------"
    ],
    "net/ipv4/raw.c||net/ipv4/raw.c": [
      "File: net/ipv4/raw.c -> net/ipv4/raw.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "696:  if (flags & MSG_OOB)",
      "697:   goto out;",
      "702:  if (flags & MSG_ERRQUEUE) {",
      "703:   err = ip_recv_error(sk, msg, len);",
      "704:   goto out;",
      "",
      "[Removed Lines]",
      "699:  if (addr_len)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/ipv4/udp.c||net/ipv4/udp.c": [
      "File: net/ipv4/udp.c -> net/ipv4/udp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1235:  int is_udplite = IS_UDPLITE(sk);",
      "1236:  bool slow;",
      "1244:  if (flags & MSG_ERRQUEUE)",
      "1245:   return ip_recv_error(sk, msg, len);",
      "",
      "[Removed Lines]",
      "1241:  if (addr_len)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/ipv6/raw.c||net/ipv6/raw.c": [
      "File: net/ipv6/raw.c -> net/ipv6/raw.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "465:  if (flags & MSG_OOB)",
      "466:   return -EOPNOTSUPP;",
      "471:  if (flags & MSG_ERRQUEUE)",
      "472:   return ipv6_recv_error(sk, msg, len);",
      "",
      "[Removed Lines]",
      "468:  if (addr_len)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/ipv6/udp.c||net/ipv6/udp.c": [
      "File: net/ipv6/udp.c -> net/ipv6/udp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "392:  int is_udp4;",
      "393:  bool slow;",
      "398:  if (flags & MSG_ERRQUEUE)",
      "399:   return ipv6_recv_error(sk, msg, len);",
      "",
      "[Removed Lines]",
      "395:  if (addr_len)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c": [
      "File: net/l2tp/l2tp_ip.c -> net/l2tp/l2tp_ip.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "518:  if (flags & MSG_OOB)",
      "519:   goto out;",
      "524:  skb = skb_recv_datagram(sk, flags, noblock, &err);",
      "525:  if (!skb)",
      "526:   goto out;",
      "",
      "[Removed Lines]",
      "521:  if (addr_len)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/phonet/datagram.c||net/phonet/datagram.c": [
      "File: net/phonet/datagram.c -> net/phonet/datagram.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:    MSG_CMSG_COMPAT))",
      "140:   goto out_nofree;",
      "145:  skb = skb_recv_datagram(sk, flags, noblock, &rval);",
      "146:  if (skb == NULL)",
      "147:   goto out_nofree;",
      "",
      "[Removed Lines]",
      "142:  if (addr_len)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "163:  rval = (flags & MSG_TRUNC) ? skb->len : copylen;",
      "168: out:",
      "169:  skb_free_datagram(sk, skb);",
      "",
      "[Removed Lines]",
      "165:  if (msg->msg_name != NULL)",
      "166:   memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));",
      "",
      "[Added Lines]",
      "162:  if (msg->msg_name != NULL) {",
      "163:   memcpy(msg->msg_name, &sa, sizeof(sa));",
      "165:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4330487acfff0cf1d7b14d238583a182e0a444bb",
      "candidate_info": {
        "commit_hash": "4330487acfff0cf1d7b14d238583a182e0a444bb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4330487acfff0cf1d7b14d238583a182e0a444bb",
        "files": [
          "net/ipv4/ping.c",
          "net/ipv6/raw.c",
          "net/ipv6/udp.c",
          "net/l2tp/l2tp_ip6.c"
        ],
        "message": "net: use inet6_iif instead of IP6CB()->iif\n\nSigned-off-by: Duan Jiong <duanj.fnst@cn.fujitsu.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/ping.c||net/ipv4/ping.c",
          "net/ipv6/raw.c||net/ipv6/raw.c",
          "net/ipv6/udp.c||net/ipv6/udp.c",
          "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/ping.c||net/ipv4/ping.c",
            "net/ipv6/raw.c||net/ipv6/raw.c",
            "net/ipv6/udp.c||net/ipv6/udp.c"
          ],
          "candidate": [
            "net/ipv4/ping.c||net/ipv4/ping.c",
            "net/ipv6/raw.c||net/ipv6/raw.c",
            "net/ipv6/udp.c||net/ipv6/udp.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/ping.c||net/ipv4/ping.c": [
          "File: net/ipv4/ping.c -> net/ipv4/ping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "911:     sin6->sin6_flowinfo = ip6_flowinfo(ip6);",
          "912:    sin6->sin6_scope_id =",
          "913:     ipv6_iface_scope_id(&sin6->sin6_addr,",
          "916:   }",
          "",
          "[Removed Lines]",
          "914:           IP6CB(skb)->iif);",
          "",
          "[Added Lines]",
          "914:           inet6_iif(skb));",
          "",
          "---------------"
        ],
        "net/ipv6/raw.c||net/ipv6/raw.c": [
          "File: net/ipv6/raw.c -> net/ipv6/raw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "176:   goto out;",
          "178:  net = dev_net(skb->dev);",
          "181:  while (sk) {",
          "182:   int filtered;",
          "",
          "[Removed Lines]",
          "179:  sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, IP6CB(skb)->iif);",
          "",
          "[Added Lines]",
          "179:  sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, inet6_iif(skb));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:    }",
          "221:   }",
          "222:   sk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr,",
          "224:  }",
          "225: out:",
          "226:  read_unlock(&raw_v6_hashinfo.lock);",
          "",
          "[Removed Lines]",
          "223:          IP6CB(skb)->iif);",
          "",
          "[Added Lines]",
          "223:          inet6_iif(skb));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "375:   net = dev_net(skb->dev);",
          "377:   while ((sk = __raw_v6_lookup(net, sk, nexthdr, saddr, daddr,",
          "379:    rawv6_err(sk, skb, NULL, type, code,",
          "380:      inner_offset, info);",
          "381:    sk = sk_next(sk);",
          "",
          "[Removed Lines]",
          "378:       IP6CB(skb)->iif))) {",
          "",
          "[Added Lines]",
          "378:       inet6_iif(skb)))) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "506:   sin6->sin6_addr = ipv6_hdr(skb)->saddr;",
          "507:   sin6->sin6_flowinfo = 0;",
          "508:   sin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,",
          "511:  }",
          "",
          "[Removed Lines]",
          "509:          IP6CB(skb)->iif);",
          "",
          "[Added Lines]",
          "509:          inet6_iif(skb));",
          "",
          "---------------"
        ],
        "net/ipv6/udp.c||net/ipv6/udp.c": [
          "File: net/ipv6/udp.c -> net/ipv6/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "472:    sin6->sin6_addr = ipv6_hdr(skb)->saddr;",
          "473:    sin6->sin6_scope_id =",
          "474:     ipv6_iface_scope_id(&sin6->sin6_addr,",
          "476:   }",
          "478:  }",
          "",
          "[Removed Lines]",
          "475:           IP6CB(skb)->iif);",
          "",
          "[Added Lines]",
          "475:           inet6_iif(skb));",
          "",
          "---------------"
        ],
        "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c": [
          "File: net/l2tp/l2tp_ip6.c -> net/l2tp/l2tp_ip6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "687:   lsa->l2tp_scope_id = 0;",
          "688:   lsa->l2tp_conn_id = 0;",
          "689:   if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)",
          "691:  }",
          "693:  if (np->rxopt.all)",
          "",
          "[Removed Lines]",
          "690:    lsa->l2tp_scope_id = IP6CB(skb)->iif;",
          "",
          "[Added Lines]",
          "690:    lsa->l2tp_scope_id = inet6_iif(skb);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cf970c002d270c36202bd5b9c2804d3097a52da0",
      "candidate_info": {
        "commit_hash": "cf970c002d270c36202bd5b9c2804d3097a52da0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cf970c002d270c36202bd5b9c2804d3097a52da0",
        "files": [
          "net/ipv4/ping.c"
        ],
        "message": "ping: prevent NULL pointer dereference on write to msg_name\n\nA plain read() on a socket does set msg->msg_name to NULL. So check for\nNULL pointer first.\n\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/ping.c||net/ipv4/ping.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/ping.c||net/ipv4/ping.c"
          ],
          "candidate": [
            "net/ipv4/ping.c||net/ipv4/ping.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/ping.c||net/ipv4/ping.c": [
          "File: net/ipv4/ping.c -> net/ipv4/ping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "870:  if (family == AF_INET) {",
          "871:   struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;",
          "879:   if (isk->cmsg_flags)",
          "880:    ip_cmsg_recv(msg, skb);",
          "",
          "[Removed Lines]",
          "873:   sin->sin_family = AF_INET;",
          "874:   sin->sin_port = 0 /* skb->h.uh->source */;",
          "875:   sin->sin_addr.s_addr = ip_hdr(skb)->saddr;",
          "876:   memset(sin->sin_zero, 0, sizeof(sin->sin_zero));",
          "",
          "[Added Lines]",
          "873:   if (sin) {",
          "874:    sin->sin_family = AF_INET;",
          "875:    sin->sin_port = 0 /* skb->h.uh->source */;",
          "876:    sin->sin_addr.s_addr = ip_hdr(skb)->saddr;",
          "877:    memset(sin->sin_zero, 0, sizeof(sin->sin_zero));",
          "879:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "886:   struct sockaddr_in6 *sin6 =",
          "887:    (struct sockaddr_in6 *)msg->msg_name;",
          "900:   if (inet6_sk(sk)->rxopt.all)",
          "901:    pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);",
          "",
          "[Removed Lines]",
          "889:   sin6->sin6_family = AF_INET6;",
          "890:   sin6->sin6_port = 0;",
          "891:   sin6->sin6_addr = ip6->saddr;",
          "892:   sin6->sin6_flowinfo = 0;",
          "893:   if (np->sndflow)",
          "894:    sin6->sin6_flowinfo = ip6_flowinfo(ip6);",
          "896:   sin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,",
          "897:          IP6CB(skb)->iif);",
          "",
          "[Added Lines]",
          "891:   if (sin6) {",
          "892:    sin6->sin6_family = AF_INET6;",
          "893:    sin6->sin6_port = 0;",
          "894:    sin6->sin6_addr = ip6->saddr;",
          "895:    sin6->sin6_flowinfo = 0;",
          "896:    if (np->sndflow)",
          "897:     sin6->sin6_flowinfo = ip6_flowinfo(ip6);",
          "898:    sin6->sin6_scope_id =",
          "899:     ipv6_iface_scope_id(&sin6->sin6_addr,",
          "900:           IP6CB(skb)->iif);",
          "902:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d0bfe22611602f36617bc7aa2ffa1bbb2f54c67",
      "candidate_info": {
        "commit_hash": "6d0bfe22611602f36617bc7aa2ffa1bbb2f54c67",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6d0bfe22611602f36617bc7aa2ffa1bbb2f54c67",
        "files": [
          "include/net/ipv6.h",
          "include/net/ping.h",
          "include/net/transp_v6.h",
          "net/ipv4/icmp.c",
          "net/ipv4/ping.c",
          "net/ipv6/Makefile",
          "net/ipv6/af_inet6.c",
          "net/ipv6/icmp.c",
          "net/ipv6/ping.c"
        ],
        "message": "net: ipv6: Add IPv6 support to the ping socket.\n\nThis adds the ability to send ICMPv6 echo requests without a\nraw socket. The equivalent ability for ICMPv4 was added in\n2011.\n\nInstead of having separate code paths for IPv4 and IPv6, make\nmost of the code in net/ipv4/ping.c dual-stack and only add a\nfew IPv6-specific bits (like the protocol definition) to a new\nnet/ipv6/ping.c. Hopefully this will reduce divergence and/or\nduplication of bugs in the future.\n\nCaveats:\n\n- Setting options via ancillary data (e.g., using IPV6_PKTINFO\n  to specify the outgoing interface) is not yet supported.\n- There are no separate security settings for IPv4 and IPv6;\n  everything is controlled by /proc/net/ipv4/ping_group_range.\n- The proc interface does not yet display IPv6 ping sockets\n  properly.\n\nTested with a patched copy of ping6 and using raw socket calls.\nCompiles and works with all of CONFIG_IPV6={n,m,y}.\n\nSigned-off-by: Lorenzo Colitti <lorenzo@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ipv6.h||include/net/ipv6.h",
          "include/net/ping.h||include/net/ping.h",
          "include/net/transp_v6.h||include/net/transp_v6.h",
          "net/ipv4/icmp.c||net/ipv4/icmp.c",
          "net/ipv4/ping.c||net/ipv4/ping.c",
          "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c",
          "net/ipv6/icmp.c||net/ipv6/icmp.c",
          "net/ipv6/ping.c||net/ipv6/ping.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/ping.c||net/ipv4/ping.c"
          ],
          "candidate": [
            "net/ipv4/ping.c||net/ipv4/ping.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ipv6.h||include/net/ipv6.h": [
          "File: include/net/ipv6.h -> include/net/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "261: extern void icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info);",
          "263: extern int    ip6_ra_control(struct sock *sk, int sel);",
          "265: extern int   ipv6_parse_hopopts(struct sk_buff *skb);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "263: int icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,",
          "264:           struct icmp6hdr *thdr, int len);",
          "266: struct dst_entry *icmpv6_route_lookup(struct net *net, struct sk_buff *skb,",
          "267:           struct sock *sk, struct flowi6 *fl6);",
          "",
          "---------------"
        ],
        "include/net/ping.h||include/net/ping.h": [
          "File: include/net/ping.h -> include/net/ping.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #ifndef _PING_H",
          "14: #define _PING_H",
          "16: #include <net/netns/hash.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <net/icmp.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #define GID_T_MAX (((gid_t)~0U) >> 1)",
          "31: struct ping_table {",
          "32:  struct hlist_nulls_head hash[PING_HTABLE_SIZE];",
          "33:  rwlock_t  lock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: struct pingv6_ops {",
          "34:  int (*ipv6_recv_error)(struct sock *sk, struct msghdr *msg, int len);",
          "35:  int (*ip6_datagram_recv_ctl)(struct sock *sk, struct msghdr *msg,",
          "36:          struct sk_buff *skb);",
          "37:  int (*icmpv6_err_convert)(u8 type, u8 code, int *err);",
          "38:  void (*ipv6_icmp_error)(struct sock *sk, struct sk_buff *skb, int err,",
          "39:     __be16 port, u32 info, u8 *payload);",
          "40:  int (*ipv6_chk_addr)(struct net *net, const struct in6_addr *addr,",
          "41:         struct net_device *dev, int strict);",
          "42: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "39: };",
          "41: extern struct proto ping_prot;",
          "47: #ifdef CONFIG_PROC_FS",
          "48: extern int __init ping_proc_init(void);",
          "",
          "[Removed Lines]",
          "44: extern void ping_rcv(struct sk_buff *);",
          "45: extern void ping_err(struct sk_buff *, u32 info);",
          "",
          "[Added Lines]",
          "55: extern struct ping_table ping_table;",
          "56: #if IS_ENABLED(CONFIG_IPV6)",
          "57: extern struct pingv6_ops pingv6_ops;",
          "58: #endif",
          "60: struct pingfakehdr {",
          "61:  struct icmphdr icmph;",
          "62:  struct iovec *iov;",
          "63:  sa_family_t family;",
          "64:  __wsum wcheck;",
          "65: };",
          "67: int  ping_get_port(struct sock *sk, unsigned short ident);",
          "68: void ping_hash(struct sock *sk);",
          "69: void ping_unhash(struct sock *sk);",
          "71: int  ping_init_sock(struct sock *sk);",
          "72: void ping_close(struct sock *sk, long timeout);",
          "73: int  ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len);",
          "74: void ping_err(struct sk_buff *skb, int offset, u32 info);",
          "75: int  ping_getfrag(void *from, char *to, int offset, int fraglen, int odd,",
          "76:     struct sk_buff *);",
          "78: int  ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "79:     size_t len, int noblock, int flags, int *addr_len);",
          "80: int  ping_common_sendmsg(int family, struct msghdr *msg, size_t len,",
          "81:     void *user_icmph, size_t icmph_len);",
          "82: int  ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "83:        size_t len);",
          "84: int  ping_v6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "85:        size_t len);",
          "86: int  ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);",
          "87: void ping_rcv(struct sk_buff *skb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "50: #endif",
          "52: void __init ping_init(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: int  __init pingv6_init(void);",
          "96: void pingv6_exit(void);",
          "",
          "---------------"
        ],
        "include/net/transp_v6.h||include/net/transp_v6.h": [
          "File: include/net/transp_v6.h -> include/net/transp_v6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: extern struct proto udpv6_prot;",
          "12: extern struct proto udplitev6_prot;",
          "13: extern struct proto tcpv6_prot;",
          "15: struct flowi6;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: extern struct proto pingv6_prot;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "21: extern void    ipv6_frag_exit(void);",
          "24: extern int    rawv6_init(void);",
          "25: extern void    rawv6_exit(void);",
          "26: extern int    udpv6_init(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: extern int    pingv6_init(void);",
          "26: extern void    pingv6_exit(void);",
          "",
          "---------------"
        ],
        "net/ipv4/icmp.c||net/ipv4/icmp.c": [
          "File: net/ipv4/icmp.c -> net/ipv4/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "939: void icmp_err(struct sk_buff *skb, u32 info)",
          "940: {",
          "941:  struct iphdr *iph = (struct iphdr *)skb->data;",
          "943:  int type = icmp_hdr(skb)->type;",
          "944:  int code = icmp_hdr(skb)->code;",
          "945:  struct net *net = dev_net(skb->dev);",
          "",
          "[Removed Lines]",
          "942:  struct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));",
          "",
          "[Added Lines]",
          "942:  int offset = iph->ihl<<2;",
          "943:  struct icmphdr *icmph = (struct icmphdr *)(skb->data + offset);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "951:  if (icmph->type != ICMP_ECHOREPLY) {",
          "953:   return;",
          "954:  }",
          "",
          "[Removed Lines]",
          "952:   ping_err(skb, info);",
          "",
          "[Added Lines]",
          "953:   ping_err(skb, offset, info);",
          "",
          "---------------"
        ],
        "net/ipv4/ping.c||net/ipv4/ping.c": [
          "File: net/ipv4/ping.c -> net/ipv4/ping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include <linux/netdevice.h>",
          "34: #include <net/snmp.h>",
          "35: #include <net/ip.h>",
          "37: #include <net/icmp.h>",
          "38: #include <net/protocol.h>",
          "39: #include <linux/skbuff.h>",
          "",
          "[Removed Lines]",
          "36: #include <net/ipv6.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46: #include <net/inet_common.h>",
          "47: #include <net/checksum.h>",
          "52: static u16 ping_port_rover;",
          "",
          "[Removed Lines]",
          "50: static struct ping_table ping_table;",
          "",
          "[Added Lines]",
          "48: #if IS_ENABLED(CONFIG_IPV6)",
          "49: #include <linux/in6.h>",
          "50: #include <linux/icmpv6.h>",
          "51: #include <net/addrconf.h>",
          "52: #include <net/ipv6.h>",
          "53: #include <net/transp_v6.h>",
          "54: #endif",
          "57: struct ping_table ping_table;",
          "58: struct pingv6_ops pingv6_ops;",
          "59: EXPORT_SYMBOL_GPL(pingv6_ops);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "58:  pr_debug(\"hash(%d) = %d\\n\", num, res);",
          "59:  return res;",
          "60: }",
          "62: static inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,",
          "63:           struct net *net, unsigned int num)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: EXPORT_SYMBOL_GPL(ping_hash);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "65:  return &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];",
          "66: }",
          "69: {",
          "70:  struct hlist_nulls_node *node;",
          "71:  struct hlist_nulls_head *hlist;",
          "",
          "[Removed Lines]",
          "68: static int ping_v4_get_port(struct sock *sk, unsigned short ident)",
          "",
          "[Added Lines]",
          "78: int ping_get_port(struct sock *sk, unsigned short ident)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "125:  write_unlock_bh(&ping_table.lock);",
          "126:  return 1;",
          "127: }",
          "130: {",
          "133: }",
          "136: {",
          "137:  struct inet_sock *isk = inet_sk(sk);",
          "139:  if (sk_hashed(sk)) {",
          "140:   write_lock_bh(&ping_table.lock);",
          "141:   hlist_nulls_del(&sk->sk_nulls_node);",
          "",
          "[Removed Lines]",
          "129: static void ping_v4_hash(struct sock *sk)",
          "131:  pr_debug(\"ping_v4_hash(sk->port=%u)\\n\", inet_sk(sk)->inet_num);",
          "135: static void ping_v4_unhash(struct sock *sk)",
          "138:  pr_debug(\"ping_v4_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);",
          "",
          "[Added Lines]",
          "142: EXPORT_SYMBOL_GPL(ping_get_port);",
          "144: void ping_hash(struct sock *sk)",
          "146:  pr_debug(\"ping_hash(sk->port=%u)\\n\", inet_sk(sk)->inet_num);",
          "150: void ping_unhash(struct sock *sk)",
          "153:  pr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "146:   write_unlock_bh(&ping_table.lock);",
          "147:  }",
          "148: }",
          "152: {",
          "153:  struct hlist_nulls_head *hslot = ping_hashslot(&ping_table, net, ident);",
          "154:  struct sock *sk = NULL;",
          "155:  struct inet_sock *isk;",
          "156:  struct hlist_nulls_node *hnode;",
          "160:  read_lock_bh(&ping_table.lock);",
          "162:  ping_portaddr_for_each_entry(sk, hnode, hslot) {",
          "163:   isk = inet_sk(sk);",
          "169:   pr_debug(\"iterate\\n\");",
          "170:   if (isk->inet_num != ident)",
          "171:    continue;",
          "174:   if (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)",
          "175:    continue;",
          "",
          "[Removed Lines]",
          "150: static struct sock *ping_v4_lookup(struct net *net, __be32 saddr, __be32 daddr,",
          "151:        u16 ident, int dif)",
          "158:  pr_debug(\"try to find: num = %d, daddr = %pI4, dif = %d\\n\",",
          "159:    (int)ident, &daddr, dif);",
          "165:   pr_debug(\"found: %p: num = %d, daddr = %pI4, dif = %d\\n\", sk,",
          "166:     (int)isk->inet_num, &isk->inet_rcv_saddr,",
          "167:     sk->sk_bound_dev_if);",
          "172:   if (isk->inet_rcv_saddr && isk->inet_rcv_saddr != daddr)",
          "173:    continue;",
          "",
          "[Added Lines]",
          "164: EXPORT_SYMBOL_GPL(ping_unhash);",
          "166: static struct sock *ping_lookup(struct net *net, struct sk_buff *skb, u16 ident)",
          "172:  int dif = skb->dev->ifindex;",
          "174:  if (skb->protocol == htons(ETH_P_IP)) {",
          "175:   pr_debug(\"try to find: num = %d, daddr = %pI4, dif = %d\\n\",",
          "176:     (int)ident, &ip_hdr(skb)->daddr, dif);",
          "177: #if IS_ENABLED(CONFIG_IPV6)",
          "178:  } else if (skb->protocol == htons(ETH_P_IPV6)) {",
          "179:   pr_debug(\"try to find: num = %d, daddr = %pI6c, dif = %d\\n\",",
          "180:     (int)ident, &ipv6_hdr(skb)->daddr, dif);",
          "181: #endif",
          "182:  }",
          "193:   if (skb->protocol == htons(ETH_P_IP) &&",
          "194:       sk->sk_family == AF_INET) {",
          "195:    pr_debug(\"found: %p: num=%d, daddr=%pI4, dif=%d\\n\", sk,",
          "196:      (int) isk->inet_num, &isk->inet_rcv_saddr,",
          "197:      sk->sk_bound_dev_if);",
          "199:    if (isk->inet_rcv_saddr &&",
          "200:        isk->inet_rcv_saddr != ip_hdr(skb)->daddr)",
          "201:     continue;",
          "202: #if IS_ENABLED(CONFIG_IPV6)",
          "203:   } else if (skb->protocol == htons(ETH_P_IPV6) &&",
          "204:       sk->sk_family == AF_INET6) {",
          "205:    struct ipv6_pinfo *np = inet6_sk(sk);",
          "207:    pr_debug(\"found: %p: num=%d, daddr=%pI6c, dif=%d\\n\", sk,",
          "208:      (int) isk->inet_num,",
          "209:      &inet6_sk(sk)->rcv_saddr,",
          "210:      sk->sk_bound_dev_if);",
          "212:    if (!ipv6_addr_any(&np->rcv_saddr) &&",
          "213:        !ipv6_addr_equal(&np->rcv_saddr,",
          "214:           &ipv6_hdr(skb)->daddr))",
          "215:     continue;",
          "216: #endif",
          "217:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "200: }",
          "204: {",
          "205:  struct net *net = sock_net(sk);",
          "206:  kgid_t group = current_egid();",
          "",
          "[Removed Lines]",
          "203: static int ping_init_sock(struct sock *sk)",
          "",
          "[Added Lines]",
          "248: int ping_init_sock(struct sock *sk)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "226:  return -EACCES;",
          "227: }",
          "230: {",
          "231:  pr_debug(\"ping_close(sk=%p,sk->num=%u)\\n\",",
          "232:    inet_sk(sk), inet_sk(sk)->inet_num);",
          "",
          "[Removed Lines]",
          "229: static void ping_close(struct sock *sk, long timeout)",
          "",
          "[Added Lines]",
          "273: EXPORT_SYMBOL_GPL(ping_init_sock);",
          "275: void ping_close(struct sock *sk, long timeout)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "235:  sk_common_release(sk);",
          "236: }",
          "244: {",
          "246:  struct inet_sock *isk = inet_sk(sk);",
          "247:  unsigned short snum;",
          "249:  int err;",
          "268:  lock_sock(sk);",
          "",
          "[Removed Lines]",
          "243: static int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)",
          "245:  struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;",
          "248:  int chk_addr_ret;",
          "251:  if (addr_len < sizeof(struct sockaddr_in))",
          "252:   return -EINVAL;",
          "254:  pr_debug(\"ping_v4_bind(sk=%p,sa_addr=%08x,sa_port=%d)\\n\",",
          "255:    sk, addr->sin_addr.s_addr, ntohs(addr->sin_port));",
          "257:  chk_addr_ret = inet_addr_type(sock_net(sk), addr->sin_addr.s_addr);",
          "258:  if (addr->sin_addr.s_addr == htonl(INADDR_ANY))",
          "259:   chk_addr_ret = RTN_LOCAL;",
          "261:  if ((sysctl_ip_nonlocal_bind == 0 &&",
          "262:      isk->freebind == 0 && isk->transparent == 0 &&",
          "263:       chk_addr_ret != RTN_LOCAL) ||",
          "264:      chk_addr_ret == RTN_MULTICAST ||",
          "265:      chk_addr_ret == RTN_BROADCAST)",
          "266:   return -EADDRNOTAVAIL;",
          "",
          "[Added Lines]",
          "283: EXPORT_SYMBOL_GPL(ping_close);",
          "286: int ping_check_bind_addr(struct sock *sk, struct inet_sock *isk,",
          "287:     struct sockaddr *uaddr, int addr_len) {",
          "288:  struct net *net = sock_net(sk);",
          "289:  if (sk->sk_family == AF_INET) {",
          "290:   struct sockaddr_in *addr = (struct sockaddr_in *) uaddr;",
          "291:   int chk_addr_ret;",
          "293:   if (addr_len < sizeof(*addr))",
          "294:    return -EINVAL;",
          "296:   pr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI4,port=%d)\\n\",",
          "297:     sk, &addr->sin_addr.s_addr, ntohs(addr->sin_port));",
          "299:   chk_addr_ret = inet_addr_type(net, addr->sin_addr.s_addr);",
          "301:   if (addr->sin_addr.s_addr == htonl(INADDR_ANY))",
          "302:    chk_addr_ret = RTN_LOCAL;",
          "304:   if ((sysctl_ip_nonlocal_bind == 0 &&",
          "305:       isk->freebind == 0 && isk->transparent == 0 &&",
          "306:        chk_addr_ret != RTN_LOCAL) ||",
          "307:       chk_addr_ret == RTN_MULTICAST ||",
          "308:       chk_addr_ret == RTN_BROADCAST)",
          "309:    return -EADDRNOTAVAIL;",
          "311: #if IS_ENABLED(CONFIG_IPV6)",
          "312:  } else if (sk->sk_family == AF_INET6) {",
          "313:   struct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;",
          "314:   int addr_type, scoped, has_addr;",
          "315:   struct net_device *dev = NULL;",
          "317:   if (addr_len < sizeof(*addr))",
          "318:    return -EINVAL;",
          "320:   pr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI6c,port=%d)\\n\",",
          "321:     sk, addr->sin6_addr.s6_addr, ntohs(addr->sin6_port));",
          "323:   addr_type = ipv6_addr_type(&addr->sin6_addr);",
          "324:   scoped = __ipv6_addr_needs_scope_id(addr_type);",
          "325:   if ((addr_type != IPV6_ADDR_ANY &&",
          "326:        !(addr_type & IPV6_ADDR_UNICAST)) ||",
          "327:       (scoped && !addr->sin6_scope_id))",
          "328:    return -EINVAL;",
          "330:   rcu_read_lock();",
          "331:   if (addr->sin6_scope_id) {",
          "332:    dev = dev_get_by_index_rcu(net, addr->sin6_scope_id);",
          "333:    if (!dev) {",
          "334:     rcu_read_unlock();",
          "335:     return -ENODEV;",
          "336:    }",
          "337:   }",
          "338:   has_addr = pingv6_ops.ipv6_chk_addr(net, &addr->sin6_addr, dev,",
          "339:           scoped);",
          "340:   rcu_read_unlock();",
          "342:   if (!(isk->freebind || isk->transparent || has_addr ||",
          "343:         addr_type == IPV6_ADDR_ANY))",
          "344:    return -EADDRNOTAVAIL;",
          "346:   if (scoped)",
          "347:    sk->sk_bound_dev_if = addr->sin6_scope_id;",
          "348: #endif",
          "349:  } else {",
          "350:   return -EAFNOSUPPORT;",
          "351:  }",
          "352:  return 0;",
          "353: }",
          "355: void ping_set_saddr(struct sock *sk, struct sockaddr *saddr)",
          "356: {",
          "357:  if (saddr->sa_family == AF_INET) {",
          "358:   struct inet_sock *isk = inet_sk(sk);",
          "359:   struct sockaddr_in *addr = (struct sockaddr_in *) saddr;",
          "360:   isk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;",
          "361: #if IS_ENABLED(CONFIG_IPV6)",
          "362:  } else if (saddr->sa_family == AF_INET6) {",
          "363:   struct sockaddr_in6 *addr = (struct sockaddr_in6 *) saddr;",
          "364:   struct ipv6_pinfo *np = inet6_sk(sk);",
          "365:   np->rcv_saddr = np->saddr = addr->sin6_addr;",
          "366: #endif",
          "367:  }",
          "368: }",
          "370: void ping_clear_saddr(struct sock *sk, int dif)",
          "371: {",
          "372:  sk->sk_bound_dev_if = dif;",
          "373:  if (sk->sk_family == AF_INET) {",
          "374:   struct inet_sock *isk = inet_sk(sk);",
          "375:   isk->inet_rcv_saddr = isk->inet_saddr = 0;",
          "376: #if IS_ENABLED(CONFIG_IPV6)",
          "377:  } else if (sk->sk_family == AF_INET6) {",
          "378:   struct ipv6_pinfo *np = inet6_sk(sk);",
          "379:   memset(&np->rcv_saddr, 0, sizeof(np->rcv_saddr));",
          "380:   memset(&np->saddr, 0, sizeof(np->saddr));",
          "381: #endif",
          "382:  }",
          "383: }",
          "389: int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)",
          "394:  int dif = sk->sk_bound_dev_if;",
          "396:  err = ping_check_bind_addr(sk, isk, uaddr, addr_len);",
          "397:  if (err)",
          "398:   return err;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "272:   goto out;",
          "274:  err = -EADDRINUSE;",
          "279:   goto out;",
          "280:  }",
          "283:    (int)isk->inet_num,",
          "285:    (int)sk->sk_bound_dev_if);",
          "287:  err = 0;",
          "289:   sk->sk_userlocks |= SOCK_BINDADDR_LOCK;",
          "290:  if (snum)",
          "291:   sk->sk_userlocks |= SOCK_BINDPORT_LOCK;",
          "292:  isk->inet_sport = htons(isk->inet_num);",
          "293:  isk->inet_daddr = 0;",
          "294:  isk->inet_dport = 0;",
          "295:  sk_dst_reset(sk);",
          "296: out:",
          "297:  release_sock(sk);",
          "298:  pr_debug(\"ping_v4_bind -> %d\\n\", err);",
          "299:  return err;",
          "300: }",
          "307: {",
          "311: }",
          "",
          "[Removed Lines]",
          "275:  isk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;",
          "276:  snum = ntohs(addr->sin_port);",
          "277:  if (ping_v4_get_port(sk, snum) != 0) {",
          "278:   isk->inet_saddr = isk->inet_rcv_saddr = 0;",
          "282:  pr_debug(\"after bind(): num = %d, daddr = %pI4, dif = %d\\n\",",
          "284:    &isk->inet_rcv_saddr,",
          "288:  if (isk->inet_rcv_saddr)",
          "306: static inline int ping_supported(int type, int code)",
          "308:  if (type == ICMP_ECHO && code == 0)",
          "309:   return 1;",
          "310:  return 0;",
          "",
          "[Added Lines]",
          "407:  ping_set_saddr(sk, uaddr);",
          "408:  snum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);",
          "409:  if (ping_get_port(sk, snum) != 0) {",
          "410:   ping_clear_saddr(sk, dif);",
          "414:  pr_debug(\"after bind(): num = %d, dif = %d\\n\",",
          "419:  if ((sk->sk_family == AF_INET && isk->inet_rcv_saddr) ||",
          "420:      (sk->sk_family == AF_INET6 &&",
          "421:       !ipv6_addr_any(&inet6_sk(sk)->rcv_saddr)))",
          "430: #if IS_ENABLED(CONFIG_IPV6)",
          "431:  if (sk->sk_family == AF_INET6)",
          "432:   memset(&inet6_sk(sk)->daddr, 0, sizeof(inet6_sk(sk)->daddr));",
          "433: #endif",
          "441: EXPORT_SYMBOL_GPL(ping_bind);",
          "447: static inline int ping_supported(int family, int type, int code)",
          "449:  return (family == AF_INET && type == ICMP_ECHO && code == 0) ||",
          "450:         (family == AF_INET6 && type == ICMPV6_ECHO_REQUEST && code == 0);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "321: {",
          "324:  struct inet_sock *inet_sock;",
          "327:  struct net *net = dev_net(skb->dev);",
          "328:  struct sock *sk;",
          "329:  int harderr;",
          "330:  int err;",
          "335:   return;",
          "342:  if (sk == NULL) {",
          "343:   pr_debug(\"no socket, dropping\\n\");",
          "",
          "[Removed Lines]",
          "318: static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);",
          "320: void ping_err(struct sk_buff *skb, u32 info)",
          "322:  struct iphdr *iph = (struct iphdr *)skb->data;",
          "323:  struct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));",
          "325:  int type = icmp_hdr(skb)->type;",
          "326:  int code = icmp_hdr(skb)->code;",
          "334:  if (!ping_supported(icmph->type, icmph->code))",
          "337:  pr_debug(\"ping_err(type=%04x,code=%04x,id=%04x,seq=%04x)\\n\", type,",
          "338:    code, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));",
          "340:  sk = ping_v4_lookup(net, iph->daddr, iph->saddr,",
          "341:        ntohs(icmph->un.echo.id), skb->dev->ifindex);",
          "",
          "[Added Lines]",
          "458: void ping_err(struct sk_buff *skb, int offset, u32 info)",
          "460:  int family;",
          "461:  struct icmphdr *icmph;",
          "463:  int type;",
          "464:  int code;",
          "470:  if (skb->protocol == htons(ETH_P_IP)) {",
          "471:   family = AF_INET;",
          "472:   type = icmp_hdr(skb)->type;",
          "473:   code = icmp_hdr(skb)->code;",
          "474:   icmph = (struct icmphdr *)(skb->data + offset);",
          "475:  } else if (skb->protocol == htons(ETH_P_IPV6)) {",
          "476:   family = AF_INET6;",
          "477:   type = icmp6_hdr(skb)->icmp6_type;",
          "478:   code = icmp6_hdr(skb)->icmp6_code;",
          "479:   icmph = (struct icmphdr *) (skb->data + offset);",
          "480:  } else {",
          "481:   BUG();",
          "482:  }",
          "486:  if (!ping_supported(family, icmph->type, icmph->code))",
          "489:  pr_debug(\"ping_err(proto=0x%x,type=%d,code=%d,id=%04x,seq=%04x)\\n\",",
          "490:    skb->protocol, type, code, ntohs(icmph->un.echo.id),",
          "491:    ntohs(icmph->un.echo.sequence));",
          "493:  sk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "349:  harderr = 0;",
          "350:  inet_sock = inet_sk(sk);",
          "373:    }",
          "380:   }",
          "387:  }",
          "394:   if (!harderr || sk->sk_state != TCP_ESTABLISHED)",
          "395:    goto out;",
          "396:  } else {",
          "399:  }",
          "400:  sk->sk_err = err;",
          "401:  sk->sk_error_report(sk);",
          "402: out:",
          "403:  sock_put(sk);",
          "404: }",
          "418: {",
          "419:  struct pingfakehdr *pfh = (struct pingfakehdr *)from;",
          "",
          "[Removed Lines]",
          "352:  switch (type) {",
          "353:  default:",
          "354:  case ICMP_TIME_EXCEEDED:",
          "355:   err = EHOSTUNREACH;",
          "356:   break;",
          "357:  case ICMP_SOURCE_QUENCH:",
          "360:   err = EREMOTEIO;",
          "361:   break;",
          "362:  case ICMP_PARAMETERPROB:",
          "363:   err = EPROTO;",
          "364:   harderr = 1;",
          "365:   break;",
          "366:  case ICMP_DEST_UNREACH:",
          "368:    ipv4_sk_update_pmtu(skb, sk, info);",
          "369:    if (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {",
          "370:     err = EMSGSIZE;",
          "371:     harderr = 1;",
          "372:     break;",
          "374:    goto out;",
          "375:   }",
          "376:   err = EHOSTUNREACH;",
          "377:   if (code <= NR_ICMP_UNREACH) {",
          "378:    harderr = icmp_err_convert[code].fatal;",
          "379:    err = icmp_err_convert[code].errno;",
          "381:   break;",
          "382:  case ICMP_REDIRECT:",
          "384:   ipv4_sk_redirect(skb, sk);",
          "385:   err = EREMOTEIO;",
          "386:   break;",
          "393:  if (!inet_sock->recverr) {",
          "397:   ip_icmp_error(sk, skb, err, 0 /* no remote port */,",
          "398:     info, (u8 *)icmph);",
          "410: struct pingfakehdr {",
          "411:  struct icmphdr icmph;",
          "412:  struct iovec *iov;",
          "413:  __wsum wcheck;",
          "414: };",
          "416: static int ping_getfrag(void *from, char *to,",
          "417:    int offset, int fraglen, int odd, struct sk_buff *skb)",
          "",
          "[Added Lines]",
          "504:  if (skb->protocol == htons(ETH_P_IP)) {",
          "505:   switch (type) {",
          "506:   default:",
          "507:   case ICMP_TIME_EXCEEDED:",
          "508:    err = EHOSTUNREACH;",
          "509:    break;",
          "510:   case ICMP_SOURCE_QUENCH:",
          "514:    err = EREMOTEIO;",
          "515:    break;",
          "516:   case ICMP_PARAMETERPROB:",
          "517:    err = EPROTO;",
          "518:    harderr = 1;",
          "519:    break;",
          "520:   case ICMP_DEST_UNREACH:",
          "522:     ipv4_sk_update_pmtu(skb, sk, info);",
          "523:     if (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {",
          "524:      err = EMSGSIZE;",
          "525:      harderr = 1;",
          "526:      break;",
          "527:     }",
          "528:     goto out;",
          "530:    err = EHOSTUNREACH;",
          "531:    if (code <= NR_ICMP_UNREACH) {",
          "532:     harderr = icmp_err_convert[code].fatal;",
          "533:     err = icmp_err_convert[code].errno;",
          "534:    }",
          "535:    break;",
          "536:   case ICMP_REDIRECT:",
          "538:    ipv4_sk_redirect(skb, sk);",
          "539:    err = EREMOTEIO;",
          "540:    break;",
          "542: #if IS_ENABLED(CONFIG_IPV6)",
          "543:  } else if (skb->protocol == htons(ETH_P_IPV6)) {",
          "544:   harderr = pingv6_ops.icmpv6_err_convert(type, code, &err);",
          "545: #endif",
          "552:  if ((family == AF_INET && !inet_sock->recverr) ||",
          "553:      (family == AF_INET6 && !inet6_sk(sk)->recverr)) {",
          "557:   if (family == AF_INET) {",
          "558:    ip_icmp_error(sk, skb, err, 0 /* no remote port */,",
          "559:           info, (u8 *)icmph);",
          "560: #if IS_ENABLED(CONFIG_IPV6)",
          "561:   } else if (family == AF_INET6) {",
          "562:    pingv6_ops.ipv6_icmp_error(sk, skb, err, 0,",
          "563:          info, (u8 *)icmph);",
          "564: #endif",
          "565:   }",
          "572: EXPORT_SYMBOL_GPL(ping_err);",
          "579: int ping_getfrag(void *from, char *to,",
          "580:    int offset, int fraglen, int odd, struct sk_buff *skb)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "425:        pfh->iov, 0, fraglen - sizeof(struct icmphdr),",
          "426:        &pfh->wcheck))",
          "427:    return -EFAULT;",
          "430:  }",
          "437:  return 0;",
          "438: }",
          "442: {",
          "443:  struct sk_buff *skb = skb_peek(&sk->sk_write_queue);",
          "",
          "[Removed Lines]",
          "429:   return 0;",
          "431:  if (offset < sizeof(struct icmphdr))",
          "432:   BUG();",
          "433:  if (csum_partial_copy_fromiovecend",
          "434:    (to, pfh->iov, offset - sizeof(struct icmphdr),",
          "435:     fraglen, &pfh->wcheck))",
          "436:   return -EFAULT;",
          "440: static int ping_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,",
          "441:         struct flowi4 *fl4)",
          "",
          "[Added Lines]",
          "591:  } else if (offset < sizeof(struct icmphdr)) {",
          "592:    BUG();",
          "593:  } else {",
          "594:   if (csum_partial_copy_fromiovecend",
          "595:     (to, pfh->iov, offset - sizeof(struct icmphdr),",
          "596:      fraglen, &pfh->wcheck))",
          "597:    return -EFAULT;",
          "598:  }",
          "600: #if IS_ENABLED(CONFIG_IPV6)",
          "605:  if (pfh->family == AF_INET6) {",
          "606:   skb->csum = pfh->wcheck;",
          "607:   skb->ip_summed = CHECKSUM_NONE;",
          "608:   pfh->wcheck = 0;",
          "610: #endif",
          "614: EXPORT_SYMBOL_GPL(ping_getfrag);",
          "616: static int ping_v4_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,",
          "617:            struct flowi4 *fl4)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "450:  return ip_push_pending_frames(sk, fl4);",
          "451: }",
          "472:  if (len > 0xFFFF)",
          "473:   return -EMSGSIZE;",
          "",
          "[Removed Lines]",
          "453: static int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "454:    size_t len)",
          "455: {",
          "456:  struct net *net = sock_net(sk);",
          "457:  struct flowi4 fl4;",
          "458:  struct inet_sock *inet = inet_sk(sk);",
          "459:  struct ipcm_cookie ipc;",
          "460:  struct icmphdr user_icmph;",
          "461:  struct pingfakehdr pfh;",
          "462:  struct rtable *rt = NULL;",
          "463:  struct ip_options_data opt_copy;",
          "464:  int free = 0;",
          "465:  __be32 saddr, daddr, faddr;",
          "466:  u8  tos;",
          "467:  int err;",
          "469:  pr_debug(\"ping_sendmsg(sk=%p,sk->num=%u)\\n\", inet, inet->inet_num);",
          "",
          "[Added Lines]",
          "629: int ping_common_sendmsg(int family, struct msghdr *msg, size_t len,",
          "630:    void *user_icmph, size_t icmph_len) {",
          "631:  u8 type, code;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "490:   return -EFAULT;",
          "492:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "488:  if (memcpy_fromiovec((u8 *)&user_icmph, msg->msg_iov,",
          "489:         sizeof(struct icmphdr)))",
          "491:  if (!ping_supported(user_icmph.type, user_icmph.code))",
          "",
          "[Added Lines]",
          "648:  if (memcpy_fromiovec(user_icmph, msg->msg_iov, icmph_len))",
          "651:  if (family == AF_INET) {",
          "652:   type = ((struct icmphdr *) user_icmph)->type;",
          "653:   code = ((struct icmphdr *) user_icmph)->code;",
          "654: #if IS_ENABLED(CONFIG_IPV6)",
          "655:  } else if (family == AF_INET6) {",
          "656:   type = ((struct icmp6hdr *) user_icmph)->icmp6_type;",
          "657:   code = ((struct icmp6hdr *) user_icmph)->icmp6_code;",
          "658: #endif",
          "659:  } else {",
          "660:   BUG();",
          "661:  }",
          "663:  if (!ping_supported(family, type, code))",
          "666:  return 0;",
          "667: }",
          "668: EXPORT_SYMBOL_GPL(ping_common_sendmsg);",
          "670: int ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "671:       size_t len)",
          "672: {",
          "673:  struct net *net = sock_net(sk);",
          "674:  struct flowi4 fl4;",
          "675:  struct inet_sock *inet = inet_sk(sk);",
          "676:  struct ipcm_cookie ipc;",
          "677:  struct icmphdr user_icmph;",
          "678:  struct pingfakehdr pfh;",
          "679:  struct rtable *rt = NULL;",
          "680:  struct ip_options_data opt_copy;",
          "681:  int free = 0;",
          "682:  __be32 saddr, daddr, faddr;",
          "683:  u8  tos;",
          "684:  int err;",
          "686:  pr_debug(\"ping_v4_sendmsg(sk=%p,sk->num=%u)\\n\", inet, inet->inet_num);",
          "688:  err = ping_common_sendmsg(AF_INET, msg, len, &user_icmph,",
          "689:       sizeof(user_icmph));",
          "690:  if (err)",
          "691:   return err;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "595:  pfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;",
          "596:  pfh.iov = msg->msg_iov;",
          "597:  pfh.wcheck = 0;",
          "599:  err = ip_append_data(sk, &fl4, ping_getfrag, &pfh, len,",
          "600:    0, &ipc, &rt, msg->msg_flags);",
          "601:  if (err)",
          "602:   ip_flush_pending_frames(sk);",
          "603:  else",
          "605:  release_sock(sk);",
          "607: out:",
          "",
          "[Removed Lines]",
          "604:   err = ping_push_pending_frames(sk, &pfh, &fl4);",
          "",
          "[Added Lines]",
          "797:  pfh.family = AF_INET;",
          "804:   err = ping_v4_push_pending_frames(sk, &pfh, &fl4);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "622:  goto out;",
          "623: }",
          "627: {",
          "628:  struct inet_sock *isk = inet_sk(sk);",
          "630:  struct sk_buff *skb;",
          "631:  int copied, err;",
          "",
          "[Removed Lines]",
          "625: static int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "626:    size_t len, int noblock, int flags, int *addr_len)",
          "629:  struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;",
          "",
          "[Added Lines]",
          "825: int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "826:    size_t len, int noblock, int flags, int *addr_len)",
          "829:  int family = sk->sk_family;",
          "830:  struct sockaddr_in *sin;",
          "831:  struct sockaddr_in6 *sin6;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "636:  if (flags & MSG_OOB)",
          "637:   goto out;",
          "645:  skb = skb_recv_datagram(sk, flags, noblock, &err);",
          "646:  if (!skb)",
          "",
          "[Removed Lines]",
          "639:  if (addr_len)",
          "642:  if (flags & MSG_ERRQUEUE)",
          "643:   return ip_recv_error(sk, msg, len);",
          "",
          "[Added Lines]",
          "841:  if (addr_len) {",
          "842:   if (family == AF_INET)",
          "844:   else if (family == AF_INET6 && addr_len)",
          "846:  }",
          "848:  if (flags & MSG_ERRQUEUE) {",
          "849:   if (family == AF_INET) {",
          "850:    return ip_recv_error(sk, msg, len);",
          "851: #if IS_ENABLED(CONFIG_IPV6)",
          "852:   } else if (family == AF_INET6) {",
          "853:    return pingv6_ops.ipv6_recv_error(sk, msg, len);",
          "854: #endif",
          "855:   }",
          "856:  }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "660:  sock_recv_timestamp(msg, sk, skb);",
          "664:   sin->sin_family = AF_INET;",
          "665:   sin->sin_port = 0 /* skb->h.uh->source */;",
          "666:   sin->sin_addr.s_addr = ip_hdr(skb)->saddr;",
          "667:   memset(sin->sin_zero, 0, sizeof(sin->sin_zero));",
          "668:  }",
          "671:  err = copied;",
          "673: done:",
          "",
          "[Removed Lines]",
          "663:  if (sin) {",
          "669:  if (isk->cmsg_flags)",
          "670:   ip_cmsg_recv(msg, skb);",
          "",
          "[Added Lines]",
          "876:  if (family == AF_INET) {",
          "877:   sin = (struct sockaddr_in *) msg->msg_name;",
          "883:   if (isk->cmsg_flags)",
          "884:    ip_cmsg_recv(msg, skb);",
          "886: #if IS_ENABLED(CONFIG_IPV6)",
          "887:  } else if (family == AF_INET6) {",
          "888:   struct ipv6_pinfo *np = inet6_sk(sk);",
          "889:   struct ipv6hdr *ip6 = ipv6_hdr(skb);",
          "890:   sin6 = (struct sockaddr_in6 *) msg->msg_name;",
          "891:   sin6->sin6_family = AF_INET6;",
          "892:   sin6->sin6_port = 0;",
          "893:   sin6->sin6_addr = ip6->saddr;",
          "895:   if (np->sndflow)",
          "896:    sin6->sin6_flowinfo = ip6_flowinfo(ip6);",
          "898:   if (__ipv6_addr_needs_scope_id(",
          "899:       ipv6_addr_type(&sin6->sin6_addr)))",
          "900:    sin6->sin6_scope_id = IP6CB(skb)->iif;",
          "902:   if (inet6_sk(sk)->rxopt.all)",
          "903:    pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);",
          "904: #endif",
          "905:  } else {",
          "906:   BUG();",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "676:  pr_debug(\"ping_recvmsg -> %d\\n\", err);",
          "677:  return err;",
          "678: }",
          "681: {",
          "682:  pr_debug(\"ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\\n\",",
          "683:    inet_sk(sk), inet_sk(sk)->inet_num, skb);",
          "",
          "[Removed Lines]",
          "680: static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)",
          "",
          "[Added Lines]",
          "917: EXPORT_SYMBOL_GPL(ping_recvmsg);",
          "919: int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "688:  }",
          "689:  return 0;",
          "690: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "930: EXPORT_SYMBOL_GPL(ping_queue_rcv_skb);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "698: {",
          "699:  struct sock *sk;",
          "700:  struct net *net = dev_net(skb->dev);",
          "702:  struct icmphdr *icmph = icmp_hdr(skb);",
          "",
          "[Removed Lines]",
          "701:  struct iphdr *iph = ip_hdr(skb);",
          "703:  __be32 saddr = iph->saddr;",
          "704:  __be32 daddr = iph->daddr;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "712:  skb_push(skb, skb->data - (u8 *)icmph);",
          "716:  if (sk != NULL) {",
          "717:   pr_debug(\"rcv on socket %p\\n\", sk);",
          "718:   ping_queue_rcv_skb(sk, skb_get(skb));",
          "",
          "[Removed Lines]",
          "714:  sk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),",
          "715:        skb->dev->ifindex);",
          "",
          "[Added Lines]",
          "951:  sk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "725: }",
          "727: struct proto ping_prot = {",
          "728:  .name =  \"PING\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "962: EXPORT_SYMBOL_GPL(ping_rcv);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "733:  .disconnect = udp_disconnect,",
          "734:  .setsockopt = ip_setsockopt,",
          "735:  .getsockopt = ip_getsockopt,",
          "737:  .recvmsg = ping_recvmsg,",
          "738:  .bind =  ping_bind,",
          "739:  .backlog_rcv = ping_queue_rcv_skb,",
          "740:  .release_cb = ip4_datagram_release_cb,",
          "744:  .obj_size = sizeof(struct inet_sock),",
          "745: };",
          "746: EXPORT_SYMBOL(ping_prot);",
          "",
          "[Removed Lines]",
          "736:  .sendmsg = ping_sendmsg,",
          "741:  .hash =  ping_v4_hash,",
          "742:  .unhash = ping_v4_unhash,",
          "743:  .get_port = ping_v4_get_port,",
          "",
          "[Added Lines]",
          "973:  .sendmsg = ping_v4_sendmsg,",
          "978:  .hash =  ping_hash,",
          "979:  .unhash = ping_unhash,",
          "980:  .get_port = ping_get_port,",
          "",
          "---------------"
        ],
        "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c": [
          "File: net/ipv6/af_inet6.c -> net/ipv6/af_inet6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: #include <net/udp.h>",
          "50: #include <net/udplite.h>",
          "51: #include <net/tcp.h>",
          "52: #include <net/protocol.h>",
          "53: #include <net/inet_common.h>",
          "54: #include <net/route.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: #include <net/ping.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "840:  if (err)",
          "841:   goto out_unregister_udplite_proto;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "844:  err = proto_register(&pingv6_prot, 1);",
          "845:  if (err)",
          "846:   goto out_unregister_ping_proto;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "930:  if (err)",
          "931:   goto ipv6_packet_fail;",
          "933: #ifdef CONFIG_SYSCTL",
          "934:  err = ipv6_sysctl_register();",
          "935:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "937:  err = pingv6_init();",
          "938:  if (err)",
          "939:   goto pingv6_fail;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "942: sysctl_fail:",
          "943:  ipv6_packet_cleanup();",
          "944: #endif",
          "945: ipv6_packet_fail:",
          "946:  tcpv6_exit();",
          "947: tcpv6_fail:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "953: pingv6_fail:",
          "954:  pingv6_exit();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "985:  rtnl_unregister_all(PF_INET6);",
          "986: out_sock_register_fail:",
          "987:  rawv6_exit();",
          "988: out_unregister_raw_proto:",
          "989:  proto_unregister(&rawv6_prot);",
          "990: out_unregister_udplite_proto:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "998: out_unregister_ping_proto:",
          "999:  proto_unregister(&pingv6_prot);",
          "",
          "---------------"
        ],
        "net/ipv6/icmp.c||net/ipv6/icmp.c": [
          "File: net/ipv6/icmp.c -> net/ipv6/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #include <net/ipv6.h>",
          "59: #include <net/ip6_checksum.h>",
          "60: #include <net/protocol.h>",
          "61: #include <net/raw.h>",
          "62: #include <net/rawv6.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60: #include <net/ping.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84: static void icmpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,",
          "85:          u8 type, u8 code, int offset, __be32 info)",
          "86: {",
          "87:  struct net *net = dev_net(skb->dev);",
          "89:  if (type == ICMPV6_PKT_TOOBIG)",
          "90:   ip6_update_pmtu(skb, net, info, 0, 0);",
          "91:  else if (type == NDISC_REDIRECT)",
          "92:   ip6_redirect(skb, net, 0, 0);",
          "93: }",
          "95: static int icmpv6_rcv(struct sk_buff *skb);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89:  struct icmp6hdr *icmp6 = (struct icmp6hdr *) (skb->data + offset);",
          "97:  if (!(type & ICMPV6_INFOMSG_MASK))",
          "98:   if (icmp6->icmp6_type == ICMPV6_ECHO_REQUEST)",
          "99:    ping_err(skb, offset, info);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "224:  return (*op & 0xC0) == 0x80;",
          "225: }",
          "228: {",
          "229:  struct sk_buff *skb;",
          "230:  struct icmp6hdr *icmp6h;",
          "",
          "[Removed Lines]",
          "227: static int icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6, struct icmp6hdr *thdr, int len)",
          "",
          "[Added Lines]",
          "234: int icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,",
          "235:           struct icmp6hdr *thdr, int len)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "307: static inline void mip6_addr_swap(struct sk_buff *skb) {}",
          "308: #endif",
          "312: {",
          "313:  struct dst_entry *dst, *dst2;",
          "314:  struct flowi6 fl2;",
          "",
          "[Removed Lines]",
          "310: static struct dst_entry *icmpv6_route_lookup(struct net *net, struct sk_buff *skb,",
          "311:           struct sock *sk, struct flowi6 *fl6)",
          "",
          "[Added Lines]",
          "318: struct dst_entry *icmpv6_route_lookup(struct net *net, struct sk_buff *skb,",
          "319:           struct sock *sk, struct flowi6 *fl6)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "697:   skb->csum = ~csum_unfold(csum_ipv6_magic(saddr, daddr, skb->len,",
          "698:           IPPROTO_ICMPV6, 0));",
          "699:   if (__skb_checksum_complete(skb)) {",
          "701:            saddr, daddr);",
          "702:    goto csum_error;",
          "703:   }",
          "",
          "[Removed Lines]",
          "700:    LIMIT_NETDEBUG(KERN_DEBUG \"ICMPv6 checksum failed [%pI6 > %pI6]\\n\",",
          "",
          "[Added Lines]",
          "708:    LIMIT_NETDEBUG(KERN_DEBUG",
          "709:            \"ICMPv6 checksum failed [%pI6c > %pI6c]\\n\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "718:   break;",
          "720:  case ICMPV6_ECHO_REPLY:",
          "722:   break;",
          "724:  case ICMPV6_PKT_TOOBIG:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "730:   ping_rcv(skb);",
          "",
          "---------------"
        ],
        "net/ipv6/ping.c||net/ipv6/ping.c": [
          "File: net/ipv6/ping.c -> net/ipv6/ping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <net/addrconf.h>",
          "22: #include <net/ipv6.h>",
          "23: #include <net/ip6_route.h>",
          "24: #include <net/protocol.h>",
          "25: #include <net/udp.h>",
          "26: #include <net/transp_v6.h>",
          "27: #include <net/ping.h>",
          "29: struct proto pingv6_prot = {",
          "30:  .name =  \"PINGv6\",",
          "31:  .owner = THIS_MODULE,",
          "32:  .init =  ping_init_sock,",
          "33:  .close = ping_close,",
          "34:  .connect = ip6_datagram_connect,",
          "35:  .disconnect = udp_disconnect,",
          "36:  .setsockopt = ipv6_setsockopt,",
          "37:  .getsockopt = ipv6_getsockopt,",
          "38:  .sendmsg = ping_v6_sendmsg,",
          "39:  .recvmsg = ping_recvmsg,",
          "40:  .bind =  ping_bind,",
          "41:  .backlog_rcv = ping_queue_rcv_skb,",
          "42:  .hash =  ping_hash,",
          "43:  .unhash = ping_unhash,",
          "44:  .get_port = ping_get_port,",
          "45:  .obj_size = sizeof(struct raw6_sock),",
          "46: };",
          "47: EXPORT_SYMBOL_GPL(pingv6_prot);",
          "49: static struct inet_protosw pingv6_protosw = {",
          "50:  .type =      SOCK_DGRAM,",
          "51:  .protocol =  IPPROTO_ICMPV6,",
          "52:  .prot =      &pingv6_prot,",
          "53:  .ops =       &inet6_dgram_ops,",
          "54:  .no_check =  UDP_CSUM_DEFAULT,",
          "55:  .flags =     INET_PROTOSW_REUSE,",
          "56: };",
          "60: int dummy_ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len)",
          "61: {",
          "62:  return -EAFNOSUPPORT;",
          "63: }",
          "64: int dummy_ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,",
          "65:      struct sk_buff *skb)",
          "66: {",
          "67:  return -EAFNOSUPPORT;",
          "68: }",
          "69: int dummy_icmpv6_err_convert(u8 type, u8 code, int *err)",
          "70: {",
          "71:  return -EAFNOSUPPORT;",
          "72: }",
          "73: void dummy_ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,",
          "74:        __be16 port, u32 info, u8 *payload) {}",
          "75: int dummy_ipv6_chk_addr(struct net *net, const struct in6_addr *addr,",
          "76:    struct net_device *dev, int strict)",
          "77: {",
          "78:  return 0;",
          "79: }",
          "81: int __init pingv6_init(void)",
          "82: {",
          "83:  pingv6_ops.ipv6_recv_error = ipv6_recv_error;",
          "84:  pingv6_ops.ip6_datagram_recv_ctl = ip6_datagram_recv_ctl;",
          "85:  pingv6_ops.icmpv6_err_convert = icmpv6_err_convert;",
          "86:  pingv6_ops.ipv6_icmp_error = ipv6_icmp_error;",
          "87:  pingv6_ops.ipv6_chk_addr = ipv6_chk_addr;",
          "88:  return inet6_register_protosw(&pingv6_protosw);",
          "89: }",
          "94: void pingv6_exit(void)",
          "95: {",
          "96:  pingv6_ops.ipv6_recv_error = dummy_ipv6_recv_error;",
          "97:  pingv6_ops.ip6_datagram_recv_ctl = dummy_ip6_datagram_recv_ctl;",
          "98:  pingv6_ops.icmpv6_err_convert = dummy_icmpv6_err_convert;",
          "99:  pingv6_ops.ipv6_icmp_error = dummy_ipv6_icmp_error;",
          "100:  pingv6_ops.ipv6_chk_addr = dummy_ipv6_chk_addr;",
          "101:  inet6_unregister_protosw(&pingv6_protosw);",
          "102: }",
          "104: int ping_v6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "105:       size_t len)",
          "106: {",
          "107:  struct inet_sock *inet = inet_sk(sk);",
          "108:  struct ipv6_pinfo *np = inet6_sk(sk);",
          "109:  struct icmp6hdr user_icmph;",
          "110:  int addr_type;",
          "111:  struct in6_addr *daddr;",
          "112:  int iif = 0;",
          "113:  struct flowi6 fl6;",
          "114:  int err;",
          "115:  int hlimit;",
          "116:  struct dst_entry *dst;",
          "117:  struct rt6_info *rt;",
          "118:  struct pingfakehdr pfh;",
          "120:  pr_debug(\"ping_v6_sendmsg(sk=%p,sk->num=%u)\\n\", inet, inet->inet_num);",
          "122:  err = ping_common_sendmsg(AF_INET6, msg, len, &user_icmph,",
          "123:       sizeof(user_icmph));",
          "124:  if (err)",
          "125:   return err;",
          "127:  if (msg->msg_name) {",
          "128:   struct sockaddr_in6 *u = (struct sockaddr_in6 *) msg->msg_name;",
          "129:   if (msg->msg_namelen < sizeof(struct sockaddr_in6) ||",
          "130:       u->sin6_family != AF_INET6) {",
          "131:    return -EINVAL;",
          "132:   }",
          "133:   if (sk->sk_bound_dev_if &&",
          "134:       sk->sk_bound_dev_if != u->sin6_scope_id) {",
          "135:    return -EINVAL;",
          "136:   }",
          "137:   daddr = &(u->sin6_addr);",
          "138:   iif = u->sin6_scope_id;",
          "139:  } else {",
          "140:   if (sk->sk_state != TCP_ESTABLISHED)",
          "141:    return -EDESTADDRREQ;",
          "142:   daddr = &np->daddr;",
          "143:  }",
          "145:  if (!iif)",
          "146:   iif = sk->sk_bound_dev_if;",
          "148:  addr_type = ipv6_addr_type(daddr);",
          "149:  if (__ipv6_addr_needs_scope_id(addr_type) && !iif)",
          "150:   return -EINVAL;",
          "151:  if (addr_type & IPV6_ADDR_MAPPED)",
          "152:   return -EINVAL;",
          "156:  memset(&fl6, 0, sizeof(fl6));",
          "158:  fl6.flowi6_proto = IPPROTO_ICMPV6;",
          "159:  fl6.saddr = np->saddr;",
          "160:  fl6.daddr = *daddr;",
          "161:  fl6.fl6_icmp_type = user_icmph.icmp6_type;",
          "162:  fl6.fl6_icmp_code = user_icmph.icmp6_code;",
          "163:  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));",
          "165:  if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))",
          "166:   fl6.flowi6_oif = np->mcast_oif;",
          "167:  else if (!fl6.flowi6_oif)",
          "168:   fl6.flowi6_oif = np->ucast_oif;",
          "170:  dst = ip6_sk_dst_lookup_flow(sk, &fl6,  daddr, 1);",
          "171:  if (IS_ERR(dst))",
          "172:   return PTR_ERR(dst);",
          "173:  rt = (struct rt6_info *) dst;",
          "175:  np = inet6_sk(sk);",
          "176:  if (!np)",
          "177:   return -EBADF;",
          "179:  if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))",
          "180:   fl6.flowi6_oif = np->mcast_oif;",
          "181:  else if (!fl6.flowi6_oif)",
          "182:   fl6.flowi6_oif = np->ucast_oif;",
          "184:  pfh.icmph.type = user_icmph.icmp6_type;",
          "185:  pfh.icmph.code = user_icmph.icmp6_code;",
          "186:  pfh.icmph.checksum = 0;",
          "187:  pfh.icmph.un.echo.id = inet->inet_sport;",
          "188:  pfh.icmph.un.echo.sequence = user_icmph.icmp6_sequence;",
          "189:  pfh.iov = msg->msg_iov;",
          "190:  pfh.wcheck = 0;",
          "191:  pfh.family = AF_INET6;",
          "193:  if (ipv6_addr_is_multicast(&fl6.daddr))",
          "194:   hlimit = np->mcast_hops;",
          "195:  else",
          "196:   hlimit = np->hop_limit;",
          "197:  if (hlimit < 0)",
          "198:   hlimit = ip6_dst_hoplimit(dst);",
          "200:  err = ip6_append_data(sk, ping_getfrag, &pfh, len,",
          "201:          0, hlimit,",
          "202:          np->tclass, NULL, &fl6, rt,",
          "203:          MSG_DONTWAIT, np->dontfrag);",
          "205:  if (err) {",
          "206:   ICMP6_INC_STATS_BH(sock_net(sk), rt->rt6i_idev,",
          "207:        ICMP6_MIB_OUTERRORS);",
          "208:   ip6_flush_pending_frames(sk);",
          "209:  } else {",
          "210:   err = icmpv6_push_pending_frames(sk, &fl6,",
          "211:        (struct icmp6hdr *) &pfh.icmph,",
          "212:        len);",
          "213:  }",
          "215:  return err;",
          "216: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6364e6ee788ae60f1c2de5c59e39adb157327e6c",
      "candidate_info": {
        "commit_hash": "6364e6ee788ae60f1c2de5c59e39adb157327e6c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6364e6ee788ae60f1c2de5c59e39adb157327e6c",
        "files": [
          "net/ieee802154/dgram.c"
        ],
        "message": "ieee802154/dgram: Pass source address in dgram_recvmsg\n\nThis patch lets dgram_recvmsg fill in the sockaddr struct in\nmsg->msg_name with the source address of the packet.\nThis is used by the userland functions recvmsg and recvfrom to get the\nsenders address.\n\n[Stefan: Changed from old zigbee legacy tree to mainline]\n\nSigned-off-by: Stephen R\u00f6ttger <stephen.roettger@zero-entropy.de>\nSigned-off-by: Stefan Schmidt <stefan@datenfreihafen.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ieee802154/dgram.c||net/ieee802154/dgram.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ieee802154/dgram.c||net/ieee802154/dgram.c"
          ],
          "candidate": [
            "net/ieee802154/dgram.c||net/ieee802154/dgram.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ieee802154/dgram.c||net/ieee802154/dgram.c": [
          "File: net/ieee802154/dgram.c -> net/ieee802154/dgram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "291:  size_t copied = 0;",
          "292:  int err = -EOPNOTSUPP;",
          "293:  struct sk_buff *skb;",
          "295:  skb = skb_recv_datagram(sk, flags, noblock, &err);",
          "296:  if (!skb)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "294:  struct sockaddr_ieee802154 *saddr;",
          "296:  saddr = (struct sockaddr_ieee802154 *)msg->msg_name;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "310:  sock_recv_ts_and_drops(msg, sk, skb);",
          "312:  if (flags & MSG_TRUNC)",
          "313:   copied = skb->len;",
          "314: done:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315:  if (saddr) {",
          "316:   saddr->family = AF_IEEE802154;",
          "317:   saddr->addr = mac_cb(skb)->sa;",
          "318:  }",
          "319:  if (addr_len)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
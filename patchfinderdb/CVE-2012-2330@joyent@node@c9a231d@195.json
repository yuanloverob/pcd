{
  "cve_id": "CVE-2012-2330",
  "cve_desc": "The Update method in src/node_http_parser.cc in Node.js before 0.6.17 and 0.7 before 0.7.8 does not properly check the length of a string, which allows remote attackers to obtain sensitive information (request header contents) and possibly spoof HTTP headers via a zero length string.",
  "repo": "joyent/node",
  "patch_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
  "patch_info": {
    "commit_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
    "repo": "joyent/node",
    "commit_url": "https://github.com/joyent/node/commit/c9a231d",
    "files": [
      "src/node_http_parser.cc"
    ],
    "message": "typo in node_http_parser",
    "before_after_code_files": [
      "src/node_http_parser.cc||src/node_http_parser.cc"
    ]
  },
  "patch_diff": {
    "src/node_http_parser.cc||src/node_http_parser.cc": [
      "File: src/node_http_parser.cc -> src/node_http_parser.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:   void Update(const char* str, size_t size) {",
      "192:     if (str_ == NULL)",
      "193:       str_ = str;",
      "197:       char* s = new char[size_ + size];",
      "",
      "[Removed Lines]",
      "194:     else if (on_heap_ || str_ + size != str) {",
      "",
      "[Added Lines]",
      "194:     else if (on_heap_ || str_ + size_ != str) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3df7c90c3059f49c81f9b8f59fc3abf18d5d392b",
      "candidate_info": {
        "commit_hash": "3df7c90c3059f49c81f9b8f59fc3abf18d5d392b",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/3df7c90c3059f49c81f9b8f59fc3abf18d5d392b",
        "files": [
          "lib/http.js",
          "test/simple/test-http-should-keep-alive.js"
        ],
        "message": "http: keep-alive should default with HTTP/1.1 server\n\nAs RFC 2616 says we should, assume that servers will provide a persistent\nconnection by default.\n\n> A significant difference between HTTP/1.1 and earlier versions of\n> HTTP is that persistent connections are the default behavior of any\n> HTTP connection. That is, unless otherwise indicated, the client\n> SHOULD assume that the server will maintain a persistent connection,\n> even after error responses from the server.\n\n> HTTP/1.1 applications that do not support persistent connections MUST\n> include the \"close\" connection option in every message.\n\nFixes #2436.",
        "before_after_code_files": [
          "lib/http.js||lihttp.js",
          "test/simple/test-http-should-keep-alive.js||test/simple/test-http-should-keep-alive.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/http.js||lihttp.js": [
          "File: lib/http.js -> lihttp.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1231:         return true;",
          "1232:       }",
          "",
          "[Removed Lines]",
          "1234:       if (req.shouldKeepAlive && res.headers.connection !== 'keep-alive' && !req.upgraded) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/simple/test-http-should-keep-alive.js||test/simple/test-http-should-keep-alive.js": [
          "File: test/simple/test-http-should-keep-alive.js -> test/simple/test-http-should-keep-alive.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: var common = require('../common');",
          "23: var assert = require('assert');",
          "24: var http = require('http');",
          "25: var net = require('net');",
          "27: var SERVER_RESPONSES = [",
          "28:   'HTTP/1.0 200 ok\\r\\nContent-Length: 0\\r\\n\\r\\n',",
          "29:   'HTTP/1.0 200 ok\\r\\nContent-Length: 0\\r\\nConnection: keep-alive\\r\\n\\r\\n',",
          "30:   'HTTP/1.0 200 ok\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n',",
          "31:   'HTTP/1.1 200 ok\\r\\nContent-Length: 0\\r\\n\\r\\n',",
          "32:   'HTTP/1.1 200 ok\\r\\nContent-Length: 0\\r\\nConnection: keep-alive\\r\\n\\r\\n',",
          "33:   'HTTP/1.1 200 ok\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n',",
          "34: ];",
          "35: var SHOULD_KEEP_ALIVE = [",
          "36:   false, // HTTP/1.0, default",
          "37:   true,  // HTTP/1.0, Connection: keep-alive",
          "38:   false, // HTTP/1.0, Connection: close",
          "39:   true,  // HTTP/1.1, default",
          "40:   true,  // HTTP/1.1, Connection: keep-alive",
          "41:   false, // HTTP/1.1, Connection: close",
          "42: ];",
          "43: var requests = 0;",
          "44: var responses = 0;",
          "46: var server = net.createServer(function(socket) {",
          "47:   socket.write(SERVER_RESPONSES[requests]);",
          "48:   ++requests;",
          "49: }).listen(common.PORT, function() {",
          "50:   function makeRequest() {",
          "51:     var req = http.get({port: common.PORT}, function(res) {",
          "52:       assert.equal(req.shouldKeepAlive, SHOULD_KEEP_ALIVE[responses],",
          "53:                    SERVER_RESPONSES[responses] + ' should ' +",
          "54:                    (SHOULD_KEEP_ALIVE[responses] ? '' : 'not ') +",
          "55:                    'Keep-Alive');",
          "56:       ++responses;",
          "57:       if (responses < SHOULD_KEEP_ALIVE.length) {",
          "58:         makeRequest();",
          "59:       } else {",
          "60:         server.close();",
          "61:       }",
          "62:     });",
          "63:   }",
          "65:   makeRequest();",
          "66: });",
          "68: process.on('exit', function() {",
          "69:   assert.equal(requests, SERVER_RESPONSES.length);",
          "70:   assert.equal(responses, SHOULD_KEEP_ALIVE.length);",
          "71: });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d3d02c70dffb29e9c80a35fe9f791b357a1dccf",
      "candidate_info": {
        "commit_hash": "1d3d02c70dffb29e9c80a35fe9f791b357a1dccf",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/1d3d02c70dffb29e9c80a35fe9f791b357a1dccf",
        "files": [
          "lib/fs.js",
          "test/simple/test-fs-readfile-pipe.js"
        ],
        "message": "Fix fs.readfile('/dev/stdin')\n\nThere is no need for fs.readFile() to be using pread rather than read.\nThe default semantics of read() are such that subsequent reads are where\nwe want them anyway.",
        "before_after_code_files": [
          "lib/fs.js||lifs.js",
          "test/simple/test-fs-readfile-pipe.js||test/simple/test-fs-readfile-pipe.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/fs.js||lifs.js": [
          "File: lib/fs.js -> lifs.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "135:   function read() {",
          "136:     if (size === 0) {",
          "137:       buffer = new Buffer(8192);",
          "139:     } else {",
          "141:     }",
          "142:   }",
          "",
          "[Removed Lines]",
          "138:       fs.read(fd, buffer, 0, 8192, pos, afterRead);",
          "140:       fs.read(fd, buffer, pos, size - pos, pos, afterRead);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/simple/test-fs-readfile-pipe.js||test/simple/test-fs-readfile-pipe.js": [
          "File: test/simple/test-fs-readfile-pipe.js -> test/simple/test-fs-readfile-pipe.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: var common = require('../common');",
          "23: var assert = require('assert');",
          "28: if (process.platform === 'win32') {",
          "29:   console.error('No /dev/stdin on windows.  Skipping test.');",
          "30:   process.exit();",
          "31: }",
          "33: var fs = require('fs');",
          "35: var dataExpected = fs.readFileSync(__filename, 'utf8');",
          "37: if (process.argv[2] === 'child') {",
          "38:   fs.readFile('/dev/stdin', function(er, data) {",
          "39:     if (er) throw er;",
          "40:     process.stdout.write(data);",
          "41:   });",
          "42:   return;",
          "43: }",
          "45: var exec = require('child_process').exec;",
          "46: var f = JSON.stringify(__filename);",
          "47: var node = JSON.stringify(process.execPath);",
          "48: var cmd = 'cat ' + f + ' | ' + node + ' ' + f + ' child';",
          "49: exec(cmd, function(err, stdout, stderr) {",
          "50:   if (err) console.error(err);",
          "51:   assert(!err, 'it exits normally');",
          "52:   assert(stdout === dataExpected, 'it reads the file and outputs it');",
          "53:   assert(stderr === '', 'it does not write to stderr');",
          "54:   console.log('ok');",
          "55: });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a9723df1b76777899a3819839cb7e8f0e2efaef1",
      "candidate_info": {
        "commit_hash": "a9723df1b76777899a3819839cb7e8f0e2efaef1",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/a9723df1b76777899a3819839cb7e8f0e2efaef1",
        "files": [
          "lib/module.js"
        ],
        "message": "Revert \"Process symlinked shared library as .node\"\n\nThis reverts commit 7e0bf7d57de318f45a097e05644efa49beb65209.\n\nIt's possible to make GYP generate an XCode project that produces a .node file,\nhence this commit is no longer needed.",
        "before_after_code_files": [
          "lib/module.js||limodule.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/module.js||limodule.js": [
          "File: lib/module.js -> limodule.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "469: };",
          "473: Module._extensions['.node'] = function(module, filename) {",
          "474:   process.dlopen(filename, module.exports);",
          "475: };",
          "479: Module.runMain = function() {",
          "",
          "[Removed Lines]",
          "476: Module._extensions['.dylib'] = Module._extensions['.node'];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ea2a618adb0f8654b07a62bccf2a3473ec4b22d",
      "candidate_info": {
        "commit_hash": "3ea2a618adb0f8654b07a62bccf2a3473ec4b22d",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/3ea2a618adb0f8654b07a62bccf2a3473ec4b22d",
        "files": [
          "deps/uv/src/unix/dl.c",
          "deps/uv/src/win/error.c",
          "deps/uv/src/win/fs.c"
        ],
        "message": "uv: upgrade to 4a88b3b",
        "before_after_code_files": [
          "deps/uv/src/unix/dl.c||deps/uv/src/unix/dl.c",
          "deps/uv/src/win/error.c||deps/uv/src/win/error.c",
          "deps/uv/src/win/fs.c||deps/uv/src/win/fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/uv/src/unix/dl.c||deps/uv/src/unix/dl.c": [
          "File: deps/uv/src/unix/dl.c -> deps/uv/src/unix/dl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:   lib->errmsg = NULL;",
          "36:   lib->handle = dlopen(filename, RTLD_LAZY);",
          "38: }",
          "",
          "[Removed Lines]",
          "37:   return uv__dlerror(lib);",
          "",
          "[Added Lines]",
          "37:   return lib->handle ? 0 : uv__dlerror(lib);",
          "",
          "---------------"
        ],
        "deps/uv/src/win/error.c||deps/uv/src/win/error.c": [
          "File: deps/uv/src/win/error.c -> deps/uv/src/win/error.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:     case ERROR_SIGNAL_REFUSED:              return UV_EIO;",
          "84:     case ERROR_FILE_NOT_FOUND:              return UV_ENOENT;",
          "85:     case ERROR_INVALID_NAME:                return UV_ENOENT;",
          "86:     case ERROR_MOD_NOT_FOUND:               return UV_ENOENT;",
          "87:     case ERROR_PATH_NOT_FOUND:              return UV_ENOENT;",
          "88:     case ERROR_ACCESS_DENIED:               return UV_EPERM;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86:     case ERROR_INVALID_REPARSE_DATA:        return UV_ENOENT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:     case ERROR_OPERATION_ABORTED:           return UV_EINTR;",
          "112:     case WSAEINTR:                          return UV_EINTR;",
          "113:     case ERROR_INVALID_DATA:                return UV_EINVAL;",
          "114:     case WSAEINVAL:                         return UV_EINVAL;",
          "115:     case ERROR_CANT_RESOLVE_FILENAME:       return UV_ELOOP;",
          "116:     case ERROR_TOO_MANY_OPEN_FILES:         return UV_EMFILE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "115:     case ERROR_SYMLINK_NOT_SUPPORTED:       return UV_EINVAL;",
          "",
          "---------------"
        ],
        "deps/uv/src/win/fs.c||deps/uv/src/win/fs.c": [
          "File: deps/uv/src/win/fs.c -> deps/uv/src/win/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "161: }",
          "175:   if (!DeviceIoControl(handle,",
          "176:                        FSCTL_GET_REPARSE_POINT,",
          "177:                        NULL,",
          "178:                        0,",
          "179:                        buffer,",
          "182:                        NULL)) {",
          "185:   }",
          "189:   if (reparse_data->ReparseTag == IO_REPARSE_TAG_SYMLINK) {",
          "194:     }",
          "195:   } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {",
          "199:         sizeof(wchar_t);",
          "200:     }",
          "201:   }",
          "205: }",
          "",
          "[Removed Lines]",
          "164: static int get_reparse_point(HANDLE handle, int* target_length) {",
          "165:   void* buffer = NULL;",
          "166:   REPARSE_DATA_BUFFER* reparse_data;",
          "167:   DWORD bytes_returned;",
          "168:   int rv = 0;",
          "170:   buffer = malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE);",
          "171:   if (!buffer) {",
          "172:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "173:   }",
          "180:                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE,",
          "181:                        &bytes_returned,",
          "183:     free(buffer);",
          "184:     return 0;",
          "187:   reparse_data = (REPARSE_DATA_BUFFER*)buffer;",
          "190:     rv = 1;",
          "191:     if (target_length) {",
          "193:         sizeof(wchar_t);",
          "196:     rv = 1;",
          "197:     if (target_length) {",
          "203:   free(buffer);",
          "204:   return rv;",
          "",
          "[Added Lines]",
          "164: INLINE static int fs__readlink_handle(HANDLE handle, char** target_ptr,",
          "165:     int64_t* target_len_ptr) {",
          "166:   char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];",
          "167:   REPARSE_DATA_BUFFER* reparse_data = (REPARSE_DATA_BUFFER*) buffer;",
          "168:   WCHAR *w_target;",
          "169:   DWORD w_target_len;",
          "170:   char* target;",
          "171:   int target_len;",
          "172:   DWORD bytes;",
          "179:                        sizeof buffer,",
          "180:                        &bytes,",
          "182:     return -1;",
          "187:     w_target = reparse_data->SymbolicLinkReparseBuffer.PathBuffer +",
          "188:         (reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset /",
          "189:         sizeof(WCHAR));",
          "190:     w_target_len =",
          "191:         reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength /",
          "192:         sizeof(WCHAR);",
          "200:     if (w_target_len >= 4 &&",
          "201:         w_target[0] == L'\\\\' &&",
          "202:         w_target[1] == L'?' &&",
          "203:         w_target[2] == L'?' &&",
          "204:         w_target[3] == L'\\\\') {",
          "206:       if (w_target_len >= 6 &&",
          "207:           ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||",
          "208:            (w_target[4] >= L'a' && w_target[4] <= L'z')) &&",
          "209:           w_target[5] == L':' &&",
          "210:           (w_target_len == 6 || w_target[6] == L'\\\\')) {",
          "212:         w_target += 4;",
          "213:         w_target_len -= 4;",
          "215:       } else if (w_target_len >= 8 &&",
          "216:                  (w_target[4] == L'U' || w_target[4] == L'u') &&",
          "217:                  (w_target[5] == L'N' || w_target[5] == L'n') &&",
          "218:                  (w_target[6] == L'C' || w_target[6] == L'c') &&",
          "219:                  w_target[7] == L'\\\\') {",
          "222:         w_target += 6;",
          "223:         w_target[0] = L'\\\\';",
          "224:         w_target_len -= 6;",
          "225:       }",
          "230:     w_target = reparse_data->MountPointReparseBuffer.PathBuffer +",
          "231:         (reparse_data->MountPointReparseBuffer.SubstituteNameOffset /",
          "232:         sizeof(WCHAR));",
          "233:     w_target_len = reparse_data->MountPointReparseBuffer.SubstituteNameLength /",
          "241:     if (!(w_target_len >= 6 &&",
          "242:           w_target[0] == L'\\\\' &&",
          "243:           w_target[1] == L'?' &&",
          "244:           w_target[2] == L'?' &&",
          "245:           w_target[3] == L'\\\\' &&",
          "246:           ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||",
          "247:            (w_target[4] >= L'a' && w_target[4] <= L'z')) &&",
          "248:           w_target[5] == L':' &&",
          "249:           (w_target_len == 6 || w_target[6] == L'\\\\'))) {",
          "250:       SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);",
          "251:       return -1;",
          "255:     w_target += 4;",
          "256:     w_target_len -= 4;",
          "258:   } else {",
          "260:     SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);",
          "261:     return -1;",
          "265:   target_len = WideCharToMultiByte(CP_UTF8,",
          "266:                                    0,",
          "267:                                    w_target,",
          "268:                                    w_target_len,",
          "269:                                    NULL,",
          "270:                                    0,",
          "271:                                    NULL,",
          "272:                                    NULL);",
          "273:   if (target_len == 0) {",
          "274:     return -1;",
          "275:   }",
          "278:   if (target_ptr != NULL) {",
          "279:     int r;",
          "280:     target = (char*) malloc(target_len + 1);",
          "281:     if (target == NULL) {",
          "282:       SetLastError(ERROR_OUTOFMEMORY);",
          "283:       return -1;",
          "284:     }",
          "286:     r = WideCharToMultiByte(CP_UTF8,",
          "287:                             0,",
          "288:                             w_target,",
          "289:                             w_target_len,",
          "290:                             target,",
          "291:                             target_len,",
          "292:                             NULL,",
          "293:                             NULL);",
          "294:     assert(r == target_len);",
          "295:     target[target_len] = '\\0';",
          "298:   }",
          "300:   if (target_len_ptr != NULL) {",
          "302:   }",
          "304:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "455:     return;",
          "456:   }",
          "461:   CloseHandle(handle);",
          "463:   if (is_dir_symlink) {",
          "464:     fs__rmdir(req, path);",
          "465:   } else {",
          "",
          "[Removed Lines]",
          "458:   is_dir_symlink = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&",
          "459:     get_reparse_point(handle, NULL);",
          "",
          "[Added Lines]",
          "558:   is_dir_symlink = (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&",
          "559:                    (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "585: INLINE static int fs__stat_handle(HANDLE handle, uv_statbuf_t* statbuf) {",
          "587:   BY_HANDLE_FILE_INFORMATION info;",
          "589:   if (!GetFileInformationByHandle(handle, &info)) {",
          "",
          "[Removed Lines]",
          "586:   int target_length;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "601:   statbuf->st_mode = 0;",
          "614:     }",
          "622:     statbuf->st_size = ((int64_t) info.nFileSizeHigh << 32) +",
          "623:                         (int64_t) info.nFileSizeLow;",
          "625:   }",
          "627:   statbuf->st_mtime = FILETIME_TO_TIME_T(info.ftLastWriteTime);",
          "",
          "[Removed Lines]",
          "603:   if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT &&",
          "604:     get_reparse_point(handle, &target_length)) {",
          "605:       statbuf->st_mode = S_IFLNK;",
          "607:       statbuf->st_size = target_length - JUNCTION_PREFIX_LEN;",
          "608:   } else {",
          "609:     if (info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {",
          "610:       statbuf->st_mode |= (_S_IREAD + (_S_IREAD >> 3) + (_S_IREAD >> 6));",
          "611:     } else {",
          "612:       statbuf->st_mode |= ((_S_IREAD|_S_IWRITE) + ((_S_IREAD|_S_IWRITE) >> 3) +",
          "613:         ((_S_IREAD|_S_IWRITE) >> 6));",
          "616:     if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {",
          "617:       statbuf->st_mode |= _S_IFDIR;",
          "618:     } else {",
          "619:       statbuf->st_mode |= _S_IFREG;",
          "620:     }",
          "",
          "[Added Lines]",
          "703:   if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {",
          "704:     if (fs__readlink_handle(handle, NULL, &statbuf->st_size) != 0) {",
          "705:       return -1;",
          "707:     statbuf->st_mode |= S_IFLNK;",
          "708:   } else if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {",
          "709:     statbuf->st_mode |= _S_IFDIR;",
          "710:     statbuf->st_size = 0;",
          "711:   } else {",
          "712:     statbuf->st_mode |= _S_IFREG;",
          "715:   }",
          "717:   if (info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {",
          "718:     statbuf->st_mode |= (_S_IREAD + (_S_IREAD >> 3) + (_S_IREAD >> 6));",
          "719:   } else {",
          "720:     statbuf->st_mode |= ((_S_IREAD|_S_IWRITE) + ((_S_IREAD|_S_IWRITE) >> 3) +",
          "721:       ((_S_IREAD|_S_IWRITE) >> 6));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "659:   }",
          "661:   if (fs__stat_handle(handle, &req->stat) != 0) {",
          "663:     CloseHandle(handle);",
          "664:     return;",
          "665:   }",
          "",
          "[Removed Lines]",
          "662:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "",
          "[Added Lines]",
          "759:     DWORD error = GetLastError();",
          "760:     if (do_lstat && error == ERROR_SYMLINK_NOT_SUPPORTED) {",
          "762:       fs__stat(req, path, 0);",
          "764:     } else {",
          "766:       SET_REQ_WIN32_ERROR(req, GetLastError());",
          "767:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1101: void fs__readlink(uv_fs_t* req, const wchar_t* path) {",
          "1134:                        0,",
          "1138:                        NULL);",
          "1180:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "1187:   }",
          "1195:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "1197:   }",
          "1199:   req->flags |= UV_FS_FREE_PTR;",
          "1213: }",
          "",
          "[Removed Lines]",
          "1102:   int result = -1;",
          "1103:   BOOL rv;",
          "1104:   HANDLE symlink;",
          "1105:   void* buffer = NULL;",
          "1106:   DWORD bytes_returned;",
          "1107:   REPARSE_DATA_BUFFER* reparse_data;",
          "1108:   int utf8size;",
          "1109:   wchar_t* substitute_name;",
          "1110:   int substitute_name_length;",
          "1112:   symlink = CreateFileW(path,",
          "1113:                         0,",
          "1114:                         0,",
          "1115:                         NULL,",
          "1116:                         OPEN_EXISTING,",
          "1117:                         FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,",
          "1118:                         NULL);",
          "1120:   if (INVALID_HANDLE_VALUE == symlink) {",
          "1121:     result = -1;",
          "1122:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "1123:     goto done;",
          "1124:   }",
          "1126:   buffer = malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE);",
          "1127:   if (!buffer) {",
          "1128:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "1129:   }",
          "1131:   rv = DeviceIoControl(symlink,",
          "1132:                        FSCTL_GET_REPARSE_POINT,",
          "1133:                        NULL,",
          "1135:                        buffer,",
          "1136:                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE,",
          "1137:                        &bytes_returned,",
          "1140:   if (!rv) {",
          "1141:     result = -1;",
          "1142:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "1143:     goto done;",
          "1144:   }",
          "1146:   reparse_data = (REPARSE_DATA_BUFFER*)buffer;",
          "1147:   if (reparse_data->ReparseTag == IO_REPARSE_TAG_SYMLINK) {",
          "1148:     substitute_name = reparse_data->SymbolicLinkReparseBuffer.PathBuffer +",
          "1149:       (reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset /",
          "1150:         sizeof(wchar_t));",
          "1151:     substitute_name_length =",
          "1152:       reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength /",
          "1153:         sizeof(wchar_t);",
          "1154:   } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {",
          "1155:     substitute_name = reparse_data->MountPointReparseBuffer.PathBuffer +",
          "1156:       (reparse_data->MountPointReparseBuffer.SubstituteNameOffset /",
          "1157:         sizeof(wchar_t));",
          "1158:     substitute_name_length =",
          "1159:       reparse_data->MountPointReparseBuffer.SubstituteNameLength /",
          "1160:         sizeof(wchar_t);",
          "1161:   } else {",
          "1162:     result = -1;",
          "1164:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "1165:     goto done;",
          "1166:   }",
          "1169:   if (wcsncmp(substitute_name, JUNCTION_PREFIX, JUNCTION_PREFIX_LEN) == 0) {",
          "1170:     substitute_name += JUNCTION_PREFIX_LEN;",
          "1171:     substitute_name_length -= JUNCTION_PREFIX_LEN;",
          "1172:   }",
          "1174:   utf8size = uv_utf16_to_utf8(substitute_name,",
          "1175:                               substitute_name_length,",
          "1176:                               NULL,",
          "1177:                               0);",
          "1178:   if (!utf8size) {",
          "1179:     result = -1;",
          "1181:     goto done;",
          "1182:   }",
          "1184:   req->ptr = malloc(utf8size + 1);",
          "1185:   if (!req->ptr) {",
          "1186:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "1189:   utf8size = uv_utf16_to_utf8(substitute_name,",
          "1190:                               substitute_name_length,",
          "1191:                               (char*)req->ptr,",
          "1192:                               utf8size);",
          "1193:   if (!utf8size) {",
          "1194:     result = -1;",
          "1196:     goto done;",
          "1200:   ((char*)req->ptr)[utf8size] = '\\0';",
          "1201:   result = 0;",
          "1203: done:",
          "1204:   if (buffer) {",
          "1205:     free(buffer);",
          "1206:   }",
          "1208:   if (symlink != INVALID_HANDLE_VALUE) {",
          "1209:     CloseHandle(symlink);",
          "1210:   }",
          "1212:   SET_REQ_RESULT(req, result);",
          "",
          "[Added Lines]",
          "1208:   HANDLE handle;",
          "1210:   handle = CreateFileW(path,",
          "1212:                        0,",
          "1213:                        NULL,",
          "1214:                        OPEN_EXISTING,",
          "1215:                        FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,",
          "1218:   if (handle == INVALID_HANDLE_VALUE) {",
          "1220:     return;",
          "1223:   if (fs__readlink_handle(handle, (char**) &req->ptr, NULL) != 0) {",
          "1225:     CloseHandle(handle);",
          "1226:     return;",
          "1230:   SET_REQ_RESULT(req, 0);",
          "1232:   CloseHandle(handle);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b40f813bab51b676efe37cc7f459c42ce806a18a",
      "candidate_info": {
        "commit_hash": "b40f813bab51b676efe37cc7f459c42ce806a18a",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/b40f813bab51b676efe37cc7f459c42ce806a18a",
        "files": [
          "common.gypi",
          "configure"
        ],
        "message": "build: fix spurious mksnapshot crashes for good\n\nA variety of gcc bugs made mksnapshot crash with either a segmentation fault\nor a 'pure virtual method callled' run-time error.\n\nAfter much wailing and gnashing of teeth I managed to deduce that the bugs\nshow up when:\n\n  1. gcc 4.5.2 for i386-pc-solaris2.11 is used and -fstrict-aliasing is\n     enabled, or\n\n  2. gcc version 4.4.6 for x86_64-redhat-linux is used and\n     -ffunction-sections -finline-functions at -O2 or higher is enabled\n\nTherefore, disable -ffunction-sections and -fdata-sections unconditionally\nand disable -fstrict-aliasing only on Solaris.\n\nThe -ffunction-sections and -fdata-sections switches were nonsense anyway\nbecause we don't link with -Wl,--gc-sections.",
        "before_after_code_files": [
          "common.gypi||common.gypi"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "common.gypi||common.gypi": [
          "File: common.gypi -> common.gypi",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: {",
          "2:   'variables': {",
          "4:     'visibility%': 'hidden',         # V8's visibility setting",
          "5:     'target_arch%': 'ia32',          # set v8's target architecture",
          "6:     'host_arch%': 'ia32',            # set v8's host architecture",
          "",
          "[Removed Lines]",
          "3:     'node_no_strict_aliasing%': 0,   # turn off -fstrict-aliasing",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:         },",
          "43:       },",
          "44:       'Release': {",
          "46:         'conditions': [",
          "47:           ['target_arch==\"x64\"', {",
          "48:             'msvs_configuration_platform': 'x64',",
          "",
          "[Removed Lines]",
          "45:         'cflags': [ '-O3', '-fdata-sections', '-ffunction-sections' ],",
          "",
          "[Added Lines]",
          "44:         # Do *NOT* enable -ffunction-sections or -fdata-sections again.",
          "45:         # We don't link with -Wl,--gc-sections so they're effectively no-ops.",
          "46:         # Worse, they trigger very nasty bugs in some versions of gcc, notably",
          "47:         # v4.4.6 on x86_64-redhat-linux (i.e. RHEL and CentOS).",
          "48:         'cflags!': [ '-ffunction-sections', '-fdata-sections' ],",
          "49:         'cflags': [ '-O3' ],",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:             # pull in V8's postmortem metadata",
          "53:             'ldflags': [ '-Wl,-z,allextract' ]",
          "54:           }],",
          "58:         ],",
          "59:         'msvs_settings': {",
          "60:           'VCCLCompilerTool': {",
          "",
          "[Removed Lines]",
          "55:           ['node_no_strict_aliasing==1', {",
          "56:             'cflags': [ '-fno-strict-aliasing' ],",
          "57:           }],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
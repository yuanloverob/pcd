{
  "cve_id": "CVE-2017-3730",
  "cve_desc": "In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.",
  "repo": "openssl/openssl",
  "patch_hash": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
  "patch_info": {
    "commit_hash": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa",
    "files": [
      "ssl/statem/statem_clnt.c"
    ],
    "message": "Fix missing NULL checks in CKE processing\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "ssl/statem/statem_clnt.c||ssl/statem/statem_clnt.c"
    ]
  },
  "patch_diff": {
    "ssl/statem/statem_clnt.c||ssl/statem/statem_clnt.c": [
      "File: ssl/statem/statem_clnt.c -> ssl/statem/statem_clnt.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2258:         return 0;",
      "2259:     }",
      "2260:     ckey = ssl_generate_pkey(skey);",
      "2261:     dh_clnt = EVP_PKEY_get0_DH(ckey);",
      "2263:     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2261:     if (ckey == NULL) {",
      "2262:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);",
      "2263:         return 0;",
      "2264:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2296:     }",
      "2298:     ckey = ssl_generate_pkey(skey);",
      "2300:     if (ssl_derive(s, ckey, skey) == 0) {",
      "2301:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2304:     if (ckey == NULL) {",
      "2305:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);",
      "2306:         goto err;",
      "2307:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "79844cbba576098675317b95ee4fc1cfc84fa784",
      "candidate_info": {
        "commit_hash": "79844cbba576098675317b95ee4fc1cfc84fa784",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/79844cbba576098675317b95ee4fc1cfc84fa784",
        "files": [
          "Configurations/descrip.mms.tmpl"
        ],
        "message": "descrip.mms.tmpl: in obj2bin, make sure an empty @deps means no empty lines\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(cherry picked from commit 47852e6ae763a40ddc3538c76a02be06fd0595a5)",
        "before_after_code_files": [
          "Configurations/descrip.mms.tmpl||Configurations/descrip.mms.tmpl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Configurations/descrip.mms.tmpl||Configurations/descrip.mms.tmpl": [
          "File: Configurations/descrip.mms.tmpl -> Configurations/descrip.mms.tmpl",
          "--- Hunk 1 ---",
          "[Context before]",
          "677:       # previous line's file spec as default, so if no directory spec",
          "678:       # is present in the current line and the previous line has one that",
          "679:       # doesn't apply, you're in for a surprise.",
          "681:           join(\",-\\\"\\n\\t\", map { my $x = $_ =~ /\\[/ ? $_ : \"[]\".$_;",
          "682:                                  \"WRITE OPT_FILE \\\"$x\" } @objs).",
          "684:           join(\"\\n\\t\", map { my $x = $_ =~ /\\[/ ? $_ : \"[]\".$_;",
          "685:                              $x =~ s|(\\.EXE)|$1/SHARE|;",
          "686:                              $x =~ s|(\\.OLB)|$1/LIB|;",
          "",
          "[Removed Lines]",
          "680:       my $write_opt =",
          "683:           \"\\\"\\n\\t\".",
          "",
          "[Added Lines]",
          "680:       my $write_opt1 =",
          "683:           \"\\\"\";",
          "684:       my $write_opt2 =",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "690: $lib.EXE : $deps",
          "691:         OPEN/WRITE/SHARE=READ OPT_FILE $lib.OPT",
          "692:         TYPE $engine_opt /OUTPUT=OPT_FILE:",
          "694:         CLOSE OPT_FILE",
          "695:         LINK /MAP=$lib.MAP /FULL/SHARE=$lib.EXE $lib.OPT/OPT \\$(EX_LIBS)",
          "696:         - PURGE $lib.EXE,$lib.OPT,$lib.MAP",
          "",
          "[Removed Lines]",
          "693:         $write_opt",
          "",
          "[Added Lines]",
          "694:         $write_opt1",
          "695:         $write_opt2",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "723:       # previous line's file spec as default, so if no directory spec",
          "724:       # is present in the current line and the previous line has one that",
          "725:       # doesn't apply, you're in for a surprise.",
          "727:           join(\",-\\\"\\n\\t\", map { my $x = $_ =~ /\\[/ ? $_ : \"[]\".$_;",
          "728:                                  \"WRITE OPT_FILE \\\"$x\" } @objs).",
          "730:           join(\"\\n\\t\", map { my $x = $_ =~ /\\[/ ? $_ : \"[]\".$_;",
          "731:                              $x =~ s|(\\.EXE)|$1/SHARE|;",
          "732:                              $x =~ s|(\\.OLB)|$1/LIB|;",
          "",
          "[Removed Lines]",
          "726:       my $write_opt =",
          "729:           \"\\\"\\n\\t\".",
          "",
          "[Added Lines]",
          "728:       my $write_opt1 =",
          "731:           \"\\\"\";",
          "732:       my $write_opt2 =",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "735:       return <<\"EOF\";",
          "736: $bin.EXE : $deps",
          "737:         OPEN/WRITE/SHARE=READ OPT_FILE $bin.OPT",
          "739:         CLOSE OPT_FILE",
          "740:         LINK/EXEC=$bin.EXE \\$(LDFLAGS) $bin.OPT/OPT \\$(EX_LIBS)",
          "741:         - PURGE $bin.EXE,$bin.OPT",
          "",
          "[Removed Lines]",
          "738:         $write_opt",
          "",
          "[Added Lines]",
          "741:         $write_opt1",
          "742:         $write_opt2",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "feb879b098f90745a0394005f38b481c68b74ad4",
      "candidate_info": {
        "commit_hash": "feb879b098f90745a0394005f38b481c68b74ad4",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/feb879b098f90745a0394005f38b481c68b74ad4",
        "files": [
          "crypto/ui/ui_openssl.c"
        ],
        "message": "VMS UI_OpenSSL: if the TT device isn't a tty, flag instead of error\n\nOn all platforms, if the controlling tty isn't an actual tty, this is\nflagged by setting is_a_tty to zero...  except on VMS, where this was\ntreated as an error.  Change this to behave like the other platforms.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2063)\n(cherry picked from commit 18edbe6519bd5b738bf410b23f437df3005526e3)",
        "before_after_code_files": [
          "crypto/ui/ui_openssl.c||crypto/ui/ui_openssl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/ui/ui_openssl.c||crypto/ui/ui_openssl.c": [
          "File: crypto/ui/ui_openssl.c -> crypto/ui/ui_openssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "445: #endif",
          "446: #ifdef OPENSSL_SYS_VMS",
          "447:     status = sys$assign(&terminal, &channel, 0, 0);",
          "448:     if (status != SS$_NORMAL)",
          "449:         return 0;",
          "453:     if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "455: #endif",
          "456:     return 1;",
          "457: }",
          "",
          "[Removed Lines]",
          "450:     status =",
          "451:         sys$qiow(0, channel, IO$_SENSEMODE, &iosb, 0, 0, tty_orig, 12, 0, 0,",
          "452:                  0, 0);",
          "454:         return 0;",
          "",
          "[Added Lines]",
          "453:     status = sys$qiow(0, channel, IO$_SENSEMODE, &iosb, 0, 0, tty_orig, 12,",
          "454:                       0, 0, 0, 0);",
          "458:         is_a_tty = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "468:         return 0;",
          "469: #endif",
          "470: #ifdef OPENSSL_SYS_VMS",
          "479: #endif",
          "480: #if defined(_WIN32) && !defined(_WIN32_WCE)",
          "481:     if (is_a_tty) {",
          "",
          "[Removed Lines]",
          "471:     tty_new[0] = tty_orig[0];",
          "472:     tty_new[1] = tty_orig[1] | TT$M_NOECHO;",
          "473:     tty_new[2] = tty_orig[2];",
          "474:     status =",
          "475:         sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12, 0, 0, 0,",
          "476:                  0);",
          "477:     if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "478:         return 0;",
          "",
          "[Added Lines]",
          "475:     if (is_a_tty) {",
          "476:         tty_new[0] = tty_orig[0];",
          "477:         tty_new[1] = tty_orig[1] | TT$M_NOECHO;",
          "478:         tty_new[2] = tty_orig[2];",
          "479:         status = sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12,",
          "480:                           0, 0, 0, 0);",
          "481:         if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "482:             return 0;",
          "483:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "499:         return 0;",
          "500: #endif",
          "501: #ifdef OPENSSL_SYS_VMS",
          "510: #endif",
          "511: #if defined(_WIN32) && !defined(_WIN32_WCE)",
          "512:     if (is_a_tty) {",
          "",
          "[Removed Lines]",
          "502:     tty_new[0] = tty_orig[0];",
          "503:     tty_new[1] = tty_orig[1] & ~TT$M_NOECHO;",
          "504:     tty_new[2] = tty_orig[2];",
          "505:     status =",
          "506:         sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12, 0, 0, 0,",
          "507:                  0);",
          "508:     if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "509:         return 0;",
          "",
          "[Added Lines]",
          "507:     if (is_a_tty) {",
          "508:         tty_new[0] = tty_orig[0];",
          "509:         tty_new[1] = tty_orig[1] & ~TT$M_NOECHO;",
          "510:         tty_new[2] = tty_orig[2];",
          "511:         status = sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12,",
          "512:                           0, 0, 0, 0);",
          "513:         if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "514:             return 0;",
          "515:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "526:         fclose(tty_out);",
          "527: #ifdef OPENSSL_SYS_VMS",
          "528:     status = sys$dassgn(channel);",
          "529: #endif",
          "530:     CRYPTO_THREAD_unlock(ui->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535:     if (status != SS$_NORMAL)",
          "536:         return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "384fd75ad822569a61fe43235df270b2948a8f7d",
      "candidate_info": {
        "commit_hash": "384fd75ad822569a61fe43235df270b2948a8f7d",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/384fd75ad822569a61fe43235df270b2948a8f7d",
        "files": [
          "test/recipes/70-test_sslcbcpadding.t",
          "util/TLSProxy/Message.pm",
          "util/TLSProxy/Proxy.pm"
        ],
        "message": "Test CBC mode padding.\n\nThis is a regression test for\nhttps://github.com/openssl/openssl/pull/1431. It tests a\nmaximally-padded record with each possible invalid offset.\n\nThis required fixing a bug in Message.pm where the client sending a\nfatal alert followed by close_notify was still treated as success.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(cherry picked from commit 8523288e6d667f052bda092e01ab17986782fede)",
        "before_after_code_files": [
          "test/recipes/70-test_sslcbcpadding.t||test/recipes/70-test_sslcbcpadding.t",
          "util/TLSProxy/Message.pm||util/TLSProxy/Message.pm",
          "util/TLSProxy/Proxy.pm||util/TLSProxy/Proxy.pm"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/recipes/70-test_sslcbcpadding.t||test/recipes/70-test_sslcbcpadding.t": [
          "File: test/recipes/70-test_sslcbcpadding.t -> test/recipes/70-test_sslcbcpadding.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #! /usr/bin/env perl",
          "2: # Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.",
          "3: #",
          "4: # Licensed under the OpenSSL license (the \"License\").  You may not use",
          "5: # this file except in compliance with the License.  You can obtain a copy",
          "6: # in the file LICENSE in the source distribution or at",
          "7: # https://www.openssl.org/source/license.html",
          "9: use strict;",
          "10: use OpenSSL::Test qw/:DEFAULT cmdstr srctop_file bldtop_dir/;",
          "11: use OpenSSL::Test::Utils;",
          "12: use TLSProxy::Proxy;",
          "14: my $test_name = \"test_sslcbcpadding\";",
          "15: setup($test_name);",
          "17: plan skip_all => \"TLSProxy isn't usable on $^O\"",
          "18:     if $^O =~ /^(VMS|MSWin32)$/;",
          "20: plan skip_all => \"$test_name needs the dynamic engine feature enabled\"",
          "21:     if disabled(\"engine\") || disabled(\"dynamic-engine\");",
          "23: plan skip_all => \"$test_name needs the sock feature enabled\"",
          "24:     if disabled(\"sock\");",
          "26: plan skip_all => \"$test_name needs TLSv1.2 enabled\"",
          "27:     if disabled(\"tls1_2\");",
          "29: $ENV{OPENSSL_ia32cap} = '~0x200000200000000';",
          "30: my $proxy = TLSProxy::Proxy->new(",
          "31:     \\&add_maximal_padding_filter,",
          "32:     cmdstr(app([\"openssl\"]), display => 1),",
          "33:     srctop_file(\"apps\", \"server.pem\"),",
          "34:     (!$ENV{HARNESS_ACTIVE} || $ENV{HARNESS_VERBOSE})",
          "35: );",
          "37: plan tests => 1 + 256;",
          "39: my $bad_padding_offset = -1;",
          "41: # Test 1: Maximally-padded records are accepted.",
          "42: $proxy->start() or plan skip_all => \"Unable to start up Proxy for tests\";",
          "43: ok(TLSProxy::Message->success(), \"Maximally-padded record test\");",
          "45: # Tests 2 through 257: Invalid padding.",
          "46: for ($bad_padding_offset = 0; $bad_padding_offset < 256;",
          "47:      $bad_padding_offset++) {",
          "48:     $proxy->clear();",
          "49:     $proxy->start() or plan skip_all => \"Unable to start up Proxy for tests\";;",
          "50:     ok(TLSProxy::Message->fail(), \"Invalid padding byte $bad_padding_offset\");",
          "51: }",
          "53: sub add_maximal_padding_filter",
          "54: {",
          "55:     my $proxy = shift;",
          "57:     if ($proxy->flight == 0) {",
          "58:         # Disable Encrypt-then-MAC.",
          "59:         foreach my $message (@{$proxy->message_list}) {",
          "60:             if ($message->mt != TLSProxy::Message::MT_CLIENT_HELLO) {",
          "61:                 next;",
          "62:             }",
          "64:             $message->delete_extension(TLSProxy::Message::EXT_ENCRYPT_THEN_MAC);",
          "65:             $message->process_extensions();",
          "66:             $message->repack();",
          "67:         }",
          "68:     }",
          "70:     if ($proxy->flight == 3) {",
          "71:         # Insert a maximally-padded record. Assume a block size of 16 (AES) and",
          "72:         # a MAC length of 20 (SHA-1).",
          "73:         my $block_size = 16;",
          "74:         my $mac_len = 20;",
          "76:         # Size the plaintext so that 256 is a valid padding.",
          "77:         my $plaintext_len = $block_size - ($mac_len % $block_size);",
          "78:         my $plaintext = \"A\" x $plaintext_len;",
          "80:         my $data = \"B\" x $block_size; # Explicit IV.",
          "81:         $data .= $plaintext;",
          "82:         $data .= TLSProxy::Proxy::fill_known_data($mac_len); # MAC.",
          "84:         # Add padding.",
          "85:         for (my $i = 0; $i < 256; $i++) {",
          "86:             if ($i == $bad_padding_offset) {",
          "87:                 $data .= \"\\xfe\";",
          "88:             } else {",
          "89:                 $data .= \"\\xff\";",
          "90:             }",
          "91:         }",
          "93:         my $record = TLSProxy::Record->new(",
          "94:             $proxy->flight,",
          "95:             TLSProxy::Record::RT_APPLICATION_DATA,",
          "96:             TLSProxy::Record::VERS_TLS_1_2,",
          "97:             length($data),",
          "98:             length($data),",
          "99:             $plaintext_len,",
          "100:             $data,",
          "101:             $plaintext,",
          "102:         );",
          "104:         # Send the record immediately after the server Finished.",
          "105:         push @{$proxy->record_list}, $record;",
          "106:     }",
          "107: }",
          "",
          "---------------"
        ],
        "util/TLSProxy/Message.pm||util/TLSProxy/Message.pm": [
          "File: util/TLSProxy/Message.pm -> util/TLSProxy/Message.pm",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:         print \"  [\".$record->decrypt_data.\"]\\n\";",
          "200:     } elsif ($record->content_type == TLSProxy::Record::RT_ALERT) {",
          "201:         my ($alertlev, $alertdesc) = unpack('CC', $record->decrypt_data);",
          "204:         #A CloseNotify from the client indicates we have finished successfully",
          "205:         #(we assume)",
          "207:             && $alertdesc == AL_DESC_CLOSE_NOTIFY) {",
          "208:             $success = 1;",
          "209:         }",
          "210:     }",
          "212:     return @messages;",
          "",
          "[Removed Lines]",
          "202:         #All alerts end the test",
          "203:         $end = 1;",
          "206:         if (!$server && $alertlev == AL_LEVEL_WARN",
          "",
          "[Added Lines]",
          "204:         if (!$end && !$server && $alertlev == AL_LEVEL_WARN",
          "208:         #All alerts end the test",
          "209:         $end = 1;",
          "",
          "---------------"
        ],
        "util/TLSProxy/Proxy.pm||util/TLSProxy/Proxy.pm": [
          "File: util/TLSProxy/Proxy.pm -> util/TLSProxy/Proxy.pm",
          "--- Hunk 1 ---",
          "[Context before]",
          "493:     }",
          "494:     return $self->{serverpid};",
          "495: }",
          "496: 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "497: sub fill_known_data",
          "498: {",
          "499:     my $length = shift;",
          "500:     my $ret = \"\";",
          "501:     for (my $i = 0; $i < $length; $i++) {",
          "502:         $ret .= chr($i);",
          "503:     }",
          "504:     return $ret;",
          "505: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d8d3b66971dab2b54dd0946d85fd45a2470714a8",
      "candidate_info": {
        "commit_hash": "d8d3b66971dab2b54dd0946d85fd45a2470714a8",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/d8d3b66971dab2b54dd0946d85fd45a2470714a8",
        "files": [
          "apps/rehash.c"
        ],
        "message": "Make \"openssl rehash\" work on VMS 8.3 and up\n\nA spelling error prevented it from building correctly.\nFurthermore, we need to be more careful when to add a / at the end\nof the dirname and when not.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2706)\n(cherry picked from commit 5c80e2af3a7d8aa5129a1668c286c1464983e1ac)",
        "before_after_code_files": [
          "apps/rehash.c||apps/rehash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "apps/rehash.c||apps/rehash.c": [
          "File: apps/rehash.c -> apps/rehash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"apps.h\"",
          "18: #if defined(OPENSSL_SYS_UNIX) || defined(__APPLE__) || \\",
          "20: # include <unistd.h>",
          "21: # include <stdio.h>",
          "22: # include <limits.h>",
          "",
          "[Removed Lines]",
          "19:     (defined(__VMS) && defined(__DECC) && __CTRL_VER >= 80300000)",
          "",
          "[Added Lines]",
          "19:     (defined(__VMS) && defined(__DECC) && __CRTL_VER >= 80300000)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "267:     OPENSSL_free(s);",
          "268: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270: static int ends_with_dirsep(const char *path)",
          "271: {",
          "272:     if (*path != '\\0')",
          "273:         path += strlen(path) - 1;",
          "274: # ifdef __VMS",
          "275:     if (*path == ']' || *path == '>' || *path == ':')",
          "276:         return 1;",
          "277: # elif _WIN32",
          "278:     if (*path == '\\\\')",
          "279:         return 1;",
          "280: # endif",
          "281:     return *path == '/';",
          "282: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "289:         return 1;",
          "290:     }",
          "291:     buflen = strlen(dirname);",
          "293:     buflen += NAME_MAX + 1 + 1;",
          "294:     buf = app_malloc(buflen, \"filename buffer\");",
          "",
          "[Removed Lines]",
          "292:     pathsep = (buflen && dirname[buflen - 1] == '/') ? \"\" : \"/\";",
          "",
          "[Added Lines]",
          "306:     pathsep = (buflen && !ends_with_dirsep(dirname)) ? \"/\": \"\";",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a3b94c9c2b577fa86a405e9119a75c785872f3b0",
      "candidate_info": {
        "commit_hash": "a3b94c9c2b577fa86a405e9119a75c785872f3b0",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/a3b94c9c2b577fa86a405e9119a75c785872f3b0",
        "files": [
          "crypto/engine/eng_cryptodev.c"
        ],
        "message": "GH1546: Fix old names in cryptodev code.\n\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1584)\n(cherry picked from commit a8a8a917c0c0d36162fdc0cbf84ab17282cef3e9)",
        "before_after_code_files": [
          "crypto/engine/eng_cryptodev.c||crypto/engine/eng_cryptodev.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/engine/eng_cryptodev.c||crypto/engine/eng_cryptodev.c": [
          "File: crypto/engine/eng_cryptodev.c -> crypto/engine/eng_cryptodev.c"
        ]
      }
    }
  ]
}
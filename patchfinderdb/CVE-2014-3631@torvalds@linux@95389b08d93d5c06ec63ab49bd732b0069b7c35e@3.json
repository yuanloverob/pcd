{
  "cve_id": "CVE-2014-3631",
  "cve_desc": "The assoc_array_gc function in the associative-array implementation in lib/assoc_array.c in the Linux kernel before 3.16.3 does not properly implement garbage collection, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via multiple \"keyctl newring\" operations followed by a \"keyctl timeout\" operation.",
  "repo": "torvalds/linux",
  "patch_hash": "95389b08d93d5c06ec63ab49bd732b0069b7c35e",
  "patch_info": {
    "commit_hash": "95389b08d93d5c06ec63ab49bd732b0069b7c35e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/95389b08d93d5c06ec63ab49bd732b0069b7c35e",
    "files": [
      "lib/assoc_array.c"
    ],
    "message": "KEYS: Fix termination condition in assoc array garbage collection\n\nThis fixes CVE-2014-3631.\n\nIt is possible for an associative array to end up with a shortcut node at the\nroot of the tree if there are more than fan-out leaves in the tree, but they\nall crowd into the same slot in the lowest level (ie. they all have the same\nfirst nibble of their index keys).\n\nWhen assoc_array_gc() returns back up the tree after scanning some leaves, it\ncan fall off of the root and crash because it assumes that the back pointer\nfrom a shortcut (after label ascend_old_tree) must point to a normal node -\nwhich isn't true of a shortcut node at the root.\n\nShould we find we're ascending rootwards over a shortcut, we should check to\nsee if the backpointer is zero - and if it is, we have completed the scan.\n\nThis particular bug cannot occur if the root node is not a shortcut - ie. if\nyou have fewer than 17 keys in a keyring or if you have at least two keys that\nsit into separate slots (eg. a keyring and a non keyring).\n\nThis can be reproduced by:\n\n\tring=`keyctl newring bar @s`\n\tfor ((i=1; i<=18; i++)); do last_key=`keyctl newring foo$i $ring`; done\n\tkeyctl timeout $last_key 2\n\nDoing this:\n\n\techo 3 >/proc/sys/kernel/keys/gc_delay\n\nfirst will speed things up.\n\nIf we do fall off of the top of the tree, we get the following oops:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000018\nIP: [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540\nPGD dae15067 PUD cfc24067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: xt_nat xt_mark nf_conntrack_netbios_ns nf_conntrack_broadcast ip6t_rpfilter ip6t_REJECT xt_conntrack ebtable_nat ebtable_broute bridge stp llc ebtable_filter ebtables ip6table_ni\nCPU: 0 PID: 26011 Comm: kworker/0:1 Not tainted 3.14.9-200.fc20.x86_64 #1\nHardware name: Bochs Bochs, BIOS Bochs 01/01/2011\nWorkqueue: events key_garbage_collector\ntask: ffff8800918bd580 ti: ffff8800aac14000 task.ti: ffff8800aac14000\nRIP: 0010:[<ffffffff8136cea7>] [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540\nRSP: 0018:ffff8800aac15d40  EFLAGS: 00010206\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff8800aaecacc0\nRDX: ffff8800daecf440 RSI: 0000000000000001 RDI: ffff8800aadc2bc0\nRBP: ffff8800aac15da8 R08: 0000000000000001 R09: 0000000000000003\nR10: ffffffff8136ccc7 R11: 0000000000000000 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000070 R15: 0000000000000001\nFS:  0000000000000000(0000) GS:ffff88011fc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 0000000000000018 CR3: 00000000db10d000 CR4: 00000000000006f0\nStack:\n ffff8800aac15d50 0000000000000011 ffff8800aac15db8 ffffffff812e2a70\n ffff880091a00600 0000000000000000 ffff8800aadc2bc3 00000000cd42c987\n ffff88003702df20 ffff88003702dfa0 0000000053b65c09 ffff8800aac15fd8\nCall Trace:\n [<ffffffff812e2a70>] ? keyring_detect_cycle_iterator+0x30/0x30\n [<ffffffff812e3e75>] keyring_gc+0x75/0x80\n [<ffffffff812e1424>] key_garbage_collector+0x154/0x3c0\n [<ffffffff810a67b6>] process_one_work+0x176/0x430\n [<ffffffff810a744b>] worker_thread+0x11b/0x3a0\n [<ffffffff810a7330>] ? rescuer_thread+0x3b0/0x3b0\n [<ffffffff810ae1a8>] kthread+0xd8/0xf0\n [<ffffffff810ae0d0>] ? insert_kthread_work+0x40/0x40\n [<ffffffff816ffb7c>] ret_from_fork+0x7c/0xb0\n [<ffffffff810ae0d0>] ? insert_kthread_work+0x40/0x40\nCode: 08 4c 8b 22 0f 84 bf 00 00 00 41 83 c7 01 49 83 e4 fc 41 83 ff 0f 4c 89 65 c0 0f 8f 5a fe ff ff 48 8b 45 c0 4d 63 cf 49 83 c1 02 <4e> 8b 34 c8 4d 85 f6 0f 84 be 00 00 00 41 f6 c6 01 0f 84 92\nRIP  [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540\n RSP <ffff8800aac15d40>\nCR2: 0000000000000018\n---[ end trace 1129028a088c0cbd ]---\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Don Zickus <dzickus@redhat.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "before_after_code_files": [
      "lib/assoc_array.c||lib/assoc_array.c"
    ]
  },
  "patch_diff": {
    "lib/assoc_array.c||lib/assoc_array.c": [
      "File: lib/assoc_array.c -> lib/assoc_array.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1723:   shortcut = assoc_array_ptr_to_shortcut(ptr);",
      "1724:   slot = shortcut->parent_slot;",
      "1725:   cursor = shortcut->back_pointer;",
      "1726:  } else {",
      "1727:   slot = node->parent_slot;",
      "1728:   cursor = ptr;",
      "1729:  }",
      "1731:  node = assoc_array_ptr_to_node(cursor);",
      "1732:  slot++;",
      "1733:  goto continue_node;",
      "",
      "[Removed Lines]",
      "1730:  BUG_ON(!ptr);",
      "",
      "[Added Lines]",
      "1726:   if (!cursor)",
      "1727:    goto gc_complete;",
      "1732:  BUG_ON(!cursor);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cc8aa7de48277f62fe3fced762d75f01ce57e909",
      "candidate_info": {
        "commit_hash": "cc8aa7de48277f62fe3fced762d75f01ce57e909",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cc8aa7de48277f62fe3fced762d75f01ce57e909",
        "files": [
          "drivers/mmc/core/core.c"
        ],
        "message": "mmc: core: resolve divded by zero panic\n\nWith one special SD card, below divide by zero error observed:\n...\n[    2.144300] divide error: 0000 [#1] PREEMPT SMP\n[    2.148860] Modules linked in:\n[    2.151898]\n[    2.152685] Set up 4031 stolen pages starting at 0x0001f000, GTT offset 0K\n[    2.157330] Set up 0 CI stolen pages starting at 0x00000000, GTT offset 131072K\n[    2.167581] Pid: 5, comm: kworker/u:0 Not tainted 3.0.8-138216-g974a2ab #1\n[    2.169506] [drm] PSB GTT mem manager ready, tt_start 4031, tt_size 28737 pages\n[    2.169906] [drm] SGX core id = 0x00000000\n[    2.169920] [drm] SGX core rev major = 0x00, minor = 0x00\n[    2.169934] [drm] SGX core rev maintenance = 0x00, designer = 0x00\n[    2.197370]  Intel Corporation Medfield/iCDKB\n[    2.201716] EIP: 0060:[<c1697ca6>] EFLAGS: 00010246 CPU: 1\n[    2.207198] EIP is at mmc_init_erase+0x76/0x150\n[    2.211704] EAX: 00002000 EBX: dcd1b400 ECX: 00002000 EDX: 00000000\n[    2.217957] ESI: 00000000 EDI: dcd5c800 EBP: dd867e84 ESP: dd867e7c\n[    2.224214]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068\n[    2.229605] Process kworker/u:0 (pid: 5, ti=dd866000 task=dd868000 task.ti=dd866000)\n[    2.237325] Stack:\n[    2.239322]  dcd1b400 00000000 dd867eb0 c16a06da c1ab7c44 dd995aa8 00000003 00000000\n[    2.247054]  00000000 00000000 dcd5c800 00000000 dcd1b400 dd867ef8 c16a1012 c1698b00\n[    2.254785]  00000029 00000001 c194eb80 dcd5c9ec dd867e00 c1239b00 00000000 00000000\n[    2.262519] Call Trace:\n[    2.264975]  [<c16a06da>] mmc_sd_setup_card+0x1da/0x4f0\n[    2.270183]  [<c16a1012>] mmc_sd_init_card+0x192/0xc40\n[    2.275304]  [<c1698b00>] ? __mmc_claim_host+0x160/0x160\n[    2.280610]  [<c1239b00>] ? __schedule_bug+0x50/0x80\n[    2.285556]  [<c16a1b89>] mmc_attach_sd+0xc9/0x230\n[    2.290333]  [<c169b6ef>] mmc_rescan+0x25f/0x2c0\n[    2.294943]  [<c1274223>] process_one_work+0x103/0x400\n[    2.300065]  [<c12670fd>] ? mod_timer+0x1ad/0x3c0\n[    2.304756]  [<c169b490>] ? mmc_suspend_host+0x1a0/0x1a0\n[    2.310056]  [<c127502d>] worker_thread+0x12d/0x4a0\n[    2.314921]  [<c18fcfbd>] ? preempt_schedule+0x2d/0x50\n[    2.320047]  [<c1274f00[    2.323976] ---[ end trace 5398ec2720494438 ]---\n...\n\nSo, seems this bad SD card does not set valid value in related SSR / CSD register fields.\nAnd then the driver will set card->erase_size to 0.\nThen it triggered this divided by zero error when calculate card->pref_erase.\n\nSubmit this patch to fix the issue.\n\nSigned-off-by: Yunpeng Gao <yunpeng.gao@intel.com>\nSigned-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>\nSigned-off-by: Ulf Hansson <ulf.hansson@linaro.org>",
        "before_after_code_files": [
          "drivers/mmc/core/core.c||drivers/mmc/core/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mmc/core/core.c||drivers/mmc/core/core.c": [
          "File: drivers/mmc/core/core.c -> drivers/mmc/core/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1753:   card->erase_shift = ffs(card->ssr.au) - 1;",
          "1754:  } else if (card->ext_csd.hc_erase_size) {",
          "1755:   card->pref_erase = card->ext_csd.hc_erase_size;",
          "1757:   sz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;",
          "1758:   if (sz < 128)",
          "1759:    card->pref_erase = 512 * 1024 / 512;",
          "",
          "[Removed Lines]",
          "1756:  } else {",
          "",
          "[Added Lines]",
          "1756:  } else if (card->erase_size) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1770:    if (sz)",
          "1771:     card->pref_erase += card->erase_size - sz;",
          "1772:   }",
          "1774: }",
          "1776: static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,",
          "",
          "[Removed Lines]",
          "1773:  }",
          "",
          "[Added Lines]",
          "1773:  } else",
          "1774:   card->pref_erase = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58a32d91306787d6733767321a14c39afc136d93",
      "candidate_info": {
        "commit_hash": "58a32d91306787d6733767321a14c39afc136d93",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/58a32d91306787d6733767321a14c39afc136d93",
        "files": [
          "arch/arm/boot/dts/imx28-tx28.dts"
        ],
        "message": "ARM: dts: imx28-tx28: Fix display duplicate name warning\n\nThe lcdif node has a property named \"display\" and also a child node\ncalled \"display\", which causes the following warning:\n\ndevice-tree: Duplicate name in lcdif@80030000, renamed to \"display#1\"\n\nRename the child node name in order to avoid the warning.\n\nSigned-off-by: Fabio Estevam <fabio.estevam@freescale.com>\nAcked-by: Lothar Wa\u00dfmann <LW@KARO-electronics.de>\nSigned-off-by: Shawn Guo <shawn.guo@freescale.com>",
        "before_after_code_files": [
          "arch/arm/boot/dts/imx28-tx28.dts||arch/arm/boot/dts/imx28-tx28.dts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm/boot/dts/imx28-tx28.dts||arch/arm/boot/dts/imx28-tx28.dts": [
          "File: arch/arm/boot/dts/imx28-tx28.dts -> arch/arm/boot/dts/imx28-tx28.dts",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  aliases {",
          "22:   can0 = &can0;",
          "23:   can1 = &can1;",
          "25:   ds1339 = &ds1339;",
          "26:   gpio5 = &gpio5;",
          "27:   lcdif = &lcdif;",
          "",
          "[Removed Lines]",
          "24:   display = &display;",
          "",
          "[Added Lines]",
          "24:   display = &display0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "309:  pinctrl-names = \"default\";",
          "310:  pinctrl-0 = <&lcdif_24bit_pins_a &lcdif_sync_pins_a &tx28_lcdif_ctrl_pins>;",
          "311:  lcd-supply = <&reg_lcd>;",
          "313:  status = \"okay\";",
          "316:   bits-per-pixel = <32>;",
          "317:   bus-width = <24>;",
          "318:   display-timings {",
          "",
          "[Removed Lines]",
          "312:  display = <&display>;",
          "315:  display: display@0 {",
          "",
          "[Added Lines]",
          "312:  display = <&display0>;",
          "315:  display0: display0 {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3cb989501c2688cacbb7dc4b0d353faf838f53a1",
      "candidate_info": {
        "commit_hash": "3cb989501c2688cacbb7dc4b0d353faf838f53a1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3cb989501c2688cacbb7dc4b0d353faf838f53a1",
        "files": [
          "Documentation/assoc_array.txt",
          "include/linux/assoc_array.h",
          "include/linux/assoc_array_priv.h",
          "lib/Kconfig",
          "lib/Makefile",
          "lib/assoc_array.c"
        ],
        "message": "Add a generic associative array implementation.\n\nAdd a generic associative array implementation that can be used as the\ncontainer for keyrings, thereby massively increasing the capacity available\nwhilst also speeding up searching in keyrings that contain a lot of keys.\n\nThis may also be useful in FS-Cache for tracking cookies.\n\nDocumentation is added into Documentation/associative_array.txt\n\nSome of the properties of the implementation are:\n\n (1) Objects are opaque pointers.  The implementation does not care where they\n     point (if anywhere) or what they point to (if anything).\n\n     [!] NOTE: Pointers to objects _must_ be zero in the two least significant\n     \t       bits.\n\n (2) Objects do not need to contain linkage blocks for use by the array.  This\n     permits an object to be located in multiple arrays simultaneously.\n     Rather, the array is made up of metadata blocks that point to objects.\n\n (3) Objects are labelled as being one of two types (the type is a bool value).\n     This information is stored in the array, but has no consequence to the\n     array itself or its algorithms.\n\n (4) Objects require index keys to locate them within the array.\n\n (5) Index keys must be unique.  Inserting an object with the same key as one\n     already in the array will replace the old object.\n\n (6) Index keys can be of any length and can be of different lengths.\n\n (7) Index keys should encode the length early on, before any variation due to\n     length is seen.\n\n (8) Index keys can include a hash to scatter objects throughout the array.\n\n (9) The array can iterated over.  The objects will not necessarily come out in\n     key order.\n\n(10) The array can be iterated whilst it is being modified, provided the RCU\n     readlock is being held by the iterator.  Note, however, under these\n     circumstances, some objects may be seen more than once.  If this is a\n     problem, the iterator should lock against modification.  Objects will not\n     be missed, however, unless deleted.\n\n(11) Objects in the array can be looked up by means of their index key.\n\n(12) Objects can be looked up whilst the array is being modified, provided the\n     RCU readlock is being held by the thread doing the look up.\n\nThe implementation uses a tree of 16-pointer nodes internally that are indexed\non each level by nibbles from the index key.  To improve memory efficiency,\nshortcuts can be emplaced to skip over what would otherwise be a series of\nsingle-occupancy nodes.  Further, nodes pack leaf object pointers into spare\nspace in the node rather than making an extra branch until as such time an\nobject needs to be added to a full node.\n\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "include/linux/assoc_array.h||include/linux/assoc_array.h",
          "include/linux/assoc_array_priv.h||include/linux/assoc_array_priv.h",
          "lib/assoc_array.c||lib/assoc_array.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/assoc_array.c||lib/assoc_array.c"
          ],
          "candidate": [
            "lib/assoc_array.c||lib/assoc_array.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/assoc_array.h||include/linux/assoc_array.h": [
          "File: include/linux/assoc_array.h -> include/linux/assoc_array.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #ifndef _LINUX_ASSOC_ARRAY_H",
          "15: #define _LINUX_ASSOC_ARRAY_H",
          "17: #ifdef CONFIG_ASSOCIATIVE_ARRAY",
          "19: #include <linux/types.h>",
          "26: struct assoc_array {",
          "28:  unsigned long  nr_leaves_on_tree;",
          "29: };",
          "34: struct assoc_array_ops {",
          "36:  unsigned long (*get_key_chunk)(const void *index_key, int level);",
          "39:  unsigned long (*get_object_key_chunk)(const void *object, int level);",
          "42:  bool (*compare_object)(const void *object, const void *index_key);",
          "47:  int (*diff_objects)(const void *a, const void *b);",
          "50:  void (*free_object)(void *object);",
          "51: };",
          "56: struct assoc_array_edit;",
          "58: static inline void assoc_array_init(struct assoc_array *array)",
          "59: {",
          "60:  array->root = NULL;",
          "61:  array->nr_leaves_on_tree = 0;",
          "62: }",
          "64: extern int assoc_array_iterate(const struct assoc_array *array,",
          "65:           int (*iterator)(const void *object,",
          "66:             void *iterator_data),",
          "67:           void *iterator_data);",
          "68: extern void *assoc_array_find(const struct assoc_array *array,",
          "69:          const struct assoc_array_ops *ops,",
          "70:          const void *index_key);",
          "71: extern void assoc_array_destroy(struct assoc_array *array,",
          "72:     const struct assoc_array_ops *ops);",
          "73: extern struct assoc_array_edit *assoc_array_insert(struct assoc_array *array,",
          "74:          const struct assoc_array_ops *ops,",
          "75:          const void *index_key,",
          "76:          void *object);",
          "77: extern void assoc_array_insert_set_object(struct assoc_array_edit *edit,",
          "78:        void *object);",
          "79: extern struct assoc_array_edit *assoc_array_delete(struct assoc_array *array,",
          "80:          const struct assoc_array_ops *ops,",
          "81:          const void *index_key);",
          "82: extern struct assoc_array_edit *assoc_array_clear(struct assoc_array *array,",
          "83:         const struct assoc_array_ops *ops);",
          "84: extern void assoc_array_apply_edit(struct assoc_array_edit *edit);",
          "85: extern void assoc_array_cancel_edit(struct assoc_array_edit *edit);",
          "86: extern int assoc_array_gc(struct assoc_array *array,",
          "87:      const struct assoc_array_ops *ops,",
          "88:      bool (*iterator)(void *object, void *iterator_data),",
          "89:      void *iterator_data);",
          "",
          "---------------"
        ],
        "include/linux/assoc_array_priv.h||include/linux/assoc_array_priv.h": [
          "File: include/linux/assoc_array_priv.h -> include/linux/assoc_array_priv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #ifndef _LINUX_ASSOC_ARRAY_PRIV_H",
          "15: #define _LINUX_ASSOC_ARRAY_PRIV_H",
          "17: #ifdef CONFIG_ASSOCIATIVE_ARRAY",
          "19: #include <linux/assoc_array.h>",
          "22: #define ASSOC_ARRAY_FAN_MASK  (ASSOC_ARRAY_FAN_OUT - 1)",
          "23: #define ASSOC_ARRAY_LEVEL_STEP  (ilog2(ASSOC_ARRAY_FAN_OUT))",
          "24: #define ASSOC_ARRAY_LEVEL_STEP_MASK (ASSOC_ARRAY_LEVEL_STEP - 1)",
          "25: #define ASSOC_ARRAY_KEY_CHUNK_MASK (ASSOC_ARRAY_KEY_CHUNK_SIZE - 1)",
          "26: #define ASSOC_ARRAY_KEY_CHUNK_SHIFT (ilog2(BITS_PER_LONG))",
          "32: struct assoc_array_ptr;",
          "56: struct assoc_array_node {",
          "57:  struct assoc_array_ptr *back_pointer;",
          "58:  u8   parent_slot;",
          "59:  struct assoc_array_ptr *slots[ASSOC_ARRAY_FAN_OUT];",
          "60:  unsigned long  nr_leaves_on_branch;",
          "61: };",
          "67: struct assoc_array_shortcut {",
          "68:  struct assoc_array_ptr *back_pointer;",
          "69:  int   parent_slot;",
          "70:  int   skip_to_level;",
          "71:  struct assoc_array_ptr *next_node;",
          "72:  unsigned long  index_key[];",
          "73: };",
          "78: struct assoc_array_edit {",
          "79:  struct rcu_head   rcu;",
          "80:  struct assoc_array  *array;",
          "81:  const struct assoc_array_ops *ops;",
          "82:  const struct assoc_array_ops *ops_for_excised_subtree;",
          "83:  struct assoc_array_ptr  *leaf;",
          "84:  struct assoc_array_ptr  **leaf_p;",
          "85:  struct assoc_array_ptr  *dead_leaf;",
          "86:  struct assoc_array_ptr  *new_meta[3];",
          "87:  struct assoc_array_ptr  *excised_meta[1];",
          "88:  struct assoc_array_ptr  *excised_subtree;",
          "89:  struct assoc_array_ptr  **set_backpointers[ASSOC_ARRAY_FAN_OUT];",
          "90:  struct assoc_array_ptr  *set_backpointers_to;",
          "91:  struct assoc_array_node  *adjust_count_on;",
          "92:  long    adjust_count_by;",
          "93:  struct {",
          "94:   struct assoc_array_ptr **ptr;",
          "95:   struct assoc_array_ptr *to;",
          "96:  } set[2];",
          "97:  struct {",
          "98:   u8   *p;",
          "99:   u8   to;",
          "100:  } set_parent_slot[1];",
          "101:  u8    segment_cache[ASSOC_ARRAY_FAN_OUT + 1];",
          "102: };",
          "112: #define ASSOC_ARRAY_PTR_TYPE_MASK 0x1UL",
          "115: #define ASSOC_ARRAY_PTR_SUBTYPE_MASK 0x2UL",
          "116: #define ASSOC_ARRAY_PTR_NODE_SUBTYPE 0x0UL",
          "117: #define ASSOC_ARRAY_PTR_SHORTCUT_SUBTYPE 0x2UL",
          "119: static inline bool assoc_array_ptr_is_meta(const struct assoc_array_ptr *x)",
          "120: {",
          "121:  return (unsigned long)x & ASSOC_ARRAY_PTR_TYPE_MASK;",
          "122: }",
          "123: static inline bool assoc_array_ptr_is_leaf(const struct assoc_array_ptr *x)",
          "124: {",
          "125:  return !assoc_array_ptr_is_meta(x);",
          "126: }",
          "127: static inline bool assoc_array_ptr_is_shortcut(const struct assoc_array_ptr *x)",
          "128: {",
          "129:  return (unsigned long)x & ASSOC_ARRAY_PTR_SUBTYPE_MASK;",
          "130: }",
          "131: static inline bool assoc_array_ptr_is_node(const struct assoc_array_ptr *x)",
          "132: {",
          "133:  return !assoc_array_ptr_is_shortcut(x);",
          "134: }",
          "136: static inline void *assoc_array_ptr_to_leaf(const struct assoc_array_ptr *x)",
          "137: {",
          "138:  return (void *)((unsigned long)x & ~ASSOC_ARRAY_PTR_TYPE_MASK);",
          "139: }",
          "141: static inline",
          "142: unsigned long __assoc_array_ptr_to_meta(const struct assoc_array_ptr *x)",
          "143: {",
          "144:  return (unsigned long)x &",
          "145:   ~(ASSOC_ARRAY_PTR_SUBTYPE_MASK | ASSOC_ARRAY_PTR_TYPE_MASK);",
          "146: }",
          "147: static inline",
          "148: struct assoc_array_node *assoc_array_ptr_to_node(const struct assoc_array_ptr *x)",
          "149: {",
          "150:  return (struct assoc_array_node *)__assoc_array_ptr_to_meta(x);",
          "151: }",
          "152: static inline",
          "153: struct assoc_array_shortcut *assoc_array_ptr_to_shortcut(const struct assoc_array_ptr *x)",
          "154: {",
          "155:  return (struct assoc_array_shortcut *)__assoc_array_ptr_to_meta(x);",
          "156: }",
          "158: static inline",
          "159: struct assoc_array_ptr *__assoc_array_x_to_ptr(const void *p, unsigned long t)",
          "160: {",
          "161:  return (struct assoc_array_ptr *)((unsigned long)p | t);",
          "162: }",
          "163: static inline",
          "164: struct assoc_array_ptr *assoc_array_leaf_to_ptr(const void *p)",
          "165: {",
          "166:  return __assoc_array_x_to_ptr(p, ASSOC_ARRAY_PTR_LEAF_TYPE);",
          "167: }",
          "168: static inline",
          "169: struct assoc_array_ptr *assoc_array_node_to_ptr(const struct assoc_array_node *p)",
          "170: {",
          "171:  return __assoc_array_x_to_ptr(",
          "172:   p, ASSOC_ARRAY_PTR_META_TYPE | ASSOC_ARRAY_PTR_NODE_SUBTYPE);",
          "173: }",
          "174: static inline",
          "175: struct assoc_array_ptr *assoc_array_shortcut_to_ptr(const struct assoc_array_shortcut *p)",
          "176: {",
          "177:  return __assoc_array_x_to_ptr(",
          "178:   p, ASSOC_ARRAY_PTR_META_TYPE | ASSOC_ARRAY_PTR_SHORTCUT_SUBTYPE);",
          "179: }",
          "",
          "---------------"
        ],
        "lib/assoc_array.c||lib/assoc_array.c": [
          "File: lib/assoc_array.c -> lib/assoc_array.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include <linux/slab.h>",
          "15: #include <linux/assoc_array_priv.h>",
          "21: static int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,",
          "22:            const struct assoc_array_ptr *stop,",
          "23:            int (*iterator)(const void *leaf,",
          "24:              void *iterator_data),",
          "25:            void *iterator_data)",
          "26: {",
          "27:  const struct assoc_array_shortcut *shortcut;",
          "28:  const struct assoc_array_node *node;",
          "29:  const struct assoc_array_ptr *cursor, *ptr, *parent;",
          "30:  unsigned long has_meta;",
          "31:  int slot, ret;",
          "33:  cursor = root;",
          "35: begin_node:",
          "36:  if (assoc_array_ptr_is_shortcut(cursor)) {",
          "38:   shortcut = assoc_array_ptr_to_shortcut(cursor);",
          "39:   smp_read_barrier_depends();",
          "40:   cursor = ACCESS_ONCE(shortcut->next_node);",
          "41:  }",
          "43:  node = assoc_array_ptr_to_node(cursor);",
          "44:  smp_read_barrier_depends();",
          "45:  slot = 0;",
          "54:  has_meta = 0;",
          "55:  for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "56:   ptr = ACCESS_ONCE(node->slots[slot]);",
          "57:   has_meta |= (unsigned long)ptr;",
          "58:   if (ptr && assoc_array_ptr_is_leaf(ptr)) {",
          "63:    smp_read_barrier_depends();",
          "66:    ret = iterator(assoc_array_ptr_to_leaf(ptr),",
          "67:            iterator_data);",
          "68:    if (ret)",
          "69:     return ret;",
          "70:   }",
          "71:  }",
          "81:  if (!(has_meta & ASSOC_ARRAY_PTR_META_TYPE))",
          "82:   goto finished_node;",
          "83:  slot = 0;",
          "85: continue_node:",
          "86:  node = assoc_array_ptr_to_node(cursor);",
          "87:  smp_read_barrier_depends();",
          "89:  for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "90:   ptr = ACCESS_ONCE(node->slots[slot]);",
          "91:   if (assoc_array_ptr_is_meta(ptr)) {",
          "92:    cursor = ptr;",
          "93:    goto begin_node;",
          "94:   }",
          "95:  }",
          "97: finished_node:",
          "99:  parent = ACCESS_ONCE(node->back_pointer);",
          "100:  slot = node->parent_slot;",
          "101:  if (parent == stop)",
          "102:   return 0;",
          "104:  if (assoc_array_ptr_is_shortcut(parent)) {",
          "105:   shortcut = assoc_array_ptr_to_shortcut(parent);",
          "106:   smp_read_barrier_depends();",
          "107:   cursor = parent;",
          "108:   parent = ACCESS_ONCE(shortcut->back_pointer);",
          "109:   slot = shortcut->parent_slot;",
          "110:   if (parent == stop)",
          "111:    return 0;",
          "112:  }",
          "115:  cursor = parent;",
          "116:  slot++;",
          "117:  goto continue_node;",
          "118: }",
          "143: int assoc_array_iterate(const struct assoc_array *array,",
          "144:    int (*iterator)(const void *object,",
          "145:      void *iterator_data),",
          "146:    void *iterator_data)",
          "147: {",
          "148:  struct assoc_array_ptr *root = ACCESS_ONCE(array->root);",
          "150:  if (!root)",
          "151:   return 0;",
          "152:  return assoc_array_subtree_iterate(root, NULL, iterator, iterator_data);",
          "153: }",
          "155: enum assoc_array_walk_status {",
          "156:  assoc_array_walk_tree_empty,",
          "157:  assoc_array_walk_found_terminal_node,",
          "158:  assoc_array_walk_found_wrong_shortcut,",
          "159: } status;",
          "161: struct assoc_array_walk_result {",
          "162:  struct {",
          "164:   int  level;",
          "165:   int  slot;",
          "166:  } terminal_node;",
          "167:  struct {",
          "168:   struct assoc_array_shortcut *shortcut;",
          "169:   int  level;",
          "170:   int  sc_level;",
          "171:   unsigned long sc_segments;",
          "172:   unsigned long dissimilarity;",
          "173:  } wrong_shortcut;",
          "174: };",
          "179: static enum assoc_array_walk_status",
          "180: assoc_array_walk(const struct assoc_array *array,",
          "181:    const struct assoc_array_ops *ops,",
          "182:    const void *index_key,",
          "183:    struct assoc_array_walk_result *result)",
          "184: {",
          "185:  struct assoc_array_shortcut *shortcut;",
          "186:  struct assoc_array_node *node;",
          "187:  struct assoc_array_ptr *cursor, *ptr;",
          "188:  unsigned long sc_segments, dissimilarity;",
          "189:  unsigned long segments;",
          "190:  int level, sc_level, next_sc_level;",
          "191:  int slot;",
          "193:  pr_devel(\"-->%s()\\n\", __func__);",
          "195:  cursor = ACCESS_ONCE(array->root);",
          "196:  if (!cursor)",
          "197:   return assoc_array_walk_tree_empty;",
          "199:  level = 0;",
          "208: jumped:",
          "209:  segments = ops->get_key_chunk(index_key, level);",
          "210:  pr_devel(\"segments[%d]: %lx\\n\", level, segments);",
          "212:  if (assoc_array_ptr_is_shortcut(cursor))",
          "213:   goto follow_shortcut;",
          "215: consider_node:",
          "216:  node = assoc_array_ptr_to_node(cursor);",
          "217:  smp_read_barrier_depends();",
          "219:  slot = segments >> (level & ASSOC_ARRAY_KEY_CHUNK_MASK);",
          "220:  slot &= ASSOC_ARRAY_FAN_MASK;",
          "221:  ptr = ACCESS_ONCE(node->slots[slot]);",
          "223:  pr_devel(\"consider slot %x [ix=%d type=%lu]\\n\",",
          "224:    slot, level, (unsigned long)ptr & 3);",
          "226:  if (!assoc_array_ptr_is_meta(ptr)) {",
          "230:   result->terminal_node.node = node;",
          "231:   result->terminal_node.level = level;",
          "232:   result->terminal_node.slot = slot;",
          "233:   pr_devel(\"<--%s() = terminal_node\\n\", __func__);",
          "234:   return assoc_array_walk_found_terminal_node;",
          "235:  }",
          "237:  if (assoc_array_ptr_is_node(ptr)) {",
          "241:   cursor = ptr;",
          "242:   level += ASSOC_ARRAY_LEVEL_STEP;",
          "243:   if ((level & ASSOC_ARRAY_KEY_CHUNK_MASK) != 0)",
          "244:    goto consider_node;",
          "245:   goto jumped;",
          "246:  }",
          "252:  cursor = ptr;",
          "253: follow_shortcut:",
          "254:  shortcut = assoc_array_ptr_to_shortcut(cursor);",
          "255:  smp_read_barrier_depends();",
          "256:  pr_devel(\"shortcut to %d\\n\", shortcut->skip_to_level);",
          "257:  sc_level = level + ASSOC_ARRAY_LEVEL_STEP;",
          "258:  BUG_ON(sc_level > shortcut->skip_to_level);",
          "260:  do {",
          "265:   if ((sc_level & ASSOC_ARRAY_KEY_CHUNK_MASK) == 0)",
          "266:    segments = ops->get_key_chunk(index_key, sc_level);",
          "268:   sc_segments = shortcut->index_key[sc_level >> ASSOC_ARRAY_KEY_CHUNK_SHIFT];",
          "269:   dissimilarity = segments ^ sc_segments;",
          "271:   if (round_up(sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE) > shortcut->skip_to_level) {",
          "273:    int shift = shortcut->skip_to_level & ASSOC_ARRAY_KEY_CHUNK_MASK;",
          "274:    dissimilarity &= ~(ULONG_MAX << shift);",
          "275:    next_sc_level = shortcut->skip_to_level;",
          "276:   } else {",
          "277:    next_sc_level = sc_level + ASSOC_ARRAY_KEY_CHUNK_SIZE;",
          "278:    next_sc_level = round_down(next_sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);",
          "279:   }",
          "281:   if (dissimilarity != 0) {",
          "283:    result->wrong_shortcut.shortcut = shortcut;",
          "284:    result->wrong_shortcut.level = level;",
          "285:    result->wrong_shortcut.sc_level = sc_level;",
          "286:    result->wrong_shortcut.sc_segments = sc_segments;",
          "287:    result->wrong_shortcut.dissimilarity = dissimilarity;",
          "288:    return assoc_array_walk_found_wrong_shortcut;",
          "289:   }",
          "291:   sc_level = next_sc_level;",
          "292:  } while (sc_level < shortcut->skip_to_level);",
          "295:  cursor = ACCESS_ONCE(shortcut->next_node);",
          "296:  if (((level ^ sc_level) & ~ASSOC_ARRAY_KEY_CHUNK_MASK) != 0) {",
          "297:   level = sc_level;",
          "298:   goto jumped;",
          "299:  } else {",
          "300:   level = sc_level;",
          "301:   goto consider_node;",
          "302:  }",
          "303: }",
          "317: void *assoc_array_find(const struct assoc_array *array,",
          "318:          const struct assoc_array_ops *ops,",
          "319:          const void *index_key)",
          "320: {",
          "321:  struct assoc_array_walk_result result;",
          "322:  const struct assoc_array_node *node;",
          "323:  const struct assoc_array_ptr *ptr;",
          "324:  const void *leaf;",
          "325:  int slot;",
          "327:  if (assoc_array_walk(array, ops, index_key, &result) !=",
          "328:      assoc_array_walk_found_terminal_node)",
          "329:   return NULL;",
          "331:  node = result.terminal_node.node;",
          "332:  smp_read_barrier_depends();",
          "337:  for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "338:   ptr = ACCESS_ONCE(node->slots[slot]);",
          "339:   if (ptr && assoc_array_ptr_is_leaf(ptr)) {",
          "344:    leaf = assoc_array_ptr_to_leaf(ptr);",
          "345:    smp_read_barrier_depends();",
          "346:    if (ops->compare_object(leaf, index_key))",
          "347:     return (void *)leaf;",
          "348:   }",
          "349:  }",
          "351:  return NULL;",
          "352: }",
          "358: static void assoc_array_destroy_subtree(struct assoc_array_ptr *root,",
          "359:      const struct assoc_array_ops *ops)",
          "360: {",
          "361:  struct assoc_array_shortcut *shortcut;",
          "362:  struct assoc_array_node *node;",
          "363:  struct assoc_array_ptr *cursor, *parent = NULL;",
          "364:  int slot = -1;",
          "366:  pr_devel(\"-->%s()\\n\", __func__);",
          "368:  cursor = root;",
          "369:  if (!cursor) {",
          "370:   pr_devel(\"empty\\n\");",
          "371:   return;",
          "372:  }",
          "374: move_to_meta:",
          "375:  if (assoc_array_ptr_is_shortcut(cursor)) {",
          "377:   pr_devel(\"[%d] shortcut\\n\", slot);",
          "378:   BUG_ON(!assoc_array_ptr_is_shortcut(cursor));",
          "379:   shortcut = assoc_array_ptr_to_shortcut(cursor);",
          "380:   BUG_ON(shortcut->back_pointer != parent);",
          "381:   BUG_ON(slot != -1 && shortcut->parent_slot != slot);",
          "382:   parent = cursor;",
          "383:   cursor = shortcut->next_node;",
          "384:   slot = -1;",
          "385:   BUG_ON(!assoc_array_ptr_is_node(cursor));",
          "386:  }",
          "388:  pr_devel(\"[%d] node\\n\", slot);",
          "389:  node = assoc_array_ptr_to_node(cursor);",
          "390:  BUG_ON(node->back_pointer != parent);",
          "391:  BUG_ON(slot != -1 && node->parent_slot != slot);",
          "392:  slot = 0;",
          "394: continue_node:",
          "395:  pr_devel(\"Node %p [back=%p]\\n\", node, node->back_pointer);",
          "396:  for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "397:   struct assoc_array_ptr *ptr = node->slots[slot];",
          "398:   if (!ptr)",
          "399:    continue;",
          "400:   if (assoc_array_ptr_is_meta(ptr)) {",
          "401:    parent = cursor;",
          "402:    cursor = ptr;",
          "403:    goto move_to_meta;",
          "404:   }",
          "406:   if (ops) {",
          "407:    pr_devel(\"[%d] free leaf\\n\", slot);",
          "408:    ops->free_object(assoc_array_ptr_to_leaf(ptr));",
          "409:   }",
          "410:  }",
          "412:  parent = node->back_pointer;",
          "413:  slot = node->parent_slot;",
          "414:  pr_devel(\"free node\\n\");",
          "415:  kfree(node);",
          "416:  if (!parent)",
          "421:  if (assoc_array_ptr_is_shortcut(parent)) {",
          "422:   shortcut = assoc_array_ptr_to_shortcut(parent);",
          "423:   BUG_ON(shortcut->next_node != cursor);",
          "424:   cursor = parent;",
          "425:   parent = shortcut->back_pointer;",
          "426:   slot = shortcut->parent_slot;",
          "427:   pr_devel(\"free shortcut\\n\");",
          "428:   kfree(shortcut);",
          "429:   if (!parent)",
          "430:    return;",
          "432:   BUG_ON(!assoc_array_ptr_is_node(parent));",
          "433:  }",
          "436:  pr_devel(\"ascend to %p[%d]\\n\", parent, slot);",
          "437:  cursor = parent;",
          "438:  node = assoc_array_ptr_to_node(cursor);",
          "439:  slot++;",
          "440:  goto continue_node;",
          "441: }",
          "456: void assoc_array_destroy(struct assoc_array *array,",
          "457:     const struct assoc_array_ops *ops)",
          "458: {",
          "459:  assoc_array_destroy_subtree(array->root, ops);",
          "460:  array->root = NULL;",
          "461: }",
          "466: static bool assoc_array_insert_in_empty_tree(struct assoc_array_edit *edit)",
          "467: {",
          "468:  struct assoc_array_node *new_n0;",
          "470:  pr_devel(\"-->%s()\\n\", __func__);",
          "472:  new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);",
          "473:  if (!new_n0)",
          "474:   return false;",
          "476:  edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);",
          "477:  edit->leaf_p = &new_n0->slots[0];",
          "478:  edit->adjust_count_on = new_n0;",
          "479:  edit->set[0].ptr = &edit->array->root;",
          "480:  edit->set[0].to = assoc_array_node_to_ptr(new_n0);",
          "482:  pr_devel(\"<--%s() = ok [no root]\\n\", __func__);",
          "483:  return true;",
          "484: }",
          "489: static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,",
          "490:         const struct assoc_array_ops *ops,",
          "491:         const void *index_key,",
          "492:         struct assoc_array_walk_result *result)",
          "493: {",
          "494:  struct assoc_array_shortcut *shortcut, *new_s0;",
          "495:  struct assoc_array_node *node, *new_n0, *new_n1, *side;",
          "496:  struct assoc_array_ptr *ptr;",
          "497:  unsigned long dissimilarity, base_seg, blank;",
          "498:  size_t keylen;",
          "499:  bool have_meta;",
          "500:  int level, diff;",
          "501:  int slot, next_slot, free_slot, i, j;",
          "503:  node = result->terminal_node.node;",
          "504:  level = result->terminal_node.level;",
          "505:  edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;",
          "507:  pr_devel(\"-->%s()\\n\", __func__);",
          "514:  free_slot = -1;",
          "519:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "520:   ptr = node->slots[i];",
          "521:   if (!ptr) {",
          "522:    free_slot = i;",
          "523:    continue;",
          "524:   }",
          "525:   if (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {",
          "526:    pr_devel(\"replace in slot %d\\n\", i);",
          "527:    edit->leaf_p = &node->slots[i];",
          "528:    edit->dead_leaf = node->slots[i];",
          "529:    pr_devel(\"<--%s() = ok [replace]\\n\", __func__);",
          "530:    return true;",
          "531:   }",
          "532:  }",
          "537:  if (free_slot >= 0) {",
          "538:   pr_devel(\"insert in free slot %d\\n\", free_slot);",
          "539:   edit->leaf_p = &node->slots[free_slot];",
          "540:   edit->adjust_count_on = node;",
          "541:   pr_devel(\"<--%s() = ok [insert]\\n\", __func__);",
          "542:   return true;",
          "543:  }",
          "552:  new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);",
          "553:  if (!new_n0)",
          "554:   return false;",
          "555:  edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);",
          "556:  new_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);",
          "557:  if (!new_n1)",
          "558:   return false;",
          "559:  edit->new_meta[1] = assoc_array_node_to_ptr(new_n1);",
          "562:  pr_devel(\"no spare slots\\n\");",
          "563:  have_meta = false;",
          "564:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "565:   ptr = node->slots[i];",
          "566:   if (assoc_array_ptr_is_meta(ptr)) {",
          "567:    edit->segment_cache[i] = 0xff;",
          "568:    have_meta = true;",
          "569:    continue;",
          "570:   }",
          "571:   base_seg = ops->get_object_key_chunk(",
          "572:    assoc_array_ptr_to_leaf(ptr), level);",
          "573:   base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;",
          "574:   edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;",
          "575:  }",
          "577:  if (have_meta) {",
          "578:   pr_devel(\"have meta\\n\");",
          "579:   goto split_node;",
          "580:  }",
          "583:  dissimilarity = 0;",
          "584:  base_seg = edit->segment_cache[0];",
          "585:  for (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)",
          "586:   dissimilarity |= edit->segment_cache[i] ^ base_seg;",
          "588:  pr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);",
          "590:  if ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {",
          "594:   if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)",
          "595:    goto all_leaves_cluster_together;",
          "600:   goto present_leaves_cluster_but_not_new_leaf;",
          "601:  }",
          "603: split_node:",
          "604:  pr_devel(\"split node\\n\");",
          "616:  edit->set[0].to = assoc_array_node_to_ptr(new_n0);",
          "617:  new_n0->back_pointer = node->back_pointer;",
          "618:  new_n0->parent_slot = node->parent_slot;",
          "619:  new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);",
          "622: do_split_node:",
          "623:  pr_devel(\"do_split_node\\n\");",
          "625:  new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;",
          "626:  new_n1->nr_leaves_on_branch = 0;",
          "634:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "635:   slot = edit->segment_cache[i];",
          "636:   if (slot != 0xff)",
          "637:    for (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)",
          "638:     if (edit->segment_cache[j] == slot)",
          "639:      goto found_slot_for_multiple_occupancy;",
          "640:  }",
          "641: found_slot_for_multiple_occupancy:",
          "642:  pr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);",
          "643:  BUG_ON(i >= ASSOC_ARRAY_FAN_OUT);",
          "644:  BUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);",
          "645:  BUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);",
          "647:  new_n1->parent_slot = slot;",
          "650:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)",
          "651:   if (assoc_array_ptr_is_meta(node->slots[i]))",
          "652:    new_n0->slots[i] = node->slots[i];",
          "653:   else",
          "654:    new_n0->slots[i] = NULL;",
          "655:  BUG_ON(new_n0->slots[slot] != NULL);",
          "656:  new_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);",
          "659:  free_slot = -1;",
          "660:  next_slot = 0;",
          "661:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "662:   if (assoc_array_ptr_is_meta(node->slots[i]))",
          "663:    continue;",
          "664:   if (edit->segment_cache[i] == slot) {",
          "665:    new_n1->slots[next_slot++] = node->slots[i];",
          "666:    new_n1->nr_leaves_on_branch++;",
          "667:   } else {",
          "668:    do {",
          "669:     free_slot++;",
          "670:    } while (new_n0->slots[free_slot] != NULL);",
          "671:    new_n0->slots[free_slot] = node->slots[i];",
          "672:   }",
          "673:  }",
          "675:  pr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);",
          "677:  if (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {",
          "678:   do {",
          "679:    free_slot++;",
          "680:   } while (new_n0->slots[free_slot] != NULL);",
          "681:   edit->leaf_p = &new_n0->slots[free_slot];",
          "682:   edit->adjust_count_on = new_n0;",
          "683:  } else {",
          "684:   edit->leaf_p = &new_n1->slots[next_slot++];",
          "685:   edit->adjust_count_on = new_n1;",
          "686:  }",
          "688:  BUG_ON(next_slot <= 1);",
          "690:  edit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);",
          "691:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "692:   if (edit->segment_cache[i] == 0xff) {",
          "693:    ptr = node->slots[i];",
          "694:    BUG_ON(assoc_array_ptr_is_leaf(ptr));",
          "695:    if (assoc_array_ptr_is_node(ptr)) {",
          "696:     side = assoc_array_ptr_to_node(ptr);",
          "697:     edit->set_backpointers[i] = &side->back_pointer;",
          "698:    } else {",
          "699:     shortcut = assoc_array_ptr_to_shortcut(ptr);",
          "700:     edit->set_backpointers[i] = &shortcut->back_pointer;",
          "701:    }",
          "702:   }",
          "703:  }",
          "705:  ptr = node->back_pointer;",
          "706:  if (!ptr)",
          "707:   edit->set[0].ptr = &edit->array->root;",
          "708:  else if (assoc_array_ptr_is_node(ptr))",
          "709:   edit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];",
          "710:  else",
          "711:   edit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;",
          "712:  edit->excised_meta[0] = assoc_array_node_to_ptr(node);",
          "713:  pr_devel(\"<--%s() = ok [split node]\\n\", __func__);",
          "714:  return true;",
          "716: present_leaves_cluster_but_not_new_leaf:",
          "721:  pr_devel(\"present leaves cluster but not new leaf\\n\");",
          "723:  new_n0->back_pointer = node->back_pointer;",
          "724:  new_n0->parent_slot = node->parent_slot;",
          "725:  new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;",
          "726:  new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);",
          "727:  new_n1->parent_slot = edit->segment_cache[0];",
          "728:  new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;",
          "729:  edit->adjust_count_on = new_n0;",
          "731:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)",
          "732:   new_n1->slots[i] = node->slots[i];",
          "734:  new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);",
          "735:  edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];",
          "737:  edit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];",
          "738:  edit->set[0].to = assoc_array_node_to_ptr(new_n0);",
          "739:  edit->excised_meta[0] = assoc_array_node_to_ptr(node);",
          "740:  pr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);",
          "741:  return true;",
          "743: all_leaves_cluster_together:",
          "758:  pr_devel(\"all leaves cluster together\\n\");",
          "759:  diff = INT_MAX;",
          "760:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "761:   int x = ops->diff_objects(assoc_array_ptr_to_leaf(edit->leaf),",
          "762:        assoc_array_ptr_to_leaf(node->slots[i]));",
          "763:   if (x < diff) {",
          "764:    BUG_ON(x < 0);",
          "765:    diff = x;",
          "766:   }",
          "767:  }",
          "768:  BUG_ON(diff == INT_MAX);",
          "769:  BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);",
          "771:  keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);",
          "772:  keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;",
          "774:  new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +",
          "775:     keylen * sizeof(unsigned long), GFP_KERNEL);",
          "776:  if (!new_s0)",
          "777:   return false;",
          "778:  edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);",
          "780:  edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);",
          "781:  new_s0->back_pointer = node->back_pointer;",
          "782:  new_s0->parent_slot = node->parent_slot;",
          "783:  new_s0->next_node = assoc_array_node_to_ptr(new_n0);",
          "784:  new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);",
          "785:  new_n0->parent_slot = 0;",
          "786:  new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);",
          "789:  new_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;",
          "790:  pr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);",
          "791:  BUG_ON(level <= 0);",
          "793:  for (i = 0; i < keylen; i++)",
          "794:   new_s0->index_key[i] =",
          "795:    ops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);",
          "797:  blank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);",
          "798:  pr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);",
          "799:  new_s0->index_key[keylen - 1] &= ~blank;",
          "804:  for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "805:   ptr = node->slots[i];",
          "806:   base_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),",
          "807:            level);",
          "808:   base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;",
          "809:   edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;",
          "810:  }",
          "812:  base_seg = ops->get_key_chunk(index_key, level);",
          "813:  base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;",
          "814:  edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;",
          "815:  goto do_split_node;",
          "816: }",
          "821: static bool assoc_array_insert_mid_shortcut(struct assoc_array_edit *edit,",
          "822:          const struct assoc_array_ops *ops,",
          "823:          struct assoc_array_walk_result *result)",
          "824: {",
          "825:  struct assoc_array_shortcut *shortcut, *new_s0, *new_s1;",
          "826:  struct assoc_array_node *node, *new_n0, *side;",
          "827:  unsigned long sc_segments, dissimilarity, blank;",
          "828:  size_t keylen;",
          "829:  int level, sc_level, diff;",
          "830:  int sc_slot;",
          "832:  shortcut = result->wrong_shortcut.shortcut;",
          "833:  level  = result->wrong_shortcut.level;",
          "834:  sc_level = result->wrong_shortcut.sc_level;",
          "835:  sc_segments = result->wrong_shortcut.sc_segments;",
          "836:  dissimilarity = result->wrong_shortcut.dissimilarity;",
          "838:  pr_devel(\"-->%s(ix=%d dis=%lx scix=%d)\\n\",",
          "839:    __func__, level, dissimilarity, sc_level);",
          "847:  diff = __ffs(dissimilarity);",
          "848:  diff &= ~ASSOC_ARRAY_LEVEL_STEP_MASK;",
          "849:  diff += sc_level & ~ASSOC_ARRAY_KEY_CHUNK_MASK;",
          "850:  pr_devel(\"diff=%d\\n\", diff);",
          "852:  if (!shortcut->back_pointer) {",
          "853:   edit->set[0].ptr = &edit->array->root;",
          "854:  } else if (assoc_array_ptr_is_node(shortcut->back_pointer)) {",
          "855:   node = assoc_array_ptr_to_node(shortcut->back_pointer);",
          "856:   edit->set[0].ptr = &node->slots[shortcut->parent_slot];",
          "857:  } else {",
          "858:   BUG();",
          "859:  }",
          "861:  edit->excised_meta[0] = assoc_array_shortcut_to_ptr(shortcut);",
          "864:  new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);",
          "865:  if (!new_n0)",
          "866:   return false;",
          "867:  edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);",
          "868:  edit->adjust_count_on = new_n0;",
          "874:  level += ASSOC_ARRAY_LEVEL_STEP;",
          "875:  if (diff > level) {",
          "876:   pr_devel(\"pre-shortcut %d...%d\\n\", level, diff);",
          "877:   keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);",
          "878:   keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;",
          "880:   new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +",
          "881:      keylen * sizeof(unsigned long), GFP_KERNEL);",
          "882:   if (!new_s0)",
          "883:    return false;",
          "884:   edit->new_meta[1] = assoc_array_shortcut_to_ptr(new_s0);",
          "885:   edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);",
          "886:   new_s0->back_pointer = shortcut->back_pointer;",
          "887:   new_s0->parent_slot = shortcut->parent_slot;",
          "888:   new_s0->next_node = assoc_array_node_to_ptr(new_n0);",
          "889:   new_s0->skip_to_level = diff;",
          "891:   new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);",
          "892:   new_n0->parent_slot = 0;",
          "894:   memcpy(new_s0->index_key, shortcut->index_key,",
          "895:          keylen * sizeof(unsigned long));",
          "897:   blank = ULONG_MAX << (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);",
          "898:   pr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, diff, blank);",
          "899:   new_s0->index_key[keylen - 1] &= ~blank;",
          "900:  } else {",
          "901:   pr_devel(\"no pre-shortcut\\n\");",
          "902:   edit->set[0].to = assoc_array_node_to_ptr(new_n0);",
          "903:   new_n0->back_pointer = shortcut->back_pointer;",
          "904:   new_n0->parent_slot = shortcut->parent_slot;",
          "905:  }",
          "907:  side = assoc_array_ptr_to_node(shortcut->next_node);",
          "908:  new_n0->nr_leaves_on_branch = side->nr_leaves_on_branch;",
          "913:  sc_slot = sc_segments >> (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);",
          "914:  sc_slot &= ASSOC_ARRAY_FAN_MASK;",
          "916:  pr_devel(\"new slot %lx >> %d -> %d\\n\",",
          "917:    sc_segments, diff & ASSOC_ARRAY_KEY_CHUNK_MASK, sc_slot);",
          "924:  level = diff + ASSOC_ARRAY_LEVEL_STEP;",
          "925:  if (level < shortcut->skip_to_level) {",
          "926:   pr_devel(\"post-shortcut %d...%d\\n\", level, shortcut->skip_to_level);",
          "927:   keylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);",
          "928:   keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;",
          "930:   new_s1 = kzalloc(sizeof(struct assoc_array_shortcut) +",
          "931:      keylen * sizeof(unsigned long), GFP_KERNEL);",
          "932:   if (!new_s1)",
          "933:    return false;",
          "934:   edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s1);",
          "936:   new_s1->back_pointer = assoc_array_node_to_ptr(new_n0);",
          "937:   new_s1->parent_slot = sc_slot;",
          "938:   new_s1->next_node = shortcut->next_node;",
          "939:   new_s1->skip_to_level = shortcut->skip_to_level;",
          "941:   new_n0->slots[sc_slot] = assoc_array_shortcut_to_ptr(new_s1);",
          "943:   memcpy(new_s1->index_key, shortcut->index_key,",
          "944:          keylen * sizeof(unsigned long));",
          "946:   edit->set[1].ptr = &side->back_pointer;",
          "947:   edit->set[1].to = assoc_array_shortcut_to_ptr(new_s1);",
          "948:  } else {",
          "949:   pr_devel(\"no post-shortcut\\n\");",
          "956:   new_n0->slots[sc_slot] = shortcut->next_node;",
          "957:   edit->set_parent_slot[0].p = &side->parent_slot;",
          "958:   edit->set_parent_slot[0].to = sc_slot;",
          "959:   edit->set[1].ptr = &side->back_pointer;",
          "960:   edit->set[1].to = assoc_array_node_to_ptr(new_n0);",
          "961:  }",
          "964:  if (sc_slot == 0)",
          "965:   edit->leaf_p = &new_n0->slots[1];",
          "966:  else",
          "967:   edit->leaf_p = &new_n0->slots[0];",
          "969:  pr_devel(\"<--%s() = ok [split shortcut]\\n\", __func__);",
          "970:  return edit;",
          "971: }",
          "992: struct assoc_array_edit *assoc_array_insert(struct assoc_array *array,",
          "993:          const struct assoc_array_ops *ops,",
          "994:          const void *index_key,",
          "995:          void *object)",
          "996: {",
          "997:  struct assoc_array_walk_result result;",
          "998:  struct assoc_array_edit *edit;",
          "1000:  pr_devel(\"-->%s()\\n\", __func__);",
          "1007:  BUG_ON(assoc_array_ptr_is_meta(object));",
          "1009:  edit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);",
          "1010:  if (!edit)",
          "1011:   return ERR_PTR(-ENOMEM);",
          "1012:  edit->array = array;",
          "1013:  edit->ops = ops;",
          "1014:  edit->leaf = assoc_array_leaf_to_ptr(object);",
          "1015:  edit->adjust_count_by = 1;",
          "1017:  switch (assoc_array_walk(array, ops, index_key, &result)) {",
          "1018:  case assoc_array_walk_tree_empty:",
          "1020:   if (!assoc_array_insert_in_empty_tree(edit))",
          "1021:    goto enomem;",
          "1022:   return edit;",
          "1024:  case assoc_array_walk_found_terminal_node:",
          "1029:   if (!assoc_array_insert_into_terminal_node(edit, ops, index_key,",
          "1030:           &result))",
          "1031:    goto enomem;",
          "1032:   return edit;",
          "1034:  case assoc_array_walk_found_wrong_shortcut:",
          "1038:   if (!assoc_array_insert_mid_shortcut(edit, ops, &result))",
          "1039:    goto enomem;",
          "1040:   return edit;",
          "1041:  }",
          "1043: enomem:",
          "1045:  pr_devel(\"enomem\\n\");",
          "1046:  assoc_array_cancel_edit(edit);",
          "1047:  return ERR_PTR(-ENOMEM);",
          "1048: }",
          "1059: void assoc_array_insert_set_object(struct assoc_array_edit *edit, void *object)",
          "1060: {",
          "1061:  BUG_ON(!object);",
          "1062:  edit->leaf = assoc_array_leaf_to_ptr(object);",
          "1063: }",
          "1065: struct assoc_array_delete_collapse_context {",
          "1066:  struct assoc_array_node *node;",
          "1067:  const void  *skip_leaf;",
          "1068:  int   slot;",
          "1069: };",
          "1074: static int assoc_array_delete_collapse_iterator(const void *leaf,",
          "1075:       void *iterator_data)",
          "1076: {",
          "1077:  struct assoc_array_delete_collapse_context *collapse = iterator_data;",
          "1079:  if (leaf == collapse->skip_leaf)",
          "1080:   return 0;",
          "1082:  BUG_ON(collapse->slot >= ASSOC_ARRAY_FAN_OUT);",
          "1084:  collapse->node->slots[collapse->slot++] = assoc_array_leaf_to_ptr(leaf);",
          "1085:  return 0;",
          "1086: }",
          "1107: struct assoc_array_edit *assoc_array_delete(struct assoc_array *array,",
          "1108:          const struct assoc_array_ops *ops,",
          "1109:          const void *index_key)",
          "1110: {",
          "1111:  struct assoc_array_delete_collapse_context collapse;",
          "1112:  struct assoc_array_walk_result result;",
          "1113:  struct assoc_array_node *node, *new_n0;",
          "1114:  struct assoc_array_edit *edit;",
          "1115:  struct assoc_array_ptr *ptr;",
          "1116:  bool has_meta;",
          "1117:  int slot, i;",
          "1119:  pr_devel(\"-->%s()\\n\", __func__);",
          "1121:  edit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);",
          "1122:  if (!edit)",
          "1123:   return ERR_PTR(-ENOMEM);",
          "1124:  edit->array = array;",
          "1125:  edit->ops = ops;",
          "1126:  edit->adjust_count_by = -1;",
          "1128:  switch (assoc_array_walk(array, ops, index_key, &result)) {",
          "1129:  case assoc_array_walk_found_terminal_node:",
          "1133:   pr_devel(\"terminal_node\\n\");",
          "1134:   node = result.terminal_node.node;",
          "1136:   for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "1137:    ptr = node->slots[slot];",
          "1138:    if (ptr &&",
          "1139:        assoc_array_ptr_is_leaf(ptr) &&",
          "1140:        ops->compare_object(assoc_array_ptr_to_leaf(ptr),",
          "1141:       index_key))",
          "1142:     goto found_leaf;",
          "1143:   }",
          "1144:  case assoc_array_walk_tree_empty:",
          "1145:  case assoc_array_walk_found_wrong_shortcut:",
          "1146:  default:",
          "1147:   assoc_array_cancel_edit(edit);",
          "1148:   pr_devel(\"not found\\n\");",
          "1149:   return NULL;",
          "1150:  }",
          "1152: found_leaf:",
          "1153:  BUG_ON(array->nr_leaves_on_tree <= 0);",
          "1158:  edit->dead_leaf = node->slots[slot];",
          "1159:  edit->set[0].ptr = &node->slots[slot];",
          "1160:  edit->set[0].to = NULL;",
          "1161:  edit->adjust_count_on = node;",
          "1166:  if (array->nr_leaves_on_tree == 1) {",
          "1167:   edit->set[1].ptr = &array->root;",
          "1168:   edit->set[1].to = NULL;",
          "1169:   edit->adjust_count_on = NULL;",
          "1170:   edit->excised_subtree = array->root;",
          "1171:   pr_devel(\"all gone\\n\");",
          "1172:   return edit;",
          "1173:  }",
          "1185:  if (node->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {",
          "1186:   struct assoc_array_node *parent, *grandparent;",
          "1187:   struct assoc_array_ptr *ptr;",
          "1193:   has_meta = false;",
          "1194:   for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "1195:    ptr = node->slots[i];",
          "1196:    if (assoc_array_ptr_is_meta(ptr)) {",
          "1197:     has_meta = true;",
          "1198:     break;",
          "1199:    }",
          "1200:   }",
          "1202:   pr_devel(\"leaves: %ld [m=%d]\\n\",",
          "1203:     node->nr_leaves_on_branch - 1, has_meta);",
          "1208:   parent = node;",
          "1209:  collapse_up:",
          "1210:   pr_devel(\"collapse subtree: %ld\\n\", parent->nr_leaves_on_branch);",
          "1212:   ptr = parent->back_pointer;",
          "1213:   if (!ptr)",
          "1214:    goto do_collapse;",
          "1215:   if (assoc_array_ptr_is_shortcut(ptr)) {",
          "1216:    struct assoc_array_shortcut *s = assoc_array_ptr_to_shortcut(ptr);",
          "1217:    ptr = s->back_pointer;",
          "1218:    if (!ptr)",
          "1219:     goto do_collapse;",
          "1220:   }",
          "1222:   grandparent = assoc_array_ptr_to_node(ptr);",
          "1223:   if (grandparent->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {",
          "1224:    parent = grandparent;",
          "1225:    goto collapse_up;",
          "1226:   }",
          "1228:  do_collapse:",
          "1233:   if (has_meta || parent != node) {",
          "1234:    node = parent;",
          "1237:    new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);",
          "1238:    if (!new_n0)",
          "1239:     goto enomem;",
          "1240:    edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);",
          "1242:    new_n0->back_pointer = node->back_pointer;",
          "1243:    new_n0->parent_slot = node->parent_slot;",
          "1244:    new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;",
          "1245:    edit->adjust_count_on = new_n0;",
          "1247:    collapse.node = new_n0;",
          "1248:    collapse.skip_leaf = assoc_array_ptr_to_leaf(edit->dead_leaf);",
          "1249:    collapse.slot = 0;",
          "1250:    assoc_array_subtree_iterate(assoc_array_node_to_ptr(node),",
          "1251:           node->back_pointer,",
          "1252:           assoc_array_delete_collapse_iterator,",
          "1253:           &collapse);",
          "1254:    pr_devel(\"collapsed %d,%lu\\n\", collapse.slot, new_n0->nr_leaves_on_branch);",
          "1255:    BUG_ON(collapse.slot != new_n0->nr_leaves_on_branch - 1);",
          "1257:    if (!node->back_pointer) {",
          "1258:     edit->set[1].ptr = &array->root;",
          "1259:    } else if (assoc_array_ptr_is_leaf(node->back_pointer)) {",
          "1260:     BUG();",
          "1261:    } else if (assoc_array_ptr_is_node(node->back_pointer)) {",
          "1262:     struct assoc_array_node *p =",
          "1263:      assoc_array_ptr_to_node(node->back_pointer);",
          "1264:     edit->set[1].ptr = &p->slots[node->parent_slot];",
          "1265:    } else if (assoc_array_ptr_is_shortcut(node->back_pointer)) {",
          "1266:     struct assoc_array_shortcut *s =",
          "1267:      assoc_array_ptr_to_shortcut(node->back_pointer);",
          "1268:     edit->set[1].ptr = &s->next_node;",
          "1269:    }",
          "1270:    edit->set[1].to = assoc_array_node_to_ptr(new_n0);",
          "1271:    edit->excised_subtree = assoc_array_node_to_ptr(node);",
          "1272:   }",
          "1273:  }",
          "1275:  return edit;",
          "1277: enomem:",
          "1279:  pr_devel(\"enomem\\n\");",
          "1280:  assoc_array_cancel_edit(edit);",
          "1281:  return ERR_PTR(-ENOMEM);",
          "1282: }",
          "1302: struct assoc_array_edit *assoc_array_clear(struct assoc_array *array,",
          "1303:         const struct assoc_array_ops *ops)",
          "1304: {",
          "1305:  struct assoc_array_edit *edit;",
          "1307:  pr_devel(\"-->%s()\\n\", __func__);",
          "1309:  if (!array->root)",
          "1310:   return NULL;",
          "1312:  edit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);",
          "1313:  if (!edit)",
          "1314:   return ERR_PTR(-ENOMEM);",
          "1315:  edit->array = array;",
          "1316:  edit->ops = ops;",
          "1317:  edit->set[1].ptr = &array->root;",
          "1318:  edit->set[1].to = NULL;",
          "1319:  edit->excised_subtree = array->root;",
          "1320:  edit->ops_for_excised_subtree = ops;",
          "1321:  pr_devel(\"all gone\\n\");",
          "1322:  return edit;",
          "1323: }",
          "1328: static void assoc_array_rcu_cleanup(struct rcu_head *head)",
          "1329: {",
          "1330:  struct assoc_array_edit *edit =",
          "1331:   container_of(head, struct assoc_array_edit, rcu);",
          "1332:  int i;",
          "1334:  pr_devel(\"-->%s()\\n\", __func__);",
          "1336:  if (edit->dead_leaf)",
          "1337:   edit->ops->free_object(assoc_array_ptr_to_leaf(edit->dead_leaf));",
          "1338:  for (i = 0; i < ARRAY_SIZE(edit->excised_meta); i++)",
          "1339:   if (edit->excised_meta[i])",
          "1340:    kfree(assoc_array_ptr_to_node(edit->excised_meta[i]));",
          "1342:  if (edit->excised_subtree) {",
          "1343:   BUG_ON(assoc_array_ptr_is_leaf(edit->excised_subtree));",
          "1344:   if (assoc_array_ptr_is_node(edit->excised_subtree)) {",
          "1345:    struct assoc_array_node *n =",
          "1346:     assoc_array_ptr_to_node(edit->excised_subtree);",
          "1347:    n->back_pointer = NULL;",
          "1348:   } else {",
          "1349:    struct assoc_array_shortcut *s =",
          "1350:     assoc_array_ptr_to_shortcut(edit->excised_subtree);",
          "1351:    s->back_pointer = NULL;",
          "1352:   }",
          "1353:   assoc_array_destroy_subtree(edit->excised_subtree,",
          "1354:          edit->ops_for_excised_subtree);",
          "1355:  }",
          "1357:  kfree(edit);",
          "1358: }",
          "1373: void assoc_array_apply_edit(struct assoc_array_edit *edit)",
          "1374: {",
          "1375:  struct assoc_array_shortcut *shortcut;",
          "1376:  struct assoc_array_node *node;",
          "1377:  struct assoc_array_ptr *ptr;",
          "1378:  int i;",
          "1380:  pr_devel(\"-->%s()\\n\", __func__);",
          "1382:  smp_wmb();",
          "1383:  if (edit->leaf_p)",
          "1386:  smp_wmb();",
          "1387:  for (i = 0; i < ARRAY_SIZE(edit->set_parent_slot); i++)",
          "1388:   if (edit->set_parent_slot[i].p)",
          "1391:  smp_wmb();",
          "1392:  for (i = 0; i < ARRAY_SIZE(edit->set_backpointers); i++)",
          "1393:   if (edit->set_backpointers[i])",
          "1396:  smp_wmb();",
          "1397:  for (i = 0; i < ARRAY_SIZE(edit->set); i++)",
          "1398:   if (edit->set[i].ptr)",
          "1401:  if (edit->array->root == NULL) {",
          "1402:   edit->array->nr_leaves_on_tree = 0;",
          "1403:  } else if (edit->adjust_count_on) {",
          "1404:   node = edit->adjust_count_on;",
          "1405:   for (;;) {",
          "1406:    node->nr_leaves_on_branch += edit->adjust_count_by;",
          "1408:    ptr = node->back_pointer;",
          "1409:    if (!ptr)",
          "1410:     break;",
          "1411:    if (assoc_array_ptr_is_shortcut(ptr)) {",
          "1412:     shortcut = assoc_array_ptr_to_shortcut(ptr);",
          "1413:     ptr = shortcut->back_pointer;",
          "1414:     if (!ptr)",
          "1415:      break;",
          "1416:    }",
          "1417:    BUG_ON(!assoc_array_ptr_is_node(ptr));",
          "1418:    node = assoc_array_ptr_to_node(ptr);",
          "1419:   }",
          "1421:   edit->array->nr_leaves_on_tree += edit->adjust_count_by;",
          "1422:  }",
          "1424:  call_rcu(&edit->rcu, assoc_array_rcu_cleanup);",
          "1425: }",
          "1437: void assoc_array_cancel_edit(struct assoc_array_edit *edit)",
          "1438: {",
          "1439:  struct assoc_array_ptr *ptr;",
          "1440:  int i;",
          "1442:  pr_devel(\"-->%s()\\n\", __func__);",
          "1445:  for (i = 0; i < ARRAY_SIZE(edit->new_meta); i++) {",
          "1446:   ptr = edit->new_meta[i];",
          "1447:   if (ptr) {",
          "1448:    if (assoc_array_ptr_is_node(ptr))",
          "1449:     kfree(assoc_array_ptr_to_node(ptr));",
          "1450:    else",
          "1451:     kfree(assoc_array_ptr_to_shortcut(ptr));",
          "1452:   }",
          "1453:  }",
          "1454:  kfree(edit);",
          "1455: }",
          "1481: int assoc_array_gc(struct assoc_array *array,",
          "1482:      const struct assoc_array_ops *ops,",
          "1483:      bool (*iterator)(void *object, void *iterator_data),",
          "1484:      void *iterator_data)",
          "1485: {",
          "1486:  struct assoc_array_shortcut *shortcut, *new_s;",
          "1487:  struct assoc_array_node *node, *new_n;",
          "1488:  struct assoc_array_edit *edit;",
          "1489:  struct assoc_array_ptr *cursor, *ptr;",
          "1490:  struct assoc_array_ptr *new_root, *new_parent, **new_ptr_pp;",
          "1491:  unsigned long nr_leaves_on_tree;",
          "1492:  int keylen, slot, nr_free, next_slot, i;",
          "1494:  pr_devel(\"-->%s()\\n\", __func__);",
          "1496:  if (!array->root)",
          "1497:   return 0;",
          "1499:  edit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);",
          "1500:  if (!edit)",
          "1501:   return -ENOMEM;",
          "1502:  edit->array = array;",
          "1503:  edit->ops = ops;",
          "1504:  edit->ops_for_excised_subtree = ops;",
          "1505:  edit->set[0].ptr = &array->root;",
          "1506:  edit->excised_subtree = array->root;",
          "1508:  new_root = new_parent = NULL;",
          "1509:  new_ptr_pp = &new_root;",
          "1510:  cursor = array->root;",
          "1512: descend:",
          "1516:  if (assoc_array_ptr_is_shortcut(cursor)) {",
          "1517:   shortcut = assoc_array_ptr_to_shortcut(cursor);",
          "1518:   keylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);",
          "1519:   keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;",
          "1520:   new_s = kmalloc(sizeof(struct assoc_array_shortcut) +",
          "1521:     keylen * sizeof(unsigned long), GFP_KERNEL);",
          "1522:   if (!new_s)",
          "1523:    goto enomem;",
          "1524:   pr_devel(\"dup shortcut %p -> %p\\n\", shortcut, new_s);",
          "1525:   memcpy(new_s, shortcut, (sizeof(struct assoc_array_shortcut) +",
          "1526:       keylen * sizeof(unsigned long)));",
          "1527:   new_s->back_pointer = new_parent;",
          "1528:   new_s->parent_slot = shortcut->parent_slot;",
          "1530:   new_ptr_pp = &new_s->next_node;",
          "1531:   cursor = shortcut->next_node;",
          "1532:  }",
          "1535:  node = assoc_array_ptr_to_node(cursor);",
          "1536:  new_n = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);",
          "1537:  if (!new_n)",
          "1538:   goto enomem;",
          "1539:  pr_devel(\"dup node %p -> %p\\n\", node, new_n);",
          "1540:  new_n->back_pointer = new_parent;",
          "1541:  new_n->parent_slot = node->parent_slot;",
          "1543:  new_ptr_pp = NULL;",
          "1544:  slot = 0;",
          "1546: continue_node:",
          "1548:  for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "1549:   ptr = node->slots[slot];",
          "1550:   if (!ptr)",
          "1551:    continue;",
          "1553:   if (assoc_array_ptr_is_leaf(ptr)) {",
          "1554:    if (iterator(assoc_array_ptr_to_leaf(ptr),",
          "1555:          iterator_data))",
          "1559:     new_n->slots[slot] = ptr;",
          "1560:    continue;",
          "1561:   }",
          "1563:   new_ptr_pp = &new_n->slots[slot];",
          "1564:   cursor = ptr;",
          "1565:   goto descend;",
          "1566:  }",
          "1568:  pr_devel(\"-- compress node %p --\\n\", new_n);",
          "1573:  new_n->nr_leaves_on_branch = 0;",
          "1574:  nr_free = 0;",
          "1575:  for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "1576:   ptr = new_n->slots[slot];",
          "1577:   if (!ptr)",
          "1578:    nr_free++;",
          "1579:   else if (assoc_array_ptr_is_leaf(ptr))",
          "1580:    new_n->nr_leaves_on_branch++;",
          "1581:  }",
          "1582:  pr_devel(\"free=%d, leaves=%lu\\n\", nr_free, new_n->nr_leaves_on_branch);",
          "1585:  next_slot = 0;",
          "1586:  for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {",
          "1587:   struct assoc_array_shortcut *s;",
          "1588:   struct assoc_array_node *child;",
          "1590:   ptr = new_n->slots[slot];",
          "1591:   if (!ptr || assoc_array_ptr_is_leaf(ptr))",
          "1592:    continue;",
          "1594:   s = NULL;",
          "1595:   if (assoc_array_ptr_is_shortcut(ptr)) {",
          "1596:    s = assoc_array_ptr_to_shortcut(ptr);",
          "1597:    ptr = s->next_node;",
          "1598:   }",
          "1600:   child = assoc_array_ptr_to_node(ptr);",
          "1601:   new_n->nr_leaves_on_branch += child->nr_leaves_on_branch;",
          "1603:   if (child->nr_leaves_on_branch <= nr_free + 1) {",
          "1605:    pr_devel(\"[%d] fold node %lu/%d [nx %d]\\n\",",
          "1606:      slot, child->nr_leaves_on_branch, nr_free + 1,",
          "1607:      next_slot);",
          "1612:    BUG_ON(s);",
          "1614:    new_n->slots[slot] = NULL;",
          "1615:    nr_free++;",
          "1616:    if (slot < next_slot)",
          "1617:     next_slot = slot;",
          "1618:    for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {",
          "1619:     struct assoc_array_ptr *p = child->slots[i];",
          "1620:     if (!p)",
          "1621:      continue;",
          "1622:     BUG_ON(assoc_array_ptr_is_meta(p));",
          "1623:     while (new_n->slots[next_slot])",
          "1624:      next_slot++;",
          "1625:     BUG_ON(next_slot >= ASSOC_ARRAY_FAN_OUT);",
          "1626:     new_n->slots[next_slot++] = p;",
          "1627:     nr_free--;",
          "1628:    }",
          "1629:    kfree(child);",
          "1630:   } else {",
          "1631:    pr_devel(\"[%d] retain node %lu/%d [nx %d]\\n\",",
          "1632:      slot, child->nr_leaves_on_branch, nr_free + 1,",
          "1633:      next_slot);",
          "1634:   }",
          "1635:  }",
          "1637:  pr_devel(\"after: %lu\\n\", new_n->nr_leaves_on_branch);",
          "1639:  nr_leaves_on_tree = new_n->nr_leaves_on_branch;",
          "1642:  if (nr_free == ASSOC_ARRAY_FAN_OUT - 1) {",
          "1643:   for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++)",
          "1644:    if ((ptr = new_n->slots[slot]))",
          "1645:     break;",
          "1647:   if (assoc_array_ptr_is_meta(ptr) &&",
          "1648:       assoc_array_ptr_is_shortcut(ptr)) {",
          "1649:    pr_devel(\"excise node %p with 1 shortcut\\n\", new_n);",
          "1650:    new_s = assoc_array_ptr_to_shortcut(ptr);",
          "1651:    new_parent = new_n->back_pointer;",
          "1652:    slot = new_n->parent_slot;",
          "1653:    kfree(new_n);",
          "1654:    if (!new_parent) {",
          "1655:     new_s->back_pointer = NULL;",
          "1656:     new_s->parent_slot = 0;",
          "1657:     new_root = ptr;",
          "1658:     goto gc_complete;",
          "1659:    }",
          "1661:    if (assoc_array_ptr_is_shortcut(new_parent)) {",
          "1663:     struct assoc_array_shortcut *s =",
          "1664:      assoc_array_ptr_to_shortcut(new_parent);",
          "1666:     pr_devel(\"excise preceding shortcut\\n\");",
          "1668:     new_parent = new_s->back_pointer = s->back_pointer;",
          "1669:     slot = new_s->parent_slot = s->parent_slot;",
          "1670:     kfree(s);",
          "1671:     if (!new_parent) {",
          "1672:      new_s->back_pointer = NULL;",
          "1673:      new_s->parent_slot = 0;",
          "1674:      new_root = ptr;",
          "1675:      goto gc_complete;",
          "1676:     }",
          "1677:    }",
          "1679:    new_s->back_pointer = new_parent;",
          "1680:    new_s->parent_slot = slot;",
          "1681:    new_n = assoc_array_ptr_to_node(new_parent);",
          "1682:    new_n->slots[slot] = ptr;",
          "1683:    goto ascend_old_tree;",
          "1684:   }",
          "1685:  }",
          "1690:  ptr = new_n->back_pointer;",
          "1691:  if (!ptr)",
          "1692:   goto gc_complete;",
          "1694:  if (assoc_array_ptr_is_shortcut(ptr)) {",
          "1695:   new_s = assoc_array_ptr_to_shortcut(ptr);",
          "1696:   new_parent = new_s->back_pointer;",
          "1697:   slot = new_s->parent_slot;",
          "1699:   if (new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {",
          "1700:    struct assoc_array_node *n;",
          "1702:    pr_devel(\"excise shortcut\\n\");",
          "1703:    new_n->back_pointer = new_parent;",
          "1704:    new_n->parent_slot = slot;",
          "1705:    kfree(new_s);",
          "1706:    if (!new_parent) {",
          "1707:     new_root = assoc_array_node_to_ptr(new_n);",
          "1708:     goto gc_complete;",
          "1709:    }",
          "1711:    n = assoc_array_ptr_to_node(new_parent);",
          "1712:    n->slots[slot] = assoc_array_node_to_ptr(new_n);",
          "1713:   }",
          "1714:  } else {",
          "1715:   new_parent = ptr;",
          "1716:  }",
          "1717:  new_n = assoc_array_ptr_to_node(new_parent);",
          "1719: ascend_old_tree:",
          "1720:  ptr = node->back_pointer;",
          "1721:  if (assoc_array_ptr_is_shortcut(ptr)) {",
          "1722:   shortcut = assoc_array_ptr_to_shortcut(ptr);",
          "1723:   slot = shortcut->parent_slot;",
          "1724:   cursor = shortcut->back_pointer;",
          "1725:  } else {",
          "1726:   slot = node->parent_slot;",
          "1727:   cursor = ptr;",
          "1728:  }",
          "1729:  BUG_ON(!ptr);",
          "1730:  node = assoc_array_ptr_to_node(cursor);",
          "1731:  slot++;",
          "1732:  goto continue_node;",
          "1734: gc_complete:",
          "1735:  edit->set[0].to = new_root;",
          "1736:  assoc_array_apply_edit(edit);",
          "1737:  edit->array->nr_leaves_on_tree = nr_leaves_on_tree;",
          "1738:  return 0;",
          "1740: enomem:",
          "1741:  pr_devel(\"enomem\\n\");",
          "1742:  assoc_array_destroy_subtree(new_root, edit->ops);",
          "1743:  kfree(edit);",
          "1744:  return -ENOMEM;",
          "1745: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-15192",
  "cve_desc": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes a list of strings to `dlpack.to_dlpack` there is a memory leak following an expected validation failure. The issue occurs because the `status` argument during validation failures is not properly checked. Since each of the above methods can return an error status, the `status` value must be checked before continuing. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "22e07fb204386768e5bcbea563641ea11f96ceb8",
  "patch_info": {
    "commit_hash": "22e07fb204386768e5bcbea563641ea11f96ceb8",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/22e07fb204386768e5bcbea563641ea11f96ceb8",
    "files": [
      "tensorflow/c/eager/dlpack.cc",
      "tensorflow/python/dlpack/BUILD",
      "tensorflow/python/dlpack/dlpack_test.py",
      "tensorflow/python/tfe_wrapper.cc"
    ],
    "message": "Fix multiple vulnerabilities in `tf.experimental.dlpack.to_dlpack`.\n\nWe have a use after free caused by memory coruption, a segmentation fault caused by memory corruption, several memory leaks and an undefined behavior when taking the reference of a nullptr.\n\nPiperOrigin-RevId: 332568894\nChange-Id: Ife0fc05e103b35325094ae5d822ee5fdea764572",
    "before_after_code_files": [
      "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc",
      "tensorflow/python/dlpack/dlpack_test.py||tensorflow/python/dlpack/dlpack_test.py",
      "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc": [
      "File: tensorflow/c/eager/dlpack.cc -> tensorflow/c/eager/dlpack.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "249: }",
      "251: void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {",
      "252:   const Tensor* tensor = GetTensorFromHandle(h, status);",
      "253:   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());",
      "256:   auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx(tensor_ref);",
      "257:   tf_dlm_tensor_ctx->reference = tensor_ref;",
      "259:   DLManagedTensor* dlm_tensor = &tf_dlm_tensor_ctx->tensor;",
      "260:   dlm_tensor->manager_ctx = tf_dlm_tensor_ctx;",
      "261:   dlm_tensor->deleter = &DLManagedTensorDeleter;",
      "263:   int ndim = tensor->dims();",
      "264:   dlm_tensor->dl_tensor.ndim = ndim;",
      "268:   std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;",
      "269:   std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;",
      "",
      "[Removed Lines]",
      "254:   TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()",
      "262:   dlm_tensor->dl_tensor.ctx = GetDlContext(h, status);",
      "265:   dlm_tensor->dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);",
      "266:   dlm_tensor->dl_tensor.dtype = GetDlDataType(data_type, status);",
      "",
      "[Added Lines]",
      "252:   auto tf_dlm_context = GetDlContext(h, status);",
      "253:   if (!status->status.ok()) {",
      "254:     return nullptr;",
      "255:   }",
      "257:   auto* tf_dlm_data = TFE_TensorHandleDevicePointer(h, status);",
      "258:   if (!status->status.ok()) {",
      "259:     return nullptr;",
      "260:   }",
      "265:   auto tf_dlm_type = GetDlDataType(data_type, status);",
      "266:   if (!status->status.ok()) {",
      "267:     return nullptr;",
      "268:   }",
      "270:   TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()",
      "277:   dlm_tensor->dl_tensor.ctx = tf_dlm_context;",
      "280:   dlm_tensor->dl_tensor.data = tf_dlm_data;",
      "281:   dlm_tensor->dl_tensor.dtype = tf_dlm_type;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "276:     (*stride_arr)[i] = (*shape_arr)[i + 1] * (*stride_arr)[i + 1];",
      "277:   }",
      "286:   dlm_tensor->dl_tensor.byte_offset =",
      "287:       0;  // TF doesn't handle the strides and byte_offsets here",
      "288:   return static_cast<void*>(dlm_tensor);",
      "",
      "[Removed Lines]",
      "279:   dlm_tensor->dl_tensor.shape = &(*shape_arr)[0];",
      "285:   dlm_tensor->dl_tensor.strides = &(*stride_arr)[0];",
      "",
      "[Added Lines]",
      "294:   dlm_tensor->dl_tensor.shape = shape_arr->data();",
      "300:   dlm_tensor->dl_tensor.strides = stride_arr->data();",
      "",
      "---------------"
    ],
    "tensorflow/python/dlpack/dlpack_test.py||tensorflow/python/dlpack/dlpack_test.py": [
      "File: tensorflow/python/dlpack/dlpack_test.py -> tensorflow/python/dlpack/dlpack_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "20: from absl.testing import parameterized",
      "21: import numpy as np",
      "23: from tensorflow.python.dlpack import dlpack",
      "24: from tensorflow.python.framework import constant_op",
      "25: from tensorflow.python.framework import dtypes",
      "26: from tensorflow.python.framework import ops",
      "27: from tensorflow.python.platform import test",
      "28: from tensorflow.python.ops import array_ops",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "27: from tensorflow.python.framework import errors",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:     self.assertRaisesRegex(Exception, \".* is not supported by dlpack\",",
      "106:                            UnsupportedComplex64)",
      "109: if __name__ == \"__main__\":",
      "110:   ops.enable_eager_execution()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "110:   def testMustPassTensorArgumentToDLPack(self):",
      "111:     with self.assertRaisesRegex(",
      "112:         errors.InvalidArgumentError,",
      "113:         \"The argument to `to_dlpack` must be a TF tensor, not Python object\"):",
      "114:       dlpack.to_dlpack([1])",
      "",
      "---------------"
    ],
    "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc": [
      "File: tensorflow/python/tfe_wrapper.cc -> tensorflow/python/tfe_wrapper.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1359:   m.def(\"TFE_ToDlpackCapsule\", [](py::handle& o) {",
      "1360:     PyObject* eager_tensor_pyobject_ptr = o.ptr();",
      "1362:     tensorflow::Safe_TF_StatusPtr status =",
      "1363:         tensorflow::make_safe(TF_NewStatus());",
      "1364:     void* dlm_ptr = tensorflow::TFE_HandleToDLPack(thandle, status.get());",
      "1365:     tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());",
      "",
      "[Removed Lines]",
      "1361:     TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);",
      "",
      "[Added Lines]",
      "1364:     if (!EagerTensor_CheckExact(eager_tensor_pyobject_ptr)) {",
      "1365:       status->status = tensorflow::errors::InvalidArgument(",
      "1366:           \"The argument to `to_dlpack` must be a TF tensor, not Python object\");",
      "1367:       tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());",
      "1368:     }",
      "1370:     TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "88d46f618496e294020b926d158dca59257dbb02",
      "candidate_info": {
        "commit_hash": "88d46f618496e294020b926d158dca59257dbb02",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/88d46f618496e294020b926d158dca59257dbb02",
        "files": [
          "tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h",
          "tensorflow/python/tfe_wrapper.cc"
        ],
        "message": "address comment",
        "before_after_code_files": [
          "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h",
          "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc",
            "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc"
          ],
          "candidate": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc",
            "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc": [
          "File: tensorflow/c/eager/dlpack.cc -> tensorflow/c/eager/dlpack.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"tensorflow/c/eager/dlpack.h\"",
          "2: #include \"include/dlpack/dlpack.h\"  // TF:dlpack",
          "3: #include \"tensorflow/c/eager/c_api_internal.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: you may not use this file except in compliance with the License.",
          "5: You may obtain a copy of the License at",
          "7:     http://www.apache.org/licenses/LICENSE-2.0",
          "9: Unless required by applicable law or agreed to in writing, software",
          "10: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: See the License for the specific language governing permissions and",
          "13: limitations under the License.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11: namespace tensorflow {",
          "16: namespace {",
          "19:   TensorReference* handle;",
          "20:   DLManagedTensor tensor;",
          "21: };",
          "25:   if (h == nullptr || !h->handle->IsValid(&status->status)) {",
          "26:     status->status = tensorflow::errors::InvalidArgument(",
          "27:         \"The passed in handle is a nullptr\");",
          "",
          "[Removed Lines]",
          "13: using tensorflow::Tensor;",
          "14: using tensorflow::TensorHandleInterface;",
          "18: struct TFDLMTensor {",
          "23: TensorHandle* GetTensorHandleFromTFEHandle(TFE_TensorHandle* h,",
          "24:                                            TF_Status* status) {",
          "",
          "[Added Lines]",
          "30: struct TFDLManagedTensorCtx {",
          "36: const Tensor* GetTensorFromHandle(TFE_TensorHandle* h, TF_Status* status) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "37:         \"handle.\");",
          "38:     return nullptr;",
          "39:   }",
          "59:   const tensorflow::Tensor* tensor;",
          "60:   status->status = handle->Tensor(&tensor);",
          "61:   if (!status->status.ok()) {",
          "",
          "[Removed Lines]",
          "40:   return handle;",
          "41: }",
          "43: const Tensor* GetTensorFromHandle(TFE_TensorHandle* h, TF_Status* status) {",
          "44:   TensorHandle* handle = GetTensorHandleFromTFEHandle(h, status);",
          "46:   if (handle->IsRemote()) {",
          "47:     status->status = tensorflow::errors::InvalidArgument(",
          "48:         \"TFE_TensorHandleDevicePointer may not be called on a remote tensor \"",
          "49:         \"handle.\");",
          "50:     return nullptr;",
          "51:   }",
          "52:   tensorflow::Device* device(absl::get<tensorflow::Device*>(handle->device()));",
          "53:   if (device != nullptr) {",
          "54:     status->status = device->Sync();",
          "55:     if (!status->status.ok()) {",
          "56:       return nullptr;",
          "57:     }",
          "58:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "64:   return tensor;",
          "65: };",
          "69:   owner->handle->Unref();",
          "70:   delete owner;",
          "71: }",
          "74:   DLDataType dtype;",
          "75:   dtype.lanes = 1;",
          "76:   dtype.bits = TF_DataTypeSize(data_type) * 8;",
          "",
          "[Removed Lines]",
          "67: void deleter(DLManagedTensor* arg) {",
          "68:   TFDLMTensor* owner = static_cast<TFDLMTensor*>(arg->manager_ctx);",
          "73: DLDataType getDLDataType(TF_DataType data_type, TF_Status* status) {",
          "",
          "[Added Lines]",
          "60: void DLManagedTensorDeleter(DLManagedTensor* arg) {",
          "61:   TFDLManagedTensorCtx* owner = static_cast<TFDLManagedTensorCtx*>(arg->manager_ctx);",
          "66: DLDataType GetDLDataType(TF_DataType data_type, TF_Status* status) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "155:   return dtype;",
          "156: }",
          "159:   DLContext ctx;",
          "160:   const char* device_name = h->handle->DeviceName(&status->status);",
          "161:   DeviceNameUtils::ParsedName parsed_name;",
          "",
          "[Removed Lines]",
          "158: DLContext getDLContext(TFE_TensorHandle* h, TF_Status* status) {",
          "",
          "[Added Lines]",
          "151: DLContext  GetDLContext(TFE_TensorHandle* h, TF_Status* status) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "180:   return ctx;",
          "181: }",
          "184:                                         TF_Status* status) {",
          "185:   const Tensor* tensor = GetTensorFromHandle(h, status);",
          "186:   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());",
          "188:   TensorReference* tensor_ref =",
          "189:       new TensorReference(*tensor);  // This will call buf_->Ref()",
          "190:   tfDLMTensor->handle = tensor_ref;",
          "191:   tfDLMTensor->tensor.manager_ctx = tfDLMTensor;",
          "194:   int ndim = tensor->dims();",
          "195:   tfDLMTensor->tensor.dl_tensor.ndim = ndim;",
          "196:   tfDLMTensor->tensor.dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);",
          "199:   int64_t* shape_arr = new int64_t[ndim];",
          "200:   for (int i = 0; i < ndim; i++) {",
          "",
          "[Removed Lines]",
          "183: DLManagedTensor* TFEHandleToTFDLMTensor(TFE_TensorHandle* h,",
          "187:   TFDLMTensor* tfDLMTensor(new TFDLMTensor);",
          "192:   tfDLMTensor->tensor.deleter = &deleter;",
          "193:   tfDLMTensor->tensor.dl_tensor.ctx = getDLContext(h, status);",
          "197:   tfDLMTensor->tensor.dl_tensor.dtype = getDLDataType(data_type, status);",
          "",
          "[Added Lines]",
          "176: DLManagedTensor* TFEHandleToTFDLManagedTensorCtx(TFE_TensorHandle* h,",
          "180:   TFDLManagedTensorCtx* tfDLMTensor(new TFDLManagedTensorCtx);",
          "185:   tfDLMTensor->tensor.deleter = &DLManagedTensorDeleter;",
          "186:   tfDLMTensor->tensor.dl_tensor.ctx = GetDLContext(h, status);",
          "190:   tfDLMTensor->tensor.dl_tensor.dtype = GetDLDataType(data_type, status);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "313: }",
          "315: void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {",
          "317:   return static_cast<void*>(tfdlmtensor);",
          "318: }",
          "",
          "[Removed Lines]",
          "316:   DLManagedTensor* tfdlmtensor = TFEHandleToTFDLMTensor(h, status);",
          "",
          "[Added Lines]",
          "309:   DLManagedTensor* tfdlmtensor = TFEHandleToTFDLManagedTensorCtx(h, status);",
          "",
          "---------------"
        ],
        "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h": [
          "File: tensorflow/c/eager/dlpack.h -> tensorflow/c/eager/dlpack.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #ifndef TENSORFLOW_C_DLPACK_H_",
          "2: #define TENSORFLOW_C_DLPACK_H_",
          "4: #include \"tensorflow/c/eager/c_api.h\"",
          "5: #include \"tensorflow/core/framework/tensor.h\"",
          "11: namespace tensorflow {",
          "13: const char* const kDlTensorCapsuleName = \"dltensor\";",
          "",
          "[Removed Lines]",
          "7: #ifdef __cplusplus",
          "8: extern \"C\" {",
          "9: #endif",
          "",
          "[Added Lines]",
          "3: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: you may not use this file except in compliance with the License.",
          "5: You may obtain a copy of the License at",
          "7:     http://www.apache.org/licenses/LICENSE-2.0",
          "9: Unless required by applicable law or agreed to in writing, software",
          "10: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: See the License for the specific language governing permissions and",
          "13: limitations under the License.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19: void TFE_CallDLManagedTensorDeleter(void* dlm_ptr);",
          "20: }  // namespace tensorflow",
          "26: #endif  // TENSORFLOW_C_DLPACK_H_",
          "",
          "[Removed Lines]",
          "22: #ifdef __cplusplus",
          "24: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc": [
          "File: tensorflow/python/tfe_wrapper.cc -> tensorflow/python/tfe_wrapper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1069:           \"Note that a DLPack tensor may be consumed at most once.\",",
          "1070:           absl::string_view(pycapsule.name()));",
          "1071:     }",
          "1075:     PyCapsule_SetName(pycapsule.ptr(), \"used_dltensor\");",
          "1076:     PyCapsule_SetDestructor(pycapsule.ptr(), nullptr);",
          "1077:     tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());",
          "",
          "[Removed Lines]",
          "1072:     TFE_TensorHandle* thandle = tensorflow::TFE_HandleFromDLPack(",
          "1073:         static_cast<void*>(pycapsule), status.get());",
          "",
          "[Added Lines]",
          "1072:     TFE_TensorHandle* thandle =",
          "1073:         tensorflow::TFE_HandleFromDLPack(pycapsule, status.get());",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d291eba07ec612f2152fa1d0c6180d72c38c669",
      "candidate_info": {
        "commit_hash": "4d291eba07ec612f2152fa1d0c6180d72c38c669",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/4d291eba07ec612f2152fa1d0c6180d72c38c669",
        "files": [
          "tensorflow/c/eager/BUILD",
          "tensorflow/python/eager/BUILD",
          "tensorflow/python/tfe_wrapper.cc"
        ],
        "message": "dlpack",
        "before_after_code_files": [
          "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc"
          ],
          "candidate": [
            "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/python/tfe_wrapper.cc||tensorflow/python/tfe_wrapper.cc": [
          "File: tensorflow/python/tfe_wrapper.cc -> tensorflow/python/tfe_wrapper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include \"tensorflow/c/eager/c_api.h\"",
          "27: #include \"tensorflow/c/eager/c_api_experimental.h\"",
          "28: #include \"tensorflow/c/eager/c_api_internal.h\"",
          "29: #include \"tensorflow/c/tf_status.h\"",
          "30: #include \"tensorflow/c/tf_status_helper.h\"",
          "31: #include \"tensorflow/compiler/jit/flags.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"tensorflow/c/eager/dlpack.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1033:   m.def(\"TF_NewBufferFromString\", &TF_NewBufferFromString,",
          "1034:         py::return_value_policy::reference);",
          "1038:   py::enum_<TFE_ContextDevicePlacementPolicy>(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1038:   m.def(\"TFE_ToDlpackCapsule\", [](py::handle& o) {",
          "1039:     PyObject* eager_tensor_pyobject_ptr = o.ptr();",
          "1040:     TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);",
          "1041:     tensorflow::Safe_TF_StatusPtr status =",
          "1042:         tensorflow::make_safe(TF_NewStatus());",
          "1043:     void* dlm_ptr = tensorflow::TFE_HandleToDLPack(thandle, status.get());",
          "1045:     py::capsule capsule(",
          "1046:         dlm_ptr, tensorflow::kDlTensorCapsuleName, [](PyObject* obj) {",
          "1047:           void* dlm_rptr =",
          "1048:               PyCapsule_GetPointer(obj, tensorflow::kDlTensorCapsuleName);",
          "1049:           if (dlm_rptr) {",
          "1050:             tensorflow::TFE_CallDLManagedTensorDeleter(dlm_rptr);",
          "1051:           } else {",
          "1054:             PyErr_Clear();",
          "1055:           }",
          "1056:         });",
          "1057:     tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());",
          "1058:     return capsule;",
          "1059:   });",
          "1061:   m.def(\"TFE_FromDlpackCapsule\", [](const py::capsule& pycapsule) {",
          "1062:     tensorflow::Safe_TF_StatusPtr status =",
          "1063:         tensorflow::make_safe(TF_NewStatus());",
          "1064:     if (absl::string_view(pycapsule.name()) !=",
          "1065:         tensorflow::kDlTensorCapsuleName) {",
          "1066:       status->status = tensorflow::errors::InvalidArgument(",
          "1067:           \"DLPack tensor must be a capsule with name \\\"dltensor\\\", got \\\"%s\\\". \"",
          "1068:           \"Note that a DLPack tensor may be consumed at most once.\",",
          "1069:           absl::string_view(pycapsule.name()));",
          "1070:     }",
          "1071:     TFE_TensorHandle* thandle = tensorflow::TFE_HandleFromDLPack(",
          "1072:         static_cast<void*>(pycapsule), status.get());",
          "1073:     tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());",
          "1074:     return py::handle(EagerTensorFromHandle(thandle));",
          "1075:   });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "89c73caf126cdad3b6f3490658f5779f1fd9a05e",
      "candidate_info": {
        "commit_hash": "89c73caf126cdad3b6f3490658f5779f1fd9a05e",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/89c73caf126cdad3b6f3490658f5779f1fd9a05e",
        "files": [
          "tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h"
        ],
        "message": "dlpack",
        "before_after_code_files": [
          "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc"
          ],
          "candidate": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc": [
          "File: tensorflow/c/eager/dlpack.cc -> tensorflow/c/eager/dlpack.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"tensorflow/c/eager/dlpack.h\"",
          "2: #include \"include/dlpack/dlpack.h\"  // TF:dlpack",
          "3: #include \"tensorflow/c/eager/c_api_internal.h\"",
          "4: #include \"tensorflow/c/tf_status_helper.h\"",
          "5: #include \"tensorflow/core/framework/tensor.h\"",
          "6: #include \"tensorflow/core/platform/casts.h\"",
          "8: #include \"tensorflow/core/framework/tensor_reference.h\"",
          "9: #include \"tensorflow/core/platform/logging.h\"",
          "11: namespace tensorflow {",
          "13: using tensorflow::Tensor;",
          "14: using tensorflow::TensorHandleInterface;",
          "16: namespace {",
          "18: struct TFDLMTensor {",
          "19:   TensorReference* handle;",
          "20:   DLManagedTensor tensor;",
          "21: };",
          "23: TensorHandle* GetTensorHandleFromTFEHandle(TFE_TensorHandle* h,",
          "24:                                            TF_Status* status) {",
          "25:   if (h == nullptr || !h->handle->IsValid(&status->status)) {",
          "26:     status->status = tensorflow::errors::InvalidArgument(",
          "27:         \"The passed in handle is a nullptr\");",
          "28:     return nullptr;",
          "29:   }",
          "30:   tensorflow::TensorHandle* handle =",
          "31:       tensorflow::down_cast<tensorflow::TensorHandleInterface*>(h->handle.get())",
          "32:           ->Handle();",
          "34:   if (handle->IsRemote()) {",
          "35:     status->status = tensorflow::errors::InvalidArgument(",
          "36:         \"TFE_TensorHandleDevicePointer may not be called on a remote tensor \"",
          "37:         \"handle.\");",
          "38:     return nullptr;",
          "39:   }",
          "40:   return handle;",
          "41: }",
          "43: const Tensor* GetTensorFromHandle(TFE_TensorHandle* h, TF_Status* status) {",
          "44:   TensorHandle* handle = GetTensorHandleFromTFEHandle(h, status);",
          "46:   if (handle->IsRemote()) {",
          "47:     status->status = tensorflow::errors::InvalidArgument(",
          "48:         \"TFE_TensorHandleDevicePointer may not be called on a remote tensor \"",
          "49:         \"handle.\");",
          "50:     return nullptr;",
          "51:   }",
          "52:   tensorflow::Device* device(absl::get<tensorflow::Device*>(handle->device()));",
          "53:   if (device != nullptr) {",
          "54:     status->status = device->Sync();",
          "55:     if (!status->status.ok()) {",
          "56:       return nullptr;",
          "57:     }",
          "58:   }",
          "59:   const tensorflow::Tensor* tensor;",
          "60:   status->status = handle->Tensor(&tensor);",
          "61:   if (!status->status.ok()) {",
          "62:     return nullptr;",
          "63:   }",
          "64:   return tensor;",
          "65: };",
          "67: void deleter(DLManagedTensor* arg) {",
          "68:   TFDLMTensor* owner = static_cast<TFDLMTensor*>(arg->manager_ctx);",
          "69:   owner->handle->Unref();",
          "70:   delete owner;",
          "71: }",
          "73: DLDataType getDLDataType(TF_DataType data_type, TF_Status* status) {",
          "74:   DLDataType dtype;",
          "75:   dtype.lanes = 1;",
          "76:   dtype.bits = TF_DataTypeSize(data_type) * 8;",
          "77:   switch (data_type) {",
          "78:     case TF_DataType::TF_FLOAT:",
          "79:       dtype.code = DLDataTypeCode::kDLFloat;",
          "80:       break;",
          "81:     case TF_DataType::TF_DOUBLE:",
          "82:       dtype.code = DLDataTypeCode::kDLFloat;",
          "83:       break;",
          "84:     case TF_DataType::TF_INT32:",
          "85:       dtype.code = DLDataTypeCode::kDLInt;",
          "86:       break;",
          "87:     case TF_DataType::TF_UINT8:",
          "88:       dtype.code = DLDataTypeCode::kDLUInt;",
          "89:       break;",
          "90:     case TF_DataType::TF_INT16:",
          "91:       dtype.code = DLDataTypeCode::kDLInt;",
          "92:       break;",
          "93:     case TF_DataType::TF_STRING:",
          "94:       dtype.code = DLDataTypeCode::kDLFloat;",
          "95:       break;",
          "96:     case TF_DataType::TF_COMPLEX64:",
          "97:       status->status = tensorflow::errors::InvalidArgument(",
          "98:           \"TF_COMPLEX64 is not supported by dlpack\");",
          "99:       break;",
          "100:     case TF_DataType::TF_INT64:",
          "101:       dtype.code = DLDataTypeCode::kDLInt;",
          "102:       break;",
          "103:     case TF_DataType::TF_BOOL:",
          "104:       dtype.code = DLDataTypeCode::kDLUInt;",
          "105:       break;",
          "106:     case TF_DataType::TF_QINT8:",
          "107:       status->status = tensorflow::errors::InvalidArgument(",
          "108:           \"TF_QINT8 is not supported by dlpack\");",
          "109:       break;",
          "110:     case TF_DataType::TF_QUINT8:",
          "111:       status->status = tensorflow::errors::InvalidArgument(",
          "112:           \"TF_QUINT8 is not supported by dlpack\");",
          "113:       break;",
          "114:     case TF_DataType::TF_QINT32:",
          "115:       status->status = tensorflow::errors::InvalidArgument(",
          "116:           \"TF_QINT32 is not supported by dlpack\");",
          "117:       break;",
          "118:     case TF_DataType::TF_BFLOAT16:",
          "119:       dtype.code = DLDataTypeCode::kDLBfloat;",
          "120:       break;",
          "121:     case TF_DataType::TF_QINT16:",
          "122:       status->status = tensorflow::errors::InvalidArgument(",
          "123:           \"TF_QINT16 is not supported by dlpack\");",
          "124:       break;",
          "125:     case TF_DataType::TF_QUINT16:",
          "126:       status->status = tensorflow::errors::InvalidArgument(",
          "127:           \"TF_QUINT16 is not supported by dlpack\");",
          "128:       break;",
          "129:     case TF_DataType::TF_COMPLEX128:",
          "130:       status->status = tensorflow::errors::InvalidArgument(",
          "131:           \"TF_COMPLEX128 is not supported by dlpack\");",
          "132:       break;",
          "133:     case TF_DataType::TF_HALF:",
          "134:       dtype.code = DLDataTypeCode::kDLFloat;",
          "135:       break;",
          "136:     case TF_DataType::TF_RESOURCE:",
          "137:       status->status = tensorflow::errors::InvalidArgument(",
          "138:           \"TF_RESOURCE is not supported by dlpack\");",
          "139:       break;",
          "140:     case TF_DataType::TF_VARIANT:",
          "141:       status->status = tensorflow::errors::InvalidArgument(",
          "142:           \"TF_VARIANT is not supported by dlpack\");",
          "143:       break;",
          "144:     case TF_DataType::TF_UINT32:",
          "145:       dtype.code = DLDataTypeCode::kDLUInt;",
          "146:       break;",
          "147:     case TF_DataType::TF_UINT64:",
          "148:       dtype.code = DLDataTypeCode::kDLUInt;",
          "149:       break;",
          "150:     default:",
          "151:       status->status = tensorflow::errors::InvalidArgument(",
          "152:           \"Unsupported TF_DataType is not supported by dlpack\");",
          "153:       break;",
          "154:   }",
          "155:   return dtype;",
          "156: }",
          "158: DLContext getDLContext(TFE_TensorHandle* h, TF_Status* status) {",
          "159:   DLContext ctx;",
          "160:   const char* device_name = h->handle->DeviceName(&status->status);",
          "161:   DeviceNameUtils::ParsedName parsed_name;",
          "162:   tensorflow::DeviceNameUtils::ParseFullName(absl::string_view(device_name),",
          "163:                                              &parsed_name);",
          "164:   std::string device_type = parsed_name.type;",
          "165:   int device_id = -1;",
          "166:   if (parsed_name.has_id) {",
          "167:     device_id = parsed_name.id;",
          "168:   }  // Question? device_id?=-1",
          "170:   ctx.device_id = device_id;",
          "171:   if (device_type == \"CPU\") {",
          "172:     ctx.device_type = DLDeviceType::kDLCPU;",
          "173:   } else if (device_type == \"GPU\") {",
          "174:     ctx.device_type = DLDeviceType::kDLGPU;",
          "175:   } else {",
          "176:     status->status = tensorflow::errors::InvalidArgument(",
          "177:         \"Unsupported Device Type for DLPack\");",
          "178:   }",
          "180:   return ctx;",
          "181: }",
          "183: DLManagedTensor* TFEHandleToTFDLMTensor(TFE_TensorHandle* h,",
          "184:                                         TF_Status* status) {",
          "185:   const Tensor* tensor = GetTensorFromHandle(h, status);",
          "186:   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());",
          "187:   TFDLMTensor* tfDLMTensor(new TFDLMTensor);",
          "188:   TensorReference* tensor_ref =",
          "189:       new TensorReference(*tensor);  // This will call buf_->Ref()",
          "190:   tfDLMTensor->handle = tensor_ref;",
          "191:   tfDLMTensor->tensor.manager_ctx = tfDLMTensor;",
          "192:   tfDLMTensor->tensor.deleter = &deleter;",
          "193:   tfDLMTensor->tensor.dl_tensor.ctx = getDLContext(h, status);",
          "194:   int ndim = tensor->dims();",
          "195:   tfDLMTensor->tensor.dl_tensor.ndim = ndim;",
          "196:   tfDLMTensor->tensor.dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);",
          "197:   tfDLMTensor->tensor.dl_tensor.dtype = getDLDataType(data_type, status);",
          "199:   int64_t* shape_arr = new int64_t[ndim];",
          "200:   for (int i = 0; i < ndim; i++) {",
          "201:     shape_arr[i] = tensor->dim_size(i);",
          "202:   }",
          "204:   tfDLMTensor->tensor.dl_tensor.shape = shape_arr;",
          "206:   tfDLMTensor->tensor.dl_tensor.strides =",
          "207:       nullptr;  // Whether this is null at all the time?",
          "208:   tfDLMTensor->tensor.dl_tensor.byte_offset =",
          "209:       0;  // Whether this is 0 at all the time?",
          "210:   return &tfDLMTensor->tensor;",
          "211: }",
          "213: std::string FromDLContext(const DLContext& ctx, TF_Status* status) {",
          "214:   switch (ctx.device_type) {",
          "215:     case DLDeviceType::kDLCPU:",
          "216:       return \"CPU:0\";",
          "217:     case DLDeviceType::kDLGPU:",
          "218:       return absl::StrCat(\"GPU:\", ctx.device_id);",
          "219:     default:",
          "220:       return \"\";",
          "221:   };",
          "222: }",
          "223: TF_DataType FromDLDataType(const DLDataType& dtype, TF_Status* status) {",
          "224:   TF_DataType tf_dtype;",
          "225:   switch (dtype.code) {",
          "226:     case DLDataTypeCode::kDLUInt:",
          "227:       switch (dtype.bits) {",
          "228:         case 1:",
          "229:           tf_dtype = TF_DataType::TF_BOOL;",
          "230:           break;",
          "231:         case 8:",
          "232:           tf_dtype = TF_DataType::TF_UINT8;",
          "233:           break;",
          "234:         case 16:",
          "235:           tf_dtype = TF_DataType::TF_UINT16;",
          "236:           break;",
          "237:         case 32:",
          "238:           tf_dtype = TF_DataType::TF_UINT32;",
          "239:           break;",
          "240:         case 64:",
          "241:           tf_dtype = TF_DataType::TF_UINT64;",
          "242:           break;",
          "243:         default:",
          "244:           status->status = tensorflow::errors::InvalidArgument(",
          "245:               \"Unsupported UInt bits\", dtype.bits);",
          "246:       }",
          "247:       break;",
          "248:     case DLDataTypeCode::kDLInt:",
          "249:       switch (dtype.bits) {",
          "250:         case 8:",
          "251:           tf_dtype = TF_DataType::TF_INT8;",
          "252:           break;",
          "253:         case 16:",
          "254:           tf_dtype = TF_DataType::TF_INT16;",
          "255:           break;",
          "256:         case 32:",
          "257:           tf_dtype = TF_DataType::TF_INT32;",
          "258:           break;",
          "259:         case 64:",
          "260:           tf_dtype = TF_DataType::TF_INT64;",
          "261:           break;",
          "262:         default:",
          "263:           status->status = tensorflow::errors::InvalidArgument(",
          "264:               \"Unsupported Int bits\", dtype.bits);",
          "265:       }",
          "266:       break;",
          "267:     case DLDataTypeCode::kDLFloat:",
          "268:       switch (dtype.bits) {",
          "269:         case 16:",
          "270:           tf_dtype = TF_DataType::TF_HALF;",
          "271:           break;",
          "272:         case 32:",
          "273:           tf_dtype = TF_DataType::TF_FLOAT;",
          "274:           break;",
          "275:         case 64:",
          "276:           tf_dtype = TF_DataType::TF_DOUBLE;",
          "277:           break;",
          "278:         default:",
          "279:           status->status = tensorflow::errors::InvalidArgument(",
          "280:               \"Unsupported Float bits\", dtype.bits);",
          "281:       }",
          "282:       break;",
          "283:     case DLDataTypeCode::kDLBfloat:",
          "284:       switch (dtype.bits) {",
          "285:         case 16:",
          "286:           tf_dtype = TF_DataType::TF_BFLOAT16;",
          "287:           break;",
          "288:         default:",
          "289:           status->status = tensorflow::errors::InvalidArgument(",
          "290:               \"Unsupported BFloat bits\", dtype.bits);",
          "291:       }",
          "292:       break;",
          "293:     default:",
          "294:       status->status = tensorflow::errors::InvalidArgument(",
          "295:           \"Unsupported Type Codes\", dtype.code);",
          "296:   }",
          "298:   return tf_dtype;",
          "299: }",
          "301: void DeallocatorWrapperFunc(void* data, size_t len, void* dlmt_vptr){",
          "302:     DLManagedTensor* dlmt = static_cast<DLManagedTensor*>(dlmt_vptr);",
          "303:     dlmt->deleter(const_cast<DLManagedTensor*>(dlmt));",
          "304: }",
          "306: }  // namespace",
          "308: void TFE_CallDLManagedTensorDeleter(void* dlm_ptr) {",
          "309:   DLManagedTensor* dlMTensor = static_cast<DLManagedTensor*>(dlm_ptr);",
          "310:   if (dlMTensor) {",
          "311:     dlMTensor->deleter(const_cast<DLManagedTensor*>(dlMTensor));",
          "312:   }",
          "313: }",
          "315: void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {",
          "316:   DLManagedTensor* tfdlmtensor = TFEHandleToTFDLMTensor(h, status);",
          "317:   return static_cast<void*>(tfdlmtensor);",
          "318: }",
          "320: TFE_TensorHandle* TFE_HandleFromDLPack(void* dlm, TF_Status* status) {",
          "321:   TFE_ContextOptions* opts = TFE_NewContextOptions();",
          "322:   TFE_Context* ctx = TFE_NewContext(opts, status);",
          "323:   DLManagedTensor* dlmt = static_cast<DLManagedTensor*>(dlm);",
          "325:   std::string device_name = FromDLContext(dlmt->dl_tensor.ctx, status);",
          "326:   TF_DataType dtype = FromDLDataType(dlmt->dl_tensor.dtype, status);",
          "327:   int num_dims = dlmt->dl_tensor.ndim;",
          "328:   const int64_t* dims = dlmt->dl_tensor.shape;",
          "329:   void* data = dlmt->dl_tensor.data;",
          "331:   size_t total_bytes = dlmt->dl_tensor.dtype.bits / 8;",
          "332:   for (int i = 0; i < num_dims; i++) {",
          "333:     total_bytes *= dims[i];",
          "334:   }",
          "335:   TFE_TensorHandle* handle = TFE_NewTensorHandleFromDeviceMemory(",
          "336:       ctx, device_name.c_str(), dtype, dims, num_dims, data, total_bytes,",
          "337:       &DeallocatorWrapperFunc, &dlmt, status);",
          "339:   return handle;",
          "340: };",
          "342: }  // namespace tensorflow",
          "",
          "---------------"
        ],
        "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h": [
          "File: tensorflow/c/eager/dlpack.h -> tensorflow/c/eager/dlpack.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef TENSORFLOW_C_DLPACK_H_",
          "2: #define TENSORFLOW_C_DLPACK_H_",
          "4: #include \"tensorflow/c/eager/c_api.h\"",
          "5: #include \"tensorflow/core/framework/tensor.h\"",
          "7: #ifdef __cplusplus",
          "8: extern \"C\" {",
          "9: #endif",
          "11: namespace tensorflow {",
          "13: const char* const kDlTensorCapsuleName = \"dltensor\";",
          "15: void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status);",
          "17: TFE_TensorHandle* TFE_HandleFromDLPack(void* dlm, TF_Status* status);",
          "19: void TFE_CallDLManagedTensorDeleter(void* dlm_ptr);",
          "20: }  // namespace tensorflow",
          "22: #ifdef __cplusplus",
          "24: #endif",
          "26: #endif  // TENSORFLOW_C_DLPACK_H_",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "90a55447a7f4bd9c7c215f82ddb9a0d539bc1bee",
      "candidate_info": {
        "commit_hash": "90a55447a7f4bd9c7c215f82ddb9a0d539bc1bee",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/90a55447a7f4bd9c7c215f82ddb9a0d539bc1bee",
        "files": [
          "tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h"
        ],
        "message": "fix copyright",
        "before_after_code_files": [
          "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc"
          ],
          "candidate": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc": [
          "File: tensorflow/c/eager/dlpack.cc -> tensorflow/c/eager/dlpack.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: namespace {",
          "32:   std::vector<int64_t> shape;",
          "33:   DLManagedTensor tensor;",
          "34: };",
          "36: const Tensor* GetTensorFromHandle(TFE_TensorHandle* h, TF_Status* status) {",
          "",
          "[Removed Lines]",
          "30: struct TFDLManagedTensorCtx {",
          "31:   TensorReference* handle;",
          "",
          "[Added Lines]",
          "30: struct TfDlManagedTensorCtx {",
          "31:   TensorReference* reference;",
          "35:   TfDlManagedTensorCtx()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57: };",
          "59: void DLManagedTensorDeleter(DLManagedTensor* arg) {",
          "64:   delete owner;",
          "65: }",
          "",
          "[Removed Lines]",
          "60:   TFDLManagedTensorCtx* owner =",
          "61:       static_cast<TFDLManagedTensorCtx*>(arg->manager_ctx);",
          "62:   owner->handle->Unref();",
          "63:   delete owner->handle;",
          "",
          "[Added Lines]",
          "62:   TfDlManagedTensorCtx* owner =",
          "63:       static_cast<TfDlManagedTensorCtx*>(arg->manager_ctx);",
          "64:   owner->reference->Unref();",
          "65:   delete owner->reference;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "123:   return ctx;",
          "124: }",
          "127:                                                  TF_Status* status) {",
          "128:   const Tensor* tensor = GetTensorFromHandle(h, status);",
          "129:   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());",
          "132:   TensorReference* tensor_ref =",
          "133:       new TensorReference(*tensor);  // This will call buf_->Ref()",
          "135:   tf_dlm_tensor_ctx->tensor.manager_ctx = tf_dlm_tensor_ctx;",
          "136:   tf_dlm_tensor_ctx->tensor.deleter = &DLManagedTensorDeleter;",
          "137:   tf_dlm_tensor_ctx->tensor.dl_tensor.ctx = GetDLContext(h, status);",
          "",
          "[Removed Lines]",
          "126: DLManagedTensor* TFEHandleToTFDLManagedTensorCtx(TFE_TensorHandle* h,",
          "130:   auto* tf_dlm_tensor_ctx = new TFDLManagedTensorCtx;",
          "134:   tf_dlm_tensor_ctx->handle = tensor_ref;",
          "",
          "[Added Lines]",
          "128: DLManagedTensor* TFEHandleToTfDlManagedTensorCtx(TFE_TensorHandle* h,",
          "132:   auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx;",
          "136:   tf_dlm_tensor_ctx->reference = tensor_ref;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "142:   tf_dlm_tensor_ctx->tensor.dl_tensor.dtype = GetDLDataType(data_type, status);",
          "144:   std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;",
          "146:   shape_arr->resize(ndim);",
          "147:   for (int i = 0; i < ndim; i++) {",
          "148:     (*shape_arr)[i] = tensor->dim_size(i);",
          "",
          "[Removed Lines]",
          "145:   std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "151:   tf_dlm_tensor_ctx->tensor.dl_tensor.shape =",
          "152:       reinterpret_cast<std::int64_t*>(shape_arr->data());",
          "153:   tf_dlm_tensor_ctx->tensor.dl_tensor.strides =",
          "155:   tf_dlm_tensor_ctx->tensor.dl_tensor.byte_offset =",
          "156:       0;  // TF doesn't handle the strides and byte_offsets here",
          "157:   return &tf_dlm_tensor_ctx->tensor;",
          "",
          "[Removed Lines]",
          "154:       nullptr;  // NULL indicates tensor is compact and row-majored.",
          "",
          "[Added Lines]",
          "155:       nullptr;  // nullptr indicates tensor is compact and row-majored.",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "259: }",
          "261: void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {",
          "263:   return static_cast<void*>(tfdlmtensor);",
          "264: }",
          "",
          "[Removed Lines]",
          "262:   DLManagedTensor* tfdlmtensor = TFEHandleToTFDLManagedTensorCtx(h, status);",
          "",
          "[Added Lines]",
          "263:   DLManagedTensor* tfdlmtensor = TFEHandleToTfDlManagedTensorCtx(h, status);",
          "",
          "---------------"
        ],
        "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h": [
          "File: tensorflow/c/eager/dlpack.h -> tensorflow/c/eager/dlpack.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: namespace tensorflow {",
          "27: TF_CAPI_EXPORT extern void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status);",
          "",
          "[Removed Lines]",
          "25: const char* const kDlTensorCapsuleName = \"dltensor\";",
          "",
          "[Added Lines]",
          "25: TF_CAPI_EXPORT extern const char* const kDlTensorCapsuleName = \"dltensor\";",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7c3ac77ee1582f0aa8546ecb74de2b34235a3e3c",
      "candidate_info": {
        "commit_hash": "7c3ac77ee1582f0aa8546ecb74de2b34235a3e3c",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/7c3ac77ee1582f0aa8546ecb74de2b34235a3e3c",
        "files": [
          "tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h"
        ],
        "message": "fix",
        "before_after_code_files": [
          "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc",
          "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc"
          ],
          "candidate": [
            "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/c/eager/dlpack.cc||tensorflow/c/eager/dlpack.cc": [
          "File: tensorflow/c/eager/dlpack.cc -> tensorflow/c/eager/dlpack.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:   return ctx;",
          "130: }",
          "173: absl::optional<std::string> DeviceNameFromDlContext(const DLContext& ctx,",
          "174:                                                     TF_Status* status) {",
          "175:   switch (ctx.device_type) {",
          "",
          "[Removed Lines]",
          "132: DLManagedTensor* TFEHandleToTfDlManagedTensorCtx(TFE_TensorHandle* h,",
          "133:                                                  TF_Status* status) {",
          "134:   const Tensor* tensor = GetTensorFromHandle(h, status);",
          "135:   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());",
          "136:   TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()",
          "138:   auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx(tensor_ref);",
          "139:   tf_dlm_tensor_ctx->reference = tensor_ref;",
          "141:   DLManagedTensor* dlm_tensor = &tf_dlm_tensor_ctx->tensor;",
          "142:   dlm_tensor->manager_ctx = tf_dlm_tensor_ctx;",
          "143:   dlm_tensor->deleter = &DLManagedTensorDeleter;",
          "144:   dlm_tensor->dl_tensor.ctx = GetDLContext(h, status);",
          "145:   int ndim = tensor->dims();",
          "146:   dlm_tensor->dl_tensor.ndim = ndim;",
          "147:   dlm_tensor->dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);",
          "148:   dlm_tensor->dl_tensor.dtype = GetDLDataType(data_type, status);",
          "150:   std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;",
          "151:   std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;",
          "152:   shape_arr->resize(ndim);",
          "153:   stride_arr->resize(ndim, 1);",
          "154:   for (int i = 0; i < ndim; i++) {",
          "155:     (*shape_arr)[i] = tensor->dim_size(i);",
          "156:   }",
          "157:   for (int i = ndim - 2; i >= 0; --i) {",
          "158:     (*stride_arr)[i] = (*shape_arr)[i + 1] * (*stride_arr)[i + 1];",
          "159:   }",
          "161:   dlm_tensor->dl_tensor.shape = &(*shape_arr)[0];",
          "167:   dlm_tensor->dl_tensor.strides = &(*stride_arr)[0];",
          "168:   dlm_tensor->dl_tensor.byte_offset =",
          "169:       0;  // TF doesn't handle the strides and byte_offsets here",
          "170:   return &tf_dlm_tensor_ctx->tensor;",
          "171: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "284: }",
          "286: void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {",
          "289: }",
          "291: TFE_TensorHandle* TFE_HandleFromDLPack(void* dlm, TF_Status* status) {",
          "",
          "[Removed Lines]",
          "287:   DLManagedTensor* tfdlmtensor = TFEHandleToTfDlManagedTensorCtx(h, status);",
          "288:   return static_cast<void*>(tfdlmtensor);",
          "",
          "[Added Lines]",
          "256:   const Tensor* tensor = GetTensorFromHandle(h, status);",
          "257:   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());",
          "258:   TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()",
          "260:   auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx(tensor_ref);",
          "261:   tf_dlm_tensor_ctx->reference = tensor_ref;",
          "263:   DLManagedTensor* dlm_tensor = &tf_dlm_tensor_ctx->tensor;",
          "264:   dlm_tensor->manager_ctx = tf_dlm_tensor_ctx;",
          "265:   dlm_tensor->deleter = &DLManagedTensorDeleter;",
          "266:   dlm_tensor->dl_tensor.ctx = GetDLContext(h, status);",
          "267:   int ndim = tensor->dims();",
          "268:   dlm_tensor->dl_tensor.ndim = ndim;",
          "269:   dlm_tensor->dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);",
          "270:   dlm_tensor->dl_tensor.dtype = GetDLDataType(data_type, status);",
          "272:   std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;",
          "273:   std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;",
          "274:   shape_arr->resize(ndim);",
          "275:   stride_arr->resize(ndim, 1);",
          "276:   for (int i = 0; i < ndim; i++) {",
          "277:     (*shape_arr)[i] = tensor->dim_size(i);",
          "278:   }",
          "279:   for (int i = ndim - 2; i >= 0; --i) {",
          "280:     (*stride_arr)[i] = (*shape_arr)[i + 1] * (*stride_arr)[i + 1];",
          "281:   }",
          "283:   dlm_tensor->dl_tensor.shape = &(*shape_arr)[0];",
          "289:   dlm_tensor->dl_tensor.strides = &(*stride_arr)[0];",
          "290:   dlm_tensor->dl_tensor.byte_offset =",
          "291:       0;  // TF doesn't handle the strides and byte_offsets here",
          "292:   return static_cast<void*>(dlm_tensor);",
          "",
          "---------------"
        ],
        "tensorflow/c/eager/dlpack.h||tensorflow/c/eager/dlpack.h": [
          "File: tensorflow/c/eager/dlpack.h -> tensorflow/c/eager/dlpack.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: namespace tensorflow {",
          "25: const char* const kDlTensorCapsuleName = \"dltensor\";",
          "31: TF_CAPI_EXPORT extern void TFE_CallDLManagedTensorDeleter(void* dlm_ptr);",
          "32: }  // namespace tensorflow",
          "35: #endif  // TENSORFLOW_C_DLPACK_H_",
          "",
          "[Removed Lines]",
          "27: TF_CAPI_EXPORT extern void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status);",
          "29: TF_CAPI_EXPORT extern TFE_TensorHandle* TFE_HandleFromDLPack(void* dlm, TF_Status* status);",
          "",
          "[Added Lines]",
          "29: TF_CAPI_EXPORT extern void* TFE_HandleToDLPack(TFE_TensorHandle* h,",
          "30:                                                TF_Status* status);",
          "33: TF_CAPI_EXPORT extern TFE_TensorHandle* TFE_HandleFromDLPack(void* dlm,",
          "34:                                                              TF_Status* status);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
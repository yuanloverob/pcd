{
  "cve_id": "CVE-2014-5272",
  "cve_desc": "libavcodec/iff.c in FFMpeg before 1.1.14, 1.2.x before 1.2.8, 2.2.x before 2.2.7, and 2.3.x before 2.3.2 allows remote attackers to have unspecified impact via a crafted iff image, which triggers an out-of-bounds array access, related to the rgb8 and rgbn formats.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "3539d6c63a16e1b2874bb037a86f317449c58770",
  "patch_info": {
    "commit_hash": "3539d6c63a16e1b2874bb037a86f317449c58770",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3539d6c63a16e1b2874bb037a86f317449c58770",
    "files": [
      "libavcodec/iff.c"
    ],
    "message": "avcodec/iff: check pixfmt for rgb8 / rgbn\n\nFixes out of array access\n\nFound-by: Piotr Bandurski <ami_stuff@o2.pl>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/iff.c||libavcodec/iff.c"
    ]
  },
  "patch_diff": {
    "libavcodec/iff.c||libavcodec/iff.c": [
      "File: libavcodec/iff.c -> libavcodec/iff.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "849:         break;",
      "850:     case 4:",
      "851:         bytestream2_init(&gb, buf, buf_size);",
      "853:             decode_rgb8(&gb, s->frame->data[0], avctx->width, avctx->height, s->frame->linesize[0]);",
      "855:             decode_rgbn(&gb, s->frame->data[0], avctx->width, avctx->height, s->frame->linesize[0]);",
      "856:         else",
      "857:             return unsupported(avctx);",
      "",
      "[Removed Lines]",
      "852:         if (avctx->codec_tag == MKTAG('R', 'G', 'B', '8'))",
      "854:         else if (avctx->codec_tag == MKTAG('R', 'G', 'B', 'N'))",
      "",
      "[Added Lines]",
      "852:         if (avctx->codec_tag == MKTAG('R', 'G', 'B', '8') && avctx->pix_fmt == AV_PIX_FMT_RGB32)",
      "854:         else if (avctx->codec_tag == MKTAG('R', 'G', 'B', 'N') && avctx->pix_fmt == AV_PIX_FMT_RGB444)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "abc1fa7c5a1dca1345b9471b81cfcda00c56220d",
      "candidate_info": {
        "commit_hash": "abc1fa7c5a1dca1345b9471b81cfcda00c56220d",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/abc1fa7c5a1dca1345b9471b81cfcda00c56220d",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "avcodec/iff: check pixfmt for rgb8 / rgbn\n\nFixes out of array access\n\nFound-by: Piotr Bandurski <ami_stuff@o2.pl>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 3539d6c63a16e1b2874bb037a86f317449c58770)\n\nConflicts:\n\n\tlibavcodec/iff.c\n(cherry picked from commit 656f930160db48e0b7b25069c62abc340e7f0628)\n\nConflicts:\n\n\tlibavcodec/iff.c",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "832:         break;",
          "833:     case 4:",
          "834:         bytestream2_init(&gb, buf, buf_size);",
          "836:             decode_rgb8(&gb, s->frame.data[0], avctx->width, avctx->height, s->frame.linesize[0]);",
          "838:             decode_rgbn(&gb, s->frame.data[0], avctx->width, avctx->height, s->frame.linesize[0]);",
          "839:         else",
          "840:             return unsupported(avctx);",
          "",
          "[Removed Lines]",
          "835:         if (avctx->codec_tag == MKTAG('R','G','B','8'))",
          "837:         else if (avctx->codec_tag == MKTAG('R','G','B','N'))",
          "",
          "[Added Lines]",
          "835:         if (avctx->codec_tag == MKTAG('R','G','B','8') && avctx->pix_fmt == AV_PIX_FMT_RGB32)",
          "837:         else if (avctx->codec_tag == MKTAG('R','G','B','N') && avctx->pix_fmt == AV_PIX_FMT_RGB444)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7016aa655b100d4582036b63fd7d6de1cec552fa",
      "candidate_info": {
        "commit_hash": "7016aa655b100d4582036b63fd7d6de1cec552fa",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7016aa655b100d4582036b63fd7d6de1cec552fa",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "iff decoder: support RGB8 and RGBN",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "335:         avctx->pix_fmt = (avctx->bits_per_coded_sample < 8) ||",
          "336:                          (avctx->extradata_size >= 2 && palette_size) ? AV_PIX_FMT_PAL8 : AV_PIX_FMT_GRAY8;",
          "337:     } else if (avctx->bits_per_coded_sample <= 32) {",
          "339:             if (avctx->bits_per_coded_sample == 24) {",
          "340:                 avctx->pix_fmt = AV_PIX_FMT_RGB0;",
          "341:             } else if (avctx->bits_per_coded_sample == 32) {",
          "",
          "[Removed Lines]",
          "338:         if (avctx->codec_tag != MKTAG('D','E','E','P')) {",
          "",
          "[Added Lines]",
          "338:         if (avctx->codec_tag == MKTAG('R','G','B','8')) {",
          "339:             avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "340:         } else if (avctx->codec_tag == MKTAG('R','G','B','N')) {",
          "341:             avctx->pix_fmt = AV_PIX_FMT_RGB444;",
          "342:         } else if (avctx->codec_tag != MKTAG('D','E','E','P')) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "484:     return buf - buf_start;",
          "485: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "491: #define DECODE_RGBX_COMMON(pixel_size) \\",
          "492:     if (!length) { \\",
          "493:         length = bytestream2_get_byte(gb); \\",
          "494:         if (!length) { \\",
          "495:             length = bytestream2_get_be16(gb); \\",
          "496:             if (!length) \\",
          "497:                 return; \\",
          "498:         } \\",
          "499:     } \\",
          "500:     for (i = 0; i < length; i++) { \\",
          "502:         x += 1; \\",
          "503:         if (x >= width) { \\",
          "504:             y += 1; \\",
          "505:             if (y >= height) \\",
          "506:                 return; \\",
          "507:             x = 0; \\",
          "508:         } \\",
          "509:     }",
          "518: static void decode_rgb8(GetByteContext *gb, uint8_t *dst, int width, int height, int linesize)",
          "519: {",
          "520:     int x = 0, y = 0, i, length;",
          "521:     while (bytestream2_get_bytes_left(gb) >= 4) {",
          "522:         uint32_t pixel = 0xFF000000 | bytestream2_get_be24(gb);",
          "523:         length = bytestream2_get_byte(gb) & 0x7F;",
          "524:         DECODE_RGBX_COMMON(4)",
          "525:     }",
          "526: }",
          "535: static void decode_rgbn(GetByteContext *gb, uint8_t *dst, int width, int height, int linesize)",
          "536: {",
          "537:     int x = 0, y = 0, i, length;",
          "538:     while (bytestream2_get_bytes_left(gb) >= 2) {",
          "539:         uint32_t pixel = bytestream2_get_be16u(gb);",
          "540:         length = pixel & 0x7;",
          "541:         pixel >>= 4;",
          "542:         DECODE_RGBX_COMMON(2)",
          "543:     }",
          "544: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "599:     const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;",
          "600:     const uint8_t *buf_end = buf+buf_size;",
          "601:     int y, plane, res;",
          "603:     if ((res = extract_header(avctx, avpkt)) < 0)",
          "604:         return res;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "661:     GetByteContext gb;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "770:                 return unsupported(avctx);",
          "771:         }",
          "772:         break;",
          "773:     case 5:",
          "774:         if (avctx->codec_tag == MKTAG('D','E','E','P')) {",
          "775:             const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "833:     case 4:",
          "834:         bytestream2_init(&gb, buf, buf_size);",
          "835:         if (avctx->codec_tag == MKTAG('R','G','B','8'))",
          "836:             decode_rgb8(&gb, s->frame.data[0], avctx->width, avctx->height, s->frame.linesize[0]);",
          "837:         else if (avctx->codec_tag == MKTAG('R','G','B','N'))",
          "838:             decode_rgbn(&gb, s->frame.data[0], avctx->width, avctx->height, s->frame.linesize[0]);",
          "839:         else",
          "840:             return unsupported(avctx);",
          "841:         break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56090b5b80431bfd791dbe8cfd23c058214118da",
      "candidate_info": {
        "commit_hash": "56090b5b80431bfd791dbe8cfd23c058214118da",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/56090b5b80431bfd791dbe8cfd23c058214118da",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "Merge commit '3865ba7b21aef5d60183719e238361ec8797ab5a'\n\n* commit '3865ba7b21aef5d60183719e238361ec8797ab5a':\n  iff: K&R formatting cosmetics\n\nConflicts:\n\tlibavcodec/iff.c\n\nMerged-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:     count = FFMIN(palette_size / 3, count);",
          "157:     if (count) {",
          "159:             pal[i] = 0xFF000000 | AV_RB24(palette + i*3);",
          "161:         if (s->flags && count >= 32) { // EHB",
          "162:             for (i = 0; i < 32; i++)",
          "163:                 pal[i + 32] = 0xFF000000 | (AV_RB24(palette + i*3) & 0xFEFEFE) >> 1;",
          "",
          "[Removed Lines]",
          "158:         for (i=0; i < count; i++) {",
          "160:         }",
          "",
          "[Added Lines]",
          "158:         for (i = 0; i < count; i++)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "166:     } else { // Create gray-scale color palette for bps < 8",
          "167:         count = 1 << avctx->bits_per_coded_sample;",
          "170:             pal[i] = 0xFF000000 | gray2rgb((i * 255) >> avctx->bits_per_coded_sample);",
          "172:     }",
          "173:     if (s->masking == MASK_HAS_MASK) {",
          "174:         memcpy(pal + (1 << avctx->bits_per_coded_sample), pal, count * 4);",
          "",
          "[Removed Lines]",
          "169:         for (i=0; i < count; i++) {",
          "171:         }",
          "",
          "[Added Lines]",
          "168:         for (i = 0; i < count; i++)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "335:         avctx->pix_fmt = (avctx->bits_per_coded_sample < 8) ||",
          "336:                          (avctx->extradata_size >= 2 && palette_size) ? AV_PIX_FMT_PAL8 : AV_PIX_FMT_GRAY8;",
          "337:     } else if (avctx->bits_per_coded_sample <= 32) {",
          "339:             avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "341:             avctx->pix_fmt = AV_PIX_FMT_RGB444;",
          "343:             if (avctx->bits_per_coded_sample == 24) {",
          "344:                 avctx->pix_fmt = AV_PIX_FMT_0BGR32;",
          "345:             } else if (avctx->bits_per_coded_sample == 32) {",
          "",
          "[Removed Lines]",
          "338:         if (avctx->codec_tag == MKTAG('R','G','B','8')) {",
          "340:         } else if (avctx->codec_tag == MKTAG('R','G','B','N')) {",
          "342:         } else if (avctx->codec_tag != MKTAG('D','E','E','P')) {",
          "",
          "[Added Lines]",
          "336:         if (avctx->codec_tag == MKTAG('R', 'G', 'B', '8')) {",
          "338:         } else if (avctx->codec_tag == MKTAG('R', 'G', 'B', 'N')) {",
          "340:         } else if (avctx->codec_tag != MKTAG('D', 'E', 'E', 'P')) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "356:     if ((err = av_image_check_size(avctx->width, avctx->height, 0, avctx)))",
          "357:         return err;",
          "358:     s->planesize = FFALIGN(avctx->width, 16) >> 3; // Align plane size in bits to word-boundary",
          "360:     if (!s->planebuf)",
          "361:         return AVERROR(ENOMEM);",
          "",
          "[Removed Lines]",
          "359:     s->planebuf = av_malloc(s->planesize + FF_INPUT_BUFFER_PADDING_SIZE);",
          "",
          "[Added Lines]",
          "357:     s->planebuf  = av_malloc(s->planesize + FF_INPUT_BUFFER_PADDING_SIZE);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "408:         dst[1] |= lut[mask++];",
          "409:         dst[2] |= lut[mask++];",
          "410:         dst[3] |= lut[mask];",
          "412:         dst[4] |= lut[mask++];",
          "413:         dst[5] |= lut[mask++];",
          "414:         dst[6] |= lut[mask++];",
          "415:         dst[7] |= lut[mask];",
          "417:     } while (--buf_size);",
          "418: }",
          "",
          "[Removed Lines]",
          "411:         mask = (*buf++ << 2) & 0x3F;",
          "416:         dst += 8;",
          "",
          "[Added Lines]",
          "409:         mask    = (*buf++ << 2) & 0x3F;",
          "414:         dst    += 8;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "470: static int decode_byterun(uint8_t *dst, int dst_size,",
          "472:     const uint8_t *const buf_start = buf;",
          "473:     unsigned x;",
          "474:     for (x = 0; x < dst_size && buf < buf_end;) {",
          "",
          "[Removed Lines]",
          "471:                           const uint8_t *buf, const uint8_t *const buf_end) {",
          "",
          "[Added Lines]",
          "469:                           const uint8_t *buf, const uint8_t *const buf_end)",
          "470: {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "651: }",
          "653: static int decode_frame(AVCodecContext *avctx,",
          "656: {",
          "661:     int y, plane, res;",
          "662:     GetByteContext gb;",
          "",
          "[Removed Lines]",
          "654:                             void *data, int *got_frame,",
          "655:                             AVPacket *avpkt)",
          "657:     IffContext *s = avctx->priv_data;",
          "658:     const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;",
          "659:     const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;",
          "660:     const uint8_t *buf_end = buf+buf_size;",
          "",
          "[Added Lines]",
          "653:                         void *data, int *got_frame,",
          "654:                         AVPacket *avpkt)",
          "656:     IffContext *s          = avctx->priv_data;",
          "657:     const uint8_t *buf     = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;",
          "658:     const int buf_size     = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;",
          "659:     const uint8_t *buf_end = buf + buf_size;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "667:         return res;",
          "668:     if (!s->init && avctx->bits_per_coded_sample <= 8 &&",
          "669:         avctx->pix_fmt == AV_PIX_FMT_PAL8) {",
          "671:             return res;",
          "672:     } else if (!s->init && avctx->bits_per_coded_sample <= 8 &&",
          "673:                avctx->pix_fmt == AV_PIX_FMT_RGB32) {",
          "",
          "[Removed Lines]",
          "670:         if ((res = cmap_read_palette(avctx, (uint32_t*)s->frame->data[1])) < 0)",
          "",
          "[Added Lines]",
          "669:         if ((res = cmap_read_palette(avctx, (uint32_t *)s->frame->data[1])) < 0)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "679:     switch (s->compression) {",
          "680:     case 0:",
          "682:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "683:                 memset(s->frame->data[0], 0, avctx->height * s->frame->linesize[0]);",
          "684:                 for (plane = 0; plane < s->bpp; plane++) {",
          "687:                         decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "688:                         buf += s->planesize;",
          "689:                     }",
          "690:                 }",
          "691:             } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "692:                 memset(s->frame->data[0], 0, avctx->height * s->frame->linesize[0]);",
          "694:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "695:                     memset(s->ham_buf, 0, s->planesize * 8);",
          "696:                     for (plane = 0; plane < s->bpp; plane++) {",
          "",
          "[Removed Lines]",
          "681:         if (avctx->codec_tag == MKTAG('A','C','B','M')) {",
          "685:                     for(y = 0; y < avctx->height && buf < buf_end; y++ ) {",
          "686:                         uint8_t *row = &s->frame->data[0][ y*s->frame->linesize[0] ];",
          "693:                 for(y = 0; y < avctx->height; y++) {",
          "",
          "[Added Lines]",
          "680:         if (avctx->codec_tag == MKTAG('A', 'C', 'B', 'M')) {",
          "684:                     for (y = 0; y < avctx->height && buf < buf_end; y++) {",
          "685:                         uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "692:                 for (y = 0; y < avctx->height; y++) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "699:                             break;",
          "700:                         decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);",
          "701:                     }",
          "703:                 }",
          "704:             } else",
          "705:                 return unsupported(avctx);",
          "707:             const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "708:             int raw_width = avctx->width * (av_get_bits_per_pixel(desc) >> 3);",
          "709:             int x;",
          "711:                 uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "712:                 memcpy(row, buf, FFMIN(raw_width, buf_end - buf));",
          "713:                 buf += raw_width;",
          "714:                 if (avctx->pix_fmt == AV_PIX_FMT_BGR32) {",
          "716:                         row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);",
          "717:                 }",
          "718:             }",
          "720:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "723:                     memset(row, 0, avctx->width);",
          "724:                     for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "725:                         decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "",
          "[Removed Lines]",
          "702:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "706:         } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {",
          "710:             for(y = 0; y < avctx->height && buf < buf_end; y++ ) {",
          "715:                     for(x = 0; x < avctx->width; x++)",
          "719:         } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved",
          "721:                 for(y = 0; y < avctx->height; y++ ) {",
          "722:                     uint8_t *row = &s->frame->data[0][ y*s->frame->linesize[0] ];",
          "",
          "[Added Lines]",
          "701:                     decode_ham_plane32((uint32_t *)row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "705:         } else if (avctx->codec_tag == MKTAG('D', 'E', 'E', 'P')) {",
          "709:             for (y = 0; y < avctx->height && buf < buf_end; y++) {",
          "714:                     for (x = 0; x < avctx->width; x++)",
          "718:         } else if (avctx->codec_tag == MKTAG('I', 'L', 'B', 'M')) { // interleaved",
          "720:                 for (y = 0; y < avctx->height; y++) {",
          "721:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "728:                 }",
          "729:             } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "730:                 for (y = 0; y < avctx->height; y++) {",
          "732:                     memset(s->ham_buf, 0, s->planesize * 8);",
          "733:                     for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "734:                         decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "735:                         buf += s->planesize;",
          "736:                     }",
          "738:                 }",
          "739:             } else { // AV_PIX_FMT_BGR32",
          "742:                     memset(row, 0, avctx->width << 2);",
          "743:                     for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "745:                         buf += s->planesize;",
          "746:                     }",
          "747:                 }",
          "748:             }",
          "750:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "752:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "753:                     memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
          "754:                     buf += avctx->width + (avctx->width % 2); // padding if odd",
          "755:                 }",
          "756:             } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
          "757:                 for (y = 0; y < avctx->height && buf_end > buf; y++) {",
          "759:                     memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
          "760:                     buf += avctx->width + (avctx->width & 1); // padding if odd",
          "762:                 }",
          "763:             } else",
          "764:                 return unsupported(avctx);",
          "765:         }",
          "766:         break;",
          "767:     case 1:",
          "769:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "772:                     memset(row, 0, avctx->width);",
          "773:                     for (plane = 0; plane < s->bpp; plane++) {",
          "774:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "",
          "[Removed Lines]",
          "731:                     uint8_t *row = &s->frame->data[0][ y*s->frame->linesize[0] ];",
          "737:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "740:                 for(y = 0; y < avctx->height; y++ ) {",
          "741:                     uint8_t *row = &s->frame->data[0][y*s->frame->linesize[0]];",
          "744:                         decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "749:         } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "751:                 for(y = 0; y < avctx->height && buf_end > buf; y++ ) {",
          "758:                     uint8_t *row = &s->frame->data[0][ y*s->frame->linesize[0] ];",
          "761:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "768:         if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved",
          "770:                 for(y = 0; y < avctx->height ; y++ ) {",
          "771:                     uint8_t *row = &s->frame->data[0][ y*s->frame->linesize[0] ];",
          "",
          "[Added Lines]",
          "730:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "736:                     decode_ham_plane32((uint32_t *)row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "739:                 for (y = 0; y < avctx->height; y++) {",
          "740:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "743:                         decodeplane32((uint32_t *)row, buf,",
          "744:                                       FFMIN(s->planesize, buf_end - buf), plane);",
          "749:         } else if (avctx->codec_tag == MKTAG('P', 'B', 'M', ' ')) { // IFF-PBM",
          "751:                 for (y = 0; y < avctx->height && buf_end > buf; y++) {",
          "758:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "761:                     decode_ham_plane32((uint32_t *)row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "768:         if (avctx->codec_tag == MKTAG('I', 'L', 'B', 'M')) { // interleaved",
          "770:                 for (y = 0; y < avctx->height; y++) {",
          "771:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "776:                     }",
          "777:                 }",
          "778:             } else if (avctx->bits_per_coded_sample <= 8) { //8-bit (+ mask) to AV_PIX_FMT_BGR32",
          "781:                     memset(s->mask_buf, 0, avctx->width * sizeof(uint32_t));",
          "782:                     for (plane = 0; plane < s->bpp; plane++) {",
          "783:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "784:                         decodeplane32(s->mask_buf, s->planebuf, s->planesize, plane);",
          "785:                     }",
          "787:                 }",
          "788:             } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "791:                     memset(s->ham_buf, 0, s->planesize * 8);",
          "792:                     for (plane = 0; plane < s->bpp; plane++) {",
          "793:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "794:                         decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);",
          "795:                     }",
          "797:                 }",
          "801:                     memset(row, 0, avctx->width << 2);",
          "802:                     for (plane = 0; plane < s->bpp; plane++) {",
          "803:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "805:                     }",
          "806:                 }",
          "807:             }",
          "809:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "812:                     buf += decode_byterun(row, avctx->width, buf, buf_end);",
          "813:                 }",
          "814:             } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
          "817:                     buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);",
          "819:                 }",
          "820:             } else",
          "821:                 return unsupported(avctx);",
          "823:             const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "824:             if (av_get_bits_per_pixel(desc) == 32)",
          "825:                 decode_deep_rle32(s->frame->data[0], buf, buf_size, avctx->width, avctx->height, s->frame->linesize[0]);",
          "",
          "[Removed Lines]",
          "779:                 for (y = 0; y < avctx->height ; y++ ) {",
          "780:                     uint8_t *row = &s->frame->data[0][y*s->frame->linesize[0]];",
          "786:                     lookup_pal_indicies((uint32_t *) row, s->mask_buf, s->mask_palbuf, avctx->width);",
          "789:                 for (y = 0; y < avctx->height ; y++) {",
          "790:                     uint8_t *row = &s->frame->data[0][y*s->frame->linesize[0]];",
          "796:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "798:             } else { //AV_PIX_FMT_BGR32",
          "799:                 for(y = 0; y < avctx->height ; y++ ) {",
          "800:                     uint8_t *row = &s->frame->data[0][y*s->frame->linesize[0]];",
          "804:                         decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);",
          "808:         } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "810:                 for(y = 0; y < avctx->height ; y++ ) {",
          "811:                     uint8_t *row = &s->frame->data[0][y*s->frame->linesize[0]];",
          "815:                 for (y = 0; y < avctx->height ; y++) {",
          "816:                     uint8_t *row = &s->frame->data[0][y*s->frame->linesize[0]];",
          "818:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "822:         } else if (avctx->codec_tag == MKTAG('D','E','E','P')) { // IFF-DEEP",
          "",
          "[Added Lines]",
          "779:                 for (y = 0; y < avctx->height; y++) {",
          "780:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "786:                     lookup_pal_indicies((uint32_t *)row, s->mask_buf, s->mask_palbuf, avctx->width);",
          "789:                 for (y = 0; y < avctx->height; y++) {",
          "790:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "796:                     decode_ham_plane32((uint32_t *)row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "798:             } else { // AV_PIX_FMT_BGR32",
          "799:                 for (y = 0; y < avctx->height; y++) {",
          "800:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "804:                         decodeplane32((uint32_t *)row, s->planebuf, s->planesize, plane);",
          "808:         } else if (avctx->codec_tag == MKTAG('P', 'B', 'M', ' ')) { // IFF-PBM",
          "810:                 for (y = 0; y < avctx->height; y++) {",
          "811:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "815:                 for (y = 0; y < avctx->height; y++) {",
          "816:                     uint8_t *row = &s->frame->data[0][y * s->frame->linesize[0]];",
          "818:                     decode_ham_plane32((uint32_t *)row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "822:         } else if (avctx->codec_tag == MKTAG('D', 'E', 'E', 'P')) { // IFF-DEEP",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "829:         break;",
          "830:     case 4:",
          "831:         bytestream2_init(&gb, buf, buf_size);",
          "833:             decode_rgb8(&gb, s->frame->data[0], avctx->width, avctx->height, s->frame->linesize[0]);",
          "835:             decode_rgbn(&gb, s->frame->data[0], avctx->width, avctx->height, s->frame->linesize[0]);",
          "836:         else",
          "837:             return unsupported(avctx);",
          "838:         break;",
          "839:     case 5:",
          "841:             const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "842:             if (av_get_bits_per_pixel(desc) == 32)",
          "843:                 decode_deep_tvdc32(s->frame->data[0], buf, buf_size, avctx->width, avctx->height, s->frame->linesize[0], s->tvdc);",
          "",
          "[Removed Lines]",
          "832:         if (avctx->codec_tag == MKTAG('R','G','B','8'))",
          "834:         else if (avctx->codec_tag == MKTAG('R','G','B','N'))",
          "840:         if (avctx->codec_tag == MKTAG('D','E','E','P')) {",
          "",
          "[Added Lines]",
          "832:         if (avctx->codec_tag == MKTAG('R', 'G', 'B', '8'))",
          "834:         else if (avctx->codec_tag == MKTAG('R', 'G', 'B', 'N'))",
          "840:         if (avctx->codec_tag == MKTAG('D', 'E', 'E', 'P')) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
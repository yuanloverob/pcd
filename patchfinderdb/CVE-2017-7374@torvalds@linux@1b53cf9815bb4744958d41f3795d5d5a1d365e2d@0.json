{
  "cve_id": "CVE-2017-7374",
  "cve_desc": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely.",
  "repo": "torvalds/linux",
  "patch_hash": "1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
  "patch_info": {
    "commit_hash": "1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
    "files": [
      "fs/crypto/crypto.c",
      "fs/crypto/fname.c",
      "fs/crypto/fscrypt_private.h",
      "fs/crypto/keyinfo.c"
    ],
    "message": "fscrypt: remove broken support for detecting keyring key revocation\n\nFilesystem encryption ostensibly supported revoking a keyring key that\nhad been used to \"unlock\" encrypted files, causing those files to become\n\"locked\" again.  This was, however, buggy for several reasons, the most\nsevere of which was that when key revocation happened to be detected for\nan inode, its fscrypt_info was immediately freed, even while other\nthreads could be using it for encryption or decryption concurrently.\nThis could be exploited to crash the kernel or worse.\n\nThis patch fixes the use-after-free by removing the code which detects\nthe keyring key having been revoked, invalidated, or expired.  Instead,\nan encrypted inode that is \"unlocked\" now simply remains unlocked until\nit is evicted from memory.  Note that this is no worse than the case for\nblock device-level encryption, e.g. dm-crypt, and it still remains\npossible for a privileged user to evict unused pages, inodes, and\ndentries by running 'sync; echo 3 > /proc/sys/vm/drop_caches', or by\nsimply unmounting the filesystem.  In fact, one of those actions was\nalready needed anyway for key revocation to work even somewhat sanely.\nThis change is not expected to break any applications.\n\nIn the future I'd like to implement a real API for fscrypt key\nrevocation that interacts sanely with ongoing filesystem operations ---\nwaiting for existing operations to complete and blocking new operations,\nand invalidating and sanitizing key material and plaintext from the VFS\ncaches.  But this is a hard problem, and for now this bug must be fixed.\n\nThis bug affected almost all versions of ext4, f2fs, and ubifs\nencryption, and it was potentially reachable in any kernel configured\nwith encryption support (CONFIG_EXT4_ENCRYPTION=y,\nCONFIG_EXT4_FS_ENCRYPTION=y, CONFIG_F2FS_FS_ENCRYPTION=y, or\nCONFIG_UBIFS_FS_ENCRYPTION=y).  Note that older kernels did not use the\nshared fs/crypto/ code, but due to the potential security implications\nof this bug, it may still be worthwhile to backport this fix to them.\n\nFixes: b7236e21d55f (\"ext4 crypto: reorganize how we store keys in the inode\")\nCc: stable@vger.kernel.org # v4.2+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nAcked-by: Michael Halcrow <mhalcrow@google.com>",
    "before_after_code_files": [
      "fs/crypto/crypto.c||fs/crypto/crypto.c",
      "fs/crypto/fname.c||fs/crypto/fname.c",
      "fs/crypto/fscrypt_private.h||fs/crypto/fscrypt_private.h",
      "fs/crypto/keyinfo.c||fs/crypto/keyinfo.c"
    ]
  },
  "patch_diff": {
    "fs/crypto/crypto.c||fs/crypto/crypto.c": [
      "File: fs/crypto/crypto.c -> fs/crypto/crypto.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "327: static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)",
      "328: {",
      "329:  struct dentry *dir;",
      "331:  int dir_has_key, cached_with_key;",
      "333:  if (flags & LOOKUP_RCU)",
      "",
      "[Removed Lines]",
      "330:  struct fscrypt_info *ci;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "339:   return 0;",
      "340:  }",
      "350:  spin_lock(&dentry->d_lock);",
      "351:  cached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;",
      "352:  spin_unlock(&dentry->d_lock);",
      "354:  dput(dir);",
      "",
      "[Removed Lines]",
      "342:  ci = d_inode(dir)->i_crypt_info;",
      "343:  if (ci && ci->ci_keyring_key &&",
      "344:      (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
      "345:        (1 << KEY_FLAG_REVOKED) |",
      "346:        (1 << KEY_FLAG_DEAD))))",
      "347:   ci = NULL;",
      "353:  dir_has_key = (ci != NULL);",
      "",
      "[Added Lines]",
      "345:  dir_has_key = (d_inode(dir)->i_crypt_info != NULL);",
      "",
      "---------------"
    ],
    "fs/crypto/fname.c||fs/crypto/fname.c": [
      "File: fs/crypto/fname.c -> fs/crypto/fname.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "350:   fname->disk_name.len = iname->len;",
      "351:   return 0;",
      "352:  }",
      "354:  if (ret && ret != -EOPNOTSUPP)",
      "355:   return ret;",
      "",
      "[Removed Lines]",
      "353:  ret = fscrypt_get_crypt_info(dir);",
      "",
      "[Added Lines]",
      "353:  ret = fscrypt_get_encryption_info(dir);",
      "",
      "---------------"
    ],
    "fs/crypto/fscrypt_private.h||fs/crypto/fscrypt_private.h": [
      "File: fs/crypto/fscrypt_private.h -> fs/crypto/fscrypt_private.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "67:  u8 ci_filename_mode;",
      "68:  u8 ci_flags;",
      "69:  struct crypto_skcipher *ci_ctfm;",
      "71:  u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];",
      "72: };",
      "",
      "[Removed Lines]",
      "70:  struct key *ci_keyring_key;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "101: extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,",
      "102:            gfp_t gfp_flags);",
      "",
      "[Removed Lines]",
      "105: extern int fscrypt_get_crypt_info(struct inode *);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/crypto/keyinfo.c||fs/crypto/keyinfo.c": [
      "File: fs/crypto/keyinfo.c -> fs/crypto/keyinfo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "95:  kfree(description);",
      "96:  if (IS_ERR(keyring_key))",
      "97:   return PTR_ERR(keyring_key);",
      "99:  if (keyring_key->type != &key_type_logon) {",
      "100:   printk_once(KERN_WARNING",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "98:  down_read(&keyring_key->sem);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "102:   res = -ENOKEY;",
      "103:   goto out;",
      "104:  }",
      "106:  ukp = user_key_payload(keyring_key);",
      "107:  if (ukp->datalen != sizeof(struct fscrypt_key)) {",
      "108:   res = -EINVAL;",
      "110:   goto out;",
      "111:  }",
      "112:  master_key = (struct fscrypt_key *)ukp->data;",
      "",
      "[Removed Lines]",
      "105:  down_read(&keyring_key->sem);",
      "109:   up_read(&keyring_key->sem);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "117:     \"%s: key size incorrect: %d\\n\",",
      "118:     __func__, master_key->size);",
      "119:   res = -ENOKEY;",
      "121:   goto out;",
      "122:  }",
      "123:  res = derive_key_aes(ctx->nonce, master_key->raw, raw_key);",
      "130: out:",
      "131:  key_put(keyring_key);",
      "132:  return res;",
      "133: }",
      "",
      "[Removed Lines]",
      "120:   up_read(&keyring_key->sem);",
      "124:  up_read(&keyring_key->sem);",
      "125:  if (res)",
      "126:   goto out;",
      "128:  crypt_info->ci_keyring_key = keyring_key;",
      "129:  return 0;",
      "",
      "[Added Lines]",
      "123:  up_read(&keyring_key->sem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "169:  if (!ci)",
      "170:   return;",
      "173:  crypto_free_skcipher(ci->ci_ctfm);",
      "174:  kmem_cache_free(fscrypt_info_cachep, ci);",
      "175: }",
      "178: {",
      "179:  struct fscrypt_info *crypt_info;",
      "180:  struct fscrypt_context ctx;",
      "",
      "[Removed Lines]",
      "172:  key_put(ci->ci_keyring_key);",
      "177: int fscrypt_get_crypt_info(struct inode *inode)",
      "",
      "[Added Lines]",
      "169: int fscrypt_get_encryption_info(struct inode *inode)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "184:  u8 *raw_key = NULL;",
      "185:  int res;",
      "187:  res = fscrypt_initialize(inode->i_sb->s_cop->flags);",
      "188:  if (res)",
      "189:   return res;",
      "191:  if (!inode->i_sb->s_cop->get_context)",
      "192:   return -EOPNOTSUPP;",
      "203:  res = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));",
      "204:  if (res < 0) {",
      "",
      "[Removed Lines]",
      "193: retry:",
      "194:  crypt_info = ACCESS_ONCE(inode->i_crypt_info);",
      "195:  if (crypt_info) {",
      "196:   if (!crypt_info->ci_keyring_key ||",
      "197:     key_validate(crypt_info->ci_keyring_key) == 0)",
      "198:    return 0;",
      "199:   fscrypt_put_encryption_info(inode, crypt_info);",
      "200:   goto retry;",
      "201:  }",
      "",
      "[Added Lines]",
      "179:  if (inode->i_crypt_info)",
      "180:   return 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "229:  crypt_info->ci_data_mode = ctx.contents_encryption_mode;",
      "230:  crypt_info->ci_filename_mode = ctx.filenames_encryption_mode;",
      "231:  crypt_info->ci_ctfm = NULL;",
      "233:  memcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,",
      "234:     sizeof(crypt_info->ci_master_key));",
      "",
      "[Removed Lines]",
      "232:  crypt_info->ci_keyring_key = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "273:  if (res)",
      "274:   goto out;",
      "284: out:",
      "285:  if (res == -ENOKEY)",
      "286:   res = 0;",
      "",
      "[Removed Lines]",
      "276:  kzfree(raw_key);",
      "277:  raw_key = NULL;",
      "278:  if (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {",
      "279:   put_crypt_info(crypt_info);",
      "280:   goto retry;",
      "281:  }",
      "282:  return 0;",
      "",
      "[Added Lines]",
      "261:  if (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) == NULL)",
      "262:   crypt_info = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "288:  kzfree(raw_key);",
      "289:  return res;",
      "290: }",
      "292: void fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)",
      "293: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "270: EXPORT_SYMBOL(fscrypt_get_encryption_info);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "305:  put_crypt_info(ci);",
      "306: }",
      "307: EXPORT_SYMBOL(fscrypt_put_encryption_info);",
      "",
      "[Removed Lines]",
      "309: int fscrypt_get_encryption_info(struct inode *inode)",
      "310: {",
      "311:  struct fscrypt_info *ci = inode->i_crypt_info;",
      "313:  if (!ci ||",
      "314:   (ci->ci_keyring_key &&",
      "315:    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
      "316:             (1 << KEY_FLAG_REVOKED) |",
      "317:             (1 << KEY_FLAG_DEAD)))))",
      "318:   return fscrypt_get_crypt_info(inode);",
      "319:  return 0;",
      "320: }",
      "321: EXPORT_SYMBOL(fscrypt_get_encryption_info);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d7d75352890447b55c13a81df316a6894ff32ecf",
      "candidate_info": {
        "commit_hash": "d7d75352890447b55c13a81df316a6894ff32ecf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d7d75352890447b55c13a81df316a6894ff32ecf",
        "files": [
          "fs/crypto/crypto.c"
        ],
        "message": "fscrypto: use dget_parent() in fscrypt_d_revalidate()\n\nThis patch updates fscrypto along with the below ext4 crypto change.\n\nFixes: 3d43bcfef5f0 (\"ext4 crypto: use dget_parent() in ext4_d_revalidate()\")\nCc: Theodore Ts'o <tytso@mit.edu>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/crypto/crypto.c||fs/crypto/crypto.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/crypto/crypto.c||fs/crypto/crypto.c"
          ],
          "candidate": [
            "fs/crypto/crypto.c||fs/crypto/crypto.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/crypto/crypto.c||fs/crypto/crypto.c": [
          "File: fs/crypto/crypto.c -> fs/crypto/crypto.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "346: static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)",
          "347: {",
          "350:  int dir_has_key, cached_with_key;",
          "353:   return 0;",
          "355:  if (ci && ci->ci_keyring_key &&",
          "356:      (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
          "357:        (1 << KEY_FLAG_REVOKED) |",
          "",
          "[Removed Lines]",
          "348:  struct inode *dir = d_inode(dentry->d_parent);",
          "349:  struct fscrypt_info *ci = dir->i_crypt_info;",
          "352:  if (!dir->i_sb->s_cop->is_encrypted(dir))",
          "",
          "[Added Lines]",
          "348:  struct dentry *dir;",
          "349:  struct fscrypt_info *ci;",
          "352:  dir = dget_parent(dentry);",
          "353:  if (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {",
          "354:   dput(dir);",
          "356:  }",
          "358:  ci = d_inode(dir)->i_crypt_info;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "363:  cached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;",
          "364:  spin_unlock(&dentry->d_lock);",
          "365:  dir_has_key = (ci != NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "370:  dput(dir);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b81d0779072696371822e5ed9e7c6292e547024",
      "candidate_info": {
        "commit_hash": "0b81d0779072696371822e5ed9e7c6292e547024",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0b81d0779072696371822e5ed9e7c6292e547024",
        "files": [
          "fs/Kconfig",
          "fs/Makefile",
          "fs/crypto/Kconfig",
          "fs/crypto/Makefile",
          "fs/crypto/crypto.c",
          "fs/crypto/fname.c",
          "fs/crypto/keyinfo.c",
          "fs/crypto/policy.c",
          "fs/f2fs/Kconfig",
          "fs/f2fs/Makefile",
          "fs/f2fs/crypto.c",
          "fs/f2fs/crypto_fname.c",
          "fs/f2fs/crypto_key.c",
          "fs/f2fs/crypto_policy.c",
          "fs/f2fs/data.c",
          "fs/f2fs/dir.c",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/f2fs_crypto.h",
          "fs/f2fs/file.c",
          "fs/f2fs/inline.c",
          "fs/f2fs/inode.c",
          "fs/f2fs/namei.c",
          "fs/f2fs/super.c",
          "include/linux/dcache.h",
          "include/linux/fs.h",
          "include/linux/fscrypto.h",
          "include/uapi/linux/fs.h"
        ],
        "message": "fs crypto: move per-file encryption from f2fs tree to fs/crypto\n\nThis patch adds the renamed functions moved from the f2fs crypto files.\n\n1. definitions for per-file encryption used by ext4 and f2fs.\n\n2. crypto.c for encrypt/decrypt functions\n a. IO preparation:\n  - fscrypt_get_ctx / fscrypt_release_ctx\n b. before IOs:\n  - fscrypt_encrypt_page\n  - fscrypt_decrypt_page\n  - fscrypt_zeroout_range\n c. after IOs:\n  - fscrypt_decrypt_bio_pages\n  - fscrypt_pullback_bio_page\n  - fscrypt_restore_control_page\n\n3. policy.c supporting context management.\n a. For ioctls:\n  - fscrypt_process_policy\n  - fscrypt_get_policy\n b. For context permission\n  - fscrypt_has_permitted_context\n  - fscrypt_inherit_context\n\n4. keyinfo.c to handle permissions\n  - fscrypt_get_encryption_info\n  - fscrypt_free_encryption_info\n\n5. fname.c to support filename encryption\n a. general wrapper functions\n  - fscrypt_fname_disk_to_usr\n  - fscrypt_fname_usr_to_disk\n  - fscrypt_setup_filename\n  - fscrypt_free_filename\n\n b. specific filename handling functions\n  - fscrypt_fname_alloc_buffer\n  - fscrypt_fname_free_buffer\n\n6. Makefile and Kconfig\n\nCc: Al Viro <viro@ftp.linux.org.uk>\nSigned-off-by: Michael Halcrow <mhalcrow@google.com>\nSigned-off-by: Ildar Muslukhov <ildarm@google.com>\nSigned-off-by: Uday Savagaonkar <savagaon@google.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nSigned-off-by: Arnd Bergmann <arnd@arndb.de>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/crypto/crypto.c||fs/crypto/crypto.c",
          "fs/f2fs/crypto_fname.c||fs/crypto/fname.c",
          "fs/f2fs/crypto_key.c||fs/crypto/keyinfo.c",
          "fs/crypto/policy.c||fs/crypto/policy.c",
          "fs/f2fs/crypto.c||fs/f2fs/crypto.c",
          "fs/f2fs/crypto_policy.c||fs/f2fs/crypto_policy.c",
          "fs/f2fs/data.c||fs/f2fs/data.c",
          "fs/f2fs/dir.c||fs/f2fs/dir.c",
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/f2fs_crypto.h||fs/f2fs/f2fs_crypto.h",
          "fs/f2fs/file.c||fs/f2fs/file.c",
          "fs/f2fs/inline.c||fs/f2fs/inline.c",
          "fs/f2fs/inode.c||fs/f2fs/inode.c",
          "fs/f2fs/namei.c||fs/f2fs/namei.c",
          "fs/f2fs/super.c||fs/f2fs/super.c",
          "include/linux/dcache.h||include/linux/dcache.h",
          "include/linux/fs.h||include/linux/fs.h",
          "include/linux/fscrypto.h||include/linux/fscrypto.h",
          "include/uapi/linux/fs.h||include/uapi/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/crypto/crypto.c||fs/crypto/crypto.c"
          ],
          "candidate": [
            "fs/crypto/crypto.c||fs/crypto/crypto.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/crypto/crypto.c||fs/crypto/crypto.c": [
          "File: fs/crypto/crypto.c -> fs/crypto/crypto.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include <linux/crypto.h>",
          "23: #include <linux/ecryptfs.h>",
          "24: #include <linux/pagemap.h>",
          "25: #include <linux/mempool.h>",
          "26: #include <linux/module.h>",
          "27: #include <linux/scatterlist.h>",
          "28: #include <linux/ratelimit.h>",
          "29: #include <linux/bio.h>",
          "30: #include <linux/dcache.h>",
          "31: #include <linux/fscrypto.h>",
          "33: static unsigned int num_prealloc_crypto_pages = 32;",
          "34: static unsigned int num_prealloc_crypto_ctxs = 128;",
          "36: module_param(num_prealloc_crypto_pages, uint, 0444);",
          "37: MODULE_PARM_DESC(num_prealloc_crypto_pages,",
          "38:   \"Number of crypto pages to preallocate\");",
          "39: module_param(num_prealloc_crypto_ctxs, uint, 0444);",
          "40: MODULE_PARM_DESC(num_prealloc_crypto_ctxs,",
          "41:   \"Number of crypto contexts to preallocate\");",
          "43: static mempool_t *fscrypt_bounce_page_pool = NULL;",
          "45: static LIST_HEAD(fscrypt_free_ctxs);",
          "46: static DEFINE_SPINLOCK(fscrypt_ctx_lock);",
          "48: static struct workqueue_struct *fscrypt_read_workqueue;",
          "49: static DEFINE_MUTEX(fscrypt_init_mutex);",
          "51: static struct kmem_cache *fscrypt_ctx_cachep;",
          "52: struct kmem_cache *fscrypt_info_cachep;",
          "63: void fscrypt_release_ctx(struct fscrypt_ctx *ctx)",
          "64: {",
          "65:  unsigned long flags;",
          "67:  if (ctx->flags & FS_WRITE_PATH_FL && ctx->w.bounce_page) {",
          "68:   mempool_free(ctx->w.bounce_page, fscrypt_bounce_page_pool);",
          "69:   ctx->w.bounce_page = NULL;",
          "70:  }",
          "71:  ctx->w.control_page = NULL;",
          "72:  if (ctx->flags & FS_CTX_REQUIRES_FREE_ENCRYPT_FL) {",
          "73:   kmem_cache_free(fscrypt_ctx_cachep, ctx);",
          "74:  } else {",
          "75:   spin_lock_irqsave(&fscrypt_ctx_lock, flags);",
          "76:   list_add(&ctx->free_list, &fscrypt_free_ctxs);",
          "77:   spin_unlock_irqrestore(&fscrypt_ctx_lock, flags);",
          "78:  }",
          "79: }",
          "80: EXPORT_SYMBOL(fscrypt_release_ctx);",
          "91: struct fscrypt_ctx *fscrypt_get_ctx(struct inode *inode)",
          "92: {",
          "93:  struct fscrypt_ctx *ctx = NULL;",
          "94:  struct fscrypt_info *ci = inode->i_crypt_info;",
          "95:  unsigned long flags;",
          "97:  if (ci == NULL)",
          "98:   return ERR_PTR(-ENOKEY);",
          "110:  spin_lock_irqsave(&fscrypt_ctx_lock, flags);",
          "111:  ctx = list_first_entry_or_null(&fscrypt_free_ctxs,",
          "112:      struct fscrypt_ctx, free_list);",
          "113:  if (ctx)",
          "114:   list_del(&ctx->free_list);",
          "115:  spin_unlock_irqrestore(&fscrypt_ctx_lock, flags);",
          "116:  if (!ctx) {",
          "117:   ctx = kmem_cache_zalloc(fscrypt_ctx_cachep, GFP_NOFS);",
          "118:   if (!ctx)",
          "119:    return ERR_PTR(-ENOMEM);",
          "120:   ctx->flags |= FS_CTX_REQUIRES_FREE_ENCRYPT_FL;",
          "121:  } else {",
          "122:   ctx->flags &= ~FS_CTX_REQUIRES_FREE_ENCRYPT_FL;",
          "123:  }",
          "124:  ctx->flags &= ~FS_WRITE_PATH_FL;",
          "125:  return ctx;",
          "126: }",
          "127: EXPORT_SYMBOL(fscrypt_get_ctx);",
          "134: static void fscrypt_complete(struct crypto_async_request *req, int res)",
          "135: {",
          "136:  struct fscrypt_completion_result *ecr = req->data;",
          "138:  if (res == -EINPROGRESS)",
          "139:   return;",
          "140:  ecr->res = res;",
          "141:  complete(&ecr->completion);",
          "142: }",
          "144: typedef enum {",
          "145:  FS_DECRYPT = 0,",
          "146:  FS_ENCRYPT,",
          "147: } fscrypt_direction_t;",
          "149: static int do_page_crypto(struct inode *inode,",
          "150:    fscrypt_direction_t rw, pgoff_t index,",
          "151:    struct page *src_page, struct page *dest_page)",
          "152: {",
          "153:  u8 xts_tweak[FS_XTS_TWEAK_SIZE];",
          "154:  struct ablkcipher_request *req = NULL;",
          "155:  DECLARE_FS_COMPLETION_RESULT(ecr);",
          "156:  struct scatterlist dst, src;",
          "157:  struct fscrypt_info *ci = inode->i_crypt_info;",
          "158:  struct crypto_ablkcipher *tfm = ci->ci_ctfm;",
          "159:  int res = 0;",
          "161:  req = ablkcipher_request_alloc(tfm, GFP_NOFS);",
          "162:  if (!req) {",
          "163:   printk_ratelimited(KERN_ERR",
          "164:     \"%s: crypto_request_alloc() failed\\n\",",
          "165:     __func__);",
          "166:   return -ENOMEM;",
          "167:  }",
          "169:  ablkcipher_request_set_callback(",
          "170:   req, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,",
          "171:   fscrypt_complete, &ecr);",
          "173:  BUILD_BUG_ON(FS_XTS_TWEAK_SIZE < sizeof(index));",
          "174:  memcpy(xts_tweak, &inode->i_ino, sizeof(index));",
          "175:  memset(&xts_tweak[sizeof(index)], 0,",
          "176:    FS_XTS_TWEAK_SIZE - sizeof(index));",
          "178:  sg_init_table(&dst, 1);",
          "179:  sg_set_page(&dst, dest_page, PAGE_CACHE_SIZE, 0);",
          "180:  sg_init_table(&src, 1);",
          "181:  sg_set_page(&src, src_page, PAGE_CACHE_SIZE, 0);",
          "182:  ablkcipher_request_set_crypt(req, &src, &dst, PAGE_CACHE_SIZE,",
          "183:      xts_tweak);",
          "184:  if (rw == FS_DECRYPT)",
          "185:   res = crypto_ablkcipher_decrypt(req);",
          "186:  else",
          "187:   res = crypto_ablkcipher_encrypt(req);",
          "188:  if (res == -EINPROGRESS || res == -EBUSY) {",
          "189:   BUG_ON(req->base.data != &ecr);",
          "190:   wait_for_completion(&ecr.completion);",
          "191:   res = ecr.res;",
          "192:  }",
          "193:  ablkcipher_request_free(req);",
          "194:  if (res) {",
          "195:   printk_ratelimited(KERN_ERR",
          "196:    \"%s: crypto_ablkcipher_encrypt() returned %d\\n\",",
          "197:    __func__, res);",
          "198:   return res;",
          "199:  }",
          "200:  return 0;",
          "201: }",
          "203: static struct page *alloc_bounce_page(struct fscrypt_ctx *ctx)",
          "204: {",
          "205:  ctx->w.bounce_page = mempool_alloc(fscrypt_bounce_page_pool,",
          "206:        GFP_NOWAIT);",
          "207:  if (ctx->w.bounce_page == NULL)",
          "208:   return ERR_PTR(-ENOMEM);",
          "209:  ctx->flags |= FS_WRITE_PATH_FL;",
          "210:  return ctx->w.bounce_page;",
          "211: }",
          "228: struct page *fscrypt_encrypt_page(struct inode *inode,",
          "229:     struct page *plaintext_page)",
          "230: {",
          "231:  struct fscrypt_ctx *ctx;",
          "232:  struct page *ciphertext_page = NULL;",
          "233:  int err;",
          "235:  BUG_ON(!PageLocked(plaintext_page));",
          "237:  ctx = fscrypt_get_ctx(inode);",
          "238:  if (IS_ERR(ctx))",
          "239:   return (struct page *)ctx;",
          "242:  ciphertext_page = alloc_bounce_page(ctx);",
          "243:  if (IS_ERR(ciphertext_page))",
          "244:   goto errout;",
          "246:  ctx->w.control_page = plaintext_page;",
          "247:  err = do_page_crypto(inode, FS_ENCRYPT, plaintext_page->index,",
          "248:      plaintext_page, ciphertext_page);",
          "249:  if (err) {",
          "250:   ciphertext_page = ERR_PTR(err);",
          "251:   goto errout;",
          "252:  }",
          "253:  SetPagePrivate(ciphertext_page);",
          "254:  set_page_private(ciphertext_page, (unsigned long)ctx);",
          "255:  lock_page(ciphertext_page);",
          "256:  return ciphertext_page;",
          "258: errout:",
          "259:  fscrypt_release_ctx(ctx);",
          "260:  return ciphertext_page;",
          "261: }",
          "262: EXPORT_SYMBOL(fscrypt_encrypt_page);",
          "274: int fscrypt_decrypt_page(struct page *page)",
          "275: {",
          "276:  BUG_ON(!PageLocked(page));",
          "278:  return do_page_crypto(page->mapping->host,",
          "279:    FS_DECRYPT, page->index, page, page);",
          "280: }",
          "281: EXPORT_SYMBOL(fscrypt_decrypt_page);",
          "283: int fscrypt_zeroout_range(struct inode *inode, pgoff_t lblk,",
          "284:     sector_t pblk, unsigned int len)",
          "285: {",
          "286:  struct fscrypt_ctx *ctx;",
          "287:  struct page *ciphertext_page = NULL;",
          "288:  struct bio *bio;",
          "289:  int ret, err = 0;",
          "291:  BUG_ON(inode->i_sb->s_blocksize != PAGE_CACHE_SIZE);",
          "293:  ctx = fscrypt_get_ctx(inode);",
          "294:  if (IS_ERR(ctx))",
          "295:   return PTR_ERR(ctx);",
          "297:  ciphertext_page = alloc_bounce_page(ctx);",
          "298:  if (IS_ERR(ciphertext_page)) {",
          "299:   err = PTR_ERR(ciphertext_page);",
          "300:   goto errout;",
          "301:  }",
          "303:  while (len--) {",
          "304:   err = do_page_crypto(inode, FS_ENCRYPT, lblk,",
          "305:       ZERO_PAGE(0), ciphertext_page);",
          "306:   if (err)",
          "307:    goto errout;",
          "309:   bio = bio_alloc(GFP_KERNEL, 1);",
          "310:   if (!bio) {",
          "311:    err = -ENOMEM;",
          "312:    goto errout;",
          "313:   }",
          "314:   bio->bi_bdev = inode->i_sb->s_bdev;",
          "315:   bio->bi_iter.bi_sector =",
          "316:    pblk << (inode->i_sb->s_blocksize_bits - 9);",
          "317:   ret = bio_add_page(bio, ciphertext_page,",
          "318:      inode->i_sb->s_blocksize, 0);",
          "319:   if (ret != inode->i_sb->s_blocksize) {",
          "321:    WARN_ON(1);",
          "322:    bio_put(bio);",
          "323:    err = -EIO;",
          "324:    goto errout;",
          "325:   }",
          "326:   err = submit_bio_wait(WRITE, bio);",
          "327:   if ((err == 0) && bio->bi_error)",
          "328:    err = -EIO;",
          "329:   bio_put(bio);",
          "330:   if (err)",
          "331:    goto errout;",
          "332:   lblk++;",
          "333:   pblk++;",
          "334:  }",
          "335:  err = 0;",
          "336: errout:",
          "337:  fscrypt_release_ctx(ctx);",
          "338:  return err;",
          "339: }",
          "340: EXPORT_SYMBOL(fscrypt_zeroout_range);",
          "347: static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)",
          "348: {",
          "349:  struct inode *dir = d_inode(dentry->d_parent);",
          "350:  struct fscrypt_info *ci = dir->i_crypt_info;",
          "351:  int dir_has_key, cached_with_key;",
          "353:  if (!dir->i_sb->s_cop->is_encrypted(dir))",
          "354:   return 0;",
          "356:  if (ci && ci->ci_keyring_key &&",
          "357:      (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
          "358:        (1 << KEY_FLAG_REVOKED) |",
          "359:        (1 << KEY_FLAG_DEAD))))",
          "360:   ci = NULL;",
          "363:  spin_lock(&dentry->d_lock);",
          "364:  cached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;",
          "365:  spin_unlock(&dentry->d_lock);",
          "366:  dir_has_key = (ci != NULL);",
          "378:  if ((!cached_with_key && d_is_negative(dentry)) ||",
          "379:    (!cached_with_key && dir_has_key) ||",
          "380:    (cached_with_key && !dir_has_key))",
          "381:   return 0;",
          "382:  return 1;",
          "383: }",
          "385: const struct dentry_operations fscrypt_d_ops = {",
          "386:  .d_revalidate = fscrypt_d_revalidate,",
          "387: };",
          "388: EXPORT_SYMBOL(fscrypt_d_ops);",
          "394: static void completion_pages(struct work_struct *work)",
          "395: {",
          "396:  struct fscrypt_ctx *ctx =",
          "397:   container_of(work, struct fscrypt_ctx, r.work);",
          "398:  struct bio *bio = ctx->r.bio;",
          "399:  struct bio_vec *bv;",
          "400:  int i;",
          "402:  bio_for_each_segment_all(bv, bio, i) {",
          "403:   struct page *page = bv->bv_page;",
          "404:   int ret = fscrypt_decrypt_page(page);",
          "406:   if (ret) {",
          "407:    WARN_ON_ONCE(1);",
          "408:    SetPageError(page);",
          "409:   } else {",
          "410:    SetPageUptodate(page);",
          "411:   }",
          "412:   unlock_page(page);",
          "413:  }",
          "414:  fscrypt_release_ctx(ctx);",
          "415:  bio_put(bio);",
          "416: }",
          "418: void fscrypt_decrypt_bio_pages(struct fscrypt_ctx *ctx, struct bio *bio)",
          "419: {",
          "420:  INIT_WORK(&ctx->r.work, completion_pages);",
          "421:  ctx->r.bio = bio;",
          "422:  queue_work(fscrypt_read_workqueue, &ctx->r.work);",
          "423: }",
          "424: EXPORT_SYMBOL(fscrypt_decrypt_bio_pages);",
          "426: void fscrypt_pullback_bio_page(struct page **page, bool restore)",
          "427: {",
          "428:  struct fscrypt_ctx *ctx;",
          "429:  struct page *bounce_page;",
          "432:  if ((*page)->mapping)",
          "433:   return;",
          "436:  bounce_page = *page;",
          "437:  ctx = (struct fscrypt_ctx *)page_private(bounce_page);",
          "442:  if (restore)",
          "443:   fscrypt_restore_control_page(bounce_page);",
          "444: }",
          "445: EXPORT_SYMBOL(fscrypt_pullback_bio_page);",
          "447: void fscrypt_restore_control_page(struct page *page)",
          "448: {",
          "449:  struct fscrypt_ctx *ctx;",
          "451:  ctx = (struct fscrypt_ctx *)page_private(page);",
          "452:  set_page_private(page, (unsigned long)NULL);",
          "453:  ClearPagePrivate(page);",
          "454:  unlock_page(page);",
          "455:  fscrypt_release_ctx(ctx);",
          "456: }",
          "457: EXPORT_SYMBOL(fscrypt_restore_control_page);",
          "459: static void fscrypt_destroy(void)",
          "460: {",
          "461:  struct fscrypt_ctx *pos, *n;",
          "463:  list_for_each_entry_safe(pos, n, &fscrypt_free_ctxs, free_list)",
          "464:   kmem_cache_free(fscrypt_ctx_cachep, pos);",
          "465:  INIT_LIST_HEAD(&fscrypt_free_ctxs);",
          "466:  mempool_destroy(fscrypt_bounce_page_pool);",
          "467:  fscrypt_bounce_page_pool = NULL;",
          "468: }",
          "478: int fscrypt_initialize(void)",
          "479: {",
          "480:  int i, res = -ENOMEM;",
          "482:  if (fscrypt_bounce_page_pool)",
          "483:   return 0;",
          "485:  mutex_lock(&fscrypt_init_mutex);",
          "486:  if (fscrypt_bounce_page_pool)",
          "487:   goto already_initialized;",
          "489:  for (i = 0; i < num_prealloc_crypto_ctxs; i++) {",
          "490:   struct fscrypt_ctx *ctx;",
          "492:   ctx = kmem_cache_zalloc(fscrypt_ctx_cachep, GFP_NOFS);",
          "493:   if (!ctx)",
          "494:    goto fail;",
          "495:   list_add(&ctx->free_list, &fscrypt_free_ctxs);",
          "496:  }",
          "498:  fscrypt_bounce_page_pool =",
          "499:   mempool_create_page_pool(num_prealloc_crypto_pages, 0);",
          "500:  if (!fscrypt_bounce_page_pool)",
          "501:   goto fail;",
          "503: already_initialized:",
          "504:  mutex_unlock(&fscrypt_init_mutex);",
          "505:  return 0;",
          "506: fail:",
          "507:  fscrypt_destroy();",
          "508:  mutex_unlock(&fscrypt_init_mutex);",
          "509:  return res;",
          "510: }",
          "511: EXPORT_SYMBOL(fscrypt_initialize);",
          "516: static int __init fscrypt_init(void)",
          "517: {",
          "518:  fscrypt_read_workqueue = alloc_workqueue(\"fscrypt_read_queue\",",
          "519:        WQ_HIGHPRI, 0);",
          "520:  if (!fscrypt_read_workqueue)",
          "521:   goto fail;",
          "523:  fscrypt_ctx_cachep = KMEM_CACHE(fscrypt_ctx, SLAB_RECLAIM_ACCOUNT);",
          "524:  if (!fscrypt_ctx_cachep)",
          "525:   goto fail_free_queue;",
          "527:  fscrypt_info_cachep = KMEM_CACHE(fscrypt_info, SLAB_RECLAIM_ACCOUNT);",
          "528:  if (!fscrypt_info_cachep)",
          "529:   goto fail_free_ctx;",
          "531:  return 0;",
          "533: fail_free_ctx:",
          "534:  kmem_cache_destroy(fscrypt_ctx_cachep);",
          "535: fail_free_queue:",
          "536:  destroy_workqueue(fscrypt_read_workqueue);",
          "537: fail:",
          "538:  return -ENOMEM;",
          "539: }",
          "540: module_init(fscrypt_init)",
          "545: static void __exit fscrypt_exit(void)",
          "546: {",
          "547:  fscrypt_destroy();",
          "549:  if (fscrypt_read_workqueue)",
          "550:   destroy_workqueue(fscrypt_read_workqueue);",
          "551:  kmem_cache_destroy(fscrypt_ctx_cachep);",
          "552:  kmem_cache_destroy(fscrypt_info_cachep);",
          "553: }",
          "554: module_exit(fscrypt_exit);",
          "556: MODULE_LICENSE(\"GPL\");",
          "",
          "---------------"
        ],
        "fs/f2fs/crypto_fname.c||fs/crypto/fname.c": [
          "File: fs/f2fs/crypto_fname.c -> fs/crypto/fname.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <crypto/hash.h>",
          "19: #include <crypto/sha.h>",
          "20: #include <keys/encrypted-type.h>",
          "21: #include <keys/user-type.h>",
          "22: #include <linux/crypto.h>",
          "29: #include <linux/scatterlist.h>",
          "32: #include <linux/ratelimit.h>",
          "42: {",
          "45:  if (res == -EINPROGRESS)",
          "46:   return;",
          "",
          "[Removed Lines]",
          "23: #include <linux/gfp.h>",
          "24: #include <linux/kernel.h>",
          "25: #include <linux/key.h>",
          "26: #include <linux/list.h>",
          "27: #include <linux/mempool.h>",
          "28: #include <linux/random.h>",
          "30: #include <linux/spinlock_types.h>",
          "31: #include <linux/f2fs_fs.h>",
          "34: #include \"f2fs.h\"",
          "35: #include \"f2fs_crypto.h\"",
          "36: #include \"xattr.h\"",
          "41: static void f2fs_dir_crypt_complete(struct crypto_async_request *req, int res)",
          "43:  struct f2fs_completion_result *ecr = req->data;",
          "",
          "[Added Lines]",
          "20: #include <linux/fscrypto.h>",
          "22: static u32 size_round_up(size_t size, size_t blksize)",
          "23: {",
          "24:  return ((size + blksize - 1) / blksize) * blksize;",
          "25: }",
          "30: static void dir_crypt_complete(struct crypto_async_request *req, int res)",
          "32:  struct fscrypt_completion_result *ecr = req->data;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:  complete(&ecr->completion);",
          "49: }",
          "71: {",
          "72:  u32 ciphertext_len;",
          "73:  struct ablkcipher_request *req = NULL;",
          "76:  struct crypto_ablkcipher *tfm = ci->ci_ctfm;",
          "77:  int res = 0;",
          "79:  struct scatterlist src_sg, dst_sg;",
          "81:  char *workbuf, buf[32], *alloc_buf = NULL;",
          "84:  if (iname->len <= 0 || iname->len > lim)",
          "85:   return -EIO;",
          "90:  ciphertext_len = (ciphertext_len > lim) ? lim : ciphertext_len;",
          "92:  if (ciphertext_len <= sizeof(buf)) {",
          "",
          "[Removed Lines]",
          "51: bool f2fs_valid_filenames_enc_mode(uint32_t mode)",
          "52: {",
          "53:  return (mode == F2FS_ENCRYPTION_MODE_AES_256_CTS);",
          "54: }",
          "56: static unsigned max_name_len(struct inode *inode)",
          "57: {",
          "58:  return S_ISLNK(inode->i_mode) ? inode->i_sb->s_blocksize :",
          "59:      F2FS_NAME_LEN;",
          "60: }",
          "69: static int f2fs_fname_encrypt(struct inode *inode,",
          "70:    const struct qstr *iname, struct f2fs_str *oname)",
          "74:  DECLARE_F2FS_COMPLETION_RESULT(ecr);",
          "75:  struct f2fs_crypt_info *ci = F2FS_I(inode)->i_crypt_info;",
          "78:  char iv[F2FS_CRYPTO_BLOCK_SIZE];",
          "80:  int padding = 4 << (ci->ci_flags & F2FS_POLICY_FLAGS_PAD_MASK);",
          "82:  unsigned lim = max_name_len(inode);",
          "87:  ciphertext_len = (iname->len < F2FS_CRYPTO_BLOCK_SIZE) ?",
          "88:   F2FS_CRYPTO_BLOCK_SIZE : iname->len;",
          "89:  ciphertext_len = f2fs_fname_crypto_round_up(ciphertext_len, padding);",
          "",
          "[Added Lines]",
          "47: static int fname_encrypt(struct inode *inode,",
          "48:    const struct qstr *iname, struct fscrypt_str *oname)",
          "52:  DECLARE_FS_COMPLETION_RESULT(ecr);",
          "53:  struct fscrypt_info *ci = inode->i_crypt_info;",
          "56:  char iv[FS_CRYPTO_BLOCK_SIZE];",
          "58:  int padding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);",
          "60:  unsigned lim;",
          "62:  lim = inode->i_sb->s_cop->max_namelen(inode);",
          "66:  ciphertext_len = (iname->len < FS_CRYPTO_BLOCK_SIZE) ?",
          "67:      FS_CRYPTO_BLOCK_SIZE : iname->len;",
          "68:  ciphertext_len = size_round_up(ciphertext_len, padding);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108:  }",
          "109:  ablkcipher_request_set_callback(req,",
          "110:    CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,",
          "114:  memcpy(workbuf, iname->name, iname->len);",
          "",
          "[Removed Lines]",
          "111:    f2fs_dir_crypt_complete, &ecr);",
          "",
          "[Added Lines]",
          "90:    dir_crypt_complete, &ecr);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "116:   memset(workbuf + iname->len, 0, ciphertext_len - iname->len);",
          "122:  sg_init_one(&src_sg, workbuf, ciphertext_len);",
          "",
          "[Removed Lines]",
          "119:  memset(iv, 0, F2FS_CRYPTO_BLOCK_SIZE);",
          "",
          "[Added Lines]",
          "98:  memset(iv, 0, FS_CRYPTO_BLOCK_SIZE);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "129:  }",
          "130:  kfree(alloc_buf);",
          "131:  ablkcipher_request_free(req);",
          "133:   printk_ratelimited(KERN_ERR",
          "134:     \"%s: Error (error code %d)\\n\", __func__, res);",
          "136:  oname->len = ciphertext_len;",
          "137:  return res;",
          "138: }",
          "149: {",
          "150:  struct ablkcipher_request *req = NULL;",
          "152:  struct scatterlist src_sg, dst_sg;",
          "154:  struct crypto_ablkcipher *tfm = ci->ci_ctfm;",
          "155:  int res = 0;",
          "159:  if (iname->len <= 0 || iname->len > lim)",
          "160:   return -EIO;",
          "",
          "[Removed Lines]",
          "132:  if (res < 0) {",
          "135:  }",
          "147: static int f2fs_fname_decrypt(struct inode *inode,",
          "148:    const struct f2fs_str *iname, struct f2fs_str *oname)",
          "151:  DECLARE_F2FS_COMPLETION_RESULT(ecr);",
          "153:  struct f2fs_crypt_info *ci = F2FS_I(inode)->i_crypt_info;",
          "156:  char iv[F2FS_CRYPTO_BLOCK_SIZE];",
          "157:  unsigned lim = max_name_len(inode);",
          "",
          "[Added Lines]",
          "111:  if (res < 0)",
          "126: static int fname_decrypt(struct inode *inode,",
          "127:     const struct fscrypt_str *iname,",
          "128:     struct fscrypt_str *oname)",
          "131:  DECLARE_FS_COMPLETION_RESULT(ecr);",
          "133:  struct fscrypt_info *ci = inode->i_crypt_info;",
          "136:  char iv[FS_CRYPTO_BLOCK_SIZE];",
          "137:  unsigned lim;",
          "139:  lim = inode->i_sb->s_cop->max_namelen(inode);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "168:  }",
          "169:  ablkcipher_request_set_callback(req,",
          "170:   CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,",
          "177:  sg_init_one(&src_sg, iname->name, iname->len);",
          "",
          "[Removed Lines]",
          "171:   f2fs_dir_crypt_complete, &ecr);",
          "174:  memset(iv, 0, F2FS_CRYPTO_BLOCK_SIZE);",
          "",
          "[Added Lines]",
          "152:   dir_crypt_complete, &ecr);",
          "155:  memset(iv, 0, FS_CRYPTO_BLOCK_SIZE);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "185:  ablkcipher_request_free(req);",
          "186:  if (res < 0) {",
          "187:   printk_ratelimited(KERN_ERR",
          "190:   return res;",
          "191:  }",
          "",
          "[Removed Lines]",
          "188:    \"%s: Error in f2fs_fname_decrypt (error code %d)\\n\",",
          "189:    __func__, res);",
          "",
          "[Added Lines]",
          "169:     \"%s: Error (error code %d)\\n\", __func__, res);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "247:  return cp - dst;",
          "248: }",
          "261: {",
          "263:  int padding = 32;",
          "265:  if (ci)",
          "270: }",
          "280: {",
          "283:  crypto_str->len = olen;",
          "288:  crypto_str->name = kmalloc(olen + 1, GFP_NOFS);",
          "289:  if (!(crypto_str->name))",
          "290:   return -ENOMEM;",
          "291:  return 0;",
          "292: }",
          "300: {",
          "301:  if (!crypto_str)",
          "302:   return;",
          "303:  kfree(crypto_str->name);",
          "304:  crypto_str->name = NULL;",
          "305: }",
          "314: {",
          "315:  const struct qstr qname = FSTR_TO_QSTR(iname);",
          "316:  char buf[24];",
          "317:  int ret;",
          "320:   oname->name[0] = '.';",
          "321:   oname->name[iname->len - 1] = '.';",
          "322:   oname->len = iname->len;",
          "323:   return oname->len;",
          "324:  }",
          "327:   return -EUCLEAN;",
          "333:   ret = digest_encode(iname->name, iname->len, oname->name);",
          "334:   oname->len = ret;",
          "335:   return ret;",
          "336:  }",
          "337:  if (hash) {",
          "341:   memset(buf, 0, 8);",
          "342:  memcpy(buf + 8, iname->name + iname->len - 16, 16);",
          "343:  oname->name[0] = '_';",
          "344:  ret = digest_encode(buf, 24, oname->name + 1);",
          "345:  oname->len = ret + 1;",
          "346:  return ret + 1;",
          "347: }",
          "353:    const struct qstr *iname,",
          "355: {",
          "360:   oname->name[0] = '.';",
          "361:   oname->name[iname->len - 1] = '.';",
          "362:   oname->len = iname->len;",
          "363:   return oname->len;",
          "364:  }",
          "373:  return -EACCES;",
          "374: }",
          "378: {",
          "380:  int ret = 0, bigname = 0;",
          "383:  fname->usr_fname = iname;",
          "386:   fname->disk_name.name = (unsigned char *)iname->name;",
          "387:   fname->disk_name.len = iname->len;",
          "388:   return 0;",
          "389:  }",
          "392:   return ret;",
          "397:   if (ret < 0)",
          "398:    return ret;",
          "400:   if (ret < 0)",
          "401:    goto errout;",
          "402:   fname->disk_name.name = fname->crypto_buf.name;",
          "",
          "[Removed Lines]",
          "255: u32 f2fs_fname_crypto_round_up(u32 size, u32 blksize)",
          "256: {",
          "257:  return ((size + blksize - 1) / blksize) * blksize;",
          "258: }",
          "260: unsigned f2fs_fname_encrypted_size(struct inode *inode, u32 ilen)",
          "262:  struct f2fs_crypt_info *ci = F2FS_I(inode)->i_crypt_info;",
          "266:   padding = 4 << (ci->ci_flags & F2FS_POLICY_FLAGS_PAD_MASK);",
          "267:  if (ilen < F2FS_CRYPTO_BLOCK_SIZE)",
          "268:   ilen = F2FS_CRYPTO_BLOCK_SIZE;",
          "269:  return f2fs_fname_crypto_round_up(ilen, padding);",
          "278: int f2fs_fname_crypto_alloc_buffer(struct inode *inode,",
          "279:        u32 ilen, struct f2fs_str *crypto_str)",
          "281:  unsigned int olen = f2fs_fname_encrypted_size(inode, ilen);",
          "284:  if (olen < F2FS_FNAME_CRYPTO_DIGEST_SIZE * 2)",
          "285:   olen = F2FS_FNAME_CRYPTO_DIGEST_SIZE * 2;",
          "299: void f2fs_fname_crypto_free_buffer(struct f2fs_str *crypto_str)",
          "310: int f2fs_fname_disk_to_usr(struct inode *inode,",
          "311:    f2fs_hash_t *hash,",
          "312:    const struct f2fs_str *iname,",
          "313:    struct f2fs_str *oname)",
          "319:  if (is_dot_dotdot(&qname)) {",
          "325:  if (iname->len < F2FS_CRYPTO_BLOCK_SIZE) {",
          "326:   printk(\"encrypted inode too small\");",
          "328:  }",
          "329:  if (F2FS_I(inode)->i_crypt_info)",
          "330:   return f2fs_fname_decrypt(inode, iname, oname);",
          "332:  if (iname->len <= F2FS_FNAME_CRYPTO_DIGEST_SIZE) {",
          "338:   memcpy(buf, hash, 4);",
          "339:   memset(buf + 4, 0, 4);",
          "340:  } else",
          "352: int f2fs_fname_usr_to_disk(struct inode *inode,",
          "354:    struct f2fs_str *oname)",
          "356:  int res;",
          "357:  struct f2fs_crypt_info *ci = F2FS_I(inode)->i_crypt_info;",
          "359:  if (is_dot_dotdot(iname)) {",
          "366:  if (ci) {",
          "367:   res = f2fs_fname_encrypt(inode, iname, oname);",
          "368:   return res;",
          "369:  }",
          "376: int f2fs_fname_setup_filename(struct inode *dir, const struct qstr *iname,",
          "377:          int lookup, struct f2fs_filename *fname)",
          "379:  struct f2fs_crypt_info *ci;",
          "382:  memset(fname, 0, sizeof(struct f2fs_filename));",
          "385:  if (!f2fs_encrypted_inode(dir) || is_dot_dotdot(iname)) {",
          "390:  ret = f2fs_get_encryption_info(dir);",
          "391:  if (ret)",
          "393:  ci = F2FS_I(dir)->i_crypt_info;",
          "394:  if (ci) {",
          "395:   ret = f2fs_fname_crypto_alloc_buffer(dir, iname->len,",
          "396:            &fname->crypto_buf);",
          "399:   ret = f2fs_fname_encrypt(dir, iname, &fname->crypto_buf);",
          "",
          "[Added Lines]",
          "230: u32 fscrypt_fname_encrypted_size(struct inode *inode, u32 ilen)",
          "233:  struct fscrypt_info *ci = inode->i_crypt_info;",
          "236:   padding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);",
          "237:  if (ilen < FS_CRYPTO_BLOCK_SIZE)",
          "238:   ilen = FS_CRYPTO_BLOCK_SIZE;",
          "239:  return size_round_up(ilen, padding);",
          "241: EXPORT_SYMBOL(fscrypt_fname_encrypted_size);",
          "249: int fscrypt_fname_alloc_buffer(struct inode *inode,",
          "250:     u32 ilen, struct fscrypt_str *crypto_str)",
          "252:  unsigned int olen = fscrypt_fname_encrypted_size(inode, ilen);",
          "255:  if (olen < FS_FNAME_CRYPTO_DIGEST_SIZE * 2)",
          "256:   olen = FS_FNAME_CRYPTO_DIGEST_SIZE * 2;",
          "266: EXPORT_SYMBOL(fscrypt_fname_alloc_buffer);",
          "273: void fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)",
          "280: EXPORT_SYMBOL(fscrypt_fname_free_buffer);",
          "286: int fscrypt_fname_disk_to_usr(struct inode *inode,",
          "287:    u32 hash, u32 minor_hash,",
          "288:    const struct fscrypt_str *iname,",
          "289:    struct fscrypt_str *oname)",
          "295:  if (fscrypt_is_dot_dotdot(&qname)) {",
          "302:  if (iname->len < FS_CRYPTO_BLOCK_SIZE)",
          "305:  if (inode->i_crypt_info)",
          "306:   return fname_decrypt(inode, iname, oname);",
          "308:  if (iname->len <= FS_FNAME_CRYPTO_DIGEST_SIZE) {",
          "314:   memcpy(buf, &hash, 4);",
          "315:   memcpy(buf + 4, &minor_hash, 4);",
          "316:  } else {",
          "318:  }",
          "325: EXPORT_SYMBOL(fscrypt_fname_disk_to_usr);",
          "331: int fscrypt_fname_usr_to_disk(struct inode *inode,",
          "333:    struct fscrypt_str *oname)",
          "335:  if (fscrypt_is_dot_dotdot(iname)) {",
          "341:  if (inode->i_crypt_info)",
          "342:   return fname_encrypt(inode, iname, oname);",
          "350: EXPORT_SYMBOL(fscrypt_fname_usr_to_disk);",
          "352: int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,",
          "353:          int lookup, struct fscrypt_name *fname)",
          "357:  memset(fname, 0, sizeof(struct fscrypt_name));",
          "360:  if (!dir->i_sb->s_cop->is_encrypted(dir) ||",
          "361:     fscrypt_is_dot_dotdot(iname)) {",
          "366:  ret = get_crypt_info(dir);",
          "367:  if (ret && ret != -EOPNOTSUPP)",
          "370:  if (dir->i_crypt_info) {",
          "371:   ret = fscrypt_fname_alloc_buffer(dir, iname->len,",
          "372:        &fname->crypto_buf);",
          "375:   ret = fname_encrypt(dir, iname, &fname->crypto_buf);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "406:  if (!lookup)",
          "407:   return -EACCES;",
          "412:  if (iname->name[0] == '_')",
          "413:   bigname = 1;",
          "416:   return -ENOENT;",
          "418:  fname->crypto_buf.name = kmalloc(32, GFP_KERNEL);",
          "419:  if (fname->crypto_buf.name == NULL)",
          "420:   return -ENOMEM;",
          "421:  ret = digest_decode(iname->name + bigname, iname->len - bigname,",
          "422:     fname->crypto_buf.name);",
          "423:  if (ret < 0) {",
          "",
          "[Removed Lines]",
          "414:  if ((bigname && (iname->len != 33)) ||",
          "415:      (!bigname && (iname->len > 43)))",
          "",
          "[Added Lines]",
          "391:  if ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "427:  fname->crypto_buf.len = ret;",
          "428:  if (bigname) {",
          "429:   memcpy(&fname->hash, fname->crypto_buf.name, 4);",
          "430:  } else {",
          "431:   fname->disk_name.name = fname->crypto_buf.name;",
          "432:   fname->disk_name.len = fname->crypto_buf.len;",
          "433:  }",
          "434:  return 0;",
          "435: errout:",
          "437:  return ret;",
          "438: }",
          "441: {",
          "442:  kfree(fname->crypto_buf.name);",
          "443:  fname->crypto_buf.name = NULL;",
          "444:  fname->usr_fname = NULL;",
          "445:  fname->disk_name.name = NULL;",
          "446: }",
          "",
          "[Removed Lines]",
          "436:  f2fs_fname_crypto_free_buffer(&fname->crypto_buf);",
          "440: void f2fs_fname_free_filename(struct f2fs_filename *fname)",
          "",
          "[Added Lines]",
          "407:   memcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);",
          "415:  fscrypt_fname_free_buffer(&fname->crypto_buf);",
          "418: EXPORT_SYMBOL(fscrypt_setup_filename);",
          "420: void fscrypt_free_filename(struct fscrypt_name *fname)",
          "427: EXPORT_SYMBOL(fscrypt_free_filename);",
          "",
          "---------------"
        ],
        "fs/f2fs/crypto_key.c||fs/crypto/keyinfo.c": [
          "File: fs/f2fs/crypto_key.c -> fs/crypto/keyinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <keys/encrypted-type.h>",
          "13: #include <keys/user-type.h>",
          "14: #include <linux/random.h>",
          "15: #include <linux/scatterlist.h>",
          "16: #include <uapi/linux/keyctl.h>",
          "17: #include <crypto/hash.h>",
          "23: static void derive_crypt_complete(struct crypto_async_request *req, int rc)",
          "24: {",
          "27:  if (rc == -EINPROGRESS)",
          "28:   return;",
          "",
          "[Removed Lines]",
          "18: #include <linux/f2fs_fs.h>",
          "20: #include \"f2fs.h\"",
          "21: #include \"xattr.h\"",
          "25:  struct f2fs_completion_result *ecr = req->data;",
          "",
          "[Added Lines]",
          "17: #include <linux/fscrypto.h>",
          "21:  struct fscrypt_completion_result *ecr = req->data;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: }",
          "45: {",
          "46:  int res = 0;",
          "47:  struct ablkcipher_request *req = NULL;",
          "49:  struct scatterlist src_sg, dst_sg;",
          "50:  struct crypto_ablkcipher *tfm = crypto_alloc_ablkcipher(\"ecb(aes)\", 0,",
          "51:         0);",
          "",
          "[Removed Lines]",
          "42: static int f2fs_derive_key_aes(char deriving_key[F2FS_AES_128_ECB_KEY_SIZE],",
          "43:     char source_key[F2FS_AES_256_XTS_KEY_SIZE],",
          "44:     char derived_key[F2FS_AES_256_XTS_KEY_SIZE])",
          "48:  DECLARE_F2FS_COMPLETION_RESULT(ecr);",
          "",
          "[Added Lines]",
          "38: static int derive_key_aes(u8 deriving_key[FS_AES_128_ECB_KEY_SIZE],",
          "39:     u8 source_key[FS_AES_256_XTS_KEY_SIZE],",
          "40:     u8 derived_key[FS_AES_256_XTS_KEY_SIZE])",
          "44:  DECLARE_FS_COMPLETION_RESULT(ecr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "65:    CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,",
          "66:    derive_crypt_complete, &ecr);",
          "67:  res = crypto_ablkcipher_setkey(tfm, deriving_key,",
          "69:  if (res < 0)",
          "70:   goto out;",
          "74:  ablkcipher_request_set_crypt(req, &src_sg, &dst_sg,",
          "76:  res = crypto_ablkcipher_encrypt(req);",
          "77:  if (res == -EINPROGRESS || res == -EBUSY) {",
          "78:   wait_for_completion(&ecr.completion);",
          "",
          "[Removed Lines]",
          "68:     F2FS_AES_128_ECB_KEY_SIZE);",
          "72:  sg_init_one(&src_sg, source_key, F2FS_AES_256_XTS_KEY_SIZE);",
          "73:  sg_init_one(&dst_sg, derived_key, F2FS_AES_256_XTS_KEY_SIZE);",
          "75:      F2FS_AES_256_XTS_KEY_SIZE, NULL);",
          "",
          "[Added Lines]",
          "64:      FS_AES_128_ECB_KEY_SIZE);",
          "68:  sg_init_one(&src_sg, source_key, FS_AES_256_XTS_KEY_SIZE);",
          "69:  sg_init_one(&dst_sg, derived_key, FS_AES_256_XTS_KEY_SIZE);",
          "71:      FS_AES_256_XTS_KEY_SIZE, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "86:  return res;",
          "87: }",
          "90: {",
          "91:  if (!ci)",
          "92:   return;",
          "95:  crypto_free_ablkcipher(ci->ci_ctfm);",
          "113: }",
          "116: {",
          "121:  struct key *keyring_key = NULL;",
          "124:  const struct user_key_payload *ukp;",
          "125:  struct crypto_ablkcipher *ctfm;",
          "126:  const char *cipher_str;",
          "129:  int res;",
          "132:  if (res)",
          "133:   return res;",
          "134: retry:",
          "136:  if (crypt_info) {",
          "137:   if (!crypt_info->ci_keyring_key ||",
          "138:     key_validate(crypt_info->ci_keyring_key) == 0)",
          "139:    return 0;",
          "141:   goto retry;",
          "142:  }",
          "150:   return -EINVAL;",
          "151:  res = 0;",
          "154:  if (!crypt_info)",
          "155:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "89: static void f2fs_free_crypt_info(struct f2fs_crypt_info *ci)",
          "94:  key_put(ci->ci_keyring_key);",
          "96:  kmem_cache_free(f2fs_crypt_info_cachep, ci);",
          "97: }",
          "99: void f2fs_free_encryption_info(struct inode *inode, struct f2fs_crypt_info *ci)",
          "100: {",
          "101:  struct f2fs_inode_info *fi = F2FS_I(inode);",
          "102:  struct f2fs_crypt_info *prev;",
          "104:  if (ci == NULL)",
          "105:   ci = ACCESS_ONCE(fi->i_crypt_info);",
          "106:  if (ci == NULL)",
          "107:   return;",
          "108:  prev = cmpxchg(&fi->i_crypt_info, ci, NULL);",
          "109:  if (prev != ci)",
          "110:   return;",
          "112:  f2fs_free_crypt_info(ci);",
          "115: int _f2fs_get_encryption_info(struct inode *inode)",
          "117:  struct f2fs_inode_info *fi = F2FS_I(inode);",
          "118:  struct f2fs_crypt_info *crypt_info;",
          "119:  char full_key_descriptor[F2FS_KEY_DESC_PREFIX_SIZE +",
          "120:     (F2FS_KEY_DESCRIPTOR_SIZE * 2) + 1];",
          "122:  struct f2fs_encryption_key *master_key;",
          "123:  struct f2fs_encryption_context ctx;",
          "127:  char raw_key[F2FS_MAX_KEY_SIZE];",
          "128:  char mode;",
          "131:  res = f2fs_crypto_initialize();",
          "135:  crypt_info = ACCESS_ONCE(fi->i_crypt_info);",
          "140:   f2fs_free_encryption_info(inode, crypt_info);",
          "144:  res = f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,",
          "145:     F2FS_XATTR_NAME_ENCRYPTION_CONTEXT,",
          "146:     &ctx, sizeof(ctx), NULL);",
          "147:  if (res < 0)",
          "148:   return res;",
          "149:  else if (res != sizeof(ctx))",
          "153:  crypt_info = kmem_cache_alloc(f2fs_crypt_info_cachep, GFP_NOFS);",
          "",
          "[Added Lines]",
          "85: static void put_crypt_info(struct fscrypt_info *ci)",
          "90:  if (ci->ci_keyring_key)",
          "91:   key_put(ci->ci_keyring_key);",
          "93:  kmem_cache_free(fscrypt_info_cachep, ci);",
          "96: int get_crypt_info(struct inode *inode)",
          "98:  struct fscrypt_info *crypt_info;",
          "99:  u8 full_key_descriptor[FS_KEY_DESC_PREFIX_SIZE +",
          "100:     (FS_KEY_DESCRIPTOR_SIZE * 2) + 1];",
          "102:  struct fscrypt_key *master_key;",
          "103:  struct fscrypt_context ctx;",
          "107:  u8 raw_key[FS_MAX_KEY_SIZE];",
          "108:  u8 mode;",
          "111:  res = fscrypt_initialize();",
          "115:  if (!inode->i_sb->s_cop->get_context)",
          "116:   return -EOPNOTSUPP;",
          "118:  crypt_info = ACCESS_ONCE(inode->i_crypt_info);",
          "123:   fscrypt_put_encryption_info(inode, crypt_info);",
          "127:  res = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));",
          "128:  if (res < 0) {",
          "129:   if (!fscrypt_dummy_context_enabled(inode))",
          "130:    return res;",
          "131:   ctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;",
          "132:   ctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;",
          "133:   ctx.flags = 0;",
          "134:  } else if (res != sizeof(ctx)) {",
          "136:  }",
          "139:  crypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "169:   BUG();",
          "171:  switch (mode) {",
          "173:   cipher_str = \"xts(aes)\";",
          "174:   break;",
          "176:   cipher_str = \"cts(cbc(aes))\";",
          "177:   break;",
          "178:  default:",
          "179:   printk_once(KERN_WARNING",
          "182:   res = -ENOKEY;",
          "183:   goto out;",
          "184:  }",
          "190:      ctx.master_key_descriptor);",
          "193:  keyring_key = request_key(&key_type_logon, full_key_descriptor, NULL);",
          "194:  if (IS_ERR(keyring_key)) {",
          "195:   res = PTR_ERR(keyring_key);",
          "",
          "[Removed Lines]",
          "172:  case F2FS_ENCRYPTION_MODE_AES_256_XTS:",
          "175:  case F2FS_ENCRYPTION_MODE_AES_256_CTS:",
          "180:        \"f2fs: unsupported key mode %d (ino %u)\\n\",",
          "181:        mode, (unsigned) inode->i_ino);",
          "186:  memcpy(full_key_descriptor, F2FS_KEY_DESC_PREFIX,",
          "187:      F2FS_KEY_DESC_PREFIX_SIZE);",
          "188:  sprintf(full_key_descriptor + F2FS_KEY_DESC_PREFIX_SIZE,",
          "189:      \"%*phN\", F2FS_KEY_DESCRIPTOR_SIZE,",
          "191:  full_key_descriptor[F2FS_KEY_DESC_PREFIX_SIZE +",
          "192:      (2 * F2FS_KEY_DESCRIPTOR_SIZE)] = '\\0';",
          "",
          "[Added Lines]",
          "158:  case FS_ENCRYPTION_MODE_AES_256_XTS:",
          "161:  case FS_ENCRYPTION_MODE_AES_256_CTS:",
          "166:        \"%s: unsupported key mode %d (ino %u)\\n\",",
          "167:        __func__, mode, (unsigned) inode->i_ino);",
          "171:  if (fscrypt_dummy_context_enabled(inode)) {",
          "172:   memset(raw_key, 0x42, FS_AES_256_XTS_KEY_SIZE);",
          "173:   goto got_key;",
          "174:  }",
          "175:  memcpy(full_key_descriptor, FS_KEY_DESC_PREFIX,",
          "176:      FS_KEY_DESC_PREFIX_SIZE);",
          "177:  sprintf(full_key_descriptor + FS_KEY_DESC_PREFIX_SIZE,",
          "178:      \"%*phN\", FS_KEY_DESCRIPTOR_SIZE,",
          "180:  full_key_descriptor[FS_KEY_DESC_PREFIX_SIZE +",
          "181:      (2 * FS_KEY_DESCRIPTOR_SIZE)] = '\\0';",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "198:  }",
          "199:  crypt_info->ci_keyring_key = keyring_key;",
          "200:  if (keyring_key->type != &key_type_logon) {",
          "202:   res = -ENOKEY;",
          "203:   goto out;",
          "204:  }",
          "205:  down_read(&keyring_key->sem);",
          "206:  ukp = user_key_payload(keyring_key);",
          "208:   res = -EINVAL;",
          "209:   up_read(&keyring_key->sem);",
          "210:   goto out;",
          "211:  }",
          "216:   printk_once(KERN_WARNING",
          "219:   res = -ENOKEY;",
          "220:   up_read(&keyring_key->sem);",
          "221:   goto out;",
          "222:  }",
          "225:  up_read(&keyring_key->sem);",
          "226:  if (res)",
          "227:   goto out;",
          "229:  ctfm = crypto_alloc_ablkcipher(cipher_str, 0, 0);",
          "230:  if (!ctfm || IS_ERR(ctfm)) {",
          "231:   res = ctfm ? PTR_ERR(ctfm) : -ENOMEM;",
          "",
          "[Removed Lines]",
          "201:   printk_once(KERN_WARNING \"f2fs: key type must be logon\\n\");",
          "207:  if (ukp->datalen != sizeof(struct f2fs_encryption_key)) {",
          "212:  master_key = (struct f2fs_encryption_key *)ukp->data;",
          "213:  BUILD_BUG_ON(F2FS_AES_128_ECB_KEY_SIZE !=",
          "214:     F2FS_KEY_DERIVATION_NONCE_SIZE);",
          "215:  if (master_key->size != F2FS_AES_256_XTS_KEY_SIZE) {",
          "217:     \"f2fs: key size incorrect: %d\\n\",",
          "218:     master_key->size);",
          "223:  res = f2fs_derive_key_aes(ctx.nonce, master_key->raw,",
          "224:       raw_key);",
          "",
          "[Added Lines]",
          "190:   printk_once(KERN_WARNING",
          "191:     \"%s: key type must be logon\\n\", __func__);",
          "197:  if (ukp->datalen != sizeof(struct fscrypt_key)) {",
          "202:  master_key = (struct fscrypt_key *)ukp->data;",
          "203:  BUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);",
          "205:  if (master_key->size != FS_AES_256_XTS_KEY_SIZE) {",
          "207:     \"%s: key size incorrect: %d\\n\",",
          "208:     __func__, master_key->size);",
          "213:  res = derive_key_aes(ctx.nonce, master_key->raw, raw_key);",
          "217: got_key:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "237:  crypt_info->ci_ctfm = ctfm;",
          "238:  crypto_ablkcipher_clear_flags(ctfm, ~0);",
          "239:  crypto_tfm_set_flags(crypto_ablkcipher_tfm(ctfm),",
          "243:  if (res)",
          "244:   goto out;",
          "246:  memzero_explicit(raw_key, sizeof(raw_key));",
          "249:   goto retry;",
          "250:  }",
          "251:  return 0;",
          "253: out:",
          "255:   res = 0;",
          "258:  memzero_explicit(raw_key, sizeof(raw_key));",
          "259:  return res;",
          "260: }",
          "263: {",
          "267: }",
          "",
          "[Removed Lines]",
          "240:         CRYPTO_TFM_REQ_WEAK_KEY);",
          "241:  res = crypto_ablkcipher_setkey(ctfm, raw_key,",
          "242:      f2fs_encryption_key_size(mode));",
          "247:  if (cmpxchg(&fi->i_crypt_info, NULL, crypt_info) != NULL) {",
          "248:   f2fs_free_crypt_info(crypt_info);",
          "254:  if (res == -ENOKEY && !S_ISREG(inode->i_mode))",
          "257:  f2fs_free_crypt_info(crypt_info);",
          "262: int f2fs_has_encryption_key(struct inode *inode)",
          "264:  struct f2fs_inode_info *fi = F2FS_I(inode);",
          "266:  return (fi->i_crypt_info != NULL);",
          "",
          "[Added Lines]",
          "229:      CRYPTO_TFM_REQ_WEAK_KEY);",
          "230:  res = crypto_ablkcipher_setkey(ctfm, raw_key, fscrypt_key_size(mode));",
          "235:  if (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {",
          "236:   put_crypt_info(crypt_info);",
          "242:  if (res == -ENOKEY)",
          "244:  put_crypt_info(crypt_info);",
          "249: void fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)",
          "251:  struct fscrypt_info *prev;",
          "253:  if (ci == NULL)",
          "254:   ci = ACCESS_ONCE(inode->i_crypt_info);",
          "255:  if (ci == NULL)",
          "256:   return;",
          "258:  prev = cmpxchg(&inode->i_crypt_info, ci, NULL);",
          "259:  if (prev != ci)",
          "260:   return;",
          "262:  put_crypt_info(ci);",
          "263: }",
          "264: EXPORT_SYMBOL(fscrypt_put_encryption_info);",
          "266: int fscrypt_get_encryption_info(struct inode *inode)",
          "267: {",
          "268:  struct fscrypt_info *ci = inode->i_crypt_info;",
          "270:  if (!ci ||",
          "271:   (ci->ci_keyring_key &&",
          "272:    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
          "273:             (1 << KEY_FLAG_REVOKED) |",
          "274:             (1 << KEY_FLAG_DEAD)))))",
          "275:   return get_crypt_info(inode);",
          "276:  return 0;",
          "278: EXPORT_SYMBOL(fscrypt_get_encryption_info);",
          "",
          "---------------"
        ],
        "fs/crypto/policy.c||fs/crypto/policy.c": [
          "File: fs/crypto/policy.c -> fs/crypto/policy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include <linux/random.h>",
          "12: #include <linux/string.h>",
          "13: #include <linux/fscrypto.h>",
          "15: static int inode_has_encryption_context(struct inode *inode)",
          "16: {",
          "17:  if (!inode->i_sb->s_cop->get_context)",
          "18:   return 0;",
          "19:  return (inode->i_sb->s_cop->get_context(inode, NULL, 0L) > 0);",
          "20: }",
          "26: static int is_encryption_context_consistent_with_policy(struct inode *inode,",
          "27:     const struct fscrypt_policy *policy)",
          "28: {",
          "29:  struct fscrypt_context ctx;",
          "30:  int res;",
          "32:  if (!inode->i_sb->s_cop->get_context)",
          "33:   return 0;",
          "35:  res = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));",
          "36:  if (res != sizeof(ctx))",
          "37:   return 0;",
          "39:  return (memcmp(ctx.master_key_descriptor, policy->master_key_descriptor,",
          "40:    FS_KEY_DESCRIPTOR_SIZE) == 0 &&",
          "41:    (ctx.flags == policy->flags) &&",
          "42:    (ctx.contents_encryption_mode ==",
          "43:     policy->contents_encryption_mode) &&",
          "44:    (ctx.filenames_encryption_mode ==",
          "45:     policy->filenames_encryption_mode));",
          "46: }",
          "48: static int create_encryption_context_from_policy(struct inode *inode,",
          "49:     const struct fscrypt_policy *policy)",
          "50: {",
          "51:  struct fscrypt_context ctx;",
          "52:  int res;",
          "54:  if (!inode->i_sb->s_cop->set_context)",
          "55:   return -EOPNOTSUPP;",
          "57:  if (inode->i_sb->s_cop->prepare_context) {",
          "58:   res = inode->i_sb->s_cop->prepare_context(inode);",
          "59:   if (res)",
          "60:    return res;",
          "61:  }",
          "63:  ctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;",
          "64:  memcpy(ctx.master_key_descriptor, policy->master_key_descriptor,",
          "65:      FS_KEY_DESCRIPTOR_SIZE);",
          "67:  if (!fscrypt_valid_contents_enc_mode(",
          "68:     policy->contents_encryption_mode)) {",
          "69:   printk(KERN_WARNING",
          "70:          \"%s: Invalid contents encryption mode %d\\n\", __func__,",
          "71:    policy->contents_encryption_mode);",
          "72:   return -EINVAL;",
          "73:  }",
          "75:  if (!fscrypt_valid_filenames_enc_mode(",
          "76:     policy->filenames_encryption_mode)) {",
          "77:   printk(KERN_WARNING",
          "78:    \"%s: Invalid filenames encryption mode %d\\n\", __func__,",
          "79:    policy->filenames_encryption_mode);",
          "80:   return -EINVAL;",
          "81:  }",
          "83:  if (policy->flags & ~FS_POLICY_FLAGS_VALID)",
          "84:   return -EINVAL;",
          "86:  ctx.contents_encryption_mode = policy->contents_encryption_mode;",
          "87:  ctx.filenames_encryption_mode = policy->filenames_encryption_mode;",
          "88:  ctx.flags = policy->flags;",
          "89:  BUILD_BUG_ON(sizeof(ctx.nonce) != FS_KEY_DERIVATION_NONCE_SIZE);",
          "90:  get_random_bytes(ctx.nonce, FS_KEY_DERIVATION_NONCE_SIZE);",
          "92:  return inode->i_sb->s_cop->set_context(inode, &ctx, sizeof(ctx), NULL);",
          "93: }",
          "95: int fscrypt_process_policy(struct inode *inode,",
          "96:     const struct fscrypt_policy *policy)",
          "97: {",
          "98:  if (policy->version != 0)",
          "99:   return -EINVAL;",
          "101:  if (!inode_has_encryption_context(inode)) {",
          "102:   if (!inode->i_sb->s_cop->empty_dir)",
          "103:    return -EOPNOTSUPP;",
          "104:   if (!inode->i_sb->s_cop->empty_dir(inode))",
          "105:    return -ENOTEMPTY;",
          "106:   return create_encryption_context_from_policy(inode, policy);",
          "107:  }",
          "109:  if (is_encryption_context_consistent_with_policy(inode, policy))",
          "110:   return 0;",
          "112:  printk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",",
          "113:         __func__);",
          "114:  return -EINVAL;",
          "115: }",
          "116: EXPORT_SYMBOL(fscrypt_process_policy);",
          "118: int fscrypt_get_policy(struct inode *inode, struct fscrypt_policy *policy)",
          "119: {",
          "120:  struct fscrypt_context ctx;",
          "121:  int res;",
          "123:  if (!inode->i_sb->s_cop->get_context ||",
          "124:    !inode->i_sb->s_cop->is_encrypted(inode))",
          "125:   return -ENODATA;",
          "127:  res = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));",
          "128:  if (res != sizeof(ctx))",
          "129:   return -ENODATA;",
          "130:  if (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)",
          "131:   return -EINVAL;",
          "133:  policy->version = 0;",
          "134:  policy->contents_encryption_mode = ctx.contents_encryption_mode;",
          "135:  policy->filenames_encryption_mode = ctx.filenames_encryption_mode;",
          "136:  policy->flags = ctx.flags;",
          "137:  memcpy(&policy->master_key_descriptor, ctx.master_key_descriptor,",
          "138:     FS_KEY_DESCRIPTOR_SIZE);",
          "139:  return 0;",
          "140: }",
          "141: EXPORT_SYMBOL(fscrypt_get_policy);",
          "143: int fscrypt_has_permitted_context(struct inode *parent, struct inode *child)",
          "144: {",
          "145:  struct fscrypt_info *parent_ci, *child_ci;",
          "146:  int res;",
          "148:  if ((parent == NULL) || (child == NULL)) {",
          "149:   printk(KERN_ERR \"parent %p child %p\\n\", parent, child);",
          "150:   BUG_ON(1);",
          "151:  }",
          "154:  if (!parent->i_sb->s_cop->is_encrypted(parent))",
          "155:   return 1;",
          "157:  if (!parent->i_sb->s_cop->is_encrypted(child))",
          "158:   return 0;",
          "159:  res = fscrypt_get_encryption_info(parent);",
          "160:  if (res)",
          "161:   return 0;",
          "162:  res = fscrypt_get_encryption_info(child);",
          "163:  if (res)",
          "164:   return 0;",
          "165:  parent_ci = parent->i_crypt_info;",
          "166:  child_ci = child->i_crypt_info;",
          "167:  if (!parent_ci && !child_ci)",
          "168:   return 1;",
          "169:  if (!parent_ci || !child_ci)",
          "170:   return 0;",
          "172:  return (memcmp(parent_ci->ci_master_key,",
          "173:    child_ci->ci_master_key,",
          "174:    FS_KEY_DESCRIPTOR_SIZE) == 0 &&",
          "175:   (parent_ci->ci_data_mode == child_ci->ci_data_mode) &&",
          "176:   (parent_ci->ci_filename_mode == child_ci->ci_filename_mode) &&",
          "177:   (parent_ci->ci_flags == child_ci->ci_flags));",
          "178: }",
          "179: EXPORT_SYMBOL(fscrypt_has_permitted_context);",
          "190: int fscrypt_inherit_context(struct inode *parent, struct inode *child,",
          "191:       void *fs_data, bool preload)",
          "192: {",
          "193:  struct fscrypt_context ctx;",
          "194:  struct fscrypt_info *ci;",
          "195:  int res;",
          "197:  if (!parent->i_sb->s_cop->set_context)",
          "198:   return -EOPNOTSUPP;",
          "200:  res = fscrypt_get_encryption_info(parent);",
          "201:  if (res < 0)",
          "202:   return res;",
          "204:  ci = parent->i_crypt_info;",
          "205:  if (ci == NULL)",
          "206:   return -ENOKEY;",
          "208:  ctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;",
          "209:  if (fscrypt_dummy_context_enabled(parent)) {",
          "210:   ctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;",
          "211:   ctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;",
          "212:   ctx.flags = 0;",
          "213:   memset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);",
          "214:   res = 0;",
          "215:  } else {",
          "216:   ctx.contents_encryption_mode = ci->ci_data_mode;",
          "217:   ctx.filenames_encryption_mode = ci->ci_filename_mode;",
          "218:   ctx.flags = ci->ci_flags;",
          "219:   memcpy(ctx.master_key_descriptor, ci->ci_master_key,",
          "220:     FS_KEY_DESCRIPTOR_SIZE);",
          "221:  }",
          "222:  get_random_bytes(ctx.nonce, FS_KEY_DERIVATION_NONCE_SIZE);",
          "223:  res = parent->i_sb->s_cop->set_context(child, &ctx,",
          "224:       sizeof(ctx), fs_data);",
          "225:  if (res)",
          "226:   return res;",
          "227:  return preload ? fscrypt_get_encryption_info(child): 0;",
          "228: }",
          "229: EXPORT_SYMBOL(fscrypt_inherit_context);",
          "",
          "---------------"
        ],
        "fs/f2fs/crypto.c||fs/f2fs/crypto.c": [
          "File: fs/f2fs/crypto.c -> fs/f2fs/crypto.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/crypto_policy.c||fs/f2fs/crypto_policy.c": [
          "File: fs/f2fs/crypto_policy.c -> fs/f2fs/crypto_policy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/data.c||fs/f2fs/data.c": [
          "File: fs/f2fs/data.c -> fs/f2fs/data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:  if (f2fs_bio_encrypted(bio)) {",
          "36:   if (bio->bi_error) {",
          "38:   } else {",
          "40:    return;",
          "41:   }",
          "42:  }",
          "",
          "[Removed Lines]",
          "37:    f2fs_release_crypto_ctx(bio->bi_private);",
          "39:    f2fs_end_io_crypto_work(bio->bi_private, bio);",
          "",
          "[Added Lines]",
          "37:    fscrypt_release_ctx(bio->bi_private);",
          "39:    fscrypt_decrypt_bio_pages(bio->bi_private, bio);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:  bio_for_each_segment_all(bvec, bio, i) {",
          "65:   struct page *page = bvec->bv_page;",
          "69:   if (unlikely(bio->bi_error)) {",
          "70:    set_bit(AS_EIO, &page->mapping->flags);",
          "",
          "[Removed Lines]",
          "67:   f2fs_restore_and_release_control_page(&page);",
          "",
          "[Added Lines]",
          "67:   fscrypt_pullback_bio_page(&page, true);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "130:  bio_for_each_segment_all(bvec, io->bio, i) {",
          "133:    target = bvec->bv_page;",
          "143:   if (inode && inode == target->mapping->host)",
          "144:    return true;",
          "",
          "[Removed Lines]",
          "132:   if (bvec->bv_page->mapping) {",
          "134:   } else {",
          "135:    struct f2fs_crypto_ctx *ctx;",
          "138:    ctx = (struct f2fs_crypto_ctx *)page_private(",
          "139:         bvec->bv_page);",
          "140:    target = ctx->w.control_page;",
          "141:   }",
          "",
          "[Added Lines]",
          "132:   if (bvec->bv_page->mapping)",
          "134:   else",
          "135:    target = fscrypt_control_page(bvec->bv_page);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "220: int f2fs_submit_page_bio(struct f2fs_io_info *fio)",
          "221: {",
          "222:  struct bio *bio;",
          "225:  trace_f2fs_submit_page_bio(page, fio);",
          "226:  f2fs_trace_ios(fio, 0);",
          "",
          "[Removed Lines]",
          "223:  struct page *page = fio->encrypted_page ? fio->encrypted_page : fio->page;",
          "",
          "[Added Lines]",
          "217:  struct page *page = fio->encrypted_page ?",
          "218:    fio->encrypted_page : fio->page;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "992:    bio = NULL;",
          "993:   }",
          "994:   if (bio == NULL) {",
          "997:    if (f2fs_encrypted_inode(inode) &&",
          "998:      S_ISREG(inode->i_mode)) {",
          "1001:     if (IS_ERR(ctx))",
          "1002:      goto set_error_page;",
          "",
          "[Removed Lines]",
          "995:    struct f2fs_crypto_ctx *ctx = NULL;",
          "1000:     ctx = f2fs_get_crypto_ctx(inode);",
          "",
          "[Added Lines]",
          "990:    struct fscrypt_ctx *ctx = NULL;",
          "995:     ctx = fscrypt_get_ctx(inode);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1010:     min_t(int, nr_pages, BIO_MAX_PAGES));",
          "1011:    if (!bio) {",
          "1012:     if (ctx)",
          "1014:     goto set_error_page;",
          "1015:    }",
          "1016:    bio->bi_bdev = bdev;",
          "",
          "[Removed Lines]",
          "1013:      f2fs_release_crypto_ctx(ctx);",
          "",
          "[Added Lines]",
          "1008:      fscrypt_release_ctx(ctx);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1102:   f2fs_wait_on_encrypted_page_writeback(F2FS_I_SB(inode),",
          "1103:        fio->old_blkaddr);",
          "1106:   if (IS_ERR(fio->encrypted_page)) {",
          "1107:    err = PTR_ERR(fio->encrypted_page);",
          "1108:    goto out_writepage;",
          "",
          "[Removed Lines]",
          "1105:   fio->encrypted_page = f2fs_encrypt(inode, fio->page);",
          "",
          "[Added Lines]",
          "1100:   fio->encrypted_page = fscrypt_encrypt_page(inode, fio->page);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1610:   if (f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode)) {",
          "1612:    if (err)",
          "1613:     goto fail;",
          "1614:   }",
          "",
          "[Removed Lines]",
          "1611:    err = f2fs_decrypt(page);",
          "",
          "[Added Lines]",
          "1606:    err = fscrypt_decrypt_page(page);",
          "",
          "---------------"
        ],
        "fs/f2fs/dir.c||fs/f2fs/dir.c": [
          "File: fs/f2fs/dir.c -> fs/f2fs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "77: }",
          "79: static struct f2fs_dir_entry *find_in_block(struct page *dentry_page,",
          "81:     f2fs_hash_t namehash,",
          "82:     int *max_slots,",
          "83:     struct page **res_page)",
          "",
          "[Removed Lines]",
          "80:     struct f2fs_filename *fname,",
          "",
          "[Added Lines]",
          "80:     struct fscrypt_name *fname,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "103:  return de;",
          "104: }",
          "107:    f2fs_hash_t namehash, int *max_slots,",
          "108:    struct f2fs_dentry_ptr *d)",
          "109: {",
          "110:  struct f2fs_dir_entry *de;",
          "111:  unsigned long bit_pos = 0;",
          "112:  int max_len = 0;",
          "116:  if (max_slots)",
          "",
          "[Removed Lines]",
          "106: struct f2fs_dir_entry *find_target_dentry(struct f2fs_filename *fname,",
          "113:  struct f2fs_str de_name = FSTR_INIT(NULL, 0);",
          "114:  struct f2fs_str *name = &fname->disk_name;",
          "",
          "[Added Lines]",
          "106: struct f2fs_dir_entry *find_target_dentry(struct fscrypt_name *fname,",
          "113:  struct fscrypt_str de_name = FSTR_INIT(NULL, 0);",
          "114:  struct fscrypt_str *name = &fname->disk_name;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "158: static struct f2fs_dir_entry *find_in_level(struct inode *dir,",
          "159:      unsigned int level,",
          "161:      struct page **res_page)",
          "162: {",
          "163:  struct qstr name = FSTR_TO_QSTR(&fname->disk_name);",
          "",
          "[Removed Lines]",
          "160:      struct f2fs_filename *fname,",
          "",
          "[Added Lines]",
          "160:      struct fscrypt_name *fname,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "218:  struct f2fs_dir_entry *de = NULL;",
          "219:  unsigned int max_depth;",
          "220:  unsigned int level;",
          "222:  int err;",
          "227:  if (err)",
          "228:   return NULL;",
          "",
          "[Removed Lines]",
          "221:  struct f2fs_filename fname;",
          "226:  err = f2fs_fname_setup_filename(dir, child, 1, &fname);",
          "",
          "[Added Lines]",
          "221:  struct fscrypt_name fname;",
          "226:  err = fscrypt_setup_filename(dir, child, 1, &fname);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "251:    break;",
          "252:  }",
          "253: out:",
          "255:  return de;",
          "256: }",
          "",
          "[Removed Lines]",
          "254:  f2fs_fname_free_filename(&fname);",
          "",
          "[Added Lines]",
          "254:  fscrypt_free_filename(&fname);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "413:    goto put_error;",
          "415:   if (f2fs_encrypted_inode(dir) && f2fs_may_encrypt(inode)) {",
          "417:    if (err)",
          "418:     goto put_error;",
          "419:   }",
          "",
          "[Removed Lines]",
          "416:    err = f2fs_inherit_context(dir, inode, page);",
          "",
          "[Added Lines]",
          "416:    err = fscrypt_inherit_context(dir, inode, page, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "536:  struct f2fs_dentry_block *dentry_blk = NULL;",
          "537:  struct f2fs_dentry_ptr d;",
          "538:  struct page *page = NULL;",
          "540:  struct qstr new_name;",
          "541:  int slots, err;",
          "544:  if (err)",
          "545:   return err;",
          "",
          "[Removed Lines]",
          "539:  struct f2fs_filename fname;",
          "543:  err = f2fs_fname_setup_filename(dir, name, 0, &fname);",
          "",
          "[Added Lines]",
          "539:  struct fscrypt_name fname;",
          "543:  err = fscrypt_setup_filename(dir, name, 0, &fname);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "639:  kunmap(dentry_page);",
          "640:  f2fs_put_page(dentry_page, 1);",
          "641: out:",
          "643:  f2fs_update_time(F2FS_I_SB(dir), REQ_TIME);",
          "644:  return err;",
          "645: }",
          "",
          "[Removed Lines]",
          "642:  f2fs_fname_free_filename(&fname);",
          "",
          "[Added Lines]",
          "642:  fscrypt_free_filename(&fname);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "781: }",
          "783: bool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,",
          "785: {",
          "786:  unsigned char d_type = DT_UNKNOWN;",
          "787:  unsigned int bit_pos;",
          "788:  struct f2fs_dir_entry *de = NULL;",
          "791:  bit_pos = ((unsigned long)ctx->pos % d->max);",
          "",
          "[Removed Lines]",
          "784:     unsigned int start_pos, struct f2fs_str *fstr)",
          "789:  struct f2fs_str de_name = FSTR_INIT(NULL, 0);",
          "",
          "[Added Lines]",
          "784:    unsigned int start_pos, struct fscrypt_str *fstr)",
          "789:  struct fscrypt_str de_name = FSTR_INIT(NULL, 0);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "821:    memcpy(de_name.name, d->filename[bit_pos], de_name.len);",
          "825:    kfree(de_name.name);",
          "826:    if (ret < 0)",
          "827:     return true;",
          "",
          "[Removed Lines]",
          "823:    ret = f2fs_fname_disk_to_usr(d->inode, &de->hash_code,",
          "824:        &de_name, fstr);",
          "",
          "[Added Lines]",
          "823:    ret = fscrypt_fname_disk_to_usr(d->inode,",
          "824:       (u32)de->hash_code, 0,",
          "825:       &de_name, fstr);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "849:  struct file_ra_state *ra = &file->f_ra;",
          "850:  unsigned int n = ((unsigned long)ctx->pos / NR_DENTRY_IN_BLOCK);",
          "851:  struct f2fs_dentry_ptr d;",
          "853:  int err = 0;",
          "855:  if (f2fs_encrypted_inode(inode)) {",
          "857:   if (err)",
          "858:    return err;",
          "862:   if (err < 0)",
          "863:    return err;",
          "864:  }",
          "",
          "[Removed Lines]",
          "852:  struct f2fs_str fstr = FSTR_INIT(NULL, 0);",
          "856:   err = f2fs_get_encryption_info(inode);",
          "860:   err = f2fs_fname_crypto_alloc_buffer(inode, F2FS_NAME_LEN,",
          "861:         &fstr);",
          "",
          "[Added Lines]",
          "853:  struct fscrypt_str fstr = FSTR_INIT(NULL, 0);",
          "857:   err = fscrypt_get_encryption_info(inode);",
          "861:   err = fscrypt_fname_alloc_buffer(inode, F2FS_NAME_LEN, &fstr);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "898:   f2fs_put_page(dentry_page, 1);",
          "899:  }",
          "900: out:",
          "902:  return err;",
          "903: }",
          "905: static int f2fs_dir_open(struct inode *inode, struct file *filp)",
          "906: {",
          "907:  if (f2fs_encrypted_inode(inode))",
          "909:  return 0;",
          "910: }",
          "",
          "[Removed Lines]",
          "901:  f2fs_fname_crypto_free_buffer(&fstr);",
          "908:   return f2fs_get_encryption_info(inode) ? -EACCES : 0;",
          "",
          "[Added Lines]",
          "901:  fscrypt_fname_free_buffer(&fstr);",
          "908:   return fscrypt_get_encryption_info(inode) ? -EACCES : 0;",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include <linux/vmalloc.h>",
          "23: #include <linux/bio.h>",
          "24: #include <linux/blkdev.h>",
          "26: #ifdef CONFIG_F2FS_CHECK_FS",
          "27: #define f2fs_bug_on(sbi, condition) BUG_ON(condition)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include <linux/fscrypto.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231: #define F2FS_IOC_WRITE_CHECKPOINT _IO(F2FS_IOCTL_MAGIC, 7)",
          "232: #define F2FS_IOC_DEFRAGMENT  _IO(F2FS_IOCTL_MAGIC, 8)",
          "",
          "[Removed Lines]",
          "234: #define F2FS_IOC_SET_ENCRYPTION_POLICY     \\",
          "235:   _IOR('f', 19, struct f2fs_encryption_policy)",
          "236: #define F2FS_IOC_GET_ENCRYPTION_PWSALT     \\",
          "237:   _IOW('f', 20, __u8[16])",
          "238: #define F2FS_IOC_GET_ENCRYPTION_POLICY     \\",
          "239:   _IOW('f', 21, struct f2fs_encryption_policy)",
          "",
          "[Added Lines]",
          "235: #define F2FS_IOC_SET_ENCRYPTION_POLICY FS_IOC_SET_ENCRYPTION_POLICY",
          "236: #define F2FS_IOC_GET_ENCRYPTION_POLICY FS_IOC_GET_ENCRYPTION_POLICY",
          "237: #define F2FS_IOC_GET_ENCRYPTION_PWSALT FS_IOC_GET_ENCRYPTION_PWSALT",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288: struct f2fs_dentry_ptr {",
          "289:  struct inode *inode;",
          "290:  const void *bitmap;",
          "",
          "[Removed Lines]",
          "269: struct f2fs_str {",
          "270:  unsigned char *name;",
          "271:  u32 len;",
          "272: };",
          "274: struct f2fs_filename {",
          "275:  const struct qstr *usr_fname;",
          "276:  struct f2fs_str disk_name;",
          "277:  f2fs_hash_t hash;",
          "278: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "279:  struct f2fs_str crypto_buf;",
          "280: #endif",
          "281: };",
          "283: #define FSTR_INIT(n, l)  { .name = n, .len = l }",
          "284: #define FSTR_TO_QSTR(f)  QSTR_INIT((f)->name, (f)->len)",
          "285: #define fname_name(p)  ((p)->disk_name.name)",
          "286: #define fname_len(p)  ((p)->disk_name.len)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "412: #define file_enc_name(inode) is_file(inode, FADVISE_ENC_NAME_BIT)",
          "413: #define file_set_enc_name(inode) set_file(inode, FADVISE_ENC_NAME_BIT)",
          "424: #define DEF_DIR_LEVEL  0",
          "426: struct f2fs_inode_info {",
          "",
          "[Removed Lines]",
          "416: #define F2FS_ENCRYPTION_MODE_INVALID  0",
          "417: #define F2FS_ENCRYPTION_MODE_AES_256_XTS 1",
          "418: #define F2FS_ENCRYPTION_MODE_AES_256_GCM 2",
          "419: #define F2FS_ENCRYPTION_MODE_AES_256_CBC 3",
          "420: #define F2FS_ENCRYPTION_MODE_AES_256_CTS 4",
          "422: #include \"f2fs_crypto.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "454: };",
          "456: static inline void get_extent_info(struct extent_info *ext,",
          "",
          "[Removed Lines]",
          "450: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "452:  struct f2fs_crypt_info *i_crypt_info;",
          "453: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1741: extern unsigned char f2fs_filetype_table[F2FS_FT_MAX];",
          "1742: void set_de_type(struct f2fs_dir_entry *, umode_t);",
          "1745:    f2fs_hash_t, int *, struct f2fs_dentry_ptr *);",
          "1746: bool f2fs_fill_dentries(struct dir_context *, struct f2fs_dentry_ptr *,",
          "1748: void do_make_empty_dir(struct inode *, struct inode *,",
          "1749:    struct f2fs_dentry_ptr *);",
          "1750: struct page *init_inode_metadata(struct inode *, struct inode *,",
          "",
          "[Removed Lines]",
          "1744: struct f2fs_dir_entry *find_target_dentry(struct f2fs_filename *,",
          "1747:    unsigned int, struct f2fs_str *);",
          "",
          "[Added Lines]",
          "1708: struct f2fs_dir_entry *find_target_dentry(struct fscrypt_name *,",
          "1711:    unsigned int, struct fscrypt_str *);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2120: int f2fs_write_inline_data(struct inode *, struct page *);",
          "2121: bool recover_inline_data(struct inode *, struct page *);",
          "2122: struct f2fs_dir_entry *find_in_inline_dir(struct inode *,",
          "2124: struct f2fs_dir_entry *f2fs_parent_inline_dir(struct inode *, struct page **);",
          "2125: int make_empty_inline_dir(struct inode *inode, struct inode *, struct page *);",
          "2126: int f2fs_add_inline_entry(struct inode *, const struct qstr *, struct inode *,",
          "",
          "[Removed Lines]",
          "2123:     struct f2fs_filename *, struct page **);",
          "",
          "[Added Lines]",
          "2087:     struct fscrypt_name *, struct page **);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2129:       struct inode *, struct inode *);",
          "2130: bool f2fs_empty_inline_dir(struct inode *);",
          "2131: int f2fs_read_inline_dir(struct file *, struct dir_context *,",
          "2133: int f2fs_inline_data_fiemap(struct inode *,",
          "2134:   struct fiemap_extent_info *, __u64, __u64);",
          "",
          "[Removed Lines]",
          "2132:       struct f2fs_str *);",
          "",
          "[Added Lines]",
          "2096:       struct fscrypt_str *);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2163: {",
          "2165:  return file_is_encrypt(inode);",
          "2169: }",
          "2171: static inline void f2fs_set_encrypted_inode(struct inode *inode)",
          "",
          "[Removed Lines]",
          "2162: static inline int f2fs_encrypted_inode(struct inode *inode)",
          "2164: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "2166: #else",
          "2167:  return 0;",
          "2168: #endif",
          "",
          "[Added Lines]",
          "2126: static inline bool f2fs_encrypted_inode(struct inode *inode)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2178: static inline bool f2fs_bio_encrypted(struct bio *bio)",
          "2179: {",
          "2185: }",
          "2187: static inline int f2fs_sb_has_crypto(struct super_block *sb)",
          "2188: {",
          "2190:  return F2FS_HAS_FEATURE(sb, F2FS_FEATURE_ENCRYPT);",
          "2194: }",
          "2196: static inline bool f2fs_may_encrypt(struct inode *inode)",
          "",
          "[Removed Lines]",
          "2180: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "2181:  return unlikely(bio->bi_private != NULL);",
          "2182: #else",
          "2183:  return false;",
          "2184: #endif",
          "2189: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "2191: #else",
          "2192:  return 0;",
          "2193: #endif",
          "",
          "[Added Lines]",
          "2140:  return bio->bi_private != NULL;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2204: #endif",
          "2205: }",
          "2288: #endif",
          "2289: #endif",
          "",
          "[Removed Lines]",
          "2208: int f2fs_is_child_context_consistent_with_parent(struct inode *,",
          "2209:        struct inode *);",
          "2210: int f2fs_inherit_context(struct inode *, struct inode *, struct page *);",
          "2211: int f2fs_process_policy(const struct f2fs_encryption_policy *, struct inode *);",
          "2212: int f2fs_get_policy(struct inode *, struct f2fs_encryption_policy *);",
          "2215: extern struct kmem_cache *f2fs_crypt_info_cachep;",
          "2216: bool f2fs_valid_contents_enc_mode(uint32_t);",
          "2217: uint32_t f2fs_validate_encryption_key_size(uint32_t, uint32_t);",
          "2218: struct f2fs_crypto_ctx *f2fs_get_crypto_ctx(struct inode *);",
          "2219: void f2fs_release_crypto_ctx(struct f2fs_crypto_ctx *);",
          "2220: struct page *f2fs_encrypt(struct inode *, struct page *);",
          "2221: int f2fs_decrypt(struct page *);",
          "2222: void f2fs_end_io_crypto_work(struct f2fs_crypto_ctx *, struct bio *);",
          "2225: void f2fs_free_encryption_info(struct inode *, struct f2fs_crypt_info *);",
          "2226: int _f2fs_get_encryption_info(struct inode *inode);",
          "2229: bool f2fs_valid_filenames_enc_mode(uint32_t);",
          "2230: u32 f2fs_fname_crypto_round_up(u32, u32);",
          "2231: unsigned f2fs_fname_encrypted_size(struct inode *, u32);",
          "2232: int f2fs_fname_crypto_alloc_buffer(struct inode *, u32, struct f2fs_str *);",
          "2233: int f2fs_fname_disk_to_usr(struct inode *, f2fs_hash_t *,",
          "2234:    const struct f2fs_str *, struct f2fs_str *);",
          "2235: int f2fs_fname_usr_to_disk(struct inode *, const struct qstr *,",
          "2236:    struct f2fs_str *);",
          "2238: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "2239: void f2fs_restore_and_release_control_page(struct page **);",
          "2240: void f2fs_restore_control_page(struct page *);",
          "2242: int __init f2fs_init_crypto(void);",
          "2243: int f2fs_crypto_initialize(void);",
          "2244: void f2fs_exit_crypto(void);",
          "2246: int f2fs_has_encryption_key(struct inode *);",
          "2248: static inline int f2fs_get_encryption_info(struct inode *inode)",
          "2249: {",
          "2250:  struct f2fs_crypt_info *ci = F2FS_I(inode)->i_crypt_info;",
          "2252:  if (!ci ||",
          "2253:   (ci->ci_keyring_key &&",
          "2254:    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
          "2255:             (1 << KEY_FLAG_REVOKED) |",
          "2256:             (1 << KEY_FLAG_DEAD)))))",
          "2257:   return _f2fs_get_encryption_info(inode);",
          "2258:  return 0;",
          "2259: }",
          "2261: void f2fs_fname_crypto_free_buffer(struct f2fs_str *);",
          "2262: int f2fs_fname_setup_filename(struct inode *, const struct qstr *,",
          "2263:     int lookup, struct f2fs_filename *);",
          "2264: void f2fs_fname_free_filename(struct f2fs_filename *);",
          "2265: #else",
          "2266: static inline void f2fs_restore_and_release_control_page(struct page **p) { }",
          "2267: static inline void f2fs_restore_control_page(struct page *p) { }",
          "2269: static inline int __init f2fs_init_crypto(void) { return 0; }",
          "2270: static inline void f2fs_exit_crypto(void) { }",
          "2272: static inline int f2fs_has_encryption_key(struct inode *i) { return 0; }",
          "2273: static inline int f2fs_get_encryption_info(struct inode *i) { return 0; }",
          "2274: static inline void f2fs_fname_crypto_free_buffer(struct f2fs_str *p) { }",
          "2276: static inline int f2fs_fname_setup_filename(struct inode *dir,",
          "2277:      const struct qstr *iname,",
          "2278:      int lookup, struct f2fs_filename *fname)",
          "2279: {",
          "2280:  memset(fname, 0, sizeof(struct f2fs_filename));",
          "2281:  fname->usr_fname = iname;",
          "2282:  fname->disk_name.name = (unsigned char *)iname->name;",
          "2283:  fname->disk_name.len = iname->len;",
          "2284:  return 0;",
          "2285: }",
          "2287: static inline void f2fs_fname_free_filename(struct f2fs_filename *fname) { }",
          "",
          "[Added Lines]",
          "2159: #ifndef CONFIG_F2FS_FS_ENCRYPTION",
          "2160: #define fscrypt_set_d_op(i)",
          "2161: #define fscrypt_get_ctx   fscrypt_notsupp_get_ctx",
          "2162: #define fscrypt_release_ctx  fscrypt_notsupp_release_ctx",
          "2163: #define fscrypt_encrypt_page  fscrypt_notsupp_encrypt_page",
          "2164: #define fscrypt_decrypt_page  fscrypt_notsupp_decrypt_page",
          "2165: #define fscrypt_decrypt_bio_pages fscrypt_notsupp_decrypt_bio_pages",
          "2166: #define fscrypt_pullback_bio_page fscrypt_notsupp_pullback_bio_page",
          "2167: #define fscrypt_restore_control_page fscrypt_notsupp_restore_control_page",
          "2168: #define fscrypt_zeroout_range  fscrypt_notsupp_zeroout_range",
          "2169: #define fscrypt_process_policy  fscrypt_notsupp_process_policy",
          "2170: #define fscrypt_get_policy  fscrypt_notsupp_get_policy",
          "2171: #define fscrypt_has_permitted_context fscrypt_notsupp_has_permitted_context",
          "2172: #define fscrypt_inherit_context  fscrypt_notsupp_inherit_context",
          "2173: #define fscrypt_get_encryption_info fscrypt_notsupp_get_encryption_info",
          "2174: #define fscrypt_put_encryption_info fscrypt_notsupp_put_encryption_info",
          "2175: #define fscrypt_setup_filename  fscrypt_notsupp_setup_filename",
          "2176: #define fscrypt_free_filename  fscrypt_notsupp_free_filename",
          "2177: #define fscrypt_fname_encrypted_size fscrypt_notsupp_fname_encrypted_size",
          "2178: #define fscrypt_fname_alloc_buffer fscrypt_notsupp_fname_alloc_buffer",
          "2179: #define fscrypt_fname_free_buffer fscrypt_notsupp_fname_free_buffer",
          "2180: #define fscrypt_fname_disk_to_usr fscrypt_notsupp_fname_disk_to_usr",
          "2181: #define fscrypt_fname_usr_to_disk fscrypt_notsupp_fname_usr_to_disk",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs_crypto.h||fs/f2fs/f2fs_crypto.h": [
          "File: fs/f2fs/f2fs_crypto.h -> fs/f2fs/f2fs_crypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/file.c||fs/f2fs/file.c": [
          "File: fs/f2fs/file.c -> fs/f2fs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "421:  int err;",
          "423:  if (f2fs_encrypted_inode(inode)) {",
          "425:   if (err)",
          "426:    return 0;",
          "427:   if (!f2fs_encrypted_inode(inode))",
          "",
          "[Removed Lines]",
          "424:   err = f2fs_get_encryption_info(inode);",
          "",
          "[Added Lines]",
          "424:   err = fscrypt_get_encryption_info(inode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "443:  int ret = generic_file_open(inode, filp);",
          "445:  if (!ret && f2fs_encrypted_inode(inode)) {",
          "447:   if (ret)",
          "448:    return -EACCES;",
          "450:    return -ENOKEY;",
          "451:  }",
          "452:  return ret;",
          "",
          "[Removed Lines]",
          "446:   ret = f2fs_get_encryption_info(inode);",
          "449:   if (!f2fs_encrypted_inode(inode))",
          "",
          "[Added Lines]",
          "446:   ret = fscrypt_get_encryption_info(inode);",
          "449:   if (!fscrypt_has_encryption_key(inode))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "526: truncate_out:",
          "527:  f2fs_wait_on_page_writeback(page, DATA, true);",
          "528:  zero_user(page, offset, PAGE_CACHE_SIZE - offset);",
          "530:   set_page_dirty(page);",
          "531:  f2fs_put_page(page, 1);",
          "532:  return 0;",
          "",
          "[Removed Lines]",
          "529:  if (!cache_only || !f2fs_encrypted_inode(inode) || !S_ISREG(inode->i_mode))",
          "",
          "[Added Lines]",
          "529:  if (!cache_only || !f2fs_encrypted_inode(inode) ||",
          "530:      !S_ISREG(inode->i_mode))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "675:  if (attr->ia_valid & ATTR_SIZE) {",
          "676:   if (f2fs_encrypted_inode(inode) &&",
          "678:    return -EACCES;",
          "680:   if (attr->ia_size <= i_size_read(inode)) {",
          "",
          "[Removed Lines]",
          "677:     f2fs_get_encryption_info(inode))",
          "",
          "[Added Lines]",
          "678:     fscrypt_get_encryption_info(inode))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1530: static int f2fs_ioc_set_encryption_policy(struct file *filp, unsigned long arg)",
          "1531: {",
          "1534:  struct inode *inode = file_inode(filp);",
          "1538:   return -EFAULT;",
          "1540:  f2fs_update_time(F2FS_I_SB(inode), REQ_TIME);",
          "1545: }",
          "1547: static int f2fs_ioc_get_encryption_policy(struct file *filp, unsigned long arg)",
          "1548: {",
          "1551:  struct inode *inode = file_inode(filp);",
          "1552:  int err;",
          "1555:  if (err)",
          "1556:   return err;",
          "1560:   return -EFAULT;",
          "1561:  return 0;",
          "1565: }",
          "1567: static int f2fs_ioc_get_encryption_pwsalt(struct file *filp, unsigned long arg)",
          "",
          "[Removed Lines]",
          "1532: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "1533:  struct f2fs_encryption_policy policy;",
          "1536:  if (copy_from_user(&policy, (struct f2fs_encryption_policy __user *)arg,",
          "1537:     sizeof(policy)))",
          "1541:  return f2fs_process_policy(&policy, inode);",
          "1542: #else",
          "1543:  return -EOPNOTSUPP;",
          "1544: #endif",
          "1549: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "1550:  struct f2fs_encryption_policy policy;",
          "1554:  err = f2fs_get_policy(inode, &policy);",
          "1558:  if (copy_to_user((struct f2fs_encryption_policy __user *)arg, &policy,",
          "1559:        sizeof(policy)))",
          "1562: #else",
          "1563:  return -EOPNOTSUPP;",
          "1564: #endif",
          "",
          "[Added Lines]",
          "1533:  struct fscrypt_policy policy;",
          "1536:  if (copy_from_user(&policy, (struct fscrypt_policy __user *)arg,",
          "1537:        sizeof(policy)))",
          "1541:  return fscrypt_process_policy(inode, &policy);",
          "1546:  struct fscrypt_policy policy;",
          "1550:  err = fscrypt_get_policy(inode, &policy);",
          "1554:  if (copy_to_user((struct fscrypt_policy __user *)arg, &policy, sizeof(policy)))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1873:  ssize_t ret;",
          "1875:  if (f2fs_encrypted_inode(inode) &&",
          "1878:   return -EACCES;",
          "1880:  inode_lock(inode);",
          "",
          "[Removed Lines]",
          "1876:     !f2fs_has_encryption_key(inode) &&",
          "1877:     f2fs_get_encryption_info(inode))",
          "",
          "[Added Lines]",
          "1868:     !fscrypt_has_encryption_key(inode) &&",
          "1869:     fscrypt_get_encryption_info(inode))",
          "",
          "---------------"
        ],
        "fs/f2fs/inline.c||fs/f2fs/inline.c": [
          "File: fs/f2fs/inline.c -> fs/f2fs/inline.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277: }",
          "279: struct f2fs_dir_entry *find_in_inline_dir(struct inode *dir,",
          "281: {",
          "282:  struct f2fs_sb_info *sbi = F2FS_SB(dir->i_sb);",
          "283:  struct f2fs_inline_dentry *inline_dentry;",
          "",
          "[Removed Lines]",
          "280:    struct f2fs_filename *fname, struct page **res_page)",
          "",
          "[Added Lines]",
          "280:    struct fscrypt_name *fname, struct page **res_page)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "535: }",
          "537: int f2fs_read_inline_dir(struct file *file, struct dir_context *ctx,",
          "539: {",
          "540:  struct inode *inode = file_inode(file);",
          "541:  struct f2fs_inline_dentry *inline_dentry = NULL;",
          "",
          "[Removed Lines]",
          "538:     struct f2fs_str *fstr)",
          "",
          "[Added Lines]",
          "538:     struct fscrypt_str *fstr)",
          "",
          "---------------"
        ],
        "fs/f2fs/inode.c||fs/f2fs/inode.c": [
          "File: fs/f2fs/inode.c -> fs/f2fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "389:   }",
          "390:  }",
          "391: out_clear:",
          "396:  clear_inode(inode);",
          "397: }",
          "",
          "[Removed Lines]",
          "392: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "393:  if (fi->i_crypt_info)",
          "394:   f2fs_free_encryption_info(inode, fi->i_crypt_info);",
          "395: #endif",
          "",
          "[Added Lines]",
          "392:  fscrypt_put_encryption_info(inode, NULL);",
          "",
          "---------------"
        ],
        "fs/f2fs/namei.c||fs/f2fs/namei.c": [
          "File: fs/f2fs/namei.c -> fs/f2fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:  int err;",
          "171:  if (f2fs_encrypted_inode(dir) &&",
          "173:   return -EPERM;",
          "175:  f2fs_balance_fs(sbi, true);",
          "",
          "[Removed Lines]",
          "172:   !f2fs_is_child_context_consistent_with_parent(dir, inode))",
          "",
          "[Added Lines]",
          "172:    !fscrypt_has_permitted_context(dir, inode))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "352:  struct f2fs_sb_info *sbi = F2FS_I_SB(dir);",
          "353:  struct inode *inode;",
          "354:  size_t len = strlen(symname);",
          "357:  int err;",
          "359:  if (f2fs_encrypted_inode(dir)) {",
          "361:   if (err)",
          "362:    return err;",
          "365:    return -EPERM;",
          "369:  }",
          "371:  if (disk_link.len > dir->i_sb->s_blocksize)",
          "",
          "[Removed Lines]",
          "355:  struct f2fs_str disk_link = FSTR_INIT((char *)symname, len + 1);",
          "356:  struct f2fs_encrypted_symlink_data *sd = NULL;",
          "360:   err = f2fs_get_encryption_info(dir);",
          "364:   if (!f2fs_encrypted_inode(dir))",
          "367:   disk_link.len = (f2fs_fname_encrypted_size(dir, len) +",
          "368:     sizeof(struct f2fs_encrypted_symlink_data));",
          "",
          "[Added Lines]",
          "355:  struct fscrypt_str disk_link = FSTR_INIT((char *)symname, len + 1);",
          "356:  struct fscrypt_symlink_data *sd = NULL;",
          "360:   err = fscrypt_get_encryption_info(dir);",
          "364:   if (!fscrypt_has_encryption_key(dir))",
          "367:   disk_link.len = (fscrypt_fname_encrypted_size(dir, len) +",
          "368:     sizeof(struct fscrypt_symlink_data));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "394:  if (f2fs_encrypted_inode(inode)) {",
          "395:   struct qstr istr = QSTR_INIT(symname, len);",
          "398:   sd = kzalloc(disk_link.len, GFP_NOFS);",
          "399:   if (!sd) {",
          "",
          "[Removed Lines]",
          "396:   struct f2fs_str ostr;",
          "",
          "[Added Lines]",
          "396:   struct fscrypt_str ostr;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401:    goto err_out;",
          "402:   }",
          "405:   if (err)",
          "406:    goto err_out;",
          "409:    err = -EPERM;",
          "410:    goto err_out;",
          "411:   }",
          "413:   ostr.name = sd->encrypted_path;",
          "414:   ostr.len = disk_link.len;",
          "416:   if (err < 0)",
          "417:    goto err_out;",
          "",
          "[Removed Lines]",
          "404:   err = f2fs_get_encryption_info(inode);",
          "408:   if (!f2fs_encrypted_inode(inode)) {",
          "415:   err = f2fs_fname_usr_to_disk(inode, &istr, &ostr);",
          "",
          "[Added Lines]",
          "404:   err = fscrypt_get_encryption_info(inode);",
          "408:   if (!fscrypt_has_encryption_key(inode)) {",
          "415:   err = fscrypt_fname_usr_to_disk(inode, &istr, &ostr);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "593: static int f2fs_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)",
          "594: {",
          "595:  if (f2fs_encrypted_inode(dir)) {",
          "597:   if (err)",
          "598:    return err;",
          "599:  }",
          "",
          "[Removed Lines]",
          "596:   int err = f2fs_get_encryption_info(dir);",
          "",
          "[Added Lines]",
          "596:   int err = fscrypt_get_encryption_info(dir);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "623:  int err = -ENOENT;",
          "625:  if ((old_dir != new_dir) && f2fs_encrypted_inode(new_dir) &&",
          "628:   err = -EPERM;",
          "629:   goto out;",
          "630:  }",
          "",
          "[Removed Lines]",
          "626:   !f2fs_is_child_context_consistent_with_parent(new_dir,",
          "627:        old_inode)) {",
          "",
          "[Added Lines]",
          "626:    !fscrypt_has_permitted_context(new_dir, old_inode)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "804:  int err = -ENOENT;",
          "806:  if ((f2fs_encrypted_inode(old_dir) || f2fs_encrypted_inode(new_dir)) &&",
          "812:   return -EPERM;",
          "814:  old_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);",
          "",
          "[Removed Lines]",
          "807:   (old_dir != new_dir) &&",
          "808:   (!f2fs_is_child_context_consistent_with_parent(new_dir,",
          "809:         old_inode) ||",
          "810:   !f2fs_is_child_context_consistent_with_parent(old_dir,",
          "811:         new_inode)))",
          "",
          "[Added Lines]",
          "806:    (old_dir != new_dir) &&",
          "807:    (!fscrypt_has_permitted_context(new_dir, old_inode) ||",
          "808:     !fscrypt_has_permitted_context(old_dir, new_inode)))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "970:  return f2fs_rename(old_dir, old_dentry, new_dir, new_dentry, flags);",
          "971: }",
          "974: static const char *f2fs_encrypted_get_link(struct dentry *dentry,",
          "975:         struct inode *inode,",
          "976:         struct delayed_call *done)",
          "977: {",
          "978:  struct page *cpage = NULL;",
          "979:  char *caddr, *paddr = NULL;",
          "983:  loff_t size = min_t(loff_t, i_size_read(inode), PAGE_SIZE - 1);",
          "984:  u32 max_size = inode->i_sb->s_blocksize;",
          "985:  int res;",
          "",
          "[Removed Lines]",
          "973: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "980:  struct f2fs_str cstr = FSTR_INIT(NULL, 0);",
          "981:  struct f2fs_str pstr = FSTR_INIT(NULL, 0);",
          "982:  struct f2fs_encrypted_symlink_data *sd;",
          "",
          "[Added Lines]",
          "976:  struct fscrypt_str cstr = FSTR_INIT(NULL, 0);",
          "977:  struct fscrypt_str pstr = FSTR_INIT(NULL, 0);",
          "978:  struct fscrypt_symlink_data *sd;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "987:  if (!dentry)",
          "988:   return ERR_PTR(-ECHILD);",
          "991:  if (res)",
          "992:   return ERR_PTR(res);",
          "",
          "[Removed Lines]",
          "990:  res = f2fs_get_encryption_info(inode);",
          "",
          "[Added Lines]",
          "986:  res = fscrypt_get_encryption_info(inode);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "998:  caddr[size] = 0;",
          "1002:  cstr.name = sd->encrypted_path;",
          "1003:  cstr.len = le16_to_cpu(sd->len);",
          "",
          "[Removed Lines]",
          "1001:  sd = (struct f2fs_encrypted_symlink_data *)caddr;",
          "",
          "[Added Lines]",
          "997:  sd = (struct fscrypt_symlink_data *)caddr;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1014:   goto errout;",
          "1015:  }",
          "1020:   res = -EIO;",
          "1021:   goto errout;",
          "1022:  }",
          "1024:  if (res)",
          "1025:   goto errout;",
          "1028:  if (res < 0)",
          "1029:   goto errout;",
          "",
          "[Removed Lines]",
          "1017:  if ((cstr.len + sizeof(struct f2fs_encrypted_symlink_data) - 1) >",
          "1018:         max_size) {",
          "1023:  res = f2fs_fname_crypto_alloc_buffer(inode, cstr.len, &pstr);",
          "1027:  res = f2fs_fname_disk_to_usr(inode, NULL, &cstr, &pstr);",
          "",
          "[Added Lines]",
          "1013:  if ((cstr.len + sizeof(struct fscrypt_symlink_data) - 1) > max_size) {",
          "1018:  res = fscrypt_fname_alloc_buffer(inode, cstr.len, &pstr);",
          "1022:  res = fscrypt_fname_disk_to_usr(inode, 0, 0, &cstr, &pstr);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1037:  set_delayed_call(done, kfree_link, paddr);",
          "1038:  return paddr;",
          "1039: errout:",
          "1041:  page_cache_release(cpage);",
          "1042:  return ERR_PTR(res);",
          "1043: }",
          "",
          "[Removed Lines]",
          "1040:  f2fs_fname_crypto_free_buffer(&pstr);",
          "",
          "[Added Lines]",
          "1035:  fscrypt_fname_free_buffer(&pstr);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1054:  .removexattr = generic_removexattr,",
          "1055: #endif",
          "1056: };",
          "1059: const struct inode_operations f2fs_dir_inode_operations = {",
          "1060:  .create  = f2fs_create,",
          "",
          "[Removed Lines]",
          "1057: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "472:  fi->i_dir_level = F2FS_SB(sb)->dir_level;",
          "477:  return &fi->vfs_inode;",
          "478: }",
          "",
          "[Removed Lines]",
          "474: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "475:  fi->i_crypt_info = NULL;",
          "476: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "508:    sb_end_intwrite(inode->i_sb);",
          "515:    spin_lock(&inode->i_lock);",
          "516:    atomic_dec(&inode->i_count);",
          "517:   }",
          "",
          "[Removed Lines]",
          "510: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "511:    if (F2FS_I(inode)->i_crypt_info)",
          "512:     f2fs_free_encryption_info(inode,",
          "513:      F2FS_I(inode)->i_crypt_info);",
          "514: #endif",
          "",
          "[Added Lines]",
          "506:    fscrypt_put_encryption_info(inode, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "891:  .remount_fs = f2fs_remount,",
          "892: };",
          "894: static struct inode *f2fs_nfs_get_inode(struct super_block *sb,",
          "895:   u64 ino, u32 generation)",
          "896: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "886: #ifdef CONFIG_F2FS_FS_ENCRYPTION",
          "887: static int f2fs_get_context(struct inode *inode, void *ctx, size_t len)",
          "888: {",
          "889:  return f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,",
          "890:     F2FS_XATTR_NAME_ENCRYPTION_CONTEXT,",
          "891:     ctx, len, NULL);",
          "892: }",
          "894: static int f2fs_set_context(struct inode *inode, const void *ctx, size_t len,",
          "895:        void *fs_data)",
          "896: {",
          "897:  return f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,",
          "898:     F2FS_XATTR_NAME_ENCRYPTION_CONTEXT,",
          "899:     ctx, len, fs_data, XATTR_CREATE);",
          "900: }",
          "902: static unsigned f2fs_max_namelen(struct inode *inode)",
          "903: {",
          "904:  return S_ISLNK(inode->i_mode) ?",
          "905:    inode->i_sb->s_blocksize : F2FS_NAME_LEN;",
          "906: }",
          "908: static struct fscrypt_operations f2fs_cryptops = {",
          "909:  .get_context = f2fs_get_context,",
          "910:  .set_context = f2fs_set_context,",
          "911:  .is_encrypted = f2fs_encrypted_inode,",
          "912:  .empty_dir = f2fs_empty_dir,",
          "913:  .max_namelen = f2fs_max_namelen,",
          "914: };",
          "915: #else",
          "916: static struct fscrypt_operations f2fs_cryptops = {",
          "917:  .is_encrypted = f2fs_encrypted_inode,",
          "918: };",
          "919: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1314:  get_random_bytes(&sbi->s_next_generation, sizeof(u32));",
          "1316:  sb->s_op = &f2fs_sops;",
          "1317:  sb->s_xattr = f2fs_xattr_handlers;",
          "1318:  sb->s_export_op = &f2fs_export_ops;",
          "1319:  sb->s_magic = F2FS_SUPER_MAGIC;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1344:  sb->s_cop = &f2fs_cryptops;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1619:   err = -ENOMEM;",
          "1620:   goto free_extent_cache;",
          "1621:  }",
          "1626:  err = register_shrinker(&f2fs_shrinker_info);",
          "1627:  if (err)",
          "1630:  err = register_filesystem(&f2fs_fs_type);",
          "1631:  if (err)",
          "",
          "[Removed Lines]",
          "1622:  err = f2fs_init_crypto();",
          "1623:  if (err)",
          "1624:   goto free_kset;",
          "1628:   goto free_crypto;",
          "",
          "[Added Lines]",
          "1652:   goto free_kset;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1640:  unregister_filesystem(&f2fs_fs_type);",
          "1641: free_shrinker:",
          "1642:  unregister_shrinker(&f2fs_shrinker_info);",
          "1645: free_kset:",
          "1646:  kset_unregister(f2fs_kset);",
          "1647: free_extent_cache:",
          "",
          "[Removed Lines]",
          "1643: free_crypto:",
          "1644:  f2fs_exit_crypto();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1664:  f2fs_destroy_root_stats();",
          "1665:  unregister_shrinker(&f2fs_shrinker_info);",
          "1666:  unregister_filesystem(&f2fs_fs_type);",
          "1668:  destroy_extent_cache();",
          "1669:  destroy_checkpoint_caches();",
          "1670:  destroy_segment_manager_caches();",
          "",
          "[Removed Lines]",
          "1667:  f2fs_exit_crypto();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/dcache.h||include/linux/dcache.h": [
          "File: include/linux/dcache.h -> include/linux/dcache.h"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: struct seq_file;",
          "54: struct workqueue_struct;",
          "55: struct iov_iter;",
          "57: extern void __init inode_init(void);",
          "58: extern void __init inode_init_early(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: struct fscrypt_info;",
          "57: struct fscrypt_operations;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "678:  struct hlist_head i_fsnotify_marks;",
          "679: #endif",
          "682: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "683: #if IS_ENABLED(CONFIG_FS_ENCRYPTION)",
          "684:  struct fscrypt_info *i_crypt_info;",
          "685: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1323: #endif",
          "1324:  const struct xattr_handler **s_xattr;",
          "1328:  struct block_device *s_bdev;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1332:  const struct fscrypt_operations *s_cop;",
          "",
          "---------------"
        ],
        "include/linux/fscrypto.h||include/linux/fscrypto.h": [
          "File: include/linux/fscrypto.h -> include/linux/fscrypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #ifndef _LINUX_FSCRYPTO_H",
          "11: #define _LINUX_FSCRYPTO_H",
          "13: #include <linux/key.h>",
          "14: #include <linux/fs.h>",
          "15: #include <linux/mm.h>",
          "16: #include <linux/bio.h>",
          "17: #include <linux/dcache.h>",
          "18: #include <uapi/linux/fs.h>",
          "20: #define FS_KEY_DERIVATION_NONCE_SIZE  16",
          "21: #define FS_ENCRYPTION_CONTEXT_FORMAT_V1  1",
          "23: #define FS_POLICY_FLAGS_PAD_4  0x00",
          "24: #define FS_POLICY_FLAGS_PAD_8  0x01",
          "25: #define FS_POLICY_FLAGS_PAD_16  0x02",
          "26: #define FS_POLICY_FLAGS_PAD_32  0x03",
          "27: #define FS_POLICY_FLAGS_PAD_MASK 0x03",
          "28: #define FS_POLICY_FLAGS_VALID  0x03",
          "31: #define FS_ENCRYPTION_MODE_INVALID  0",
          "32: #define FS_ENCRYPTION_MODE_AES_256_XTS  1",
          "33: #define FS_ENCRYPTION_MODE_AES_256_GCM  2",
          "34: #define FS_ENCRYPTION_MODE_AES_256_CBC  3",
          "35: #define FS_ENCRYPTION_MODE_AES_256_CTS  4",
          "48: struct fscrypt_context {",
          "49:  u8 format;",
          "50:  u8 contents_encryption_mode;",
          "51:  u8 filenames_encryption_mode;",
          "52:  u8 flags;",
          "53:  u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];",
          "54:  u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];",
          "55: } __packed;",
          "58: #define FS_XTS_TWEAK_SIZE  16",
          "59: #define FS_AES_128_ECB_KEY_SIZE  16",
          "60: #define FS_AES_256_GCM_KEY_SIZE  32",
          "61: #define FS_AES_256_CBC_KEY_SIZE  32",
          "62: #define FS_AES_256_CTS_KEY_SIZE  32",
          "63: #define FS_AES_256_XTS_KEY_SIZE  64",
          "64: #define FS_MAX_KEY_SIZE   64",
          "66: #define FS_KEY_DESC_PREFIX  \"fscrypt:\"",
          "67: #define FS_KEY_DESC_PREFIX_SIZE  8",
          "70: struct fscrypt_key {",
          "71:  u32 mode;",
          "72:  u8 raw[FS_MAX_KEY_SIZE];",
          "73:  u32 size;",
          "74: } __packed;",
          "76: struct fscrypt_info {",
          "77:  u8 ci_data_mode;",
          "78:  u8 ci_filename_mode;",
          "79:  u8 ci_flags;",
          "80:  struct crypto_ablkcipher *ci_ctfm;",
          "81:  struct key *ci_keyring_key;",
          "82:  u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];",
          "83: };",
          "85: #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL  0x00000001",
          "86: #define FS_WRITE_PATH_FL   0x00000002",
          "88: struct fscrypt_ctx {",
          "89:  union {",
          "90:   struct {",
          "93:   } w;",
          "94:   struct {",
          "95:    struct bio *bio;",
          "96:    struct work_struct work;",
          "97:   } r;",
          "99:  };",
          "102: };",
          "104: struct fscrypt_completion_result {",
          "105:  struct completion completion;",
          "106:  int res;",
          "107: };",
          "109: #define DECLARE_FS_COMPLETION_RESULT(ecr) \\",
          "110:  struct fscrypt_completion_result ecr = { \\",
          "111:   COMPLETION_INITIALIZER((ecr).completion), 0 }",
          "113: static inline int fscrypt_key_size(int mode)",
          "114: {",
          "115:  switch (mode) {",
          "116:  case FS_ENCRYPTION_MODE_AES_256_XTS:",
          "117:   return FS_AES_256_XTS_KEY_SIZE;",
          "118:  case FS_ENCRYPTION_MODE_AES_256_GCM:",
          "119:   return FS_AES_256_GCM_KEY_SIZE;",
          "120:  case FS_ENCRYPTION_MODE_AES_256_CBC:",
          "121:   return FS_AES_256_CBC_KEY_SIZE;",
          "122:  case FS_ENCRYPTION_MODE_AES_256_CTS:",
          "123:   return FS_AES_256_CTS_KEY_SIZE;",
          "124:  default:",
          "125:   BUG();",
          "126:  }",
          "127:  return 0;",
          "128: }",
          "130: #define FS_FNAME_NUM_SCATTER_ENTRIES 4",
          "131: #define FS_CRYPTO_BLOCK_SIZE  16",
          "132: #define FS_FNAME_CRYPTO_DIGEST_SIZE 32",
          "138: struct fscrypt_symlink_data {",
          "139:  __le16 len;",
          "140:  char encrypted_path[1];",
          "141: } __packed;",
          "147: static inline u32 fscrypt_symlink_data_len(u32 l)",
          "148: {",
          "149:  if (l < FS_CRYPTO_BLOCK_SIZE)",
          "150:   l = FS_CRYPTO_BLOCK_SIZE;",
          "151:  return (l + sizeof(struct fscrypt_symlink_data) - 1);",
          "152: }",
          "154: struct fscrypt_str {",
          "155:  unsigned char *name;",
          "156:  u32 len;",
          "157: };",
          "159: struct fscrypt_name {",
          "160:  const struct qstr *usr_fname;",
          "161:  struct fscrypt_str disk_name;",
          "162:  u32 hash;",
          "163:  u32 minor_hash;",
          "164:  struct fscrypt_str crypto_buf;",
          "165: };",
          "167: #define FSTR_INIT(n, l)  { .name = n, .len = l }",
          "168: #define FSTR_TO_QSTR(f)  QSTR_INIT((f)->name, (f)->len)",
          "169: #define fname_name(p)  ((p)->disk_name.name)",
          "170: #define fname_len(p)  ((p)->disk_name.len)",
          "175: struct fscrypt_operations {",
          "176:  int (*get_context)(struct inode *, void *, size_t);",
          "177:  int (*prepare_context)(struct inode *);",
          "178:  int (*set_context)(struct inode *, const void *, size_t, void *);",
          "179:  int (*dummy_context)(struct inode *);",
          "180:  bool (*is_encrypted)(struct inode *);",
          "181:  bool (*empty_dir)(struct inode *);",
          "182:  unsigned (*max_namelen)(struct inode *);",
          "183: };",
          "185: static inline bool fscrypt_dummy_context_enabled(struct inode *inode)",
          "186: {",
          "187:  if (inode->i_sb->s_cop->dummy_context &&",
          "188:     inode->i_sb->s_cop->dummy_context(inode))",
          "189:   return true;",
          "190:  return false;",
          "191: }",
          "193: static inline bool fscrypt_valid_contents_enc_mode(u32 mode)",
          "194: {",
          "195:  return (mode == FS_ENCRYPTION_MODE_AES_256_XTS);",
          "196: }",
          "198: static inline bool fscrypt_valid_filenames_enc_mode(u32 mode)",
          "199: {",
          "200:  return (mode == FS_ENCRYPTION_MODE_AES_256_CTS);",
          "201: }",
          "203: static inline u32 fscrypt_validate_encryption_key_size(u32 mode, u32 size)",
          "204: {",
          "205:  if (size == fscrypt_key_size(mode))",
          "206:   return size;",
          "207:  return 0;",
          "208: }",
          "210: static inline bool fscrypt_is_dot_dotdot(const struct qstr *str)",
          "211: {",
          "212:  if (str->len == 1 && str->name[0] == '.')",
          "213:   return true;",
          "215:  if (str->len == 2 && str->name[0] == '.' && str->name[1] == '.')",
          "216:   return true;",
          "218:  return false;",
          "219: }",
          "221: static inline struct page *fscrypt_control_page(struct page *page)",
          "222: {",
          "223: #if IS_ENABLED(CONFIG_FS_ENCRYPTION)",
          "224:  return ((struct fscrypt_ctx *)page_private(page))->w.control_page;",
          "225: #else",
          "226:  WARN_ON_ONCE(1);",
          "227:  return ERR_PTR(-EINVAL);",
          "228: #endif",
          "229: }",
          "231: static inline int fscrypt_has_encryption_key(struct inode *inode)",
          "232: {",
          "233: #if IS_ENABLED(CONFIG_FS_ENCRYPTION)",
          "234:  return (inode->i_crypt_info != NULL);",
          "235: #else",
          "236:  return 0;",
          "237: #endif",
          "238: }",
          "240: static inline void fscrypt_set_encrypted_dentry(struct dentry *dentry)",
          "241: {",
          "242: #if IS_ENABLED(CONFIG_FS_ENCRYPTION)",
          "243:  spin_lock(&dentry->d_lock);",
          "244:  dentry->d_flags |= DCACHE_ENCRYPTED_WITH_KEY;",
          "245:  spin_unlock(&dentry->d_lock);",
          "246: #endif",
          "247: }",
          "249: #if IS_ENABLED(CONFIG_FS_ENCRYPTION)",
          "250: extern const struct dentry_operations fscrypt_d_ops;",
          "251: #endif",
          "253: static inline void fscrypt_set_d_op(struct dentry *dentry)",
          "254: {",
          "255: #if IS_ENABLED(CONFIG_FS_ENCRYPTION)",
          "256:  d_set_d_op(dentry, &fscrypt_d_ops);",
          "257: #endif",
          "258: }",
          "260: #if IS_ENABLED(CONFIG_FS_ENCRYPTION)",
          "262: extern struct kmem_cache *fscrypt_info_cachep;",
          "263: int fscrypt_initialize(void);",
          "265: extern struct fscrypt_ctx *fscrypt_get_ctx(struct inode *);",
          "266: extern void fscrypt_release_ctx(struct fscrypt_ctx *);",
          "267: extern struct page *fscrypt_encrypt_page(struct inode *, struct page *);",
          "268: extern int fscrypt_decrypt_page(struct page *);",
          "269: extern void fscrypt_decrypt_bio_pages(struct fscrypt_ctx *, struct bio *);",
          "270: extern void fscrypt_pullback_bio_page(struct page **, bool);",
          "271: extern void fscrypt_restore_control_page(struct page *);",
          "272: extern int fscrypt_zeroout_range(struct inode *, pgoff_t, sector_t,",
          "273:       unsigned int);",
          "275: extern int fscrypt_process_policy(struct inode *,",
          "276:      const struct fscrypt_policy *);",
          "277: extern int fscrypt_get_policy(struct inode *, struct fscrypt_policy *);",
          "278: extern int fscrypt_has_permitted_context(struct inode *, struct inode *);",
          "279: extern int fscrypt_inherit_context(struct inode *, struct inode *,",
          "280:      void *, bool);",
          "282: extern int get_crypt_info(struct inode *);",
          "283: extern int fscrypt_get_encryption_info(struct inode *);",
          "284: extern void fscrypt_put_encryption_info(struct inode *, struct fscrypt_info *);",
          "287: extern int fscrypt_setup_filename(struct inode *, const struct qstr *,",
          "288:     int lookup, struct fscrypt_name *);",
          "289: extern void fscrypt_free_filename(struct fscrypt_name *);",
          "290: extern u32 fscrypt_fname_encrypted_size(struct inode *, u32);",
          "291: extern int fscrypt_fname_alloc_buffer(struct inode *, u32,",
          "292:     struct fscrypt_str *);",
          "293: extern void fscrypt_fname_free_buffer(struct fscrypt_str *);",
          "294: extern int fscrypt_fname_disk_to_usr(struct inode *, u32, u32,",
          "295:    const struct fscrypt_str *, struct fscrypt_str *);",
          "296: extern int fscrypt_fname_usr_to_disk(struct inode *, const struct qstr *,",
          "297:    struct fscrypt_str *);",
          "298: #endif",
          "301: static inline struct fscrypt_ctx *fscrypt_notsupp_get_ctx(struct inode *i)",
          "302: {",
          "303:  return ERR_PTR(-EOPNOTSUPP);",
          "304: }",
          "306: static inline void fscrypt_notsupp_release_ctx(struct fscrypt_ctx *c)",
          "307: {",
          "308:  return;",
          "309: }",
          "311: static inline struct page *fscrypt_notsupp_encrypt_page(struct inode *i,",
          "312:       struct page *p)",
          "313: {",
          "314:  return ERR_PTR(-EOPNOTSUPP);",
          "315: }",
          "317: static inline int fscrypt_notsupp_decrypt_page(struct page *p)",
          "318: {",
          "319:  return -EOPNOTSUPP;",
          "320: }",
          "322: static inline void fscrypt_notsupp_decrypt_bio_pages(struct fscrypt_ctx *c,",
          "323:       struct bio *b)",
          "324: {",
          "325:  return;",
          "326: }",
          "328: static inline void fscrypt_notsupp_pullback_bio_page(struct page **p, bool b)",
          "329: {",
          "330:  return;",
          "331: }",
          "333: static inline void fscrypt_notsupp_restore_control_page(struct page *p)",
          "334: {",
          "335:  return;",
          "336: }",
          "338: static inline int fscrypt_notsupp_zeroout_range(struct inode *i, pgoff_t p,",
          "339:      sector_t s, unsigned int f)",
          "340: {",
          "341:  return -EOPNOTSUPP;",
          "342: }",
          "345: static inline int fscrypt_notsupp_process_policy(struct inode *i,",
          "346:     const struct fscrypt_policy *p)",
          "347: {",
          "348:  return -EOPNOTSUPP;",
          "349: }",
          "351: static inline int fscrypt_notsupp_get_policy(struct inode *i,",
          "352:     struct fscrypt_policy *p)",
          "353: {",
          "354:  return -EOPNOTSUPP;",
          "355: }",
          "357: static inline int fscrypt_notsupp_has_permitted_context(struct inode *p,",
          "358:     struct inode *i)",
          "359: {",
          "360:  return 0;",
          "361: }",
          "363: static inline int fscrypt_notsupp_inherit_context(struct inode *p,",
          "364:     struct inode *i, void *v, bool b)",
          "365: {",
          "366:  return -EOPNOTSUPP;",
          "367: }",
          "370: static inline int fscrypt_notsupp_get_encryption_info(struct inode *i)",
          "371: {",
          "372:  return -EOPNOTSUPP;",
          "373: }",
          "375: static inline void fscrypt_notsupp_put_encryption_info(struct inode *i,",
          "376:      struct fscrypt_info *f)",
          "377: {",
          "378:  return;",
          "379: }",
          "382: static inline int fscrypt_notsupp_setup_filename(struct inode *dir,",
          "383:    const struct qstr *iname,",
          "384:    int lookup, struct fscrypt_name *fname)",
          "385: {",
          "386:  if (dir->i_sb->s_cop->is_encrypted(dir))",
          "387:   return -EOPNOTSUPP;",
          "389:  memset(fname, 0, sizeof(struct fscrypt_name));",
          "390:  fname->usr_fname = iname;",
          "391:  fname->disk_name.name = (unsigned char *)iname->name;",
          "392:  fname->disk_name.len = iname->len;",
          "393:  return 0;",
          "394: }",
          "396: static inline void fscrypt_notsupp_free_filename(struct fscrypt_name *fname)",
          "397: {",
          "398:  return;",
          "399: }",
          "401: static inline u32 fscrypt_notsupp_fname_encrypted_size(struct inode *i, u32 s)",
          "402: {",
          "404:  WARN_ON(1);",
          "405:  return 0;",
          "406: }",
          "408: static inline int fscrypt_notsupp_fname_alloc_buffer(struct inode *inode,",
          "409:     u32 ilen, struct fscrypt_str *crypto_str)",
          "410: {",
          "411:  return -EOPNOTSUPP;",
          "412: }",
          "414: static inline void fscrypt_notsupp_fname_free_buffer(struct fscrypt_str *c)",
          "415: {",
          "416:  return;",
          "417: }",
          "419: static inline int fscrypt_notsupp_fname_disk_to_usr(struct inode *inode,",
          "420:    u32 hash, u32 minor_hash,",
          "421:    const struct fscrypt_str *iname,",
          "422:    struct fscrypt_str *oname)",
          "423: {",
          "424:  return -EOPNOTSUPP;",
          "425: }",
          "427: static inline int fscrypt_notsupp_fname_usr_to_disk(struct inode *inode,",
          "428:    const struct qstr *iname,",
          "429:    struct fscrypt_str *oname)",
          "430: {",
          "431:  return -EOPNOTSUPP;",
          "432: }",
          "",
          "---------------"
        ],
        "include/uapi/linux/fs.h||include/uapi/linux/fs.h": [
          "File: include/uapi/linux/fs.h -> include/uapi/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "246: #define FS_IOC_FSGETXATTR  _IOR ('X', 31, struct fsxattr)",
          "247: #define FS_IOC_FSSETXATTR  _IOW ('X', 32, struct fsxattr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "253: #define FS_KEY_DESCRIPTOR_SIZE 8",
          "255: struct fscrypt_policy {",
          "256:  __u8 version;",
          "257:  __u8 contents_encryption_mode;",
          "258:  __u8 filenames_encryption_mode;",
          "259:  __u8 flags;",
          "260:  __u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];",
          "261: } __packed;",
          "263: #define FS_IOC_SET_ENCRYPTION_POLICY _IOR('f', 19, struct fscrypt_policy)",
          "264: #define FS_IOC_GET_ENCRYPTION_PWSALT _IOW('f', 20, __u8[16])",
          "265: #define FS_IOC_GET_ENCRYPTION_POLICY _IOW('f', 21, struct fscrypt_policy)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cc4e0df038ddb73510c01712abf302b3f0130147",
      "candidate_info": {
        "commit_hash": "cc4e0df038ddb73510c01712abf302b3f0130147",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cc4e0df038ddb73510c01712abf302b3f0130147",
        "files": [
          "fs/crypto/crypto.c",
          "fs/crypto/fscrypt_private.h",
          "fs/crypto/policy.c",
          "include/linux/fscrypto.h"
        ],
        "message": "fscrypt: move non-public structures and constants to fscrypt_private.h\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nReviewed-by: Eric Biggers <ebiggers@google.com>",
        "before_after_code_files": [
          "fs/crypto/crypto.c||fs/crypto/crypto.c",
          "fs/crypto/fscrypt_private.h||fs/crypto/fscrypt_private.h",
          "fs/crypto/policy.c||fs/crypto/policy.c",
          "include/linux/fscrypto.h||include/linux/fscrypto.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/crypto/crypto.c||fs/crypto/crypto.c",
            "fs/crypto/fscrypt_private.h||fs/crypto/fscrypt_private.h"
          ],
          "candidate": [
            "fs/crypto/crypto.c||fs/crypto/crypto.c",
            "fs/crypto/fscrypt_private.h||fs/crypto/fscrypt_private.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/crypto/crypto.c||fs/crypto/crypto.c": [
          "File: fs/crypto/crypto.c -> fs/crypto/crypto.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include <linux/bio.h>",
          "28: #include <linux/dcache.h>",
          "29: #include <linux/namei.h>",
          "32: static unsigned int num_prealloc_crypto_pages = 32;",
          "33: static unsigned int num_prealloc_crypto_ctxs = 128;",
          "",
          "[Removed Lines]",
          "30: #include <linux/fscrypto.h>",
          "",
          "[Added Lines]",
          "30: #include \"fscrypt_private.h\"",
          "",
          "---------------"
        ],
        "fs/crypto/fscrypt_private.h||fs/crypto/fscrypt_private.h": [
          "File: fs/crypto/fscrypt_private.h -> fs/crypto/fscrypt_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include <linux/fscrypto.h>",
          "17: int fscrypt_initialize(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #define FS_FNAME_CRYPTO_DIGEST_SIZE 32",
          "19: #define FS_XTS_TWEAK_SIZE  16",
          "20: #define FS_AES_128_ECB_KEY_SIZE  16",
          "21: #define FS_AES_256_GCM_KEY_SIZE  32",
          "22: #define FS_AES_256_CBC_KEY_SIZE  32",
          "23: #define FS_AES_256_CTS_KEY_SIZE  32",
          "24: #define FS_AES_256_XTS_KEY_SIZE  64",
          "25: #define FS_MAX_KEY_SIZE   64",
          "27: #define FS_KEY_DESC_PREFIX  \"fscrypt:\"",
          "28: #define FS_KEY_DESC_PREFIX_SIZE  8",
          "30: #define FS_KEY_DERIVATION_NONCE_SIZE  16",
          "43: struct fscrypt_context {",
          "44:  u8 format;",
          "45:  u8 contents_encryption_mode;",
          "46:  u8 filenames_encryption_mode;",
          "47:  u8 flags;",
          "48:  u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];",
          "49:  u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];",
          "50: } __packed;",
          "52: #define FS_ENCRYPTION_CONTEXT_FORMAT_V1  1",
          "55: struct fscrypt_key {",
          "56:  u32 mode;",
          "57:  u8 raw[FS_MAX_KEY_SIZE];",
          "58:  u32 size;",
          "59: } __packed;",
          "65: struct fscrypt_info {",
          "66:  u8 ci_data_mode;",
          "67:  u8 ci_filename_mode;",
          "68:  u8 ci_flags;",
          "69:  struct crypto_skcipher *ci_ctfm;",
          "70:  struct key *ci_keyring_key;",
          "71:  u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];",
          "72: };",
          "74: #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL  0x00000001",
          "75: #define FS_WRITE_PATH_FL   0x00000002",
          "77: struct fscrypt_completion_result {",
          "78:  struct completion completion;",
          "79:  int res;",
          "80: };",
          "82: #define DECLARE_FS_COMPLETION_RESULT(ecr) \\",
          "83:  struct fscrypt_completion_result ecr = { \\",
          "84:   COMPLETION_INITIALIZER((ecr).completion), 0 }",
          "",
          "---------------"
        ],
        "fs/crypto/policy.c||fs/crypto/policy.c": [
          "File: fs/crypto/policy.c -> fs/crypto/policy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include <linux/random.h>",
          "12: #include <linux/string.h>",
          "14: #include <linux/mount.h>",
          "16: static int inode_has_encryption_context(struct inode *inode)",
          "17: {",
          "",
          "[Removed Lines]",
          "13: #include <linux/fscrypto.h>",
          "",
          "[Added Lines]",
          "14: #include \"fscrypt_private.h\"",
          "",
          "---------------"
        ],
        "include/linux/fscrypto.h||include/linux/fscrypto.h": [
          "File: include/linux/fscrypto.h -> include/linux/fscrypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <crypto/skcipher.h>",
          "19: #include <uapi/linux/fs.h>",
          "24: #define FS_POLICY_FLAGS_PAD_4  0x00",
          "25: #define FS_POLICY_FLAGS_PAD_8  0x01",
          "26: #define FS_POLICY_FLAGS_PAD_16  0x02",
          "",
          "[Removed Lines]",
          "21: #define FS_KEY_DERIVATION_NONCE_SIZE  16",
          "22: #define FS_ENCRYPTION_CONTEXT_FORMAT_V1  1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35: #define FS_ENCRYPTION_MODE_AES_256_CBC  3",
          "36: #define FS_ENCRYPTION_MODE_AES_256_CTS  4",
          "89: struct fscrypt_ctx {",
          "90:  union {",
          "",
          "[Removed Lines]",
          "49: struct fscrypt_context {",
          "50:  u8 format;",
          "51:  u8 contents_encryption_mode;",
          "52:  u8 filenames_encryption_mode;",
          "53:  u8 flags;",
          "54:  u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];",
          "55:  u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];",
          "56: } __packed;",
          "59: #define FS_XTS_TWEAK_SIZE  16",
          "60: #define FS_AES_128_ECB_KEY_SIZE  16",
          "61: #define FS_AES_256_GCM_KEY_SIZE  32",
          "62: #define FS_AES_256_CBC_KEY_SIZE  32",
          "63: #define FS_AES_256_CTS_KEY_SIZE  32",
          "64: #define FS_AES_256_XTS_KEY_SIZE  64",
          "65: #define FS_MAX_KEY_SIZE   64",
          "67: #define FS_KEY_DESC_PREFIX  \"fscrypt:\"",
          "68: #define FS_KEY_DESC_PREFIX_SIZE  8",
          "71: struct fscrypt_key {",
          "72:  u32 mode;",
          "73:  u8 raw[FS_MAX_KEY_SIZE];",
          "74:  u32 size;",
          "75: } __packed;",
          "77: struct fscrypt_info {",
          "78:  u8 ci_data_mode;",
          "79:  u8 ci_filename_mode;",
          "80:  u8 ci_flags;",
          "81:  struct crypto_skcipher *ci_ctfm;",
          "82:  struct key *ci_keyring_key;",
          "83:  u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];",
          "84: };",
          "86: #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL  0x00000001",
          "87: #define FS_WRITE_PATH_FL   0x00000002",
          "",
          "[Added Lines]",
          "35: #define FS_CRYPTO_BLOCK_SIZE  16",
          "37: struct fscrypt_info;",
          "38: struct fscrypt_ctx;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103: };",
          "",
          "[Removed Lines]",
          "105: struct fscrypt_completion_result {",
          "106:  struct completion completion;",
          "107:  int res;",
          "108: };",
          "110: #define DECLARE_FS_COMPLETION_RESULT(ecr) \\",
          "111:  struct fscrypt_completion_result ecr = { \\",
          "112:   COMPLETION_INITIALIZER((ecr).completion), 0 }",
          "114: #define FS_FNAME_NUM_SCATTER_ENTRIES 4",
          "115: #define FS_CRYPTO_BLOCK_SIZE  16",
          "116: #define FS_FNAME_CRYPTO_DIGEST_SIZE 32",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-3134",
  "cve_desc": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
  "repo": "torvalds/linux",
  "patch_hash": "54d83fc74aa9ec72794373cb47432c5f7fb1a309",
  "patch_info": {
    "commit_hash": "54d83fc74aa9ec72794373cb47432c5f7fb1a309",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
    "files": [
      "net/ipv4/netfilter/arp_tables.c",
      "net/ipv4/netfilter/ip_tables.c",
      "net/ipv6/netfilter/ip6_tables.c"
    ],
    "message": "netfilter: x_tables: fix unconditional helper\n\nBen Hawkes says:\n\n In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it\n is possible for a user-supplied ipt_entry structure to have a large\n next_offset field. This field is not bounds checked prior to writing a\n counter value at the supplied offset.\n\nProblem is that mark_source_chains should not have been called --\nthe rule doesn't have a next entry, so its supposed to return\nan absolute verdict of either ACCEPT or DROP.\n\nHowever, the function conditional() doesn't work as the name implies.\nIt only checks that the rule is using wildcard address matching.\n\nHowever, an unconditional rule must also not be using any matches\n(no -m args).\n\nThe underflow validator only checked the addresses, therefore\npassing the 'unconditional absolute verdict' test, while\nmark_source_chains also tested for presence of matches, and thus\nproceeeded to the next (not-existent) rule.\n\nUnify this so that all the callers have same idea of 'unconditional rule'.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "before_after_code_files": [
      "net/ipv4/netfilter/arp_tables.c||net/ipv4/netfilter/arp_tables.c",
      "net/ipv4/netfilter/ip_tables.c||net/ipv4/netfilter/ip_tables.c",
      "net/ipv6/netfilter/ip6_tables.c||net/ipv6/netfilter/ip6_tables.c"
    ]
  },
  "patch_diff": {
    "net/ipv4/netfilter/arp_tables.c||net/ipv4/netfilter/arp_tables.c": [
      "File: net/ipv4/netfilter/arp_tables.c -> net/ipv4/netfilter/arp_tables.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "359: }",
      "363: {",
      "364:  static const struct arpt_arp uncond;",
      "367: }",
      "",
      "[Removed Lines]",
      "362: static inline bool unconditional(const struct arpt_arp *arp)",
      "366:  return memcmp(arp, &uncond, sizeof(uncond)) == 0;",
      "",
      "[Added Lines]",
      "362: static inline bool unconditional(const struct arpt_entry *e)",
      "366:  return e->target_offset == sizeof(struct arpt_entry) &&",
      "367:         memcmp(&e->arp, &uncond, sizeof(uncond)) == 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "402:     |= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));",
      "406:         (strcmp(t->target.u.user.name,",
      "407:          XT_STANDARD_TARGET) == 0) &&",
      "410:     unsigned int oldpos, size;",
      "412:     if ((strcmp(t->target.u.user.name,",
      "",
      "[Removed Lines]",
      "405:    if ((e->target_offset == sizeof(struct arpt_entry) &&",
      "408:         t->verdict < 0 && unconditional(&e->arp)) ||",
      "409:        visited) {",
      "",
      "[Added Lines]",
      "406:    if ((unconditional(e) &&",
      "409:         t->verdict < 0) || visited) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "551:  const struct xt_entry_target *t;",
      "552:  unsigned int verdict;",
      "555:   return false;",
      "556:  t = arpt_get_target_c(e);",
      "557:  if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)",
      "",
      "[Removed Lines]",
      "554:  if (!unconditional(&e->arp))",
      "",
      "[Added Lines]",
      "554:  if (!unconditional(e))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "598:    newinfo->hook_entry[h] = hook_entries[h];",
      "599:   if ((unsigned char *)e - base == underflows[h]) {",
      "600:    if (!check_underflow(e)) {",
      "604:     return -EINVAL;",
      "605:    }",
      "606:    newinfo->underflow[h] = underflows[h];",
      "",
      "[Removed Lines]",
      "601:     pr_err(\"Underflows must be unconditional and \"",
      "602:            \"use the STANDARD target with \"",
      "603:            \"ACCEPT/DROP\\n\");",
      "",
      "[Added Lines]",
      "601:     pr_debug(\"Underflows must be unconditional and \"",
      "602:       \"use the STANDARD target with \"",
      "603:       \"ACCEPT/DROP\\n\");",
      "",
      "---------------"
    ],
    "net/ipv4/netfilter/ip_tables.c||net/ipv4/netfilter/ip_tables.c": [
      "File: net/ipv4/netfilter/ip_tables.c -> net/ipv4/netfilter/ip_tables.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "172: {",
      "173:  static const struct ipt_ip uncond;",
      "176: #undef FWINV",
      "177: }",
      "",
      "[Removed Lines]",
      "171: static inline bool unconditional(const struct ipt_ip *ip)",
      "175:  return memcmp(ip, &uncond, sizeof(uncond)) == 0;",
      "",
      "[Added Lines]",
      "171: static inline bool unconditional(const struct ipt_entry *e)",
      "175:  return e->target_offset == sizeof(struct ipt_entry) &&",
      "176:         memcmp(&e->ip, &uncond, sizeof(uncond)) == 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "229:  } else if (s == e) {",
      "230:   (*rulenum)++;",
      "233:       strcmp(t->target.u.kernel.target->name,",
      "234:       XT_STANDARD_TARGET) == 0 &&",
      "239:     ? comments[NF_IP_TRACE_COMMENT_POLICY]",
      "",
      "[Removed Lines]",
      "232:   if (s->target_offset == sizeof(struct ipt_entry) &&",
      "235:      t->verdict < 0 &&",
      "236:      unconditional(&s->ip)) {",
      "",
      "[Added Lines]",
      "233:   if (unconditional(s) &&",
      "236:      t->verdict < 0) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "476:    e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));",
      "480:         (strcmp(t->target.u.user.name,",
      "481:          XT_STANDARD_TARGET) == 0) &&",
      "484:     unsigned int oldpos, size;",
      "486:     if ((strcmp(t->target.u.user.name,",
      "",
      "[Removed Lines]",
      "479:    if ((e->target_offset == sizeof(struct ipt_entry) &&",
      "482:         t->verdict < 0 && unconditional(&e->ip)) ||",
      "483:        visited) {",
      "",
      "[Added Lines]",
      "479:    if ((unconditional(e) &&",
      "482:         t->verdict < 0) || visited) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "715:  const struct xt_entry_target *t;",
      "716:  unsigned int verdict;",
      "719:   return false;",
      "720:  t = ipt_get_target_c(e);",
      "721:  if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)",
      "",
      "[Removed Lines]",
      "718:  if (!unconditional(&e->ip))",
      "",
      "[Added Lines]",
      "717:  if (!unconditional(e))",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "763:    newinfo->hook_entry[h] = hook_entries[h];",
      "764:   if ((unsigned char *)e - base == underflows[h]) {",
      "765:    if (!check_underflow(e)) {",
      "769:     return -EINVAL;",
      "770:    }",
      "771:    newinfo->underflow[h] = underflows[h];",
      "",
      "[Removed Lines]",
      "766:     pr_err(\"Underflows must be unconditional and \"",
      "767:            \"use the STANDARD target with \"",
      "768:            \"ACCEPT/DROP\\n\");",
      "",
      "[Added Lines]",
      "765:     pr_debug(\"Underflows must be unconditional and \"",
      "766:       \"use the STANDARD target with \"",
      "767:       \"ACCEPT/DROP\\n\");",
      "",
      "---------------"
    ],
    "net/ipv6/netfilter/ip6_tables.c||net/ipv6/netfilter/ip6_tables.c": [
      "File: net/ipv6/netfilter/ip6_tables.c -> net/ipv6/netfilter/ip6_tables.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "202: {",
      "203:  static const struct ip6t_ip6 uncond;",
      "206: }",
      "208: static inline const struct xt_entry_target *",
      "",
      "[Removed Lines]",
      "201: static inline bool unconditional(const struct ip6t_ip6 *ipv6)",
      "205:  return memcmp(ipv6, &uncond, sizeof(uncond)) == 0;",
      "",
      "[Added Lines]",
      "201: static inline bool unconditional(const struct ip6t_entry *e)",
      "205:  return e->target_offset == sizeof(struct ip6t_entry) &&",
      "206:         memcmp(&e->ipv6, &uncond, sizeof(uncond)) == 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "258:  } else if (s == e) {",
      "259:   (*rulenum)++;",
      "262:       strcmp(t->target.u.kernel.target->name,",
      "263:       XT_STANDARD_TARGET) == 0 &&",
      "268:     ? comments[NF_IP6_TRACE_COMMENT_POLICY]",
      "",
      "[Removed Lines]",
      "261:   if (s->target_offset == sizeof(struct ip6t_entry) &&",
      "264:       t->verdict < 0 &&",
      "265:       unconditional(&s->ipv6)) {",
      "",
      "[Added Lines]",
      "262:   if (unconditional(s) &&",
      "265:       t->verdict < 0) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "488:    e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));",
      "492:         (strcmp(t->target.u.user.name,",
      "493:          XT_STANDARD_TARGET) == 0) &&",
      "496:     unsigned int oldpos, size;",
      "498:     if ((strcmp(t->target.u.user.name,",
      "",
      "[Removed Lines]",
      "491:    if ((e->target_offset == sizeof(struct ip6t_entry) &&",
      "494:         t->verdict < 0 &&",
      "495:         unconditional(&e->ipv6)) || visited) {",
      "",
      "[Added Lines]",
      "491:    if ((unconditional(e) &&",
      "494:         t->verdict < 0) || visited) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "727:  const struct xt_entry_target *t;",
      "728:  unsigned int verdict;",
      "731:   return false;",
      "732:  t = ip6t_get_target_c(e);",
      "733:  if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)",
      "",
      "[Removed Lines]",
      "730:  if (!unconditional(&e->ipv6))",
      "",
      "[Added Lines]",
      "729:  if (!unconditional(e))",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "775:    newinfo->hook_entry[h] = hook_entries[h];",
      "776:   if ((unsigned char *)e - base == underflows[h]) {",
      "777:    if (!check_underflow(e)) {",
      "781:     return -EINVAL;",
      "782:    }",
      "783:    newinfo->underflow[h] = underflows[h];",
      "",
      "[Removed Lines]",
      "778:     pr_err(\"Underflows must be unconditional and \"",
      "779:            \"use the STANDARD target with \"",
      "780:            \"ACCEPT/DROP\\n\");",
      "",
      "[Added Lines]",
      "777:     pr_debug(\"Underflows must be unconditional and \"",
      "778:       \"use the STANDARD target with \"",
      "779:       \"ACCEPT/DROP\\n\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d7cdf81657776ca1aa8377fd84d02fd8774db483",
      "candidate_info": {
        "commit_hash": "d7cdf81657776ca1aa8377fd84d02fd8774db483",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d7cdf81657776ca1aa8377fd84d02fd8774db483",
        "files": [
          "net/ipv4/netfilter/arp_tables.c",
          "net/ipv4/netfilter/ip_tables.c",
          "net/ipv6/netfilter/ip6_tables.c"
        ],
        "message": "netfilter: x_tables: get rid of old and inconsistent debugging\n\nThe dprintf() and duprintf() functions are enabled at compile time,\nthese days we have better runtime debugging through pr_debug() and\nstatic keys.\n\nOn top of this, this debugging is so old that I don't expect anyone\nusing this anymore, so let's get rid of this.\n\nIP_NF_ASSERT() is still left in place, although this needs that\nNETFILTER_DEBUG is enabled, I think these assertions provide useful\ncontext information when reading the code.\n\nNote that ARP_NF_ASSERT() has been removed as there is no user of\nthis.\n\nKill also DEBUG_ALLOW_ALL and a couple of pr_error() and pr_debug()\nspots that are inconsistently placed in the code.\n\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/ipv4/netfilter/arp_tables.c||net/ipv4/netfilter/arp_tables.c",
          "net/ipv4/netfilter/ip_tables.c||net/ipv4/netfilter/ip_tables.c",
          "net/ipv6/netfilter/ip6_tables.c||net/ipv6/netfilter/ip6_tables.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/netfilter/arp_tables.c||net/ipv4/netfilter/arp_tables.c",
            "net/ipv4/netfilter/ip_tables.c||net/ipv4/netfilter/ip_tables.c",
            "net/ipv6/netfilter/ip6_tables.c||net/ipv6/netfilter/ip6_tables.c"
          ],
          "candidate": [
            "net/ipv4/netfilter/arp_tables.c||net/ipv4/netfilter/arp_tables.c",
            "net/ipv4/netfilter/ip_tables.c||net/ipv4/netfilter/ip_tables.c",
            "net/ipv6/netfilter/ip6_tables.c||net/ipv6/netfilter/ip6_tables.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/netfilter/arp_tables.c||net/ipv4/netfilter/arp_tables.c": [
          "File: net/ipv4/netfilter/arp_tables.c -> net/ipv4/netfilter/arp_tables.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: MODULE_AUTHOR(\"David S. Miller <davem@redhat.com>\");",
          "35: MODULE_DESCRIPTION(\"arptables core\");",
          "58: void *arpt_alloc_initial_table(const struct xt_table *info)",
          "59: {",
          "60:  return xt_alloc_initial_table(arpt, ARPT);",
          "",
          "[Removed Lines]",
          "40: #ifdef DEBUG_ARP_TABLES",
          "41: #define dprintf(format, args...)  pr_debug(format, ## args)",
          "42: #else",
          "43: #define dprintf(format, args...)",
          "44: #endif",
          "46: #ifdef DEBUG_ARP_TABLES_USER",
          "47: #define duprintf(format, args...) pr_debug(format, ## args)",
          "48: #else",
          "49: #define duprintf(format, args...)",
          "50: #endif",
          "52: #ifdef CONFIG_NETFILTER_DEBUG",
          "53: #define ARP_NF_ASSERT(x) WARN_ON(!(x))",
          "54: #else",
          "55: #define ARP_NF_ASSERT(x)",
          "56: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: #define FWINV(bool, invflg) ((bool) ^ !!(arpinfo->invflags & (invflg)))",
          "115:  if (FWINV((arphdr->ar_op & arpinfo->arpop_mask) != arpinfo->arpop,",
          "120:   return 0;",
          "123:  if (FWINV((arphdr->ar_hrd & arpinfo->arhrd_mask) != arpinfo->arhrd,",
          "128:   return 0;",
          "131:  if (FWINV((arphdr->ar_pro & arpinfo->arpro_mask) != arpinfo->arpro,",
          "136:   return 0;",
          "139:  if (FWINV((arphdr->ar_hln & arpinfo->arhln_mask) != arpinfo->arhln,",
          "144:   return 0;",
          "147:  src_devaddr = arpptr;",
          "148:  arpptr += dev->addr_len;",
          "",
          "[Removed Lines]",
          "116:     ARPT_INV_ARPOP)) {",
          "117:   dprintf(\"ARP operation field mismatch.\\n\");",
          "118:   dprintf(\"ar_op: %04x info->arpop: %04x info->arpop_mask: %04x\\n\",",
          "119:    arphdr->ar_op, arpinfo->arpop, arpinfo->arpop_mask);",
          "121:  }",
          "124:     ARPT_INV_ARPHRD)) {",
          "125:   dprintf(\"ARP hardware address format mismatch.\\n\");",
          "126:   dprintf(\"ar_hrd: %04x info->arhrd: %04x info->arhrd_mask: %04x\\n\",",
          "127:    arphdr->ar_hrd, arpinfo->arhrd, arpinfo->arhrd_mask);",
          "129:  }",
          "132:     ARPT_INV_ARPPRO)) {",
          "133:   dprintf(\"ARP protocol address format mismatch.\\n\");",
          "134:   dprintf(\"ar_pro: %04x info->arpro: %04x info->arpro_mask: %04x\\n\",",
          "135:    arphdr->ar_pro, arpinfo->arpro, arpinfo->arpro_mask);",
          "137:  }",
          "140:     ARPT_INV_ARPHLN)) {",
          "141:   dprintf(\"ARP hardware address length mismatch.\\n\");",
          "142:   dprintf(\"ar_hln: %02x info->arhln: %02x info->arhln_mask: %02x\\n\",",
          "143:    arphdr->ar_hln, arpinfo->arhln, arpinfo->arhln_mask);",
          "145:  }",
          "",
          "[Added Lines]",
          "95:     ARPT_INV_ARPOP))",
          "99:     ARPT_INV_ARPHRD))",
          "103:     ARPT_INV_ARPPRO))",
          "107:     ARPT_INV_ARPHLN))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "155:  if (FWINV(arp_devaddr_compare(&arpinfo->src_devaddr, src_devaddr, dev->addr_len),",
          "156:     ARPT_INV_SRCDEVADDR) ||",
          "157:      FWINV(arp_devaddr_compare(&arpinfo->tgt_devaddr, tgt_devaddr, dev->addr_len),",
          "161:   return 0;",
          "164:  if (FWINV((src_ipaddr & arpinfo->smsk.s_addr) != arpinfo->src.s_addr,",
          "165:     ARPT_INV_SRCIP) ||",
          "166:      FWINV(((tgt_ipaddr & arpinfo->tmsk.s_addr) != arpinfo->tgt.s_addr),",
          "180:   return 0;",
          "184:  ret = ifname_compare(indev, arpinfo->iniface, arpinfo->iniface_mask);",
          "190:   return 0;",
          "193:  ret = ifname_compare(outdev, arpinfo->outiface, arpinfo->outiface_mask);",
          "199:   return 0;",
          "202:  return 1;",
          "203: #undef FWINV",
          "",
          "[Removed Lines]",
          "158:     ARPT_INV_TGTDEVADDR)) {",
          "159:   dprintf(\"Source or target device address mismatch.\\n\");",
          "162:  }",
          "167:     ARPT_INV_TGTIP)) {",
          "168:   dprintf(\"Source or target IP address mismatch.\\n\");",
          "170:   dprintf(\"SRC: %pI4. Mask: %pI4. Target: %pI4.%s\\n\",",
          "171:    &src_ipaddr,",
          "172:    &arpinfo->smsk.s_addr,",
          "173:    &arpinfo->src.s_addr,",
          "174:    arpinfo->invflags & ARPT_INV_SRCIP ? \" (INV)\" : \"\");",
          "175:   dprintf(\"TGT: %pI4 Mask: %pI4 Target: %pI4.%s\\n\",",
          "176:    &tgt_ipaddr,",
          "177:    &arpinfo->tmsk.s_addr,",
          "178:    &arpinfo->tgt.s_addr,",
          "179:    arpinfo->invflags & ARPT_INV_TGTIP ? \" (INV)\" : \"\");",
          "181:  }",
          "186:  if (FWINV(ret != 0, ARPT_INV_VIA_IN)) {",
          "187:   dprintf(\"VIA in mismatch (%s vs %s).%s\\n\",",
          "188:    indev, arpinfo->iniface,",
          "189:    arpinfo->invflags & ARPT_INV_VIA_IN ? \" (INV)\" : \"\");",
          "191:  }",
          "195:  if (FWINV(ret != 0, ARPT_INV_VIA_OUT)) {",
          "196:   dprintf(\"VIA out mismatch (%s vs %s).%s\\n\",",
          "197:    outdev, arpinfo->outiface,",
          "198:    arpinfo->invflags & ARPT_INV_VIA_OUT ? \" (INV)\" : \"\");",
          "200:  }",
          "",
          "[Added Lines]",
          "121:     ARPT_INV_TGTDEVADDR))",
          "127:     ARPT_INV_TGTIP))",
          "133:  if (FWINV(ret != 0, ARPT_INV_VIA_IN))",
          "138:  if (FWINV(ret != 0, ARPT_INV_VIA_OUT))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "206: static inline int arp_checkentry(const struct arpt_arp *arp)",
          "207: {",
          "211:   return 0;",
          "216:   return 0;",
          "219:  return 1;",
          "220: }",
          "",
          "[Removed Lines]",
          "208:  if (arp->flags & ~ARPT_F_MASK) {",
          "209:   duprintf(\"Unknown flag bits set: %08X\\n\",",
          "210:     arp->flags & ~ARPT_F_MASK);",
          "212:  }",
          "213:  if (arp->invflags & ~ARPT_INV_MASK) {",
          "214:   duprintf(\"Unknown invflag bits set: %08X\\n\",",
          "215:     arp->invflags & ~ARPT_INV_MASK);",
          "217:  }",
          "",
          "[Added Lines]",
          "147:  if (arp->flags & ~ARPT_F_MASK)",
          "149:  if (arp->invflags & ~ARPT_INV_MASK)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "406:     = (void *)arpt_get_target_c(e);",
          "407:    int visited = e->comefrom & (1 << hook);",
          "412:     return 0;",
          "414:    e->comefrom",
          "415:     |= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));",
          "",
          "[Removed Lines]",
          "409:    if (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {",
          "410:     pr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",",
          "411:            hook, pos, e->comefrom);",
          "413:    }",
          "",
          "[Added Lines]",
          "342:    if (e->comefrom & (1 << NF_ARP_NUMHOOKS))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "424:     if ((strcmp(t->target.u.user.name,",
          "425:          XT_STANDARD_TARGET) == 0) &&",
          "430:      return 0;",
          "",
          "[Removed Lines]",
          "426:         t->verdict < -NF_MAX_VERDICT - 1) {",
          "427:      duprintf(\"mark_source_chains: bad \"",
          "428:       \"negative verdict (%i)\\n\",",
          "429:         t->verdict);",
          "431:     }",
          "",
          "[Added Lines]",
          "357:         t->verdict < -NF_MAX_VERDICT - 1)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "462:         XT_STANDARD_TARGET) == 0 &&",
          "463:         newpos >= 0) {",
          "467:      e = (struct arpt_entry *)",
          "468:       (entry0 + newpos);",
          "469:      if (!find_jump_target(newinfo, e))",
          "",
          "[Removed Lines]",
          "465:      duprintf(\"Jump rule %u -> %u\\n\",",
          "466:        pos, newpos);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "480:     pos = newpos;",
          "481:    }",
          "482:   }",
          "485:  }",
          "486:  return 1;",
          "487: }",
          "",
          "[Removed Lines]",
          "483: next:",
          "484:   duprintf(\"Finished chain %u\\n\", hook);",
          "",
          "[Added Lines]",
          "408: next:  ;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "489: static inline int check_target(struct arpt_entry *e, const char *name)",
          "490: {",
          "491:  struct xt_entry_target *t = arpt_get_target(e);",
          "493:  struct xt_tgchk_param par = {",
          "494:   .table     = name,",
          "495:   .entryinfo = e,",
          "",
          "[Removed Lines]",
          "492:  int ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "499:   .family    = NFPROTO_ARP,",
          "500:  };",
          "509: }",
          "511: static inline int",
          "",
          "[Removed Lines]",
          "502:  ret = xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);",
          "503:  if (ret < 0) {",
          "504:   duprintf(\"arp_tables: check failed for `%s'.\\n\",",
          "505:     t->u.kernel.target->name);",
          "506:   return ret;",
          "507:  }",
          "508:  return 0;",
          "",
          "[Added Lines]",
          "425:  return xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "525:  target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,",
          "526:      t->u.user.revision);",
          "527:  if (IS_ERR(target)) {",
          "529:   ret = PTR_ERR(target);",
          "530:   goto out;",
          "531:  }",
          "",
          "[Removed Lines]",
          "528:   duprintf(\"find_check_entry: `%s' not found\\n\", t->u.user.name);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "572:  if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||",
          "573:      (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||",
          "576:   return -EINVAL;",
          "579:  if (e->next_offset",
          "583:   return -EINVAL;",
          "586:  if (!arp_checkentry(&e->arp))",
          "587:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "574:      (unsigned char *)e + e->next_offset > limit) {",
          "575:   duprintf(\"Bad offset %p\\n\", e);",
          "577:  }",
          "580:      < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {",
          "581:   duprintf(\"checking: element %p size %u\\n\",",
          "582:     e, e->next_offset);",
          "584:  }",
          "",
          "[Added Lines]",
          "490:      (unsigned char *)e + e->next_offset > limit)",
          "494:      < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "598:   if ((unsigned char *)e - base == hook_entries[h])",
          "599:    newinfo->hook_entry[h] = hook_entries[h];",
          "600:   if ((unsigned char *)e - base == underflows[h]) {",
          "605:     return -EINVAL;",
          "607:    newinfo->underflow[h] = underflows[h];",
          "608:   }",
          "609:  }",
          "",
          "[Removed Lines]",
          "601:    if (!check_underflow(e)) {",
          "602:     pr_debug(\"Underflows must be unconditional and \"",
          "603:       \"use the STANDARD target with \"",
          "604:       \"ACCEPT/DROP\\n\");",
          "606:    }",
          "",
          "[Added Lines]",
          "512:    if (!check_underflow(e))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "648:   newinfo->underflow[i] = 0xFFFFFFFF;",
          "649:  }",
          "652:  i = 0;",
          "",
          "[Removed Lines]",
          "651:  duprintf(\"translate_table: size %u\\n\", newinfo->size);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "665:       XT_ERROR_TARGET) == 0)",
          "666:    ++newinfo->stacksize;",
          "667:  }",
          "669:  if (ret != 0)",
          "670:   return ret;",
          "675:   return -EINVAL;",
          "679:  for (i = 0; i < NF_ARP_NUMHOOKS; i++) {",
          "681:   if (!(repl->valid_hooks & (1 << i)))",
          "682:    continue;",
          "686:    return -EINVAL;",
          "691:    return -EINVAL;",
          "693:  }",
          "695:  if (!mark_source_chains(newinfo, repl->valid_hooks, entry0))",
          "",
          "[Removed Lines]",
          "668:  duprintf(\"translate_table: ARPT_ENTRY_ITERATE gives %d\\n\", ret);",
          "672:  if (i != repl->num_entries) {",
          "673:   duprintf(\"translate_table: %u not %u entries\\n\",",
          "674:     i, repl->num_entries);",
          "676:  }",
          "683:   if (newinfo->hook_entry[i] == 0xFFFFFFFF) {",
          "684:    duprintf(\"Invalid hook entry %u %u\\n\",",
          "685:      i, repl->hook_entry[i]);",
          "687:   }",
          "688:   if (newinfo->underflow[i] == 0xFFFFFFFF) {",
          "689:    duprintf(\"Invalid underflow %u %u\\n\",",
          "690:      i, repl->underflow[i]);",
          "692:   }",
          "",
          "[Added Lines]",
          "578:  if (i != repl->num_entries)",
          "586:   if (newinfo->hook_entry[i] == 0xFFFFFFFF)",
          "588:   if (newinfo->underflow[i] == 0xFFFFFFFF)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "897:  struct xt_table *t;",
          "898:  int ret;",
          "903:   return -EINVAL;",
          "906:  if (copy_from_user(name, user, sizeof(name)) != 0)",
          "907:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "900:  if (*len != sizeof(struct arpt_getinfo)) {",
          "901:   duprintf(\"length %u != %Zu\\n\", *len,",
          "902:     sizeof(struct arpt_getinfo));",
          "904:  }",
          "",
          "[Added Lines]",
          "797:  if (*len != sizeof(struct arpt_getinfo))",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "957:  struct arpt_get_entries get;",
          "958:  struct xt_table *t;",
          "962:   return -EINVAL;",
          "964:  if (copy_from_user(&get, uptr, sizeof(get)) != 0)",
          "965:   return -EFAULT;",
          "969:   return -EINVAL;",
          "971:  get.name[sizeof(get.name) - 1] = '\\0';",
          "973:  t = xt_find_table_lock(net, NFPROTO_ARP, get.name);",
          "974:  if (!IS_ERR_OR_NULL(t)) {",
          "975:   const struct xt_table_info *private = t->private;",
          "979:   if (get.size == private->size)",
          "980:    ret = copy_entries_to_user(private->size,",
          "981:          t, uptr->entrytable);",
          "985:    ret = -EAGAIN;",
          "987:   module_put(t->me);",
          "988:   xt_table_unlock(t);",
          "989:  } else",
          "",
          "[Removed Lines]",
          "960:  if (*len < sizeof(get)) {",
          "961:   duprintf(\"get_entries: %u < %Zu\\n\", *len, sizeof(get));",
          "963:  }",
          "966:  if (*len != sizeof(struct arpt_get_entries) + get.size) {",
          "967:   duprintf(\"get_entries: %u != %Zu\\n\", *len,",
          "968:     sizeof(struct arpt_get_entries) + get.size);",
          "970:  }",
          "977:   duprintf(\"t->private->number = %u\\n\",",
          "978:     private->number);",
          "982:   else {",
          "983:    duprintf(\"get_entries: I've got %u not %u!\\n\",",
          "984:      private->size, get.size);",
          "986:   }",
          "",
          "[Added Lines]",
          "854:  if (*len < sizeof(get))",
          "858:  if (*len != sizeof(struct arpt_get_entries) + get.size)",
          "870:   else",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1023:  if (valid_hooks != t->valid_hooks) {",
          "1026:   ret = -EINVAL;",
          "1027:   goto put_module;",
          "1028:  }",
          "",
          "[Removed Lines]",
          "1024:   duprintf(\"Valid hook crap: %08X vs %08X\\n\",",
          "1025:     valid_hooks, t->valid_hooks);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1032:   goto put_module;",
          "1037:  if ((oldinfo->number > oldinfo->initial_entries) ||",
          "1038:      (newinfo->number <= oldinfo->initial_entries))",
          "1039:   module_put(t->me);",
          "",
          "[Removed Lines]",
          "1035:  duprintf(\"do_replace: oldnum=%u, initnum=%u, newnum=%u\\n\",",
          "1036:   oldinfo->number, oldinfo->initial_entries, newinfo->number);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1103:  if (ret != 0)",
          "1104:   goto free_newinfo;",
          "1108:  ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,",
          "1109:       tmp.num_counters, tmp.counters);",
          "1110:  if (ret)",
          "",
          "[Removed Lines]",
          "1106:  duprintf(\"arp_tables: Translated table\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1202:  unsigned int entry_offset;",
          "1203:  int ret, off;",
          "1206:  if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||",
          "1207:      (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||",
          "1210:   return -EINVAL;",
          "1213:  if (e->next_offset < sizeof(struct compat_arpt_entry) +",
          "1217:   return -EINVAL;",
          "1220:  if (!arp_checkentry(&e->arp))",
          "1221:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "1205:  duprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);",
          "1208:      (unsigned char *)e + e->next_offset > limit) {",
          "1209:   duprintf(\"Bad offset %p, limit = %p\\n\", e, limit);",
          "1211:  }",
          "1214:         sizeof(struct compat_xt_entry_target)) {",
          "1215:   duprintf(\"checking: element %p size %u\\n\",",
          "1216:     e, e->next_offset);",
          "1218:  }",
          "",
          "[Added Lines]",
          "1087:      (unsigned char *)e + e->next_offset > limit)",
          "1091:         sizeof(struct compat_xt_entry_target))",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1232:  target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,",
          "1233:      t->u.user.revision);",
          "1234:  if (IS_ERR(target)) {",
          "1237:   ret = PTR_ERR(target);",
          "1238:   goto out;",
          "1239:  }",
          "",
          "[Removed Lines]",
          "1235:   duprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",",
          "1236:     t->u.user.name);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1303:  size = compatr->size;",
          "1304:  info->number = compatr->num_entries;",
          "1307:  j = 0;",
          "1308:  xt_compat_lock(NFPROTO_ARP);",
          "1309:  xt_compat_init_offsets(NFPROTO_ARP, compatr->num_entries);",
          "",
          "[Removed Lines]",
          "1306:  duprintf(\"translate_compat_table: size %u\\n\", info->size);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1318:  }",
          "1320:  ret = -EINVAL;",
          "1324:   goto out_unlock;",
          "1327:  ret = -ENOMEM;",
          "1328:  newinfo = xt_alloc_table_info(size);",
          "",
          "[Removed Lines]",
          "1321:  if (j != compatr->num_entries) {",
          "1322:   duprintf(\"translate_compat_table: %u not %u entries\\n\",",
          "1323:     j, compatr->num_entries);",
          "1325:  }",
          "",
          "[Added Lines]",
          "1192:  if (j != compatr->num_entries)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1413:  if (ret != 0)",
          "1414:   goto free_newinfo;",
          "1418:  ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,",
          "1419:       tmp.num_counters, compat_ptr(tmp.counters));",
          "1420:  if (ret)",
          "",
          "[Removed Lines]",
          "1416:  duprintf(\"compat_do_replace: Translated table\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1447:   break;",
          "1449:  default:",
          "1451:   ret = -EINVAL;",
          "1452:  }",
          "",
          "[Removed Lines]",
          "1450:   duprintf(\"do_arpt_set_ctl:  unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1530:  struct compat_arpt_get_entries get;",
          "1531:  struct xt_table *t;",
          "1535:   return -EINVAL;",
          "1537:  if (copy_from_user(&get, uptr, sizeof(get)) != 0)",
          "1538:   return -EFAULT;",
          "1542:   return -EINVAL;",
          "1544:  get.name[sizeof(get.name) - 1] = '\\0';",
          "1546:  xt_compat_lock(NFPROTO_ARP);",
          "",
          "[Removed Lines]",
          "1533:  if (*len < sizeof(get)) {",
          "1534:   duprintf(\"compat_get_entries: %u < %zu\\n\", *len, sizeof(get));",
          "1536:  }",
          "1539:  if (*len != sizeof(struct compat_arpt_get_entries) + get.size) {",
          "1540:   duprintf(\"compat_get_entries: %u != %zu\\n\",",
          "1543:  }",
          "",
          "[Added Lines]",
          "1398:  if (*len < sizeof(get))",
          "1402:  if (*len != sizeof(struct compat_arpt_get_entries) + get.size)",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1549:   const struct xt_table_info *private = t->private;",
          "1550:   struct xt_table_info info;",
          "1553:   ret = compat_table_info(private, &info);",
          "1554:   if (!ret && get.size == info.size) {",
          "1555:    ret = compat_copy_entries_to_user(private->size,",
          "1556:          t, uptr->entrytable);",
          "1560:    ret = -EAGAIN;",
          "1562:   xt_compat_flush_offsets(NFPROTO_ARP);",
          "1563:   module_put(t->me);",
          "1564:   xt_table_unlock(t);",
          "",
          "[Removed Lines]",
          "1552:   duprintf(\"t->private->number = %u\\n\", private->number);",
          "1557:   } else if (!ret) {",
          "1558:    duprintf(\"compat_get_entries: I've got %u not %u!\\n\",",
          "1559:      private->size, get.size);",
          "1561:   }",
          "",
          "[Added Lines]",
          "1417:   } else if (!ret)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1610:   break;",
          "1612:  default:",
          "1614:   ret = -EINVAL;",
          "1615:  }",
          "",
          "[Removed Lines]",
          "1613:   duprintf(\"do_arpt_set_ctl:  unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1653:  }",
          "1655:  default:",
          "1657:   ret = -EINVAL;",
          "1658:  }",
          "",
          "[Removed Lines]",
          "1656:   duprintf(\"do_arpt_get_ctl: unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1698:  memcpy(loc_cpu_entry, repl->entries, repl->size);",
          "1700:  ret = translate_table(newinfo, loc_cpu_entry, repl);",
          "1702:  if (ret != 0)",
          "1703:   goto out_free;",
          "",
          "[Removed Lines]",
          "1701:  duprintf(\"arpt_register_table: translate table gives %d\\n\", ret);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "net/ipv4/netfilter/ip_tables.c||net/ipv4/netfilter/ip_tables.c": [
          "File: net/ipv4/netfilter/ip_tables.c -> net/ipv4/netfilter/ip_tables.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: MODULE_AUTHOR(\"Netfilter Core Team <coreteam@netfilter.org>\");",
          "36: MODULE_DESCRIPTION(\"IPv4 packet filter\");",
          "54: #ifdef CONFIG_NETFILTER_DEBUG",
          "55: #define IP_NF_ASSERT(x)  WARN_ON(!(x))",
          "56: #else",
          "57: #define IP_NF_ASSERT(x)",
          "58: #endif",
          "66: void *ipt_alloc_initial_table(const struct xt_table *info)",
          "67: {",
          "68:  return xt_alloc_initial_table(ipt, IPT);",
          "",
          "[Removed Lines]",
          "42: #ifdef DEBUG_IP_FIREWALL",
          "43: #define dprintf(format, args...) pr_info(format , ## args)",
          "44: #else",
          "45: #define dprintf(format, args...)",
          "46: #endif",
          "48: #ifdef DEBUG_IP_FIREWALL_USER",
          "49: #define duprintf(format, args...) pr_info(format , ## args)",
          "50: #else",
          "51: #define duprintf(format, args...)",
          "52: #endif",
          "60: #if 0",
          "62: #define static",
          "63: #define inline",
          "64: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:  if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,",
          "86:     IPT_INV_SRCIP) ||",
          "87:      FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,",
          "97:   return false;",
          "100:  ret = ifname_compare_aligned(indev, ipinfo->iniface, ipinfo->iniface_mask);",
          "106:   return false;",
          "109:  ret = ifname_compare_aligned(outdev, ipinfo->outiface, ipinfo->outiface_mask);",
          "115:   return false;",
          "119:  if (ipinfo->proto &&",
          "124:   return false;",
          "132:   return false;",
          "135:  return true;",
          "136: }",
          "",
          "[Removed Lines]",
          "88:     IPT_INV_DSTIP)) {",
          "89:   dprintf(\"Source or dest mismatch.\\n\");",
          "91:   dprintf(\"SRC: %pI4. Mask: %pI4. Target: %pI4.%s\\n\",",
          "92:    &ip->saddr, &ipinfo->smsk.s_addr, &ipinfo->src.s_addr,",
          "93:    ipinfo->invflags & IPT_INV_SRCIP ? \" (INV)\" : \"\");",
          "94:   dprintf(\"DST: %pI4 Mask: %pI4 Target: %pI4.%s\\n\",",
          "95:    &ip->daddr, &ipinfo->dmsk.s_addr, &ipinfo->dst.s_addr,",
          "96:    ipinfo->invflags & IPT_INV_DSTIP ? \" (INV)\" : \"\");",
          "98:  }",
          "102:  if (FWINV(ret != 0, IPT_INV_VIA_IN)) {",
          "103:   dprintf(\"VIA in mismatch (%s vs %s).%s\\n\",",
          "104:    indev, ipinfo->iniface,",
          "105:    ipinfo->invflags & IPT_INV_VIA_IN ? \" (INV)\" : \"\");",
          "107:  }",
          "111:  if (FWINV(ret != 0, IPT_INV_VIA_OUT)) {",
          "112:   dprintf(\"VIA out mismatch (%s vs %s).%s\\n\",",
          "113:    outdev, ipinfo->outiface,",
          "114:    ipinfo->invflags & IPT_INV_VIA_OUT ? \" (INV)\" : \"\");",
          "116:  }",
          "120:      FWINV(ip->protocol != ipinfo->proto, IPT_INV_PROTO)) {",
          "121:   dprintf(\"Packet protocol %hi does not match %hi.%s\\n\",",
          "122:    ip->protocol, ipinfo->proto,",
          "123:    ipinfo->invflags & IPT_INV_PROTO ? \" (INV)\" : \"\");",
          "125:  }",
          "129:  if (FWINV((ipinfo->flags&IPT_F_FRAG) && !isfrag, IPT_INV_FRAG)) {",
          "130:   dprintf(\"Fragment rule but not fragment.%s\\n\",",
          "131:    ipinfo->invflags & IPT_INV_FRAG ? \" (INV)\" : \"\");",
          "133:  }",
          "",
          "[Added Lines]",
          "66:     IPT_INV_DSTIP))",
          "71:  if (FWINV(ret != 0, IPT_INV_VIA_IN))",
          "76:  if (FWINV(ret != 0, IPT_INV_VIA_OUT))",
          "81:      FWINV(ip->protocol != ipinfo->proto, IPT_INV_PROTO))",
          "86:  if (FWINV((ipinfo->flags&IPT_F_FRAG) && !isfrag, IPT_INV_FRAG))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "138: static bool",
          "139: ip_checkentry(const struct ipt_ip *ip)",
          "140: {",
          "144:   return false;",
          "149:   return false;",
          "151:  return true;",
          "152: }",
          "",
          "[Removed Lines]",
          "141:  if (ip->flags & ~IPT_F_MASK) {",
          "142:   duprintf(\"Unknown flag bits set: %08X\\n\",",
          "143:     ip->flags & ~IPT_F_MASK);",
          "145:  }",
          "146:  if (ip->invflags & ~IPT_INV_MASK) {",
          "147:   duprintf(\"Unknown invflag bits set: %08X\\n\",",
          "148:     ip->invflags & ~IPT_INV_MASK);",
          "150:  }",
          "",
          "[Added Lines]",
          "95:  if (ip->flags & ~IPT_F_MASK)",
          "97:  if (ip->invflags & ~IPT_INV_MASK)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "347:  e = get_entry(table_base, private->hook_entry[hook]);",
          "353:  do {",
          "354:   const struct xt_entry_target *t;",
          "355:   const struct xt_entry_match *ematch;",
          "",
          "[Removed Lines]",
          "349:  pr_debug(\"Entering %s(hook %u), UF %p\\n\",",
          "350:    table->name, hook,",
          "351:    get_entry(table_base, private->underflow[hook]));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "396:     if (stackidx == 0) {",
          "397:      e = get_entry(table_base,",
          "398:          private->underflow[hook]);",
          "401:     } else {",
          "402:      e = jumpstack[--stackidx];",
          "405:      e = ipt_next_entry(e);",
          "406:     }",
          "407:     continue;",
          "408:    }",
          "409:    if (table_base + v != ipt_next_entry(e) &&",
          "411:     jumpstack[stackidx++] = e;",
          "416:    e = get_entry(table_base, v);",
          "417:    continue;",
          "",
          "[Removed Lines]",
          "399:      pr_debug(\"Underflow (this is normal) \"",
          "400:        \"to %p\\n\", e);",
          "403:      pr_debug(\"Pulled %p out from pos %u\\n\",",
          "404:        e, stackidx);",
          "410:        !(e->ip.flags & IPT_F_GOTO)) {",
          "412:     pr_debug(\"Pushed %p into pos %u\\n\",",
          "413:       e, stackidx - 1);",
          "414:    }",
          "",
          "[Added Lines]",
          "350:        !(e->ip.flags & IPT_F_GOTO))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "430:    break;",
          "431:  } while (!acpar.hotdrop);",
          "434:  xt_write_recseq_end(addend);",
          "435:  local_bh_enable();",
          "440:  if (acpar.hotdrop)",
          "441:   return NF_DROP;",
          "442:  else return verdict;",
          "444: }",
          "446: static bool find_jump_target(const struct xt_table_info *t,",
          "",
          "[Removed Lines]",
          "432:  pr_debug(\"Exiting %s; sp at %u\\n\", __func__, stackidx);",
          "437: #ifdef DEBUG_ALLOW_ALL",
          "438:  return NF_ACCEPT;",
          "439: #else",
          "443: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "480:     = (void *)ipt_get_target_c(e);",
          "481:    int visited = e->comefrom & (1 << hook);",
          "486:     return 0;",
          "488:    e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));",
          "",
          "[Removed Lines]",
          "483:    if (e->comefrom & (1 << NF_INET_NUMHOOKS)) {",
          "484:     pr_err(\"iptables: loop hook %u pos %u %08X.\\n\",",
          "485:            hook, pos, e->comefrom);",
          "487:    }",
          "",
          "[Added Lines]",
          "415:    if (e->comefrom & (1 << NF_INET_NUMHOOKS))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "497:     if ((strcmp(t->target.u.user.name,",
          "498:          XT_STANDARD_TARGET) == 0) &&",
          "503:      return 0;",
          "508:     do {",
          "509:      e->comefrom ^= (1<<NF_INET_NUMHOOKS);",
          "519:      oldpos = pos;",
          "520:      pos = e->counters.pcnt;",
          "521:      e->counters.pcnt = 0;",
          "",
          "[Removed Lines]",
          "499:         t->verdict < -NF_MAX_VERDICT - 1) {",
          "500:      duprintf(\"mark_source_chains: bad \"",
          "501:       \"negative verdict (%i)\\n\",",
          "502:         t->verdict);",
          "504:     }",
          "510: #ifdef DEBUG_IP_FIREWALL_USER",
          "511:      if (e->comefrom",
          "512:          & (1 << NF_INET_NUMHOOKS)) {",
          "513:       duprintf(\"Back unset \"",
          "514:         \"on hook %u \"",
          "515:         \"rule %u\\n\",",
          "516:         hook, pos);",
          "517:      }",
          "518: #endif",
          "",
          "[Added Lines]",
          "429:         t->verdict < -NF_MAX_VERDICT - 1)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "543:         XT_STANDARD_TARGET) == 0 &&",
          "544:         newpos >= 0) {",
          "548:      e = (struct ipt_entry *)",
          "549:       (entry0 + newpos);",
          "550:      if (!find_jump_target(newinfo, e))",
          "",
          "[Removed Lines]",
          "546:      duprintf(\"Jump rule %u -> %u\\n\",",
          "547:        pos, newpos);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "561:     pos = newpos;",
          "562:    }",
          "563:   }",
          "566:  }",
          "567:  return 1;",
          "568: }",
          "",
          "[Removed Lines]",
          "564: next:",
          "565:   duprintf(\"Finished chain %u\\n\", hook);",
          "",
          "[Added Lines]",
          "479: next:  ;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "584: check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)",
          "585: {",
          "586:  const struct ipt_ip *ip = par->entryinfo;",
          "589:  par->match     = m->u.kernel.match;",
          "590:  par->matchinfo = m->data;",
          "599: }",
          "601: static int",
          "",
          "[Removed Lines]",
          "587:  int ret;",
          "592:  ret = xt_check_match(par, m->u.match_size - sizeof(*m),",
          "593:        ip->proto, ip->invflags & IPT_INV_PROTO);",
          "594:  if (ret < 0) {",
          "595:   duprintf(\"check failed for `%s'.\\n\", par->match->name);",
          "596:   return ret;",
          "597:  }",
          "598:  return 0;",
          "",
          "[Added Lines]",
          "505:  return xt_check_match(par, m->u.match_size - sizeof(*m),",
          "506:          ip->proto, ip->invflags & IPT_INV_PROTO);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "607:  match = xt_request_find_match(NFPROTO_IPV4, m->u.user.name,",
          "608:           m->u.user.revision);",
          "611:   return PTR_ERR(match);",
          "613:  m->u.kernel.match = match;",
          "615:  ret = check_match(m, par);",
          "",
          "[Removed Lines]",
          "609:  if (IS_ERR(match)) {",
          "610:   duprintf(\"find_check_match: `%s' not found\\n\", m->u.user.name);",
          "612:  }",
          "",
          "[Added Lines]",
          "517:  if (IS_ERR(match))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "634:   .hook_mask = e->comefrom,",
          "635:   .family    = NFPROTO_IPV4,",
          "636:  };",
          "647: }",
          "649: static int",
          "",
          "[Removed Lines]",
          "637:  int ret;",
          "639:  ret = xt_check_target(&par, t->u.target_size - sizeof(*t),",
          "640:        e->ip.proto, e->ip.invflags & IPT_INV_PROTO);",
          "641:  if (ret < 0) {",
          "642:   duprintf(\"check failed for `%s'.\\n\",",
          "643:     t->u.kernel.target->name);",
          "644:   return ret;",
          "645:  }",
          "646:  return 0;",
          "",
          "[Added Lines]",
          "544:  return xt_check_target(&par, t->u.target_size - sizeof(*t),",
          "545:           e->ip.proto, e->ip.invflags & IPT_INV_PROTO);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "680:  target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,",
          "681:      t->u.user.revision);",
          "682:  if (IS_ERR(target)) {",
          "684:   ret = PTR_ERR(target);",
          "685:   goto cleanup_matches;",
          "686:  }",
          "",
          "[Removed Lines]",
          "683:   duprintf(\"find_check_entry: `%s' not found\\n\", t->u.user.name);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "735:  if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||",
          "736:      (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||",
          "739:   return -EINVAL;",
          "742:  if (e->next_offset",
          "746:   return -EINVAL;",
          "749:  if (!ip_checkentry(&e->ip))",
          "750:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "737:      (unsigned char *)e + e->next_offset > limit) {",
          "738:   duprintf(\"Bad offset %p\\n\", e);",
          "740:  }",
          "743:      < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {",
          "744:   duprintf(\"checking: element %p size %u\\n\",",
          "745:     e, e->next_offset);",
          "747:  }",
          "",
          "[Added Lines]",
          "635:      (unsigned char *)e + e->next_offset > limit)",
          "639:      < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "761:   if ((unsigned char *)e - base == hook_entries[h])",
          "762:    newinfo->hook_entry[h] = hook_entries[h];",
          "763:   if ((unsigned char *)e - base == underflows[h]) {",
          "768:     return -EINVAL;",
          "770:    newinfo->underflow[h] = underflows[h];",
          "771:   }",
          "772:  }",
          "",
          "[Removed Lines]",
          "764:    if (!check_underflow(e)) {",
          "765:     pr_debug(\"Underflows must be unconditional and \"",
          "766:       \"use the STANDARD target with \"",
          "767:       \"ACCEPT/DROP\\n\");",
          "769:    }",
          "",
          "[Added Lines]",
          "657:    if (!check_underflow(e))",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "818:   newinfo->underflow[i] = 0xFFFFFFFF;",
          "819:  }",
          "822:  i = 0;",
          "824:  xt_entry_foreach(iter, entry0, newinfo->size) {",
          "",
          "[Removed Lines]",
          "821:  duprintf(\"translate_table: size %u\\n\", newinfo->size);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "835:    ++newinfo->stacksize;",
          "836:  }",
          "841:   return -EINVAL;",
          "845:  for (i = 0; i < NF_INET_NUMHOOKS; i++) {",
          "847:   if (!(repl->valid_hooks & (1 << i)))",
          "848:    continue;",
          "852:    return -EINVAL;",
          "857:    return -EINVAL;",
          "859:  }",
          "861:  if (!mark_source_chains(newinfo, repl->valid_hooks, entry0))",
          "",
          "[Removed Lines]",
          "838:  if (i != repl->num_entries) {",
          "839:   duprintf(\"translate_table: %u not %u entries\\n\",",
          "840:     i, repl->num_entries);",
          "842:  }",
          "849:   if (newinfo->hook_entry[i] == 0xFFFFFFFF) {",
          "850:    duprintf(\"Invalid hook entry %u %u\\n\",",
          "851:      i, repl->hook_entry[i]);",
          "853:   }",
          "854:   if (newinfo->underflow[i] == 0xFFFFFFFF) {",
          "855:    duprintf(\"Invalid underflow %u %u\\n\",",
          "856:      i, repl->underflow[i]);",
          "858:   }",
          "",
          "[Added Lines]",
          "727:  if (i != repl->num_entries)",
          "735:   if (newinfo->hook_entry[i] == 0xFFFFFFFF)",
          "737:   if (newinfo->underflow[i] == 0xFFFFFFFF)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1083:  struct xt_table *t;",
          "1084:  int ret;",
          "1089:   return -EINVAL;",
          "1092:  if (copy_from_user(name, user, sizeof(name)) != 0)",
          "1093:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "1086:  if (*len != sizeof(struct ipt_getinfo)) {",
          "1087:   duprintf(\"length %u != %zu\\n\", *len,",
          "1088:     sizeof(struct ipt_getinfo));",
          "1090:  }",
          "",
          "[Added Lines]",
          "966:  if (*len != sizeof(struct ipt_getinfo))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1145:  struct ipt_get_entries get;",
          "1146:  struct xt_table *t;",
          "1150:   return -EINVAL;",
          "1152:  if (copy_from_user(&get, uptr, sizeof(get)) != 0)",
          "1153:   return -EFAULT;",
          "1157:   return -EINVAL;",
          "1159:  get.name[sizeof(get.name) - 1] = '\\0';",
          "1161:  t = xt_find_table_lock(net, AF_INET, get.name);",
          "1162:  if (!IS_ERR_OR_NULL(t)) {",
          "1163:   const struct xt_table_info *private = t->private;",
          "1165:   if (get.size == private->size)",
          "1166:    ret = copy_entries_to_user(private->size,",
          "1167:          t, uptr->entrytable);",
          "1171:    ret = -EAGAIN;",
          "1173:   module_put(t->me);",
          "1174:   xt_table_unlock(t);",
          "1175:  } else",
          "",
          "[Removed Lines]",
          "1148:  if (*len < sizeof(get)) {",
          "1149:   duprintf(\"get_entries: %u < %zu\\n\", *len, sizeof(get));",
          "1151:  }",
          "1154:  if (*len != sizeof(struct ipt_get_entries) + get.size) {",
          "1155:   duprintf(\"get_entries: %u != %zu\\n\",",
          "1158:  }",
          "1164:   duprintf(\"t->private->number = %u\\n\", private->number);",
          "1168:   else {",
          "1169:    duprintf(\"get_entries: I've got %u not %u!\\n\",",
          "1170:      private->size, get.size);",
          "1172:   }",
          "",
          "[Added Lines]",
          "1025:  if (*len < sizeof(get))",
          "1029:  if (*len != sizeof(struct ipt_get_entries) + get.size)",
          "1039:   else",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1207:  if (valid_hooks != t->valid_hooks) {",
          "1210:   ret = -EINVAL;",
          "1211:   goto put_module;",
          "1212:  }",
          "",
          "[Removed Lines]",
          "1208:   duprintf(\"Valid hook crap: %08X vs %08X\\n\",",
          "1209:     valid_hooks, t->valid_hooks);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1216:   goto put_module;",
          "1221:  if ((oldinfo->number > oldinfo->initial_entries) ||",
          "1222:      (newinfo->number <= oldinfo->initial_entries))",
          "1223:   module_put(t->me);",
          "",
          "[Removed Lines]",
          "1219:  duprintf(\"do_replace: oldnum=%u, initnum=%u, newnum=%u\\n\",",
          "1220:   oldinfo->number, oldinfo->initial_entries, newinfo->number);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1286:  if (ret != 0)",
          "1287:   goto free_newinfo;",
          "1291:  ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,",
          "1292:       tmp.num_counters, tmp.counters);",
          "1293:  if (ret)",
          "",
          "[Removed Lines]",
          "1289:  duprintf(\"Translated table\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1414:  match = xt_request_find_match(NFPROTO_IPV4, m->u.user.name,",
          "1415:           m->u.user.revision);",
          "1419:   return PTR_ERR(match);",
          "1421:  m->u.kernel.match = match;",
          "1423:  return 0;",
          "",
          "[Removed Lines]",
          "1416:  if (IS_ERR(match)) {",
          "1417:   duprintf(\"compat_check_calc_match: `%s' not found\\n\",",
          "1418:     m->u.user.name);",
          "1420:  }",
          "",
          "[Added Lines]",
          "1279:  if (IS_ERR(match))",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1449:  unsigned int j;",
          "1450:  int ret, off;",
          "1453:  if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||",
          "1454:      (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||",
          "1457:   return -EINVAL;",
          "1460:  if (e->next_offset < sizeof(struct compat_ipt_entry) +",
          "1464:   return -EINVAL;",
          "1467:  if (!ip_checkentry(&e->ip))",
          "1468:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "1452:  duprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);",
          "1455:      (unsigned char *)e + e->next_offset > limit) {",
          "1456:   duprintf(\"Bad offset %p, limit = %p\\n\", e, limit);",
          "1458:  }",
          "1461:         sizeof(struct compat_xt_entry_target)) {",
          "1462:   duprintf(\"checking: element %p size %u\\n\",",
          "1463:     e, e->next_offset);",
          "1465:  }",
          "",
          "[Added Lines]",
          "1315:      (unsigned char *)e + e->next_offset > limit)",
          "1319:         sizeof(struct compat_xt_entry_target))",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1486:  target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,",
          "1487:      t->u.user.revision);",
          "1488:  if (IS_ERR(target)) {",
          "1491:   ret = PTR_ERR(target);",
          "1492:   goto release_matches;",
          "1493:  }",
          "",
          "[Removed Lines]",
          "1489:   duprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",",
          "1490:     t->u.user.name);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1569:  size = compatr->size;",
          "1570:  info->number = compatr->num_entries;",
          "1573:  j = 0;",
          "1574:  xt_compat_lock(AF_INET);",
          "1575:  xt_compat_init_offsets(AF_INET, compatr->num_entries);",
          "",
          "[Removed Lines]",
          "1572:  duprintf(\"translate_compat_table: size %u\\n\", info->size);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1584:  }",
          "1586:  ret = -EINVAL;",
          "1590:   goto out_unlock;",
          "1593:  ret = -ENOMEM;",
          "1594:  newinfo = xt_alloc_table_info(size);",
          "",
          "[Removed Lines]",
          "1587:  if (j != compatr->num_entries) {",
          "1588:   duprintf(\"translate_compat_table: %u not %u entries\\n\",",
          "1589:     j, compatr->num_entries);",
          "1591:  }",
          "",
          "[Added Lines]",
          "1439:  if (j != compatr->num_entries)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1685:  if (ret != 0)",
          "1686:   goto free_newinfo;",
          "1690:  ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,",
          "1691:       tmp.num_counters, compat_ptr(tmp.counters));",
          "1692:  if (ret)",
          "",
          "[Removed Lines]",
          "1688:  duprintf(\"compat_do_replace: Translated table\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1720:   break;",
          "1722:  default:",
          "1724:   ret = -EINVAL;",
          "1725:  }",
          "",
          "[Removed Lines]",
          "1723:   duprintf(\"do_ipt_set_ctl:  unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1770:  struct compat_ipt_get_entries get;",
          "1771:  struct xt_table *t;",
          "1775:   return -EINVAL;",
          "1778:  if (copy_from_user(&get, uptr, sizeof(get)) != 0)",
          "1779:   return -EFAULT;",
          "1784:   return -EINVAL;",
          "1786:  get.name[sizeof(get.name) - 1] = '\\0';",
          "1788:  xt_compat_lock(AF_INET);",
          "",
          "[Removed Lines]",
          "1773:  if (*len < sizeof(get)) {",
          "1774:   duprintf(\"compat_get_entries: %u < %zu\\n\", *len, sizeof(get));",
          "1776:  }",
          "1781:  if (*len != sizeof(struct compat_ipt_get_entries) + get.size) {",
          "1782:   duprintf(\"compat_get_entries: %u != %zu\\n\",",
          "1785:  }",
          "",
          "[Added Lines]",
          "1619:  if (*len < sizeof(get))",
          "1625:  if (*len != sizeof(struct compat_ipt_get_entries) + get.size)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1790:  if (!IS_ERR_OR_NULL(t)) {",
          "1791:   const struct xt_table_info *private = t->private;",
          "1792:   struct xt_table_info info;",
          "1794:   ret = compat_table_info(private, &info);",
          "1796:    ret = compat_copy_entries_to_user(private->size,",
          "1797:          t, uptr->entrytable);",
          "1801:    ret = -EAGAIN;",
          "1803:   xt_compat_flush_offsets(AF_INET);",
          "1804:   module_put(t->me);",
          "1805:   xt_table_unlock(t);",
          "",
          "[Removed Lines]",
          "1793:   duprintf(\"t->private->number = %u\\n\", private->number);",
          "1795:   if (!ret && get.size == info.size) {",
          "1798:   } else if (!ret) {",
          "1799:    duprintf(\"compat_get_entries: I've got %u not %u!\\n\",",
          "1800:      private->size, get.size);",
          "1802:   }",
          "",
          "[Added Lines]",
          "1636:   if (!ret && get.size == info.size)",
          "1639:   else if (!ret)",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1852:   break;",
          "1854:  default:",
          "1856:   ret = -EINVAL;",
          "1857:  }",
          "",
          "[Removed Lines]",
          "1855:   duprintf(\"do_ipt_set_ctl:  unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1904:  }",
          "1906:  default:",
          "1908:   ret = -EINVAL;",
          "1909:  }",
          "",
          "[Removed Lines]",
          "1907:   duprintf(\"do_ipt_get_ctl: unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2010:   par->hotdrop = true;",
          "2011:   return false;",
          "2012:  }",
          "",
          "[Removed Lines]",
          "2009:   duprintf(\"Dropping evil ICMP tinygram.\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "net/ipv6/netfilter/ip6_tables.c||net/ipv6/netfilter/ip6_tables.c": [
          "File: net/ipv6/netfilter/ip6_tables.c -> net/ipv6/netfilter/ip6_tables.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: MODULE_AUTHOR(\"Netfilter Core Team <coreteam@netfilter.org>\");",
          "40: MODULE_DESCRIPTION(\"IPv6 packet filter\");",
          "58: #ifdef CONFIG_NETFILTER_DEBUG",
          "59: #define IP_NF_ASSERT(x) WARN_ON(!(x))",
          "60: #else",
          "61: #define IP_NF_ASSERT(x)",
          "62: #endif",
          "70: void *ip6t_alloc_initial_table(const struct xt_table *info)",
          "71: {",
          "72:  return xt_alloc_initial_table(ip6t, IP6T);",
          "",
          "[Removed Lines]",
          "46: #ifdef DEBUG_IP_FIREWALL",
          "47: #define dprintf(format, args...) pr_info(format , ## args)",
          "48: #else",
          "49: #define dprintf(format, args...)",
          "50: #endif",
          "52: #ifdef DEBUG_IP_FIREWALL_USER",
          "53: #define duprintf(format, args...) pr_info(format , ## args)",
          "54: #else",
          "55: #define duprintf(format, args...)",
          "56: #endif",
          "64: #if 0",
          "66: #define static",
          "67: #define inline",
          "68: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:  if (FWINV(ipv6_masked_addr_cmp(&ipv6->saddr, &ip6info->smsk,",
          "101:            &ip6info->src), IP6T_INV_SRCIP) ||",
          "102:      FWINV(ipv6_masked_addr_cmp(&ipv6->daddr, &ip6info->dmsk,",
          "112:   return false;",
          "115:  ret = ifname_compare_aligned(indev, ip6info->iniface, ip6info->iniface_mask);",
          "121:   return false;",
          "124:  ret = ifname_compare_aligned(outdev, ip6info->outiface, ip6info->outiface_mask);",
          "130:   return false;",
          "",
          "[Removed Lines]",
          "103:            &ip6info->dst), IP6T_INV_DSTIP)) {",
          "104:   dprintf(\"Source or dest mismatch.\\n\");",
          "106:   dprintf(\"SRC: %u. Mask: %u. Target: %u.%s\\n\", ip->saddr,",
          "107:    ipinfo->smsk.s_addr, ipinfo->src.s_addr,",
          "108:    ipinfo->invflags & IP6T_INV_SRCIP ? \" (INV)\" : \"\");",
          "109:   dprintf(\"DST: %u. Mask: %u. Target: %u.%s\\n\", ip->daddr,",
          "110:    ipinfo->dmsk.s_addr, ipinfo->dst.s_addr,",
          "113:  }",
          "117:  if (FWINV(ret != 0, IP6T_INV_VIA_IN)) {",
          "118:   dprintf(\"VIA in mismatch (%s vs %s).%s\\n\",",
          "119:    indev, ip6info->iniface,",
          "120:    ip6info->invflags & IP6T_INV_VIA_IN ? \" (INV)\" : \"\");",
          "122:  }",
          "126:  if (FWINV(ret != 0, IP6T_INV_VIA_OUT)) {",
          "127:   dprintf(\"VIA out mismatch (%s vs %s).%s\\n\",",
          "128:    outdev, ip6info->outiface,",
          "129:    ip6info->invflags & IP6T_INV_VIA_OUT ? \" (INV)\" : \"\");",
          "131:  }",
          "",
          "[Added Lines]",
          "81:            &ip6info->dst), IP6T_INV_DSTIP))",
          "86:  if (FWINV(ret != 0, IP6T_INV_VIA_IN))",
          "91:  if (FWINV(ret != 0, IP6T_INV_VIA_OUT))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "145:   }",
          "153:   if (ip6info->proto == protohdr) {",
          "154:    if (ip6info->invflags & IP6T_INV_PROTO)",
          "155:     return false;",
          "",
          "[Removed Lines]",
          "148:   dprintf(\"Packet protocol %hi ?= %s%hi.\\n\",",
          "149:     protohdr,",
          "150:     ip6info->invflags & IP6T_INV_PROTO ? \"!\":\"\",",
          "151:     ip6info->proto);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "169: static bool",
          "170: ip6_checkentry(const struct ip6t_ip6 *ipv6)",
          "171: {",
          "175:   return false;",
          "180:   return false;",
          "182:  return true;",
          "183: }",
          "",
          "[Removed Lines]",
          "172:  if (ipv6->flags & ~IP6T_F_MASK) {",
          "173:   duprintf(\"Unknown flag bits set: %08X\\n\",",
          "174:     ipv6->flags & ~IP6T_F_MASK);",
          "176:  }",
          "177:  if (ipv6->invflags & ~IP6T_INV_MASK) {",
          "178:   duprintf(\"Unknown invflag bits set: %08X\\n\",",
          "179:     ipv6->invflags & ~IP6T_INV_MASK);",
          "181:  }",
          "",
          "[Added Lines]",
          "128:  if (ipv6->flags & ~IP6T_F_MASK)",
          "130:  if (ipv6->invflags & ~IP6T_INV_MASK)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "446:  xt_write_recseq_end(addend);",
          "447:  local_bh_enable();",
          "452:  if (acpar.hotdrop)",
          "453:   return NF_DROP;",
          "454:  else return verdict;",
          "456: }",
          "458: static bool find_jump_target(const struct xt_table_info *t,",
          "",
          "[Removed Lines]",
          "449: #ifdef DEBUG_ALLOW_ALL",
          "450:  return NF_ACCEPT;",
          "451: #else",
          "455: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "492:     = (void *)ip6t_get_target_c(e);",
          "493:    int visited = e->comefrom & (1 << hook);",
          "498:     return 0;",
          "500:    e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));",
          "",
          "[Removed Lines]",
          "495:    if (e->comefrom & (1 << NF_INET_NUMHOOKS)) {",
          "496:     pr_err(\"iptables: loop hook %u pos %u %08X.\\n\",",
          "497:            hook, pos, e->comefrom);",
          "499:    }",
          "",
          "[Added Lines]",
          "442:    if (e->comefrom & (1 << NF_INET_NUMHOOKS))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "509:     if ((strcmp(t->target.u.user.name,",
          "510:          XT_STANDARD_TARGET) == 0) &&",
          "515:      return 0;",
          "520:     do {",
          "521:      e->comefrom ^= (1<<NF_INET_NUMHOOKS);",
          "531:      oldpos = pos;",
          "532:      pos = e->counters.pcnt;",
          "533:      e->counters.pcnt = 0;",
          "",
          "[Removed Lines]",
          "511:         t->verdict < -NF_MAX_VERDICT - 1) {",
          "512:      duprintf(\"mark_source_chains: bad \"",
          "513:       \"negative verdict (%i)\\n\",",
          "514:         t->verdict);",
          "516:     }",
          "522: #ifdef DEBUG_IP_FIREWALL_USER",
          "523:      if (e->comefrom",
          "524:          & (1 << NF_INET_NUMHOOKS)) {",
          "525:       duprintf(\"Back unset \"",
          "526:         \"on hook %u \"",
          "527:         \"rule %u\\n\",",
          "528:         hook, pos);",
          "529:      }",
          "530: #endif",
          "",
          "[Added Lines]",
          "456:         t->verdict < -NF_MAX_VERDICT - 1)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "555:         XT_STANDARD_TARGET) == 0 &&",
          "556:         newpos >= 0) {",
          "560:      e = (struct ip6t_entry *)",
          "561:       (entry0 + newpos);",
          "562:      if (!find_jump_target(newinfo, e))",
          "",
          "[Removed Lines]",
          "558:      duprintf(\"Jump rule %u -> %u\\n\",",
          "559:        pos, newpos);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "573:     pos = newpos;",
          "574:    }",
          "575:   }",
          "578:  }",
          "579:  return 1;",
          "580: }",
          "",
          "[Removed Lines]",
          "576: next:",
          "577:   duprintf(\"Finished chain %u\\n\", hook);",
          "",
          "[Added Lines]",
          "506: next:  ;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "595: static int check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)",
          "596: {",
          "597:  const struct ip6t_ip6 *ipv6 = par->entryinfo;",
          "600:  par->match     = m->u.kernel.match;",
          "601:  par->matchinfo = m->data;",
          "611: }",
          "613: static int",
          "",
          "[Removed Lines]",
          "598:  int ret;",
          "603:  ret = xt_check_match(par, m->u.match_size - sizeof(*m),",
          "604:         ipv6->proto, ipv6->invflags & IP6T_INV_PROTO);",
          "605:  if (ret < 0) {",
          "606:   duprintf(\"ip_tables: check failed for `%s'.\\n\",",
          "607:     par.match->name);",
          "608:   return ret;",
          "609:  }",
          "610:  return 0;",
          "",
          "[Added Lines]",
          "531:  return xt_check_match(par, m->u.match_size - sizeof(*m),",
          "532:          ipv6->proto, ipv6->invflags & IP6T_INV_PROTO);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "619:  match = xt_request_find_match(NFPROTO_IPV6, m->u.user.name,",
          "620:           m->u.user.revision);",
          "623:   return PTR_ERR(match);",
          "625:  m->u.kernel.match = match;",
          "627:  ret = check_match(m, par);",
          "",
          "[Removed Lines]",
          "621:  if (IS_ERR(match)) {",
          "622:   duprintf(\"find_check_match: `%s' not found\\n\", m->u.user.name);",
          "624:  }",
          "",
          "[Added Lines]",
          "543:  if (IS_ERR(match))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "646:   .hook_mask = e->comefrom,",
          "647:   .family    = NFPROTO_IPV6,",
          "648:  };",
          "651:  t = ip6t_get_target(e);",
          "660: }",
          "662: static int",
          "",
          "[Removed Lines]",
          "649:  int ret;",
          "652:  ret = xt_check_target(&par, t->u.target_size - sizeof(*t),",
          "653:        e->ipv6.proto, e->ipv6.invflags & IP6T_INV_PROTO);",
          "654:  if (ret < 0) {",
          "655:   duprintf(\"ip_tables: check failed for `%s'.\\n\",",
          "656:     t->u.kernel.target->name);",
          "657:   return ret;",
          "658:  }",
          "659:  return 0;",
          "",
          "[Added Lines]",
          "572:  return xt_check_target(&par, t->u.target_size - sizeof(*t),",
          "573:           e->ipv6.proto,",
          "574:           e->ipv6.invflags & IP6T_INV_PROTO);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "693:  target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,",
          "694:      t->u.user.revision);",
          "695:  if (IS_ERR(target)) {",
          "697:   ret = PTR_ERR(target);",
          "698:   goto cleanup_matches;",
          "699:  }",
          "",
          "[Removed Lines]",
          "696:   duprintf(\"find_check_entry: `%s' not found\\n\", t->u.user.name);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "747:  if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||",
          "748:      (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||",
          "751:   return -EINVAL;",
          "754:  if (e->next_offset",
          "758:   return -EINVAL;",
          "761:  if (!ip6_checkentry(&e->ipv6))",
          "762:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "749:      (unsigned char *)e + e->next_offset > limit) {",
          "750:   duprintf(\"Bad offset %p\\n\", e);",
          "752:  }",
          "755:      < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {",
          "756:   duprintf(\"checking: element %p size %u\\n\",",
          "757:     e, e->next_offset);",
          "759:  }",
          "",
          "[Added Lines]",
          "663:      (unsigned char *)e + e->next_offset > limit)",
          "667:      < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target))",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "773:   if ((unsigned char *)e - base == hook_entries[h])",
          "774:    newinfo->hook_entry[h] = hook_entries[h];",
          "775:   if ((unsigned char *)e - base == underflows[h]) {",
          "780:     return -EINVAL;",
          "782:    newinfo->underflow[h] = underflows[h];",
          "783:   }",
          "784:  }",
          "",
          "[Removed Lines]",
          "776:    if (!check_underflow(e)) {",
          "777:     pr_debug(\"Underflows must be unconditional and \"",
          "778:       \"use the STANDARD target with \"",
          "779:       \"ACCEPT/DROP\\n\");",
          "781:    }",
          "",
          "[Added Lines]",
          "685:    if (!check_underflow(e))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "830:   newinfo->underflow[i] = 0xFFFFFFFF;",
          "831:  }",
          "834:  i = 0;",
          "836:  xt_entry_foreach(iter, entry0, newinfo->size) {",
          "",
          "[Removed Lines]",
          "833:  duprintf(\"translate_table: size %u\\n\", newinfo->size);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "847:    ++newinfo->stacksize;",
          "848:  }",
          "853:   return -EINVAL;",
          "857:  for (i = 0; i < NF_INET_NUMHOOKS; i++) {",
          "859:   if (!(repl->valid_hooks & (1 << i)))",
          "860:    continue;",
          "864:    return -EINVAL;",
          "869:    return -EINVAL;",
          "871:  }",
          "873:  if (!mark_source_chains(newinfo, repl->valid_hooks, entry0))",
          "",
          "[Removed Lines]",
          "850:  if (i != repl->num_entries) {",
          "851:   duprintf(\"translate_table: %u not %u entries\\n\",",
          "852:     i, repl->num_entries);",
          "854:  }",
          "861:   if (newinfo->hook_entry[i] == 0xFFFFFFFF) {",
          "862:    duprintf(\"Invalid hook entry %u %u\\n\",",
          "863:      i, repl->hook_entry[i]);",
          "865:   }",
          "866:   if (newinfo->underflow[i] == 0xFFFFFFFF) {",
          "867:    duprintf(\"Invalid underflow %u %u\\n\",",
          "868:      i, repl->underflow[i]);",
          "870:   }",
          "",
          "[Added Lines]",
          "755:  if (i != repl->num_entries)",
          "763:   if (newinfo->hook_entry[i] == 0xFFFFFFFF)",
          "765:   if (newinfo->underflow[i] == 0xFFFFFFFF)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1095:  struct xt_table *t;",
          "1096:  int ret;",
          "1101:   return -EINVAL;",
          "1104:  if (copy_from_user(name, user, sizeof(name)) != 0)",
          "1105:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "1098:  if (*len != sizeof(struct ip6t_getinfo)) {",
          "1099:   duprintf(\"length %u != %zu\\n\", *len,",
          "1100:     sizeof(struct ip6t_getinfo));",
          "1102:  }",
          "",
          "[Added Lines]",
          "994:  if (*len != sizeof(struct ip6t_getinfo))",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1157:  struct ip6t_get_entries get;",
          "1158:  struct xt_table *t;",
          "1162:   return -EINVAL;",
          "1164:  if (copy_from_user(&get, uptr, sizeof(get)) != 0)",
          "1165:   return -EFAULT;",
          "1169:   return -EINVAL;",
          "1171:  get.name[sizeof(get.name) - 1] = '\\0';",
          "1173:  t = xt_find_table_lock(net, AF_INET6, get.name);",
          "1174:  if (!IS_ERR_OR_NULL(t)) {",
          "1175:   struct xt_table_info *private = t->private;",
          "1177:   if (get.size == private->size)",
          "1178:    ret = copy_entries_to_user(private->size,",
          "1179:          t, uptr->entrytable);",
          "1183:    ret = -EAGAIN;",
          "1185:   module_put(t->me);",
          "1186:   xt_table_unlock(t);",
          "1187:  } else",
          "",
          "[Removed Lines]",
          "1160:  if (*len < sizeof(get)) {",
          "1161:   duprintf(\"get_entries: %u < %zu\\n\", *len, sizeof(get));",
          "1163:  }",
          "1166:  if (*len != sizeof(struct ip6t_get_entries) + get.size) {",
          "1167:   duprintf(\"get_entries: %u != %zu\\n\",",
          "1170:  }",
          "1176:   duprintf(\"t->private->number = %u\\n\", private->number);",
          "1180:   else {",
          "1181:    duprintf(\"get_entries: I've got %u not %u!\\n\",",
          "1182:      private->size, get.size);",
          "1184:   }",
          "",
          "[Added Lines]",
          "1053:  if (*len < sizeof(get))",
          "1057:  if (*len != sizeof(struct ip6t_get_entries) + get.size)",
          "1068:   else",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1219:  if (valid_hooks != t->valid_hooks) {",
          "1222:   ret = -EINVAL;",
          "1223:   goto put_module;",
          "1224:  }",
          "",
          "[Removed Lines]",
          "1220:   duprintf(\"Valid hook crap: %08X vs %08X\\n\",",
          "1221:     valid_hooks, t->valid_hooks);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1228:   goto put_module;",
          "1233:  if ((oldinfo->number > oldinfo->initial_entries) ||",
          "1234:      (newinfo->number <= oldinfo->initial_entries))",
          "1235:   module_put(t->me);",
          "",
          "[Removed Lines]",
          "1231:  duprintf(\"do_replace: oldnum=%u, initnum=%u, newnum=%u\\n\",",
          "1232:   oldinfo->number, oldinfo->initial_entries, newinfo->number);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1298:  if (ret != 0)",
          "1299:   goto free_newinfo;",
          "1303:  ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,",
          "1304:       tmp.num_counters, tmp.counters);",
          "1305:  if (ret)",
          "",
          "[Removed Lines]",
          "1301:  duprintf(\"ip_tables: Translated table\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1425:  match = xt_request_find_match(NFPROTO_IPV6, m->u.user.name,",
          "1426:           m->u.user.revision);",
          "1430:   return PTR_ERR(match);",
          "1432:  m->u.kernel.match = match;",
          "1434:  return 0;",
          "",
          "[Removed Lines]",
          "1427:  if (IS_ERR(match)) {",
          "1428:   duprintf(\"compat_check_calc_match: `%s' not found\\n\",",
          "1429:     m->u.user.name);",
          "1431:  }",
          "",
          "[Added Lines]",
          "1307:  if (IS_ERR(match))",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1460:  unsigned int j;",
          "1461:  int ret, off;",
          "1464:  if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||",
          "1465:      (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||",
          "1468:   return -EINVAL;",
          "1471:  if (e->next_offset < sizeof(struct compat_ip6t_entry) +",
          "1475:   return -EINVAL;",
          "1478:  if (!ip6_checkentry(&e->ipv6))",
          "1479:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "1463:  duprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);",
          "1466:      (unsigned char *)e + e->next_offset > limit) {",
          "1467:   duprintf(\"Bad offset %p, limit = %p\\n\", e, limit);",
          "1469:  }",
          "1472:         sizeof(struct compat_xt_entry_target)) {",
          "1473:   duprintf(\"checking: element %p size %u\\n\",",
          "1474:     e, e->next_offset);",
          "1476:  }",
          "",
          "[Added Lines]",
          "1343:      (unsigned char *)e + e->next_offset > limit)",
          "1347:         sizeof(struct compat_xt_entry_target))",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1497:  target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,",
          "1498:      t->u.user.revision);",
          "1499:  if (IS_ERR(target)) {",
          "1502:   ret = PTR_ERR(target);",
          "1503:   goto release_matches;",
          "1504:  }",
          "",
          "[Removed Lines]",
          "1500:   duprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",",
          "1501:     t->u.user.name);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1577:  size = compatr->size;",
          "1578:  info->number = compatr->num_entries;",
          "1581:  j = 0;",
          "1582:  xt_compat_lock(AF_INET6);",
          "1583:  xt_compat_init_offsets(AF_INET6, compatr->num_entries);",
          "",
          "[Removed Lines]",
          "1580:  duprintf(\"translate_compat_table: size %u\\n\", info->size);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1592:  }",
          "1594:  ret = -EINVAL;",
          "1598:   goto out_unlock;",
          "1601:  ret = -ENOMEM;",
          "1602:  newinfo = xt_alloc_table_info(size);",
          "",
          "[Removed Lines]",
          "1595:  if (j != compatr->num_entries) {",
          "1596:   duprintf(\"translate_compat_table: %u not %u entries\\n\",",
          "1597:     j, compatr->num_entries);",
          "1599:  }",
          "",
          "[Added Lines]",
          "1464:  if (j != compatr->num_entries)",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1687:  if (ret != 0)",
          "1688:   goto free_newinfo;",
          "1692:  ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,",
          "1693:       tmp.num_counters, compat_ptr(tmp.counters));",
          "1694:  if (ret)",
          "",
          "[Removed Lines]",
          "1690:  duprintf(\"compat_do_replace: Translated table\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1722:   break;",
          "1724:  default:",
          "1726:   ret = -EINVAL;",
          "1727:  }",
          "",
          "[Removed Lines]",
          "1725:   duprintf(\"do_ip6t_set_ctl:  unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1772:  struct compat_ip6t_get_entries get;",
          "1773:  struct xt_table *t;",
          "1777:   return -EINVAL;",
          "1780:  if (copy_from_user(&get, uptr, sizeof(get)) != 0)",
          "1781:   return -EFAULT;",
          "1786:   return -EINVAL;",
          "1788:  get.name[sizeof(get.name) - 1] = '\\0';",
          "1790:  xt_compat_lock(AF_INET6);",
          "",
          "[Removed Lines]",
          "1775:  if (*len < sizeof(get)) {",
          "1776:   duprintf(\"compat_get_entries: %u < %zu\\n\", *len, sizeof(get));",
          "1778:  }",
          "1783:  if (*len != sizeof(struct compat_ip6t_get_entries) + get.size) {",
          "1784:   duprintf(\"compat_get_entries: %u != %zu\\n\",",
          "1787:  }",
          "",
          "[Added Lines]",
          "1638:  if (*len < sizeof(get))",
          "1644:  if (*len != sizeof(struct compat_ip6t_get_entries) + get.size)",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1792:  if (!IS_ERR_OR_NULL(t)) {",
          "1793:   const struct xt_table_info *private = t->private;",
          "1794:   struct xt_table_info info;",
          "1796:   ret = compat_table_info(private, &info);",
          "1798:    ret = compat_copy_entries_to_user(private->size,",
          "1799:          t, uptr->entrytable);",
          "1803:    ret = -EAGAIN;",
          "1805:   xt_compat_flush_offsets(AF_INET6);",
          "1806:   module_put(t->me);",
          "1807:   xt_table_unlock(t);",
          "",
          "[Removed Lines]",
          "1795:   duprintf(\"t->private->number = %u\\n\", private->number);",
          "1797:   if (!ret && get.size == info.size) {",
          "1800:   } else if (!ret) {",
          "1801:    duprintf(\"compat_get_entries: I've got %u not %u!\\n\",",
          "1802:      private->size, get.size);",
          "1804:   }",
          "",
          "[Added Lines]",
          "1655:   if (!ret && get.size == info.size)",
          "1658:   else if (!ret)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1854:   break;",
          "1856:  default:",
          "1858:   ret = -EINVAL;",
          "1859:  }",
          "",
          "[Removed Lines]",
          "1857:   duprintf(\"do_ip6t_set_ctl:  unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1906:  }",
          "1908:  default:",
          "1910:   ret = -EINVAL;",
          "1911:  }",
          "",
          "[Removed Lines]",
          "1909:   duprintf(\"do_ip6t_get_ctl: unknown request %i\\n\", cmd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2012:   par->hotdrop = true;",
          "2013:   return false;",
          "2014:  }",
          "",
          "[Removed Lines]",
          "2011:   duprintf(\"Dropping evil ICMP tinygram.\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
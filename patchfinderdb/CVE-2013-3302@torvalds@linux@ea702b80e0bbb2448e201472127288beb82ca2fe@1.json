{
  "cve_id": "CVE-2013-3302",
  "cve_desc": "Race condition in the smb_send_rqst function in fs/cifs/transport.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact via vectors involving a reconnection event.",
  "repo": "torvalds/linux",
  "patch_hash": "ea702b80e0bbb2448e201472127288beb82ca2fe",
  "patch_info": {
    "commit_hash": "ea702b80e0bbb2448e201472127288beb82ca2fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ea702b80e0bbb2448e201472127288beb82ca2fe",
    "files": [
      "fs/cifs/transport.c"
    ],
    "message": "cifs: move check for NULL socket into smb_send_rqst\n\nCai reported this oops:\n\n[90701.616664] BUG: unable to handle kernel NULL pointer dereference at 0000000000000028\n[90701.625438] IP: [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.632167] PGD fea319067 PUD 103fda4067 PMD 0\n[90701.637255] Oops: 0000 [#1] SMP\n[90701.640878] Modules linked in: des_generic md4 nls_utf8 cifs dns_resolver binfmt_misc tun sg igb iTCO_wdt iTCO_vendor_support lpc_ich pcspkr i2c_i801 i2c_core i7core_edac edac_core ioatdma dca mfd_core coretemp kvm_intel kvm crc32c_intel microcode sr_mod cdrom ata_generic sd_mod pata_acpi crc_t10dif ata_piix libata megaraid_sas dm_mirror dm_region_hash dm_log dm_mod\n[90701.677655] CPU 10\n[90701.679808] Pid: 9627, comm: ls Tainted: G        W    3.7.1+ #10 QCI QSSC-S4R/QSSC-S4R\n[90701.688950] RIP: 0010:[<ffffffff814a343e>]  [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.698383] RSP: 0018:ffff88177b431bb8  EFLAGS: 00010206\n[90701.704309] RAX: ffff88177b431fd8 RBX: 00007ffffffff000 RCX: ffff88177b431bec\n[90701.712271] RDX: 0000000000000003 RSI: 0000000000000006 RDI: 0000000000000000\n[90701.720223] RBP: ffff88177b431bc8 R08: 0000000000000004 R09: 0000000000000000\n[90701.728185] R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000001\n[90701.736147] R13: ffff88184ef92000 R14: 0000000000000023 R15: ffff88177b431c88\n[90701.744109] FS:  00007fd56a1a47c0(0000) GS:ffff88105fc40000(0000) knlGS:0000000000000000\n[90701.753137] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[90701.759550] CR2: 0000000000000028 CR3: 000000104f15f000 CR4: 00000000000007e0\n[90701.767512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[90701.775465] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[90701.783428] Process ls (pid: 9627, threadinfo ffff88177b430000, task ffff88185ca4cb60)\n[90701.792261] Stack:\n[90701.794505]  0000000000000023 ffff88177b431c50 ffff88177b431c38 ffffffffa014fcb1\n[90701.802809]  ffff88184ef921bc 0000000000000000 00000001ffffffff ffff88184ef921c0\n[90701.811123]  ffff88177b431c08 ffffffff815ca3d9 ffff88177b431c18 ffff880857758000\n[90701.819433] Call Trace:\n[90701.822183]  [<ffffffffa014fcb1>] smb_send_rqst+0x71/0x1f0 [cifs]\n[90701.828991]  [<ffffffff815ca3d9>] ? schedule+0x29/0x70\n[90701.834736]  [<ffffffffa014fe6d>] smb_sendv+0x3d/0x40 [cifs]\n[90701.841062]  [<ffffffffa014fe96>] smb_send+0x26/0x30 [cifs]\n[90701.847291]  [<ffffffffa015801f>] send_nt_cancel+0x6f/0xd0 [cifs]\n[90701.854102]  [<ffffffffa015075e>] SendReceive+0x18e/0x360 [cifs]\n[90701.860814]  [<ffffffffa0134a78>] CIFSFindFirst+0x1a8/0x3f0 [cifs]\n[90701.867724]  [<ffffffffa013f731>] ? build_path_from_dentry+0xf1/0x260 [cifs]\n[90701.875601]  [<ffffffffa013f731>] ? build_path_from_dentry+0xf1/0x260 [cifs]\n[90701.883477]  [<ffffffffa01578e6>] cifs_query_dir_first+0x26/0x30 [cifs]\n[90701.890869]  [<ffffffffa015480d>] initiate_cifs_search+0xed/0x250 [cifs]\n[90701.898354]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.904486]  [<ffffffffa01554cb>] cifs_readdir+0x45b/0x8f0 [cifs]\n[90701.911288]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.917410]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.923533]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.929657]  [<ffffffff81195848>] vfs_readdir+0xb8/0xe0\n[90701.935490]  [<ffffffff81195b9f>] sys_getdents+0x8f/0x110\n[90701.941521]  [<ffffffff815d3b99>] system_call_fastpath+0x16/0x1b\n[90701.948222] Code: 66 90 55 65 48 8b 04 25 f0 c6 00 00 48 89 e5 53 48 83 ec 08 83 fe 01 48 8b 98 48 e0 ff ff 48 c7 80 48 e0 ff ff ff ff ff ff 74 22 <48> 8b 47 28 ff 50 68 65 48 8b 14 25 f0 c6 00 00 48 89 9a 48 e0\n[90701.970313] RIP  [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.977125]  RSP <ffff88177b431bb8>\n[90701.981018] CR2: 0000000000000028\n[90701.984809] ---[ end trace 24bd602971110a43 ]---\n\nThis is likely due to a race vs. a reconnection event.\n\nThe current code checks for a NULL socket in smb_send_kvec, but that's\ntoo late. By the time that check is done, the socket will already have\nbeen passed to kernel_setsockopt. Move the check into smb_send_rqst, so\nthat it's checked earlier.\n\nIn truth, this is a bit of a half-assed fix. The -ENOTSOCK error\nreturn here looks like it could bubble back up to userspace. The locking\nrules around the ssocket pointer are really unclear as well. There are\ncases where the ssocket pointer is changed without holding the srv_mutex,\nbut I'm not clear whether there's a potential race here yet or not.\n\nThis code seems like it could benefit from some fundamental re-think of\nhow the socket handling should behave. Until then though, this patch\nshould at least fix the above oops in most cases.\n\nCc: <stable@vger.kernel.org> # 3.7+\nReported-and-Tested-by: CAI Qian <caiqian@redhat.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>",
    "before_after_code_files": [
      "fs/cifs/transport.c||fs/cifs/transport.c"
    ]
  },
  "patch_diff": {
    "fs/cifs/transport.c||fs/cifs/transport.c": [
      "File: fs/cifs/transport.c -> fs/cifs/transport.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:  smb_msg.msg_name = (struct sockaddr *) &server->dstaddr;",
      "151:  smb_msg.msg_namelen = sizeof(struct sockaddr);",
      "152:  smb_msg.msg_control = NULL;",
      "",
      "[Removed Lines]",
      "147:  if (ssocket == NULL)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "291:  struct socket *ssocket = server->ssocket;",
      "292:  int val = 1;",
      "294:  cFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);",
      "295:  dump_smb(iov[0].iov_base, iov[0].iov_len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291:  if (ssocket == NULL)",
      "292:   return -ENOTSOCK;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "42288fe366c4f1ce7522bc9f27d0bc2a81c55264",
      "candidate_info": {
        "commit_hash": "42288fe366c4f1ce7522bc9f27d0bc2a81c55264",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/42288fe366c4f1ce7522bc9f27d0bc2a81c55264",
        "files": [
          "include/linux/mempolicy.h",
          "mm/mempolicy.c"
        ],
        "message": "mm: mempolicy: Convert shared_policy mutex to spinlock\n\nSasha was fuzzing with trinity and reported the following problem:\n\n  BUG: sleeping function called from invalid context at kernel/mutex.c:269\n  in_atomic(): 1, irqs_disabled(): 0, pid: 6361, name: trinity-main\n  2 locks held by trinity-main/6361:\n   #0:  (&mm->mmap_sem){++++++}, at: [<ffffffff810aa314>] __do_page_fault+0x1e4/0x4f0\n   #1:  (&(&mm->page_table_lock)->rlock){+.+...}, at: [<ffffffff8122f017>] handle_pte_fault+0x3f7/0x6a0\n  Pid: 6361, comm: trinity-main Tainted: G        W\n  3.7.0-rc2-next-20121024-sasha-00001-gd95ef01-dirty #74\n  Call Trace:\n    __might_sleep+0x1c3/0x1e0\n    mutex_lock_nested+0x29/0x50\n    mpol_shared_policy_lookup+0x2e/0x90\n    shmem_get_policy+0x2e/0x30\n    get_vma_policy+0x5a/0xa0\n    mpol_misplaced+0x41/0x1d0\n    handle_pte_fault+0x465/0x6a0\n\nThis was triggered by a different version of automatic NUMA balancing\nbut in theory the current version is vunerable to the same problem.\n\ndo_numa_page\n  -> numa_migrate_prep\n    -> mpol_misplaced\n      -> get_vma_policy\n        -> shmem_get_policy\n\nIt's very unlikely this will happen as shared pages are not marked\npte_numa -- see the page_mapcount() check in change_pte_range() -- but\nit is possible.\n\nTo address this, this patch restores sp->lock as originally implemented\nby Kosaki Motohiro.  In the path where get_vma_policy() is called, it\nshould not be calling sp_alloc() so it is not necessary to treat the PTL\nspecially.\n\nSigned-off-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nTested-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nSigned-off-by: Mel Gorman <mgorman@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/mempolicy.h||include/linux/mempolicy.h",
          "mm/mempolicy.c||mm/mempolicy.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/linux/mempolicy.h||include/linux/mempolicy.h": [
          "File: include/linux/mempolicy.h -> include/linux/mempolicy.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "124: struct shared_policy {",
          "125:  struct rb_root root;",
          "127: };",
          "129: void mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol);",
          "",
          "[Removed Lines]",
          "126:  struct mutex mutex;",
          "",
          "[Added Lines]",
          "126:  spinlock_t lock;",
          "",
          "---------------"
        ],
        "mm/mempolicy.c||mm/mempolicy.c": [
          "File: mm/mempolicy.c -> mm/mempolicy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2197:  if (!sp->root.rb_node)",
          "2198:   return NULL;",
          "2200:  sn = sp_lookup(sp, idx, idx+1);",
          "2201:  if (sn) {",
          "2202:   mpol_get(sn->policy);",
          "2203:   pol = sn->policy;",
          "2204:  }",
          "2206:  return pol;",
          "2207: }",
          "",
          "[Removed Lines]",
          "2199:  mutex_lock(&sp->mutex);",
          "2205:  mutex_unlock(&sp->mutex);",
          "",
          "[Added Lines]",
          "2199:  spin_lock(&sp->lock);",
          "2205:  spin_unlock(&sp->lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2328:  sp_free(n);",
          "2329: }",
          "2331: static struct sp_node *sp_alloc(unsigned long start, unsigned long end,",
          "2332:     struct mempolicy *pol)",
          "2333: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2331: static void sp_node_init(struct sp_node *node, unsigned long start,",
          "2332:    unsigned long end, struct mempolicy *pol)",
          "2333: {",
          "2334:  node->start = start;",
          "2335:  node->end = end;",
          "2336:  node->policy = pol;",
          "2337: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2344:   return NULL;",
          "2345:  }",
          "2346:  newpol->flags |= MPOL_F_SHARED;",
          "2352:  return n;",
          "2353: }",
          "",
          "[Removed Lines]",
          "2348:  n->start = start;",
          "2349:  n->end = end;",
          "2350:  n->policy = newpol;",
          "",
          "[Added Lines]",
          "2355:  sp_node_init(n, start, end, newpol);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2357:      unsigned long end, struct sp_node *new)",
          "2358: {",
          "2359:  struct sp_node *n;",
          "2360:  int ret = 0;",
          "2363:  n = sp_lookup(sp, start, end);",
          "2365:  while (n && n->start < end) {",
          "",
          "[Removed Lines]",
          "2362:  mutex_lock(&sp->mutex);",
          "",
          "[Added Lines]",
          "2365:  struct sp_node *n_new = NULL;",
          "2366:  struct mempolicy *mpol_new = NULL;",
          "2369: restart:",
          "2370:  spin_lock(&sp->lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2372:   } else {",
          "2374:    if (n->end > end) {",
          "2381:     n->end = start;",
          "2383:     break;",
          "2384:    } else",
          "2385:     n->end = start;",
          "",
          "[Removed Lines]",
          "2375:     struct sp_node *new2;",
          "2376:     new2 = sp_alloc(end, n->end, n->policy);",
          "2377:     if (!new2) {",
          "2378:      ret = -ENOMEM;",
          "2379:      goto out;",
          "2380:     }",
          "2382:     sp_insert(sp, new2);",
          "",
          "[Added Lines]",
          "2383:     if (!n_new)",
          "2384:      goto alloc_new;",
          "2387:     atomic_set(&mpol_new->refcnt, 1);",
          "2388:     sp_node_init(n_new, n->end, end, mpol_new);",
          "2389:     sp_insert(sp, n_new);",
          "2391:     n_new = NULL;",
          "2392:     mpol_new = NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2390:  }",
          "2391:  if (new)",
          "2392:   sp_insert(sp, new);",
          "2395:  return ret;",
          "2396: }",
          "",
          "[Removed Lines]",
          "2393: out:",
          "2394:  mutex_unlock(&sp->mutex);",
          "",
          "[Added Lines]",
          "2403:  spin_unlock(&sp->lock);",
          "2404:  ret = 0;",
          "2406: err_out:",
          "2407:  if (mpol_new)",
          "2408:   mpol_put(mpol_new);",
          "2409:  if (n_new)",
          "2410:   kmem_cache_free(sn_cache, n_new);",
          "2414: alloc_new:",
          "2415:  spin_unlock(&sp->lock);",
          "2416:  ret = -ENOMEM;",
          "2417:  n_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);",
          "2418:  if (!n_new)",
          "2419:   goto err_out;",
          "2420:  mpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);",
          "2421:  if (!mpol_new)",
          "2422:   goto err_out;",
          "2423:  goto restart;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2410:  int ret;",
          "2415:  if (mpol) {",
          "2416:   struct vm_area_struct pvma;",
          "",
          "[Removed Lines]",
          "2413:  mutex_init(&sp->mutex);",
          "",
          "[Added Lines]",
          "2441:  spin_lock_init(&sp->lock);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2477:  if (!p->root.rb_node)",
          "2478:   return;",
          "2480:  next = rb_first(&p->root);",
          "2481:  while (next) {",
          "2482:   n = rb_entry(next, struct sp_node, nd);",
          "2483:   next = rb_next(&n->nd);",
          "2484:   sp_delete(p, n);",
          "2485:  }",
          "2487: }",
          "2489: #ifdef CONFIG_NUMA_BALANCING",
          "",
          "[Removed Lines]",
          "2479:  mutex_lock(&p->mutex);",
          "2486:  mutex_unlock(&p->mutex);",
          "",
          "[Added Lines]",
          "2507:  spin_lock(&p->lock);",
          "2514:  spin_unlock(&p->lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9f10523f891928330b7529da54c1a3cc65180b1a",
      "candidate_info": {
        "commit_hash": "9f10523f891928330b7529da54c1a3cc65180b1a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9f10523f891928330b7529da54c1a3cc65180b1a",
        "files": [
          "Documentation/filesystems/caching/backend-api.txt",
          "Documentation/filesystems/caching/operations.txt",
          "fs/cachefiles/rdwr.c",
          "fs/fscache/object.c",
          "fs/fscache/operation.c",
          "fs/fscache/page.c",
          "include/linux/fscache-cache.h"
        ],
        "message": "FS-Cache: Fix operation state management and accounting\n\nFix the state management of internal fscache operations and the accounting of\nwhat operations are in what states.\n\nThis is done by:\n\n (1) Give struct fscache_operation a enum variable that directly represents the\n     state it's currently in, rather than spreading this knowledge over a bunch\n     of flags, who's processing the operation at the moment and whether it is\n     queued or not.\n\n     This makes it easier to write assertions to check the state at various\n     points and to prevent invalid state transitions.\n\n (2) Add an 'operation complete' state and supply a function to indicate the\n     completion of an operation (fscache_op_complete()) and make things call\n     it.  The final call to fscache_put_operation() can then check that an op\n     in the appropriate state (complete or cancelled).\n\n (3) Adjust the use of object->n_ops, ->n_in_progress, ->n_exclusive to better\n     govern the state of an object:\n\n\t(a) The ->n_ops is now the number of extant operations on the object\n\t    and is now decremented by fscache_put_operation() only.\n\n\t(b) The ->n_in_progress is simply the number of objects that have been\n\t    taken off of the object's pending queue for the purposes of being\n\t    run.  This is decremented by fscache_op_complete() only.\n\n\t(c) The ->n_exclusive is the number of exclusive ops that have been\n\t    submitted and queued or are in progress.  It is decremented by\n\t    fscache_op_complete() and by fscache_cancel_op().\n\n     fscache_put_operation() and fscache_operation_gc() now no longer try to\n     clean up ->n_exclusive and ->n_in_progress.  That was leading to double\n     decrements against fscache_cancel_op().\n\n     fscache_cancel_op() now no longer decrements ->n_ops.  That was leading to\n     double decrements against fscache_put_operation().\n\n     fscache_submit_exclusive_op() now decides whether it has to queue an op\n     based on ->n_in_progress being > 0 rather than ->n_ops > 0 as the latter\n     will persist in being true even after all preceding operations have been\n     cancelled or completed.  Furthermore, if an object is active and there are\n     runnable ops against it, there must be at least one op running.\n\n (4) Add a remaining-pages counter (n_pages) to struct fscache_retrieval and\n     provide a function to record completion of the pages as they complete.\n\n     When n_pages reaches 0, the operation is deemed to be complete and\n     fscache_op_complete() is called.\n\n     Add calls to fscache_retrieval_complete() anywhere we've finished with a\n     page we've been given to read or allocate for.  This includes places where\n     we just return pages to the netfs for reading from the server and where\n     accessing the cache fails and we discard the proposed netfs page.\n\nThe bugs in the unfixed state management manifest themselves as oopses like the\nfollowing where the operation completion gets out of sync with return of the\ncookie by the netfs.  This is possible because the cache unlocks and returns\nall the netfs pages before recording its completion - which means that there's\nnothing to stop the netfs discarding them and returning the cookie.\n\n\nFS-Cache: Cookie 'NFS.fh' still has outstanding reads\n------------[ cut here ]------------\nkernel BUG at fs/fscache/cookie.c:519!\ninvalid opcode: 0000 [#1] SMP\nCPU 1\nModules linked in: cachefiles nfs fscache auth_rpcgss nfs_acl lockd sunrpc\n\nPid: 400, comm: kswapd0 Not tainted 3.1.0-rc7-fsdevel+ #1090                  /DG965RY\nRIP: 0010:[<ffffffffa007050a>]  [<ffffffffa007050a>] __fscache_relinquish_cookie+0x170/0x343 [fscache]\nRSP: 0018:ffff8800368cfb00  EFLAGS: 00010282\nRAX: 000000000000003c RBX: ffff880023cc8790 RCX: 0000000000000000\nRDX: 0000000000002f2e RSI: 0000000000000001 RDI: ffffffff813ab86c\nRBP: ffff8800368cfb50 R08: 0000000000000002 R09: 0000000000000000\nR10: ffff88003a1b7890 R11: ffff88001df6e488 R12: ffff880023d8ed98\nR13: ffff880023cc8798 R14: 0000000000000004 R15: ffff88003b8bf370\nFS:  0000000000000000(0000) GS:ffff88003bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 00000000008ba008 CR3: 0000000023d93000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess kswapd0 (pid: 400, threadinfo ffff8800368ce000, task ffff88003b8bf040)\nStack:\n ffff88003b8bf040 ffff88001df6e528 ffff88001df6e528 ffffffffa00b46b0\n ffff88003b8bf040 ffff88001df6e488 ffff88001df6e620 ffffffffa00b46b0\n ffff88001ebd04c8 0000000000000004 ffff8800368cfb70 ffffffffa00b2c91\nCall Trace:\n [<ffffffffa00b2c91>] nfs_fscache_release_inode_cookie+0x3b/0x47 [nfs]\n [<ffffffffa008f25f>] nfs_clear_inode+0x3c/0x41 [nfs]\n [<ffffffffa0090df1>] nfs4_evict_inode+0x2f/0x33 [nfs]\n [<ffffffff810d8d47>] evict+0xa1/0x15c\n [<ffffffff810d8e2e>] dispose_list+0x2c/0x38\n [<ffffffff810d9ebd>] prune_icache_sb+0x28c/0x29b\n [<ffffffff810c56b7>] prune_super+0xd5/0x140\n [<ffffffff8109b615>] shrink_slab+0x102/0x1ab\n [<ffffffff8109d690>] balance_pgdat+0x2f2/0x595\n [<ffffffff8103e009>] ? process_timeout+0xb/0xb\n [<ffffffff8109dba3>] kswapd+0x270/0x289\n [<ffffffff8104c5ea>] ? __init_waitqueue_head+0x46/0x46\n [<ffffffff8109d933>] ? balance_pgdat+0x595/0x595\n [<ffffffff8104bf7a>] kthread+0x7f/0x87\n [<ffffffff813ad6b4>] kernel_thread_helper+0x4/0x10\n [<ffffffff81026b98>] ? finish_task_switch+0x45/0xc0\n [<ffffffff813abcdd>] ? retint_restore_args+0xe/0xe\n [<ffffffff8104befb>] ? __init_kthread_worker+0x53/0x53\n [<ffffffff813ad6b0>] ? gs_change+0xb/0xb\n\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "fs/cachefiles/rdwr.c||fs/cachefiles/rdwr.c",
          "fs/fscache/object.c||fs/fscache/object.c",
          "fs/fscache/operation.c||fs/fscache/operation.c",
          "fs/fscache/page.c||fs/fscache/page.c",
          "include/linux/fscache-cache.h||include/linux/fscache-cache.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/cachefiles/rdwr.c||fs/cachefiles/rdwr.c": [
          "File: fs/cachefiles/rdwr.c -> fs/cachefiles/rdwr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "198:   fscache_end_io(op, monitor->netfs_page, error);",
          "199:   page_cache_release(monitor->netfs_page);",
          "200:   fscache_put_retrieval(op);",
          "201:   kfree(monitor);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:   fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:  copy_highpage(netpage, backpage);",
          "341:  fscache_end_io(op, netpage, 0);",
          "343: success:",
          "344:  _debug(\"success\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "343:  fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "360:   goto out;",
          "361: io_error:",
          "362:  cachefiles_io_error_obj(object, \"Page read error on backing file\");",
          "363:  ret = -ENOBUFS;",
          "364:  goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "365:  fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "369:  fscache_put_retrieval(monitor->op);",
          "370:  kfree(monitor);",
          "371: nomem:",
          "372:  _leave(\" = -ENOMEM\");",
          "373:  return -ENOMEM;",
          "374: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "375:  fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "407:  _enter(\"{%p},{%lx},,,\", object, page->index);",
          "409:  if (!object->backer)",
          "412:  inode = object->backer->d_inode;",
          "413:  ASSERT(S_ISREG(inode->i_mode));",
          "",
          "[Removed Lines]",
          "410:   return -ENOBUFS;",
          "",
          "[Added Lines]",
          "414:   goto enobufs;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "418:  if (inode->i_sb->s_blocksize > PAGE_SIZE)",
          "421:  shift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;",
          "",
          "[Removed Lines]",
          "419:   return -ENOBUFS;",
          "",
          "[Added Lines]",
          "423:   goto enobufs;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "448:  } else if (cachefiles_has_space(cache, 0, 1) == 0) {",
          "450:   fscache_mark_page_cached(op, page);",
          "451:   ret = -ENODATA;",
          "452:  } else {",
          "454:  }",
          "456:  _leave(\" = %d\", ret);",
          "457:  return ret;",
          "458: }",
          "",
          "[Removed Lines]",
          "453:   ret = -ENOBUFS;",
          "",
          "[Added Lines]",
          "455:   fscache_retrieval_complete(op, 1);",
          "458:   goto enobufs;",
          "464: enobufs:",
          "465:  fscache_retrieval_complete(op, 1);",
          "466:  _leave(\" = -ENOBUFS\");",
          "467:  return -ENOBUFS;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "634:   fscache_end_io(op, netpage, 0);",
          "635:   page_cache_release(netpage);",
          "636:   netpage = NULL;",
          "637:   continue;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "645:   fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "659:  list_for_each_entry_safe(netpage, _n, list, lru) {",
          "660:   list_del(&netpage->lru);",
          "661:   page_cache_release(netpage);",
          "662:  }",
          "664:  _leave(\" = %d\", ret);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "673:   fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "709:  if (!object->backer)",
          "712:  space = 1;",
          "713:  if (cachefiles_has_space(cache, 0, *nr_pages) < 0)",
          "",
          "[Removed Lines]",
          "710:   return -ENOBUFS;",
          "",
          "[Added Lines]",
          "722:   goto all_enobufs;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "722:  if (inode->i_sb->s_blocksize > PAGE_SIZE)",
          "725:  shift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;",
          "",
          "[Removed Lines]",
          "723:   return -ENOBUFS;",
          "",
          "[Added Lines]",
          "735:   goto all_enobufs;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "760:    nrbackpages++;",
          "761:   } else if (space && pagevec_add(&pagevec, page) == 0) {",
          "762:    fscache_mark_pages_cached(op, &pagevec);",
          "763:    ret = -ENODATA;",
          "764:   }",
          "765:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "775:    fscache_retrieval_complete(op, 1);",
          "777:   } else {",
          "778:    fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "781:  _leave(\" = %d [nr=%u%s]\",",
          "782:         ret, *nr_pages, list_empty(pages) ? \" empty\" : \"\");",
          "783:  return ret;",
          "784: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "800: all_enobufs:",
          "801:  fscache_retrieval_complete(op, *nr_pages);",
          "802:  return -ENOBUFS;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "815:  else",
          "816:   ret = -ENOBUFS;",
          "818:  _leave(\" = %d\", ret);",
          "819:  return ret;",
          "820: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "837:  fscache_retrieval_complete(op, 1);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "864:   ret = -ENOBUFS;",
          "865:  }",
          "867:  _leave(\" = %d\", ret);",
          "868:  return ret;",
          "869: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "887:  fscache_retrieval_complete(op, *nr_pages);",
          "",
          "---------------"
        ],
        "fs/fscache/object.c||fs/fscache/object.c": [
          "File: fs/fscache/object.c -> fs/fscache/object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "587:  if (object->n_in_progress == 0) {",
          "588:   if (object->n_ops > 0) {",
          "589:    ASSERTCMP(object->n_ops, >=, object->n_obj_ops);",
          "592:    fscache_start_operations(object);",
          "593:   } else {",
          "594:    ASSERT(list_empty(&object->pending_ops));",
          "",
          "[Removed Lines]",
          "590:    ASSERTIF(object->n_ops > object->n_obj_ops,",
          "591:      !list_empty(&object->pending_ops));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/fscache/operation.c||fs/fscache/operation.c": [
          "File: fs/fscache/operation.c -> fs/fscache/operation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:  ASSERT(op->processor != NULL);",
          "38:  ASSERTCMP(op->object->state, >=, FSCACHE_OBJECT_AVAILABLE);",
          "39:  ASSERTCMP(atomic_read(&op->usage), >, 0);",
          "41:  fscache_stat(&fscache_n_op_enqueue);",
          "42:  switch (op->flags & FSCACHE_OP_TYPE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:  ASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64: static void fscache_run_op(struct fscache_object *object,",
          "65:       struct fscache_operation *op)",
          "66: {",
          "67:  object->n_in_progress++;",
          "68:  if (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))",
          "69:   wake_up_bit(&op->flags, FSCACHE_OP_WAITING);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  ASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);",
          "70:  op->state = FSCACHE_OP_ST_IN_PROGRESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80: int fscache_submit_exclusive_op(struct fscache_object *object,",
          "81:     struct fscache_operation *op)",
          "82: {",
          "85:  _enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);",
          "87:  spin_lock(&object->lock);",
          "88:  ASSERTCMP(object->n_ops, >=, object->n_in_progress);",
          "89:  ASSERTCMP(object->n_ops, >=, object->n_exclusive);",
          "90:  ASSERT(list_empty(&op->pend_link));",
          "93:  if (fscache_object_is_active(object)) {",
          "94:   op->object = object;",
          "95:   object->n_ops++;",
          "99:    atomic_inc(&op->usage);",
          "100:    list_add_tail(&op->pend_link, &object->pending_ops);",
          "101:    fscache_stat(&fscache_n_op_pend);",
          "",
          "[Removed Lines]",
          "83:  int ret;",
          "92:  ret = -ENOBUFS;",
          "98:   if (object->n_ops > 1) {",
          "",
          "[Added Lines]",
          "89:  ASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);",
          "90:  ASSERTCMP(atomic_read(&op->usage), >, 0);",
          "97:  op->state = FSCACHE_OP_ST_PENDING;",
          "103:   if (object->n_in_progress > 0) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "113:   clear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);",
          "115:  } else if (object->state == FSCACHE_OBJECT_CREATING) {",
          "116:   op->object = object;",
          "117:   object->n_ops++;",
          "",
          "[Removed Lines]",
          "114:   ret = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "119:   atomic_inc(&op->usage);",
          "120:   list_add_tail(&op->pend_link, &object->pending_ops);",
          "121:   fscache_stat(&fscache_n_op_pend);",
          "123:  } else {",
          "125:   BUG();",
          "126:  }",
          "128:  spin_unlock(&object->lock);",
          "130: }",
          "",
          "[Removed Lines]",
          "122:   ret = 0;",
          "129:  return ret;",
          "",
          "[Added Lines]",
          "132:  return 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "186:  _enter(\"{OBJ%x OP%x},{%u}\",",
          "187:         object->debug_id, op->debug_id, atomic_read(&op->usage));",
          "189:  ASSERTCMP(atomic_read(&op->usage), >, 0);",
          "191:  spin_lock(&object->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192:  ASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "196:  ostate = object->state;",
          "197:  smp_rmb();",
          "199:  if (fscache_object_is_active(object)) {",
          "200:   op->object = object;",
          "201:   object->n_ops++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:  op->state = FSCACHE_OP_ST_PENDING;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "225:      object->state == FSCACHE_OBJECT_LC_DYING ||",
          "226:      object->state == FSCACHE_OBJECT_WITHDRAWING) {",
          "227:   fscache_stat(&fscache_n_op_rejected);",
          "228:   ret = -ENOBUFS;",
          "229:  } else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {",
          "230:   fscache_report_unexpected_submission(object, op, ostate);",
          "231:   ASSERT(!fscache_object_is_active(object));",
          "232:   ret = -ENOBUFS;",
          "233:  } else {",
          "234:   ret = -ENOBUFS;",
          "235:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:   op->state = FSCACHE_OP_ST_CANCELLED;",
          "238:   op->state = FSCACHE_OP_ST_CANCELLED;",
          "241:   op->state = FSCACHE_OP_ST_CANCELLED;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "291:  _enter(\"OBJ%x OP%x}\", op->object->debug_id, op->debug_id);",
          "293:  spin_lock(&object->lock);",
          "295:  ret = -EBUSY;",
          "297:   fscache_stat(&fscache_n_op_cancelled);",
          "298:   list_del_init(&op->pend_link);",
          "300:   if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))",
          "301:    object->n_exclusive--;",
          "302:   if (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))",
          "",
          "[Removed Lines]",
          "296:  if (!list_empty(&op->pend_link)) {",
          "299:   object->n_ops--;",
          "",
          "[Added Lines]",
          "301:  ASSERTCMP(op->state, >=, FSCACHE_OP_ST_PENDING);",
          "302:  ASSERTCMP(op->state, !=, FSCACHE_OP_ST_CANCELLED);",
          "303:  ASSERTCMP(atomic_read(&op->usage), >, 0);",
          "308:  if (op->state == FSCACHE_OP_ST_PENDING) {",
          "309:   ASSERT(!list_empty(&op->pend_link));",
          "312:   op->state = FSCACHE_OP_ST_CANCELLED;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "310:  return ret;",
          "311: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329: void fscache_op_complete(struct fscache_operation *op)",
          "330: {",
          "331:  struct fscache_object *object = op->object;",
          "333:  _enter(\"OBJ%x\", object->debug_id);",
          "335:  ASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);",
          "336:  ASSERTCMP(object->n_in_progress, >, 0);",
          "337:  ASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),",
          "338:       object->n_exclusive, >, 0);",
          "339:  ASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),",
          "340:       object->n_in_progress, ==, 1);",
          "342:  spin_lock(&object->lock);",
          "344:  op->state = FSCACHE_OP_ST_COMPLETE;",
          "346:  if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))",
          "347:   object->n_exclusive--;",
          "348:  object->n_in_progress--;",
          "349:  if (object->n_in_progress == 0)",
          "350:   fscache_start_operations(object);",
          "352:  spin_unlock(&object->lock);",
          "353:  _leave(\"\");",
          "354: }",
          "355: EXPORT_SYMBOL(fscache_op_complete);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "328:   return;",
          "330:  _debug(\"PUT OP\");",
          "334:  fscache_stat(&fscache_n_op_release);",
          "",
          "[Removed Lines]",
          "331:  if (test_and_set_bit(FSCACHE_OP_DEAD, &op->flags))",
          "332:   BUG();",
          "",
          "[Added Lines]",
          "375:  ASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,",
          "376:       op->state, ==, FSCACHE_OP_ST_CANCELLED);",
          "377:  op->state = FSCACHE_OP_ST_DEAD;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "365:   return;",
          "366:  }",
          "378:  ASSERTCMP(object->n_ops, >, 0);",
          "379:  object->n_ops--;",
          "380:  if (object->n_ops == 0)",
          "",
          "[Removed Lines]",
          "368:  if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {",
          "369:   ASSERTCMP(object->n_exclusive, >, 0);",
          "370:   object->n_exclusive--;",
          "371:  }",
          "373:  ASSERTCMP(object->n_in_progress, >, 0);",
          "374:  object->n_in_progress--;",
          "375:  if (object->n_in_progress == 0)",
          "376:   fscache_start_operations(object);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "413:   spin_unlock(&cache->op_gc_list_lock);",
          "415:   object = op->object;",
          "417:   _debug(\"GC DEFERRED REL OBJ%x OP%x\",",
          "418:          object->debug_id, op->debug_id);",
          "419:   fscache_stat(&fscache_n_op_gc);",
          "421:   ASSERTCMP(atomic_read(&op->usage), ==, 0);",
          "434:   ASSERTCMP(object->n_ops, >, 0);",
          "435:   object->n_ops--;",
          "",
          "[Removed Lines]",
          "423:   spin_lock(&object->lock);",
          "424:   if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {",
          "425:    ASSERTCMP(object->n_exclusive, >, 0);",
          "426:    object->n_exclusive--;",
          "427:   }",
          "429:   ASSERTCMP(object->n_in_progress, >, 0);",
          "430:   object->n_in_progress--;",
          "431:   if (object->n_in_progress == 0)",
          "432:    fscache_start_operations(object);",
          "",
          "[Added Lines]",
          "451:   spin_lock(&object->lock);",
          "458:   ASSERTCMP(op->state, ==, FSCACHE_OP_ST_DEAD);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "437:    fscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);",
          "439:   spin_unlock(&object->lock);",
          "441:  } while (count++ < 20);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466:   kfree(op);",
          "",
          "---------------"
        ],
        "fs/fscache/page.c||fs/fscache/page.c": [
          "File: fs/fscache/page.c -> fs/fscache/page.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:    fscache_abort_object(object);",
          "163:  }",
          "165:  _leave(\"\");",
          "166: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165:  fscache_op_complete(op);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:  _enter(\"{OP%x}\", op->op.debug_id);",
          "226:  fscache_hist(fscache_retrieval_histogram, op->start_time);",
          "227:  if (op->context)",
          "228:   fscache_put_context(op->op.object->cookie, op->context);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227:  ASSERTCMP(op->n_pages, ==, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "320:  _debug(\"<<< GO\");",
          "322: check_if_dead:",
          "323:  if (unlikely(fscache_object_is_dead(object))) {",
          "324:   fscache_stat(stat_object_dead);",
          "325:   return -ENOBUFS;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "326:  if (op->op.state == FSCACHE_OP_ST_CANCELLED) {",
          "327:   fscache_stat(stat_object_dead);",
          "328:   _leave(\" = -ENOBUFS [cancelled]\");",
          "329:   return -ENOBUFS;",
          "330:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "364:   _leave(\" = -ENOMEM\");",
          "365:   return -ENOMEM;",
          "366:  }",
          "368:  spin_lock(&cookie->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "375:  op->n_pages = 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "375:  ASSERTCMP(object->state, >, FSCACHE_OBJECT_LOOKING_UP);",
          "377:  atomic_inc(&object->n_reads);",
          "380:  if (fscache_submit_op(object, &op->op) < 0)",
          "382:  spin_unlock(&cookie->lock);",
          "384:  fscache_stat(&fscache_n_retrieval_ops);",
          "",
          "[Removed Lines]",
          "378:  set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);",
          "381:   goto nobufs_unlock;",
          "",
          "[Added Lines]",
          "387:  __set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);",
          "390:   goto nobufs_unlock_dec;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "425:  _leave(\" = %d\", ret);",
          "426:  return ret;",
          "428: nobufs_unlock:",
          "429:  spin_unlock(&cookie->lock);",
          "430:  kfree(op);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "437: nobufs_unlock_dec:",
          "438:  atomic_dec(&object->n_reads);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "482:  op = fscache_alloc_retrieval(mapping, end_io_func, context);",
          "483:  if (!op)",
          "484:   return -ENOMEM;",
          "486:  spin_lock(&cookie->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "496:  op->n_pages = *nr_pages;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "491:         struct fscache_object, cookie_link);",
          "493:  atomic_inc(&object->n_reads);",
          "496:  if (fscache_submit_op(object, &op->op) < 0)",
          "498:  spin_unlock(&cookie->lock);",
          "500:  fscache_stat(&fscache_n_retrieval_ops);",
          "",
          "[Removed Lines]",
          "494:  set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);",
          "497:   goto nobufs_unlock;",
          "",
          "[Added Lines]",
          "506:  __set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);",
          "509:   goto nobufs_unlock_dec;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "541:  _leave(\" = %d\", ret);",
          "542:  return ret;",
          "544: nobufs_unlock:",
          "545:  spin_unlock(&cookie->lock);",
          "546:  kfree(op);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "556: nobufs_unlock_dec:",
          "557:  atomic_dec(&object->n_reads);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "583:  op = fscache_alloc_retrieval(page->mapping, NULL, NULL);",
          "584:  if (!op)",
          "585:   return -ENOMEM;",
          "587:  spin_lock(&cookie->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "600:  op->n_pages = 1;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "696:  fscache_end_page_write(object, page);",
          "697:  if (ret < 0) {",
          "698:   fscache_abort_object(object);",
          "699:  } else {",
          "700:   fscache_enqueue_operation(&op->op);",
          "701:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "714:   fscache_op_complete(&op->op);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "710:  spin_unlock(&cookie->stores_lock);",
          "711:  clear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);",
          "712:  spin_unlock(&object->lock);",
          "713:  _leave(\"\");",
          "714: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "729:  fscache_op_complete(&op->op);",
          "",
          "---------------"
        ],
        "include/linux/fscache-cache.h||include/linux/fscache-cache.h": [
          "File: include/linux/fscache-cache.h -> include/linux/fscache-cache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "75: typedef void (*fscache_operation_release_t)(struct fscache_operation *op);",
          "76: typedef void (*fscache_operation_processor_t)(struct fscache_operation *op);",
          "78: struct fscache_operation {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78: enum fscache_operation_state {",
          "86: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:  atomic_t  usage;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:  enum fscache_operation_state state;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "106: extern void fscache_op_work_func(struct work_struct *work);",
          "108: extern void fscache_enqueue_operation(struct fscache_operation *);",
          "109: extern void fscache_put_operation(struct fscache_operation *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119: extern void fscache_op_complete(struct fscache_operation *);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "122: {",
          "123:  INIT_WORK(&op->work, fscache_op_work_func);",
          "124:  atomic_set(&op->usage, 1);",
          "125:  op->debug_id = atomic_inc_return(&fscache_op_debug_id);",
          "126:  op->processor = processor;",
          "127:  op->release = release;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136:  op->state = FSCACHE_OP_ST_INITIALISED;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "173:  fscache_enqueue_operation(&op->op);",
          "174: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194: static inline void fscache_retrieval_complete(struct fscache_retrieval *op,",
          "195:            int n_pages)",
          "196: {",
          "197:  op->n_pages -= n_pages;",
          "198:  if (op->n_pages <= 0)",
          "199:   fscache_op_complete(&op->op);",
          "200: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9650388b5c56578fdccc79c57a8c82fb92b8e7f1",
      "candidate_info": {
        "commit_hash": "9650388b5c56578fdccc79c57a8c82fb92b8e7f1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9650388b5c56578fdccc79c57a8c82fb92b8e7f1",
        "files": [
          "net/ipv4/arp.c"
        ],
        "message": "ipv4: arp: fix a lockdep splat in arp_solicit()\n\nYan Burman reported following lockdep warning :\n\n=============================================\n[ INFO: possible recursive locking detected ]\n3.7.0+ #24 Not tainted\n---------------------------------------------\nswapper/1/0 is trying to acquire lock:\n  (&n->lock){++--..}, at: [<ffffffff8139f56e>] __neigh_event_send\n+0x2e/0x2f0\n\nbut task is already holding lock:\n  (&n->lock){++--..}, at: [<ffffffff813f63f4>] arp_solicit+0x1d4/0x280\n\nother info that might help us debug this:\n  Possible unsafe locking scenario:\n\n        CPU0\n        ----\n   lock(&n->lock);\n   lock(&n->lock);\n\n  *** DEADLOCK ***\n\n  May be due to missing lock nesting notation\n\n4 locks held by swapper/1/0:\n  #0:  (((&n->timer))){+.-...}, at: [<ffffffff8104b350>]\ncall_timer_fn+0x0/0x1c0\n  #1:  (&n->lock){++--..}, at: [<ffffffff813f63f4>] arp_solicit\n+0x1d4/0x280\n  #2:  (rcu_read_lock_bh){.+....}, at: [<ffffffff81395400>]\ndev_queue_xmit+0x0/0x5d0\n  #3:  (rcu_read_lock_bh){.+....}, at: [<ffffffff813cb41e>]\nip_finish_output+0x13e/0x640\n\nstack backtrace:\nPid: 0, comm: swapper/1 Not tainted 3.7.0+ #24\nCall Trace:\n  <IRQ>  [<ffffffff8108c7ac>] validate_chain+0xdcc/0x11f0\n  [<ffffffff8108d570>] ? __lock_acquire+0x440/0xc30\n  [<ffffffff81120565>] ? kmem_cache_free+0xe5/0x1c0\n  [<ffffffff8108d570>] __lock_acquire+0x440/0xc30\n  [<ffffffff813c3570>] ? inet_getpeer+0x40/0x600\n  [<ffffffff8108d570>] ? __lock_acquire+0x440/0xc30\n  [<ffffffff8139f56e>] ? __neigh_event_send+0x2e/0x2f0\n  [<ffffffff8108ddf5>] lock_acquire+0x95/0x140\n  [<ffffffff8139f56e>] ? __neigh_event_send+0x2e/0x2f0\n  [<ffffffff8108d570>] ? __lock_acquire+0x440/0xc30\n  [<ffffffff81448d4b>] _raw_write_lock_bh+0x3b/0x50\n  [<ffffffff8139f56e>] ? __neigh_event_send+0x2e/0x2f0\n  [<ffffffff8139f56e>] __neigh_event_send+0x2e/0x2f0\n  [<ffffffff8139f99b>] neigh_resolve_output+0x16b/0x270\n  [<ffffffff813cb62d>] ip_finish_output+0x34d/0x640\n  [<ffffffff813cb41e>] ? ip_finish_output+0x13e/0x640\n  [<ffffffffa046f146>] ? vxlan_xmit+0x556/0xbec [vxlan]\n  [<ffffffff813cb9a0>] ip_output+0x80/0xf0\n  [<ffffffff813ca368>] ip_local_out+0x28/0x80\n  [<ffffffffa046f25a>] vxlan_xmit+0x66a/0xbec [vxlan]\n  [<ffffffffa046f146>] ? vxlan_xmit+0x556/0xbec [vxlan]\n  [<ffffffff81394a50>] ? skb_gso_segment+0x2b0/0x2b0\n  [<ffffffff81449355>] ? _raw_spin_unlock_irqrestore+0x65/0x80\n  [<ffffffff81394c57>] ? dev_queue_xmit_nit+0x207/0x270\n  [<ffffffff813950c8>] dev_hard_start_xmit+0x298/0x5d0\n  [<ffffffff813956f3>] dev_queue_xmit+0x2f3/0x5d0\n  [<ffffffff81395400>] ? dev_hard_start_xmit+0x5d0/0x5d0\n  [<ffffffff813f5788>] arp_xmit+0x58/0x60\n  [<ffffffff813f59db>] arp_send+0x3b/0x40\n  [<ffffffff813f6424>] arp_solicit+0x204/0x280\n  [<ffffffff813a1a70>] ? neigh_add+0x310/0x310\n  [<ffffffff8139f515>] neigh_probe+0x45/0x70\n  [<ffffffff813a1c10>] neigh_timer_handler+0x1a0/0x2a0\n  [<ffffffff8104b3cf>] call_timer_fn+0x7f/0x1c0\n  [<ffffffff8104b350>] ? detach_if_pending+0x120/0x120\n  [<ffffffff8104b748>] run_timer_softirq+0x238/0x2b0\n  [<ffffffff813a1a70>] ? neigh_add+0x310/0x310\n  [<ffffffff81043e51>] __do_softirq+0x101/0x280\n  [<ffffffff814518cc>] call_softirq+0x1c/0x30\n  [<ffffffff81003b65>] do_softirq+0x85/0xc0\n  [<ffffffff81043a7e>] irq_exit+0x9e/0xc0\n  [<ffffffff810264f8>] smp_apic_timer_interrupt+0x68/0xa0\n  [<ffffffff8145122f>] apic_timer_interrupt+0x6f/0x80\n  <EOI>  [<ffffffff8100a054>] ? mwait_idle+0xa4/0x1c0\n  [<ffffffff8100a04b>] ? mwait_idle+0x9b/0x1c0\n  [<ffffffff8100a6a9>] cpu_idle+0x89/0xe0\n  [<ffffffff81441127>] start_secondary+0x1b2/0x1b6\n\nBug is from arp_solicit(), releasing the neigh lock after arp_send()\nIn case of vxlan, we eventually need to write lock a neigh lock later.\n\nIts a false positive, but we can get rid of it without lockdep\nannotations.\n\nWe can instead use neigh_ha_snapshot() helper.\n\nReported-by: Yan Burman <yanb@mellanox.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/arp.c||net/ipv4/arp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/ipv4/arp.c||net/ipv4/arp.c": [
          "File: net/ipv4/arp.c -> net/ipv4/arp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "321: static void arp_solicit(struct neighbour *neigh, struct sk_buff *skb)",
          "322: {",
          "323:  __be32 saddr = 0;",
          "325:  struct net_device *dev = neigh->dev;",
          "326:  __be32 target = *(__be32 *)neigh->primary_key;",
          "327:  int probes = atomic_read(&neigh->probes);",
          "",
          "[Removed Lines]",
          "324:  u8  *dst_ha = NULL;",
          "",
          "[Added Lines]",
          "324:  u8 dst_ha[MAX_ADDR_LEN];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "363:  if (probes < 0) {",
          "364:   if (!(neigh->nud_state & NUD_VALID))",
          "365:    pr_debug(\"trying to ucast probe in NUD_INVALID\\n\");",
          "368:  } else {",
          "369:   probes -= neigh->parms->app_probes;",
          "370:   if (probes < 0) {",
          "371: #ifdef CONFIG_ARPD",
          "",
          "[Removed Lines]",
          "366:   dst_ha = neigh->ha;",
          "367:   read_lock_bh(&neigh->lock);",
          "",
          "[Added Lines]",
          "366:   neigh_ha_snapshot(dst_ha, neigh, dev);",
          "368:   memset(dst_ha, 0, dev->addr_len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "378:  arp_send(ARPOP_REQUEST, ETH_P_ARP, target, dev, saddr,",
          "379:    dst_ha, dev->dev_addr, NULL);",
          "382: }",
          "384: static int arp_ignore(struct in_device *in_dev, __be32 sip, __be32 tip)",
          "",
          "[Removed Lines]",
          "380:  if (dst_ha)",
          "381:   read_unlock_bh(&neigh->lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ef303988cfcb35922f550892cf476e861377f0b",
      "candidate_info": {
        "commit_hash": "3ef303988cfcb35922f550892cf476e861377f0b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3ef303988cfcb35922f550892cf476e861377f0b",
        "files": [
          "drivers/regulator/s5m8767.c"
        ],
        "message": "regulator: s5m8767: Fix probe failure due to stack corruption\n\nThe function sec_reg_read invokes regmap_read which expects unsigned int *\nas the destination address. The existing driver is passing address of local\nvariable \"val\" which is u8. This causes the stack corruption and following\ndump is observed during probe.\n\nHence change \"val\" from u8 to unsigned int.\n\nUnable to handle kernel paging request at virtual address 02410020\npgd = c0004000\n[02410020] *pgd=00000000\nInternal error: Oops: 80000005 [#1] PREEMPT SMP ARM\nModules linked in:\nCPU: 0    Not tainted  (3.6.0-00696-g98a28b18-dirty #27)\nPC is at 0x2410020\nLR is at _regulator_get_voltage+0x3c/0x70\npc : [<02410020>]    lr : [<c02395d4>]    psr: 20000013\nsp : cf839b68  ip : 00000000  fp : cf92d410\nr10: 0000cfd0  r9 : c06d9878  r8 : 0000f0a0\nr7 : cf839b70  r6 : cf92d400  r5 : 00000011  r4 : cf000000\nr3 : 02410020  r2 : 00000000  r1 : 00000048  r0 : cf000000\nFlags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel\n...........................\n.................................\n\n[<c02395d4>] (_regulator_get_voltage+0x3c/0x70) from [<c023ad80>] (print_constraints+0x50/0x36c)\n[<c023ad80>] (print_constraints+0x50/0x36c) from [<c023e504>] (set_machine_constraints+0xe8/0x2b0)\n[<c023e504>] (set_machine_constraints+0xe8/0x2b0) from [<c023e9c8>] (regulator_register+0x2fc/0x604)\n[<c023e9c8>] (regulator_register+0x2fc/0x604) from [<c049d628>] (s5m8767_pmic_probe+0x688/0x718)\n[<c049d628>] (s5m8767_pmic_probe+0x688/0x718) from [<c029915c>] (platform_drv_probe+0x18/0x1c)\n[<c029915c>] (platform_drv_probe+0x18/0x1c) from [<c0297dd0>] (really_probe+0x68/0x1f4)\n[<c0297dd0>] (really_probe+0x68/0x1f4) from [<c0298070>] (driver_probe_device+0x30/0x48)\n\nSigned-off-by: Inderpal Singh <inderpal.singh@linaro.org>\nSigned-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>",
        "before_after_code_files": [
          "drivers/regulator/s5m8767.c||drivers/regulator/s5m8767.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/regulator/s5m8767.c||drivers/regulator/s5m8767.c": [
          "File: drivers/regulator/s5m8767.c -> drivers/regulator/s5m8767.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "214:  struct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);",
          "215:  int ret, reg;",
          "216:  int mask = 0xc0, enable_ctrl;",
          "219:  ret = s5m8767_get_register(rdev, &reg, &enable_ctrl);",
          "220:  if (ret == -EINVAL)",
          "",
          "[Removed Lines]",
          "217:  u8 val;",
          "",
          "[Added Lines]",
          "217:  unsigned int val;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "306:  struct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);",
          "307:  int reg, mask, ret;",
          "308:  int reg_id = rdev_get_id(rdev);",
          "311:  ret = s5m8767_get_voltage_register(rdev, &reg);",
          "312:  if (ret)",
          "",
          "[Removed Lines]",
          "309:  u8 val;",
          "",
          "[Added Lines]",
          "309:  unsigned int val;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4ca075decc2bffc36ecacc59f2d943a037b46543",
      "candidate_info": {
        "commit_hash": "4ca075decc2bffc36ecacc59f2d943a037b46543",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4ca075decc2bffc36ecacc59f2d943a037b46543",
        "files": [
          "drivers/pinctrl/pinctrl-nomadik.c"
        ],
        "message": "pinctrl: nomadik: return if prcm_base is NULL\n\nThis patch adds a check for npct->prcm_base to make sure that the\naddress is not NULL before using it, as the driver was made capable of\nloading even without a proper memory resource in:\n\nf1671bf pinctrl/nomadik: make independent of prcmu driver\n\nAlso, refuses to probe without prcm_base on anything else than nomadik.\n\nThis solves the following crash, introduced during the merge window when\nbooting on U8500 with device tree:\n\npinctrl-nomadik pinctrl-db8500: No PRCM base, assume no ALT-Cx control is available\nUnable to handle kernel NULL pointer dereference at virtual address 00000138\npgd = c0004000\n[00000138] *pgd=00000000\nInternal error: Oops: 5 [#1] PREEMPT SMP ARM\nModules linked in:\nCPU: 0    Not tainted  (3.7.0-02892-g1ebaf4f #631)\nPC is at nmk_pmx_enable+0x1bc/0x4d0\nLR is at clk_disable+0x40/0x44\n[snip]\n[<c01d5e50>] (nmk_pmx_enable+0x1bc/0x4d0) from [<c01d3ba8>] (pinmux_enable_setting+0x12c/0x1ec)\n[<c01d3ba8>] (pinmux_enable_setting+0x12c/0x1ec) from [<c01d1dc8>] (pinctrl_select_state_locked+0xfc/0x134)\n[<c01d1dc8>] (pinctrl_select_state_locked+0xfc/0x134) from [<c01d2814>] (pinctrl_register+0x26c/0x43c)\n[<c01d2814>] (pinctrl_register+0x26c/0x43c) from [<c01d668c>] (nmk_pinctrl_probe+0x114/0x238)\n[<c01d668c>] (nmk_pinctrl_probe+0x114/0x238) from [<c0211cc4>] (platform_drv_probe+0x28/0x2c)\n[<c0211cc4>] (platform_drv_probe+0x28/0x2c) from [<c0210738>] (driver_probe_device+0x84/0x21c)\n[<c0210738>] (driver_probe_device+0x84/0x21c) from [<c02109c0>] (__device_attach+0x50/0x54)\n[<c02109c0>] (__device_attach+0x50/0x54) from [<c020eb1c>] (bus_for_each_drv+0x54/0x9c)\n[<c020eb1c>] (bus_for_each_drv+0x54/0x9c) from [<c0210668>] (device_attach+0x84/0x9c)\n[<c0210668>] (device_attach+0x84/0x9c) from [<c020fbac>] (bus_probe_device+0x94/0xb8)\n[<c020fbac>] (bus_probe_device+0x94/0xb8) from [<c020e084>] (device_add+0x4f0/0x5bc)\n[<c020e084>] (device_add+0x4f0/0x5bc) from [<c0276400>] (of_device_add+0x40/0x48)\n[<c0276400>] (of_device_add+0x40/0x48) from [<c0276a98>] (of_platform_device_create_pdata+0x68/0x98)\n[<c0276a98>] (of_platform_device_create_pdata+0x68/0x98) from [<c0276bac>] (of_platform_bus_create+0xe4/0x260)\n[<c0276bac>] (of_platform_bus_create+0xe4/0x260) from [<c0276bf8>] (of_platform_bus_create+0x130/0x260)\n[<c0276bf8>] (of_platform_bus_create+0x130/0x260) from [<c0276d94>] (of_platform_populate+0x6c/0xac)\n[<c0276d94>] (of_platform_populate+0x6c/0xac) from [<c04a8224>] (u8500_init_machine+0x78/0x140)\n[<c04a8224>] (u8500_init_machine+0x78/0x140) from [<c04a3560>] (customize_machine+0x24/0x30)\n[<c04a3560>] (customize_machine+0x24/0x30) from [<c00087b0>] (do_one_initcall+0x130/0x1b0)\n[<c00087b0>] (do_one_initcall+0x130/0x1b0) from [<c033ff9c>] (kernel_init+0x138/0x2e8)\n[<c033ff9c>] (kernel_init+0x138/0x2e8) from [<c000eb18>] (ret_from_fork+0x14/0x20)\nCode: 0a00001b e19400b2 e59a200c e0822000 (e592c000)\n---[ end trace 1b75b31a2719ed1c ]---\nnote: swapper/0[1] exited with preempt_count 1\nKernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\n\nSigned-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>\nSigned-off-by: Linus Walleij <linus.walleij@linaro.org>",
        "before_after_code_files": [
          "drivers/pinctrl/pinctrl-nomadik.c||drivers/pinctrl/pinctrl-nomadik.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/pinctrl/pinctrl-nomadik.c||drivers/pinctrl/pinctrl-nomadik.c": [
          "File: drivers/pinctrl/pinctrl-nomadik.c -> drivers/pinctrl/pinctrl-nomadik.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "259:  const struct prcm_gpiocr_altcx_pin_desc *pin_desc;",
          "260:  const u16 *gpiocr_regs;",
          "262:  if (alt_num > PRCM_IDX_GPIOCR_ALTC_MAX) {",
          "263:   dev_err(npct->dev, \"PRCM GPIOCR: alternate-C%i is invalid\\n\",",
          "264:    alt_num);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "262:  if (!npct->prcm_base)",
          "263:   return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "682:  const struct prcm_gpiocr_altcx_pin_desc *pin_desc;",
          "683:  const u16 *gpiocr_regs;",
          "685:  for (i = 0; i < npct->soc->npins_altcx; i++) {",
          "686:   if (npct->soc->altcx_pins[i].pin == gpio)",
          "687:    break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "688:  if (!npct->prcm_base)",
          "689:   return NMK_GPIO_ALT_C;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1887:     \"failed to ioremap PRCM registers\\n\");",
          "1888:    return -ENOMEM;",
          "1889:   }",
          "1891:   dev_info(&pdev->dev,",
          "1892:     \"No PRCM base, assume no ALT-Cx control is available\\n\");",
          "1893:  }",
          "",
          "[Removed Lines]",
          "1890:  } else {",
          "",
          "[Added Lines]",
          "1896:  } else if (version == PINCTRL_NMK_STN8815) {",
          "1899:  } else {",
          "1900:   dev_err(&pdev->dev, \"missing PRCM base address\\n\");",
          "1901:   return -EINVAL;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0b79824ec5055bf336840077e5b093e2869a2c18",
      "candidate_info": {
        "commit_hash": "0b79824ec5055bf336840077e5b093e2869a2c18",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/0b79824ec5055bf336840077e5b093e2869a2c18",
        "files": [
          "manifest",
          "manifest.uuid",
          "tool/lemon.c",
          "tool/lempar.c"
        ],
        "message": "Improve Lemon so that it enlarges some of its tables slightly in order to avoid having to index range checks on table lookups for a performance increase.\n\nFossilOrigin-Name: 4be6a23a188bd1fea445283d6dcc2f5c3470c28852dc4895d63117ad0c773fcf",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "tool/lemon.c||tool/lemon.c",
          "tool/lempar.c||tool/lempar.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 94085fb3e756bc984237b74b6e29c68462ad860870c64dcb5124feaeec387660",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4153:   struct rule *rp;",
          "4154:   struct acttab *pActtab;",
          "4155:   int i, j, n, sz;",
          "4158:   const char *name;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4156:   int nLookAhead;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4403:     if( la<0 ) la = lemp->nsymbol;",
          "4404:     if( j==0 ) fprintf(out,\" /* %5d */ \", i);",
          "4405:     fprintf(out, \" %4d,\", la);",
          "4407:       fprintf(out, \"\\n\"); lineno++;",
          "4408:       j = 0;",
          "4409:     }else{",
          "4410:       j++;",
          "4411:     }",
          "4412:   }",
          "4413:   fprintf(out, \"};\\n\"); lineno++;",
          "",
          "[Removed Lines]",
          "4406:     if( j==9 || i==n-1 ){",
          "",
          "[Added Lines]",
          "4407:     if( j==9 ){",
          "4408:       fprintf(out, \"\\n\"); lineno++;",
          "4409:       j = 0;",
          "4410:     }else{",
          "4411:       j++;",
          "4412:     }",
          "4413:   }",
          "4417:   nLookAhead = lemp->nterminal + lemp->nactiontab;",
          "4418:   while( i<nLookAhead ){",
          "4419:     if( j==0 ) fprintf(out,\" /* %5d */ \", i);",
          "4420:     fprintf(out, \" %4d,\", lemp->nterminal);",
          "4421:     if( j==9 ){",
          "4427:     i++;",
          "4429:   if( j>0 ) fprintf(out, \"\\n\"); lineno++;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4490:   if( lemp->has_fallback ){",
          "4491:     int mx = lemp->nterminal - 1;",
          "4493:     lemp->tablesize += (mx+1)*szCodeType;",
          "4494:     for(i=0; i<=mx; i++){",
          "4495:       struct symbol *p = lemp->symbols[i];",
          "",
          "[Removed Lines]",
          "4492:     while( mx>0 && lemp->symbols[mx]->fallback==0 ){ mx--; }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lempar.c||tool/lempar.c": [
          "File: tool/lempar.c -> tool/lempar.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "521:   do{",
          "522:     i = yy_shift_ofst[stateno];",
          "523:     assert( i>=0 );",
          "525:     assert( iLookAhead!=YYNOCODE );",
          "526:     assert( iLookAhead < YYNTOKEN );",
          "527:     i += iLookAhead;",
          "529: #ifdef YYFALLBACK",
          "533: #ifndef NDEBUG",
          "534:         if( yyTraceFILE ){",
          "535:           fprintf(yyTraceFILE, \"%sFALLBACK %s => %s\\n\",",
          "",
          "[Removed Lines]",
          "528:     if( i>=YY_NLOOKAHEAD || yy_lookahead[i]!=iLookAhead ){",
          "531:       if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])",
          "532:              && (iFallback = yyFallback[iLookAhead])!=0 ){",
          "",
          "[Added Lines]",
          "524:     assert( i<=YY_ACTTAB_COUNT );",
          "525:     assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD );",
          "529:     assert( i<(int)YY_NLOOKAHEAD );",
          "530:     if( yy_lookahead[i]!=iLookAhead ){",
          "533:       assert( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0]) );",
          "534:       iFallback = yyFallback[iLookAhead];",
          "535:       if( iFallback!=0 ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "544: #ifdef YYWILDCARD",
          "545:       {",
          "546:         int j = i - iLookAhead + YYWILDCARD;",
          "557: #ifndef NDEBUG",
          "558:           if( yyTraceFILE ){",
          "559:             fprintf(yyTraceFILE, \"%sWILDCARD %s => %s\\n\",",
          "",
          "[Removed Lines]",
          "547:         if(",
          "548: #if YY_SHIFT_MIN+YYWILDCARD<0",
          "549:           j>=0 &&",
          "550: #endif",
          "551: #if YY_SHIFT_MAX+YYWILDCARD>=YY_ACTTAB_COUNT",
          "552:           j<YY_ACTTAB_COUNT &&",
          "553: #endif",
          "554:           j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) &&",
          "555:           yy_lookahead[j]==YYWILDCARD && iLookAhead>0",
          "556:         ){",
          "",
          "[Added Lines]",
          "550:         assert( j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) );",
          "551:         if( yy_lookahead[j]==YYWILDCARD && iLookAhead>0 ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1070: int ParseFallback(int iToken){",
          "1071: #ifdef YYFALLBACK",
          "1075: #else",
          "1076:   (void)iToken;",
          "1077: #endif",
          "",
          "[Removed Lines]",
          "1072:   if( iToken<(int)(sizeof(yyFallback)/sizeof(yyFallback[0])) ){",
          "1073:     return yyFallback[iToken];",
          "1074:   }",
          "",
          "[Added Lines]",
          "1067:   assert( iToken<(int)(sizeof(yyFallback)/sizeof(yyFallback[0])) );",
          "1068:   return yyFallback[iToken];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8eff0cc3261fdbbb539857795b6516a0f1ba7c48",
      "candidate_info": {
        "commit_hash": "8eff0cc3261fdbbb539857795b6516a0f1ba7c48",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/8eff0cc3261fdbbb539857795b6516a0f1ba7c48",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/window1.test",
          "test/window8.tcl",
          "test/window8.test"
        ],
        "message": "Add tests to ensure that the window functions implementation is not generating code for unnecessary sorts.\n\nFossilOrigin-Name: e195948a6876efe01b5cf2ed67bc9015a781fda39dca668099cb7edc1d331818",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/window1.test||test/window1.test",
          "test/window8.tcl||test/window8.tcl",
          "test/window8.test||test/window8.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4f9b93e6cfa0b3b6ab8a126299c2b2a242f840453dc450e84d3df87576cf6cf8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/window1.test||test/window1.test": [
          "File: test/window1.test -> test/window1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "970:   \" $res",
          "971: }",
          "973: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "973: #-------------------------------------------------------------------------",
          "974: reset_db",
          "975: do_execsql_test 23.0 {",
          "976:   CREATE TABLE t5(a, b, c);",
          "977:   CREATE INDEX t5ab ON t5(a, b);",
          "978: }",
          "980: proc do_ordercount_test {tn sql nOrderBy} {",
          "981:   set plan [execsql \"EXPLAIN QUERY PLAN $sql\"]",
          "982:   uplevel [list do_test $tn [list regexp -all ORDER $plan] $nOrderBy]",
          "983: }",
          "985: do_ordercount_test 23.1 {",
          "986:   SELECT",
          "987:     sum(c) OVER (ORDER BY a, b),",
          "988:     sum(c) OVER (PARTITION BY a ORDER BY b)",
          "989:   FROM t5",
          "990: } 0",
          "992: do_ordercount_test 23.2 {",
          "993:   SELECT",
          "994:     sum(c) OVER (ORDER BY b, a),",
          "995:     sum(c) OVER (PARTITION BY b ORDER BY a)",
          "996:   FROM t5",
          "997: } 1",
          "999: do_ordercount_test 23.3 {",
          "1000:   SELECT",
          "1001:     sum(c) OVER (ORDER BY b, a),",
          "1002:     sum(c) OVER (ORDER BY c, b)",
          "1003:   FROM t5",
          "1004: } 2",
          "1006: do_ordercount_test 23.4 {",
          "1007:   SELECT",
          "1008:     sum(c) OVER (ORDER BY b ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),",
          "1009:     sum(c) OVER (ORDER BY b RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),",
          "1010:     sum(c) OVER (ORDER BY b GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)",
          "1011:   FROM t5",
          "1012: } 1",
          "1014: do_ordercount_test 23.5 {",
          "1015:   SELECT",
          "1016:     sum(c) OVER (ORDER BY b+1 ROWS UNBOUNDED PRECEDING),",
          "1017:     sum(c) OVER (ORDER BY b+1 RANGE UNBOUNDED PRECEDING),",
          "1018:     sum(c) OVER (ORDER BY b+1 GROUPS UNBOUNDED PRECEDING)",
          "1019:   FROM t5",
          "1020: } 1",
          "1022: do_ordercount_test 23.6 {",
          "1023:   SELECT",
          "1024:     sum(c) OVER (ORDER BY b+1 ROWS UNBOUNDED PRECEDING),",
          "1025:     sum(c) OVER (ORDER BY b+2 RANGE UNBOUNDED PRECEDING),",
          "1026:     sum(c) OVER (ORDER BY b+3 GROUPS UNBOUNDED PRECEDING)",
          "1027:   FROM t5",
          "1028: } 3",
          "",
          "---------------"
        ],
        "test/window8.tcl||test/window8.tcl": [
          "File: test/window8.tcl -> test/window8.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:   10 { ORDER BY a DESC RANGE BETWEEN 5.7 PRECEDING AND 5.8 FOLLOWING }",
          "166:   11 { ORDER BY a DESC RANGE BETWEEN UNBOUNDED PRECEDING AND 5.9 PRECEDING }",
          "167:   12 { ORDER BY a DESC RANGE BETWEEN 2.1 FOLLOWING AND UNBOUNDED FOLLOWING }",
          "168: } {",
          "169:   execsql_test 3.$tn \"",
          "170:     SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ($frame)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168:   13  { ORDER BY a RANGE 5.1 PRECEDING }",
          "",
          "---------------"
        ],
        "test/window8.test||test/window8.test": [
          "File: test/window8.test -> test/window8.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "3494:   SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a DESC RANGE BETWEEN 2.1 FOLLOWING AND UNBOUNDED FOLLOWING )",
          "3495: } {30 232   22 112   20 112   15 30   13 30   13 30   10 10   5 {}}",
          "3497: #==========================================================================",
          "3499: do_execsql_test 4.0 {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3497: do_execsql_test 3.13 {",
          "3498:   SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE 5.1 PRECEDING )",
          "3499: } {5 10   10 30   13 72   13 72   15 102   20 70   22 120   30 90}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4fb24c82cd6bedf39e8c536eb3d1563eca11544a",
      "candidate_info": {
        "commit_hash": "4fb24c82cd6bedf39e8c536eb3d1563eca11544a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4fb24c82cd6bedf39e8c536eb3d1563eca11544a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/wherecode.c",
          "test/gencol1.test"
        ],
        "message": "Fix the OP_DeferredSeek index-to-table column map in P4 so that it works with generated columns.  Ticket [ce22a07731530118]\n\nFossilOrigin-Name: 36c11ad51fe9ab1bde0b98d0ea9b8588e07d168cd8027486749372894941ad93",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/wherecode.c||src/wherecode.c",
          "test/gencol1.test||test/gencol1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "test/gencol1.test||test/gencol1.test"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "test/gencol1.test||test/gencol1.test"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 77b1c90add514050fe62f22751362fecacd99f9775346cffc60e09c326e64e10",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1054:     if( ai ){",
          "1055:       ai[0] = pTab->nCol;",
          "1056:       for(i=0; i<pIdx->nColumn-1; i++){",
          "1057:         assert( pIdx->aiColumn[i]<pTab->nCol );",
          "1059:       }",
          "1060:       sqlite3VdbeChangeP4(v, -1, (char*)ai, P4_INTARRAY);",
          "1061:     }",
          "",
          "[Removed Lines]",
          "1058:         if( pIdx->aiColumn[i]>=0 ) ai[pIdx->aiColumn[i]+1] = i+1;",
          "",
          "[Added Lines]",
          "1057:         int x1, x2;",
          "1059:         x1 = pIdx->aiColumn[i];",
          "1060:         x2 = sqlite3TableColumnToStorage(pTab, x1);",
          "1061:         testcase( x1!=x2 );",
          "1062:         if( pIdx->aiColumn[i]>=0 ) ai[x2+1] = i+1;",
          "",
          "---------------"
        ],
        "test/gencol1.test||test/gencol1.test": [
          "File: test/gencol1.test -> test/gencol1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "211:   REPLACE INTO t0(c1) VALUES(NULL);",
          "212: } {1 {NOT NULL constraint failed: t0.c0}}",
          "214: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "214: # 2019-11-06 ticket b13b7dce76e9352b34e7",
          "215: do_execsql_test gencol1-7.10 {",
          "216:   DROP TABLE IF EXISTS t0;",
          "217:   CREATE TABLE t0 (c0 GENERATED ALWAYS AS (1), c1 UNIQUE, c2 UNIQUE);",
          "218:   INSERT INTO t0(c1) VALUES (1);",
          "219:   SELECT quote(0 = t0.c2 OR t0.c1 BETWEEN t0.c2 AND 1) FROM t0;",
          "220: } {NULL}",
          "221: do_execsql_test gencol1-7.20 {",
          "222:   SELECT 99 FROM t0 WHERE 0 = t0.c2 OR t0.c1 BETWEEN t0.c2 AND 1;",
          "223: } {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "46b341530e03b54d9c4ae31b81abb719f4b5f0e2",
      "candidate_info": {
        "commit_hash": "46b341530e03b54d9c4ae31b81abb719f4b5f0e2",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/46b341530e03b54d9c4ae31b81abb719f4b5f0e2",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/attach.c"
        ],
        "message": "Fix a problem with the user-auth extension and deserializing in-memory databases.\n\nFossilOrigin-Name: 09fa0b3c4adf7f81a777975762029ad43dbdc76b02dc32d2307e1c42465213c9",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/attach.c||src/attach.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 734192d876e0489cb34e454aaa4a9c6858145791a49959b31dee2917a8e41a7d",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/attach.c||src/attach.c": [
          "File: src/attach.c -> src/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:     assert( zErrDyn==0 || rc!=SQLITE_OK );",
          "242:   }",
          "243: #ifdef SQLITE_USER_AUTHENTICATION",
          "245:     u8 newAuth = 0;",
          "246:     rc = sqlite3UserAuthCheckLogin(db, zName, &newAuth);",
          "247:     if( newAuth<db->auth.authLevel ){",
          "",
          "[Removed Lines]",
          "244:   if( rc==SQLITE_OK ){",
          "",
          "[Added Lines]",
          "244:   if( rc==SQLITE_OK && !REOPEN_AS_MEMDB(db) ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4bec44bdfa1fea3374a8e262b6a8da6fc79f08b8",
      "candidate_info": {
        "commit_hash": "4bec44bdfa1fea3374a8e262b6a8da6fc79f08b8",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4bec44bdfa1fea3374a8e262b6a8da6fc79f08b8",
        "files": [
          "ext/misc/fossildelta.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Add the fossildelta.c extension in ext/misc with implementations of the Fossil delta functions.\n\nFossilOrigin-Name: b80cafa6f8a5c6ff1dc9efd2f670777ab131ace2df1eb431cedc8cfa901baf18",
        "before_after_code_files": [
          "ext/misc/fossildelta.c||ext/misc/fossildelta.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/fossildelta.c||ext/misc/fossildelta.c": [
          "File: ext/misc/fossildelta.c -> ext/misc/fossildelta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #include <string.h>",
          "16: #include <assert.h>",
          "17: #include <stdlib.h>",
          "18: #include \"sqlite3ext.h\"",
          "19: SQLITE_EXTENSION_INIT1",
          "24: typedef unsigned int u32;",
          "29: typedef short int s16;",
          "30: typedef unsigned short int u16;",
          "37: #define NHASH 16",
          "51: typedef struct hash hash;",
          "52: struct hash {",
          "56: };",
          "61: static void hash_init(hash *pHash, const char *z){",
          "62:   u16 a, b, i;",
          "63:   a = b = z[0];",
          "64:   for(i=1; i<NHASH; i++){",
          "65:     a += z[i];",
          "66:     b += a;",
          "67:   }",
          "68:   memcpy(pHash->z, z, NHASH);",
          "69:   pHash->a = a & 0xffff;",
          "70:   pHash->b = b & 0xffff;",
          "71:   pHash->i = 0;",
          "72: }",
          "77: static void hash_next(hash *pHash, int c){",
          "78:   u16 old = pHash->z[pHash->i];",
          "79:   pHash->z[pHash->i] = c;",
          "80:   pHash->i = (pHash->i+1)&(NHASH-1);",
          "81:   pHash->a = pHash->a - old + c;",
          "82:   pHash->b = pHash->b - NHASH*old + pHash->a;",
          "83: }",
          "88: static u32 hash_32bit(hash *pHash){",
          "89:   return (pHash->a & 0xffff) | (((u32)(pHash->b & 0xffff))<<16);",
          "90: }",
          "100: static u32 hash_once(const char *z){",
          "101:   u16 a, b, i;",
          "102:   a = b = z[0];",
          "103:   for(i=1; i<NHASH; i++){",
          "104:     a += z[i];",
          "105:     b += a;",
          "106:   }",
          "107:   return a | (((u32)b)<<16);",
          "108: }",
          "113: static void putInt(unsigned int v, char **pz){",
          "114:   static const char zDigits[] =",
          "115:     \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\";",
          "117:   int i, j;",
          "118:   char zBuf[20];",
          "119:   if( v==0 ){",
          "121:     return;",
          "122:   }",
          "123:   for(i=0; v>0; i++, v>>=6){",
          "124:     zBuf[i] = zDigits[v&0x3f];",
          "125:   }",
          "126:   for(j=i-1; j>=0; j--){",
          "128:   }",
          "129: }",
          "137: static unsigned int getInt(const char **pz, int *pLen){",
          "138:   static const signed char zValue[] = {",
          "139:     -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,",
          "140:     -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,",
          "141:     -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,",
          "142:      0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,",
          "143:     -1, 10, 11, 12, 13, 14, 15, 16,   17, 18, 19, 20, 21, 22, 23, 24,",
          "144:     25, 26, 27, 28, 29, 30, 31, 32,   33, 34, 35, -1, -1, -1, -1, 36,",
          "145:     -1, 37, 38, 39, 40, 41, 42, 43,   44, 45, 46, 47, 48, 49, 50, 51,",
          "146:     52, 53, 54, 55, 56, 57, 58, 59,   60, 61, 62, -1, -1, -1, 63, -1,",
          "147:   };",
          "148:   unsigned int v = 0;",
          "149:   int c;",
          "150:   unsigned char *z = (unsigned char*)*pz;",
          "151:   unsigned char *zStart = z;",
          "152:   while( (c = zValue[0x7f&*(z++)])>=0 ){",
          "153:      v = (v<<6) + c;",
          "154:   }",
          "155:   z--;",
          "158:   return v;",
          "159: }",
          "164: static int digit_count(int v){",
          "165:   unsigned int i, x;",
          "166:   for(i=1, x=64; v>=x; i++, x <<= 6){}",
          "167:   return i;",
          "168: }",
          "170: #ifdef __GNUC__",
          "171: # define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)",
          "172: #else",
          "173: # define GCC_VERSION 0",
          "174: #endif",
          "182: static unsigned int checksum(const char *zIn, size_t N){",
          "183:   static const int byteOrderTest = 1;",
          "184:   const unsigned char *z = (const unsigned char *)zIn;",
          "185:   const unsigned char *zEnd = (const unsigned char*)&zIn[N&~3];",
          "186:   unsigned sum = 0;",
          "188:   if( 0==*(char*)&byteOrderTest ){",
          "190:     while( z<zEnd ){",
          "191:       sum += *(unsigned*)z;",
          "192:       z += 4;",
          "193:     }",
          "194:   }else{",
          "196: #if GCC_VERSION>=4003000",
          "197:     while( z<zEnd ){",
          "198:       sum += __builtin_bswap32(*(unsigned*)z);",
          "199:       z += 4;",
          "200:     }",
          "201: #elif defined(_MSC_VER) && _MSC_VER>=1300",
          "202:     while( z<zEnd ){",
          "203:       sum += _byteswap_ulong(*(unsigned*)z);",
          "204:       z += 4;",
          "205:     }",
          "206: #else",
          "207:     unsigned sum0 = 0;",
          "208:     unsigned sum1 = 0;",
          "209:     unsigned sum2 = 0;",
          "210:     while(N >= 16){",
          "211:       sum0 += ((unsigned)z[0] + z[4] + z[8] + z[12]);",
          "212:       sum1 += ((unsigned)z[1] + z[5] + z[9] + z[13]);",
          "213:       sum2 += ((unsigned)z[2] + z[6] + z[10]+ z[14]);",
          "214:       sum  += ((unsigned)z[3] + z[7] + z[11]+ z[15]);",
          "215:       z += 16;",
          "216:       N -= 16;",
          "217:     }",
          "218:     while(N >= 4){",
          "219:       sum0 += z[0];",
          "220:       sum1 += z[1];",
          "221:       sum2 += z[2];",
          "222:       sum  += z[3];",
          "223:       z += 4;",
          "224:       N -= 4;",
          "225:     }",
          "226:     sum += (sum2 << 8) + (sum1 << 16) + (sum0 << 24);",
          "227: #endif",
          "228:   }",
          "229:   switch(N&3){",
          "230:     case 3:   sum += (z[2] << 8);",
          "231:     case 2:   sum += (z[1] << 16);",
          "232:     case 1:   sum += (z[0] << 24);",
          "233:     default:  ;",
          "234:   }",
          "235:   return sum;",
          "236: }",
          "299: static int delta_create(",
          "305: ){",
          "306:   int i, base;",
          "307:   char *zOrigDelta = zDelta;",
          "308:   hash h;",
          "316:   putInt(lenOut, &zDelta);",
          "323:   if( lenSrc<=NHASH ){",
          "324:     putInt(lenOut, &zDelta);",
          "326:     memcpy(zDelta, zOut, lenOut);",
          "327:     zDelta += lenOut;",
          "328:     putInt(checksum(zOut, lenOut), &zDelta);",
          "330:     return zDelta - zOrigDelta;",
          "331:   }",
          "336:   nHash = lenSrc/NHASH;",
          "337:   collide = sqlite3_malloc64( (sqlite3_int64)nHash*2*sizeof(int) );",
          "338:   memset(collide, -1, nHash*2*sizeof(int));",
          "339:   landmark = &collide[nHash];",
          "340:   for(i=0; i<lenSrc-NHASH; i+=NHASH){",
          "341:     int hv = hash_once(&zSrc[i]) % nHash;",
          "342:     collide[i/NHASH] = landmark[hv];",
          "343:     landmark[hv] = i/NHASH;",
          "344:   }",
          "350:   while( base+NHASH<lenOut ){",
          "351:     int iSrc, iBlock;",
          "352:     unsigned int bestCnt, bestOfst=0, bestLitsz=0;",
          "353:     hash_init(&h, &zOut[base]);",
          "355:     bestCnt = 0;",
          "356:     while( 1 ){",
          "357:       int hv;",
          "358:       int limit = 250;",
          "360:       hv = hash_32bit(&h) % nHash;",
          "361:       iBlock = landmark[hv];",
          "362:       while( iBlock>=0 && (limit--)>0 ){",
          "378:         int cnt, ofst, litsz;",
          "379:         int j, k, x, y;",
          "380:         int sz;",
          "381:         int limitX;",
          "385:         iSrc = iBlock*NHASH;",
          "386:         y = base+i;",
          "387:         limitX = ( lenSrc-iSrc <= lenOut-y ) ? lenSrc : iSrc + lenOut - y;",
          "388:         for(x=iSrc; x<limitX; x++, y++){",
          "389:           if( zSrc[x]!=zOut[y] ) break;",
          "390:         }",
          "391:         j = x - iSrc - 1;",
          "395:         for(k=1; k<iSrc && k<=i; k++){",
          "396:           if( zSrc[iSrc-k]!=zOut[base+i-k] ) break;",
          "397:         }",
          "398:         k--;",
          "401:         ofst = iSrc-k;",
          "402:         cnt = j+k+1;",
          "406:         sz = digit_count(i-k)+digit_count(cnt)+digit_count(ofst)+3;",
          "407:         if( cnt>=sz && cnt>bestCnt ){",
          "410:           bestCnt = cnt;",
          "411:           bestOfst = iSrc-k;",
          "412:           bestLitsz = litsz;",
          "413:         }",
          "416:         iBlock = collide[iBlock];",
          "417:       }",
          "422:       if( bestCnt>0 ){",
          "423:         if( bestLitsz>0 ){",
          "425:           putInt(bestLitsz,&zDelta);",
          "427:           memcpy(zDelta, &zOut[base], bestLitsz);",
          "428:           zDelta += bestLitsz;",
          "429:           base += bestLitsz;",
          "430:         }",
          "431:         base += bestCnt;",
          "432:         putInt(bestCnt, &zDelta);",
          "434:         putInt(bestOfst, &zDelta);",
          "436:         if( bestOfst + bestCnt -1 > lastRead ){",
          "437:           lastRead = bestOfst + bestCnt - 1;",
          "438:         }",
          "439:         bestCnt = 0;",
          "440:         break;",
          "441:       }",
          "444:       if( base+i+NHASH>=lenOut ){",
          "447:         putInt(lenOut-base, &zDelta);",
          "449:         memcpy(zDelta, &zOut[base], lenOut-base);",
          "450:         zDelta += lenOut-base;",
          "451:         base = lenOut;",
          "452:         break;",
          "453:       }",
          "456:       hash_next(&h, zOut[base+i+NHASH]);",
          "457:       i++;",
          "458:     }",
          "459:   }",
          "463:   if( base<lenOut ){",
          "464:     putInt(lenOut-base, &zDelta);",
          "466:     memcpy(zDelta, &zOut[base], lenOut-base);",
          "467:     zDelta += lenOut-base;",
          "468:   }",
          "470:   putInt(checksum(zOut, lenOut), &zDelta);",
          "472:   sqlite3_free(collide);",
          "473:   return zDelta - zOrigDelta;",
          "474: }",
          "485: static int delta_output_size(const char *zDelta, int lenDelta){",
          "486:   int size;",
          "487:   size = getInt(&zDelta, &lenDelta);",
          "488:   if( *zDelta!='\\n' ){",
          "490:     return -1;",
          "491:   }",
          "492:   return size;",
          "493: }",
          "516: static int delta_apply(",
          "522: ){",
          "523:   unsigned int limit;",
          "524:   unsigned int total = 0;",
          "525: #ifdef FOSSIL_ENABLE_DELTA_CKSUM_TEST",
          "526:   char *zOrigOut = zOut;",
          "527: #endif",
          "529:   limit = getInt(&zDelta, &lenDelta);",
          "530:   if( *zDelta!='\\n' ){",
          "532:     return -1;",
          "533:   }",
          "534:   zDelta++; lenDelta--;",
          "535:   while( *zDelta && lenDelta>0 ){",
          "536:     unsigned int cnt, ofst;",
          "537:     cnt = getInt(&zDelta, &lenDelta);",
          "538:     switch( zDelta[0] ){",
          "539:       case '@': {",
          "540:         zDelta++; lenDelta--;",
          "541:         ofst = getInt(&zDelta, &lenDelta);",
          "542:         if( lenDelta>0 && zDelta[0]!=',' ){",
          "544:           return -1;",
          "545:         }",
          "546:         zDelta++; lenDelta--;",
          "547:         total += cnt;",
          "548:         if( total>limit ){",
          "550:           return -1;",
          "551:         }",
          "552:         if( ofst+cnt > lenSrc ){",
          "554:           return -1;",
          "555:         }",
          "556:         memcpy(zOut, &zSrc[ofst], cnt);",
          "557:         zOut += cnt;",
          "558:         break;",
          "559:       }",
          "560:       case ':': {",
          "561:         zDelta++; lenDelta--;",
          "562:         total += cnt;",
          "563:         if( total>limit ){",
          "565:           return -1;",
          "566:         }",
          "567:         if( cnt>lenDelta ){",
          "569:           return -1;",
          "570:         }",
          "571:         memcpy(zOut, zDelta, cnt);",
          "572:         zOut += cnt;",
          "573:         zDelta += cnt;",
          "574:         lenDelta -= cnt;",
          "575:         break;",
          "576:       }",
          "577:       case ';': {",
          "578:         zDelta++; lenDelta--;",
          "579:         zOut[0] = 0;",
          "580: #ifdef FOSSIL_ENABLE_DELTA_CKSUM_TEST",
          "581:         if( cnt!=checksum(zOrigOut, total) ){",
          "583:           return -1;",
          "584:         }",
          "585: #endif",
          "586:         if( total!=limit ){",
          "588:           return -1;",
          "589:         }",
          "590:         return total;",
          "591:       }",
          "592:       default: {",
          "594:         return -1;",
          "595:       }",
          "596:     }",
          "597:   }",
          "599:   return -1;",
          "600: }",
          "607: static int delta_analyze(",
          "612: ){",
          "613:   unsigned int nInsert = 0;",
          "614:   unsigned int nCopy = 0;",
          "616:   (void)getInt(&zDelta, &lenDelta);",
          "617:   if( *zDelta!='\\n' ){",
          "619:     return -1;",
          "620:   }",
          "621:   zDelta++; lenDelta--;",
          "622:   while( *zDelta && lenDelta>0 ){",
          "623:     unsigned int cnt;",
          "624:     cnt = getInt(&zDelta, &lenDelta);",
          "625:     switch( zDelta[0] ){",
          "626:       case '@': {",
          "627:         zDelta++; lenDelta--;",
          "628:         (void)getInt(&zDelta, &lenDelta);",
          "629:         if( lenDelta>0 && zDelta[0]!=',' ){",
          "631:           return -1;",
          "632:         }",
          "633:         zDelta++; lenDelta--;",
          "634:         nCopy += cnt;",
          "635:         break;",
          "636:       }",
          "637:       case ':': {",
          "638:         zDelta++; lenDelta--;",
          "639:         nInsert += cnt;",
          "640:         if( cnt>lenDelta ){",
          "642:           return -1;",
          "643:         }",
          "644:         zDelta += cnt;",
          "645:         lenDelta -= cnt;",
          "646:         break;",
          "647:       }",
          "648:       case ';': {",
          "651:         return 0;",
          "652:       }",
          "653:       default: {",
          "655:         return -1;",
          "656:       }",
          "657:     }",
          "658:   }",
          "660:   return -1;",
          "661: }",
          "668: static void deltaCreateFunc(",
          "669:   sqlite3_context *context,",
          "670:   int argc,",
          "671:   sqlite3_value **argv",
          "672: ){",
          "677:   assert( argc==2 );",
          "678:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;",
          "679:   if( sqlite3_value_type(argv[1])==SQLITE_NULL ) return;",
          "680:   nOrig = sqlite3_value_bytes(argv[0]);",
          "681:   aOrig = (const char*)sqlite3_value_blob(argv[0]);",
          "682:   nNew = sqlite3_value_bytes(argv[1]);",
          "683:   aNew = (const char*)sqlite3_value_blob(argv[1]);",
          "684:   aOut = sqlite3_malloc64(nNew+70);",
          "685:   if( aOut==0 ){",
          "686:     sqlite3_result_error_nomem(context);",
          "687:   }else{",
          "688:     nOut = delta_create(aOrig, nOrig, aNew, nNew, aOut);",
          "689:     if( nOut<0 ){",
          "690:       sqlite3_free(aOut);",
          "691:       sqlite3_result_error(context, \"cannot create fossil delta\", -1);",
          "692:     }else{",
          "693:       sqlite3_result_blob(context, aOut, nOut, sqlite3_free);",
          "694:     }",
          "695:   }",
          "696: }",
          "703: static void deltaApplyFunc(",
          "704:   sqlite3_context *context,",
          "705:   int argc,",
          "706:   sqlite3_value **argv",
          "707: ){",
          "712:   assert( argc==2 );",
          "713:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;",
          "714:   if( sqlite3_value_type(argv[1])==SQLITE_NULL ) return;",
          "715:   nOrig = sqlite3_value_bytes(argv[0]);",
          "716:   aOrig = (const char*)sqlite3_value_blob(argv[0]);",
          "717:   nDelta = sqlite3_value_bytes(argv[1]);",
          "718:   aDelta = (const char*)sqlite3_value_blob(argv[1]);",
          "721:   nOut = delta_output_size(aDelta, nDelta);",
          "722:   if( nOut<0 ){",
          "723:     sqlite3_result_error(context, \"corrupt fossil delta\", -1);",
          "724:     return;",
          "725:   }",
          "726:   aOut = sqlite3_malloc64((sqlite3_int64)nOut+1);",
          "727:   if( aOut==0 ){",
          "728:     sqlite3_result_error_nomem(context);",
          "729:   }else{",
          "730:     nOut2 = delta_apply(aOrig, nOrig, aDelta, nDelta, aOut);",
          "731:     if( nOut2!=nOut ){",
          "732:       sqlite3_free(aOut);",
          "733:       sqlite3_result_error(context, \"corrupt fossil delta\", -1);",
          "734:     }else{",
          "735:       sqlite3_result_blob(context, aOut, nOut, sqlite3_free);",
          "736:     }",
          "737:   }",
          "738: }",
          "746: static void deltaOutputSizeFunc(",
          "747:   sqlite3_context *context,",
          "748:   int argc,",
          "749:   sqlite3_value **argv",
          "750: ){",
          "753:   assert( argc==1 );",
          "754:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;",
          "755:   nDelta = sqlite3_value_bytes(argv[0]);",
          "756:   aDelta = (const char*)sqlite3_value_blob(argv[0]);",
          "759:   nOut = delta_output_size(aDelta, nDelta);",
          "760:   if( nOut<0 ){",
          "761:     sqlite3_result_error(context, \"corrupt fossil delta\", -1);",
          "762:     return;",
          "763:   }else{",
          "764:     sqlite3_result_int(context, nOut);",
          "765:   }",
          "766: }",
          "769: #ifdef _WIN32",
          "770: __declspec(dllexport)",
          "771: #endif",
          "772: int sqlite3_fossildelta_init(",
          "773:   sqlite3 *db,",
          "774:   char **pzErrMsg,",
          "775:   const sqlite3_api_routines *pApi",
          "776: ){",
          "777:   int rc = SQLITE_OK;",
          "778:   SQLITE_EXTENSION_INIT2(pApi);",
          "780:   rc = sqlite3_create_function(db, \"delta_create\", 2, SQLITE_UTF8, 0,",
          "781:                                deltaCreateFunc, 0, 0);",
          "782:   if( rc==SQLITE_OK ){",
          "783:     rc = sqlite3_create_function(db, \"delta_apply\", 2, SQLITE_UTF8, 0,",
          "784:                                  deltaApplyFunc, 0, 0);",
          "785:   }",
          "786:   if( rc==SQLITE_OK ){",
          "787:     rc = sqlite3_create_function(db, \"delta_output_size\", 1, SQLITE_UTF8, 0,",
          "788:                                  deltaOutputSizeFunc, 0, 0);",
          "789:   }",
          "790:   return rc;",
          "791: }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 12517d1b15da46bc90bd95bb9c161d7f2ecdd7f28b1b3a5ed4397939ef986061",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
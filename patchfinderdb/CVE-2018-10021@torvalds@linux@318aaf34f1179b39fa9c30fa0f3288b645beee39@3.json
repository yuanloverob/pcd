{
  "cve_id": "CVE-2018-10021",
  "cve_desc": "drivers/scsi/libsas/sas_scsi_host.c in the Linux kernel before 4.16 allows local users to cause a denial of service (ata qc leak) by triggering certain failure conditions. NOTE: a third party disputes the relevance of this report because the failure can only occur for physically proximate attackers who unplug SAS Host Bus Adapter cables",
  "repo": "torvalds/linux",
  "patch_hash": "318aaf34f1179b39fa9c30fa0f3288b645beee39",
  "patch_info": {
    "commit_hash": "318aaf34f1179b39fa9c30fa0f3288b645beee39",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39",
    "files": [
      "drivers/scsi/libsas/sas_scsi_host.c"
    ],
    "message": "scsi: libsas: defer ata device eh commands to libata\n\nWhen ata device doing EH, some commands still attached with tasks are\nnot passed to libata when abort failed or recover failed, so libata did\nnot handle these commands. After these commands done, sas task is freed,\nbut ata qc is not freed. This will cause ata qc leak and trigger a\nwarning like below:\n\nWARNING: CPU: 0 PID: 28512 at drivers/ata/libata-eh.c:4037\nata_eh_finish+0xb4/0xcc\nCPU: 0 PID: 28512 Comm: kworker/u32:2 Tainted: G     W  OE 4.14.0#1\n......\nCall trace:\n[<ffff0000088b7bd0>] ata_eh_finish+0xb4/0xcc\n[<ffff0000088b8420>] ata_do_eh+0xc4/0xd8\n[<ffff0000088b8478>] ata_std_error_handler+0x44/0x8c\n[<ffff0000088b8068>] ata_scsi_port_error_handler+0x480/0x694\n[<ffff000008875fc4>] async_sas_ata_eh+0x4c/0x80\n[<ffff0000080f6be8>] async_run_entry_fn+0x4c/0x170\n[<ffff0000080ebd70>] process_one_work+0x144/0x390\n[<ffff0000080ec100>] worker_thread+0x144/0x418\n[<ffff0000080f2c98>] kthread+0x10c/0x138\n[<ffff0000080855dc>] ret_from_fork+0x10/0x18\n\nIf ata qc leaked too many, ata tag allocation will fail and io blocked\nfor ever.\n\nAs suggested by Dan Williams, defer ata device commands to libata and\nmerge sas_eh_finish_cmd() with sas_eh_defer_cmd(). libata will handle\nata qcs correctly after this.\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nCC: Xiaofei Tan <tanxiaofei@huawei.com>\nCC: John Garry <john.garry@huawei.com>\nCC: Dan Williams <dan.j.williams@intel.com>\nReviewed-by: Dan Williams <dan.j.williams@intel.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "before_after_code_files": [
      "drivers/scsi/libsas/sas_scsi_host.c||drivers/scsi/libsas/sas_scsi_host.c"
    ]
  },
  "patch_diff": {
    "drivers/scsi/libsas/sas_scsi_host.c||drivers/scsi/libsas/sas_scsi_host.c": [
      "File: drivers/scsi/libsas/sas_scsi_host.c -> drivers/scsi/libsas/sas_scsi_host.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "223: static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)",
      "224: {",
      "225:  struct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);",
      "226:  struct sas_task *task = TO_SAS_TASK(cmd);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "226:  struct domain_device *dev = cmd_to_domain_dev(cmd);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "232:  sas_end_task(cmd, task);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "235:  if (dev_is_sata(dev)) {",
      "239:   list_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);",
      "240:   return;",
      "241:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:  scsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);",
      "239: }",
      "257: static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)",
      "258: {",
      "259:  struct scsi_cmnd *cmd, *n;",
      "",
      "[Removed Lines]",
      "241: static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)",
      "242: {",
      "243:  struct domain_device *dev = cmd_to_domain_dev(cmd);",
      "244:  struct sas_ha_struct *ha = dev->port->ha;",
      "245:  struct sas_task *task = TO_SAS_TASK(cmd);",
      "247:  if (!dev_is_sata(dev)) {",
      "248:   sas_eh_finish_cmd(cmd);",
      "249:   return;",
      "250:  }",
      "253:  sas_end_task(cmd, task);",
      "254:  list_move_tail(&cmd->eh_entry, &ha->eh_ata_q);",
      "255: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "261:  list_for_each_entry_safe(cmd, n, error_q, eh_entry) {",
      "262:   if (cmd->device->sdev_target == my_cmd->device->sdev_target &&",
      "263:       cmd->device->lun == my_cmd->device->lun)",
      "265:  }",
      "266: }",
      "",
      "[Removed Lines]",
      "264:    sas_eh_defer_cmd(cmd);",
      "",
      "[Added Lines]",
      "257:    sas_eh_finish_cmd(cmd);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "618:   case TASK_IS_DONE:",
      "619:    SAS_DPRINTK(\"%s: task 0x%p is done\\n\", __func__,",
      "620:         task);",
      "622:    continue;",
      "623:   case TASK_IS_ABORTED:",
      "624:    SAS_DPRINTK(\"%s: task 0x%p is aborted\\n\",",
      "625:         __func__, task);",
      "627:    continue;",
      "628:   case TASK_IS_AT_LU:",
      "629:    SAS_DPRINTK(\"task 0x%p is at LU: lu recover\\n\", task);",
      "",
      "[Removed Lines]",
      "621:    sas_eh_defer_cmd(cmd);",
      "626:    sas_eh_defer_cmd(cmd);",
      "",
      "[Added Lines]",
      "614:    sas_eh_finish_cmd(cmd);",
      "619:    sas_eh_finish_cmd(cmd);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "634:          \"recovered\\n\",",
      "635:          SAS_ADDR(task->dev),",
      "636:          cmd->device->lun);",
      "638:     sas_scsi_clear_queue_lu(work_q, cmd);",
      "639:     goto Again;",
      "640:    }",
      "",
      "[Removed Lines]",
      "637:     sas_eh_defer_cmd(cmd);",
      "",
      "[Added Lines]",
      "630:     sas_eh_finish_cmd(cmd);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2bbea6e117357d17842114c65e9a9cf2d13ae8a3",
      "candidate_info": {
        "commit_hash": "2bbea6e117357d17842114c65e9a9cf2d13ae8a3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2bbea6e117357d17842114c65e9a9cf2d13ae8a3",
        "files": [
          "drivers/block/paride/pcd.c",
          "drivers/cdrom/cdrom.c",
          "drivers/cdrom/gdrom.c",
          "drivers/ide/ide-cd.c",
          "drivers/scsi/sr.c"
        ],
        "message": "cdrom: do not call check_disk_change() inside cdrom_open()\n\nwhen mounting an ISO filesystem sometimes (very rarely)\nthe system hangs because of a race condition between two tasks.\n\nPID: 6766   TASK: ffff88007b2a6dd0  CPU: 0   COMMAND: \"mount\"\n #0 [ffff880078447ae0] __schedule at ffffffff8168d605\n #1 [ffff880078447b48] schedule_preempt_disabled at ffffffff8168ed49\n #2 [ffff880078447b58] __mutex_lock_slowpath at ffffffff8168c995\n #3 [ffff880078447bb8] mutex_lock at ffffffff8168bdef\n #4 [ffff880078447bd0] sr_block_ioctl at ffffffffa00b6818 [sr_mod]\n #5 [ffff880078447c10] blkdev_ioctl at ffffffff812fea50\n #6 [ffff880078447c70] ioctl_by_bdev at ffffffff8123a8b3\n #7 [ffff880078447c90] isofs_fill_super at ffffffffa04fb1e1 [isofs]\n #8 [ffff880078447da8] mount_bdev at ffffffff81202570\n #9 [ffff880078447e18] isofs_mount at ffffffffa04f9828 [isofs]\n#10 [ffff880078447e28] mount_fs at ffffffff81202d09\n#11 [ffff880078447e70] vfs_kern_mount at ffffffff8121ea8f\n#12 [ffff880078447ea8] do_mount at ffffffff81220fee\n#13 [ffff880078447f28] sys_mount at ffffffff812218d6\n#14 [ffff880078447f80] system_call_fastpath at ffffffff81698c49\n    RIP: 00007fd9ea914e9a  RSP: 00007ffd5d9bf648  RFLAGS: 00010246\n    RAX: 00000000000000a5  RBX: ffffffff81698c49  RCX: 0000000000000010\n    RDX: 00007fd9ec2bc210  RSI: 00007fd9ec2bc290  RDI: 00007fd9ec2bcf30\n    RBP: 0000000000000000   R8: 0000000000000000   R9: 0000000000000010\n    R10: 00000000c0ed0001  R11: 0000000000000206  R12: 00007fd9ec2bc040\n    R13: 00007fd9eb6b2380  R14: 00007fd9ec2bc210  R15: 00007fd9ec2bcf30\n    ORIG_RAX: 00000000000000a5  CS: 0033  SS: 002b\n\nThis task was trying to mount the cdrom.  It allocated and configured a\nsuper_block struct and owned the write-lock for the super_block->s_umount\nrwsem. While exclusively owning the s_umount lock, it called\nsr_block_ioctl and waited to acquire the global sr_mutex lock.\n\nPID: 6785   TASK: ffff880078720fb0  CPU: 0   COMMAND: \"systemd-udevd\"\n #0 [ffff880078417898] __schedule at ffffffff8168d605\n #1 [ffff880078417900] schedule at ffffffff8168dc59\n #2 [ffff880078417910] rwsem_down_read_failed at ffffffff8168f605\n #3 [ffff880078417980] call_rwsem_down_read_failed at ffffffff81328838\n #4 [ffff8800784179d0] down_read at ffffffff8168cde0\n #5 [ffff8800784179e8] get_super at ffffffff81201cc7\n #6 [ffff880078417a10] __invalidate_device at ffffffff8123a8de\n #7 [ffff880078417a40] flush_disk at ffffffff8123a94b\n #8 [ffff880078417a88] check_disk_change at ffffffff8123ab50\n #9 [ffff880078417ab0] cdrom_open at ffffffffa00a29e1 [cdrom]\n#10 [ffff880078417b68] sr_block_open at ffffffffa00b6f9b [sr_mod]\n#11 [ffff880078417b98] __blkdev_get at ffffffff8123ba86\n#12 [ffff880078417bf0] blkdev_get at ffffffff8123bd65\n#13 [ffff880078417c78] blkdev_open at ffffffff8123bf9b\n#14 [ffff880078417c90] do_dentry_open at ffffffff811fc7f7\n#15 [ffff880078417cd8] vfs_open at ffffffff811fc9cf\n#16 [ffff880078417d00] do_last at ffffffff8120d53d\n#17 [ffff880078417db0] path_openat at ffffffff8120e6b2\n#18 [ffff880078417e48] do_filp_open at ffffffff8121082b\n#19 [ffff880078417f18] do_sys_open at ffffffff811fdd33\n#20 [ffff880078417f70] sys_open at ffffffff811fde4e\n#21 [ffff880078417f80] system_call_fastpath at ffffffff81698c49\n    RIP: 00007f29438b0c20  RSP: 00007ffc76624b78  RFLAGS: 00010246\n    RAX: 0000000000000002  RBX: ffffffff81698c49  RCX: 0000000000000000\n    RDX: 00007f2944a5fa70  RSI: 00000000000a0800  RDI: 00007f2944a5fa70\n    RBP: 00007f2944a5f540   R8: 0000000000000000   R9: 0000000000000020\n    R10: 00007f2943614c40  R11: 0000000000000246  R12: ffffffff811fde4e\n    R13: ffff880078417f78  R14: 000000000000000c  R15: 00007f2944a4b010\n    ORIG_RAX: 0000000000000002  CS: 0033  SS: 002b\n\nThis task tried to open the cdrom device, the sr_block_open function\nacquired the global sr_mutex lock. The call to check_disk_change()\nthen saw an event flag indicating a possible media change and tried\nto flush any cached data for the device.\nAs part of the flush, it tried to acquire the super_block->s_umount\nlock associated with the cdrom device.\nThis was the same super_block as created and locked by the previous task.\n\nThe first task acquires the s_umount lock and then the sr_mutex_lock;\nthe second task acquires the sr_mutex_lock and then the s_umount lock.\n\nThis patch fixes the issue by moving check_disk_change() out of\ncdrom_open() and let the caller take care of it.\n\nSigned-off-by: Maurizio Lombardi <mlombard@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/block/paride/pcd.c||drivers/block/paride/pcd.c",
          "drivers/cdrom/cdrom.c||drivers/cdrom/cdrom.c",
          "drivers/cdrom/gdrom.c||drivers/cdrom/gdrom.c",
          "drivers/ide/ide-cd.c||drivers/ide/ide-cd.c",
          "drivers/scsi/sr.c||drivers/scsi/sr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/block/paride/pcd.c||drivers/block/paride/pcd.c": [
          "File: drivers/block/paride/pcd.c -> drivers/block/paride/pcd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "230:  struct pcd_unit *cd = bdev->bd_disk->private_data;",
          "231:  int ret;",
          "233:  mutex_lock(&pcd_mutex);",
          "234:  ret = cdrom_open(&cd->info, bdev, mode);",
          "235:  mutex_unlock(&pcd_mutex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:  check_disk_change(bdev);",
          "",
          "---------------"
        ],
        "drivers/cdrom/cdrom.c||drivers/cdrom/cdrom.c": [
          "File: drivers/cdrom/cdrom.c -> drivers/cdrom/cdrom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1153:  cd_dbg(CD_OPEN, \"entering cdrom_open\\n\");",
          "1160:  cdi->use_count++;",
          "",
          "[Removed Lines]",
          "1156:  check_disk_change(bdev);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/cdrom/gdrom.c||drivers/cdrom/gdrom.c": [
          "File: drivers/cdrom/gdrom.c -> drivers/cdrom/gdrom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "497: static int gdrom_bdops_open(struct block_device *bdev, fmode_t mode)",
          "498: {",
          "499:  int ret;",
          "500:  mutex_lock(&gdrom_mutex);",
          "501:  ret = cdrom_open(gd.cd_info, bdev, mode);",
          "502:  mutex_unlock(&gdrom_mutex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "501:  check_disk_change(bdev);",
          "",
          "---------------"
        ],
        "drivers/ide/ide-cd.c||drivers/ide/ide-cd.c": [
          "File: drivers/ide/ide-cd.c -> drivers/ide/ide-cd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1613:  struct cdrom_info *info;",
          "1614:  int rc = -ENXIO;",
          "1616:  mutex_lock(&ide_cd_mutex);",
          "1617:  info = ide_cd_get(bdev->bd_disk);",
          "1618:  if (!info)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1616:  check_disk_change(bdev);",
          "",
          "---------------"
        ],
        "drivers/scsi/sr.c||drivers/scsi/sr.c": [
          "File: drivers/scsi/sr.c -> drivers/scsi/sr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "525:  struct scsi_cd *cd;",
          "526:  int ret = -ENXIO;",
          "528:  mutex_lock(&sr_mutex);",
          "529:  cd = scsi_cd_get(bdev->bd_disk);",
          "530:  if (cd) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "528:  check_disk_change(bdev);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0c81ffc60d5280991773d17e84bda605387148b1",
      "candidate_info": {
        "commit_hash": "0c81ffc60d5280991773d17e84bda605387148b1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0c81ffc60d5280991773d17e84bda605387148b1",
        "files": [
          "drivers/infiniband/core/ucma.c"
        ],
        "message": "RDMA/ucma: Don't allow join attempts for unsupported AF family\n\nUsers can provide garbage while calling to ucma_join_ip_multicast(),\nit will indirectly cause to rdma_addr_size() return 0, making the\ncall to ucma_process_join(), which had the right checks, but it is\nbetter to check the input as early as possible.\n\nThe following crash from syzkaller revealed it.\n\nkernel BUG at lib/string.c:1052!\ninvalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:\n   (ftrace buffer empty)\nModules linked in:\nCPU: 0 PID: 4113 Comm: syz-executor0 Not tainted 4.16.0-rc5+ #261\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:fortify_panic+0x13/0x20 lib/string.c:1051\nRSP: 0018:ffff8801ca81f8f0 EFLAGS: 00010286\nRAX: 0000000000000022 RBX: 1ffff10039503f23 RCX: 0000000000000000\nRDX: 0000000000000022 RSI: 1ffff10039503ed3 RDI: ffffed0039503f12\nRBP: ffff8801ca81f8f0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000006 R11: 0000000000000000 R12: ffff8801ca81f998\nR13: ffff8801ca81f938 R14: ffff8801ca81fa58 R15: 000000000000fa00\nFS:  0000000000000000(0000) GS:ffff8801db200000(0063) knlGS:000000000a12a900\nCS:  0010 DS: 002b ES: 002b CR0: 0000000080050033\nCR2: 0000000008138024 CR3: 00000001cbb58004 CR4: 00000000001606f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n memcpy include/linux/string.h:344 [inline]\n ucma_join_ip_multicast+0x36b/0x3b0 drivers/infiniband/core/ucma.c:1421\n ucma_write+0x2d6/0x3d0 drivers/infiniband/core/ucma.c:1633\n __vfs_write+0xef/0x970 fs/read_write.c:480\n vfs_write+0x189/0x510 fs/read_write.c:544\n SYSC_write fs/read_write.c:589 [inline]\n SyS_write+0xef/0x220 fs/read_write.c:581\n do_syscall_32_irqs_on arch/x86/entry/common.c:330 [inline]\n do_fast_syscall_32+0x3ec/0xf9f arch/x86/entry/common.c:392\n entry_SYSENTER_compat+0x70/0x7f arch/x86/entry/entry_64_compat.S:139\nRIP: 0023:0xf7f9ec99\nRSP: 002b:00000000ff8172cc EFLAGS: 00000282 ORIG_RAX: 0000000000000004\nRAX: ffffffffffffffda RBX: 0000000000000003 RCX: 0000000020000100\nRDX: 0000000000000063 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\nCode: 08 5b 41 5c 41 5d 41 5e 41 5f 5d c3 0f 0b 48 89 df e8 42 2c e3 fb eb de\n55 48 89 fe 48 c7 c7 80 75 98 86 48 89 e5 e8 85 95 94 fb <0f> 0b 90 90 90 90\n90 90 90 90 90 90 90 55 48 89 e5 41 57 41 56\nRIP: fortify_panic+0x13/0x20 lib/string.c:1051 RSP: ffff8801ca81f8f0\n\nFixes: 5bc2b7b397b0 (\"RDMA/ucma: Allow user space to specify AF_IB when joining multicast\")\nReported-by: <syzbot+2287ac532caa81900a4e@syzkaller.appspotmail.com>\nSigned-off-by: Leon Romanovsky <leonro@mellanox.com>\nReviewed-by: Sean Hefty <sean.hefty@intel.com>\nSigned-off-by: Doug Ledford <dledford@redhat.com>",
        "before_after_code_files": [
          "drivers/infiniband/core/ucma.c||drivers/infiniband/core/ucma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/infiniband/core/ucma.c||drivers/infiniband/core/ucma.c": [
          "File: drivers/infiniband/core/ucma.c -> drivers/infiniband/core/ucma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1349:   return -ENOSPC;",
          "1351:  addr = (struct sockaddr *) &cmd->addr;",
          "1353:   return -EINVAL;",
          "1355:  if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)",
          "",
          "[Removed Lines]",
          "1352:  if (!cmd->addr_size || (cmd->addr_size != rdma_addr_size(addr)))",
          "",
          "[Added Lines]",
          "1352:  if (cmd->addr_size != rdma_addr_size(addr))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1417:  join_cmd.uid = cmd.uid;",
          "1418:  join_cmd.id = cmd.id;",
          "1419:  join_cmd.addr_size = rdma_addr_size((struct sockaddr *) &cmd.addr);",
          "1420:  join_cmd.join_flags = RDMA_MC_JOIN_FLAG_FULLMEMBER;",
          "1421:  memcpy(&join_cmd.addr, &cmd.addr, join_cmd.addr_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1420:  if (!join_cmd.addr_size)",
          "1421:   return -EINVAL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1432:  if (copy_from_user(&cmd, inbuf, sizeof(cmd)))",
          "1433:   return -EFAULT;",
          "1435:  return ucma_process_join(file, &cmd, out_len);",
          "1436: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1438:  if (!rdma_addr_size((struct sockaddr *)&cmd.addr))",
          "1439:   return -EINVAL;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-3739",
  "cve_desc": "A NULL pointer dereference flaw was found in the btrfs_rm_device function in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system or leak kernel internal information. The highest threat from this vulnerability is to system availability.",
  "repo": "torvalds/linux",
  "patch_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
  "patch_info": {
    "commit_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "files": [
      "fs/btrfs/volumes.c"
    ],
    "message": "btrfs: fix NULL pointer dereference when deleting device by invalid id\n\n[BUG]\nIt's easy to trigger NULL pointer dereference, just by removing a\nnon-existing device id:\n\n # mkfs.btrfs -f -m single -d single /dev/test/scratch1 \\\n\t\t\t\t     /dev/test/scratch2\n # mount /dev/test/scratch1 /mnt/btrfs\n # btrfs device remove 3 /mnt/btrfs\n\nThen we have the following kernel NULL pointer dereference:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 9 PID: 649 Comm: btrfs Not tainted 5.14.0-rc3-custom+ #35\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n RIP: 0010:btrfs_rm_device+0x4de/0x6b0 [btrfs]\n  btrfs_ioctl+0x18bb/0x3190 [btrfs]\n  ? lock_is_held_type+0xa5/0x120\n  ? find_held_lock.constprop.0+0x2b/0x80\n  ? do_user_addr_fault+0x201/0x6a0\n  ? lock_release+0xd2/0x2d0\n  ? __x64_sys_ioctl+0x83/0xb0\n  __x64_sys_ioctl+0x83/0xb0\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n[CAUSE]\nCommit a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return\nbtrfs_device directly\") moves the \"missing\" device path check into\nbtrfs_rm_device().\n\nBut btrfs_rm_device() itself can have case where it only receives\n@devid, with NULL as @device_path.\n\nIn that case, calling strcmp() on NULL will trigger the NULL pointer\ndereference.\n\nBefore that commit, we handle the \"missing\" case inside\nbtrfs_find_device_by_devspec(), which will not check @device_path at all\nif @devid is provided, thus no way to trigger the bug.\n\n[FIX]\nBefore calling strcmp(), also make sure @device_path is not NULL.\n\nFixes: a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly\")\nCC: stable@vger.kernel.org # 5.4+\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
    "before_after_code_files": [
      "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
    ]
  },
  "patch_diff": {
    "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
      "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2075:  if (IS_ERR(device)) {",
      "2076:   if (PTR_ERR(device) == -ENOENT &&",
      "2078:    ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;",
      "2079:   else",
      "2080:    ret = PTR_ERR(device);",
      "",
      "[Removed Lines]",
      "2077:       strcmp(device_path, \"missing\") == 0)",
      "",
      "[Added Lines]",
      "2077:       device_path && strcmp(device_path, \"missing\") == 0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ef486bf448a057a6e2d50e40ae879f7add6585da",
      "candidate_info": {
        "commit_hash": "ef486bf448a057a6e2d50e40ae879f7add6585da",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ef486bf448a057a6e2d50e40ae879f7add6585da",
        "files": [
          "arch/powerpc/include/asm/book3s/32/kup.h"
        ],
        "message": "powerpc/32s: Fix random crashes by adding isync() after locking/unlocking KUEP\n\nCommit b5efec00b671 (\"powerpc/32s: Move KUEP locking/unlocking in C\")\nremoved the 'isync' instruction after adding/removing NX bit in user\nsegments. The reasoning behind this change was that when setting the\nNX bit we don't mind it taking effect with delay as the kernel never\nexecutes text from userspace, and when clearing the NX bit this is\nto return to userspace and then the 'rfi' should synchronise the\ncontext.\n\nHowever, it looks like on book3s/32 having a hash page table, at least\non the G3 processor, we get an unexpected fault from userspace, then\nthis is followed by something wrong in the verification of MSR_PR\nat end of another interrupt.\n\nThis is fixed by adding back the removed isync() following update\nof NX bit in user segment registers. Only do it for cores with an\nhash table, as 603 cores don't exhibit that problem and the two isync\nincrease ./null_syscall selftest by 6 cycles on an MPC 832x.\n\nFirst problem: unexpected WARN_ON() for mysterious PROTFAULT\n\n  WARNING: CPU: 0 PID: 1660 at arch/powerpc/mm/fault.c:354 do_page_fault+0x6c/0x5b0\n  Modules linked in:\n  CPU: 0 PID: 1660 Comm: Xorg Not tainted 5.13.0-pmac-00028-gb3c15b60339a #40\n  NIP:  c001b5c8 LR: c001b6f8 CTR: 00000000\n  REGS: e2d09e40 TRAP: 0700   Not tainted  (5.13.0-pmac-00028-gb3c15b60339a)\n  MSR:  00021032 <ME,IR,DR,RI>  CR: 42d04f30  XER: 20000000\n  GPR00: c000424c e2d09f00 c301b680 e2d09f40 0000001e 42000000 00cba028 00000000\n  GPR08: 08000000 48000010 c301b680 e2d09f30 22d09f30 00c1fff0 00cba000 a7b7ba4c\n  GPR16: 00000031 00000000 00000000 00000000 00000000 00000000 a7b7b0d0 00c5c010\n  GPR24: a7b7b64c a7b7d2f0 00000004 00000000 c1efa6c0 00cba02c 00000300 e2d09f40\n  NIP [c001b5c8] do_page_fault+0x6c/0x5b0\n  LR [c001b6f8] do_page_fault+0x19c/0x5b0\n  Call Trace:\n  [e2d09f00] [e2d09f04] 0xe2d09f04 (unreliable)\n  [e2d09f30] [c000424c] DataAccess_virt+0xd4/0xe4\n  --- interrupt: 300 at 0xa7a261dc\n  NIP:  a7a261dc LR: a7a253bc CTR: 00000000\n  REGS: e2d09f40 TRAP: 0300   Not tainted  (5.13.0-pmac-00028-gb3c15b60339a)\n  MSR:  0000d032 <EE,PR,ME,IR,DR,RI>  CR: 228428e2  XER: 20000000\n  DAR: 00cba02c DSISR: 42000000\n  GPR00: a7a27448 afa6b0e0 a74c35c0 a7b7b614 0000001e a7b7b614 00cba028 00000000\n  GPR08: 00020fd9 00000031 00cb9ff8 a7a273b0 220028e2 00c1fff0 00cba000 a7b7ba4c\n  GPR16: 00000031 00000000 00000000 00000000 00000000 00000000 a7b7b0d0 00c5c010\n  GPR24: a7b7b64c a7b7d2f0 00000004 00000002 0000001e a7b7b614 a7b7aff4 00000030\n  NIP [a7a261dc] 0xa7a261dc\n  LR [a7a253bc] 0xa7a253bc\n  --- interrupt: 300\n  Instruction dump:\n  7c4a1378 810300a0 75278410 83820298 83a300a4 553b018c 551e0036 4082038c\n  2e1b0000 40920228 75280800 41820220 <0fe00000> 3b600000 41920214 81420594\n\nSecond problem: MSR PR is seen unset allthough the interrupt frame shows it set\n\n  kernel BUG at arch/powerpc/kernel/interrupt.c:458!\n  Oops: Exception in kernel mode, sig: 5 [#1]\n  BE PAGE_SIZE=4K MMU=Hash SMP NR_CPUS=2 PowerMac\n  Modules linked in:\n  CPU: 0 PID: 1660 Comm: Xorg Tainted: G        W         5.13.0-pmac-00028-gb3c15b60339a #40\n  NIP:  c0011434 LR: c001629c CTR: 00000000\n  REGS: e2d09e70 TRAP: 0700   Tainted: G        W          (5.13.0-pmac-00028-gb3c15b60339a)\n  MSR:  00029032 <EE,ME,IR,DR,RI>  CR: 42d09f30  XER: 00000000\n  GPR00: 00000000 e2d09f30 c301b680 e2d09f40 83440000 c44d0e68 e2d09e8c 00000000\n  GPR08: 00000002 00dc228a 00004000 e2d09f30 22d09f30 00c1fff0 afa6ceb4 00c26144\n  GPR16: 00c25fb8 00c26140 afa6ceb8 90000000 00c944d8 0000001c 00000000 00200000\n  GPR24: 00000000 000001fb afa6d1b4 00000001 00000000 a539a2a0 a530fd80 00000089\n  NIP [c0011434] interrupt_exit_kernel_prepare+0x10/0x70\n  LR [c001629c] interrupt_return+0x9c/0x144\n  Call Trace:\n  [e2d09f30] [c000424c] DataAccess_virt+0xd4/0xe4 (unreliable)\n  --- interrupt: 300 at 0xa09be008\n  NIP:  a09be008 LR: a09bdfe8 CTR: a09bdfc0\n  REGS: e2d09f40 TRAP: 0300   Tainted: G        W          (5.13.0-pmac-00028-gb3c15b60339a)\n  MSR:  0000d032 <EE,PR,ME,IR,DR,RI>  CR: 420028e2  XER: 20000000\n  DAR: a539a308 DSISR: 0a000000\n  GPR00: a7b90d50 afa6b2d0 a74c35c0 a0a8b690 a0a8b698 a5365d70 a4fa82a8 00000004\n  GPR08: 00000000 a09bdfc0 00000000 a5360000 a09bde7c 00c1fff0 afa6ceb4 00c26144\n  GPR16: 00c25fb8 00c26140 afa6ceb8 90000000 00c944d8 0000001c 00000000 00200000\n  GPR24: 00000000 000001fb afa6d1b4 00000001 00000000 a539a2a0 a530fd80 00000089\n  NIP [a09be008] 0xa09be008\n  LR [a09bdfe8] 0xa09bdfe8\n  --- interrupt: 300\n  Instruction dump:\n  80010024 83e1001c 7c0803a6 4bffff80 3bc00800 4bffffd0 486b42fd 4bffffcc\n  81430084 71480002 41820038 554a0462 <0f0a0000> 80620060 74630001 40820034\n\nFixes: b5efec00b671 (\"powerpc/32s: Move KUEP locking/unlocking in C\")\nCc: stable@vger.kernel.org # v5.13+\nReported-by: Stan Johnson <userm57@yahoo.com>\nSigned-off-by: Christophe Leroy <christophe.leroy@csgroup.eu>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/4856f5574906e2aec0522be17bf3848a22b2cd0b.1629269345.git.christophe.leroy@csgroup.eu",
        "before_after_code_files": [
          "arch/powerpc/include/asm/book3s/32/kup.h||arch/powerpc/include/asm/book3s/32/kup.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/include/asm/book3s/32/kup.h||arch/powerpc/include/asm/book3s/32/kup.h": [
          "File: arch/powerpc/include/asm/book3s/32/kup.h -> arch/powerpc/include/asm/book3s/32/kup.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include <asm/bug.h>",
          "6: #include <asm/book3s/32/mmu-hash.h>",
          "8: #ifndef __ASSEMBLY__",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include <asm/mmu.h>",
          "8: #include <asm/synch.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:   return;",
          "30:  update_user_segments(mfsr(0) | SR_NX);",
          "31: }",
          "33: static inline void kuep_unlock(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:  if (mmu_has_feature(MMU_FTR_HPTE_TABLE))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "36:   return;",
          "38:  update_user_segments(mfsr(0) & ~SR_NX);",
          "39: }",
          "41: #ifdef CONFIG_PPC_KUAP",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57:  if (mmu_has_feature(MMU_FTR_HPTE_TABLE))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "02c6dcd543f8f051973ee18bfbc4dc3bd595c558",
      "candidate_info": {
        "commit_hash": "02c6dcd543f8f051973ee18bfbc4dc3bd595c558",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/02c6dcd543f8f051973ee18bfbc4dc3bd595c558",
        "files": [
          "drivers/scsi/scsi_sysfs.c"
        ],
        "message": "scsi: core: Fix hang of freezing queue between blocking and running device\n\nWe found a hang, the steps to reproduce  are as follows:\n\n  1. blocking device via scsi_device_set_state()\n\n  2. dd if=/dev/sda of=/mnt/t.log bs=1M count=10\n\n  3. echo none > /sys/block/sda/queue/scheduler\n\n  4. echo \"running\" >/sys/block/sda/device/state\n\nStep 3 and 4 should complete after step 4, but they hang.\n\n  CPU#0               CPU#1                CPU#2\n  ---------------     ----------------     ----------------\n                                           Step 1: blocking device\n\n                                           Step 2: dd xxxx\n                                                  ^^^^^^ get request\n                                                         q_usage_counter++\n\n                      Step 3: switching scheculer\n                      elv_iosched_store\n                        elevator_switch\n                          blk_mq_freeze_queue\n                            blk_freeze_queue\n                              > blk_freeze_queue_start\n                                ^^^^^^ mq_freeze_depth++\n\n                              > blk_mq_run_hw_queues\n                                ^^^^^^ can't run queue when dev blocked\n\n                              > blk_mq_freeze_queue_wait\n                                ^^^^^^ Hang here!!!\n                                       wait q_usage_counter==0\n\n  Step 4: running device\n  store_state_field\n    scsi_rescan_device\n      scsi_attach_vpd\n        scsi_vpd_inquiry\n          __scsi_execute\n            blk_get_request\n              blk_mq_alloc_request\n                blk_queue_enter\n                ^^^^^^ Hang here!!!\n                       wait mq_freeze_depth==0\n\n    blk_mq_run_hw_queues\n    ^^^^^^ dispatch IO, q_usage_counter will reduce to zero\n\n                            blk_mq_unfreeze_queue\n                            ^^^^^ mq_freeze_depth--\n\nTo fix this, we need to run queue before rescanning device when the device\nstate changes to SDEV_RUNNING.\n\nLink: https://lore.kernel.org/r/20210824025921.3277629-1-lijinlin3@huawei.com\nFixes: f0f82e2476f6 (\"scsi: core: Fix capacity set to zero after offlinining device\")\nReviewed-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Li Jinlin <lijinlin3@huawei.com>\nSigned-off-by: Qiu Laibin <qiulaibin@huawei.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/scsi_sysfs.c||drivers/scsi/scsi_sysfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/scsi_sysfs.c||drivers/scsi/scsi_sysfs.c": [
          "File: drivers/scsi/scsi_sysfs.c -> drivers/scsi/scsi_sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "808:  ret = scsi_device_set_state(sdev, state);",
          "814:  if (ret == 0 && state == SDEV_RUNNING) {",
          "816:   blk_mq_run_hw_queues(sdev->request_queue, true);",
          "817:  }",
          "818:  mutex_unlock(&sdev->state_mutex);",
          "",
          "[Removed Lines]",
          "815:   scsi_rescan_device(dev);",
          "",
          "[Added Lines]",
          "819:   scsi_rescan_device(dev);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "963e4db83e2832ee5e760f3c7f92d68bd66156f6",
      "candidate_info": {
        "commit_hash": "963e4db83e2832ee5e760f3c7f92d68bd66156f6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/963e4db83e2832ee5e760f3c7f92d68bd66156f6",
        "files": [
          "fs/btrfs/extent_io.c"
        ],
        "message": "btrfs: unify regular and subpage error paths in __extent_writepage()\n\n[BUG]\nWhen running btrfs/160 in a loop for subpage with experimental\ncompression support, it has a high chance to crash (~20%):\n\n BTRFS critical (device dm-7): panic in __btrfs_add_ordered_extent:238: inconsistency in ordered tree at offset 0 (errno=-17 Object already exists)\n ------------[ cut here ]------------\n kernel BUG at fs/btrfs/ordered-data.c:238!\n Internal error: Oops - BUG: 0 [#1] SMP\n pc : __btrfs_add_ordered_extent+0x550/0x670 [btrfs]\n lr : __btrfs_add_ordered_extent+0x550/0x670 [btrfs]\n Call trace:\n  __btrfs_add_ordered_extent+0x550/0x670 [btrfs]\n  btrfs_add_ordered_extent+0x2c/0x50 [btrfs]\n  run_delalloc_nocow+0x81c/0x8fc [btrfs]\n  btrfs_run_delalloc_range+0xa4/0x390 [btrfs]\n  writepage_delalloc+0xc0/0x1ac [btrfs]\n  __extent_writepage+0xf4/0x370 [btrfs]\n  extent_write_cache_pages+0x288/0x4f4 [btrfs]\n  extent_writepages+0x58/0xe0 [btrfs]\n  btrfs_writepages+0x1c/0x30 [btrfs]\n  do_writepages+0x60/0x110\n  __filemap_fdatawrite_range+0x108/0x170\n  filemap_fdatawrite_range+0x20/0x30\n  btrfs_fdatawrite_range+0x34/0x4dc [btrfs]\n  __btrfs_write_out_cache+0x34c/0x480 [btrfs]\n  btrfs_write_out_cache+0x144/0x220 [btrfs]\n  btrfs_start_dirty_block_groups+0x3ac/0x6b0 [btrfs]\n  btrfs_commit_transaction+0xd0/0xbb4 [btrfs]\n  btrfs_sync_fs+0x64/0x1cc [btrfs]\n  sync_fs_one_sb+0x3c/0x50\n  iterate_supers+0xcc/0x1d4\n  ksys_sync+0x6c/0xd0\n  __arm64_sys_sync+0x1c/0x30\n  invoke_syscall+0x50/0x120\n  el0_svc_common.constprop.0+0x4c/0xd4\n  do_el0_svc+0x30/0x9c\n  el0_svc+0x2c/0x54\n  el0_sync_handler+0x1a8/0x1b0\n  el0_sync+0x198/0x1c0\n ---[ end trace 336f67369ae6e0af ]---\n\n[CAUSE]\nFor subpage case, we can have multiple sectors inside a page, this makes\nit possible for __extent_writepage() to have part of its page submitted\nbefore returning.\n\nIn btrfs/160, we are using dm-dust to emulate write error, this means\nfor certain pages, we could have everything running fine, but at the end\nof __extent_writepage(), one of the submitted bios fails due to dm-dust.\n\nThen the page is marked Error, and we change @ret from 0 to -EIO.\n\nThis makes the caller extent_write_cache_pages() to error out, without\nsubmitting the remaining pages.\n\nFurthermore, since we're erroring out for free space cache, it doesn't\nreally care about the error and will update the inode and retry the\nwriteback.\n\nThen we re-run the delalloc range, and will try to insert the same\ndelalloc range while previous delalloc range is still hanging there,\ntriggering the above error.\n\n[FIX]\nThe proper fix is to handle errors from __extent_writepage() properly,\nby ending the remaining ordered extent.\n\nBut that fix needs the following changes:\n\n- Know at exactly which sector the error happened\n  Currently __extent_writepage_io() works for the full page, can't\n  return at which sector we hit the error.\n\n- Grab the ordered extent covering the failed sector\n\nAs a hotfix for subpage case, here we unify the error paths in\n__extent_writepage().\n\nIn fact, the \"if (PageError(page))\" branch never get executed if @ret is\nstill 0 for non-subpage cases.\n\nAs for non-subpage case, we never submit current page in\n__extent_writepage(), but only add current page into bio.\nThe bio can only get submitted in next page.\n\nThus we never get PageError() set due to IO failure, thus when we hit\nthe branch, @ret is never 0.\n\nBy simply removing that @ret assignment, we let subpage case ignore the\nIO failure, thus only error out for fatal errors just like regular\nsectorsize.\n\nSo that IO error won't be treated as fatal error not trigger the hanging\nOE problem.\n\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/extent_io.c||fs/btrfs/extent_io.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/extent_io.c||fs/btrfs/extent_io.c": [
          "File: fs/btrfs/extent_io.c -> fs/btrfs/extent_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2789:  btrfs_writepage_endio_finish_ordered(inode, page, start, end, uptodate);",
          "2791:  if (!uptodate) {",
          "2794:   ret = err < 0 ? err : -EIO;",
          "2795:   mapping_set_error(page->mapping, ret);",
          "2796:  }",
          "",
          "[Removed Lines]",
          "2792:   ClearPageUptodate(page);",
          "2793:   SetPageError(page);",
          "",
          "[Added Lines]",
          "2792:   const struct btrfs_fs_info *fs_info = inode->root->fs_info;",
          "2793:   u32 len;",
          "2795:   ASSERT(end + 1 - start <= U32_MAX);",
          "2796:   len = end + 1 - start;",
          "2798:   btrfs_page_clear_uptodate(fs_info, page, start, len);",
          "2799:   btrfs_page_set_error(fs_info, page, start, len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3793:   ret = btrfs_run_delalloc_range(inode, page, delalloc_start,",
          "3794:     delalloc_end, &page_started, nr_written, wbc);",
          "3795:   if (ret) {",
          "",
          "[Removed Lines]",
          "3796:    SetPageError(page);",
          "",
          "[Added Lines]",
          "3802:    btrfs_page_set_error(inode->root->fs_info, page,",
          "3803:           page_offset(page), PAGE_SIZE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4068:  WARN_ON(!PageLocked(page));",
          "4072:  pg_offset = offset_in_page(i_size);",
          "4073:  if (page->index > end_index ||",
          "",
          "[Removed Lines]",
          "4070:  ClearPageError(page);",
          "",
          "[Added Lines]",
          "4077:  btrfs_page_clear_error(btrfs_sb(inode->i_sb), page,",
          "4078:           page_offset(page), PAGE_SIZE);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4108:   set_page_writeback(page);",
          "4109:   end_page_writeback(page);",
          "4110:  }",
          "4113:   end_extent_writepage(page, ret, start, page_end);",
          "4115:  unlock_page(page);",
          "4116:  ASSERT(ret <= 0);",
          "4117:  return ret;",
          "",
          "[Removed Lines]",
          "4111:  if (PageError(page)) {",
          "4112:   ret = ret < 0 ? ret : -EIO;",
          "4114:  }",
          "",
          "[Added Lines]",
          "4150:  if (PageError(page))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1e35b8a7780a0c043cc5389420f069b69343f5d9",
      "candidate_info": {
        "commit_hash": "1e35b8a7780a0c043cc5389420f069b69343f5d9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1e35b8a7780a0c043cc5389420f069b69343f5d9",
        "files": [
          "drivers/platform/x86/gigabyte-wmi.c"
        ],
        "message": "platform/x86: gigabyte-wmi: add support for B450M S2H V2\n\nReported as working here:\nhttps://github.com/t-8ch/linux-gigabyte-wmi-driver/issues/1#issuecomment-901207693\n\nSigned-off-by: Thomas Wei\u00dfschuh <linux@weissschuh.net>\nLink: https://lore.kernel.org/r/20210818164435.99821-1-linux@weissschuh.net\nSigned-off-by: Hans de Goede <hdegoede@redhat.com>",
        "before_after_code_files": [
          "drivers/platform/x86/gigabyte-wmi.c||drivers/platform/x86/gigabyte-wmi.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/platform/x86/gigabyte-wmi.c||drivers/platform/x86/gigabyte-wmi.c": [
          "File: drivers/platform/x86/gigabyte-wmi.c -> drivers/platform/x86/gigabyte-wmi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "140:  }}",
          "142: static const struct dmi_system_id gigabyte_wmi_known_working_platforms[] = {",
          "143:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B550 AORUS ELITE\"),",
          "144:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B550 AORUS ELITE V2\"),",
          "145:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B550 GAMING X V2\"),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "143:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B450M S2H V2\"),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4b79959510e6612d80f8d86022e0cb44eee6f4a2",
      "candidate_info": {
        "commit_hash": "4b79959510e6612d80f8d86022e0cb44eee6f4a2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4b79959510e6612d80f8d86022e0cb44eee6f4a2",
        "files": [
          "drivers/net/ethernet/intel/igc/igc_main.c",
          "drivers/net/ethernet/intel/igc/igc_ptp.c"
        ],
        "message": "igc: fix page fault when thunderbolt is unplugged\n\nAfter unplug thunderbolt dock with i225, pciehp interrupt is triggered,\nremove call will read/write mmio address which is already disconnected,\nthen cause page fault and make system hang.\n\nCheck PCI state to remove device safely.\n\nTrace:\nBUG: unable to handle page fault for address: 000000000000b604\nOops: 0000 [#1] SMP NOPTI\nRIP: 0010:igc_rd32+0x1c/0x90 [igc]\nCall Trace:\nigc_ptp_suspend+0x6c/0xa0 [igc]\nigc_ptp_stop+0x12/0x50 [igc]\nigc_remove+0x7f/0x1c0 [igc]\npci_device_remove+0x3e/0xb0\n__device_release_driver+0x181/0x240\n\nFixes: 13b5b7fd6a4a (\"igc: Add support for Tx/Rx rings\")\nFixes: b03c49cde61f (\"igc: Save PTP time before a reset\")\nSigned-off-by: Aaron Ma <aaron.ma@canonical.com>\nTested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>\nSigned-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>",
        "before_after_code_files": [
          "drivers/net/ethernet/intel/igc/igc_main.c||drivers/net/ethernet/intel/igc/igc_main.c",
          "drivers/net/ethernet/intel/igc/igc_ptp.c||drivers/net/ethernet/intel/igc/igc_ptp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/intel/igc/igc_main.c||drivers/net/ethernet/intel/igc/igc_main.c": [
          "File: drivers/net/ethernet/intel/igc/igc_main.c -> drivers/net/ethernet/intel/igc/igc_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:  struct igc_hw *hw = &adapter->hw;",
          "150:  u32 ctrl_ext;",
          "153:  ctrl_ext = rd32(IGC_CTRL_EXT);",
          "154:  wr32(IGC_CTRL_EXT,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "152:  if (!pci_device_is_present(adapter->pdev))",
          "153:   return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4450:  igc_ptp_suspend(adapter);",
          "4458:  netif_trans_update(netdev);",
          "4460:  netif_carrier_off(netdev);",
          "4461:  netif_tx_stop_all_queues(netdev);",
          "4473:  adapter->flags &= ~IGC_FLAG_NEED_LINK_UPDATE;",
          "",
          "[Removed Lines]",
          "4453:  rctl = rd32(IGC_RCTL);",
          "4454:  wr32(IGC_RCTL, rctl & ~IGC_RCTL_EN);",
          "4464:  tctl = rd32(IGC_TCTL);",
          "4465:  tctl &= ~IGC_TCTL_EN;",
          "4466:  wr32(IGC_TCTL, tctl);",
          "4468:  wrfl();",
          "4469:  usleep_range(10000, 20000);",
          "4471:  igc_irq_disable(adapter);",
          "",
          "[Added Lines]",
          "4455:  if (pci_device_is_present(adapter->pdev)) {",
          "4457:   rctl = rd32(IGC_RCTL);",
          "4458:   wr32(IGC_RCTL, rctl & ~IGC_RCTL_EN);",
          "4460:  }",
          "4467:  if (pci_device_is_present(adapter->pdev)) {",
          "4469:   tctl = rd32(IGC_TCTL);",
          "4470:   tctl &= ~IGC_TCTL_EN;",
          "4471:   wr32(IGC_TCTL, tctl);",
          "4473:   wrfl();",
          "4474:   usleep_range(10000, 20000);",
          "4476:   igc_irq_disable(adapter);",
          "4477:  }",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/intel/igc/igc_ptp.c||drivers/net/ethernet/intel/igc/igc_ptp.c": [
          "File: drivers/net/ethernet/intel/igc/igc_ptp.c -> drivers/net/ethernet/intel/igc/igc_ptp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "849:  adapter->ptp_tx_skb = NULL;",
          "850:  clear_bit_unlock(__IGC_PTP_TX_IN_PROGRESS, &adapter->state);",
          "853: }",
          "",
          "[Removed Lines]",
          "852:  igc_ptp_time_save(adapter);",
          "",
          "[Added Lines]",
          "852:  if (pci_device_is_present(adapter->pdev))",
          "853:   igc_ptp_time_save(adapter);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
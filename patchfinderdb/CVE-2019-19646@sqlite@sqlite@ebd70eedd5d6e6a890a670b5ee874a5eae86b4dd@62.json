{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6a0db87a2fbd50aa8fd22fe4362549f31b1a82b1",
      "candidate_info": {
        "commit_hash": "6a0db87a2fbd50aa8fd22fe4362549f31b1a82b1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/6a0db87a2fbd50aa8fd22fe4362549f31b1a82b1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/parse.y"
        ],
        "message": "If the amalgamation file \"sqlite3.c\" is generated using the SQLITE_ENABLE_UPDATE_DELETE_LIMIT option, but then subsequently (mis-)compiled without that option, and then a particular syntax error could cause a memory leak, but for this fix.\n\nFossilOrigin-Name: 1bb17c863a269ab8b28df94b9fdaac3ee70777ccd0a30300131bf67df6722052",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/parse.y||src/parse.y"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 507c43537f00d089efb3c3020fb6e826e8f89f3efa2caaa12c5309d35dd0c22e",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "826: cmd ::= with DELETE FROM xfullname(X) indexed_opt(I) where_opt(W)",
          "827:         orderby_opt(O) limit_opt(L). {",
          "828:   sqlite3SrcListIndexedBy(pParse, X, &I);",
          "829:   sqlite3DeleteFrom(pParse,X,W,O,L);",
          "830: }",
          "831: %endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "829: #ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "830:   sqlite3ExprListDelete(pParse->db, O); O = 0;",
          "831:   sqlite3ExprDelete(pParse->db, L); L = 0;",
          "832: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f4f86f3fcaa6110aaf64cd2f5b9f878dac17974c",
      "candidate_info": {
        "commit_hash": "f4f86f3fcaa6110aaf64cd2f5b9f878dac17974c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f4f86f3fcaa6110aaf64cd2f5b9f878dac17974c",
        "files": [
          "ext/rbu/rbu_common.tcl",
          "ext/rbu/rbupartial.test",
          "ext/rbu/rbuvacuum4.test",
          "ext/rbu/sqlite3rbu.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Optimize the restarting of an RBU vacuum.\n\nFossilOrigin-Name: 82062351a62f4ccc438a2b47a22ee581bd030dec952fecd610f360a25002a5ea",
        "before_after_code_files": [
          "ext/rbu/rbu_common.tcl||ext/rbu/rbu_common.tcl",
          "ext/rbu/rbupartial.test||ext/rbu/rbupartial.test",
          "ext/rbu/rbuvacuum4.test||ext/rbu/rbuvacuum4.test",
          "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/rbu/rbu_common.tcl||ext/rbu/rbu_common.tcl": [
          "File: ext/rbu/rbu_common.tcl -> ext/rbu/rbu_common.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "89: proc do_rbu_vacuum_test {tn step {statedb state.db}} {",
          "90:   forcedelete $statedb",
          "91:   if {$statedb==\"\" && $step==1} breakpoint",
          "94:     while 1 {",
          "96:       set state [rbu state]",
          "97:       check_prestep_state test.db $state",
          "98:       set rc [rbu step]",
          "99:       check_poststep_state $rc test.db $state",
          "100:       if {$rc!=\"SQLITE_OK\"} break",
          "102:     }",
          "103:     rbu close",
          "104:   }] {SQLITE_DONE}]",
          "",
          "[Removed Lines]",
          "92:   uplevel [list do_test $tn.1 [string map [list %state% $statedb] {",
          "93:     if {$step==0} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "95:       if {$step==1} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "101:       if {$step==1} { rbu close }",
          "",
          "[Added Lines]",
          "92:   uplevel [list do_test $tn.1 [string map [list %state% $statedb %step% $step] {",
          "93:     if {%step%==0} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "95:       if {%step%==1} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "101:       if {%step%==1} { rbu close }",
          "",
          "---------------"
        ],
        "ext/rbu/rbupartial.test||ext/rbu/rbupartial.test": [
          "File: ext/rbu/rbupartial.test -> ext/rbu/rbupartial.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:   set step 0",
          "82:   do_rbu_vacuum_test $tn.1.5 0",
          "83:   }]",
          "84: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84:   do_test $tn.1.6 {",
          "85:     execsql { PRAGMA integrity_check }",
          "86:   } {ok}",
          "",
          "---------------"
        ],
        "ext/rbu/rbuvacuum4.test||ext/rbu/rbuvacuum4.test": [
          "File: ext/rbu/rbuvacuum4.test -> ext/rbu/rbuvacuum4.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 Jan 3",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # This file contains tests for the RBU module. More specifically, it",
          "13: # contains tests to ensure that the sqlite3rbu_vacuum() API works as",
          "14: # expected.",
          "15: #",
          "17: source [file join [file dirname [info script]] rbu_common.tcl]",
          "18: set testprefix rbuvacuum4",
          "20: set step 1",
          "22: do_execsql_test 1.0 {",
          "23:   CREATE TABLE t1(a PRIMARY KEY, b, c) WITHOUT ROWID;",
          "24:   INSERT INTO t1 VALUES(1, 2, 3);",
          "25:   INSERT INTO t1 VALUES(4, 5, 6);",
          "26:   INSERT INTO t1 VALUES(7, 8, 9);",
          "27: }",
          "28: do_rbu_vacuum_test 1.1 1",
          "30: #-------------------------------------------------------------------------",
          "31: reset_db",
          "33: do_execsql_test 2.0 {",
          "34:   CREATE TABLE t1(a, b, c, PRIMARY KEY(a, b, c)) WITHOUT ROWID;",
          "35:   INSERT INTO t1 VALUES(1, 2, 3);",
          "36:   INSERT INTO t1 VALUES(4, 5, 6);",
          "37:   INSERT INTO t1 VALUES(7, 8, 9);",
          "38: }",
          "39: do_rbu_vacuum_test 2.1 1",
          "40: do_execsql_test 2.2 {",
          "41:   SELECT * FROM t1;",
          "42: } {1 2 3 4 5 6 7 8 9}",
          "44: #-------------------------------------------------------------------------",
          "45: reset_db",
          "47: do_execsql_test 3.0 {",
          "48:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "49:   CREATE INDEX i1 oN t1(b, c);",
          "50:   INSERT INTO t1 VALUES(1, 2, 3);",
          "51:   INSERT INTO t1 VALUES(4, 5, 6);",
          "52:   INSERT INTO t1 VALUES(7, 8, 9);",
          "53: }",
          "55: do_rbu_vacuum_test 3.1 1",
          "57: do_execsql_test 3.2 {",
          "58:   SELECT * FROM t1;",
          "59: } {1 2 3 4 5 6 7 8 9}",
          "61: #-------------------------------------------------------------------------",
          "62: reset_db",
          "63: do_execsql_test 4.0 {",
          "64:   CREATE TABLE x1(a, b, c, d, PRIMARY KEY(c, b)) WITHOUT ROWID;",
          "65:   INSERT INTO x1 VALUES(1, 1, 1, 1);",
          "66:   INSERT INTO x1 VALUES(1, 1, 2, 1);",
          "67:   INSERT INTO x1 VALUES(1, 2, 2, 1);",
          "69:   INSERT INTO x1 VALUES(NULL, 2, 3, NULL);",
          "70:   INSERT INTO x1 VALUES(NULL, 2, 4, NULL);",
          "71:   INSERT INTO x1 VALUES(NULL, 2, 5, NULL);",
          "73:   CREATE INDEX x1ad ON x1(d, a);",
          "74:   CREATE INDEX x1null ON x1(d, a) WHERE d>15;",
          "75: }",
          "77: do_rbu_vacuum_test 4.1.1 1",
          "79: do_execsql_test 4.2 {",
          "80:   SELECT count(*) fROM x1",
          "81: } 6",
          "83: do_rbu_vacuum_test 4.1.2 0",
          "85: #-------------------------------------------------------------------------",
          "86: reset_db",
          "87: do_execsql_test 5.0 {",
          "88:   CREATE TABLE \"a b c\"(a, \"b b\" PRIMARY KEY, \"c c\");",
          "89:   CREATE INDEX abc1 ON \"a b c\"(a, \"c c\");",
          "91:   INSERT INTO \"a b c\" VALUES(NULL, 'a', NULL);",
          "92:   INSERT INTO \"a b c\" VALUES(NULL, 'b', NULL);",
          "93:   INSERT INTO \"a b c\" VALUES(NULL, 'c', NULL);",
          "95:   INSERT INTO \"a b c\" VALUES(1, 2, 3);",
          "96:   INSERT INTO \"a b c\" VALUES(3, 9, 1);",
          "97:   INSERT INTO \"a b c\" VALUES('aaa', 'bbb', 'ccc');",
          "99:   CREATE TABLE x(a);",
          "100:   INSERT INTO x VALUES('a'), ('b'), ('d');",
          "101:   CREATE UNIQUE INDEX y ON x(a);",
          "102: }",
          "104: do_rbu_vacuum_test 5.1 1",
          "106: finish_test",
          "",
          "---------------"
        ],
        "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c": [
          "File: ext/rbu/sqlite3rbu.c -> ext/rbu/sqlite3rbu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "930:   zIn = (const char*)sqlite3_value_text(argv[0]);",
          "931:   if( zIn ){",
          "932:     if( rbuIsVacuum(p) ){",
          "934:         sqlite3_result_text(pCtx, zIn, -1, SQLITE_STATIC);",
          "935:       }",
          "936:     }else{",
          "",
          "[Removed Lines]",
          "933:       if( argc==1 || 0==sqlite3_value_int(argv[1]) ){",
          "",
          "[Added Lines]",
          "933:       assert( argc==2 );",
          "934:       if( 0==sqlite3_value_int(argv[1]) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1381:         }",
          "1383:         pIter->azTblType[iOrder] = rbuStrndup(zType, &p->rc);",
          "1385:         pIter->abNotNull[iOrder] = (u8)bNotNull || (iPk!=0);",
          "1386:         iOrder++;",
          "1387:       }",
          "",
          "[Removed Lines]",
          "1384:         pIter->abTblPk[iOrder] = (iPk!=0);",
          "",
          "[Added Lines]",
          "1385:         assert( iPk>=0 );",
          "1386:         pIter->abTblPk[iOrder] = (u8)iPk;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1416:   return zList;",
          "1417: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1427: static char *rbuObjIterGetPkList(",
          "1433: ){",
          "1434:   int iPk = 1;",
          "1435:   char *zRet = 0;",
          "1436:   const char *zSep = \"\";",
          "1437:   while( 1 ){",
          "1438:     int i;",
          "1439:     for(i=0; i<pIter->nTblCol; i++){",
          "1440:       if( (int)pIter->abTblPk[i]==iPk ){",
          "1441:         const char *zCol = pIter->azTblCol[i];",
          "1442:         zRet = rbuMPrintf(p, \"%z%s%s\\\"%w\\\"%s\", zRet, zSep, zPre, zCol, zPost);",
          "1443:         zSep = zSeparator;",
          "1444:         break;",
          "1445:       }",
          "1446:     }",
          "1447:     if( i==pIter->nTblCol ) break;",
          "1448:     iPk++;",
          "1449:   }",
          "1450:   return zRet;",
          "1451: }",
          "1472: static char *rbuVacuumTableStart(",
          "1477: ){",
          "1478:   sqlite3_stmt *pMax = 0;",
          "1479:   char *zRet = 0;",
          "1480:   if( bRowid ){",
          "1481:     p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,",
          "1482:         sqlite3_mprintf(",
          "1483:           \"SELECT max(_rowid_) FROM \\\"%s%w\\\"\", zWrite, pIter->zTbl",
          "1484:         )",
          "1485:     );",
          "1486:     if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){",
          "1487:       sqlite3_int64 iMax = sqlite3_column_int64(pMax, 0);",
          "1488:       zRet = rbuMPrintf(p, \" WHERE _rowid_ > %lld \", iMax);",
          "1489:     }",
          "1490:     rbuFinalize(p, pMax);",
          "1491:   }else{",
          "1492:     char *zOrder = rbuObjIterGetPkList(p, pIter, \"\", \", \", \" DESC\");",
          "1493:     char *zSelect = rbuObjIterGetPkList(p, pIter, \"quote(\", \"||','||\", \")\");",
          "1494:     char *zList = rbuObjIterGetPkList(p, pIter, \"\", \", \", \"\");",
          "1496:     if( p->rc==SQLITE_OK ){",
          "1497:       p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,",
          "1498:           sqlite3_mprintf(",
          "1499:             \"SELECT %s FROM \\\"%s%w\\\" ORDER BY %s LIMIT 1\",",
          "1500:                 zSelect, zWrite, pIter->zTbl, zOrder",
          "1501:           )",
          "1502:       );",
          "1503:       if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){",
          "1504:         const char *zVal = (const char*)sqlite3_column_text(pMax, 0);",
          "1505:         zRet = rbuMPrintf(p, \" WHERE (%s) > (%s) \", zList, zVal);",
          "1506:       }",
          "1507:       rbuFinalize(p, pMax);",
          "1508:     }",
          "1510:     sqlite3_free(zOrder);",
          "1511:     sqlite3_free(zSelect);",
          "1512:     sqlite3_free(zList);",
          "1513:   }",
          "1514:   return zRet;",
          "1515: }",
          "1539: char *rbuVacuumIndexStart(",
          "1542: ){",
          "1543:   char *zOrder = 0;",
          "1544:   char *zLhs = 0;",
          "1545:   char *zSelect = 0;",
          "1546:   char *zVector = 0;",
          "1547:   char *zRet = 0;",
          "1548:   int bFailed = 0;",
          "1550:   if( p->rc==SQLITE_OK ){",
          "1551:     const char *zSep = \"\";",
          "1552:     int iCol = 0;",
          "1553:     sqlite3_stmt *pXInfo = 0;",
          "1554:     p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,",
          "1555:         sqlite3_mprintf(\"PRAGMA main.index_xinfo = %Q\", pIter->zIdx)",
          "1556:     );",
          "1557:     while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){",
          "1558:       int iCid = sqlite3_column_int(pXInfo, 1);",
          "1559:       const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);",
          "1560:       const char *zCol;",
          "1561:       if( sqlite3_column_int(pXInfo, 3) ){",
          "1562:         bFailed = 1;",
          "1563:         break;",
          "1564:       }",
          "1566:       if( iCid<0 ){",
          "1567:         if( pIter->eType==RBU_PK_IPK ){",
          "1568:           int i;",
          "1569:           for(i=0; pIter->abTblPk[i]==0; i++);",
          "1570:           assert( i<pIter->nTblCol );",
          "1571:           zCol = pIter->azTblCol[i];",
          "1572:         }else{",
          "1573:           zCol = \"_rowid_\";",
          "1574:         }",
          "1575:       }else{",
          "1576:         zCol = pIter->azTblCol[iCid];",
          "1577:       }",
          "1579:       zLhs = rbuMPrintf(p, \"%z%s \\\"%w\\\" COLLATE %Q\",",
          "1580:           zLhs, zSep, zCol, zCollate",
          "1581:       );",
          "1582:       zOrder = rbuMPrintf(p, \"%z%s \\\"rbu_imp_%d%w\\\" COLLATE %Q DESC\",",
          "1583:           zOrder, zSep, iCol, zCol, zCollate",
          "1584:       );",
          "1585:       zSelect = rbuMPrintf(p, \"%z%s quote(\\\"rbu_imp_%d%w\\\")\",",
          "1586:           zSelect, zSep, iCol, zCol",
          "1587:       );",
          "1588:       zSep = \", \";",
          "1589:       iCol++;",
          "1590:     }",
          "1591:     rbuFinalize(p, pXInfo);",
          "1592:   }",
          "1593:   if( bFailed ) goto index_start_out;",
          "1595:   if( p->rc==SQLITE_OK ){",
          "1596:     int iCol;",
          "1597:     sqlite3_stmt *pSel = 0;",
          "1599:     if( p->rc==SQLITE_OK ){",
          "1600:       p->rc = prepareFreeAndCollectError(p->dbMain, &pSel, &p->zErrmsg,",
          "1601:           sqlite3_mprintf(\"SELECT %s FROM \\\"rbu_imp_%w\\\" ORDER BY %s LIMIT 1\",",
          "1602:             zSelect, pIter->zTbl, zOrder",
          "1603:           )",
          "1604:       );",
          "1605:     }",
          "1606:     if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSel) ){",
          "1607:       const char *zSep = \"\";",
          "1608:       for(iCol=0; iCol<pIter->nCol; iCol++){",
          "1609:         const char *zQuoted = (const char*)sqlite3_column_text(pSel, iCol);",
          "1610:         if( zQuoted[0]=='N' ){",
          "1611:           bFailed = 1;",
          "1612:           break;",
          "1613:         }",
          "1614:         zVector = rbuMPrintf(p, \"%z%s%s\", zVector, zSep, zQuoted);",
          "1615:         zSep = \", \";",
          "1616:       }",
          "1618:       if( !bFailed ){",
          "1619:         zRet = rbuMPrintf(p, \"(%s) > (%s)\", zLhs, zVector);",
          "1620:       }",
          "1621:     }",
          "1622:     rbuFinalize(p, pSel);",
          "1623:   }",
          "1625:  index_start_out:",
          "1626:   sqlite3_free(zOrder);",
          "1627:   sqlite3_free(zSelect);",
          "1628:   sqlite3_free(zVector);",
          "1629:   sqlite3_free(zLhs);",
          "1630:   return zRet;",
          "1631: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2092:       if( p->rc==SQLITE_OK ){",
          "2093:         char *zSql;",
          "2094:         if( rbuIsVacuum(p) ){",
          "2095:           zSql = sqlite3_mprintf(",
          "2097:               zCollist,",
          "2098:               pIter->zDataTbl,",
          "2100:           );",
          "2101:         }else",
          "2103:         if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){",
          "",
          "[Removed Lines]",
          "2096:               \"SELECT %s, 0 AS rbu_control FROM '%q' %s ORDER BY %s%s\",",
          "2099:               zPart, zCollist, zLimit",
          "",
          "[Added Lines]",
          "2309:           char *zStart = 0;",
          "2310:           if( nOffset ){",
          "2311:             zStart = rbuVacuumIndexStart(p, pIter);",
          "2312:             if( zStart ){",
          "2313:               sqlite3_free(zLimit);",
          "2314:               zLimit = 0;",
          "2315:             }",
          "2316:           }",
          "2319:               \"SELECT %s, 0 AS rbu_control FROM '%q' %s %s %s ORDER BY %s%s\",",
          "2322:               zPart,",
          "2323:               (zStart ? (zPart ? \"AND\" : \"WHERE\") : \"\"), zStart,",
          "2324:               zCollist, zLimit",
          "2326:           sqlite3_free(zStart);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2120:               zCollist, zLimit",
          "2121:           );",
          "2122:         }",
          "2124:       }",
          "2126:       sqlite3_free(zImposterCols);",
          "",
          "[Removed Lines]",
          "2123:         p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz, zSql);",
          "",
          "[Added Lines]",
          "2349:         if( p->rc==SQLITE_OK ){",
          "2350:           p->rc = prepareFreeAndCollectError(p->dbRbu,&pIter->pSelect,pz,zSql);",
          "2351:         }else{",
          "2352:           sqlite3_free(zSql);",
          "2353:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2221:       if( p->rc==SQLITE_OK ){",
          "2222:         const char *zRbuRowid = \"\";",
          "2223:         if( bRbuRowid ){",
          "2224:           zRbuRowid = rbuIsVacuum(p) ? \",_rowid_ \" : \",rbu_rowid\";",
          "2225:         }",
          "2235:       }",
          "2237:       sqlite3_free(zWhere);",
          "",
          "[Removed Lines]",
          "2226:         p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,",
          "2227:             sqlite3_mprintf(",
          "2228:               \"SELECT %s,%s rbu_control%s FROM '%q'%s\",",
          "2229:               zCollist,",
          "2230:               (rbuIsVacuum(p) ? \"0 AS \" : \"\"),",
          "2231:               zRbuRowid,",
          "2232:               pIter->zDataTbl, zLimit",
          "2233:             )",
          "2234:         );",
          "",
          "[Added Lines]",
          "2453:         char *zStart = 0;",
          "2454:         char *zOrder = 0;",
          "2459:         if( rbuIsVacuum(p) ){",
          "2460:           if( nOffset ){",
          "2461:             zStart = rbuVacuumTableStart(p, pIter, bRbuRowid, zWrite);",
          "2462:             if( zStart ){",
          "2463:               sqlite3_free(zLimit);",
          "2464:               zLimit = 0;",
          "2465:             }",
          "2466:           }",
          "2467:           if( bRbuRowid ){",
          "2468:             zOrder = rbuMPrintf(p, \"_rowid_\");",
          "2469:           }else{",
          "2470:             zOrder = rbuObjIterGetPkList(p, pIter, \"\", \", \", \"\");",
          "2471:           }",
          "2472:         }",
          "2474:         if( p->rc==SQLITE_OK ){",
          "2475:           p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,",
          "2476:               sqlite3_mprintf(",
          "2477:                 \"SELECT %s,%s rbu_control%s FROM '%q'%s %s %s %s\",",
          "2478:                 zCollist,",
          "2479:                 (rbuIsVacuum(p) ? \"0 AS \" : \"\"),",
          "2480:                 zRbuRowid,",
          "2481:                 pIter->zDataTbl, (zStart ? zStart : \"\"),",
          "2482:                 (zOrder ? \"ORDER BY\" : \"\"), zOrder,",
          "2483:                 zLimit",
          "2484:               )",
          "2485:           );",
          "2486:         }",
          "2487:         sqlite3_free(zStart);",
          "2488:         sqlite3_free(zOrder);",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 91f701d39852ef1ddb29d1527d1520867c5efea110333315c55d8b08084384e7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "919458923dd9ea81db155fce5976a42207be11c7",
      "candidate_info": {
        "commit_hash": "919458923dd9ea81db155fce5976a42207be11c7",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/919458923dd9ea81db155fce5976a42207be11c7",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/wapptest.tcl"
        ],
        "message": "Update wapptest.tcl to use a simpler slave script. And to leave scripts wapptest_configure.sh and wapptest_make.sh in each test directory.\n\nFossilOrigin-Name: 07e527d781838412b2a434e64baaa49cbf7410a51c7393f54adc7b8eaffd5229",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/wapptest.tcl||test/wapptest.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1dbbb0101e8213b92b9a4c78c0fd2f9d0240a8ea3b40dff1033d1b8d71fb04ef",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/wapptest.tcl||test/wapptest.tcl": [
          "File: test/wapptest.tcl -> test/wapptest.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:   # The root of the SQLite source tree.",
          "38:   set G(srcdir)   [file dirname [file dirname [info script]]]",
          "43:   set G(sqlite_version) \"unknown\"",
          "45:   # Either \"config\", \"running\" or \"stopped\":",
          "",
          "[Removed Lines]",
          "40:   # releasetest.tcl script",
          "41:   set G(releaseTest) [file join [file dirname [info script]] releasetest.tcl]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:   append G(host) \" $::tcl_platform(machine) $::tcl_platform(byteOrder)\"",
          "53: }",
          "57: #",
          "70: proc generate_fossil_info {} {",
          "71:   global G",
          "72:   set pwd [pwd]",
          "73:   cd $G(srcdir)",
          "76:   cd $pwd",
          "78:   foreach line [split $r1 \"\\n\"] {",
          "79:     if {[regexp {^checkout: *(.*)$} $line -> co]} {",
          "",
          "[Removed Lines]",
          "55: # Check to see if there are uncommitted changes in the SQLite source",
          "56: # directory. Return true if there are, or false otherwise.",
          "58: proc check_uncommitted {} {",
          "59:   global G",
          "60:   set ret 0",
          "61:   set pwd [pwd]",
          "62:   cd $G(srcdir)",
          "63:   if {[catch {exec fossil changes} res]==0 && [string trim $res]!=\"\"} {",
          "64:     set ret 1",
          "65:   }",
          "66:   cd $pwd",
          "67:   return $ret",
          "68: }",
          "74:   if {[catch {exec fossil info}    r1]} return",
          "75:   if {[catch {exec fossil changes} r2]} return",
          "",
          "[Added Lines]",
          "52: # Generate the text for the box at the top of the UI. The current SQLite",
          "53: # version, according to fossil, along with a warning if there are",
          "54: # uncommitted changes in the checkout.",
          "60:   set rc [catch {",
          "61:     set r1 [exec fossil info]",
          "62:     set r2 [exec fossil changes]",
          "63:   }]",
          "65:   if {$rc} return",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "239:   do_some_stuff",
          "240: }",
          "242: proc do_some_stuff {} {",
          "243:   global G",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "231: proc wapptest_slave_script {} {",
          "232:   global G",
          "233:   set res {",
          "234:     proc readfile {filename} {",
          "235:       set fd [open $filename]",
          "236:       set data [read $fd]",
          "237:       close $fd",
          "238:       return $data",
          "239:     }",
          "240:   }",
          "242:   if {$G(msvc)==0} {",
          "243:     append res {",
          "244:       set cfg  [readfile wapptest_configure.sh]",
          "245:       set rc [catch { exec {*}$cfg >& test.log } msg]",
          "246:       if {$rc==0} {",
          "247:         set make [readfile wapptest_make.sh]",
          "248:         catch { exec {*}$make >>& test.log }",
          "249:       }",
          "250:     }",
          "251:   } else {",
          "252:     append res {",
          "253:       set make [readfile wapptest_make.sh]",
          "254:       catch { exec {*}$make >>& test.log }",
          "255:     }",
          "256:   }",
          "258:   set res",
          "259: }",
          "262: # Launch a slave process to run a test.",
          "263: #",
          "264: proc slave_launch {",
          "265:   name wtcl title dir configOpts testtarget makeOpts cflags opts",
          "266: } {",
          "267:   global G",
          "269:   catch { file mkdir $dir } msg",
          "270:   foreach f [glob -nocomplain [file join $dir *]] {",
          "271:     catch { file delete -force $f }",
          "272:   }",
          "274:   # Write the configure command to wapptest_configure.sh. This file",
          "275:   # is empty if using MSVC - MSVC does not use configure.",
          "276:   #",
          "277:   set fd1 [open [file join $dir wapptest_configure.sh] w]",
          "278:   if {$G(msvc)==0} {",
          "279:     puts $fd1 \"[file join .. $G(srcdir) configure] $wtcl $configOpts\"",
          "280:   }",
          "281:   close $fd1",
          "283:   # Write the make command to wapptest_make.sh. Using nmake for MSVC and",
          "284:   # make for all other systems.",
          "285:   #",
          "286:   set makecmd \"make\"",
          "287:   if {$G(msvc)} {",
          "288:     set nativedir [file nativename $G(srcdir)]",
          "289:     set nativedir [string map [list \"\\\\\" \"\\\\\\\\\"] $nativedir]",
          "290:     set makecmd \"nmake /f [file join $nativedir Makefile.msc] TOP=$nativedir\"",
          "291:   }",
          "292:   set fd2 [open [file join $dir wapptest_make.sh] w]",
          "293:   puts $fd2 \"$makecmd $makeOpts $testtarget \\\"CFLAGS=$cflags\\\" \\\"OPTS=$opts\\\"\"",
          "294:   close $fd2",
          "296:   # Write the wapptest_run.tcl script to the test directory. To run the",
          "297:   # commands in the other two files.",
          "298:   #",
          "299:   set fd3 [open [file join $dir wapptest_run.tcl] w]",
          "300:   puts $fd3 [wapptest_slave_script]",
          "301:   close $fd3",
          "303:   set pwd [pwd]",
          "304:   cd $dir",
          "305:   set fd [open \"|[info nameofexecutable] wapptest_run.tcl\" r+]",
          "306:   cd $pwd",
          "308:   set G(test.$name.channel) $fd",
          "309:   fconfigure $fd -blocking 0",
          "310:   fileevent $fd readable [list slave_fileevent $name]",
          "311: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "275:       if { ![info exists G(test.$name.channel)]",
          "276:         && ![info exists G(test.$name.done)]",
          "277:       } {",
          "278:         set target [dict get $j target]",
          "279:         set G(test.$name.start) [clock seconds]",
          "287:         set wtcl \"\"",
          "288:         if {$G(tcl)!=\"\"} { set wtcl \"--with-tcl=$G(tcl)\" }",
          "",
          "[Removed Lines]",
          "280:         set fd [open \"|[info nameofexecutable] $G(releaseTest) --slave\" r+]",
          "281:         set G(test.$name.channel) $fd",
          "282:         fconfigure $fd -blocking 0",
          "283:         fileevent $fd readable [list slave_fileevent $name]",
          "285:         puts $fd [list 0 $G(msvc) 0 $G(keep)]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "303:         }",
          "305:         set L [make_test_suite $G(msvc) $wtcl $name $target $opts]",
          "308:         set G(test.$name.log) [file join [lindex $L 1] test.log]",
          "309:         incr nLaunch -1",
          "310:       }",
          "",
          "[Removed Lines]",
          "306:         puts $fd $L",
          "307:         flush $fd",
          "",
          "[Added Lines]",
          "371:         set G(test.$name.log) [file join [lindex $L 1] test.log]",
          "372:         slave_launch $name $wtcl {*}$L",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "06fc24555fd7fc826c68de4b85f2326ada87ea90",
      "candidate_info": {
        "commit_hash": "06fc24555fd7fc826c68de4b85f2326ada87ea90",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/06fc24555fd7fc826c68de4b85f2326ada87ea90",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/wherecode.c"
        ],
        "message": "Changes an unreachable testcase() into an assert().\n\nFossilOrigin-Name: 5710845b6314f924b490434b4446169f4bb50576aaa940472af68150db16e127",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/wherecode.c||src/wherecode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ea20068e6d97c9349ebcc7d0a01e99ebf08c6f44363f71a0218a1abea209adc5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1903:         whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);",
          "1904:       }",
          "1905:     }else{",
          "1907:       testcase( pIdx->pPartIdxWhere );",
          "1908:     }",
          "",
          "[Removed Lines]",
          "1906:       testcase( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0 );",
          "",
          "[Added Lines]",
          "1910:       assert( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0 );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "790b37a2403eb479fcb9e33e0d7622b78524c579",
      "candidate_info": {
        "commit_hash": "790b37a2403eb479fcb9e33e0d7622b78524c579",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/790b37a2403eb479fcb9e33e0d7622b78524c579",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/parse.y",
          "src/select.c",
          "src/sqliteInt.h",
          "src/vdbe.c",
          "src/where.c",
          "test/in4.test"
        ],
        "message": "Omit the \"x IN (y)\" to \"x==y\" optimization of check-in [e68b427afbc82e20] (and ticket [e39d032577df6942]) as it causes difficult affinity problems as demonstrated by ticket [dbaf8a6820be1ece] and the original assertion fault is no longer a factor due to countless other changes of the previous 5 years.\n\nFossilOrigin-Name: 7f5168a76a400fc2e1e40c6950470b1bfb38a0be54fc5518c17c29fdae7d8f1f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/parse.y||src/parse.y",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/vdbe.c||src/vdbe.c",
          "src/where.c||src/where.c",
          "test/in4.test||test/in4.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 069c2f4c61f06211a8981abc412afcc1536ece13380b13a70aa99123f8f527cd",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: char sqlite3ExprAffinity(Expr *pExpr){",
          "46:   int op;",
          "48:   while( ExprHasProperty(pExpr, EP_Skip) ){",
          "49:     assert( pExpr->op==TK_COLLATE );",
          "50:     pExpr = pExpr->pLeft;",
          "",
          "[Removed Lines]",
          "47:   if( pExpr->flags & EP_Generic ) return 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "156:   Expr *p = pExpr;",
          "157:   while( p ){",
          "158:     int op = p->op;",
          "160:     if( op==TK_REGISTER ) op = p->op2;",
          "161:     if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER)",
          "162:      && p->y.pTab!=0",
          "",
          "[Removed Lines]",
          "159:     if( p->flags & EP_Generic ) break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "1177:       sqlite3ExprUnmapAndDelete(pParse, A);",
          "1178:       A = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[N],1);",
          "1206:     }else{",
          "1207:       A = sqlite3PExpr(pParse, TK_IN, A, 0);",
          "1208:       if( A ){",
          "",
          "[Removed Lines]",
          "1179:     }else if( Y->nExpr==1 ){",
          "1196:       Expr *pRHS = Y->a[0].pExpr;",
          "1197:       Y->a[0].pExpr = 0;",
          "1198:       sqlite3ExprListDelete(pParse->db, Y);",
          "1201:       if( ALWAYS(pRHS) ){",
          "1202:         pRHS->flags &= ~EP_Collate;",
          "1203:         pRHS->flags |= EP_Generic;",
          "1204:       }",
          "1205:       A = sqlite3PExpr(pParse, N ? TK_NE : TK_EQ, A, pRHS);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3476:           pNew->iRightJoinTable = pExpr->iRightJoinTable;",
          "3477:           ExprSetProperty(pNew, EP_FromJoin);",
          "3478:         }",
          "3482:         sqlite3ExprDelete(db, pExpr);",
          "3483:         pExpr = pNew;",
          "3484:       }",
          "",
          "[Removed Lines]",
          "3479:         if( pNew && ExprHasProperty(pExpr,EP_Generic) ){",
          "3480:           ExprSetProperty(pNew, EP_Generic);",
          "3481:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5445:   assert( pOp->opcode!=OP_Next",
          "5446:        || pC->seekOp==OP_SeekGT || pC->seekOp==OP_SeekGE",
          "5449:   assert( pOp->opcode!=OP_Prev",
          "5450:        || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE",
          "5452:        || pC->seekOp==OP_NullRow);",
          "5454:   rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);",
          "",
          "[Removed Lines]",
          "5447:        || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found",
          "5448:        || pC->seekOp==OP_NullRow|| pC->seekOp==OP_SeekRowid);",
          "5451:        || pC->seekOp==OP_Last",
          "",
          "[Added Lines]",
          "5447:        || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found",
          "5448:        || pC->seekOp==OP_NullRow|| pC->seekOp==OP_SeekRowid",
          "5449:        || pC->seekOp==OP_IfNoHope);",
          "5452:        || pC->seekOp==OP_Last   || pC->seekOp==OP_IfNoHope",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2517:       }else if( ALWAYS(pExpr->x.pList && pExpr->x.pList->nExpr) ){",
          "2519:         nIn = sqlite3LogEst(pExpr->x.pList->nExpr);",
          "2522:       }",
          "2523:       if( pProbe->hasStat1 ){",
          "2524:         LogEst M, logK, safetyMargin;",
          "",
          "[Removed Lines]",
          "2520:         assert( nIn>0 );  /* RHS always has 2 or more terms...  The parser",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/in4.test||test/in4.test": [
          "File: test/in4.test -> test/in4.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "226: do_execsql_test in4-3.43 {",
          "227:   SELECT * FROM t3 WHERE x IN (10);",
          "228: } {10 10 10}",
          "233: do_execsql_test in4-3.45 {",
          "234:   SELECT * FROM t3 WHERE x NOT IN (10,11,99999);",
          "235: } {1 1 1}",
          "",
          "[Removed Lines]",
          "229: do_execsql_test in4-3.44 {",
          "230:   EXPLAIN",
          "231:   SELECT * FROM t3 WHERE x IN (10);",
          "232: } {~/OpenEphemeral/}",
          "",
          "[Added Lines]",
          "230: # This test would verify that the \"X IN (Y)\" -> \"X==Y\" optimization",
          "231: # was working.  But we have now taken that optimization out.",
          "232: #do_execsql_test in4-3.44 {",
          "233: #  EXPLAIN",
          "234: #  SELECT * FROM t3 WHERE x IN (10);",
          "235: #} {~/OpenEphemeral/}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "326: do_execsql_test in4-6.1-eqp {",
          "327:   EXPLAIN QUERY PLAN",
          "328:   SELECT * FROM t6a, t6b WHERE a=3 AND b IN (c);",
          "330: do_execsql_test in4-6.2 {",
          "331:   SELECT * FROM t6a, t6b WHERE a=3 AND c IN (b);",
          "332: } {3 4 4 44}",
          "",
          "[Removed Lines]",
          "329: } {~/SCAN/}",
          "",
          "[Added Lines]",
          "332: } {~/SCAN TABLE t6a/}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
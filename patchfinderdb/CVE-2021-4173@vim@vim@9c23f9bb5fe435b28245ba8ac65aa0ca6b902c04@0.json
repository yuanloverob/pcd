{
  "cve_id": "CVE-2021-4173",
  "cve_desc": "vim is vulnerable to Use After Free",
  "repo": "vim/vim",
  "patch_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
  "patch_info": {
    "commit_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
    "files": [
      "src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim",
      "src/userfunc.c",
      "src/version.c",
      "src/vim9compile.c",
      "src/vim9execute.c"
    ],
    "message": "patch 8.2.3902: Vim9: double free with nested :def function\n\nProblem:    Vim9: double free with nested :def function.\nSolution:   Pass \"line_to_free\" from compile_def_function() and make sure\n            cmdlinep is valid.",
    "before_after_code_files": [
      "src/proto/userfunc.pro||src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
      "src/userfunc.c||src/userfunc.c",
      "src/version.c||src/version.c",
      "src/vim9compile.c||src/vim9compile.c",
      "src/vim9execute.c||src/vim9execute.c"
    ]
  },
  "patch_diff": {
    "src/proto/userfunc.pro||src/proto/userfunc.pro": [
      "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: char_u *get_scriptlocal_funcname(char_u *funcname);",
      "39: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
      "40: void list_functions(regmatch_T *regmatch);",
      "42: void ex_function(exarg_T *eap);",
      "43: void ex_defcompile(exarg_T *eap);",
      "44: int eval_fname_script(char_u *p);",
      "",
      "[Removed Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg);",
      "",
      "[Added Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);",
      "",
      "---------------"
    ],
    "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
      "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "1669:   assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')",
      "1670: enddef",
      "1672: def Test_return_type_wrong()",
      "1673:   CheckScriptFailure([",
      "1674:         'def Func(): number',",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1672: def Test_nested_functin_with_nextcmd()",
      "1673:   var lines =<< trim END",
      "1674:       vim9script",
      "1675:       # Define an outer function",
      "1676:       def FirstFunction()",
      "1677:         # Define an inner function",
      "1678:         def SecondFunction()",
      "1679:           # the function has a body, a double free is detected.",
      "1680:           AAAAA",
      "1682:          # enddef followed by | or } followed by # one or more characters",
      "1683:          enddef|BBBB",
      "1684:       enddef",
      "1686:       # Compile all functions",
      "1687:       defcompile",
      "1688:   END",
      "1689:   CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')",
      "1690: enddef",
      "",
      "---------------"
    ],
    "src/userfunc.c||src/userfunc.c": [
      "File: src/userfunc.c -> src/userfunc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "720:  }",
      "721:  else",
      "722:  {",
      "724:      if (eap->getline == NULL)",
      "725:   theline = getcmdline(':', 0L, indent, getline_options);",
      "726:      else",
      "727:   theline = eap->getline(':', eap->cookie, indent,",
      "728:              getline_options);",
      "730:  }",
      "731:  if (KeyTyped)",
      "",
      "[Removed Lines]",
      "723:      vim_free(*line_to_free);",
      "",
      "[Added Lines]",
      "728:      if (*eap->cmdlinep == *line_to_free)",
      "730:      vim_free(*line_to_free);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "839:    eap->nextcmd = nextcmd;",
      "841:    {",
      "842:        vim_free(*eap->cmdlinep);",
      "",
      "[Removed Lines]",
      "840:    if (*line_to_free != NULL)",
      "",
      "[Added Lines]",
      "842:    if (*line_to_free != NULL",
      "843:          && *eap->cmdlinep != *line_to_free)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1161:  }",
      "1162:  if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)",
      "1163:      goto erret;",
      "1166:      last = cmdline;",
      "1167:  else",
      "",
      "[Removed Lines]",
      "1164:  if (cmdline != NULL)",
      "",
      "[Added Lines]",
      "1167:  if (eap.nextcmd != NULL)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1175:  ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;",
      "1176:     }",
      "1179:     {",
      "1180:  garray_T *tfgap = &evalarg->eval_tofree_ga;",
      "",
      "[Removed Lines]",
      "1178:     if (cmdline != NULL)",
      "",
      "[Added Lines]",
      "1181:     if (eap.nextcmd != NULL)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1187:  {",
      "1188:      ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;",
      "1189:      evalarg->eval_using_cmdline = TRUE;",
      "1190:  }",
      "1191:     }",
      "1192:     else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1193:      if (cmdline == line_to_free)",
      "1194:   line_to_free = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "3990:     ufunc_T *",
      "3992: {",
      "3994:     int  j;",
      "3995:     int  c;",
      "3996:     int  saved_did_emsg;",
      "",
      "[Removed Lines]",
      "3991: define_function(exarg_T *eap, char_u *name_arg)",
      "3993:     char_u *line_to_free = NULL;",
      "",
      "[Added Lines]",
      "3996: define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "4258:     if (get_function_args(&p, ')', &newargs,",
      "4259:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
      "4260:     NULL, &varargs, &default_args, eap->skip,",
      "4262:  goto errret_2;",
      "4263:     whitep = p;",
      "",
      "[Removed Lines]",
      "4261:     eap, &line_to_free) == FAIL)",
      "",
      "[Added Lines]",
      "4265:     eap, line_to_free) == FAIL)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "4372:      || eap->skip)",
      "4373:  goto erret;",
      "",
      "[Removed Lines]",
      "4371:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL",
      "",
      "[Added Lines]",
      "4375:     if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "4660:     }",
      "4661: ret_free:",
      "4662:     ga_clear_strings(&argtypes);",
      "4664:     vim_free(fudi.fd_newkey);",
      "4665:     if (name != name_arg)",
      "4666:  vim_free(name);",
      "",
      "[Removed Lines]",
      "4663:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "4676:     void",
      "4677: ex_function(exarg_T *eap)",
      "4678: {",
      "4680: }",
      "",
      "[Removed Lines]",
      "4679:     (void)define_function(eap, NULL);",
      "",
      "[Added Lines]",
      "4682:     char_u *line_to_free = NULL;",
      "4684:     (void)define_function(eap, NULL, &line_to_free);",
      "4685:     vim_free(line_to_free);",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "750: static int included_patches[] =",
      "753:     3901,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "753:     3902,",
      "",
      "---------------"
    ],
    "src/vim9compile.c||src/vim9compile.c": [
      "File: src/vim9compile.c -> src/vim9compile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "814:     static char_u *",
      "816: {",
      "817:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
      "818:     char_u *name_start = eap->arg;",
      "819:     char_u *name_end = to_name_end(eap->arg, TRUE);",
      "820:     char_u *lambda_name;",
      "821:     ufunc_T *ufunc;",
      "822:     int  r = FAIL;",
      "",
      "[Removed Lines]",
      "815: compile_nested_function(exarg_T *eap, cctx_T *cctx)",
      "",
      "[Added Lines]",
      "815: compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)",
      "820:     int  off;",
      "821:     char_u *func_name;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "866:     lambda_name = vim_strsave(get_lambda_name());",
      "867:     if (lambda_name == NULL)",
      "868:  return NULL;",
      "871:     if (ufunc == NULL)",
      "872:     {",
      "",
      "[Removed Lines]",
      "869:     ufunc = define_function(eap, lambda_name);",
      "",
      "[Added Lines]",
      "873:     off = is_global ? 2 : 0;",
      "874:     func_name = vim_strnsave(name_start + off, name_end - name_start - off);",
      "875:     if (func_name == NULL)",
      "876:     {",
      "877:  r = FAIL;",
      "878:  goto theend;",
      "879:     }",
      "881:     ufunc = define_function(eap, lambda_name, line_to_free);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "912:     if (is_global)",
      "913:     {",
      "924:     }",
      "925:     else",
      "926:     {",
      "929:           TRUE, ufunc->uf_func_type);",
      "931:  if (lvar == NULL)",
      "",
      "[Removed Lines]",
      "914:  char_u *func_name = vim_strnsave(name_start + 2,",
      "915:           name_end - name_start - 2);",
      "917:  if (func_name == NULL)",
      "918:      r = FAIL;",
      "919:  else",
      "920:  {",
      "921:      r = generate_NEWFUNC(cctx, lambda_name, func_name);",
      "922:      lambda_name = NULL;",
      "923:  }",
      "928:  lvar_T *lvar = reserve_local(cctx, name_start, name_end - name_start,",
      "",
      "[Added Lines]",
      "926:  r = generate_NEWFUNC(cctx, lambda_name, func_name);",
      "927:  func_name = NULL;",
      "928:  lambda_name = NULL;",
      "933:  lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "938: theend:",
      "939:     vim_free(lambda_name);",
      "940:     return r == FAIL ? NULL : (char_u *)\"\";",
      "941: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "945:     vim_free(func_name);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2861:      case CMD_def:",
      "2862:      case CMD_function:",
      "2863:       ea.arg = p;",
      "2865:       break;",
      "2867:      case CMD_return:",
      "",
      "[Removed Lines]",
      "2864:       line = compile_nested_function(&ea, &cctx);",
      "",
      "[Added Lines]",
      "2870:       line = compile_nested_function(&ea, &cctx, &line_to_free);",
      "",
      "---------------"
    ],
    "src/vim9execute.c||src/vim9execute.c": [
      "File: src/vim9execute.c -> src/vim9execute.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3345:   else",
      "3346:   {",
      "3347:       exarg_T ea;",
      "3349:       CLEAR_FIELD(ea);",
      "3350:       ea.cmd = ea.arg = iptr->isn_arg.string;",
      "3352:   }",
      "3353:   break;",
      "",
      "[Removed Lines]",
      "3351:       define_function(&ea, NULL);",
      "",
      "[Added Lines]",
      "3348:       char_u  *line_to_free = NULL;",
      "3352:       define_function(&ea, NULL, &line_to_free);",
      "3353:       vim_free(line_to_free);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ab360526ef653b139f4b007a0efbdb3410c8fb4b",
      "candidate_info": {
        "commit_hash": "ab360526ef653b139f4b007a0efbdb3410c8fb4b",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/ab360526ef653b139f4b007a0efbdb3410c8fb4b",
        "files": [
          "src/structs.h",
          "src/testdir/test_vim9_disassemble.vim",
          "src/testdir/test_vim9_func.vim",
          "src/version.c",
          "src/vim9.h",
          "src/vim9compile.c",
          "src/vim9execute.c"
        ],
        "message": "patch 8.2.2321: Vim9: cannot nest closures\n\nProblem:    Vim9: cannot nest closures.\nSolution:   Add the nesting level to ISN_LOADOUTER and ISN_STOREOUTER.\n            (closes #7150, closes #7635)",
        "before_after_code_files": [
          "src/structs.h||src/structs.h",
          "src/testdir/test_vim9_disassemble.vim||src/testdir/test_vim9_disassemble.vim",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/version.c||src/version.c",
          "src/vim9.h||src/vim9.h",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9execute.c||src/vim9execute.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ]
        }
      },
      "candidate_diff": {
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1979:     garray_T *pt_ectx_stack;     // where to find local vars",
          "1980:     int  pt_ectx_frame;     // index of function frame in uf_ectx_stack",
          "1981:     funcstack_T *pt_funcstack;     // copy of stack, used after context",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1981:     garray_T *pt_outer_stack;    // pt_ectx_stack one level up",
          "1982:     int  pt_outer_frame;     // pt_ectx_frame one level up.",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_disassemble.vim||src/testdir/test_vim9_disassemble.vim": [
          "File: src/testdir/test_vim9_disassemble.vim -> src/testdir/test_vim9_disassemble.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "567:   var res = execute('disass g:Append')",
          "568:   assert_match('<lambda>\\d\\_s*' ..",
          "569:         'local ..= arg\\_s*' ..",
          "571:         '\\d LOAD arg\\[-1\\]\\_s*' ..",
          "572:         '\\d CONCAT\\_s*' ..",
          "574:         '\\d RETURN 0',",
          "575:         res)",
          "577:   res = execute('disass g:Get')",
          "578:   assert_match('<lambda>\\d\\_s*' ..",
          "579:         'return local\\_s*' ..",
          "581:         '\\d RETURN',",
          "582:         res)",
          "",
          "[Removed Lines]",
          "570:         '\\d LOADOUTER $0\\_s*' ..",
          "573:         '\\d STOREOUTER $0\\_s*' ..",
          "580:         '\\d LOADOUTER $0\\_s*' ..",
          "",
          "[Added Lines]",
          "570:         '\\d LOADOUTER level 1 $0\\_s*' ..",
          "573:         '\\d STOREOUTER level 1 $0\\_s*' ..",
          "580:         '\\d LOADOUTER level 1 $0\\_s*' ..",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1812:   assert_match('def <lambda>\\d\\+(_: any, ...): number\\n1  return 0\\n   enddef', body)",
          "1813: enddef",
          "1815: func Test_silent_echo()",
          "1816:   CheckScreendump",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1815: def DoFilterThis(a: string): list<string>",
          "1816:   # closure nested inside another closure using argument",
          "1817:   var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)",
          "1818:   return ['x', 'y', 'a', 'x2', 'c']->Filter()",
          "1819: enddef",
          "1821: def Test_nested_closure_using_argument()",
          "1822:   assert_equal(['x', 'x2'], DoFilterThis('x'))",
          "1823: enddef",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2320,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2321,",
          "",
          "---------------"
        ],
        "src/vim9.h||src/vim9.h": [
          "File: src/vim9.h -> src/vim9.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:     ISN_LOADWDICT,  // push w: dict",
          "34:     ISN_LOADTDICT,  // push t: dict",
          "35:     ISN_LOADS,     // push s: variable isn_arg.loadstore",
          "37:     ISN_LOADSCRIPT, // push script-local variable isn_arg.script.",
          "38:     ISN_LOADOPT,    // push option isn_arg.string",
          "39:     ISN_LOADENV,    // push environment variable isn_arg.string",
          "",
          "[Removed Lines]",
          "36:     ISN_LOADOUTER,  // push variable from outer scope isn_arg.number",
          "",
          "[Added Lines]",
          "36:     ISN_LOADOUTER,  // push variable from outer scope isn_arg.outer",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:     ISN_STOREW,     // pop into window-local variable isn_arg.string",
          "48:     ISN_STORET,     // pop into tab-local variable isn_arg.string",
          "49:     ISN_STORES,     // pop into script variable isn_arg.loadstore",
          "51:     ISN_STORESCRIPT, // pop into script variable isn_arg.script",
          "52:     ISN_STOREOPT,    // pop into option isn_arg.string",
          "53:     ISN_STOREENV,    // pop into environment variable isn_arg.string",
          "",
          "[Removed Lines]",
          "50:     ISN_STOREOUTER,  // pop variable into outer scope isn_arg.number",
          "",
          "[Added Lines]",
          "50:     ISN_STOREOUTER,  // pop variable into outer scope isn_arg.outer",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "303:     int  unp_semicolon; // last item gets list of remainder",
          "304: } unpack_T;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "307: typedef struct {",
          "308:     int  outer_idx; // index",
          "309:     int  outer_depth; // nesting level, stack frames to go up",
          "310: } outer_T;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "342:  put_T      put;",
          "343:  cmod_T      cmdmod;",
          "344:  unpack_T     unpack;",
          "345:     } isn_arg;",
          "346: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  outer_T      outer;",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:     char_u *lv_name;",
          "109:     type_T *lv_type;",
          "110:     int  lv_idx;  // index of the variable on the stack",
          "112:     int  lv_const; // when TRUE cannot be assigned to",
          "113:     int  lv_arg;  // when TRUE this is an argument",
          "114: } lvar_T;",
          "",
          "[Removed Lines]",
          "111:     int  lv_from_outer; // when TRUE using ctx_outer scope",
          "",
          "[Added Lines]",
          "111:     int  lv_from_outer; // nesting level, using ctx_outer scope",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:      if (lvar != NULL)",
          "173:      {",
          "176:      }",
          "177:      return OK;",
          "178:  }",
          "",
          "[Removed Lines]",
          "175:   lvar->lv_from_outer = FALSE;",
          "",
          "[Added Lines]",
          "175:   lvar->lv_from_outer = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "186:      if (lvar != NULL)",
          "187:      {",
          "188:   cctx->ctx_outer_used = TRUE;",
          "190:      }",
          "191:      return OK;",
          "192:  }",
          "",
          "[Removed Lines]",
          "189:   lvar->lv_from_outer = TRUE;",
          "",
          "[Added Lines]",
          "189:   ++lvar->lv_from_outer;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "258:  if (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)",
          "259:           == OK)",
          "260:  {",
          "262:      return OK;",
          "263:  }",
          "264:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "261:      ++*gen_load_outer;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1175:     return OK;",
          "1176: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1181:     static int",
          "1182: generate_STOREOUTER(cctx_T *cctx, int idx, int level)",
          "1183: {",
          "1184:     isn_T *isn;",
          "1186:     RETURN_OK_IF_SKIP(cctx);",
          "1187:     if ((isn = generate_instr_drop(cctx, ISN_STOREOUTER, 1)) == NULL)",
          "1188:  return FAIL;",
          "1189:     isn->isn_arg.outer.outer_idx = idx;",
          "1190:     isn->isn_arg.outer.outer_depth = level;",
          "1192:     return OK;",
          "1193: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1233:     return OK;",
          "1234: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1256:     static int",
          "1257: generate_LOADOUTER(",
          "1258:  cctx_T     *cctx,",
          "1259:  int     idx,",
          "1260:  int     nesting,",
          "1261:  type_T     *type)",
          "1262: {",
          "1263:     isn_T *isn;",
          "1265:     RETURN_OK_IF_SKIP(cctx);",
          "1266:     if ((isn = generate_instr_type(cctx, ISN_LOADOUTER, type)) == NULL)",
          "1267:  return FAIL;",
          "1268:     isn->isn_arg.outer.outer_idx = idx;",
          "1269:     isn->isn_arg.outer.outer_depth = nesting;",
          "1271:     return OK;",
          "1272: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1439:     isn->isn_arg.funcref.fr_func = ufunc->uf_dfunc_idx;",
          "1440:     cctx->ctx_has_closure = 1;",
          "1442:     if (ga_grow(stack, 1) == FAIL)",
          "1443:  return FAIL;",
          "1444:     ((type_T **)stack->ga_data)[stack->ga_len] =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1482:     if (ufunc->uf_flags & FC_CLOSURE)",
          "1483:  cctx->ctx_ufunc->uf_flags |= FC_CLOSURE;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2589:  size_t     len = end - *arg;",
          "2590:  int     idx;",
          "2591:  int     gen_load = FALSE;",
          "2594:  name = vim_strnsave(*arg, end - *arg);",
          "2595:  if (name == NULL)",
          "",
          "[Removed Lines]",
          "2592:  int     gen_load_outer = FALSE;",
          "",
          "[Added Lines]",
          "2635:  int     gen_load_outer = 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2598:  if (arg_exists(*arg, len, &idx, &type, &gen_load_outer, cctx) == OK)",
          "2599:  {",
          "2601:   gen_load = TRUE;",
          "2602:  }",
          "2603:  else",
          "",
          "[Removed Lines]",
          "2600:      if (!gen_load_outer)",
          "",
          "[Added Lines]",
          "2643:      if (gen_load_outer == 0)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2608:      {",
          "2609:   type = lvar.lv_type;",
          "2610:   idx = lvar.lv_idx;",
          "2613:   else",
          "2614:       gen_load = TRUE;",
          "2615:      }",
          "",
          "[Removed Lines]",
          "2611:   if (lvar.lv_from_outer)",
          "2612:       gen_load_outer = TRUE;",
          "",
          "[Added Lines]",
          "2654:   if (lvar.lv_from_outer != 0)",
          "2655:       gen_load_outer = lvar.lv_from_outer;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2631:  }",
          "2632:  if (gen_load)",
          "2633:      res = generate_LOAD(cctx, ISN_LOAD, idx, NULL, type);",
          "2635:  {",
          "2637:      cctx->ctx_outer_used = TRUE;",
          "2638:  }",
          "2639:     }",
          "",
          "[Removed Lines]",
          "2634:  if (gen_load_outer)",
          "2636:      res = generate_LOAD(cctx, ISN_LOADOUTER, idx, NULL, type);",
          "",
          "[Added Lines]",
          "2677:  if (gen_load_outer > 0)",
          "2679:      res = generate_LOADOUTER(cctx, idx, gen_load_outer, type);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "5120:      generate_LOADV(cctx, name + 2, TRUE);",
          "5121:      break;",
          "5122:  case dest_local:",
          "5126:      else",
          "5127:   generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);",
          "5128:      break;",
          "",
          "[Removed Lines]",
          "5123:      if (lvar->lv_from_outer)",
          "5124:   generate_LOAD(cctx, ISN_LOADOUTER, lvar->lv_idx,",
          "5125:           NULL, type);",
          "",
          "[Added Lines]",
          "5166:      if (lvar->lv_from_outer > 0)",
          "5167:   generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,",
          "5168:           type);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "6182:     && instr->ga_len == instr_count + 1",
          "6183:     && isn->isn_type == ISN_PUSHNR)",
          "6184:   {",
          "",
          "[Removed Lines]",
          "6181:   if (!lhs.lhs_lvar->lv_from_outer",
          "",
          "[Added Lines]",
          "6224:   if (lhs.lhs_lvar->lv_from_outer == 0",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "6190:       if (stack->ga_len > 0)",
          "6191:    --stack->ga_len;",
          "6192:   }",
          "6196:   else",
          "6197:       generate_STORE(cctx, ISN_STORE, lhs.lhs_lvar->lv_idx, NULL);",
          "6198:      }",
          "",
          "[Removed Lines]",
          "6193:   else if (lhs.lhs_lvar->lv_from_outer)",
          "6194:       generate_STORE(cctx, ISN_STOREOUTER,",
          "6195:          lhs.lhs_lvar->lv_idx, NULL);",
          "",
          "[Added Lines]",
          "6236:   else if (lhs.lhs_lvar->lv_from_outer > 0)",
          "6237:       generate_STOREOUTER(cctx, lhs.lhs_lvar->lv_idx,",
          "6238:         lhs.lhs_lvar->lv_from_outer);",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:     garray_T *ec_outer_stack;    // stack used for closures",
          "62:     int  ec_outer_frame;     // stack frame in ec_outer_stack",
          "64:     garray_T ec_trystack; // stack of trycmd_T values",
          "65:     int  ec_in_catch; // when TRUE in catch or finally block",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:     garray_T *ec_outer_up_stack;   // ec_outer_stack one level up",
          "64:     int  ec_outer_up_frame;    // ec_outer_frame one level up",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "266:     {",
          "267:  ectx->ec_outer_stack = ufunc->uf_partial->pt_ectx_stack;",
          "268:  ectx->ec_outer_frame = ufunc->uf_partial->pt_ectx_frame;",
          "269:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "274:  ectx->ec_outer_up_stack = ufunc->uf_partial->pt_outer_stack;",
          "275:  ectx->ec_outer_up_frame = ufunc->uf_partial->pt_outer_frame;",
          "276:     }",
          "277:     else if (ufunc->uf_flags & FC_CLOSURE)",
          "278:     {",
          "279:  ectx->ec_outer_stack = &ectx->ec_stack;",
          "280:  ectx->ec_outer_frame = ectx->ec_frame_idx;",
          "281:  ectx->ec_outer_up_stack = ectx->ec_outer_stack;",
          "282:  ectx->ec_outer_up_frame = ectx->ec_outer_frame;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "417:   pt->pt_funcstack = funcstack;",
          "418:   pt->pt_ectx_stack = &funcstack->fs_ga;",
          "419:   pt->pt_ectx_frame = ectx->ec_frame_idx - top;",
          "420:      }",
          "421:  }",
          "422:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "434:   pt->pt_outer_stack = ectx->ec_outer_stack;",
          "435:   pt->pt_outer_frame = ectx->ec_outer_frame;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "744:  if (pt->pt_func != NULL)",
          "745:  {",
          "746:      int ret = call_ufunc(pt->pt_func, argcount, ectx, NULL);",
          "752:      return ret;",
          "753:  }",
          "",
          "[Removed Lines]",
          "749:      ectx->ec_outer_stack = pt->pt_ectx_stack;",
          "750:      ectx->ec_outer_frame = pt->pt_ectx_frame;",
          "",
          "[Added Lines]",
          "765:      int frame_idx = ectx->ec_frame_idx;",
          "768:      if (ectx->ec_frame_idx != frame_idx)",
          "769:      {",
          "772:   ectx->ec_outer_stack = pt->pt_ectx_stack;",
          "773:   ectx->ec_outer_frame = pt->pt_ectx_frame;",
          "774:   ectx->ec_outer_up_stack = pt->pt_outer_stack;",
          "775:   ectx->ec_outer_up_frame = pt->pt_outer_frame;",
          "776:      }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1042:  pt->pt_ectx_stack = &ectx->ec_stack;",
          "1043:  pt->pt_ectx_frame = ectx->ec_frame_idx;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1070:  pt->pt_outer_stack = ectx->ec_outer_stack;",
          "1071:  pt->pt_outer_frame = ectx->ec_outer_frame;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1221:      ectx.ec_outer_stack = &current_ectx->ec_stack;",
          "1222:      ectx.ec_outer_frame = current_ectx->ec_frame_idx;",
          "1223:  }",
          "1224:  else",
          "1225:  {",
          "1226:      ectx.ec_outer_stack = partial->pt_ectx_stack;",
          "1227:      ectx.ec_outer_frame = partial->pt_ectx_frame;",
          "1228:  }",
          "1229:     }",
          "1230:     else if (ufunc->uf_partial != NULL)",
          "1231:     {",
          "1232:  ectx.ec_outer_stack = ufunc->uf_partial->pt_ectx_stack;",
          "1233:  ectx.ec_outer_frame = ufunc->uf_partial->pt_ectx_frame;",
          "1234:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1251:      ectx.ec_outer_up_stack = current_ectx->ec_outer_stack;",
          "1252:      ectx.ec_outer_up_frame = current_ectx->ec_outer_frame;",
          "1258:      ectx.ec_outer_up_stack = partial->pt_outer_stack;",
          "1259:      ectx.ec_outer_up_frame = partial->pt_outer_frame;",
          "1266:  ectx.ec_outer_up_stack = ufunc->uf_partial->pt_outer_stack;",
          "1267:  ectx.ec_outer_up_frame = ufunc->uf_partial->pt_outer_frame;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1516:      case ISN_LOADOUTER:",
          "1520:              STACK_TV_BOT(0));",
          "1522:   break;",
          "",
          "[Removed Lines]",
          "1517:   if (GA_GROW(&ectx.ec_stack, 1) == FAIL)",
          "1518:       goto failed;",
          "1519:   copy_tv(STACK_OUT_TV_VAR(iptr->isn_arg.number),",
          "1521:   ++ectx.ec_stack.ga_len;",
          "",
          "[Added Lines]",
          "1551:   {",
          "1552:       typval_T *stack;",
          "1553:       int  depth = iptr->isn_arg.outer.outer_depth;",
          "1555:       if (GA_GROW(&ectx.ec_stack, 1) == FAIL)",
          "1556:    goto failed;",
          "1557:       if (depth <= 1)",
          "1558:    stack = ((typval_T *)ectx.ec_outer_stack->ga_data)",
          "1559:         + ectx.ec_outer_frame;",
          "1560:       else if (depth == 2)",
          "1561:    stack = ((typval_T *)ectx.ec_outer_up_stack->ga_data)",
          "1562:             + ectx.ec_outer_up_frame;",
          "1563:       else",
          "1564:       {",
          "1565:    SOURCING_LNUM = iptr->isn_lnum;",
          "1566:    iemsg(\"LOADOUTER level > 2 not supported yet\");",
          "1567:    goto failed;",
          "1568:       }",
          "1570:       copy_tv(stack + STACK_FRAME_SIZE",
          "1571:             + iptr->isn_arg.outer.outer_idx,",
          "1573:       ++ectx.ec_stack.ga_len;",
          "1574:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1720:      case ISN_STOREOUTER:",
          "1721:   --ectx.ec_stack.ga_len;",
          "1723:   clear_tv(tv);",
          "1725:   break;",
          "",
          "[Removed Lines]",
          "1722:   tv = STACK_OUT_TV_VAR(iptr->isn_arg.number);",
          "",
          "[Added Lines]",
          "1776:   tv = STACK_OUT_TV_VAR(iptr->isn_arg.outer.outer_idx);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3622:          (varnumber_T)(iptr->isn_arg.number));",
          "3623:   break;",
          "3624:      case ISN_LOAD:",
          "3626:   {",
          "3629:       if (iptr->isn_arg.number < 0)",
          "3631:     (varnumber_T)(iptr->isn_arg.number",
          "3632:          + STACK_FRAME_SIZE));",
          "3633:       else",
          "3636:   }",
          "3637:   break;",
          "3638:      case ISN_LOADV:",
          "",
          "[Removed Lines]",
          "3625:      case ISN_LOADOUTER:",
          "3627:       char *add = iptr->isn_type == ISN_LOAD ? \"\" : \"OUTER\";",
          "3630:    smsg(\"%4d LOAD%s arg[%lld]\", current, add,",
          "3634:    smsg(\"%4d LOAD%s $%lld\", current, add,",
          "3635:          (varnumber_T)(iptr->isn_arg.number));",
          "",
          "[Added Lines]",
          "3681:    smsg(\"%4d LOAD arg[%lld]\", current,",
          "3685:    smsg(\"%4d LOAD $%lld\", current,",
          "3686:        (varnumber_T)(iptr->isn_arg.number));",
          "3687:   }",
          "3688:   break;",
          "3689:      case ISN_LOADOUTER:",
          "3690:   {",
          "3691:       if (iptr->isn_arg.number < 0)",
          "3692:    smsg(\"%4d LOADOUTER level %d arg[%d]\", current,",
          "3693:     iptr->isn_arg.outer.outer_depth,",
          "3694:     iptr->isn_arg.outer.outer_idx",
          "3695:          + STACK_FRAME_SIZE);",
          "3696:       else",
          "3697:    smsg(\"%4d LOADOUTER level %d $%d\", current,",
          "3698:            iptr->isn_arg.outer.outer_depth,",
          "3699:            iptr->isn_arg.outer.outer_idx);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3699:   break;",
          "3701:      case ISN_STORE:",
          "3702:      case ISN_STOREOUTER:",
          "3703:   {",
          "3706:   if (iptr->isn_arg.number < 0)",
          "3709:   else",
          "3712:   }",
          "3713:   break;",
          "3714:      case ISN_STOREV:",
          "",
          "[Removed Lines]",
          "3704:       char *add = iptr->isn_type == ISN_STORE ? \"\" : \"OUTER\";",
          "3707:       smsg(\"%4d STORE%s arg[%lld]\", current, add,",
          "3708:     (varnumber_T)(iptr->isn_arg.number + STACK_FRAME_SIZE));",
          "3710:       smsg(\"%4d STORE%s $%lld\", current, add,",
          "3711:          (varnumber_T)(iptr->isn_arg.number));",
          "",
          "[Added Lines]",
          "3766:   if (iptr->isn_arg.number < 0)",
          "3767:       smsg(\"%4d STORE arg[%lld]\", current,",
          "3768:           iptr->isn_arg.number + STACK_FRAME_SIZE);",
          "3769:   else",
          "3770:       smsg(\"%4d STORE $%lld\", current, iptr->isn_arg.number);",
          "3771:   break;",
          "3775:       smsg(\"%4d STOREOUTEr level %d arg[%d]\", current,",
          "3776:        iptr->isn_arg.outer.outer_depth,",
          "3777:        iptr->isn_arg.outer.outer_idx + STACK_FRAME_SIZE);",
          "3779:       smsg(\"%4d STOREOUTER level %d $%d\", current,",
          "3780:        iptr->isn_arg.outer.outer_depth,",
          "3781:        iptr->isn_arg.outer.outer_idx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "57bc2333b1d713bc54f8e33ef3ef7ac169af2ac4",
      "candidate_info": {
        "commit_hash": "57bc2333b1d713bc54f8e33ef3ef7ac169af2ac4",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/57bc2333b1d713bc54f8e33ef3ef7ac169af2ac4",
        "files": [
          "src/userfunc.c",
          "src/version.c"
        ],
        "message": "patch 8.2.3812: Vim9: leaking memory in numbered function test\n\nProblem:    Vim9: leaking memory in numbered function test.\nSolution:   Skip \"g:\" when checking for numbered function.  Clean up after\n            errors properly.",
        "before_after_code_files": [
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2135:     }",
          "2136: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2141:     static int",
          "2142: numbered_function(char_u *name)",
          "2143: {",
          "2144:     return isdigit(*name)",
          "2145:      || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));",
          "2146: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2146:     int",
          "2147: func_name_refcount(char_u *name)",
          "2148: {",
          "2150: }",
          "",
          "[Removed Lines]",
          "2149:     return isdigit(*name) || *name == '<';",
          "",
          "[Added Lines]",
          "2159:     return numbered_function(name) || *name == '<';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3956:     int  flags = 0;",
          "3957:     char_u *ret_type = NULL;",
          "3958:     ufunc_T *fp = NULL;",
          "3959:     int  overwrite = FALSE;",
          "3960:     dictitem_T *v;",
          "3961:     funcdict_T fudi;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3969:     int  fp_allocated = FALSE;",
          "3970:     int  free_fp = FALSE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4460:  fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);",
          "4461:  if (fp == NULL)",
          "4462:      goto erret;",
          "4464:  if (fudi.fd_dict != NULL)",
          "4465:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4475:  fp_allocated = TRUE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4491:      flags |= FC_DICT;",
          "4492:  }",
          "4508:     }",
          "4509:     fp->uf_args = newargs;",
          "4510:     fp->uf_def_args = default_args;",
          "",
          "[Removed Lines]",
          "4495:  set_ufunc_name(fp, name);",
          "4496:  if (overwrite)",
          "4497:  {",
          "4498:      hi = hash_find(&func_hashtab, name);",
          "4499:      hi->hi_key = UF2HIKEY(fp);",
          "4500:  }",
          "4501:  else if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)",
          "4502:  {",
          "4503:      vim_free(fp);",
          "4504:      fp = NULL;",
          "4505:      goto erret;",
          "4506:  }",
          "4507:  fp->uf_refcount = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4527:  if (parse_argument_types(fp, &argtypes, varargs) == FAIL)",
          "4528:  {",
          "4529:      SOURCING_LNUM = lnum_save;",
          "4531:  }",
          "4532:  varargs = FALSE;",
          "",
          "[Removed Lines]",
          "4530:      goto errret_2;",
          "",
          "[Added Lines]",
          "4528:      free_fp = fp_allocated;",
          "4529:      goto erret;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4535:  if (parse_return_type(fp, ret_type) == FAIL)",
          "4536:  {",
          "4537:      SOURCING_LNUM = lnum_save;",
          "4538:      goto erret;",
          "4539:  }",
          "4540:  SOURCING_LNUM = lnum_save;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4537:      free_fp = fp_allocated;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4542:     else",
          "4543:  fp->uf_def_status = UF_NOT_COMPILED;",
          "4545:     fp->uf_lines = newlines;",
          "4546:     if ((flags & FC_CLOSURE) != 0)",
          "4547:     {",
          "4548:  if (register_closure(fp) == FAIL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4545:     if (fp_allocated)",
          "4546:     {",
          "4548:  set_ufunc_name(fp, name);",
          "4549:  if (overwrite)",
          "4550:  {",
          "4551:      hi = hash_find(&func_hashtab, name);",
          "4552:      hi->hi_key = UF2HIKEY(fp);",
          "4553:  }",
          "4554:  else if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)",
          "4555:  {",
          "4556:      free_fp = TRUE;",
          "4557:      goto erret;",
          "4558:  }",
          "4559:  fp->uf_refcount = 1;",
          "4560:     }",
          "4563:     newlines.ga_data = NULL;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4593:     ga_clear_strings(&newlines);",
          "4594:     if (fp != NULL)",
          "4595:  VIM_CLEAR(fp->uf_arg_types);",
          "4596: ret_free:",
          "4597:     ga_clear_strings(&argtypes);",
          "4598:     vim_free(line_to_free);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4614:     if (free_fp)",
          "4615:     {",
          "4616:  vim_free(fp);",
          "4617:  fp = NULL;",
          "4618:     }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4813:     if (eap->nextcmd != NULL)",
          "4817:     {",
          "4818:  if (!eap->skip)",
          "4819:      semsg(_(e_invarg2), eap->arg);",
          "",
          "[Removed Lines]",
          "4816:     if (isdigit(*name) && fudi.fd_dict == NULL)",
          "",
          "[Added Lines]",
          "4839:     if (numbered_function(name) && fudi.fd_dict == NULL)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4881:     if (name == NULL || !func_name_refcount(name))",
          "4882:  return;",
          "4883:     fp = find_func(name, FALSE, NULL);",
          "4885:     {",
          "4886: #ifdef EXITFREE",
          "4887:  if (!entered_free_all_mem)",
          "",
          "[Removed Lines]",
          "4884:     if (fp == NULL && isdigit(*name))",
          "",
          "[Added Lines]",
          "4907:     if (fp == NULL && numbered_function(name))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4924:     fp = find_func(name, FALSE, NULL);",
          "4925:     if (fp != NULL)",
          "4926:  ++fp->uf_refcount;",
          "4930:  internal_error(\"func_ref()\");",
          "",
          "[Removed Lines]",
          "4927:     else if (isdigit(*name))",
          "",
          "[Added Lines]",
          "4950:     else if (numbered_function(name))",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3811,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3812,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a915fa010330ee7212e06d3511acd363d04d2d28",
      "candidate_info": {
        "commit_hash": "a915fa010330ee7212e06d3511acd363d04d2d28",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/a915fa010330ee7212e06d3511acd363d04d2d28",
        "files": [
          "src/proto/vim9instr.pro",
          "src/testdir/test_vim9_func.vim",
          "src/version.c",
          "src/vim9compile.c",
          "src/vim9expr.c",
          "src/vim9instr.c"
        ],
        "message": "patch 8.2.4612: Vim9: cannot use a recursive call in a nested function\n\nProblem:    Vim9: cannot use a recursive call in a nested function. (Sergey\n            Vlasov)\nSolution:   Define the funcref before compiling the function. (closes #9989)",
        "before_after_code_files": [
          "src/proto/vim9instr.pro||src/proto/vim9instr.pro",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9expr.c||src/vim9expr.c",
          "src/vim9instr.c||src/vim9instr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/proto/vim9instr.pro||src/proto/vim9instr.pro": [
          "File: src/proto/vim9instr.pro -> src/proto/vim9instr.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: int generate_VIM9SCRIPT(cctx_T *cctx, isntype_T isn_type, int sid, int idx, type_T *type);",
          "39: int generate_NEWLIST(cctx_T *cctx, int count);",
          "40: int generate_NEWDICT(cctx_T *cctx, int count);",
          "42: int generate_NEWFUNC(cctx_T *cctx, char_u *lambda_name, char_u *func_name);",
          "43: int generate_DEF(cctx_T *cctx, char_u *name, size_t len);",
          "44: int generate_JUMP(cctx_T *cctx, jumpwhen_T when, int where);",
          "",
          "[Removed Lines]",
          "41: int generate_FUNCREF(cctx_T *cctx, ufunc_T *ufunc);",
          "",
          "[Added Lines]",
          "41: int generate_FUNCREF(cctx_T *cctx, ufunc_T *ufunc, isn_T **isnp);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "876:   END",
          "877:   v9.CheckScriptSuccess(lines)",
          "879:   lines =<< trim END",
          "880:       vim9script",
          "881:       def Outer()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "879:   # nested function with recursive call",
          "880:   lines =<< trim END",
          "881:       vim9script",
          "883:       def MyFunc(): number",
          "884:         def Fib(n: number): number",
          "885:           if n < 2",
          "886:             return 1",
          "887:           endif",
          "888:           return Fib(n - 2) + Fib(n - 1)",
          "889:         enddef",
          "891:         return Fib(5)",
          "892:       enddef",
          "894:       assert_equal(8, MyFunc())",
          "895:   END",
          "896:   v9.CheckScriptSuccess(lines)",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     4611,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     4612,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "818:     ufunc_T *ufunc;",
          "819:     int  r = FAIL;",
          "820:     compiletype_T   compile_type;",
          "822:     if (eap->forceit)",
          "823:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "821:     isn_T *funcref_isn = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "913:  }",
          "914:     }",
          "916:     compile_type = get_compile_type(ufunc);",
          "917: #ifdef FEAT_PROFILE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "919:     if (is_global)",
          "920:     {",
          "921:  r = generate_NEWFUNC(cctx, lambda_name, func_name);",
          "922:  func_name = NULL;",
          "923:  lambda_name = NULL;",
          "924:     }",
          "925:     else",
          "926:     {",
          "928:  lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,",
          "929:           TRUE, ufunc->uf_func_type);",
          "931:  if (lvar == NULL)",
          "932:      goto theend;",
          "933:  if (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)",
          "934:      goto theend;",
          "935:  r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);",
          "936:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "934:  compile_def_function(ufunc, FALSE, CT_NONE, cctx);",
          "935: #endif",
          "956: theend:",
          "957:     vim_free(lambda_name);",
          "",
          "[Removed Lines]",
          "937:     if (is_global)",
          "938:     {",
          "939:  r = generate_NEWFUNC(cctx, lambda_name, func_name);",
          "940:  func_name = NULL;",
          "941:  lambda_name = NULL;",
          "942:     }",
          "943:     else",
          "944:     {",
          "946:  lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,",
          "947:           TRUE, ufunc->uf_func_type);",
          "949:  if (lvar == NULL)",
          "950:      goto theend;",
          "951:  if (generate_FUNCREF(cctx, ufunc) == FAIL)",
          "952:      goto theend;",
          "953:  r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);",
          "954:     }",
          "",
          "[Added Lines]",
          "960:     if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)",
          "961:  funcref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;",
          "",
          "---------------"
        ],
        "src/vim9expr.c||src/vim9expr.c": [
          "File: src/vim9expr.c -> src/vim9expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1044:     }",
          "1046:     func_ptr_unref(ufunc);",
          "",
          "[Removed Lines]",
          "1043:  return generate_FUNCREF(cctx, ufunc);",
          "",
          "[Added Lines]",
          "1043:  return generate_FUNCREF(cctx, ufunc, NULL);",
          "",
          "---------------"
        ],
        "src/vim9instr.c||src/vim9instr.c": [
          "File: src/vim9instr.c -> src/vim9instr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1176:     int",
          "1178: {",
          "1179:     isn_T *isn;",
          "1180:     type_T *type;",
          "",
          "[Removed Lines]",
          "1177: generate_FUNCREF(cctx_T *cctx, ufunc_T *ufunc)",
          "",
          "[Added Lines]",
          "1178: generate_FUNCREF(cctx_T *cctx, ufunc_T *ufunc, isn_T **isnp)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1182:     RETURN_OK_IF_SKIP(cctx);",
          "1183:     if ((isn = generate_instr(cctx, ISN_FUNCREF)) == NULL)",
          "1184:  return FAIL;",
          "1185:     if (ufunc->uf_def_status == UF_NOT_COMPILED)",
          "1186:  isn->isn_arg.funcref.fr_func_name = vim_strsave(ufunc->uf_name);",
          "1187:     else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1186:     if (isnp != NULL)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ecb664501d3b04d124fca69029b275c520401d40",
      "candidate_info": {
        "commit_hash": "ecb664501d3b04d124fca69029b275c520401d40",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/ecb664501d3b04d124fca69029b275c520401d40",
        "files": [
          "src/eval.c",
          "src/structs.h",
          "src/userfunc.c",
          "src/version.c"
        ],
        "message": "patch 8.2.2866: Vim9: memory leak when using inline function\n\nProblem:    Vim9: memory leak when using inline function.\nSolution:   Remember what strings to free.",
        "before_after_code_files": [
          "src/eval.c||src/eval.c",
          "src/structs.h||src/structs.h",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416:     int  res;",
          "417:     int  vim9script = in_vim9script();",
          "418:     garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;",
          "419:     int  save_flags = evalarg == NULL ? 0 : evalarg->eval_flags;",
          "420:     int  evaluate = evalarg == NULL",
          "421:           ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "419:     garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "428:  if (ga_grow(gap, 1) == OK)",
          "429:      ++gap->ga_len;",
          "430:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "431:  ga_init2(freegap, sizeof(char_u *), 10);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "471:   ga_clear_strings(gap);",
          "472:      }",
          "473:      else",
          "474:   ga_clear(gap);",
          "475:      gap->ga_itemsize = 0;",
          "476:      if (p == NULL)",
          "477:   return FAIL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "476:      {",
          "480:   ga_clear_strings(freegap);",
          "481:      }",
          "",
          "---------------"
        ],
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1884:     garray_T eval_ga;",
          "1887:     char_u *eval_tofree;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1886:     garray_T eval_freega;",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "976: {",
          "977:     int  evaluate = (evalarg->eval_flags & EVAL_EVALUATE);",
          "978:     garray_T *gap = &evalarg->eval_ga;",
          "979:     ufunc_T *ufunc = NULL;",
          "980:     exarg_T eap;",
          "981:     garray_T newlines;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "979:     garray_T *freegap = &evalarg->eval_freega;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1026:  {",
          "1027:      char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);",
          "1030:   goto erret;",
          "",
          "[Removed Lines]",
          "1029:      if (ga_grow(gap, 1) == FAIL)",
          "",
          "[Added Lines]",
          "1030:      if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1039:      pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);",
          "1040:      if (pnl != NULL)",
          "1041:   mch_memmove(pnl + 1, p, plen + 1);",
          "1044:  }",
          "1046:      goto erret;",
          "1047:  if (cmdline != NULL)",
          "",
          "[Removed Lines]",
          "1042:      ((char_u **)gap->ga_data)[gap->ga_len] = pnl;",
          "1043:      ++gap->ga_len;",
          "1045:  if (ga_grow(gap, 1) == FAIL)",
          "",
          "[Added Lines]",
          "1043:      ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;",
          "1044:      ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;",
          "1046:  if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1054:  pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);",
          "1055:  if (pnl != NULL)",
          "1056:      mch_memmove(pnl + 1, last, plen + 1);",
          "1059:     }",
          "1061:     if (cmdline != NULL)",
          "",
          "[Removed Lines]",
          "1057:  ((char_u **)gap->ga_data)[gap->ga_len] = pnl;",
          "1058:  ++gap->ga_len;",
          "",
          "[Added Lines]",
          "1058:  ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;",
          "1059:  ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2865,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2866,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
      "candidate_info": {
        "commit_hash": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
        "files": [
          "src/alloc.c",
          "src/message.c",
          "src/proto/alloc.pro",
          "src/proto/userfunc.pro",
          "src/testdir/test_vim9_func.vim",
          "src/usercmd.c",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c",
          "src/viminfo.c"
        ],
        "message": "patch 8.2.4040: keeping track of allocated lines is too complicated\n\nProblem:    Keeping track of allocated lines in user functions is too\n            complicated.\nSolution:   Instead of freeing individual lines keep them all until the end.",
        "before_after_code_files": [
          "src/alloc.c||src/alloc.c",
          "src/message.c||src/message.c",
          "src/proto/alloc.pro||src/proto/alloc.pro",
          "src/proto/userfunc.pro||src/proto/userfunc.pro",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/usercmd.c||src/usercmd.c",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/viminfo.c||src/viminfo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/alloc.c||src/alloc.c": [
          "File: src/alloc.c -> src/alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "702: }",
          "704:     void",
          "706: {",
          "707:     ga_init(gap);",
          "708:     gap->ga_itemsize = itemsize;",
          "",
          "[Removed Lines]",
          "705: ga_init2(garray_T *gap, int itemsize, int growsize)",
          "",
          "[Added Lines]",
          "705: ga_init2(garray_T *gap, size_t itemsize, int growsize)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "791:     int",
          "793: {",
          "794:     char_u *cp = vim_strsave(p);",
          "",
          "[Removed Lines]",
          "792: ga_add_string(garray_T *gap, char_u *p)",
          "",
          "[Added Lines]",
          "792: ga_copy_string(garray_T *gap, char_u *p)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "805:     return OK;",
          "806: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "812:     int",
          "813: ga_add_string(garray_T *gap, char_u *p)",
          "814: {",
          "815:     if (ga_grow(gap, 1) == FAIL)",
          "816:  return FAIL;",
          "817:     ((char_u **)(gap->ga_data))[gap->ga_len++] = p;",
          "818:     return OK;",
          "819: }",
          "",
          "---------------"
        ],
        "src/message.c||src/message.c": [
          "File: src/message.c -> src/message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "587:     if (STRCMP(\"RESET\", error) == 0)",
          "588:  ga_clear_strings(&ignore_error_list);",
          "589:     else",
          "591: }",
          "593:     static int",
          "",
          "[Removed Lines]",
          "590:  ga_add_string(&ignore_error_list, error);",
          "",
          "[Added Lines]",
          "590:  ga_copy_string(&ignore_error_list, error);",
          "",
          "---------------"
        ],
        "src/proto/alloc.pro||src/proto/alloc.pro": [
          "File: src/proto/alloc.pro -> src/proto/alloc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: void ga_clear_strings(garray_T *gap);",
          "18: int ga_copy_strings(garray_T *from, garray_T *to);",
          "19: void ga_init(garray_T *gap);",
          "21: int ga_grow(garray_T *gap, int n);",
          "22: int ga_grow_inner(garray_T *gap, int n);",
          "23: char_u *ga_concat_strings(garray_T *gap, char *sep);",
          "24: int ga_add_string(garray_T *gap, char_u *p);",
          "25: void ga_concat(garray_T *gap, char_u *s);",
          "26: void ga_concat_len(garray_T *gap, char_u *s, size_t len);",
          "",
          "[Removed Lines]",
          "20: void ga_init2(garray_T *gap, int itemsize, int growsize);",
          "",
          "[Added Lines]",
          "20: void ga_init2(garray_T *gap, size_t itemsize, int growsize);",
          "24: int ga_copy_string(garray_T *gap, char_u *p);",
          "",
          "---------------"
        ],
        "src/proto/userfunc.pro||src/proto/userfunc.pro": [
          "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: char_u *get_scriptlocal_funcname(char_u *funcname);",
          "39: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
          "40: void list_functions(regmatch_T *regmatch);",
          "42: void ex_function(exarg_T *eap);",
          "43: void ex_defcompile(exarg_T *eap);",
          "44: int eval_fname_script(char_u *p);",
          "",
          "[Removed Lines]",
          "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);",
          "",
          "[Added Lines]",
          "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1757:   CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')",
          "1758: enddef",
          "1760: def Test_return_type_wrong()",
          "1761:   CheckScriptFailure([",
          "1762:         'def Func(): number',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1760: def Test_error_in_function_args()",
          "1761:   var lines =<< trim END",
          "1762:       def FirstFunction()",
          "1763:         def SecondFunction(J  =",
          "1764:         # Nois",
          "1765:         # one",
          "1767:          enddef|BBBB",
          "1768:       enddef",
          "1769:       # Compile all functions",
          "1770:       defcompile",
          "1771:   END",
          "1772:   CheckScriptFailure(lines, 'E488:')",
          "1773: enddef",
          "",
          "---------------"
        ],
        "src/usercmd.c||src/usercmd.c": [
          "File: src/usercmd.c -> src/usercmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1021:  char_u     *line = NULL;",
          "1023:  ga_init2(&ga, sizeof(char_u *), 10);",
          "1025:      return retp;",
          "",
          "[Removed Lines]",
          "1024:  if (ga_add_string(&ga, p) == FAIL)",
          "",
          "[Added Lines]",
          "1024:  if (ga_copy_string(&ga, p) == FAIL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1038:       emsg(_(e_missing_rcurly));",
          "1039:       break;",
          "1040:   }",
          "1042:       break;",
          "1043:   if (*skipwhite(line) == '}')",
          "1044:       break;",
          "",
          "[Removed Lines]",
          "1041:   if (ga_add_string(&ga, line) == FAIL)",
          "",
          "[Added Lines]",
          "1041:   if (ga_copy_string(&ga, line) == FAIL)",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "172:     static char_u *",
          "173: get_function_line(",
          "174:  exarg_T  *eap,",
          "176:  int  indent,",
          "177:  getline_opt_T getline_options)",
          "178: {",
          "",
          "[Removed Lines]",
          "175:  char_u  **line_to_free,",
          "",
          "[Added Lines]",
          "175:  garray_T *lines_to_free,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:  theline = eap->getline(':', eap->cookie, indent, getline_options);",
          "185:     if (theline != NULL)",
          "186:     {",
          "191:     }",
          "193:     return theline;",
          "",
          "[Removed Lines]",
          "187:  if (*eap->cmdlinep == *line_to_free)",
          "189:  vim_free(*line_to_free);",
          "",
          "[Added Lines]",
          "187:  if (lines_to_free->ga_len > 0",
          "188:   && *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)",
          "189:          [lines_to_free->ga_len - 1])",
          "191:  ga_add_string(lines_to_free, theline);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "210:     garray_T *default_args,",
          "211:     int  skip,",
          "212:     exarg_T *eap,",
          "214: {",
          "215:     int  mustend = FALSE;",
          "216:     char_u *arg;",
          "",
          "[Removed Lines]",
          "213:     char_u **line_to_free)",
          "",
          "[Added Lines]",
          "214:     garray_T *lines_to_free)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "241:     && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))",
          "242:  {",
          "245:          GETLINE_CONCAT_CONT);",
          "247:      if (theline == NULL)",
          "",
          "[Removed Lines]",
          "244:      char_u *theline = get_function_line(eap, line_to_free, 0,",
          "",
          "[Added Lines]",
          "245:      char_u *theline = get_function_line(eap, lines_to_free, 0,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "677:  exarg_T     *eap,",
          "678:  garray_T    *newlines,",
          "679:  char_u     *line_arg_in,",
          "681: {",
          "682:     linenr_T sourcing_lnum_top = SOURCING_LNUM;",
          "683:     linenr_T sourcing_lnum_off;",
          "",
          "[Removed Lines]",
          "680:  char_u     **line_to_free)",
          "",
          "[Added Lines]",
          "681:  garray_T    *lines_to_free)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "744:  }",
          "745:  else",
          "746:  {",
          "748:              getline_options);",
          "749:  }",
          "750:  if (KeyTyped)",
          "",
          "[Removed Lines]",
          "747:      theline = get_function_line(eap, line_to_free, indent,",
          "",
          "[Added Lines]",
          "748:      theline = get_function_line(eap, lines_to_free, indent,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "854:       {",
          "858:    eap->nextcmd = nextcmd;",
          "861:    {",
          "862:        vim_free(*eap->cmdlinep);",
          "865:    }",
          "866:       }",
          "867:       break;",
          "",
          "[Removed Lines]",
          "859:    if (*line_to_free != NULL",
          "860:          && *eap->cmdlinep != *line_to_free)",
          "",
          "[Added Lines]",
          "861:    if (lines_to_free->ga_len > 0",
          "862:     && *eap->cmdlinep !=",
          "863:          ((char_u **)lines_to_free->ga_data)",
          "864:          [lines_to_free->ga_len - 1])",
          "870:          [lines_to_free->ga_len - 1];",
          "871:        --lines_to_free->ga_len;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1118:     garray_T newlines;",
          "1119:     char_u *cmdline = NULL;",
          "1120:     int  ret = FAIL;",
          "1122:     partial_T *pt;",
          "1123:     char_u *name;",
          "1124:     int  lnum_save = -1;",
          "",
          "[Removed Lines]",
          "1121:     char_u *line_to_free = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1144:     }",
          "1146:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
          "1151:  goto erret;",
          "1155:     evalarg->eval_break_count += newlines.ga_len;",
          "",
          "[Removed Lines]",
          "1147:     if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)",
          "1148:     {",
          "1149:  if (cmdline != line_to_free)",
          "1150:      vim_free(cmdline);",
          "1152:     }",
          "",
          "[Added Lines]",
          "1153:     if (get_function_body(&eap, &newlines, NULL,",
          "1154:           &evalarg->eval_tofree_ga) == FAIL)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1208:  {",
          "1209:      ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;",
          "1210:      evalarg->eval_using_cmdline = TRUE;",
          "1213:  }",
          "1214:     }",
          "1215:     else",
          "",
          "[Removed Lines]",
          "1211:      if (cmdline == line_to_free)",
          "1212:   line_to_free = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1278: erret:",
          "1279:     if (lnum_save >= 0)",
          "1280:  SOURCING_LNUM = lnum_save;",
          "1282:     ga_clear_strings(&newlines);",
          "1283:     if (newargs != NULL)",
          "1284:  ga_clear_strings(newargs);",
          "",
          "[Removed Lines]",
          "1281:     vim_free(line_to_free);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3962:     ufunc_T *",
          "3964: {",
          "3965:     int  j;",
          "3966:     int  c;",
          "",
          "[Removed Lines]",
          "3963: define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)",
          "",
          "[Added Lines]",
          "3964: define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4229:     if (get_function_args(&p, ')', &newargs,",
          "4230:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
          "4231:     NULL, &varargs, &default_args, eap->skip,",
          "4233:  goto errret_2;",
          "4234:     whitep = p;",
          "",
          "[Removed Lines]",
          "4232:     eap, line_to_free) == FAIL)",
          "",
          "[Added Lines]",
          "4233:     eap, lines_to_free) == FAIL)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4343:      || eap->skip)",
          "4344:  goto erret;",
          "",
          "[Removed Lines]",
          "4342:     if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL",
          "",
          "[Added Lines]",
          "4343:     if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4645:     void",
          "4646: ex_function(exarg_T *eap)",
          "4647: {",
          "4652: }",
          "",
          "[Removed Lines]",
          "4648:     char_u *line_to_free = NULL;",
          "4650:     (void)define_function(eap, NULL, &line_to_free);",
          "4651:     vim_free(line_to_free);",
          "",
          "[Added Lines]",
          "4649:     garray_T lines_to_free;",
          "4651:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "4652:     (void)define_function(eap, NULL, &lines_to_free);",
          "4653:     ga_clear_strings(&lines_to_free);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     4039,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     4040,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "812:     static char_u *",
          "814: {",
          "815:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
          "816:     char_u *name_start = eap->arg;",
          "",
          "[Removed Lines]",
          "813: compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)",
          "",
          "[Added Lines]",
          "813: compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "876:  goto theend;",
          "877:     }",
          "880:     if (ufunc == NULL)",
          "881:     {",
          "882:  r = eap->skip ? OK : FAIL;",
          "",
          "[Removed Lines]",
          "879:     ufunc = define_function(eap, lambda_name, line_to_free);",
          "",
          "[Added Lines]",
          "879:     ufunc = define_function(eap, lambda_name, lines_to_free);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2496:  cctx_T  *outer_cctx)",
          "2497: {",
          "2498:     char_u *line = NULL;",
          "2500:     char_u *p;",
          "2501:     char *errormsg = NULL; // error message",
          "2502:     cctx_T cctx;",
          "",
          "[Removed Lines]",
          "2499:     char_u *line_to_free = NULL;",
          "",
          "[Added Lines]",
          "2499:     garray_T lines_to_free;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2514: #endif",
          "2515:     int  debug_lnum = -1;",
          "2519:     if (ufunc->uf_dfunc_idx > 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2518:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2681:      if (line != NULL)",
          "2682:      {",
          "2683:   line = vim_strsave(line);",
          "2686:      }",
          "2687:  }",
          "",
          "[Removed Lines]",
          "2684:   vim_free(line_to_free);",
          "2685:   line_to_free = line;",
          "",
          "[Added Lines]",
          "2687:   if (ga_add_string(&lines_to_free, line) == FAIL)",
          "2688:       goto erret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2926:      case CMD_def:",
          "2927:      case CMD_function:",
          "2928:       ea.arg = p;",
          "2930:       break;",
          "2932:      case CMD_return:",
          "",
          "[Removed Lines]",
          "2929:       line = compile_nested_function(&ea, &cctx, &line_to_free);",
          "",
          "[Added Lines]",
          "2932:       line = compile_nested_function(&ea, &cctx, &lines_to_free);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3236:     if (do_estack_push)",
          "3237:  estack_pop();",
          "3240:     free_imported(&cctx);",
          "3241:     free_locals(&cctx);",
          "3242:     ga_clear(&cctx.ctx_type_stack);",
          "",
          "[Removed Lines]",
          "3239:     vim_free(line_to_free);",
          "",
          "[Added Lines]",
          "3242:     ga_clear_strings(&lines_to_free);",
          "",
          "---------------"
        ],
        "src/viminfo.c||src/viminfo.c": [
          "File: src/viminfo.c -> src/viminfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2730:     {",
          "2732:  if (writing)",
          "2734:     }",
          "2735:     else",
          "2736:     {",
          "",
          "[Removed Lines]",
          "2733:      ga_add_string(&virp->vir_barlines, virp->vir_line);",
          "",
          "[Added Lines]",
          "2733:      ga_copy_string(&virp->vir_barlines, virp->vir_line);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2769:      default:",
          "2771:   if (writing)",
          "2773:  }",
          "2774:  for (i = 0; i < values.ga_len; ++i)",
          "2775:  {",
          "",
          "[Removed Lines]",
          "2772:       ga_add_string(&virp->vir_barlines, virp->vir_line);",
          "",
          "[Added Lines]",
          "2772:       ga_copy_string(&virp->vir_barlines, virp->vir_line);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
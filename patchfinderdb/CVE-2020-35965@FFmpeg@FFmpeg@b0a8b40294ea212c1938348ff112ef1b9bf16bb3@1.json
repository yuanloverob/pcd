{
  "cve_id": "CVE-2020-35965",
  "cve_desc": "decode_frame in libavcodec/exr.c in FFmpeg 4.3.1 has an out-of-bounds write because of errors in calculations of when to perform memset zero operations.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "b0a8b40294ea212c1938348ff112ef1b9bf16bb3",
  "patch_info": {
    "commit_hash": "b0a8b40294ea212c1938348ff112ef1b9bf16bb3",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b0a8b40294ea212c1938348ff112ef1b9bf16bb3",
    "files": [
      "libavcodec/exr.c"
    ],
    "message": "avcodec/exr: skip bottom clearing loop when its outside the image\n\nFixes: signed integer overflow: 1633771809 * 32960 cannot be represented in type 'int'\nFixes: 26532/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_EXR_fuzzer-5613925708857344\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/exr.c||libavcodec/exr.c"
    ]
  },
  "patch_diff": {
    "libavcodec/exr.c||libavcodec/exr.c": [
      "File: libavcodec/exr.c -> libavcodec/exr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1843:     ymax = FFMAX(0, s->ymax + 1);",
      "1850:         }",
      "1853:     picture->pict_type = AV_PICTURE_TYPE_I;",
      "",
      "[Removed Lines]",
      "1845:     for (i = 0; i < planes; i++) {",
      "1846:         ptr = picture->data[i] + (ymax * picture->linesize[i]);",
      "1847:         for (y = ymax; y < avctx->height; y++) {",
      "1848:             memset(ptr, 0, out_line_size);",
      "1849:             ptr += picture->linesize[i];",
      "1851:     }",
      "",
      "[Added Lines]",
      "1845:     if (ymax < avctx->height)",
      "1846:         for (i = 0; i < planes; i++) {",
      "1847:             ptr = picture->data[i] + (ymax * picture->linesize[i]);",
      "1848:             for (y = ymax; y < avctx->height; y++) {",
      "1849:                 memset(ptr, 0, out_line_size);",
      "1850:                 ptr += picture->linesize[i];",
      "1851:             }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "33faa949ea807b1881129b5b71324bf309f4ee62",
      "candidate_info": {
        "commit_hash": "33faa949ea807b1881129b5b71324bf309f4ee62",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/33faa949ea807b1881129b5b71324bf309f4ee62",
        "files": [
          "libavcodec/exr.c"
        ],
        "message": "avcodec/exr: skip bottom clearing loop when its outside the image\n\nFixes: signed integer overflow: 1633771809 * 32960 cannot be represented in type 'int'\nFixes: 26532/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_EXR_fuzzer-5613925708857344\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/exr.c||libavcodec/exr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ],
          "candidate": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/exr.c||libavcodec/exr.c": [
          "File: libavcodec/exr.c -> libavcodec/exr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1825:     avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);",
          "1833:         }",
          "1836:     picture->pict_type = AV_PICTURE_TYPE_I;",
          "",
          "[Removed Lines]",
          "1828:     for (i = 0; i < planes; i++) {",
          "1829:         ptr = picture->data[i] + ((s->ymax+1) * picture->linesize[i]);",
          "1830:         for (y = s->ymax + 1; y < avctx->height; y++) {",
          "1831:             memset(ptr, 0, out_line_size);",
          "1832:             ptr += picture->linesize[i];",
          "1834:     }",
          "",
          "[Added Lines]",
          "1828:     if ((s->ymax+1) < avctx->height)",
          "1829:         for (i = 0; i < planes; i++) {",
          "1830:             ptr = picture->data[i] + ((s->ymax+1) * picture->linesize[i]);",
          "1831:             for (y = s->ymax + 1; y < avctx->height; y++) {",
          "1832:                 memset(ptr, 0, out_line_size);",
          "1833:                 ptr += picture->linesize[i];",
          "1834:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-32626",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",
  "repo": "redis/redis",
  "patch_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "patch_info": {
    "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
    "files": [
      "src/scripting.c"
    ],
    "message": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\u00a0 \u00a0to explode the LUA stack (notice that currently there is no such\n\u00a0 \u00a0command in Redis that returns such a nested reply, but modules might\n\u00a0 \u00a0do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n\u00a0 \u00a0explode the LUA stack (all the arguments will be pushed to the LUA\n\u00a0 \u00a0stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
    "before_after_code_files": [
      "src/scripting.c||src/scripting.c"
    ]
  },
  "patch_diff": {
    "src/scripting.c||src/scripting.c": [
      "File: src/scripting.c -> src/scripting.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130: char *redisProtocolToLuaType(lua_State *lua, char* reply) {",
      "131:     char *p = reply;",
      "133:     switch(*p) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "132:     if (!lua_checkstack(lua, 5)) {",
      "138:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
      "139:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "220:             if (atype == '%') {",
      "221:                 p = redisProtocolToLuaType(lua,p);",
      "222:             } else {",
      "223:                 lua_pushboolean(lua,1);",
      "224:             }",
      "225:             lua_settable(lua,-3);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "233:                 if (!lua_checkstack(lua, 1)) {",
      "236:                     serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
      "237:                 }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "341: void luaReplyToRedisReply(client *c, lua_State *lua) {",
      "342:     int t = lua_type(lua,-1);",
      "344:     switch(t) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "358:     if (!lua_checkstack(lua, 4)) {",
      "363:         addReplyErrorFormat(c, \"reached lua stack limit\");",
      "364:         lua_pop(lua,1); // pop the element from the stack",
      "365:         return;",
      "366:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2506: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
      "2507:     int j, saved_rc = server.lua_replicate_commands;",
      "2509:     lua_getglobal(lua,\"redis\");",
      "2510:     lua_pushstring(lua,\"call\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2539:     if (!lua_checkstack(lua, argc + 1)) {",
      "2546:         ldbLogRedisReply(\"max lua stack reached\");",
      "2547:         return;",
      "2548:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
      "candidate_info": {
        "commit_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
        "files": [
          "src/networking.c",
          "src/server.c",
          "src/server.h",
          "tests/unit/auth.tcl"
        ],
        "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
        "before_after_code_files": [
          "src/networking.c||src/networking.c",
          "src/server.c||src/server.c",
          "src/server.h||src/server.h",
          "tests/unit/auth.tcl||tests/unit/auth.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/networking.c||src/networking.c": [
          "File: src/networking.c -> src/networking.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:     raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);",
          "98: }",
          "100: client *createClient(connection *conn) {",
          "101:     client *c = zmalloc(sizeof(client));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "100: int authRequired(client *c) {",
          "103:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "104:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "105:                         !c->authenticated;",
          "106:     return auth_required;",
          "107: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1744:             addReplyError(c,\"Protocol error: invalid multibulk length\");",
          "1745:             setProtocolError(\"invalid mbulk count\",c);",
          "1746:             return C_ERR;",
          "1747:         }",
          "1749:         c->qb_pos = (newline-c->querybuf)+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1756:         } else if (ll > 10 && authRequired(c)) {",
          "1757:             addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
          "1758:             setProtocolError(\"unauth mbulk count\", c);",
          "1759:             return C_ERR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1791:                 addReplyError(c,\"Protocol error: invalid bulk length\");",
          "1792:                 setProtocolError(\"invalid bulk length\",c);",
          "1793:                 return C_ERR;",
          "1794:             }",
          "1796:             c->qb_pos = newline-c->querybuf+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1807:             } else if (ll > 16384 && authRequired(c)) {",
          "1808:                 addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
          "1809:                 setProtocolError(\"unauth bulk length\", c);",
          "1810:                 return C_ERR;",
          "",
          "---------------"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3590:     int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||",
          "3591:                                  (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));",
          "3601:         if (!(c->cmd->flags & CMD_NO_AUTH)) {",
          "3602:             rejectCommand(c,shared.noautherr);",
          "",
          "[Removed Lines]",
          "3595:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "3596:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "3597:                         !c->authenticated;",
          "3598:     if (auth_required) {",
          "",
          "[Added Lines]",
          "3593:     if (authRequired(c)) {",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1743: void unprotectClient(client *c);",
          "1744: void initThreadedIO(void);",
          "1745: client *lookupClientByID(uint64_t id);",
          "1747: #ifdef __GNUC__",
          "1748: void addReplyErrorFormat(client *c, const char *fmt, ...)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1746: int authRequired(client *c);",
          "",
          "---------------"
        ],
        "tests/unit/auth.tcl||tests/unit/auth.tcl": [
          "File: tests/unit/auth.tcl -> tests/unit/auth.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:         r set foo 100",
          "25:         r incr foo",
          "26:     } {101}",
          "27: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:     test {For unauthenticated clients multibulk and bulk length are limited} {",
          "29:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "30:         $rr write \"*100\\r\\n\"",
          "31:         $rr flush",
          "32:         catch {[$rr read]} e",
          "33:         assert_match {*unauthenticated multibulk length*} $e",
          "34:         $rr close",
          "36:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "37:         $rr write \"*1\\r\\n\\$100000000\\r\\n\"",
          "38:         $rr flush",
          "39:         catch {[$rr read]} e",
          "40:         assert_match {*unauthenticated bulk length*} $e",
          "41:         $rr close",
          "42:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bb7597f46ee7798531e236a20f41729d5a056050",
      "candidate_info": {
        "commit_hash": "bb7597f46ee7798531e236a20f41729d5a056050",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/bb7597f46ee7798531e236a20f41729d5a056050",
        "files": [
          "deps/hiredis/hiredis.c",
          "deps/hiredis/test.c"
        ],
        "message": "Fix redis-cli / redis-sential overflow on some platforms (CVE-2021-32762)\n\nThe redis-cli command line tool and redis-sentinel service may be vulnerable\nto integer overflow when parsing specially crafted large multi-bulk network\nreplies. This is a result of a vulnerability in the underlying hiredis\nlibrary which does not perform an overflow check before calling the calloc()\nheap allocation function.\n\nThis issue only impacts systems with heap allocators that do not perform their\nown overflow checks. Most modern systems do and are therefore not likely to\nbe affected. Furthermore, by default redis-sentinel uses the jemalloc allocator\nwhich is also not vulnerable.",
        "before_after_code_files": [
          "deps/hiredis/hiredis.c||deps/hiredis/hiredis.c",
          "deps/hiredis/test.c||deps/hiredis/test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/hiredis/hiredis.c||deps/hiredis/hiredis.c": [
          "File: deps/hiredis/hiredis.c -> deps/hiredis/hiredis.c"
        ],
        "deps/hiredis/test.c||deps/hiredis/test.c": [
          "File: deps/hiredis/test.c -> deps/hiredis/test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "400:     freeReplyObject(reply);",
          "401:     redisReaderFree(reader);",
          "403: #if LLONG_MAX > SIZE_MAX",
          "404:     test(\"Set error when array > SIZE_MAX: \");",
          "405:     reader = redisReaderCreate();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "403:     test(\"Multi-bulk never overflows regardless of maxelements: \");",
          "404:     size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;",
          "405:     char bad_mbulk_reply[100];",
          "406:     snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",",
          "407:         (unsigned long long) bad_mbulk_len);",
          "409:     reader = redisReaderCreate();",
          "411:     redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));",
          "412:     ret = redisReaderGetReply(reader,&reply);",
          "413:     test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\") == 0);",
          "414:     freeReplyObject(reply);",
          "415:     redisReaderFree(reader);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
      "candidate_info": {
        "commit_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "files": [
          "src/rio.c"
        ],
        "message": "more strict check in rioConnRead (#7564)\n\n(cherry picked from commit da840e9851bab8d1674e245a812b2105be111208)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "[Added Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
      "candidate_info": {
        "commit_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
        "files": [
          "src/intset.c",
          "src/rdb.c",
          "src/t_set.c"
        ],
        "message": "Fix Integer overflow issue with intsets (CVE-2021-32687)\n\nThe vulnerability involves changing the default set-max-intset-entries\nconfiguration parameter to a very large value and constructing specially\ncrafted commands to manipulate sets",
        "before_after_code_files": [
          "src/intset.c||src/intset.c",
          "src/rdb.c||src/rdb.c",
          "src/t_set.c||src/t_set.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/intset.c||src/intset.c": [
          "File: src/intset.c -> src/intset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"intset.h\"",
          "35: #include \"zmalloc.h\"",
          "36: #include \"endianconv.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"redisassert.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105: static intset *intsetResize(intset *is, uint32_t len) {",
          "107:     is = zrealloc(is,sizeof(intset)+size);",
          "108:     return is;",
          "109: }",
          "",
          "[Removed Lines]",
          "106:     uint32_t size = len*intrev32ifbe(is->encoding);",
          "",
          "[Added Lines]",
          "107:     uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);",
          "108:     assert(size <= SIZE_MAX - sizeof(intset));",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1518:         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "1522:             o = createSetObject();",
          "",
          "[Removed Lines]",
          "1521:         if (len > server.set_max_intset_entries) {",
          "",
          "[Added Lines]",
          "1521:         size_t max_entries = server.set_max_intset_entries;",
          "1522:         if (max_entries >= 1<<30) max_entries = 1<<30;",
          "1523:         if (len > max_entries) {",
          "",
          "---------------"
        ],
        "src/t_set.c||src/t_set.c": [
          "File: src/t_set.c -> src/t_set.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:             if (success) {",
          "70:                     setTypeConvert(subject,OBJ_ENCODING_HT);",
          "71:                 return 1;",
          "72:             }",
          "",
          "[Removed Lines]",
          "69:                 if (intsetLen(subject->ptr) > server.set_max_intset_entries)",
          "",
          "[Added Lines]",
          "69:                 size_t max_entries = server.set_max_intset_entries;",
          "71:                 if (max_entries >= 1<<30) max_entries = 1<<30;",
          "72:                 if (intsetLen(subject->ptr) > max_entries)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
      "candidate_info": {
        "commit_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/dde1c975b88f2e305ad4df720230474e30f6b100",
        "files": [
          "src/replication.c",
          "src/rio.c"
        ],
        "message": "Minor refactoring for rioConnRead and adding errno (#9280)\n\nminor refactoring for rioConnRead and adding errno\n\n(cherry picked from commit a40381640502439f751f42c4b23d4c6d396993e3)",
        "before_after_code_files": [
          "src/replication.c||src/replication.c",
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/replication.c||src/replication.c": [
          "File: src/replication.c -> src/replication.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1667:         if (rdbLoadRio(&rdb,RDBFLAGS_REPLICATION,&rsi) != C_OK) {",
          "1670:             serverLog(LL_WARNING,",
          "1673:             cancelReplicationHandshake();",
          "1674:             rioFreeConn(&rdb, NULL);",
          "",
          "[Removed Lines]",
          "1669:             stopLoading(0);",
          "1671:                 \"Failed trying to load the MASTER synchronization DB \"",
          "1672:                 \"from socket\");",
          "",
          "[Added Lines]",
          "1670:                       \"Failed trying to load the MASTER synchronization DB \"",
          "1671:                       \"from socket: %s\", strerror(errno));",
          "1672:             stopLoading(0);",
          "",
          "---------------"
        ],
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:         r->io.conn.pos = 0;",
          "188:     }",
          "191:     while (len > sdslen(r->io.conn.buf) - r->io.conn.pos) {",
          "192:         size_t buffered = sdslen(r->io.conn.buf) - r->io.conn.pos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:     if (r->io.conn.read_limit != 0 && r->io.conn.read_limit < r->io.conn.read_so_far + len) {",
          "194:         errno = EOVERFLOW;",
          "195:         return 0;",
          "196:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "198:         if (r->io.conn.read_limit != 0 &&",
          "199:             r->io.conn.read_so_far + buffered + toread > r->io.conn.read_limit)",
          "200:         {",
          "210:         }",
          "211:         int retval = connRead(r->io.conn.conn,",
          "212:                           (char*)r->io.conn.buf + sdslen(r->io.conn.buf),",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "208:                 return 0;",
          "209:             }",
          "",
          "[Added Lines]",
          "209:             toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-24028",
  "cve_desc": "An invalid free in Thrift's table-based serialization can cause the application to crash or potentially result in code execution or other undesirable effects. This issue affects Facebook Thrift prior to v2021.02.22.00.",
  "repo": "facebook/fbthrift",
  "patch_hash": "bfda1efa547dce11a38592820916db01b05b9339",
  "patch_info": {
    "commit_hash": "bfda1efa547dce11a38592820916db01b05b9339",
    "repo": "facebook/fbthrift",
    "commit_url": "https://github.com/facebook/fbthrift/commit/bfda1efa547dce11a38592820916db01b05b9339",
    "files": [
      "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp",
      "thrift/test/tablebased/SerializerTest.cpp",
      "thrift/test/tablebased/thrift_tablebased.thrift"
    ],
    "message": "Fix handling of invalid union data in table-based serializer\n\nSummary:\nFix handling of invalid union data in the table-based serializer. Previously if the input contained duplicate union data, previous active member of the union was overwritten without calling the destructor of the old object, potentially causing a memory leak. In addition to that, if the second piece of data was incomplete the wrong destructor would be called during stack unwinding causing a segfault, data corruption or other undesirable effects.\n\nFix the issue by clearing the union if there is an active member.\n\nAlso fix the type of the data member that holds the active field id (it's `int`, not `FieldID`).\n\nReviewed By: yfeldblum\n\nDifferential Revision: D26440248\n\nfbshipit-source-id: fae9ab96566cf07e14dabe9663b2beb680a01bb4",
    "before_after_code_files": [
      "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp||thrift/lib/cpp2/protocol/TableBasedSerializer.cpp",
      "thrift/test/tablebased/SerializerTest.cpp||thrift/test/tablebased/SerializerTest.cpp",
      "thrift/test/tablebased/thrift_tablebased.thrift||thrift/test/tablebased/thrift_tablebased.thrift"
    ]
  },
  "patch_diff": {
    "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp||thrift/lib/cpp2/protocol/TableBasedSerializer.cpp": [
      "File: thrift/lib/cpp2/protocol/TableBasedSerializer.cpp -> thrift/lib/cpp2/protocol/TableBasedSerializer.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "186:   return nullptr;",
      "187: }",
      "192: }",
      "194: const bool& fieldIsSet(const void* object, ptrdiff_t offset) {",
      "",
      "[Removed Lines]",
      "189: const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {",
      "190:   return *reinterpret_cast<const FieldID*>(",
      "191:       offset + static_cast<const char*>(object));",
      "",
      "[Added Lines]",
      "191: const int& getActiveId(const void* object, const StructInfo& info) {",
      "192:   return *reinterpret_cast<const int*>(",
      "193:       static_cast<const char*>(object) + info.unionExt->unionTypeOffset);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "591:       readState.readStructEnd(iprot);",
      "592:       return;",
      "593:     }",
      "604:     } else {",
      "605:       skip(iprot, readState);",
      "606:     }",
      "",
      "[Removed Lines]",
      "594:     const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);",
      "596:     if (fieldInfo) {",
      "597:       void* unionVal = getMember(*fieldInfo, object);",
      "599:       structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](",
      "600:           unionVal);",
      "601:       read(iprot, *fieldInfo->typeInfo, readState, unionVal);",
      "602:       const_cast<FieldID&>(activeUnionMemberId(",
      "603:           object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;",
      "",
      "[Added Lines]",
      "596:     if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {",
      "597:       auto& activeId = const_cast<int&>(getActiveId(object, structInfo));",
      "598:       if (activeId != 0) {",
      "599:         structInfo.unionExt->clear(object);",
      "600:       }",
      "601:       void* value = getMember(*fieldInfo, object);",
      "602:       structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);",
      "603:       read(iprot, *fieldInfo->typeInfo, readState, value);",
      "604:       activeId = fieldInfo->id;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "671:   size_t written = iprot->writeStructBegin(structInfo.name);",
      "672:   if (UNLIKELY(structInfo.unionExt != nullptr)) {",
      "673:     const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;",
      "676:     const FieldInfo* found = std::lower_bound(",
      "677:         structInfo.fieldInfos,",
      "678:         end,",
      "680:         [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });",
      "682:       const OptionalThriftValue value = getValue(*found->typeInfo, object);",
      "683:       if (value.hasValue()) {",
      "684:         written += writeField(iprot, *found, value.value());",
      "",
      "[Removed Lines]",
      "674:     const auto& unionId =",
      "675:         activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);",
      "679:         unionId,",
      "681:     if (found < end && found->id == unionId) {",
      "",
      "[Added Lines]",
      "675:     const auto& activeId = getActiveId(object, structInfo);",
      "679:         activeId,",
      "681:     if (found < end && found->id == activeId) {",
      "",
      "---------------"
    ],
    "thrift/test/tablebased/SerializerTest.cpp||thrift/test/tablebased/SerializerTest.cpp": [
      "File: thrift/test/tablebased/SerializerTest.cpp -> thrift/test/tablebased/SerializerTest.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "356:   u.set_fieldB({});",
      "357:   EXPECT_EQ(static_cast<void*>(&u), &*u.fieldB_ref());",
      "358: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "360: TEST(SerializerTest, DuplicateUnionData) {",
      "363:   const char data[] =",
      "364:       \"\\x0c\" // type = TType::T_STRUCT",
      "365:       \"\\x00\\x01\" // fieldId = 1 (unionField)",
      "366:       \"\\x0b\" // type = TType::T_STRING",
      "367:       \"\\x00\\x01\" // fieldId = 1 (stringField)",
      "368:       \"\\x00\\x00\\x00\\x00\" // size = 0",
      "369:       \"\\x00\" // end of unionField",
      "371:       \"\\x0c\" // type = TType::T_STRUCT",
      "372:       \"\\x00\\x01\" // fieldId = 1 (unionField)",
      "373:       \"\\x13\" // type = TType::T_FLOAT",
      "374:       \"\\x00\\x02\"; // fieldId = 2 (floatField), value is missing",
      "376:   EXPECT_THROW(",
      "377:       BinarySerializer::deserialize<tablebased::TestStructWithUnion>(",
      "378:           folly::StringPiece(data, sizeof(data))),",
      "379:       std::out_of_range);",
      "380: }",
      "",
      "---------------"
    ],
    "thrift/test/tablebased/thrift_tablebased.thrift||thrift/test/tablebased/thrift_tablebased.thrift": [
      "File: thrift/test/tablebased/thrift_tablebased.thrift -> thrift/test/tablebased/thrift_tablebased.thrift",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:   3: StructA fieldC (cpp2.ref_type = \"shared_const\");",
      "80:   4: StructA fieldD (cpp2.ref_type = \"shared\");",
      "81: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "83: union TestUnion {",
      "84:   1: string stringField;",
      "85:   2: float floatField;",
      "86: }",
      "88: struct TestStructWithUnion {",
      "89:   1: TestUnion unionField;",
      "90: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "971f861eadb9da750e80a3cb07ab9f8472a635b0",
      "candidate_info": {
        "commit_hash": "971f861eadb9da750e80a3cb07ab9f8472a635b0",
        "repo": "facebook/fbthrift",
        "commit_url": "https://github.com/facebook/fbthrift/commit/971f861eadb9da750e80a3cb07ab9f8472a635b0",
        "files": [
          "thrift/test/tablebased/SerializerTest.cpp",
          "thrift/test/tablebased/thrift.thrift",
          "thrift/test/tablebased/thrift_tablebased.thrift"
        ],
        "message": "Cleanup table-based serializer test\n\nSummary:\nCleanup table-based serializer test in preparation for adding more test cases:\n\n* Use more meaningful field names\n* Remove redundant code\n\nReviewed By: yfeldblum\n\nDifferential Revision: D28816684\n\nfbshipit-source-id: dd596bc33cd8e86b45cea1550d1a4d4d2ccec4f0",
        "before_after_code_files": [
          "thrift/test/tablebased/SerializerTest.cpp||thrift/test/tablebased/SerializerTest.cpp",
          "thrift/test/tablebased/thrift.thrift||thrift/test/tablebased/thrift.thrift",
          "thrift/test/tablebased/thrift_tablebased.thrift||thrift/test/tablebased/thrift_tablebased.thrift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "thrift/test/tablebased/SerializerTest.cpp||thrift/test/tablebased/SerializerTest.cpp",
            "thrift/test/tablebased/thrift_tablebased.thrift||thrift/test/tablebased/thrift_tablebased.thrift"
          ],
          "candidate": [
            "thrift/test/tablebased/SerializerTest.cpp||thrift/test/tablebased/SerializerTest.cpp",
            "thrift/test/tablebased/thrift_tablebased.thrift||thrift/test/tablebased/thrift_tablebased.thrift"
          ]
        }
      },
      "candidate_diff": {
        "thrift/test/tablebased/SerializerTest.cpp||thrift/test/tablebased/SerializerTest.cpp": [
          "File: thrift/test/tablebased/SerializerTest.cpp -> thrift/test/tablebased/SerializerTest.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:     }                                                           \\",
          "49:   } while (false)",
          "",
          "[Removed Lines]",
          "51: constexpr const char* UNQUALIFIED = \"unqualified\";",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79: template <typename Type>",
          "80: Type makeStructWithIncludeLike() {",
          "84: }",
          "86: template <typename Type>",
          "87: Type makeFrozenStructBLike() {",
          "91: }",
          "93: template <typename Type>",
          "94: Type makeFrozenStructALike() {",
          "98: }",
          "100: template <typename Type>",
          "101: Type makeStructBLike() {",
          "119: }",
          "121: template <typename Type>",
          "122: Type makeStructALike() {",
          "135: }",
          "137: template <typename Type>",
          "138: Type makeStructWithRefLike() {",
          "144:   std::vector<std::string> tmp = {\"test1\", \"test2\"};",
          "146:       std::make_shared<const std::vector<std::string>>(std::move(tmp));",
          "150: }",
          "151: } // namespace",
          "",
          "[Removed Lines]",
          "81:   Type object;",
          "82:   object.fieldA_ref().emplace();",
          "83:   return object;",
          "88:   Type structBLike;",
          "89:   structBLike.fieldA_ref() = 2000;",
          "90:   return structBLike;",
          "95:   Type structALike;",
          "96:   structALike.fieldA_ref() = 2000;",
          "97:   return structALike;",
          "102:   Type otherStructLike;",
          "103:   otherStructLike.fieldB_ref() = 2000;",
          "105:   otherStructLike.fieldC_ref() = folly::IOBuf::copyBuffer(\"testBuffer\");",
          "107:   otherStructLike.fieldD_ref() = std::make_shared<std::vector<int64_t>>();",
          "108:   otherStructLike.fieldD_ref()->emplace_back(9000);",
          "109:   otherStructLike.fieldD_ref()->emplace_back(8000);",
          "110:   otherStructLike.fieldE_ref() = 1000;",
          "111:   otherStructLike.fieldF_ref() = 20;",
          "112:   otherStructLike.fieldG_ref() = 16;",
          "113:   otherStructLike.fieldH_ref() = true;",
          "114:   otherStructLike.fieldI_ref() = std::set{1, 2, 3};",
          "115:   otherStructLike.fieldJ_ref() = \"testBuffer\";",
          "116:   otherStructLike.fieldK_ref() = 1.0;",
          "117:   otherStructLike.fieldL_ref() = 2.0;",
          "118:   return otherStructLike;",
          "123:   Type structALike;",
          "124:   structALike.fieldD_ref() = {\"first\", \"second\"};",
          "125:   structALike.fieldE_ref() = {{\"first\", 1}, {\"second\", 2}};",
          "126:   structALike.fieldA_ref() = \"yo\";",
          "127:   structALike.fieldB_ref() = 123;",
          "128:   structALike.fieldF_ref() = UNQUALIFIED;",
          "129:   structALike.fieldC_ref().emplace();",
          "130:   structALike.fieldC_ref() = makeStructBLike<",
          "131:       std::remove_reference_t<decltype(*structALike.fieldC_ref())>>();",
          "132:   using EnumType = std::remove_reference_t<decltype(*structALike.fieldG_ref())>;",
          "133:   structALike.fieldG_ref() = EnumType::A;",
          "134:   return structALike;",
          "139:   Type object;",
          "140:   object.fieldA_ref() = std::make_shared<std::add_const_t<",
          "141:       std::remove_reference_t<decltype(*object.fieldA_ref())>>>(",
          "142:       makeStructBLike<typename std::remove_const<",
          "143:           std::remove_reference_t<decltype(*object.fieldA_ref())>>::type>());",
          "145:   object.fieldB_ref() =",
          "147:   object.fieldC_ref() = std::make_shared<const std::int16_t>(1000);",
          "148:   object.fieldD_ref() = std::make_unique<std::int32_t>(5000);",
          "149:   return object;",
          "",
          "[Added Lines]",
          "79:   auto obj = Type();",
          "80:   obj.field_ref() = {};",
          "81:   return obj;",
          "86:   auto obj = Type();",
          "87:   obj.fieldA_ref() = 2000;",
          "88:   return obj;",
          "93:   auto obj = Type();",
          "94:   obj.fieldA_ref() = 2000;",
          "95:   return obj;",
          "100:   auto obj = Type();",
          "101:   obj.i64_field_ref() = 2000;",
          "102:   obj.iobufptr_field_ref() = folly::IOBuf::copyBuffer(\"testBuffer\");",
          "104:   obj.list_field_ref() = std::make_shared<std::vector<int64_t>>();",
          "105:   obj.list_field_ref()->emplace_back(9000);",
          "106:   obj.list_field_ref()->emplace_back(8000);",
          "108:   obj.i32_field_ref() = 1000;",
          "109:   obj.i16_field_ref() = 20;",
          "110:   obj.byte_field_ref() = 16;",
          "111:   obj.bool_field_ref() = true;",
          "112:   obj.set_field_ref() = std::set{1, 2, 3};",
          "113:   obj.iobuf_field_ref() = \"testBuffer\";",
          "114:   obj.double_field_ref() = 1.0;",
          "115:   obj.float_field_ref() = 2.0;",
          "116:   return obj;",
          "121:   auto obj = Type();",
          "122:   obj.list_field_ref() = {\"first\", \"second\"};",
          "123:   obj.map_field_ref() = {{\"first\", 1}, {\"second\", 2}};",
          "124:   obj.opt_str_field_ref() = \"yo\";",
          "125:   obj.i64_field_ref() = 123;",
          "126:   obj.str_field_ref() = \"unqualified\";",
          "127:   using Struct = std::remove_reference_t<decltype(*obj.struct_field_ref())>;",
          "128:   obj.struct_field_ref() = makeStructBLike<Struct>();",
          "129:   using Enum = std::remove_reference_t<decltype(*obj.enum_field_ref())>;",
          "130:   obj.enum_field_ref() = Enum::A;",
          "131:   return obj;",
          "136:   auto obj = Type();",
          "137:   using Struct =",
          "138:       std::remove_reference_t<decltype(*obj.shared_struct_field_ref())>;",
          "139:   obj.shared_struct_field_ref() = std::make_shared<std::add_const_t<Struct>>(",
          "140:       makeStructBLike<typename std::remove_const<Struct>::type>());",
          "142:   obj.shared_list_field_ref() =",
          "144:   obj.shared_i16_field_ref() = std::make_shared<const std::int16_t>(1000);",
          "145:   obj.unique_i32_field_ref() = std::make_unique<std::int32_t>(5000);",
          "146:   return obj;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "220: TYPED_TEST(MultiProtocolTest, Union) {",
          "221:   {",
          "223:     Union oldObject;",
          "226:     tablebased::Union newObject;",
          "228:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "229:   }",
          "230:   {",
          "232:     Union oldObject;",
          "235:     tablebased::Union newObject;",
          "237:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "238:   }",
          "239:   {",
          "240:     Union oldObject;",
          "242:     tablebased::Union newObject;",
          "244:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "245:   }",
          "246: }",
          "",
          "[Removed Lines]",
          "222:     StructA oldUnionVal = makeStructALike<StructA>();",
          "224:     oldObject.fieldA_ref() = oldUnionVal;",
          "225:     tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();",
          "227:     newObject.fieldA_ref() = newUnionVal;",
          "231:     StructB oldUnionVal = makeStructBLike<StructB>();",
          "233:     oldObject.fieldB_ref() = oldUnionVal;",
          "234:     tablebased::StructB newUnionVal = makeStructBLike<tablebased::StructB>();",
          "236:     newObject.fieldB_ref() = newUnionVal;",
          "241:     oldObject.fieldC_ref() = \"test\";",
          "243:     newObject.fieldC_ref() = \"test\";",
          "",
          "[Added Lines]",
          "220:     oldObject.a_field_ref() = makeStructALike<StructA>();",
          "222:     newObject.a_field_ref() = makeStructALike<tablebased::StructA>();",
          "227:     oldObject.b_field_ref() = makeStructBLike<StructB>();",
          "229:     newObject.b_field_ref() = makeStructBLike<tablebased::StructB>();",
          "234:     oldObject.str_field_ref() = \"test\";",
          "236:     newObject.str_field_ref() = \"test\";",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "253: TYPED_TEST(MultiProtocolTest, UnionWithRef) {",
          "254:   {",
          "255:     UnionWithRef oldObject;",
          "257:     {",
          "259:       const_cast<std::unique_ptr<StructA>&>(ptr) =",
          "260:           std::unique_ptr<StructA>(nullptr);",
          "261:     }",
          "262:     tablebased::UnionWithRef newObject;",
          "264:     {",
          "266:       const_cast<std::unique_ptr<tablebased::StructA>&>(ptr) =",
          "267:           std::unique_ptr<tablebased::StructA>(nullptr);",
          "268:     }",
          "269:     EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);",
          "274:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "275:   }",
          "276:   {",
          "278:     UnionWithRef oldObject;",
          "288:     {",
          "292:     }",
          "293:     tablebased::UnionWithRef newObject;",
          "295:     {",
          "299:     }",
          "300:     EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);",
          "305:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "306:   }",
          "307:   {",
          "308:     UnionWithRef oldObject;",
          "310:     {",
          "314:     }",
          "315:     tablebased::UnionWithRef newObject;",
          "317:     {",
          "321:     }",
          "322:     EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);",
          "327:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "328:   }",
          "329: }",
          "331: TYPED_TEST(MultiProtocolTest, DirtyReadIntoContainer) {",
          "337:   TypeParam::deserialize(serialized, dirty);",
          "339: }",
          "341: TYPED_TEST(MultiProtocolTest, ReadingUnqualifiedFieldShouldSetIsset) {",
          "349: }",
          "351: TEST(SerializerTest, UnionValueOffsetIsZero) {",
          "352:   tablebased::Union u;",
          "361: }",
          "363: TEST(SerializerTest, DuplicateUnionData) {",
          "",
          "[Removed Lines]",
          "256:     oldObject.set_fieldA();",
          "258:       auto& ptr = oldObject.get_fieldA();",
          "263:     newObject.set_fieldA();",
          "265:       auto& ptr = newObject.get_fieldA();",
          "270:     StructA oldUnionVal = makeStructALike<StructA>();",
          "271:     oldObject.set_fieldA(oldUnionVal);",
          "272:     tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();",
          "273:     newObject.set_fieldA(newUnionVal);",
          "277:     StructB oldUnionVal = makeStructBLike<StructB>();",
          "279:     oldObject.set_fieldB(oldUnionVal);",
          "280:     tablebased::StructB newUnionVal = makeStructBLike<tablebased::StructB>();",
          "281:     tablebased::UnionWithRef newObject;",
          "282:     newObject.set_fieldB(newUnionVal);",
          "283:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "284:   }",
          "285:   {",
          "286:     UnionWithRef oldObject;",
          "287:     oldObject.set_fieldC();",
          "289:       auto& ptr = oldObject.get_fieldC();",
          "290:       const_cast<std::shared_ptr<const StructA>&>(ptr) =",
          "291:           std::shared_ptr<const StructA>(nullptr);",
          "294:     newObject.set_fieldC();",
          "296:       auto& ptr = newObject.get_fieldC();",
          "297:       const_cast<std::shared_ptr<const tablebased::StructA>&>(ptr) =",
          "298:           std::shared_ptr<const tablebased::StructA>(nullptr);",
          "301:     StructA oldUnionVal = makeStructALike<StructA>();",
          "302:     oldObject.set_fieldC(oldUnionVal);",
          "303:     tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();",
          "304:     newObject.set_fieldC(newUnionVal);",
          "309:     oldObject.set_fieldD();",
          "311:       auto& ptr = oldObject.get_fieldD();",
          "312:       const_cast<std::shared_ptr<StructA>&>(ptr) =",
          "313:           std::shared_ptr<StructA>(nullptr);",
          "316:     newObject.set_fieldD();",
          "318:       auto& ptr = newObject.get_fieldD();",
          "319:       const_cast<std::shared_ptr<tablebased::StructA>&>(ptr) =",
          "320:           std::shared_ptr<tablebased::StructA>(nullptr);",
          "323:     StructA oldUnionVal = makeStructALike<StructA>();",
          "324:     oldObject.set_fieldD(oldUnionVal);",
          "325:     tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();",
          "326:     newObject.set_fieldD(newUnionVal);",
          "332:   tablebased::StructA dirty;",
          "333:   dirty.fieldD_ref() = {\"should be cleared\"};",
          "335:   tablebased::StructA filled = makeStructALike<tablebased::StructA>();",
          "336:   std::string serialized = TypeParam::template serialize<std::string>(filled);",
          "338:   EXPECT_EQ(*filled.fieldD_ref(), *dirty.fieldD_ref());",
          "342:   tablebased::StructA obj = makeStructALike<tablebased::StructA>();",
          "344:   tablebased::StructA deserialized =",
          "345:       TypeParam::template deserialize<tablebased::StructA>(",
          "346:           TypeParam::template serialize<std::string>(obj));",
          "347:   EXPECT_TRUE(deserialized.fieldF_ref().is_set());",
          "348:   EXPECT_EQ(deserialized.fieldF_ref().value(), UNQUALIFIED);",
          "353:   u.set_fieldC(\"test\");",
          "354:   EXPECT_EQ(static_cast<void*>(&u), &*u.fieldC_ref());",
          "356:   u.set_fieldA({});",
          "357:   EXPECT_EQ(static_cast<void*>(&u), &*u.fieldA_ref());",
          "359:   u.set_fieldB({});",
          "360:   EXPECT_EQ(static_cast<void*>(&u), &*u.fieldB_ref());",
          "",
          "[Added Lines]",
          "249:     oldObject.set_simple_field(makeStructBLike<StructB>());",
          "250:     tablebased::UnionWithRef newObject;",
          "251:     newObject.set_simple_field(makeStructBLike<tablebased::StructB>());",
          "252:     EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);",
          "253:   }",
          "254:   {",
          "255:     UnionWithRef oldObject;",
          "256:     oldObject.set_unique_field();",
          "258:       auto& ptr = oldObject.get_unique_field();",
          "263:     newObject.set_unique_field();",
          "265:       auto& ptr = newObject.get_unique_field();",
          "270:     oldObject.set_unique_field(makeStructALike<StructA>());",
          "271:     newObject.set_unique_field(makeStructALike<tablebased::StructA>());",
          "276:     oldObject.set_shared_field();",
          "278:       auto& ptr = oldObject.get_shared_field();",
          "279:       const_cast<std::shared_ptr<StructA>&>(ptr) =",
          "280:           std::shared_ptr<StructA>(nullptr);",
          "283:     newObject.set_shared_field();",
          "285:       auto& ptr = newObject.get_shared_field();",
          "286:       const_cast<std::shared_ptr<tablebased::StructA>&>(ptr) =",
          "287:           std::shared_ptr<tablebased::StructA>(nullptr);",
          "290:     oldObject.set_shared_field(makeStructALike<StructA>());",
          "291:     newObject.set_shared_field(makeStructALike<tablebased::StructA>());",
          "296:     oldObject.set_shared_const_field();",
          "298:       auto& ptr = oldObject.get_shared_const_field();",
          "299:       const_cast<std::shared_ptr<const StructA>&>(ptr) =",
          "300:           std::shared_ptr<const StructA>(nullptr);",
          "303:     newObject.set_shared_const_field();",
          "305:       auto& ptr = newObject.get_shared_const_field();",
          "306:       const_cast<std::shared_ptr<const tablebased::StructA>&>(ptr) =",
          "307:           std::shared_ptr<const tablebased::StructA>(nullptr);",
          "310:     oldObject.set_shared_const_field(makeStructALike<StructA>());",
          "311:     newObject.set_shared_const_field(makeStructALike<tablebased::StructA>());",
          "317:   auto dirty = tablebased::StructA();",
          "318:   dirty.list_field_ref() = {\"should be cleared\"};",
          "319:   auto filled = makeStructALike<tablebased::StructA>();",
          "320:   auto serialized = TypeParam::template serialize<std::string>(filled);",
          "322:   EXPECT_EQ(filled.list_field_ref(), dirty.list_field_ref());",
          "326:   auto obj = makeStructALike<tablebased::StructA>();",
          "327:   auto deserialized = TypeParam::template deserialize<tablebased::StructA>(",
          "328:       TypeParam::template serialize<std::string>(obj));",
          "329:   EXPECT_TRUE(deserialized.str_field_ref().is_set());",
          "330:   EXPECT_EQ(deserialized.str_field_ref(), \"unqualified\");",
          "335:   u.set_str_field(\"test\");",
          "336:   EXPECT_EQ(static_cast<void*>(&u), &*u.str_field_ref());",
          "338:   u.set_a_field({});",
          "339:   EXPECT_EQ(static_cast<void*>(&u), &*u.a_field_ref());",
          "341:   u.set_b_field({});",
          "342:   EXPECT_EQ(static_cast<void*>(&u), &*u.b_field_ref());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "366:   const char data[] =",
          "367:       \"\\x0c\" // type = TType::T_STRUCT",
          "369:       \"\\x0b\" // type = TType::T_STRING",
          "371:       \"\\x00\\x00\\x00\\x00\" // size = 0",
          "374:       \"\\x0c\" // type = TType::T_STRUCT",
          "376:       \"\\x13\" // type = TType::T_FLOAT",
          "379:   EXPECT_THROW(",
          "380:       BinarySerializer::deserialize<tablebased::TestStructWithUnion>(",
          "",
          "[Removed Lines]",
          "368:       \"\\x00\\x01\" // fieldId = 1 (unionField)",
          "370:       \"\\x00\\x01\" // fieldId = 1 (stringField)",
          "372:       \"\\x00\" // end of unionField",
          "375:       \"\\x00\\x01\" // fieldId = 1 (unionField)",
          "377:       \"\\x00\\x02\"; // fieldId = 2 (floatField), value is missing",
          "",
          "[Added Lines]",
          "350:       \"\\x00\\x01\" // fieldId = 1 (union_field)",
          "352:       \"\\x00\\x01\" // fieldId = 1 (string_field)",
          "354:       \"\\x00\" // end of union_field",
          "357:       \"\\x00\\x01\" // fieldId = 1 (union_field)",
          "359:       \"\\x00\\x02\"; // fieldId = 2 (float_field), value is missing",
          "",
          "---------------"
        ],
        "thrift/test/tablebased/thrift.thrift||thrift/test/tablebased/thrift.thrift": [
          "File: thrift/test/tablebased/thrift.thrift -> thrift/test/tablebased/thrift.thrift",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: }",
          "28: struct StructA {",
          "36: }",
          "38: struct StructWithRef {",
          "43: }",
          "45: struct StructWithCppType {",
          "46:   1: optional map<string, StructA> (",
          "47:     cpp.type = \"std::unordered_map<std::string, StructA>\",",
          "49: }",
          "51: struct StructB {",
          "64: }",
          "66: struct StructWithInclude {",
          "68: }",
          "70: union Union {",
          "74: }",
          "76: union UnionWithRef {",
          "81: }",
          "",
          "[Removed Lines]",
          "29:   1: optional string fieldA;",
          "30:   2: optional i64 fieldB;",
          "31:   3: optional StructB fieldC;",
          "32:   5: optional list<string> fieldD;",
          "33:   10: optional map<string, i64> fieldE;",
          "34:   11: string fieldF;",
          "35:   12: Enum fieldG;",
          "39:   1: optional StructB fieldA (cpp2.ref_type = \"shared_const\");",
          "40:   2: optional list<string> fieldB (cpp2.ref_type = \"shared_const\");",
          "41:   3: optional i16 fieldC (cpp2.ref_type = \"shared_const\");",
          "42:   4: optional i32 fieldD (cpp2.ref_type = \"unique\");",
          "48:   ) fieldA;",
          "52:   1: string fieldA;",
          "53:   2: optional i64 fieldB;",
          "54:   3: optional IOBufPtr fieldC;",
          "55:   5: optional list<i64> fieldD (cpp2.ref_type = \"shared\");",
          "56:   6: i32 fieldE;",
          "57:   7: i16 fieldF;",
          "58:   8: byte fieldG;",
          "59:   9: bool fieldH;",
          "60:   10: set<i32> fieldI;",
          "61:   11: string fieldJ (cpp2.type = \"folly::IOBuf\");",
          "62:   12: double fieldK;",
          "63:   13: float fieldL;",
          "67:   1: optional include.IncludedStruct fieldA;",
          "71:   1: StructA fieldA;",
          "72:   2: StructB fieldB;",
          "73:   3: string fieldC;",
          "77:   1: StructA fieldA (cpp2.ref_type = \"unique\");",
          "78:   2: StructB fieldB;",
          "79:   3: StructA fieldC (cpp2.ref_type = \"shared_const\");",
          "80:   4: StructA fieldD (cpp2.ref_type = \"shared\");",
          "",
          "[Added Lines]",
          "29:   1: optional i64 i64_field;",
          "30:   2: optional string opt_str_field;",
          "31:   3: optional StructB struct_field;",
          "32:   5: optional list<string> list_field;",
          "33:   10: optional map<string, i64> map_field;",
          "34:   11: string str_field;",
          "35:   12: Enum enum_field;",
          "39:   1: optional StructB shared_struct_field (cpp.ref_type = \"shared_const\");",
          "40:   2: optional list<string> shared_list_field (cpp.ref_type = \"shared_const\");",
          "41:   3: optional i16 shared_i16_field (cpp.ref_type = \"shared_const\");",
          "42:   4: optional i32 unique_i32_field (cpp.ref_type = \"unique\");",
          "48:   ) field;",
          "52:   1: string str_field;",
          "53:   2: optional i64 i64_field;",
          "54:   3: optional IOBufPtr iobufptr_field;",
          "55:   5: optional list<i64> list_field (cpp.ref_type = \"shared\");",
          "56:   6: i32 i32_field;",
          "57:   7: i16 i16_field;",
          "58:   8: byte byte_field;",
          "59:   9: bool bool_field;",
          "60:   10: set<i32> set_field;",
          "61:   11: string iobuf_field (cpp.type = \"folly::IOBuf\");",
          "62:   12: double double_field;",
          "63:   13: float float_field;",
          "67:   1: optional include.IncludedStruct field;",
          "71:   1: StructA a_field;",
          "72:   2: StructB b_field;",
          "73:   3: string str_field;",
          "77:   1: StructB simple_field;",
          "78:   2: StructA unique_field (cpp.ref_type = \"unique\");",
          "79:   4: StructA shared_field (cpp2.ref_type = \"shared\");",
          "80:   3: StructA shared_const_field (cpp.ref_type = \"shared_const\");",
          "",
          "---------------"
        ],
        "thrift/test/tablebased/thrift_tablebased.thrift||thrift/test/tablebased/thrift_tablebased.thrift": [
          "File: thrift/test/tablebased/thrift_tablebased.thrift -> thrift/test/tablebased/thrift_tablebased.thrift",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: }",
          "28: struct StructA {",
          "36: }",
          "38: struct StructWithRef {",
          "43: }",
          "45: struct StructWithCppType {",
          "46:   1: optional map<string, StructA> (",
          "47:     cpp.type = \"std::unordered_map<std::string, StructA>\",",
          "49: }",
          "51: struct StructB {",
          "64: }",
          "66: struct StructWithInclude {",
          "68: }",
          "70: union Union {",
          "74: }",
          "76: union UnionWithRef {",
          "81: }",
          "83: union TestUnion {",
          "86: }",
          "88: struct TestStructWithUnion {",
          "90: }",
          "",
          "[Removed Lines]",
          "29:   1: optional string fieldA;",
          "30:   2: optional i64 fieldB;",
          "31:   3: optional StructB fieldC;",
          "32:   5: optional list<string> fieldD;",
          "33:   10: optional map<string, i64> fieldE;",
          "34:   11: string fieldF;",
          "35:   12: Enum fieldG;",
          "39:   1: optional StructB fieldA (cpp2.ref_type = \"shared_const\");",
          "40:   2: optional list<string> fieldB (cpp2.ref_type = \"shared_const\");",
          "41:   3: optional i16 fieldC (cpp2.ref_type = \"shared_const\");",
          "42:   4: optional i32 fieldD (cpp2.ref_type = \"unique\");",
          "48:   ) fieldA;",
          "52:   1: string fieldA;",
          "53:   2: optional i64 fieldB;",
          "54:   3: optional IOBufPtr fieldC;",
          "55:   5: optional list<i64> fieldD (cpp2.ref_type = \"shared\");",
          "56:   6: i32 fieldE;",
          "57:   7: i16 fieldF;",
          "58:   8: byte fieldG;",
          "59:   9: bool fieldH;",
          "60:   10: set<i32> fieldI;",
          "61:   11: string fieldJ (cpp2.type = \"folly::IOBuf\");",
          "62:   12: double fieldK;",
          "63:   13: float fieldL;",
          "67:   1: optional include_tablebased.IncludedStruct fieldA;",
          "71:   1: StructA fieldA;",
          "72:   2: StructB fieldB;",
          "73:   3: string fieldC;",
          "77:   1: StructA fieldA (cpp2.ref_type = \"unique\");",
          "78:   2: StructB fieldB;",
          "79:   3: StructA fieldC (cpp2.ref_type = \"shared_const\");",
          "80:   4: StructA fieldD (cpp2.ref_type = \"shared\");",
          "84:   1: string stringField;",
          "85:   2: float floatField;",
          "89:   1: TestUnion unionField;",
          "",
          "[Added Lines]",
          "29:   1: optional i64 i64_field;",
          "30:   2: optional string opt_str_field;",
          "31:   3: optional StructB struct_field;",
          "32:   5: optional list<string> list_field;",
          "33:   10: optional map<string, i64> map_field;",
          "34:   11: string str_field;",
          "35:   12: Enum enum_field;",
          "39:   1: optional StructB shared_struct_field (cpp.ref_type = \"shared_const\");",
          "40:   2: optional list<string> shared_list_field (cpp.ref_type = \"shared_const\");",
          "41:   3: optional i16 shared_i16_field (cpp.ref_type = \"shared_const\");",
          "42:   4: optional i32 unique_i32_field (cpp.ref_type = \"unique\");",
          "48:   ) field;",
          "52:   1: string str_field;",
          "53:   2: optional i64 i64_field;",
          "54:   3: optional IOBufPtr iobufptr_field;",
          "55:   5: optional list<i64> list_field (cpp.ref_type = \"shared\");",
          "56:   6: i32 i32_field;",
          "57:   7: i16 i16_field;",
          "58:   8: byte byte_field;",
          "59:   9: bool bool_field;",
          "60:   10: set<i32> set_field;",
          "61:   11: string iobuf_field (cpp.type = \"folly::IOBuf\");",
          "62:   12: double double_field;",
          "63:   13: float float_field;",
          "67:   1: optional include_tablebased.IncludedStruct field;",
          "71:   1: StructA a_field;",
          "72:   2: StructB b_field;",
          "73:   3: string str_field;",
          "77:   1: StructB simple_field;",
          "78:   2: StructA unique_field (cpp.ref_type = \"unique\");",
          "79:   4: StructA shared_field (cpp2.ref_type = \"shared\");",
          "80:   3: StructA shared_const_field (cpp.ref_type = \"shared_const\");",
          "84:   1: string string_field;",
          "85:   2: float float_field;",
          "89:   1: TestUnion union_field;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "86cc41449a2d2f24794ac4d04fd7431f11bfb511",
      "candidate_info": {
        "commit_hash": "86cc41449a2d2f24794ac4d04fd7431f11bfb511",
        "repo": "facebook/fbthrift",
        "commit_url": "https://github.com/facebook/fbthrift/commit/86cc41449a2d2f24794ac4d04fd7431f11bfb511",
        "files": [
          "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp",
          "thrift/lib/cpp2/protocol/TableBasedSerializer.h"
        ],
        "message": "TableBasedSerializer runtime\n\nSummary:\nThis diff implements the runtime (de)serialization code codenamed `TableBasedSerializer`.\n\nNormally, thrift compiler will generate per-struct (de)serialization code, the approach essentially inlines all (de)serialization code in favor of performance. However, in some cases, thrift users want to optimize for binary size and instead want to reuse similar code for reading/ writing thrift types. All mobile code tend to favor this trade off.\n\nThe `TableBasedSerializer` approach is to capture the struct layout as DATA in table form, using 2 key information about the struct fields to be able to read/ write them:\n* the offset from the struct object memory address to the field's memory address\n* the type information of the field\n\nThus in effect we replace:\n```\nSerializer::read<StructClass>(object);\n```\nwith:\n```\nSerializer::read(structLayout, object);\n```\n\nThe type information helps us fully type-erase the serializer implementation and share all primitive data types specialization functions for read/ write.\n\nHowever, since Thrift is a flexible data structure that allows arbitrary recursive nesting of collection types (i.e.: vector of vector of map, ...), the savings for collection types are considerably less since each specialization of a collection is accompanied by the associated specialization function for read/ write. It's pretty much unavoidable\n\nReviewed By: vitaut\n\nDifferential Revision: D21891168\n\nfbshipit-source-id: eb419c84d110515b5c3fb3018d016a67659803ad",
        "before_after_code_files": [
          "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp||thrift/lib/cpp2/protocol/TableBasedSerializer.cpp",
          "thrift/lib/cpp2/protocol/TableBasedSerializer.h||thrift/lib/cpp2/protocol/TableBasedSerializer.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp||thrift/lib/cpp2/protocol/TableBasedSerializer.cpp"
          ],
          "candidate": [
            "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp||thrift/lib/cpp2/protocol/TableBasedSerializer.cpp"
          ]
        }
      },
      "candidate_diff": {
        "thrift/lib/cpp2/protocol/TableBasedSerializer.cpp||thrift/lib/cpp2/protocol/TableBasedSerializer.cpp": [
          "File: thrift/lib/cpp2/protocol/TableBasedSerializer.cpp -> thrift/lib/cpp2/protocol/TableBasedSerializer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #include \"thrift/lib/cpp2/protocol/TableBasedSerializer.h\"",
          "19: #include \"folly/CppAttributes.h\"",
          "20: #include \"glog/logging.h\"",
          "21: #include \"thrift/lib/cpp2/protocol/BinaryProtocol.h\"",
          "22: #include \"thrift/lib/cpp2/protocol/CompactProtocol.h\"",
          "23: #include \"thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h\"",
          "24: #include \"thrift/lib/cpp2/protocol/ProtocolReaderWireTypeInfo.h\"",
          "25: #include \"thrift/lib/cpp2/protocol/SimpleJSONProtocol.h\"",
          "27: namespace apache {",
          "28: namespace thrift {",
          "29: namespace detail {",
          "31: #define THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(                          \\",
          "32:     TypeClass, Type, ThriftType, TTypeValue)                           \\",
          "33:   const TypeInfo TypeToInfo<type_class::TypeClass, Type>::typeInfo = { \\",
          "34:       protocol::TType::TTypeValue,                                     \\",
          "35:       reinterpret_cast<VoidFuncPtr>(identity(set<Type, ThriftType>)),  \\",
          "36:       reinterpret_cast<VoidFuncPtr>(identity(get<ThriftType, Type>)),  \\",
          "37:       nullptr,                                                         \\",
          "38:   }",
          "41: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "42:     integral,",
          "43:     std::int8_t,",
          "44:     std::int8_t,",
          "45:     T_BYTE);",
          "46: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "47:     integral,",
          "48:     std::int16_t,",
          "49:     std::int16_t,",
          "50:     T_I16);",
          "51: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "52:     integral,",
          "53:     std::int32_t,",
          "54:     std::int32_t,",
          "55:     T_I32);",
          "56: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "57:     integral,",
          "58:     std::int64_t,",
          "59:     std::int64_t,",
          "60:     T_I64);",
          "61: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "62:     integral,",
          "63:     std::uint8_t,",
          "64:     std::int8_t,",
          "65:     T_BYTE);",
          "66: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "67:     integral,",
          "68:     std::uint16_t,",
          "69:     std::int16_t,",
          "70:     T_I16);",
          "71: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "72:     integral,",
          "73:     std::uint32_t,",
          "74:     std::int32_t,",
          "75:     T_I32);",
          "76: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "77:     integral,",
          "78:     std::uint64_t,",
          "79:     std::int64_t,",
          "80:     T_I64);",
          "81: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(integral, bool, bool, T_BOOL);",
          "83: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, float, float, T_FLOAT);",
          "84: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, double, double, T_DOUBLE);",
          "87: #define THRIFT_DEFINE_STRING_TYPE_TO_INFO(TypeClass, ActualType, ExtVal)     \\",
          "88:   const StringFieldType TypeToInfo<type_class::TypeClass, ActualType>::ext = \\",
          "89:       ExtVal;                                                                \\",
          "90:   const TypeInfo TypeToInfo<type_class::TypeClass, ActualType>::typeInfo = { \\",
          "95:   }",
          "97: THRIFT_DEFINE_STRING_TYPE_TO_INFO(string, std::string, StringFieldType::String);",
          "98: THRIFT_DEFINE_STRING_TYPE_TO_INFO(",
          "99:     string,",
          "100:     folly::fbstring,",
          "101:     StringFieldType::String);",
          "102: THRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, std::string, StringFieldType::String);",
          "103: THRIFT_DEFINE_STRING_TYPE_TO_INFO(",
          "104:     binary,",
          "105:     folly::fbstring,",
          "106:     StringFieldType::String);",
          "107: THRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, folly::IOBuf, StringFieldType::IOBuf);",
          "108: THRIFT_DEFINE_STRING_TYPE_TO_INFO(",
          "109:     binary,",
          "110:     std::unique_ptr<folly::IOBuf>,",
          "111:     StringFieldType::IOBufPtr);",
          "113: namespace {",
          "114: constexpr TypeInfo kStopType = {protocol::TType::T_STOP,",
          "115:                                 nullptr,",
          "116:                                 nullptr,",
          "117:                                 nullptr};",
          "118: constexpr FieldInfo kStopMarker = {0, nullptr, 0, 0, &kStopType};",
          "120: template <class Protocol_>",
          "121: void skip(",
          "122:     Protocol_* iprot,",
          "123:     ProtocolReaderStructReadState<Protocol_>& readState) {",
          "124:   readState.skip(iprot);",
          "125:   readState.readFieldEnd(iprot);",
          "126:   readState.readFieldBeginNoInline(iprot);",
          "127: }",
          "129: const void* getMember(const FieldInfo& fieldInfo, const void* object) {",
          "130:   return static_cast<const char*>(object) + fieldInfo.memberOffset;",
          "131: }",
          "133: void* getMember(const FieldInfo& fieldInfo, void* object) {",
          "134:   return static_cast<char*>(object) + fieldInfo.memberOffset;",
          "135: }",
          "137: const void* maybeDerefObject(const TypeInfo& typeInfo, const void* object) {",
          "138:   return typeInfo.get",
          "139:       ? reinterpret_cast<const void* (*)(const void*)>(typeInfo.get)(object)",
          "140:       : object;",
          "141: }",
          "143: void* maybeDerefObject(const TypeInfo& typeInfo, void* object) {",
          "144:   return const_cast<void*>(",
          "145:       maybeDerefObject(typeInfo, const_cast<const void*>(object)));",
          "146: }",
          "148: template <class Protocol_>",
          "149: const FieldInfo* FOLLY_NULLABLE findFieldInfo(",
          "150:     Protocol_* iprot,",
          "151:     ProtocolReaderStructReadState<Protocol_>& readState,",
          "152:     const StructInfo& structInfo) {",
          "153:   auto* end = structInfo.fieldInfos + structInfo.numFields;",
          "154:   if (iprot->kUsesFieldNames()) {",
          "155:     const FieldInfo* found =",
          "156:         std::find_if(structInfo.fieldInfos, end, [&](const FieldInfo& val) {",
          "157:           return val.name == readState.fieldName();",
          "158:         });",
          "159:     if (found != end) {",
          "160:       readState.fieldId = found->id;",
          "161:       readState.fieldType = found->typeInfo->type;",
          "162:       if (readState.isCompatibleWithType(iprot, found->typeInfo->type)) {",
          "163:         return found;",
          "164:       }",
          "165:     }",
          "166:   } else {",
          "167:     const FieldInfo* found = std::lower_bound(",
          "168:         structInfo.fieldInfos,",
          "169:         end,",
          "170:         readState.fieldId,",
          "171:         [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });",
          "172:     if (found != end && found->id == readState.fieldId &&",
          "173:         readState.isCompatibleWithType(iprot, found->typeInfo->type)) {",
          "174:       return found;",
          "175:     }",
          "176:   }",
          "177:   return nullptr;",
          "178: }",
          "180: const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {",
          "181:   return *reinterpret_cast<const FieldID*>(",
          "182:       offset + static_cast<const char*>(object));",
          "183: }",
          "185: const bool& fieldIsSet(const void* object, ptrdiff_t offset) {",
          "186:   return *reinterpret_cast<const bool*>(",
          "187:       offset + static_cast<const char*>(object));",
          "188: }",
          "190: template <class Protocol_>",
          "191: void read(",
          "192:     Protocol_* iprot,",
          "193:     const TypeInfo& typeInfo,",
          "194:     ProtocolReaderStructReadState<Protocol_>& readState,",
          "195:     void* object) {",
          "196:   using WireTypeInfo = ProtocolReaderWireTypeInfo<Protocol_>;",
          "197:   using WireType = typename WireTypeInfo::WireType;",
          "198:   switch (typeInfo.type) {",
          "199:     case protocol::TType::T_STRUCT:",
          "200:       readState.beforeSubobject(iprot);",
          "201:       read<Protocol_>(",
          "202:           iprot,",
          "204:           maybeDerefObject(typeInfo, object));",
          "205:       readState.afterSubobject(iprot);",
          "206:       break;",
          "207:     case protocol::TType::T_I64: {",
          "208:       std::int64_t temp;",
          "209:       iprot->readI64(temp);",
          "210:       reinterpret_cast<void (*)(void*, const std::int64_t&)>(typeInfo.set)(",
          "211:           object, temp);",
          "212:       break;",
          "213:     }",
          "214:     case protocol::TType::T_I32: {",
          "215:       std::int32_t temp;",
          "216:       iprot->readI32(temp);",
          "217:       reinterpret_cast<void (*)(void*, std::int32_t)>(typeInfo.set)(",
          "218:           object, temp);",
          "219:       break;",
          "220:     }",
          "221:     case protocol::TType::T_I16: {",
          "222:       std::int16_t temp;",
          "223:       iprot->readI16(temp);",
          "224:       reinterpret_cast<void (*)(void*, std::int16_t)>(typeInfo.set)(",
          "225:           object, temp);",
          "226:       break;",
          "227:     }",
          "228:     case protocol::TType::T_BYTE: {",
          "229:       std::int8_t temp;",
          "230:       iprot->readByte(temp);",
          "231:       reinterpret_cast<void (*)(void*, std::int8_t)>(typeInfo.set)(",
          "232:           object, temp);",
          "233:       break;",
          "234:     }",
          "235:     case protocol::TType::T_BOOL: {",
          "236:       bool temp;",
          "237:       iprot->readBool(temp);",
          "238:       reinterpret_cast<void (*)(void*, bool)>(typeInfo.set)(object, temp);",
          "239:       break;",
          "240:     }",
          "241:     case protocol::TType::T_DOUBLE: {",
          "242:       double temp;",
          "243:       iprot->readDouble(temp);",
          "244:       reinterpret_cast<void (*)(void*, double)>(typeInfo.set)(object, temp);",
          "245:       break;",
          "246:     }",
          "247:     case protocol::TType::T_FLOAT: {",
          "248:       float temp;",
          "249:       iprot->readFloat(temp);",
          "250:       reinterpret_cast<void (*)(void*, float)>(typeInfo.set)(object, temp);",
          "251:       break;",
          "252:     }",
          "253:     case protocol::TType::T_STRING: {",
          "254:       switch (*static_cast<const StringFieldType*>(typeInfo.typeExt)) {",
          "255:         case StringFieldType::String:",
          "256:           iprot->readString(*static_cast<std::string*>(object));",
          "257:           break;",
          "258:         case StringFieldType::IOBuf:",
          "259:           iprot->readBinary(*static_cast<folly::IOBuf*>(object));",
          "260:           break;",
          "261:         case StringFieldType::IOBufPtr:",
          "262:           iprot->readBinary(",
          "264:           break;",
          "265:       }",
          "266:       break;",
          "267:     }",
          "268:     case protocol::TType::T_MAP: {",
          "269:       readState.beforeSubobject(iprot);",
          "271:       typeInfo.set(object);",
          "272:       auto* actualObject = maybeDerefObject(typeInfo, object);",
          "273:       const MapFieldExt& ext =",
          "275:       std::uint32_t size = ~0;",
          "276:       WireType reportedKeyType = WireTypeInfo::defaultValue();",
          "277:       WireType reportedMappedType = WireTypeInfo::defaultValue();",
          "278:       iprot->readMapBegin(reportedKeyType, reportedMappedType, size);",
          "279:       struct Context {",
          "280:         const TypeInfo* keyInfo;",
          "281:         const TypeInfo* valInfo;",
          "282:         Protocol_* iprot;",
          "283:         ProtocolReaderStructReadState<Protocol_>& readState;",
          "284:       };",
          "285:       const Context context = {",
          "286:           ext.keyInfo,",
          "287:           ext.valInfo,",
          "288:           iprot,",
          "289:           readState,",
          "290:       };",
          "291:       auto const keyReader = [](const void* context, void* key) {",
          "292:         const auto& typedContext = *static_cast<const Context*>(context);",
          "293:         read(",
          "294:             typedContext.iprot,",
          "296:             typedContext.readState,",
          "297:             key);",
          "298:       };",
          "299:       auto const valueReader = [](const void* context, void* val) {",
          "300:         const auto& typedContext = *static_cast<const Context*>(context);",
          "301:         read(",
          "302:             typedContext.iprot,",
          "304:             typedContext.readState,",
          "305:             val);",
          "306:       };",
          "307:       if (iprot->kOmitsContainerSizes()) {",
          "308:         while (iprot->peekMap()) {",
          "309:           ext.consumeElem(&context, actualObject, keyReader, valueReader);",
          "310:         }",
          "311:       } else {",
          "312:         if (size > 0 &&",
          "313:             (ext.keyInfo->type != reportedKeyType ||",
          "314:              ext.valInfo->type != reportedMappedType)) {",
          "315:           skip_n(*iprot, size, {reportedKeyType, reportedMappedType});",
          "316:         } else {",
          "317:           if (!canReadNElements(",
          "319:             protocol::TProtocolException::throwTruncatedData();",
          "320:           }",
          "321:           ext.readMap(&context, actualObject, size, keyReader, valueReader);",
          "322:         }",
          "323:       }",
          "324:       iprot->readMapEnd();",
          "325:       readState.afterSubobject(iprot);",
          "326:       break;",
          "327:     }",
          "328:     case protocol::TType::T_SET: {",
          "329:       readState.beforeSubobject(iprot);",
          "331:       typeInfo.set(object);",
          "332:       auto* actualObject = maybeDerefObject(typeInfo, object);",
          "333:       const SetFieldExt& ext =",
          "335:       std::uint32_t size = ~0;",
          "336:       WireType reportedType = WireTypeInfo::defaultValue();",
          "337:       iprot->readSetBegin(reportedType, size);",
          "338:       struct Context {",
          "339:         const TypeInfo* valInfo;",
          "340:         Protocol_* iprot;",
          "341:         ProtocolReaderStructReadState<Protocol_>& readState;",
          "342:       };",
          "343:       const Context context = {",
          "344:           ext.valInfo,",
          "345:           iprot,",
          "346:           readState,",
          "347:       };",
          "348:       auto const reader = [](const void* context, void* value) {",
          "349:         const auto& typedContext = *static_cast<const Context*>(context);",
          "350:         read(",
          "351:             typedContext.iprot,",
          "353:             typedContext.readState,",
          "354:             value);",
          "355:       };",
          "356:       if (iprot->kOmitsContainerSizes()) {",
          "357:         while (iprot->peekSet()) {",
          "358:           ext.consumeElem(&context, actualObject, reader);",
          "359:         }",
          "360:       } else {",
          "361:         if (reportedType != ext.valInfo->type) {",
          "362:           skip_n(*iprot, size, {reportedType});",
          "363:         } else {",
          "364:           if (!canReadNElements(*iprot, size, {reportedType})) {",
          "365:             protocol::TProtocolException::throwTruncatedData();",
          "366:           }",
          "367:           ext.readSet(&context, actualObject, size, reader);",
          "368:         }",
          "369:       }",
          "370:       iprot->readSetEnd();",
          "371:       readState.afterSubobject(iprot);",
          "372:       break;",
          "373:     }",
          "374:     case protocol::TType::T_LIST: {",
          "375:       readState.beforeSubobject(iprot);",
          "377:       typeInfo.set(object);",
          "378:       auto* actualObject = maybeDerefObject(typeInfo, object);",
          "379:       const ListFieldExt& ext =",
          "381:       std::uint32_t size = ~0;",
          "382:       WireType reportedType = WireTypeInfo::defaultValue();",
          "384:       iprot->readListBegin(reportedType, size);",
          "385:       struct Context {",
          "386:         const TypeInfo* valInfo;",
          "387:         Protocol_* iprot;",
          "388:         ProtocolReaderStructReadState<Protocol_>& readState;",
          "389:       };",
          "390:       const Context context = {",
          "391:           ext.valInfo,",
          "392:           iprot,",
          "393:           readState,",
          "394:       };",
          "395:       auto const reader = [](const void* context, void* value) {",
          "396:         const auto& typedContext = *static_cast<const Context*>(context);",
          "397:         read(",
          "398:             typedContext.iprot,",
          "400:             typedContext.readState,",
          "401:             value);",
          "402:       };",
          "403:       if (iprot->kOmitsContainerSizes()) {",
          "404:         while (iprot->peekList()) {",
          "405:           ext.consumeElem(&context, actualObject, reader);",
          "406:         }",
          "407:       } else {",
          "408:         if (reportedType != ext.valInfo->type) {",
          "409:           skip_n(*iprot, size, {reportedType});",
          "410:         } else {",
          "411:           if (!canReadNElements(*iprot, size, {reportedType})) {",
          "412:             protocol::TProtocolException::throwTruncatedData();",
          "413:           }",
          "414:           ext.readList(&context, actualObject, size, reader);",
          "415:         }",
          "416:       }",
          "417:       iprot->readListEnd();",
          "418:       readState.afterSubobject(iprot);",
          "419:       break;",
          "420:     }",
          "421:     case protocol::TType::T_STOP:",
          "422:     case protocol::TType::T_VOID:",
          "423:     case protocol::TType::T_UTF8:",
          "424:     case protocol::TType::T_U64:",
          "425:     case protocol::TType::T_UTF16:",
          "426:     case protocol::TType::T_STREAM:",
          "427:       skip(iprot, readState);",
          "428:   }",
          "429: }",
          "431: template <class Protocol_>",
          "432: size_t write(Protocol_* iprot, const TypeInfo& typeInfo, const void* object) {",
          "433:   switch (typeInfo.type) {",
          "434:     case protocol::TType::T_STRUCT:",
          "435:       return write(",
          "436:           iprot,",
          "438:           maybeDerefObject(typeInfo, object));",
          "439:     case protocol::TType::T_I64:",
          "440:       return iprot->writeI64(reinterpret_cast<std::int64_t (*)(const void*)>(",
          "441:           typeInfo.get)(object));",
          "442:     case protocol::TType::T_I32:",
          "443:       return iprot->writeI32(reinterpret_cast<std::int32_t (*)(const void*)>(",
          "444:           typeInfo.get)(object));",
          "445:     case protocol::TType::T_I16:",
          "446:       return iprot->writeI16(reinterpret_cast<std::int16_t (*)(const void*)>(",
          "447:           typeInfo.get)(object));",
          "448:     case protocol::TType::T_BYTE:",
          "449:       return iprot->writeByte(",
          "450:           reinterpret_cast<std::int8_t (*)(const void*)>(typeInfo.get)(object));",
          "451:     case protocol::TType::T_BOOL:",
          "452:       return iprot->writeBool(",
          "453:           reinterpret_cast<bool (*)(const void*)>(typeInfo.get)(object));",
          "454:     case protocol::TType::T_DOUBLE:",
          "455:       return iprot->writeDouble(",
          "456:           reinterpret_cast<double (*)(const void*)>(typeInfo.get)(object));",
          "457:     case protocol::TType::T_FLOAT:",
          "458:       return iprot->writeFloat(",
          "459:           reinterpret_cast<float (*)(const void*)>(typeInfo.get)(object));",
          "460:     case protocol::TType::T_STRING: {",
          "461:       switch (*static_cast<const StringFieldType*>(typeInfo.typeExt)) {",
          "462:         case StringFieldType::String:",
          "463:           return iprot->writeString(*static_cast<const std::string*>(object));",
          "464:         case StringFieldType::IOBuf:",
          "465:           return iprot->writeBinary(*static_cast<const folly::IOBuf*>(object));",
          "466:         case StringFieldType::IOBufPtr:",
          "467:           return iprot->writeBinary(",
          "469:       };",
          "470:     }",
          "471:     case protocol::TType::T_MAP: {",
          "472:       size_t written = 0;",
          "473:       auto* actualObject = maybeDerefObject(typeInfo, object);",
          "474:       const auto& ext = *static_cast<const MapFieldExt*>(typeInfo.typeExt);",
          "475:       written += iprot->writeMapBegin(",
          "476:           ext.keyInfo->type, ext.valInfo->type, ext.size(actualObject));",
          "478:       struct Context {",
          "479:         const TypeInfo* keyInfo;",
          "480:         const TypeInfo* valInfo;",
          "481:         Protocol_* iprot;",
          "482:       };",
          "483:       const Context context = {",
          "484:           ext.keyInfo,",
          "485:           ext.valInfo,",
          "486:           iprot,",
          "487:       };",
          "488:       written += ext.writeMap(",
          "489:           &context,",
          "490:           actualObject,",
          "491:           iprot->kSortKeys(),",
          "492:           [](const void* context, const void* key, const void* val) {",
          "493:             const auto& typedContext = *static_cast<const Context*>(context);",
          "494:             return write(typedContext.iprot, *typedContext.keyInfo, key) +",
          "495:                 write(typedContext.iprot, *typedContext.valInfo, val);",
          "496:           });",
          "497:       written += iprot->writeMapEnd();",
          "498:       return written;",
          "499:     }",
          "500:     case protocol::TType::T_SET: {",
          "501:       auto* actualObject = maybeDerefObject(typeInfo, object);",
          "502:       const auto& ext = *static_cast<const SetFieldExt*>(typeInfo.typeExt);",
          "503:       size_t written =",
          "504:           iprot->writeSetBegin(ext.valInfo->type, ext.size(actualObject));",
          "506:       struct Context {",
          "507:         const TypeInfo* valInfo;",
          "508:         Protocol_* iprot;",
          "509:       };",
          "510:       const Context context = {",
          "511:           ext.valInfo,",
          "512:           iprot,",
          "513:       };",
          "514:       written += ext.writeSet(",
          "515:           &context,",
          "516:           actualObject,",
          "517:           iprot->kSortKeys(),",
          "518:           [](const void* context, const void* value) {",
          "519:             const auto& typedContext = *static_cast<const Context*>(context);",
          "520:             return write(typedContext.iprot, *typedContext.valInfo, value);",
          "521:           });",
          "522:       written += iprot->writeSetEnd();",
          "523:       return written;",
          "524:     }",
          "525:     case protocol::TType::T_LIST: {",
          "526:       auto* actualObject = maybeDerefObject(typeInfo, object);",
          "527:       const auto& ext = *static_cast<const ListFieldExt*>(typeInfo.typeExt);",
          "528:       size_t written =",
          "529:           iprot->writeListBegin(ext.valInfo->type, ext.size(actualObject));",
          "531:       struct Context {",
          "532:         const TypeInfo* valInfo;",
          "533:         Protocol_* iprot;",
          "534:       };",
          "535:       const Context context = {",
          "536:           ext.valInfo,",
          "537:           iprot,",
          "538:       };",
          "539:       written += ext.writeList(",
          "540:           &context, actualObject, [](const void* context, const void* value) {",
          "541:             const auto& typedContext = *static_cast<const Context*>(context);",
          "542:             return write(typedContext.iprot, *typedContext.valInfo, value);",
          "543:           });",
          "544:       written += iprot->writeListEnd();",
          "545:       return written;",
          "546:     }",
          "547:     case protocol::TType::T_STOP:",
          "548:     case protocol::TType::T_VOID:",
          "549:     case protocol::TType::T_STREAM:",
          "550:     case protocol::TType::T_UTF8:",
          "551:     case protocol::TType::T_U64:",
          "552:     case protocol::TType::T_UTF16:",
          "553:       DCHECK(false);",
          "554:       break;",
          "555:   }",
          "556:   return 0;",
          "557: }",
          "559: template <class Protocol_>",
          "560: size_t",
          "561: writeField(Protocol_* iprot, const FieldInfo& fieldInfo, const void* object) {",
          "562:   size_t written = iprot->writeFieldBegin(",
          "563:       fieldInfo.name, fieldInfo.typeInfo->type, fieldInfo.id);",
          "564:   written += write(iprot, *fieldInfo.typeInfo, getMember(fieldInfo, object));",
          "565:   written += iprot->writeFieldEnd();",
          "566:   return written;",
          "567: }",
          "568: } // namespace",
          "570: template <class Protocol_>",
          "571: void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {",
          "572:   DCHECK(object);",
          "573:   ProtocolReaderStructReadState<Protocol_> readState;",
          "574:   readState.readStructBegin(iprot);",
          "576:   if (UNLIKELY(structInfo.unionExt != nullptr)) {",
          "577:     readState.fieldId = 0;",
          "578:     readState.readFieldBegin(iprot);",
          "579:     if (readState.atStop()) {",
          "580:       structInfo.unionExt->clear(object);",
          "581:       readState.readStructEnd(iprot);",
          "582:       return;",
          "583:     }",
          "584:     const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);",
          "586:     if (fieldInfo) {",
          "587:       void* unionVal = getMember(*fieldInfo, object);",
          "589:       structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](",
          "590:           unionVal);",
          "591:       read(iprot, *fieldInfo->typeInfo, readState, unionVal);",
          "592:       const_cast<FieldID&>(activeUnionMemberId(",
          "593:           object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;",
          "594:     } else {",
          "595:       skip(iprot, readState);",
          "596:     }",
          "597:     readState.readFieldEnd(iprot);",
          "598:     readState.readFieldBegin(iprot);",
          "599:     if (UNLIKELY(!readState.atStop())) {",
          "600:       TProtocolException::throwUnionMissingStop();",
          "601:     }",
          "602:     readState.readStructEnd(iprot);",
          "603:     return;",
          "604:   }",
          "607:   FieldID prevFieldId = 0;",
          "610:   std::int16_t index = 0;",
          "619:   for (;; ++index) {",
          "620:     auto* fieldInfo = index < structInfo.numFields",
          "621:         ? &structInfo.fieldInfos[index]",
          "622:         : &kStopMarker;",
          "624:     if (UNLIKELY(!readState.advanceToNextField(",
          "625:             iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {",
          "627:       for (;;) {",
          "628:         readState.afterAdvanceFailure(iprot);",
          "629:         if (readState.atStop()) {",
          "631:           readState.readStructEnd(iprot);",
          "632:           return;",
          "633:         }",
          "634:         fieldInfo = findFieldInfo(iprot, readState, structInfo);",
          "636:         if (fieldInfo) {",
          "638:           index = fieldInfo - structInfo.fieldInfos;",
          "639:           break;",
          "640:         }",
          "641:         skip(iprot, readState);",
          "642:       }",
          "643:     } else if (UNLIKELY(index >= structInfo.numFields)) {",
          "645:       readState.readStructEnd(iprot);",
          "646:       return;",
          "647:     }",
          "649:     prevFieldId = fieldInfo->id;",
          "650:     read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));",
          "651:     if (fieldInfo->issetOffset > 0) {",
          "652:       const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;",
          "653:     }",
          "654:   }",
          "655: }",
          "657: template <class Protocol_>",
          "658: size_t",
          "659: write(Protocol_* iprot, const StructInfo& structInfo, const void* object) {",
          "660:   DCHECK(object);",
          "661:   size_t written = iprot->writeStructBegin(structInfo.name);",
          "662:   if (UNLIKELY(structInfo.unionExt != nullptr)) {",
          "663:     const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;",
          "664:     const auto& unionId =",
          "665:         activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);",
          "666:     const FieldInfo* found = std::lower_bound(",
          "667:         structInfo.fieldInfos,",
          "668:         end,",
          "669:         unionId,",
          "670:         [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });",
          "671:     if (found < end && found->id == unionId) {",
          "672:       written += writeField(iprot, *found, object);",
          "673:     }",
          "674:   } else {",
          "675:     for (std::int16_t index = 0; index < structInfo.numFields; index++) {",
          "676:       const auto& fieldInfo = structInfo.fieldInfos[index];",
          "677:       if (fieldInfo.issetOffset == 0 ||",
          "678:           fieldIsSet(object, fieldInfo.issetOffset)) {",
          "679:         written += writeField(iprot, fieldInfo, object);",
          "680:       }",
          "681:     }",
          "682:   }",
          "684:   written += iprot->writeFieldStop();",
          "685:   written += iprot->writeStructEnd();",
          "686:   return written;",
          "687: }",
          "689: template void read<CompactProtocolReader>(",
          "690:     CompactProtocolReader* iprot,",
          "691:     const StructInfo& structInfo,",
          "692:     void* object);",
          "693: template size_t write<CompactProtocolWriter>(",
          "694:     CompactProtocolWriter* iprot,",
          "695:     const StructInfo& structInfo,",
          "696:     const void* object);",
          "697: template void read<BinaryProtocolReader>(",
          "698:     BinaryProtocolReader* iprot,",
          "699:     const StructInfo& structInfo,",
          "700:     void* object);",
          "701: template size_t write<BinaryProtocolWriter>(",
          "702:     BinaryProtocolWriter* iprot,",
          "703:     const StructInfo& structInfo,",
          "704:     const void* object);",
          "705: template void read<SimpleJSONProtocolReader>(",
          "706:     SimpleJSONProtocolReader* iprot,",
          "707:     const StructInfo& structInfo,",
          "708:     void* object);",
          "709: template size_t write<SimpleJSONProtocolWriter>(",
          "710:     SimpleJSONProtocolWriter* iprot,",
          "711:     const StructInfo& structInfo,",
          "712:     const void* object);",
          "713: } // namespace detail",
          "714: } // namespace thrift",
          "715: } // namespace apache",
          "",
          "---------------"
        ],
        "thrift/lib/cpp2/protocol/TableBasedSerializer.h||thrift/lib/cpp2/protocol/TableBasedSerializer.h": [
          "File: thrift/lib/cpp2/protocol/TableBasedSerializer.h -> thrift/lib/cpp2/protocol/TableBasedSerializer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #pragma once",
          "19: #include <algorithm>",
          "20: #include <cstdint>",
          "21: #include <iterator>",
          "22: #include <memory>",
          "23: #include <type_traits>",
          "24: #include <utility>",
          "25: #include <vector>",
          "27: #include <folly/CPortability.h>",
          "28: #include <folly/Traits.h>",
          "29: #include <folly/Utility.h>",
          "30: #include <thrift/lib/cpp/protocol/TType.h>",
          "31: #include <thrift/lib/cpp2/TypeClass.h>",
          "32: #include <thrift/lib/cpp2/protocol/Protocol.h>",
          "33: #include <thrift/lib/cpp2/protocol/detail/protocol_methods.h>",
          "35: namespace apache {",
          "36: namespace thrift {",
          "37: namespace detail {",
          "39: using FieldID = std::int16_t;",
          "40: using VoidFuncPtr = void (*)(void*);",
          "45: template <typename T>",
          "46: FOLLY_ALWAYS_INLINE constexpr T identity(T t) {",
          "47:   return t;",
          "48: }",
          "50: template <typename T>",
          "51: struct is_unique_ptr : std::false_type {};",
          "53: template <typename T>",
          "54: struct is_unique_ptr<std::unique_ptr<T>> : std::true_type {};",
          "56: template <typename T>",
          "57: struct is_shared_ptr : std::false_type {};",
          "59: template <typename T>",
          "60: struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};",
          "62: template <typename T>",
          "63: using is_smart_ptr =",
          "64:     folly::bool_constant<is_unique_ptr<T>::value || is_shared_ptr<T>::value>;",
          "66: template <typename T, typename U = void>",
          "67: using enable_if_smart_ptr_t = std::enable_if_t<is_smart_ptr<T>::value, U>;",
          "69: template <typename T, typename U = void>",
          "70: using enable_if_not_smart_ptr_t = std::enable_if_t<!is_smart_ptr<T>::value, U>;",
          "72: template <typename T, typename Enable = void>",
          "73: struct maybe_get_element_type {",
          "74:   using type = T;",
          "75: };",
          "77: template <typename T>",
          "78: struct maybe_get_element_type<T, enable_if_smart_ptr_t<T>>",
          "79:     : maybe_get_element_type<typename T::element_type> {};",
          "81: template <typename T>",
          "82: using maybe_get_element_type_t = typename maybe_get_element_type<T>::type;",
          "84: enum class StringFieldType {",
          "85:   IOBuf,",
          "86:   IOBufPtr,",
          "87:   String,",
          "88: };",
          "90: struct TypeInfo {",
          "91:   protocol::TType type;",
          "99:   VoidFuncPtr set;",
          "117:   VoidFuncPtr get;",
          "119:   const void* typeExt;",
          "120: };",
          "122: struct FieldInfo {",
          "124:   FieldID id;",
          "125:   const char* name;",
          "127:   ptrdiff_t memberOffset;",
          "130:   ptrdiff_t issetOffset;",
          "132:   const TypeInfo* typeInfo;",
          "133: };",
          "135: struct UnionExt {",
          "137:   VoidFuncPtr clear;",
          "139:   ptrdiff_t unionTypeOffset;",
          "143:   VoidFuncPtr initMember[];",
          "144: };",
          "147: template <std::int16_t NumFields>",
          "148: struct UnionExtN {",
          "149:   VoidFuncPtr clear;",
          "150:   ptrdiff_t unionTypeOffset;",
          "151:   VoidFuncPtr initMember[NumFields];",
          "152: };",
          "154: struct StructInfo {",
          "155:   std::int16_t numFields;",
          "156:   const char* name;",
          "158:   const UnionExt* unionExt = nullptr;",
          "159:   FieldInfo fieldInfos[];",
          "160: };",
          "163: template <std::int16_t NumFields>",
          "164: struct StructInfoN {",
          "165:   std::int16_t numFields = NumFields;",
          "166:   const char* name;",
          "167:   const void* unionExt = nullptr;",
          "168:   FieldInfo fieldInfos[NumFields];",
          "169: };",
          "171: struct MapFieldExt {",
          "172:   const TypeInfo* keyInfo;",
          "173:   const TypeInfo* valInfo;",
          "174:   std::uint32_t (*size)(const void* object);",
          "175:   void (*consumeElem)(",
          "176:       const void* context,",
          "177:       void* object,",
          "178:       void (*keyReader)(const void* context, void* key),",
          "179:       void (*valueReader)(const void* context, void* val));",
          "180:   void (*readMap)(",
          "181:       const void* context,",
          "182:       void* object,",
          "183:       std::uint32_t mapSize,",
          "184:       void (*keyReader)(const void* context, void* key),",
          "185:       void (*valueReader)(const void* context, void* val));",
          "186:   size_t (*writeMap)(",
          "187:       const void* context,",
          "188:       const void* object,",
          "189:       bool protocolSortKeys,",
          "190:       size_t (*writer)(",
          "191:           const void* context,",
          "192:           const void* keyElem,",
          "193:           const void* valueElem));",
          "194: };",
          "196: struct ListFieldExt {",
          "197:   const TypeInfo* valInfo;",
          "198:   std::uint32_t (*size)(const void* object);",
          "199:   void (*consumeElem)(",
          "200:       const void* context,",
          "201:       void* object,",
          "202:       void (*reader)(const void* context, void* val));",
          "203:   void (*readList)(",
          "204:       const void* context,",
          "205:       void* object,",
          "206:       std::uint32_t listSize,",
          "207:       void (*reader)(const void* context, void* val));",
          "208:   size_t (*writeList)(",
          "209:       const void* context,",
          "210:       const void* val,",
          "211:       size_t (*writer)(const void* context, const void* val));",
          "212: };",
          "214: struct SetFieldExt {",
          "215:   const TypeInfo* valInfo;",
          "216:   std::uint32_t (*size)(const void* object);",
          "217:   void (*consumeElem)(",
          "218:       const void* context,",
          "219:       void* object,",
          "220:       void (*reader)(const void* context, void* val));",
          "221:   void (*readSet)(",
          "222:       const void* context,",
          "223:       void* object,",
          "224:       std::uint32_t setSize,",
          "225:       void (*reader)(const void* context, void* val));",
          "226:   size_t (*writeSet)(",
          "227:       const void* context,",
          "228:       const void* object,",
          "229:       bool protocolSortKeys,",
          "230:       size_t (*writer)(const void* context, const void* val));",
          "231: };",
          "233: template <typename Type>",
          "234: enable_if_not_smart_ptr_t<Type> initialize(void* object) {",
          "236: }",
          "238: template <typename Type>",
          "239: std::enable_if_t<is_shared_ptr<Type>::value> initialize(void* object) {",
          "241: }",
          "243: template <typename Type>",
          "244: std::enable_if_t<is_unique_ptr<Type>::value> initialize(void* object) {",
          "246: }",
          "248: template <typename SmartPtr>",
          "249: const void* derefSmartPointer(const void* object) {",
          "250:   return static_cast<const SmartPtr*>(object)->get();",
          "251: }",
          "253: template <typename ReturnType, typename ObjectType>",
          "254: enable_if_not_smart_ptr_t<ObjectType, ReturnType> get(const void* object) {",
          "255:   return static_cast<ReturnType>(*static_cast<const ObjectType*>(object));",
          "256: }",
          "258: template <typename ReturnType, typename SmartPtr>",
          "259: enable_if_smart_ptr_t<SmartPtr, ReturnType> get(const void* object) {",
          "260:   return static_cast<ReturnType>(**static_cast<const SmartPtr*>(object));",
          "261: }",
          "263: template <typename ObjectType, typename ValueType>",
          "264: enable_if_not_smart_ptr_t<ObjectType> set(void* object, const ValueType& val) {",
          "266: }",
          "268: template <typename SmartPtr, typename ValueType>",
          "269: std::enable_if_t<is_unique_ptr<SmartPtr>::value> set(",
          "270:     void* object,",
          "271:     const ValueType& val) {",
          "272:   using Element = typename SmartPtr::element_type;",
          "274:       std::make_unique<Element>(static_cast<Element>(val));",
          "275: }",
          "277: template <typename SmartPtr, typename ValueType>",
          "278: std::enable_if_t<is_shared_ptr<SmartPtr>::value> set(",
          "279:     void* object,",
          "280:     const ValueType& val) {",
          "281:   using Element = typename SmartPtr::element_type;",
          "283:       std::make_shared<Element>(static_cast<Element>(val));",
          "284: }",
          "286: template <typename ValueType>",
          "287: enable_if_not_smart_ptr_t<ValueType> placementNewUnionValue(void* object) {",
          "288:   ::new (object) ValueType();",
          "289: }",
          "291: template <typename SmartPtr>",
          "292: enable_if_smart_ptr_t<SmartPtr> placementNewUnionValue(void* object) {",
          "293:   ::new (object) SmartPtr(new typename SmartPtr::element_type());",
          "294: }",
          "296: template <typename List>",
          "297: size_t writeList(",
          "298:     const void* context,",
          "299:     const void* object,",
          "300:     size_t (*writer)(const void* /*context*/, const void* /*val*/)) {",
          "301:   const List& out = *static_cast<const List*>(object);",
          "302:   size_t written = 0;",
          "303:   for (auto& elem : out) {",
          "304:     written += writer(context, &elem);",
          "305:   }",
          "306:   return written;",
          "307: }",
          "309: template <typename Set>",
          "310: size_t writeSet(",
          "311:     const void* context,",
          "312:     const void* object,",
          "313:     bool protocolSortKeys,",
          "314:     size_t (*writer)(const void* /*context*/, const void* /*val*/)) {",
          "315:   const Set& out = *static_cast<const Set*>(object);",
          "316:   size_t written = 0;",
          "318:   if (!folly::is_detected_v<",
          "319:           ::apache::thrift::detail::pm::detect_key_compare,",
          "320:           Set> &&",
          "321:       protocolSortKeys) {",
          "322:     std::vector<typename Set::const_iterator> iters;",
          "323:     iters.reserve(out.size());",
          "324:     for (auto it = out.begin(); it != out.end(); ++it) {",
          "325:       iters.push_back(it);",
          "326:     }",
          "327:     std::sort(",
          "328:         iters.begin(), iters.end(), [](auto a, auto b) { return *a < *b; });",
          "329:     for (auto it : iters) {",
          "330:       written += writer(context, &(*it));",
          "331:     }",
          "332:   } else {",
          "334:     using folly::order_preserving_reinsertion_view;",
          "335:     for (auto& elem : order_preserving_reinsertion_view(out)) {",
          "336:       written += writer(context, &elem);",
          "337:     }",
          "338:   }",
          "339:   return written;",
          "340: }",
          "342: template <typename Map>",
          "343: size_t writeMap(",
          "344:     const void* context,",
          "345:     const void* object,",
          "346:     bool protocolSortKeys,",
          "347:     size_t (*writer)(",
          "348:         const void* /*context*/,",
          "349:         const void* /*keyElem*/,",
          "350:         const void* /*valueElem*/)) {",
          "351:   const Map& out = *static_cast<const Map*>(object);",
          "352:   size_t written = 0;",
          "353:   if (!folly::is_detected_v<",
          "354:           ::apache::thrift::detail::pm::detect_key_compare,",
          "355:           Map> &&",
          "356:       protocolSortKeys) {",
          "357:     std::vector<typename Map::const_iterator> iters;",
          "358:     iters.reserve(out.size());",
          "359:     for (auto it = out.begin(); it != out.end(); ++it) {",
          "360:       iters.push_back(it);",
          "361:     }",
          "362:     std::sort(iters.begin(), iters.end(), [](auto a, auto b) {",
          "363:       return a->first < b->first;",
          "364:     });",
          "365:     for (auto it : iters) {",
          "366:       written += writer(context, &it->first, &it->second);",
          "367:     }",
          "368:   } else {",
          "370:     using folly::order_preserving_reinsertion_view;",
          "371:     for (auto& elem_pair : order_preserving_reinsertion_view(out)) {",
          "372:       written += writer(context, &elem_pair.first, &elem_pair.second);",
          "373:     }",
          "374:   }",
          "375:   return written;",
          "376: }",
          "378: template <typename Container>",
          "379: std::uint32_t containerSize(const void* object) {",
          "380:   return folly::to_narrow(",
          "381:       folly::to_unsigned(static_cast<const Container*>(object)->size()));",
          "382: }",
          "384: template <typename Map>",
          "385: void consumeMapElem(",
          "386:     const void* context,",
          "387:     void* object,",
          "388:     void (*keyReader)(const void* /*context*/, void* /*key*/),",
          "389:     void (*valueReader)(const void* /*context*/, void* /*val*/)) {",
          "390:   Map& out = *static_cast<Map*>(object);",
          "391:   typename Map::key_type key;",
          "392:   keyReader(context, &key);",
          "393:   valueReader(context, &out[key]);",
          "394: }",
          "396: template <typename Map>",
          "397: void readMap(",
          "398:     const void* context,",
          "399:     void* object,",
          "400:     std::uint32_t mapSize,",
          "401:     void (*keyReader)(const void* /*context*/, void* /*key*/),",
          "402:     void (*valueReader)(const void* /*context*/, void* /*val*/)) {",
          "403:   Map& out = *static_cast<Map*>(object);",
          "404:   ::apache::thrift::detail::pm::reserve_if_possible(&out, mapSize);",
          "406:   for (auto i = mapSize; i--;) {",
          "407:     typename Map::key_type key;",
          "408:     keyReader(context, &key);",
          "409:     valueReader(context, &out[key]);",
          "410:   }",
          "411: }",
          "413: template <typename List>",
          "414: void consumeListElem(",
          "415:     const void* context,",
          "416:     void* object,",
          "417:     void (*reader)(const void* /*context*/, void* /*val*/)) {",
          "418:   List& out = *static_cast<List*>(object);",
          "419:   out.emplace_back();",
          "420:   reader(context, &out.back());",
          "421: }",
          "423: template <typename Set>",
          "424: void consumeSetElem(",
          "425:     const void* context,",
          "426:     void* object,",
          "427:     void (*reader)(const void* /*context*/, void* /*val*/)) {",
          "428:   Set& out = *static_cast<Set*>(object);",
          "429:   typename Set::value_type tmp;",
          "430:   reader(context, &tmp);",
          "431:   out.insert(std::move(tmp));",
          "432: }",
          "434: template <typename Set>",
          "435: void readKnownLengthSet(",
          "436:     const void* context,",
          "437:     void* object,",
          "438:     std::uint32_t setSize,",
          "439:     void (*reader)(const void* /*context*/, void* /*val*/)) {",
          "440:   ::apache::thrift::detail::pm::reserve_if_possible(",
          "441:       static_cast<Set*>(object), setSize);",
          "443:   while (setSize--) {",
          "444:     consumeSetElem<Set>(context, object, reader);",
          "445:   }",
          "446: }",
          "448: template <typename List>",
          "449: void readList(",
          "450:     const void* context,",
          "451:     void* object,",
          "452:     std::uint32_t listSize,",
          "453:     void (*reader)(const void* /*context*/, void* /*val*/)) {",
          "454:   List& out = *static_cast<List*>(object);",
          "455:   using traits = std::iterator_traits<typename List::iterator>;",
          "456:   using cat = typename traits::iterator_category;",
          "457:   if (::apache::thrift::detail::pm::reserve_if_possible(&out, listSize) ||",
          "458:       std::is_same<cat, std::bidirectional_iterator_tag>::value) {",
          "459:     while (listSize--) {",
          "460:       consumeListElem<List>(context, object, reader);",
          "461:     }",
          "462:   } else {",
          "463:     out.resize(listSize);",
          "464:     for (auto& elem : out) {",
          "465:       reader(context, &elem);",
          "466:     }",
          "467:   }",
          "468: }",
          "470: template <typename TypeClass, typename T, typename Enable = void>",
          "471: struct TypeToInfo;",
          "473: #define THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(      \\",
          "474:     TypeClass, Type, ThriftType, TTypeValue)       \\",
          "475:   template <>                                      \\",
          "476:   struct TypeToInfo<type_class::TypeClass, Type> { \\",
          "477:     using underlying_type = ThriftType;            \\",
          "478:     static const TypeInfo typeInfo;                \\",
          "479:   }",
          "482: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "483:     integral,",
          "484:     std::int8_t,",
          "485:     std::int8_t,",
          "486:     T_BYTE);",
          "487: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "488:     integral,",
          "489:     std::int16_t,",
          "490:     std::int16_t,",
          "491:     T_I16);",
          "492: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "493:     integral,",
          "494:     std::int32_t,",
          "495:     std::int32_t,",
          "496:     T_I32);",
          "497: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "498:     integral,",
          "499:     std::int64_t,",
          "500:     std::int64_t,",
          "501:     T_I64);",
          "502: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "503:     integral,",
          "504:     std::uint8_t,",
          "505:     std::int8_t,",
          "506:     T_BYTE);",
          "507: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "508:     integral,",
          "509:     std::uint16_t,",
          "510:     std::int16_t,",
          "511:     T_I16);",
          "512: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "513:     integral,",
          "514:     std::uint32_t,",
          "515:     std::int32_t,",
          "516:     T_I32);",
          "517: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(",
          "518:     integral,",
          "519:     std::uint64_t,",
          "520:     std::int64_t,",
          "521:     T_I64);",
          "522: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(integral, bool, bool, T_BOOL);",
          "523: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, float, float, T_FLOAT);",
          "524: THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, double, double, T_DOUBLE);",
          "526: #undef THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO",
          "529: #define THRIFT_DEFINE_STRING_TYPE_TO_INFO(TypeClass, T, ExtVal) \\",
          "530:   template <>                                                   \\",
          "531:   struct TypeToInfo<type_class::TypeClass, T> {                 \\",
          "532:     static const StringFieldType ext;                           \\",
          "533:     static const TypeInfo typeInfo;                             \\",
          "534:   }",
          "536: THRIFT_DEFINE_STRING_TYPE_TO_INFO(string, std::string, StringFieldType::String);",
          "537: THRIFT_DEFINE_STRING_TYPE_TO_INFO(",
          "538:     string,",
          "539:     folly::fbstring,",
          "540:     StringFieldType::String);",
          "541: THRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, std::string, StringFieldType::String);",
          "542: THRIFT_DEFINE_STRING_TYPE_TO_INFO(",
          "543:     binary,",
          "544:     folly::fbstring,",
          "545:     StringFieldType::String);",
          "546: THRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, folly::IOBuf, StringFieldType::IOBuf);",
          "547: THRIFT_DEFINE_STRING_TYPE_TO_INFO(",
          "548:     binary,",
          "549:     std::unique_ptr<folly::IOBuf>,",
          "550:     StringFieldType::IOBufPtr);",
          "552: #undef THRIFT_DEFINE_STRING_TYPE_TO_INFO",
          "554: template <typename T>",
          "555: constexpr VoidFuncPtr getDerefFuncPtr(enable_if_not_smart_ptr_t<T, void*>) {",
          "556:   return nullptr;",
          "557: }",
          "559: template <typename T>",
          "560: constexpr VoidFuncPtr getDerefFuncPtr(enable_if_smart_ptr_t<T, void*>) {",
          "561:   return reinterpret_cast<VoidFuncPtr>(identity(derefSmartPointer<T>));",
          "562: }",
          "565: template <typename ElemTypeClass, typename T>",
          "566: struct TypeToInfo<type_class::set<ElemTypeClass>, T> {",
          "567:   using set_type = maybe_get_element_type_t<T>;",
          "568:   static const SetFieldExt ext;",
          "569:   static const TypeInfo typeInfo;",
          "570: };",
          "572: template <typename ElemTypeClass, typename T>",
          "573: const SetFieldExt TypeToInfo<type_class::set<ElemTypeClass>, T>::ext = {",
          "575:         typeInfo,",
          "580: };",
          "582: template <typename ElemTypeClass, typename T>",
          "583: const TypeInfo TypeToInfo<type_class::set<ElemTypeClass>, T>::typeInfo = {",
          "588:     &TypeToInfo<type_class::set<ElemTypeClass>, T>::ext,",
          "589: };",
          "592: template <typename ElemTypeClass, typename T>",
          "593: struct TypeToInfo<type_class::list<ElemTypeClass>, T> {",
          "594:   using list_type = maybe_get_element_type_t<T>;",
          "595:   static const ListFieldExt ext;",
          "596:   static const TypeInfo typeInfo;",
          "597: };",
          "598: template <typename ElemTypeClass, typename T>",
          "599: const ListFieldExt TypeToInfo<type_class::list<ElemTypeClass>, T>::ext = {",
          "601:         typeInfo,",
          "606: };",
          "607: template <typename ElemTypeClass, typename T>",
          "608: const TypeInfo TypeToInfo<type_class::list<ElemTypeClass>, T>::typeInfo = {",
          "613: };",
          "616: template <typename KeyTypeClass, typename ValTypeClass, typename T>",
          "617: struct TypeToInfo<type_class::map<KeyTypeClass, ValTypeClass>, T> {",
          "618:   using map_type = maybe_get_element_type_t<T>;",
          "619:   static const MapFieldExt ext;",
          "620:   static const TypeInfo typeInfo;",
          "621: };",
          "622: template <typename KeyTypeClass, typename ValTypeClass, typename T>",
          "623: const MapFieldExt",
          "624:     TypeToInfo<type_class::map<KeyTypeClass, ValTypeClass>, T>::ext = {",
          "626:             typeInfo,",
          "628:         &TypeToInfo<ValTypeClass, typename map_type::mapped_type>::typeInfo,",
          "633: };",
          "634: template <typename KeyTypeClass, typename ValTypeClass, typename T>",
          "635: const TypeInfo",
          "636:     TypeToInfo<type_class::map<KeyTypeClass, ValTypeClass>, T>::typeInfo = {",
          "641: };",
          "644: #define THRIFT_DEFINE_STRUCT_PTR_TYPE_INFO(TypeClass)                       \\",
          "645:   template <typename T>                                                     \\",
          "646:   struct TypeToInfo<type_class::TypeClass, T, enable_if_smart_ptr_t<T>> {   \\",
          "647:     static const TypeInfo typeInfo;                                         \\",
          "648:   };                                                                        \\",
          "649:                                                                             \\",
          "650:   template <typename T>                                                     \\",
          "651:   const TypeInfo TypeToInfo<                                                \\",
          "652:       type_class::TypeClass,                                                \\",
          "653:       T,                                                                    \\",
          "654:       enable_if_smart_ptr_t<T>>::typeInfo = {                               \\",
          "655:       TypeToInfo<type_class::TypeClass, typename T::element_type>::typeInfo \\",
          "656:           .type,                                                            \\",
          "657:       TypeToInfo<type_class::TypeClass, typename T::element_type>::typeInfo \\",
          "658:           .set,                                                             \\",
          "659:       reinterpret_cast<VoidFuncPtr>(identity(derefSmartPointer<T>)),        \\",
          "660:       TypeToInfo<type_class::TypeClass, typename T::element_type>::typeInfo \\",
          "661:           .typeExt,                                                         \\",
          "662:   }",
          "664: THRIFT_DEFINE_STRUCT_PTR_TYPE_INFO(structure);",
          "665: THRIFT_DEFINE_STRUCT_PTR_TYPE_INFO(variant);",
          "666: #undef THRIFT_DEFINE_STRUCT_PTR_TYPE_INFO",
          "668: template <class ThriftStruct>",
          "669: constexpr ptrdiff_t fieldOffset(std::int16_t fieldIndex);",
          "671: template <class ThriftStruct>",
          "672: constexpr ptrdiff_t issetOffset(std::int16_t fieldIndex);",
          "674: template <class ThriftUnion>",
          "675: constexpr ptrdiff_t unionTypeOffset();",
          "677: template <class Protocol_>",
          "678: void read(Protocol_* iprot, const StructInfo& structInfo, void* object);",
          "680: template <class Protocol_>",
          "681: size_t",
          "682: write(Protocol_* iprot, const StructInfo& structInfo, const void* object);",
          "684: } // namespace detail",
          "685: } // namespace thrift",
          "686: } // namespace apache",
          "",
          "---------------"
        ]
      }
    }
  ]
}
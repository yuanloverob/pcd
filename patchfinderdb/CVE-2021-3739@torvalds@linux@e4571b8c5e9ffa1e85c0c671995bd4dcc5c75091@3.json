{
  "cve_id": "CVE-2021-3739",
  "cve_desc": "A NULL pointer dereference flaw was found in the btrfs_rm_device function in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system or leak kernel internal information. The highest threat from this vulnerability is to system availability.",
  "repo": "torvalds/linux",
  "patch_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
  "patch_info": {
    "commit_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "files": [
      "fs/btrfs/volumes.c"
    ],
    "message": "btrfs: fix NULL pointer dereference when deleting device by invalid id\n\n[BUG]\nIt's easy to trigger NULL pointer dereference, just by removing a\nnon-existing device id:\n\n # mkfs.btrfs -f -m single -d single /dev/test/scratch1 \\\n\t\t\t\t     /dev/test/scratch2\n # mount /dev/test/scratch1 /mnt/btrfs\n # btrfs device remove 3 /mnt/btrfs\n\nThen we have the following kernel NULL pointer dereference:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 9 PID: 649 Comm: btrfs Not tainted 5.14.0-rc3-custom+ #35\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n RIP: 0010:btrfs_rm_device+0x4de/0x6b0 [btrfs]\n  btrfs_ioctl+0x18bb/0x3190 [btrfs]\n  ? lock_is_held_type+0xa5/0x120\n  ? find_held_lock.constprop.0+0x2b/0x80\n  ? do_user_addr_fault+0x201/0x6a0\n  ? lock_release+0xd2/0x2d0\n  ? __x64_sys_ioctl+0x83/0xb0\n  __x64_sys_ioctl+0x83/0xb0\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n[CAUSE]\nCommit a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return\nbtrfs_device directly\") moves the \"missing\" device path check into\nbtrfs_rm_device().\n\nBut btrfs_rm_device() itself can have case where it only receives\n@devid, with NULL as @device_path.\n\nIn that case, calling strcmp() on NULL will trigger the NULL pointer\ndereference.\n\nBefore that commit, we handle the \"missing\" case inside\nbtrfs_find_device_by_devspec(), which will not check @device_path at all\nif @devid is provided, thus no way to trigger the bug.\n\n[FIX]\nBefore calling strcmp(), also make sure @device_path is not NULL.\n\nFixes: a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly\")\nCC: stable@vger.kernel.org # 5.4+\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
    "before_after_code_files": [
      "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
    ]
  },
  "patch_diff": {
    "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
      "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2075:  if (IS_ERR(device)) {",
      "2076:   if (PTR_ERR(device) == -ENOENT &&",
      "2078:    ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;",
      "2079:   else",
      "2080:    ret = PTR_ERR(device);",
      "",
      "[Removed Lines]",
      "2077:       strcmp(device_path, \"missing\") == 0)",
      "",
      "[Added Lines]",
      "2077:       device_path && strcmp(device_path, \"missing\") == 0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "09dba21b432a13369d6d600941c4902237218f20",
      "candidate_info": {
        "commit_hash": "09dba21b432a13369d6d600941c4902237218f20",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/09dba21b432a13369d6d600941c4902237218f20",
        "files": [
          "net/dsa/port.c"
        ],
        "message": "net: dsa: don't call switchdev_bridge_port_unoffload for unoffloaded bridge ports\n\nFor ports that have a NULL dp->bridge_dev, dsa_port_to_bridge_port()\nalso returns NULL as expected.\n\nIssue #1 is that we are performing a NULL pointer dereference on brport_dev.\n\nIssue #2 is that these are ports on which switchdev_bridge_port_offload\nhas not been called, so we should not call switchdev_bridge_port_unoffload\non them either.\n\nBoth issues are addressed by checking against a NULL brport_dev in\ndsa_port_pre_bridge_leave and exiting early.\n\nFixes: 2f5dc00f7a3e (\"net: bridge: switchdev: let drivers inform which bridge ports are offloaded\")\nSigned-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/dsport.c||net/dsa/port.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/dsport.c||net/dsa/port.c": [
          "File: net/dsport.c -> net/dsa/port.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "377:  if (!brport_dev)",
          "378:   return;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d359902d5c357b280e7a0862bb8a1ba56b3fc197",
      "candidate_info": {
        "commit_hash": "d359902d5c357b280e7a0862bb8a1ba56b3fc197",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d359902d5c357b280e7a0862bb8a1ba56b3fc197",
        "files": [
          "net/unix/af_unix.c"
        ],
        "message": "af_unix: Fix NULL pointer bug in unix_shutdown\n\nCommit 94531cfcbe79 (\"af_unix: Add unix_stream_proto for sockmap\")\nintroduced a bug for af_unix SEQPACKET type. In unix_shutdown, the\nunhash function will call prot->unhash(), which is NULL for SEQPACKET.\nAnd kernel will panic. On ARM32, it will show following messages: (it\nlikely affects x86 too).\n\nFix the bug by checking the prot->unhash is NULL or not first.\n\nKernel log:\n<--- cut here ---\n Unable to handle kernel NULL pointer dereference at virtual address\n00000000\n pgd = 2fba1ffb\n *pgd=00000000\n Internal error: Oops: 80000005 [#1] PREEMPT SMP THUMB2\n Modules linked in:\n CPU: 1 PID: 1999 Comm: falkon Tainted: G        W\n5.14.0-rc5-01175-g94531cfcbe79-dirty #9240\n Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)\n PC is at 0x0\n LR is at unix_shutdown+0x81/0x1a8\n pc : [<00000000>]    lr : [<c08f3311>]    psr: 600f0013\n sp : e45aff70  ip : e463a3c0  fp : beb54f04\n r10: 00000125  r9 : e45ae000  r8 : c4a56664\n r7 : 00000001  r6 : c4a56464  r5 : 00000001  r4 : c4a56400\n r3 : 00000000  r2 : c5a6b180  r1 : 00000000  r0 : c4a56400\n Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n Control: 50c5387d  Table: 05aa804a  DAC: 00000051\n Register r0 information: slab PING start c4a56400 pointer offset 0\n Register r1 information: NULL pointer\n Register r2 information: slab task_struct start c5a6b180 pointer offset 0\n Register r3 information: NULL pointer\n Register r4 information: slab PING start c4a56400 pointer offset 0\n Register r5 information: non-paged memory\n Register r6 information: slab PING start c4a56400 pointer offset 100\n Register r7 information: non-paged memory\n Register r8 information: slab PING start c4a56400 pointer offset 612\n Register r9 information: non-slab/vmalloc memory\n Register r10 information: non-paged memory\n Register r11 information: non-paged memory\n Register r12 information: slab filp start e463a3c0 pointer offset 0\n Process falkon (pid: 1999, stack limit = 0x9ec48895)\n Stack: (0xe45aff70 to 0xe45b0000)\n ff60:                                     e45ae000 c5f26a00 00000000 00000125\n ff80: c0100264 c07f7fa3 beb54f04 fffffff7 00000001 e6f3fc0e b5e5e9ec beb54ec4\n ffa0: b5da0ccc c010024b b5e5e9ec beb54ec4 0000000f 00000000 00000000 beb54ebc\n ffc0: b5e5e9ec beb54ec4 b5da0ccc 00000125 beb54f58 00785238 beb5529c beb54f04\n ffe0: b5da1e24 beb54eac b301385c b62b6ee8 600f0030 0000000f 00000000 00000000\n [<c08f3311>] (unix_shutdown) from [<c07f7fa3>] (__sys_shutdown+0x2f/0x50)\n [<c07f7fa3>] (__sys_shutdown) from [<c010024b>]\n(__sys_trace_return+0x1/0x16)\n Exception stack(0xe45affa8 to 0xe45afff0)\n\nFixes: 94531cfcbe79 (\"af_unix: Add unix_stream_proto for sockmap\")\nReported-by: Dmitry Osipenko <digetx@gmail.com>\nSigned-off-by: Jiang Wang <jiang.wang@bytedance.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nTested-by: Dmitry Osipenko <digetx@gmail.com>\nAcked-by: Kuniyuki Iwashima <kuniyu@amazon.co.jp>\nLink: https://lore.kernel.org/bpf/20210821180738.1151155-1-jiang.wang@bytedance.com",
        "before_after_code_files": [
          "net/unix/af_unix.c||net/unix/af_unix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/unix/af_unix.c||net/unix/af_unix.c": [
          "File: net/unix/af_unix.c -> net/unix/af_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2847:   int peer_mode = 0;",
          "2848:   const struct proto *prot = READ_ONCE(other->sk_prot);",
          "2851:   if (mode&RCV_SHUTDOWN)",
          "2852:    peer_mode |= SEND_SHUTDOWN;",
          "2853:   if (mode&SEND_SHUTDOWN)",
          "",
          "[Removed Lines]",
          "2850:   prot->unhash(other);",
          "",
          "[Added Lines]",
          "2850:   if (prot->unhash)",
          "2851:    prot->unhash(other);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1406e8cb4b05fdc67692b1af2da39d7ca5278713",
      "candidate_info": {
        "commit_hash": "1406e8cb4b05fdc67692b1af2da39d7ca5278713",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1406e8cb4b05fdc67692b1af2da39d7ca5278713",
        "files": [
          "drivers/net/usb/asix_devices.c"
        ],
        "message": "net: usb: asix: do not call phy_disconnect() for ax88178\n\nFix crash on reboot on a system with ASIX AX88178 USB adapter attached\nto it:\n| asix 1-1.4:1.0 eth0: unregister 'asix' usb-ci_hdrc.0-1.4, ASIX AX88178 USB 2.0 Ethernet\n| 8<--- cut here ---\n| Unable to handle kernel NULL pointer dereference at virtual address 0000028c\n| pgd = 5ec93aee\n| [0000028c] *pgd=00000000\n| Internal error: Oops: 5 [#1] PREEMPT SMP ARM\n| Modules linked in:\n| CPU: 1 PID: 1 Comm: systemd-shutdow Not tainted 5.14.0-rc1-20210811-1 #4\n| Hardware name: Freescale i.MX6 Quad/DualLite (Device Tree)\n| PC is at phy_disconnect+0x8/0x48\n| LR is at ax88772_unbind+0x14/0x20\n| [<80650d04>] (phy_disconnect) from [<80741aa4>] (ax88772_unbind+0x14/0x20)\n| [<80741aa4>] (ax88772_unbind) from [<8074e250>] (usbnet_disconnect+0x48/0xd8)\n| [<8074e250>] (usbnet_disconnect) from [<807655e0>] (usb_unbind_interface+0x78/0x25c)\n| [<807655e0>] (usb_unbind_interface) from [<805b03a0>] (__device_release_driver+0x154/0x20c)\n| [<805b03a0>] (__device_release_driver) from [<805b0478>] (device_release_driver+0x20/0x2c)\n| [<805b0478>] (device_release_driver) from [<805af944>] (bus_remove_device+0xcc/0xf8)\n| [<805af944>] (bus_remove_device) from [<805ab26c>] (device_del+0x178/0x4b0)\n| [<805ab26c>] (device_del) from [<807634a4>] (usb_disable_device+0xcc/0x178)\n| [<807634a4>] (usb_disable_device) from [<8075a060>] (usb_disconnect+0xd8/0x238)\n| [<8075a060>] (usb_disconnect) from [<8075a02c>] (usb_disconnect+0xa4/0x238)\n| [<8075a02c>] (usb_disconnect) from [<8075a02c>] (usb_disconnect+0xa4/0x238)\n| [<8075a02c>] (usb_disconnect) from [<80af3520>] (usb_remove_hcd+0xa0/0x198)\n| [<80af3520>] (usb_remove_hcd) from [<807902e0>] (host_stop+0x38/0xa8)\n| [<807902e0>] (host_stop) from [<8078d9e4>] (ci_hdrc_remove+0x3c/0x118)\n| [<8078d9e4>] (ci_hdrc_remove) from [<805b27ec>] (platform_remove+0x20/0x50)\n| [<805b27ec>] (platform_remove) from [<805b03a0>] (__device_release_driver+0x154/0x20c)\n| [<805b03a0>] (__device_release_driver) from [<805b0478>] (device_release_driver+0x20/0x2c)\n| [<805b0478>] (device_release_driver) from [<805af944>] (bus_remove_device+0xcc/0xf8)\n| [<805af944>] (bus_remove_device) from [<805ab26c>] (device_del+0x178/0x4b0)\n\nFor this adapter we call ax88178_bind() and ax88772_unbind(), which is\nrelated to different chip version and different counter part *bind()\nfunction.\n\nSince this chip is currently not ported to the PHYLIB, we do not need to\ncall phy_disconnect() here. So, to fix this crash, we need to add\nax88178_unbind().\n\nFixes: e532a096be0e (\"net: usb: asix: ax88772: add phylib support\")\nReported-by: Robin van der Gracht <robin@protonic.nl>\nTested-by: Robin van der Gracht <robin@protonic.nl>\nSigned-off-by: Oleksij Rempel <o.rempel@pengutronix.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/usb/asix_devices.c||drivers/net/usasix_devices.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/usb/asix_devices.c||drivers/net/usasix_devices.c": [
          "File: drivers/net/usb/asix_devices.c -> drivers/net/usasix_devices.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "816:  asix_rx_fixup_common_free(dev->driver_priv);",
          "817: }",
          "819: static const struct ethtool_ops ax88178_ethtool_ops = {",
          "820:  .get_drvinfo  = asix_get_drvinfo,",
          "821:  .get_link  = asix_get_link,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1224: static const struct driver_info ax88178_info = {",
          "1225:  .description = \"ASIX AX88178 USB 2.0 Ethernet\",",
          "1226:  .bind = ax88178_bind,",
          "1228:  .status = asix_status,",
          "1229:  .link_reset = ax88178_link_reset,",
          "1230:  .reset = ax88178_reset,",
          "",
          "[Removed Lines]",
          "1227:  .unbind = ax88772_unbind,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "21e39809fd7c4b8ff3662f23e0168e87594c8ca8",
      "candidate_info": {
        "commit_hash": "21e39809fd7c4b8ff3662f23e0168e87594c8ca8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/21e39809fd7c4b8ff3662f23e0168e87594c8ca8",
        "files": [
          "drivers/regulator/vctrl-regulator.c"
        ],
        "message": "regulator: vctrl: Avoid lockdep warning in enable/disable ops\n\nvctrl_enable() and vctrl_disable() call regulator_enable() and\nregulator_disable(), respectively. However, vctrl_* are regulator ops\nand should not be calling the locked regulator APIs. Doing so results in\na lockdep warning.\n\nInstead of exporting more internal regulator ops, model the ctrl supply\nas an actual supply to vctrl-regulator. At probe time this driver still\nneeds to use the consumer API to fetch its constraints, but otherwise\nlets the regulator core handle the upstream supply for it.\n\nThe enable/disable/is_enabled ops are not removed, but now only track\nstate internally. This preserves the original behavior with the ops\nbeing available, but one could argue that the original behavior was\nalready incorrect: the internal state would not match the upstream\nsupply if that supply had another consumer that enabled the supply,\nwhile vctrl-regulator was not enabled.\n\nThe lockdep warning is as follows:\n\n\tWARNING: possible circular locking dependency detected\n\t5.14.0-rc6 #2 Not tainted\n\t------------------------------------------------------\n\tswapper/0/1 is trying to acquire lock:\n\tffffffc011306d00 (regulator_list_mutex){+.+.}-{3:3}, at:\n\t\tregulator_lock_dependent (arch/arm64/include/asm/current.h:19\n\t\t\t\t\t  include/linux/ww_mutex.h:111\n\t\t\t\t\t  drivers/regulator/core.c:329)\n\n\tbut task is already holding lock:\n\tffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:\n\t\tregulator_lock_recursive (drivers/regulator/core.c:156\n\t\t\t\t\t  drivers/regulator/core.c:263)\n\n\twhich lock already depends on the new lock.\n\n\tthe existing dependency chain (in reverse order) is:\n\n\t-> #2 (regulator_ww_class_mutex){+.+.}-{3:3}:\n\t__mutex_lock_common (include/asm-generic/atomic-instrumented.h:606\n\t\t\t     include/asm-generic/atomic-long.h:29\n\t\t\t     kernel/locking/mutex.c:103\n\t\t\t     kernel/locking/mutex.c:144\n\t\t\t     kernel/locking/mutex.c:963)\n\tww_mutex_lock (kernel/locking/mutex.c:1199)\n\tregulator_lock_recursive (drivers/regulator/core.c:156\n\t\t\t\t  drivers/regulator/core.c:263)\n\tregulator_lock_dependent (drivers/regulator/core.c:343)\n\tregulator_enable (drivers/regulator/core.c:2808)\n\tset_machine_constraints (drivers/regulator/core.c:1536)\n\tregulator_register (drivers/regulator/core.c:5486)\n\tdevm_regulator_register (drivers/regulator/devres.c:196)\n\treg_fixed_voltage_probe (drivers/regulator/fixed.c:289)\n\tplatform_probe (drivers/base/platform.c:1427)\n\t[...]\n\n\t-> #1 (regulator_ww_class_acquire){+.+.}-{0:0}:\n\tregulator_lock_dependent (include/linux/ww_mutex.h:129\n\t\t\t\t  drivers/regulator/core.c:329)\n\tregulator_enable (drivers/regulator/core.c:2808)\n\tset_machine_constraints (drivers/regulator/core.c:1536)\n\tregulator_register (drivers/regulator/core.c:5486)\n\tdevm_regulator_register (drivers/regulator/devres.c:196)\n\treg_fixed_voltage_probe (drivers/regulator/fixed.c:289)\n\t[...]\n\n\t-> #0 (regulator_list_mutex){+.+.}-{3:3}:\n\t__lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)\n\t\t\tkernel/locking/lockdep.c:3174 (discriminator 4)\n\t\t\tkernel/locking/lockdep.c:3789 (discriminator 4)\n\t\t\tkernel/locking/lockdep.c:5015 (discriminator 4))\n\tlock_acquire (arch/arm64/include/asm/percpu.h:39\n\t\t      kernel/locking/lockdep.c:438\n\t\t      kernel/locking/lockdep.c:5627)\n\t__mutex_lock_common (include/asm-generic/atomic-instrumented.h:606\n\t\t\t     include/asm-generic/atomic-long.h:29\n\t\t\t     kernel/locking/mutex.c:103\n\t\t\t     kernel/locking/mutex.c:144\n\t\t\t     kernel/locking/mutex.c:963)\n\tmutex_lock_nested (kernel/locking/mutex.c:1125)\n\tregulator_lock_dependent (arch/arm64/include/asm/current.h:19\n\t\t\t\t  include/linux/ww_mutex.h:111\n\t\t\t\t  drivers/regulator/core.c:329)\n\tregulator_enable (drivers/regulator/core.c:2808)\n\tvctrl_enable (drivers/regulator/vctrl-regulator.c:400)\n\t_regulator_do_enable (drivers/regulator/core.c:2617)\n\t_regulator_enable (drivers/regulator/core.c:2764)\n\tregulator_enable (drivers/regulator/core.c:308\n\t\t\t  drivers/regulator/core.c:2809)\n\t_set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)\n\tdev_pm_opp_set_rate (drivers/opp/core.c:1164)\n\tset_target (drivers/cpufreq/cpufreq-dt.c:62)\n\t__cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216\n\t\t\t\t drivers/cpufreq/cpufreq.c:2271)\n\tcpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))\n\tcpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)\n\tsubsys_interface_register (drivers/base/bus.c:?)\n\tcpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)\n\tdt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)\n\t[...]\n\n\tother info that might help us debug this:\n\n\tChain exists of:\n\t  regulator_list_mutex --> regulator_ww_class_acquire --> regulator_ww_class_mutex\n\n\t Possible unsafe locking scenario:\n\n\t       CPU0                    CPU1\n\t       ----                    ----\n\t  lock(regulator_ww_class_mutex);\n\t\t\t\t       lock(regulator_ww_class_acquire);\n\t\t\t\t       lock(regulator_ww_class_mutex);\n\t  lock(regulator_list_mutex);\n\n\t *** DEADLOCK ***\n\n\t6 locks held by swapper/0/1:\n\t#0: ffffff8002d32188 (&dev->mutex){....}-{3:3}, at:\n\t\t__device_driver_lock (drivers/base/dd.c:1030)\n\t#1: ffffffc0111a0520 (cpu_hotplug_lock){++++}-{0:0}, at:\n\t\tcpufreq_register_driver (drivers/cpufreq/cpufreq.c:2792 (discriminator 2))\n\t#2: ffffff8002a8d918 (subsys mutex#9){+.+.}-{3:3}, at:\n\t\tsubsys_interface_register (drivers/base/bus.c:1033)\n\t#3: ffffff800341bb90 (&policy->rwsem){+.+.}-{3:3}, at:\n\t\tcpufreq_online (include/linux/bitmap.h:285\n\t\t\t\tinclude/linux/cpumask.h:405\n\t\t\t\tdrivers/cpufreq/cpufreq.c:1399)\n\t#4: ffffffc011f0b7b8 (regulator_ww_class_acquire){+.+.}-{0:0}, at:\n\t\tregulator_enable (drivers/regulator/core.c:2808)\n\t#5: ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:\n\t\tregulator_lock_recursive (drivers/regulator/core.c:156\n\t\tdrivers/regulator/core.c:263)\n\n\tstack backtrace:\n\tCPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.14.0-rc6 #2 7c8f8996d021ed0f65271e6aeebf7999de74a9fa\n\tHardware name: Google Scarlet (DT)\n\tCall trace:\n\tdump_backtrace (arch/arm64/kernel/stacktrace.c:161)\n\tshow_stack (arch/arm64/kernel/stacktrace.c:218)\n\tdump_stack_lvl (lib/dump_stack.c:106 (discriminator 2))\n\tdump_stack (lib/dump_stack.c:113)\n\tprint_circular_bug (kernel/locking/lockdep.c:?)\n\tcheck_noncircular (kernel/locking/lockdep.c:?)\n\t__lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)\n\t\t\tkernel/locking/lockdep.c:3174 (discriminator 4)\n\t\t\tkernel/locking/lockdep.c:3789 (discriminator 4)\n\t\t\tkernel/locking/lockdep.c:5015 (discriminator 4))\n\tlock_acquire (arch/arm64/include/asm/percpu.h:39\n\t\t      kernel/locking/lockdep.c:438\n\t\t      kernel/locking/lockdep.c:5627)\n\t__mutex_lock_common (include/asm-generic/atomic-instrumented.h:606\n\t\t\t     include/asm-generic/atomic-long.h:29\n\t\t\t     kernel/locking/mutex.c:103\n\t\t\t     kernel/locking/mutex.c:144\n\t\t\t     kernel/locking/mutex.c:963)\n\tmutex_lock_nested (kernel/locking/mutex.c:1125)\n\tregulator_lock_dependent (arch/arm64/include/asm/current.h:19\n\t\t\t\t  include/linux/ww_mutex.h:111\n\t\t\t\t  drivers/regulator/core.c:329)\n\tregulator_enable (drivers/regulator/core.c:2808)\n\tvctrl_enable (drivers/regulator/vctrl-regulator.c:400)\n\t_regulator_do_enable (drivers/regulator/core.c:2617)\n\t_regulator_enable (drivers/regulator/core.c:2764)\n\tregulator_enable (drivers/regulator/core.c:308\n\t\t\t  drivers/regulator/core.c:2809)\n\t_set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)\n\tdev_pm_opp_set_rate (drivers/opp/core.c:1164)\n\tset_target (drivers/cpufreq/cpufreq-dt.c:62)\n\t__cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216\n\t\t\t\t drivers/cpufreq/cpufreq.c:2271)\n\tcpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))\n\tcpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)\n\tsubsys_interface_register (drivers/base/bus.c:?)\n\tcpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)\n\tdt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)\n\t[...]\n\nReported-by: Brian Norris <briannorris@chromium.org>\nFixes: f8702f9e4aa7 (\"regulator: core: Use ww_mutex for regulators locking\")\nFixes: e9153311491d (\"regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage\")\nSigned-off-by: Chen-Yu Tsai <wenst@chromium.org>\nLink: https://lore.kernel.org/r/20210825033704.3307263-3-wenst@chromium.org\nSigned-off-by: Mark Brown <broonie@kernel.org>",
        "before_after_code_files": [
          "drivers/regulator/vctrl-regulator.c||drivers/regulator/vctrl-regulator.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/regulator/vctrl-regulator.c||drivers/regulator/vctrl-regulator.c": [
          "File: drivers/regulator/vctrl-regulator.c -> drivers/regulator/vctrl-regulator.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: struct vctrl_data {",
          "38:  struct regulator_dev *rdev;",
          "39:  struct regulator_desc desc;",
          "41:  bool enabled;",
          "42:  unsigned int min_slew_down_rate;",
          "43:  unsigned int ovp_threshold;",
          "",
          "[Removed Lines]",
          "40:  struct regulator *ctrl_reg;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82: static int vctrl_get_voltage(struct regulator_dev *rdev)",
          "83: {",
          "84:  struct vctrl_data *vctrl = rdev_get_drvdata(rdev);",
          "87:  return vctrl_calc_output_voltage(vctrl, ctrl_uV);",
          "88: }",
          "",
          "[Removed Lines]",
          "85:  int ctrl_uV = regulator_get_voltage_rdev(vctrl->ctrl_reg->rdev);",
          "",
          "[Added Lines]",
          "84:  int ctrl_uV;",
          "86:  if (!rdev->supply)",
          "87:   return -EPROBE_DEFER;",
          "89:  ctrl_uV = regulator_get_voltage_rdev(rdev->supply->rdev);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:         unsigned int *selector)",
          "93: {",
          "94:  struct vctrl_data *vctrl = rdev_get_drvdata(rdev);",
          "98:  int ret;",
          "100:  if (req_min_uV >= uV || !vctrl->ovp_threshold)",
          "103:    vctrl_calc_ctrl_voltage(vctrl, req_min_uV),",
          "104:    vctrl_calc_ctrl_voltage(vctrl, req_max_uV),",
          "105:    PM_SUSPEND_ON);",
          "",
          "[Removed Lines]",
          "95:  struct regulator *ctrl_reg = vctrl->ctrl_reg;",
          "96:  int orig_ctrl_uV = regulator_get_voltage_rdev(ctrl_reg->rdev);",
          "97:  int uV = vctrl_calc_output_voltage(vctrl, orig_ctrl_uV);",
          "102:   return regulator_set_voltage_rdev(ctrl_reg->rdev,",
          "",
          "[Added Lines]",
          "99:  int orig_ctrl_uV;",
          "100:  int uV;",
          "103:  if (!rdev->supply)",
          "104:   return -EPROBE_DEFER;",
          "106:  orig_ctrl_uV = regulator_get_voltage_rdev(rdev->supply->rdev);",
          "107:  uV = vctrl_calc_output_voltage(vctrl, orig_ctrl_uV);",
          "111:   return regulator_set_voltage_rdev(rdev->supply->rdev,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "117:   next_uV = max_t(int, req_min_uV, uV - max_drop_uV);",
          "118:   next_ctrl_uV = vctrl_calc_ctrl_voltage(vctrl, next_uV);",
          "121:          next_ctrl_uV,",
          "122:          next_ctrl_uV,",
          "123:          PM_SUSPEND_ON);",
          "",
          "[Removed Lines]",
          "120:   ret = regulator_set_voltage_rdev(ctrl_reg->rdev,",
          "",
          "[Added Lines]",
          "129:   ret = regulator_set_voltage_rdev(rdev->supply->rdev,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "135: err:",
          "138:        PM_SUSPEND_ON);",
          "140:  return ret;",
          "",
          "[Removed Lines]",
          "137:  regulator_set_voltage_rdev(ctrl_reg->rdev, orig_ctrl_uV, orig_ctrl_uV,",
          "",
          "[Added Lines]",
          "146:  regulator_set_voltage_rdev(rdev->supply->rdev, orig_ctrl_uV, orig_ctrl_uV,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "151:      unsigned int selector)",
          "152: {",
          "153:  struct vctrl_data *vctrl = rdev_get_drvdata(rdev);",
          "155:  unsigned int orig_sel = vctrl->sel;",
          "156:  int ret;",
          "158:  if (selector >= rdev->desc->n_voltages)",
          "159:   return -EINVAL;",
          "161:  if (selector >= vctrl->sel || !vctrl->ovp_threshold) {",
          "164:          vctrl->vtable[selector].ctrl,",
          "165:          vctrl->vtable[selector].ctrl,",
          "166:          PM_SUSPEND_ON);",
          "",
          "[Removed Lines]",
          "154:  struct regulator *ctrl_reg = vctrl->ctrl_reg;",
          "163:   ret = regulator_set_voltage_rdev(ctrl_reg->rdev,",
          "",
          "[Added Lines]",
          "166:  if (!rdev->supply)",
          "167:   return -EPROBE_DEFER;",
          "174:   ret = regulator_set_voltage_rdev(rdev->supply->rdev,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "179:   else",
          "180:    next_sel = vctrl->vtable[vctrl->sel].ovp_min_sel;",
          "183:          vctrl->vtable[next_sel].ctrl,",
          "184:          vctrl->vtable[next_sel].ctrl,",
          "185:          PM_SUSPEND_ON);",
          "",
          "[Removed Lines]",
          "182:   ret = regulator_set_voltage_rdev(ctrl_reg->rdev,",
          "",
          "[Added Lines]",
          "193:   ret = regulator_set_voltage_rdev(rdev->supply->rdev,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "202: err:",
          "203:  if (vctrl->sel != orig_sel) {",
          "206:         vctrl->vtable[orig_sel].ctrl,",
          "207:         vctrl->vtable[orig_sel].ctrl,",
          "208:         PM_SUSPEND_ON))",
          "",
          "[Removed Lines]",
          "205:   if (!regulator_set_voltage_rdev(ctrl_reg->rdev,",
          "",
          "[Added Lines]",
          "216:   if (!regulator_set_voltage_rdev(rdev->supply->rdev,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "234:  u32 pval;",
          "235:  u32 vrange_ctrl[2];",
          "241:  ret = of_property_read_u32(np, \"ovp-threshold-percent\", &pval);",
          "242:  if (!ret) {",
          "243:   vctrl->ovp_threshold = pval;",
          "",
          "[Removed Lines]",
          "237:  vctrl->ctrl_reg = devm_regulator_get(&pdev->dev, \"ctrl\");",
          "238:  if (IS_ERR(vctrl->ctrl_reg))",
          "239:   return PTR_ERR(vctrl->ctrl_reg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "315:  return at->ctrl - bt->ctrl;",
          "316: }",
          "319: {",
          "320:  struct vctrl_data *vctrl = platform_get_drvdata(pdev);",
          "321:  struct regulator_desc *rdesc = &vctrl->desc;",
          "323:  struct vctrl_voltage_range *vrange_ctrl = &vctrl->vrange.ctrl;",
          "324:  int n_voltages;",
          "325:  int ctrl_uV;",
          "",
          "[Removed Lines]",
          "318: static int vctrl_init_vtable(struct platform_device *pdev)",
          "322:  struct regulator *ctrl_reg = vctrl->ctrl_reg;",
          "",
          "[Added Lines]",
          "325: static int vctrl_init_vtable(struct platform_device *pdev,",
          "326:         struct regulator *ctrl_reg)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "395: static int vctrl_enable(struct regulator_dev *rdev)",
          "396: {",
          "397:  struct vctrl_data *vctrl = rdev_get_drvdata(rdev);",
          "404: }",
          "406: static int vctrl_disable(struct regulator_dev *rdev)",
          "407: {",
          "408:  struct vctrl_data *vctrl = rdev_get_drvdata(rdev);",
          "415: }",
          "417: static int vctrl_is_enabled(struct regulator_dev *rdev)",
          "",
          "[Removed Lines]",
          "398:  int ret = regulator_enable(vctrl->ctrl_reg);",
          "400:  if (!ret)",
          "401:   vctrl->enabled = true;",
          "403:  return ret;",
          "409:  int ret = regulator_disable(vctrl->ctrl_reg);",
          "411:  if (!ret)",
          "412:   vctrl->enabled = false;",
          "414:  return ret;",
          "",
          "[Added Lines]",
          "406:  vctrl->enabled = true;",
          "408:  return 0;",
          "415:  vctrl->enabled = false;",
          "417:  return 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "447:  struct regulator_desc *rdesc;",
          "448:  struct regulator_config cfg = { };",
          "449:  struct vctrl_voltage_range *vrange_ctrl;",
          "450:  int ctrl_uV;",
          "451:  int ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "453:  struct regulator *ctrl_reg;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "461:  if (ret)",
          "462:   return ret;",
          "464:  vrange_ctrl = &vctrl->vrange.ctrl;",
          "466:  rdesc = &vctrl->desc;",
          "467:  rdesc->name = \"vctrl\";",
          "468:  rdesc->type = REGULATOR_VOLTAGE;",
          "469:  rdesc->owner = THIS_MODULE;",
          "473:   rdesc->continuous_voltage_range = true;",
          "474:   rdesc->ops = &vctrl_ops_cont;",
          "475:  } else {",
          "",
          "[Removed Lines]",
          "471:  if ((regulator_get_linear_step(vctrl->ctrl_reg) == 1) ||",
          "472:      (regulator_count_voltages(vctrl->ctrl_reg) == -EINVAL)) {",
          "",
          "[Added Lines]",
          "468:  ctrl_reg = devm_regulator_get(&pdev->dev, \"ctrl\");",
          "469:  if (IS_ERR(ctrl_reg))",
          "470:   return PTR_ERR(ctrl_reg);",
          "478:  rdesc->supply_name = \"ctrl\";",
          "480:  if ((regulator_get_linear_step(ctrl_reg) == 1) ||",
          "481:      (regulator_count_voltages(ctrl_reg) == -EINVAL)) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "486:  cfg.init_data = init_data;",
          "488:  if (!rdesc->continuous_voltage_range) {",
          "490:   if (ret)",
          "491:    return ret;",
          "495:   if (ctrl_uV < 0) {",
          "496:    dev_err(&pdev->dev, \"failed to get control voltage\\n\");",
          "497:    return ctrl_uV;",
          "",
          "[Removed Lines]",
          "489:   ret = vctrl_init_vtable(pdev);",
          "494:   ctrl_uV = regulator_get_voltage(vctrl->ctrl_reg);",
          "",
          "[Added Lines]",
          "498:   ret = vctrl_init_vtable(pdev, ctrl_reg);",
          "503:   ctrl_uV = regulator_get_voltage(ctrl_reg);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "514:   }",
          "515:  }",
          "517:  vctrl->rdev = devm_regulator_register(&pdev->dev, rdesc, &cfg);",
          "518:  if (IS_ERR(vctrl->rdev)) {",
          "519:   ret = PTR_ERR(vctrl->rdev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "527:  devm_regulator_put(ctrl_reg);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1a15eb724aaef8656f8cc01d9355797cfe7c618e",
      "candidate_info": {
        "commit_hash": "1a15eb724aaef8656f8cc01d9355797cfe7c618e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1a15eb724aaef8656f8cc01d9355797cfe7c618e",
        "files": [
          "fs/btrfs/ioctl.c",
          "fs/btrfs/volumes.c",
          "fs/btrfs/volumes.h"
        ],
        "message": "btrfs: use btrfs_get_dev_args_from_path in dev removal ioctls\n\nFor device removal and replace we call btrfs_find_device_by_devspec,\nwhich if we give it a device path and nothing else will call\nbtrfs_get_dev_args_from_path, which opens the block device and reads the\nsuper block and then looks up our device based on that.\n\nHowever at this point we're holding the sb write \"lock\", so reading the\nblock device pulls in the dependency of ->open_mutex, which produces the\nfollowing lockdep splat\n\n======================================================\nWARNING: possible circular locking dependency detected\n5.14.0-rc2+ #405 Not tainted\n------------------------------------------------------\nlosetup/11576 is trying to acquire lock:\nffff9bbe8cded938 ((wq_completion)loop0){+.+.}-{0:0}, at: flush_workqueue+0x67/0x5e0\n\nbut task is already holding lock:\nffff9bbe88e4fc68 (&lo->lo_mutex){+.+.}-{3:3}, at: __loop_clr_fd+0x41/0x660 [loop]\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #4 (&lo->lo_mutex){+.+.}-{3:3}:\n       __mutex_lock+0x7d/0x750\n       lo_open+0x28/0x60 [loop]\n       blkdev_get_whole+0x25/0xf0\n       blkdev_get_by_dev.part.0+0x168/0x3c0\n       blkdev_open+0xd2/0xe0\n       do_dentry_open+0x161/0x390\n       path_openat+0x3cc/0xa20\n       do_filp_open+0x96/0x120\n       do_sys_openat2+0x7b/0x130\n       __x64_sys_openat+0x46/0x70\n       do_syscall_64+0x38/0x90\n       entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n-> #3 (&disk->open_mutex){+.+.}-{3:3}:\n       __mutex_lock+0x7d/0x750\n       blkdev_get_by_dev.part.0+0x56/0x3c0\n       blkdev_get_by_path+0x98/0xa0\n       btrfs_get_bdev_and_sb+0x1b/0xb0\n       btrfs_find_device_by_devspec+0x12b/0x1c0\n       btrfs_rm_device+0x127/0x610\n       btrfs_ioctl+0x2a31/0x2e70\n       __x64_sys_ioctl+0x80/0xb0\n       do_syscall_64+0x38/0x90\n       entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n-> #2 (sb_writers#12){.+.+}-{0:0}:\n       lo_write_bvec+0xc2/0x240 [loop]\n       loop_process_work+0x238/0xd00 [loop]\n       process_one_work+0x26b/0x560\n       worker_thread+0x55/0x3c0\n       kthread+0x140/0x160\n       ret_from_fork+0x1f/0x30\n\n-> #1 ((work_completion)(&lo->rootcg_work)){+.+.}-{0:0}:\n       process_one_work+0x245/0x560\n       worker_thread+0x55/0x3c0\n       kthread+0x140/0x160\n       ret_from_fork+0x1f/0x30\n\n-> #0 ((wq_completion)loop0){+.+.}-{0:0}:\n       __lock_acquire+0x10ea/0x1d90\n       lock_acquire+0xb5/0x2b0\n       flush_workqueue+0x91/0x5e0\n       drain_workqueue+0xa0/0x110\n       destroy_workqueue+0x36/0x250\n       __loop_clr_fd+0x9a/0x660 [loop]\n       block_ioctl+0x3f/0x50\n       __x64_sys_ioctl+0x80/0xb0\n       do_syscall_64+0x38/0x90\n       entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nother info that might help us debug this:\n\nChain exists of:\n  (wq_completion)loop0 --> &disk->open_mutex --> &lo->lo_mutex\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&lo->lo_mutex);\n                               lock(&disk->open_mutex);\n                               lock(&lo->lo_mutex);\n  lock((wq_completion)loop0);\n\n *** DEADLOCK ***\n\n1 lock held by losetup/11576:\n #0: ffff9bbe88e4fc68 (&lo->lo_mutex){+.+.}-{3:3}, at: __loop_clr_fd+0x41/0x660 [loop]\n\nstack backtrace:\nCPU: 0 PID: 11576 Comm: losetup Not tainted 5.14.0-rc2+ #405\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014\nCall Trace:\n dump_stack_lvl+0x57/0x72\n check_noncircular+0xcf/0xf0\n ? stack_trace_save+0x3b/0x50\n __lock_acquire+0x10ea/0x1d90\n lock_acquire+0xb5/0x2b0\n ? flush_workqueue+0x67/0x5e0\n ? lockdep_init_map_type+0x47/0x220\n flush_workqueue+0x91/0x5e0\n ? flush_workqueue+0x67/0x5e0\n ? verify_cpu+0xf0/0x100\n drain_workqueue+0xa0/0x110\n destroy_workqueue+0x36/0x250\n __loop_clr_fd+0x9a/0x660 [loop]\n ? blkdev_ioctl+0x8d/0x2a0\n block_ioctl+0x3f/0x50\n __x64_sys_ioctl+0x80/0xb0\n do_syscall_64+0x38/0x90\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f31b02404cb\n\nInstead what we want to do is populate our device lookup args before we\ngrab any locks, and then pass these args into btrfs_rm_device().  From\nthere we can find the device and do the appropriate removal.\n\nSuggested-by: Anand Jain <anand.jain@oracle.com>\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c",
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
          "fs/btrfs/volumes.h||fs/btrfs/volumes.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ],
          "candidate": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c": [
          "File: fs/btrfs/ioctl.c -> fs/btrfs/ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3161: static long btrfs_ioctl_rm_dev_v2(struct file *file, void __user *arg)",
          "3162: {",
          "3163:  struct inode *inode = file_inode(file);",
          "3164:  struct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);",
          "3165:  struct btrfs_ioctl_vol_args_v2 *vol_args;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3163:  BTRFS_DEV_LOOKUP_ARGS(args);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3171:  if (!capable(CAP_SYS_ADMIN))",
          "3172:   return -EPERM;",
          "3178:  vol_args = memdup_user(arg, sizeof(*vol_args));",
          "3179:  if (IS_ERR(vol_args)) {",
          "3180:   ret = PTR_ERR(vol_args);",
          "3182:  }",
          "3184:  if (vol_args->flags & ~BTRFS_DEVICE_REMOVE_ARGS_MASK) {",
          "3185:   ret = -EOPNOTSUPP;",
          "3186:   goto out;",
          "3187:  }",
          "3188:  vol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';",
          "3191:   cancel = true;",
          "3193:  ret = exclop_start_or_cancel_reloc(fs_info, BTRFS_EXCLOP_DEV_REMOVE,",
          "3194:         cancel);",
          "3195:  if (ret)",
          "3204:  btrfs_exclop_finish(fs_info);",
          "",
          "[Removed Lines]",
          "3174:  ret = mnt_want_write_file(file);",
          "3175:  if (ret)",
          "3176:   return ret;",
          "3181:   goto err_drop;",
          "3189:  if (!(vol_args->flags & BTRFS_DEVICE_SPEC_BY_ID) &&",
          "3190:      strcmp(\"cancel\", vol_args->name) == 0)",
          "3196:   goto out;",
          "3199:  if (vol_args->flags & BTRFS_DEVICE_SPEC_BY_ID)",
          "3200:   ret = btrfs_rm_device(fs_info, NULL, vol_args->devid, &bdev, &mode);",
          "3201:  else",
          "3202:   ret = btrfs_rm_device(fs_info, vol_args->name, 0, &bdev, &mode);",
          "",
          "[Added Lines]",
          "3178:   goto out;",
          "3187:  if (vol_args->flags & BTRFS_DEVICE_SPEC_BY_ID) {",
          "3188:   args.devid = vol_args->devid;",
          "3189:  } else if (!strcmp(\"cancel\", vol_args->name)) {",
          "3191:  } else {",
          "3192:   ret = btrfs_get_dev_args_from_path(fs_info, &args, vol_args->name);",
          "3193:   if (ret)",
          "3194:    goto out;",
          "3195:  }",
          "3197:  ret = mnt_want_write_file(file);",
          "3198:  if (ret)",
          "3199:   goto out;",
          "3204:   goto err_drop;",
          "3207:  ret = btrfs_rm_device(fs_info, &args, &bdev, &mode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3211:    btrfs_info(fs_info, \"device deleted: %s\",",
          "3212:      vol_args->name);",
          "3213:  }",
          "3216: err_drop:",
          "3217:  mnt_drop_write_file(file);",
          "3218:  if (bdev)",
          "3219:   blkdev_put(bdev, mode);",
          "3220:  return ret;",
          "3221: }",
          "3223: static long btrfs_ioctl_rm_dev(struct file *file, void __user *arg)",
          "3224: {",
          "3225:  struct inode *inode = file_inode(file);",
          "3226:  struct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);",
          "3227:  struct btrfs_ioctl_vol_args *vol_args;",
          "",
          "[Removed Lines]",
          "3214: out:",
          "3215:  kfree(vol_args);",
          "",
          "[Added Lines]",
          "3223: out:",
          "3224:  btrfs_put_dev_args_from_path(&args);",
          "3225:  kfree(vol_args);",
          "3231:  BTRFS_DEV_LOOKUP_ARGS(args);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3233:  if (!capable(CAP_SYS_ADMIN))",
          "3234:   return -EPERM;",
          "3240:  vol_args = memdup_user(arg, sizeof(*vol_args));",
          "3245:  vol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';",
          "3248:  ret = exclop_start_or_cancel_reloc(fs_info, BTRFS_EXCLOP_DEV_REMOVE,",
          "3249:         cancel);",
          "3250:  if (ret == 0) {",
          "3252:   if (!ret)",
          "3253:    btrfs_info(fs_info, \"disk deleted %s\", vol_args->name);",
          "3254:   btrfs_exclop_finish(fs_info);",
          "3255:  }",
          "3259:  mnt_drop_write_file(file);",
          "3260:  if (bdev)",
          "3261:   blkdev_put(bdev, mode);",
          "3262:  return ret;",
          "3263: }",
          "",
          "[Removed Lines]",
          "3236:  ret = mnt_want_write_file(file);",
          "3237:  if (ret)",
          "3238:   return ret;",
          "3241:  if (IS_ERR(vol_args)) {",
          "3242:   ret = PTR_ERR(vol_args);",
          "3243:   goto out_drop_write;",
          "3244:  }",
          "3246:  cancel = (strcmp(\"cancel\", vol_args->name) == 0);",
          "3251:   ret = btrfs_rm_device(fs_info, vol_args->name, 0, &bdev, &mode);",
          "3257:  kfree(vol_args);",
          "3258: out_drop_write:",
          "",
          "[Added Lines]",
          "3244:  if (IS_ERR(vol_args))",
          "3245:   return PTR_ERR(vol_args);",
          "3248:  if (!strcmp(\"cancel\", vol_args->name)) {",
          "3249:   cancel = true;",
          "3250:  } else {",
          "3251:   ret = btrfs_get_dev_args_from_path(fs_info, &args, vol_args->name);",
          "3252:   if (ret)",
          "3253:    goto out;",
          "3254:  }",
          "3256:  ret = mnt_want_write_file(file);",
          "3257:  if (ret)",
          "3258:   goto out;",
          "3263:   ret = btrfs_rm_device(fs_info, &args, &bdev, &mode);",
          "3272: out:",
          "3273:  btrfs_put_dev_args_from_path(&args);",
          "3274:  kfree(vol_args);",
          "",
          "---------------"
        ],
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2076:  update_dev_time(bdev);",
          "2077: }",
          "2081: {",
          "2082:  struct btrfs_device *device;",
          "2083:  struct btrfs_fs_devices *cur_devices;",
          "",
          "[Removed Lines]",
          "2079: int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,",
          "2080:       u64 devid, struct block_device **bdev, fmode_t *mode)",
          "",
          "[Added Lines]",
          "2079: int btrfs_rm_device(struct btrfs_fs_info *fs_info,",
          "2080:       struct btrfs_dev_lookup_args *args,",
          "2081:       struct block_device **bdev, fmode_t *mode)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2096:  if (ret)",
          "2097:   goto out;",
          "2104:    ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;",
          "2105:   else",
          "2107:   goto out;",
          "2108:  }",
          "",
          "[Removed Lines]",
          "2099:  device = btrfs_find_device_by_devspec(fs_info, devid, device_path);",
          "2101:  if (IS_ERR(device)) {",
          "2102:   if (PTR_ERR(device) == -ENOENT &&",
          "2103:       device_path && strcmp(device_path, \"missing\") == 0)",
          "2106:    ret = PTR_ERR(device);",
          "",
          "[Added Lines]",
          "2100:  device = btrfs_find_device(fs_info->fs_devices, args);",
          "2101:  if (!device) {",
          "2102:   if (args->missing)",
          "2105:    ret = -ENOENT;",
          "",
          "---------------"
        ],
        "fs/btrfs/volumes.h||fs/btrfs/volumes.h": [
          "File: fs/btrfs/volumes.h -> fs/btrfs/volumes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "529: void btrfs_put_dev_args_from_path(struct btrfs_dev_lookup_args *args);",
          "530: void btrfs_free_device(struct btrfs_device *device);",
          "531: int btrfs_rm_device(struct btrfs_fs_info *fs_info,",
          "533:       struct block_device **bdev, fmode_t *mode);",
          "534: void __exit btrfs_cleanup_fs_uuids(void);",
          "535: int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);",
          "",
          "[Removed Lines]",
          "532:       const char *device_path, u64 devid,",
          "",
          "[Added Lines]",
          "532:       struct btrfs_dev_lookup_args *args,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
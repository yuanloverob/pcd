{
  "cve_id": "CVE-2020-27638",
  "cve_desc": "receive.c in fastd before v21 allows denial of service (assertion failure) when receiving packets with an invalid type code.",
  "repo": "NeoRaider/fastd",
  "patch_hash": "737925113363b6130879729cdff9ccc46c33eaea",
  "patch_info": {
    "commit_hash": "737925113363b6130879729cdff9ccc46c33eaea",
    "repo": "NeoRaider/fastd",
    "commit_url": "https://github.com/NeoRaider/fastd/commit/737925113363b6130879729cdff9ccc46c33eaea",
    "files": [
      "src/receive.c"
    ],
    "message": "receive: fix buffer leak when receiving invalid packets\n\nFor fastd versions before v20, this was just a memory leak (which could\nstill be used for DoS, as it's remotely triggerable). With the new\nbuffer management of fastd v20, this will trigger an assertion failure\ninstead as soon as the buffer pool is empty.",
    "before_after_code_files": [
      "src/receive.c||src/receive.c"
    ]
  },
  "patch_diff": {
    "src/receive.c||src/receive.c": [
      "File: src/receive.c -> src/receive.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "170:  case PACKET_HANDSHAKE:",
      "171:   fastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);",
      "172:  }",
      "173: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "172:   break;",
      "174:  default:",
      "175:   fastd_buffer_free(buffer);",
      "176:   pr_debug(\"received packet with invalid type from %P[%I]\", peer, remote_addr);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "196:  case PACKET_HANDSHAKE:",
      "197:   fastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);",
      "198:  }",
      "199: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "203:   break;",
      "205:  default:",
      "206:   fastd_buffer_free(buffer);",
      "207:   pr_debug(\"received packet with invalid type from unknown address %I\", remote_addr);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9bb78a5ab900d65c223dbb80519426d8e2088a6a",
      "candidate_info": {
        "commit_hash": "9bb78a5ab900d65c223dbb80519426d8e2088a6a",
        "repo": "NeoRaider/fastd",
        "commit_url": "https://github.com/NeoRaider/fastd/commit/9bb78a5ab900d65c223dbb80519426d8e2088a6a",
        "files": [
          "src/handshake.c",
          "src/receive.c"
        ],
        "message": "handshake: move buffer free out of fastd_handshake_handle()",
        "before_after_code_files": [
          "src/handshake.c||src/handshake.c",
          "src/receive.c||src/receive.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/receive.c||src/receive.c"
          ],
          "candidate": [
            "src/receive.c||src/receive.c"
          ]
        }
      },
      "candidate_diff": {
        "src/handshake.c||src/handshake.c": [
          "File: src/handshake.c -> src/handshake.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "456: void fastd_handshake_handle(",
          "457:  fastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,",
          "458:  fastd_peer_t *peer, fastd_buffer_t *buffer) {",
          "461:  fastd_handshake_t handshake = parse_tlvs(buffer);",
          "463:  if (!handshake.tlv_data) {",
          "464:   pr_warn(\"received a short handshake from %I\", remote_addr);",
          "466:  }",
          "468:  if (handshake.records[RECORD_HANDSHAKE_TYPE].length != 1) {",
          "469:   pr_debug(\"received handshake without handshake type from %I\", remote_addr);",
          "471:  }",
          "473:  handshake.type = as_uint8(&handshake.records[RECORD_HANDSHAKE_TYPE]);",
          "475:  if (!check_records(sock, local_addr, remote_addr, peer, &handshake))",
          "478:  if (handshake.type > 1) {",
          "479:   if (handshake.records[RECORD_VERSION_NAME].data)",
          "",
          "[Removed Lines]",
          "459:  char *peer_version = NULL;",
          "465:   goto end_free;",
          "470:   goto end_free;",
          "476:   goto end_free;",
          "",
          "[Added Lines]",
          "464:   return;",
          "469:   return;",
          "475:   return;",
          "477:  char *peer_version = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "485:  conf.protocol->handshake_handle(sock, local_addr, remote_addr, peer, &handshake);",
          "488:  free(peer_version);",
          "490: }",
          "",
          "[Removed Lines]",
          "487: end_free:",
          "489:  fastd_buffer_free(buffer);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/receive.c||src/receive.c": [
          "File: src/receive.c -> src/receive.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:  case PACKET_HANDSHAKE:",
          "171:   fastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);",
          "172:   break;",
          "174:  default:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:   fastd_buffer_free(buffer);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "201:  case PACKET_HANDSHAKE:",
          "202:   fastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);",
          "203:   break;",
          "205:  default:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "204:   fastd_buffer_free(buffer);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8a5717e73e370bf50a0351e901ebf460fd69fdc9",
      "candidate_info": {
        "commit_hash": "8a5717e73e370bf50a0351e901ebf460fd69fdc9",
        "repo": "NeoRaider/fastd",
        "commit_url": "https://github.com/NeoRaider/fastd/commit/8a5717e73e370bf50a0351e901ebf460fd69fdc9",
        "files": [
          "src/receive.c"
        ],
        "message": "receive: merge handling of packets from known and unknown addresses",
        "before_after_code_files": [
          "src/receive.c||src/receive.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/receive.c||src/receive.c"
          ],
          "candidate": [
            "src/receive.c||src/receive.c"
          ]
        }
      },
      "candidate_diff": {
        "src/receive.c||src/receive.c": [
          "File: src/receive.c -> src/receive.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:  return false;",
          "142: }",
          "179: }",
          "182: static inline bool allow_unknown_peers(void) {",
          "183:  return ctx.has_floating || fastd_allow_verify();",
          "184: }",
          "215:  fastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,",
          "216:  fastd_buffer_t *buffer) {",
          "217:  fastd_peer_t *peer = NULL;",
          "219:  if (sock->peer) {",
          "",
          "[Removed Lines]",
          "145: static inline void handle_socket_receive_known(",
          "146:  fastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,",
          "147:  fastd_peer_t *peer, fastd_buffer_t *buffer) {",
          "148:  if (!fastd_peer_may_connect(peer)) {",
          "149:   fastd_buffer_free(buffer);",
          "150:   return;",
          "151:  }",
          "153:  const uint8_t *packet_type = buffer->data;",
          "155:  switch (*packet_type) {",
          "156:  case PACKET_DATA:",
          "157:   if (!fastd_peer_is_established(peer) || !fastd_peer_address_equal(&peer->local_address, local_addr)) {",
          "158:    fastd_buffer_free(buffer);",
          "160:    if (!backoff_unknown(remote_addr)) {",
          "161:     pr_debug(\"unexpectedly received payload data from %P[%I]\", peer, remote_addr);",
          "162:     conf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);",
          "163:    }",
          "164:    return;",
          "165:   }",
          "167:   conf.protocol->handle_recv(peer, buffer);",
          "168:   break;",
          "170:  case PACKET_HANDSHAKE:",
          "171:   fastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);",
          "172:   fastd_buffer_free(buffer);",
          "173:   break;",
          "175:  default:",
          "176:   fastd_buffer_free(buffer);",
          "177:   pr_debug(\"received packet with invalid type from %P[%I]\", peer, remote_addr);",
          "178:  }",
          "187: static inline void handle_socket_receive_unknown(",
          "188:  fastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,",
          "189:  fastd_buffer_t *buffer) {",
          "190:  const uint8_t *packet_type = buffer->data;",
          "192:  switch (*packet_type) {",
          "193:  case PACKET_DATA:",
          "194:   fastd_buffer_free(buffer);",
          "196:   if (!backoff_unknown(remote_addr)) {",
          "197:    pr_debug(\"unexpectedly received payload data from unknown address %I\", remote_addr);",
          "198:    conf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);",
          "199:   }",
          "200:   break;",
          "202:  case PACKET_HANDSHAKE:",
          "203:   fastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);",
          "204:   fastd_buffer_free(buffer);",
          "205:   break;",
          "207:  default:",
          "208:   fastd_buffer_free(buffer);",
          "209:   pr_debug(\"received packet with invalid type from unknown address %I\", remote_addr);",
          "210:  }",
          "211: }",
          "214: static inline void handle_socket_receive(",
          "",
          "[Added Lines]",
          "145: static inline bool can_receive_data(const fastd_peer_t *peer, const fastd_peer_address_t *local_addr) {",
          "146:  if (!peer || !fastd_peer_is_established(peer))",
          "147:   return false;",
          "149:  return fastd_peer_address_equal(&peer->local_address, local_addr);",
          "158: static void handle_socket_receive(",
          "161:  const uint8_t packet_type = *(const uint8_t *)buffer->data;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "227:   peer = fastd_peer_hashtable_lookup(remote_addr);",
          "228:  }",
          "236:   fastd_buffer_free(buffer);",
          "237:  }",
          "238: }",
          "",
          "[Removed Lines]",
          "230:  if (peer) {",
          "231:   handle_socket_receive_known(sock, local_addr, remote_addr, peer, buffer);",
          "232:  } else if (allow_unknown_peers()) {",
          "233:   handle_socket_receive_unknown(sock, local_addr, remote_addr, buffer);",
          "234:  } else {",
          "235:   pr_debug(\"received packet from unknown peer %I\", remote_addr);",
          "",
          "[Added Lines]",
          "175:  if (packet_type == PACKET_DATA && can_receive_data(peer, local_addr)) {",
          "177:   conf.protocol->handle_recv(peer, buffer);",
          "178:   return;",
          "179:  }",
          "181:  if (!peer && !allow_unknown_peers()) {",
          "182:   pr_debug(\"received packet from unknown address %I\", remote_addr);",
          "184:   return;",
          "187:  switch (packet_type) {",
          "188:  case PACKET_HANDSHAKE:",
          "189:   fastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);",
          "190:   break;",
          "192:  case PACKET_DATA:",
          "193:   if (!backoff_unknown(remote_addr)) {",
          "194:    pr_debug(\"unexpectedly received payload data from %I\", remote_addr);",
          "195:    conf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);",
          "196:   }",
          "198:   break;",
          "200:  default:",
          "201:   pr_debug(\"received packet with invalid type from %I\", remote_addr);",
          "202:  }",
          "204:  fastd_buffer_free(buffer);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-3815",
  "cve_desc": "The detect_version function in wiretap/logcat.c in the Android Logcat file parser in Wireshark 1.12.x before 1.12.5 does not check the length of the payload, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a packet with a crafted payload, as demonstrated by a length of zero, a different vulnerability than CVE-2015-3906.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
  "patch_info": {
    "commit_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "files": [
      "wiretap/logcat.c"
    ],
    "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nChange-Id: I46c8813e76fe705b293ffdee85b4c1bfff7d8362\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>",
    "before_after_code_files": [
      "wiretap/logcat.c||wiretap/logcat.c"
    ]
  },
  "patch_diff": {
    "wiretap/logcat.c||wiretap/logcat.c": [
      "File: wiretap/logcat.c -> wiretap/logcat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43:     enum dump_type_t type;",
      "44: };",
      "47:     static gchar priorities[] = \"??VDIWEFS\";",
      "50:         return '?';",
      "53: }",
      "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
      "57:         const gchar *log)",
      "58: {",
      "59:     gchar  time_buffer[15];",
      "",
      "[Removed Lines]",
      "46: static gchar get_priority(const guint8 *priority) {",
      "49:     if (*priority >= (guint8) sizeof(priorities))",
      "52:     return priorities[(int) *priority];",
      "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "[Added Lines]",
      "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
      "53: struct logger_entry {",
      "61: };",
      "63: struct logger_entry_v2 {",
      "70:     union {",
      "74:     };",
      "76: };",
      "79: static gchar get_priority(const guint8 priority) {",
      "82:     if (priority >= (guint8) sizeof(priorities))",
      "85:     return priorities[priority];",
      "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "81:                     gmtime(&datetime));",
      "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
      "84:         case DUMP_THREADTIME:",
      "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "86:                     gmtime(&datetime));",
      "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
      "89:         case DUMP_LONG:",
      "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "91:                     gmtime(&datetime));",
      "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
      "94:         default:",
      "95:             return NULL;",
      "96:     }",
      "",
      "[Removed Lines]",
      "83:                     time_buffer, microseconds, priority, tag, pid, log);",
      "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "",
      "[Added Lines]",
      "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
      "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
      "101: {",
      "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
      "114:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "102:     gint     bytes_read;",
      "103:     guint16  payload_length;",
      "104:     guint16  try_header_size;",
      "105:     guint8  *buffer;",
      "106:     gint64   file_offset;",
      "107:     guint32  log_length;",
      "108:     guint32  tag_length;",
      "109:     guint16  tmp;",
      "111:     file_offset = file_tell(wth->fh);",
      "",
      "[Added Lines]",
      "135:     gint                     bytes_read;",
      "136:     guint16                  payload_length;",
      "137:     guint16                  hdr_size;",
      "138:     guint16                  read_sofar;",
      "139:     guint16                  entry_len;",
      "140:     gint                     version;",
      "141:     struct logger_entry     *log_entry;",
      "142:     struct logger_entry_v2  *log_entry_v2;",
      "143:     guint8                  *buffer;",
      "144:     guint16                  tmp;",
      "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
      "146:     guint16                  msg_len;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "127:         return -1;",
      "128:     }",
      "136:             if (*err == 0 && bytes_read != 0)",
      "140:         }",
      "159:         g_free(buffer);",
      "161:     }",
      "163:     g_free(buffer);",
      "165: }",
      "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
      "",
      "[Removed Lines]",
      "129:     try_header_size = pletoh16(&tmp);",
      "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
      "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
      "133:     if (bytes_read != 5 * 4 + payload_length) {",
      "134:         if (bytes_read != 4 * 4 + payload_length) {",
      "138:             g_free(buffer);",
      "139:             return -1;",
      "141:     }",
      "143:     if (try_header_size == 24) {",
      "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
      "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
      "146:         if (payload_length == 1 + tag_length + log_length) {",
      "147:             g_free(buffer);",
      "148:             return 2;",
      "149:         }",
      "150:     }",
      "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
      "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
      "154:     if (payload_length == 1 + tag_length + log_length) {",
      "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
      "156:             g_free(buffer);",
      "157:             return -1;",
      "158:         }",
      "160:         return 1;",
      "164:     return 0;",
      "",
      "[Added Lines]",
      "166:     hdr_size = pletoh16(&tmp);",
      "167:     read_sofar = 4;",
      "170:     if (payload_length < 3)",
      "171:         return -1;",
      "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
      "174:         return -1;",
      "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
      "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
      "179:     log_entry = (struct logger_entry *) buffer;",
      "183:     for (version = 1; version <= 2; ++version) {",
      "184:         if (version == 1) {",
      "185:             msg_payload = log_entry->msg;",
      "186:             entry_len = sizeof(*log_entry) + payload_length;",
      "187:         } else if (version == 2) {",
      "189:             msg_payload = log_entry_v2->msg;",
      "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
      "191:             if (hdr_size != sizeof(*log_entry_v2))",
      "192:                 continue;",
      "193:         }",
      "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
      "196:                 wth->fh);",
      "197:         if (bytes_read != entry_len - read_sofar) {",
      "202:             version = -1;",
      "203:             break;",
      "205:         read_sofar += bytes_read;",
      "208:         if (get_priority(msg_payload[0]) == '?')",
      "209:             continue;",
      "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
      "213:         if (msg_part == NULL)",
      "214:             continue;",
      "217:         ++msg_part;",
      "218:         msg_len = payload_length - (msg_part - msg_payload);",
      "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
      "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
      "222:             continue;",
      "225:         return version;",
      "229:     return -1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "172:     guint16              payload_length;",
      "173:     guint                tmp[2];",
      "174:     guint8              *pd;",
      "176:     bytes_read = file_read(&tmp, 2, fh);",
      "177:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "240:     struct logger_entry *log_entry;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "183:     payload_length = pletoh16(tmp);",
      "185:     if (logcat->version == 1) {",
      "187:     } else if (logcat->version == 2) {",
      "189:     } else {",
      "190:         return FALSE;",
      "191:     }",
      "193:     buffer_assure_space(buf, packet_size);",
      "194:     pd = buffer_start_ptr(buf);",
      "197:     memcpy(pd, tmp, 2);",
      "",
      "[Removed Lines]",
      "186:         packet_size = 5 * 4 + payload_length;",
      "188:         packet_size = 6 * 4 + payload_length;",
      "",
      "[Added Lines]",
      "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
      "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
      "261:     log_entry = (struct logger_entry *) pd;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "208:     phdr->rec_type = REC_TYPE_PACKET;",
      "209:     phdr->presence_flags = WTAP_HAS_TS;",
      "212:     phdr->caplen = packet_size;",
      "213:     phdr->len = packet_size;",
      "",
      "[Removed Lines]",
      "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
      "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
      "",
      "[Added Lines]",
      "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
      "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "340:     gchar                          *buf;",
      "341:     gint                            length;",
      "342:     gchar                           priority;",
      "343:     const gchar                    *tag;",
      "347:     gchar                          *log_part;",
      "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
      "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
      "",
      "[Removed Lines]",
      "344:     const gint                     *pid;",
      "345:     const gint                     *tid;",
      "346:     const gchar                    *log;",
      "348:     const gchar                    *str_begin;",
      "349:     const gchar                    *str_end;",
      "350:     const guint32                  *datetime;",
      "351:     const guint32                  *nanoseconds;",
      "",
      "[Added Lines]",
      "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
      "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
      "412:     gint                            payload_length;",
      "414:     gint32                          pid;",
      "415:     gint32                          tid;",
      "416:     gint32                          seconds;",
      "417:     gint32                          milliseconds;",
      "418:     const gchar                    *msg_begin;",
      "419:     gint                            msg_pre_skip;",
      "420:     gchar                          *log;",
      "422:     gchar                          *log_next;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "358:         return FALSE;",
      "359:     }",
      "361:     if (pseudo_header->logcat.version == 1) {",
      "369:     } else if (pseudo_header->logcat.version == 2) {",
      "377:     } else {",
      "379:         return FALSE;",
      "380:     }",
      "401:         }",
      "413:                 priority, tag, log_part);",
      "414:         if (!buf) {",
      "416:             return FALSE;",
      "417:         }",
      "419:         length = (guint32)strlen(buf);",
      "421:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "423:             return FALSE;",
      "424:         }",
      "426:         wdh->bytes_dumped += length;",
      "430:     return TRUE;",
      "431: }",
      "",
      "[Removed Lines]",
      "362:         pid = (const gint *) (pd + 4);",
      "363:         tid = (const gint *) (pd + 2 * 4);",
      "364:         datetime = (const guint32 *) (pd + 3 * 4);",
      "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
      "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
      "368:         log = tag + strlen(tag) + 1;",
      "370:         pid = (const gint *) (pd + 4);",
      "371:         tid = (const gint *) (pd + 2 * 4);",
      "372:         datetime = (const guint32 *) (pd + 3 * 4);",
      "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
      "375:         tag = (const char *) (pd + 6 * 4 + 1);",
      "376:         log = tag + strlen(tag) + 1;",
      "382:     str_begin = str_end = log;",
      "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
      "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
      "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
      "387:         str_begin = str_end + 1;",
      "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "390:                 priority, tag, log_part);",
      "391:         if (!buf) {",
      "392:             g_free(log_part);",
      "393:             return FALSE;",
      "394:         }",
      "395:         g_free(log_part);",
      "396:         length = (guint32)strlen(buf);",
      "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "399:             g_free(buf);",
      "400:             return FALSE;",
      "403:         wdh->bytes_dumped += length;",
      "405:         g_free(buf);",
      "406:     }",
      "408:     if (*str_begin != '\\0') {",
      "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
      "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
      "412:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "415:             g_free(log_part);",
      "418:         g_free(log_part);",
      "422:             g_free(buf);",
      "427:         g_free(buf);",
      "428:     }",
      "",
      "[Added Lines]",
      "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
      "433:     pid = GINT32_FROM_LE(log_entry->pid);",
      "434:     tid = GINT32_FROM_LE(log_entry->tid);",
      "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
      "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
      "440:         priority = get_priority(log_entry->msg[0]);",
      "441:         tag = log_entry->msg + 1;",
      "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "443:         msg_begin = log_entry->msg + msg_pre_skip;",
      "445:         priority = get_priority(log_entry_v2->msg[0]);",
      "446:         tag = log_entry_v2->msg + 1;",
      "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
      "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
      "459:     log_next = log;",
      "460:     do {",
      "461:         log_part = log_next;",
      "462:         if (dumper->type == DUMP_LONG) {",
      "464:             log_next = NULL;",
      "465:         } else {",
      "467:             log_next = strchr(log_part, '\\n');",
      "468:             if (log_next != NULL) {",
      "470:                 ++log_next;",
      "472:                 if (*log_next == '\\0') {",
      "473:                     log_next = NULL;",
      "474:                 }",
      "475:             }",
      "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
      "481:             g_free(log);",
      "487:             g_free(log);",
      "492:     } while (log_next != NULL);",
      "494:     g_free(log);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded",
      "candidate_info": {
        "commit_hash": "afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>\n(cherry picked from commit b3b1f7c3aa2233a147294bad833b748d38fba84d)\n\nConflicts:\n\twiretap/logcat.c\n\nChange-Id: I33bb20b5f9a5e03a231121a784bfffdfba0aba98\nReviewed-on: https://code.wireshark.org/review/8346\nReviewed-by: Gerald Combs <gerald@wireshark.org>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     enum dump_type_t type;",
          "44: };",
          "47:     static gchar priorities[] = \"??VDIWEFS\";",
          "50:         return '?';",
          "53: }",
          "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
          "57:         const gchar *log)",
          "58: {",
          "59:     gchar  time_buffer[15];",
          "",
          "[Removed Lines]",
          "46: static gchar get_priority(const guint8 *priority) {",
          "49:     if (*priority >= (guint8) sizeof(priorities))",
          "52:     return priorities[(int) *priority];",
          "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "[Added Lines]",
          "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
          "53: struct logger_entry {",
          "61: };",
          "63: struct logger_entry_v2 {",
          "70:     union {",
          "74:     };",
          "76: };",
          "79: static gchar get_priority(const guint8 priority) {",
          "82:     if (priority >= (guint8) sizeof(priorities))",
          "85:     return priorities[priority];",
          "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "81:                     gmtime(&datetime));",
          "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
          "84:         case DUMP_THREADTIME:",
          "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "86:                     gmtime(&datetime));",
          "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
          "89:         case DUMP_LONG:",
          "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "91:                     gmtime(&datetime));",
          "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
          "94:         default:",
          "95:             return NULL;",
          "96:     }",
          "",
          "[Removed Lines]",
          "83:                     time_buffer, microseconds, priority, tag, pid, log);",
          "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "",
          "[Added Lines]",
          "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
          "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
          "101: {",
          "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "114:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "102:     gint     bytes_read;",
          "103:     guint16  payload_length;",
          "104:     guint16  try_header_size;",
          "105:     guint8  *buffer;",
          "106:     gint64   file_offset;",
          "107:     guint32  log_length;",
          "108:     guint32  tag_length;",
          "109:     guint16  tmp;",
          "111:     file_offset = file_tell(wth->fh);",
          "",
          "[Added Lines]",
          "135:     gint                     bytes_read;",
          "136:     guint16                  payload_length;",
          "137:     guint16                  hdr_size;",
          "138:     guint16                  read_sofar;",
          "139:     guint16                  entry_len;",
          "140:     gint                     version;",
          "141:     struct logger_entry     *log_entry;",
          "142:     struct logger_entry_v2  *log_entry_v2;",
          "143:     guint8                  *buffer;",
          "144:     guint16                  tmp;",
          "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
          "146:     guint16                  msg_len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127:         return -1;",
          "128:     }",
          "136:             if (*err == 0 && bytes_read != 0)",
          "140:         }",
          "159:         g_free(buffer);",
          "161:     }",
          "163:     g_free(buffer);",
          "165: }",
          "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
          "",
          "[Removed Lines]",
          "129:     try_header_size = pletoh16(&tmp);",
          "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
          "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
          "133:     if (bytes_read != 5 * 4 + payload_length) {",
          "134:         if (bytes_read != 4 * 4 + payload_length) {",
          "138:             g_free(buffer);",
          "139:             return -1;",
          "141:     }",
          "143:     if (try_header_size == 24) {",
          "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
          "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "146:         if (payload_length == 1 + tag_length + log_length) {",
          "147:             g_free(buffer);",
          "148:             return 2;",
          "149:         }",
          "150:     }",
          "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
          "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "154:     if (payload_length == 1 + tag_length + log_length) {",
          "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
          "156:             g_free(buffer);",
          "157:             return -1;",
          "158:         }",
          "160:         return 1;",
          "164:     return 0;",
          "",
          "[Added Lines]",
          "166:     hdr_size = pletoh16(&tmp);",
          "167:     read_sofar = 4;",
          "170:     if (payload_length < 3)",
          "171:         return -1;",
          "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
          "174:         return -1;",
          "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
          "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
          "179:     log_entry = (struct logger_entry *) buffer;",
          "183:     for (version = 1; version <= 2; ++version) {",
          "184:         if (version == 1) {",
          "185:             msg_payload = log_entry->msg;",
          "186:             entry_len = sizeof(*log_entry) + payload_length;",
          "187:         } else if (version == 2) {",
          "189:             msg_payload = log_entry_v2->msg;",
          "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
          "191:             if (hdr_size != sizeof(*log_entry_v2))",
          "192:                 continue;",
          "193:         }",
          "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
          "196:                 wth->fh);",
          "197:         if (bytes_read != entry_len - read_sofar) {",
          "202:             version = -1;",
          "203:             break;",
          "205:         read_sofar += bytes_read;",
          "208:         if (get_priority(msg_payload[0]) == '?')",
          "209:             continue;",
          "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
          "213:         if (msg_part == NULL)",
          "214:             continue;",
          "217:         ++msg_part;",
          "218:         msg_len = payload_length - (msg_part - msg_payload);",
          "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
          "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
          "222:             continue;",
          "225:         return version;",
          "229:     return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "172:     guint16              payload_length;",
          "173:     guint                tmp[2];",
          "174:     guint8              *pd;",
          "176:     bytes_read = file_read(&tmp, 2, fh);",
          "177:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:     struct logger_entry *log_entry;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "183:     payload_length = pletoh16(tmp);",
          "185:     if (logcat->version == 1) {",
          "187:     } else if (logcat->version == 2) {",
          "189:     } else {",
          "190:         return FALSE;",
          "191:     }",
          "193:     buffer_assure_space(buf, packet_size);",
          "194:     pd = buffer_start_ptr(buf);",
          "197:     memcpy(pd, tmp, 2);",
          "",
          "[Removed Lines]",
          "186:         packet_size = 5 * 4 + payload_length;",
          "188:         packet_size = 6 * 4 + payload_length;",
          "",
          "[Added Lines]",
          "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
          "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
          "261:     log_entry = (struct logger_entry *) pd;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "208:     phdr->rec_type = REC_TYPE_PACKET;",
          "209:     phdr->presence_flags = WTAP_HAS_TS;",
          "212:     phdr->caplen = packet_size;",
          "213:     phdr->len = packet_size;",
          "",
          "[Removed Lines]",
          "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
          "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
          "",
          "[Added Lines]",
          "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
          "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "340:     gchar                          *buf;",
          "341:     gint                            length;",
          "342:     gchar                           priority;",
          "343:     const gchar                    *tag;",
          "347:     gchar                          *log_part;",
          "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
          "",
          "[Removed Lines]",
          "344:     const gint                     *pid;",
          "345:     const gint                     *tid;",
          "346:     const gchar                    *log;",
          "348:     const gchar                    *str_begin;",
          "349:     const gchar                    *str_end;",
          "350:     const guint32                  *datetime;",
          "351:     const guint32                  *nanoseconds;",
          "",
          "[Added Lines]",
          "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
          "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "412:     gint                            payload_length;",
          "414:     gint32                          pid;",
          "415:     gint32                          tid;",
          "416:     gint32                          seconds;",
          "417:     gint32                          milliseconds;",
          "418:     const gchar                    *msg_begin;",
          "419:     gint                            msg_pre_skip;",
          "420:     gchar                          *log;",
          "422:     gchar                          *log_next;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "358:         return FALSE;",
          "359:     }",
          "361:     if (pseudo_header->logcat.version == 1) {",
          "369:     } else if (pseudo_header->logcat.version == 2) {",
          "377:     } else {",
          "379:         return FALSE;",
          "380:     }",
          "401:         }",
          "414:                 priority, tag, log_part);",
          "415:         if (!buf) {",
          "417:             return FALSE;",
          "418:         }",
          "420:         length = (guint32)strlen(buf);",
          "422:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "424:             return FALSE;",
          "425:         }",
          "427:         wdh->bytes_dumped += length;",
          "431:     return TRUE;",
          "432: }",
          "",
          "[Removed Lines]",
          "362:         pid = (const gint *) (pd + 4);",
          "363:         tid = (const gint *) (pd + 2 * 4);",
          "364:         datetime = (const guint32 *) (pd + 3 * 4);",
          "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
          "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
          "368:         log = tag + strlen(tag) + 1;",
          "370:         pid = (const gint *) (pd + 4);",
          "371:         tid = (const gint *) (pd + 2 * 4);",
          "372:         datetime = (const guint32 *) (pd + 3 * 4);",
          "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
          "375:         tag = (const char *) (pd + 6 * 4 + 1);",
          "376:         log = tag + strlen(tag) + 1;",
          "382:     str_begin = str_end = log;",
          "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
          "387:         str_begin = str_end + 1;",
          "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "390:                 priority, tag, log_part);",
          "391:         if (!buf) {",
          "392:             g_free(log_part);",
          "393:             return FALSE;",
          "394:         }",
          "395:         g_free(log_part);",
          "396:         length = (guint32)strlen(buf);",
          "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "399:             g_free(buf);",
          "400:             return FALSE;",
          "403:         wdh->bytes_dumped += length;",
          "405:         g_free(buf);",
          "406:     }",
          "408:     if (*str_begin != '\\0') {",
          "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
          "413:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "416:             g_free(log_part);",
          "419:         g_free(log_part);",
          "423:             g_free(buf);",
          "428:         g_free(buf);",
          "429:     }",
          "",
          "[Added Lines]",
          "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
          "433:     pid = GINT32_FROM_LE(log_entry->pid);",
          "434:     tid = GINT32_FROM_LE(log_entry->tid);",
          "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
          "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
          "440:         priority = get_priority(log_entry->msg[0]);",
          "441:         tag = log_entry->msg + 1;",
          "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "443:         msg_begin = log_entry->msg + msg_pre_skip;",
          "445:         priority = get_priority(log_entry_v2->msg[0]);",
          "446:         tag = log_entry_v2->msg + 1;",
          "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
          "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
          "459:     log_next = log;",
          "460:     do {",
          "461:         log_part = log_next;",
          "462:         if (dumper->type == DUMP_LONG) {",
          "464:             log_next = NULL;",
          "465:         } else {",
          "467:             log_next = strchr(log_part, '\\n');",
          "468:             if (log_next != NULL) {",
          "470:                 ++log_next;",
          "472:                 if (*log_next == '\\0') {",
          "473:                     log_next = NULL;",
          "474:                 }",
          "475:             }",
          "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
          "481:             g_free(log);",
          "487:             g_free(log);",
          "492:     } while (log_next != NULL);",
          "494:     g_free(log);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "22c2210cc254cc6251c3831cd2b58f1ffe6a0cf8",
      "candidate_info": {
        "commit_hash": "22c2210cc254cc6251c3831cd2b58f1ffe6a0cf8",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/22c2210cc254cc6251c3831cd2b58f1ffe6a0cf8",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>\n(cherry picked from commit b3b1f7c3aa2233a147294bad833b748d38fba84d)\n\nConflicts:\n\twiretap/logcat.c\n\nChange-Id: I33bb20b5f9a5e03a231121a784bfffdfba0aba98\nReviewed-on: https://code.wireshark.org/review/8346\nReviewed-by: Gerald Combs <gerald@wireshark.org>\n(cherry picked from commit afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded)\nReviewed-on: https://code.wireshark.org/review/8641\nReviewed-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     enum dump_type_t type;",
          "44: };",
          "47:     static gchar priorities[] = \"??VDIWEFS\";",
          "50:         return '?';",
          "53: }",
          "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
          "57:         const gchar *log)",
          "58: {",
          "59:     gchar  time_buffer[15];",
          "",
          "[Removed Lines]",
          "46: static gchar get_priority(const guint8 *priority) {",
          "49:     if (*priority >= (guint8) sizeof(priorities))",
          "52:     return priorities[(int) *priority];",
          "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "[Added Lines]",
          "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
          "53: struct logger_entry {",
          "61: };",
          "63: struct logger_entry_v2 {",
          "70:     union {",
          "74:     };",
          "76: };",
          "79: static gchar get_priority(const guint8 priority) {",
          "82:     if (priority >= (guint8) sizeof(priorities))",
          "85:     return priorities[priority];",
          "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "81:                     gmtime(&datetime));",
          "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
          "84:         case DUMP_THREADTIME:",
          "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "86:                     gmtime(&datetime));",
          "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
          "89:         case DUMP_LONG:",
          "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "91:                     gmtime(&datetime));",
          "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
          "94:         default:",
          "95:             return NULL;",
          "96:     }",
          "",
          "[Removed Lines]",
          "83:                     time_buffer, microseconds, priority, tag, pid, log);",
          "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "",
          "[Added Lines]",
          "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
          "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
          "101: {",
          "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "114:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "102:     gint     bytes_read;",
          "103:     guint16  payload_length;",
          "104:     guint16  try_header_size;",
          "105:     guint8  *buffer;",
          "106:     gint64   file_offset;",
          "107:     guint32  log_length;",
          "108:     guint32  tag_length;",
          "109:     guint16  tmp;",
          "111:     file_offset = file_tell(wth->fh);",
          "",
          "[Added Lines]",
          "135:     gint                     bytes_read;",
          "136:     guint16                  payload_length;",
          "137:     guint16                  hdr_size;",
          "138:     guint16                  read_sofar;",
          "139:     guint16                  entry_len;",
          "140:     gint                     version;",
          "141:     struct logger_entry     *log_entry;",
          "142:     struct logger_entry_v2  *log_entry_v2;",
          "143:     guint8                  *buffer;",
          "144:     guint16                  tmp;",
          "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
          "146:     guint16                  msg_len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127:         return -1;",
          "128:     }",
          "136:             if (*err == 0 && bytes_read != 0)",
          "140:         }",
          "159:         g_free(buffer);",
          "161:     }",
          "163:     g_free(buffer);",
          "165: }",
          "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
          "",
          "[Removed Lines]",
          "129:     try_header_size = pletoh16(&tmp);",
          "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
          "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
          "133:     if (bytes_read != 5 * 4 + payload_length) {",
          "134:         if (bytes_read != 4 * 4 + payload_length) {",
          "138:             g_free(buffer);",
          "139:             return -1;",
          "141:     }",
          "143:     if (try_header_size == 24) {",
          "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
          "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "146:         if (payload_length == 1 + tag_length + log_length) {",
          "147:             g_free(buffer);",
          "148:             return 2;",
          "149:         }",
          "150:     }",
          "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
          "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "154:     if (payload_length == 1 + tag_length + log_length) {",
          "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
          "156:             g_free(buffer);",
          "157:             return -1;",
          "158:         }",
          "160:         return 1;",
          "164:     return 0;",
          "",
          "[Added Lines]",
          "166:     hdr_size = pletoh16(&tmp);",
          "167:     read_sofar = 4;",
          "170:     if (payload_length < 3)",
          "171:         return -1;",
          "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
          "174:         return -1;",
          "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
          "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
          "179:     log_entry = (struct logger_entry *) buffer;",
          "183:     for (version = 1; version <= 2; ++version) {",
          "184:         if (version == 1) {",
          "185:             msg_payload = log_entry->msg;",
          "186:             entry_len = sizeof(*log_entry) + payload_length;",
          "187:         } else if (version == 2) {",
          "189:             msg_payload = log_entry_v2->msg;",
          "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
          "191:             if (hdr_size != sizeof(*log_entry_v2))",
          "192:                 continue;",
          "193:         }",
          "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
          "196:                 wth->fh);",
          "197:         if (bytes_read != entry_len - read_sofar) {",
          "202:             version = -1;",
          "203:             break;",
          "205:         read_sofar += bytes_read;",
          "208:         if (get_priority(msg_payload[0]) == '?')",
          "209:             continue;",
          "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
          "213:         if (msg_part == NULL)",
          "214:             continue;",
          "217:         ++msg_part;",
          "218:         msg_len = payload_length - (msg_part - msg_payload);",
          "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
          "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
          "222:             continue;",
          "225:         return version;",
          "229:     return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "172:     guint16              payload_length;",
          "173:     guint                tmp[2];",
          "174:     guint8              *pd;",
          "176:     bytes_read = file_read(&tmp, 2, fh);",
          "177:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:     struct logger_entry *log_entry;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "183:     payload_length = pletoh16(tmp);",
          "185:     if (logcat->version == 1) {",
          "187:     } else if (logcat->version == 2) {",
          "189:     } else {",
          "190:         return FALSE;",
          "191:     }",
          "193:     buffer_assure_space(buf, packet_size);",
          "194:     pd = buffer_start_ptr(buf);",
          "197:     memcpy(pd, tmp, 2);",
          "",
          "[Removed Lines]",
          "186:         packet_size = 5 * 4 + payload_length;",
          "188:         packet_size = 6 * 4 + payload_length;",
          "",
          "[Added Lines]",
          "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
          "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
          "261:     log_entry = (struct logger_entry *) pd;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "208:     phdr->rec_type = REC_TYPE_PACKET;",
          "209:     phdr->presence_flags = WTAP_HAS_TS;",
          "212:     phdr->caplen = packet_size;",
          "213:     phdr->len = packet_size;",
          "",
          "[Removed Lines]",
          "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
          "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
          "",
          "[Added Lines]",
          "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
          "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "340:     gchar                          *buf;",
          "341:     gint                            length;",
          "342:     gchar                           priority;",
          "343:     const gchar                    *tag;",
          "347:     gchar                          *log_part;",
          "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
          "",
          "[Removed Lines]",
          "344:     const gint                     *pid;",
          "345:     const gint                     *tid;",
          "346:     const gchar                    *log;",
          "348:     const gchar                    *str_begin;",
          "349:     const gchar                    *str_end;",
          "350:     const guint32                  *datetime;",
          "351:     const guint32                  *nanoseconds;",
          "",
          "[Added Lines]",
          "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
          "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "412:     gint                            payload_length;",
          "414:     gint32                          pid;",
          "415:     gint32                          tid;",
          "416:     gint32                          seconds;",
          "417:     gint32                          milliseconds;",
          "418:     const gchar                    *msg_begin;",
          "419:     gint                            msg_pre_skip;",
          "420:     gchar                          *log;",
          "422:     gchar                          *log_next;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "358:         return FALSE;",
          "359:     }",
          "361:     if (pseudo_header->logcat.version == 1) {",
          "369:     } else if (pseudo_header->logcat.version == 2) {",
          "377:     } else {",
          "379:         return FALSE;",
          "380:     }",
          "401:         }",
          "414:                 priority, tag, log_part);",
          "415:         if (!buf) {",
          "417:             return FALSE;",
          "418:         }",
          "420:         length = (guint32)strlen(buf);",
          "422:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "424:             return FALSE;",
          "425:         }",
          "427:         wdh->bytes_dumped += length;",
          "431:     return TRUE;",
          "432: }",
          "",
          "[Removed Lines]",
          "362:         pid = (const gint *) (pd + 4);",
          "363:         tid = (const gint *) (pd + 2 * 4);",
          "364:         datetime = (const guint32 *) (pd + 3 * 4);",
          "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
          "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
          "368:         log = tag + strlen(tag) + 1;",
          "370:         pid = (const gint *) (pd + 4);",
          "371:         tid = (const gint *) (pd + 2 * 4);",
          "372:         datetime = (const guint32 *) (pd + 3 * 4);",
          "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
          "375:         tag = (const char *) (pd + 6 * 4 + 1);",
          "376:         log = tag + strlen(tag) + 1;",
          "382:     str_begin = str_end = log;",
          "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
          "387:         str_begin = str_end + 1;",
          "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "390:                 priority, tag, log_part);",
          "391:         if (!buf) {",
          "392:             g_free(log_part);",
          "393:             return FALSE;",
          "394:         }",
          "395:         g_free(log_part);",
          "396:         length = (guint32)strlen(buf);",
          "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "399:             g_free(buf);",
          "400:             return FALSE;",
          "403:         wdh->bytes_dumped += length;",
          "405:         g_free(buf);",
          "406:     }",
          "408:     if (*str_begin != '\\0') {",
          "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
          "413:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "416:             g_free(log_part);",
          "419:         g_free(log_part);",
          "423:             g_free(buf);",
          "428:         g_free(buf);",
          "429:     }",
          "",
          "[Added Lines]",
          "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
          "433:     pid = GINT32_FROM_LE(log_entry->pid);",
          "434:     tid = GINT32_FROM_LE(log_entry->tid);",
          "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
          "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
          "440:         priority = get_priority(log_entry->msg[0]);",
          "441:         tag = log_entry->msg + 1;",
          "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "443:         msg_begin = log_entry->msg + msg_pre_skip;",
          "445:         priority = get_priority(log_entry_v2->msg[0]);",
          "446:         tag = log_entry_v2->msg + 1;",
          "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
          "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
          "459:     log_next = log;",
          "460:     do {",
          "461:         log_part = log_next;",
          "462:         if (dumper->type == DUMP_LONG) {",
          "464:             log_next = NULL;",
          "465:         } else {",
          "467:             log_next = strchr(log_part, '\\n');",
          "468:             if (log_next != NULL) {",
          "470:                 ++log_next;",
          "472:                 if (*log_next == '\\0') {",
          "473:                     log_next = NULL;",
          "474:                 }",
          "475:             }",
          "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
          "481:             g_free(log);",
          "487:             g_free(log);",
          "492:     } while (log_next != NULL);",
          "494:     g_free(log);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef1b11f622ce61bc363e13ec6b80afaae9642441",
      "candidate_info": {
        "commit_hash": "ef1b11f622ce61bc363e13ec6b80afaae9642441",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ef1b11f622ce61bc363e13ec6b80afaae9642441",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Fix Dead Store (Dead assignement/Dead increment) warning found by Clang\n\nChange-Id: I17dc2259e039586b9a06944bd1c2b552dd23855d\nReviewed-on: https://code.wireshark.org/review/3052\nReviewed-by: Evan Huus <eapache@gmail.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:             if (*err == 0 && bytes_read != 0)",
          "203:             break;",
          "204:         }",
          "205:         read_sofar += bytes_read;",
          "",
          "[Removed Lines]",
          "202:             version = -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71550ba98a38508ae90df43bddd0644b2df2f717",
      "candidate_info": {
        "commit_hash": "71550ba98a38508ae90df43bddd0644b2df2f717",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/71550ba98a38508ae90df43bddd0644b2df2f717",
        "files": [
          "wiretap/k12.c",
          "wiretap/lanalyzer.c",
          "wiretap/logcat.c",
          "wiretap/network_instruments.c",
          "wiretap/ngsniffer.c",
          "wiretap/packetlogger.c",
          "wiretap/peekclassic.c",
          "wiretap/radcom.c"
        ],
        "message": "Make the code a bit more like the pre-new-APIs code.\n\nChange-Id: I40282d8825936d24480c9b77e2e7d9374b1de6b5\nReviewed-on: https://code.wireshark.org/review/4534\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/k12.c||wiretap/k12.c",
          "wiretap/lanalyzer.c||wiretap/lanalyzer.c",
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/network_instruments.c||wiretap/network_instruments.c",
          "wiretap/ngsniffer.c||wiretap/ngsniffer.c",
          "wiretap/packetlogger.c||wiretap/packetlogger.c",
          "wiretap/peekclassic.c||wiretap/peekclassic.c",
          "wiretap/radcom.c||wiretap/radcom.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/k12.c||wiretap/k12.c": [
          "File: wiretap/k12.c -> wiretap/k12.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "855:     if ( !wtap_read_bytes(wth->fh,header_buffer,K12_FILE_HDR_LEN,err,err_info) ) {",
          "856:         K12_DBG(1,(\"k12_open: FILE HEADER TOO SHORT OR READ ERROR\"));",
          "858:             return -1;",
          "859:         return 0;",
          "860:     }",
          "",
          "[Removed Lines]",
          "857:         if (*err != WTAP_ERR_SHORT_READ)",
          "",
          "[Added Lines]",
          "857:         if (*err != WTAP_ERR_SHORT_READ) {",
          "859:         }",
          "",
          "---------------"
        ],
        "wiretap/lanalyzer.c||wiretap/lanalyzer.c": [
          "File: wiretap/lanalyzer.c -> wiretap/lanalyzer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:  }",
          "314:  if (!wtap_read_bytes(wth->fh, &header_fixed, sizeof header_fixed,",
          "315:      err, err_info)) {",
          "324:  }",
          "325:  record_length -= sizeof header_fixed;",
          "",
          "[Removed Lines]",
          "316:   if (*err == WTAP_ERR_SHORT_READ) {",
          "321:    return 0;",
          "322:   }",
          "323:   return -1;",
          "",
          "[Added Lines]",
          "316:   if (*err != WTAP_ERR_SHORT_READ)",
          "317:    return -1;",
          "318:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "329:   comment = (char *)g_malloc(record_length + 1);",
          "330:   if (!wtap_read_bytes(wth->fh, comment, record_length,",
          "331:       err, err_info)) {",
          "340:   }",
          "341:   comment[record_length] = '\\0';",
          "342:   wth->shb_hdr.opt_comment = comment;",
          "",
          "[Removed Lines]",
          "332:    if (*err == WTAP_ERR_SHORT_READ) {",
          "337:     return 0;",
          "338:    }",
          "339:    return -1;",
          "",
          "[Added Lines]",
          "327:    if (*err != WTAP_ERR_SHORT_READ)",
          "328:     return -1;",
          "329:    return 0;",
          "",
          "---------------"
        ],
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:             return -2;",
          "72:         }",
          "80:     }",
          "81:     payload_length = pletoh16(&tmp);",
          "",
          "[Removed Lines]",
          "73:         if (*err == WTAP_ERR_SHORT_READ) {",
          "77:             return 0;",
          "78:         }",
          "79:         return -1;",
          "",
          "[Added Lines]",
          "73:         if (*err != WTAP_ERR_SHORT_READ)",
          "74:             return -1;",
          "75:         return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:     if (!wtap_read_bytes(fh, &tmp, 2, err, err_info)) {",
          "99:     }",
          "100:     hdr_size = pletoh16(&tmp);",
          "101:     read_sofar = 4;",
          "",
          "[Removed Lines]",
          "92:         if (*err == WTAP_ERR_SHORT_READ) {",
          "96:             return 0;",
          "97:         }",
          "98:         return -1;",
          "",
          "[Added Lines]",
          "88:         if (*err != WTAP_ERR_SHORT_READ)",
          "89:             return -1;",
          "90:         return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "122:         if (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {",
          "123:             g_free(buffer);",
          "131:         }",
          "132:         read_sofar += entry_len - read_sofar;",
          "",
          "[Removed Lines]",
          "124:             if (*err == WTAP_ERR_SHORT_READ) {",
          "128:                 return 0;",
          "129:             }",
          "130:             return -1;",
          "",
          "[Added Lines]",
          "116:             if (*err != WTAP_ERR_SHORT_READ)",
          "117:                 return -1;",
          "118:             return 0;",
          "",
          "---------------"
        ],
        "wiretap/network_instruments.c||wiretap/network_instruments.c": [
          "File: wiretap/network_instruments.c -> wiretap/network_instruments.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: static gboolean process_packet_header(wtap *wth,",
          "104:     packet_entry_header *packet_header, struct wtap_pkthdr *phdr, int *err,",
          "105:     gchar **err_info);",
          "109: static gboolean skip_to_next_packet(wtap *wth, int offset_to_next_packet,",
          "110:     int current_offset_from_packet_header, int *err, char **err_info);",
          "111: static gboolean observer_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,",
          "",
          "[Removed Lines]",
          "106: static int read_packet_data(FILE_T fh, int offset_to_frame,",
          "107:     int current_offset_from_packet_header, Buffer *buf, int length,",
          "108:     int *err, char **err_info);",
          "",
          "[Added Lines]",
          "106: static int read_packet_data(FILE_T fh, int offset_to_frame, int current_offset_from_packet_header,",
          "107:     Buffer *buf, int length, int *err, char **err_info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "339:     if (!wtap_read_bytes_or_eof(fh, packet_header, sizeof *packet_header,",
          "340:                                 err, err_info)) {",
          "344:     }",
          "345:     offset += (int)sizeof *packet_header;",
          "346:     PACKET_ENTRY_HEADER_FROM_LE_IN_PLACE(*packet_header);",
          "",
          "[Removed Lines]",
          "341:         if (*err == 0)",
          "343:         return -1;",
          "",
          "[Added Lines]",
          "340:         if (*err != 0)",
          "341:             return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "498: }",
          "500: static int",
          "504: {",
          "505:     int seek_increment;",
          "506:     int bytes_consumed = 0;",
          "",
          "[Removed Lines]",
          "501: read_packet_data(FILE_T fh, int offset_to_frame,",
          "502:     int current_offset_from_packet_header, Buffer *buf, int length,",
          "503:     int *err, char **err_info)",
          "",
          "[Added Lines]",
          "500: read_packet_data(FILE_T fh, int offset_to_frame, int current_offset_from_packet_header, Buffer *buf,",
          "501:     int length, int *err, char **err_info)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "534: }",
          "536: static gboolean",
          "539: {",
          "540:     int seek_increment;",
          "",
          "[Removed Lines]",
          "537: skip_to_next_packet(wtap *wth, int offset_to_next_packet,",
          "538:     int current_offset_from_packet_header, int *err, char **err_info)",
          "",
          "[Added Lines]",
          "535: skip_to_next_packet(wtap *wth, int offset_to_next_packet, int current_offset_from_packet_header, int *err,",
          "536:     char **err_info)",
          "",
          "---------------"
        ],
        "wiretap/ngsniffer.c||wiretap/ngsniffer.c": [
          "File: wiretap/ngsniffer.c -> wiretap/ngsniffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "790:  for (;;) {",
          "791:   errno = WTAP_ERR_CANT_READ;",
          "792:   if (!wtap_read_bytes_or_eof(wth->fh, record_type, 2, err, err_info)) {",
          "796:   }",
          "798:   type = pletoh16(record_type);",
          "",
          "[Removed Lines]",
          "793:    if (*err == 0)",
          "795:    return -1;",
          "",
          "[Added Lines]",
          "793:    if (*err != 0)",
          "794:     return -1;",
          "",
          "---------------"
        ],
        "wiretap/packetlogger.c||wiretap/packetlogger.c": [
          "File: wiretap/packetlogger.c -> wiretap/packetlogger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:  }",
          "69:  if (!wtap_read_bytes(wth->fh, &type, 1, err, err_info)) {",
          "78:  }",
          "",
          "[Removed Lines]",
          "70:   if (*err == WTAP_ERR_SHORT_READ) {",
          "75:    return 0;",
          "76:   }",
          "77:   return -1;",
          "",
          "[Added Lines]",
          "70:   if (*err != WTAP_ERR_SHORT_READ)",
          "71:    return -1;",
          "72:   return 0;",
          "",
          "---------------"
        ],
        "wiretap/peekclassic.c||wiretap/peekclassic.c": [
          "File: wiretap/peekclassic.c -> wiretap/peekclassic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:           PEEKCLASSIC_V567_HDR_SIZE);",
          "200:   if (!wtap_read_bytes(wth->fh, &ep_hdr.secondary.v567,",
          "201:       (int)sizeof(ep_hdr.secondary.v567), err, err_info)) {",
          "210:   }",
          "212:   if ((0 != ep_hdr.secondary.v567.reserved[0]) ||",
          "",
          "[Removed Lines]",
          "202:    if (*err == WTAP_ERR_SHORT_READ) {",
          "207:     return 0;",
          "208:    }",
          "209:    return -1;",
          "",
          "[Added Lines]",
          "202:    if (*err != WTAP_ERR_SHORT_READ)",
          "203:     return -1;",
          "204:    return 0;",
          "",
          "---------------"
        ],
        "wiretap/radcom.c||wiretap/radcom.c": [
          "File: wiretap/radcom.c -> wiretap/radcom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:  errno = WTAP_ERR_CANT_READ;",
          "124:  if (!wtap_read_bytes(wth->fh, t_magic, 11, err, err_info)) {",
          "133:  }",
          "134:  while (memcmp(t_magic, active_time_magic, 11) != 0)",
          "135:  {",
          "",
          "[Removed Lines]",
          "125:   if (*err == WTAP_ERR_SHORT_READ) {",
          "130:    return 0;",
          "131:   }",
          "132:   return -1;",
          "",
          "[Added Lines]",
          "125:   if (*err != WTAP_ERR_SHORT_READ)",
          "126:    return -1;",
          "127:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "137:    return -1;",
          "138:   errno = WTAP_ERR_CANT_READ;",
          "139:   if (!wtap_read_bytes(wth->fh, t_magic, 11, err, err_info)) {",
          "148:   }",
          "149:  }",
          "150:  if (file_seek(wth->fh, -43, SEEK_CUR, err) == -1) return -1;",
          "",
          "[Removed Lines]",
          "140:    if (*err == WTAP_ERR_SHORT_READ) {",
          "145:     return 0;",
          "146:    }",
          "147:    return -1;",
          "",
          "[Added Lines]",
          "135:    if (*err != WTAP_ERR_SHORT_READ)",
          "136:     return -1;",
          "137:    return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "153:  errno = WTAP_ERR_CANT_READ;",
          "154:  if (!wtap_read_bytes(wth->fh, &start_date, sizeof(struct frame_date),",
          "155:      err, err_info)) {",
          "164:  }",
          "166:  if (file_seek(wth->fh, sizeof(struct frame_date), SEEK_CUR, err) == -1)",
          "",
          "[Removed Lines]",
          "156:   if (*err == WTAP_ERR_SHORT_READ) {",
          "161:    return 0;",
          "162:   }",
          "163:   return -1;",
          "",
          "[Added Lines]",
          "146:   if (*err != WTAP_ERR_SHORT_READ)",
          "147:    return -1;",
          "148:   return 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "170:   errno = WTAP_ERR_CANT_READ;",
          "171:   if (!wtap_read_bytes(wth->fh, search_encap, 4,",
          "172:       err, err_info)) {",
          "181:   }",
          "183:   if (memcmp(encap_magic, search_encap, 4) == 0)",
          "",
          "[Removed Lines]",
          "173:    if (*err == WTAP_ERR_SHORT_READ) {",
          "178:     return 0;",
          "179:    }",
          "180:    return -1;",
          "",
          "[Added Lines]",
          "158:    if (*err != WTAP_ERR_SHORT_READ)",
          "159:     return -1;",
          "160:    return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "196:   return -1;",
          "197:  errno = WTAP_ERR_CANT_READ;",
          "198:  if (!wtap_read_bytes(wth->fh, search_encap, 4, err, err_info)) {",
          "207:  }",
          "",
          "[Removed Lines]",
          "199:   if (*err == WTAP_ERR_SHORT_READ) {",
          "204:    return 0;",
          "205:   }",
          "206:   return -1;",
          "",
          "[Added Lines]",
          "179:   if (*err != WTAP_ERR_SHORT_READ)",
          "180:    return -1;",
          "181:   return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1275d05913e7ad40208fd34746748ff9ac3324b3",
      "candidate_info": {
        "commit_hash": "1275d05913e7ad40208fd34746748ff9ac3324b3",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1275d05913e7ad40208fd34746748ff9ac3324b3",
        "files": [
          "wiretap/logcat.c",
          "wiretap/logcat_text.c"
        ],
        "message": "Reduce compilator warnings\n\nwarning: cast from 'const guint8 *' (aka 'const unsigned char *') to\n\t'const guint16 *' (aka 'const unsigned short *') increases required\n\talignment from 1 to 2 [-Wcast-align]\nwarning: cast from 'const guint8 *' (aka 'const unsigned char *') to\n\t'const struct logger_entry *' increases required alignment\n\tfrom 1 to 4 [-Wcast-align]\n\nChange-Id: I1ef8bfedb31c3f633166405689d8d788d45365db\nReviewed-on: https://code.wireshark.org/review/4236\nPetri-Dish: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/logcat_text.c||wiretap/logcat_text.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
          "",
          "[Removed Lines]",
          "88:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
          "89:     log_entry = (struct logger_entry *) buffer;",
          "",
          "[Added Lines]",
          "88:     log_entry_v2 = (struct logger_entry_v2 *)(void *) buffer;",
          "89:     log_entry = (struct logger_entry *)(void *) buffer;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143:     const guint16  *tag_length;",
          "144:     gint            length = 0;",
          "148:     while(GINT16_FROM_BE(*tag)) {",
          "150:         length += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "152:         pd += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "154:     }",
          "156:     length += 2 + 2;",
          "",
          "[Removed Lines]",
          "146:     tag = (const guint16 *) pd;",
          "149:         tag_length = (const guint16 *) (pd + 2);",
          "153:         tag = (const guint16 *) pd;",
          "",
          "[Added Lines]",
          "146:     tag = (const guint16 *)(const void *) pd;",
          "149:         tag_length = (const guint16 *)(const void *) (pd + 2);",
          "153:         tag = (const guint16 *)(const void *) pd;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "188:     ws_buffer_assure_space(buf, packet_size);",
          "189:     pd = ws_buffer_start_ptr(buf);",
          "193:     memcpy(pd, tmp, 2);",
          "",
          "[Removed Lines]",
          "190:     log_entry = (struct logger_entry *) pd;",
          "",
          "[Added Lines]",
          "190:     log_entry = (struct logger_entry *)(void *) pd;",
          "",
          "---------------"
        ],
        "wiretap/logcat_text.c||wiretap/logcat_text.c": [
          "File: wiretap/logcat_text.c -> wiretap/logcat_text.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     guint8                  *msg_end;",
          "65:     guint16                  msg_len;",
          "71:     if (log_entry->len < 3)",
          "",
          "[Removed Lines]",
          "67:     log_entry_v2 = (const struct logger_entry_v2 *) pd;",
          "68:     log_entry = (const struct logger_entry *) pd;",
          "",
          "[Added Lines]",
          "67:     log_entry    = (const struct logger_entry *)(const void *) pd;",
          "68:     log_entry_v2 = (const struct logger_entry_v2 *)(const void *) pd;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "459:             logcat_version = pseudo_header->logcat.version;",
          "460:         }",
          "465:         payload_length = GINT32_FROM_LE(log_entry->len);",
          "466:         pid = GINT32_FROM_LE(log_entry->pid);",
          "",
          "[Removed Lines]",
          "462:         log_entry = (const struct logger_entry *) pd;",
          "463:         log_entry_v2 = (const struct logger_entry_v2 *) pd;",
          "",
          "[Added Lines]",
          "462:         log_entry    = (const struct logger_entry *)(const void *) pd;",
          "463:         log_entry_v2 = (const struct logger_entry_v2 *)(const void *) pd;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
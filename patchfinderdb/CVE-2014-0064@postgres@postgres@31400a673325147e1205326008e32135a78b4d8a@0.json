{
  "cve_id": "CVE-2014-0064",
  "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.",
  "repo": "postgres/postgres",
  "patch_hash": "31400a673325147e1205326008e32135a78b4d8a",
  "patch_info": {
    "commit_hash": "31400a673325147e1205326008e32135a78b4d8a",
    "repo": "postgres/postgres",
    "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a",
    "files": [
      "contrib/hstore/hstore.h",
      "contrib/hstore/hstore_io.c",
      "contrib/hstore/hstore_op.c",
      "contrib/intarray/_int.h",
      "contrib/intarray/_int_bool.c",
      "contrib/ltree/ltree.h",
      "contrib/ltree/ltree_io.c",
      "contrib/ltree/ltxtquery_io.c",
      "src/backend/utils/adt/geo_ops.c",
      "src/backend/utils/adt/tsquery.c",
      "src/backend/utils/adt/tsquery_util.c",
      "src/backend/utils/adt/txid.c",
      "src/backend/utils/adt/varbit.c",
      "src/include/tsearch/ts_type.h",
      "src/include/utils/varbit.h"
    ],
    "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
    "before_after_code_files": [
      "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
      "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
      "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
      "contrib/intarray/_int.h||contrib/intarray/_int.h",
      "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
      "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
      "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
      "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
      "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
      "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
      "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
      "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
      "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
      "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
      "src/include/utils/varbit.h||src/include/utils/varbit.h"
    ]
  },
  "patch_diff": {
    "contrib/hstore/hstore.h||contrib/hstore/hstore.h": [
      "File: contrib/hstore/hstore.h -> contrib/hstore/hstore.h"
    ],
    "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c": [
      "File: contrib/hstore/hstore_io.c -> contrib/hstore/hstore_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #include \"utils/builtins.h\"",
      "14: #include \"utils/json.h\"",
      "15: #include \"utils/lsyscache.h\"",
      "16: #include \"utils/typcache.h\"",
      "18: #include \"hstore.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "16: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "439:   PG_RETURN_POINTER(out);",
      "440:  }",
      "442:  pairs = palloc(pcount * sizeof(Pairs));",
      "444:  for (i = 0; i < pcount; ++i)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "443:  if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))",
      "444:   ereport(ERROR,",
      "445:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "446:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "447:       pcount, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "554:        TEXTOID, -1, false, 'i',",
      "555:        &key_datums, &key_nulls, &key_count);",
      "559:  if (PG_ARGISNULL(1))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "564:  if (key_count > MaxAllocSize / sizeof(Pairs))",
      "565:   ereport(ERROR,",
      "566:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "567:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "568:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "677:  count = in_count / 2;",
      "679:  pairs = palloc(count * sizeof(Pairs));",
      "681:  for (i = 0; i < count; ++i)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "693:  if (count > MaxAllocSize / sizeof(Pairs))",
      "694:   ereport(ERROR,",
      "695:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "696:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "697:       count, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------"
    ],
    "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c": [
      "File: contrib/hstore/hstore_op.c -> contrib/hstore/hstore_op.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: #include \"catalog/pg_type.h\"",
      "9: #include \"funcapi.h\"",
      "10: #include \"utils/builtins.h\"",
      "12: #include \"hstore.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "90:   return NULL;",
      "91:  }",
      "93:  key_pairs = palloc(sizeof(Pairs) * key_count);",
      "95:  for (i = 0, j = 0; i < key_count; i++)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "101:  if (key_count > MaxAllocSize / sizeof(Pairs))",
      "102:   ereport(ERROR,",
      "103:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "104:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "105:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------"
    ],
    "contrib/intarray/_int.h||contrib/intarray/_int.h": [
      "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: #define ___INT_H__",
      "7: #include \"utils/array.h\"",
      "10: #define MAXNUMRANGE 100",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "138: #define HDRSIZEQT offsetof(QUERYTYPE, items)",
      "139: #define COMPUTESIZE(size) ( HDRSIZEQT + (size) * sizeof(ITEM) )",
      "140: #define GETQUERY(x)  ( (x)->items )",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "141: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
      "",
      "---------------"
    ],
    "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
      "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "448: static void",
      "449: findoprnd(ITEM *ptr, int32 *pos)",
      "450: {",
      "451: #ifdef BS_DEBUG",
      "452:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
      "453:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "452:  check_stack_depth();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "508:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
      "509:      errmsg(\"empty query\")));",
      "511:  commonlen = COMPUTESIZE(state.num);",
      "512:  query = (QUERYTYPE *) palloc(commonlen);",
      "513:  SET_VARSIZE(query, commonlen);",
      "514:  query->size = state.num;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "514:  if (state.num > QUERYTYPEMAXITEMS)",
      "515:   ereport(ERROR,",
      "516:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "517:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
      "518:       state.num, (int) QUERYTYPEMAXITEMS)));",
      "",
      "---------------"
    ],
    "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
      "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "6: #include \"fmgr.h\"",
      "7: #include \"tsearch/ts_locale.h\"",
      "9: typedef struct",
      "10: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "112: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int32))",
      "113: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
      "114: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
      "115: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "115: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
      "116:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
      "",
      "---------------"
    ],
    "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
      "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: #include <ctype.h>",
      "10: #include \"ltree.h\"",
      "11: #include \"crc32.h\"",
      "13: PG_FUNCTION_INFO_V1(ltree_in);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:   ptr += charlen;",
      "65:  }",
      "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
      "68:  ptr = buf;",
      "69:  while (*ptr)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
      "69:   ereport(ERROR,",
      "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
      "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "228:  }",
      "230:  num++;",
      "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
      "232:  ptr = buf;",
      "233:  while (*ptr)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "237:  if (num > MaxAllocSize / ITEMSIZE)",
      "238:   ereport(ERROR,",
      "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
      "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
      "",
      "---------------"
    ],
    "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
      "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: #include \"crc32.h\"",
      "11: #include \"ltree.h\"",
      "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
      "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: #include \"miscadmin.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "212:  int32  lenstack = 0;",
      "213:  uint16  flag = 0;",
      "215:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
      "216:  {",
      "217:   switch (type)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "217:  check_stack_depth();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "276: static void",
      "277: findoprnd(ITEM *ptr, int32 *pos)",
      "278: {",
      "279:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
      "280:  {",
      "281:   ptr[*pos].left = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "284:  check_stack_depth();",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "340:      errmsg(\"syntax error\"),",
      "341:      errdetail(\"Empty query.\")));",
      "344:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
      "345:  query = (ltxtquery *) palloc(commonlen);",
      "346:  SET_VARSIZE(query, commonlen);",
      "347:  query->size = state.num;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "350:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
      "351:   ereport(ERROR,",
      "352:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "353:      errmsg(\"ltxtquery is too large\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
      "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1366:  char    *s;",
      "1367:  int   npts;",
      "1368:  int   size;",
      "1369:  int   depth = 0;",
      "1371:  if ((npts = pair_count(str, ',')) <= 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1369:  int   base_size;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1384:   depth++;",
      "1385:  }",
      "1388:  path = (PATH *) palloc(size);",
      "1390:  SET_VARSIZE(path, size);",
      "",
      "[Removed Lines]",
      "1387:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
      "",
      "[Added Lines]",
      "1388:  base_size = sizeof(path->p[0]) * npts;",
      "1389:  size = offsetof(PATH, p[0]) + base_size;",
      "1392:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
      "1393:   ereport(ERROR,",
      "1394:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "1395:      errmsg(\"too many points requested\")));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3429:  POLYGON    *poly;",
      "3430:  int   npts;",
      "3431:  int   size;",
      "3432:  int   isopen;",
      "3433:  char    *s;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3441:  int   base_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3437:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
      "3438:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
      "3443:  SET_VARSIZE(poly, size);",
      "",
      "[Removed Lines]",
      "3440:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
      "",
      "[Added Lines]",
      "3450:  base_size = sizeof(poly->p[0]) * npts;",
      "3451:  size = offsetof(POLYGON, p[0]) + base_size;",
      "3454:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
      "3455:   ereport(ERROR,",
      "3456:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "3457:      errmsg(\"too many points requested\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
      "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "514:   return query;",
      "515:  }",
      "518:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
      "519:  query = (TSQuery) palloc0(commonlen);",
      "520:  SET_VARSIZE(query, commonlen);",
      "521:  query->size = list_length(state.polstr);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "517:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
      "518:   ereport(ERROR,",
      "519:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "520:      errmsg(\"tsquery is too large\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
      "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "333:  QTN2QTState state;",
      "335:  cntsize(in, &sumlen, &nnode);",
      "336:  len = COMPUTESIZE(nnode, sumlen);",
      "338:  out = (TSQuery) palloc0(len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "337:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
      "338:   ereport(ERROR,",
      "339:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "340:      errmsg(\"tsquery is too large\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
      "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "26: #include \"funcapi.h\"",
      "27: #include \"miscadmin.h\"",
      "28: #include \"libpq/pqformat.h\"",
      "29: #include \"utils/builtins.h\"",
      "30: #include \"utils/snapmgr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "29: #include \"postmaster/postmaster.h\"",
      "31: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "67: #define TXID_SNAPSHOT_SIZE(nxip) \\",
      "68:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "71: #define TXID_SNAPSHOT_MAX_NXIP \\",
      "72:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "369:  load_xid_epoch(&state);",
      "372:  nxip = cur->xcnt;",
      "373:  size = TXID_SNAPSHOT_SIZE(nxip);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:  StaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,",
      "380:       \"possible overflow in txid_current_snapshot()\");",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "445:  txid  last = 0;",
      "446:  int   nxip;",
      "447:  int   i;",
      "450:  txid  xmin,",
      "451:     xmax;",
      "458:  nxip = pq_getmsgint(buf, 4);",
      "462:   goto bad_format;",
      "464:  xmin = pq_getmsgint64(buf);",
      "",
      "[Removed Lines]",
      "448:  int   avail;",
      "449:  int   expect;",
      "459:  avail = buf->len - buf->cursor;",
      "460:  expect = 8 + 8 + nxip * 8;",
      "461:  if (nxip < 0 || nxip > avail || expect > avail)",
      "",
      "[Added Lines]",
      "464:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
      "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "148:   sp = input_string;",
      "149:  }",
      "151:  slen = strlen(sp);",
      "153:  if (bit_not_hex)",
      "154:   bitlen = slen;",
      "155:  else",
      "156:   bitlen = slen * 4;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "159:  {",
      "160:   if (slen > VARBITMAXLEN / 4)",
      "161:    ereport(ERROR,",
      "162:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "163:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
      "164:       VARBITMAXLEN)));",
      "166:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "450:   sp = input_string;",
      "451:  }",
      "453:  slen = strlen(sp);",
      "455:  if (bit_not_hex)",
      "456:   bitlen = slen;",
      "457:  else",
      "458:   bitlen = slen * 4;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "471:  {",
      "472:   if (slen > VARBITMAXLEN / 4)",
      "473:    ereport(ERROR,",
      "474:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "475:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
      "476:       VARBITMAXLEN)));",
      "478:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "944:  bitlen1 = VARBITLEN(arg1);",
      "945:  bitlen2 = VARBITLEN(arg2);",
      "947:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
      "949:  result = (VarBit *) palloc(bytelen);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "970:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
      "971:   ereport(ERROR,",
      "972:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "973:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
      "974:       VARBITMAXLEN)));",
      "",
      "---------------"
    ],
    "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
      "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #define _PG_TSTYPE_H_",
      "15: #include \"fmgr.h\"",
      "16: #include \"utils/pg_crc.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "16: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "246: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
      "249: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "248: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
      "249:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
      "",
      "---------------"
    ],
    "src/include/utils/varbit.h||src/include/utils/varbit.h": [
      "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: #ifndef VARBIT_H",
      "16: #define VARBIT_H",
      "18: #include \"fmgr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: #include <limits.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
      "55:          VARHDRSZ + VARBITHDRSZ)",
      "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "823b9dc2566dbdbdab3c08b83adb64eb428b8ca5",
      "candidate_info": {
        "commit_hash": "823b9dc2566dbdbdab3c08b83adb64eb428b8ca5",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/823b9dc2566dbdbdab3c08b83adb64eb428b8ca5",
        "files": [
          "src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h",
          "src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c"
        ],
        "message": "Prevent privilege escalation in explicit calls to PL validators.\n\nThe primary role of PL validators is to be called implicitly during\nCREATE FUNCTION, but they are also normal functions that a user can call\nexplicitly.  Add a permissions check to each validator to ensure that a\nuser cannot use explicit validator calls to achieve things he could not\notherwise achieve.  Back-patch to 8.4 (all supported versions).\nNon-core procedural language extensions ought to make the same two-line\nchange to their own validators.\n\nAndres Freund, reviewed by Tom Lane and Noah Misch.\n\nSecurity: CVE-2014-0061",
        "before_after_code_files": [
          "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h||src/include/fmgr.h",
          "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c": [
          "File: src/backend/catalog/pg_proc.c -> src/backend/catalog/pg_proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "623:  Datum  tmp;",
          "624:  char    *prosrc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "626:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "627:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "672:  char    *prosrc;",
          "673:  char    *probin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "678:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "679:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "724:  bool  haspolyarg;",
          "725:  int   i;",
          "727:  tuple = SearchSysCache(PROCOID,",
          "728:          ObjectIdGetDatum(funcoid),",
          "729:          0, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "733:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "734:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c": [
          "File: src/backend/commands/functioncmds.c -> src/backend/commands/functioncmds.c"
        ],
        "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c": [
          "File: src/backend/utils/fmgr/fmgr.c -> src/backend/utils/fmgr/fmgr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"miscadmin.h\"",
          "25: #include \"nodes/nodeFuncs.h\"",
          "26: #include \"pgstat.h\"",
          "27: #include \"utils/builtins.h\"",
          "28: #include \"utils/fmgrtab.h\"",
          "29: #include \"utils/guc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"utils/acl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2429:  return false;",
          "2430: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2463: bool",
          "2464: CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid)",
          "2465: {",
          "2466:  HeapTuple procTup;",
          "2467:  HeapTuple langTup;",
          "2468:  Form_pg_proc procStruct;",
          "2469:  Form_pg_language langStruct;",
          "2470:  AclResult aclresult;",
          "2473:  procTup = SearchSysCache(PROCOID, ObjectIdGetDatum(functionOid), 0, 0, 0);",
          "2474:  if (!HeapTupleIsValid(procTup))",
          "2475:   elog(ERROR, \"cache lookup failed for function %u\", functionOid);",
          "2476:  procStruct = (Form_pg_proc) GETSTRUCT(procTup);",
          "2482:  langTup = SearchSysCache(LANGOID, ObjectIdGetDatum(procStruct->prolang),",
          "2483:         0, 0, 0);",
          "2484:  if (!HeapTupleIsValid(langTup))",
          "2485:   elog(ERROR, \"cache lookup failed for language %u\", procStruct->prolang);",
          "2486:  langStruct = (Form_pg_language) GETSTRUCT(langTup);",
          "2488:  if (langStruct->lanvalidator != validatorOid)",
          "2489:   ereport(ERROR,",
          "2490:     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),",
          "2491:      errmsg(\"language validation function %u called for language %u instead of %u\",",
          "2492:       validatorOid, procStruct->prolang,",
          "2493:       langStruct->lanvalidator)));",
          "2496:  aclresult = pg_language_aclcheck(procStruct->prolang, GetUserId(),",
          "2497:           ACL_USAGE);",
          "2498:  if (aclresult != ACLCHECK_OK)",
          "2499:   aclcheck_error(aclresult, ACL_KIND_LANGUAGE,",
          "2500:         NameStr(langStruct->lanname));",
          "2507:  aclresult = pg_proc_aclcheck(functionOid, GetUserId(), ACL_EXECUTE);",
          "2508:  if (aclresult != ACLCHECK_OK)",
          "2509:   aclcheck_error(aclresult, ACL_KIND_PROC, NameStr(procStruct->proname));",
          "2511:  ReleaseSysCache(procTup);",
          "2512:  ReleaseSysCache(langTup);",
          "2514:  return true;",
          "2515: }",
          "",
          "---------------"
        ],
        "src/include/fmgr.h||src/include/fmgr.h": [
          "File: src/include/fmgr.h -> src/include/fmgr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "518: extern Oid get_call_expr_argtype(fmNodePtr expr, int argnum);",
          "519: extern bool get_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum);",
          "520: extern bool get_call_expr_arg_stable(fmNodePtr expr, int argnum);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "521: extern bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);",
          "",
          "---------------"
        ],
        "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c": [
          "File: src/pl/plperl/plperl.c -> src/pl/plperl/plperl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1094:  bool  istrigger = false;",
          "1095:  int   i;",
          "1098:  tuple = SearchSysCache(PROCOID,",
          "1099:          ObjectIdGetDatum(funcoid),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1097:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "1098:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c": [
          "File: src/pl/plpgsql/src/pl_handler.c -> src/pl/plpgsql/src/pl_handler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "136:  bool  istrigger = false;",
          "137:  int   i;",
          "140:  tuple = SearchSysCache(PROCOID,",
          "141:          ObjectIdGetDatum(funcoid),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "140:   PG_RETURN_VOID();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0ac4c75ff048b8ff6d8436946e9c414c2b64f94",
      "candidate_info": {
        "commit_hash": "c0ac4c75ff048b8ff6d8436946e9c414c2b64f94",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/c0ac4c75ff048b8ff6d8436946e9c414c2b64f94",
        "files": [
          "doc/src/sgml/plhandler.sgml",
          "src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h",
          "src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c"
        ],
        "message": "Prevent privilege escalation in explicit calls to PL validators.\n\nThe primary role of PL validators is to be called implicitly during\nCREATE FUNCTION, but they are also normal functions that a user can call\nexplicitly.  Add a permissions check to each validator to ensure that a\nuser cannot use explicit validator calls to achieve things he could not\notherwise achieve.  Back-patch to 8.4 (all supported versions).\nNon-core procedural language extensions ought to make the same two-line\nchange to their own validators.\n\nAndres Freund, reviewed by Tom Lane and Noah Misch.\n\nSecurity: CVE-2014-0061",
        "before_after_code_files": [
          "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h||src/include/fmgr.h",
          "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c": [
          "File: src/backend/catalog/pg_proc.c -> src/backend/catalog/pg_proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "688:  Datum  tmp;",
          "689:  char    *prosrc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "691:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "692:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "735:  char    *prosrc;",
          "736:  char    *probin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "742:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "785:  bool  haspolyarg;",
          "786:  int   i;",
          "788:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "789:  if (!HeapTupleIsValid(tuple))",
          "790:   elog(ERROR, \"cache lookup failed for function %u\", funcoid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "794:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "795:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c": [
          "File: src/backend/commands/functioncmds.c -> src/backend/commands/functioncmds.c"
        ],
        "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c": [
          "File: src/backend/utils/fmgr/fmgr.c -> src/backend/utils/fmgr/fmgr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"miscadmin.h\"",
          "25: #include \"nodes/nodeFuncs.h\"",
          "26: #include \"pgstat.h\"",
          "27: #include \"utils/builtins.h\"",
          "28: #include \"utils/fmgrtab.h\"",
          "29: #include \"utils/guc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"utils/acl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2410:  return false;",
          "2411: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2444: bool",
          "2445: CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid)",
          "2446: {",
          "2447:  HeapTuple procTup;",
          "2448:  HeapTuple langTup;",
          "2449:  Form_pg_proc procStruct;",
          "2450:  Form_pg_language langStruct;",
          "2451:  AclResult aclresult;",
          "2454:  procTup = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionOid));",
          "2455:  if (!HeapTupleIsValid(procTup))",
          "2456:   elog(ERROR, \"cache lookup failed for function %u\", functionOid);",
          "2457:  procStruct = (Form_pg_proc) GETSTRUCT(procTup);",
          "2463:  langTup = SearchSysCache1(LANGOID, ObjectIdGetDatum(procStruct->prolang));",
          "2464:  if (!HeapTupleIsValid(langTup))",
          "2465:   elog(ERROR, \"cache lookup failed for language %u\", procStruct->prolang);",
          "2466:  langStruct = (Form_pg_language) GETSTRUCT(langTup);",
          "2468:  if (langStruct->lanvalidator != validatorOid)",
          "2469:   ereport(ERROR,",
          "2470:     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),",
          "2471:      errmsg(\"language validation function %u called for language %u instead of %u\",",
          "2472:       validatorOid, procStruct->prolang,",
          "2473:       langStruct->lanvalidator)));",
          "2476:  aclresult = pg_language_aclcheck(procStruct->prolang, GetUserId(),",
          "2477:           ACL_USAGE);",
          "2478:  if (aclresult != ACLCHECK_OK)",
          "2479:   aclcheck_error(aclresult, ACL_KIND_LANGUAGE,",
          "2480:         NameStr(langStruct->lanname));",
          "2487:  aclresult = pg_proc_aclcheck(functionOid, GetUserId(), ACL_EXECUTE);",
          "2488:  if (aclresult != ACLCHECK_OK)",
          "2489:   aclcheck_error(aclresult, ACL_KIND_PROC, NameStr(procStruct->proname));",
          "2491:  ReleaseSysCache(procTup);",
          "2492:  ReleaseSysCache(langTup);",
          "2494:  return true;",
          "2495: }",
          "",
          "---------------"
        ],
        "src/include/fmgr.h||src/include/fmgr.h": [
          "File: src/include/fmgr.h -> src/include/fmgr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "518: extern Oid get_call_expr_argtype(fmNodePtr expr, int argnum);",
          "519: extern bool get_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum);",
          "520: extern bool get_call_expr_arg_stable(fmNodePtr expr, int argnum);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "521: extern bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);",
          "",
          "---------------"
        ],
        "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c": [
          "File: src/pl/plperl/plperl.c -> src/pl/plperl/plperl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1395:  bool  istrigger = false;",
          "1396:  int   i;",
          "1399:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "1400:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1398:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "1399:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c": [
          "File: src/pl/plpgsql/src/pl_handler.c -> src/pl/plpgsql/src/pl_handler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:  bool  istrigger = false;",
          "218:  int   i;",
          "221:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "222:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "221:   PG_RETURN_VOID();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "15a8f97b9d16aaf659f58c981242b9da591cf24c",
      "candidate_info": {
        "commit_hash": "15a8f97b9d16aaf659f58c981242b9da591cf24c",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/15a8f97b9d16aaf659f58c981242b9da591cf24c",
        "files": [
          "doc/src/sgml/ref/grant.sgml",
          "src/backend/commands/user.c",
          "src/backend/utils/adt/acl.c",
          "src/test/regress/expected/privileges.out",
          "src/test/regress/sql/privileges.sql"
        ],
        "message": "Shore up ADMIN OPTION restrictions.\n\nGranting a role without ADMIN OPTION is supposed to prevent the grantee\nfrom adding or removing members from the granted role.  Issuing SET ROLE\nbefore the GRANT bypassed that, because the role itself had an implicit\nright to add or remove members.  Plug that hole by recognizing that\nimplicit right only when the session user matches the current role.\nAdditionally, do not recognize it during a security-restricted operation\nor during execution of a SECURITY DEFINER function.  The restriction on\nSECURITY DEFINER is not security-critical.  However, it seems best for a\nuser testing his own SECURITY DEFINER function to see the same behavior\nothers will see.  Back-patch to 8.4 (all supported versions).\n\nThe SQL standards do not conflate roles and users as PostgreSQL does;\nonly SQL roles have members, and only SQL users initiate sessions.  An\napplication using PostgreSQL users and roles as SQL users and roles will\nnever attempt to grant membership in the role that is the session user,\nso the implicit right to add or remove members will never arise.\n\nThe security impact was mostly that a role member could revoke access\nfrom others, contrary to the wishes of his own grantor.  Unapproved role\nmember additions are less notable, because the member can still largely\nachieve that by creating a view or a SECURITY DEFINER function.\n\nReviewed by Andres Freund and Tom Lane.  Reported, independently, by\nJonas Sundman and Noah Misch.\n\nSecurity: CVE-2014-0060",
        "before_after_code_files": [
          "src/backend/commands/user.c||src/backend/commands/user.c",
          "src/backend/utils/adt/acl.c||src/backend/utils/adt/acl.c",
          "src/test/regress/sql/privileges.sql||src/test/regress/sql/privileges.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/commands/user.c||src/backend/commands/user.c": [
          "File: src/backend/commands/user.c -> src/backend/commands/user.c"
        ],
        "src/backend/utils/adt/acl.c||src/backend/utils/adt/acl.c": [
          "File: src/backend/utils/adt/acl.c -> src/backend/utils/adt/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4910:  List    *roles_list;",
          "4911:  ListCell   *l;",
          "4918:  if (superuser_arg(member))",
          "4919:   return true;",
          "",
          "[Removed Lines]",
          "4914:  if (member == role)",
          "4915:   return true;",
          "",
          "[Added Lines]",
          "4919:  if (member == role)",
          "4948:   return member == GetSessionUserId() &&",
          "4949:    !InLocalUserIdChange() && !InSecurityRestrictedOperation();",
          "",
          "---------------"
        ],
        "src/test/regress/sql/privileges.sql||src/test/regress/sql/privileges.sql": [
          "File: src/test/regress/sql/privileges.sql -> src/test/regress/sql/privileges.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: ALTER GROUP regressgroup2 ADD USER regressuser2; -- duplicate",
          "39: ALTER GROUP regressgroup2 DROP USER regressuser2;",
          "42: -- test owner privileges",
          "",
          "[Removed Lines]",
          "40: ALTER GROUP regressgroup2 ADD USER regressuser4;",
          "",
          "[Added Lines]",
          "40: GRANT regressgroup2 TO regressuser4 WITH ADMIN OPTION;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "581: SELECT has_table_privilege('regressuser1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true",
          "584: -- has_sequence_privilege tests",
          "585: \\c -",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "584: -- Admin options",
          "586: SET SESSION AUTHORIZATION regressuser4;",
          "587: CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS",
          "588:  'GRANT regressgroup2 TO regressuser5';",
          "589: GRANT regressgroup2 TO regressuser5; -- ok: had ADMIN OPTION",
          "590: SET ROLE regressgroup2;",
          "591: GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE suspended privilege",
          "593: SET SESSION AUTHORIZATION regressuser1;",
          "594: GRANT regressgroup2 TO regressuser5; -- fails: no ADMIN OPTION",
          "595: SELECT dogrant_ok();   -- ok: SECURITY DEFINER conveys ADMIN",
          "596: SET ROLE regressgroup2;",
          "597: GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE did not help",
          "599: SET SESSION AUTHORIZATION regressgroup2;",
          "600: GRANT regressgroup2 TO regressuser5; -- ok: a role can self-admin",
          "601: CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS",
          "602:  'GRANT regressgroup2 TO regressuser5';",
          "603: SELECT dogrant_fails();   -- fails: no self-admin in SECURITY DEFINER",
          "604: DROP FUNCTION dogrant_fails();",
          "606: SET SESSION AUTHORIZATION regressuser4;",
          "607: DROP FUNCTION dogrant_ok();",
          "608: REVOKE regressgroup2 FROM regressuser5;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "23b5a85e60c464ab8bc438a547a4b15260ca9453",
      "candidate_info": {
        "commit_hash": "23b5a85e60c464ab8bc438a547a4b15260ca9453",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/23b5a85e60c464ab8bc438a547a4b15260ca9453",
        "files": [
          "doc/src/sgml/plhandler.sgml",
          "src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h",
          "src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c",
          "src/pl/plpython/plpython.c"
        ],
        "message": "Prevent privilege escalation in explicit calls to PL validators.\n\nThe primary role of PL validators is to be called implicitly during\nCREATE FUNCTION, but they are also normal functions that a user can call\nexplicitly.  Add a permissions check to each validator to ensure that a\nuser cannot use explicit validator calls to achieve things he could not\notherwise achieve.  Back-patch to 8.4 (all supported versions).\nNon-core procedural language extensions ought to make the same two-line\nchange to their own validators.\n\nAndres Freund, reviewed by Tom Lane and Noah Misch.\n\nSecurity: CVE-2014-0061",
        "before_after_code_files": [
          "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h||src/include/fmgr.h",
          "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c",
          "src/pl/plpython/plpython.c||src/pl/plpython/plpython.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c": [
          "File: src/backend/catalog/pg_proc.c -> src/backend/catalog/pg_proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "694:  Datum  tmp;",
          "695:  char    *prosrc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "697:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "698:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "739:  char    *prosrc;",
          "740:  char    *probin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "745:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "746:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "790:  bool  haspolyarg;",
          "791:  int   i;",
          "793:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "794:  if (!HeapTupleIsValid(tuple))",
          "795:   elog(ERROR, \"cache lookup failed for function %u\", funcoid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "799:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "800:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c": [
          "File: src/backend/commands/functioncmds.c -> src/backend/commands/functioncmds.c"
        ],
        "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c": [
          "File: src/backend/utils/fmgr/fmgr.c -> src/backend/utils/fmgr/fmgr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"miscadmin.h\"",
          "25: #include \"nodes/nodeFuncs.h\"",
          "26: #include \"pgstat.h\"",
          "27: #include \"utils/builtins.h\"",
          "28: #include \"utils/fmgrtab.h\"",
          "29: #include \"utils/guc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"utils/acl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2446:  return false;",
          "2447: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2480: bool",
          "2481: CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid)",
          "2482: {",
          "2483:  HeapTuple procTup;",
          "2484:  HeapTuple langTup;",
          "2485:  Form_pg_proc procStruct;",
          "2486:  Form_pg_language langStruct;",
          "2487:  AclResult aclresult;",
          "2490:  procTup = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionOid));",
          "2491:  if (!HeapTupleIsValid(procTup))",
          "2492:   elog(ERROR, \"cache lookup failed for function %u\", functionOid);",
          "2493:  procStruct = (Form_pg_proc) GETSTRUCT(procTup);",
          "2499:  langTup = SearchSysCache1(LANGOID, ObjectIdGetDatum(procStruct->prolang));",
          "2500:  if (!HeapTupleIsValid(langTup))",
          "2501:   elog(ERROR, \"cache lookup failed for language %u\", procStruct->prolang);",
          "2502:  langStruct = (Form_pg_language) GETSTRUCT(langTup);",
          "2504:  if (langStruct->lanvalidator != validatorOid)",
          "2505:   ereport(ERROR,",
          "2506:     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),",
          "2507:      errmsg(\"language validation function %u called for language %u instead of %u\",",
          "2508:       validatorOid, procStruct->prolang,",
          "2509:       langStruct->lanvalidator)));",
          "2512:  aclresult = pg_language_aclcheck(procStruct->prolang, GetUserId(),",
          "2513:           ACL_USAGE);",
          "2514:  if (aclresult != ACLCHECK_OK)",
          "2515:   aclcheck_error(aclresult, ACL_KIND_LANGUAGE,",
          "2516:         NameStr(langStruct->lanname));",
          "2523:  aclresult = pg_proc_aclcheck(functionOid, GetUserId(), ACL_EXECUTE);",
          "2524:  if (aclresult != ACLCHECK_OK)",
          "2525:   aclcheck_error(aclresult, ACL_KIND_PROC, NameStr(procStruct->proname));",
          "2527:  ReleaseSysCache(procTup);",
          "2528:  ReleaseSysCache(langTup);",
          "2530:  return true;",
          "2531: }",
          "",
          "---------------"
        ],
        "src/include/fmgr.h||src/include/fmgr.h": [
          "File: src/include/fmgr.h -> src/include/fmgr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "624: extern Oid get_call_expr_argtype(fmNodePtr expr, int argnum);",
          "625: extern bool get_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum);",
          "626: extern bool get_call_expr_arg_stable(fmNodePtr expr, int argnum);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627: extern bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);",
          "",
          "---------------"
        ],
        "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c": [
          "File: src/pl/plperl/plperl.c -> src/pl/plperl/plperl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1846:  bool  istrigger = false;",
          "1847:  int   i;",
          "1850:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "1851:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1849:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "1850:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c": [
          "File: src/pl/plpgsql/src/pl_handler.c -> src/pl/plpgsql/src/pl_handler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "227:  bool  istrigger = false;",
          "228:  int   i;",
          "231:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "232:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "231:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpython/plpython.c||src/pl/plpython/plpython.c": [
          "File: src/pl/plpython/plpython.c -> src/pl/plpython/plpython.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "519:  Form_pg_proc procStruct;",
          "520:  bool  is_trigger;",
          "522:  if (!check_function_bodies)",
          "523:  {",
          "524:   PG_RETURN_VOID();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "522:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "523:   PG_RETURN_VOID();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6a10e57b0f79678243f42e2a6033723975aa8530",
      "candidate_info": {
        "commit_hash": "6a10e57b0f79678243f42e2a6033723975aa8530",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/6a10e57b0f79678243f42e2a6033723975aa8530",
        "files": [
          "src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/expected/interval.out",
          "src/test/regress/sql/interval.sql"
        ],
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
        "before_after_code_files": [
          "src/include/utils/datetime.h||src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/include/utils/datetime.h||src/include/utils/datetime.h": [
          "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "191: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
          "201: typedef struct",
          "",
          "[Removed Lines]",
          "193: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "195: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "197: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "199: #define MAXDATELEN  128",
          "201: #define MAXDATEFIELDS 25",
          "203: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
          "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  int   nf;",
          "62:  char    *field[MAXDATEFIELDS];",
          "63:  int   ftype[MAXDATEFIELDS];",
          "65:  char    *realptr;",
          "66:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "68:  bool  EuroDates = FALSE;",
          "70:  errno = 0;",
          "72:  {",
          "73:   errno = PGTYPES_DATE_BAD_DATE;",
          "74:   return INT_MIN;",
          "",
          "[Removed Lines]",
          "64:  char  lowstr[MAXDATELEN + 1];",
          "71:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "64:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
          "71:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
          "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
          "203: typedef struct",
          "",
          "[Removed Lines]",
          "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "201: #define MAXDATELEN  128",
          "203: #define MAXDATEFIELDS 25",
          "205: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
          "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1164:  if ((cp = strchr(str, '.')) != NULL)",
          "1165:  {",
          "1166: #ifdef HAVE_INT64_TIMESTAMP",
          "1177: #else",
          "",
          "[Removed Lines]",
          "1167:   char  fstr[MAXDATELEN + 1];",
          "1173:   strcpy(fstr, (cp + 1));",
          "1174:   strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1167:   char  fstr[7];",
          "1168:   int   i;",
          "1170:   cp++;",
          "1180:   for (i = 0; i < 6; i++)",
          "1181:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1182:   fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1524:   else if (*cp == '.')",
          "1525:   {",
          "1526: #ifdef HAVE_INT64_TIMESTAMP",
          "1537: #else",
          "1538:    str = cp;",
          "",
          "[Removed Lines]",
          "1527:    char  fstr[MAXDATELEN + 1];",
          "1533:    strncpy(fstr, (cp + 1), 7);",
          "1534:    strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1534:    char  fstr[7];",
          "1535:    int   i;",
          "1537:    cp++;",
          "1547:    for (i = 0; i < 6; i++)",
          "1548:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1549:    fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1671:  while (*(*endstr) != '\\0')",
          "1672:  {",
          "1673:   field[nf] = lp;",
          "1676:   if (isdigit((unsigned char) *(*endstr)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1692:   if (nf >= MAXDATEFIELDS)",
          "1693:    return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1813:   nf++;",
          "1816:  }",
          "",
          "[Removed Lines]",
          "1814:   if (nf > MAXDATEFIELDS)",
          "1815:    return -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
          "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1092:  tm->tm_sec = 0;",
          "1093:  fsec = 0;",
          "1096:  {",
          "1097:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
          "1098:   return NULL;",
          "",
          "[Removed Lines]",
          "1095:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "1095:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
          "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "297:  char    *realptr;",
          "298:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "301:  {",
          "302:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
          "303:   return (noresult);",
          "",
          "[Removed Lines]",
          "300:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "300:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:       \"1999.008\",",
          "46:       \"J2451187\",",
          "47:       \"January 8, 99 BC\",",
          "48:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:       \"1:59 PDT\",",
          "53:       \"13:24:40 -8:00\",",
          "54:       \"13:24:40.495+3\",",
          "55:       NULL };",
          "57: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:       \"13:24:40.123456789+3\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  date date1 ;",
          "80:  timestamp ts1 , ts2 ;",
          "83:  char * text ;",
          "86:  interval * i1 ;",
          "89:  date * dc ;",
          "94:  int i, j;",
          "",
          "[Removed Lines]",
          "76: #line 52 \"dt_test2.pgc\"",
          "79: #line 53 \"dt_test2.pgc\"",
          "82: #line 54 \"dt_test2.pgc\"",
          "85: #line 55 \"dt_test2.pgc\"",
          "88: #line 56 \"dt_test2.pgc\"",
          "91: #line 57 \"dt_test2.pgc\"",
          "",
          "[Added Lines]",
          "86: #line 62 \"dt_test2.pgc\"",
          "89: #line 63 \"dt_test2.pgc\"",
          "92: #line 64 \"dt_test2.pgc\"",
          "95: #line 65 \"dt_test2.pgc\"",
          "98: #line 66 \"dt_test2.pgc\"",
          "101: #line 67 \"dt_test2.pgc\"",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: TS[3,1]: 1999-01-08 01:59:00",
          "9: TS[3,2]: 1999-01-08 13:24:40",
          "10: TS[3,3]: 1999-01-08 13:24:40.495",
          "11: Date[4]: 1999-01-08 (N - F)",
          "12: TS[4,0]: 1999-01-08 00:04:00",
          "13: TS[4,1]: 1999-01-08 01:59:00",
          "14: TS[4,2]: 1999-01-08 13:24:40",
          "15: TS[4,3]: 1999-01-08 13:24:40.495",
          "16: Date[5]: 1999-01-08 (N - F)",
          "17: TS[5,0]: 1999-01-08 00:04:00",
          "18: TS[5,1]: 1999-01-08 01:59:00",
          "19: TS[5,2]: 1999-01-08 13:24:40",
          "20: TS[5,3]: 1999-01-08 13:24:40.495",
          "21: Date[6]: 1999-01-18 (N - F)",
          "22: TS[6,0]: 1999-01-18 00:04:00",
          "23: TS[6,1]: 1999-01-18 01:59:00",
          "24: TS[6,2]: 1999-01-18 13:24:40",
          "25: TS[6,3]: 1999-01-18 13:24:40.495",
          "26: Date[7]: 2003-01-02 (N - F)",
          "27: TS[7,0]: 2003-01-02 00:04:00",
          "28: TS[7,1]: 2003-01-02 01:59:00",
          "29: TS[7,2]: 2003-01-02 13:24:40",
          "30: TS[7,3]: 2003-01-02 13:24:40.495",
          "31: Date[8]: 1999-01-08 (N - F)",
          "32: TS[8,0]: 1999-01-08 00:04:00",
          "33: TS[8,1]: 1999-01-08 01:59:00",
          "34: TS[8,2]: 1999-01-08 13:24:40",
          "35: TS[8,3]: 1999-01-08 13:24:40.495",
          "36: Date[9]: 1999-01-08 (N - F)",
          "37: TS[9,0]: 1999-01-08 00:04:00",
          "38: TS[9,1]: 1999-01-08 01:59:00",
          "39: TS[9,2]: 1999-01-08 13:24:40",
          "40: TS[9,3]: 1999-01-08 13:24:40.495",
          "41: Date[10]: 1999-01-08 (N - F)",
          "42: TS[10,0]: 1999-01-08 00:04:00",
          "43: TS[10,1]: 1999-01-08 01:59:00",
          "44: TS[10,2]: 1999-01-08 13:24:40",
          "45: TS[10,3]: 1999-01-08 13:24:40.495",
          "46: Date[11]: 1999-01-08 (N - F)",
          "47: TS[11,0]: 1999-01-08 00:04:00",
          "48: TS[11,1]: 1999-01-08 01:59:00",
          "49: TS[11,2]: 1999-01-08 13:24:40",
          "50: TS[11,3]: 1999-01-08 13:24:40.495",
          "51: Date[12]: 1999-01-08 (N - F)",
          "52: TS[12,0]: 1999-01-08 00:04:00",
          "53: TS[12,1]: 1999-01-08 01:59:00",
          "54: TS[12,2]: 1999-01-08 13:24:40",
          "55: TS[12,3]: 1999-01-08 13:24:40.495",
          "56: Date[13]: 2006-01-08 (N - F)",
          "57: TS[13,0]: 2006-01-08 00:04:00",
          "58: TS[13,1]: 2006-01-08 01:59:00",
          "59: TS[13,2]: 2006-01-08 13:24:40",
          "60: TS[13,3]: 2006-01-08 13:24:40.495",
          "61: Date[14]: 1999-01-08 (N - F)",
          "62: TS[14,0]: 1999-01-08 00:04:00",
          "63: TS[14,1]: 1999-01-08 01:59:00",
          "64: TS[14,2]: 1999-01-08 13:24:40",
          "65: TS[14,3]: 1999-01-08 13:24:40.495",
          "66: Date[15]: 1999-01-08 (N - F)",
          "67: TS[15,0]: 1999-01-08 00:04:00",
          "68: TS[15,1]: 1999-01-08 01:59:00",
          "69: TS[15,2]: 1999-01-08 13:24:40",
          "70: TS[15,3]: 1999-01-08 13:24:40.495",
          "71: Date[16]: 1999-01-08 (N - F)",
          "72: TS[16,0]: 1999-01-08 00:04:00",
          "73: TS[16,1]: 1999-01-08 01:59:00",
          "74: TS[16,2]: 1999-01-08 13:24:40",
          "75: TS[16,3]: 1999-01-08 13:24:40.495",
          "76: Date[17]: 1999-01-08 (N - F)",
          "77: TS[17,0]: 1999-01-08 00:04:00",
          "78: TS[17,1]: 1999-01-08 01:59:00",
          "79: TS[17,2]: 1999-01-08 13:24:40",
          "80: TS[17,3]: 1999-01-08 13:24:40.495",
          "81: Date[18]: 1999-01-08 (N - F)",
          "82: TS[18,0]: 1999-01-08 00:04:00",
          "83: TS[18,1]: 1999-01-08 01:59:00",
          "84: TS[18,2]: 1999-01-08 13:24:40",
          "85: TS[18,3]: 1999-01-08 13:24:40.495",
          "86: Date[19]: 0099-01-08 BC (N - F)",
          "87: TS[19,0]: 0099-01-08 00:04:00 BC",
          "88: TS[19,1]: 0099-01-08 01:59:00 BC",
          "89: TS[19,2]: 0099-01-08 13:24:40 BC",
          "90: interval[0]: @ 1 min",
          "91: interval_copy[0]: @ 1 min",
          "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: TS[3,4]: 1999-01-08 13:24:40.123456",
          "17: TS[4,4]: 1999-01-08 13:24:40.123456",
          "23: TS[5,4]: 1999-01-08 13:24:40.123456",
          "29: TS[6,4]: 1999-01-18 13:24:40.123456",
          "35: TS[7,4]: 2003-01-02 13:24:40.123456",
          "41: TS[8,4]: 1999-01-08 13:24:40.123456",
          "47: TS[9,4]: 1999-01-08 13:24:40.123456",
          "53: TS[10,4]: 1999-01-08 13:24:40.123456",
          "59: TS[11,4]: 1999-01-08 13:24:40.123456",
          "65: TS[12,4]: 1999-01-08 13:24:40.123456",
          "71: TS[13,4]: 2006-01-08 13:24:40.123456",
          "77: TS[14,4]: 1999-01-08 13:24:40.123456",
          "83: TS[15,4]: 1999-01-08 13:24:40.123456",
          "89: TS[16,4]: 1999-01-08 13:24:40.123456",
          "95: TS[17,4]: 1999-01-08 13:24:40.123456",
          "101: TS[18,4]: 1999-01-08 13:24:40.123456",
          "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
          "107: Date[20]: - (N - T)",
          "108: Date[21]: - (N - T)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
          "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:       \"1999.008\",",
          "28:       \"J2451187\",",
          "29:       \"January 8, 99 BC\",",
          "30:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:       \"1:59 PDT\",",
          "35:       \"13:24:40 -8:00\",",
          "36:       \"13:24:40.495+3\",",
          "37:       NULL };",
          "39: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:       \"13:24:40.123456789+3\",",
          "",
          "---------------"
        ],
        "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
          "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: -- test long interval input",
          "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
          "112: -- test justify_hours() and justify_days()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: -- test long interval output",
          "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
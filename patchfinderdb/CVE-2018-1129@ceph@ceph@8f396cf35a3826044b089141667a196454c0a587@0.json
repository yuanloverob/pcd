{
  "cve_id": "CVE-2018-1129",
  "cve_desc": "A flaw was found in the way signature calculation was handled by cephx authentication protocol. An attacker having access to ceph cluster network who is able to alter the message payload was able to bypass signature checks done by cephx protocol. Ceph branches master, mimic, luminous and jewel are believed to be vulnerable.",
  "repo": "ceph/ceph",
  "patch_hash": "8f396cf35a3826044b089141667a196454c0a587",
  "patch_info": {
    "commit_hash": "8f396cf35a3826044b089141667a196454c0a587",
    "repo": "ceph/ceph",
    "commit_url": "https://github.com/ceph/ceph/commit/8f396cf35a3826044b089141667a196454c0a587",
    "files": [
      "src/auth/cephx/CephxSessionHandler.cc"
    ],
    "message": "auth/cephx/CephxSessionHandler: implement CEPHX_V2 calculation mode\n\nDerive the signature from the entire buffer (both cipher blocks).\n\nSigned-off-by: Sage Weil <sage@redhat.com>",
    "before_after_code_files": [
      "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
    ]
  },
  "patch_diff": {
    "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc": [
      "File: src/auth/cephx/CephxSessionHandler.cc -> src/auth/cephx/CephxSessionHandler.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "29:   const ceph_msg_header& header = m->get_header();",
      "30:   const ceph_msg_footer& footer = m->get_footer();",
      "55:     };",
      "59:     };",
      "69:   ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()",
      "70:    << \" front_crc_ = \" << footer.front_crc",
      "",
      "[Removed Lines]",
      "35:   struct {",
      "36:     __u8 v;",
      "37:     __le64 magic;",
      "38:     __le32 len;",
      "39:     __le32 header_crc;",
      "40:     __le32 front_crc;",
      "41:     __le32 middle_crc;",
      "42:     __le32 data_crc;",
      "43:   } __attribute__ ((packed)) sigblock = {",
      "44:     1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
      "45:     mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
      "46:     mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
      "47:   };",
      "49:   char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
      "51:   try {",
      "52:     const CryptoKey::in_slice_t in {",
      "53:       sizeof(sigblock),",
      "54:       reinterpret_cast<const unsigned char*>(&sigblock)",
      "56:     const CryptoKey::out_slice_t out {",
      "57:       sizeof(exp_buf),",
      "58:       reinterpret_cast<unsigned char*>(&exp_buf)",
      "61:     key.encrypt(cct, in, out);",
      "62:   } catch (std::exception& e) {",
      "63:     lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
      "64:     return -1;",
      "65:   }",
      "",
      "[Added Lines]",
      "32:   if (!HAVE_FEATURE(features, CEPHX_V2)) {",
      "38:     struct {",
      "39:       __u8 v;",
      "40:       __le64 magic;",
      "41:       __le32 len;",
      "42:       __le32 header_crc;",
      "43:       __le32 front_crc;",
      "44:       __le32 middle_crc;",
      "45:       __le32 data_crc;",
      "46:     } __attribute__ ((packed)) sigblock = {",
      "47:       1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
      "48:       mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
      "49:       mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
      "52:     char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
      "54:     try {",
      "55:       const CryptoKey::in_slice_t in {",
      "56:  sizeof(sigblock),",
      "57:  reinterpret_cast<const unsigned char*>(&sigblock)",
      "58:       };",
      "59:       const CryptoKey::out_slice_t out {",
      "60:  sizeof(exp_buf),",
      "61:  reinterpret_cast<unsigned char*>(&exp_buf)",
      "62:       };",
      "63:       key.encrypt(cct, in, out);",
      "64:     } catch (std::exception& e) {",
      "65:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
      "66:       return -1;",
      "67:     }",
      "70:   } else {",
      "72:     struct {",
      "73:       __le32 header_crc;",
      "74:       __le32 front_crc;",
      "75:       __le32 front_len;",
      "76:       __le32 middle_crc;",
      "77:       __le32 middle_len;",
      "78:       __le32 data_crc;",
      "79:       __le32 data_len;",
      "80:       __le32 seq_lower_word;",
      "81:     } __attribute__ ((packed)) sigblock = {",
      "82:       mswab<uint32_t>(header.crc),",
      "83:       mswab<uint32_t>(footer.front_crc),",
      "84:       mswab<uint32_t>(header.front_len),",
      "85:       mswab<uint32_t>(footer.middle_crc),",
      "86:       mswab<uint32_t>(header.middle_len),",
      "87:       mswab<uint32_t>(footer.data_crc),",
      "88:       mswab<uint32_t>(header.data_len),",
      "89:       mswab<uint32_t>(header.seq)",
      "92:     char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
      "94:     try {",
      "95:       const CryptoKey::in_slice_t in {",
      "96:  sizeof(sigblock),",
      "97:  reinterpret_cast<const unsigned char*>(&sigblock)",
      "98:       };",
      "99:       const CryptoKey::out_slice_t out {",
      "100:  sizeof(exp_buf),",
      "101:  reinterpret_cast<unsigned char*>(&exp_buf)",
      "102:       };",
      "103:       key.encrypt(cct, in, out);",
      "104:     } catch (std::exception& e) {",
      "105:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
      "106:       return -1;",
      "107:     }",
      "109:     struct enc {",
      "110:       __le64 a, b, c, d;",
      "111:     } *penc = reinterpret_cast<enc*>(exp_buf);",
      "113:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "546d15b25eb2af8b27ec509344c1a45387f77a57",
      "candidate_info": {
        "commit_hash": "546d15b25eb2af8b27ec509344c1a45387f77a57",
        "repo": "ceph/ceph",
        "commit_url": "https://github.com/ceph/ceph/commit/546d15b25eb2af8b27ec509344c1a45387f77a57",
        "files": [
          "src/auth/cephx/CephxSessionHandler.cc"
        ],
        "message": "auth/cephx/CephxSessionHandler: implement CEPHX_V2 calculation mode\n\nDerive the signature from the entire buffer (both cipher blocks).\n\nSigned-off-by: Sage Weil <sage@redhat.com>\n(cherry picked from commit 8f396cf35a3826044b089141667a196454c0a587)\n\n# Conflicts:\n#\tsrc/auth/cephx/CephxSessionHandler.cc\n\n- master and mimic use no_bl crypto interface, which doesn't exist here,\nso fall back to using bufferlist-based calls into encrypt().\n\n(cherry picked from commit a2b04cc337a6f6f7b7a8b02bf31a8f3448670645)\n\n# Conflicts:\n#\tsrc/auth/cephx/CephxSessionHandler.cc\n\n- mswab differences",
        "before_after_code_files": [
          "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "olp_code_files": {
          "patch": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ],
          "candidate": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc": [
          "File: src/auth/cephx/CephxSessionHandler.cc -> src/auth/cephx/CephxSessionHandler.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   const ceph_msg_header& header = m->get_header();",
          "30:   const ceph_msg_footer& footer = m->get_footer();",
          "60:   ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()",
          "61:    << \" front_crc_ = \" << footer.front_crc",
          "",
          "[Removed Lines]",
          "35:   struct {",
          "36:     __u8 v;",
          "37:     __le64 magic;",
          "38:     __le32 len;",
          "39:     __le32 header_crc;",
          "40:     __le32 front_crc;",
          "41:     __le32 middle_crc;",
          "42:     __le32 data_crc;",
          "43:   } __attribute__ ((packed)) sigblock = {",
          "44:     1, mswab64(AUTH_ENC_MAGIC), mswab32(4*4),",
          "45:     mswab32(header.crc), mswab32(footer.front_crc),",
          "46:     mswab32(footer.middle_crc), mswab32(footer.data_crc)",
          "47:   };",
          "48:   bufferlist bl_plaintext;",
          "49:   bl_plaintext.append(buffer::create_static(sizeof(sigblock), (char*)&sigblock));",
          "51:   bufferlist bl_ciphertext;",
          "52:   if (key.encrypt(cct, bl_plaintext, bl_ciphertext, NULL) < 0) {",
          "53:     lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "54:     return -1;",
          "55:   }",
          "57:   bufferlist::iterator ci = bl_ciphertext.begin();",
          "58:   ::decode(*psig, ci);",
          "",
          "[Added Lines]",
          "32:   if ((features & CEPH_FEATURE_CEPHX_V2) == 0) {",
          "38:     struct {",
          "39:       __u8 v;",
          "40:       __le64 magic;",
          "41:       __le32 len;",
          "42:       __le32 header_crc;",
          "43:       __le32 front_crc;",
          "44:       __le32 middle_crc;",
          "45:       __le32 data_crc;",
          "46:     } __attribute__ ((packed)) sigblock = {",
          "47:       1, mswab64(AUTH_ENC_MAGIC), mswab32(4*4),",
          "48:       mswab32(header.crc), mswab32(footer.front_crc),",
          "49:       mswab32(footer.middle_crc), mswab32(footer.data_crc)",
          "50:     };",
          "52:     bufferlist bl_plaintext;",
          "53:     bl_plaintext.append(buffer::create_static(sizeof(sigblock),",
          "54:            (char*)&sigblock));",
          "56:     bufferlist bl_ciphertext;",
          "57:     if (key.encrypt(cct, bl_plaintext, bl_ciphertext, NULL) < 0) {",
          "58:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "59:       return -1;",
          "60:     }",
          "62:     bufferlist::iterator ci = bl_ciphertext.begin();",
          "63:     ::decode(*psig, ci);",
          "64:   } else {",
          "66:     struct {",
          "67:       __le32 header_crc;",
          "68:       __le32 front_crc;",
          "69:       __le32 front_len;",
          "70:       __le32 middle_crc;",
          "71:       __le32 middle_len;",
          "72:       __le32 data_crc;",
          "73:       __le32 data_len;",
          "74:       __le32 seq_lower_word;",
          "75:     } __attribute__ ((packed)) sigblock = {",
          "76:       mswab32(header.crc),",
          "77:       mswab32(footer.front_crc),",
          "78:       mswab32(header.front_len),",
          "79:       mswab32(footer.middle_crc),",
          "80:       mswab32(header.middle_len),",
          "81:       mswab32(footer.data_crc),",
          "82:       mswab32(header.data_len),",
          "83:       mswab32((uint32_t)header.seq)",
          "84:     };",
          "86:     bufferlist bl_plaintext;",
          "87:     bl_plaintext.append(buffer::create_static(sizeof(sigblock),",
          "88:            (char*)&sigblock));",
          "90:     bufferlist bl_ciphertext;",
          "91:     if (key.encrypt(cct, bl_plaintext, bl_ciphertext, NULL) < 0) {",
          "92:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "93:       return -1;",
          "94:     }",
          "96:     struct enc {",
          "97:       __le64 a, b, c, d;",
          "98:     } *penc = reinterpret_cast<enc*>(bl_ciphertext.c_str());",
          "100:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "436b08688a5be238280a6e93de8658c10d72044c",
      "candidate_info": {
        "commit_hash": "436b08688a5be238280a6e93de8658c10d72044c",
        "repo": "ceph/ceph",
        "commit_url": "https://github.com/ceph/ceph/commit/436b08688a5be238280a6e93de8658c10d72044c",
        "files": [
          "src/auth/cephx/CephxSessionHandler.cc"
        ],
        "message": "auth/cephx/CephxSessionHandler: implement CEPHX_V2 calculation mode\n\nDerive the signature from the entire buffer (both cipher blocks).\n\nSigned-off-by: Sage Weil <sage@redhat.com>\n(cherry picked from commit 8f396cf35a3826044b089141667a196454c0a587)",
        "before_after_code_files": [
          "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ],
          "candidate": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc": [
          "File: src/auth/cephx/CephxSessionHandler.cc -> src/auth/cephx/CephxSessionHandler.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   const ceph_msg_header& header = m->get_header();",
          "30:   const ceph_msg_footer& footer = m->get_footer();",
          "55:     };",
          "59:     };",
          "69:   ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()",
          "70:    << \" front_crc_ = \" << footer.front_crc",
          "",
          "[Removed Lines]",
          "35:   struct {",
          "36:     __u8 v;",
          "37:     __le64 magic;",
          "38:     __le32 len;",
          "39:     __le32 header_crc;",
          "40:     __le32 front_crc;",
          "41:     __le32 middle_crc;",
          "42:     __le32 data_crc;",
          "43:   } __attribute__ ((packed)) sigblock = {",
          "44:     1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
          "45:     mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
          "46:     mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
          "47:   };",
          "49:   char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
          "51:   try {",
          "52:     const CryptoKey::in_slice_t in {",
          "53:       sizeof(sigblock),",
          "54:       reinterpret_cast<const unsigned char*>(&sigblock)",
          "56:     const CryptoKey::out_slice_t out {",
          "57:       sizeof(exp_buf),",
          "58:       reinterpret_cast<unsigned char*>(&exp_buf)",
          "61:     key.encrypt(cct, in, out);",
          "62:   } catch (std::exception& e) {",
          "63:     lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "64:     return -1;",
          "65:   }",
          "",
          "[Added Lines]",
          "32:   if (!HAVE_FEATURE(features, CEPHX_V2)) {",
          "38:     struct {",
          "39:       __u8 v;",
          "40:       __le64 magic;",
          "41:       __le32 len;",
          "42:       __le32 header_crc;",
          "43:       __le32 front_crc;",
          "44:       __le32 middle_crc;",
          "45:       __le32 data_crc;",
          "46:     } __attribute__ ((packed)) sigblock = {",
          "47:       1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
          "48:       mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
          "49:       mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
          "52:     char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
          "54:     try {",
          "55:       const CryptoKey::in_slice_t in {",
          "56:  sizeof(sigblock),",
          "57:  reinterpret_cast<const unsigned char*>(&sigblock)",
          "58:       };",
          "59:       const CryptoKey::out_slice_t out {",
          "60:  sizeof(exp_buf),",
          "61:  reinterpret_cast<unsigned char*>(&exp_buf)",
          "62:       };",
          "63:       key.encrypt(cct, in, out);",
          "64:     } catch (std::exception& e) {",
          "65:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "66:       return -1;",
          "67:     }",
          "70:   } else {",
          "72:     struct {",
          "73:       __le32 header_crc;",
          "74:       __le32 front_crc;",
          "75:       __le32 front_len;",
          "76:       __le32 middle_crc;",
          "77:       __le32 middle_len;",
          "78:       __le32 data_crc;",
          "79:       __le32 data_len;",
          "80:       __le32 seq_lower_word;",
          "81:     } __attribute__ ((packed)) sigblock = {",
          "82:       mswab<uint32_t>(header.crc),",
          "83:       mswab<uint32_t>(footer.front_crc),",
          "84:       mswab<uint32_t>(header.front_len),",
          "85:       mswab<uint32_t>(footer.middle_crc),",
          "86:       mswab<uint32_t>(header.middle_len),",
          "87:       mswab<uint32_t>(footer.data_crc),",
          "88:       mswab<uint32_t>(header.data_len),",
          "89:       mswab<uint32_t>(header.seq)",
          "92:     char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
          "94:     try {",
          "95:       const CryptoKey::in_slice_t in {",
          "96:  sizeof(sigblock),",
          "97:  reinterpret_cast<const unsigned char*>(&sigblock)",
          "98:       };",
          "99:       const CryptoKey::out_slice_t out {",
          "100:  sizeof(exp_buf),",
          "101:  reinterpret_cast<unsigned char*>(&exp_buf)",
          "102:       };",
          "103:       key.encrypt(cct, in, out);",
          "104:     } catch (std::exception& e) {",
          "105:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "106:       return -1;",
          "107:     }",
          "109:     struct enc {",
          "110:       __le64 a, b, c, d;",
          "111:     } *penc = reinterpret_cast<enc*>(exp_buf);",
          "113:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a2b04cc337a6f6f7b7a8b02bf31a8f3448670645",
      "candidate_info": {
        "commit_hash": "a2b04cc337a6f6f7b7a8b02bf31a8f3448670645",
        "repo": "ceph/ceph",
        "commit_url": "https://github.com/ceph/ceph/commit/a2b04cc337a6f6f7b7a8b02bf31a8f3448670645",
        "files": [
          "src/auth/cephx/CephxSessionHandler.cc"
        ],
        "message": "auth/cephx/CephxSessionHandler: implement CEPHX_V2 calculation mode\n\nDerive the signature from the entire buffer (both cipher blocks).\n\nSigned-off-by: Sage Weil <sage@redhat.com>\n(cherry picked from commit 8f396cf35a3826044b089141667a196454c0a587)\n\n# Conflicts:\n#\tsrc/auth/cephx/CephxSessionHandler.cc\n\n- master and mimic use no_bl crypto interface, which doesn't exist here,\nso fall back to using bufferlist-based calls into encrypt().",
        "before_after_code_files": [
          "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "olp_code_files": {
          "patch": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ],
          "candidate": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc": [
          "File: src/auth/cephx/CephxSessionHandler.cc -> src/auth/cephx/CephxSessionHandler.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   const ceph_msg_header& header = m->get_header();",
          "30:   const ceph_msg_footer& footer = m->get_footer();",
          "60:   ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()",
          "61:    << \" front_crc_ = \" << footer.front_crc",
          "",
          "[Removed Lines]",
          "35:   struct {",
          "36:     __u8 v;",
          "37:     __le64 magic;",
          "38:     __le32 len;",
          "39:     __le32 header_crc;",
          "40:     __le32 front_crc;",
          "41:     __le32 middle_crc;",
          "42:     __le32 data_crc;",
          "43:   } __attribute__ ((packed)) sigblock = {",
          "44:     1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
          "45:     mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
          "46:     mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
          "47:   };",
          "48:   bufferlist bl_plaintext;",
          "49:   bl_plaintext.append(buffer::create_static(sizeof(sigblock), (char*)&sigblock));",
          "51:   bufferlist bl_ciphertext;",
          "52:   if (key.encrypt(cct, bl_plaintext, bl_ciphertext, NULL) < 0) {",
          "53:     lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "54:     return -1;",
          "55:   }",
          "57:   bufferlist::iterator ci = bl_ciphertext.begin();",
          "58:   ::decode(*psig, ci);",
          "",
          "[Added Lines]",
          "32:   if (!HAVE_FEATURE(features, CEPHX_V2)) {",
          "38:     struct {",
          "39:       __u8 v;",
          "40:       __le64 magic;",
          "41:       __le32 len;",
          "42:       __le32 header_crc;",
          "43:       __le32 front_crc;",
          "44:       __le32 middle_crc;",
          "45:       __le32 data_crc;",
          "46:     } __attribute__ ((packed)) sigblock = {",
          "47:       1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
          "48:       mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
          "49:       mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
          "50:     };",
          "52:     bufferlist bl_plaintext;",
          "53:     bl_plaintext.append(buffer::create_static(sizeof(sigblock),",
          "54:            (char*)&sigblock));",
          "56:     bufferlist bl_ciphertext;",
          "57:     if (key.encrypt(cct, bl_plaintext, bl_ciphertext, NULL) < 0) {",
          "58:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "59:       return -1;",
          "60:     }",
          "62:     bufferlist::iterator ci = bl_ciphertext.begin();",
          "63:     ::decode(*psig, ci);",
          "64:   } else {",
          "66:     struct {",
          "67:       __le32 header_crc;",
          "68:       __le32 front_crc;",
          "69:       __le32 front_len;",
          "70:       __le32 middle_crc;",
          "71:       __le32 middle_len;",
          "72:       __le32 data_crc;",
          "73:       __le32 data_len;",
          "74:       __le32 seq_lower_word;",
          "75:     } __attribute__ ((packed)) sigblock = {",
          "76:       mswab<uint32_t>(header.crc),",
          "77:       mswab<uint32_t>(footer.front_crc),",
          "78:       mswab<uint32_t>(header.front_len),",
          "79:       mswab<uint32_t>(footer.middle_crc),",
          "80:       mswab<uint32_t>(header.middle_len),",
          "81:       mswab<uint32_t>(footer.data_crc),",
          "82:       mswab<uint32_t>(header.data_len),",
          "83:       mswab<uint32_t>(header.seq)",
          "84:     };",
          "86:     bufferlist bl_plaintext;",
          "87:     bl_plaintext.append(buffer::create_static(sizeof(sigblock),",
          "88:            (char*)&sigblock));",
          "90:     bufferlist bl_ciphertext;",
          "91:     if (key.encrypt(cct, bl_plaintext, bl_ciphertext, NULL) < 0) {",
          "92:       lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "93:       return -1;",
          "94:     }",
          "96:     struct enc {",
          "97:       __le64 a, b, c, d;",
          "98:     } *penc = reinterpret_cast<enc*>(bl_ciphertext.c_str());",
          "100:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b5acef206c94142464f7ff314bb11c843c5420e8",
      "candidate_info": {
        "commit_hash": "b5acef206c94142464f7ff314bb11c843c5420e8",
        "repo": "ceph/ceph",
        "commit_url": "https://github.com/ceph/ceph/commit/b5acef206c94142464f7ff314bb11c843c5420e8",
        "files": [
          "src/auth/Crypto.cc",
          "src/auth/Crypto.h",
          "src/auth/cephx/CephxSessionHandler.cc"
        ],
        "message": "auth: extend CryptoKey with no-bl encrypt/decrypt.\n\nSigned-off-by: Radoslaw Zarzynski <rzarzyns@redhat.com>",
        "before_after_code_files": [
          "src/auth/Crypto.cc||src/auth/Crypto.cc",
          "src/auth/Crypto.h||src/auth/Crypto.h",
          "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ],
          "candidate": [
            "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/auth/Crypto.cc||src/auth/Crypto.cc": [
          "File: src/auth/Crypto.cc -> src/auth/Crypto.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "73: #endif",
          "78: class CryptoNoneKeyHandler : public CryptoKeyHandler {",
          "79: public:",
          "80:   int encrypt(const bufferlist& in,",
          "81:         bufferlist& out, std::string *error) const override {",
          "82:     out = in;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80: std::size_t CryptoKeyHandler::encrypt(",
          "81:   const CryptoKeyHandler::in_slice_t& in,",
          "82:   const CryptoKeyHandler::out_slice_t& out) const",
          "83: {",
          "84:   ceph::bufferptr inptr(reinterpret_cast<const char*>(in.buf), in.length);",
          "85:   ceph::bufferlist plaintext;",
          "86:   plaintext.append(std::move(inptr));",
          "88:   ceph::bufferlist ciphertext;",
          "89:   std::string error;",
          "90:   const int ret = encrypt(plaintext, ciphertext, &error);",
          "91:   if (ret != 0 || !error.empty()) {",
          "92:     throw std::runtime_error(std::move(error));",
          "93:   }",
          "97:   const auto todo_len = \\",
          "98:     std::min<std::size_t>(ciphertext.length(), out.max_length);",
          "99:   memcpy(out.buf, ciphertext.c_str(), todo_len);",
          "101:   return todo_len;",
          "102: }",
          "104: std::size_t CryptoKeyHandler::decrypt(",
          "105:   const CryptoKeyHandler::in_slice_t& in,",
          "106:   const CryptoKeyHandler::out_slice_t& out) const",
          "107: {",
          "108:   ceph::bufferptr inptr(reinterpret_cast<const char*>(in.buf), in.length);",
          "109:   ceph::bufferlist ciphertext;",
          "110:   ciphertext.append(std::move(inptr));",
          "112:   ceph::bufferlist plaintext;",
          "113:   std::string error;",
          "114:   const int ret = decrypt(ciphertext, plaintext, &error);",
          "115:   if (ret != 0 || !error.empty()) {",
          "116:     throw std::runtime_error(std::move(error));",
          "117:   }",
          "121:   const auto todo_len = \\",
          "122:     std::min<std::size_t>(plaintext.length(), out.max_length);",
          "123:   memcpy(out.buf, plaintext.c_str(), todo_len);",
          "125:   return todo_len;",
          "126: }",
          "132:   CryptoNoneKeyHandler()",
          "133:     : CryptoKeyHandler(CryptoKeyHandler::BLOCK_SIZE_0B()) {",
          "134:   }",
          "136:   using CryptoKeyHandler::encrypt;",
          "137:   using CryptoKeyHandler::decrypt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128: # define AES_KEY_LEN 16",
          "129: # define AES_BLOCK_LEN   16",
          "132: class CryptoAESKeyHandler : public CryptoKeyHandler {",
          "133:   AES_KEY enc_key;",
          "134:   AES_KEY dec_key;",
          "136: public:",
          "137:   int init(const bufferptr& s, ostringstream& err) {",
          "138:     secret = s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "195:   CryptoAESKeyHandler()",
          "196:     : CryptoKeyHandler(CryptoKeyHandler::BLOCK_SIZE_16B()) {",
          "197:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:     return 0;",
          "229:   }",
          "230: };",
          "232: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:   std::size_t encrypt(const in_slice_t& in,",
          "294:         const out_slice_t& out) const override {",
          "295:     return 0;",
          "296:   }",
          "297:   std::size_t decrypt(const in_slice_t& in,",
          "298:         const out_slice_t& out) const override {",
          "299:     return 0;",
          "300:   }",
          "",
          "---------------"
        ],
        "src/auth/Crypto.h||src/auth/Crypto.h": [
          "File: src/auth/Crypto.h -> src/auth/Crypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: class CryptoKeyHandler {",
          "46: public:",
          "49:   virtual ~CryptoKeyHandler() {}",
          "",
          "[Removed Lines]",
          "47:   bufferptr secret;",
          "",
          "[Added Lines]",
          "48:   static constexpr std::size_t MAX_BLOCK_SIZE {16};",
          "51:   typedef std::integral_constant<std::size_t,  0> BLOCK_SIZE_0B;",
          "52:   typedef std::integral_constant<std::size_t, 16> BLOCK_SIZE_16B;",
          "54:   struct in_slice_t {",
          "55:     const std::size_t length;",
          "56:     const unsigned char* const buf;",
          "57:   };",
          "59:   struct out_slice_t {",
          "60:     const std::size_t max_length;",
          "61:     unsigned char* const buf;",
          "62:   };",
          "64:   ceph::bufferptr secret;",
          "66:   template <class BlockSizeT>",
          "67:   CryptoKeyHandler(BlockSizeT) {",
          "68:     static_assert(BlockSizeT::value <= MAX_BLOCK_SIZE);",
          "69:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:          bufferlist& out, std::string *error) const = 0;",
          "53:   virtual int decrypt(const bufferlist& in,",
          "54:          bufferlist& out, std::string *error) const = 0;",
          "55: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:   virtual std::size_t encrypt(const in_slice_t& in,",
          "81:          const out_slice_t& out) const;",
          "82:   virtual std::size_t decrypt(const in_slice_t& in,",
          "83:          const out_slice_t& out) const;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "127:     return ckh->decrypt(in, out, error);",
          "128:   }",
          "130:   void to_str(std::string& s) const;",
          "131: };",
          "132: WRITE_CLASS_ENCODER(CryptoKey)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:   using in_slice_t = CryptoKeyHandler::in_slice_t;",
          "160:   using out_slice_t = CryptoKeyHandler::out_slice_t;",
          "162:   std::size_t encrypt(CephContext*, const in_slice_t& in,",
          "163:         const out_slice_t& out) {",
          "164:     assert(ckh);",
          "165:     return ckh->encrypt(in, out);",
          "166:   }",
          "167:   std::size_t decrypt(CephContext*, const in_slice_t& in,",
          "168:         const out_slice_t& out) {",
          "169:     assert(ckh);",
          "170:     return ckh->encrypt(in, out);",
          "171:   }",
          "173:   static constexpr std::size_t get_max_outbuf_size(std::size_t want_size) {",
          "174:     return want_size + CryptoKeyHandler::MAX_BLOCK_SIZE;",
          "175:   }",
          "",
          "---------------"
        ],
        "src/auth/cephx/CephxSessionHandler.cc||src/auth/cephx/CephxSessionHandler.cc": [
          "File: src/auth/cephx/CephxSessionHandler.cc -> src/auth/cephx/CephxSessionHandler.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:     mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
          "46:     mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
          "47:   };",
          "53:     lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
          "54:     return -1;",
          "55:   }",
          "60:   ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()",
          "61:    << \" front_crc_ = \" << footer.front_crc",
          "",
          "[Removed Lines]",
          "48:   bufferlist bl_plaintext;",
          "49:   bl_plaintext.append(buffer::create_static(sizeof(sigblock), (char*)&sigblock));",
          "51:   bufferlist bl_ciphertext;",
          "52:   if (key.encrypt(cct, bl_plaintext, bl_ciphertext, NULL) < 0) {",
          "57:   auto ci = bl_ciphertext.cbegin();",
          "58:   decode(*psig, ci);",
          "",
          "[Added Lines]",
          "49:   char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
          "51:   try {",
          "52:     const CryptoKey::in_slice_t in {",
          "53:       sizeof(sigblock),",
          "54:       reinterpret_cast<const unsigned char*>(&sigblock)",
          "55:     };",
          "56:     const CryptoKey::out_slice_t out {",
          "57:       sizeof(exp_buf),",
          "58:       reinterpret_cast<unsigned char*>(&exp_buf)",
          "59:     };",
          "61:     key.encrypt(cct, in, out);",
          "62:   } catch (std::exception& e) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
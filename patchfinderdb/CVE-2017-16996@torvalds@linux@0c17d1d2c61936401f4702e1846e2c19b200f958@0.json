{
  "cve_id": "CVE-2017-16996",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging register truncation mishandling.",
  "repo": "torvalds/linux",
  "patch_hash": "0c17d1d2c61936401f4702e1846e2c19b200f958",
  "patch_info": {
    "commit_hash": "0c17d1d2c61936401f4702e1846e2c19b200f958",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958",
    "files": [
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: fix incorrect tracking of register size truncation\n\nProperly handle register truncation to a smaller size.\n\nThe old code first mirrors the clearing of the high 32 bits in the bitwise\ntristate representation, which is correct. But then, it computes the new\narithmetic bounds as the intersection between the old arithmetic bounds and\nthe bounds resulting from the bitwise tristate representation. Therefore,\nwhen coerce_reg_to_32() is called on a number with bounds\n[0xffff'fff8, 0x1'0000'0007], the verifier computes\n[0xffff'fff8, 0xffff'ffff] as bounds of the truncated number.\nThis is incorrect: The truncated number could also be in the range [0, 7],\nand no meaningful arithmetic bounds can be computed in that case apart from\nthe obvious [0, 0xffff'ffff].\n\nStarting with v4.14, this is exploitable by unprivileged users as long as\nthe unprivileged_bpf_disabled sysctl isn't set.\n\nDebian assigned CVE-2017-16996 for this issue.\n\nv2:\n - flip the mask during arithmetic bounds calculation (Ben Hutchings)\nv3:\n - add CVE number (Ben Hutchings)\n\nFixes: b03c9f9fdc37 (\"bpf/verifier: track signed and unsigned min/max values\")\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "before_after_code_files": [
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1067:         strict);",
      "1068: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1073: static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)",
      "1074: {",
      "1075:  u64 mask;",
      "1078:  reg->var_off = tnum_cast(reg->var_off, size);",
      "1081:  mask = ((u64)1 << (size * 8)) - 1;",
      "1082:  if ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {",
      "1083:   reg->umin_value &= mask;",
      "1084:   reg->umax_value &= mask;",
      "1085:  } else {",
      "1086:   reg->umin_value = 0;",
      "1087:   reg->umax_value = mask;",
      "1088:  }",
      "1089:  reg->smin_value = reg->umin_value;",
      "1090:  reg->smax_value = reg->umax_value;",
      "1091: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1200:  if (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&",
      "1201:      regs[value_regno].type == SCALAR_VALUE) {",
      "1206:  }",
      "1207:  return err;",
      "1208: }",
      "",
      "[Removed Lines]",
      "1203:   regs[value_regno].var_off =",
      "1204:    tnum_cast(regs[value_regno].var_off, size);",
      "1205:   __update_reg_bounds(&regs[value_regno]);",
      "",
      "[Added Lines]",
      "1226:   coerce_reg_to_size(&regs[value_regno], size);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1772:  return 0;",
      "1773: }",
      "1783: static bool signed_add_overflows(s64 a, s64 b)",
      "1784: {",
      "",
      "[Removed Lines]",
      "1775: static void coerce_reg_to_32(struct bpf_reg_state *reg)",
      "1776: {",
      "1778:  reg->var_off = tnum_cast(reg->var_off, 4);",
      "1780:  __update_reg_bounds(reg);",
      "1781: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2018:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
      "2022:  }",
      "2023:  smin_val = src_reg.smin_value;",
      "2024:  smax_val = src_reg.smax_value;",
      "",
      "[Removed Lines]",
      "2020:   coerce_reg_to_32(dst_reg);",
      "2021:   coerce_reg_to_32(&src_reg);",
      "",
      "[Added Lines]",
      "2033:   coerce_reg_to_size(dst_reg, 4);",
      "2034:   coerce_reg_to_size(&src_reg, 4);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2398:      return -EACCES;",
      "2399:     }",
      "2400:     mark_reg_unknown(env, regs, insn->dst_reg);",
      "2405:    }",
      "2406:   } else {",
      "",
      "[Removed Lines]",
      "2402:     regs[insn->dst_reg].var_off = tnum_cast(",
      "2403:       regs[insn->dst_reg].var_off, 4);",
      "2404:     __update_reg_bounds(&regs[insn->dst_reg]);",
      "",
      "[Added Lines]",
      "2414:     coerce_reg_to_size(&regs[insn->dst_reg], 4);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "61bd5218eef349fcacc4976a251bc83a4748b4af",
      "candidate_info": {
        "commit_hash": "61bd5218eef349fcacc4976a251bc83a4748b4af",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/61bd5218eef349fcacc4976a251bc83a4748b4af",
        "files": [
          "include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: move global verifier log into verifier environment\n\nThe biggest piece of global state protected by the verifier lock\nis the verifier_log.  Move that log to struct bpf_verifier_env.\nstruct bpf_verifier_env has to be passed now to all invocations\nof verbose().\n\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nReviewed-by: Simon Horman <simon.horman@netronome.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:  bool allow_ptr_leaks;",
          "153:  bool seen_direct_write;",
          "155: };",
          "157: int bpf_analyzer(struct bpf_prog *prog, const struct bpf_ext_analyzer_ops *ops,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156:  struct bpf_verifer_log log;",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "153:  int access_size;",
          "154: };",
          "161: static DEFINE_MUTEX(bpf_verifier_lock);",
          "168: {",
          "170:  va_list args;",
          "172:  if (!log->level || bpf_verifier_log_full(log))",
          "",
          "[Removed Lines]",
          "159: static struct bpf_verifer_log verifier_log;",
          "167: static __printf(1, 2) void verbose(const char *fmt, ...)",
          "169:  struct bpf_verifer_log *log = &verifier_log;",
          "",
          "[Added Lines]",
          "162: static __printf(2, 3) void verbose(struct bpf_verifier_env *env,",
          "163:        const char *fmt, ...)",
          "165:  struct bpf_verifer_log *log = &env->log;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "214:   return \"unknown\";",
          "215: }",
          "218: {",
          "219:  struct bpf_reg_state *reg;",
          "220:  enum bpf_reg_type t;",
          "",
          "[Removed Lines]",
          "217: static void print_verifier_state(struct bpf_verifier_state *state)",
          "",
          "[Added Lines]",
          "213: static void print_verifier_state(struct bpf_verifier_env *env,",
          "214:      struct bpf_verifier_state *state)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "225:   t = reg->type;",
          "226:   if (t == NOT_INIT)",
          "227:    continue;",
          "229:   if ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&",
          "230:       tnum_is_const(reg->var_off)) {",
          "233:   } else {",
          "235:    if (t != SCALAR_VALUE)",
          "237:    if (type_is_pkt_pointer(t))",
          "239:    else if (t == CONST_PTR_TO_MAP ||",
          "240:      t == PTR_TO_MAP_VALUE ||",
          "241:      t == PTR_TO_MAP_VALUE_OR_NULL)",
          "243:      reg->map_ptr->key_size,",
          "244:      reg->map_ptr->value_size);",
          "245:    if (tnum_is_const(reg->var_off)) {",
          "",
          "[Removed Lines]",
          "228:   verbose(\" R%d=%s\", i, reg_type_str[t]);",
          "232:    verbose(\"%lld\", reg->var_off.value + reg->off);",
          "234:    verbose(\"(id=%d\", reg->id);",
          "236:     verbose(\",off=%d\", reg->off);",
          "238:     verbose(\",r=%d\", reg->range);",
          "242:     verbose(\",ks=%d,vs=%d\",",
          "",
          "[Added Lines]",
          "225:   verbose(env, \" R%d=%s\", i, reg_type_str[t]);",
          "229:    verbose(env, \"%lld\", reg->var_off.value + reg->off);",
          "231:    verbose(env, \"(id=%d\", reg->id);",
          "233:     verbose(env, \",off=%d\", reg->off);",
          "235:     verbose(env, \",r=%d\", reg->range);",
          "239:     verbose(env, \",ks=%d,vs=%d\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "251:    } else {",
          "252:     if (reg->smin_value != reg->umin_value &&",
          "253:         reg->smin_value != S64_MIN)",
          "255:       (long long)reg->smin_value);",
          "256:     if (reg->smax_value != reg->umax_value &&",
          "257:         reg->smax_value != S64_MAX)",
          "259:       (long long)reg->smax_value);",
          "260:     if (reg->umin_value != 0)",
          "262:       (unsigned long long)reg->umin_value);",
          "263:     if (reg->umax_value != U64_MAX)",
          "265:       (unsigned long long)reg->umax_value);",
          "266:     if (!tnum_is_unknown(reg->var_off)) {",
          "267:      char tn_buf[48];",
          "269:      tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "271:     }",
          "272:    }",
          "274:   }",
          "275:  }",
          "276:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "277:   if (state->stack_slot_type[i] == STACK_SPILL)",
          "279:     reg_type_str[state->spilled_regs[i / BPF_REG_SIZE].type]);",
          "280:  }",
          "282: }",
          "284: static const char *const bpf_class_string[] = {",
          "",
          "[Removed Lines]",
          "250:     verbose(\",imm=%llx\", reg->var_off.value);",
          "254:      verbose(\",smin_value=%lld\",",
          "258:      verbose(\",smax_value=%lld\",",
          "261:      verbose(\",umin_value=%llu\",",
          "264:      verbose(\",umax_value=%llu\",",
          "270:      verbose(\",var_off=%s\", tn_buf);",
          "273:    verbose(\")\");",
          "278:    verbose(\" fp%d=%s\", -MAX_BPF_STACK + i,",
          "281:  verbose(\"\\n\");",
          "",
          "[Added Lines]",
          "247:     verbose(env, \",imm=%llx\", reg->var_off.value);",
          "251:      verbose(env, \",smin_value=%lld\",",
          "255:      verbose(env, \",smax_value=%lld\",",
          "258:      verbose(env, \",umin_value=%llu\",",
          "261:      verbose(env, \",umax_value=%llu\",",
          "267:      verbose(env, \",var_off=%s\", tn_buf);",
          "270:    verbose(env, \")\");",
          "275:    verbose(env, \" fp%d=%s\", -MAX_BPF_STACK + i,",
          "278:  verbose(env, \"\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "333:  [BPF_EXIT >> 4] = \"exit\",",
          "334: };",
          "337:           const struct bpf_insn *insn)",
          "338: {",
          "340:   BPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",",
          "341:   insn->imm, insn->dst_reg);",
          "342: }",
          "345:       const struct bpf_insn *insn)",
          "346: {",
          "347:  u8 class = BPF_CLASS(insn->code);",
          "",
          "[Removed Lines]",
          "336: static void print_bpf_end_insn(const struct bpf_verifier_env *env,",
          "339:  verbose(\"(%02x) r%d = %s%d r%d\\n\", insn->code, insn->dst_reg,",
          "344: static void print_bpf_insn(const struct bpf_verifier_env *env,",
          "",
          "[Added Lines]",
          "333: static void print_bpf_end_insn(struct bpf_verifier_env *env,",
          "336:  verbose(env, \"(%02x) r%d = %s%d r%d\\n\", insn->code, insn->dst_reg,",
          "341: static void print_bpf_insn(struct bpf_verifier_env *env,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "349:  if (class == BPF_ALU || class == BPF_ALU64) {",
          "350:   if (BPF_OP(insn->code) == BPF_END) {",
          "351:    if (class == BPF_ALU64)",
          "353:    else",
          "354:     print_bpf_end_insn(env, insn);",
          "355:   } else if (BPF_OP(insn->code) == BPF_NEG) {",
          "357:     insn->code, insn->dst_reg,",
          "358:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "359:     insn->dst_reg);",
          "360:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "362:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "363:     insn->dst_reg,",
          "364:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "365:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "366:     insn->src_reg);",
          "367:   } else {",
          "369:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "370:     insn->dst_reg,",
          "371:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "",
          "[Removed Lines]",
          "352:     verbose(\"BUG_alu64_%02x\\n\", insn->code);",
          "356:    verbose(\"(%02x) r%d = %s-r%d\\n\",",
          "361:    verbose(\"(%02x) %sr%d %s %sr%d\\n\",",
          "368:    verbose(\"(%02x) %sr%d %s %s%d\\n\",",
          "",
          "[Added Lines]",
          "349:     verbose(env, \"BUG_alu64_%02x\\n\", insn->code);",
          "353:    verbose(env, \"(%02x) r%d = %s-r%d\\n\",",
          "358:    verbose(env, \"(%02x) %sr%d %s %sr%d\\n\",",
          "365:    verbose(env, \"(%02x) %sr%d %s %s%d\\n\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "374:   }",
          "375:  } else if (class == BPF_STX) {",
          "376:   if (BPF_MODE(insn->code) == BPF_MEM)",
          "378:     insn->code,",
          "379:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "380:     insn->dst_reg,",
          "381:     insn->off, insn->src_reg);",
          "382:   else if (BPF_MODE(insn->code) == BPF_XADD)",
          "384:     insn->code,",
          "385:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "386:     insn->dst_reg, insn->off,",
          "387:     insn->src_reg);",
          "388:   else",
          "390:  } else if (class == BPF_ST) {",
          "391:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "393:    return;",
          "394:   }",
          "396:    insn->code,",
          "397:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "398:    insn->dst_reg,",
          "399:    insn->off, insn->imm);",
          "400:  } else if (class == BPF_LDX) {",
          "401:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "403:    return;",
          "404:   }",
          "406:    insn->code, insn->dst_reg,",
          "407:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "408:    insn->src_reg, insn->off);",
          "409:  } else if (class == BPF_LD) {",
          "410:   if (BPF_MODE(insn->code) == BPF_ABS) {",
          "412:     insn->code,",
          "413:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "414:     insn->imm);",
          "415:   } else if (BPF_MODE(insn->code) == BPF_IND) {",
          "417:     insn->code,",
          "418:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "419:     insn->src_reg, insn->imm);",
          "",
          "[Removed Lines]",
          "377:    verbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "383:    verbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "389:    verbose(\"BUG_%02x\\n\", insn->code);",
          "392:    verbose(\"BUG_st_%02x\\n\", insn->code);",
          "395:   verbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "402:    verbose(\"BUG_ldx_%02x\\n\", insn->code);",
          "405:   verbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "411:    verbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "416:    verbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "",
          "[Added Lines]",
          "374:    verbose(env, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "380:    verbose(env, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "386:    verbose(env, \"BUG_%02x\\n\", insn->code);",
          "389:    verbose(env, \"BUG_st_%02x\\n\", insn->code);",
          "392:   verbose(env, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "399:    verbose(env, \"BUG_ldx_%02x\\n\", insn->code);",
          "402:   verbose(env, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "408:    verbose(env, \"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "413:    verbose(env, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "428:    if (map_ptr && !env->allow_ptr_leaks)",
          "429:     imm = 0;",
          "432:     insn->dst_reg, (unsigned long long)imm);",
          "433:   } else {",
          "435:    return;",
          "436:   }",
          "437:  } else if (class == BPF_JMP) {",
          "438:   u8 opcode = BPF_OP(insn->code);",
          "440:   if (opcode == BPF_CALL) {",
          "442:     func_id_name(insn->imm), insn->imm);",
          "443:   } else if (insn->code == (BPF_JMP | BPF_JA)) {",
          "445:     insn->code, insn->off);",
          "446:   } else if (insn->code == (BPF_JMP | BPF_EXIT)) {",
          "448:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "450:     insn->code, insn->dst_reg,",
          "451:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "452:     insn->src_reg, insn->off);",
          "453:   } else {",
          "455:     insn->code, insn->dst_reg,",
          "456:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "457:     insn->imm, insn->off);",
          "458:   }",
          "459:  } else {",
          "461:  }",
          "462: }",
          "",
          "[Removed Lines]",
          "431:    verbose(\"(%02x) r%d = 0x%llx\\n\", insn->code,",
          "434:    verbose(\"BUG_ld_%02x\\n\", insn->code);",
          "441:    verbose(\"(%02x) call %s#%d\\n\", insn->code,",
          "444:    verbose(\"(%02x) goto pc%+d\\n\",",
          "447:    verbose(\"(%02x) exit\\n\", insn->code);",
          "449:    verbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "454:    verbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "460:   verbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);",
          "",
          "[Added Lines]",
          "428:    verbose(env, \"(%02x) r%d = 0x%llx\\n\", insn->code,",
          "431:    verbose(env, \"BUG_ld_%02x\\n\", insn->code);",
          "438:    verbose(env, \"(%02x) call %s#%d\\n\", insn->code,",
          "441:    verbose(env, \"(%02x) goto pc%+d\\n\",",
          "444:    verbose(env, \"(%02x) exit\\n\", insn->code);",
          "446:    verbose(env, \"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "451:    verbose(env, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "457:   verbose(env, \"(%02x) %s\\n\",",
          "458:    insn->code, bpf_class_string[class]);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "496:  env->head = elem;",
          "497:  env->stack_size++;",
          "498:  if (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {",
          "500:   goto err;",
          "501:  }",
          "502:  return &elem->st;",
          "",
          "[Removed Lines]",
          "499:   verbose(\"BPF program is too complex\\n\");",
          "",
          "[Added Lines]",
          "497:   verbose(env, \"BPF program is too complex\\n\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "534:  __mark_reg_known(reg, 0);",
          "535: }",
          "538: {",
          "539:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "542:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "543:    __mark_reg_not_init(regs + regno);",
          "",
          "[Removed Lines]",
          "537: static void mark_reg_known_zero(struct bpf_reg_state *regs, u32 regno)",
          "540:   verbose(\"mark_reg_known_zero(regs, %u)\\n\", regno);",
          "",
          "[Added Lines]",
          "535: static void mark_reg_known_zero(struct bpf_verifier_env *env,",
          "536:     struct bpf_reg_state *regs, u32 regno)",
          "539:   verbose(env, \"mark_reg_known_zero(regs, %u)\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "647:  __mark_reg_unbounded(reg);",
          "648: }",
          "651: {",
          "652:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "655:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "656:    __mark_reg_not_init(regs + regno);",
          "",
          "[Removed Lines]",
          "650: static void mark_reg_unknown(struct bpf_reg_state *regs, u32 regno)",
          "653:   verbose(\"mark_reg_unknown(regs, %u)\\n\", regno);",
          "",
          "[Added Lines]",
          "649: static void mark_reg_unknown(struct bpf_verifier_env *env,",
          "650:         struct bpf_reg_state *regs, u32 regno)",
          "653:   verbose(env, \"mark_reg_unknown(regs, %u)\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "665:  reg->type = NOT_INIT;",
          "666: }",
          "669: {",
          "670:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "673:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "674:    __mark_reg_not_init(regs + regno);",
          "",
          "[Removed Lines]",
          "668: static void mark_reg_not_init(struct bpf_reg_state *regs, u32 regno)",
          "671:   verbose(\"mark_reg_not_init(regs, %u)\\n\", regno);",
          "",
          "[Added Lines]",
          "668: static void mark_reg_not_init(struct bpf_verifier_env *env,",
          "669:          struct bpf_reg_state *regs, u32 regno)",
          "672:   verbose(env, \"mark_reg_not_init(regs, %u)\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "677:  __mark_reg_not_init(regs + regno);",
          "678: }",
          "681: {",
          "682:  int i;",
          "684:  for (i = 0; i < MAX_BPF_REG; i++) {",
          "686:   regs[i].live = REG_LIVE_NONE;",
          "687:  }",
          "690:  regs[BPF_REG_FP].type = PTR_TO_STACK;",
          "694:  regs[BPF_REG_1].type = PTR_TO_CTX;",
          "696: }",
          "698: enum reg_arg_type {",
          "",
          "[Removed Lines]",
          "680: static void init_reg_state(struct bpf_reg_state *regs)",
          "685:   mark_reg_not_init(regs, i);",
          "691:  mark_reg_known_zero(regs, BPF_REG_FP);",
          "695:  mark_reg_known_zero(regs, BPF_REG_1);",
          "",
          "[Added Lines]",
          "681: static void init_reg_state(struct bpf_verifier_env *env,",
          "682:       struct bpf_reg_state *regs)",
          "687:   mark_reg_not_init(env, regs, i);",
          "693:  mark_reg_known_zero(env, regs, BPF_REG_FP);",
          "697:  mark_reg_known_zero(env, regs, BPF_REG_1);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "726:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "728:  if (regno >= MAX_BPF_REG) {",
          "730:   return -EINVAL;",
          "731:  }",
          "733:  if (t == SRC_OP) {",
          "735:   if (regs[regno].type == NOT_INIT) {",
          "737:    return -EACCES;",
          "738:   }",
          "739:   mark_reg_read(&env->cur_state, regno);",
          "740:  } else {",
          "742:   if (regno == BPF_REG_FP) {",
          "744:    return -EACCES;",
          "745:   }",
          "746:   regs[regno].live |= REG_LIVE_WRITTEN;",
          "747:   if (t == DST_OP)",
          "749:  }",
          "750:  return 0;",
          "751: }",
          "",
          "[Removed Lines]",
          "729:   verbose(\"R%d is invalid\\n\", regno);",
          "736:    verbose(\"R%d !read_ok\\n\", regno);",
          "743:    verbose(\"frame pointer is read only\\n\");",
          "748:    mark_reg_unknown(regs, regno);",
          "",
          "[Added Lines]",
          "731:   verbose(env, \"R%d is invalid\\n\", regno);",
          "738:    verbose(env, \"R%d !read_ok\\n\", regno);",
          "745:    verbose(env, \"frame pointer is read only\\n\");",
          "750:    mark_reg_unknown(env, regs, regno);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "774:         int size, int value_regno)",
          "775: {",
          "776:  int i, spi = (MAX_BPF_STACK + off) / BPF_REG_SIZE;",
          "",
          "[Removed Lines]",
          "773: static int check_stack_write(struct bpf_verifier_state *state, int off,",
          "",
          "[Added Lines]",
          "775: static int check_stack_write(struct bpf_verifier_env *env,",
          "776:         struct bpf_verifier_state *state, int off,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "785:   if (size != BPF_REG_SIZE) {",
          "787:    return -EACCES;",
          "788:   }",
          "",
          "[Removed Lines]",
          "786:    verbose(\"invalid size of register spill\\n\");",
          "",
          "[Added Lines]",
          "789:    verbose(env, \"invalid size of register spill\\n\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "818:  }",
          "819: }",
          "822:        int value_regno)",
          "823: {",
          "824:  u8 *slot_type;",
          "",
          "[Removed Lines]",
          "821: static int check_stack_read(struct bpf_verifier_state *state, int off, int size,",
          "",
          "[Added Lines]",
          "824: static int check_stack_read(struct bpf_verifier_env *env,",
          "825:        struct bpf_verifier_state *state, int off, int size,",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "829:  if (slot_type[0] == STACK_SPILL) {",
          "830:   if (size != BPF_REG_SIZE) {",
          "832:    return -EACCES;",
          "833:   }",
          "834:   for (i = 1; i < BPF_REG_SIZE; i++) {",
          "835:    if (slot_type[i] != STACK_SPILL) {",
          "837:     return -EACCES;",
          "838:    }",
          "839:   }",
          "",
          "[Removed Lines]",
          "831:    verbose(\"invalid size of register spill\\n\");",
          "836:     verbose(\"corrupted spill memory\\n\");",
          "",
          "[Added Lines]",
          "835:    verbose(env, \"invalid size of register spill\\n\");",
          "840:     verbose(env, \"corrupted spill memory\\n\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "849:  } else {",
          "850:   for (i = 0; i < size; i++) {",
          "851:    if (slot_type[i] != STACK_MISC) {",
          "853:      off, i, size);",
          "854:     return -EACCES;",
          "855:    }",
          "856:   }",
          "857:   if (value_regno >= 0)",
          "860:   return 0;",
          "861:  }",
          "862: }",
          "",
          "[Removed Lines]",
          "852:     verbose(\"invalid read from stack off %d+%d size %d\\n\",",
          "859:    mark_reg_unknown(state->regs, value_regno);",
          "",
          "[Added Lines]",
          "856:     verbose(env, \"invalid read from stack off %d+%d size %d\\n\",",
          "863:    mark_reg_unknown(env, state->regs, value_regno);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "868:  struct bpf_map *map = env->cur_state.regs[regno].map_ptr;",
          "870:  if (off < 0 || size <= 0 || off + size > map->value_size) {",
          "872:    map->value_size, off, size);",
          "873:   return -EACCES;",
          "874:  }",
          "",
          "[Removed Lines]",
          "871:   verbose(\"invalid access to map value, value_size=%d off=%d size=%d\\n\",",
          "",
          "[Added Lines]",
          "875:   verbose(env, \"invalid access to map value, value_size=%d off=%d size=%d\\n\",",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "890:  if (verifier_log.level)",
          "891:   print_verifier_state(state);",
          "",
          "[Added Lines]",
          "894:  if (env->log.level)",
          "895:   print_verifier_state(env, state);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "898:  if (reg->smin_value < 0) {",
          "900:    regno);",
          "901:   return -EACCES;",
          "902:  }",
          "903:  err = __check_map_access(env, regno, reg->smin_value + off, size);",
          "904:  if (err) {",
          "906:   return err;",
          "907:  }",
          "",
          "[Removed Lines]",
          "899:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "905:   verbose(\"R%d min value is outside of the array range\\n\", regno);",
          "",
          "[Added Lines]",
          "903:   verbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "909:   verbose(env, \"R%d min value is outside of the array range\\n\",",
          "910:    regno);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "913:  if (reg->umax_value >= BPF_MAX_VAR_OFF) {",
          "915:    regno);",
          "916:   return -EACCES;",
          "917:  }",
          "918:  err = __check_map_access(env, regno, reg->umax_value + off, size);",
          "919:  if (err)",
          "921:  return err;",
          "922: }",
          "",
          "[Removed Lines]",
          "914:   verbose(\"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",",
          "920:   verbose(\"R%d max value is outside of the array range\\n\", regno);",
          "",
          "[Added Lines]",
          "919:   verbose(env, \"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",",
          "925:   verbose(env, \"R%d max value is outside of the array range\\n\",",
          "926:    regno);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "956:  struct bpf_reg_state *reg = &regs[regno];",
          "958:  if (off < 0 || size <= 0 || (u64)off + size > reg->range) {",
          "960:    off, size, regno, reg->id, reg->off, reg->range);",
          "961:   return -EACCES;",
          "962:  }",
          "",
          "[Removed Lines]",
          "959:   verbose(\"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",",
          "",
          "[Added Lines]",
          "965:   verbose(env, \"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "981:  if (reg->smin_value < 0) {",
          "983:    regno);",
          "984:   return -EACCES;",
          "985:  }",
          "986:  err = __check_packet_access(env, regno, off, size);",
          "987:  if (err) {",
          "989:   return err;",
          "990:  }",
          "991:  return err;",
          "",
          "[Removed Lines]",
          "982:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "988:   verbose(\"R%d offset is outside of the packet\\n\", regno);",
          "",
          "[Added Lines]",
          "988:   verbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "994:   verbose(env, \"R%d offset is outside of the packet\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1021:   return 0;",
          "1022:  }",
          "1025:  return -EACCES;",
          "1026: }",
          "",
          "[Removed Lines]",
          "1024:  verbose(\"invalid bpf_context access off=%d size=%d\\n\", off, size);",
          "",
          "[Added Lines]",
          "1030:  verbose(env, \"invalid bpf_context access off=%d size=%d\\n\", off, size);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1039:  return __is_pointer_value(env->allow_ptr_leaks, &env->cur_state.regs[regno]);",
          "1040: }",
          "1043:        int off, int size, bool strict)",
          "1044: {",
          "1045:  struct tnum reg_off;",
          "",
          "[Removed Lines]",
          "1042: static int check_pkt_ptr_alignment(const struct bpf_reg_state *reg,",
          "",
          "[Added Lines]",
          "1048: static int check_pkt_ptr_alignment(struct bpf_verifier_env *env,",
          "1049:        const struct bpf_reg_state *reg,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1064:   char tn_buf[48];",
          "1066:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1068:    ip_align, tn_buf, reg->off, off, size);",
          "1069:   return -EACCES;",
          "1070:  }",
          "",
          "[Removed Lines]",
          "1067:   verbose(\"misaligned packet access off %d+%s+%d+%d size %d\\n\",",
          "",
          "[Added Lines]",
          "1074:   verbose(env,",
          "1075:    \"misaligned packet access off %d+%s+%d+%d size %d\\n\",",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1072:  return 0;",
          "1073: }",
          "1076:            const char *pointer_desc,",
          "1077:            int off, int size, bool strict)",
          "1078: {",
          "",
          "[Removed Lines]",
          "1075: static int check_generic_ptr_alignment(const struct bpf_reg_state *reg,",
          "",
          "[Added Lines]",
          "1083: static int check_generic_ptr_alignment(struct bpf_verifier_env *env,",
          "1084:            const struct bpf_reg_state *reg,",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1087:   char tn_buf[48];",
          "1089:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1091:    pointer_desc, tn_buf, reg->off, off, size);",
          "1092:   return -EACCES;",
          "1093:  }",
          "",
          "[Removed Lines]",
          "1090:   verbose(\"misaligned %saccess off %s+%d+%d size %d\\n\",",
          "",
          "[Added Lines]",
          "1099:   verbose(env, \"misaligned %saccess off %s+%d+%d size %d\\n\",",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1112:  case PTR_TO_MAP_VALUE:",
          "1113:   pointer_desc = \"value \";",
          "1114:   break;",
          "",
          "[Removed Lines]",
          "1111:   return check_pkt_ptr_alignment(reg, off, size, strict);",
          "",
          "[Added Lines]",
          "1120:   return check_pkt_ptr_alignment(env, reg, off, size, strict);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1121:  default:",
          "1122:   break;",
          "1123:  }",
          "1125: }",
          "",
          "[Removed Lines]",
          "1124:  return check_generic_ptr_alignment(reg, pointer_desc, off, size, strict);",
          "",
          "[Added Lines]",
          "1133:  return check_generic_ptr_alignment(env, reg, pointer_desc, off, size,",
          "1134:         strict);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1153:  if (reg->type == PTR_TO_MAP_VALUE) {",
          "1154:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "1155:       is_pointer_value(env, value_regno)) {",
          "1157:    return -EACCES;",
          "1158:   }",
          "1160:   err = check_map_access(env, regno, off, size);",
          "1161:   if (!err && t == BPF_READ && value_regno >= 0)",
          "1164:  } else if (reg->type == PTR_TO_CTX) {",
          "1165:   enum bpf_reg_type reg_type = SCALAR_VALUE;",
          "1167:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "1168:       is_pointer_value(env, value_regno)) {",
          "1170:    return -EACCES;",
          "1171:   }",
          "",
          "[Removed Lines]",
          "1156:    verbose(\"R%d leaks addr into map\\n\", value_regno);",
          "1162:    mark_reg_unknown(state->regs, value_regno);",
          "1169:    verbose(\"R%d leaks addr into ctx\\n\", value_regno);",
          "",
          "[Added Lines]",
          "1166:    verbose(env, \"R%d leaks addr into map\\n\", value_regno);",
          "1172:    mark_reg_unknown(env, state->regs, value_regno);",
          "1179:    verbose(env, \"R%d leaks addr into ctx\\n\", value_regno);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1176:    char tn_buf[48];",
          "1178:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1180:     tn_buf, off, size);",
          "1181:    return -EACCES;",
          "1182:   }",
          "",
          "[Removed Lines]",
          "1179:    verbose(\"variable ctx access var_off=%s off=%d size=%d\",",
          "",
          "[Added Lines]",
          "1189:    verbose(env,",
          "1190:     \"variable ctx access var_off=%s off=%d size=%d\",",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1190:    if (reg_type == SCALAR_VALUE)",
          "1192:    else",
          "1194:    state->regs[value_regno].id = 0;",
          "1195:    state->regs[value_regno].off = 0;",
          "1196:    state->regs[value_regno].range = 0;",
          "",
          "[Removed Lines]",
          "1191:     mark_reg_unknown(state->regs, value_regno);",
          "1193:     mark_reg_known_zero(state->regs, value_regno);",
          "",
          "[Added Lines]",
          "1202:     mark_reg_unknown(env, state->regs, value_regno);",
          "1204:     mark_reg_known_zero(env, state->regs,",
          "1205:           value_regno);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1206:    char tn_buf[48];",
          "1208:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1210:     tn_buf, off, size);",
          "1211:    return -EACCES;",
          "1212:   }",
          "1213:   off += reg->var_off.value;",
          "1214:   if (off >= 0 || off < -MAX_BPF_STACK) {",
          "1216:    return -EACCES;",
          "1217:   }",
          "",
          "[Removed Lines]",
          "1209:    verbose(\"variable stack access var_off=%s off=%d size=%d\",",
          "1215:    verbose(\"invalid stack off=%d size=%d\\n\", off, size);",
          "",
          "[Added Lines]",
          "1221:    verbose(env, \"variable stack access var_off=%s off=%d size=%d\",",
          "1227:    verbose(env, \"invalid stack off=%d size=%d\\n\", off,",
          "1228:     size);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1223:    if (!env->allow_ptr_leaks &&",
          "1224:        state->stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &&",
          "1225:        size != BPF_REG_SIZE) {",
          "1227:     return -EACCES;",
          "1228:    }",
          "1230:   } else {",
          "1232:   }",
          "1233:  } else if (reg_is_pkt_pointer(reg)) {",
          "1234:   if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {",
          "1236:    return -EACCES;",
          "1237:   }",
          "1238:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "1239:       is_pointer_value(env, value_regno)) {",
          "1241:    return -EACCES;",
          "1242:   }",
          "1243:   err = check_packet_access(env, regno, off, size);",
          "1244:   if (!err && t == BPF_READ && value_regno >= 0)",
          "1246:  } else {",
          "1249:   return -EACCES;",
          "1250:  }",
          "",
          "[Removed Lines]",
          "1226:     verbose(\"attempt to corrupt spilled pointer on stack\\n\");",
          "1229:    err = check_stack_write(state, off, size, value_regno);",
          "1231:    err = check_stack_read(state, off, size, value_regno);",
          "1235:    verbose(\"cannot write into packet\\n\");",
          "1240:    verbose(\"R%d leaks addr into packet\\n\", value_regno);",
          "1245:    mark_reg_unknown(state->regs, value_regno);",
          "1247:   verbose(\"R%d invalid mem access '%s'\\n\",",
          "1248:    regno, reg_type_str[reg->type]);",
          "",
          "[Added Lines]",
          "1239:     verbose(env, \"attempt to corrupt spilled pointer on stack\\n\");",
          "1242:    err = check_stack_write(env, state, off, size,",
          "1243:       value_regno);",
          "1245:    err = check_stack_read(env, state, off, size,",
          "1246:             value_regno);",
          "1250:    verbose(env, \"cannot write into packet\\n\");",
          "1255:    verbose(env, \"R%d leaks addr into packet\\n\",",
          "1256:     value_regno);",
          "1261:    mark_reg_unknown(env, state->regs, value_regno);",
          "1263:   verbose(env, \"R%d invalid mem access '%s'\\n\", regno,",
          "1264:    reg_type_str[reg->type]);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1266:  if ((BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) ||",
          "1267:      insn->imm != 0) {",
          "1269:   return -EINVAL;",
          "1270:  }",
          "",
          "[Removed Lines]",
          "1268:   verbose(\"BPF_XADD uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "1284:   verbose(env, \"BPF_XADD uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1280:   return err;",
          "1282:  if (is_pointer_value(env, insn->src_reg)) {",
          "1284:   return -EACCES;",
          "1285:  }",
          "",
          "[Removed Lines]",
          "1283:   verbose(\"R%d leaks addr into mem\\n\", insn->src_reg);",
          "",
          "[Added Lines]",
          "1299:   verbose(env, \"R%d leaks addr into mem\\n\", insn->src_reg);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1321:       register_is_null(regs[regno]))",
          "1322:    return 0;",
          "1325:    reg_type_str[regs[regno].type],",
          "1326:    reg_type_str[PTR_TO_STACK]);",
          "1327:   return -EACCES;",
          "",
          "[Removed Lines]",
          "1324:   verbose(\"R%d type=%s expected=%s\\n\", regno,",
          "",
          "[Added Lines]",
          "1340:   verbose(env, \"R%d type=%s expected=%s\\n\", regno,",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1332:   char tn_buf[48];",
          "1334:   tnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);",
          "1336:    regno, tn_buf);",
          "1337:  }",
          "1338:  off = regs[regno].off + regs[regno].var_off.value;",
          "1339:  if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",
          "1340:      access_size <= 0) {",
          "1342:    regno, off, access_size);",
          "1343:   return -EACCES;",
          "1344:  }",
          "",
          "[Removed Lines]",
          "1335:   verbose(\"invalid variable stack read R%d var_off=%s\\n\",",
          "1341:   verbose(\"invalid stack type R%d off=%d access_size=%d\\n\",",
          "",
          "[Added Lines]",
          "1351:   verbose(env, \"invalid variable stack read R%d var_off=%s\\n\",",
          "1357:   verbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1355:  for (i = 0; i < access_size; i++) {",
          "1356:   if (state->stack_slot_type[MAX_BPF_STACK + off + i] != STACK_MISC) {",
          "1358:     off, i, access_size);",
          "1359:    return -EACCES;",
          "1360:   }",
          "",
          "[Removed Lines]",
          "1357:    verbose(\"invalid indirect read from stack off %d+%d size %d\\n\",",
          "",
          "[Added Lines]",
          "1373:    verbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1398:  if (arg_type == ARG_ANYTHING) {",
          "1399:   if (is_pointer_value(env, regno)) {",
          "1401:    return -EACCES;",
          "1402:   }",
          "1403:   return 0;",
          "",
          "[Removed Lines]",
          "1400:    verbose(\"R%d leaks addr into helper function\\n\", regno);",
          "",
          "[Added Lines]",
          "1416:    verbose(env, \"R%d leaks addr into helper function\\n\",",
          "1417:     regno);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1406:  if (type_is_pkt_pointer(type) &&",
          "1407:      !may_access_direct_pkt_data(env, meta, BPF_READ)) {",
          "1409:   return -EACCES;",
          "1410:  }",
          "",
          "[Removed Lines]",
          "1408:   verbose(\"helper access to the packet is not allowed\\n\");",
          "",
          "[Added Lines]",
          "1425:   verbose(env, \"helper access to the packet is not allowed\\n\");",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1443:    goto err_type;",
          "1444:   meta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;",
          "1445:  } else {",
          "1447:   return -EFAULT;",
          "1448:  }",
          "",
          "[Removed Lines]",
          "1446:   verbose(\"unsupported arg_type %d\\n\", arg_type);",
          "",
          "[Added Lines]",
          "1463:   verbose(env, \"unsupported arg_type %d\\n\", arg_type);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1465:    return -EACCES;",
          "1466:   }",
          "1467:   if (type_is_pkt_pointer(type))",
          "",
          "[Removed Lines]",
          "1464:    verbose(\"invalid map_ptr to access map->key\\n\");",
          "",
          "[Added Lines]",
          "1481:    verbose(env, \"invalid map_ptr to access map->key\\n\");",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1478:   if (!meta->map_ptr) {",
          "1481:    return -EACCES;",
          "1482:   }",
          "1483:   if (type_is_pkt_pointer(type))",
          "",
          "[Removed Lines]",
          "1480:    verbose(\"invalid map_ptr to access map->value\\n\");",
          "",
          "[Added Lines]",
          "1497:    verbose(env, \"invalid map_ptr to access map->value\\n\");",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1498:   if (regno == 0) {",
          "1501:    return -EACCES;",
          "1502:   }",
          "",
          "[Removed Lines]",
          "1500:    verbose(\"ARG_CONST_SIZE cannot be first argument\\n\");",
          "",
          "[Added Lines]",
          "1517:    verbose(env,",
          "1518:     \"ARG_CONST_SIZE cannot be first argument\\n\");",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1514:    meta = NULL;",
          "1516:   if (reg->smin_value < 0) {",
          "1518:     regno);",
          "1519:    return -EACCES;",
          "1520:   }",
          "",
          "[Removed Lines]",
          "1517:    verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "",
          "[Added Lines]",
          "1535:    verbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1528:   }",
          "1530:   if (reg->umax_value >= BPF_MAX_VAR_SIZ) {",
          "1532:     regno);",
          "1533:    return -EACCES;",
          "1534:   }",
          "",
          "[Removed Lines]",
          "1531:    verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "",
          "[Added Lines]",
          "1549:    verbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1540:  return err;",
          "1541: err_type:",
          "1543:   reg_type_str[type], reg_type_str[expected_type]);",
          "1544:  return -EACCES;",
          "1545: }",
          "1548: {",
          "1549:  if (!map)",
          "1550:   return 0;",
          "",
          "[Removed Lines]",
          "1542:  verbose(\"R%d type=%s expected=%s\\n\", regno,",
          "1547: static int check_map_func_compatibility(struct bpf_map *map, int func_id)",
          "",
          "[Added Lines]",
          "1560:  verbose(env, \"R%d type=%s expected=%s\\n\", regno,",
          "1565: static int check_map_func_compatibility(struct bpf_verifier_env *env,",
          "1566:      struct bpf_map *map, int func_id)",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1633:  return 0;",
          "1634: error:",
          "1636:   map->map_type, func_id_name(func_id), func_id);",
          "1637:  return -EINVAL;",
          "1638: }",
          "",
          "[Removed Lines]",
          "1635:  verbose(\"cannot pass map_type %d into func %s#%d\\n\",",
          "",
          "[Added Lines]",
          "1654:  verbose(env, \"cannot pass map_type %d into func %s#%d\\n\",",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1667:  for (i = 0; i < MAX_BPF_REG; i++)",
          "1668:   if (reg_is_pkt_pointer_any(&regs[i]))",
          "1671:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "1672:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "",
          "[Removed Lines]",
          "1669:    mark_reg_unknown(regs, i);",
          "",
          "[Added Lines]",
          "1688:    mark_reg_unknown(env, regs, i);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1690:  if (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {",
          "1692:   return -EINVAL;",
          "1693:  }",
          "",
          "[Removed Lines]",
          "1691:   verbose(\"invalid func %s#%d\\n\", func_id_name(func_id), func_id);",
          "",
          "[Added Lines]",
          "1710:   verbose(env, \"invalid func %s#%d\\n\", func_id_name(func_id),",
          "1711:    func_id);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1696:   fn = env->prog->aux->ops->get_func_proto(func_id);",
          "1698:  if (!fn) {",
          "1700:   return -EINVAL;",
          "1701:  }",
          "1704:  if (!env->prog->gpl_compatible && fn->gpl_only) {",
          "1706:   return -EINVAL;",
          "1707:  }",
          "",
          "[Removed Lines]",
          "1699:   verbose(\"unknown func %s#%d\\n\", func_id_name(func_id), func_id);",
          "1705:   verbose(\"cannot call GPL only function from proprietary program\\n\");",
          "",
          "[Added Lines]",
          "1719:   verbose(env, \"unknown func %s#%d\\n\", func_id_name(func_id),",
          "1720:    func_id);",
          "1726:   verbose(env, \"cannot call GPL only function from proprietary program\\n\");",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1717:  err = check_raw_mode(fn);",
          "1718:  if (err) {",
          "1720:    func_id_name(func_id), func_id);",
          "1721:   return err;",
          "1722:  }",
          "",
          "[Removed Lines]",
          "1719:   verbose(\"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "[Added Lines]",
          "1740:   verbose(env, \"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1751:  for (i = 0; i < CALLER_SAVED_REGS; i++) {",
          "1753:   check_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);",
          "1754:  }",
          "1757:  if (fn->ret_type == RET_INTEGER) {",
          "1760:  } else if (fn->ret_type == RET_VOID) {",
          "1761:   regs[BPF_REG_0].type = NOT_INIT;",
          "1762:  } else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {",
          "",
          "[Removed Lines]",
          "1752:   mark_reg_not_init(regs, caller_saved[i]);",
          "1759:   mark_reg_unknown(regs, BPF_REG_0);",
          "",
          "[Added Lines]",
          "1773:   mark_reg_not_init(env, regs, caller_saved[i]);",
          "1780:   mark_reg_unknown(env, regs, BPF_REG_0);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1765:   regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;",
          "1768:   regs[BPF_REG_0].off = 0;",
          "1773:   if (meta.map_ptr == NULL) {",
          "1775:    return -EINVAL;",
          "1776:   }",
          "1777:   regs[BPF_REG_0].map_ptr = meta.map_ptr;",
          "",
          "[Removed Lines]",
          "1767:   mark_reg_known_zero(regs, BPF_REG_0);",
          "1774:    verbose(\"kernel subsystem misconfigured verifier\\n\");",
          "",
          "[Added Lines]",
          "1788:   mark_reg_known_zero(env, regs, BPF_REG_0);",
          "1795:    verbose(env,",
          "1796:     \"kernel subsystem misconfigured verifier\\n\");",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1782:   else if (insn_aux->map_ptr != meta.map_ptr)",
          "1783:    insn_aux->map_ptr = BPF_MAP_PTR_POISON;",
          "1784:  } else {",
          "1786:    fn->ret_type, func_id_name(func_id), func_id);",
          "1787:   return -EINVAL;",
          "1788:  }",
          "1791:  if (err)",
          "1792:   return err;",
          "",
          "[Removed Lines]",
          "1785:   verbose(\"unknown return type %d of func %s#%d\\n\",",
          "1790:  err = check_map_func_compatibility(meta.map_ptr, func_id);",
          "",
          "[Added Lines]",
          "1807:   verbose(env, \"unknown return type %d of func %s#%d\\n\",",
          "1812:  err = check_map_func_compatibility(env, meta.map_ptr, func_id);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1846:  dst_reg = &regs[dst];",
          "1848:  if (WARN_ON_ONCE(known && (smin_val != smax_val))) {",
          "1851:   return -EINVAL;",
          "1852:  }",
          "1853:  if (WARN_ON_ONCE(known && (umin_val != umax_val))) {",
          "1856:   return -EINVAL;",
          "1857:  }",
          "1859:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1861:   if (!env->allow_ptr_leaks)",
          "1863:     dst);",
          "1864:   return -EACCES;",
          "1865:  }",
          "1867:  if (ptr_reg->type == PTR_TO_MAP_VALUE_OR_NULL) {",
          "1868:   if (!env->allow_ptr_leaks)",
          "1870:     dst);",
          "1871:   return -EACCES;",
          "1872:  }",
          "1873:  if (ptr_reg->type == CONST_PTR_TO_MAP) {",
          "1874:   if (!env->allow_ptr_leaks)",
          "1876:     dst);",
          "1877:   return -EACCES;",
          "1878:  }",
          "1879:  if (ptr_reg->type == PTR_TO_PACKET_END) {",
          "1880:   if (!env->allow_ptr_leaks)",
          "1882:     dst);",
          "1883:   return -EACCES;",
          "1884:  }",
          "",
          "[Removed Lines]",
          "1849:   print_verifier_state(&env->cur_state);",
          "1850:   verbose(\"verifier internal error: known but bad sbounds\\n\");",
          "1854:   print_verifier_state(&env->cur_state);",
          "1855:   verbose(\"verifier internal error: known but bad ubounds\\n\");",
          "1862:    verbose(\"R%d 32-bit pointer arithmetic prohibited\\n\",",
          "1869:    verbose(\"R%d pointer arithmetic on PTR_TO_MAP_VALUE_OR_NULL prohibited, null-check it first\\n\",",
          "1875:    verbose(\"R%d pointer arithmetic on CONST_PTR_TO_MAP prohibited\\n\",",
          "1881:    verbose(\"R%d pointer arithmetic on PTR_TO_PACKET_END prohibited\\n\",",
          "",
          "[Added Lines]",
          "1871:   print_verifier_state(env, &env->cur_state);",
          "1872:   verbose(env,",
          "1873:    \"verifier internal error: known but bad sbounds\\n\");",
          "1877:   print_verifier_state(env, &env->cur_state);",
          "1878:   verbose(env,",
          "1879:    \"verifier internal error: known but bad ubounds\\n\");",
          "1886:    verbose(env,",
          "1887:     \"R%d 32-bit pointer arithmetic prohibited\\n\",",
          "1894:    verbose(env, \"R%d pointer arithmetic on PTR_TO_MAP_VALUE_OR_NULL prohibited, null-check it first\\n\",",
          "1900:    verbose(env, \"R%d pointer arithmetic on CONST_PTR_TO_MAP prohibited\\n\",",
          "1906:    verbose(env, \"R%d pointer arithmetic on PTR_TO_PACKET_END prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1943:   if (dst_reg == off_reg) {",
          "1945:    if (!env->allow_ptr_leaks)",
          "1947:      dst);",
          "1948:    return -EACCES;",
          "1949:   }",
          "",
          "[Removed Lines]",
          "1946:     verbose(\"R%d tried to subtract pointer from scalar\\n\",",
          "",
          "[Added Lines]",
          "1971:     verbose(env, \"R%d tried to subtract pointer from scalar\\n\",",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1954:   if (ptr_reg->type == PTR_TO_STACK) {",
          "1955:    if (!env->allow_ptr_leaks)",
          "1957:      dst);",
          "1958:    return -EACCES;",
          "1959:   }",
          "",
          "[Removed Lines]",
          "1956:     verbose(\"R%d subtraction from stack pointer prohibited\\n\",",
          "",
          "[Added Lines]",
          "1981:     verbose(env, \"R%d subtraction from stack pointer prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "2010:   if (!env->allow_ptr_leaks)",
          "2012:     dst, bpf_alu_string[opcode >> 4]);",
          "2013:   return -EACCES;",
          "2014:  default:",
          "2016:   if (!env->allow_ptr_leaks)",
          "2018:     dst, bpf_alu_string[opcode >> 4]);",
          "2019:   return -EACCES;",
          "2020:  }",
          "",
          "[Removed Lines]",
          "2011:    verbose(\"R%d bitwise operator %s on pointer prohibited\\n\",",
          "2017:    verbose(\"R%d pointer arithmetic with %s operator prohibited\\n\",",
          "",
          "[Added Lines]",
          "2036:    verbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",",
          "2042:    verbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2184:    break;",
          "2185:   }",
          "",
          "[Removed Lines]",
          "2183:    mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2208:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2212:    break;",
          "2213:   }",
          "",
          "[Removed Lines]",
          "2211:    mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2236:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2236:   __update_reg_bounds(dst_reg);",
          "2237:   break;",
          "2238:  default:",
          "2240:   break;",
          "2241:  }",
          "",
          "[Removed Lines]",
          "2239:   mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2264:   mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2270:     if (!env->allow_ptr_leaks) {",
          "2272:       insn->dst_reg,",
          "2273:       bpf_alu_string[opcode >> 4]);",
          "2274:      return -EACCES;",
          "2275:     }",
          "2277:     return 0;",
          "2278:    } else {",
          "",
          "[Removed Lines]",
          "2271:      verbose(\"R%d pointer %s pointer prohibited\\n\",",
          "2276:     mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2296:      verbose(env, \"R%d pointer %s pointer prohibited\\n\",",
          "2301:     mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2327:  if (WARN_ON_ONCE(ptr_reg)) {",
          "2330:   return -EINVAL;",
          "2331:  }",
          "2332:  if (WARN_ON(!src_reg)) {",
          "2335:   return -EINVAL;",
          "2336:  }",
          "2337:  return adjust_scalar_min_max_vals(env, insn, dst_reg, *src_reg);",
          "",
          "[Removed Lines]",
          "2328:   print_verifier_state(&env->cur_state);",
          "2329:   verbose(\"verifier internal error: unexpected ptr_reg\\n\");",
          "2333:   print_verifier_state(&env->cur_state);",
          "2334:   verbose(\"verifier internal error: no src_reg\\n\");",
          "",
          "[Added Lines]",
          "2353:   print_verifier_state(env, &env->cur_state);",
          "2354:   verbose(env, \"verifier internal error: unexpected ptr_reg\\n\");",
          "2358:   print_verifier_state(env, &env->cur_state);",
          "2359:   verbose(env, \"verifier internal error: no src_reg\\n\");",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2349:    if (BPF_SRC(insn->code) != 0 ||",
          "2350:        insn->src_reg != BPF_REG_0 ||",
          "2351:        insn->off != 0 || insn->imm != 0) {",
          "2353:     return -EINVAL;",
          "2354:    }",
          "2355:   } else {",
          "2356:    if (insn->src_reg != BPF_REG_0 || insn->off != 0 ||",
          "2357:        (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||",
          "2358:        BPF_CLASS(insn->code) == BPF_ALU64) {",
          "2360:     return -EINVAL;",
          "2361:    }",
          "2362:   }",
          "",
          "[Removed Lines]",
          "2352:     verbose(\"BPF_NEG uses reserved fields\\n\");",
          "2359:     verbose(\"BPF_END uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2377:     verbose(env, \"BPF_NEG uses reserved fields\\n\");",
          "2384:     verbose(env, \"BPF_END uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2367:    return err;",
          "2369:   if (is_pointer_value(env, insn->dst_reg)) {",
          "2371:     insn->dst_reg);",
          "2372:    return -EACCES;",
          "2373:   }",
          "",
          "[Removed Lines]",
          "2370:    verbose(\"R%d pointer arithmetic prohibited\\n\",",
          "",
          "[Added Lines]",
          "2395:    verbose(env, \"R%d pointer arithmetic prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2382:   if (BPF_SRC(insn->code) == BPF_X) {",
          "2383:    if (insn->imm != 0 || insn->off != 0) {",
          "2385:     return -EINVAL;",
          "2386:    }",
          "",
          "[Removed Lines]",
          "2384:     verbose(\"BPF_MOV uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2409:     verbose(env, \"BPF_MOV uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2391:     return err;",
          "2392:   } else {",
          "2393:    if (insn->src_reg != BPF_REG_0 || insn->off != 0) {",
          "2395:     return -EINVAL;",
          "2396:    }",
          "2397:   }",
          "",
          "[Removed Lines]",
          "2394:     verbose(\"BPF_MOV uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2419:     verbose(env, \"BPF_MOV uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2411:    } else {",
          "2413:     if (is_pointer_value(env, insn->src_reg)) {",
          "2415:       insn->src_reg);",
          "2416:      return -EACCES;",
          "2417:     }",
          "2420:     regs[insn->dst_reg].var_off = tnum_cast(",
          "2421:       regs[insn->dst_reg].var_off, 4);",
          "",
          "[Removed Lines]",
          "2414:      verbose(\"R%d partial copy of pointer\\n\",",
          "2418:     mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2439:      verbose(env,",
          "2440:       \"R%d partial copy of pointer\\n\",",
          "2444:     mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2430:   }",
          "2432:  } else if (opcode > BPF_END) {",
          "2434:   return -EINVAL;",
          "2438:   if (BPF_SRC(insn->code) == BPF_X) {",
          "2439:    if (insn->imm != 0 || insn->off != 0) {",
          "2441:     return -EINVAL;",
          "2442:    }",
          "",
          "[Removed Lines]",
          "2433:   verbose(\"invalid BPF_ALU opcode %x\\n\", opcode);",
          "2440:     verbose(\"BPF_ALU uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2459:   verbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);",
          "2466:     verbose(env, \"BPF_ALU uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2446:     return err;",
          "2447:   } else {",
          "2448:    if (insn->src_reg != BPF_REG_0 || insn->off != 0) {",
          "2450:     return -EINVAL;",
          "2451:    }",
          "2452:   }",
          "",
          "[Removed Lines]",
          "2449:     verbose(\"BPF_ALU uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2475:     verbose(env, \"BPF_ALU uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2459:   if ((opcode == BPF_MOD || opcode == BPF_DIV) &&",
          "2460:       BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {",
          "2462:    return -EINVAL;",
          "2463:   }",
          "",
          "[Removed Lines]",
          "2461:    verbose(\"div by zero\\n\");",
          "",
          "[Added Lines]",
          "2487:    verbose(env, \"div by zero\\n\");",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2467:    int size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;",
          "2469:    if (insn->imm < 0 || insn->imm >= size) {",
          "2471:     return -EINVAL;",
          "2472:    }",
          "2473:   }",
          "",
          "[Removed Lines]",
          "2470:     verbose(\"invalid shift %d\\n\", insn->imm);",
          "",
          "[Added Lines]",
          "2496:     verbose(env, \"invalid shift %d\\n\", insn->imm);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2820:  int err;",
          "2822:  if (opcode > BPF_JSLE) {",
          "2824:   return -EINVAL;",
          "2825:  }",
          "2827:  if (BPF_SRC(insn->code) == BPF_X) {",
          "2828:   if (insn->imm != 0) {",
          "2830:    return -EINVAL;",
          "2831:   }",
          "",
          "[Removed Lines]",
          "2823:   verbose(\"invalid BPF_JMP opcode %x\\n\", opcode);",
          "2829:    verbose(\"BPF_JMP uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2849:   verbose(env, \"invalid BPF_JMP opcode %x\\n\", opcode);",
          "2855:    verbose(env, \"BPF_JMP uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2836:    return err;",
          "2838:   if (is_pointer_value(env, insn->src_reg)) {",
          "2840:     insn->src_reg);",
          "2841:    return -EACCES;",
          "2842:   }",
          "2843:  } else {",
          "2844:   if (insn->src_reg != BPF_REG_0) {",
          "2846:    return -EINVAL;",
          "2847:   }",
          "2848:  }",
          "",
          "[Removed Lines]",
          "2839:    verbose(\"R%d pointer comparison prohibited\\n\",",
          "2845:    verbose(\"BPF_JMP uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2865:    verbose(env, \"R%d pointer comparison prohibited\\n\",",
          "2871:    verbose(env, \"BPF_JMP uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "2954:   find_good_pkt_pointers(this_branch, &regs[insn->src_reg],",
          "2955:            PTR_TO_PACKET_META);",
          "2956:  } else if (is_pointer_value(env, insn->dst_reg)) {",
          "2958:   return -EACCES;",
          "2959:  }",
          "2962:  return 0;",
          "2963: }",
          "",
          "[Removed Lines]",
          "2957:   verbose(\"R%d pointer comparison prohibited\\n\", insn->dst_reg);",
          "2960:  if (verifier_log.level)",
          "2961:   print_verifier_state(this_branch);",
          "",
          "[Added Lines]",
          "2983:   verbose(env, \"R%d pointer comparison prohibited\\n\",",
          "2984:    insn->dst_reg);",
          "2987:  if (env->log.level)",
          "2988:   print_verifier_state(env, this_branch);",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "2977:  int err;",
          "2979:  if (BPF_SIZE(insn->code) != BPF_DW) {",
          "2981:   return -EINVAL;",
          "2982:  }",
          "2983:  if (insn->off != 0) {",
          "2985:   return -EINVAL;",
          "2986:  }",
          "",
          "[Removed Lines]",
          "2980:   verbose(\"invalid BPF_LD_IMM insn\\n\");",
          "2984:   verbose(\"BPF_LD_IMM64 uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3007:   verbose(env, \"invalid BPF_LD_IMM insn\\n\");",
          "3011:   verbose(env, \"BPF_LD_IMM64 uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "3039:  int i, err;",
          "3041:  if (!may_access_skb(env->prog->type)) {",
          "3043:   return -EINVAL;",
          "3044:  }",
          "3046:  if (insn->dst_reg != BPF_REG_0 || insn->off != 0 ||",
          "3047:      BPF_SIZE(insn->code) == BPF_DW ||",
          "3048:      (mode == BPF_ABS && insn->src_reg != BPF_REG_0)) {",
          "3050:   return -EINVAL;",
          "3051:  }",
          "",
          "[Removed Lines]",
          "3042:   verbose(\"BPF_LD_[ABS|IND] instructions not allowed for this program type\\n\");",
          "3049:   verbose(\"BPF_LD_[ABS|IND] uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3069:   verbose(env, \"BPF_LD_[ABS|IND] instructions not allowed for this program type\\n\");",
          "3076:   verbose(env, \"BPF_LD_[ABS|IND] uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "3056:   return err;",
          "3058:  if (regs[BPF_REG_6].type != PTR_TO_CTX) {",
          "3060:   return -EINVAL;",
          "3061:  }",
          "",
          "[Removed Lines]",
          "3059:   verbose(\"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");",
          "",
          "[Added Lines]",
          "3086:   verbose(env,",
          "3087:    \"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "3071:  for (i = 0; i < CALLER_SAVED_REGS; i++) {",
          "3073:   check_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);",
          "3074:  }",
          "",
          "[Removed Lines]",
          "3072:   mark_reg_not_init(regs, caller_saved[i]);",
          "",
          "[Added Lines]",
          "3100:   mark_reg_not_init(env, regs, caller_saved[i]);",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "3081:  return 0;",
          "3082: }",
          "",
          "[Removed Lines]",
          "3080:  mark_reg_unknown(regs, BPF_REG_0);",
          "",
          "[Added Lines]",
          "3108:  mark_reg_unknown(env, regs, BPF_REG_0);",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "3098:  reg = &env->cur_state.regs[BPF_REG_0];",
          "3099:  if (reg->type != SCALAR_VALUE) {",
          "3101:    reg_type_str[reg->type]);",
          "3102:   return -EINVAL;",
          "3103:  }",
          "3105:  if (!tnum_in(range, reg->var_off)) {",
          "3107:   if (!tnum_is_unknown(reg->var_off)) {",
          "3108:    char tn_buf[48];",
          "3110:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "3112:   } else {",
          "3114:   }",
          "3116:   return -EINVAL;",
          "3117:  }",
          "3118:  return 0;",
          "",
          "[Removed Lines]",
          "3100:   verbose(\"At program exit the register R0 is not a known value (%s)\\n\",",
          "3106:   verbose(\"At program exit the register R0 \");",
          "3111:    verbose(\"has value %s\", tn_buf);",
          "3113:    verbose(\"has unknown scalar value\");",
          "3115:   verbose(\" should have been 0 or 1\\n\");",
          "",
          "[Added Lines]",
          "3128:   verbose(env, \"At program exit the register R0 is not a known value (%s)\\n\",",
          "3134:   verbose(env, \"At program exit the register R0 \");",
          "3139:    verbose(env, \"has value %s\", tn_buf);",
          "3141:    verbose(env, \"has unknown scalar value\");",
          "3143:   verbose(env, \" should have been 0 or 1\\n\");",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "3178:   return 0;",
          "3180:  if (w < 0 || w >= env->prog->len) {",
          "3182:   return -EINVAL;",
          "3183:  }",
          "",
          "[Removed Lines]",
          "3181:   verbose(\"jump out of range from insn %d to %d\\n\", t, w);",
          "",
          "[Added Lines]",
          "3209:   verbose(env, \"jump out of range from insn %d to %d\\n\", t, w);",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "3195:   insn_stack[cur_stack++] = w;",
          "3196:   return 1;",
          "3197:  } else if ((insn_state[w] & 0xF0) == DISCOVERED) {",
          "3199:   return -EINVAL;",
          "3200:  } else if (insn_state[w] == EXPLORED) {",
          "3202:   insn_state[t] = DISCOVERED | e;",
          "3203:  } else {",
          "3205:   return -EFAULT;",
          "3206:  }",
          "3207:  return 0;",
          "",
          "[Removed Lines]",
          "3198:   verbose(\"back-edge from insn %d to %d\\n\", t, w);",
          "3204:   verbose(\"insn state internal bug\\n\");",
          "",
          "[Added Lines]",
          "3226:   verbose(env, \"back-edge from insn %d to %d\\n\", t, w);",
          "3232:   verbose(env, \"insn state internal bug\\n\");",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "3295: mark_explored:",
          "3296:  insn_state[t] = EXPLORED;",
          "3297:  if (cur_stack-- <= 0) {",
          "3299:   ret = -EFAULT;",
          "3300:   goto err_free;",
          "3301:  }",
          "",
          "[Removed Lines]",
          "3298:   verbose(\"pop stack internal bug\\n\");",
          "",
          "[Added Lines]",
          "3326:   verbose(env, \"pop stack internal bug\\n\");",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "3304: check_state:",
          "3305:  for (i = 0; i < insn_cnt; i++) {",
          "3306:   if (insn_state[i] != EXPLORED) {",
          "3308:    ret = -EINVAL;",
          "3309:    goto err_free;",
          "3310:   }",
          "",
          "[Removed Lines]",
          "3307:    verbose(\"unreachable insn %d\\n\", i);",
          "",
          "[Added Lines]",
          "3335:    verbose(env, \"unreachable insn %d\\n\", i);",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "3685:  int insn_processed = 0;",
          "3686:  bool do_print_state = false;",
          "3689:  state->parent = NULL;",
          "3690:  insn_idx = 0;",
          "3691:  for (;;) {",
          "",
          "[Removed Lines]",
          "3688:  init_reg_state(regs);",
          "",
          "[Added Lines]",
          "3716:  init_reg_state(env, regs);",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "3694:   int err;",
          "3696:   if (insn_idx >= insn_cnt) {",
          "3698:     insn_idx, insn_cnt);",
          "3699:    return -EFAULT;",
          "3700:   }",
          "",
          "[Removed Lines]",
          "3697:    verbose(\"invalid insn idx %d insn_cnt %d\\n\",",
          "",
          "[Added Lines]",
          "3725:    verbose(env, \"invalid insn idx %d insn_cnt %d\\n\",",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "3703:   class = BPF_CLASS(insn->code);",
          "3705:   if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {",
          "3707:     insn_processed);",
          "3708:    return -E2BIG;",
          "3709:   }",
          "",
          "[Removed Lines]",
          "3706:    verbose(\"BPF program is too large. Processed %d insn\\n\",",
          "",
          "[Added Lines]",
          "3734:    verbose(env,",
          "3735:     \"BPF program is too large. Processed %d insn\\n\",",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "3713:    return err;",
          "3714:   if (err == 1) {",
          "3717:     if (do_print_state)",
          "3719:       prev_insn_idx, insn_idx);",
          "3720:     else",
          "3722:    }",
          "3723:    goto process_bpf_exit;",
          "3724:   }",
          "",
          "[Removed Lines]",
          "3716:    if (verifier_log.level) {",
          "3718:      verbose(\"\\nfrom %d to %d: safe\\n\",",
          "3721:      verbose(\"%d: safe\\n\", insn_idx);",
          "",
          "[Added Lines]",
          "3745:    if (env->log.level) {",
          "3747:      verbose(env, \"\\nfrom %d to %d: safe\\n\",",
          "3750:      verbose(env, \"%d: safe\\n\", insn_idx);",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "3726:   if (need_resched())",
          "3727:    cond_resched();",
          "3733:    else",
          "3735:      prev_insn_idx, insn_idx);",
          "3737:    do_print_state = false;",
          "3738:   }",
          "3742:    print_bpf_insn(env, insn);",
          "3743:   }",
          "",
          "[Removed Lines]",
          "3729:   if (verifier_log.level > 1 ||",
          "3730:       (verifier_log.level && do_print_state)) {",
          "3731:    if (verifier_log.level > 1)",
          "3732:     verbose(\"%d:\", insn_idx);",
          "3734:     verbose(\"\\nfrom %d to %d:\",",
          "3736:    print_verifier_state(&env->cur_state);",
          "3740:   if (verifier_log.level) {",
          "3741:    verbose(\"%d: \", insn_idx);",
          "",
          "[Added Lines]",
          "3758:   if (env->log.level > 1 || (env->log.level && do_print_state)) {",
          "3759:    if (env->log.level > 1)",
          "3760:     verbose(env, \"%d:\", insn_idx);",
          "3762:     verbose(env, \"\\nfrom %d to %d:\",",
          "3764:    print_verifier_state(env, &env->cur_state);",
          "3768:   if (env->log.level) {",
          "3769:    verbose(env, \"%d: \", insn_idx);",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "3799:     return -EINVAL;",
          "3800:    }",
          "",
          "[Removed Lines]",
          "3798:     verbose(\"same insn cannot be used with different pointers\\n\");",
          "",
          "[Added Lines]",
          "3826:     verbose(env, \"same insn cannot be used with different pointers\\n\");",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "3835:    } else if (dst_reg_type != *prev_dst_type &&",
          "3836:        (dst_reg_type == PTR_TO_CTX ||",
          "3839:     return -EINVAL;",
          "3840:    }",
          "3842:   } else if (class == BPF_ST) {",
          "3843:    if (BPF_MODE(insn->code) != BPF_MEM ||",
          "3844:        insn->src_reg != BPF_REG_0) {",
          "3846:     return -EINVAL;",
          "3847:    }",
          "",
          "[Removed Lines]",
          "3838:     verbose(\"same insn cannot be used with different pointers\\n\");",
          "3845:     verbose(\"BPF_ST uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3866:     verbose(env, \"same insn cannot be used with different pointers\\n\");",
          "3873:     verbose(env, \"BPF_ST uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "3865:         insn->off != 0 ||",
          "3866:         insn->src_reg != BPF_REG_0 ||",
          "3867:         insn->dst_reg != BPF_REG_0) {",
          "3869:      return -EINVAL;",
          "3870:     }",
          "",
          "[Removed Lines]",
          "3868:      verbose(\"BPF_CALL uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3896:      verbose(env, \"BPF_CALL uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "3878:         insn->imm != 0 ||",
          "3879:         insn->src_reg != BPF_REG_0 ||",
          "3880:         insn->dst_reg != BPF_REG_0) {",
          "3882:      return -EINVAL;",
          "3883:     }",
          "",
          "[Removed Lines]",
          "3881:      verbose(\"BPF_JA uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3909:      verbose(env, \"BPF_JA uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "3890:         insn->imm != 0 ||",
          "3891:         insn->src_reg != BPF_REG_0 ||",
          "3892:         insn->dst_reg != BPF_REG_0) {",
          "3894:      return -EINVAL;",
          "3895:     }",
          "",
          "[Removed Lines]",
          "3893:      verbose(\"BPF_EXIT uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3921:      verbose(env, \"BPF_EXIT uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "3905:      return err;",
          "3907:     if (is_pointer_value(env, BPF_REG_0)) {",
          "3909:      return -EACCES;",
          "3910:     }",
          "",
          "[Removed Lines]",
          "3908:      verbose(\"R0 leaks addr as return value\\n\");",
          "",
          "[Added Lines]",
          "3936:      verbose(env, \"R0 leaks addr as return value\\n\");",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "3941:     insn_idx++;",
          "3942:    } else {",
          "3944:     return -EINVAL;",
          "3945:    }",
          "3946:   } else {",
          "3948:    return -EINVAL;",
          "3949:   }",
          "3951:   insn_idx++;",
          "3952:  }",
          "3956:  return 0;",
          "3957: }",
          "",
          "[Removed Lines]",
          "3943:     verbose(\"invalid BPF_LD mode\\n\");",
          "3947:    verbose(\"unknown insn class %d\\n\", class);",
          "3954:  verbose(\"processed %d insns, stack depth %d\\n\",",
          "3955:   insn_processed, env->prog->aux->stack_depth);",
          "",
          "[Added Lines]",
          "3971:     verbose(env, \"invalid BPF_LD mode\\n\");",
          "3975:    verbose(env, \"unknown insn class %d\\n\", class);",
          "3982:  verbose(env, \"processed %d insns, stack depth %d\\n\", insn_processed,",
          "3983:   env->prog->aux->stack_depth);",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "3964:   !(map->map_flags & BPF_F_NO_PREALLOC);",
          "3965: }",
          "3968:      struct bpf_prog *prog)",
          "3970: {",
          "",
          "[Removed Lines]",
          "3967: static int check_map_prog_compatibility(struct bpf_map *map,",
          "",
          "[Added Lines]",
          "3995: static int check_map_prog_compatibility(struct bpf_verifier_env *env,",
          "3996:      struct bpf_map *map,",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "3976:  if (prog->type == BPF_PROG_TYPE_PERF_EVENT) {",
          "3977:   if (!check_map_prealloc(map)) {",
          "3979:    return -EINVAL;",
          "3980:   }",
          "3981:   if (map->inner_map_meta &&",
          "3982:       !check_map_prealloc(map->inner_map_meta)) {",
          "3984:    return -EINVAL;",
          "3985:   }",
          "3986:  }",
          "",
          "[Removed Lines]",
          "3978:    verbose(\"perf_event programs can only use preallocated hash map\\n\");",
          "3983:    verbose(\"perf_event programs can only use preallocated inner hash map\\n\");",
          "",
          "[Added Lines]",
          "4007:    verbose(env, \"perf_event programs can only use preallocated hash map\\n\");",
          "4012:    verbose(env, \"perf_event programs can only use preallocated inner hash map\\n\");",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "4003:  for (i = 0; i < insn_cnt; i++, insn++) {",
          "4004:   if (BPF_CLASS(insn->code) == BPF_LDX &&",
          "4005:       (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {",
          "4007:    return -EINVAL;",
          "4008:   }",
          "4010:   if (BPF_CLASS(insn->code) == BPF_STX &&",
          "4011:       ((BPF_MODE(insn->code) != BPF_MEM &&",
          "4012:         BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {",
          "4014:    return -EINVAL;",
          "4015:   }",
          "",
          "[Removed Lines]",
          "4006:    verbose(\"BPF_LDX uses reserved fields\\n\");",
          "4013:    verbose(\"BPF_STX uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "4035:    verbose(env, \"BPF_LDX uses reserved fields\\n\");",
          "4042:    verbose(env, \"BPF_STX uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "4021:    if (i == insn_cnt - 1 || insn[1].code != 0 ||",
          "4022:        insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||",
          "4023:        insn[1].off != 0) {",
          "4025:     return -EINVAL;",
          "4026:    }",
          "",
          "[Removed Lines]",
          "4024:     verbose(\"invalid bpf_ld_imm64 insn\\n\");",
          "",
          "[Added Lines]",
          "4053:     verbose(env, \"invalid bpf_ld_imm64 insn\\n\");",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "4030:     goto next_insn;",
          "4032:    if (insn->src_reg != BPF_PSEUDO_MAP_FD) {",
          "4034:     return -EINVAL;",
          "4035:    }",
          "4037:    f = fdget(insn->imm);",
          "4038:    map = __bpf_map_get(f);",
          "4039:    if (IS_ERR(map)) {",
          "4041:      insn->imm);",
          "4042:     return PTR_ERR(map);",
          "4043:    }",
          "4046:    if (err) {",
          "4047:     fdput(f);",
          "4048:     return err;",
          "",
          "[Removed Lines]",
          "4033:     verbose(\"unrecognized bpf_ld_imm64 insn\\n\");",
          "4040:     verbose(\"fd %d is not pointing to valid bpf_map\\n\",",
          "4045:    err = check_map_prog_compatibility(map, env->prog);",
          "",
          "[Added Lines]",
          "4062:     verbose(env,",
          "4063:      \"unrecognized bpf_ld_imm64 insn\\n\");",
          "4070:     verbose(env, \"fd %d is not pointing to valid bpf_map\\n\",",
          "4075:    err = check_map_prog_compatibility(env, map, env->prog);",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "4164:   cnt = ops->gen_prologue(insn_buf, env->seen_direct_write,",
          "4165:      env->prog);",
          "4166:   if (cnt >= ARRAY_SIZE(insn_buf)) {",
          "4168:    return -EINVAL;",
          "4169:   } else if (cnt) {",
          "4170:    new_prog = bpf_patch_insn_data(env, 0, insn_buf, cnt);",
          "",
          "[Removed Lines]",
          "4167:    verbose(\"bpf verifier is misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4197:    verbose(env, \"bpf verifier is misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "4212:    u8 size_code;",
          "4214:    if (type == BPF_WRITE) {",
          "4216:     return -EINVAL;",
          "4217:    }",
          "",
          "[Removed Lines]",
          "4215:     verbose(\"bpf verifier narrow ctx access misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4245:     verbose(env, \"bpf verifier narrow ctx access misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "4231:            &target_size);",
          "4232:   if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf) ||",
          "4233:       (ctx_field_size && !target_size)) {",
          "4235:    return -EINVAL;",
          "4236:   }",
          "",
          "[Removed Lines]",
          "4234:    verbose(\"bpf verifier is misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4264:    verbose(env, \"bpf verifier is misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "4314:    cnt = map_ptr->ops->map_gen_lookup(map_ptr, insn_buf);",
          "4315:    if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {",
          "4317:     return -EINVAL;",
          "4318:    }",
          "",
          "[Removed Lines]",
          "4316:     verbose(\"bpf verifier is misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4346:     verbose(env, \"bpf verifier is misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "4359:   if (!fn->func) {",
          "4361:     func_id_name(insn->imm), insn->imm);",
          "4362:    return -EFAULT;",
          "4363:   }",
          "",
          "[Removed Lines]",
          "4360:    verbose(\"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "[Added Lines]",
          "4390:    verbose(env,",
          "4391:     \"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "4392: int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)",
          "4393: {",
          "4395:  struct bpf_verifier_env *env;",
          "4396:  int ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "4394:  struct bpf_verifer_log *log = &verifier_log;",
          "",
          "[Added Lines]",
          "4426:  struct bpf_verifer_log *log;",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "4401:  env = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);",
          "4402:  if (!env)",
          "4403:   return -ENOMEM;",
          "4405:  env->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *",
          "4406:          (*prog)->len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4435:  log = &env->log;",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "4419:   log->level = attr->log_level;",
          "4420:   log->ubuf = (char __user *) (unsigned long) attr->log_buf;",
          "4421:   log->len_total = attr->log_size;",
          "4424:   ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "4422:   log->len_used = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "4431:   log->kbuf = vmalloc(log->len_total);",
          "4432:   if (!log->kbuf)",
          "4433:    goto err_unlock;",
          "4436:  }",
          "4438:  env->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);",
          "",
          "[Removed Lines]",
          "4434:  } else {",
          "4435:   log->level = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "4544:  mutex_lock(&bpf_verifier_lock);",
          "4548:  env->strict_alignment = false;",
          "4549:  if (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))",
          "4550:   env->strict_alignment = true;",
          "",
          "[Removed Lines]",
          "4546:  verifier_log.level = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "de8f3a83b0a0fddb2cf56e7a718127e9619ea3da",
      "candidate_info": {
        "commit_hash": "de8f3a83b0a0fddb2cf56e7a718127e9619ea3da",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/de8f3a83b0a0fddb2cf56e7a718127e9619ea3da",
        "files": [
          "drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c",
          "drivers/net/ethernet/cavium/thunder/nicvf_main.c",
          "drivers/net/ethernet/intel/i40e/i40e_txrx.c",
          "drivers/net/ethernet/intel/ixgbe/ixgbe_main.c",
          "drivers/net/ethernet/mellanox/mlx4/en_rx.c",
          "drivers/net/ethernet/mellanox/mlx5/core/en_rx.c",
          "drivers/net/ethernet/netronome/nfp/nfp_net_common.c",
          "drivers/net/ethernet/qlogic/qede/qede_fp.c",
          "drivers/net/tun.c",
          "drivers/net/virtio_net.c",
          "include/linux/bpf.h",
          "include/linux/filter.h",
          "include/linux/skbuff.h",
          "include/uapi/linux/bpf.h",
          "kernel/bpf/verifier.c",
          "net/bpf/test_run.c",
          "net/core/dev.c",
          "net/core/filter.c",
          "net/core/skbuff.c"
        ],
        "message": "bpf: add meta pointer for direct access\n\nThis work enables generic transfer of metadata from XDP into skb. The\nbasic idea is that we can make use of the fact that the resulting skb\nmust be linear and already comes with a larger headroom for supporting\nbpf_xdp_adjust_head(), which mangles xdp->data. Here, we base our work\non a similar principle and introduce a small helper bpf_xdp_adjust_meta()\nfor adjusting a new pointer called xdp->data_meta. Thus, the packet has\na flexible and programmable room for meta data, followed by the actual\npacket data. struct xdp_buff is therefore laid out that we first point\nto data_hard_start, then data_meta directly prepended to data followed\nby data_end marking the end of packet. bpf_xdp_adjust_head() takes into\naccount whether we have meta data already prepended and if so, memmove()s\nthis along with the given offset provided there's enough room.\n\nxdp->data_meta is optional and programs are not required to use it. The\nrationale is that when we process the packet in XDP (e.g. as DoS filter),\nwe can push further meta data along with it for the XDP_PASS case, and\ngive the guarantee that a clsact ingress BPF program on the same device\ncan pick this up for further post-processing. Since we work with skb\nthere, we can also set skb->mark, skb->priority or other skb meta data\nout of BPF, thus having this scratch space generic and programmable\nallows for more flexibility than defining a direct 1:1 transfer of\npotentially new XDP members into skb (it's also more efficient as we\ndon't need to initialize/handle each of such new members). The facility\nalso works together with GRO aggregation. The scratch space at the head\nof the packet can be multiple of 4 byte up to 32 byte large. Drivers not\nyet supporting xdp->data_meta can simply be set up with xdp->data_meta\nas xdp->data + 1 as bpf_xdp_adjust_meta() will detect this and bail out,\nsuch that the subsequent match against xdp->data for later access is\nguaranteed to fail.\n\nThe verifier treats xdp->data_meta/xdp->data the same way as we treat\nxdp->data/xdp->data_end pointer comparisons. The requirement for doing\nthe compare against xdp->data is that it hasn't been modified from it's\noriginal address we got from ctx access. It may have a range marking\nalready from prior successful xdp->data/xdp->data_end pointer comparisons\nthough.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c||drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c",
          "drivers/net/ethernet/cavium/thunder/nicvf_main.c||drivers/net/ethernet/cavium/thunder/nicvf_main.c",
          "drivers/net/ethernet/intel/i40e/i40e_txrx.c||drivers/net/ethernet/intel/i40e/i40e_txrx.c",
          "drivers/net/ethernet/intel/ixgbe/ixgbe_main.c||drivers/net/ethernet/intel/ixgbe/ixgbe_main.c",
          "drivers/net/ethernet/mellanox/mlx4/en_rx.c||drivers/net/ethernet/mellanox/mlx4/en_rx.c",
          "drivers/net/ethernet/mellanox/mlx5/core/en_rx.c||drivers/net/ethernet/mellanox/mlx5/core/en_rx.c",
          "drivers/net/ethernet/netronome/nfp/nfp_net_common.c||drivers/net/ethernet/netronome/nfp/nfp_net_common.c",
          "drivers/net/ethernet/qlogic/qede/qede_fp.c||drivers/net/ethernet/qlogic/qede/qede_fp.c",
          "drivers/net/tun.c||drivers/net/tun.c",
          "drivers/net/virtio_net.c||drivers/net/virtio_net.c",
          "include/linux/bpf.h||include/linux/bpf.h",
          "include/linux/filter.h||include/linux/filter.h",
          "include/linux/skbuff.h||include/linux/skbuff.h",
          "include/uapi/linux/bpf.h||include/uapi/linux/bpf.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c",
          "net/bpf/test_run.c||net/bpf/test_run.c",
          "net/core/dev.c||net/core/dev.c",
          "net/core/filter.c||net/core/filter.c",
          "net/core/skbuff.c||net/core/skbuff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c||drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c": [
          "File: drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c -> drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:  xdp.data_hard_start = *data_ptr - offset;",
          "96:  xdp.data = *data_ptr;",
          "97:  xdp.data_end = *data_ptr + *len;",
          "98:  orig_data = xdp.data;",
          "99:  mapping = rx_buf->mapping - bp->rx_dma_offset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97:  xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/cavium/thunder/nicvf_main.c||drivers/net/ethernet/cavium/thunder/nicvf_main.c": [
          "File: drivers/net/ethernet/cavium/thunder/nicvf_main.c -> drivers/net/ethernet/cavium/thunder/nicvf_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "524:  xdp.data_hard_start = page_address(page);",
          "525:  xdp.data = (void *)cpu_addr;",
          "526:  xdp.data_end = xdp.data + len;",
          "527:  orig_data = xdp.data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "526:  xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/intel/i40e/i40e_txrx.c||drivers/net/ethernet/intel/i40e/i40e_txrx.c": [
          "File: drivers/net/ethernet/intel/i40e/i40e_txrx.c -> drivers/net/ethernet/intel/i40e/i40e_txrx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2107:   if (!skb) {",
          "2108:    xdp.data = page_address(rx_buffer->page) +",
          "2109:        rx_buffer->page_offset;",
          "2110:    xdp.data_hard_start = xdp.data -",
          "2111:            i40e_rx_offset(rx_ring);",
          "2112:    xdp.data_end = xdp.data + size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2110:    xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/intel/ixgbe/ixgbe_main.c||drivers/net/ethernet/intel/ixgbe/ixgbe_main.c": [
          "File: drivers/net/ethernet/intel/ixgbe/ixgbe_main.c -> drivers/net/ethernet/intel/ixgbe/ixgbe_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2326:   if (!skb) {",
          "2327:    xdp.data = page_address(rx_buffer->page) +",
          "2328:        rx_buffer->page_offset;",
          "2329:    xdp.data_hard_start = xdp.data -",
          "2330:            ixgbe_rx_offset(rx_ring);",
          "2331:    xdp.data_end = xdp.data + size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2329:    xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/mellanox/mlx4/en_rx.c||drivers/net/ethernet/mellanox/mlx4/en_rx.c": [
          "File: drivers/net/ethernet/mellanox/mlx4/en_rx.c -> drivers/net/ethernet/mellanox/mlx4/en_rx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "763:    xdp.data_hard_start = va - frags[0].page_offset;",
          "764:    xdp.data = va;",
          "765:    xdp.data_end = xdp.data + length;",
          "766:    orig_data = xdp.data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "765:    xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/mellanox/mlx5/core/en_rx.c||drivers/net/ethernet/mellanox/mlx5/core/en_rx.c": [
          "File: drivers/net/ethernet/mellanox/mlx5/core/en_rx.c -> drivers/net/ethernet/mellanox/mlx5/core/en_rx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "794:   return false;",
          "796:  xdp.data = va + *rx_headroom;",
          "797:  xdp.data_end = xdp.data + *len;",
          "798:  xdp.data_hard_start = va;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "797:  xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/netronome/nfp/nfp_net_common.c||drivers/net/ethernet/netronome/nfp/nfp_net_common.c": [
          "File: drivers/net/ethernet/netronome/nfp/nfp_net_common.c -> drivers/net/ethernet/netronome/nfp/nfp_net_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1584:  xdp.data_hard_start = hard_start;",
          "1585:  xdp.data = data + *off;",
          "1586:  xdp.data_end = data + *off + *len;",
          "1588:  orig_data = xdp.data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1586:  xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/qlogic/qede/qede_fp.c||drivers/net/ethernet/qlogic/qede/qede_fp.c": [
          "File: drivers/net/ethernet/qlogic/qede/qede_fp.c -> drivers/net/ethernet/qlogic/qede/qede_fp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1005:  xdp.data_hard_start = page_address(bd->data);",
          "1006:  xdp.data = xdp.data_hard_start + *data_offset;",
          "1007:  xdp.data_end = xdp.data + *len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1007:  xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/tun.c||drivers/net/tun.c": [
          "File: drivers/net/tun.c -> drivers/net/tun.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1469:   xdp.data_hard_start = buf;",
          "1470:   xdp.data = buf + pad;",
          "1471:   xdp.data_end = xdp.data + len;",
          "1472:   orig_data = xdp.data;",
          "1473:   act = bpf_prog_run_xdp(xdp_prog, &xdp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1471:   xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "drivers/net/virtio_net.c||drivers/net/virtio_net.c": [
          "File: drivers/net/virtio_net.c -> drivers/net/virtio_net.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "555:   xdp.data_hard_start = buf + VIRTNET_RX_PAD + vi->hdr_len;",
          "556:   xdp.data = xdp.data_hard_start + xdp_headroom;",
          "557:   xdp.data_end = xdp.data + len;",
          "558:   orig_data = xdp.data;",
          "559:   act = bpf_prog_run_xdp(xdp_prog, &xdp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "557:   xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "686:   data = page_address(xdp_page) + offset;",
          "687:   xdp.data_hard_start = data - VIRTIO_XDP_HEADROOM + vi->hdr_len;",
          "688:   xdp.data = data + vi->hdr_len;",
          "689:   xdp.data_end = xdp.data + (len - vi->hdr_len);",
          "690:   act = bpf_prog_run_xdp(xdp_prog, &xdp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "690:   xdp_set_data_meta_invalid(&xdp);",
          "",
          "---------------"
        ],
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h"
        ],
        "include/linux/filter.h||include/linux/filter.h": [
          "File: include/linux/filter.h -> include/linux/filter.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "488: struct bpf_skb_data_end {",
          "489:  struct qdisc_skb_cb qdisc_cb;",
          "490:  void *data_end;",
          "491: };",
          "493: struct xdp_buff {",
          "494:  void *data;",
          "495:  void *data_end;",
          "496:  void *data_hard_start;",
          "497: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "490:  void *data_meta;",
          "497:  void *data_meta;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "507:  struct bpf_skb_data_end *cb = (struct bpf_skb_data_end *)skb->cb;",
          "509:  BUILD_BUG_ON(sizeof(*cb) > FIELD_SIZEOF(struct sk_buff, cb));",
          "511: }",
          "513: static inline u8 *bpf_skb_cb(struct sk_buff *skb)",
          "",
          "[Removed Lines]",
          "510:  cb->data_end = skb->data + skb_headlen(skb);",
          "",
          "[Added Lines]",
          "512:  cb->data_meta = skb->data - skb_metadata_len(skb);",
          "513:  cb->data_end  = skb->data + skb_headlen(skb);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "728:       struct bpf_prog *prog);",
          "729: void xdp_do_flush_map(void);",
          "731: void bpf_warn_invalid_xdp_action(u32 act);",
          "734: struct sock *do_sk_redirect_map(void);",
          "",
          "[Removed Lines]",
          "732: void bpf_warn_invalid_xdp_redirect(u32 ifindex);",
          "",
          "[Added Lines]",
          "737: static __always_inline void",
          "738: xdp_set_data_meta_invalid(struct xdp_buff *xdp)",
          "739: {",
          "740:  xdp->data_meta = xdp->data + 1;",
          "741: }",
          "743: static __always_inline bool",
          "744: xdp_data_meta_unsupported(const struct xdp_buff *xdp)",
          "745: {",
          "746:  return unlikely(xdp->data_meta > xdp->data);",
          "747: }",
          "",
          "---------------"
        ],
        "include/linux/skbuff.h||include/linux/skbuff.h": [
          "File: include/linux/skbuff.h -> include/linux/skbuff.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "491: struct skb_shared_info {",
          "494:  __u8  tx_flags;",
          "495:  unsigned short gso_size;",
          "",
          "[Removed Lines]",
          "492:  unsigned short _unused;",
          "493:  unsigned char nr_frags;",
          "",
          "[Added Lines]",
          "492:  __u8  __unused;",
          "493:  __u8  meta_len;",
          "494:  __u8  nr_frags;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3400:  return 0;",
          "3401: }",
          "3403: struct sk_buff *skb_clone_sk(struct sk_buff *skb);",
          "3405: #ifdef CONFIG_NETWORK_PHY_TIMESTAMPING",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3404: static inline u8 skb_metadata_len(const struct sk_buff *skb)",
          "3405: {",
          "3406:  return skb_shinfo(skb)->meta_len;",
          "3407: }",
          "3409: static inline void *skb_metadata_end(const struct sk_buff *skb)",
          "3410: {",
          "3411:  return skb_mac_header(skb);",
          "3412: }",
          "3414: static inline bool __skb_metadata_differs(const struct sk_buff *skb_a,",
          "3415:        const struct sk_buff *skb_b,",
          "3416:        u8 meta_len)",
          "3417: {",
          "3418:  const void *a = skb_metadata_end(skb_a);",
          "3419:  const void *b = skb_metadata_end(skb_b);",
          "3421: #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64",
          "3422:  u64 diffs = 0;",
          "3424:  switch (meta_len) {",
          "3425: #define __it(x, op) (x -= sizeof(u##op))",
          "3426: #define __it_diff(a, b, op) (*(u##op *)__it(a, op)) ^ (*(u##op *)__it(b, op))",
          "3427:  case 32: diffs |= __it_diff(a, b, 64);",
          "3428:  case 24: diffs |= __it_diff(a, b, 64);",
          "3429:  case 16: diffs |= __it_diff(a, b, 64);",
          "3430:  case  8: diffs |= __it_diff(a, b, 64);",
          "3431:   break;",
          "3432:  case 28: diffs |= __it_diff(a, b, 64);",
          "3433:  case 20: diffs |= __it_diff(a, b, 64);",
          "3434:  case 12: diffs |= __it_diff(a, b, 64);",
          "3435:  case  4: diffs |= __it_diff(a, b, 32);",
          "3436:   break;",
          "3437:  }",
          "3438:  return diffs;",
          "3439: #else",
          "3440:  return memcmp(a - meta_len, b - meta_len, meta_len);",
          "3441: #endif",
          "3442: }",
          "3444: static inline bool skb_metadata_differs(const struct sk_buff *skb_a,",
          "3445:      const struct sk_buff *skb_b)",
          "3446: {",
          "3447:  u8 len_a = skb_metadata_len(skb_a);",
          "3448:  u8 len_b = skb_metadata_len(skb_b);",
          "3450:  if (!(len_a | len_b))",
          "3451:   return false;",
          "3453:  return len_a != len_b ?",
          "3454:         true : __skb_metadata_differs(skb_a, skb_b, len_a);",
          "3455: }",
          "3457: static inline void skb_metadata_set(struct sk_buff *skb, u8 meta_len)",
          "3458: {",
          "3459:  skb_shinfo(skb)->meta_len = meta_len;",
          "3460: }",
          "3462: static inline void skb_metadata_clear(struct sk_buff *skb)",
          "3463: {",
          "3464:  skb_metadata_set(skb, 0);",
          "3465: }",
          "",
          "---------------"
        ],
        "include/uapi/linux/bpf.h||include/uapi/linux/bpf.h": [
          "File: include/uapi/linux/bpf.h -> include/uapi/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "638:  FN(redirect_map),  \\",
          "639:  FN(sk_redirect_map),  \\",
          "640:  FN(sock_map_update),  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "647:  FN(xdp_adjust_meta),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "726: };",
          "728: struct bpf_tunnel_key {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "735:  __u32 data_meta;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "783: struct xdp_md {",
          "784:  __u32 data;",
          "785:  __u32 data_end;",
          "786: };",
          "788: enum sk_action {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "796:  __u32 data_meta;",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "177:  va_end(args);",
          "178: }",
          "181: static const char * const reg_type_str[] = {",
          "182:  [NOT_INIT]  = \"?\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "180: static bool type_is_pkt_pointer(enum bpf_reg_type type)",
          "181: {",
          "182:  return type == PTR_TO_PACKET ||",
          "183:         type == PTR_TO_PACKET_META;",
          "184: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "187:  [PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",",
          "188:  [PTR_TO_STACK]  = \"fp\",",
          "189:  [PTR_TO_PACKET]  = \"pkt\",",
          "190:  [PTR_TO_PACKET_END] = \"pkt_end\",",
          "191: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "196:  [PTR_TO_PACKET_META] = \"pkt_meta\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226:    verbose(\"(id=%d\", reg->id);",
          "227:    if (t != SCALAR_VALUE)",
          "228:     verbose(\",off=%d\", reg->off);",
          "230:     verbose(\",r=%d\", reg->range);",
          "231:    else if (t == CONST_PTR_TO_MAP ||",
          "232:      t == PTR_TO_MAP_VALUE ||",
          "",
          "[Removed Lines]",
          "229:    if (t == PTR_TO_PACKET)",
          "",
          "[Added Lines]",
          "236:    if (type_is_pkt_pointer(t))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "519:  __mark_reg_known_zero(regs + regno);",
          "520: }",
          "523: static void __update_reg_bounds(struct bpf_reg_state *reg)",
          "524: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "529: static bool reg_is_pkt_pointer(const struct bpf_reg_state *reg)",
          "530: {",
          "531:  return type_is_pkt_pointer(reg->type);",
          "532: }",
          "534: static bool reg_is_pkt_pointer_any(const struct bpf_reg_state *reg)",
          "535: {",
          "536:  return reg_is_pkt_pointer(reg) ||",
          "537:         reg->type == PTR_TO_PACKET_END;",
          "538: }",
          "541: static bool reg_is_init_pkt_pointer(const struct bpf_reg_state *reg,",
          "542:         enum bpf_reg_type which)",
          "543: {",
          "548:  return reg->type == which &&",
          "549:         reg->id == 0 &&",
          "550:         reg->off == 0 &&",
          "551:         tnum_equals_const(reg->var_off, 0);",
          "552: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "702:  case PTR_TO_STACK:",
          "703:  case PTR_TO_CTX:",
          "704:  case PTR_TO_PACKET:",
          "705:  case PTR_TO_PACKET_END:",
          "706:  case CONST_PTR_TO_MAP:",
          "707:   return true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "737:  case PTR_TO_PACKET_META:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1048:  switch (reg->type) {",
          "1049:  case PTR_TO_PACKET:",
          "1051:   return check_pkt_ptr_alignment(reg, off, size, strict);",
          "1052:  case PTR_TO_MAP_VALUE:",
          "1053:   pointer_desc = \"value \";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1083:  case PTR_TO_PACKET_META:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1170:   } else {",
          "1171:    err = check_stack_read(state, off, size, value_regno);",
          "1172:   }",
          "1174:   if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {",
          "1175:    verbose(\"cannot write into packet\\n\");",
          "1176:    return -EACCES;",
          "",
          "[Removed Lines]",
          "1173:  } else if (reg->type == PTR_TO_PACKET) {",
          "",
          "[Added Lines]",
          "1209:  } else if (reg_is_pkt_pointer(reg)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1311:  switch (reg->type) {",
          "1312:  case PTR_TO_PACKET:",
          "1313:   return check_packet_access(env, regno, reg->off, access_size);",
          "1314:  case PTR_TO_MAP_VALUE:",
          "1315:   return check_map_access(env, regno, reg->off, access_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1349:  case PTR_TO_PACKET_META:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1342:   return 0;",
          "1343:  }",
          "1346:      !may_access_direct_pkt_data(env, meta, BPF_READ)) {",
          "1347:   verbose(\"helper access to the packet is not allowed\\n\");",
          "1348:   return -EACCES;",
          "",
          "[Removed Lines]",
          "1345:  if (type == PTR_TO_PACKET &&",
          "",
          "[Added Lines]",
          "1382:  if (type_is_pkt_pointer(type) &&",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1351:  if (arg_type == ARG_PTR_TO_MAP_KEY ||",
          "1352:      arg_type == ARG_PTR_TO_MAP_VALUE) {",
          "1353:   expected_type = PTR_TO_STACK;",
          "1355:    goto err_type;",
          "1356:  } else if (arg_type == ARG_CONST_SIZE ||",
          "1357:      arg_type == ARG_CONST_SIZE_OR_ZERO) {",
          "",
          "[Removed Lines]",
          "1354:   if (type != PTR_TO_PACKET && type != expected_type)",
          "",
          "[Added Lines]",
          "1391:   if (!type_is_pkt_pointer(type) &&",
          "1392:       type != expected_type)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1376:   if (register_is_null(*reg))",
          "1379:     type != expected_type)",
          "1380:    goto err_type;",
          "1381:   meta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;",
          "",
          "[Removed Lines]",
          "1378:   else if (type != PTR_TO_PACKET && type != PTR_TO_MAP_VALUE &&",
          "",
          "[Added Lines]",
          "1416:   else if (!type_is_pkt_pointer(type) &&",
          "1417:     type != PTR_TO_MAP_VALUE &&",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1401:    verbose(\"invalid map_ptr to access map->key\\n\");",
          "1402:    return -EACCES;",
          "1403:   }",
          "1405:    err = check_packet_access(env, regno, reg->off,",
          "1406:         meta->map_ptr->key_size);",
          "1407:   else",
          "",
          "[Removed Lines]",
          "1404:   if (type == PTR_TO_PACKET)",
          "",
          "[Added Lines]",
          "1443:   if (type_is_pkt_pointer(type))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1417:    verbose(\"invalid map_ptr to access map->value\\n\");",
          "1418:    return -EACCES;",
          "1419:   }",
          "1421:    err = check_packet_access(env, regno, reg->off,",
          "1422:         meta->map_ptr->value_size);",
          "1423:   else",
          "",
          "[Removed Lines]",
          "1420:   if (type == PTR_TO_PACKET)",
          "",
          "[Added Lines]",
          "1459:   if (type_is_pkt_pointer(type))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1600:  int i;",
          "1602:  for (i = 0; i < MAX_BPF_REG; i++)",
          "1605:    mark_reg_unknown(regs, i);",
          "1607:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "1608:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "1609:    continue;",
          "1610:   reg = &state->spilled_regs[i / BPF_REG_SIZE];",
          "1615:  }",
          "1616: }",
          "",
          "[Removed Lines]",
          "1603:   if (regs[i].type == PTR_TO_PACKET ||",
          "1604:       regs[i].type == PTR_TO_PACKET_END)",
          "1611:   if (reg->type != PTR_TO_PACKET &&",
          "1612:       reg->type != PTR_TO_PACKET_END)",
          "1613:    continue;",
          "1614:   __mark_reg_unknown(reg);",
          "",
          "[Added Lines]",
          "1642:   if (reg_is_pkt_pointer_any(&regs[i]))",
          "1649:   if (reg_is_pkt_pointer_any(reg))",
          "1650:    __mark_reg_unknown(reg);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1871:   }",
          "1872:   dst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);",
          "1873:   dst_reg->off = ptr_reg->off;",
          "1875:    dst_reg->id = ++env->id_gen;",
          "1877:    dst_reg->range = 0;",
          "",
          "[Removed Lines]",
          "1874:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "",
          "[Added Lines]",
          "1910:   if (reg_is_pkt_pointer(ptr_reg)) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1931:   }",
          "1932:   dst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);",
          "1933:   dst_reg->off = ptr_reg->off;",
          "1935:    dst_reg->id = ++env->id_gen;",
          "1937:    if (smin_val < 0)",
          "",
          "[Removed Lines]",
          "1934:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "",
          "[Added Lines]",
          "1970:   if (reg_is_pkt_pointer(ptr_reg)) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2421: }",
          "2423: static void find_good_pkt_pointers(struct bpf_verifier_state *state,",
          "2425: {",
          "2426:  struct bpf_reg_state *regs = state->regs, *reg;",
          "2427:  int i;",
          "",
          "[Removed Lines]",
          "2424:        struct bpf_reg_state *dst_reg)",
          "",
          "[Added Lines]",
          "2460:        struct bpf_reg_state *dst_reg,",
          "2461:        enum bpf_reg_type type)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2485:  for (i = 0; i < MAX_BPF_REG; i++)",
          "2488:    regs[i].range = max_t(u16, regs[i].range, dst_reg->off);",
          "",
          "[Removed Lines]",
          "2486:   if (regs[i].type == PTR_TO_PACKET && regs[i].id == dst_reg->id)",
          "",
          "[Added Lines]",
          "2523:   if (regs[i].type == type && regs[i].id == dst_reg->id)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2491:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "2492:    continue;",
          "2493:   reg = &state->spilled_regs[i / BPF_REG_SIZE];",
          "2495:    reg->range = max_t(u16, reg->range, dst_reg->off);",
          "2496:  }",
          "2497: }",
          "",
          "[Removed Lines]",
          "2494:   if (reg->type == PTR_TO_PACKET && reg->id == dst_reg->id)",
          "",
          "[Added Lines]",
          "2531:   if (reg->type == type && reg->id == dst_reg->id)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2856:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGT &&",
          "2857:      dst_reg->type == PTR_TO_PACKET &&",
          "2858:      regs[insn->src_reg].type == PTR_TO_PACKET_END) {",
          "2860:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JLT &&",
          "2861:      dst_reg->type == PTR_TO_PACKET &&",
          "2862:      regs[insn->src_reg].type == PTR_TO_PACKET_END) {",
          "2864:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGE &&",
          "2865:      dst_reg->type == PTR_TO_PACKET_END &&",
          "2866:      regs[insn->src_reg].type == PTR_TO_PACKET) {",
          "2868:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JLE &&",
          "2869:      dst_reg->type == PTR_TO_PACKET_END &&",
          "2870:      regs[insn->src_reg].type == PTR_TO_PACKET) {",
          "2872:  } else if (is_pointer_value(env, insn->dst_reg)) {",
          "2873:   verbose(\"R%d pointer comparison prohibited\\n\", insn->dst_reg);",
          "2874:   return -EACCES;",
          "",
          "[Removed Lines]",
          "2859:   find_good_pkt_pointers(this_branch, dst_reg);",
          "2863:   find_good_pkt_pointers(other_branch, dst_reg);",
          "2867:   find_good_pkt_pointers(other_branch, &regs[insn->src_reg]);",
          "2871:   find_good_pkt_pointers(this_branch, &regs[insn->src_reg]);",
          "",
          "[Added Lines]",
          "2896:   find_good_pkt_pointers(this_branch, dst_reg, PTR_TO_PACKET);",
          "2900:   find_good_pkt_pointers(other_branch, dst_reg, PTR_TO_PACKET);",
          "2904:   find_good_pkt_pointers(other_branch, &regs[insn->src_reg],",
          "2905:            PTR_TO_PACKET);",
          "2909:   find_good_pkt_pointers(this_branch, &regs[insn->src_reg],",
          "2910:            PTR_TO_PACKET);",
          "2911:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGT &&",
          "2912:      dst_reg->type == PTR_TO_PACKET_META &&",
          "2913:      reg_is_init_pkt_pointer(&regs[insn->src_reg], PTR_TO_PACKET)) {",
          "2914:   find_good_pkt_pointers(this_branch, dst_reg, PTR_TO_PACKET_META);",
          "2915:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JLT &&",
          "2916:      dst_reg->type == PTR_TO_PACKET_META &&",
          "2917:      reg_is_init_pkt_pointer(&regs[insn->src_reg], PTR_TO_PACKET)) {",
          "2918:   find_good_pkt_pointers(other_branch, dst_reg, PTR_TO_PACKET_META);",
          "2919:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGE &&",
          "2920:      reg_is_init_pkt_pointer(dst_reg, PTR_TO_PACKET) &&",
          "2921:      regs[insn->src_reg].type == PTR_TO_PACKET_META) {",
          "2922:   find_good_pkt_pointers(other_branch, &regs[insn->src_reg],",
          "2923:            PTR_TO_PACKET_META);",
          "2924:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JLE &&",
          "2925:      reg_is_init_pkt_pointer(dst_reg, PTR_TO_PACKET) &&",
          "2926:      regs[insn->src_reg].type == PTR_TO_PACKET_META) {",
          "2927:   find_good_pkt_pointers(this_branch, &regs[insn->src_reg],",
          "2928:            PTR_TO_PACKET_META);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3298:    return false;",
          "3300:   return check_ids(rold->id, rcur->id, idmap);",
          "3301:  case PTR_TO_PACKET:",
          "3303:    return false;",
          "",
          "[Removed Lines]",
          "3302:   if (rcur->type != PTR_TO_PACKET)",
          "",
          "[Added Lines]",
          "3358:  case PTR_TO_PACKET_META:",
          "3360:   if (rcur->type != rold->type)",
          "",
          "---------------"
        ],
        "net/bpf/test_run.c||net/bpf/test_run.c": [
          "File: net/bpf/test_run.c -> net/bpf/test_run.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "163:  xdp.data_hard_start = data;",
          "164:  xdp.data = data + XDP_PACKET_HEADROOM + NET_IP_ALIGN;",
          "165:  xdp.data_end = xdp.data + size;",
          "167:  retval = bpf_test_run(prog, &xdp, repeat, &duration);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165:  xdp.data_meta = xdp.data;",
          "",
          "---------------"
        ],
        "net/core/dev.c||net/core/dev.c": [
          "File: net/core/dev.c -> net/core/dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3864: static u32 netif_receive_generic_xdp(struct sk_buff *skb,",
          "3865:          struct bpf_prog *xdp_prog)",
          "3866: {",
          "3867:  struct xdp_buff xdp;",
          "3869:  void *orig_data;",
          "3870:  int hlen, off;",
          "3871:  u32 mac_len;",
          "",
          "[Removed Lines]",
          "3868:  u32 act = XDP_DROP;",
          "",
          "[Added Lines]",
          "3867:  u32 metalen, act = XDP_DROP;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3876:  if (skb_cloned(skb))",
          "3877:   return XDP_PASS;",
          "",
          "[Removed Lines]",
          "3879:  if (skb_linearize(skb))",
          "3880:   goto do_drop;",
          "",
          "[Added Lines]",
          "3883:  if (skb_is_nonlinear(skb) ||",
          "3884:      skb_headroom(skb) < XDP_PACKET_HEADROOM) {",
          "3885:   int hroom = XDP_PACKET_HEADROOM - skb_headroom(skb);",
          "3886:   int troom = skb->tail + skb->data_len - skb->end;",
          "3891:   if (pskb_expand_head(skb,",
          "3892:          hroom > 0 ? ALIGN(hroom, NET_SKB_PAD) : 0,",
          "3893:          troom > 0 ? troom + 128 : 0, GFP_ATOMIC))",
          "3894:    goto do_drop;",
          "3895:   if (troom > 0 && __skb_linearize(skb))",
          "3896:    goto do_drop;",
          "3897:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3885:  mac_len = skb->data - skb_mac_header(skb);",
          "3886:  hlen = skb_headlen(skb) + mac_len;",
          "3887:  xdp.data = skb->data - mac_len;",
          "3888:  xdp.data_end = xdp.data + hlen;",
          "3889:  xdp.data_hard_start = skb->data - skb_headroom(skb);",
          "3890:  orig_data = xdp.data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3905:  xdp.data_meta = xdp.data;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3902:  case XDP_REDIRECT:",
          "3903:  case XDP_TX:",
          "3904:   __skb_push(skb, mac_len);",
          "3906:  case XDP_PASS:",
          "3907:   break;",
          "3909:  default:",
          "3910:   bpf_warn_invalid_xdp_action(act);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3923:   break;",
          "3925:   metalen = xdp.data - xdp.data_meta;",
          "3926:   if (metalen)",
          "3927:    skb_metadata_set(skb, metalen);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4695:   diffs = (unsigned long)p->dev ^ (unsigned long)skb->dev;",
          "4696:   diffs |= p->vlan_tci ^ skb->vlan_tci;",
          "4697:   diffs |= skb_metadata_dst_cmp(p, skb);",
          "4698:   if (maclen == ETH_HLEN)",
          "4699:    diffs |= compare_ether_header(skb_mac_header(p),",
          "4700:             skb_mac_header(skb));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4718:   diffs |= skb_metadata_differs(p, skb);",
          "",
          "---------------"
        ],
        "net/core/filter.c||net/core/filter.c": [
          "File: net/core/filter.c -> net/core/filter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2447:  .arg3_type = ARG_ANYTHING,",
          "2448: };",
          "2450: BPF_CALL_2(bpf_xdp_adjust_head, struct xdp_buff *, xdp, int, offset)",
          "2451: {",
          "2452:  void *data = xdp->data + offset;",
          "2455:        data > xdp->data_end - ETH_HLEN))",
          "2456:   return -EINVAL;",
          "2458:  xdp->data = data;",
          "2460:  return 0;",
          "",
          "[Removed Lines]",
          "2454:  if (unlikely(data < xdp->data_hard_start ||",
          "",
          "[Added Lines]",
          "2450: static unsigned long xdp_get_metalen(const struct xdp_buff *xdp)",
          "2451: {",
          "2452:  return xdp_data_meta_unsupported(xdp) ? 0 :",
          "2453:         xdp->data - xdp->data_meta;",
          "2454: }",
          "2458:  unsigned long metalen = xdp_get_metalen(xdp);",
          "2459:  void *data_start = xdp->data_hard_start + metalen;",
          "2462:  if (unlikely(data < data_start ||",
          "2466:  if (metalen)",
          "2467:   memmove(xdp->data_meta + offset,",
          "2468:    xdp->data_meta, metalen);",
          "2469:  xdp->data_meta += offset;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2468:  .arg2_type = ARG_ANYTHING,",
          "2469: };",
          "2471: static int __bpf_tx_xdp(struct net_device *dev,",
          "2472:    struct bpf_map *map,",
          "2473:    struct xdp_buff *xdp,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2483: BPF_CALL_2(bpf_xdp_adjust_meta, struct xdp_buff *, xdp, int, offset)",
          "2484: {",
          "2485:  void *meta = xdp->data_meta + offset;",
          "2486:  unsigned long metalen = xdp->data - meta;",
          "2488:  if (xdp_data_meta_unsupported(xdp))",
          "2489:   return -ENOTSUPP;",
          "2490:  if (unlikely(meta < xdp->data_hard_start ||",
          "2491:        meta > xdp->data))",
          "2492:   return -EINVAL;",
          "2493:  if (unlikely((metalen & (sizeof(__u32) - 1)) ||",
          "2494:        (metalen > 32)))",
          "2495:   return -EACCES;",
          "2497:  xdp->data_meta = meta;",
          "2499:  return 0;",
          "2500: }",
          "2502: static const struct bpf_func_proto bpf_xdp_adjust_meta_proto = {",
          "2503:  .func  = bpf_xdp_adjust_meta,",
          "2504:  .gpl_only = false,",
          "2505:  .ret_type = RET_INTEGER,",
          "2506:  .arg1_type = ARG_PTR_TO_CTX,",
          "2507:  .arg2_type = ARG_ANYTHING,",
          "2508: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2692:      func == bpf_clone_redirect ||",
          "2693:      func == bpf_l3_csum_replace ||",
          "2694:      func == bpf_l4_csum_replace ||",
          "2696:   return true;",
          "2698:  return false;",
          "",
          "[Removed Lines]",
          "2695:      func == bpf_xdp_adjust_head)",
          "",
          "[Added Lines]",
          "2734:      func == bpf_xdp_adjust_head ||",
          "2735:      func == bpf_xdp_adjust_meta)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3288:   return &bpf_get_smp_processor_id_proto;",
          "3289:  case BPF_FUNC_xdp_adjust_head:",
          "3290:   return &bpf_xdp_adjust_head_proto;",
          "3291:  case BPF_FUNC_redirect:",
          "3292:   return &bpf_xdp_redirect_proto;",
          "3293:  case BPF_FUNC_redirect_map:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3331:  case BPF_FUNC_xdp_adjust_meta:",
          "3332:   return &bpf_xdp_adjust_meta_proto;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3418:  case bpf_ctx_range_till(struct __sk_buff, remote_ip4, remote_ip4):",
          "3419:  case bpf_ctx_range_till(struct __sk_buff, local_ip4, local_ip4):",
          "3420:  case bpf_ctx_range(struct __sk_buff, data):",
          "3421:  case bpf_ctx_range(struct __sk_buff, data_end):",
          "3422:   if (size != size_default)",
          "3423:    return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3463:  case bpf_ctx_range(struct __sk_buff, data_meta):",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3444:  switch (off) {",
          "3445:  case bpf_ctx_range(struct __sk_buff, tc_classid):",
          "3446:  case bpf_ctx_range(struct __sk_buff, data):",
          "3447:  case bpf_ctx_range(struct __sk_buff, data_end):",
          "3448:  case bpf_ctx_range_till(struct __sk_buff, family, local_port):",
          "3449:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3490:  case bpf_ctx_range(struct __sk_buff, data_meta):",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3468:  switch (off) {",
          "3469:  case bpf_ctx_range(struct __sk_buff, tc_classid):",
          "3470:  case bpf_ctx_range_till(struct __sk_buff, family, local_port):",
          "3471:   return false;",
          "3472:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3515:  case bpf_ctx_range(struct __sk_buff, data_meta):",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3586:  case bpf_ctx_range(struct __sk_buff, data):",
          "3587:   info->reg_type = PTR_TO_PACKET;",
          "3588:   break;",
          "3589:  case bpf_ctx_range(struct __sk_buff, data_end):",
          "3590:   info->reg_type = PTR_TO_PACKET_END;",
          "3591:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3634:  case bpf_ctx_range(struct __sk_buff, data_meta):",
          "3635:   info->reg_type = PTR_TO_PACKET_META;",
          "3636:   break;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3619:  case offsetof(struct xdp_md, data):",
          "3620:   info->reg_type = PTR_TO_PACKET;",
          "3621:   break;",
          "3622:  case offsetof(struct xdp_md, data_end):",
          "3623:   info->reg_type = PTR_TO_PACKET_END;",
          "3624:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3670:  case offsetof(struct xdp_md, data_meta):",
          "3671:   info->reg_type = PTR_TO_PACKET_META;",
          "3672:   break;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3677:        enum bpf_access_type type,",
          "3678:        struct bpf_insn_access_aux *info)",
          "3679: {",
          "3680:  if (type == BPF_WRITE) {",
          "3681:   switch (off) {",
          "3682:   case bpf_ctx_range(struct __sk_buff, mark):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3731:  switch (off) {",
          "3732:  case bpf_ctx_range(struct __sk_buff, tc_classid):",
          "3733:  case bpf_ctx_range(struct __sk_buff, data_meta):",
          "3734:   return false;",
          "3735:  }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3689:  }",
          "3691:  switch (off) {",
          "3694:  case bpf_ctx_range(struct __sk_buff, data):",
          "3695:   info->reg_type = PTR_TO_PACKET;",
          "3696:   break;",
          "",
          "[Removed Lines]",
          "3692:  case bpf_ctx_range(struct __sk_buff, tc_classid):",
          "3693:   return false;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3847:           offsetof(struct sk_buff, data));",
          "3848:   break;",
          "3850:  case offsetof(struct __sk_buff, data_end):",
          "3851:   off  = si->off;",
          "3852:   off -= offsetof(struct __sk_buff, data_end);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3905:  case offsetof(struct __sk_buff, data_meta):",
          "3906:   off  = si->off;",
          "3907:   off -= offsetof(struct __sk_buff, data_meta);",
          "3908:   off += offsetof(struct sk_buff, cb);",
          "3909:   off += offsetof(struct bpf_skb_data_end, data_meta);",
          "3911:           si->src_reg, off);",
          "3912:   break;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4095:           si->dst_reg, si->src_reg,",
          "4096:           offsetof(struct xdp_buff, data));",
          "4097:   break;",
          "4098:  case offsetof(struct xdp_md, data_end):",
          "4100:           si->dst_reg, si->src_reg,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4162:  case offsetof(struct xdp_md, data_meta):",
          "4164:           si->dst_reg, si->src_reg,",
          "4165:           offsetof(struct xdp_buff, data_meta));",
          "4166:   break;",
          "",
          "---------------"
        ],
        "net/core/skbuff.c||net/core/skbuff.c": [
          "File: net/core/skbuff.c -> net/core/skbuff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1509:  skb->nohdr    = 0;",
          "1510:  atomic_set(&skb_shinfo(skb)->dataref, 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1512:  skb_metadata_clear(skb);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fad73a1a35ea61f13607a391aca669caad8c04ca",
      "candidate_info": {
        "commit_hash": "fad73a1a35ea61f13607a391aca669caad8c04ca",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fad73a1a35ea61f13607a391aca669caad8c04ca",
        "files": [
          "kernel/bpf/arraymap.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: Fix and simplifications on inline map lookup\n\nFix in verifier:\nFor the same bpf_map_lookup_elem() instruction (i.e. \"call 1\"),\na broken case is \"a different type of map could be used for the\nsame lookup instruction\". For example, an array in one case and a\nhashmap in another.  We have to resort to the old dynamic call behavior\nin this case.  The fix is to check for collision on insn_aux->map_ptr.\nIf there is collision, don't inline the map lookup.\n\nPlease see the \"do_reg_lookup()\" in test_map_in_map_kern.c in the later\npatch for how-to trigger the above case.\n\nSimplifications on array_map_gen_lookup():\n1. Calculate elem_size from map->value_size.  It removes the\n   need for 'struct bpf_array' which makes the later map-in-map\n   implementation easier.\n2. Remove the 'elem_size == 1' test\n\nFixes: 81ed18ab3098 (\"bpf: add helper inlining infra and optimize map_array lookup\")\nSigned-off-by: Martin KaFai Lau <kafai@fb.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "kernel/bpf/arraymap.c||kernel/bpf/arraymap.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/arraymap.c||kernel/bpf/arraymap.c": [
          "File: kernel/bpf/arraymap.c -> kernel/bpf/arraymap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118: static u32 array_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)",
          "119: {",
          "121:  struct bpf_insn *insn = insn_buf;",
          "123:  const int ret = BPF_REG_0;",
          "124:  const int map_ptr = BPF_REG_1;",
          "125:  const int index = BPF_REG_2;",
          "135:  } else {",
          "",
          "[Removed Lines]",
          "120:  struct bpf_array *array = container_of(map, struct bpf_array, map);",
          "122:  u32 elem_size = array->elem_size;",
          "130:          elem_size == 1 ? 2 : 3);",
          "131:  if (elem_size == 1) {",
          "133:  } else if (is_power_of_2(elem_size)) {",
          "",
          "[Added Lines]",
          "121:  u32 elem_size = round_up(map->value_size, 8);",
          "130:  if (is_power_of_2(elem_size)) {",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "143: #define BPF_COMPLEXITY_LIMIT_INSNS 65536",
          "144: #define BPF_COMPLEXITY_LIMIT_STACK 1024",
          "146: struct bpf_call_arg_meta {",
          "147:  struct bpf_map *map_ptr;",
          "148:  bool raw_mode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146: #define BPF_MAP_PTR_POISON ((void *)0xeB9F + POISON_POINTER_DELTA)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1357:  } else if (fn->ret_type == RET_VOID) {",
          "1358:   regs[BPF_REG_0].type = NOT_INIT;",
          "1359:  } else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {",
          "1360:   regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;",
          "1361:   regs[BPF_REG_0].max_value = regs[BPF_REG_0].min_value = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1362:   struct bpf_insn_aux_data *insn_aux;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1369:   }",
          "1370:   regs[BPF_REG_0].map_ptr = meta.map_ptr;",
          "1371:   regs[BPF_REG_0].id = ++env->id_gen;",
          "1373:  } else {",
          "1374:   verbose(\"unknown return type %d of func %s#%d\\n\",",
          "1375:    fn->ret_type, func_id_name(func_id), func_id);",
          "",
          "[Removed Lines]",
          "1372:   env->insn_aux_data[insn_idx].map_ptr = meta.map_ptr;",
          "",
          "[Added Lines]",
          "1376:   insn_aux = &env->insn_aux_data[insn_idx];",
          "1377:   if (!insn_aux->map_ptr)",
          "1378:    insn_aux->map_ptr = meta.map_ptr;",
          "1379:   else if (insn_aux->map_ptr != meta.map_ptr)",
          "1380:    insn_aux->map_ptr = BPF_MAP_PTR_POISON;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3308:   if (ebpf_jit_enabled() && insn->imm == BPF_FUNC_map_lookup_elem) {",
          "3309:    map_ptr = env->insn_aux_data[i + delta].map_ptr;",
          "3311:     goto patch_call_imm;",
          "3313:    cnt = map_ptr->ops->map_gen_lookup(map_ptr, insn_buf);",
          "",
          "[Removed Lines]",
          "3310:    if (!map_ptr->ops->map_gen_lookup)",
          "",
          "[Added Lines]",
          "3318:    if (map_ptr == BPF_MAP_PTR_POISON ||",
          "3319:        !map_ptr->ops->map_gen_lookup)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f1174f77b50c94eecaa658fdc56fa69b421de4b8",
      "candidate_info": {
        "commit_hash": "f1174f77b50c94eecaa658fdc56fa69b421de4b8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f1174f77b50c94eecaa658fdc56fa69b421de4b8",
        "files": [
          "drivers/net/ethernet/netronome/nfp/bpf/verifier.c",
          "include/linux/bpf.h",
          "include/linux/bpf_verifier.h",
          "include/linux/tnum.h",
          "kernel/bpf/Makefile",
          "kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf/verifier: rework value tracking\n\nUnifies adjusted and unadjusted register value types (e.g. FRAME_POINTER is\n now just a PTR_TO_STACK with zero offset).\nTracks value alignment by means of tracking known & unknown bits.  This\n also replaces the 'reg->imm' (leading zero bits) calculations for (what\n were) UNKNOWN_VALUEs.\nIf pointer leaks are allowed, and adjust_ptr_min_max_vals returns -EACCES,\n treat the pointer as an unknown scalar and try again, because we might be\n able to conclude something about the result (e.g. pointer & 0x40 is either\n 0 or 0x40).\nVerifier hooks in the netronome/nfp driver were changed to match the new\n data structures.\n\nSigned-off-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/netronome/nfp/bpf/verifier.c||drivers/net/ethernet/netronome/nfp/bpf/verifier.c",
          "include/linux/bpf.h||include/linux/bpf.h",
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "include/linux/tnum.h||include/linux/tnum.h",
          "kernel/bpf/tnum.c||kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/netronome/nfp/bpf/verifier.c||drivers/net/ethernet/netronome/nfp/bpf/verifier.c": [
          "File: drivers/net/ethernet/netronome/nfp/bpf/verifier.c -> drivers/net/ethernet/netronome/nfp/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:      const struct bpf_verifier_env *env)",
          "80: {",
          "81:  const struct bpf_reg_state *reg0 = &env->cur_state.regs[0];",
          "83:  if (nfp_prog->act == NN_ACT_XDP)",
          "84:   return 0;",
          "89:   return -EINVAL;",
          "90:  }",
          "94:   pr_info(\"unsupported exit state: %d, imm: %llx\\n\",",
          "96:   return -EINVAL;",
          "97:  }",
          "102:   pr_info(\"unsupported exit state: %d, imm: %llx\\n\",",
          "104:   return -EINVAL;",
          "105:  }",
          "",
          "[Removed Lines]",
          "86:  if (reg0->type != CONST_IMM) {",
          "87:   pr_info(\"unsupported exit state: %d, imm: %llx\\n\",",
          "88:    reg0->type, reg0->imm);",
          "92:  if (nfp_prog->act != NN_ACT_DIRECT &&",
          "93:      reg0->imm != 0 && (reg0->imm & ~0U) != ~0U) {",
          "95:    reg0->type, reg0->imm);",
          "99:  if (nfp_prog->act == NN_ACT_DIRECT && reg0->imm <= TC_ACT_REDIRECT &&",
          "100:      reg0->imm != TC_ACT_SHOT && reg0->imm != TC_ACT_STOLEN &&",
          "101:      reg0->imm != TC_ACT_QUEUED) {",
          "103:    reg0->type, reg0->imm);",
          "",
          "[Added Lines]",
          "82:  u64 imm;",
          "87:  if (!(reg0->type == SCALAR_VALUE && tnum_is_const(reg0->var_off))) {",
          "88:   char tn_buf[48];",
          "90:   tnum_strn(tn_buf, sizeof(tn_buf), reg0->var_off);",
          "91:   pr_info(\"unsupported exit state: %d, var_off: %s\\n\",",
          "92:    reg0->type, tn_buf);",
          "96:  imm = reg0->var_off.value;",
          "97:  if (nfp_prog->act != NN_ACT_DIRECT && imm != 0 && (imm & ~0U) != ~0U) {",
          "99:    reg0->type, imm);",
          "103:  if (nfp_prog->act == NN_ACT_DIRECT && imm <= TC_ACT_REDIRECT &&",
          "104:      imm != TC_ACT_SHOT && imm != TC_ACT_STOLEN &&",
          "105:      imm != TC_ACT_QUEUED) {",
          "107:    reg0->type, imm);",
          "",
          "---------------"
        ],
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "117: };",
          "120: enum bpf_reg_type {",
          "149: };",
          "151: struct bpf_prog;",
          "",
          "[Removed Lines]",
          "140:  PTR_TO_PACKET,",
          "148:  PTR_TO_MAP_VALUE_ADJ,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include <linux/tnum.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19: struct bpf_reg_state {",
          "20:  enum bpf_reg_type type;",
          "21:  union {",
          "34:   struct bpf_map *map_ptr;",
          "35:  };",
          "36:  u32 id;",
          "41:  s64 min_value;",
          "42:  u64 max_value;",
          "46:  bool value_from_signed;",
          "47: };",
          "",
          "[Removed Lines]",
          "23:   s64 imm;",
          "26:   struct {",
          "27:    u16 off;",
          "28:    u16 range;",
          "29:   };",
          "43:  u32 min_align;",
          "44:  u32 aux_off;",
          "45:  u32 aux_off_align;",
          "",
          "[Added Lines]",
          "24:   u16 range;",
          "32:  s32 off;",
          "46:  struct tnum var_off;",
          "",
          "---------------"
        ],
        "include/linux/tnum.h||include/linux/tnum.h": [
          "File: include/linux/tnum.h -> include/linux/tnum.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include <linux/types.h>",
          "10: struct tnum {",
          "11:  u64 value;",
          "12:  u64 mask;",
          "13: };",
          "17: struct tnum tnum_const(u64 value);",
          "19: extern const struct tnum tnum_unknown;",
          "23: struct tnum tnum_lshift(struct tnum a, u8 shift);",
          "25: struct tnum tnum_rshift(struct tnum a, u8 shift);",
          "27: struct tnum tnum_add(struct tnum a, struct tnum b);",
          "29: struct tnum tnum_sub(struct tnum a, struct tnum b);",
          "31: struct tnum tnum_and(struct tnum a, struct tnum b);",
          "33: struct tnum tnum_or(struct tnum a, struct tnum b);",
          "35: struct tnum tnum_xor(struct tnum a, struct tnum b);",
          "37: struct tnum tnum_mul(struct tnum a, struct tnum b);",
          "40: struct tnum tnum_intersect(struct tnum a, struct tnum b);",
          "43: struct tnum tnum_cast(struct tnum a, u8 size);",
          "46: static inline bool tnum_is_const(struct tnum a)",
          "47: {",
          "48:  return !a.mask;",
          "49: }",
          "52: static inline bool tnum_equals_const(struct tnum a, u64 b)",
          "53: {",
          "54:  return tnum_is_const(a) && a.value == b;",
          "55: }",
          "58: static inline bool tnum_is_unknown(struct tnum a)",
          "59: {",
          "60:  return !~a.mask;",
          "61: }",
          "66: bool tnum_is_aligned(struct tnum a, u64 size);",
          "69: bool tnum_in(struct tnum a, struct tnum b);",
          "77: int tnum_strn(char *str, size_t size, struct tnum a);",
          "79: int tnum_sbin(char *str, size_t size, struct tnum a);",
          "",
          "---------------"
        ],
        "kernel/bpf/tnum.c||kernel/bpf/tnum.c": [
          "File: kernel/bpf/tnum.c -> kernel/bpf/tnum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include <linux/kernel.h>",
          "9: #include <linux/tnum.h>",
          "11: #define TNUM(_v, _m) (struct tnum){.value = _v, .mask = _m}",
          "13: const struct tnum tnum_unknown = { .value = 0, .mask = -1 };",
          "15: struct tnum tnum_const(u64 value)",
          "16: {",
          "17:  return TNUM(value, 0);",
          "18: }",
          "20: struct tnum tnum_lshift(struct tnum a, u8 shift)",
          "21: {",
          "22:  return TNUM(a.value << shift, a.mask << shift);",
          "23: }",
          "25: struct tnum tnum_rshift(struct tnum a, u8 shift)",
          "26: {",
          "27:  return TNUM(a.value >> shift, a.mask >> shift);",
          "28: }",
          "30: struct tnum tnum_add(struct tnum a, struct tnum b)",
          "31: {",
          "32:  u64 sm, sv, sigma, chi, mu;",
          "34:  sm = a.mask + b.mask;",
          "35:  sv = a.value + b.value;",
          "36:  sigma = sm + sv;",
          "37:  chi = sigma ^ sv;",
          "38:  mu = chi | a.mask | b.mask;",
          "39:  return TNUM(sv & ~mu, mu);",
          "40: }",
          "42: struct tnum tnum_sub(struct tnum a, struct tnum b)",
          "43: {",
          "44:  u64 dv, alpha, beta, chi, mu;",
          "46:  dv = a.value - b.value;",
          "47:  alpha = dv + a.mask;",
          "48:  beta = dv - b.mask;",
          "49:  chi = alpha ^ beta;",
          "50:  mu = chi | a.mask | b.mask;",
          "51:  return TNUM(dv & ~mu, mu);",
          "52: }",
          "54: struct tnum tnum_and(struct tnum a, struct tnum b)",
          "55: {",
          "56:  u64 alpha, beta, v;",
          "58:  alpha = a.value | a.mask;",
          "59:  beta = b.value | b.mask;",
          "60:  v = a.value & b.value;",
          "61:  return TNUM(v, alpha & beta & ~v);",
          "62: }",
          "64: struct tnum tnum_or(struct tnum a, struct tnum b)",
          "65: {",
          "66:  u64 v, mu;",
          "68:  v = a.value | b.value;",
          "69:  mu = a.mask | b.mask;",
          "70:  return TNUM(v, mu & ~v);",
          "71: }",
          "73: struct tnum tnum_xor(struct tnum a, struct tnum b)",
          "74: {",
          "75:  u64 v, mu;",
          "77:  v = a.value ^ b.value;",
          "78:  mu = a.mask | b.mask;",
          "79:  return TNUM(v & ~mu, mu);",
          "80: }",
          "85: static struct tnum hma(struct tnum acc, u64 value, u64 mask)",
          "86: {",
          "87:  while (mask) {",
          "88:   if (mask & 1)",
          "89:    acc = tnum_add(acc, TNUM(0, value));",
          "90:   mask >>= 1;",
          "91:   value <<= 1;",
          "92:  }",
          "93:  return acc;",
          "94: }",
          "96: struct tnum tnum_mul(struct tnum a, struct tnum b)",
          "97: {",
          "98:  struct tnum acc;",
          "99:  u64 pi;",
          "101:  pi = a.value * b.value;",
          "102:  acc = hma(TNUM(pi, 0), a.mask, b.mask | b.value);",
          "103:  return hma(acc, b.mask, a.value);",
          "104: }",
          "109: struct tnum tnum_intersect(struct tnum a, struct tnum b)",
          "110: {",
          "111:  u64 v, mu;",
          "113:  v = a.value | b.value;",
          "114:  mu = a.mask & b.mask;",
          "115:  return TNUM(v & ~mu, mu);",
          "116: }",
          "118: struct tnum tnum_cast(struct tnum a, u8 size)",
          "119: {",
          "120:  a.value &= (1ULL << (size * 8)) - 1;",
          "121:  a.mask &= (1ULL << (size * 8)) - 1;",
          "122:  return a;",
          "123: }",
          "125: bool tnum_is_aligned(struct tnum a, u64 size)",
          "126: {",
          "127:  if (!size)",
          "128:   return true;",
          "129:  return !((a.value | a.mask) & (size - 1));",
          "130: }",
          "132: bool tnum_in(struct tnum a, struct tnum b)",
          "133: {",
          "134:  if (b.mask & ~a.mask)",
          "135:   return false;",
          "136:  b.value &= ~a.mask;",
          "137:  return a.value == b.value;",
          "138: }",
          "140: int tnum_strn(char *str, size_t size, struct tnum a)",
          "141: {",
          "142:  return snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);",
          "143: }",
          "144: EXPORT_SYMBOL_GPL(tnum_strn);",
          "146: int tnum_sbin(char *str, size_t size, struct tnum a)",
          "147: {",
          "148:  size_t n;",
          "150:  for (n = 64; n; n--) {",
          "151:   if (n < size) {",
          "152:    if (a.mask & 1)",
          "153:     str[n - 1] = 'x';",
          "154:    else if (a.value & 1)",
          "155:     str[n - 1] = '1';",
          "156:    else",
          "157:     str[n - 1] = '0';",
          "158:   }",
          "159:   a.mask >>= 1;",
          "160:   a.value >>= 1;",
          "161:  }",
          "162:  str[min(size - 1, (size_t)64)] = 0;",
          "163:  return 64;",
          "164: }",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "181: static const char * const reg_type_str[] = {",
          "182:  [NOT_INIT]  = \"?\",",
          "184:  [PTR_TO_CTX]  = \"ctx\",",
          "185:  [CONST_PTR_TO_MAP] = \"map_ptr\",",
          "186:  [PTR_TO_MAP_VALUE] = \"map_value\",",
          "187:  [PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",",
          "190:  [PTR_TO_STACK]  = \"fp\",",
          "192:  [PTR_TO_PACKET]  = \"pkt\",",
          "193:  [PTR_TO_PACKET_END] = \"pkt_end\",",
          "194: };",
          "",
          "[Removed Lines]",
          "183:  [UNKNOWN_VALUE]  = \"inv\",",
          "188:  [PTR_TO_MAP_VALUE_ADJ] = \"map_value_adj\",",
          "189:  [FRAME_PTR]  = \"fp\",",
          "191:  [CONST_IMM]  = \"imm\",",
          "",
          "[Added Lines]",
          "183:  [SCALAR_VALUE]  = \"inv\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "221:   if (t == NOT_INIT)",
          "222:    continue;",
          "223:   verbose(\" R%d=%s\", i, reg_type_str[t]);",
          "250:  }",
          "251:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "252:   if (state->stack_slot_type[i] == STACK_SPILL)",
          "",
          "[Removed Lines]",
          "224:   if (t == CONST_IMM || t == PTR_TO_STACK)",
          "225:    verbose(\"%lld\", reg->imm);",
          "226:   else if (t == PTR_TO_PACKET)",
          "227:    verbose(\"(id=%d,off=%d,r=%d)\",",
          "228:     reg->id, reg->off, reg->range);",
          "229:   else if (t == UNKNOWN_VALUE && reg->imm)",
          "230:    verbose(\"%lld\", reg->imm);",
          "231:   else if (t == CONST_PTR_TO_MAP || t == PTR_TO_MAP_VALUE ||",
          "232:     t == PTR_TO_MAP_VALUE_OR_NULL ||",
          "233:     t == PTR_TO_MAP_VALUE_ADJ)",
          "234:    verbose(\"(ks=%d,vs=%d,id=%u)\",",
          "235:     reg->map_ptr->key_size,",
          "236:     reg->map_ptr->value_size,",
          "237:     reg->id);",
          "238:   if (reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "239:    verbose(\",min_value=%lld\",",
          "240:     (long long)reg->min_value);",
          "241:   if (reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "242:    verbose(\",max_value=%llu\",",
          "243:     (unsigned long long)reg->max_value);",
          "244:   if (reg->min_align)",
          "245:    verbose(\",min_align=%u\", reg->min_align);",
          "246:   if (reg->aux_off)",
          "247:    verbose(\",aux_off=%u\", reg->aux_off);",
          "248:   if (reg->aux_off_align)",
          "249:    verbose(\",aux_off_align=%u\", reg->aux_off_align);",
          "",
          "[Added Lines]",
          "221:   if ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&",
          "222:       tnum_is_const(reg->var_off)) {",
          "224:    verbose(\"%lld\", reg->var_off.value + reg->off);",
          "225:   } else {",
          "226:    verbose(\"(id=%d\", reg->id);",
          "227:    if (t != SCALAR_VALUE)",
          "228:     verbose(\",off=%d\", reg->off);",
          "229:    if (t == PTR_TO_PACKET)",
          "230:     verbose(\",r=%d\", reg->range);",
          "231:    else if (t == CONST_PTR_TO_MAP ||",
          "232:      t == PTR_TO_MAP_VALUE ||",
          "233:      t == PTR_TO_MAP_VALUE_OR_NULL)",
          "234:     verbose(\",ks=%d,vs=%d\",",
          "235:      reg->map_ptr->key_size,",
          "236:      reg->map_ptr->value_size);",
          "237:    if (reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "238:     verbose(\",min_value=%lld\",",
          "239:      (long long)reg->min_value);",
          "240:    if (reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "241:     verbose(\",max_value=%llu\",",
          "242:      (unsigned long long)reg->max_value);",
          "243:    if (!tnum_is_unknown(reg->var_off)) {",
          "244:     char tn_buf[48];",
          "246:     tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "247:     verbose(\",var_off=%s\", tn_buf);",
          "248:    }",
          "249:    verbose(\")\");",
          "250:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "463:  BPF_REG_0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5",
          "464: };",
          "467: {",
          "474: }",
          "476: static void init_reg_state(struct bpf_reg_state *regs)",
          "",
          "[Removed Lines]",
          "466: static void mark_reg_not_init(struct bpf_reg_state *regs, u32 regno)",
          "468:  BUG_ON(regno >= MAX_BPF_REG);",
          "470:  memset(&regs[regno], 0, sizeof(regs[regno]));",
          "471:  regs[regno].type = NOT_INIT;",
          "472:  regs[regno].min_value = BPF_REGISTER_MIN_RANGE;",
          "473:  regs[regno].max_value = BPF_REGISTER_MAX_RANGE;",
          "",
          "[Added Lines]",
          "467: static void __mark_reg_not_init(struct bpf_reg_state *reg);",
          "472: static void __mark_reg_known_zero(struct bpf_reg_state *reg)",
          "474:  reg->var_off = tnum_const(0);",
          "475:  reg->min_value = 0;",
          "476:  reg->max_value = 0;",
          "477: }",
          "479: static void mark_reg_known_zero(struct bpf_reg_state *regs, u32 regno)",
          "480: {",
          "481:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "482:   verbose(\"mark_reg_known_zero(regs, %u)\\n\", regno);",
          "484:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "485:    __mark_reg_not_init(regs + regno);",
          "486:   return;",
          "487:  }",
          "488:  __mark_reg_known_zero(regs + regno);",
          "489: }",
          "492: static void __mark_reg_unknown(struct bpf_reg_state *reg)",
          "493: {",
          "494:  reg->type = SCALAR_VALUE;",
          "495:  reg->id = 0;",
          "496:  reg->off = 0;",
          "497:  reg->var_off = tnum_unknown;",
          "498:  reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "499:  reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "500: }",
          "502: static void mark_reg_unknown(struct bpf_reg_state *regs, u32 regno)",
          "503: {",
          "504:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "505:   verbose(\"mark_reg_unknown(regs, %u)\\n\", regno);",
          "507:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "508:    __mark_reg_not_init(regs + regno);",
          "509:   return;",
          "510:  }",
          "511:  __mark_reg_unknown(regs + regno);",
          "512: }",
          "514: static void __mark_reg_not_init(struct bpf_reg_state *reg)",
          "515: {",
          "516:  __mark_reg_unknown(reg);",
          "517:  reg->type = NOT_INIT;",
          "518: }",
          "520: static void mark_reg_not_init(struct bpf_reg_state *regs, u32 regno)",
          "521: {",
          "522:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "523:   verbose(\"mark_reg_not_init(regs, %u)\\n\", regno);",
          "525:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "526:    __mark_reg_not_init(regs + regno);",
          "527:   return;",
          "528:  }",
          "529:  __mark_reg_not_init(regs + regno);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "481:   mark_reg_not_init(regs, i);",
          "487:  regs[BPF_REG_1].type = PTR_TO_CTX;",
          "501: }",
          "503: static void reset_reg_range_values(struct bpf_reg_state *regs, u32 regno)",
          "",
          "[Removed Lines]",
          "484:  regs[BPF_REG_FP].type = FRAME_PTR;",
          "488: }",
          "490: static void __mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)",
          "491: {",
          "492:  regs[regno].type = UNKNOWN_VALUE;",
          "493:  regs[regno].id = 0;",
          "494:  regs[regno].imm = 0;",
          "495: }",
          "497: static void mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)",
          "498: {",
          "499:  BUG_ON(regno >= MAX_BPF_REG);",
          "500:  __mark_reg_unknown_value(regs, regno);",
          "",
          "[Added Lines]",
          "540:  regs[BPF_REG_FP].type = PTR_TO_STACK;",
          "541:  mark_reg_known_zero(regs, BPF_REG_FP);",
          "545:  mark_reg_known_zero(regs, BPF_REG_1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "505:  regs[regno].min_value = BPF_REGISTER_MIN_RANGE;",
          "506:  regs[regno].max_value = BPF_REGISTER_MAX_RANGE;",
          "507:  regs[regno].value_from_signed = false;",
          "516: }",
          "518: enum reg_arg_type {",
          "",
          "[Removed Lines]",
          "508:  regs[regno].min_align = 0;",
          "509: }",
          "511: static void mark_reg_unknown_value_and_range(struct bpf_reg_state *regs,",
          "512:           u32 regno)",
          "513: {",
          "514:  mark_reg_unknown_value(regs, regno);",
          "515:  reset_reg_range_values(regs, regno);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "542:    return -EACCES;",
          "543:   }",
          "544:   if (t == DST_OP)",
          "546:  }",
          "547:  return 0;",
          "548: }",
          "",
          "[Removed Lines]",
          "545:    mark_reg_unknown_value(regs, regno);",
          "",
          "[Added Lines]",
          "582:    mark_reg_unknown(regs, regno);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "552:  switch (type) {",
          "553:  case PTR_TO_MAP_VALUE:",
          "554:  case PTR_TO_MAP_VALUE_OR_NULL:",
          "556:  case PTR_TO_STACK:",
          "557:  case PTR_TO_CTX:",
          "558:  case PTR_TO_PACKET:",
          "559:  case PTR_TO_PACKET_END:",
          "561:  case CONST_PTR_TO_MAP:",
          "562:   return true;",
          "563:  default:",
          "",
          "[Removed Lines]",
          "555:  case PTR_TO_MAP_VALUE_ADJ:",
          "560:  case FRAME_PTR:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "637:   }",
          "638:   if (value_regno >= 0)",
          "642:   return 0;",
          "643:  }",
          "644: }",
          "648:        int size)",
          "649: {",
          "650:  struct bpf_map *map = env->cur_state.regs[regno].map_ptr;",
          "",
          "[Removed Lines]",
          "640:    mark_reg_unknown_value_and_range(state->regs,",
          "641:         value_regno);",
          "647: static int check_map_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "",
          "[Added Lines]",
          "675:    mark_reg_unknown(state->regs, value_regno);",
          "681: static int __check_map_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "657:  return 0;",
          "658: }",
          "662:     int off, int size)",
          "663: {",
          "664:  struct bpf_verifier_state *state = &env->cur_state;",
          "665:  struct bpf_reg_state *reg = &state->regs[regno];",
          "666:  int err;",
          "673:  if (log_level)",
          "674:   print_verifier_state(state);",
          "",
          "[Removed Lines]",
          "661: static int check_map_access_adj(struct bpf_verifier_env *env, u32 regno,",
          "675:  env->varlen_map_value_access = true;",
          "",
          "[Added Lines]",
          "695: static int check_map_access(struct bpf_verifier_env *env, u32 regno,",
          "711:  if (!tnum_is_const(reg->var_off))",
          "712:   env->varlen_map_value_access = true;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "684:    regno);",
          "685:   return -EACCES;",
          "686:  }",
          "688:  if (err) {",
          "691:   return err;",
          "692:  }",
          "",
          "[Removed Lines]",
          "687:  err = check_map_access(env, regno, reg->min_value + off, size);",
          "689:   verbose(\"R%d min value is outside of the array range\\n\",",
          "690:    regno);",
          "",
          "[Added Lines]",
          "724:  err = __check_map_access(env, regno, reg->min_value + off, size);",
          "726:   verbose(\"R%d min value is outside of the array range\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "699:    regno);",
          "700:   return -EACCES;",
          "701:  }",
          "703: }",
          "705: #define MAX_PACKET_OFF 0xffff",
          "",
          "[Removed Lines]",
          "702:  return check_map_access(env, regno, reg->max_value + off, size);",
          "",
          "[Added Lines]",
          "738:  err = __check_map_access(env, regno, reg->max_value + off, size);",
          "739:  if (err)",
          "740:   verbose(\"R%d max value is outside of the array range\\n\", regno);",
          "741:  return err;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "729:  }",
          "730: }",
          "734: {",
          "735:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "736:  struct bpf_reg_state *reg = &regs[regno];",
          "740:   verbose(\"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",",
          "741:    off, size, regno, reg->id, reg->off, reg->range);",
          "742:   return -EACCES;",
          "",
          "[Removed Lines]",
          "732: static int check_packet_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "733:           int size)",
          "738:  off += reg->off;",
          "739:  if (off < 0 || size <= 0 || off + size > reg->range) {",
          "",
          "[Added Lines]",
          "771: static int __check_packet_access(struct bpf_verifier_env *env, u32 regno,",
          "772:      int off, int size)",
          "777:  if (off < 0 || size <= 0 || (u64)off + size > reg->range) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "744:  return 0;",
          "745: }",
          "748: static int check_ctx_access(struct bpf_verifier_env *env, int insn_idx, int off, int size,",
          "749:        enum bpf_access_type t, enum bpf_reg_type *reg_type)",
          "750: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "785: static int check_packet_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "786:           int size)",
          "787: {",
          "788:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "789:  struct bpf_reg_state *reg = &regs[regno];",
          "790:  int err;",
          "800:  if (reg->min_value < 0) {",
          "801:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "802:    regno);",
          "803:   return -EACCES;",
          "804:  }",
          "805:  err = __check_packet_access(env, regno, off, size);",
          "806:  if (err) {",
          "807:   verbose(\"R%d offset is outside of the packet\\n\", regno);",
          "808:   return err;",
          "809:  }",
          "810:  return err;",
          "811: }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "784:  if (allow_ptr_leaks)",
          "785:   return false;",
          "794: }",
          "796: static bool is_pointer_value(struct bpf_verifier_env *env, int regno)",
          "",
          "[Removed Lines]",
          "787:  switch (reg->type) {",
          "788:  case UNKNOWN_VALUE:",
          "789:  case CONST_IMM:",
          "790:   return false;",
          "791:  default:",
          "792:   return true;",
          "793:  }",
          "",
          "[Added Lines]",
          "853:  return reg->type != SCALAR_VALUE;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "801: static int check_pkt_ptr_alignment(const struct bpf_reg_state *reg,",
          "802:        int off, int size, bool strict)",
          "803: {",
          "804:  int ip_align;",
          "808:  if (!strict || size == 1)",
          "809:   return 0;",
          "",
          "[Removed Lines]",
          "805:  int reg_off;",
          "811:  reg_off = reg->off;",
          "812:  if (reg->id) {",
          "813:   if (reg->aux_off_align % size) {",
          "814:    verbose(\"Packet access is only %u byte aligned, %d byte access not allowed\\n\",",
          "815:     reg->aux_off_align, size);",
          "816:    return -EACCES;",
          "817:   }",
          "818:   reg_off += reg->aux_off;",
          "819:  }",
          "",
          "[Added Lines]",
          "864:  struct tnum reg_off;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "829:  ip_align = 2;",
          "833:   return -EACCES;",
          "834:  }",
          "836:  return 0;",
          "837: }",
          "841: {",
          "844:   return -EACCES;",
          "845:  }",
          "",
          "[Removed Lines]",
          "830:  if ((ip_align + reg_off + off) % size != 0) {",
          "831:   verbose(\"misaligned packet access off %d+%d+%d size %d\\n\",",
          "832:    ip_align, reg_off, off, size);",
          "839: static int check_val_ptr_alignment(const struct bpf_reg_state *reg,",
          "840:        int size, bool strict)",
          "842:  if (strict && size != 1) {",
          "843:   verbose(\"Unknown alignment. Only byte-sized access allowed in value access.\\n\");",
          "",
          "[Added Lines]",
          "881:  reg_off = tnum_add(reg->var_off, tnum_const(ip_align + reg->off + off));",
          "882:  if (!tnum_is_aligned(reg_off, size)) {",
          "883:   char tn_buf[48];",
          "885:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "886:   verbose(\"misaligned packet access off %d+%s+%d+%d size %d\\n\",",
          "887:    ip_align, tn_buf, reg->off, off, size);",
          "894: static int check_generic_ptr_alignment(const struct bpf_reg_state *reg,",
          "895:            const char *pointer_desc,",
          "896:            int off, int size, bool strict)",
          "898:  struct tnum reg_off;",
          "901:  if (!strict || size == 1)",
          "902:   return 0;",
          "904:  reg_off = tnum_add(reg->var_off, tnum_const(reg->off + off));",
          "905:  if (!tnum_is_aligned(reg_off, size)) {",
          "906:   char tn_buf[48];",
          "908:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "909:   verbose(\"misaligned %saccess off %s+%d+%d size %d\\n\",",
          "910:    pointer_desc, tn_buf, reg->off, off, size);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "852:           int off, int size)",
          "853: {",
          "854:  bool strict = env->strict_alignment;",
          "856:  switch (reg->type) {",
          "857:  case PTR_TO_PACKET:",
          "858:   return check_pkt_ptr_alignment(reg, off, size, strict);",
          "861:  default:",
          "869:  }",
          "870: }",
          "",
          "[Removed Lines]",
          "859:  case PTR_TO_MAP_VALUE_ADJ:",
          "860:   return check_val_ptr_alignment(reg, size, strict);",
          "862:   if (off % size != 0) {",
          "863:    verbose(\"misaligned access off %d size %d\\n\",",
          "864:     off, size);",
          "865:    return -EACCES;",
          "866:   }",
          "868:   return 0;",
          "",
          "[Added Lines]",
          "922:  const char *pointer_desc = \"\";",
          "928:  case PTR_TO_MAP_VALUE:",
          "929:   pointer_desc = \"value \";",
          "930:   break;",
          "931:  case PTR_TO_CTX:",
          "932:   pointer_desc = \"context \";",
          "933:   break;",
          "934:  case PTR_TO_STACK:",
          "935:   pointer_desc = \"stack \";",
          "936:   break;",
          "938:   break;",
          "940:  return check_generic_ptr_alignment(reg, pointer_desc, off, size, strict);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "883:  struct bpf_reg_state *reg = &state->regs[regno];",
          "884:  int size, err = 0;",
          "889:  size = bpf_size_to_bytes(bpf_size);",
          "890:  if (size < 0)",
          "891:   return size;",
          "893:  err = check_ptr_alignment(env, reg, off, size);",
          "894:  if (err)",
          "895:   return err;",
          "899:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "900:       is_pointer_value(env, value_regno)) {",
          "901:    verbose(\"R%d leaks addr into map\\n\", value_regno);",
          "902:    return -EACCES;",
          "903:   }",
          "909:   if (!err && t == BPF_READ && value_regno >= 0)",
          "913:  } else if (reg->type == PTR_TO_CTX) {",
          "916:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "917:       is_pointer_value(env, value_regno)) {",
          "918:    verbose(\"R%d leaks addr into ctx\\n\", value_regno);",
          "919:    return -EACCES;",
          "920:   }",
          "921:   err = check_ctx_access(env, insn_idx, off, size, t, &reg_type);",
          "922:   if (!err && t == BPF_READ && value_regno >= 0) {",
          "926:    state->regs[value_regno].type = reg_type;",
          "929:   }",
          "932:   if (off >= 0 || off < -MAX_BPF_STACK) {",
          "933:    verbose(\"invalid stack off=%d size=%d\\n\", off, size);",
          "934:    return -EACCES;",
          "",
          "[Removed Lines]",
          "886:  if (reg->type == PTR_TO_STACK)",
          "887:   off += reg->imm;",
          "897:  if (reg->type == PTR_TO_MAP_VALUE ||",
          "898:      reg->type == PTR_TO_MAP_VALUE_ADJ) {",
          "905:   if (reg->type == PTR_TO_MAP_VALUE_ADJ)",
          "906:    err = check_map_access_adj(env, regno, off, size);",
          "907:   else",
          "908:    err = check_map_access(env, regno, off, size);",
          "910:    mark_reg_unknown_value_and_range(state->regs,",
          "911:         value_regno);",
          "914:   enum bpf_reg_type reg_type = UNKNOWN_VALUE;",
          "923:    mark_reg_unknown_value_and_range(state->regs,",
          "924:         value_regno);",
          "927:    state->regs[value_regno].aux_off = 0;",
          "928:    state->regs[value_regno].aux_off_align = 0;",
          "931:  } else if (reg->type == FRAME_PTR || reg->type == PTR_TO_STACK) {",
          "",
          "[Added Lines]",
          "967:  off += reg->off;",
          "969:  if (reg->type == PTR_TO_MAP_VALUE) {",
          "976:   err = check_map_access(env, regno, off, size);",
          "978:    mark_reg_unknown(state->regs, value_regno);",
          "981:   enum bpf_reg_type reg_type = SCALAR_VALUE;",
          "991:   if (!tnum_is_const(reg->var_off)) {",
          "992:    char tn_buf[48];",
          "994:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "995:    verbose(\"variable ctx access var_off=%s off=%d size=%d\",",
          "996:     tn_buf, off, size);",
          "997:    return -EACCES;",
          "998:   }",
          "999:   off += reg->var_off.value;",
          "1006:    if (reg_type == SCALAR_VALUE)",
          "1007:     mark_reg_unknown(state->regs, value_regno);",
          "1008:    else",
          "1009:     mark_reg_known_zero(state->regs, value_regno);",
          "1010:    state->regs[value_regno].id = 0;",
          "1011:    state->regs[value_regno].off = 0;",
          "1012:    state->regs[value_regno].range = 0;",
          "1016:  } else if (reg->type == PTR_TO_STACK) {",
          "1021:   if (!tnum_is_const(reg->var_off)) {",
          "1022:    char tn_buf[48];",
          "1024:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1025:    verbose(\"variable stack access var_off=%s off=%d size=%d\",",
          "1026:     tn_buf, off, size);",
          "1027:    return -EACCES;",
          "1028:   }",
          "1029:   off += reg->var_off.value;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "948:   } else {",
          "949:    err = check_stack_read(state, off, size, value_regno);",
          "950:   }",
          "952:   if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {",
          "953:    verbose(\"cannot write into packet\\n\");",
          "954:    return -EACCES;",
          "",
          "[Removed Lines]",
          "951:  } else if (state->regs[regno].type == PTR_TO_PACKET) {",
          "",
          "[Added Lines]",
          "1049:  } else if (reg->type == PTR_TO_PACKET) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "960:   }",
          "961:   err = check_packet_access(env, regno, off, size);",
          "962:   if (!err && t == BPF_READ && value_regno >= 0)",
          "965:  } else {",
          "966:   verbose(\"R%d invalid mem access '%s'\\n\",",
          "967:    regno, reg_type_str[reg->type]);",
          "968:   return -EACCES;",
          "969:  }",
          "978:  }",
          "979:  return err;",
          "980: }",
          "",
          "[Removed Lines]",
          "963:    mark_reg_unknown_value_and_range(state->regs,",
          "964:         value_regno);",
          "971:  if (!err && size <= 2 && value_regno >= 0 && env->allow_ptr_leaks &&",
          "972:      state->regs[value_regno].type == UNKNOWN_VALUE) {",
          "977:   state->regs[value_regno].imm = 64 - size * 8;",
          "",
          "[Added Lines]",
          "1061:    mark_reg_unknown(state->regs, value_regno);",
          "1068:  if (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&",
          "1069:      state->regs[value_regno].type == SCALAR_VALUE) {",
          "1071:   state->regs[value_regno].var_off = tnum_cast(",
          "1072:      state->regs[value_regno].var_off, size);",
          "1074:   state->regs[value_regno].min_value = 0;",
          "1075:   state->regs[value_regno].max_value = min_t(u64,",
          "1076:      state->regs[value_regno].var_off.value |",
          "1077:      state->regs[value_regno].var_off.mask,",
          "1078:      BPF_REGISTER_MAX_RANGE);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1016:     BPF_SIZE(insn->code), BPF_WRITE, -1);",
          "1017: }",
          "1023: static int check_stack_boundary(struct bpf_verifier_env *env, int regno,",
          "1024:     int access_size, bool zero_size_allowed,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1121: static bool register_is_null(struct bpf_reg_state reg)",
          "1122: {",
          "1123:  return reg.type == SCALAR_VALUE && tnum_equals_const(reg.var_off, 0);",
          "1124: }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1029:  int off, i;",
          "1031:  if (regs[regno].type != PTR_TO_STACK) {",
          "1032:   if (zero_size_allowed && access_size == 0 &&",
          "1035:    return 0;",
          "1037:   verbose(\"R%d type=%s expected=%s\\n\", regno,",
          "",
          "[Removed Lines]",
          "1033:       regs[regno].type == CONST_IMM &&",
          "1034:       regs[regno].imm  == 0)",
          "",
          "[Added Lines]",
          "1143:       register_is_null(regs[regno]))",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1040:   return -EACCES;",
          "1041:  }",
          "1044:  if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",
          "1045:      access_size <= 0) {",
          "1046:   verbose(\"invalid stack type R%d off=%d access_size=%d\\n\",",
          "",
          "[Removed Lines]",
          "1043:  off = regs[regno].imm;",
          "",
          "[Added Lines]",
          "1153:  if (!tnum_is_const(regs[regno].var_off)) {",
          "1154:   char tn_buf[48];",
          "1156:   tnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);",
          "1157:   verbose(\"invalid variable stack read R%d var_off=%s\\n\",",
          "1158:    regno, tn_buf);",
          "1159:  }",
          "1160:  off = regs[regno].off + regs[regno].var_off.value;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1071:        int access_size, bool zero_size_allowed,",
          "1072:        struct bpf_call_arg_meta *meta)",
          "1073: {",
          "1077:  case PTR_TO_PACKET:",
          "1079:  case PTR_TO_MAP_VALUE:",
          "1084:   return check_stack_boundary(env, regno, access_size,",
          "1085:          zero_size_allowed, meta);",
          "1086:  }",
          "",
          "[Removed Lines]",
          "1074:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1076:  switch (regs[regno].type) {",
          "1078:   return check_packet_access(env, regno, 0, access_size);",
          "1080:   return check_map_access(env, regno, 0, access_size);",
          "1081:  case PTR_TO_MAP_VALUE_ADJ:",
          "1082:   return check_map_access_adj(env, regno, 0, access_size);",
          "",
          "[Added Lines]",
          "1191:  struct bpf_reg_state *regs = env->cur_state.regs, *reg = &regs[regno];",
          "1193:  switch (reg->type) {",
          "1195:   return check_packet_access(env, regno, reg->off, access_size);",
          "1197:   return check_map_access(env, regno, reg->off, access_size);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1123:    goto err_type;",
          "1124:  } else if (arg_type == ARG_CONST_SIZE ||",
          "1125:      arg_type == ARG_CONST_SIZE_OR_ZERO) {",
          "1131:    goto err_type;",
          "1132:  } else if (arg_type == ARG_CONST_MAP_PTR) {",
          "1133:   expected_type = CONST_PTR_TO_MAP;",
          "",
          "[Removed Lines]",
          "1126:   expected_type = CONST_IMM;",
          "1130:   if (type != UNKNOWN_VALUE && type != expected_type)",
          "",
          "[Added Lines]",
          "1241:   expected_type = SCALAR_VALUE;",
          "1242:   if (type != expected_type)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1141:      arg_type == ARG_PTR_TO_UNINIT_MEM) {",
          "1142:   expected_type = PTR_TO_STACK;",
          "1149:   else if (type != PTR_TO_PACKET && type != PTR_TO_MAP_VALUE &&",
          "1151:    goto err_type;",
          "1152:   meta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;",
          "1153:  } else {",
          "",
          "[Removed Lines]",
          "1147:   if (type == CONST_IMM && reg->imm == 0)",
          "1150:     type != PTR_TO_MAP_VALUE_ADJ && type != expected_type)",
          "",
          "[Added Lines]",
          "1259:   if (register_is_null(*reg))",
          "1262:     type != expected_type)",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1173:    return -EACCES;",
          "1174:   }",
          "1175:   if (type == PTR_TO_PACKET)",
          "1177:         meta->map_ptr->key_size);",
          "1178:   else",
          "1179:    err = check_stack_boundary(env, regno,",
          "",
          "[Removed Lines]",
          "1176:    err = check_packet_access(env, regno, 0,",
          "",
          "[Added Lines]",
          "1288:    err = check_packet_access(env, regno, reg->off,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1189:    return -EACCES;",
          "1190:   }",
          "1191:   if (type == PTR_TO_PACKET)",
          "1193:         meta->map_ptr->value_size);",
          "1194:   else",
          "1195:    err = check_stack_boundary(env, regno,",
          "",
          "[Removed Lines]",
          "1192:    err = check_packet_access(env, regno, 0,",
          "",
          "[Added Lines]",
          "1304:    err = check_packet_access(env, regno, reg->off,",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1209:    return -EACCES;",
          "1210:   }",
          "",
          "[Removed Lines]",
          "1215:   if (type == UNKNOWN_VALUE) {",
          "",
          "[Added Lines]",
          "1328:   if (!tnum_is_const(reg->var_off))",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1221:    meta = NULL;",
          "1245:    if (err)",
          "1246:     return err;",
          "1251:   }",
          "1252:  }",
          "1254:  return err;",
          "",
          "[Removed Lines]",
          "1223:    if (reg->min_value < 0) {",
          "1224:     verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "1225:      regno);",
          "1226:     return -EACCES;",
          "1227:    }",
          "1229:    if (reg->min_value == 0) {",
          "1230:     err = check_helper_mem_access(env, regno - 1, 0,",
          "1231:              zero_size_allowed,",
          "1232:              meta);",
          "1233:     if (err)",
          "1234:      return err;",
          "1235:    }",
          "1237:    if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "1238:     verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "1239:      regno);",
          "1240:     return -EACCES;",
          "1241:    }",
          "1242:    err = check_helper_mem_access(env, regno - 1,",
          "1243:             reg->max_value,",
          "1244:             zero_size_allowed, meta);",
          "1247:   } else {",
          "1249:    err = check_helper_mem_access(env, regno - 1, reg->imm,",
          "1250:             zero_size_allowed, meta);",
          "",
          "[Added Lines]",
          "1336:   if (reg->min_value < 0) {",
          "1337:    verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "1338:     regno);",
          "1339:    return -EACCES;",
          "1340:   }",
          "1342:   if (reg->min_value == 0) {",
          "1343:    err = check_helper_mem_access(env, regno - 1, 0,",
          "1344:             zero_size_allowed,",
          "1345:             meta);",
          "1350:   if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "1351:    verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "1352:     regno);",
          "1353:    return -EACCES;",
          "1354:   }",
          "1355:   err = check_helper_mem_access(env, regno - 1,",
          "1356:            reg->max_value,",
          "1357:            zero_size_allowed, meta);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1361:  for (i = 0; i < MAX_BPF_REG; i++)",
          "1362:   if (regs[i].type == PTR_TO_PACKET ||",
          "1363:       regs[i].type == PTR_TO_PACKET_END)",
          "1366:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "1367:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "",
          "[Removed Lines]",
          "1364:    mark_reg_unknown_value(regs, i);",
          "",
          "[Added Lines]",
          "1473:    mark_reg_unknown(regs, i);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1370:   if (reg->type != PTR_TO_PACKET &&",
          "1371:       reg->type != PTR_TO_PACKET_END)",
          "1372:    continue;",
          "1375:  }",
          "1376: }",
          "",
          "[Removed Lines]",
          "1373:   __mark_reg_unknown_value(state->spilled_regs,",
          "1374:       i / BPF_REG_SIZE);",
          "",
          "[Added Lines]",
          "1482:   __mark_reg_unknown(reg);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1453:  if (fn->ret_type == RET_INTEGER) {",
          "1455:  } else if (fn->ret_type == RET_VOID) {",
          "1456:   regs[BPF_REG_0].type = NOT_INIT;",
          "1457:  } else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {",
          "1458:   struct bpf_insn_aux_data *insn_aux;",
          "1460:   regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;",
          "",
          "[Removed Lines]",
          "1454:   regs[BPF_REG_0].type = UNKNOWN_VALUE;",
          "1461:   regs[BPF_REG_0].max_value = regs[BPF_REG_0].min_value = 0;",
          "",
          "[Added Lines]",
          "1563:   mark_reg_unknown(regs, BPF_REG_0);",
          "1571:   mark_reg_known_zero(regs, BPF_REG_0);",
          "1572:   regs[BPF_REG_0].off = 0;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1489:  return 0;",
          "1490: }",
          "1494: {",
          "1573:  }",
          "1575: }",
          "1578: {",
          "1581:  u8 opcode = BPF_OP(insn->code);",
          "1620:  }",
          "1729:   }",
          "1732:  }",
          "1735:  return 0;",
          "1736: }",
          "1740: {",
          "1741:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1819:  s64 min_val = BPF_REGISTER_MIN_RANGE;",
          "1820:  u64 max_val = BPF_REGISTER_MAX_RANGE;",
          "1821:  u8 opcode = BPF_OP(insn->code);",
          "1885:  }",
          "1887:  switch (opcode) {",
          "1888:  case BPF_ADD:",
          "1889:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1890:    dst_reg->min_value += min_val;",
          "1891:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1892:    dst_reg->max_value += max_val;",
          "1894:   break;",
          "1895:  case BPF_SUB:",
          "1901:   if (max_val == BPF_REGISTER_MAX_RANGE)",
          "1902:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1903:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1904:    dst_reg->min_value -= max_val;",
          "1905:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1906:    dst_reg->max_value -= min_val;",
          "1908:   break;",
          "1909:  case BPF_MUL:",
          "1912:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1913:    dst_reg->max_value *= max_val;",
          "1915:   break;",
          "1916:  case BPF_AND:",
          "1922:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1923:   else",
          "1927:   break;",
          "1928:  case BPF_LSH:",
          "1933:   if (min_val > ilog2(BPF_REGISTER_MAX_RANGE)) {",
          "1934:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1936:   } else {",
          "1937:    if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1938:     dst_reg->min_value <<= min_val;",
          "1942:   }",
          "1943:   if (max_val > ilog2(BPF_REGISTER_MAX_RANGE))",
          "1944:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "",
          "[Removed Lines]",
          "1492: static int check_packet_ptr_add(struct bpf_verifier_env *env,",
          "1493:     struct bpf_insn *insn)",
          "1495:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1496:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1497:  struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1498:  struct bpf_reg_state tmp_reg;",
          "1499:  s32 imm;",
          "1501:  if (BPF_SRC(insn->code) == BPF_K) {",
          "1503:   imm = insn->imm;",
          "1505: add_imm:",
          "1506:   if (imm < 0) {",
          "1507:    verbose(\"addition of negative constant to packet pointer is not allowed\\n\");",
          "1508:    return -EACCES;",
          "1509:   }",
          "1510:   if (imm >= MAX_PACKET_OFF ||",
          "1511:       imm + dst_reg->off >= MAX_PACKET_OFF) {",
          "1512:    verbose(\"constant %d is too large to add to packet pointer\\n\",",
          "1513:     imm);",
          "1514:    return -EACCES;",
          "1515:   }",
          "1519:   dst_reg->off += imm;",
          "1520:  } else {",
          "1521:   bool had_id;",
          "1523:   if (src_reg->type == PTR_TO_PACKET) {",
          "1534:   }",
          "1536:   if (src_reg->type == CONST_IMM) {",
          "1538:    imm = src_reg->imm;",
          "1539:    goto add_imm;",
          "1540:   }",
          "1546:   if (src_reg->type != UNKNOWN_VALUE) {",
          "1547:    verbose(\"cannot add '%s' to ptr_to_packet\\n\",",
          "1548:     reg_type_str[src_reg->type]);",
          "1549:    return -EACCES;",
          "1550:   }",
          "1551:   if (src_reg->imm < 48) {",
          "1552:    verbose(\"cannot add integer value with %lld upper zero bits to ptr_to_packet\\n\",",
          "1553:     src_reg->imm);",
          "1554:    return -EACCES;",
          "1555:   }",
          "1557:   had_id = (dst_reg->id != 0);",
          "1562:   dst_reg->id = ++env->id_gen;",
          "1565:   dst_reg->aux_off += dst_reg->off;",
          "1566:   dst_reg->off = 0;",
          "1567:   dst_reg->range = 0;",
          "1568:   if (had_id)",
          "1569:    dst_reg->aux_off_align = min(dst_reg->aux_off_align,",
          "1570:            src_reg->min_align);",
          "1571:   else",
          "1572:    dst_reg->aux_off_align = src_reg->min_align;",
          "1574:  return 0;",
          "1577: static int evaluate_reg_alu(struct bpf_verifier_env *env, struct bpf_insn *insn)",
          "1579:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1580:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1582:  s64 imm_log2;",
          "1589:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1590:   struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1592:   if (src_reg->type == UNKNOWN_VALUE && src_reg->imm > 0 &&",
          "1593:       dst_reg->imm && opcode == BPF_ADD) {",
          "1601:    dst_reg->imm = min(dst_reg->imm, src_reg->imm);",
          "1602:    dst_reg->imm--;",
          "1603:    return 0;",
          "1604:   }",
          "1605:   if (src_reg->type == CONST_IMM && src_reg->imm > 0 &&",
          "1606:       dst_reg->imm && opcode == BPF_ADD) {",
          "1612:    imm_log2 = __ilog2_u64((long long)src_reg->imm);",
          "1613:    dst_reg->imm = min(dst_reg->imm, 63 - imm_log2);",
          "1614:    dst_reg->imm--;",
          "1615:    return 0;",
          "1616:   }",
          "1618:   dst_reg->imm = 0;",
          "1619:   return 0;",
          "1626:  imm_log2 = __ilog2_u64((long long)insn->imm);",
          "1628:  if (dst_reg->imm && opcode == BPF_LSH) {",
          "1634:   dst_reg->imm -= insn->imm;",
          "1635:  } else if (dst_reg->imm && opcode == BPF_MUL) {",
          "1641:   dst_reg->imm -= imm_log2 + 1;",
          "1642:  } else if (opcode == BPF_AND) {",
          "1644:   dst_reg->imm = 63 - imm_log2;",
          "1645:  } else if (dst_reg->imm && opcode == BPF_ADD) {",
          "1647:   dst_reg->imm = min(dst_reg->imm, 63 - imm_log2);",
          "1648:   dst_reg->imm--;",
          "1649:  } else if (opcode == BPF_RSH) {",
          "1655:   dst_reg->imm += insn->imm;",
          "1656:   if (unlikely(dst_reg->imm > 64))",
          "1661:    dst_reg->imm = 64;",
          "1662:  } else {",
          "1666:   dst_reg->imm = 0;",
          "1667:  }",
          "1669:  if (dst_reg->imm < 0) {",
          "1674:   dst_reg->imm = 0;",
          "1675:  }",
          "1676:  return 0;",
          "1677: }",
          "1679: static int evaluate_reg_imm_alu_unknown(struct bpf_verifier_env *env,",
          "1680:      struct bpf_insn *insn)",
          "1681: {",
          "1682:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1683:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1684:  struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1685:  u8 opcode = BPF_OP(insn->code);",
          "1686:  s64 imm_log2 = __ilog2_u64((long long)dst_reg->imm);",
          "1689:  if (src_reg->imm > 0 && dst_reg->imm) {",
          "1690:   switch (opcode) {",
          "1691:   case BPF_ADD:",
          "1699:    dst_reg->imm = min(src_reg->imm, 63 - imm_log2);",
          "1700:    dst_reg->imm--;",
          "1701:    break;",
          "1702:   case BPF_AND:",
          "1710:    dst_reg->imm = max(src_reg->imm, 63 - imm_log2);",
          "1711:    break;",
          "1712:   case BPF_OR:",
          "1720:    dst_reg->imm = min(src_reg->imm, 63 - imm_log2);",
          "1721:    break;",
          "1722:   case BPF_SUB:",
          "1723:   case BPF_MUL:",
          "1724:   case BPF_RSH:",
          "1725:   case BPF_LSH:",
          "1727:   default:",
          "1728:    mark_reg_unknown_value(regs, insn->dst_reg);",
          "1730:  } else {",
          "1731:   mark_reg_unknown_value(regs, insn->dst_reg);",
          "1734:  dst_reg->type = UNKNOWN_VALUE;",
          "1738: static int evaluate_reg_imm_alu(struct bpf_verifier_env *env,",
          "1739:     struct bpf_insn *insn)",
          "1742:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1743:  struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1744:  u8 opcode = BPF_OP(insn->code);",
          "1745:  u64 dst_imm = dst_reg->imm;",
          "1747:  if (BPF_SRC(insn->code) == BPF_X && src_reg->type == UNKNOWN_VALUE)",
          "1748:   return evaluate_reg_imm_alu_unknown(env, insn);",
          "1754:  if (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_K) {",
          "1755:   dst_imm += insn->imm;",
          "1756:  } else if (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_X &&",
          "1757:      src_reg->type == CONST_IMM) {",
          "1758:   dst_imm += src_reg->imm;",
          "1759:  } else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_K) {",
          "1760:   dst_imm -= insn->imm;",
          "1761:  } else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_X &&",
          "1762:      src_reg->type == CONST_IMM) {",
          "1763:   dst_imm -= src_reg->imm;",
          "1764:  } else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_K) {",
          "1765:   dst_imm *= insn->imm;",
          "1766:  } else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_X &&",
          "1767:      src_reg->type == CONST_IMM) {",
          "1768:   dst_imm *= src_reg->imm;",
          "1769:  } else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_K) {",
          "1770:   dst_imm |= insn->imm;",
          "1771:  } else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_X &&",
          "1772:      src_reg->type == CONST_IMM) {",
          "1773:   dst_imm |= src_reg->imm;",
          "1774:  } else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_K) {",
          "1775:   dst_imm &= insn->imm;",
          "1776:  } else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_X &&",
          "1777:      src_reg->type == CONST_IMM) {",
          "1778:   dst_imm &= src_reg->imm;",
          "1779:  } else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_K) {",
          "1780:   dst_imm >>= insn->imm;",
          "1781:  } else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_X &&",
          "1782:      src_reg->type == CONST_IMM) {",
          "1783:   dst_imm >>= src_reg->imm;",
          "1784:  } else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_K) {",
          "1785:   dst_imm <<= insn->imm;",
          "1786:  } else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_X &&",
          "1787:      src_reg->type == CONST_IMM) {",
          "1788:   dst_imm <<= src_reg->imm;",
          "1789:  } else {",
          "1790:   mark_reg_unknown_value(regs, insn->dst_reg);",
          "1791:   goto out;",
          "1792:  }",
          "1794:  dst_reg->imm = dst_imm;",
          "1795: out:",
          "1796:  return 0;",
          "1797: }",
          "1799: static void check_reg_overflow(struct bpf_reg_state *reg)",
          "1800: {",
          "1801:  if (reg->max_value > BPF_REGISTER_MAX_RANGE)",
          "1802:   reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1803:  if (reg->min_value < BPF_REGISTER_MIN_RANGE ||",
          "1804:      reg->min_value > BPF_REGISTER_MAX_RANGE)",
          "1805:   reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1806: }",
          "1808: static u32 calc_align(u32 imm)",
          "1809: {",
          "1810:  if (!imm)",
          "1811:   return 1U << 31;",
          "1812:  return imm - ((imm - 1) & imm);",
          "1813: }",
          "1815: static void adjust_reg_min_max_vals(struct bpf_verifier_env *env,",
          "1816:         struct bpf_insn *insn)",
          "1817: {",
          "1818:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "1822:  u32 dst_align, src_align;",
          "1824:  dst_reg = &regs[insn->dst_reg];",
          "1825:  src_align = 0;",
          "1826:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1827:   check_reg_overflow(&regs[insn->src_reg]);",
          "1828:   min_val = regs[insn->src_reg].min_value;",
          "1829:   max_val = regs[insn->src_reg].max_value;",
          "1837:   if (regs[insn->src_reg].type != CONST_IMM &&",
          "1838:       regs[insn->src_reg].type != UNKNOWN_VALUE) {",
          "1839:    min_val = BPF_REGISTER_MIN_RANGE;",
          "1840:    max_val = BPF_REGISTER_MAX_RANGE;",
          "1841:    src_align = 0;",
          "1842:   } else {",
          "1843:    src_align = regs[insn->src_reg].min_align;",
          "1844:   }",
          "1845:  } else if (insn->imm < BPF_REGISTER_MAX_RANGE &&",
          "1846:      (s64)insn->imm > BPF_REGISTER_MIN_RANGE) {",
          "1847:   min_val = max_val = insn->imm;",
          "1848:   src_align = calc_align(insn->imm);",
          "1849:  }",
          "1851:  dst_align = dst_reg->min_align;",
          "1859:  if ((min_val == BPF_REGISTER_MIN_RANGE &&",
          "1860:       max_val == BPF_REGISTER_MAX_RANGE) ||",
          "1861:      (BPF_SRC(insn->code) == BPF_X &&",
          "1862:       ((min_val != BPF_REGISTER_MIN_RANGE &&",
          "1863:         max_val == BPF_REGISTER_MAX_RANGE) ||",
          "1864:        (min_val == BPF_REGISTER_MIN_RANGE &&",
          "1865:         max_val != BPF_REGISTER_MAX_RANGE) ||",
          "1866:        (dst_reg->min_value != BPF_REGISTER_MIN_RANGE &&",
          "1867:         dst_reg->max_value == BPF_REGISTER_MAX_RANGE) ||",
          "1868:        (dst_reg->min_value == BPF_REGISTER_MIN_RANGE &&",
          "1869:         dst_reg->max_value != BPF_REGISTER_MAX_RANGE)) &&",
          "1870:       regs[insn->dst_reg].value_from_signed !=",
          "1871:       regs[insn->src_reg].value_from_signed)) {",
          "1872:   reset_reg_range_values(regs, insn->dst_reg);",
          "1873:   return;",
          "1874:  }",
          "1880:  if (opcode != BPF_SUB) {",
          "1881:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1882:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1883:   if (max_val == BPF_REGISTER_MAX_RANGE)",
          "1884:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1893:   dst_reg->min_align = min(src_align, dst_align);",
          "1899:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1900:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1907:   dst_reg->min_align = min(src_align, dst_align);",
          "1910:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1911:    dst_reg->min_value *= min_val;",
          "1914:   dst_reg->min_align = max(src_align, dst_align);",
          "1921:   if (min_val < 0)",
          "1924:    dst_reg->min_value = 0;",
          "1925:   dst_reg->max_value = max_val;",
          "1926:   dst_reg->min_align = max(src_align, dst_align);",
          "1935:    dst_reg->min_align = 1;",
          "1939:    if (!dst_reg->min_align)",
          "1940:     dst_reg->min_align = 1;",
          "1941:    dst_reg->min_align <<= min_val;",
          "",
          "[Added Lines]",
          "1603: static void check_reg_overflow(struct bpf_reg_state *reg)",
          "1605:  if (reg->max_value > BPF_REGISTER_MAX_RANGE)",
          "1606:   reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1607:  if (reg->min_value < BPF_REGISTER_MIN_RANGE ||",
          "1608:      reg->min_value > BPF_REGISTER_MAX_RANGE)",
          "1609:   reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1610: }",
          "1612: static void coerce_reg_to_32(struct bpf_reg_state *reg)",
          "1613: {",
          "1615:  if (reg->min_value < 0)",
          "1616:   reg->min_value = 0;",
          "1618:  reg->var_off = tnum_cast(reg->var_off, 4);",
          "1620:  if (tnum_is_const(reg->var_off)) {",
          "1621:   if ((s64)reg->var_off.value > BPF_REGISTER_MIN_RANGE)",
          "1622:    reg->min_value = reg->var_off.value;",
          "1623:   if (reg->var_off.value < BPF_REGISTER_MAX_RANGE)",
          "1624:    reg->max_value = reg->var_off.value;",
          "1634: static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,",
          "1635:        struct bpf_insn *insn,",
          "1636:        const struct bpf_reg_state *ptr_reg,",
          "1637:        const struct bpf_reg_state *off_reg)",
          "1639:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "1640:  bool known = tnum_is_const(off_reg->var_off);",
          "1641:  s64 min_val = off_reg->min_value;",
          "1642:  u64 max_val = off_reg->max_value;",
          "1644:  u32 dst = insn->dst_reg;",
          "1646:  dst_reg = &regs[dst];",
          "1648:  if (WARN_ON_ONCE(known && (min_val != max_val))) {",
          "1649:   print_verifier_state(&env->cur_state);",
          "1650:   verbose(\"verifier internal error\\n\");",
          "1651:   return -EINVAL;",
          "1652:  }",
          "1654:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1656:   if (!env->allow_ptr_leaks)",
          "1657:    verbose(\"R%d 32-bit pointer arithmetic prohibited\\n\",",
          "1658:     dst);",
          "1659:   return -EACCES;",
          "1662:  if (ptr_reg->type == PTR_TO_MAP_VALUE_OR_NULL) {",
          "1663:   if (!env->allow_ptr_leaks)",
          "1664:    verbose(\"R%d pointer arithmetic on PTR_TO_MAP_VALUE_OR_NULL prohibited, null-check it first\\n\",",
          "1665:     dst);",
          "1666:   return -EACCES;",
          "1667:  }",
          "1668:  if (ptr_reg->type == CONST_PTR_TO_MAP) {",
          "1669:   if (!env->allow_ptr_leaks)",
          "1670:    verbose(\"R%d pointer arithmetic on CONST_PTR_TO_MAP prohibited\\n\",",
          "1671:     dst);",
          "1672:   return -EACCES;",
          "1673:  }",
          "1674:  if (ptr_reg->type == PTR_TO_PACKET_END) {",
          "1675:   if (!env->allow_ptr_leaks)",
          "1676:    verbose(\"R%d pointer arithmetic on PTR_TO_PACKET_END prohibited\\n\",",
          "1677:     dst);",
          "1678:   return -EACCES;",
          "1679:  }",
          "1684:  dst_reg->type = ptr_reg->type;",
          "1685:  dst_reg->id = ptr_reg->id;",
          "1687:  switch (opcode) {",
          "1688:  case BPF_ADD:",
          "1692:   if (known && (ptr_reg->off + min_val ==",
          "1693:          (s64)(s32)(ptr_reg->off + min_val))) {",
          "1695:    dst_reg->min_value = ptr_reg->min_value;",
          "1696:    dst_reg->max_value = ptr_reg->max_value;",
          "1697:    dst_reg->var_off = ptr_reg->var_off;",
          "1698:    dst_reg->off = ptr_reg->off + min_val;",
          "1699:    dst_reg->range = ptr_reg->range;",
          "1700:    break;",
          "1701:   }",
          "1702:   if (max_val == BPF_REGISTER_MAX_RANGE) {",
          "1703:    if (!env->allow_ptr_leaks)",
          "1704:     verbose(\"R%d tried to add unbounded value to pointer\\n\",",
          "1705:      dst);",
          "1706:    return -EACCES;",
          "1707:   }",
          "1717:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1718:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1719:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1720:    dst_reg->min_value += min_val;",
          "1721:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1722:    dst_reg->max_value += max_val;",
          "1723:   dst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);",
          "1724:   dst_reg->off = ptr_reg->off;",
          "1725:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "1726:    dst_reg->id = ++env->id_gen;",
          "1728:    dst_reg->range = 0;",
          "1729:   }",
          "1730:   break;",
          "1731:  case BPF_SUB:",
          "1732:   if (dst_reg == off_reg) {",
          "1734:    if (!env->allow_ptr_leaks)",
          "1735:     verbose(\"R%d tried to subtract pointer from scalar\\n\",",
          "1736:      dst);",
          "1737:    return -EACCES;",
          "1738:   }",
          "1743:   if (ptr_reg->type == PTR_TO_STACK) {",
          "1744:    if (!env->allow_ptr_leaks)",
          "1745:     verbose(\"R%d subtraction from stack pointer prohibited\\n\",",
          "1746:      dst);",
          "1747:    return -EACCES;",
          "1748:   }",
          "1749:   if (known && (ptr_reg->off - min_val ==",
          "1750:          (s64)(s32)(ptr_reg->off - min_val))) {",
          "1752:    dst_reg->min_value = ptr_reg->min_value;",
          "1753:    dst_reg->max_value = ptr_reg->max_value;",
          "1754:    dst_reg->var_off = ptr_reg->var_off;",
          "1755:    dst_reg->id = ptr_reg->id;",
          "1756:    dst_reg->off = ptr_reg->off - min_val;",
          "1757:    dst_reg->range = ptr_reg->range;",
          "1758:    break;",
          "1759:   }",
          "1763:   if ((s64)max_val < 0) {",
          "1764:    if (!env->allow_ptr_leaks)",
          "1765:     verbose(\"R%d tried to subtract negative max_val %lld from pointer\\n\",",
          "1766:      dst, (s64)max_val);",
          "1767:    return -EACCES;",
          "1768:   }",
          "1772:   if (max_val >= BPF_REGISTER_MAX_RANGE)",
          "1773:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1774:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1775:    dst_reg->min_value -= max_val;",
          "1776:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1777:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1778:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1779:    dst_reg->max_value -= min_val;",
          "1780:   dst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);",
          "1781:   dst_reg->off = ptr_reg->off;",
          "1782:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "1783:    dst_reg->id = ++env->id_gen;",
          "1785:    if (min_val < 0)",
          "1786:     dst_reg->range = 0;",
          "1788:   break;",
          "1789:  case BPF_AND:",
          "1790:  case BPF_OR:",
          "1791:  case BPF_XOR:",
          "1796:   if (!env->allow_ptr_leaks)",
          "1797:    verbose(\"R%d bitwise operator %s on pointer prohibited\\n\",",
          "1798:     dst, bpf_alu_string[opcode >> 4]);",
          "1799:   return -EACCES;",
          "1800:  default:",
          "1802:   if (!env->allow_ptr_leaks)",
          "1803:    verbose(\"R%d pointer arithmetic with %s operator prohibited\\n\",",
          "1804:     dst, bpf_alu_string[opcode >> 4]);",
          "1805:   return -EACCES;",
          "1808:  check_reg_overflow(dst_reg);",
          "1812: static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,",
          "1813:           struct bpf_insn *insn,",
          "1814:           struct bpf_reg_state *dst_reg,",
          "1815:           struct bpf_reg_state src_reg)",
          "1821:  bool src_known, dst_known;",
          "1823:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1825:   coerce_reg_to_32(dst_reg);",
          "1826:   coerce_reg_to_32(&src_reg);",
          "1828:  min_val = src_reg.min_value;",
          "1829:  max_val = src_reg.max_value;",
          "1830:  src_known = tnum_is_const(src_reg.var_off);",
          "1831:  dst_known = tnum_is_const(dst_reg->var_off);",
          "1835:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1836:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1842:   dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);",
          "1849:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1850:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1853:   dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);",
          "1856:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1858:    __mark_reg_unknown(dst_reg);",
          "1859:    break;",
          "1860:   }",
          "1861:   dst_reg->min_value *= min_val;",
          "1866:   BUILD_BUG_ON(BPF_REGISTER_MAX_RANGE > (u32)-1);",
          "1869:   dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);",
          "1872:   if (src_known && dst_known) {",
          "1873:    u64 value = dst_reg->var_off.value & src_reg.var_off.value;",
          "1875:    dst_reg->var_off = tnum_const(value);",
          "1876:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1877:      value, BPF_REGISTER_MAX_RANGE);",
          "1878:    break;",
          "1879:   }",
          "1885:   dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);",
          "1886:   if (min_val < 0 && dst_reg->min_value < 0)",
          "1889:    dst_reg->min_value = dst_reg->var_off.value;",
          "1890:   dst_reg->max_value = min(dst_reg->max_value, max_val);",
          "1891:   break;",
          "1892:  case BPF_OR:",
          "1893:   if (src_known && dst_known) {",
          "1894:    u64 value = dst_reg->var_off.value | src_reg.var_off.value;",
          "1896:    dst_reg->var_off = tnum_const(value);",
          "1897:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1898:      value, BPF_REGISTER_MAX_RANGE);",
          "1899:    break;",
          "1900:   }",
          "1905:   dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);",
          "1906:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1907:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1908:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1909:   } else {",
          "1910:    dst_reg->min_value = max(dst_reg->min_value, min_val);",
          "1911:    dst_reg->max_value = dst_reg->var_off.value | dst_reg->var_off.mask;",
          "1912:   }",
          "1915:   if (min_val < 0) {",
          "1917:    mark_reg_unknown(regs, insn->dst_reg);",
          "1918:    break;",
          "1919:   }",
          "1926:    dst_reg->var_off = tnum_unknown;",
          "1930:    if (src_known)",
          "1931:     dst_reg->var_off = tnum_lshift(dst_reg->var_off, min_val);",
          "1932:    else",
          "1933:     dst_reg->var_off = tnum_lshift(tnum_unknown, min_val);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1946:    dst_reg->max_value <<= max_val;",
          "1947:   break;",
          "1948:  case BPF_RSH:",
          "1954:   } else {",
          "1955:    dst_reg->min_value =",
          "1956:     (u64)(dst_reg->min_value) >> min_val;",
          "1957:   }",
          "1967:   break;",
          "1968:  default:",
          "1970:   break;",
          "1971:  }",
          "1973:  check_reg_overflow(dst_reg);",
          "1974: }",
          "1977: static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)",
          "1978: {",
          "1980:  u8 opcode = BPF_OP(insn->code);",
          "1981:  int err;",
          "",
          "[Removed Lines]",
          "1952:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1953:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1958:   if (min_val < 0) {",
          "1959:    dst_reg->min_align = 1;",
          "1960:   } else {",
          "1961:    dst_reg->min_align >>= (u64) min_val;",
          "1962:    if (!dst_reg->min_align)",
          "1963:     dst_reg->min_align = 1;",
          "1964:   }",
          "1965:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1966:    dst_reg->max_value >>= max_val;",
          "1969:   reset_reg_range_values(regs, insn->dst_reg);",
          "1979:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "",
          "[Added Lines]",
          "1941:   if (min_val < 0) {",
          "1943:    mark_reg_unknown(regs, insn->dst_reg);",
          "1944:    break;",
          "1945:   }",
          "1947:   if (dst_reg->min_value < 0) {",
          "1948:    if (min_val)",
          "1950:     dst_reg->min_value = 0;",
          "1955:   if (src_known)",
          "1956:    dst_reg->var_off = tnum_rshift(dst_reg->var_off, min_val);",
          "1957:   else",
          "1958:    dst_reg->var_off = tnum_rshift(tnum_unknown, min_val);",
          "1959:   if (dst_reg->max_value == BPF_REGISTER_MAX_RANGE)",
          "1960:    dst_reg->max_value = ~0;",
          "1961:   dst_reg->max_value >>= max_val;",
          "1964:   mark_reg_unknown(regs, insn->dst_reg);",
          "1969:  return 0;",
          "1970: }",
          "1975: static int adjust_reg_min_max_vals(struct bpf_verifier_env *env,",
          "1976:        struct bpf_insn *insn)",
          "1977: {",
          "1978:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg, *src_reg;",
          "1979:  struct bpf_reg_state *ptr_reg = NULL, off_reg = {0};",
          "1980:  u8 opcode = BPF_OP(insn->code);",
          "1981:  int rc;",
          "1983:  dst_reg = &regs[insn->dst_reg];",
          "1984:  check_reg_overflow(dst_reg);",
          "1985:  src_reg = NULL;",
          "1986:  if (dst_reg->type != SCALAR_VALUE)",
          "1987:   ptr_reg = dst_reg;",
          "1988:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1989:   src_reg = &regs[insn->src_reg];",
          "1990:   check_reg_overflow(src_reg);",
          "1992:   if (src_reg->type != SCALAR_VALUE) {",
          "1993:    if (dst_reg->type != SCALAR_VALUE) {",
          "1997:     if (!env->allow_ptr_leaks) {",
          "1998:      verbose(\"R%d pointer %s pointer prohibited\\n\",",
          "1999:       insn->dst_reg,",
          "2000:       bpf_alu_string[opcode >> 4]);",
          "2001:      return -EACCES;",
          "2002:     }",
          "2003:     mark_reg_unknown(regs, insn->dst_reg);",
          "2004:     return 0;",
          "2005:    } else {",
          "2010:     rc = adjust_ptr_min_max_vals(env, insn,",
          "2011:             src_reg, dst_reg);",
          "2012:     if (rc == -EACCES && env->allow_ptr_leaks) {",
          "2014:      __mark_reg_unknown(&off_reg);",
          "2015:      return adjust_scalar_min_max_vals(",
          "2016:        env, insn,",
          "2017:        dst_reg, off_reg);",
          "2018:     }",
          "2019:     return rc;",
          "2020:    }",
          "2021:   } else if (ptr_reg) {",
          "2023:    rc = adjust_ptr_min_max_vals(env, insn,",
          "2024:            dst_reg, src_reg);",
          "2025:    if (rc == -EACCES && env->allow_ptr_leaks) {",
          "2027:     __mark_reg_unknown(dst_reg);",
          "2028:     return adjust_scalar_min_max_vals(",
          "2029:       env, insn, dst_reg, *src_reg);",
          "2030:    }",
          "2031:    return rc;",
          "2032:   }",
          "2033:  } else {",
          "2037:   off_reg.type = SCALAR_VALUE;",
          "2038:   off_reg.var_off = tnum_const(insn->imm);",
          "2039:   off_reg.min_value = insn->imm;",
          "2040:   off_reg.max_value = insn->imm;",
          "2041:   src_reg = &off_reg;",
          "2042:   check_reg_overflow(src_reg);",
          "2044:    rc = adjust_ptr_min_max_vals(env, insn,",
          "2045:            ptr_reg, src_reg);",
          "2046:    if (rc == -EACCES && env->allow_ptr_leaks) {",
          "2048:     __mark_reg_unknown(dst_reg);",
          "2049:     return adjust_scalar_min_max_vals(",
          "2050:       env, insn, dst_reg, off_reg);",
          "2051:    }",
          "2052:    return rc;",
          "2053:   }",
          "2054:  }",
          "2057:  if (WARN_ON_ONCE(ptr_reg)) {",
          "2058:   print_verifier_state(&env->cur_state);",
          "2059:   verbose(\"verifier internal error: unexpected ptr_reg\\n\");",
          "2060:   return -EINVAL;",
          "2061:  }",
          "2062:  if (WARN_ON(!src_reg)) {",
          "2063:   print_verifier_state(&env->cur_state);",
          "2064:   verbose(\"verifier internal error: no src_reg\\n\");",
          "2065:   return -EINVAL;",
          "2066:  }",
          "2067:  return adjust_scalar_min_max_vals(env, insn, dst_reg, *src_reg);",
          "2073:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2036:   if (err)",
          "2037:    return err;",
          "2044:   if (BPF_SRC(insn->code) == BPF_X) {",
          "2045:    if (BPF_CLASS(insn->code) == BPF_ALU64) {",
          "",
          "[Removed Lines]",
          "2042:   reset_reg_range_values(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2049:     regs[insn->dst_reg] = regs[insn->src_reg];",
          "2050:    } else {",
          "2051:     if (is_pointer_value(env, insn->src_reg)) {",
          "2052:      verbose(\"R%d partial copy of pointer\\n\",",
          "2053:       insn->src_reg);",
          "2054:      return -EACCES;",
          "2055:     }",
          "2057:    }",
          "2058:   } else {",
          "2065:    regs[insn->dst_reg].max_value = insn->imm;",
          "2066:    regs[insn->dst_reg].min_value = insn->imm;",
          "2069:   }",
          "2071:  } else if (opcode > BPF_END) {",
          "",
          "[Removed Lines]",
          "2056:     mark_reg_unknown_value(regs, insn->dst_reg);",
          "2062:    regs[insn->dst_reg].type = CONST_IMM;",
          "2063:    regs[insn->dst_reg].imm = insn->imm;",
          "2064:    regs[insn->dst_reg].id = 0;",
          "2067:    regs[insn->dst_reg].min_align = calc_align(insn->imm);",
          "2068:    regs[insn->dst_reg].value_from_signed = false;",
          "",
          "[Added Lines]",
          "2146:     mark_reg_unknown(regs, insn->dst_reg);",
          "2151:     regs[insn->dst_reg].var_off = tnum_cast(",
          "2152:       regs[insn->dst_reg].var_off, 4);",
          "2158:    regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2159:    regs[insn->dst_reg].var_off = tnum_const(insn->imm);",
          "2162:    regs[insn->dst_reg].id = 0;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2116:   if (err)",
          "2117:    return err;",
          "2181:  }",
          "2183:  return 0;",
          "",
          "[Removed Lines]",
          "2119:   dst_reg = &regs[insn->dst_reg];",
          "2122:   adjust_reg_min_max_vals(env, insn);",
          "2125:   if (opcode == BPF_ADD && BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2126:       dst_reg->type == FRAME_PTR && BPF_SRC(insn->code) == BPF_K) {",
          "2127:    dst_reg->type = PTR_TO_STACK;",
          "2128:    dst_reg->imm = insn->imm;",
          "2129:    return 0;",
          "2130:   } else if (opcode == BPF_ADD &&",
          "2131:       BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2132:       dst_reg->type == PTR_TO_STACK &&",
          "2133:       ((BPF_SRC(insn->code) == BPF_X &&",
          "2134:         regs[insn->src_reg].type == CONST_IMM) ||",
          "2135:        BPF_SRC(insn->code) == BPF_K)) {",
          "2136:    if (BPF_SRC(insn->code) == BPF_X)",
          "2137:     dst_reg->imm += regs[insn->src_reg].imm;",
          "2138:    else",
          "2139:     dst_reg->imm += insn->imm;",
          "2140:    return 0;",
          "2141:   } else if (opcode == BPF_ADD &&",
          "2142:       BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2143:       (dst_reg->type == PTR_TO_PACKET ||",
          "2144:        (BPF_SRC(insn->code) == BPF_X &&",
          "2145:         regs[insn->src_reg].type == PTR_TO_PACKET))) {",
          "2147:    return check_packet_ptr_add(env, insn);",
          "2148:   } else if (BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2149:       dst_reg->type == UNKNOWN_VALUE &&",
          "2150:       env->allow_ptr_leaks) {",
          "2152:    return evaluate_reg_alu(env, insn);",
          "2153:   } else if (BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2154:       dst_reg->type == CONST_IMM &&",
          "2155:       env->allow_ptr_leaks) {",
          "2157:    return evaluate_reg_imm_alu(env, insn);",
          "2158:   } else if (is_pointer_value(env, insn->dst_reg)) {",
          "2159:    verbose(\"R%d pointer arithmetic prohibited\\n\",",
          "2160:     insn->dst_reg);",
          "2161:    return -EACCES;",
          "2162:   } else if (BPF_SRC(insn->code) == BPF_X &&",
          "2163:       is_pointer_value(env, insn->src_reg)) {",
          "2164:    verbose(\"R%d pointer arithmetic prohibited\\n\",",
          "2165:     insn->src_reg);",
          "2166:    return -EACCES;",
          "2167:   }",
          "2174:   if (env->allow_ptr_leaks &&",
          "2175:       BPF_CLASS(insn->code) == BPF_ALU64 && opcode == BPF_ADD &&",
          "2176:       (dst_reg->type == PTR_TO_MAP_VALUE ||",
          "2177:        dst_reg->type == PTR_TO_MAP_VALUE_ADJ))",
          "2178:    dst_reg->type = PTR_TO_MAP_VALUE_ADJ;",
          "2179:   else",
          "2180:    mark_reg_unknown_value(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2213:   return adjust_reg_min_max_vals(env, insn);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2189:  struct bpf_reg_state *regs = state->regs, *reg;",
          "2190:  int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2225:  if (dst_reg->off < 0)",
          "2227:   return;",
          "2229:  if (dst_reg->max_value > MAX_PACKET_OFF ||",
          "2230:      dst_reg->max_value + dst_reg->off > MAX_PACKET_OFF)",
          "2234:   return;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "2222:  for (i = 0; i < MAX_BPF_REG; i++)",
          "2223:   if (regs[i].type == PTR_TO_PACKET && regs[i].id == dst_reg->id)",
          "2227:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "2228:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "2229:    continue;",
          "2230:   reg = &state->spilled_regs[i / BPF_REG_SIZE];",
          "2231:   if (reg->type == PTR_TO_PACKET && reg->id == dst_reg->id)",
          "2233:  }",
          "2234: }",
          "2240: static void reg_set_min_max(struct bpf_reg_state *true_reg,",
          "2241:        struct bpf_reg_state *false_reg, u64 val,",
          "2242:        u8 opcode)",
          "2243: {",
          "2244:  bool value_from_signed = true;",
          "2247:  switch (opcode) {",
          "2248:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "2225:    regs[i].range = max(regs[i].range, dst_reg->off);",
          "2232:    reg->range = max(reg->range, dst_reg->off);",
          "2245:  bool is_range = true;",
          "",
          "[Added Lines]",
          "2274:    regs[i].range = max_t(u16, regs[i].range, dst_reg->off);",
          "2281:    reg->range = max_t(u16, reg->range, dst_reg->off);",
          "2302:  if (__is_pointer_value(false, false_reg))",
          "2303:   return;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2252:   true_reg->max_value = true_reg->min_value = val;",
          "2254:   break;",
          "2255:  case BPF_JNE:",
          "2259:   false_reg->max_value = false_reg->min_value = val;",
          "2261:   break;",
          "2262:  case BPF_JGT:",
          "2263:   value_from_signed = false;",
          "",
          "[Removed Lines]",
          "2253:   is_range = false;",
          "2260:   is_range = false;",
          "",
          "[Added Lines]",
          "2311:   true_reg->var_off = tnum_const(val);",
          "2318:   false_reg->var_off = tnum_const(val);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2306:  check_reg_overflow(false_reg);",
          "2307:  check_reg_overflow(true_reg);",
          "2314: }",
          "2319: static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,",
          "2320:     struct bpf_reg_state *false_reg, u64 val,",
          "2321:     u8 opcode)",
          "2322: {",
          "2323:  bool value_from_signed = true;",
          "2326:  switch (opcode) {",
          "2327:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "2308:  if (is_range) {",
          "2309:   if (__is_pointer_value(false, false_reg))",
          "2310:    reset_reg_range_values(false_reg, 0);",
          "2311:   if (__is_pointer_value(false, true_reg))",
          "2312:    reset_reg_range_values(true_reg, 0);",
          "2313:  }",
          "2324:  bool is_range = true;",
          "",
          "[Added Lines]",
          "2377:  if (__is_pointer_value(false, false_reg))",
          "2378:   return;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2331:   true_reg->max_value = true_reg->min_value = val;",
          "2333:   break;",
          "2334:  case BPF_JNE:",
          "2338:   false_reg->max_value = false_reg->min_value = val;",
          "2340:   break;",
          "2341:  case BPF_JGT:",
          "2342:   value_from_signed = false;",
          "",
          "[Removed Lines]",
          "2332:   is_range = false;",
          "2339:   is_range = false;",
          "",
          "[Added Lines]",
          "2386:   true_reg->var_off = tnum_const(val);",
          "2393:   false_reg->var_off = tnum_const(val);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2386:  check_reg_overflow(false_reg);",
          "2387:  check_reg_overflow(true_reg);",
          "2393:  }",
          "2394: }",
          "2396: static void mark_map_reg(struct bpf_reg_state *regs, u32 regno, u32 id,",
          "2398: {",
          "2399:  struct bpf_reg_state *reg = &regs[regno];",
          "2401:  if (reg->type == PTR_TO_MAP_VALUE_OR_NULL && reg->id == id) {",
          "2404:   } else if (reg->map_ptr->inner_map_meta) {",
          "2405:    reg->type = CONST_PTR_TO_MAP;",
          "2406:    reg->map_ptr = reg->map_ptr->inner_map_meta;",
          "2407:   } else {",
          "2409:   }",
          "",
          "[Removed Lines]",
          "2388:  if (is_range) {",
          "2389:   if (__is_pointer_value(false, false_reg))",
          "2390:    reset_reg_range_values(false_reg, 0);",
          "2391:   if (__is_pointer_value(false, true_reg))",
          "2392:    reset_reg_range_values(true_reg, 0);",
          "2397:     enum bpf_reg_type type)",
          "2402:   if (type == UNKNOWN_VALUE) {",
          "2403:    __mark_reg_unknown_value(regs, regno);",
          "2408:    reg->type = type;",
          "",
          "[Added Lines]",
          "2442: }",
          "2445: static void __reg_combine_min_max(struct bpf_reg_state *src_reg,",
          "2446:       struct bpf_reg_state *dst_reg)",
          "2447: {",
          "2448:  src_reg->min_value = dst_reg->min_value = max(src_reg->min_value,",
          "2449:             dst_reg->min_value);",
          "2450:  src_reg->max_value = dst_reg->max_value = min(src_reg->max_value,",
          "2451:             dst_reg->max_value);",
          "2452:  src_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,",
          "2453:             dst_reg->var_off);",
          "2454:  check_reg_overflow(src_reg);",
          "2455:  check_reg_overflow(dst_reg);",
          "2456: }",
          "2458: static void reg_combine_min_max(struct bpf_reg_state *true_src,",
          "2459:     struct bpf_reg_state *true_dst,",
          "2460:     struct bpf_reg_state *false_src,",
          "2461:     struct bpf_reg_state *false_dst,",
          "2462:     u8 opcode)",
          "2463: {",
          "2464:  switch (opcode) {",
          "2465:  case BPF_JEQ:",
          "2466:   __reg_combine_min_max(true_src, true_dst);",
          "2467:   break;",
          "2468:  case BPF_JNE:",
          "2469:   __reg_combine_min_max(false_src, false_dst);",
          "2474:     bool is_null)",
          "2483:   if (WARN_ON_ONCE(reg->min_value || reg->max_value ||",
          "2484:      reg->var_off.value || reg->var_off.mask ||",
          "2485:      reg->off)) {",
          "2486:    reg->min_value = reg->max_value = reg->off = 0;",
          "2487:    reg->var_off = tnum_const(0);",
          "2488:   }",
          "2489:   if (is_null) {",
          "2490:    reg->type = SCALAR_VALUE;",
          "2495:    reg->type = PTR_TO_MAP_VALUE;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2421: static void mark_map_regs(struct bpf_verifier_state *state, u32 regno,",
          "2423: {",
          "2424:  struct bpf_reg_state *regs = state->regs;",
          "2425:  u32 id = regs[regno].id;",
          "2426:  int i;",
          "2428:  for (i = 0; i < MAX_BPF_REG; i++)",
          "2431:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "2432:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "2433:    continue;",
          "2435:  }",
          "2436: }",
          "",
          "[Removed Lines]",
          "2422:      enum bpf_reg_type type)",
          "2429:   mark_map_reg(regs, i, id, type);",
          "2434:   mark_map_reg(state->spilled_regs, i / BPF_REG_SIZE, id, type);",
          "",
          "[Added Lines]",
          "2509:      bool is_null)",
          "2516:   mark_map_reg(regs, i, id, is_null);",
          "2521:   mark_map_reg(state->spilled_regs, i / BPF_REG_SIZE, id, is_null);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2482:  if (BPF_SRC(insn->code) == BPF_K &&",
          "2483:      (opcode == BPF_JEQ || opcode == BPF_JNE) &&",
          "2485:   if (opcode == BPF_JEQ) {",
          "",
          "[Removed Lines]",
          "2484:      dst_reg->type == CONST_IMM && dst_reg->imm == insn->imm) {",
          "",
          "[Added Lines]",
          "2571:      dst_reg->type == SCALAR_VALUE &&",
          "2572:      tnum_equals_const(dst_reg->var_off, insn->imm)) {",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2507:  if (BPF_SRC(insn->code) == BPF_X) {",
          "2517:   reg_set_min_max(&other_branch->regs[insn->dst_reg],",
          "2518:      dst_reg, insn->imm, opcode);",
          "2519:  }",
          "",
          "[Removed Lines]",
          "2508:   if (regs[insn->src_reg].type == CONST_IMM)",
          "2509:    reg_set_min_max(&other_branch->regs[insn->dst_reg],",
          "2510:      dst_reg, regs[insn->src_reg].imm,",
          "2511:      opcode);",
          "2512:   else if (dst_reg->type == CONST_IMM)",
          "2513:    reg_set_min_max_inv(&other_branch->regs[insn->src_reg],",
          "2514:          &regs[insn->src_reg], dst_reg->imm,",
          "2515:          opcode);",
          "2516:  } else {",
          "",
          "[Added Lines]",
          "2600:   if (dst_reg->type == SCALAR_VALUE &&",
          "2601:       regs[insn->src_reg].type == SCALAR_VALUE) {",
          "2602:    if (tnum_is_const(regs[insn->src_reg].var_off))",
          "2603:     reg_set_min_max(&other_branch->regs[insn->dst_reg],",
          "2604:       dst_reg, regs[insn->src_reg].var_off.value,",
          "2605:       opcode);",
          "2606:    else if (tnum_is_const(dst_reg->var_off))",
          "2607:     reg_set_min_max_inv(&other_branch->regs[insn->src_reg],",
          "2608:           &regs[insn->src_reg],",
          "2609:           dst_reg->var_off.value, opcode);",
          "2610:    else if (opcode == BPF_JEQ || opcode == BPF_JNE)",
          "2612:     reg_combine_min_max(&other_branch->regs[insn->src_reg],",
          "2613:           &other_branch->regs[insn->dst_reg],",
          "2614:           &regs[insn->src_reg],",
          "2615:           &regs[insn->dst_reg], opcode);",
          "2616:   }",
          "2617:  } else if (dst_reg->type == SCALAR_VALUE) {",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2532:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGT &&",
          "2533:      dst_reg->type == PTR_TO_PACKET &&",
          "2534:      regs[insn->src_reg].type == PTR_TO_PACKET_END) {",
          "",
          "[Removed Lines]",
          "2528:   mark_map_regs(this_branch, insn->dst_reg,",
          "2529:          opcode == BPF_JEQ ? PTR_TO_MAP_VALUE : UNKNOWN_VALUE);",
          "2530:   mark_map_regs(other_branch, insn->dst_reg,",
          "2531:          opcode == BPF_JEQ ? UNKNOWN_VALUE : PTR_TO_MAP_VALUE);",
          "",
          "[Added Lines]",
          "2629:   mark_map_regs(this_branch, insn->dst_reg, opcode == BPF_JNE);",
          "2630:   mark_map_regs(other_branch, insn->dst_reg, opcode == BPF_JEQ);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2576:  if (insn->src_reg == 0) {",
          "2577:   u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
          "2581:   regs[insn->dst_reg].id = 0;",
          "2582:   return 0;",
          "2583:  }",
          "",
          "[Removed Lines]",
          "2579:   regs[insn->dst_reg].type = CONST_IMM;",
          "2580:   regs[insn->dst_reg].imm = imm;",
          "",
          "[Added Lines]",
          "2678:   regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2679:   regs[insn->dst_reg].min_value = imm;",
          "2680:   regs[insn->dst_reg].max_value = imm;",
          "2681:   check_reg_overflow(&regs[insn->dst_reg]);",
          "2682:   regs[insn->dst_reg].var_off = tnum_const(imm);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2663:  return 0;",
          "2664: }",
          "",
          "[Removed Lines]",
          "2662:  regs[BPF_REG_0].type = UNKNOWN_VALUE;",
          "",
          "[Added Lines]",
          "2764:  mark_reg_unknown(regs, BPF_REG_0);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2862:  return ret;",
          "2863: }",
          "2871: {",
          "2884:   return true;",
          "2914:   return true;",
          "2916:  return false;",
          "2917: }",
          "",
          "[Removed Lines]",
          "2868: static bool compare_ptrs_to_packet(struct bpf_verifier_env *env,",
          "2869:        struct bpf_reg_state *old,",
          "2870:        struct bpf_reg_state *cur)",
          "2872:  if (old->id != cur->id)",
          "2873:   return false;",
          "2883:  if (old->off == cur->off && old->range < cur->range)",
          "2912:  if (!env->strict_alignment && old->off <= cur->off &&",
          "2913:      old->off >= old->range && cur->off >= cur->range)",
          "",
          "[Added Lines]",
          "2968: static bool range_within(struct bpf_reg_state *old,",
          "2969:     struct bpf_reg_state *cur)",
          "2970: {",
          "2971:  return old->min_value <= cur->min_value &&",
          "2972:         old->max_value >= cur->max_value;",
          "2973: }",
          "2976: #define ID_MAP_SIZE (MAX_BPF_REG + MAX_BPF_STACK / BPF_REG_SIZE)",
          "2977: struct idpair {",
          "2978:  u32 old;",
          "2979:  u32 cur;",
          "2980: };",
          "2992: static bool check_ids(u32 old_id, u32 cur_id, struct idpair *idmap)",
          "2994:  unsigned int i;",
          "2996:  for (i = 0; i < ID_MAP_SIZE; i++) {",
          "2997:   if (!idmap[i].old) {",
          "2999:    idmap[i].old = old_id;",
          "3000:    idmap[i].cur = cur_id;",
          "3001:    return true;",
          "3002:   }",
          "3003:   if (idmap[i].old == old_id)",
          "3004:    return idmap[i].cur == cur_id;",
          "3005:  }",
          "3007:  WARN_ON_ONCE(1);",
          "3008:  return false;",
          "3009: }",
          "3012: static bool regsafe(struct bpf_reg_state *rold,",
          "3013:       struct bpf_reg_state *rcur,",
          "3014:       bool varlen_map_access, struct idpair *idmap)",
          "3015: {",
          "3016:  if (memcmp(rold, rcur, sizeof(*rold)) == 0)",
          "3019:  if (rold->type == NOT_INIT)",
          "3022:  if (rcur->type == NOT_INIT)",
          "3023:   return false;",
          "3024:  switch (rold->type) {",
          "3025:  case SCALAR_VALUE:",
          "3026:   if (rcur->type == SCALAR_VALUE) {",
          "3028:    return range_within(rold, rcur) &&",
          "3029:           tnum_in(rold->var_off, rcur->var_off);",
          "3030:   } else {",
          "3035:    return rold->min_value == BPF_REGISTER_MIN_RANGE &&",
          "3036:           rold->max_value == BPF_REGISTER_MAX_RANGE &&",
          "3037:           tnum_is_unknown(rold->var_off);",
          "3038:   }",
          "3039:  case PTR_TO_MAP_VALUE:",
          "3040:   if (varlen_map_access) {",
          "3046:    return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&",
          "3047:           range_within(rold, rcur) &&",
          "3048:           tnum_in(rold->var_off, rcur->var_off);",
          "3049:   } else {",
          "3054:    return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0;",
          "3055:   }",
          "3056:  case PTR_TO_MAP_VALUE_OR_NULL:",
          "3064:   if (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)",
          "3065:    return false;",
          "3066:   if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))",
          "3067:    return false;",
          "3069:   return check_ids(rold->id, rcur->id, idmap);",
          "3070:  case PTR_TO_PACKET:",
          "3071:   if (rcur->type != PTR_TO_PACKET)",
          "3072:    return false;",
          "3079:   if (rold->range > rcur->range)",
          "3080:    return false;",
          "3084:   if (rold->off != rcur->off)",
          "3085:    return false;",
          "3087:   if (rold->id && !check_ids(rold->id, rcur->id, idmap))",
          "3088:    return false;",
          "3090:   return range_within(rold, rcur) &&",
          "3091:          tnum_in(rold->var_off, rcur->var_off);",
          "3092:  case PTR_TO_CTX:",
          "3093:  case CONST_PTR_TO_MAP:",
          "3094:  case PTR_TO_STACK:",
          "3095:  case PTR_TO_PACKET_END:",
          "3099:  default:",
          "3101:   return false;",
          "3102:  }",
          "3105:  WARN_ON_ONCE(1);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2947:     struct bpf_verifier_state *cur)",
          "2948: {",
          "2949:  bool varlen_map_access = env->varlen_map_value_access;",
          "2951:  int i;",
          "2986:   return false;",
          "2987:  }",
          "2989:  for (i = 0; i < MAX_BPF_STACK; i++) {",
          "",
          "[Removed Lines]",
          "2950:  struct bpf_reg_state *rold, *rcur;",
          "2953:  for (i = 0; i < MAX_BPF_REG; i++) {",
          "2954:   rold = &old->regs[i];",
          "2955:   rcur = &cur->regs[i];",
          "2957:   if (memcmp(rold, rcur, sizeof(*rold)) == 0)",
          "2958:    continue;",
          "2963:   if (!varlen_map_access &&",
          "2964:       memcmp(rold, rcur, offsetofend(struct bpf_reg_state, id)) == 0)",
          "2965:    continue;",
          "2971:   if (rold->type == NOT_INIT ||",
          "2972:       (!varlen_map_access && rold->type == UNKNOWN_VALUE &&",
          "2973:        rcur->type != NOT_INIT))",
          "2974:    continue;",
          "2977:   if (rold->type == PTR_TO_MAP_VALUE_OR_NULL &&",
          "2978:       rcur->type == PTR_TO_MAP_VALUE_OR_NULL &&",
          "2979:       rold->map_ptr == rcur->map_ptr)",
          "2980:    continue;",
          "2982:   if (rold->type == PTR_TO_PACKET && rcur->type == PTR_TO_PACKET &&",
          "2983:       compare_ptrs_to_packet(env, rold, rcur))",
          "2984:    continue;",
          "",
          "[Added Lines]",
          "3140:  struct idpair *idmap;",
          "3141:  bool ret = false;",
          "3144:  idmap = kcalloc(ID_MAP_SIZE, sizeof(struct idpair), GFP_KERNEL);",
          "3146:  if (!idmap)",
          "3149:  for (i = 0; i < MAX_BPF_REG; i++) {",
          "3150:   if (!regsafe(&old->regs[i], &cur->regs[i], varlen_map_access,",
          "3151:         idmap))",
          "3152:    goto out_free;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2999:   if (i % BPF_REG_SIZE)",
          "3000:    continue;",
          "3001:   if (old->stack_slot_type[i] != STACK_SPILL)",
          "3002:    continue;",
          "3017:   else",
          "3018:    continue;",
          "3019:  }",
          "3021: }",
          "3023: static int is_state_visited(struct bpf_verifier_env *env, int insn_idx)",
          "",
          "[Removed Lines]",
          "2998:    return false;",
          "3003:   if (memcmp(&old->spilled_regs[i / BPF_REG_SIZE],",
          "3004:       &cur->spilled_regs[i / BPF_REG_SIZE],",
          "3005:       sizeof(old->spilled_regs[0])))",
          "3016:    return false;",
          "3020:  return true;",
          "",
          "[Added Lines]",
          "3164:    goto out_free;",
          "3169:   if (!regsafe(&old->spilled_regs[i / BPF_REG_SIZE],",
          "3170:         &cur->spilled_regs[i / BPF_REG_SIZE],",
          "3171:         varlen_map_access, idmap))",
          "3182:    goto out_free;",
          "3186:  ret = true;",
          "3187: out_free:",
          "3188:  kfree(idmap);",
          "3189:  return ret;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3331:     verbose(\"invalid BPF_LD mode\\n\");",
          "3332:     return -EINVAL;",
          "3333:    }",
          "3335:   } else {",
          "3336:    verbose(\"unknown insn class %d\\n\", class);",
          "3337:    return -EINVAL;",
          "",
          "[Removed Lines]",
          "3334:    reset_reg_range_values(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e434b8cdf788568ba65a0a0fd9f3cb41f3ca1803",
      "candidate_info": {
        "commit_hash": "e434b8cdf788568ba65a0a0fd9f3cb41f3ca1803",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e434b8cdf788568ba65a0a0fd9f3cb41f3ca1803",
        "files": [
          "kernel/bpf/verifier.c",
          "tools/testing/selftests/bpf/test_verifier.c"
        ],
        "message": "bpf: relax verifier restriction on BPF_MOV | BPF_ALU\n\nCurrently, the destination register is marked as unknown for 32-bit\nsub-register move (BPF_MOV | BPF_ALU) whenever the source register type is\nSCALAR_VALUE.\n\nThis is too conservative that some valid cases will be rejected.\nEspecially, this may turn a constant scalar value into unknown value that\ncould break some assumptions of verifier.\n\nFor example, test_l4lb_noinline.c has the following C code:\n\n    struct real_definition *dst\n\n1:  if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6))\n2:    return TC_ACT_SHOT;\n3:\n4:  if (dst->flags & F_IPV6) {\n\nget_packet_dst is responsible for initializing \"dst\" into valid pointer and\nreturn true (1), otherwise return false (0). The compiled instruction\nsequence using alu32 will be:\n\n  412: (54) (u32) r7 &= (u32) 1\n  413: (bc) (u32) r0 = (u32) r7\n  414: (95) exit\n\ninsn 413, a BPF_MOV | BPF_ALU, however will turn r0 into unknown value even\nr7 contains SCALAR_VALUE 1.\n\nThis causes trouble when verifier is walking the code path that hasn't\ninitialized \"dst\" inside get_packet_dst, for which case 0 is returned and\nwe would then expect verifier concluding line 1 in the above C code pass\nthe \"if\" check, therefore would skip fall through path starting at line 4.\nNow, because r0 returned from callee has became unknown value, so verifier\nwon't skip analyzing path starting at line 4 and \"dst->flags\" requires\ndereferencing the pointer \"dst\" which actually hasn't be initialized for\nthis path.\n\nThis patch relaxed the code marking sub-register move destination. For a\nSCALAR_VALUE, it is safe to just copy the value from source then truncate\nit into 32-bit.\n\nA unit test also included to demonstrate this issue. This test will fail\nbefore this patch.\n\nThis relaxation could let verifier skipping more paths for conditional\ncomparison against immediate. It also let verifier recording a more\naccurate/strict value for one register at one state, if this state end up\nwith going through exit without rejection and it is used for state\ncomparison later, then it is possible an inaccurate/permissive value is\nbetter. So the real impact on verifier processed insn number is complex.\nBut in all, without this fix, valid program could be rejected.\n\n>From real benchmarking on kernel selftests and Cilium bpf tests, there is\nno impact on processed instruction number when tests ares compiled with\ndefault compilation options. There is slightly improvements when they are\ncompiled with -mattr=+alu32 after this patch.\n\nAlso, test_xdp_noinline/-mattr=+alu32 now passed verification. It is\nrejected before this fix.\n\nInsn processed before/after this patch:\n\n                        default     -mattr=+alu32\n\nKernel selftest\n\n===\ntest_xdp.o              371/371      369/369\ntest_l4lb.o             6345/6345    5623/5623\ntest_xdp_noinline.o     2971/2971    rejected/2727\ntest_tcp_estates.o      429/429      430/430\n\nCilium bpf\n===\nbpf_lb-DLB_L3.o:        2085/2085     1685/1687\nbpf_lb-DLB_L4.o:        2287/2287     1986/1982\nbpf_lb-DUNKNOWN.o:      690/690       622/622\nbpf_lxc.o:              95033/95033   N/A\nbpf_netdev.o:           7245/7245     N/A\nbpf_overlay.o:          2898/2898     3085/2947\n\nNOTE:\n  - bpf_lxc.o and bpf_netdev.o compiled by -mattr=+alu32 are rejected by\n    verifier due to another issue inside verifier on supporting alu32\n    binary.\n  - Each cilium bpf program could generate several processed insn number,\n    above number is sum of them.\n\nv1->v2:\n - Restrict the change on SCALAR_VALUE.\n - Update benchmark numbers on Cilium bpf tests.\n\nSigned-off-by: Jiong Wang <jiong.wang@netronome.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c",
          "tools/testing/selftests/bpf/test_verifier.c||tools/testing/selftests/bpf/test_verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3583:    return err;",
          "3585:   if (BPF_SRC(insn->code) == BPF_X) {",
          "3586:    if (BPF_CLASS(insn->code) == BPF_ALU64) {",
          "3592:    } else {",
          "3594:     if (is_pointer_value(env, insn->src_reg)) {",
          "",
          "[Removed Lines]",
          "3590:     regs[insn->dst_reg] = regs[insn->src_reg];",
          "3591:     regs[insn->dst_reg].live |= REG_LIVE_WRITTEN;",
          "",
          "[Added Lines]",
          "3586:    struct bpf_reg_state *src_reg = regs + insn->src_reg;",
          "3587:    struct bpf_reg_state *dst_reg = regs + insn->dst_reg;",
          "3594:     dst_reg->live |= REG_LIVE_WRITTEN;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3596:       \"R%d partial copy of pointer\\n\",",
          "3597:       insn->src_reg);",
          "3598:      return -EACCES;",
          "3599:     }",
          "3602:    }",
          "3603:   } else {",
          "",
          "[Removed Lines]",
          "3600:     mark_reg_unknown(env, regs, insn->dst_reg);",
          "3601:     coerce_reg_to_size(&regs[insn->dst_reg], 4);",
          "",
          "[Added Lines]",
          "3602:     } else if (src_reg->type == SCALAR_VALUE) {",
          "3604:      dst_reg->live |= REG_LIVE_WRITTEN;",
          "3605:     } else {",
          "3606:      mark_reg_unknown(env, regs,",
          "3607:         insn->dst_reg);",
          "3609:     coerce_reg_to_size(dst_reg, 4);",
          "",
          "---------------"
        ],
        "tools/testing/selftests/bpf/test_verifier.c||tools/testing/selftests/bpf/test_verifier.c": [
          "File: tools/testing/selftests/bpf/test_verifier.c -> tools/testing/selftests/bpf/test_verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2959:   .result_unpriv = REJECT,",
          "2960:   .result = ACCEPT,",
          "2961:  },",
          "2962:  {",
          "2963:   \"unpriv: partial copy of pointer\",",
          "2964:   .insns = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2962:  {",
          "2963:   \"alu32: mov u32 const\",",
          "2964:   .insns = {",
          "2965:    BPF_MOV32_IMM(BPF_REG_7, 0),",
          "2966:    BPF_ALU32_IMM(BPF_AND, BPF_REG_7, 1),",
          "2967:    BPF_MOV32_REG(BPF_REG_0, BPF_REG_7),",
          "2968:    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 1),",
          "2969:    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_7, 0),",
          "2970:    BPF_EXIT_INSN(),",
          "2971:   },",
          "2972:   .result = ACCEPT,",
          "2973:   .retval = 0,",
          "2974:  },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
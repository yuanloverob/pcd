{
  "cve_id": "CVE-2021-4173",
  "cve_desc": "vim is vulnerable to Use After Free",
  "repo": "vim/vim",
  "patch_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
  "patch_info": {
    "commit_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
    "files": [
      "src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim",
      "src/userfunc.c",
      "src/version.c",
      "src/vim9compile.c",
      "src/vim9execute.c"
    ],
    "message": "patch 8.2.3902: Vim9: double free with nested :def function\n\nProblem:    Vim9: double free with nested :def function.\nSolution:   Pass \"line_to_free\" from compile_def_function() and make sure\n            cmdlinep is valid.",
    "before_after_code_files": [
      "src/proto/userfunc.pro||src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
      "src/userfunc.c||src/userfunc.c",
      "src/version.c||src/version.c",
      "src/vim9compile.c||src/vim9compile.c",
      "src/vim9execute.c||src/vim9execute.c"
    ]
  },
  "patch_diff": {
    "src/proto/userfunc.pro||src/proto/userfunc.pro": [
      "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: char_u *get_scriptlocal_funcname(char_u *funcname);",
      "39: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
      "40: void list_functions(regmatch_T *regmatch);",
      "42: void ex_function(exarg_T *eap);",
      "43: void ex_defcompile(exarg_T *eap);",
      "44: int eval_fname_script(char_u *p);",
      "",
      "[Removed Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg);",
      "",
      "[Added Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);",
      "",
      "---------------"
    ],
    "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
      "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "1669:   assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')",
      "1670: enddef",
      "1672: def Test_return_type_wrong()",
      "1673:   CheckScriptFailure([",
      "1674:         'def Func(): number',",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1672: def Test_nested_functin_with_nextcmd()",
      "1673:   var lines =<< trim END",
      "1674:       vim9script",
      "1675:       # Define an outer function",
      "1676:       def FirstFunction()",
      "1677:         # Define an inner function",
      "1678:         def SecondFunction()",
      "1679:           # the function has a body, a double free is detected.",
      "1680:           AAAAA",
      "1682:          # enddef followed by | or } followed by # one or more characters",
      "1683:          enddef|BBBB",
      "1684:       enddef",
      "1686:       # Compile all functions",
      "1687:       defcompile",
      "1688:   END",
      "1689:   CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')",
      "1690: enddef",
      "",
      "---------------"
    ],
    "src/userfunc.c||src/userfunc.c": [
      "File: src/userfunc.c -> src/userfunc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "720:  }",
      "721:  else",
      "722:  {",
      "724:      if (eap->getline == NULL)",
      "725:   theline = getcmdline(':', 0L, indent, getline_options);",
      "726:      else",
      "727:   theline = eap->getline(':', eap->cookie, indent,",
      "728:              getline_options);",
      "730:  }",
      "731:  if (KeyTyped)",
      "",
      "[Removed Lines]",
      "723:      vim_free(*line_to_free);",
      "",
      "[Added Lines]",
      "728:      if (*eap->cmdlinep == *line_to_free)",
      "730:      vim_free(*line_to_free);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "839:    eap->nextcmd = nextcmd;",
      "841:    {",
      "842:        vim_free(*eap->cmdlinep);",
      "",
      "[Removed Lines]",
      "840:    if (*line_to_free != NULL)",
      "",
      "[Added Lines]",
      "842:    if (*line_to_free != NULL",
      "843:          && *eap->cmdlinep != *line_to_free)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1161:  }",
      "1162:  if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)",
      "1163:      goto erret;",
      "1166:      last = cmdline;",
      "1167:  else",
      "",
      "[Removed Lines]",
      "1164:  if (cmdline != NULL)",
      "",
      "[Added Lines]",
      "1167:  if (eap.nextcmd != NULL)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1175:  ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;",
      "1176:     }",
      "1179:     {",
      "1180:  garray_T *tfgap = &evalarg->eval_tofree_ga;",
      "",
      "[Removed Lines]",
      "1178:     if (cmdline != NULL)",
      "",
      "[Added Lines]",
      "1181:     if (eap.nextcmd != NULL)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1187:  {",
      "1188:      ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;",
      "1189:      evalarg->eval_using_cmdline = TRUE;",
      "1190:  }",
      "1191:     }",
      "1192:     else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1193:      if (cmdline == line_to_free)",
      "1194:   line_to_free = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "3990:     ufunc_T *",
      "3992: {",
      "3994:     int  j;",
      "3995:     int  c;",
      "3996:     int  saved_did_emsg;",
      "",
      "[Removed Lines]",
      "3991: define_function(exarg_T *eap, char_u *name_arg)",
      "3993:     char_u *line_to_free = NULL;",
      "",
      "[Added Lines]",
      "3996: define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "4258:     if (get_function_args(&p, ')', &newargs,",
      "4259:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
      "4260:     NULL, &varargs, &default_args, eap->skip,",
      "4262:  goto errret_2;",
      "4263:     whitep = p;",
      "",
      "[Removed Lines]",
      "4261:     eap, &line_to_free) == FAIL)",
      "",
      "[Added Lines]",
      "4265:     eap, line_to_free) == FAIL)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "4372:      || eap->skip)",
      "4373:  goto erret;",
      "",
      "[Removed Lines]",
      "4371:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL",
      "",
      "[Added Lines]",
      "4375:     if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "4660:     }",
      "4661: ret_free:",
      "4662:     ga_clear_strings(&argtypes);",
      "4664:     vim_free(fudi.fd_newkey);",
      "4665:     if (name != name_arg)",
      "4666:  vim_free(name);",
      "",
      "[Removed Lines]",
      "4663:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "4676:     void",
      "4677: ex_function(exarg_T *eap)",
      "4678: {",
      "4680: }",
      "",
      "[Removed Lines]",
      "4679:     (void)define_function(eap, NULL);",
      "",
      "[Added Lines]",
      "4682:     char_u *line_to_free = NULL;",
      "4684:     (void)define_function(eap, NULL, &line_to_free);",
      "4685:     vim_free(line_to_free);",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "750: static int included_patches[] =",
      "753:     3901,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "753:     3902,",
      "",
      "---------------"
    ],
    "src/vim9compile.c||src/vim9compile.c": [
      "File: src/vim9compile.c -> src/vim9compile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "814:     static char_u *",
      "816: {",
      "817:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
      "818:     char_u *name_start = eap->arg;",
      "819:     char_u *name_end = to_name_end(eap->arg, TRUE);",
      "820:     char_u *lambda_name;",
      "821:     ufunc_T *ufunc;",
      "822:     int  r = FAIL;",
      "",
      "[Removed Lines]",
      "815: compile_nested_function(exarg_T *eap, cctx_T *cctx)",
      "",
      "[Added Lines]",
      "815: compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)",
      "820:     int  off;",
      "821:     char_u *func_name;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "866:     lambda_name = vim_strsave(get_lambda_name());",
      "867:     if (lambda_name == NULL)",
      "868:  return NULL;",
      "871:     if (ufunc == NULL)",
      "872:     {",
      "",
      "[Removed Lines]",
      "869:     ufunc = define_function(eap, lambda_name);",
      "",
      "[Added Lines]",
      "873:     off = is_global ? 2 : 0;",
      "874:     func_name = vim_strnsave(name_start + off, name_end - name_start - off);",
      "875:     if (func_name == NULL)",
      "876:     {",
      "877:  r = FAIL;",
      "878:  goto theend;",
      "879:     }",
      "881:     ufunc = define_function(eap, lambda_name, line_to_free);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "912:     if (is_global)",
      "913:     {",
      "924:     }",
      "925:     else",
      "926:     {",
      "929:           TRUE, ufunc->uf_func_type);",
      "931:  if (lvar == NULL)",
      "",
      "[Removed Lines]",
      "914:  char_u *func_name = vim_strnsave(name_start + 2,",
      "915:           name_end - name_start - 2);",
      "917:  if (func_name == NULL)",
      "918:      r = FAIL;",
      "919:  else",
      "920:  {",
      "921:      r = generate_NEWFUNC(cctx, lambda_name, func_name);",
      "922:      lambda_name = NULL;",
      "923:  }",
      "928:  lvar_T *lvar = reserve_local(cctx, name_start, name_end - name_start,",
      "",
      "[Added Lines]",
      "926:  r = generate_NEWFUNC(cctx, lambda_name, func_name);",
      "927:  func_name = NULL;",
      "928:  lambda_name = NULL;",
      "933:  lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "938: theend:",
      "939:     vim_free(lambda_name);",
      "940:     return r == FAIL ? NULL : (char_u *)\"\";",
      "941: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "945:     vim_free(func_name);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2861:      case CMD_def:",
      "2862:      case CMD_function:",
      "2863:       ea.arg = p;",
      "2865:       break;",
      "2867:      case CMD_return:",
      "",
      "[Removed Lines]",
      "2864:       line = compile_nested_function(&ea, &cctx);",
      "",
      "[Added Lines]",
      "2870:       line = compile_nested_function(&ea, &cctx, &line_to_free);",
      "",
      "---------------"
    ],
    "src/vim9execute.c||src/vim9execute.c": [
      "File: src/vim9execute.c -> src/vim9execute.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3345:   else",
      "3346:   {",
      "3347:       exarg_T ea;",
      "3349:       CLEAR_FIELD(ea);",
      "3350:       ea.cmd = ea.arg = iptr->isn_arg.string;",
      "3352:   }",
      "3353:   break;",
      "",
      "[Removed Lines]",
      "3351:       define_function(&ea, NULL);",
      "",
      "[Added Lines]",
      "3348:       char_u  *line_to_free = NULL;",
      "3352:       define_function(&ea, NULL, &line_to_free);",
      "3353:       vim_free(line_to_free);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dc7c366f3aae65ee691010b08f37acfb26e0742b",
      "candidate_info": {
        "commit_hash": "dc7c366f3aae65ee691010b08f37acfb26e0742b",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/dc7c366f3aae65ee691010b08f37acfb26e0742b",
        "files": [
          "src/Make_ami.mak",
          "src/Make_cyg_ming.mak",
          "src/Make_mvc.mak",
          "src/Make_vms.mms",
          "src/Makefile",
          "src/proto.h",
          "src/proto/vim9cmds.pro",
          "src/proto/vim9compile.pro",
          "src/proto/vim9expr.pro",
          "src/proto/vim9instr.pro",
          "src/version.c",
          "src/vim9.h",
          "src/vim9cmds.c",
          "src/vim9compile.c",
          "src/vim9execute.c",
          "src/vim9expr.c",
          "src/vim9instr.c",
          "src/vim9script.c"
        ],
        "message": "patch 8.2.3860: Vim9: codecov struggles with the file size\n\nProblem:    Vim9: codecov struggles with the file size.\nSolution:   Split vim9compile.c into four files.",
        "before_after_code_files": [
          "src/Make_ami.mak||src/Make_ami.mak",
          "src/Make_cyg_ming.mak||src/Make_cyg_ming.mak",
          "src/Make_mvc.mak||src/Make_mvc.mak",
          "src/Make_vms.mms||src/Make_vms.mms",
          "src/proto.h||src/proto.h",
          "src/proto/vim9cmds.pro||src/proto/vim9cmds.pro",
          "src/proto/vim9compile.pro||src/proto/vim9compile.pro",
          "src/proto/vim9expr.pro||src/proto/vim9expr.pro",
          "src/proto/vim9instr.pro||src/proto/vim9instr.pro",
          "src/version.c||src/version.c",
          "src/vim9.h||src/vim9.h",
          "src/vim9cmds.c||src/vim9cmds.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9execute.c||src/vim9execute.c",
          "src/vim9expr.c||src/vim9expr.c",
          "src/vim9instr.c||src/vim9instr.c",
          "src/vim9script.c||src/vim9script.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ],
          "candidate": [
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ]
        }
      },
      "candidate_diff": {
        "src/Make_ami.mak||src/Make_ami.mak": [
          "File: src/Make_ami.mak -> src/Make_ami.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "180:  userfunc.c \\",
          "181:  version.c \\",
          "182:  viminfo.c \\",
          "183:  vim9compile.c \\",
          "184:  vim9execute.c \\",
          "185:  vim9script.c \\",
          "186:  vim9type.c \\",
          "187:  window.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:  vim9cmds.c \\",
          "186:  vim9expr.c \\",
          "187:  vim9instr.c \\",
          "",
          "---------------"
        ],
        "src/Make_cyg_ming.mak||src/Make_cyg_ming.mak": [
          "File: src/Make_cyg_ming.mak -> src/Make_cyg_ming.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "825:  $(OUTDIR)/usercmd.o \\",
          "826:  $(OUTDIR)/userfunc.o \\",
          "827:  $(OUTDIR)/version.o \\",
          "828:  $(OUTDIR)/vim9compile.o \\",
          "829:  $(OUTDIR)/vim9execute.o \\",
          "830:  $(OUTDIR)/vim9script.o \\",
          "831:  $(OUTDIR)/vim9type.o \\",
          "832:  $(OUTDIR)/viminfo.o \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "828:  $(OUTDIR)/vim9cmds.o \\",
          "831:  $(OUTDIR)/vim9expr.o \\",
          "832:  $(OUTDIR)/vim9instr.o \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1204: $(OUTDIR)/version.o: version.c $(INCL) version.h",
          "1206: $(OUTDIR)/vim9compile.o: vim9compile.c $(INCL) version.h",
          "1208: $(OUTDIR)/vim9execute.o: vim9execute.c $(INCL) version.h",
          "1210: $(OUTDIR)/vim9script.o: vim9script.c $(INCL) version.h",
          "1212: $(OUTDIR)/vim9type.o: vim9type.c $(INCL) version.h",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1209: $(OUTDIR)/vim9cmds.o: vim9cmds.c $(INCL) version.h",
          "1215: $(OUTDIR)/vim9expr.o: vim9expr.c $(INCL) version.h",
          "1217: $(OUTDIR)/vim9instr.o: vim9instr.c $(INCL) version.h",
          "",
          "---------------"
        ],
        "src/Make_mvc.mak||src/Make_mvc.mak": [
          "File: src/Make_mvc.mak -> src/Make_mvc.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "842:  $(OUTDIR)\\undo.obj \\",
          "843:  $(OUTDIR)\\usercmd.obj \\",
          "844:  $(OUTDIR)\\userfunc.obj \\",
          "845:  $(OUTDIR)\\vim9compile.obj \\",
          "846:  $(OUTDIR)\\vim9execute.obj \\",
          "847:  $(OUTDIR)\\vim9script.obj \\",
          "848:  $(OUTDIR)\\vim9type.obj \\",
          "849:  $(OUTDIR)\\viminfo.obj \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "845:  $(OUTDIR)\\vim9cmds.obj \\",
          "848:  $(OUTDIR)\\vim9expr.obj \\",
          "849:  $(OUTDIR)\\vim9instr.obj \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1835: $(OUTDIR)/version.obj: $(OUTDIR) version.c  $(INCL) version.h",
          "1837: $(OUTDIR)/vim9compile.obj: $(OUTDIR) vim9compile.c  $(INCL)",
          "1839: $(OUTDIR)/vim9execute.obj: $(OUTDIR) vim9execute.c  $(INCL)",
          "1841: $(OUTDIR)/vim9script.obj: $(OUTDIR) vim9script.c  $(INCL)",
          "1843: $(OUTDIR)/vim9type.obj: $(OUTDIR) vim9type.c  $(INCL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1840: $(OUTDIR)/vim9cmds.obj: $(OUTDIR) vim9cmds.c  $(INCL)",
          "1846: $(OUTDIR)/vim9expr.obj: $(OUTDIR) vim9expr.c  $(INCL)",
          "1848: $(OUTDIR)/vim9instr.obj: $(OUTDIR) vim9instr.c  $(INCL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2041:  proto/undo.pro \\",
          "2042:  proto/usercmd.pro \\",
          "2043:  proto/userfunc.pro \\",
          "2044:  proto/vim9compile.pro \\",
          "2045:  proto/vim9execute.pro \\",
          "2046:  proto/vim9script.pro \\",
          "2047:  proto/vim9type.pro \\",
          "2048:  proto/viminfo.pro \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2053:  proto/vim9cmds.pro \\",
          "2056:  proto/vim9expr.pro \\",
          "2057:  proto/vim9instr.pro \\",
          "",
          "---------------"
        ],
        "src/Make_vms.mms||src/Make_vms.mms": [
          "File: src/Make_vms.mms -> src/Make_vms.mms",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: # Makefile for Vim on OpenVMS",
          "3: #",
          "4: # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>",
          "6: #",
          "7: # This script has been tested on VMS 6.2 to 8.4 on DEC Alpha, VAX and IA64",
          "8: # with MMS and MMK",
          "",
          "[Removed Lines]",
          "5: # Last change:  2021 Nov 19",
          "",
          "[Added Lines]",
          "5: # Last change:  2021 Dec 20",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "410:  usercmd.c \\",
          "411:  userfunc.c \\",
          "412:  version.c \\",
          "413:  vim9compile.c \\",
          "414:  vim9execute.c \\",
          "415:  vim9script.c \\",
          "416:  vim9type.c \\",
          "417:  viminfo.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "413:  vim9cmds.c \\",
          "416:  vim9expr.c \\",
          "417:  vim9instr.c \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "531:  usercmd.obj \\",
          "532:  userfunc.obj \\",
          "533:  version.obj \\",
          "534:  vim9compile.obj \\",
          "535:  vim9execute.obj \\",
          "536:  vim9script.obj \\",
          "537:  vim9type.obj \\",
          "538:  viminfo.obj \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "537:  vim9cmds.obj \\",
          "540:  vim9expr.obj \\",
          "541:  vim9instr.obj \\",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1112:  ascii.h keymap.h termdefs.h macros.h structs.h regexp.h \\",
          "1113:  gui.h beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \\",
          "1114:  errors.h globals.h version.h",
          "1115: vim9compile.obj : vim9compile.c vim.h [.auto]config.h feature.h os_unix.h \\",
          "1116:  ascii.h keymap.h termdefs.h macros.h structs.h regexp.h \\",
          "1117:  gui.h beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1121: vim9cmds.obj : vim9cmds.c vim.h [.auto]config.h feature.h os_unix.h \\",
          "1122:  ascii.h keymap.h termdefs.h macros.h structs.h regexp.h \\",
          "1123:  gui.h beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \\",
          "1124:  errors.h globals.h version.h",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1120:  ascii.h keymap.h termdefs.h macros.h structs.h regexp.h \\",
          "1121:  gui.h beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \\",
          "1122:  errors.h globals.h version.h",
          "1123: vim9script.obj : vim9script.c vim.h [.auto]config.h feature.h os_unix.h \\",
          "1124:  ascii.h keymap.h termdefs.h macros.h structs.h regexp.h \\",
          "1125:  gui.h beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1133: vim9expr.obj : vim9expr.c vim.h [.auto]config.h feature.h os_unix.h \\",
          "1134:  ascii.h keymap.h termdefs.h macros.h structs.h regexp.h \\",
          "1135:  gui.h beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \\",
          "1136:  errors.h globals.h version.h",
          "1137: vim9instr.obj : vim9instr.c vim.h [.auto]config.h feature.h os_unix.h \\",
          "1138:  ascii.h keymap.h termdefs.h macros.h structs.h regexp.h \\",
          "1139:  gui.h beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \\",
          "1140:  errors.h globals.h version.h",
          "",
          "---------------"
        ],
        "src/proto.h||src/proto.h": [
          "File: src/proto.h -> src/proto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "212: # include \"version.pro\"",
          "213: # include \"vim9script.pro\"",
          "214: # ifdef FEAT_EVAL",
          "215: #  include \"vim9compile.pro\"",
          "216: #  include \"vim9execute.pro\"",
          "217: #  include \"vim9type.pro\"",
          "218: # endif",
          "219: # include \"window.pro\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216: #  include \"vim9.h\"",
          "217: #  include \"vim9cmds.pro\"",
          "220: #  include \"vim9expr.pro\"",
          "221: #  include \"vim9instr.pro\"",
          "",
          "---------------"
        ],
        "src/proto/vim9cmds.pro||src/proto/vim9cmds.pro": [
          "File: src/proto/vim9cmds.pro -> src/proto/vim9cmds.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: void free_locals(cctx_T *cctx);",
          "3: int check_vim9_unlet(char_u *name);",
          "4: char_u *compile_unletlock(char_u *arg, exarg_T *eap, cctx_T *cctx);",
          "5: void drop_scope(cctx_T *cctx);",
          "6: char_u *compile_if(char_u *arg, cctx_T *cctx);",
          "7: char_u *compile_elseif(char_u *arg, cctx_T *cctx);",
          "8: char_u *compile_else(char_u *arg, cctx_T *cctx);",
          "9: char_u *compile_endif(char_u *arg, cctx_T *cctx);",
          "10: char_u *compile_for(char_u *arg_start, cctx_T *cctx);",
          "11: char_u *compile_endfor(char_u *arg, cctx_T *cctx);",
          "12: char_u *compile_while(char_u *arg, cctx_T *cctx);",
          "13: char_u *compile_endwhile(char_u *arg, cctx_T *cctx);",
          "14: char_u *compile_continue(char_u *arg, cctx_T *cctx);",
          "15: char_u *compile_break(char_u *arg, cctx_T *cctx);",
          "16: char_u *compile_block(char_u *arg, cctx_T *cctx);",
          "17: void compile_endblock(cctx_T *cctx);",
          "18: char_u *compile_try(char_u *arg, cctx_T *cctx);",
          "19: char_u *compile_catch(char_u *arg, cctx_T *cctx);",
          "20: char_u *compile_finally(char_u *arg, cctx_T *cctx);",
          "21: char_u *compile_endtry(char_u *arg, cctx_T *cctx);",
          "22: char_u *compile_throw(char_u *arg, cctx_T *cctx);",
          "23: char_u *compile_eval(char_u *arg, cctx_T *cctx);",
          "24: char_u *compile_mult_expr(char_u *arg, int cmdidx, cctx_T *cctx);",
          "25: char_u *compile_put(char_u *arg, exarg_T *eap, cctx_T *cctx);",
          "26: char_u *compile_exec(char_u *line_arg, exarg_T *eap, cctx_T *cctx);",
          "27: char_u *compile_script(char_u *line, cctx_T *cctx);",
          "28: char_u *compile_substitute(char_u *arg, exarg_T *eap, cctx_T *cctx);",
          "29: char_u *compile_redir(char_u *line, exarg_T *eap, cctx_T *cctx);",
          "30: char_u *compile_cexpr(char_u *line, exarg_T *eap, cctx_T *cctx);",
          "31: char_u *compile_return(char_u *arg, int check_return_type, int legacy, cctx_T *cctx);",
          "32: int check_global_and_subst(char_u *cmd, char_u *arg);",
          "",
          "---------------"
        ],
        "src/proto/vim9compile.pro||src/proto/vim9compile.pro": [
          "File: src/proto/vim9compile.pro -> src/proto/vim9compile.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: int check_defined(char_u *p, size_t len, cctx_T *cctx, int is_arg);",
          "4: int need_type(type_T *actual, type_T *expected, int offset, int arg_idx, cctx_T *cctx, int silent, int actual_is_const);",
          "6: int get_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx);",
          "7: imported_T *find_imported(char_u *name, size_t len, cctx_T *cctx);",
          "8: imported_T *find_imported_in_script(char_u *name, size_t len, int sid);",
          "9: char_u *peek_next_line_from_context(cctx_T *cctx);",
          "10: char_u *next_line_from_context(cctx_T *cctx, int skip_comment);",
          "16: void fill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx);",
          "17: int assignment_len(char_u *p, int *heredoc);",
          "18: void vim9_declare_error(char_u *name);",
          "21: int compile_def_function(ufunc_T *ufunc, int check_return_type, compiletype_T compile_type, cctx_T *outer_cctx);",
          "22: void set_function_type(ufunc_T *ufunc);",
          "24: void unlink_def_function(ufunc_T *ufunc);",
          "25: void link_def_function(ufunc_T *ufunc);",
          "26: void free_def_functions(void);",
          "",
          "[Removed Lines]",
          "3: int check_compare_types(exprtype_T type, typval_T *tv1, typval_T *tv2);",
          "5: int func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type);",
          "11: char_u *to_name_end(char_u *arg, int use_namespace);",
          "12: char_u *to_name_const_end(char_u *arg);",
          "13: int get_lambda_tv_and_compile(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);",
          "14: exprtype_T get_compare_type(char_u *p, int *len, int *type_is);",
          "15: void error_white_both(char_u *op, int len);",
          "19: int check_vim9_unlet(char_u *name);",
          "20: int check_global_and_subst(char_u *cmd, char_u *arg);",
          "23: void delete_instr(isn_T *isn);",
          "",
          "[Added Lines]",
          "2: int lookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx);",
          "3: int arg_exists(char_u *name, size_t len, int *idxp, type_T **type, int *gen_load_outer, cctx_T *cctx);",
          "4: int script_is_vim9(void);",
          "5: int script_var_exists(char_u *name, size_t len, cctx_T *cctx);",
          "8: lvar_T *reserve_local(cctx_T *cctx, char_u *name, size_t len, int isConst, type_T *type);",
          "12: char_u *may_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp);",
          "15: int may_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx);",
          "16: int may_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx);",
          "18: int func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type);",
          "21: int get_var_dest(char_u *name, assign_dest_T *dest, int cmdidx, int *option_scope, int *vimvaridx, type_T **type, cctx_T *cctx);",
          "22: int compile_lhs(char_u *var_start, lhs_T *lhs, int cmdidx, int heredoc, int oplen, cctx_T *cctx);",
          "23: int compile_assign_lhs(char_u *var_start, lhs_T *lhs, int cmdidx, int is_decl, int heredoc, int oplen, cctx_T *cctx);",
          "24: int compile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx);",
          "25: int compile_assign_unlet(char_u *var_start, lhs_T *lhs, int is_assign, type_T *rhs_type, cctx_T *cctx);",
          "",
          "---------------"
        ],
        "src/proto/vim9expr.pro||src/proto/vim9expr.pro": [
          "File: src/proto/vim9expr.pro -> src/proto/vim9expr.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: int generate_ppconst(cctx_T *cctx, ppconst_T *ppconst);",
          "3: void clear_ppconst(ppconst_T *ppconst);",
          "4: int compile_member(int is_slice, int *keeping_dict, cctx_T *cctx);",
          "5: int compile_load_scriptvar(cctx_T *cctx, char_u *name, char_u *start, char_u **end, int error);",
          "6: int compile_load(char_u **arg, char_u *end_arg, cctx_T *cctx, int is_expr, int error);",
          "7: char_u *to_name_end(char_u *arg, int use_namespace);",
          "8: char_u *to_name_const_end(char_u *arg);",
          "9: int get_lambda_tv_and_compile(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);",
          "10: exprtype_T get_compare_type(char_u *p, int *len, int *type_is);",
          "11: void skip_expr_cctx(char_u **arg, cctx_T *cctx);",
          "12: int bool_on_stack(cctx_T *cctx);",
          "13: void error_white_both(char_u *op, int len);",
          "14: int compile_expr1(char_u **arg, cctx_T *cctx, ppconst_T *ppconst);",
          "15: int compile_expr0_ext(char_u **arg, cctx_T *cctx, int *is_const);",
          "16: int compile_expr0(char_u **arg, cctx_T *cctx);",
          "",
          "---------------"
        ],
        "src/proto/vim9instr.pro||src/proto/vim9instr.pro": [
          "File: src/proto/vim9instr.pro -> src/proto/vim9instr.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: isn_T *generate_instr(cctx_T *cctx, isntype_T isn_type);",
          "3: isn_T *generate_instr_drop(cctx_T *cctx, isntype_T isn_type, int drop);",
          "4: isn_T *generate_instr_type(cctx_T *cctx, isntype_T isn_type, type_T *type);",
          "5: isn_T *generate_instr_debug(cctx_T *cctx);",
          "6: int may_generate_2STRING(int offset, int tolerant, cctx_T *cctx);",
          "7: int generate_add_instr(cctx_T *cctx, vartype_T vartype, type_T *type1, type_T *type2, exprtype_T expr_type);",
          "8: vartype_T operator_type(type_T *type1, type_T *type2);",
          "9: int generate_two_op(cctx_T *cctx, char_u *op);",
          "10: int check_compare_types(exprtype_T type, typval_T *tv1, typval_T *tv2);",
          "11: int generate_COMPARE(cctx_T *cctx, exprtype_T exprtype, int ic);",
          "12: int generate_2BOOL(cctx_T *cctx, int invert, int offset);",
          "13: int generate_COND2BOOL(cctx_T *cctx);",
          "14: int generate_TYPECHECK(cctx_T *cctx, type_T *expected, int offset, int argidx);",
          "15: int generate_SETTYPE(cctx_T *cctx, type_T *expected);",
          "16: int generate_tv_PUSH(cctx_T *cctx, typval_T *tv);",
          "17: int generate_PUSHNR(cctx_T *cctx, varnumber_T number);",
          "18: int generate_PUSHBOOL(cctx_T *cctx, varnumber_T number);",
          "19: int generate_PUSHSPEC(cctx_T *cctx, varnumber_T number);",
          "20: int generate_PUSHF(cctx_T *cctx, float_T fnumber);",
          "21: int generate_PUSHS(cctx_T *cctx, char_u **str);",
          "22: int generate_PUSHCHANNEL(cctx_T *cctx, channel_T *channel);",
          "23: int generate_PUSHJOB(cctx_T *cctx, job_T *job);",
          "24: int generate_PUSHBLOB(cctx_T *cctx, blob_T *blob);",
          "25: int generate_PUSHFUNC(cctx_T *cctx, char_u *name, type_T *type);",
          "26: int generate_GETITEM(cctx_T *cctx, int index, int with_op);",
          "27: int generate_SLICE(cctx_T *cctx, int count);",
          "28: int generate_CHECKLEN(cctx_T *cctx, int min_len, int more_OK);",
          "29: int generate_STORE(cctx_T *cctx, isntype_T isn_type, int idx, char_u *name);",
          "30: int generate_STOREOUTER(cctx_T *cctx, int idx, int level);",
          "31: int generate_STORENR(cctx_T *cctx, int idx, varnumber_T value);",
          "32: int generate_STOREOPT(cctx_T *cctx, isntype_T isn_type, char_u *name, int opt_flags);",
          "33: int generate_LOAD(cctx_T *cctx, isntype_T isn_type, int idx, char_u *name, type_T *type);",
          "34: int generate_LOADOUTER(cctx_T *cctx, int idx, int nesting, type_T *type);",
          "35: int generate_LOADV(cctx_T *cctx, char_u *name, int error);",
          "36: int generate_UNLET(cctx_T *cctx, isntype_T isn_type, char_u *name, int forceit);",
          "37: int generate_LOCKCONST(cctx_T *cctx);",
          "38: int generate_OLDSCRIPT(cctx_T *cctx, isntype_T isn_type, char_u *name, int sid, type_T *type);",
          "39: int generate_VIM9SCRIPT(cctx_T *cctx, isntype_T isn_type, int sid, int idx, type_T *type);",
          "40: int generate_NEWLIST(cctx_T *cctx, int count);",
          "41: int generate_NEWDICT(cctx_T *cctx, int count);",
          "42: int generate_FUNCREF(cctx_T *cctx, ufunc_T *ufunc);",
          "43: int generate_NEWFUNC(cctx_T *cctx, char_u *lambda_name, char_u *func_name);",
          "44: int generate_DEF(cctx_T *cctx, char_u *name, size_t len);",
          "45: int generate_JUMP(cctx_T *cctx, jumpwhen_T when, int where);",
          "46: int generate_JUMP_IF_ARG_SET(cctx_T *cctx, int arg_off);",
          "47: int generate_FOR(cctx_T *cctx, int loop_idx);",
          "48: int generate_TRYCONT(cctx_T *cctx, int levels, int where);",
          "49: int generate_BCALL(cctx_T *cctx, int func_idx, int argcount, int method_call);",
          "50: int generate_LISTAPPEND(cctx_T *cctx);",
          "51: int generate_BLOBAPPEND(cctx_T *cctx);",
          "52: int generate_CALL(cctx_T *cctx, ufunc_T *ufunc, int pushed_argcount);",
          "53: int generate_UCALL(cctx_T *cctx, char_u *name, int argcount);",
          "54: int generate_PCALL(cctx_T *cctx, int argcount, char_u *name, type_T *type, int at_top);",
          "55: int generate_STRINGMEMBER(cctx_T *cctx, char_u *name, size_t len);",
          "56: int generate_ECHO(cctx_T *cctx, int with_white, int count);",
          "57: int generate_MULT_EXPR(cctx_T *cctx, isntype_T isn_type, int count);",
          "58: int generate_PUT(cctx_T *cctx, int regname, linenr_T lnum);",
          "59: int generate_EXEC_copy(cctx_T *cctx, isntype_T isntype, char_u *line);",
          "60: int generate_EXEC(cctx_T *cctx, isntype_T isntype, char_u *str);",
          "61: int generate_LEGACY_EVAL(cctx_T *cctx, char_u *line);",
          "62: int generate_EXECCONCAT(cctx_T *cctx, int count);",
          "63: int generate_RANGE(cctx_T *cctx, char_u *range);",
          "64: int generate_UNPACK(cctx_T *cctx, int var_count, int semicolon);",
          "65: int generate_cmdmods(cctx_T *cctx, cmdmod_T *cmod);",
          "66: int generate_undo_cmdmods(cctx_T *cctx);",
          "67: int generate_store_var(cctx_T *cctx, assign_dest_T dest, int opt_flags, int vimvaridx, int scriptvar_idx, int scriptvar_sid, type_T *type, char_u *name);",
          "68: int generate_store_lhs(cctx_T *cctx, lhs_T *lhs, int instr_count);",
          "69: void may_generate_prof_end(cctx_T *cctx, int prof_lnum);",
          "70: void delete_instr(isn_T *isn);",
          "71: void clear_instr_ga(garray_T *gap);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3859,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3860,",
          "",
          "---------------"
        ],
        "src/vim9.h||src/vim9.h": [
          "File: src/vim9.h -> src/vim9.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: typedef enum {",
          "15:     ISN_EXEC,     // execute Ex command line isn_arg.string",
          "16:     ISN_EXECCONCAT, // execute Ex command from isn_arg.number items on stack",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #ifdef VMS",
          "15: # include <float.h>",
          "16: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "502: #define STACK_FRAME_SIZE 6",
          "511: extern garray_T def_functions;",
          "515: #define LNUM_VARIABLE_RANGE -999",
          "",
          "[Removed Lines]",
          "505: #ifdef DEFINE_VIM9_GLOBALS",
          "509: garray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};",
          "510: #else",
          "512: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "531:   ? (dfunc)->df_instr_debug \\",
          "532:   : (dfunc)->df_instr)",
          "533: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "538: #define PPSIZE 50",
          "539: typedef struct {",
          "540:     typval_T pp_tv[PPSIZE]; // stack of ppconst constants",
          "541:     int  pp_used; // active entries in pp_tv[]",
          "542:     int  pp_is_const; // all generated code was constants, used for a",
          "544: } ppconst_T;",
          "547: typedef enum {",
          "548:     SKIP_NOT,  // condition is a constant, produce code",
          "549:     SKIP_YES,  // condition is a constant, do NOT produce code",
          "550:     SKIP_UNKNOWN // condition is not a constant, produce code",
          "551: } skip_T;",
          "556: typedef struct endlabel_S endlabel_T;",
          "557: struct endlabel_S {",
          "558:     endlabel_T *el_next;     // chain end_label locations",
          "559:     int  el_end_label;     // instruction idx where to set end",
          "560: };",
          "565: typedef struct {",
          "566:     int  is_seen_else;",
          "567:     int  is_seen_skip_not;   // a block was unconditionally executed",
          "568:     int  is_had_return;     // every block ends in :return",
          "569:     int  is_if_label;     // instruction idx at IF or ELSEIF",
          "570:     endlabel_T *is_end_label;     // instructions to set end label",
          "571: } ifscope_T;",
          "576: typedef struct {",
          "577:     int  ws_top_label;     // instruction idx at WHILE",
          "578:     endlabel_T *ws_end_label;     // instructions to set end",
          "579: } whilescope_T;",
          "584: typedef struct {",
          "585:     int  fs_top_label;     // instruction idx at FOR",
          "586:     endlabel_T *fs_end_label;     // break instructions",
          "587: } forscope_T;",
          "592: typedef struct {",
          "593:     int  ts_try_label;     // instruction idx at TRY",
          "594:     endlabel_T *ts_end_label;     // jump to :finally or :endtry",
          "595:     int  ts_catch_label;     // instruction idx of last CATCH",
          "596:     int  ts_caught_all;     // \"catch\" without argument encountered",
          "597: } tryscope_T;",
          "599: typedef enum {",
          "600:     NO_SCOPE,",
          "601:     IF_SCOPE,",
          "602:     WHILE_SCOPE,",
          "603:     FOR_SCOPE,",
          "604:     TRY_SCOPE,",
          "605:     BLOCK_SCOPE",
          "606: } scopetype_T;",
          "611: typedef struct scope_S scope_T;",
          "612: struct scope_S {",
          "613:     scope_T *se_outer;     // scope containing this one",
          "614:     scopetype_T se_type;",
          "615:     int  se_local_count;     // ctx_locals.ga_len before scope",
          "616:     skip_T se_skip_save;     // ctx_skip before the block",
          "617:     union {",
          "618:  ifscope_T se_if;",
          "619:  whilescope_T se_while;",
          "620:  forscope_T se_for;",
          "621:  tryscope_T se_try;",
          "622:     } se_u;",
          "623: };",
          "628: typedef struct {",
          "629:     char_u *lv_name;",
          "630:     type_T *lv_type;",
          "631:     int  lv_idx;  // index of the variable on the stack",
          "632:     int  lv_from_outer; // nesting level, using ctx_outer scope",
          "633:     int  lv_const; // when TRUE cannot be assigned to",
          "634:     int  lv_arg;  // when TRUE this is an argument",
          "635: } lvar_T;",
          "638: typedef enum {",
          "639:     dest_local,",
          "640:     dest_option,",
          "641:     dest_func_option,",
          "642:     dest_env,",
          "643:     dest_global,",
          "644:     dest_buffer,",
          "645:     dest_window,",
          "646:     dest_tab,",
          "647:     dest_vimvar,",
          "648:     dest_script,",
          "649:     dest_reg,",
          "650:     dest_expr,",
          "651: } assign_dest_T;",
          "655: typedef struct {",
          "656:     assign_dest_T   lhs_dest;     // type of destination",
          "658:     char_u     *lhs_name;     // allocated name excluding the last",
          "660:     size_t     lhs_varlen;     // length of the variable without",
          "662:     char_u     *lhs_whole;     // allocated name including the last",
          "664:     size_t     lhs_varlen_total; // length of the variable including",
          "666:     char_u     *lhs_dest_end;  // end of the destination, including",
          "668:     char_u     *lhs_end;     // end including any type",
          "670:     int      lhs_has_index;  // has \"[expr]\" or \".name\"",
          "672:     int      lhs_new_local;  // create new local variable",
          "673:     int      lhs_opt_flags;  // for when destination is an option",
          "674:     int      lhs_vimvaridx;  // for when destination is a v:var",
          "676:     lvar_T     lhs_local_lvar; // used for existing local destination",
          "677:     lvar_T     lhs_arg_lvar;   // used for argument destination",
          "678:     lvar_T     *lhs_lvar;     // points to destination lvar",
          "679:     int      lhs_scriptvar_sid;",
          "680:     int      lhs_scriptvar_idx;",
          "682:     int      lhs_has_type;   // type was specified",
          "683:     type_T     *lhs_type;",
          "684:     type_T     *lhs_member_type;",
          "686:     int      lhs_append;     // used by ISN_REDIREND",
          "687: } lhs_T;",
          "693: struct cctx_S {",
          "694:     ufunc_T *ctx_ufunc;     // current function",
          "695:     int  ctx_lnum;     // line number in current function",
          "696:     char_u *ctx_line_start;    // start of current line or NULL",
          "697:     garray_T ctx_instr;     // generated instructions",
          "699:     int  ctx_prev_lnum;     // line number below previous command, for",
          "702:     compiletype_T ctx_compile_type;",
          "704:     garray_T ctx_locals;     // currently visible local variables",
          "706:     int  ctx_has_closure;    // set to one if a closures was created in",
          "709:     garray_T ctx_imports;     // imported items",
          "711:     skip_T ctx_skip;",
          "712:     scope_T *ctx_scope;     // current scope, NULL at toplevel",
          "713:     int  ctx_had_return;     // last seen statement was \"return\"",
          "715:     cctx_T *ctx_outer;     // outer scope for lambda or nested",
          "717:     int  ctx_outer_used;     // var in ctx_outer was used",
          "719:     garray_T ctx_type_stack;     // type of each item on the stack",
          "720:     garray_T *ctx_type_list;     // list of pointers to allocated types",
          "722:     int  ctx_has_cmdmod;     // ISN_CMDMOD was generated",
          "724:     lhs_T ctx_redir_lhs;     // LHS for \":redir => var\", valid when",
          "726: };",
          "",
          "---------------"
        ],
        "src/vim9cmds.c||src/vim9cmds.c": [
          "File: src/vim9cmds.c -> src/vim9cmds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #define USING_FLOAT_STUFF",
          "15: #include \"vim.h\"",
          "17: #if defined(FEAT_EVAL) || defined(PROTO)",
          "20: #ifdef PROTO",
          "21: # include \"vim9.h\"",
          "22: #endif",
          "28:     static int",
          "29: current_instr_idx(cctx_T *cctx)",
          "30: {",
          "31:     garray_T *instr = &cctx->ctx_instr;",
          "32:     int  idx = instr->ga_len;",
          "34:     while (idx > 0)",
          "35:     {",
          "36:  if (cctx->ctx_has_cmdmod && ((isn_T *)instr->ga_data)[idx - 1]",
          "37:              .isn_type == ISN_CMDMOD)",
          "38:  {",
          "39:      --idx;",
          "40:      continue;",
          "41:  }",
          "42: #ifdef FEAT_PROFILE",
          "43:  if (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_PROF_START)",
          "44:  {",
          "45:      --idx;",
          "46:      continue;",
          "47:  }",
          "48: #endif",
          "49:  if (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_DEBUG)",
          "50:  {",
          "51:      --idx;",
          "52:      continue;",
          "53:  }",
          "54:  break;",
          "55:     }",
          "56:     return idx;",
          "57: }",
          "61:     static void",
          "62: unwind_locals(cctx_T *cctx, int new_top)",
          "63: {",
          "64:     if (cctx->ctx_locals.ga_len > new_top)",
          "65:     {",
          "66:  int idx;",
          "67:  lvar_T *lvar;",
          "69:  for (idx = new_top; idx < cctx->ctx_locals.ga_len; ++idx)",
          "70:  {",
          "71:      lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;",
          "72:      vim_free(lvar->lv_name);",
          "73:  }",
          "74:     }",
          "75:     cctx->ctx_locals.ga_len = new_top;",
          "76: }",
          "81:     void",
          "82: free_locals(cctx_T *cctx)",
          "83: {",
          "84:     unwind_locals(cctx, 0);",
          "85:     ga_clear(&cctx->ctx_locals);",
          "86: }",
          "92:     int",
          "93: check_vim9_unlet(char_u *name)",
          "94: {",
          "95:     if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)",
          "96:     {",
          "98:  if (*name == 's' && !script_is_vim9())",
          "99:      return OK;",
          "100:  semsg(_(e_cannot_unlet_str), name);",
          "101:  return FAIL;",
          "102:     }",
          "103:     return OK;",
          "104: }",
          "109:     static int",
          "110: compile_unlet(",
          "111:     lval_T  *lvp,",
          "112:     char_u  *name_end,",
          "113:     exarg_T *eap,",
          "114:     int     deep UNUSED,",
          "115:     void    *coookie)",
          "116: {",
          "117:     cctx_T *cctx = coookie;",
          "118:     char_u *p = lvp->ll_name;",
          "119:     int  cc = *name_end;",
          "120:     int  ret = OK;",
          "122:     if (cctx->ctx_skip == SKIP_YES)",
          "123:  return OK;",
          "126:     if (*p == '$')",
          "127:     {",
          "129:  ret = generate_UNLET(cctx, ISN_UNLETENV, p + 1, eap->forceit);",
          "130:     }",
          "131:     else if (vim_strchr(p, '.') != NULL || vim_strchr(p, '[') != NULL)",
          "132:     {",
          "133:  lhs_T     lhs;",
          "142:  ret = compile_lhs(p, &lhs, CMD_unlet, FALSE, 0, cctx);",
          "145:  if (!lhs.lhs_has_index)",
          "146:  {",
          "147:      iemsg(\"called compile_lhs() without an index\");",
          "148:      ret = FAIL;",
          "149:  }",
          "150:  else",
          "151:  {",
          "154:      ret = compile_assign_unlet(p, &lhs, FALSE, &t_void, cctx);",
          "155:  }",
          "157:  vim_free(lhs.lhs_name);",
          "158:     }",
          "159:     else if (check_vim9_unlet(p) == FAIL)",
          "160:     {",
          "161:  ret = FAIL;",
          "162:     }",
          "163:     else",
          "164:     {",
          "166:  ret = generate_UNLET(cctx, ISN_UNLET, p, eap->forceit);",
          "167:     }",
          "170:     return ret;",
          "171: }",
          "176:     static int",
          "177: compile_lock_unlock(",
          "178:     lval_T  *lvp,",
          "179:     char_u  *name_end,",
          "180:     exarg_T *eap,",
          "181:     int     deep UNUSED,",
          "182:     void    *coookie)",
          "183: {",
          "184:     cctx_T *cctx = coookie;",
          "185:     int  cc = *name_end;",
          "186:     char_u *p = lvp->ll_name;",
          "187:     int  ret = OK;",
          "188:     size_t len;",
          "189:     char_u *buf;",
          "190:     isntype_T isn = ISN_EXEC;",
          "192:     if (cctx->ctx_skip == SKIP_YES)",
          "193:  return OK;",
          "196:     if (p[1] != ':')",
          "197:     {",
          "198:  char_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);",
          "200:  if (lookup_local(p, end - p, NULL, cctx) == OK)",
          "201:  {",
          "202:      char_u *s = p;",
          "204:      if (*end != '.' && *end != '[')",
          "205:      {",
          "206:   emsg(_(e_cannot_lock_unlock_local_variable));",
          "207:   return FAIL;",
          "208:      }",
          "212:      if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)",
          "213:   return FAIL;",
          "214:      isn = ISN_LOCKUNLOCK;",
          "215:  }",
          "216:     }",
          "220:     len = name_end - p + 20;",
          "221:     buf = alloc(len);",
          "222:     if (buf == NULL)",
          "223:  ret = FAIL;",
          "224:     else",
          "225:     {",
          "226:  vim_snprintf((char *)buf, len, \"%s %s\",",
          "227:   eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\",",
          "228:   p);",
          "229:  ret = generate_EXEC_copy(cctx, isn, buf);",
          "231:  vim_free(buf);",
          "233:     }",
          "234:     return ret;",
          "235: }",
          "241:     char_u *",
          "242: compile_unletlock(char_u *arg, exarg_T *eap, cctx_T *cctx)",
          "243: {",
          "244:     ex_unletlock(eap, arg, 0, GLV_NO_AUTOLOAD | GLV_COMPILING,",
          "245:      eap->cmdidx == CMD_unlet ? compile_unlet : compile_lock_unlock,",
          "246:      cctx);",
          "247:     return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;",
          "248: }",
          "253:     static int",
          "254: compile_jump_to_end(endlabel_T **el, jumpwhen_T when, cctx_T *cctx)",
          "255: {",
          "256:     garray_T *instr = &cctx->ctx_instr;",
          "257:     endlabel_T  *endlabel = ALLOC_CLEAR_ONE(endlabel_T);",
          "259:     if (endlabel == NULL)",
          "260:  return FAIL;",
          "261:     endlabel->el_next = *el;",
          "263:     endlabel->el_end_label = instr->ga_len;",
          "265:     generate_JUMP(cctx, when, 0);",
          "266:     return OK;",
          "267: }",
          "269:     static void",
          "270: compile_fill_jump_to_end(endlabel_T **el, int jump_where, cctx_T *cctx)",
          "271: {",
          "272:     garray_T *instr = &cctx->ctx_instr;",
          "274:     while (*el != NULL)",
          "275:     {",
          "276:  endlabel_T  *cur = (*el);",
          "277:  isn_T     *isn;",
          "279:  isn = ((isn_T *)instr->ga_data) + cur->el_end_label;",
          "280:  isn->isn_arg.jump.jump_where = jump_where;",
          "282:  vim_free(cur);",
          "283:     }",
          "284: }",
          "286:     static void",
          "287: compile_free_jump_to_end(endlabel_T **el)",
          "288: {",
          "289:     while (*el != NULL)",
          "290:     {",
          "291:  endlabel_T  *cur = (*el);",
          "294:  vim_free(cur);",
          "295:     }",
          "296: }",
          "301:     static scope_T *",
          "302: new_scope(cctx_T *cctx, scopetype_T type)",
          "303: {",
          "304:     scope_T *scope = ALLOC_CLEAR_ONE(scope_T);",
          "306:     if (scope == NULL)",
          "307:  return NULL;",
          "308:     scope->se_outer = cctx->ctx_scope;",
          "309:     cctx->ctx_scope = scope;",
          "310:     scope->se_type = type;",
          "311:     scope->se_local_count = cctx->ctx_locals.ga_len;",
          "312:     return scope;",
          "313: }",
          "318:     void",
          "319: drop_scope(cctx_T *cctx)",
          "320: {",
          "321:     scope_T *scope = cctx->ctx_scope;",
          "323:     if (scope == NULL)",
          "324:     {",
          "325:  iemsg(\"calling drop_scope() without a scope\");",
          "326:  return;",
          "327:     }",
          "328:     cctx->ctx_scope = scope->se_outer;",
          "329:     switch (scope->se_type)",
          "330:     {",
          "331:  case IF_SCOPE:",
          "332:      compile_free_jump_to_end(&scope->se_u.se_if.is_end_label); break;",
          "333:  case FOR_SCOPE:",
          "334:      compile_free_jump_to_end(&scope->se_u.se_for.fs_end_label); break;",
          "335:  case WHILE_SCOPE:",
          "336:      compile_free_jump_to_end(&scope->se_u.se_while.ws_end_label); break;",
          "337:  case TRY_SCOPE:",
          "338:      compile_free_jump_to_end(&scope->se_u.se_try.ts_end_label); break;",
          "339:  case NO_SCOPE:",
          "340:  case BLOCK_SCOPE:",
          "341:      break;",
          "342:     }",
          "343:     vim_free(scope);",
          "344: }",
          "346:     static int",
          "347: misplaced_cmdmod(cctx_T *cctx)",
          "348: {",
          "349:     garray_T *instr = &cctx->ctx_instr;",
          "351:     if (cctx->ctx_has_cmdmod",
          "352:      && ((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type",
          "353:          == ISN_CMDMOD)",
          "354:     {",
          "355:  emsg(_(e_misplaced_command_modifier));",
          "356:  return TRUE;",
          "357:     }",
          "358:     return FALSE;",
          "359: }",
          "393:     char_u *",
          "394: compile_if(char_u *arg, cctx_T *cctx)",
          "395: {",
          "396:     char_u *p = arg;",
          "397:     garray_T *instr = &cctx->ctx_instr;",
          "398:     int  instr_count = instr->ga_len;",
          "399:     scope_T *scope;",
          "400:     skip_T skip_save = cctx->ctx_skip;",
          "401:     ppconst_T ppconst;",
          "403:     CLEAR_FIELD(ppconst);",
          "404:     if (compile_expr1(&p, cctx, &ppconst) == FAIL)",
          "405:     {",
          "406:  clear_ppconst(&ppconst);",
          "407:  return NULL;",
          "408:     }",
          "409:     if (!ends_excmd2(arg, skipwhite(p)))",
          "410:     {",
          "411:  semsg(_(e_trailing_arg), p);",
          "412:  return NULL;",
          "413:     }",
          "414:     if (cctx->ctx_skip == SKIP_YES)",
          "415:  clear_ppconst(&ppconst);",
          "416:     else if (instr->ga_len == instr_count && ppconst.pp_used == 1)",
          "417:     {",
          "418:  int error = FALSE;",
          "419:  int v;",
          "422:  v = tv_get_bool_chk(&ppconst.pp_tv[0], &error);",
          "423:  clear_ppconst(&ppconst);",
          "424:  if (error)",
          "425:      return NULL;",
          "426:  cctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;",
          "427:     }",
          "428:     else",
          "429:     {",
          "431:  cctx->ctx_skip = SKIP_UNKNOWN;",
          "432:  if (generate_ppconst(cctx, &ppconst) == FAIL)",
          "433:      return NULL;",
          "434:  if (bool_on_stack(cctx) == FAIL)",
          "435:      return NULL;",
          "436:     }",
          "439:     generate_undo_cmdmods(cctx);",
          "441:     scope = new_scope(cctx, IF_SCOPE);",
          "442:     if (scope == NULL)",
          "443:  return NULL;",
          "444:     scope->se_skip_save = skip_save;",
          "446:     scope->se_u.se_if.is_had_return = TRUE;",
          "448:     if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "449:     {",
          "451:  scope->se_u.se_if.is_if_label = instr->ga_len;",
          "452:  generate_JUMP(cctx, JUMP_IF_FALSE, 0);",
          "453:     }",
          "454:     else",
          "455:  scope->se_u.se_if.is_if_label = -1;",
          "457: #ifdef FEAT_PROFILE",
          "458:     if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES",
          "459:             && skip_save != SKIP_YES)",
          "460:     {",
          "463:  cctx->ctx_skip = SKIP_NOT;",
          "464:  generate_instr(cctx, ISN_PROF_END);",
          "465:  cctx->ctx_skip = SKIP_YES;",
          "466:     }",
          "467: #endif",
          "469:     return p;",
          "470: }",
          "472:     char_u *",
          "473: compile_elseif(char_u *arg, cctx_T *cctx)",
          "474: {",
          "475:     char_u *p = arg;",
          "476:     garray_T *instr = &cctx->ctx_instr;",
          "477:     int  instr_count;",
          "478:     isn_T *isn;",
          "479:     scope_T *scope = cctx->ctx_scope;",
          "480:     ppconst_T ppconst;",
          "481:     skip_T save_skip = cctx->ctx_skip;",
          "483:     if (scope == NULL || scope->se_type != IF_SCOPE)",
          "484:     {",
          "485:  emsg(_(e_elseif_without_if));",
          "486:  return NULL;",
          "487:     }",
          "488:     unwind_locals(cctx, scope->se_local_count);",
          "489:     if (!cctx->ctx_had_return)",
          "490:  scope->se_u.se_if.is_had_return = FALSE;",
          "492:     if (cctx->ctx_skip == SKIP_NOT)",
          "493:     {",
          "495:  cctx->ctx_skip = SKIP_YES;",
          "496:  scope->se_u.se_if.is_seen_skip_not = TRUE;",
          "497:     }",
          "498:     if (scope->se_u.se_if.is_seen_skip_not)",
          "499:     {",
          "502:  instr->ga_len = current_instr_idx(cctx);",
          "504:  skip_expr_cctx(&p, cctx);",
          "505:  return p;",
          "506:     }",
          "508:     if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "509:     {",
          "510:  int     moved_cmdmod = FALSE;",
          "511:  int     saved_debug = FALSE;",
          "512:  isn_T     debug_isn;",
          "515:  if (((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type == ISN_CMDMOD)",
          "516:  {",
          "517:      if (GA_GROW_FAILS(instr, 1))",
          "518:   return NULL;",
          "519:      ((isn_T *)instr->ga_data)[instr->ga_len] =",
          "520:       ((isn_T *)instr->ga_data)[instr->ga_len - 1];",
          "521:      --instr->ga_len;",
          "522:      moved_cmdmod = TRUE;",
          "523:  }",
          "527:  if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0",
          "528:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "529:        .isn_type == ISN_DEBUG)",
          "530:  {",
          "531:      --instr->ga_len;",
          "532:      debug_isn = ((isn_T *)instr->ga_data)[instr->ga_len];",
          "533:      saved_debug = TRUE;",
          "534:  }",
          "536:  if (compile_jump_to_end(&scope->se_u.se_if.is_end_label,",
          "537:           JUMP_ALWAYS, cctx) == FAIL)",
          "538:      return NULL;",
          "540:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;",
          "541:  isn->isn_arg.jump.jump_where = instr->ga_len;",
          "543:  if (moved_cmdmod)",
          "544:      ++instr->ga_len;",
          "546:  if (saved_debug)",
          "547:  {",
          "549:      if (GA_GROW_FAILS(instr, 1))",
          "550:   return NULL;",
          "551:      ((isn_T *)instr->ga_data)[instr->ga_len] = debug_isn;",
          "552:      ++instr->ga_len;",
          "553:  }",
          "554:     }",
          "557:     CLEAR_FIELD(ppconst);",
          "558:     if (cctx->ctx_skip == SKIP_YES)",
          "559:     {",
          "560:  cctx->ctx_skip = SKIP_UNKNOWN;",
          "561: #ifdef FEAT_PROFILE",
          "562:  if (cctx->ctx_compile_type == CT_PROFILE)",
          "564:      generate_instr(cctx, ISN_PROF_START);",
          "565: #endif",
          "566:  if (cctx->ctx_compile_type == CT_DEBUG)",
          "568:      generate_instr_debug(cctx);",
          "569:     }",
          "571:     instr_count = instr->ga_len;",
          "572:     if (compile_expr1(&p, cctx, &ppconst) == FAIL)",
          "573:     {",
          "574:  clear_ppconst(&ppconst);",
          "575:  return NULL;",
          "576:     }",
          "577:     cctx->ctx_skip = save_skip;",
          "578:     if (!ends_excmd2(arg, skipwhite(p)))",
          "579:     {",
          "580:  clear_ppconst(&ppconst);",
          "581:  semsg(_(e_trailing_arg), p);",
          "582:  return NULL;",
          "583:     }",
          "584:     if (scope->se_skip_save == SKIP_YES)",
          "585:  clear_ppconst(&ppconst);",
          "586:     else if (instr->ga_len == instr_count && ppconst.pp_used == 1)",
          "587:     {",
          "588:  int error = FALSE;",
          "589:  int v;",
          "592:  v = tv_get_bool_chk(&ppconst.pp_tv[0], &error);",
          "593:  if (error)",
          "594:  {",
          "595:      clear_ppconst(&ppconst);",
          "596:      return NULL;",
          "597:  }",
          "598:  cctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;",
          "599:  clear_ppconst(&ppconst);",
          "600:  scope->se_u.se_if.is_if_label = -1;",
          "601:     }",
          "602:     else",
          "603:     {",
          "605:  cctx->ctx_skip = SKIP_UNKNOWN;",
          "606:  if (generate_ppconst(cctx, &ppconst) == FAIL)",
          "607:      return NULL;",
          "608:  if (bool_on_stack(cctx) == FAIL)",
          "609:      return NULL;",
          "612:  generate_undo_cmdmods(cctx);",
          "615:  scope->se_u.se_if.is_if_label = instr->ga_len;",
          "616:  generate_JUMP(cctx, JUMP_IF_FALSE, 0);",
          "617:     }",
          "619:     return p;",
          "620: }",
          "622:     char_u *",
          "623: compile_else(char_u *arg, cctx_T *cctx)",
          "624: {",
          "625:     char_u *p = arg;",
          "626:     garray_T *instr = &cctx->ctx_instr;",
          "627:     isn_T *isn;",
          "628:     scope_T *scope = cctx->ctx_scope;",
          "630:     if (scope == NULL || scope->se_type != IF_SCOPE)",
          "631:     {",
          "632:  emsg(_(e_else_without_if));",
          "633:  return NULL;",
          "634:     }",
          "635:     unwind_locals(cctx, scope->se_local_count);",
          "636:     if (!cctx->ctx_had_return)",
          "637:  scope->se_u.se_if.is_had_return = FALSE;",
          "638:     scope->se_u.se_if.is_seen_else = TRUE;",
          "640: #ifdef FEAT_PROFILE",
          "641:     if (cctx->ctx_compile_type == CT_PROFILE)",
          "642:     {",
          "643:  if (cctx->ctx_skip == SKIP_NOT",
          "644:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "645:          .isn_type == ISN_PROF_START)",
          "648:      --instr->ga_len;",
          "649:  if (cctx->ctx_skip == SKIP_YES && !scope->se_u.se_if.is_seen_skip_not)",
          "650:  {",
          "653:      cctx->ctx_skip = SKIP_NOT;",
          "654:      generate_instr(cctx, ISN_PROF_END);",
          "655:      generate_instr(cctx, ISN_PROF_START);",
          "656:      cctx->ctx_skip = SKIP_YES;",
          "657:  }",
          "658:     }",
          "659: #endif",
          "661:     if (!scope->se_u.se_if.is_seen_skip_not && scope->se_skip_save != SKIP_YES)",
          "662:     {",
          "664:  if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "665:  {",
          "666:      if (!cctx->ctx_had_return",
          "667:       && compile_jump_to_end(&scope->se_u.se_if.is_end_label,",
          "668:           JUMP_ALWAYS, cctx) == FAIL)",
          "669:   return NULL;",
          "670:  }",
          "672:  if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "673:  {",
          "674:      if (scope->se_u.se_if.is_if_label >= 0)",
          "675:      {",
          "677:   isn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;",
          "678:   isn->isn_arg.jump.jump_where = instr->ga_len;",
          "679:   scope->se_u.se_if.is_if_label = -1;",
          "680:      }",
          "681:  }",
          "683:  if (cctx->ctx_skip != SKIP_UNKNOWN)",
          "684:      cctx->ctx_skip = cctx->ctx_skip == SKIP_YES ? SKIP_NOT : SKIP_YES;",
          "685:     }",
          "687:     return p;",
          "688: }",
          "690:     char_u *",
          "691: compile_endif(char_u *arg, cctx_T *cctx)",
          "692: {",
          "693:     scope_T *scope = cctx->ctx_scope;",
          "694:     ifscope_T *ifscope;",
          "695:     garray_T *instr = &cctx->ctx_instr;",
          "696:     isn_T *isn;",
          "698:     if (misplaced_cmdmod(cctx))",
          "699:  return NULL;",
          "701:     if (scope == NULL || scope->se_type != IF_SCOPE)",
          "702:     {",
          "703:  emsg(_(e_endif_without_if));",
          "704:  return NULL;",
          "705:     }",
          "706:     ifscope = &scope->se_u.se_if;",
          "707:     unwind_locals(cctx, scope->se_local_count);",
          "708:     if (!cctx->ctx_had_return)",
          "709:  ifscope->is_had_return = FALSE;",
          "711:     if (scope->se_u.se_if.is_if_label >= 0)",
          "712:     {",
          "714:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;",
          "715:  isn->isn_arg.jump.jump_where = instr->ga_len;",
          "716:     }",
          "718:     compile_fill_jump_to_end(&ifscope->is_end_label, instr->ga_len, cctx);",
          "720: #ifdef FEAT_PROFILE",
          "723:     if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES",
          "724:          && scope->se_skip_save != SKIP_YES)",
          "725:     {",
          "726:  cctx->ctx_skip = SKIP_NOT;",
          "727:  generate_instr(cctx, ISN_PROF_START);",
          "728:     }",
          "729: #endif",
          "730:     cctx->ctx_skip = scope->se_skip_save;",
          "734:     cctx->ctx_had_return = ifscope->is_had_return && ifscope->is_seen_else;",
          "736:     drop_scope(cctx);",
          "737:     return arg;",
          "738: }",
          "760:     char_u *",
          "761: compile_for(char_u *arg_start, cctx_T *cctx)",
          "762: {",
          "763:     char_u *arg;",
          "764:     char_u *arg_end;",
          "765:     char_u *name = NULL;",
          "766:     char_u *p;",
          "767:     char_u *wp;",
          "768:     int  var_count = 0;",
          "769:     int  var_list = FALSE;",
          "770:     int  semicolon = FALSE;",
          "771:     size_t varlen;",
          "772:     garray_T *stack = &cctx->ctx_type_stack;",
          "773:     garray_T *instr = &cctx->ctx_instr;",
          "774:     scope_T *scope;",
          "775:     lvar_T *loop_lvar; // loop iteration variable",
          "776:     lvar_T *var_lvar; // variable for \"var\"",
          "777:     type_T *vartype;",
          "778:     type_T *item_type = &t_any;",
          "779:     int  idx;",
          "780:     int  prev_lnum = cctx->ctx_prev_lnum;",
          "782:     p = skip_var_list(arg_start, TRUE, &var_count, &semicolon, FALSE);",
          "783:     if (p == NULL)",
          "784:  return NULL;",
          "785:     if (var_count == 0)",
          "786:  var_count = 1;",
          "787:     else",
          "788:  var_list = TRUE;  // can also be a list of one variable",
          "791:     wp = p;",
          "792:     if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "793:  return NULL;",
          "794:     if (STRNCMP(p, \"in\", 2) != 0 || !IS_WHITE_OR_NUL(p[2]))",
          "795:     {",
          "796:  if (*p == ':' && wp != p)",
          "797:      semsg(_(e_no_white_space_allowed_before_colon_str), p);",
          "798:  else",
          "799:      emsg(_(e_missing_in));",
          "800:  return NULL;",
          "801:     }",
          "802:     wp = p + 2;",
          "803:     if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "804:  return NULL;",
          "808:     if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0",
          "809:      && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "810:        .isn_type == ISN_DEBUG)",
          "811:     {",
          "812:  --instr->ga_len;",
          "813:  prev_lnum = ((isn_T *)instr->ga_data)[instr->ga_len]",
          "814:        .isn_arg.debug.dbg_break_lnum;",
          "815:     }",
          "817:     scope = new_scope(cctx, FOR_SCOPE);",
          "818:     if (scope == NULL)",
          "819:  return NULL;",
          "823:     loop_lvar = reserve_local(cctx, (char_u *)\"\", 0, FALSE, &t_number);",
          "824:     if (loop_lvar == NULL)",
          "825:     {",
          "827:  drop_scope(cctx);",
          "828:  return NULL;",
          "829:     }",
          "830:     generate_STORENR(cctx, loop_lvar->lv_idx, -1);",
          "833:     arg = p;",
          "834:     if (compile_expr0(&arg, cctx) == FAIL)",
          "835:     {",
          "836:  drop_scope(cctx);",
          "837:  return NULL;",
          "838:     }",
          "839:     arg_end = arg;",
          "841:     if (cctx->ctx_skip != SKIP_YES)",
          "842:     {",
          "845:  vartype = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "846:  if (vartype->tt_type != VAR_LIST && vartype->tt_type != VAR_STRING",
          "847:   && vartype->tt_type != VAR_BLOB && vartype->tt_type != VAR_ANY)",
          "848:  {",
          "849:      semsg(_(e_for_loop_on_str_not_supported),",
          "850:             vartype_name(vartype->tt_type));",
          "851:      drop_scope(cctx);",
          "852:      return NULL;",
          "853:  }",
          "855:  if (vartype->tt_type == VAR_STRING)",
          "856:      item_type = &t_string;",
          "857:  else if (vartype->tt_type == VAR_BLOB)",
          "858:      item_type = &t_number;",
          "859:  else if (vartype->tt_type == VAR_LIST",
          "860:          && vartype->tt_member->tt_type != VAR_ANY)",
          "861:  {",
          "862:      if (!var_list)",
          "863:   item_type = vartype->tt_member;",
          "864:      else if (vartype->tt_member->tt_type == VAR_LIST",
          "865:      && vartype->tt_member->tt_member->tt_type != VAR_ANY)",
          "866:   item_type = vartype->tt_member->tt_member;",
          "867:  }",
          "870:  generate_undo_cmdmods(cctx);",
          "873:  scope->se_u.se_for.fs_top_label = current_instr_idx(cctx);",
          "875:  generate_FOR(cctx, loop_lvar->lv_idx);",
          "877:  arg = arg_start;",
          "878:  if (var_list)",
          "879:  {",
          "880:      generate_UNPACK(cctx, var_count, semicolon);",
          "881:      arg = skipwhite(arg + 1); // skip white after '['",
          "884:      if (GA_GROW_FAILS(stack, var_count - 1))",
          "885:      {",
          "886:   drop_scope(cctx);",
          "887:   return NULL;",
          "888:      }",
          "889:      --stack->ga_len;",
          "890:      for (idx = 0; idx < var_count; ++idx)",
          "891:      {",
          "892:   ((type_T **)stack->ga_data)[stack->ga_len] =",
          "893:      (semicolon && idx == 0) ? vartype : item_type;",
          "894:   ++stack->ga_len;",
          "895:      }",
          "896:  }",
          "898:  for (idx = 0; idx < var_count; ++idx)",
          "899:  {",
          "900:      assign_dest_T dest = dest_local;",
          "901:      int   opt_flags = 0;",
          "902:      int   vimvaridx = -1;",
          "903:      type_T  *type = &t_any;",
          "904:      type_T  *lhs_type = &t_any;",
          "905:      where_T  where = WHERE_INIT;",
          "907:      p = skip_var_one(arg, FALSE);",
          "908:      varlen = p - arg;",
          "909:      name = vim_strnsave(arg, varlen);",
          "910:      if (name == NULL)",
          "911:   goto failed;",
          "912:      if (*p == ':')",
          "913:      {",
          "914:   p = skipwhite(p + 1);",
          "915:   lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);",
          "916:      }",
          "918:      if (get_var_dest(name, &dest, CMD_for, &opt_flags,",
          "919:            &vimvaridx, &type, cctx) == FAIL)",
          "920:   goto failed;",
          "921:      if (dest != dest_local)",
          "922:      {",
          "923:   if (generate_store_var(cctx, dest, opt_flags, vimvaridx,",
          "924:            0, 0, type, name) == FAIL)",
          "925:       goto failed;",
          "926:      }",
          "927:      else if (varlen == 1 && *arg == '_')",
          "928:      {",
          "930:   if (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)",
          "931:       goto failed;",
          "932:      }",
          "933:      else",
          "934:      {",
          "936:   if (STRNCMP(name, \"s:\", 2) == 0)",
          "937:   {",
          "938:       emsg(_(e_cannot_use_script_variable_in_for_loop));",
          "939:       goto failed;",
          "940:   }",
          "942:   if (!valid_varname(arg, (int)varlen, FALSE))",
          "943:       goto failed;",
          "944:   if (lookup_local(arg, varlen, NULL, cctx) == OK)",
          "945:   {",
          "946:       semsg(_(e_variable_already_declared), arg);",
          "947:       goto failed;",
          "948:   }",
          "951:   where.wt_index = var_list ? idx + 1 : 0;",
          "952:   where.wt_variable = TRUE;",
          "953:   if (lhs_type == &t_any)",
          "954:       lhs_type = item_type;",
          "955:   else if (item_type != &t_unknown",
          "956:        && (item_type == &t_any",
          "957:          ? need_type(item_type, lhs_type,",
          "958:            -1, 0, cctx, FALSE, FALSE)",
          "959:          : check_type(lhs_type, item_type, TRUE, where))",
          "960:        == FAIL)",
          "961:       goto failed;",
          "962:   var_lvar = reserve_local(cctx, arg, varlen, TRUE, lhs_type);",
          "963:   if (var_lvar == NULL)",
          "965:       goto failed;",
          "967:   if (semicolon && idx == var_count - 1)",
          "968:       var_lvar->lv_type = vartype;",
          "969:   else",
          "970:       var_lvar->lv_type = item_type;",
          "971:   generate_STORE(cctx, ISN_STORE, var_lvar->lv_idx, NULL);",
          "972:      }",
          "974:      if (*p == ',' || *p == ';')",
          "975:   ++p;",
          "976:      arg = skipwhite(p);",
          "977:      vim_free(name);",
          "978:  }",
          "980:  if (cctx->ctx_compile_type == CT_DEBUG)",
          "981:  {",
          "982:      int save_prev_lnum = cctx->ctx_prev_lnum;",
          "986:      cctx->ctx_prev_lnum = prev_lnum;",
          "987:      generate_instr_debug(cctx);",
          "988:      cctx->ctx_prev_lnum = save_prev_lnum;",
          "989:  }",
          "990:     }",
          "992:     return arg_end;",
          "994: failed:",
          "995:     vim_free(name);",
          "996:     drop_scope(cctx);",
          "997:     return NULL;",
          "998: }",
          "1003:     char_u *",
          "1004: compile_endfor(char_u *arg, cctx_T *cctx)",
          "1005: {",
          "1006:     garray_T *instr = &cctx->ctx_instr;",
          "1007:     scope_T *scope = cctx->ctx_scope;",
          "1008:     forscope_T *forscope;",
          "1009:     isn_T *isn;",
          "1011:     if (misplaced_cmdmod(cctx))",
          "1012:  return NULL;",
          "1014:     if (scope == NULL || scope->se_type != FOR_SCOPE)",
          "1015:     {",
          "1016:  emsg(_(e_for));",
          "1017:  return NULL;",
          "1018:     }",
          "1019:     forscope = &scope->se_u.se_for;",
          "1020:     cctx->ctx_scope = scope->se_outer;",
          "1021:     if (cctx->ctx_skip != SKIP_YES)",
          "1022:     {",
          "1023:  unwind_locals(cctx, scope->se_local_count);",
          "1026:  generate_JUMP(cctx, JUMP_ALWAYS, forscope->fs_top_label);",
          "1029:  isn = ((isn_T *)instr->ga_data) + forscope->fs_top_label;",
          "1030:  isn->isn_arg.forloop.for_end = instr->ga_len;",
          "1033:  compile_fill_jump_to_end(&forscope->fs_end_label, instr->ga_len, cctx);",
          "1036:  if (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)",
          "1037:      return NULL;",
          "1038:     }",
          "1040:     vim_free(scope);",
          "1042:     return arg;",
          "1043: }",
          "1056:     char_u *",
          "1057: compile_while(char_u *arg, cctx_T *cctx)",
          "1058: {",
          "1059:     char_u *p = arg;",
          "1060:     scope_T *scope;",
          "1062:     scope = new_scope(cctx, WHILE_SCOPE);",
          "1063:     if (scope == NULL)",
          "1064:  return NULL;",
          "1067:     scope->se_u.se_while.ws_top_label = current_instr_idx(cctx);",
          "1070:     if (compile_expr0(&p, cctx) == FAIL)",
          "1071:  return NULL;",
          "1073:     if (!ends_excmd2(arg, skipwhite(p)))",
          "1074:     {",
          "1075:  semsg(_(e_trailing_arg), p);",
          "1076:  return NULL;",
          "1077:     }",
          "1079:     if (cctx->ctx_skip != SKIP_YES)",
          "1080:     {",
          "1081:  if (bool_on_stack(cctx) == FAIL)",
          "1082:      return FAIL;",
          "1085:  generate_undo_cmdmods(cctx);",
          "1088:  if (compile_jump_to_end(&scope->se_u.se_while.ws_end_label,",
          "1089:         JUMP_IF_FALSE, cctx) == FAIL)",
          "1090:      return FAIL;",
          "1091:     }",
          "1093:     return p;",
          "1094: }",
          "1099:     char_u *",
          "1100: compile_endwhile(char_u *arg, cctx_T *cctx)",
          "1101: {",
          "1102:     scope_T *scope = cctx->ctx_scope;",
          "1103:     garray_T *instr = &cctx->ctx_instr;",
          "1105:     if (misplaced_cmdmod(cctx))",
          "1106:  return NULL;",
          "1107:     if (scope == NULL || scope->se_type != WHILE_SCOPE)",
          "1108:     {",
          "1109:  emsg(_(e_while));",
          "1110:  return NULL;",
          "1111:     }",
          "1112:     cctx->ctx_scope = scope->se_outer;",
          "1113:     if (cctx->ctx_skip != SKIP_YES)",
          "1114:     {",
          "1115:  unwind_locals(cctx, scope->se_local_count);",
          "1117: #ifdef FEAT_PROFILE",
          "1119:  may_generate_prof_end(cctx, cctx->ctx_lnum);",
          "1120: #endif",
          "1123:  generate_JUMP(cctx, JUMP_ALWAYS, scope->se_u.se_while.ws_top_label);",
          "1127:  compile_fill_jump_to_end(&scope->se_u.se_while.ws_end_label,",
          "1128:          instr->ga_len, cctx);",
          "1129:     }",
          "1131:     vim_free(scope);",
          "1133:     return arg;",
          "1134: }",
          "1139:     char_u *",
          "1140: compile_continue(char_u *arg, cctx_T *cctx)",
          "1141: {",
          "1142:     scope_T *scope = cctx->ctx_scope;",
          "1143:     int  try_scopes = 0;",
          "1144:     int  loop_label;",
          "1146:     for (;;)",
          "1147:     {",
          "1148:  if (scope == NULL)",
          "1149:  {",
          "1150:      emsg(_(e_continue));",
          "1151:      return NULL;",
          "1152:  }",
          "1153:  if (scope->se_type == FOR_SCOPE)",
          "1154:  {",
          "1155:      loop_label = scope->se_u.se_for.fs_top_label;",
          "1156:      break;",
          "1157:  }",
          "1158:  if (scope->se_type == WHILE_SCOPE)",
          "1159:  {",
          "1160:      loop_label = scope->se_u.se_while.ws_top_label;",
          "1161:      break;",
          "1162:  }",
          "1163:  if (scope->se_type == TRY_SCOPE)",
          "1164:      ++try_scopes;",
          "1165:  scope = scope->se_outer;",
          "1166:     }",
          "1168:     if (try_scopes > 0)",
          "1171:  generate_TRYCONT(cctx, try_scopes, loop_label);",
          "1172:     else",
          "1174:  generate_JUMP(cctx, JUMP_ALWAYS, loop_label);",
          "1176:     return arg;",
          "1177: }",
          "1182:     char_u *",
          "1183: compile_break(char_u *arg, cctx_T *cctx)",
          "1184: {",
          "1185:     scope_T *scope = cctx->ctx_scope;",
          "1186:     endlabel_T **el;",
          "1188:     for (;;)",
          "1189:     {",
          "1190:  if (scope == NULL)",
          "1191:  {",
          "1192:      emsg(_(e_break));",
          "1193:      return NULL;",
          "1194:  }",
          "1195:  if (scope->se_type == FOR_SCOPE || scope->se_type == WHILE_SCOPE)",
          "1196:      break;",
          "1197:  scope = scope->se_outer;",
          "1198:     }",
          "1201:     if (scope->se_type == FOR_SCOPE)",
          "1202:  el = &scope->se_u.se_for.fs_end_label;",
          "1203:     else",
          "1204:  el = &scope->se_u.se_while.ws_end_label;",
          "1205:     if (compile_jump_to_end(el, JUMP_ALWAYS, cctx) == FAIL)",
          "1206:  return FAIL;",
          "1208:     return arg;",
          "1209: }",
          "1214:     char_u *",
          "1215: compile_block(char_u *arg, cctx_T *cctx)",
          "1216: {",
          "1217:     if (new_scope(cctx, BLOCK_SCOPE) == NULL)",
          "1218:  return NULL;",
          "1219:     return skipwhite(arg + 1);",
          "1220: }",
          "1225:     void",
          "1226: compile_endblock(cctx_T *cctx)",
          "1227: {",
          "1228:     scope_T *scope = cctx->ctx_scope;",
          "1230:     cctx->ctx_scope = scope->se_outer;",
          "1231:     unwind_locals(cctx, scope->se_local_count);",
          "1232:     vim_free(scope);",
          "1233: }",
          "1267:     char_u *",
          "1268: compile_try(char_u *arg, cctx_T *cctx)",
          "1269: {",
          "1270:     garray_T *instr = &cctx->ctx_instr;",
          "1271:     scope_T *try_scope;",
          "1272:     scope_T *scope;",
          "1274:     if (misplaced_cmdmod(cctx))",
          "1275:  return NULL;",
          "1278:     try_scope = new_scope(cctx, TRY_SCOPE);",
          "1279:     if (try_scope == NULL)",
          "1280:  return NULL;",
          "1282:     if (cctx->ctx_skip != SKIP_YES)",
          "1283:     {",
          "1284:  isn_T *isn;",
          "1290:  try_scope->se_u.se_try.ts_try_label = instr->ga_len;",
          "1291:  if ((isn = generate_instr(cctx, ISN_TRY)) == NULL)",
          "1292:      return NULL;",
          "1293:  isn->isn_arg.try.try_ref = ALLOC_CLEAR_ONE(tryref_T);",
          "1294:  if (isn->isn_arg.try.try_ref == NULL)",
          "1295:      return NULL;",
          "1296:     }",
          "1299:     scope = new_scope(cctx, BLOCK_SCOPE);",
          "1300:     if (scope == NULL)",
          "1301:  return NULL;",
          "1303:     return arg;",
          "1304: }",
          "1309:     char_u *",
          "1310: compile_catch(char_u *arg, cctx_T *cctx UNUSED)",
          "1311: {",
          "1312:     scope_T *scope = cctx->ctx_scope;",
          "1313:     garray_T *instr = &cctx->ctx_instr;",
          "1314:     char_u *p;",
          "1315:     isn_T *isn;",
          "1317:     if (misplaced_cmdmod(cctx))",
          "1318:  return NULL;",
          "1321:     if (scope != NULL && scope->se_type == BLOCK_SCOPE)",
          "1322:  compile_endblock(cctx);",
          "1323:     scope = cctx->ctx_scope;",
          "1326:     if (scope == NULL || scope->se_type != TRY_SCOPE)",
          "1327:     {",
          "1328:  emsg(_(e_catch));",
          "1329:  return NULL;",
          "1330:     }",
          "1332:     if (scope->se_u.se_try.ts_caught_all)",
          "1333:     {",
          "1334:  emsg(_(e_catch_unreachable_after_catch_all));",
          "1335:  return NULL;",
          "1336:     }",
          "1338:     if (cctx->ctx_skip != SKIP_YES)",
          "1339:     {",
          "1340: #ifdef FEAT_PROFILE",
          "1342:  if (cctx->ctx_compile_type == CT_PROFILE",
          "1343:   && instr->ga_len > 0",
          "1344:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "1345:          .isn_type == ISN_PROF_START)",
          "1346:      --instr->ga_len;",
          "1347: #endif",
          "1349:  if (compile_jump_to_end(&scope->se_u.se_try.ts_end_label,",
          "1350:           JUMP_ALWAYS, cctx) == FAIL)",
          "1351:      return NULL;",
          "1354:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;",
          "1355:  if (isn->isn_arg.try.try_ref->try_catch == 0)",
          "1356:      isn->isn_arg.try.try_ref->try_catch = instr->ga_len;",
          "1357:  if (scope->se_u.se_try.ts_catch_label != 0)",
          "1358:  {",
          "1360:      isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;",
          "1361:      isn->isn_arg.jump.jump_where = instr->ga_len;",
          "1362:  }",
          "1363: #ifdef FEAT_PROFILE",
          "1364:  if (cctx->ctx_compile_type == CT_PROFILE)",
          "1365:  {",
          "1367:      generate_instr(cctx, ISN_PROF_END);",
          "1369:      generate_instr(cctx, ISN_PROF_START);",
          "1370:  }",
          "1371: #endif",
          "1372:  if (cctx->ctx_compile_type == CT_DEBUG)",
          "1373:      generate_instr_debug(cctx);",
          "1374:     }",
          "1376:     p = skipwhite(arg);",
          "1377:     if (ends_excmd2(arg, p))",
          "1378:     {",
          "1379:  scope->se_u.se_try.ts_caught_all = TRUE;",
          "1380:  scope->se_u.se_try.ts_catch_label = 0;",
          "1381:     }",
          "1382:     else",
          "1383:     {",
          "1384:  char_u *end;",
          "1385:  char_u *pat;",
          "1386:  char_u *tofree = NULL;",
          "1387:  int dropped = 0;",
          "1388:  int len;",
          "1391:  generate_instr_type(cctx, ISN_PUSHEXC, &t_string);",
          "1393:  end = skip_regexp_ex(p + 1, *p, TRUE, &tofree, &dropped, NULL);",
          "1394:  if (*end != *p)",
          "1395:  {",
          "1396:      semsg(_(e_separator_mismatch_str), p);",
          "1397:      vim_free(tofree);",
          "1398:      return FAIL;",
          "1399:  }",
          "1400:  if (tofree == NULL)",
          "1401:      len = (int)(end - (p + 1));",
          "1402:  else",
          "1403:      len = (int)(end - tofree);",
          "1404:  pat = vim_strnsave(tofree == NULL ? p + 1 : tofree, len);",
          "1405:  vim_free(tofree);",
          "1406:  p += len + 2 + dropped;",
          "1407:  if (pat == NULL)",
          "1408:      return FAIL;",
          "1409:  if (generate_PUSHS(cctx, &pat) == FAIL)",
          "1410:      return FAIL;",
          "1412:  if (generate_COMPARE(cctx, EXPR_MATCH, FALSE) == FAIL)",
          "1413:      return NULL;",
          "1415:  scope->se_u.se_try.ts_catch_label = instr->ga_len;",
          "1416:  if (generate_JUMP(cctx, JUMP_IF_FALSE, 0) == FAIL)",
          "1417:      return NULL;",
          "1418:     }",
          "1420:     if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_CATCH) == NULL)",
          "1421:  return NULL;",
          "1423:     if (new_scope(cctx, BLOCK_SCOPE) == NULL)",
          "1424:  return NULL;",
          "1425:     return p;",
          "1426: }",
          "1428:     char_u *",
          "1429: compile_finally(char_u *arg, cctx_T *cctx)",
          "1430: {",
          "1431:     scope_T *scope = cctx->ctx_scope;",
          "1432:     garray_T *instr = &cctx->ctx_instr;",
          "1433:     isn_T *isn;",
          "1434:     int  this_instr;",
          "1436:     if (misplaced_cmdmod(cctx))",
          "1437:  return NULL;",
          "1440:     if (scope != NULL && scope->se_type == BLOCK_SCOPE)",
          "1441:  compile_endblock(cctx);",
          "1442:     scope = cctx->ctx_scope;",
          "1445:     if (scope == NULL || scope->se_type != TRY_SCOPE)",
          "1446:     {",
          "1447:  emsg(_(e_finally));",
          "1448:  return NULL;",
          "1449:     }",
          "1451:     if (cctx->ctx_skip != SKIP_YES)",
          "1452:     {",
          "1454:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;",
          "1455:  if (isn->isn_arg.try.try_ref->try_finally != 0)",
          "1456:  {",
          "1457:      emsg(_(e_finally_dup));",
          "1458:      return NULL;",
          "1459:  }",
          "1461:  this_instr = instr->ga_len;",
          "1462: #ifdef FEAT_PROFILE",
          "1463:  if (cctx->ctx_compile_type == CT_PROFILE",
          "1464:   && ((isn_T *)instr->ga_data)[this_instr - 1]",
          "1465:          .isn_type == ISN_PROF_START)",
          "1466:  {",
          "1468:      --this_instr;",
          "1471:      if (this_instr > 0 && ((isn_T *)instr->ga_data)[this_instr - 1]",
          "1472:            .isn_type == ISN_PROF_END)",
          "1473:   --this_instr;",
          "1474:  }",
          "1475: #endif",
          "1478:  compile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,",
          "1479:             this_instr, cctx);",
          "1482:  if (isn->isn_arg.try.try_ref->try_catch == 0)",
          "1483:      isn->isn_arg.try.try_ref->try_catch = this_instr;",
          "1484:  isn->isn_arg.try.try_ref->try_finally = this_instr;",
          "1485:  if (scope->se_u.se_try.ts_catch_label != 0)",
          "1486:  {",
          "1488:      isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;",
          "1489:      isn->isn_arg.jump.jump_where = this_instr;",
          "1490:      scope->se_u.se_try.ts_catch_label = 0;",
          "1491:  }",
          "1492:  if (generate_instr(cctx, ISN_FINALLY) == NULL)",
          "1493:      return NULL;",
          "1494:     }",
          "1496:     return arg;",
          "1497: }",
          "1499:     char_u *",
          "1500: compile_endtry(char_u *arg, cctx_T *cctx)",
          "1501: {",
          "1502:     scope_T *scope = cctx->ctx_scope;",
          "1503:     garray_T *instr = &cctx->ctx_instr;",
          "1504:     isn_T *try_isn;",
          "1506:     if (misplaced_cmdmod(cctx))",
          "1507:  return NULL;",
          "1510:     if (scope != NULL && scope->se_type == BLOCK_SCOPE)",
          "1511:  compile_endblock(cctx);",
          "1512:     scope = cctx->ctx_scope;",
          "1515:     if (scope == NULL || scope->se_type != TRY_SCOPE)",
          "1516:     {",
          "1517:  if (scope == NULL)",
          "1518:      emsg(_(e_no_endtry));",
          "1519:  else if (scope->se_type == WHILE_SCOPE)",
          "1520:      emsg(_(e_endwhile));",
          "1521:  else if (scope->se_type == FOR_SCOPE)",
          "1522:      emsg(_(e_endfor));",
          "1523:  else",
          "1524:      emsg(_(e_endif));",
          "1525:  return NULL;",
          "1526:     }",
          "1528:     try_isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;",
          "1529:     if (cctx->ctx_skip != SKIP_YES)",
          "1530:     {",
          "1531:  if (try_isn->isn_arg.try.try_ref->try_catch == 0",
          "1532:           && try_isn->isn_arg.try.try_ref->try_finally == 0)",
          "1533:  {",
          "1534:      emsg(_(e_missing_catch_or_finally));",
          "1535:      return NULL;",
          "1536:  }",
          "1538: #ifdef FEAT_PROFILE",
          "1539:  if (cctx->ctx_compile_type == CT_PROFILE",
          "1540:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "1541:       .isn_type == ISN_PROF_START)",
          "1544:      --instr->ga_len;",
          "1545: #endif",
          "1549:  compile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,",
          "1550:          instr->ga_len, cctx);",
          "1552:  if (scope->se_u.se_try.ts_catch_label != 0)",
          "1553:  {",
          "1555:      isn_T *isn = ((isn_T *)instr->ga_data)",
          "1556:         + scope->se_u.se_try.ts_catch_label;",
          "1557:      isn->isn_arg.jump.jump_where = instr->ga_len;",
          "1558:  }",
          "1559:     }",
          "1561:     compile_endblock(cctx);",
          "1563:     if (cctx->ctx_skip != SKIP_YES)",
          "1564:     {",
          "1567:  try_isn->isn_arg.try.try_ref->try_endtry = instr->ga_len;",
          "1568:  if (cctx->ctx_skip != SKIP_YES",
          "1569:        && generate_instr(cctx, ISN_ENDTRY) == NULL)",
          "1570:      return NULL;",
          "1571: #ifdef FEAT_PROFILE",
          "1572:  if (cctx->ctx_compile_type == CT_PROFILE)",
          "1573:      generate_instr(cctx, ISN_PROF_START);",
          "1574: #endif",
          "1575:     }",
          "1576:     return arg;",
          "1577: }",
          "1582:     char_u *",
          "1583: compile_throw(char_u *arg, cctx_T *cctx UNUSED)",
          "1584: {",
          "1585:     char_u *p = skipwhite(arg);",
          "1587:     if (compile_expr0(&p, cctx) == FAIL)",
          "1588:  return NULL;",
          "1589:     if (cctx->ctx_skip == SKIP_YES)",
          "1590:  return p;",
          "1591:     if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "1592:  return NULL;",
          "1593:     if (generate_instr_drop(cctx, ISN_THROW, 1) == NULL)",
          "1594:  return NULL;",
          "1596:     return p;",
          "1597: }",
          "1599:     char_u *",
          "1600: compile_eval(char_u *arg, cctx_T *cctx)",
          "1601: {",
          "1602:     char_u *p = arg;",
          "1603:     int  name_only;",
          "1604:     long lnum = SOURCING_LNUM;",
          "1609:     name_only = cmd_is_name_only(arg);",
          "1611:     if (compile_expr0(&p, cctx) == FAIL)",
          "1612:  return NULL;",
          "1614:     if (name_only && lnum == SOURCING_LNUM)",
          "1615:     {",
          "1616:  semsg(_(e_expression_without_effect_str), arg);",
          "1617:  return NULL;",
          "1618:     }",
          "1621:     generate_instr_drop(cctx, ISN_DROP, 1);",
          "1623:     return skipwhite(p);",
          "1624: }",
          "1633:     char_u *",
          "1634: compile_mult_expr(char_u *arg, int cmdidx, cctx_T *cctx)",
          "1635: {",
          "1636:     char_u *p = arg;",
          "1637:     char_u *prev = arg;",
          "1638:     char_u *expr_start;",
          "1639:     int  count = 0;",
          "1640:     int  start_ctx_lnum = cctx->ctx_lnum;",
          "1641:     garray_T *stack = &cctx->ctx_type_stack;",
          "1642:     type_T *type;",
          "1644:     for (;;)",
          "1645:     {",
          "1646:  if (ends_excmd2(prev, p))",
          "1647:      break;",
          "1648:  expr_start = p;",
          "1649:  if (compile_expr0(&p, cctx) == FAIL)",
          "1650:      return NULL;",
          "1652:  if (cctx->ctx_skip != SKIP_YES)",
          "1653:  {",
          "1655:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1656:      if (type->tt_type == VAR_VOID)",
          "1657:      {",
          "1658:   semsg(_(e_expression_does_not_result_in_value_str), expr_start);",
          "1659:   return NULL;",
          "1660:      }",
          "1661:  }",
          "1663:  ++count;",
          "1664:  prev = p;",
          "1665:  p = skipwhite(p);",
          "1666:     }",
          "1668:     if (count > 0)",
          "1669:     {",
          "1670:  long save_lnum = cctx->ctx_lnum;",
          "1673:  cctx->ctx_lnum = start_ctx_lnum;",
          "1675:  if (cmdidx == CMD_echo || cmdidx == CMD_echon)",
          "1676:      generate_ECHO(cctx, cmdidx == CMD_echo, count);",
          "1677:  else if (cmdidx == CMD_execute)",
          "1678:      generate_MULT_EXPR(cctx, ISN_EXECUTE, count);",
          "1679:  else if (cmdidx == CMD_echomsg)",
          "1680:      generate_MULT_EXPR(cctx, ISN_ECHOMSG, count);",
          "1681:  else if (cmdidx == CMD_echoconsole)",
          "1682:      generate_MULT_EXPR(cctx, ISN_ECHOCONSOLE, count);",
          "1683:  else",
          "1684:      generate_MULT_EXPR(cctx, ISN_ECHOERR, count);",
          "1686:  cctx->ctx_lnum = save_lnum;",
          "1687:     }",
          "1688:     return p;",
          "1689: }",
          "1696:     static int",
          "1697: compile_variable_range(exarg_T *eap, cctx_T *cctx)",
          "1698: {",
          "1699:     char_u *range_end = skip_range(eap->cmd, TRUE, NULL);",
          "1700:     char_u *p = skipdigits(eap->cmd);",
          "1702:     if (p == range_end)",
          "1703:  return FAIL;",
          "1704:     return generate_RANGE(cctx, vim_strnsave(eap->cmd, range_end - eap->cmd));",
          "1705: }",
          "1711:     char_u *",
          "1712: compile_put(char_u *arg, exarg_T *eap, cctx_T *cctx)",
          "1713: {",
          "1714:     char_u *line = arg;",
          "1715:     linenr_T lnum;",
          "1716:     char *errormsg;",
          "1717:     int  above = eap->forceit;",
          "1719:     eap->regname = *line;",
          "1721:     if (eap->regname == '=')",
          "1722:     {",
          "1723:  char_u *p = line + 1;",
          "1725:  if (compile_expr0(&p, cctx) == FAIL)",
          "1726:      return NULL;",
          "1727:  line = p;",
          "1728:     }",
          "1729:     else if (eap->regname != NUL)",
          "1730:  ++line;",
          "1732:     if (compile_variable_range(eap, cctx) == OK)",
          "1733:     {",
          "1734:  lnum = above ? LNUM_VARIABLE_RANGE_ABOVE : LNUM_VARIABLE_RANGE;",
          "1735:     }",
          "1736:     else",
          "1737:     {",
          "1740:  if (parse_cmd_address(eap, &errormsg, FALSE) == FAIL)",
          "1742:      return NULL;",
          "1743:  if (eap->addr_count == 0)",
          "1744:      lnum = -1;",
          "1745:  else",
          "1746:      lnum = eap->line2;",
          "1747:  if (above)",
          "1748:      --lnum;",
          "1749:     }",
          "1751:     generate_PUT(cctx, eap->regname, lnum);",
          "1752:     return line;",
          "1753: }",
          "1758:     char_u *",
          "1759: compile_exec(char_u *line_arg, exarg_T *eap, cctx_T *cctx)",
          "1760: {",
          "1761:     char_u *line = line_arg;",
          "1762:     char_u *p;",
          "1763:     int  has_expr = FALSE;",
          "1764:     char_u *nextcmd = (char_u *)\"\";",
          "1765:     char_u *tofree = NULL;",
          "1766:     char_u *cmd_arg = NULL;",
          "1768:     if (cctx->ctx_skip == SKIP_YES)",
          "1769:  goto theend;",
          "1773:     if (cctx->ctx_has_cmdmod)",
          "1774:     {",
          "1775:  garray_T *instr = &cctx->ctx_instr;",
          "1776:  isn_T  *isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "1778:  if (isn->isn_type == ISN_CMDMOD)",
          "1779:  {",
          "1780:      vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod",
          "1781:             ->cmod_filter_regmatch.regprog);",
          "1782:      vim_free(isn->isn_arg.cmdmod.cf_cmdmod);",
          "1783:      --instr->ga_len;",
          "1784:      cctx->ctx_has_cmdmod = FALSE;",
          "1785:  }",
          "1786:     }",
          "1788:     if (eap->cmdidx >= 0 && eap->cmdidx < CMD_SIZE)",
          "1789:     {",
          "1790:  long argt = eap->argt;",
          "1791:  int usefilter = FALSE;",
          "1793:  has_expr = argt & (EX_XFILE | EX_EXPAND);",
          "1798:  if ((eap->cmdidx == CMD_write || eap->cmdidx == CMD_read)",
          "1799:           && *eap->arg == '!')",
          "1801:      usefilter = TRUE;",
          "1802:  if ((argt & EX_TRLBAR) && !usefilter)",
          "1803:  {",
          "1804:      eap->argt = argt;",
          "1805:      separate_nextcmd(eap);",
          "1806:      if (eap->nextcmd != NULL)",
          "1807:   nextcmd = eap->nextcmd;",
          "1808:  }",
          "1809:  else if (eap->cmdidx == CMD_wincmd)",
          "1810:  {",
          "1811:      p = eap->arg;",
          "1812:      if (*p != NUL)",
          "1813:   ++p;",
          "1814:      if (*p == 'g' || *p == Ctrl_G)",
          "1815:   ++p;",
          "1816:      p = skipwhite(p);",
          "1817:      if (*p == '|')",
          "1818:      {",
          "1820:   nextcmd = p + 1;",
          "1821:      }",
          "1822:  }",
          "1823:  else if (eap->cmdidx == CMD_command || eap->cmdidx == CMD_autocmd)",
          "1824:  {",
          "1826:      p = eap->arg + STRLEN(eap->arg) - 1;",
          "1827:      while (p > eap->arg && VIM_ISWHITE(*p))",
          "1828:   --p;",
          "1829:      if (*p == '{')",
          "1830:      {",
          "1831:   exarg_T ea;",
          "1832:   int flags;  // unused",
          "1833:   int start_lnum = SOURCING_LNUM;",
          "1835:   CLEAR_FIELD(ea);",
          "1836:   ea.arg = eap->arg;",
          "1837:   fill_exarg_from_cctx(&ea, cctx);",
          "1838:   (void)may_get_cmd_block(&ea, p, &tofree, &flags);",
          "1839:   if (tofree != NULL)",
          "1840:   {",
          "1842:       line = concat_str(line, tofree);",
          "1843:       if (line == NULL)",
          "1844:    goto theend;",
          "1845:       vim_free(tofree);",
          "1846:       tofree = line;",
          "1847:       SOURCING_LNUM = start_lnum;",
          "1848:   }",
          "1849:      }",
          "1850:  }",
          "1851:     }",
          "1853:     if (eap->cmdidx == CMD_syntax && STRNCMP(eap->arg, \"include \", 8) == 0)",
          "1854:     {",
          "1856:  has_expr = TRUE;",
          "1857:  eap->arg = skipwhite(eap->arg + 7);",
          "1858:  if (*eap->arg == '@')",
          "1859:      eap->arg = skiptowhite(eap->arg);",
          "1860:     }",
          "1862:     if ((eap->cmdidx == CMD_global || eap->cmdidx == CMD_vglobal)",
          "1863:              && STRLEN(eap->arg) > 4)",
          "1864:     {",
          "1865:  int delim = *eap->arg;",
          "1867:  p = skip_regexp_ex(eap->arg + 1, delim, TRUE, NULL, NULL, NULL);",
          "1868:  if (*p == delim)",
          "1869:      cmd_arg = p + 1;",
          "1870:     }",
          "1872:     if (eap->cmdidx == CMD_folddoopen || eap->cmdidx == CMD_folddoclosed)",
          "1873:  cmd_arg = eap->arg;",
          "1875:     if (cmd_arg != NULL)",
          "1876:     {",
          "1877:  exarg_T nea;",
          "1879:  CLEAR_FIELD(nea);",
          "1880:  nea.cmd = cmd_arg;",
          "1881:  p = find_ex_command(&nea, NULL, lookup_scriptitem, NULL);",
          "1882:  if (nea.cmdidx < CMD_SIZE)",
          "1883:  {",
          "1884:      has_expr = excmd_get_argt(nea.cmdidx) & (EX_XFILE | EX_EXPAND);",
          "1885:      if (has_expr)",
          "1886:   eap->arg = skiptowhite(eap->arg);",
          "1887:  }",
          "1888:     }",
          "1890:     if (has_expr && (p = (char_u *)strstr((char *)eap->arg, \"`=\")) != NULL)",
          "1891:     {",
          "1892:  int count = 0;",
          "1893:  char_u *start = skipwhite(line);",
          "1902:  for (;;)",
          "1903:  {",
          "1904:      if (p > start)",
          "1905:      {",
          "1906:   char_u *val = vim_strnsave(start, p - start);",
          "1908:   generate_PUSHS(cctx, &val);",
          "1909:   ++count;",
          "1910:      }",
          "1911:      p += 2;",
          "1912:      if (compile_expr0(&p, cctx) == FAIL)",
          "1913:   return NULL;",
          "1914:      may_generate_2STRING(-1, TRUE, cctx);",
          "1915:      ++count;",
          "1916:      p = skipwhite(p);",
          "1917:      if (*p != '`')",
          "1918:      {",
          "1919:   emsg(_(e_missing_backtick));",
          "1920:   return NULL;",
          "1921:      }",
          "1922:      start = p + 1;",
          "1924:      p = (char_u *)strstr((char *)start, \"`=\");",
          "1925:      if (p == NULL)",
          "1926:      {",
          "1927:   if (*skipwhite(start) != NUL)",
          "1928:   {",
          "1929:       char_u *val = vim_strsave(start);",
          "1931:       generate_PUSHS(cctx, &val);",
          "1932:       ++count;",
          "1933:   }",
          "1934:   break;",
          "1935:      }",
          "1936:  }",
          "1937:  generate_EXECCONCAT(cctx, count);",
          "1938:     }",
          "1939:     else",
          "1940:  generate_EXEC_copy(cctx, ISN_EXEC, line);",
          "1942: theend:",
          "1943:     if (*nextcmd != NUL)",
          "1944:     {",
          "1946:  --nextcmd;",
          "1948:     }",
          "1949:     vim_free(tofree);",
          "1951:     return nextcmd;",
          "1952: }",
          "1963:     char_u *",
          "1964: compile_script(char_u *line, cctx_T *cctx)",
          "1965: {",
          "1966:     if (cctx->ctx_skip != SKIP_YES)",
          "1967:     {",
          "1968:  isn_T *isn;",
          "1970:  if ((isn = generate_instr(cctx, ISN_EXEC_SPLIT)) == NULL)",
          "1971:      return NULL;",
          "1972:  isn->isn_arg.string = vim_strsave(line);",
          "1973:     }",
          "1974:     return (char_u *)\"\";",
          "1975: }",
          "1981:     char_u *",
          "1982: compile_substitute(char_u *arg, exarg_T *eap, cctx_T *cctx)",
          "1983: {",
          "1984:     char_u  *cmd = eap->arg;",
          "1985:     char_u  *expr = (char_u *)strstr((char *)cmd, \"\\\\=\");",
          "1987:     if (expr != NULL)",
          "1988:     {",
          "1989:  int delimiter = *cmd++;",
          "1992:  cmd = skip_regexp_ex(cmd, delimiter, magic_isset(), NULL, NULL, NULL);",
          "1993:  if (cmd[0] == delimiter && cmd[1] == '\\\\' && cmd[2] == '=')",
          "1994:  {",
          "1995:      garray_T save_ga = cctx->ctx_instr;",
          "1996:      char_u *end;",
          "1997:      int  expr_res;",
          "1998:      int  trailing_error;",
          "1999:      int  instr_count;",
          "2000:      isn_T *instr;",
          "2001:      isn_T *isn;",
          "2003:      cmd += 3;",
          "2004:      end = skip_substitute(cmd, delimiter);",
          "2008:      cctx->ctx_instr.ga_len = 0;",
          "2009:      cctx->ctx_instr.ga_maxlen = 0;",
          "2010:      cctx->ctx_instr.ga_data = NULL;",
          "2011:      expr_res = compile_expr0(&cmd, cctx);",
          "2012:      if (end[-1] == NUL)",
          "2013:   end[-1] = delimiter;",
          "2014:      cmd = skipwhite(cmd);",
          "2015:      trailing_error = *cmd != delimiter && *cmd != NUL;",
          "2017:      if (expr_res == FAIL || trailing_error",
          "2018:            || GA_GROW_FAILS(&cctx->ctx_instr, 1))",
          "2019:      {",
          "2020:   if (trailing_error)",
          "2021:       semsg(_(e_trailing_arg), cmd);",
          "2022:   clear_instr_ga(&cctx->ctx_instr);",
          "2023:   cctx->ctx_instr = save_ga;",
          "2024:   return NULL;",
          "2025:      }",
          "2030:      instr_count = cctx->ctx_instr.ga_len;",
          "2031:      instr = cctx->ctx_instr.ga_data;",
          "2032:      instr[instr_count].isn_type = ISN_FINISH;",
          "2034:      cctx->ctx_instr = save_ga;",
          "2035:      if ((isn = generate_instr(cctx, ISN_SUBSTITUTE)) == NULL)",
          "2036:      {",
          "2037:   int idx;",
          "2039:   for (idx = 0; idx < instr_count; ++idx)",
          "2040:       delete_instr(instr + idx);",
          "2041:   vim_free(instr);",
          "2042:   return NULL;",
          "2043:      }",
          "2044:      isn->isn_arg.subs.subs_cmd = vim_strsave(arg);",
          "2045:      isn->isn_arg.subs.subs_instr = instr;",
          "2048:      if (*end == '&')",
          "2049:   ++end;",
          "2050:      while (ASCII_ISALPHA(*end) || *end == '#')",
          "2051:   ++end;",
          "2052:      return end;",
          "2053:  }",
          "2054:     }",
          "2056:     return compile_exec(arg, eap, cctx);",
          "2057: }",
          "2059:     char_u *",
          "2060: compile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)",
          "2061: {",
          "2062:     char_u  *arg = eap->arg;",
          "2063:     lhs_T   *lhs = &cctx->ctx_redir_lhs;",
          "2065:     if (lhs->lhs_name != NULL)",
          "2066:     {",
          "2067:  if (STRNCMP(arg, \"END\", 3) == 0)",
          "2068:  {",
          "2069:      if (lhs->lhs_append)",
          "2070:      {",
          "2072:   if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,",
          "2073:          cctx) == FAIL)",
          "2074:       return NULL;",
          "2075:      }",
          "2079:      generate_instr_type(cctx, ISN_REDIREND, &t_string);",
          "2081:      if (lhs->lhs_append)",
          "2082:   generate_instr_drop(cctx, ISN_CONCAT, 1);",
          "2084:      if (lhs->lhs_has_index)",
          "2085:      {",
          "2088:   if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,",
          "2089:             &t_string, cctx) == FAIL)",
          "2090:       return NULL;",
          "2091:      }",
          "2092:      else if (generate_store_lhs(cctx, lhs, -1) == FAIL)",
          "2093:   return NULL;",
          "2095:      VIM_CLEAR(lhs->lhs_name);",
          "2096:      VIM_CLEAR(lhs->lhs_whole);",
          "2097:      return arg + 3;",
          "2098:  }",
          "2099:  emsg(_(e_cannot_nest_redir));",
          "2100:  return NULL;",
          "2101:     }",
          "2103:     if (arg[0] == '=' && arg[1] == '>')",
          "2104:     {",
          "2105:  int     append = FALSE;",
          "2108:  arg += 2;",
          "2109:  if (*arg == '>')",
          "2110:  {",
          "2111:      ++arg;",
          "2112:      append = TRUE;",
          "2113:  }",
          "2114:  arg = skipwhite(arg);",
          "2116:  if (compile_assign_lhs(arg, lhs, CMD_redir,",
          "2117:       FALSE, FALSE, 1, cctx) == FAIL)",
          "2118:      return NULL;",
          "2119:  if (need_type(&t_string, lhs->lhs_member_type,",
          "2120:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "2121:      return NULL;",
          "2122:  generate_instr(cctx, ISN_REDIRSTART);",
          "2123:  lhs->lhs_append = append;",
          "2124:  if (lhs->lhs_has_index)",
          "2125:  {",
          "2126:      lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);",
          "2127:      if (lhs->lhs_whole == NULL)",
          "2128:   return NULL;",
          "2129:  }",
          "2131:  return arg + lhs->lhs_varlen_total;",
          "2132:     }",
          "2135:     return compile_exec(line, eap, cctx);",
          "2136: }",
          "2138: #if defined(FEAT_QUICKFIX) || defined(PROTO)",
          "2139:     char_u *",
          "2140: compile_cexpr(char_u *line, exarg_T *eap, cctx_T *cctx)",
          "2141: {",
          "2142:     isn_T *isn;",
          "2143:     char_u *p;",
          "2145:     isn = generate_instr(cctx, ISN_CEXPR_AUCMD);",
          "2146:     if (isn == NULL)",
          "2147:  return NULL;",
          "2148:     isn->isn_arg.number = eap->cmdidx;",
          "2150:     p = eap->arg;",
          "2151:     if (compile_expr0(&p, cctx) == FAIL)",
          "2152:  return NULL;",
          "2154:     isn = generate_instr(cctx, ISN_CEXPR_CORE);",
          "2155:     if (isn == NULL)",
          "2156:  return NULL;",
          "2157:     isn->isn_arg.cexpr.cexpr_ref = ALLOC_ONE(cexprref_T);",
          "2158:     if (isn->isn_arg.cexpr.cexpr_ref == NULL)",
          "2159:  return NULL;",
          "2160:     isn->isn_arg.cexpr.cexpr_ref->cer_cmdidx = eap->cmdidx;",
          "2161:     isn->isn_arg.cexpr.cexpr_ref->cer_forceit = eap->forceit;",
          "2162:     isn->isn_arg.cexpr.cexpr_ref->cer_cmdline = vim_strsave(skipwhite(line));",
          "2164:     return p;",
          "2165: }",
          "2166: #endif",
          "2172:     char_u *",
          "2173: compile_return(char_u *arg, int check_return_type, int legacy, cctx_T *cctx)",
          "2174: {",
          "2175:     char_u *p = arg;",
          "2176:     garray_T *stack = &cctx->ctx_type_stack;",
          "2177:     type_T *stack_type;",
          "2179:     if (*p != NUL && *p != '|' && *p != '\\n')",
          "2180:     {",
          "2181:  if (legacy)",
          "2182:  {",
          "2183:      int save_flags = cmdmod.cmod_flags;",
          "2185:      generate_LEGACY_EVAL(cctx, p);",
          "2186:      if (need_type(&t_any, cctx->ctx_ufunc->uf_ret_type, -1,",
          "2187:       0, cctx, FALSE, FALSE) == FAIL)",
          "2188:   return NULL;",
          "2189:      cmdmod.cmod_flags |= CMOD_LEGACY;",
          "2190:      (void)skip_expr(&p, NULL);",
          "2191:      cmdmod.cmod_flags = save_flags;",
          "2192:  }",
          "2193:  else",
          "2194:  {",
          "2196:      if (compile_expr0(&p, cctx) == FAIL)",
          "2197:   return NULL;",
          "2198:  }",
          "2200:  if (cctx->ctx_skip != SKIP_YES)",
          "2201:  {",
          "2205:      stack_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "2206:      if ((check_return_type && (cctx->ctx_ufunc->uf_ret_type == NULL",
          "2207:     || cctx->ctx_ufunc->uf_ret_type == &t_unknown",
          "2208:     || cctx->ctx_ufunc->uf_ret_type == &t_any))",
          "2209:       || (!check_return_type",
          "2210:     && cctx->ctx_ufunc->uf_ret_type == &t_unknown))",
          "2211:      {",
          "2212:   cctx->ctx_ufunc->uf_ret_type = stack_type;",
          "2213:      }",
          "2214:      else",
          "2215:      {",
          "2216:   if (cctx->ctx_ufunc->uf_ret_type->tt_type == VAR_VOID",
          "2217:    && stack_type->tt_type != VAR_VOID",
          "2218:    && stack_type->tt_type != VAR_UNKNOWN)",
          "2219:   {",
          "2220:       emsg(_(e_returning_value_in_function_without_return_type));",
          "2221:       return NULL;",
          "2222:   }",
          "2223:   if (need_type(stack_type, cctx->ctx_ufunc->uf_ret_type, -1,",
          "2224:       0, cctx, FALSE, FALSE) == FAIL)",
          "2225:       return NULL;",
          "2226:      }",
          "2227:  }",
          "2228:     }",
          "2229:     else",
          "2230:     {",
          "2233:  if (cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_VOID",
          "2234:   && cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_UNKNOWN)",
          "2235:  {",
          "2236:      emsg(_(e_missing_return_value));",
          "2237:      return NULL;",
          "2238:  }",
          "2241:  generate_PUSHNR(cctx, 0);",
          "2242:     }",
          "2245:     generate_undo_cmdmods(cctx);",
          "2247:     if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_RETURN) == NULL)",
          "2248:  return NULL;",
          "2251:     return skipwhite(p);",
          "2252: }",
          "2257:     int",
          "2258: check_global_and_subst(char_u *cmd, char_u *arg)",
          "2259: {",
          "2260:     if (arg == cmd + 1 && vim_strchr((char_u *)\":-.\", *arg) != NULL)",
          "2261:     {",
          "2262:  semsg(_(e_separator_not_supported_str), arg);",
          "2263:  return FAIL;",
          "2264:     }",
          "2265:     if (VIM_ISWHITE(cmd[1]))",
          "2266:     {",
          "2267:  semsg(_(e_no_white_space_allowed_before_separator_str), cmd);",
          "2268:  return FAIL;",
          "2269:     }",
          "2270:     return OK;",
          "2271: }",
          "2274: #endif  // defined(FEAT_EVAL)",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #if defined(FEAT_EVAL) || defined(PROTO)",
          "21: #endif",
          "208: static void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);",
          "",
          "[Removed Lines]",
          "19: #ifdef VMS",
          "20: # include <float.h>",
          "23: #define DEFINE_VIM9_GLOBALS",
          "24: #include \"vim9.h\"",
          "27: typedef enum {",
          "28:     SKIP_NOT,  // condition is a constant, produce code",
          "29:     SKIP_YES,  // condition is a constant, do NOT produce code",
          "30:     SKIP_UNKNOWN // condition is not a constant, produce code",
          "31: } skip_T;",
          "36: typedef struct endlabel_S endlabel_T;",
          "37: struct endlabel_S {",
          "38:     endlabel_T *el_next;     // chain end_label locations",
          "39:     int  el_end_label;     // instruction idx where to set end",
          "40: };",
          "45: typedef struct {",
          "46:     int  is_seen_else;",
          "47:     int  is_seen_skip_not;   // a block was unconditionally executed",
          "48:     int  is_had_return;     // every block ends in :return",
          "49:     int  is_if_label;     // instruction idx at IF or ELSEIF",
          "50:     endlabel_T *is_end_label;     // instructions to set end label",
          "51: } ifscope_T;",
          "56: typedef struct {",
          "57:     int  ws_top_label;     // instruction idx at WHILE",
          "58:     endlabel_T *ws_end_label;     // instructions to set end",
          "59: } whilescope_T;",
          "64: typedef struct {",
          "65:     int  fs_top_label;     // instruction idx at FOR",
          "66:     endlabel_T *fs_end_label;     // break instructions",
          "67: } forscope_T;",
          "72: typedef struct {",
          "73:     int  ts_try_label;     // instruction idx at TRY",
          "74:     endlabel_T *ts_end_label;     // jump to :finally or :endtry",
          "75:     int  ts_catch_label;     // instruction idx of last CATCH",
          "76:     int  ts_caught_all;     // \"catch\" without argument encountered",
          "77: } tryscope_T;",
          "79: typedef enum {",
          "80:     NO_SCOPE,",
          "81:     IF_SCOPE,",
          "82:     WHILE_SCOPE,",
          "83:     FOR_SCOPE,",
          "84:     TRY_SCOPE,",
          "85:     BLOCK_SCOPE",
          "86: } scopetype_T;",
          "91: typedef struct scope_S scope_T;",
          "92: struct scope_S {",
          "93:     scope_T *se_outer;     // scope containing this one",
          "94:     scopetype_T se_type;",
          "95:     int  se_local_count;     // ctx_locals.ga_len before scope",
          "96:     skip_T se_skip_save;     // ctx_skip before the block",
          "97:     union {",
          "98:  ifscope_T se_if;",
          "99:  whilescope_T se_while;",
          "100:  forscope_T se_for;",
          "101:  tryscope_T se_try;",
          "102:     } se_u;",
          "103: };",
          "108: typedef struct {",
          "109:     char_u *lv_name;",
          "110:     type_T *lv_type;",
          "111:     int  lv_idx;  // index of the variable on the stack",
          "112:     int  lv_from_outer; // nesting level, using ctx_outer scope",
          "113:     int  lv_const; // when TRUE cannot be assigned to",
          "114:     int  lv_arg;  // when TRUE this is an argument",
          "115: } lvar_T;",
          "118: typedef enum {",
          "119:     dest_local,",
          "120:     dest_option,",
          "121:     dest_func_option,",
          "122:     dest_env,",
          "123:     dest_global,",
          "124:     dest_buffer,",
          "125:     dest_window,",
          "126:     dest_tab,",
          "127:     dest_vimvar,",
          "128:     dest_script,",
          "129:     dest_reg,",
          "130:     dest_expr,",
          "131: } assign_dest_T;",
          "135: typedef struct {",
          "136:     assign_dest_T   lhs_dest;     // type of destination",
          "138:     char_u     *lhs_name;     // allocated name excluding the last",
          "140:     size_t     lhs_varlen;     // length of the variable without",
          "142:     char_u     *lhs_whole;     // allocated name including the last",
          "144:     size_t     lhs_varlen_total; // length of the variable including",
          "146:     char_u     *lhs_dest_end;  // end of the destination, including",
          "148:     char_u     *lhs_end;     // end including any type",
          "150:     int      lhs_has_index;  // has \"[expr]\" or \".name\"",
          "152:     int      lhs_new_local;  // create new local variable",
          "153:     int      lhs_opt_flags;  // for when destination is an option",
          "154:     int      lhs_vimvaridx;  // for when destination is a v:var",
          "156:     lvar_T     lhs_local_lvar; // used for existing local destination",
          "157:     lvar_T     lhs_arg_lvar;   // used for argument destination",
          "158:     lvar_T     *lhs_lvar;     // points to destination lvar",
          "159:     int      lhs_scriptvar_sid;",
          "160:     int      lhs_scriptvar_idx;",
          "162:     int      lhs_has_type;   // type was specified",
          "163:     type_T     *lhs_type;",
          "164:     type_T     *lhs_member_type;",
          "166:     int      lhs_append;     // used by ISN_REDIREND",
          "167: } lhs_T;",
          "173: struct cctx_S {",
          "174:     ufunc_T *ctx_ufunc;     // current function",
          "175:     int  ctx_lnum;     // line number in current function",
          "176:     char_u *ctx_line_start;    // start of current line or NULL",
          "177:     garray_T ctx_instr;     // generated instructions",
          "179:     int  ctx_prev_lnum;     // line number below previous command, for",
          "182:     compiletype_T ctx_compile_type;",
          "184:     garray_T ctx_locals;     // currently visible local variables",
          "186:     int  ctx_has_closure;    // set to one if a closures was created in",
          "189:     garray_T ctx_imports;     // imported items",
          "191:     skip_T ctx_skip;",
          "192:     scope_T *ctx_scope;     // current scope, NULL at toplevel",
          "193:     int  ctx_had_return;     // last seen statement was \"return\"",
          "195:     cctx_T *ctx_outer;     // outer scope for lambda or nested",
          "197:     int  ctx_outer_used;     // var in ctx_outer was used",
          "199:     garray_T ctx_type_stack;     // type of each item on the stack",
          "200:     garray_T *ctx_type_list;     // list of pointers to allocated types",
          "202:     int  ctx_has_cmdmod;     // ISN_CMDMOD was generated",
          "204:     lhs_T ctx_redir_lhs;     // LHS for \":redir => var\", valid when",
          "206: };",
          "",
          "[Added Lines]",
          "20: #ifdef PROTO",
          "21: # include \"vim9.h\"",
          "27: garray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "217: lookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)",
          "218: {",
          "219:     int     idx;",
          "",
          "[Removed Lines]",
          "216:     static int",
          "",
          "[Added Lines]",
          "37:     int",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "266: arg_exists(",
          "267:  char_u *name,",
          "268:  size_t len,",
          "",
          "[Removed Lines]",
          "265:     static int",
          "",
          "[Added Lines]",
          "86:     int",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401: script_is_vim9()",
          "402: {",
          "403:     return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;",
          "",
          "[Removed Lines]",
          "400:     static int",
          "",
          "[Added Lines]",
          "221:     int",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "412: script_var_exists(char_u *name, size_t len, cctx_T *cctx)",
          "413: {",
          "414:     if (current_sctx.sc_sid <= 0)",
          "",
          "[Removed Lines]",
          "411:     static int",
          "",
          "[Added Lines]",
          "232:     int",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "533: }",
          "",
          "[Removed Lines]",
          "539: #define RETURN_NULL_IF_SKIP(cctx) if (cctx->ctx_skip == SKIP_YES) return NULL",
          "540: #define RETURN_OK_IF_SKIP(cctx) if (cctx->ctx_skip == SKIP_YES) return OK",
          "546:     static isn_T *",
          "547: generate_instr(cctx_T *cctx, isntype_T isn_type)",
          "548: {",
          "549:     garray_T *instr = &cctx->ctx_instr;",
          "550:     isn_T *isn;",
          "552:     RETURN_NULL_IF_SKIP(cctx);",
          "553:     if (GA_GROW_FAILS(instr, 1))",
          "554:  return NULL;",
          "555:     isn = ((isn_T *)instr->ga_data) + instr->ga_len;",
          "556:     isn->isn_type = isn_type;",
          "557:     isn->isn_lnum = cctx->ctx_lnum + 1;",
          "558:     ++instr->ga_len;",
          "560:     return isn;",
          "561: }",
          "568:     static isn_T *",
          "569: generate_instr_drop(cctx_T *cctx, isntype_T isn_type, int drop)",
          "570: {",
          "571:     garray_T *stack = &cctx->ctx_type_stack;",
          "573:     RETURN_NULL_IF_SKIP(cctx);",
          "574:     stack->ga_len -= drop;",
          "575:     return generate_instr(cctx, isn_type);",
          "576: }",
          "581:     static isn_T *",
          "582: generate_instr_type(cctx_T *cctx, isntype_T isn_type, type_T *type)",
          "583: {",
          "584:     isn_T *isn;",
          "585:     garray_T *stack = &cctx->ctx_type_stack;",
          "587:     if ((isn = generate_instr(cctx, isn_type)) == NULL)",
          "588:  return NULL;",
          "590:     if (GA_GROW_FAILS(stack, 1))",
          "591:  return NULL;",
          "592:     ((type_T **)stack->ga_data)[stack->ga_len] = type == NULL ? &t_any : type;",
          "593:     ++stack->ga_len;",
          "595:     return isn;",
          "596: }",
          "601:     static isn_T *",
          "602: generate_instr_debug(cctx_T *cctx)",
          "603: {",
          "604:     isn_T *isn;",
          "605:     dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "606:             + cctx->ctx_ufunc->uf_dfunc_idx;",
          "608:     if ((isn = generate_instr(cctx, ISN_DEBUG)) == NULL)",
          "609:  return NULL;",
          "610:     isn->isn_arg.debug.dbg_var_names_len = dfunc->df_var_names.ga_len;",
          "611:     isn->isn_arg.debug.dbg_break_lnum = cctx->ctx_prev_lnum;",
          "612:     return isn;",
          "613: }",
          "620:     static int",
          "621: may_generate_2STRING(int offset, int tolerant, cctx_T *cctx)",
          "622: {",
          "623:     isn_T *isn;",
          "624:     isntype_T isntype = ISN_2STRING;",
          "625:     garray_T *stack = &cctx->ctx_type_stack;",
          "626:     type_T **type;",
          "628:     RETURN_OK_IF_SKIP(cctx);",
          "629:     type = ((type_T **)stack->ga_data) + stack->ga_len + offset;",
          "630:     switch ((*type)->tt_type)",
          "631:     {",
          "633:  case VAR_STRING: return OK;",
          "636:  case VAR_SPECIAL:",
          "637:  case VAR_BOOL:",
          "638:  case VAR_NUMBER:",
          "639:  case VAR_FLOAT:",
          "640:     break;",
          "643:  case VAR_ANY:",
          "644:  case VAR_UNKNOWN:",
          "645:     isntype = ISN_2STRING_ANY;",
          "646:     break;",
          "649:  case VAR_LIST:",
          "650:     if (tolerant)",
          "651:     {",
          "652:         isntype = ISN_2STRING_ANY;",
          "653:         break;",
          "654:     }",
          "658:  case VAR_VOID:",
          "659:  case VAR_BLOB:",
          "660:  case VAR_FUNC:",
          "661:  case VAR_PARTIAL:",
          "662:  case VAR_DICT:",
          "663:  case VAR_JOB:",
          "664:  case VAR_CHANNEL:",
          "665:  case VAR_INSTR:",
          "666:     to_string_error((*type)->tt_type);",
          "667:     return FAIL;",
          "668:     }",
          "671:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "672:  return FAIL;",
          "673:     isn->isn_arg.tostring.offset = offset;",
          "674:     isn->isn_arg.tostring.tolerant = tolerant;",
          "676:     return OK;",
          "677: }",
          "679:     static int",
          "680: check_number_or_float(vartype_T type1, vartype_T type2, char_u *op)",
          "681: {",
          "682:     if (!((type1 == VAR_NUMBER || type1 == VAR_FLOAT || type1 == VAR_ANY)",
          "683:      && (type2 == VAR_NUMBER || type2 == VAR_FLOAT",
          "684:         || type2 == VAR_ANY)))",
          "685:     {",
          "686:  if (*op == '+')",
          "687:      emsg(_(e_wrong_argument_type_for_plus));",
          "688:  else",
          "689:      semsg(_(e_char_requires_number_or_float_arguments), *op);",
          "690:  return FAIL;",
          "691:     }",
          "692:     return OK;",
          "693: }",
          "698:     static int",
          "699: generate_add_instr(",
          "700:  cctx_T *cctx,",
          "701:  vartype_T vartype,",
          "702:  type_T *type1,",
          "703:  type_T *type2,",
          "704:  exprtype_T expr_type)",
          "705: {",
          "706:     garray_T *stack = &cctx->ctx_type_stack;",
          "707:     isn_T *isn = generate_instr_drop(cctx,",
          "708:         vartype == VAR_NUMBER ? ISN_OPNR",
          "709:       : vartype == VAR_LIST ? ISN_ADDLIST",
          "710:       : vartype == VAR_BLOB ? ISN_ADDBLOB",
          "711: #ifdef FEAT_FLOAT",
          "712:       : vartype == VAR_FLOAT ? ISN_OPFLOAT",
          "713: #endif",
          "714:       : ISN_OPANY, 1);",
          "716:     if (vartype != VAR_LIST && vartype != VAR_BLOB",
          "717:      && type1->tt_type != VAR_ANY",
          "718:      && type2->tt_type != VAR_ANY",
          "719:      && check_number_or_float(",
          "720:    type1->tt_type, type2->tt_type, (char_u *)\"+\") == FAIL)",
          "721:  return FAIL;",
          "723:     if (isn != NULL)",
          "724:     {",
          "725:  if (isn->isn_type == ISN_ADDLIST)",
          "726:      isn->isn_arg.op.op_type = expr_type;",
          "727:  else",
          "728:      isn->isn_arg.op.op_type = EXPR_ADD;",
          "729:     }",
          "733:     if (vartype == VAR_LIST",
          "734:      && type1->tt_type == VAR_LIST && type2->tt_type == VAR_LIST",
          "735:      && type1->tt_member != type2->tt_member)",
          "736:  (((type_T **)stack->ga_data)[stack->ga_len - 1]) = &t_list_any;",
          "738:     return isn == NULL ? FAIL : OK;",
          "739: }",
          "746:     static vartype_T",
          "747: operator_type(type_T *type1, type_T *type2)",
          "748: {",
          "749:     if (type1->tt_type == type2->tt_type",
          "750:      && (type1->tt_type == VAR_NUMBER",
          "751:   || type1->tt_type == VAR_LIST",
          "752: #ifdef FEAT_FLOAT",
          "753:   || type1->tt_type == VAR_FLOAT",
          "754: #endif",
          "755:   || type1->tt_type == VAR_BLOB))",
          "756:  return type1->tt_type;",
          "757:     return VAR_ANY;",
          "758: }",
          "764:     static int",
          "765: generate_two_op(cctx_T *cctx, char_u *op)",
          "766: {",
          "767:     garray_T *stack = &cctx->ctx_type_stack;",
          "768:     type_T *type1;",
          "769:     type_T *type2;",
          "770:     vartype_T vartype;",
          "771:     isn_T *isn;",
          "773:     RETURN_OK_IF_SKIP(cctx);",
          "776:     type1 = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "777:     type2 = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "778:     vartype = operator_type(type1, type2);",
          "780:     switch (*op)",
          "781:     {",
          "782:  case '+':",
          "783:     if (generate_add_instr(cctx, vartype, type1, type2,",
          "784:            EXPR_COPY) == FAIL)",
          "785:         return FAIL;",
          "786:     break;",
          "788:  case '-':",
          "789:  case '*':",
          "790:  case '/': if (check_number_or_float(type1->tt_type, type2->tt_type,",
          "791:            op) == FAIL)",
          "792:         return FAIL;",
          "793:     if (vartype == VAR_NUMBER)",
          "794:         isn = generate_instr_drop(cctx, ISN_OPNR, 1);",
          "795: #ifdef FEAT_FLOAT",
          "796:     else if (vartype == VAR_FLOAT)",
          "797:         isn = generate_instr_drop(cctx, ISN_OPFLOAT, 1);",
          "798: #endif",
          "799:     else",
          "800:         isn = generate_instr_drop(cctx, ISN_OPANY, 1);",
          "801:     if (isn != NULL)",
          "802:         isn->isn_arg.op.op_type = *op == '*'",
          "803:      ? EXPR_MULT : *op == '/'? EXPR_DIV : EXPR_SUB;",
          "804:     break;",
          "806:  case '%': if ((type1->tt_type != VAR_ANY",
          "807:             && type1->tt_type != VAR_NUMBER)",
          "808:      || (type2->tt_type != VAR_ANY",
          "809:            && type2->tt_type != VAR_NUMBER))",
          "810:     {",
          "811:         emsg(_(e_percent_requires_number_arguments));",
          "812:         return FAIL;",
          "813:     }",
          "814:     isn = generate_instr_drop(cctx,",
          "815:          vartype == VAR_NUMBER ? ISN_OPNR : ISN_OPANY, 1);",
          "816:     if (isn != NULL)",
          "817:         isn->isn_arg.op.op_type = EXPR_REM;",
          "818:     break;",
          "819:     }",
          "822:     if (vartype == VAR_ANY)",
          "823:     {",
          "824:  type_T *type = &t_any;",
          "826: #ifdef FEAT_FLOAT",
          "828:  if ((type1->tt_type == VAR_NUMBER || type1->tt_type == VAR_FLOAT)",
          "829:   && (type2->tt_type == VAR_NUMBER || type2->tt_type == VAR_FLOAT))",
          "830:      type = &t_float;",
          "831: #endif",
          "832:  ((type_T **)stack->ga_data)[stack->ga_len - 1] = type;",
          "833:     }",
          "835:     return OK;",
          "836: }",
          "842:     static isntype_T",
          "843: get_compare_isn(exprtype_T exprtype, vartype_T type1, vartype_T type2)",
          "844: {",
          "845:     isntype_T isntype = ISN_DROP;",
          "847:     if (type1 == VAR_UNKNOWN)",
          "848:  type1 = VAR_ANY;",
          "849:     if (type2 == VAR_UNKNOWN)",
          "850:  type2 = VAR_ANY;",
          "852:     if (type1 == type2)",
          "853:     {",
          "854:  switch (type1)",
          "855:  {",
          "856:      case VAR_BOOL: isntype = ISN_COMPAREBOOL; break;",
          "857:      case VAR_SPECIAL: isntype = ISN_COMPARESPECIAL; break;",
          "858:      case VAR_NUMBER: isntype = ISN_COMPARENR; break;",
          "859:      case VAR_FLOAT: isntype = ISN_COMPAREFLOAT; break;",
          "860:      case VAR_STRING: isntype = ISN_COMPARESTRING; break;",
          "861:      case VAR_BLOB: isntype = ISN_COMPAREBLOB; break;",
          "862:      case VAR_LIST: isntype = ISN_COMPARELIST; break;",
          "863:      case VAR_DICT: isntype = ISN_COMPAREDICT; break;",
          "864:      case VAR_FUNC: isntype = ISN_COMPAREFUNC; break;",
          "865:      default: isntype = ISN_COMPAREANY; break;",
          "866:  }",
          "867:     }",
          "868:     else if (type1 == VAR_ANY || type2 == VAR_ANY",
          "869:      || ((type1 == VAR_NUMBER || type1 == VAR_FLOAT)",
          "870:        && (type2 == VAR_NUMBER || type2 == VAR_FLOAT)))",
          "871:  isntype = ISN_COMPAREANY;",
          "873:     if ((exprtype == EXPR_IS || exprtype == EXPR_ISNOT)",
          "874:      && (isntype == ISN_COMPAREBOOL",
          "875:      || isntype == ISN_COMPARESPECIAL",
          "876:      || isntype == ISN_COMPARENR",
          "877:      || isntype == ISN_COMPAREFLOAT))",
          "878:     {",
          "879:  semsg(_(e_cannot_use_str_with_str),",
          "880:   exprtype == EXPR_IS ? \"is\" : \"isnot\" , vartype_name(type1));",
          "881:  return ISN_DROP;",
          "882:     }",
          "883:     if (isntype == ISN_DROP",
          "884:      || ((exprtype != EXPR_EQUAL && exprtype != EXPR_NEQUAL",
          "885:       && (type1 == VAR_BOOL || type1 == VAR_SPECIAL",
          "886:          || type2 == VAR_BOOL || type2 == VAR_SPECIAL)))",
          "887:      || ((exprtype != EXPR_EQUAL && exprtype != EXPR_NEQUAL",
          "888:      && exprtype != EXPR_IS && exprtype != EXPR_ISNOT",
          "889:       && (type1 == VAR_BLOB || type2 == VAR_BLOB",
          "890:    || type1 == VAR_LIST || type2 == VAR_LIST))))",
          "891:     {",
          "892:  semsg(_(e_cannot_compare_str_with_str),",
          "893:   vartype_name(type1), vartype_name(type2));",
          "894:  return ISN_DROP;",
          "895:     }",
          "896:     return isntype;",
          "897: }",
          "899:     int",
          "900: check_compare_types(exprtype_T type, typval_T *tv1, typval_T *tv2)",
          "901: {",
          "902:     if (get_compare_isn(type, tv1->v_type, tv2->v_type) == ISN_DROP)",
          "903:  return FAIL;",
          "904:     return OK;",
          "905: }",
          "910:     static int",
          "911: generate_COMPARE(cctx_T *cctx, exprtype_T exprtype, int ic)",
          "912: {",
          "913:     isntype_T isntype;",
          "914:     isn_T *isn;",
          "915:     garray_T *stack = &cctx->ctx_type_stack;",
          "916:     vartype_T type1;",
          "917:     vartype_T type2;",
          "919:     RETURN_OK_IF_SKIP(cctx);",
          "924:     type1 = ((type_T **)stack->ga_data)[stack->ga_len - 2]->tt_type;",
          "925:     type2 = ((type_T **)stack->ga_data)[stack->ga_len - 1]->tt_type;",
          "926:     isntype = get_compare_isn(exprtype, type1, type2);",
          "927:     if (isntype == ISN_DROP)",
          "928:  return FAIL;",
          "930:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "931:  return FAIL;",
          "932:     isn->isn_arg.op.op_type = exprtype;",
          "933:     isn->isn_arg.op.op_ic = ic;",
          "936:     if (stack->ga_len >= 2)",
          "937:     {",
          "938:  --stack->ga_len;",
          "939:  ((type_T **)stack->ga_data)[stack->ga_len - 1] = &t_bool;",
          "940:     }",
          "942:     return OK;",
          "943: }",
          "949:     static int",
          "950: generate_2BOOL(cctx_T *cctx, int invert, int offset)",
          "951: {",
          "952:     isn_T *isn;",
          "953:     garray_T *stack = &cctx->ctx_type_stack;",
          "955:     RETURN_OK_IF_SKIP(cctx);",
          "956:     if ((isn = generate_instr(cctx, ISN_2BOOL)) == NULL)",
          "957:  return FAIL;",
          "958:     isn->isn_arg.tobool.invert = invert;",
          "959:     isn->isn_arg.tobool.offset = offset;",
          "962:     ((type_T **)stack->ga_data)[stack->ga_len + offset] = &t_bool;",
          "964:     return OK;",
          "965: }",
          "970:     static int",
          "971: generate_COND2BOOL(cctx_T *cctx)",
          "972: {",
          "973:     isn_T *isn;",
          "974:     garray_T *stack = &cctx->ctx_type_stack;",
          "976:     RETURN_OK_IF_SKIP(cctx);",
          "977:     if ((isn = generate_instr(cctx, ISN_COND2BOOL)) == NULL)",
          "978:  return FAIL;",
          "981:     ((type_T **)stack->ga_data)[stack->ga_len - 1] = &t_bool;",
          "983:     return OK;",
          "984: }",
          "986:     static int",
          "987: generate_TYPECHECK(",
          "988:  cctx_T     *cctx,",
          "989:  type_T     *expected,",
          "990:  int     offset,",
          "991:  int     argidx)",
          "992: {",
          "993:     isn_T *isn;",
          "994:     garray_T *stack = &cctx->ctx_type_stack;",
          "996:     RETURN_OK_IF_SKIP(cctx);",
          "997:     if ((isn = generate_instr(cctx, ISN_CHECKTYPE)) == NULL)",
          "998:  return FAIL;",
          "999:     isn->isn_arg.type.ct_type = alloc_type(expected);",
          "1000:     isn->isn_arg.type.ct_off = (int8_T)offset;",
          "1001:     isn->isn_arg.type.ct_arg_idx = (int8_T)argidx;",
          "1004:     ((type_T **)stack->ga_data)[stack->ga_len + offset] = expected;",
          "1006:     return OK;",
          "1007: }",
          "1009:     static int",
          "1010: generate_SETTYPE(",
          "1011:  cctx_T     *cctx,",
          "1012:  type_T     *expected)",
          "1013: {",
          "1014:     isn_T *isn;",
          "1016:     RETURN_OK_IF_SKIP(cctx);",
          "1017:     if ((isn = generate_instr(cctx, ISN_SETTYPE)) == NULL)",
          "1018:  return FAIL;",
          "1019:     isn->isn_arg.type.ct_type = alloc_type(expected);",
          "1020:     return OK;",
          "1021: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1108: }",
          "1116: {",
          "1130: }",
          "1135:     static int",
          "1137: {",
          "1143:  return FAIL;",
          "1149:     return OK;",
          "1150: }",
          "1157: {",
          "1182: }",
          "1190: {",
          "1199: }",
          "1208: {",
          "1218:     {",
          "1226: }",
          "1234: {",
          "1243: }",
          "1251: {",
          "1260: }",
          "1268: {",
          "1277: }",
          "1285: {",
          "1297:     {",
          "1300:  {",
          "1303:  }",
          "1308: }",
          "1317: {",
          "1334:  return FAIL;",
          "1343:     return OK;",
          "1344: }",
          "1351: {",
          "1356:  return FAIL;",
          "1358:     return OK;",
          "1359: }",
          "1366: {",
          "1377: }",
          "1420: {",
          "1451: }",
          "1463: {",
          "1513:     {",
          "1517:     }",
          "1570:     else",
          "1614: }",
          "1621: {",
          "1651: }",
          "1687: }",
          "1694: {",
          "1719: }",
          "1728: {",
          "1738:     {",
          "1742:     }",
          "1747: }",
          "1754: {",
          "1761:     {",
          "1764:      return FAIL;",
          "1765:     }",
          "1766:     return OK;",
          "1767: }",
          "1772:     static int",
          "1774: {",
          "1788: }",
          "1795: {",
          "1872:     {",
          "1890:     }",
          "1952:  return FAIL;",
          "1969:     {",
          "1974:  {",
          "1989:  }",
          "2031:  {",
          "2058:   return FAIL;",
          "2152:      {",
          "2155:      }",
          "2157:      {",
          "2160:      }",
          "2162:      {",
          "2166:   {",
          "2182:       {",
          "2184:    return FAIL;",
          "2185:       }",
          "8233:     }",
          "8243:     {",
          "8247:     }",
          "8253:     {",
          "8256:     }",
          "8260:     {",
          "8266:  {",
          "8271:  }",
          "8279:  {",
          "8285:  }",
          "8297:  {",
          "8314:  }",
          "8317:  {",
          "8352:      {",
          "8390:      }",
          "8396:  }",
          "8399:  {",
          "8407:  }",
          "8456:     }",
          "8461: }",
          "8476: {",
          "8492:     {",
          "8495:     }",
          "8498:     {",
          "8509:     }",
          "8512: }",
          "8519: {",
          "8552: }",
          "8559: {",
          "8565:     {",
          "8567:  {",
          "8570:  }",
          "8572:  {",
          "8575:  }",
          "8577:  {",
          "8580:  }",
          "8584:     }",
          "8595: }",
          "8602: {",
          "8607:     {",
          "8609:  {",
          "8612:  }",
          "8621:     else",
          "8651: }",
          "8687: {",
          "8701:     {",
          "8722: }",
          "8729: {",
          "8757:     {",
          "8792:     }",
          "8796:     {",
          "8799:     }",
          "8800:     else",
          "8801:     {",
          "8813:  {",
          "8816:      return FAIL;",
          "8817:  }",
          "8828:      return FAIL;",
          "8904:  {",
          "8944:     }",
          "8948:     {",
          "8951:  {",
          "8971:  {",
          "8976:  }",
          "8977:     }",
          "8982:     {",
          "8993:     }",
          "8995: }",
          "9000:     static char_u *",
          "9002: {",
          "9033:     {",
          "9035:  return NULL;",
          "9036:     }",
          "9063:     {",
          "9068:      return NULL;",
          "9070:  if (cctx->ctx_skip != SKIP_YES)",
          "9071:  {",
          "9075:      {",
          "9078:      }",
          "9079:  }",
          "9084:     }",
          "9087:     {",
          "9143:  if (compile_expr0(&p, cctx) == FAIL)",
          "9144:      return NULL;",
          "9203:  }",
          "9204:     }",
          "9207:     {",
          "9228:  {",
          "9236:      {",
          "9239:      }",
          "9240:  }",
          "9242:  {",
          "9248:      {",
          "9258:   {",
          "9266:   }",
          "9267:      }",
          "9323:      {",
          "9328:      }",
          "9336:      {",
          "9339:      }",
          "9344:      {",
          "9346:   {",
          "9351:   }",
          "9353:      }",
          "9354:  }",
          "9412:  {",
          "9437:      {",
          "9443:      }",
          "9454:      {",
          "9461:      }",
          "9471:  }",
          "9486:  {",
          "9488:      {",
          "9493:      }",
          "9503:      {",
          "9509:      }",
          "9516:  }",
          "9519:     }",
          "9522:     {",
          "9550:     }",
          "9583: }",
          "9591: {",
          "9593:     {",
          "9596:     }",
          "9598:     {",
          "9601:     }",
          "9603: }",
          "",
          "[Removed Lines]",
          "1114:     static int",
          "1115: bool_on_stack(cctx_T *cctx)",
          "1117:     garray_T *stack = &cctx->ctx_type_stack;",
          "1118:     type_T *type;",
          "1120:     type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1121:     if (type == &t_bool)",
          "1122:  return OK;",
          "1124:     if (type == &t_any || type == &t_number || type == &t_number_bool)",
          "1127:  return generate_COND2BOOL(cctx);",
          "1129:     return need_type(type, &t_bool, -1, 0, cctx, FALSE, FALSE);",
          "1136: generate_PUSHNR(cctx_T *cctx, varnumber_T number)",
          "1138:     isn_T *isn;",
          "1139:     garray_T *stack = &cctx->ctx_type_stack;",
          "1141:     RETURN_OK_IF_SKIP(cctx);",
          "1142:     if ((isn = generate_instr_type(cctx, ISN_PUSHNR, &t_number)) == NULL)",
          "1144:     isn->isn_arg.number = number;",
          "1146:     if (number == 0 || number == 1)",
          "1148:  ((type_T **)stack->ga_data)[stack->ga_len - 1] = &t_number_bool;",
          "1155:     static int",
          "1156: generate_PUSHBOOL(cctx_T *cctx, varnumber_T number)",
          "1158:     isn_T *isn;",
          "1160:     RETURN_OK_IF_SKIP(cctx);",
          "1161:     if ((isn = generate_instr_type(cctx, ISN_PUSHBOOL, &t_bool)) == NULL)",
          "1162:  return FAIL;",
          "1163:     isn->isn_arg.number = number;",
          "1165:     return OK;",
          "1166: }",
          "1171:     static int",
          "1172: generate_PUSHSPEC(cctx_T *cctx, varnumber_T number)",
          "1173: {",
          "1174:     isn_T *isn;",
          "1176:     RETURN_OK_IF_SKIP(cctx);",
          "1177:     if ((isn = generate_instr_type(cctx, ISN_PUSHSPEC, &t_special)) == NULL)",
          "1178:  return FAIL;",
          "1179:     isn->isn_arg.number = number;",
          "1181:     return OK;",
          "1184: #ifdef FEAT_FLOAT",
          "1188:     static int",
          "1189: generate_PUSHF(cctx_T *cctx, float_T fnumber)",
          "1191:     isn_T *isn;",
          "1193:     RETURN_OK_IF_SKIP(cctx);",
          "1194:     if ((isn = generate_instr_type(cctx, ISN_PUSHF, &t_float)) == NULL)",
          "1195:  return FAIL;",
          "1196:     isn->isn_arg.fnumber = fnumber;",
          "1198:     return OK;",
          "1200: #endif",
          "1206:     static int",
          "1207: generate_PUSHS(cctx_T *cctx, char_u **str)",
          "1209:     isn_T *isn;",
          "1211:     if (cctx->ctx_skip == SKIP_YES)",
          "1212:     {",
          "1213:  if (str != NULL)",
          "1214:      VIM_CLEAR(*str);",
          "1215:  return OK;",
          "1216:     }",
          "1217:     if ((isn = generate_instr_type(cctx, ISN_PUSHS, &t_string)) == NULL)",
          "1219:  if (str != NULL)",
          "1220:      VIM_CLEAR(*str);",
          "1221:  return FAIL;",
          "1222:     }",
          "1223:     isn->isn_arg.string = str == NULL ? NULL : *str;",
          "1225:     return OK;",
          "1232:     static int",
          "1233: generate_PUSHCHANNEL(cctx_T *cctx, channel_T *channel)",
          "1235:     isn_T *isn;",
          "1237:     RETURN_OK_IF_SKIP(cctx);",
          "1238:     if ((isn = generate_instr_type(cctx, ISN_PUSHCHANNEL, &t_channel)) == NULL)",
          "1239:  return FAIL;",
          "1240:     isn->isn_arg.channel = channel;",
          "1242:     return OK;",
          "1249:     static int",
          "1250: generate_PUSHJOB(cctx_T *cctx, job_T *job)",
          "1252:     isn_T *isn;",
          "1254:     RETURN_OK_IF_SKIP(cctx);",
          "1255:     if ((isn = generate_instr_type(cctx, ISN_PUSHJOB, &t_channel)) == NULL)",
          "1256:  return FAIL;",
          "1257:     isn->isn_arg.job = job;",
          "1259:     return OK;",
          "1266:     static int",
          "1267: generate_PUSHBLOB(cctx_T *cctx, blob_T *blob)",
          "1269:     isn_T *isn;",
          "1271:     RETURN_OK_IF_SKIP(cctx);",
          "1272:     if ((isn = generate_instr_type(cctx, ISN_PUSHBLOB, &t_blob)) == NULL)",
          "1273:  return FAIL;",
          "1274:     isn->isn_arg.blob = blob;",
          "1276:     return OK;",
          "1283:     static int",
          "1284: generate_PUSHFUNC(cctx_T *cctx, char_u *name, type_T *type)",
          "1286:     isn_T *isn;",
          "1287:     char_u *funcname;",
          "1289:     RETURN_OK_IF_SKIP(cctx);",
          "1290:     if ((isn = generate_instr_type(cctx, ISN_PUSHFUNC, type)) == NULL)",
          "1291:  return FAIL;",
          "1292:     if (name == NULL)",
          "1293:  funcname = NULL;",
          "1294:     else if (*name == K_SPECIAL)  // script-local",
          "1295:  funcname = vim_strsave(name);",
          "1296:     else",
          "1298:  funcname = alloc(STRLEN(name) + 3);",
          "1299:  if (funcname != NULL)",
          "1301:      STRCPY(funcname, \"g:\");",
          "1302:      STRCPY(funcname + 2, name);",
          "1304:     }",
          "1306:     isn->isn_arg.string = funcname;",
          "1307:     return OK;",
          "1315:     static int",
          "1316: generate_GETITEM(cctx_T *cctx, int index, int with_op)",
          "1318:     isn_T *isn;",
          "1319:     garray_T *stack = &cctx->ctx_type_stack;",
          "1320:     type_T *type = ((type_T **)stack->ga_data)[stack->ga_len",
          "1321:          - (with_op ? 2 : 1)];",
          "1322:     type_T *item_type = &t_any;",
          "1324:     RETURN_OK_IF_SKIP(cctx);",
          "1326:     if (type->tt_type != VAR_LIST)",
          "1327:     {",
          "1329:  emsg(_(e_listreq));",
          "1330:  return FAIL;",
          "1331:     }",
          "1332:     item_type = type->tt_member;",
          "1333:     if ((isn = generate_instr(cctx, ISN_GETITEM)) == NULL)",
          "1335:     isn->isn_arg.getitem.gi_index = index;",
          "1336:     isn->isn_arg.getitem.gi_with_op = with_op;",
          "1339:     if (GA_GROW_FAILS(stack, 1))",
          "1340:  return FAIL;",
          "1341:     ((type_T **)stack->ga_data)[stack->ga_len] = item_type;",
          "1342:     ++stack->ga_len;",
          "1349:     static int",
          "1350: generate_SLICE(cctx_T *cctx, int count)",
          "1352:     isn_T *isn;",
          "1354:     RETURN_OK_IF_SKIP(cctx);",
          "1355:     if ((isn = generate_instr(cctx, ISN_SLICE)) == NULL)",
          "1357:     isn->isn_arg.number = count;",
          "1364:     static int",
          "1365: generate_CHECKLEN(cctx_T *cctx, int min_len, int more_OK)",
          "1367:     isn_T *isn;",
          "1369:     RETURN_OK_IF_SKIP(cctx);",
          "1371:     if ((isn = generate_instr(cctx, ISN_CHECKLEN)) == NULL)",
          "1372:  return FAIL;",
          "1373:     isn->isn_arg.checklen.cl_min_len = min_len;",
          "1374:     isn->isn_arg.checklen.cl_more_OK = more_OK;",
          "1376:     return OK;",
          "1382:     static int",
          "1383: generate_STORE(cctx_T *cctx, isntype_T isn_type, int idx, char_u *name)",
          "1384: {",
          "1385:     isn_T *isn;",
          "1387:     RETURN_OK_IF_SKIP(cctx);",
          "1388:     if ((isn = generate_instr_drop(cctx, isn_type, 1)) == NULL)",
          "1389:  return FAIL;",
          "1390:     if (name != NULL)",
          "1391:  isn->isn_arg.string = vim_strsave(name);",
          "1392:     else",
          "1393:  isn->isn_arg.number = idx;",
          "1395:     return OK;",
          "1396: }",
          "1401:     static int",
          "1402: generate_STOREOUTER(cctx_T *cctx, int idx, int level)",
          "1403: {",
          "1404:     isn_T *isn;",
          "1406:     RETURN_OK_IF_SKIP(cctx);",
          "1407:     if ((isn = generate_instr_drop(cctx, ISN_STOREOUTER, 1)) == NULL)",
          "1408:  return FAIL;",
          "1409:     isn->isn_arg.outer.outer_idx = idx;",
          "1410:     isn->isn_arg.outer.outer_depth = level;",
          "1412:     return OK;",
          "1413: }",
          "1418:     static int",
          "1419: generate_STORENR(cctx_T *cctx, int idx, varnumber_T value)",
          "1421:     isn_T *isn;",
          "1423:     RETURN_OK_IF_SKIP(cctx);",
          "1424:     if ((isn = generate_instr(cctx, ISN_STORENR)) == NULL)",
          "1425:  return FAIL;",
          "1426:     isn->isn_arg.storenr.stnr_idx = idx;",
          "1427:     isn->isn_arg.storenr.stnr_val = value;",
          "1429:     return OK;",
          "1430: }",
          "1435:     static int",
          "1436: generate_STOREOPT(",
          "1437:  cctx_T     *cctx,",
          "1438:  isntype_T   isn_type,",
          "1439:  char_u     *name,",
          "1440:  int     opt_flags)",
          "1441: {",
          "1442:     isn_T *isn;",
          "1444:     RETURN_OK_IF_SKIP(cctx);",
          "1445:     if ((isn = generate_instr_drop(cctx, isn_type, 1)) == NULL)",
          "1446:  return FAIL;",
          "1447:     isn->isn_arg.storeopt.so_name = vim_strsave(name);",
          "1448:     isn->isn_arg.storeopt.so_flags = opt_flags;",
          "1450:     return OK;",
          "1456:     static int",
          "1457: generate_LOAD(",
          "1458:  cctx_T     *cctx,",
          "1459:  isntype_T   isn_type,",
          "1460:  int     idx,",
          "1461:  char_u     *name,",
          "1462:  type_T     *type)",
          "1464:     isn_T *isn;",
          "1466:     RETURN_OK_IF_SKIP(cctx);",
          "1467:     if ((isn = generate_instr_type(cctx, isn_type, type)) == NULL)",
          "1468:  return FAIL;",
          "1469:     if (name != NULL)",
          "1470:  isn->isn_arg.string = vim_strsave(name);",
          "1471:     else",
          "1472:  isn->isn_arg.number = idx;",
          "1474:     return OK;",
          "1475: }",
          "1480:     static int",
          "1481: generate_LOADOUTER(",
          "1482:  cctx_T     *cctx,",
          "1483:  int     idx,",
          "1484:  int     nesting,",
          "1485:  type_T     *type)",
          "1486: {",
          "1487:     isn_T *isn;",
          "1489:     RETURN_OK_IF_SKIP(cctx);",
          "1490:     if ((isn = generate_instr_type(cctx, ISN_LOADOUTER, type)) == NULL)",
          "1491:  return FAIL;",
          "1492:     isn->isn_arg.outer.outer_idx = idx;",
          "1493:     isn->isn_arg.outer.outer_depth = nesting;",
          "1495:     return OK;",
          "1496: }",
          "1501:     static int",
          "1502: generate_LOADV(",
          "1503:  cctx_T     *cctx,",
          "1504:  char_u     *name,",
          "1505:  int     error)",
          "1506: {",
          "1507:     int     di_flags;",
          "1508:     int     vidx = find_vim_var(name, &di_flags);",
          "1509:     type_T  *type;",
          "1511:     RETURN_OK_IF_SKIP(cctx);",
          "1512:     if (vidx < 0)",
          "1514:  if (error)",
          "1515:      semsg(_(e_variable_not_found_str), name);",
          "1516:  return FAIL;",
          "1518:     type = typval2type_vimvar(get_vim_var_tv(vidx), cctx->ctx_type_list);",
          "1520:     return generate_LOAD(cctx, ISN_LOADV, vidx, NULL, type);",
          "1521: }",
          "1526:     static int",
          "1527: generate_UNLET(cctx_T *cctx, isntype_T isn_type, char_u *name, int forceit)",
          "1528: {",
          "1529:     isn_T *isn;",
          "1531:     RETURN_OK_IF_SKIP(cctx);",
          "1532:     if ((isn = generate_instr(cctx, isn_type)) == NULL)",
          "1533:  return FAIL;",
          "1534:     isn->isn_arg.unlet.ul_name = vim_strsave(name);",
          "1535:     isn->isn_arg.unlet.ul_forceit = forceit;",
          "1537:     return OK;",
          "1538: }",
          "1543:     static int",
          "1544: generate_LOCKCONST(cctx_T *cctx)",
          "1545: {",
          "1546:     isn_T *isn;",
          "1548:     RETURN_OK_IF_SKIP(cctx);",
          "1549:     if ((isn = generate_instr(cctx, ISN_LOCKCONST)) == NULL)",
          "1550:  return FAIL;",
          "1551:     return OK;",
          "1552: }",
          "1557:     static int",
          "1558: generate_OLDSCRIPT(",
          "1559:  cctx_T     *cctx,",
          "1560:  isntype_T   isn_type,",
          "1561:  char_u     *name,",
          "1562:  int     sid,",
          "1563:  type_T     *type)",
          "1564: {",
          "1565:     isn_T *isn;",
          "1567:     RETURN_OK_IF_SKIP(cctx);",
          "1568:     if (isn_type == ISN_LOADS)",
          "1569:  isn = generate_instr_type(cctx, isn_type, type);",
          "1571:  isn = generate_instr_drop(cctx, isn_type, 1);",
          "1572:     if (isn == NULL)",
          "1573:  return FAIL;",
          "1574:     isn->isn_arg.loadstore.ls_name = vim_strsave(name);",
          "1575:     isn->isn_arg.loadstore.ls_sid = sid;",
          "1577:     return OK;",
          "1578: }",
          "1583:     static int",
          "1584: generate_VIM9SCRIPT(",
          "1585:  cctx_T     *cctx,",
          "1586:  isntype_T   isn_type,",
          "1587:  int     sid,",
          "1588:  int     idx,",
          "1589:  type_T     *type)",
          "1590: {",
          "1591:     isn_T *isn;",
          "1592:     scriptref_T *sref;",
          "1593:     scriptitem_T *si = SCRIPT_ITEM(sid);",
          "1595:     RETURN_OK_IF_SKIP(cctx);",
          "1596:     if (isn_type == ISN_LOADSCRIPT)",
          "1597:  isn = generate_instr_type(cctx, isn_type, type);",
          "1598:     else",
          "1599:  isn = generate_instr_drop(cctx, isn_type, 1);",
          "1600:     if (isn == NULL)",
          "1601:  return FAIL;",
          "1605:     sref = ALLOC_ONE(scriptref_T);",
          "1606:     if (sref == NULL)",
          "1607:  return FAIL;",
          "1608:     isn->isn_arg.script.scriptref = sref;",
          "1609:     sref->sref_sid = sid;",
          "1610:     sref->sref_idx = idx;",
          "1611:     sref->sref_seq = si->sn_script_seq;",
          "1612:     sref->sref_type = type;",
          "1613:     return OK;",
          "1619:     static int",
          "1620: generate_NEWLIST(cctx_T *cctx, int count)",
          "1622:     isn_T *isn;",
          "1623:     garray_T *stack = &cctx->ctx_type_stack;",
          "1624:     type_T *type;",
          "1625:     type_T *member;",
          "1627:     RETURN_OK_IF_SKIP(cctx);",
          "1628:     if ((isn = generate_instr(cctx, ISN_NEWLIST)) == NULL)",
          "1629:  return FAIL;",
          "1630:     isn->isn_arg.number = count;",
          "1633:     if (count == 0)",
          "1634:  member = &t_unknown;",
          "1635:     else",
          "1636:  member = get_member_type_from_stack(",
          "1637:      ((type_T **)stack->ga_data) + stack->ga_len, count, 1,",
          "1638:          cctx->ctx_type_list);",
          "1639:     type = get_list_type(member, cctx->ctx_type_list);",
          "1642:     stack->ga_len -= count;",
          "1645:     if (GA_GROW_FAILS(stack, 1))",
          "1646:  return FAIL;",
          "1647:     ((type_T **)stack->ga_data)[stack->ga_len] = type;",
          "1648:     ++stack->ga_len;",
          "1650:     return OK;",
          "1656:     static int",
          "1657: generate_NEWDICT(cctx_T *cctx, int count)",
          "1658: {",
          "1659:     isn_T *isn;",
          "1660:     garray_T *stack = &cctx->ctx_type_stack;",
          "1661:     type_T *type;",
          "1662:     type_T *member;",
          "1664:     RETURN_OK_IF_SKIP(cctx);",
          "1665:     if ((isn = generate_instr(cctx, ISN_NEWDICT)) == NULL)",
          "1666:  return FAIL;",
          "1667:     isn->isn_arg.number = count;",
          "1669:     if (count == 0)",
          "1670:  member = &t_void;",
          "1671:     else",
          "1672:  member = get_member_type_from_stack(",
          "1673:      ((type_T **)stack->ga_data) + stack->ga_len, count, 2,",
          "1674:          cctx->ctx_type_list);",
          "1675:     type = get_dict_type(member, cctx->ctx_type_list);",
          "1678:     stack->ga_len -= 2 * count;",
          "1681:     if (GA_GROW_FAILS(stack, 1))",
          "1682:  return FAIL;",
          "1683:     ((type_T **)stack->ga_data)[stack->ga_len] = type;",
          "1684:     ++stack->ga_len;",
          "1686:     return OK;",
          "1692:     static int",
          "1693: generate_FUNCREF(cctx_T *cctx, ufunc_T *ufunc)",
          "1695:     isn_T *isn;",
          "1696:     garray_T *stack = &cctx->ctx_type_stack;",
          "1698:     RETURN_OK_IF_SKIP(cctx);",
          "1699:     if ((isn = generate_instr(cctx, ISN_FUNCREF)) == NULL)",
          "1700:  return FAIL;",
          "1701:     if (ufunc->uf_def_status == UF_NOT_COMPILED)",
          "1702:  isn->isn_arg.funcref.fr_func_name = vim_strsave(ufunc->uf_name);",
          "1703:     else",
          "1704:  isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;",
          "1705:     cctx->ctx_has_closure = 1;",
          "1709:     if (ufunc->uf_flags & FC_CLOSURE)",
          "1710:  cctx->ctx_ufunc->uf_flags |= FC_CLOSURE;",
          "1712:     if (GA_GROW_FAILS(stack, 1))",
          "1713:  return FAIL;",
          "1714:     ((type_T **)stack->ga_data)[stack->ga_len] =",
          "1715:         ufunc->uf_func_type == NULL ? &t_func_any : ufunc->uf_func_type;",
          "1716:     ++stack->ga_len;",
          "1718:     return OK;",
          "1726:     static int",
          "1727: generate_NEWFUNC(cctx_T *cctx, char_u *lambda_name, char_u *func_name)",
          "1729:     isn_T *isn;",
          "1731:     if (cctx->ctx_skip == SKIP_YES)",
          "1732:     {",
          "1733:  vim_free(lambda_name);",
          "1734:  vim_free(func_name);",
          "1735:  return OK;",
          "1736:     }",
          "1737:     if ((isn = generate_instr(cctx, ISN_NEWFUNC)) == NULL)",
          "1739:  vim_free(lambda_name);",
          "1740:  vim_free(func_name);",
          "1741:  return FAIL;",
          "1743:     isn->isn_arg.newfunc.nf_lambda = lambda_name;",
          "1744:     isn->isn_arg.newfunc.nf_global = func_name;",
          "1746:     return OK;",
          "1752:     static int",
          "1753: generate_DEF(cctx_T *cctx, char_u *name, size_t len)",
          "1755:     isn_T *isn;",
          "1757:     RETURN_OK_IF_SKIP(cctx);",
          "1758:     if ((isn = generate_instr(cctx, ISN_DEF)) == NULL)",
          "1759:  return FAIL;",
          "1760:     if (len > 0)",
          "1762:  isn->isn_arg.string = vim_strnsave(name, len);",
          "1763:  if (isn->isn_arg.string == NULL)",
          "1773: generate_JUMP(cctx_T *cctx, jumpwhen_T when, int where)",
          "1775:     isn_T *isn;",
          "1776:     garray_T *stack = &cctx->ctx_type_stack;",
          "1778:     RETURN_OK_IF_SKIP(cctx);",
          "1779:     if ((isn = generate_instr(cctx, ISN_JUMP)) == NULL)",
          "1780:  return FAIL;",
          "1781:     isn->isn_arg.jump.jump_when = when;",
          "1782:     isn->isn_arg.jump.jump_where = where;",
          "1784:     if (when != JUMP_ALWAYS && stack->ga_len > 0)",
          "1785:  --stack->ga_len;",
          "1787:     return OK;",
          "1793:     static int",
          "1794: generate_JUMP_IF_ARG_SET(cctx_T *cctx, int arg_off)",
          "1796:     isn_T *isn;",
          "1798:     RETURN_OK_IF_SKIP(cctx);",
          "1799:     if ((isn = generate_instr(cctx, ISN_JUMP_IF_ARG_SET)) == NULL)",
          "1800:  return FAIL;",
          "1801:     isn->isn_arg.jumparg.jump_arg_off = arg_off;",
          "1803:     return OK;",
          "1804: }",
          "1806:     static int",
          "1807: generate_FOR(cctx_T *cctx, int loop_idx)",
          "1808: {",
          "1809:     isn_T *isn;",
          "1810:     garray_T *stack = &cctx->ctx_type_stack;",
          "1812:     RETURN_OK_IF_SKIP(cctx);",
          "1813:     if ((isn = generate_instr(cctx, ISN_FOR)) == NULL)",
          "1814:  return FAIL;",
          "1815:     isn->isn_arg.forloop.for_idx = loop_idx;",
          "1817:     if (GA_GROW_FAILS(stack, 1))",
          "1818:  return FAIL;",
          "1820:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_any;",
          "1821:     ++stack->ga_len;",
          "1823:     return OK;",
          "1824: }",
          "1828:     static int",
          "1829: generate_TRYCONT(cctx_T *cctx, int levels, int where)",
          "1830: {",
          "1831:     isn_T *isn;",
          "1833:     RETURN_OK_IF_SKIP(cctx);",
          "1834:     if ((isn = generate_instr(cctx, ISN_TRYCONT)) == NULL)",
          "1835:  return FAIL;",
          "1836:     isn->isn_arg.trycont.tct_levels = levels;",
          "1837:     isn->isn_arg.trycont.tct_where = where;",
          "1839:     return OK;",
          "1840: }",
          "1848:     static int",
          "1849: generate_BCALL(cctx_T *cctx, int func_idx, int argcount, int method_call)",
          "1850: {",
          "1851:     isn_T *isn;",
          "1852:     garray_T *stack = &cctx->ctx_type_stack;",
          "1853:     int  argoff;",
          "1854:     type_T **argtypes = NULL;",
          "1855:     type_T *shuffled_argtypes[MAX_FUNC_ARGS];",
          "1856:     type_T *maptype = NULL;",
          "1858:     RETURN_OK_IF_SKIP(cctx);",
          "1859:     argoff = check_internal_func(func_idx, argcount);",
          "1860:     if (argoff < 0)",
          "1861:  return FAIL;",
          "1863:     if (method_call && argoff > 1)",
          "1864:     {",
          "1865:  if ((isn = generate_instr(cctx, ISN_SHUFFLE)) == NULL)",
          "1866:      return FAIL;",
          "1867:  isn->isn_arg.shuffle.shfl_item = argcount;",
          "1868:  isn->isn_arg.shuffle.shfl_up = argoff - 1;",
          "1869:     }",
          "1871:     if (argcount > 0)",
          "1874:  argtypes = ((type_T **)stack->ga_data) + stack->ga_len - argcount;",
          "1875:  if (method_call && argoff > 1)",
          "1876:  {",
          "1877:      int i;",
          "1879:      for (i = 0; i < argcount; ++i)",
          "1880:   shuffled_argtypes[i] = (i < argoff - 1)",
          "1881:        ? argtypes[i + 1]",
          "1882:        : (i == argoff - 1) ? argtypes[0] : argtypes[i];",
          "1883:      argtypes = shuffled_argtypes;",
          "1884:  }",
          "1885:  if (internal_func_check_arg_types(argtypes, func_idx, argcount,",
          "1886:          cctx) == FAIL)",
          "1887:      return FAIL;",
          "1888:  if (internal_func_is_map(func_idx))",
          "1889:      maptype = *argtypes;",
          "1892:     if ((isn = generate_instr(cctx, ISN_BCALL)) == NULL)",
          "1893:  return FAIL;",
          "1894:     isn->isn_arg.bfunc.cbf_idx = func_idx;",
          "1895:     isn->isn_arg.bfunc.cbf_argcount = argcount;",
          "1898:     stack->ga_len -= argcount;",
          "1899:     if (GA_GROW_FAILS(stack, 1))",
          "1900:  return FAIL;",
          "1901:     ((type_T **)stack->ga_data)[stack->ga_len] =",
          "1902:      internal_func_ret_type(func_idx, argcount, argtypes);",
          "1903:     ++stack->ga_len;",
          "1905:     if (maptype != NULL && maptype->tt_member != NULL",
          "1906:             && maptype->tt_member != &t_any)",
          "1908:  generate_TYPECHECK(cctx, maptype, -1, 1);",
          "1910:     return OK;",
          "1911: }",
          "1917:     static int",
          "1918: generate_LISTAPPEND(cctx_T *cctx)",
          "1919: {",
          "1920:     garray_T *stack = &cctx->ctx_type_stack;",
          "1921:     type_T *list_type;",
          "1922:     type_T *item_type;",
          "1923:     type_T *expected;",
          "1926:     list_type = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "1927:     item_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1928:     expected = list_type->tt_member;",
          "1929:     if (need_type(item_type, expected, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1930:  return FAIL;",
          "1932:     if (generate_instr(cctx, ISN_LISTAPPEND) == NULL)",
          "1933:  return FAIL;",
          "1935:     --stack->ga_len;     // drop the argument",
          "1936:     return OK;",
          "1937: }",
          "1943:     static int",
          "1944: generate_BLOBAPPEND(cctx_T *cctx)",
          "1945: {",
          "1946:     garray_T *stack = &cctx->ctx_type_stack;",
          "1947:     type_T *item_type;",
          "1950:     item_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1951:     if (need_type(item_type, &t_number, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1954:     if (generate_instr(cctx, ISN_BLOBAPPEND) == NULL)",
          "1955:  return FAIL;",
          "1957:     --stack->ga_len;     // drop the argument",
          "1958:     return OK;",
          "1959: }",
          "1965:     int",
          "1966: func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)",
          "1967: {",
          "1968:     switch (ufunc->uf_def_status)",
          "1970:  case UF_TO_BE_COMPILED:",
          "1971:      return TRUE;",
          "1973:  case UF_COMPILED:",
          "1975:      dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "1976:         + ufunc->uf_dfunc_idx;",
          "1978:      switch (compile_type)",
          "1979:      {",
          "1980:   case CT_PROFILE:",
          "1981: #ifdef FEAT_PROFILE",
          "1982:       return dfunc->df_instr_prof == NULL;",
          "1983: #endif",
          "1984:   case CT_NONE:",
          "1985:       return dfunc->df_instr == NULL;",
          "1986:   case CT_DEBUG:",
          "1987:       return dfunc->df_instr_debug == NULL;",
          "1988:      }",
          "1991:  case UF_NOT_COMPILED:",
          "1992:  case UF_COMPILE_ERROR:",
          "1993:  case UF_COMPILING:",
          "1994:      break;",
          "1995:     }",
          "1996:     return FALSE;",
          "1997: }",
          "2003:     static int",
          "2004: generate_CALL(cctx_T *cctx, ufunc_T *ufunc, int pushed_argcount)",
          "2005: {",
          "2006:     isn_T *isn;",
          "2007:     garray_T *stack = &cctx->ctx_type_stack;",
          "2008:     int  regular_args = ufunc->uf_args.ga_len;",
          "2009:     int  argcount = pushed_argcount;",
          "2011:     RETURN_OK_IF_SKIP(cctx);",
          "2012:     if (argcount > regular_args && !has_varargs(ufunc))",
          "2013:     {",
          "2014:  semsg(_(e_too_many_arguments_for_function_str),",
          "2015:          printable_func_name(ufunc));",
          "2016:  return FAIL;",
          "2017:     }",
          "2018:     if (argcount < regular_args - ufunc->uf_def_args.ga_len)",
          "2019:     {",
          "2020:  semsg(_(e_not_enough_arguments_for_function_str),",
          "2021:          printable_func_name(ufunc));",
          "2022:  return FAIL;",
          "2023:     }",
          "2025:     if (ufunc->uf_def_status != UF_NOT_COMPILED",
          "2026:      && ufunc->uf_def_status != UF_COMPILE_ERROR)",
          "2027:     {",
          "2028:  int  i;",
          "2030:  for (i = 0; i < argcount; ++i)",
          "2032:      type_T *expected;",
          "2033:      type_T *actual;",
          "2035:      actual = ((type_T **)stack->ga_data)[stack->ga_len - argcount + i];",
          "2036:      if (actual == &t_special",
          "2037:          && i >= regular_args - ufunc->uf_def_args.ga_len)",
          "2038:      {",
          "2040:   continue;",
          "2041:      }",
          "2042:      if (i < regular_args)",
          "2043:      {",
          "2044:   if (ufunc->uf_arg_types == NULL)",
          "2045:       continue;",
          "2046:   expected = ufunc->uf_arg_types[i];",
          "2047:      }",
          "2048:      else if (ufunc->uf_va_type == NULL",
          "2049:         || ufunc->uf_va_type == &t_list_any)",
          "2051:   expected = &t_any;",
          "2052:      else",
          "2053:   expected = ufunc->uf_va_type->tt_member;",
          "2054:      if (need_type(actual, expected, -argcount + i, i + 1, cctx,",
          "2055:          TRUE, FALSE) == FAIL)",
          "2056:      {",
          "2057:   arg_type_mismatch(expected, actual, i + 1);",
          "2059:      }",
          "2060:  }",
          "2061:  if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))",
          "2062:   && compile_def_function(ufunc, ufunc->uf_ret_type == NULL,",
          "2063:          COMPILE_TYPE(ufunc), NULL) == FAIL)",
          "2064:      return FAIL;",
          "2065:     }",
          "2066:     if (ufunc->uf_def_status == UF_COMPILE_ERROR)",
          "2067:     {",
          "2068:  emsg_funcname(_(e_call_to_function_that_failed_to_compile_str),",
          "2069:               ufunc->uf_name);",
          "2070:  return FAIL;",
          "2071:     }",
          "2073:     if ((isn = generate_instr(cctx,",
          "2074:       ufunc->uf_def_status != UF_NOT_COMPILED ? ISN_DCALL",
          "2075:         : ISN_UCALL)) == NULL)",
          "2076:  return FAIL;",
          "2077:     if (isn->isn_type == ISN_DCALL)",
          "2078:     {",
          "2079:  isn->isn_arg.dfunc.cdf_idx = ufunc->uf_dfunc_idx;",
          "2080:  isn->isn_arg.dfunc.cdf_argcount = argcount;",
          "2081:     }",
          "2082:     else",
          "2083:     {",
          "2086:  isn->isn_arg.ufunc.cuf_name = vim_strsave(ufunc->uf_name);",
          "2087:  isn->isn_arg.ufunc.cuf_argcount = argcount;",
          "2088:     }",
          "2090:     stack->ga_len -= argcount; // drop the arguments",
          "2091:     if (GA_GROW_FAILS(stack, 1))",
          "2092:  return FAIL;",
          "2094:     ((type_T **)stack->ga_data)[stack->ga_len] = ufunc->uf_ret_type;",
          "2095:     ++stack->ga_len;",
          "2097:     return OK;",
          "2098: }",
          "2103:     static int",
          "2104: generate_UCALL(cctx_T *cctx, char_u *name, int argcount)",
          "2105: {",
          "2106:     isn_T *isn;",
          "2107:     garray_T *stack = &cctx->ctx_type_stack;",
          "2109:     RETURN_OK_IF_SKIP(cctx);",
          "2110:     if ((isn = generate_instr(cctx, ISN_UCALL)) == NULL)",
          "2111:  return FAIL;",
          "2112:     isn->isn_arg.ufunc.cuf_name = vim_strsave(name);",
          "2113:     isn->isn_arg.ufunc.cuf_argcount = argcount;",
          "2115:     stack->ga_len -= argcount; // drop the arguments",
          "2116:     if (GA_GROW_FAILS(stack, 1))",
          "2117:  return FAIL;",
          "2119:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_any;",
          "2120:     ++stack->ga_len;",
          "2122:     return OK;",
          "2123: }",
          "2129:     static int",
          "2130: generate_PCALL(",
          "2131:  cctx_T *cctx,",
          "2132:  int argcount,",
          "2133:  char_u *name,",
          "2134:  type_T *type,",
          "2135:  int at_top)",
          "2136: {",
          "2137:     isn_T *isn;",
          "2138:     garray_T *stack = &cctx->ctx_type_stack;",
          "2139:     type_T *ret_type;",
          "2141:     RETURN_OK_IF_SKIP(cctx);",
          "2143:     if (type->tt_type == VAR_ANY)",
          "2144:  ret_type = &t_any;",
          "2145:     else if (type->tt_type == VAR_FUNC || type->tt_type == VAR_PARTIAL)",
          "2146:     {",
          "2147:  if (type->tt_argcount != -1)",
          "2148:  {",
          "2149:      int     varargs = (type->tt_flags & TTFLAG_VARARGS) ? 1 : 0;",
          "2151:      if (argcount < type->tt_min_argcount - varargs)",
          "2153:   semsg(_(e_not_enough_arguments_for_function_str), name);",
          "2154:   return FAIL;",
          "2156:      if (!varargs && argcount > type->tt_argcount)",
          "2158:   semsg(_(e_too_many_arguments_for_function_str), name);",
          "2159:   return FAIL;",
          "2161:      if (type->tt_args != NULL)",
          "2163:   int i;",
          "2165:   for (i = 0; i < argcount; ++i)",
          "2167:       int     offset = -argcount + i - (at_top ? 0 : 1);",
          "2168:       type_T *actual = ((type_T **)stack->ga_data)[",
          "2169:              stack->ga_len + offset];",
          "2170:       type_T *expected;",
          "2172:       if (varargs && i >= type->tt_argcount - 1)",
          "2173:    expected = type->tt_args[",
          "2174:           type->tt_argcount - 1]->tt_member;",
          "2175:       else if (i >= type->tt_min_argcount",
          "2176:              && actual == &t_special)",
          "2177:    expected = &t_any;",
          "2178:       else",
          "2179:    expected = type->tt_args[i];",
          "2180:       if (need_type(actual, expected, offset, i + 1,",
          "2181:           cctx, TRUE, FALSE) == FAIL)",
          "2183:    arg_type_mismatch(expected, actual, i + 1);",
          "2186:   }",
          "2187:      }",
          "2188:  }",
          "2189:  ret_type = type->tt_member;",
          "2190:  if (ret_type == &t_unknown)",
          "2192:      ret_type = &t_any;",
          "2193:     }",
          "2194:     else",
          "2195:     {",
          "2196:  semsg(_(e_not_callable_type_str), name);",
          "2197:  return FAIL;",
          "2198:     }",
          "2200:     if ((isn = generate_instr(cctx, ISN_PCALL)) == NULL)",
          "2201:  return FAIL;",
          "2202:     isn->isn_arg.pfunc.cpf_top = at_top;",
          "2203:     isn->isn_arg.pfunc.cpf_argcount = argcount;",
          "2205:     stack->ga_len -= argcount; // drop the arguments",
          "2208:     ((type_T **)stack->ga_data)[stack->ga_len - 1] = ret_type;",
          "2212:     if (at_top && generate_instr(cctx, ISN_PCALL_END) == NULL)",
          "2213:  return FAIL;",
          "2215:     return OK;",
          "2216: }",
          "2221:     static int",
          "2222: generate_STRINGMEMBER(cctx_T *cctx, char_u *name, size_t len)",
          "2223: {",
          "2224:     isn_T *isn;",
          "2225:     garray_T *stack = &cctx->ctx_type_stack;",
          "2226:     type_T *type;",
          "2228:     RETURN_OK_IF_SKIP(cctx);",
          "2229:     if ((isn = generate_instr(cctx, ISN_STRINGMEMBER)) == NULL)",
          "2230:  return FAIL;",
          "2231:     isn->isn_arg.string = vim_strnsave(name, len);",
          "2234:     type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "2235:     if (type->tt_type != VAR_DICT && type != &t_any)",
          "2236:     {",
          "2237:  char *tofree;",
          "2239:  semsg(_(e_expected_dictionary_for_using_key_str_but_got_str),",
          "2240:             name, type_name(type, &tofree));",
          "2241:  vim_free(tofree);",
          "2242:  return FAIL;",
          "2243:     }",
          "2245:     if (type->tt_type == VAR_DICT)",
          "2246:     {",
          "2247:  ((type_T **)stack->ga_data)[stack->ga_len - 1] =",
          "2248:         type->tt_member == &t_unknown ? &t_any : type->tt_member;",
          "2249:     }",
          "2251:     return OK;",
          "2252: }",
          "2257:     static int",
          "2258: generate_ECHO(cctx_T *cctx, int with_white, int count)",
          "2259: {",
          "2260:     isn_T *isn;",
          "2262:     RETURN_OK_IF_SKIP(cctx);",
          "2263:     if ((isn = generate_instr_drop(cctx, ISN_ECHO, count)) == NULL)",
          "2264:  return FAIL;",
          "2265:     isn->isn_arg.echo.echo_with_white = with_white;",
          "2266:     isn->isn_arg.echo.echo_count = count;",
          "2268:     return OK;",
          "2269: }",
          "2274:     static int",
          "2275: generate_MULT_EXPR(cctx_T *cctx, isntype_T isn_type, int count)",
          "2276: {",
          "2277:     isn_T *isn;",
          "2279:     if ((isn = generate_instr_drop(cctx, isn_type, count)) == NULL)",
          "2280:  return FAIL;",
          "2281:     isn->isn_arg.number = count;",
          "2283:     return OK;",
          "2284: }",
          "2289:     static int",
          "2290: generate_PUT(cctx_T *cctx, int regname, linenr_T lnum)",
          "2291: {",
          "2292:     isn_T *isn;",
          "2294:     RETURN_OK_IF_SKIP(cctx);",
          "2295:     if ((isn = generate_instr(cctx, ISN_PUT)) == NULL)",
          "2296:  return FAIL;",
          "2297:     isn->isn_arg.put.put_regname = regname;",
          "2298:     isn->isn_arg.put.put_lnum = lnum;",
          "2299:     return OK;",
          "2300: }",
          "2306:     static int",
          "2307: generate_EXEC_copy(cctx_T *cctx, isntype_T isntype, char_u *line)",
          "2308: {",
          "2309:     isn_T *isn;",
          "2311:     RETURN_OK_IF_SKIP(cctx);",
          "2312:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "2313:  return FAIL;",
          "2314:     isn->isn_arg.string = vim_strsave(line);",
          "2315:     return OK;",
          "2316: }",
          "2322:     static int",
          "2323: generate_EXEC(cctx_T *cctx, isntype_T isntype, char_u *str)",
          "2324: {",
          "2325:     isn_T *isn;",
          "2327:     if (cctx->ctx_skip == SKIP_YES)",
          "2328:     {",
          "2329:  vim_free(str);",
          "2330:  return OK;",
          "2331:     }",
          "2332:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "2333:     {",
          "2334:  vim_free(str);",
          "2335:  return FAIL;",
          "2336:     }",
          "2337:     isn->isn_arg.string = str;",
          "2338:     return OK;",
          "2339: }",
          "2341:     static int",
          "2342: generate_LEGACY_EVAL(cctx_T *cctx, char_u *line)",
          "2343: {",
          "2344:     isn_T *isn;",
          "2345:     garray_T *stack = &cctx->ctx_type_stack;",
          "2347:     RETURN_OK_IF_SKIP(cctx);",
          "2348:     if ((isn = generate_instr(cctx, ISN_LEGACY_EVAL)) == NULL)",
          "2349:  return FAIL;",
          "2350:     isn->isn_arg.string = vim_strsave(line);",
          "2352:     if (GA_GROW_FAILS(stack, 1))",
          "2353:  return FAIL;",
          "2354:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_any;",
          "2355:     ++stack->ga_len;",
          "2357:     return OK;",
          "2358: }",
          "2360:     static int",
          "2361: generate_EXECCONCAT(cctx_T *cctx, int count)",
          "2362: {",
          "2363:     isn_T *isn;",
          "2365:     if ((isn = generate_instr_drop(cctx, ISN_EXECCONCAT, count)) == NULL)",
          "2366:  return FAIL;",
          "2367:     isn->isn_arg.number = count;",
          "2368:     return OK;",
          "2369: }",
          "2374:     static int",
          "2375: generate_RANGE(cctx_T *cctx, char_u *range)",
          "2376: {",
          "2377:     isn_T *isn;",
          "2378:     garray_T *stack = &cctx->ctx_type_stack;",
          "2380:     if ((isn = generate_instr(cctx, ISN_RANGE)) == NULL)",
          "2381:  return FAIL;",
          "2382:     isn->isn_arg.string = range;",
          "2384:     if (GA_GROW_FAILS(stack, 1))",
          "2385:  return FAIL;",
          "2386:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_number;",
          "2387:     ++stack->ga_len;",
          "2388:     return OK;",
          "2389: }",
          "2391:     static int",
          "2392: generate_UNPACK(cctx_T *cctx, int var_count, int semicolon)",
          "2393: {",
          "2394:     isn_T *isn;",
          "2396:     RETURN_OK_IF_SKIP(cctx);",
          "2397:     if ((isn = generate_instr(cctx, ISN_UNPACK)) == NULL)",
          "2398:  return FAIL;",
          "2399:     isn->isn_arg.unpack.unp_count = var_count;",
          "2400:     isn->isn_arg.unpack.unp_semicolon = semicolon;",
          "2401:     return OK;",
          "2402: }",
          "2407:     static int",
          "2408: generate_cmdmods(cctx_T *cctx, cmdmod_T *cmod)",
          "2409: {",
          "2410:     isn_T *isn;",
          "2412:     if (has_cmdmod(cmod, FALSE))",
          "2413:     {",
          "2414:  cctx->ctx_has_cmdmod = TRUE;",
          "2416:  if ((isn = generate_instr(cctx, ISN_CMDMOD)) == NULL)",
          "2417:      return FAIL;",
          "2418:  isn->isn_arg.cmdmod.cf_cmdmod = ALLOC_ONE(cmdmod_T);",
          "2419:  if (isn->isn_arg.cmdmod.cf_cmdmod == NULL)",
          "2420:      return FAIL;",
          "2421:  mch_memmove(isn->isn_arg.cmdmod.cf_cmdmod, cmod, sizeof(cmdmod_T));",
          "2423:  cmod->cmod_filter_regmatch.regprog = NULL;",
          "2424:     }",
          "2426:     return OK;",
          "2427: }",
          "2429:     static int",
          "2430: generate_undo_cmdmods(cctx_T *cctx)",
          "2431: {",
          "2432:     if (cctx->ctx_has_cmdmod && generate_instr(cctx, ISN_CMDMOD_REV) == NULL)",
          "2433:  return FAIL;",
          "2434:     cctx->ctx_has_cmdmod = FALSE;",
          "2435:     return OK;",
          "2436: }",
          "2438:     static int",
          "2439: misplaced_cmdmod(cctx_T *cctx)",
          "2440: {",
          "2441:     garray_T *instr = &cctx->ctx_instr;",
          "2443:     if (cctx->ctx_has_cmdmod",
          "2444:      && ((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type",
          "2445:          == ISN_CMDMOD)",
          "2446:     {",
          "2447:  emsg(_(e_misplaced_command_modifier));",
          "2448:  return TRUE;",
          "2449:     }",
          "2450:     return FALSE;",
          "2451: }",
          "2457:     static int",
          "2458: current_instr_idx(cctx_T *cctx)",
          "2459: {",
          "2460:     garray_T *instr = &cctx->ctx_instr;",
          "2461:     int  idx = instr->ga_len;",
          "2463:     while (idx > 0)",
          "2464:     {",
          "2465:  if (cctx->ctx_has_cmdmod && ((isn_T *)instr->ga_data)[idx - 1]",
          "2466:              .isn_type == ISN_CMDMOD)",
          "2467:  {",
          "2468:      --idx;",
          "2469:      continue;",
          "2470:  }",
          "2471: #ifdef FEAT_PROFILE",
          "2472:  if (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_PROF_START)",
          "2473:  {",
          "2474:      --idx;",
          "2475:      continue;",
          "2476:  }",
          "2477: #endif",
          "2478:  if (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_DEBUG)",
          "2479:  {",
          "2480:      --idx;",
          "2481:      continue;",
          "2482:  }",
          "2483:  break;",
          "2484:     }",
          "2485:     return idx;",
          "2486: }",
          "2488: #ifdef FEAT_PROFILE",
          "2489:     static void",
          "2490: may_generate_prof_end(cctx_T *cctx, int prof_lnum)",
          "2491: {",
          "2492:     if (cctx->ctx_compile_type == CT_PROFILE && prof_lnum >= 0)",
          "2493:  generate_instr(cctx, ISN_PROF_END);",
          "2494: }",
          "2495: #endif",
          "2501:     static lvar_T *",
          "2502: reserve_local(",
          "2503:  cctx_T *cctx,",
          "2504:  char_u *name,",
          "2505:  size_t len,",
          "2506:  int isConst,",
          "2507:  type_T *type)",
          "2508: {",
          "2509:     lvar_T  *lvar;",
          "2510:     dfunc_T *dfunc;",
          "2512:     if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)",
          "2513:     {",
          "2514:  emsg_namelen(_(e_str_is_used_as_argument), name, (int)len);",
          "2515:  return NULL;",
          "2516:     }",
          "2518:     if (GA_GROW_FAILS(&cctx->ctx_locals, 1))",
          "2519:  return NULL;",
          "2520:     lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;",
          "2521:     CLEAR_POINTER(lvar);",
          "2527:     dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;",
          "2528:     lvar->lv_idx = dfunc->df_var_names.ga_len;",
          "2530:     lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);",
          "2531:     lvar->lv_const = isConst;",
          "2532:     lvar->lv_type = type;",
          "2535:     if (GA_GROW_FAILS(&dfunc->df_var_names, 1))",
          "2536:  return NULL;",
          "2537:     ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =",
          "2538:           vim_strsave(lvar->lv_name);",
          "2539:     ++dfunc->df_var_names.ga_len;",
          "2541:     return lvar;",
          "2542: }",
          "2547:     static void",
          "2548: unwind_locals(cctx_T *cctx, int new_top)",
          "2549: {",
          "2550:     if (cctx->ctx_locals.ga_len > new_top)",
          "2551:     {",
          "2552:  int idx;",
          "2553:  lvar_T *lvar;",
          "2555:  for (idx = new_top; idx < cctx->ctx_locals.ga_len; ++idx)",
          "2556:  {",
          "2557:      lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;",
          "2558:      vim_free(lvar->lv_name);",
          "2559:  }",
          "2560:     }",
          "2561:     cctx->ctx_locals.ga_len = new_top;",
          "2562: }",
          "2567:     static void",
          "2568: free_locals(cctx_T *cctx)",
          "2569: {",
          "2570:     unwind_locals(cctx, 0);",
          "2571:     ga_clear(&cctx->ctx_locals);",
          "2572: }",
          "2579:     static int",
          "2580: check_item_writable(svar_T *sv, int check_writable, char_u *name)",
          "2581: {",
          "2582:     if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)",
          "2583:      || (check_writable == ASSIGN_FINAL",
          "2584:            && sv->sv_const == ASSIGN_CONST))",
          "2585:     {",
          "2586:  semsg(_(e_cannot_change_readonly_variable_str), name);",
          "2587:  return FAIL;",
          "2588:     }",
          "2589:     return OK;",
          "2590: }",
          "2599:     int",
          "2600: get_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx)",
          "2601: {",
          "2602:     hashtab_T     *ht;",
          "2603:     dictitem_T     *di;",
          "2604:     scriptitem_T    *si = SCRIPT_ITEM(sid);",
          "2605:     svar_T     *sv;",
          "2606:     int      idx;",
          "2608:     if (!SCRIPT_ID_VALID(sid))",
          "2609:  return -1;",
          "2610:     if (sid == current_sctx.sc_sid)",
          "2611:     {",
          "2612:  sallvar_T *sav = find_script_var(name, 0, cctx);",
          "2614:  if (sav == NULL)",
          "2615:      return -2;",
          "2616:  idx = sav->sav_var_vals_idx;",
          "2617:  sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;",
          "2618:  if (check_item_writable(sv, check_writable, name) == FAIL)",
          "2619:      return -2;",
          "2620:  return idx;",
          "2621:     }",
          "2624:     ht = &SCRIPT_VARS(sid);",
          "2625:     di = find_var_in_ht(ht, 0, name, TRUE);",
          "2626:     if (di == NULL)",
          "2627:  return -2;",
          "2630:     for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)",
          "2631:     {",
          "2632:  sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;",
          "2633:  if (sv->sv_tv == &di->di_tv)",
          "2634:  {",
          "2635:      if (check_item_writable(sv, check_writable, name) == FAIL)",
          "2636:   return -2;",
          "2637:      return idx;",
          "2638:  }",
          "2639:     }",
          "2640:     return -1;",
          "2641: }",
          "2647:     imported_T *",
          "2648: find_imported(char_u *name, size_t len, cctx_T *cctx)",
          "2649: {",
          "2650:     int      idx;",
          "2652:     if (!SCRIPT_ID_VALID(current_sctx.sc_sid))",
          "2653:  return NULL;",
          "2654:     if (cctx != NULL)",
          "2655:  for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)",
          "2656:  {",
          "2657:      imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data)",
          "2658:           + idx;",
          "2660:      if (len == 0 ? STRCMP(name, import->imp_name) == 0",
          "2661:     : STRLEN(import->imp_name) == len",
          "2662:       && STRNCMP(name, import->imp_name, len) == 0)",
          "2663:   return import;",
          "2664:  }",
          "2666:     return find_imported_in_script(name, len, current_sctx.sc_sid);",
          "2667: }",
          "2669:     imported_T *",
          "2670: find_imported_in_script(char_u *name, size_t len, int sid)",
          "2671: {",
          "2672:     scriptitem_T    *si;",
          "2673:     int      idx;",
          "2675:     if (!SCRIPT_ID_VALID(sid))",
          "2676:  return NULL;",
          "2677:     si = SCRIPT_ITEM(sid);",
          "2678:     for (idx = 0; idx < si->sn_imports.ga_len; ++idx)",
          "2679:     {",
          "2680:  imported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;",
          "2682:  if (len == 0 ? STRCMP(name, import->imp_name) == 0",
          "2683:        : STRLEN(import->imp_name) == len",
          "2684:       && STRNCMP(name, import->imp_name, len) == 0)",
          "2685:      return import;",
          "2686:     }",
          "2687:     return NULL;",
          "2688: }",
          "2693:     static void",
          "2694: free_imported(cctx_T *cctx)",
          "2695: {",
          "2696:     int idx;",
          "2698:     for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)",
          "2699:     {",
          "2700:  imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data) + idx;",
          "2702:  vim_free(import->imp_name);",
          "2703:     }",
          "2704:     ga_clear(&cctx->ctx_imports);",
          "2705: }",
          "2712:     char_u *",
          "2713: peek_next_line_from_context(cctx_T *cctx)",
          "2714: {",
          "2715:     int lnum = cctx->ctx_lnum;",
          "2717:     while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)",
          "2718:     {",
          "2719:  char_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];",
          "2720:  char_u *p;",
          "2723:  if (line != NULL)",
          "2724:  {",
          "2725:      p = skipwhite(line);",
          "2726:      if (vim9_bad_comment(p))",
          "2727:   return NULL;",
          "2728:      if (*p != NUL && !vim9_comment_start(p))",
          "2729:   return p;",
          "2730:  }",
          "2731:     }",
          "2732:     return NULL;",
          "2733: }",
          "2741:     static char_u *",
          "2742: may_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)",
          "2743: {",
          "2744:     char_u *p = skipwhite(arg);",
          "2747:     if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))",
          "2748:     {",
          "2750:  if (*nextp != NULL)",
          "2751:      return *nextp;",
          "2752:     }",
          "2753:     return p;",
          "2754: }",
          "2761:     char_u *",
          "2762: next_line_from_context(cctx_T *cctx, int skip_comment)",
          "2763: {",
          "2764:     char_u *line;",
          "2766:     do",
          "2767:     {",
          "2768:  ++cctx->ctx_lnum;",
          "2769:  if (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)",
          "2770:  {",
          "2771:      line = NULL;",
          "2772:      break;",
          "2773:  }",
          "2774:  line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];",
          "2775:  cctx->ctx_line_start = line;",
          "2776:  SOURCING_LNUM = cctx->ctx_lnum + 1;",
          "2777:     } while (line == NULL || *skipwhite(line) == NUL",
          "2778:        || (skip_comment && vim9_comment_start(skipwhite(line))));",
          "2779:     return line;",
          "2780: }",
          "2788:     static int",
          "2789: may_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)",
          "2790: {",
          "2792:     if (vim9_bad_comment(*arg))",
          "2793:  return FAIL;",
          "2794:     if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))",
          "2795:     {",
          "2796:  char_u *next = next_line_from_context(cctx, TRUE);",
          "2798:  if (next == NULL)",
          "2799:      return FAIL;",
          "2801:     }",
          "2802:     return OK;",
          "2803: }",
          "2808:     static int",
          "2809: may_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)",
          "2810: {",
          "2811:     if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "2812:     {",
          "2813:  SOURCING_LNUM = cctx->ctx_lnum + 1;",
          "2814:  emsg(_(e_line_incomplete));",
          "2815:  return FAIL;",
          "2816:     }",
          "2817:     return OK;",
          "2818: }",
          "2827: #define PPSIZE 50",
          "2828: typedef struct {",
          "2829:     typval_T pp_tv[PPSIZE]; // stack of ppconst constants",
          "2830:     int  pp_used; // active entries in pp_tv[]",
          "2831:     int  pp_is_const; // all generated code was constants, used for a",
          "2833: } ppconst_T;",
          "2835: static int compile_expr0_ext(char_u **arg,  cctx_T *cctx, int *is_const);",
          "2836: static int compile_expr0(char_u **arg,  cctx_T *cctx);",
          "2837: static int compile_expr1(char_u **arg,  cctx_T *cctx, ppconst_T *ppconst);",
          "2844:     static int",
          "2845: generate_tv_PUSH(cctx_T *cctx, typval_T *tv)",
          "2846: {",
          "2847:     if (tv != NULL)",
          "2848:     {",
          "2849:  switch (tv->v_type)",
          "2850:  {",
          "2851:      case VAR_UNKNOWN:",
          "2852:   break;",
          "2853:      case VAR_BOOL:",
          "2854:   generate_PUSHBOOL(cctx, tv->vval.v_number);",
          "2855:   break;",
          "2856:      case VAR_SPECIAL:",
          "2857:   generate_PUSHSPEC(cctx, tv->vval.v_number);",
          "2858:   break;",
          "2859:      case VAR_NUMBER:",
          "2860:   generate_PUSHNR(cctx, tv->vval.v_number);",
          "2861:   break;",
          "2862: #ifdef FEAT_FLOAT",
          "2863:      case VAR_FLOAT:",
          "2864:   generate_PUSHF(cctx, tv->vval.v_float);",
          "2865:   break;",
          "2866: #endif",
          "2867:      case VAR_BLOB:",
          "2868:   generate_PUSHBLOB(cctx, tv->vval.v_blob);",
          "2869:   tv->vval.v_blob = NULL;",
          "2870:   break;",
          "2871:      case VAR_STRING:",
          "2872:   generate_PUSHS(cctx, &tv->vval.v_string);",
          "2873:   tv->vval.v_string = NULL;",
          "2874:   break;",
          "2875:      default:",
          "2876:   iemsg(\"constant type not supported\");",
          "2877:   clear_tv(tv);",
          "2878:   return FAIL;",
          "2879:  }",
          "2880:  tv->v_type = VAR_UNKNOWN;",
          "2881:     }",
          "2882:     return OK;",
          "2883: }",
          "2888:     static int",
          "2889: generate_ppconst(cctx_T *cctx, ppconst_T *ppconst)",
          "2890: {",
          "2891:     int     i;",
          "2892:     int     ret = OK;",
          "2893:     int     save_skip = cctx->ctx_skip;",
          "2895:     cctx->ctx_skip = SKIP_NOT;",
          "2896:     for (i = 0; i < ppconst->pp_used; ++i)",
          "2897:  if (generate_tv_PUSH(cctx, &ppconst->pp_tv[i]) == FAIL)",
          "2898:      ret = FAIL;",
          "2899:     ppconst->pp_used = 0;",
          "2900:     cctx->ctx_skip = save_skip;",
          "2901:     return ret;",
          "2902: }",
          "2907:     static int",
          "2908: check_ppconst_bool(ppconst_T *ppconst)",
          "2909: {",
          "2910:     if (ppconst->pp_used > 0)",
          "2911:     {",
          "2912:  typval_T    *tv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "2913:  where_T     where = WHERE_INIT;",
          "2915:  return check_typval_type(&t_bool, tv, where);",
          "2916:     }",
          "2917:     return OK;",
          "2918: }",
          "2923:     static void",
          "2924: clear_ppconst(ppconst_T *ppconst)",
          "2925: {",
          "2926:     int     i;",
          "2928:     for (i = 0; i < ppconst->pp_used; ++i)",
          "2929:  clear_tv(&ppconst->pp_tv[i]);",
          "2930:     ppconst->pp_used = 0;",
          "2931: }",
          "2938:     static int",
          "2939: compile_member(int is_slice, int *keeping_dict, cctx_T *cctx)",
          "2940: {",
          "2941:     type_T **typep;",
          "2942:     garray_T *stack = &cctx->ctx_type_stack;",
          "2943:     vartype_T vartype;",
          "2944:     type_T *idxtype;",
          "2949:     typep = ((type_T **)stack->ga_data) + stack->ga_len",
          "2950:         - (is_slice ? 3 : 2);",
          "2951:     vartype = (*typep)->tt_type;",
          "2952:     idxtype = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "2954:     if (*typep == &t_any && idxtype == &t_string)",
          "2955:  vartype = VAR_DICT;",
          "2956:     if (vartype == VAR_STRING || vartype == VAR_LIST || vartype == VAR_BLOB)",
          "2957:     {",
          "2958:  if (need_type(idxtype, &t_number, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "2959:      return FAIL;",
          "2960:  if (is_slice)",
          "2961:  {",
          "2962:      idxtype = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "2963:      if (need_type(idxtype, &t_number, -2, 0, cctx,",
          "2964:         FALSE, FALSE) == FAIL)",
          "2965:   return FAIL;",
          "2966:  }",
          "2967:     }",
          "2969:     if (vartype == VAR_DICT)",
          "2970:     {",
          "2971:  if (is_slice)",
          "2972:  {",
          "2973:      emsg(_(e_cannot_slice_dictionary));",
          "2974:      return FAIL;",
          "2975:  }",
          "2976:  if ((*typep)->tt_type == VAR_DICT)",
          "2977:  {",
          "2979:      if (*typep == &t_unknown)",
          "2982:  }",
          "2983:  else",
          "2984:  {",
          "2985:      if (need_type(*typep, &t_dict_any, -2, 0, cctx,",
          "2986:         FALSE, FALSE) == FAIL)",
          "2987:   return FAIL;",
          "2989:  }",
          "2990:  if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "2991:      return FAIL;",
          "2992:  if (generate_instr_drop(cctx, ISN_MEMBER, 1) == FAIL)",
          "2993:      return FAIL;",
          "2994:  if (keeping_dict != NULL)",
          "2996:     }",
          "2997:     else if (vartype == VAR_STRING)",
          "2998:     {",
          "3000:  if ((is_slice",
          "3001:   ? generate_instr_drop(cctx, ISN_STRSLICE, 2)",
          "3002:   : generate_instr_drop(cctx, ISN_STRINDEX, 1)) == FAIL)",
          "3003:      return FAIL;",
          "3004:     }",
          "3005:     else if (vartype == VAR_BLOB)",
          "3006:     {",
          "3007:  if (is_slice)",
          "3008:  {",
          "3010:      if (generate_instr_drop(cctx, ISN_BLOBSLICE, 2) == FAIL)",
          "3011:   return FAIL;",
          "3012:  }",
          "3013:  else",
          "3014:  {",
          "3016:      if (generate_instr_drop(cctx, ISN_BLOBINDEX, 1) == FAIL)",
          "3017:   return FAIL;",
          "3018:  }",
          "3019:     }",
          "3020:     else if (vartype == VAR_LIST || *typep == &t_any)",
          "3021:     {",
          "3022:  if (is_slice)",
          "3023:  {",
          "3024:      if (generate_instr_drop(cctx,",
          "3025:        vartype == VAR_LIST ?  ISN_LISTSLICE : ISN_ANYSLICE,",
          "3026:            2) == FAIL)",
          "3027:   return FAIL;",
          "3028:  }",
          "3029:  else",
          "3030:  {",
          "3031:      if ((*typep)->tt_type == VAR_LIST)",
          "3032:      {",
          "3034:   if (*typep == &t_unknown)",
          "3037:      }",
          "3038:      if (generate_instr_drop(cctx,",
          "3039:    vartype == VAR_LIST ?  ISN_LISTINDEX : ISN_ANYINDEX, 1)",
          "3040:                == FAIL)",
          "3041:   return FAIL;",
          "3042:  }",
          "3043:     }",
          "3044:     else",
          "3045:     {",
          "3046:  switch (vartype)",
          "3047:  {",
          "3048:      case VAR_FUNC:",
          "3049:      case VAR_PARTIAL:",
          "3050:   emsg(_(e_cannot_index_a_funcref));",
          "3051:   break;",
          "3052:      case VAR_BOOL:",
          "3053:      case VAR_SPECIAL:",
          "3054:      case VAR_JOB:",
          "3055:      case VAR_CHANNEL:",
          "3056:      case VAR_INSTR:",
          "3057:      case VAR_UNKNOWN:",
          "3058:      case VAR_ANY:",
          "3059:      case VAR_VOID:",
          "3060:   emsg(_(e_cannot_index_special_variable));",
          "3061:   break;",
          "3062:      default:",
          "3063:   emsg(_(e_string_list_dict_or_blob_required));",
          "3064:  }",
          "3065:  return FAIL;",
          "3066:     }",
          "3067:     return OK;",
          "3068: }",
          "3075:     static int",
          "3076: compile_load_scriptvar(",
          "3077:  cctx_T *cctx,",
          "3078:  char_u *name,     // variable NUL terminated",
          "3079:  char_u *start,     // start of variable",
          "3080:  char_u **end,     // end of variable",
          "3081:  int    error)     // when TRUE may give error",
          "3082: {",
          "3083:     scriptitem_T    *si;",
          "3084:     int      idx;",
          "3085:     imported_T     *import;",
          "3087:     if (!SCRIPT_ID_VALID(current_sctx.sc_sid))",
          "3088:  return FAIL;",
          "3089:     si = SCRIPT_ITEM(current_sctx.sc_sid);",
          "3090:     idx = get_script_item_idx(current_sctx.sc_sid, name, 0, cctx);",
          "3091:     if (idx == -1 || si->sn_version != SCRIPT_VERSION_VIM9)",
          "3092:     {",
          "3094:  return generate_OLDSCRIPT(cctx, ISN_LOADS, name, current_sctx.sc_sid,",
          "3095:                &t_any);",
          "3096:     }",
          "3097:     if (idx >= 0)",
          "3098:     {",
          "3099:  svar_T  *sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;",
          "3101:  generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "3102:      current_sctx.sc_sid, idx, sv->sv_type);",
          "3103:  return OK;",
          "3104:     }",
          "3106:     import = find_imported(name, 0, cctx);",
          "3107:     if (import != NULL)",
          "3108:     {",
          "3109:  if (import->imp_flags & IMP_FLAGS_STAR)",
          "3110:  {",
          "3111:      char_u *p = skipwhite(*end);",
          "3112:      char_u *exp_name;",
          "3113:      int  cc;",
          "3114:      ufunc_T *ufunc;",
          "3115:      type_T *type;",
          "3118:      if (*p != '.')",
          "3119:      {",
          "3120:   semsg(_(e_expected_dot_after_name_str), start);",
          "3121:   return FAIL;",
          "3122:      }",
          "3123:      ++p;",
          "3124:      if (VIM_ISWHITE(*p))",
          "3125:      {",
          "3126:   emsg(_(e_no_white_space_allowed_after_dot));",
          "3127:   return FAIL;",
          "3128:      }",
          "3131:      exp_name = p;",
          "3132:      while (eval_isnamec(*p))",
          "3133:   ++p;",
          "3134:      cc = *p;",
          "3137:      idx = find_exported(import->imp_sid, exp_name, &ufunc, &type,",
          "3138:            cctx, TRUE);",
          "3140:      p = skipwhite(p);",
          "3143:      if (idx < 0)",
          "3144:      {",
          "3145:   if (*p == '(' && ufunc != NULL)",
          "3146:   {",
          "3147:       generate_PUSHFUNC(cctx, ufunc->uf_name, import->imp_type);",
          "3148:       return OK;",
          "3149:   }",
          "3150:   return FAIL;",
          "3151:      }",
          "3153:      generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "3154:       import->imp_sid,",
          "3155:       idx,",
          "3156:       type);",
          "3157:  }",
          "3158:  else if (import->imp_funcname != NULL)",
          "3159:      generate_PUSHFUNC(cctx, import->imp_funcname, import->imp_type);",
          "3160:  else",
          "3161:      generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "3162:       import->imp_sid,",
          "3163:       import->imp_var_vals_idx,",
          "3164:       import->imp_type);",
          "3165:  return OK;",
          "3166:     }",
          "3168:     if (error)",
          "3169:  semsg(_(e_item_not_found_str), name);",
          "3170:     return FAIL;",
          "3171: }",
          "3173:     static int",
          "3174: generate_funcref(cctx_T *cctx, char_u *name)",
          "3175: {",
          "3176:     ufunc_T *ufunc = find_func(name, FALSE, cctx);",
          "3178:     if (ufunc == NULL)",
          "3179:  return FAIL;",
          "3182:     if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))",
          "3183:      && compile_def_function(ufunc, TRUE, COMPILE_TYPE(ufunc), NULL)",
          "3184:                == FAIL)",
          "3185:  return FAIL;",
          "3186:     return generate_PUSHFUNC(cctx, ufunc->uf_name, ufunc->uf_func_type);",
          "3187: }",
          "3195:     static int",
          "3196: compile_load(",
          "3197:  char_u **arg,",
          "3198:  char_u *end_arg,",
          "3199:  cctx_T *cctx,",
          "3200:  int is_expr,",
          "3201:  int error)",
          "3202: {",
          "3203:     type_T *type;",
          "3204:     char_u *name = NULL;",
          "3205:     char_u *end = end_arg;",
          "3206:     int  res = FAIL;",
          "3207:     int  prev_called_emsg = called_emsg;",
          "3209:     if (*(*arg + 1) == ':')",
          "3210:     {",
          "3211:  if (end <= *arg + 2)",
          "3212:  {",
          "3213:      isntype_T  isn_type;",
          "3216:      switch (**arg)",
          "3217:      {",
          "3218:   case 'g': isn_type = ISN_LOADGDICT; break;",
          "3219:   case 'w': isn_type = ISN_LOADWDICT; break;",
          "3220:   case 't': isn_type = ISN_LOADTDICT; break;",
          "3221:   case 'b': isn_type = ISN_LOADBDICT; break;",
          "3222:   default:",
          "3223:       semsg(_(e_namespace_not_supported_str), *arg);",
          "3224:       goto theend;",
          "3225:      }",
          "3226:      if (generate_instr_type(cctx, isn_type, &t_dict_any) == NULL)",
          "3227:   goto theend;",
          "3228:      res = OK;",
          "3229:  }",
          "3230:  else",
          "3231:  {",
          "3232:      isntype_T  isn_type = ISN_DROP;",
          "3235:      name = vim_strnsave(*arg + 2, end - (*arg + 2));",
          "3236:      if (name == NULL)",
          "3237:   return FAIL;",
          "3239:      switch (**arg)",
          "3240:      {",
          "3241:   case 'v': res = generate_LOADV(cctx, name, error);",
          "3242:      break;",
          "3243:   case 's': if (is_expr && ASCII_ISUPPER(*name)",
          "3244:            && find_func(name, FALSE, cctx) != NULL)",
          "3245:          res = generate_funcref(cctx, name);",
          "3246:      else",
          "3247:          res = compile_load_scriptvar(cctx, name,",
          "3248:            NULL, &end, error);",
          "3249:      break;",
          "3250:   case 'g': if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)",
          "3251:      {",
          "3252:          if (is_expr && ASCII_ISUPPER(*name)",
          "3253:            && find_func(name, FALSE, cctx) != NULL)",
          "3254:       res = generate_funcref(cctx, name);",
          "3255:          else",
          "3256:       isn_type = ISN_LOADG;",
          "3257:      }",
          "3258:      else",
          "3259:      {",
          "3260:          isn_type = ISN_LOADAUTO;",
          "3261:          vim_free(name);",
          "3262:          name = vim_strnsave(*arg, end - *arg);",
          "3263:          if (name == NULL)",
          "3264:       return FAIL;",
          "3265:      }",
          "3266:      break;",
          "3267:   case 'w': isn_type = ISN_LOADW; break;",
          "3268:   case 't': isn_type = ISN_LOADT; break;",
          "3269:   case 'b': isn_type = ISN_LOADB; break;",
          "3270:   default:  // cannot happen, just in case",
          "3271:      semsg(_(e_namespace_not_supported_str), *arg);",
          "3272:      goto theend;",
          "3273:      }",
          "3274:      if (isn_type != ISN_DROP)",
          "3275:      {",
          "3279:   res = generate_LOAD(cctx, isn_type, 0, name, &t_any);",
          "3280:      }",
          "3281:  }",
          "3282:     }",
          "3283:     else",
          "3284:     {",
          "3285:  size_t     len = end - *arg;",
          "3286:  int     idx;",
          "3287:  int     gen_load = FALSE;",
          "3288:  int     gen_load_outer = 0;",
          "3290:  name = vim_strnsave(*arg, end - *arg);",
          "3291:  if (name == NULL)",
          "3292:      return FAIL;",
          "3294:  if (vim_strchr(name, AUTOLOAD_CHAR) != NULL)",
          "3295:  {",
          "3296:      script_autoload(name, FALSE);",
          "3297:      res = generate_LOAD(cctx, ISN_LOADAUTO, 0, name, &t_any);",
          "3298:  }",
          "3299:  else if (arg_exists(*arg, len, &idx, &type, &gen_load_outer, cctx)",
          "3300:           == OK)",
          "3301:  {",
          "3302:      if (gen_load_outer == 0)",
          "3303:   gen_load = TRUE;",
          "3304:  }",
          "3305:  else",
          "3306:  {",
          "3307:      lvar_T lvar;",
          "3309:      if (lookup_local(*arg, len, &lvar, cctx) == OK)",
          "3310:      {",
          "3311:   type = lvar.lv_type;",
          "3312:   idx = lvar.lv_idx;",
          "3313:   if (lvar.lv_from_outer != 0)",
          "3314:       gen_load_outer = lvar.lv_from_outer;",
          "3315:   else",
          "3316:       gen_load = TRUE;",
          "3317:      }",
          "3318:      else",
          "3319:      {",
          "3322:   if (script_var_exists(*arg, len, cctx) == OK",
          "3323:    || find_imported(name, 0, cctx) != NULL)",
          "3324:      res = compile_load_scriptvar(cctx, name, *arg, &end, FALSE);",
          "3329:   if (res == FAIL && is_expr && ASCII_ISUPPER(*name))",
          "3330:       res = generate_funcref(cctx, name);",
          "3331:      }",
          "3332:  }",
          "3333:  if (gen_load)",
          "3334:      res = generate_LOAD(cctx, ISN_LOAD, idx, NULL, type);",
          "3335:  if (gen_load_outer > 0)",
          "3336:  {",
          "3337:      res = generate_LOADOUTER(cctx, idx, gen_load_outer, type);",
          "3338:      cctx->ctx_outer_used = TRUE;",
          "3339:  }",
          "3340:     }",
          "3344: theend:",
          "3345:     if (res == FAIL && error && called_emsg == prev_called_emsg)",
          "3346:  semsg(_(e_variable_not_found_str), name);",
          "3347:     vim_free(name);",
          "3348:     return res;",
          "3349: }",
          "3351:     static void",
          "3352: clear_instr_ga(garray_T *gap)",
          "3353: {",
          "3354:     int idx;",
          "3356:     for (idx = 0; idx < gap->ga_len; ++idx)",
          "3357:  delete_instr(((isn_T *)gap->ga_data) + idx);",
          "3358:     ga_clear(gap);",
          "3359: }",
          "3365:     static int",
          "3366: compile_string(isn_T *isn, cctx_T *cctx)",
          "3367: {",
          "3368:     char_u *s = isn->isn_arg.string;",
          "3369:     garray_T save_ga = cctx->ctx_instr;",
          "3370:     int  expr_res;",
          "3371:     int  trailing_error;",
          "3372:     int  instr_count;",
          "3373:     isn_T *instr = NULL;",
          "3376:     --cctx->ctx_type_stack.ga_len;",
          "3380:     cctx->ctx_instr.ga_len = 0;",
          "3381:     cctx->ctx_instr.ga_maxlen = 0;",
          "3382:     cctx->ctx_instr.ga_data = NULL;",
          "3383:     expr_res = compile_expr0(&s, cctx);",
          "3384:     s = skipwhite(s);",
          "3385:     trailing_error = *s != NUL;",
          "3387:     if (expr_res == FAIL || trailing_error",
          "3388:            || GA_GROW_FAILS(&cctx->ctx_instr, 1))",
          "3389:     {",
          "3390:  if (trailing_error)",
          "3391:      semsg(_(e_trailing_arg), s);",
          "3392:  clear_instr_ga(&cctx->ctx_instr);",
          "3393:  cctx->ctx_instr = save_ga;",
          "3394:  ++cctx->ctx_type_stack.ga_len;",
          "3395:  return FAIL;",
          "3396:     }",
          "3400:     instr_count = cctx->ctx_instr.ga_len;",
          "3401:     instr = cctx->ctx_instr.ga_data;",
          "3402:     instr[instr_count].isn_type = ISN_FINISH;",
          "3404:     cctx->ctx_instr = save_ga;",
          "3405:     vim_free(isn->isn_arg.string);",
          "3406:     isn->isn_type = ISN_INSTR;",
          "3407:     isn->isn_arg.instr = instr;",
          "3408:     return OK;",
          "3409: }",
          "3415:     static int",
          "3416: compile_arguments(char_u **arg, cctx_T *cctx, int *argcount, int is_searchpair)",
          "3417: {",
          "3418:     char_u  *p = *arg;",
          "3419:     char_u  *whitep = *arg;",
          "3420:     int     must_end = FALSE;",
          "3421:     int     instr_count;",
          "3423:     for (;;)",
          "3424:     {",
          "3425:  if (may_get_next_line(whitep, &p, cctx) == FAIL)",
          "3426:      goto failret;",
          "3427:  if (*p == ')')",
          "3428:  {",
          "3430:      return OK;",
          "3431:  }",
          "3432:  if (must_end)",
          "3433:  {",
          "3434:      semsg(_(e_missing_comma_before_argument_str), p);",
          "3435:      return FAIL;",
          "3436:  }",
          "3438:  instr_count = cctx->ctx_instr.ga_len;",
          "3439:  if (compile_expr0(&p, cctx) == FAIL)",
          "3440:      return FAIL;",
          "3441:  ++*argcount;",
          "3443:  if (is_searchpair && *argcount == 5",
          "3444:   && cctx->ctx_instr.ga_len == instr_count + 1)",
          "3445:  {",
          "3446:      isn_T *isn = ((isn_T *)cctx->ctx_instr.ga_data) + instr_count;",
          "3449:      if (isn->isn_type == ISN_PUSHS && *isn->isn_arg.string != NUL)",
          "3450:   compile_string(isn, cctx);",
          "3451:  }",
          "3453:  if (*p != ',' && *skipwhite(p) == ',')",
          "3454:  {",
          "3455:      semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);",
          "3456:      p = skipwhite(p);",
          "3457:  }",
          "3458:  if (*p == ',')",
          "3459:  {",
          "3460:      ++p;",
          "3461:      if (*p != NUL && !VIM_ISWHITE(*p))",
          "3462:   semsg(_(e_white_space_required_after_str_str), \",\", p - 1);",
          "3463:  }",
          "3464:  else",
          "3465:      must_end = TRUE;",
          "3466:  whitep = p;",
          "3467:  p = skipwhite(p);",
          "3468:     }",
          "3469: failret:",
          "3470:     emsg(_(e_missing_closing_paren));",
          "3471:     return FAIL;",
          "3472: }",
          "3483:     static int",
          "3484: compile_call(",
          "3485:  char_u     **arg,",
          "3486:  size_t     varlen,",
          "3487:  cctx_T     *cctx,",
          "3488:  ppconst_T   *ppconst,",
          "3489:  int     argcount_init)",
          "3490: {",
          "3491:     char_u *name = *arg;",
          "3492:     char_u *p;",
          "3493:     int  argcount = argcount_init;",
          "3494:     char_u namebuf[100];",
          "3495:     char_u fname_buf[FLEN_FIXED + 1];",
          "3496:     char_u *tofree = NULL;",
          "3497:     int  error = FCERR_NONE;",
          "3498:     ufunc_T *ufunc = NULL;",
          "3499:     int  res = FAIL;",
          "3500:     int  is_autoload;",
          "3501:     int  is_searchpair;",
          "3505:     if ((varlen == 3 && STRNCMP(*arg, \"has\", 3) == 0)",
          "3506:      || (varlen == 15 && STRNCMP(*arg, \"exists_compiled\", 6) == 0))",
          "3507:     {",
          "3508:  char_u     *s = skipwhite(*arg + varlen + 1);",
          "3509:  typval_T    argvars[2];",
          "3510:  int     is_has = **arg == 'h';",
          "3512:  argvars[0].v_type = VAR_UNKNOWN;",
          "3513:  if (*s == '\"')",
          "3514:      (void)eval_string(&s, &argvars[0], TRUE);",
          "3515:  else if (*s == '\\'')",
          "3516:      (void)eval_lit_string(&s, &argvars[0], TRUE);",
          "3517:  s = skipwhite(s);",
          "3518:  if (*s == ')' && argvars[0].v_type == VAR_STRING",
          "3519:         && ((is_has && !dynamic_feature(argvars[0].vval.v_string))",
          "3520:       || !is_has))",
          "3521:  {",
          "3522:      typval_T *tv = &ppconst->pp_tv[ppconst->pp_used];",
          "3525:      argvars[1].v_type = VAR_UNKNOWN;",
          "3526:      tv->v_type = VAR_NUMBER;",
          "3527:      tv->vval.v_number = 0;",
          "3528:      if (is_has)",
          "3529:   f_has(argvars, tv);",
          "3530:      else",
          "3531:   f_exists(argvars, tv);",
          "3532:      clear_tv(&argvars[0]);",
          "3533:      ++ppconst->pp_used;",
          "3534:      return OK;",
          "3535:  }",
          "3536:  clear_tv(&argvars[0]);",
          "3537:  if (!is_has)",
          "3538:  {",
          "3539:      emsg(_(e_argument_of_exists_compiled_must_be_literal_string));",
          "3540:      return FAIL;",
          "3541:  }",
          "3542:     }",
          "3544:     if (generate_ppconst(cctx, ppconst) == FAIL)",
          "3545:  return FAIL;",
          "3547:     if (varlen >= sizeof(namebuf))",
          "3548:     {",
          "3549:  semsg(_(e_name_too_long_str), name);",
          "3550:  return FAIL;",
          "3551:     }",
          "3552:     vim_strncpy(namebuf, *arg, varlen);",
          "3553:     name = fname_trans_sid(namebuf, fname_buf, &tofree, &error);",
          "3557:     is_searchpair = (varlen == 6 && STRNCMP(*arg, \"search\", 6) == 0)",
          "3558:           || (varlen == 9 && STRNCMP(*arg, \"searchpos\", 9) == 0)",
          "3559:          || (varlen == 10 && STRNCMP(*arg, \"searchpair\", 10) == 0)",
          "3560:          || (varlen == 13 && STRNCMP(*arg, \"searchpairpos\", 13) == 0);",
          "3563:     if (compile_arguments(arg, cctx, &argcount, is_searchpair) == FAIL)",
          "3564:  goto theend;",
          "3566:     is_autoload = vim_strchr(name, AUTOLOAD_CHAR) != NULL;",
          "3567:     if (ASCII_ISLOWER(*name) && name[1] != ':' && !is_autoload)",
          "3568:     {",
          "3569:  int     idx;",
          "3572:  idx = find_internal_func(name);",
          "3573:  if (idx >= 0)",
          "3574:  {",
          "3575:      if (STRCMP(name, \"flatten\") == 0)",
          "3576:      {",
          "3577:   emsg(_(e_cannot_use_flatten_in_vim9_script));",
          "3578:   goto theend;",
          "3579:      }",
          "3581:      if (STRCMP(name, \"add\") == 0 && argcount == 2)",
          "3582:      {",
          "3583:   garray_T    *stack = &cctx->ctx_type_stack;",
          "3584:   type_T     *type = ((type_T **)stack->ga_data)[",
          "3585:            stack->ga_len - 2];",
          "3588:   if (type->tt_type == VAR_LIST)",
          "3589:   {",
          "3591:       res = generate_LISTAPPEND(cctx);",
          "3592:       idx = -1;",
          "3593:   }",
          "3594:   else if (type->tt_type == VAR_BLOB)",
          "3595:   {",
          "3597:       res = generate_BLOBAPPEND(cctx);",
          "3598:       idx = -1;",
          "3599:   }",
          "3600:      }",
          "3602:      if (idx >= 0)",
          "3603:   res = generate_BCALL(cctx, idx, argcount, argcount_init == 1);",
          "3604:  }",
          "3605:  else",
          "3606:      semsg(_(e_unknown_function_str), namebuf);",
          "3607:  goto theend;",
          "3608:     }",
          "3612:     if (lookup_local(namebuf, varlen, NULL, cctx) == FAIL",
          "3613:      && arg_exists(namebuf, varlen, NULL, NULL, NULL, cctx) != OK)",
          "3614:     {",
          "3617:  ufunc = find_func(name, FALSE, cctx);",
          "3618:  if (ufunc != NULL && !func_is_global(ufunc))",
          "3619:  {",
          "3620:      res = generate_CALL(cctx, ufunc, argcount);",
          "3621:      goto theend;",
          "3622:  }",
          "3623:     }",
          "3628:     p = namebuf;",
          "3629:     if (STRNCMP(namebuf, \"g:\", 2) != 0 && !is_autoload",
          "3630:      && compile_load(&p, namebuf + varlen, cctx, FALSE, FALSE) == OK)",
          "3631:     {",
          "3632:  garray_T    *stack = &cctx->ctx_type_stack;",
          "3633:  type_T     *type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "3635:  res = generate_PCALL(cctx, argcount, namebuf, type, FALSE);",
          "3636:  goto theend;",
          "3637:     }",
          "3640:     if (ufunc != NULL)",
          "3641:     {",
          "3642:  res = generate_CALL(cctx, ufunc, argcount);",
          "3643:  goto theend;",
          "3644:     }",
          "3648:     if (STRNCMP(namebuf, \"g:\", 2) == 0 || is_autoload)",
          "3649:  res = generate_UCALL(cctx, name, argcount);",
          "3650:     else",
          "3651:  semsg(_(e_unknown_function_str), namebuf);",
          "3653: theend:",
          "3654:     vim_free(tofree);",
          "3655:     return res;",
          "3656: }",
          "3659: #define VIM9_NAMESPACE_CHAR (char_u *)\"bgstvw\"",
          "3668:     char_u *",
          "3669: to_name_end(char_u *arg, int use_namespace)",
          "3670: {",
          "3671:     char_u *p;",
          "3674:     if (!eval_isnamec1(*arg))",
          "3675:  return arg;",
          "3677:     for (p = arg + 1; *p != NUL && eval_isnamec(*p); MB_PTR_ADV(p))",
          "3680:  if (*p == ':' && (p != arg + 1",
          "3681:         || !use_namespace",
          "3682:         || vim_strchr(VIM9_NAMESPACE_CHAR, *arg) == NULL))",
          "3683:      break;",
          "3684:     return p;",
          "3685: }",
          "3692:     char_u *",
          "3693: to_name_const_end(char_u *arg)",
          "3694: {",
          "3695:     char_u *p = arg;",
          "3696:     typval_T rettv;",
          "3698:     if (STRNCMP(p, \"<SNR>\", 5) == 0)",
          "3699:  p = skipdigits(p + 5);",
          "3700:     p = to_name_end(p, TRUE);",
          "3701:     if (p == arg && *arg == '[')",
          "3702:     {",
          "3705:  if (eval_list(&p, &rettv, NULL, FALSE) == FAIL)",
          "3706:      p = arg;",
          "3707:     }",
          "3708:     return p;",
          "3709: }",
          "3716:     static int",
          "3717: compile_list(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "3718: {",
          "3719:     char_u *p = skipwhite(*arg + 1);",
          "3720:     char_u *whitep = *arg + 1;",
          "3721:     int  count = 0;",
          "3722:     int  is_const;",
          "3723:     int  is_all_const = TRUE; // reset when non-const encountered",
          "3725:     for (;;)",
          "3726:     {",
          "3727:  if (may_get_next_line(whitep, &p, cctx) == FAIL)",
          "3728:  {",
          "3729:      semsg(_(e_list_end), *arg);",
          "3730:      return FAIL;",
          "3731:  }",
          "3732:  if (*p == ',')",
          "3733:  {",
          "3734:      semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);",
          "3735:      return FAIL;",
          "3736:  }",
          "3737:  if (*p == ']')",
          "3738:  {",
          "3739:      ++p;",
          "3740:      break;",
          "3741:  }",
          "3742:  if (compile_expr0_ext(&p, cctx, &is_const) == FAIL)",
          "3743:      return FAIL;",
          "3744:  if (!is_const)",
          "3745:      is_all_const = FALSE;",
          "3746:  ++count;",
          "3747:  if (*p == ',')",
          "3748:  {",
          "3749:      ++p;",
          "3750:      if (*p != ']' && !IS_WHITE_OR_NUL(*p))",
          "3751:      {",
          "3752:   semsg(_(e_white_space_required_after_str_str), \",\", p - 1);",
          "3753:   return FAIL;",
          "3754:      }",
          "3755:  }",
          "3756:  whitep = p;",
          "3757:  p = skipwhite(p);",
          "3758:     }",
          "3761:     ppconst->pp_is_const = is_all_const;",
          "3762:     return generate_NEWLIST(cctx, count);",
          "3763: }",
          "3770:     static int",
          "3771: compile_lambda(char_u **arg, cctx_T *cctx)",
          "3772: {",
          "3773:     int  r;",
          "3774:     typval_T rettv;",
          "3775:     ufunc_T *ufunc;",
          "3776:     evalarg_T evalarg;",
          "3778:     init_evalarg(&evalarg);",
          "3779:     evalarg.eval_flags = EVAL_EVALUATE;",
          "3780:     evalarg.eval_cctx = cctx;",
          "3783:     r = get_lambda_tv(arg, &rettv, TRUE, &evalarg);",
          "3784:     if (r != OK)",
          "3785:     {",
          "3786:  clear_evalarg(&evalarg, NULL);",
          "3787:  return r;",
          "3788:     }",
          "3791:     ufunc = rettv.vval.v_partial->pt_func;",
          "3792:     ++ufunc->uf_refcount;",
          "3793:     clear_tv(&rettv);",
          "3798:     if (ufunc->uf_ret_type->tt_type == VAR_VOID)",
          "3799:  ufunc->uf_ret_type = &t_unknown;",
          "3800:     compile_def_function(ufunc, FALSE, cctx->ctx_compile_type, cctx);",
          "3805:     if (cctx->ctx_compile_type == CT_DEBUG",
          "3806: #ifdef FEAT_PROFILE",
          "3807:      || cctx->ctx_compile_type == CT_PROFILE",
          "3808: #endif",
          "3809:        )",
          "3810:  compile_def_function(ufunc, FALSE, CT_NONE, cctx);",
          "3815:     if (evalarg.eval_using_cmdline)",
          "3816:     {",
          "3817:  garray_T    *gap = &evalarg.eval_tofree_ga;",
          "3818:  size_t     off = *arg - ((char_u **)gap->ga_data)[gap->ga_len - 1];",
          "3821:           + off;",
          "3822:     }",
          "3824:     clear_evalarg(&evalarg, NULL);",
          "3826:     if (ufunc->uf_def_status == UF_COMPILED)",
          "3827:     {",
          "3829:  set_function_type(ufunc);",
          "3834:  return generate_FUNCREF(cctx, ufunc);",
          "3835:     }",
          "3837:     func_ptr_unref(ufunc);",
          "3838:     return FAIL;",
          "3839: }",
          "3844:     int",
          "3845: get_lambda_tv_and_compile(",
          "3846:  char_u     **arg,",
          "3847:  typval_T    *rettv,",
          "3848:  int     types_optional,",
          "3849:  evalarg_T   *evalarg)",
          "3850: {",
          "3851:     int  r;",
          "3852:     ufunc_T *ufunc;",
          "3853:     int  save_sc_version = current_sctx.sc_version;",
          "3856:     current_sctx.sc_version = SCRIPT_VERSION_VIM9;",
          "3857:     r = get_lambda_tv(arg, rettv, types_optional, evalarg);",
          "3858:     current_sctx.sc_version = save_sc_version;",
          "3859:     if (r != OK)",
          "3860:  return r;",
          "3863:     ufunc = rettv->vval.v_partial->pt_func;",
          "3868:     if (ufunc->uf_ret_type == NULL || ufunc->uf_ret_type->tt_type == VAR_VOID)",
          "3869:  ufunc->uf_ret_type = &t_unknown;",
          "3870:     compile_def_function(ufunc, FALSE, CT_NONE, NULL);",
          "3872:     if (ufunc->uf_def_status == UF_COMPILED)",
          "3873:     {",
          "3875:  set_function_type(ufunc);",
          "3876:  return OK;",
          "3877:     }",
          "3878:     clear_tv(rettv);",
          "3879:     return FAIL;",
          "3880: }",
          "3887:     static int",
          "3888: compile_dict(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "3889: {",
          "3890:     garray_T *instr = &cctx->ctx_instr;",
          "3891:     int  count = 0;",
          "3892:     dict_T *d = dict_alloc();",
          "3893:     dictitem_T *item;",
          "3894:     char_u *whitep = *arg + 1;",
          "3895:     char_u *p;",
          "3896:     int  is_const;",
          "3897:     int  is_all_const = TRUE; // reset when non-const encountered",
          "3899:     if (d == NULL)",
          "3900:  return FAIL;",
          "3901:     if (generate_ppconst(cctx, ppconst) == FAIL)",
          "3902:  return FAIL;",
          "3903:     for (;;)",
          "3904:     {",
          "3905:  char_u     *key = NULL;",
          "3907:  if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "3908:  {",
          "3910:      goto failret;",
          "3911:  }",
          "3913:  if (**arg == '}')",
          "3914:      break;",
          "3916:  if (**arg == '[')",
          "3917:  {",
          "3918:      isn_T *isn;",
          "3922:      if (compile_expr0(arg, cctx) == FAIL)",
          "3923:   return FAIL;",
          "3924:      isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "3925:      if (isn->isn_type == ISN_PUSHNR)",
          "3926:      {",
          "3927:   char buf[NUMBUFLEN];",
          "3930:   vim_snprintf(buf, NUMBUFLEN, \"%lld\", isn->isn_arg.number);",
          "3931:   isn->isn_type = ISN_PUSHS;",
          "3932:   isn->isn_arg.string = vim_strsave((char_u *)buf);",
          "3933:      }",
          "3934:      if (isn->isn_type == ISN_PUSHS)",
          "3935:   key = isn->isn_arg.string;",
          "3936:      else if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "3937:   return FAIL;",
          "3939:      if (**arg != ']')",
          "3940:      {",
          "3941:   emsg(_(e_missing_matching_bracket_after_dict_key));",
          "3942:   return FAIL;",
          "3943:      }",
          "3944:      ++*arg;",
          "3945:  }",
          "3946:  else",
          "3947:  {",
          "3951:      key = get_literal_key(arg);",
          "3952:      if (key == NULL)",
          "3953:   return FAIL;",
          "3954:      if (generate_PUSHS(cctx, &key) == FAIL)",
          "3955:   return FAIL;",
          "3956:  }",
          "3959:  if (key != NULL)",
          "3960:  {",
          "3961:      item = dict_find(d, key, -1);",
          "3962:      if (item != NULL)",
          "3963:      {",
          "3964:   semsg(_(e_duplicate_key), key);",
          "3965:   goto failret;",
          "3966:      }",
          "3967:      item = dictitem_alloc(key);",
          "3968:      if (item != NULL)",
          "3969:      {",
          "3970:   item->di_tv.v_type = VAR_UNKNOWN;",
          "3971:   item->di_tv.v_lock = 0;",
          "3972:   if (dict_add(d, item) == FAIL)",
          "3973:       dictitem_free(item);",
          "3974:      }",
          "3975:  }",
          "3977:  if (**arg != ':')",
          "3978:  {",
          "3979:      if (*skipwhite(*arg) == ':')",
          "3980:   semsg(_(e_no_white_space_allowed_before_str_str), \":\", *arg);",
          "3981:      else",
          "3982:   semsg(_(e_missing_dict_colon), *arg);",
          "3983:      return FAIL;",
          "3984:  }",
          "3985:  whitep = *arg + 1;",
          "3986:  if (!IS_WHITE_OR_NUL(*whitep))",
          "3987:  {",
          "3988:      semsg(_(e_white_space_required_after_str_str), \":\", *arg);",
          "3989:      return FAIL;",
          "3990:  }",
          "3992:  if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "3993:  {",
          "3995:      goto failret;",
          "3996:  }",
          "3998:  if (compile_expr0_ext(arg, cctx, &is_const) == FAIL)",
          "3999:      return FAIL;",
          "4000:  if (!is_const)",
          "4001:      is_all_const = FALSE;",
          "4002:  ++count;",
          "4004:  whitep = *arg;",
          "4005:  if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "4006:  {",
          "4008:      goto failret;",
          "4009:  }",
          "4010:  if (**arg == '}')",
          "4011:      break;",
          "4012:  if (**arg != ',')",
          "4013:  {",
          "4014:      semsg(_(e_missing_dict_comma), *arg);",
          "4015:      goto failret;",
          "4016:  }",
          "4017:  if (IS_WHITE_OR_NUL(*whitep))",
          "4018:  {",
          "4019:      semsg(_(e_no_white_space_allowed_before_str_str), \",\", whitep);",
          "4020:      return FAIL;",
          "4021:  }",
          "4022:  whitep = *arg + 1;",
          "4023:  if (!IS_WHITE_OR_NUL(*whitep))",
          "4024:  {",
          "4025:      semsg(_(e_white_space_required_after_str_str), \",\", *arg);",
          "4026:      return FAIL;",
          "4027:  }",
          "4029:     }",
          "4034:     p = skipwhite(*arg);",
          "4035:     if (VIM_ISWHITE(**arg) && vim9_comment_start(p))",
          "4038:     dict_unref(d);",
          "4039:     ppconst->pp_is_const = is_all_const;",
          "4040:     return generate_NEWDICT(cctx, count);",
          "4042: failret:",
          "4043:     if (*arg == NULL)",
          "4044:     {",
          "4045:  semsg(_(e_missing_dict_end), _(\"[end of lines]\"));",
          "4047:     }",
          "4048:     dict_unref(d);",
          "4049:     return FAIL;",
          "4050: }",
          "4055:     static int",
          "4056: compile_get_option(char_u **arg, cctx_T *cctx)",
          "4057: {",
          "4058:     typval_T rettv;",
          "4059:     char_u *start = *arg;",
          "4060:     int  ret;",
          "4063:     rettv.v_type = VAR_UNKNOWN;",
          "4064:     ret = eval_option(arg, &rettv, TRUE);",
          "4065:     if (ret == OK)",
          "4066:     {",
          "4068:  char_u *name = vim_strnsave(start, *arg - start);",
          "4069:  type_T *type = rettv.v_type == VAR_BOOL ? &t_bool",
          "4070:      : rettv.v_type == VAR_NUMBER ? &t_number : &t_string;",
          "4072:  ret = generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);",
          "4073:  vim_free(name);",
          "4074:     }",
          "4075:     clear_tv(&rettv);",
          "4077:     return ret;",
          "4078: }",
          "4083:     static int",
          "4084: compile_get_env(char_u **arg, cctx_T *cctx)",
          "4085: {",
          "4086:     char_u *start = *arg;",
          "4087:     int  len;",
          "4088:     int  ret;",
          "4089:     char_u *name;",
          "4091:     ++*arg;",
          "4092:     len = get_env_len(arg);",
          "4093:     if (len == 0)",
          "4094:     {",
          "4095:  semsg(_(e_syntax_error_at_str), start - 1);",
          "4096:  return FAIL;",
          "4097:     }",
          "4100:     name = vim_strnsave(start, len + 1);",
          "4101:     ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);",
          "4102:     vim_free(name);",
          "4103:     return ret;",
          "4104: }",
          "4109:     static int",
          "4110: compile_get_register(char_u **arg, cctx_T *cctx)",
          "4111: {",
          "4112:     int  ret;",
          "4114:     ++*arg;",
          "4115:     if (**arg == NUL)",
          "4116:     {",
          "4117:  semsg(_(e_syntax_error_at_str), *arg - 1);",
          "4118:  return FAIL;",
          "4119:     }",
          "4120:     if (!valid_yank_reg(**arg, FALSE))",
          "4121:     {",
          "4122:  emsg_invreg(**arg);",
          "4123:  return FAIL;",
          "4124:     }",
          "4125:     ret = generate_LOAD(cctx, ISN_LOADREG, **arg, NULL, &t_string);",
          "4126:     ++*arg;",
          "4127:     return ret;",
          "4128: }",
          "4134:     static int",
          "4135: apply_leader(typval_T *rettv, int numeric_only, char_u *start, char_u **end)",
          "4136: {",
          "4137:     char_u *p = *end;",
          "4140:     while (p > start)",
          "4141:     {",
          "4142:  --p;",
          "4143:  if (*p == '-' || *p == '+')",
          "4144:  {",
          "4146: #ifdef FEAT_FLOAT",
          "4147:      if (rettv->v_type == VAR_FLOAT)",
          "4148:      {",
          "4149:   if (*p == '-')",
          "4150:       rettv->vval.v_float = -rettv->vval.v_float;",
          "4151:      }",
          "4152:      else",
          "4153: #endif",
          "4154:      {",
          "4155:   varnumber_T val;",
          "4156:   int  error = FALSE;",
          "4160:   if (check_not_string(rettv) == FAIL)",
          "4161:       return FAIL;",
          "4162:   val = tv_get_number_chk(rettv, &error);",
          "4163:   clear_tv(rettv);",
          "4164:   if (error)",
          "4165:       return FAIL;",
          "4166:   if (*p == '-')",
          "4167:       val = -val;",
          "4168:   rettv->v_type = VAR_NUMBER;",
          "4169:   rettv->vval.v_number = val;",
          "4170:      }",
          "4171:  }",
          "4172:  else if (numeric_only)",
          "4173:  {",
          "4174:      ++p;",
          "4175:      break;",
          "4176:  }",
          "4177:  else if (*p == '!')",
          "4178:  {",
          "4179:      int v = tv2bool(rettv);",
          "4182:      clear_tv(rettv);",
          "4183:      rettv->v_type = VAR_BOOL;",
          "4184:      rettv->vval.v_number = v ? VVAL_FALSE : VVAL_TRUE;",
          "4185:  }",
          "4186:     }",
          "4188:     return OK;",
          "4189: }",
          "4194:     static void",
          "4195: get_vim_constant(char_u **arg, typval_T *rettv)",
          "4196: {",
          "4197:     if (STRNCMP(*arg, \"v:true\", 6) == 0)",
          "4198:     {",
          "4199:  rettv->v_type = VAR_BOOL;",
          "4200:  rettv->vval.v_number = VVAL_TRUE;",
          "4202:     }",
          "4203:     else if (STRNCMP(*arg, \"v:false\", 7) == 0)",
          "4204:     {",
          "4205:  rettv->v_type = VAR_BOOL;",
          "4206:  rettv->vval.v_number = VVAL_FALSE;",
          "4208:     }",
          "4209:     else if (STRNCMP(*arg, \"v:null\", 6) == 0)",
          "4210:     {",
          "4211:  rettv->v_type = VAR_SPECIAL;",
          "4212:  rettv->vval.v_number = VVAL_NULL;",
          "4214:     }",
          "4215:     else if (STRNCMP(*arg, \"v:none\", 6) == 0)",
          "4216:     {",
          "4217:  rettv->v_type = VAR_SPECIAL;",
          "4218:  rettv->vval.v_number = VVAL_NONE;",
          "4220:     }",
          "4221: }",
          "4223:     exprtype_T",
          "4224: get_compare_type(char_u *p, int *len, int *type_is)",
          "4225: {",
          "4226:     exprtype_T type = EXPR_UNKNOWN;",
          "4227:     int  i;",
          "4229:     switch (p[0])",
          "4230:     {",
          "4231:  case '=':   if (p[1] == '=')",
          "4232:    type = EXPR_EQUAL;",
          "4233:       else if (p[1] == '~')",
          "4234:    type = EXPR_MATCH;",
          "4235:       break;",
          "4236:  case '!':   if (p[1] == '=')",
          "4237:    type = EXPR_NEQUAL;",
          "4238:       else if (p[1] == '~')",
          "4239:    type = EXPR_NOMATCH;",
          "4240:       break;",
          "4241:  case '>':   if (p[1] != '=')",
          "4242:       {",
          "4243:    type = EXPR_GREATER;",
          "4245:       }",
          "4246:       else",
          "4247:    type = EXPR_GEQUAL;",
          "4248:       break;",
          "4249:  case '<':   if (p[1] != '=')",
          "4250:       {",
          "4251:    type = EXPR_SMALLER;",
          "4253:       }",
          "4254:       else",
          "4255:    type = EXPR_SEQUAL;",
          "4256:       break;",
          "4257:  case 'i':   if (p[1] == 's')",
          "4258:       {",
          "4260:    if (p[2] == 'n' && p[3] == 'o' && p[4] == 't')",
          "4262:    i = p[*len];",
          "4263:    if (!isalnum(i) && i != '_')",
          "4264:    {",
          "4265:        type = *len == 2 ? EXPR_IS : EXPR_ISNOT;",
          "4267:    }",
          "4268:       }",
          "4269:       break;",
          "4270:     }",
          "4271:     return type;",
          "4272: }",
          "4277:     static void",
          "4278: skip_expr_cctx(char_u **arg, cctx_T *cctx)",
          "4279: {",
          "4280:     evalarg_T evalarg;",
          "4282:     init_evalarg(&evalarg);",
          "4283:     evalarg.eval_cctx = cctx;",
          "4284:     skip_expr(arg, &evalarg);",
          "4285:     clear_evalarg(&evalarg, NULL);",
          "4286: }",
          "4292:     static int",
          "4293: compile_leader(cctx_T *cctx, int numeric_only, char_u *start, char_u **end)",
          "4294: {",
          "4295:     char_u *p = *end;",
          "4298:     while (p > start)",
          "4299:     {",
          "4300:  --p;",
          "4301:  while (VIM_ISWHITE(*p))",
          "4302:      --p;",
          "4303:  if (*p == '-' || *p == '+')",
          "4304:  {",
          "4305:      int  negate = *p == '-';",
          "4306:      isn_T *isn;",
          "4307:      garray_T    *stack = &cctx->ctx_type_stack;",
          "4308:      type_T *type;",
          "4310:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "4311:      if (type != &t_float && need_type(type, &t_number,",
          "4312:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "4313:   return FAIL;",
          "4315:      while (p > start && (p[-1] == '-' || p[-1] == '+'))",
          "4316:      {",
          "4317:   --p;",
          "4318:   if (*p == '-')",
          "4319:       negate = !negate;",
          "4320:      }",
          "4322:      if (negate)",
          "4323:      {",
          "4324:   isn = generate_instr(cctx, ISN_NEGATENR);",
          "4325:   if (isn == NULL)",
          "4326:       return FAIL;",
          "4327:      }",
          "4328:  }",
          "4329:  else if (numeric_only)",
          "4330:  {",
          "4331:      ++p;",
          "4332:      break;",
          "4333:  }",
          "4334:  else",
          "4335:  {",
          "4336:      int  invert = *p == '!';",
          "4338:      while (p > start && (p[-1] == '!' || VIM_ISWHITE(p[-1])))",
          "4339:      {",
          "4340:   if (p[-1] == '!')",
          "4341:       invert = !invert;",
          "4342:   --p;",
          "4343:      }",
          "4344:      if (generate_2BOOL(cctx, invert, -1) == FAIL)",
          "4345:   return FAIL;",
          "4346:  }",
          "4347:     }",
          "4349:     return OK;",
          "4350: }",
          "4356:     static int",
          "4357: compile_parenthesis(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "4358: {",
          "4359:     int     ret;",
          "4360:     char_u  *p = *arg + 1;",
          "4362:     if (may_get_next_line_error(p, arg, cctx) == FAIL)",
          "4363:  return FAIL;",
          "4364:     if (ppconst->pp_used <= PPSIZE - 10)",
          "4365:     {",
          "4366:  ret = compile_expr1(arg, cctx, ppconst);",
          "4367:     }",
          "4368:     else",
          "4369:     {",
          "4371:  if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4372:      return FAIL;",
          "4373:  ret = compile_expr0(arg, cctx);",
          "4374:     }",
          "4375:     if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "4376:  return FAIL;",
          "4377:     if (**arg == ')')",
          "4378:  ++*arg;",
          "4379:     else if (ret == OK)",
          "4380:     {",
          "4381:  emsg(_(e_missing_closing_paren));",
          "4382:  ret = FAIL;",
          "4383:     }",
          "4384:     return ret;",
          "4385: }",
          "4391:     static int",
          "4392: compile_subscript(",
          "4393:  char_u **arg,",
          "4394:  cctx_T *cctx,",
          "4395:  char_u *start_leader,",
          "4396:  char_u **end_leader,",
          "4397:  ppconst_T *ppconst)",
          "4398: {",
          "4399:     char_u *name_start = *end_leader;",
          "4400:     int  keeping_dict = FALSE;",
          "4402:     for (;;)",
          "4403:     {",
          "4404:  char_u *p = skipwhite(*arg);",
          "4406:  if (*p == NUL || (VIM_ISWHITE(**arg) && vim9_comment_start(p)))",
          "4407:  {",
          "4408:      char_u *next = peek_next_line_from_context(cctx);",
          "4413:      if (next != NULL &&",
          "4414:       ((next[0] == '-' && next[1] == '>'",
          "4415:      && (next[2] == '{'",
          "4416:            || ASCII_ISALPHA(*skipwhite(next + 2))))",
          "4417:       || (next[0] == '.' && eval_isdictc(next[1]))))",
          "4418:      {",
          "4419:   next = next_line_from_context(cctx, TRUE);",
          "4420:   if (next == NULL)",
          "4421:       return FAIL;",
          "4423:   p = skipwhite(*arg);",
          "4424:      }",
          "4425:  }",
          "4429:  if (**arg == '(')",
          "4430:  {",
          "4431:      garray_T    *stack = &cctx->ctx_type_stack;",
          "4432:      type_T *type;",
          "4433:      int  argcount = 0;",
          "4435:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4436:   return FAIL;",
          "4437:      ppconst->pp_is_const = FALSE;",
          "4440:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "4443:      if (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)",
          "4444:   return FAIL;",
          "4445:      if (generate_PCALL(cctx, argcount, name_start, type, TRUE) == FAIL)",
          "4446:   return FAIL;",
          "4447:      if (keeping_dict)",
          "4448:      {",
          "4449:   keeping_dict = FALSE;",
          "4450:   if (generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "4451:       return FAIL;",
          "4452:      }",
          "4453:  }",
          "4454:  else if (*p == '-' && p[1] == '>')",
          "4455:  {",
          "4456:      char_u *pstart = p;",
          "4458:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4459:   return FAIL;",
          "4460:      ppconst->pp_is_const = FALSE;",
          "4465:      if (compile_leader(cctx, TRUE, start_leader, end_leader) == FAIL)",
          "4466:   return FAIL;",
          "4468:      p += 2;",
          "4471:      if (**arg == '(')",
          "4472:      {",
          "4473:   int     argcount = 1;",
          "4474:   garray_T    *stack = &cctx->ctx_type_stack;",
          "4475:   int     type_idx_start = stack->ga_len;",
          "4476:   type_T     *type;",
          "4477:   int     expr_isn_start = cctx->ctx_instr.ga_len;",
          "4478:   int     expr_isn_end;",
          "4479:   int     arg_isn_count;",
          "4485:   if (compile_parenthesis(arg, cctx, ppconst) == FAIL)",
          "4486:       return FAIL;",
          "4490:   expr_isn_end = cctx->ctx_instr.ga_len;",
          "4493:   if (**arg != '(')",
          "4494:   {",
          "4495:       if (*skipwhite(*arg) == '(')",
          "4496:    emsg(_(e_nowhitespace));",
          "4497:       else",
          "4498:    semsg(_(e_missing_parenthesis_str), *arg);",
          "4499:       return FAIL;",
          "4500:   }",
          "4502:   if (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)",
          "4503:       return FAIL;",
          "4509:   stack = &cctx->ctx_type_stack;",
          "4510:   arg_isn_count = cctx->ctx_instr.ga_len - expr_isn_end;",
          "4511:   if (arg_isn_count > 0)",
          "4512:   {",
          "4513:       int     expr_isn_count = expr_isn_end - expr_isn_start;",
          "4514:       isn_T   *isn = ALLOC_MULT(isn_T, expr_isn_count);",
          "4516:       if (isn == NULL)",
          "4517:    return FAIL;",
          "4518:       mch_memmove(isn, ((isn_T *)cctx->ctx_instr.ga_data)",
          "4519:              + expr_isn_start,",
          "4520:             sizeof(isn_T) * expr_isn_count);",
          "4521:       mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)",
          "4522:              + expr_isn_start,",
          "4523:         ((isn_T *)cctx->ctx_instr.ga_data) + expr_isn_end,",
          "4524:       sizeof(isn_T) * arg_isn_count);",
          "4525:       mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)",
          "4526:            + expr_isn_start + arg_isn_count,",
          "4527:        isn, sizeof(isn_T) * expr_isn_count);",
          "4528:       vim_free(isn);",
          "4530:       type = ((type_T **)stack->ga_data)[type_idx_start];",
          "4531:       mch_memmove(((type_T **)stack->ga_data) + type_idx_start,",
          "4532:          ((type_T **)stack->ga_data) + type_idx_start + 1,",
          "4533:          sizeof(type_T *)",
          "4535:       ((type_T **)stack->ga_data)[stack->ga_len - 1] = type;",
          "4536:   }",
          "4538:   type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "4539:   if (generate_PCALL(cctx, argcount, p - 2, type, FALSE) == FAIL)",
          "4540:       return FAIL;",
          "4541:      }",
          "4542:      else",
          "4543:      {",
          "4545:   p = *arg;",
          "4546:   if (!eval_isnamec1(*p))",
          "4547:   {",
          "4548:       semsg(_(e_trailing_arg), pstart);",
          "4549:       return FAIL;",
          "4550:   }",
          "4551:   if (ASCII_ISALPHA(*p) && p[1] == ':')",
          "4552:       p += 2;",
          "4553:   for ( ; eval_isnamec(*p); ++p)",
          "4554:       ;",
          "4555:   if (*p != '(')",
          "4556:   {",
          "4557:       semsg(_(e_missing_parenthesis_str), *arg);",
          "4558:       return FAIL;",
          "4559:   }",
          "4560:   if (compile_call(arg, p - *arg, cctx, ppconst, 1) == FAIL)",
          "4561:       return FAIL;",
          "4562:      }",
          "4563:      if (keeping_dict)",
          "4564:      {",
          "4565:   keeping_dict = FALSE;",
          "4566:   if (generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "4567:       return FAIL;",
          "4568:      }",
          "4569:  }",
          "4570:  else if (**arg == '[')",
          "4571:  {",
          "4572:      int  is_slice = FALSE;",
          "4578:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4579:   return FAIL;",
          "4580:      ppconst->pp_is_const = FALSE;",
          "4582:      ++p;",
          "4583:      if (may_get_next_line_error(p, arg, cctx) == FAIL)",
          "4584:   return FAIL;",
          "4585:      if (**arg == ':')",
          "4586:      {",
          "4588:   generate_PUSHNR(cctx, 0);",
          "4589:      }",
          "4590:      else",
          "4591:      {",
          "4592:   if (compile_expr0(arg, cctx) == FAIL)",
          "4593:       return FAIL;",
          "4594:   if (**arg == ':')",
          "4595:   {",
          "4596:       semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "4597:             \":\", *arg);",
          "4598:       return FAIL;",
          "4599:   }",
          "4600:   if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "4601:       return FAIL;",
          "4603:      }",
          "4604:      if (**arg == ':')",
          "4605:      {",
          "4606:   is_slice = TRUE;",
          "4607:   ++*arg;",
          "4608:   if (!IS_WHITE_OR_NUL(**arg) && **arg != ']')",
          "4609:   {",
          "4610:       semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "4611:             \":\", *arg);",
          "4612:       return FAIL;",
          "4613:   }",
          "4614:   if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "4615:       return FAIL;",
          "4616:   if (**arg == ']')",
          "4618:       generate_PUSHNR(cctx, -1);",
          "4619:   else",
          "4620:   {",
          "4621:       if (compile_expr0(arg, cctx) == FAIL)",
          "4622:    return FAIL;",
          "4623:       if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "4624:    return FAIL;",
          "4626:   }",
          "4627:      }",
          "4629:      if (**arg != ']')",
          "4630:      {",
          "4631:   emsg(_(e_missing_closing_square_brace));",
          "4632:   return FAIL;",
          "4633:      }",
          "4636:      if (keeping_dict)",
          "4637:      {",
          "4638:   keeping_dict = FALSE;",
          "4639:   if (generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "4640:       return FAIL;",
          "4641:      }",
          "4642:      if (compile_member(is_slice, &keeping_dict, cctx) == FAIL)",
          "4643:   return FAIL;",
          "4644:  }",
          "4645:  else if (*p == '.' && p[1] != '.')",
          "4646:  {",
          "4648:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4649:   return FAIL;",
          "4650:      ppconst->pp_is_const = FALSE;",
          "4653:      if (IS_WHITE_OR_NUL(**arg))",
          "4654:      {",
          "4655:   emsg(_(e_missing_name_after_dot));",
          "4656:   return FAIL;",
          "4657:      }",
          "4658:      p = *arg;",
          "4659:      if (eval_isdictc(*p))",
          "4660:   while (eval_isnamec(*p))",
          "4661:       MB_PTR_ADV(p);",
          "4662:      if (p == *arg)",
          "4663:      {",
          "4664:   semsg(_(e_syntax_error_at_str), *arg);",
          "4665:   return FAIL;",
          "4666:      }",
          "4667:      if (keeping_dict && generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "4668:   return FAIL;",
          "4669:      if (generate_STRINGMEMBER(cctx, *arg, p - *arg) == FAIL)",
          "4670:   return FAIL;",
          "4671:      keeping_dict = TRUE;",
          "4673:  }",
          "4674:  else",
          "4675:      break;",
          "4676:     }",
          "4680:     if (keeping_dict && generate_instr(cctx, ISN_USEDICT) == NULL)",
          "4681:  return FAIL;",
          "4683:     return OK;",
          "4684: }",
          "4719:     static int",
          "4720: compile_expr7(",
          "4721:  char_u **arg,",
          "4722:  cctx_T *cctx,",
          "4723:  ppconst_T *ppconst)",
          "4724: {",
          "4725:     char_u *start_leader, *end_leader;",
          "4726:     int  ret = OK;",
          "4727:     typval_T *rettv = &ppconst->pp_tv[ppconst->pp_used];",
          "4728:     int  used_before = ppconst->pp_used;",
          "4730:     ppconst->pp_is_const = FALSE;",
          "4735:     start_leader = *arg;",
          "4736:     if (eval_leader(arg, TRUE) == FAIL)",
          "4737:  return FAIL;",
          "4738:     end_leader = *arg;",
          "4740:     rettv->v_type = VAR_UNKNOWN;",
          "4741:     switch (**arg)",
          "4742:     {",
          "4746:  case '0': // also for blob starting with 0z",
          "4747:  case '1':",
          "4748:  case '2':",
          "4749:  case '3':",
          "4750:  case '4':",
          "4751:  case '5':",
          "4752:  case '6':",
          "4753:  case '7':",
          "4754:  case '8':",
          "4755:  case '9':",
          "4756:  case '.':   if (eval_number(arg, rettv, TRUE, FALSE) == FAIL)",
          "4757:    return FAIL;",
          "4761:       if (apply_leader(rettv, TRUE,",
          "4762:          start_leader, &end_leader) == FAIL)",
          "4763:       {",
          "4764:    clear_tv(rettv);",
          "4765:    return FAIL;",
          "4766:       }",
          "4767:       break;",
          "4772:  case '\"':   if (eval_string(arg, rettv, TRUE) == FAIL)",
          "4773:    return FAIL;",
          "4774:       break;",
          "4779:  case '\\'':  if (eval_lit_string(arg, rettv, TRUE) == FAIL)",
          "4780:    return FAIL;",
          "4781:       break;",
          "4786:  case 'v':   get_vim_constant(arg, rettv);",
          "4787:       ret = NOTDONE;",
          "4788:       break;",
          "4793:  case 't':   if (STRNCMP(*arg, \"true\", 4) == 0",
          "4794:          && !eval_isnamec((*arg)[4]))",
          "4795:       {",
          "4797:    rettv->v_type = VAR_BOOL;",
          "4798:    rettv->vval.v_number = VVAL_TRUE;",
          "4799:       }",
          "4800:       else",
          "4801:    ret = NOTDONE;",
          "4802:       break;",
          "4807:  case 'f':   if (STRNCMP(*arg, \"false\", 5) == 0",
          "4808:          && !eval_isnamec((*arg)[5]))",
          "4809:       {",
          "4811:    rettv->v_type = VAR_BOOL;",
          "4812:    rettv->vval.v_number = VVAL_FALSE;",
          "4813:       }",
          "4814:       else",
          "4815:    ret = NOTDONE;",
          "4816:       break;",
          "4821:  case 'n':   if (STRNCMP(*arg, \"null\", 4) == 0",
          "4822:          && !eval_isnamec((*arg)[4]))",
          "4823:       {",
          "4825:    rettv->v_type = VAR_SPECIAL;",
          "4826:    rettv->vval.v_number = VVAL_NULL;",
          "4827:       }",
          "4828:       else",
          "4829:    ret = NOTDONE;",
          "4830:       break;",
          "4835:  case '[':   if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4836:    return FAIL;",
          "4837:       ret = compile_list(arg, cctx, ppconst);",
          "4838:       break;",
          "4843:  case '{':   if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4844:    return FAIL;",
          "4845:       ret = compile_dict(arg, cctx, ppconst);",
          "4846:       break;",
          "4851:  case '&': if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4852:        return FAIL;",
          "4853:    ret = compile_get_option(arg, cctx);",
          "4854:    break;",
          "4859:  case '$': if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4860:        return FAIL;",
          "4861:    ret = compile_get_env(arg, cctx);",
          "4862:    break;",
          "4867:  case '@': if (generate_ppconst(cctx, ppconst) == FAIL)",
          "4868:        return FAIL;",
          "4869:    ret = compile_get_register(arg, cctx);",
          "4870:    break;",
          "4876:  case '(':   // if compile_lambda returns NOTDONE then it must be (expr)",
          "4877:       ret = compile_lambda(arg, cctx);",
          "4878:       if (ret == NOTDONE)",
          "4879:    ret = compile_parenthesis(arg, cctx, ppconst);",
          "4880:       break;",
          "4882:  default:    ret = NOTDONE;",
          "4883:       break;",
          "4884:     }",
          "4885:     if (ret == FAIL)",
          "4886:  return FAIL;",
          "4888:     if (rettv->v_type != VAR_UNKNOWN && used_before == ppconst->pp_used)",
          "4889:     {",
          "4890:  if (cctx->ctx_skip == SKIP_YES)",
          "4891:      clear_tv(rettv);",
          "4892:  else",
          "4895:      ++ppconst->pp_used;",
          "4896:     }",
          "4897:     else if (ret == NOTDONE)",
          "4898:     {",
          "4899:  char_u     *p;",
          "4900:  int     r;",
          "4902:  if (!eval_isnamec1(**arg))",
          "4903:  {",
          "4904:      if (!vim9_bad_comment(*arg))",
          "4905:      {",
          "4906:   if (ends_excmd(*skipwhite(*arg)))",
          "4907:       semsg(_(e_empty_expression_str), *arg);",
          "4908:   else",
          "4909:       semsg(_(e_name_expected_str), *arg);",
          "4910:      }",
          "4911:      return FAIL;",
          "4912:  }",
          "4915:  p = to_name_end(*arg, TRUE);",
          "4916:  if (p - *arg == (size_t)1 && **arg == '_')",
          "4917:  {",
          "4918:      emsg(_(e_cannot_use_underscore_here));",
          "4919:      return FAIL;",
          "4920:  }",
          "4922:  if (*p == '(')",
          "4923:  {",
          "4924:      r = compile_call(arg, p - *arg, cctx, ppconst, 0);",
          "4925:  }",
          "4926:  else",
          "4927:  {",
          "4928:      if (cctx->ctx_skip != SKIP_YES",
          "4929:         && generate_ppconst(cctx, ppconst) == FAIL)",
          "4930:   return FAIL;",
          "4931:      r = compile_load(arg, p, cctx, TRUE, TRUE);",
          "4932:  }",
          "4933:  if (r == FAIL)",
          "4934:      return FAIL;",
          "4935:     }",
          "4939:     if (compile_subscript(arg, cctx, start_leader, &end_leader,",
          "4940:             ppconst) == FAIL)",
          "4941:  return FAIL;",
          "4942:     if (ppconst->pp_used > 0)",
          "4943:     {",
          "4945:  rettv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "4946:  if (apply_leader(rettv, FALSE, start_leader, &end_leader) == FAIL)",
          "4947:      return FAIL;",
          "4948:  return OK;",
          "4949:     }",
          "4950:     if (compile_leader(cctx, FALSE, start_leader, &end_leader) == FAIL)",
          "4951:  return FAIL;",
          "4952:     return OK;",
          "4953: }",
          "4958:     void",
          "4959: error_white_both(char_u *op, int len)",
          "4960: {",
          "4961:     char_u buf[10];",
          "4963:     vim_strncpy(buf, op, len);",
          "4964:     semsg(_(e_white_space_required_before_and_after_str_at_str), buf, op);",
          "4965: }",
          "4970:     static int",
          "4971: compile_expr7t(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "4972: {",
          "4973:     type_T *want_type = NULL;",
          "4976:     if (**arg == '<' && eval_isnamec1((*arg)[1]))",
          "4977:     {",
          "4978:  ++*arg;",
          "4979:  want_type = parse_type(arg, cctx->ctx_type_list, TRUE);",
          "4980:  if (want_type == NULL)",
          "4981:      return FAIL;",
          "4983:  if (**arg != '>')",
          "4984:  {",
          "4985:      if (*skipwhite(*arg) == '>')",
          "4986:   semsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);",
          "4987:      else",
          "4988:   emsg(_(e_missing_gt));",
          "4989:      return FAIL;",
          "4990:  }",
          "4991:  ++*arg;",
          "4992:  if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "4993:      return FAIL;",
          "4994:     }",
          "4996:     if (compile_expr7(arg, cctx, ppconst) == FAIL)",
          "4997:  return FAIL;",
          "4999:     if (want_type != NULL)",
          "5000:     {",
          "5001:  garray_T    *stack = &cctx->ctx_type_stack;",
          "5002:  type_T     *actual;",
          "5003:  where_T     where = WHERE_INIT;",
          "5005:  generate_ppconst(cctx, ppconst);",
          "5006:  actual = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "5007:  if (check_type(want_type, actual, FALSE, where) == FAIL)",
          "5008:  {",
          "5009:      if (need_type(actual, want_type, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "5010:   return FAIL;",
          "5011:  }",
          "5012:     }",
          "5014:     return OK;",
          "5015: }",
          "5022:     static int",
          "5023: compile_expr6(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "5024: {",
          "5025:     char_u *op;",
          "5026:     char_u *next;",
          "5027:     int  ppconst_used = ppconst->pp_used;",
          "5030:     if (compile_expr7t(arg, cctx, ppconst) == FAIL)",
          "5031:  return FAIL;",
          "5036:     for (;;)",
          "5037:     {",
          "5038:  op = may_peek_next_line(cctx, *arg, &next);",
          "5039:  if (*op != '*' && *op != '/' && *op != '%')",
          "5040:      break;",
          "5041:  if (next != NULL)",
          "5042:  {",
          "5044:      op = skipwhite(*arg);",
          "5045:  }",
          "5047:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[1]))",
          "5048:  {",
          "5049:      error_white_both(op, 1);",
          "5050:      return FAIL;",
          "5051:  }",
          "5052:  if (may_get_next_line_error(op + 1, arg, cctx) == FAIL)",
          "5053:      return FAIL;",
          "5056:  if (compile_expr7t(arg, cctx, ppconst) == FAIL)",
          "5057:      return FAIL;",
          "5059:  if (ppconst->pp_used == ppconst_used + 2",
          "5060:   && ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER",
          "5061:   && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)",
          "5062:  {",
          "5063:      typval_T     *tv1 = &ppconst->pp_tv[ppconst_used];",
          "5064:      typval_T     *tv2 = &ppconst->pp_tv[ppconst_used + 1];",
          "5065:      varnumber_T     res = 0;",
          "5066:      int      failed = FALSE;",
          "5069:      switch (*op)",
          "5070:      {",
          "5071:   case '*': res = tv1->vval.v_number * tv2->vval.v_number;",
          "5072:      break;",
          "5073:   case '/': res = num_divide(tv1->vval.v_number,",
          "5074:         tv2->vval.v_number, &failed);",
          "5075:      break;",
          "5076:   case '%': res = num_modulus(tv1->vval.v_number,",
          "5077:         tv2->vval.v_number, &failed);",
          "5078:      break;",
          "5079:      }",
          "5080:      if (failed)",
          "5081:   return FAIL;",
          "5082:      tv1->vval.v_number = res;",
          "5083:      --ppconst->pp_used;",
          "5084:  }",
          "5085:  else",
          "5086:  {",
          "5087:      generate_ppconst(cctx, ppconst);",
          "5088:      generate_two_op(cctx, op);",
          "5089:  }",
          "5090:     }",
          "5092:     return OK;",
          "5093: }",
          "5100:     static int",
          "5101: compile_expr5(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "5102: {",
          "5103:     char_u *op;",
          "5104:     char_u *next;",
          "5105:     int  oplen;",
          "5106:     int  ppconst_used = ppconst->pp_used;",
          "5109:     if (compile_expr6(arg, cctx, ppconst) == FAIL)",
          "5110:  return FAIL;",
          "5115:     for (;;)",
          "5116:     {",
          "5117:  op = may_peek_next_line(cctx, *arg, &next);",
          "5118:  if (*op != '+' && *op != '-' && !(*op == '.' && *(op + 1) == '.'))",
          "5119:      break;",
          "5120:  if (op[0] == op[1] && *op != '.' && next)",
          "5123:      break;",
          "5124:  oplen = (*op == '.' ? 2 : 1);",
          "5125:  if (next != NULL)",
          "5126:  {",
          "5128:      op = skipwhite(*arg);",
          "5129:  }",
          "5131:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[oplen]))",
          "5132:  {",
          "5133:      error_white_both(op, oplen);",
          "5134:      return FAIL;",
          "5135:  }",
          "5137:  if (may_get_next_line_error(op + oplen, arg, cctx) == FAIL)",
          "5138:      return FAIL;",
          "5141:  if (compile_expr6(arg, cctx, ppconst) == FAIL)",
          "5142:      return FAIL;",
          "5144:  if (ppconst->pp_used == ppconst_used + 2",
          "5145:   && (*op == '.'",
          "5146:       ? (ppconst->pp_tv[ppconst_used].v_type == VAR_STRING",
          "5147:       && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_STRING)",
          "5148:       : (ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER",
          "5149:       && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)))",
          "5150:  {",
          "5151:      typval_T *tv1 = &ppconst->pp_tv[ppconst_used];",
          "5152:      typval_T *tv2 = &ppconst->pp_tv[ppconst_used + 1];",
          "5155:      if (*op == '+')",
          "5156:   tv1->vval.v_number = tv1->vval.v_number + tv2->vval.v_number;",
          "5157:      else if (*op == '-')",
          "5158:   tv1->vval.v_number = tv1->vval.v_number - tv2->vval.v_number;",
          "5159:      else",
          "5160:      {",
          "5162:   char_u *s1 = tv1->vval.v_string;",
          "5163:   char_u *s2 = tv2->vval.v_string;",
          "5164:   size_t len1 = STRLEN(s1);",
          "5166:   tv1->vval.v_string = alloc((int)(len1 + STRLEN(s2) + 1));",
          "5167:   if (tv1->vval.v_string == NULL)",
          "5168:   {",
          "5169:       clear_ppconst(ppconst);",
          "5170:       return FAIL;",
          "5171:   }",
          "5172:   mch_memmove(tv1->vval.v_string, s1, len1);",
          "5173:   STRCPY(tv1->vval.v_string + len1, s2);",
          "5174:   vim_free(s1);",
          "5175:   vim_free(s2);",
          "5176:      }",
          "5177:      --ppconst->pp_used;",
          "5178:  }",
          "5179:  else",
          "5180:  {",
          "5181:      generate_ppconst(cctx, ppconst);",
          "5182:      ppconst->pp_is_const = FALSE;",
          "5183:      if (*op == '.')",
          "5184:      {",
          "5185:   if (may_generate_2STRING(-2, FALSE, cctx) == FAIL",
          "5186:    || may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "5187:       return FAIL;",
          "5188:   generate_instr_drop(cctx, ISN_CONCAT, 1);",
          "5189:      }",
          "5190:      else",
          "5191:   generate_two_op(cctx, op);",
          "5192:  }",
          "5193:     }",
          "5195:     return OK;",
          "5196: }",
          "5215:     static int",
          "5216: compile_expr4(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "5217: {",
          "5218:     exprtype_T type = EXPR_UNKNOWN;",
          "5219:     char_u *p;",
          "5220:     char_u *next;",
          "5221:     int  len = 2;",
          "5222:     int  type_is = FALSE;",
          "5223:     int  ppconst_used = ppconst->pp_used;",
          "5226:     if (compile_expr5(arg, cctx, ppconst) == FAIL)",
          "5227:  return FAIL;",
          "5229:     p = may_peek_next_line(cctx, *arg, &next);",
          "5230:     type = get_compare_type(p, &len, &type_is);",
          "5235:     if (type != EXPR_UNKNOWN)",
          "5236:     {",
          "5237:  int ic = FALSE;  // Default: do not ignore case",
          "5239:  if (next != NULL)",
          "5240:  {",
          "5242:      p = skipwhite(*arg);",
          "5243:  }",
          "5244:  if (type_is && (p[len] == '?' || p[len] == '#'))",
          "5245:  {",
          "5246:      semsg(_(e_invalid_expression_str), *arg);",
          "5247:      return FAIL;",
          "5248:  }",
          "5250:  if (p[len] == '?')",
          "5251:  {",
          "5252:      ic = TRUE;",
          "5253:      ++len;",
          "5254:  }",
          "5256:  else if (p[len] == '#')",
          "5257:      ++len;",
          "5260:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[len]))",
          "5261:  {",
          "5262:      error_white_both(p, len);",
          "5263:      return FAIL;",
          "5264:  }",
          "5267:  if (may_get_next_line_error(p + len, arg, cctx) == FAIL)",
          "5268:      return FAIL;",
          "5270:  if (compile_expr5(arg, cctx, ppconst) == FAIL)",
          "5271:      return FAIL;",
          "5273:  if (ppconst->pp_used == ppconst_used + 2)",
          "5274:  {",
          "5275:      typval_T * tv1 = &ppconst->pp_tv[ppconst->pp_used - 2];",
          "5276:      typval_T *tv2 = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "5277:      int  ret;",
          "5282:      if (check_compare_types(type, tv1, tv2) == FAIL)",
          "5283:   ret = FAIL;",
          "5284:      else",
          "5285:      {",
          "5286:   ret = typval_compare(tv1, tv2, type, ic);",
          "5287:   tv1->v_type = VAR_BOOL;",
          "5288:   tv1->vval.v_number = tv1->vval.v_number",
          "5289:             ? VVAL_TRUE : VVAL_FALSE;",
          "5290:   clear_tv(tv2);",
          "5291:   --ppconst->pp_used;",
          "5292:      }",
          "5293:      return ret;",
          "5294:  }",
          "5296:  generate_ppconst(cctx, ppconst);",
          "5297:  return generate_COMPARE(cctx, type, ic);",
          "5298:     }",
          "5300:     return OK;",
          "5301: }",
          "5303: static int compile_expr3(char_u **arg,  cctx_T *cctx, ppconst_T *ppconst);",
          "5308:     static int",
          "5309: compile_and_or(",
          "5310:  char_u **arg,",
          "5311:  cctx_T *cctx,",
          "5312:  char *op,",
          "5313:  ppconst_T *ppconst,",
          "5314:  int ppconst_used UNUSED)",
          "5315: {",
          "5316:     char_u *next;",
          "5317:     char_u *p = may_peek_next_line(cctx, *arg, &next);",
          "5318:     int  opchar = *op;",
          "5320:     if (p[0] == opchar && p[1] == opchar)",
          "5321:     {",
          "5322:  garray_T *instr = &cctx->ctx_instr;",
          "5323:  garray_T end_ga;",
          "5324:  int  save_skip = cctx->ctx_skip;",
          "5329:  ga_init2(&end_ga, sizeof(int), 10);",
          "5330:  while (p[0] == opchar && p[1] == opchar)",
          "5331:  {",
          "5332:      long start_lnum = SOURCING_LNUM;",
          "5333:      long save_sourcing_lnum;",
          "5334:      int  start_ctx_lnum = cctx->ctx_lnum;",
          "5335:      int  save_lnum;",
          "5336:      int  const_used;",
          "5337:      int  status;",
          "5338:      jumpwhen_T jump_when = opchar == '|'",
          "5339:           ? JUMP_IF_COND_TRUE : JUMP_IF_COND_FALSE;",
          "5341:      if (next != NULL)",
          "5342:      {",
          "5344:   p = skipwhite(*arg);",
          "5345:      }",
          "5347:      if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[2]))",
          "5348:      {",
          "5349:   semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "5350:          op, p);",
          "5351:   ga_clear(&end_ga);",
          "5352:   return FAIL;",
          "5353:      }",
          "5355:      save_sourcing_lnum = SOURCING_LNUM;",
          "5356:      SOURCING_LNUM = start_lnum;",
          "5357:      save_lnum = cctx->ctx_lnum;",
          "5358:      cctx->ctx_lnum = start_ctx_lnum;",
          "5360:      status = check_ppconst_bool(ppconst);",
          "5361:      if (status != FAIL)",
          "5362:      {",
          "5364:   if (ppconst->pp_used > 0)",
          "5365:   {",
          "5366:       typval_T *tv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "5367:       int  is_true = tv2bool(tv);",
          "5369:       if ((is_true && opchar == '|')",
          "5370:       || (!is_true && opchar == '&'))",
          "5371:       {",
          "5374:    cctx->ctx_skip = SKIP_YES;",
          "5375:    clear_tv(tv);",
          "5376:    tv->v_type = VAR_BOOL;",
          "5377:    tv->vval.v_number = is_true ? VVAL_TRUE : VVAL_FALSE;",
          "5378:       }",
          "5379:       else",
          "5380:       {",
          "5383:    --ppconst->pp_used;",
          "5384:    jump_when = JUMP_NEVER;",
          "5385:       }",
          "5386:   }",
          "5387:   else",
          "5388:   {",
          "5390:       status = bool_on_stack(cctx);",
          "5391:   }",
          "5392:      }",
          "5393:      if (status != FAIL)",
          "5394:   status = ga_grow(&end_ga, 1);",
          "5395:      cctx->ctx_lnum = save_lnum;",
          "5396:      if (status == FAIL)",
          "5397:      {",
          "5398:   ga_clear(&end_ga);",
          "5399:   return FAIL;",
          "5400:      }",
          "5402:      if (jump_when != JUMP_NEVER)",
          "5403:      {",
          "5404:   if (cctx->ctx_skip != SKIP_YES)",
          "5405:   {",
          "5407:       ++end_ga.ga_len;",
          "5408:   }",
          "5409:   generate_JUMP(cctx, jump_when, 0);",
          "5410:      }",
          "5413:      SOURCING_LNUM = save_sourcing_lnum;",
          "5414:      if (may_get_next_line_error(p + 2, arg, cctx) == FAIL)",
          "5415:      {",
          "5416:   ga_clear(&end_ga);",
          "5417:   return FAIL;",
          "5418:      }",
          "5420:      const_used = ppconst->pp_used;",
          "5421:      if ((opchar == '|' ? compile_expr3(arg, cctx, ppconst)",
          "5422:       : compile_expr4(arg, cctx, ppconst)) == FAIL)",
          "5423:      {",
          "5424:   ga_clear(&end_ga);",
          "5425:   return FAIL;",
          "5426:      }",
          "5429:      if (ppconst->pp_used == const_used + 1)",
          "5430:      {",
          "5431:   typval_T *tv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "5433:   if (tv->v_type == VAR_NUMBER",
          "5434:     && (tv->vval.v_number == 1 || tv->vval.v_number == 0))",
          "5435:   {",
          "5436:       tv->vval.v_number = tv->vval.v_number == 1",
          "5437:             ? VVAL_TRUE : VVAL_FALSE;",
          "5438:       tv->v_type = VAR_BOOL;",
          "5439:   }",
          "5440:      }",
          "5442:      p = may_peek_next_line(cctx, *arg, &next);",
          "5443:  }",
          "5445:  if (check_ppconst_bool(ppconst) == FAIL)",
          "5446:  {",
          "5447:      ga_clear(&end_ga);",
          "5448:      return FAIL;",
          "5449:  }",
          "5451:  if (cctx->ctx_skip != SKIP_YES && ppconst->pp_used == 0)",
          "5453:      if (bool_on_stack(cctx) == FAIL)",
          "5454:      {",
          "5455:   ga_clear(&end_ga);",
          "5456:   return FAIL;",
          "5457:      }",
          "5459:  if (end_ga.ga_len > 0)",
          "5460:  {",
          "5462:      generate_ppconst(cctx, ppconst);",
          "5463:      while (end_ga.ga_len > 0)",
          "5464:      {",
          "5465:   isn_T *isn;",
          "5467:   --end_ga.ga_len;",
          "5468:   isn = ((isn_T *)instr->ga_data)",
          "5469:       + *(((int *)end_ga.ga_data) + end_ga.ga_len);",
          "5470:   isn->isn_arg.jump.jump_where = instr->ga_len;",
          "5471:      }",
          "5472:  }",
          "5473:  ga_clear(&end_ga);",
          "5475:  cctx->ctx_skip = save_skip;",
          "5476:     }",
          "5478:     return OK;",
          "5479: }",
          "5493:     static int",
          "5494: compile_expr3(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "5495: {",
          "5496:     int  ppconst_used = ppconst->pp_used;",
          "5499:     if (compile_expr4(arg, cctx, ppconst) == FAIL)",
          "5500:  return FAIL;",
          "5503:     return compile_and_or(arg, cctx, \"&&\", ppconst, ppconst_used);",
          "5504: }",
          "5518:     static int",
          "5519: compile_expr2(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "5520: {",
          "5521:     int  ppconst_used = ppconst->pp_used;",
          "5524:     if (compile_expr3(arg, cctx, ppconst) == FAIL)",
          "5525:  return FAIL;",
          "5528:     return compile_and_or(arg, cctx, \"||\", ppconst, ppconst_used);",
          "5529: }",
          "5548:     static int",
          "5549: compile_expr1(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "5550: {",
          "5551:     char_u *p;",
          "5552:     int  ppconst_used = ppconst->pp_used;",
          "5553:     char_u *next;",
          "5556:     if (cctx->ctx_skip == SKIP_YES)",
          "5557:     {",
          "5558:  skip_expr_cctx(arg, cctx);",
          "5559:  return OK;",
          "5560:     }",
          "5563:     if (compile_expr2(arg, cctx, ppconst) == FAIL)",
          "5564:  return FAIL;",
          "5566:     p = may_peek_next_line(cctx, *arg, &next);",
          "5567:     if (*p == '?')",
          "5568:     {",
          "5569:  int  op_falsy = p[1] == '?';",
          "5570:  garray_T *instr = &cctx->ctx_instr;",
          "5571:  garray_T *stack = &cctx->ctx_type_stack;",
          "5572:  int  alt_idx = instr->ga_len;",
          "5573:  int  end_idx = 0;",
          "5574:  isn_T  *isn;",
          "5575:  type_T  *type1 = NULL;",
          "5576:  int  has_const_expr = FALSE;",
          "5577:  int  const_value = FALSE;",
          "5578:  int  save_skip = cctx->ctx_skip;",
          "5580:  if (next != NULL)",
          "5581:  {",
          "5583:      p = skipwhite(*arg);",
          "5584:  }",
          "5586:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1 + op_falsy]))",
          "5587:  {",
          "5588:      semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "5589:            op_falsy ? \"??\" : \"?\", p);",
          "5590:      return FAIL;",
          "5591:  }",
          "5593:  if (ppconst->pp_used == ppconst_used + 1)",
          "5594:  {",
          "5597:      has_const_expr = TRUE;",
          "5598:      if (op_falsy)",
          "5599:   const_value = tv2bool(&ppconst->pp_tv[ppconst_used]);",
          "5600:      else",
          "5601:      {",
          "5602:   int error = FALSE;",
          "5604:   const_value = tv_get_bool_chk(&ppconst->pp_tv[ppconst_used],",
          "5605:                &error);",
          "5606:   if (error)",
          "5607:       return FAIL;",
          "5608:      }",
          "5609:      cctx->ctx_skip = save_skip == SKIP_YES ||",
          "5610:    (op_falsy ? const_value : !const_value) ? SKIP_YES : SKIP_NOT;",
          "5612:      if (op_falsy && cctx->ctx_skip == SKIP_YES)",
          "5614:   generate_ppconst(cctx, ppconst);",
          "5615:      else",
          "5616:      {",
          "5617:   clear_tv(&ppconst->pp_tv[ppconst_used]);",
          "5618:   --ppconst->pp_used;",
          "5619:      }",
          "5620:  }",
          "5621:  else",
          "5622:  {",
          "5623:      generate_ppconst(cctx, ppconst);",
          "5624:      if (op_falsy)",
          "5625:   end_idx = instr->ga_len;",
          "5626:      generate_JUMP(cctx, op_falsy",
          "5627:        ? JUMP_AND_KEEP_IF_TRUE : JUMP_IF_FALSE, 0);",
          "5628:      if (op_falsy)",
          "5629:   type1 = ((type_T **)stack->ga_data)[stack->ga_len];",
          "5630:  }",
          "5633:  if (may_get_next_line_error(p + 1 + op_falsy, arg, cctx) == FAIL)",
          "5634:      return FAIL;",
          "5635:  if (compile_expr1(arg, cctx, ppconst) == FAIL)",
          "5636:      return FAIL;",
          "5638:  if (!has_const_expr)",
          "5639:  {",
          "5640:      generate_ppconst(cctx, ppconst);",
          "5642:      if (!op_falsy)",
          "5643:      {",
          "5645:   --stack->ga_len;",
          "5646:   type1 = ((type_T **)stack->ga_data)[stack->ga_len];",
          "5648:   end_idx = instr->ga_len;",
          "5649:   generate_JUMP(cctx, JUMP_ALWAYS, 0);",
          "5652:   isn = ((isn_T *)instr->ga_data) + alt_idx;",
          "5653:   isn->isn_arg.jump.jump_where = instr->ga_len;",
          "5654:      }",
          "5655:  }",
          "5657:  if (!op_falsy)",
          "5658:  {",
          "5660:      p = may_peek_next_line(cctx, *arg, &next);",
          "5661:      if (*p != ':')",
          "5662:      {",
          "5663:   emsg(_(e_missing_colon_after_questionmark));",
          "5664:   return FAIL;",
          "5665:      }",
          "5666:      if (next != NULL)",
          "5667:      {",
          "5669:   p = skipwhite(*arg);",
          "5670:      }",
          "5672:      if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1]))",
          "5673:      {",
          "5674:   semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "5675:                \":\", p);",
          "5676:   return FAIL;",
          "5677:      }",
          "5680:      if (has_const_expr)",
          "5681:   cctx->ctx_skip = save_skip == SKIP_YES || const_value",
          "5682:         ? SKIP_YES : SKIP_NOT;",
          "5683:      if (may_get_next_line_error(p + 1, arg, cctx) == FAIL)",
          "5684:   return FAIL;",
          "5685:      if (compile_expr1(arg, cctx, ppconst) == FAIL)",
          "5686:   return FAIL;",
          "5687:  }",
          "5689:  if (!has_const_expr)",
          "5690:  {",
          "5691:      type_T **typep;",
          "5693:      generate_ppconst(cctx, ppconst);",
          "5696:      typep = ((type_T **)stack->ga_data) + stack->ga_len - 1;",
          "5697:      common_type(type1, *typep, typep, cctx->ctx_type_list);",
          "5700:      isn = ((isn_T *)instr->ga_data) + end_idx;",
          "5701:      isn->isn_arg.jump.jump_where = instr->ga_len;",
          "5702:  }",
          "5704:  cctx->ctx_skip = save_skip;",
          "5705:     }",
          "5706:     return OK;",
          "5707: }",
          "5714:     static int",
          "5715: compile_expr0_ext(char_u **arg,  cctx_T *cctx, int *is_const)",
          "5716: {",
          "5717:     ppconst_T ppconst;",
          "5719:     CLEAR_FIELD(ppconst);",
          "5720:     if (compile_expr1(arg, cctx, &ppconst) == FAIL)",
          "5721:     {",
          "5722:  clear_ppconst(&ppconst);",
          "5723:  return FAIL;",
          "5724:     }",
          "5725:     if (is_const != NULL)",
          "5727:     if (generate_ppconst(cctx, &ppconst) == FAIL)",
          "5728:  return FAIL;",
          "5729:     return OK;",
          "5730: }",
          "5735:     static int",
          "5736: compile_expr0(char_u **arg,  cctx_T *cctx)",
          "5737: {",
          "5738:     return compile_expr0_ext(arg, cctx, NULL);",
          "5739: }",
          "5745:     static char_u *",
          "5746: compile_return(char_u *arg, int check_return_type, int legacy, cctx_T *cctx)",
          "5747: {",
          "5748:     char_u *p = arg;",
          "5749:     garray_T *stack = &cctx->ctx_type_stack;",
          "5750:     type_T *stack_type;",
          "5752:     if (*p != NUL && *p != '|' && *p != '\\n')",
          "5753:     {",
          "5754:  if (legacy)",
          "5755:  {",
          "5756:      int save_flags = cmdmod.cmod_flags;",
          "5758:      generate_LEGACY_EVAL(cctx, p);",
          "5759:      if (need_type(&t_any, cctx->ctx_ufunc->uf_ret_type, -1,",
          "5760:       0, cctx, FALSE, FALSE) == FAIL)",
          "5761:   return NULL;",
          "5762:      cmdmod.cmod_flags |= CMOD_LEGACY;",
          "5763:      (void)skip_expr(&p, NULL);",
          "5764:      cmdmod.cmod_flags = save_flags;",
          "5765:  }",
          "5766:  else",
          "5767:  {",
          "5769:      if (compile_expr0(&p, cctx) == FAIL)",
          "5770:   return NULL;",
          "5771:  }",
          "5773:  if (cctx->ctx_skip != SKIP_YES)",
          "5774:  {",
          "5778:      stack_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "5779:      if ((check_return_type && (cctx->ctx_ufunc->uf_ret_type == NULL",
          "5780:     || cctx->ctx_ufunc->uf_ret_type == &t_unknown",
          "5781:     || cctx->ctx_ufunc->uf_ret_type == &t_any))",
          "5782:       || (!check_return_type",
          "5783:     && cctx->ctx_ufunc->uf_ret_type == &t_unknown))",
          "5784:      {",
          "5785:   cctx->ctx_ufunc->uf_ret_type = stack_type;",
          "5786:      }",
          "5787:      else",
          "5788:      {",
          "5789:   if (cctx->ctx_ufunc->uf_ret_type->tt_type == VAR_VOID",
          "5790:    && stack_type->tt_type != VAR_VOID",
          "5791:    && stack_type->tt_type != VAR_UNKNOWN)",
          "5792:   {",
          "5793:       emsg(_(e_returning_value_in_function_without_return_type));",
          "5794:       return NULL;",
          "5795:   }",
          "5796:   if (need_type(stack_type, cctx->ctx_ufunc->uf_ret_type, -1,",
          "5797:       0, cctx, FALSE, FALSE) == FAIL)",
          "5798:       return NULL;",
          "5799:      }",
          "5800:  }",
          "5801:     }",
          "5802:     else",
          "5803:     {",
          "5806:  if (cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_VOID",
          "5807:   && cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_UNKNOWN)",
          "5808:  {",
          "5809:      emsg(_(e_missing_return_value));",
          "5810:      return NULL;",
          "5811:  }",
          "5814:  generate_PUSHNR(cctx, 0);",
          "5815:     }",
          "5818:     generate_undo_cmdmods(cctx);",
          "5820:     if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_RETURN) == NULL)",
          "5821:  return NULL;",
          "5824:     return skipwhite(p);",
          "5825: }",
          "5832:     static char_u *",
          "5833: exarg_getline(",
          "5834:  int c UNUSED,",
          "5835:  void *cookie,",
          "5836:  int indent UNUSED,",
          "5837:  getline_opt_T options UNUSED)",
          "5838: {",
          "5839:     cctx_T  *cctx = (cctx_T *)cookie;",
          "5840:     char_u  *p;",
          "5842:     for (;;)",
          "5843:     {",
          "5844:  if (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)",
          "5845:      return NULL;",
          "5846:  ++cctx->ctx_lnum;",
          "5847:  p = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];",
          "5849:  if (p != NULL)",
          "5850:      return vim_strsave(p);",
          "5851:     }",
          "5852: }",
          "5854:     void",
          "5855: fill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)",
          "5856: {",
          "5857:     eap->getline = exarg_getline;",
          "5858:     eap->cookie = cctx;",
          "5859: }",
          "5864:     static char_u *",
          "5865: compile_nested_function(exarg_T *eap, cctx_T *cctx)",
          "5866: {",
          "5867:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
          "5868:     char_u *name_start = eap->arg;",
          "5869:     char_u *name_end = to_name_end(eap->arg, TRUE);",
          "5870:     char_u *lambda_name;",
          "5871:     ufunc_T *ufunc;",
          "5872:     int  r = FAIL;",
          "5873:     compiletype_T   compile_type;",
          "5875:     if (eap->forceit)",
          "5876:     {",
          "5877:  emsg(_(e_cannot_use_bang_with_nested_def));",
          "5878:  return NULL;",
          "5879:     }",
          "5881:     if (*name_start == '/')",
          "5882:     {",
          "5883:  name_end = skip_regexp(name_start + 1, '/', TRUE);",
          "5884:  if (*name_end == '/')",
          "5885:      ++name_end;",
          "5886:  set_nextcmd(eap, name_end);",
          "5887:     }",
          "5888:     if (name_end == name_start || *skipwhite(name_end) != '(')",
          "5889:     {",
          "5890:  if (!ends_excmd2(name_start, name_end))",
          "5891:  {",
          "5892:      semsg(_(e_invalid_command_str), eap->cmd);",
          "5893:      return NULL;",
          "5894:  }",
          "5897:  if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)",
          "5898:      return NULL;",
          "5899:  return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;",
          "5900:     }",
          "5903:     if (name_start[1] == ':' && !is_global)",
          "5904:     {",
          "5905:  semsg(_(e_namespace_not_supported_str), name_start);",
          "5906:  return NULL;",
          "5907:     }",
          "5908:     if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)",
          "5909:  return NULL;",
          "5911:     eap->arg = name_end;",
          "5912:     fill_exarg_from_cctx(eap, cctx);",
          "5914:     eap->forceit = FALSE;",
          "5916:     lambda_name = vim_strsave(get_lambda_name());",
          "5917:     if (lambda_name == NULL)",
          "5918:  return NULL;",
          "5919:     ufunc = define_function(eap, lambda_name);",
          "5921:     if (ufunc == NULL)",
          "5922:     {",
          "5923:  r = eap->skip ? OK : FAIL;",
          "5924:  goto theend;",
          "5925:     }",
          "5928:     if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)",
          "5929:     {",
          "5930:  int block_depth = cctx->ctx_ufunc->uf_block_depth;",
          "5932:  ufunc->uf_block_ids = ALLOC_MULT(int, block_depth);",
          "5933:  if (ufunc->uf_block_ids != NULL)",
          "5934:  {",
          "5935:      mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,",
          "5936:           sizeof(int) * block_depth);",
          "5937:      ufunc->uf_block_depth = block_depth;",
          "5938:  }",
          "5939:     }",
          "5941:     compile_type = COMPILE_TYPE(ufunc);",
          "5942: #ifdef FEAT_PROFILE",
          "5945:     if (cctx->ctx_compile_type == CT_PROFILE)",
          "5946:  compile_type = CT_PROFILE;",
          "5947: #endif",
          "5948:     if (func_needs_compiling(ufunc, compile_type)",
          "5949:      && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)",
          "5950:     {",
          "5951:  func_ptr_unref(ufunc);",
          "5952:  goto theend;",
          "5953:     }",
          "5955: #ifdef FEAT_PROFILE",
          "5958:     if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))",
          "5959:  compile_def_function(ufunc, FALSE, CT_NONE, cctx);",
          "5960: #endif",
          "5962:     if (is_global)",
          "5963:     {",
          "5964:  char_u *func_name = vim_strnsave(name_start + 2,",
          "5965:           name_end - name_start - 2);",
          "5967:  if (func_name == NULL)",
          "5968:      r = FAIL;",
          "5969:  else",
          "5970:  {",
          "5971:      r = generate_NEWFUNC(cctx, lambda_name, func_name);",
          "5972:      lambda_name = NULL;",
          "5973:  }",
          "5974:     }",
          "5975:     else",
          "5976:     {",
          "5978:  lvar_T *lvar = reserve_local(cctx, name_start, name_end - name_start,",
          "5979:           TRUE, ufunc->uf_func_type);",
          "5981:  if (lvar == NULL)",
          "5982:      goto theend;",
          "5983:  if (generate_FUNCREF(cctx, ufunc) == FAIL)",
          "5984:      goto theend;",
          "5985:  r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);",
          "5986:     }",
          "5988: theend:",
          "5989:     vim_free(lambda_name);",
          "5990:     return r == FAIL ? NULL : (char_u *)\"\";",
          "5991: }",
          "5996:     int",
          "5997: assignment_len(char_u *p, int *heredoc)",
          "5998: {",
          "5999:     if (*p == '=')",
          "6000:     {",
          "6001:  if (p[1] == '<' && p[2] == '<')",
          "6002:  {",
          "6004:      return 3;",
          "6005:  }",
          "6006:  return 1;",
          "6007:     }",
          "6008:     if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')",
          "6009:  return 2;",
          "6010:     if (STRNCMP(p, \"..=\", 3) == 0)",
          "6011:  return 3;",
          "6012:     return 0;",
          "6013: }",
          "6018:     static void",
          "6019: generate_loadvar(",
          "6020:  cctx_T  *cctx,",
          "6021:  assign_dest_T dest,",
          "6022:  char_u  *name,",
          "6023:  lvar_T  *lvar,",
          "6024:  type_T  *type)",
          "6025: {",
          "6026:     switch (dest)",
          "6027:     {",
          "6028:  case dest_option:",
          "6029:  case dest_func_option:",
          "6030:      generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);",
          "6031:      break;",
          "6032:  case dest_global:",
          "6033:      if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)",
          "6034:   generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);",
          "6035:      else",
          "6036:   generate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);",
          "6037:      break;",
          "6038:  case dest_buffer:",
          "6039:      generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);",
          "6040:      break;",
          "6041:  case dest_window:",
          "6042:      generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);",
          "6043:      break;",
          "6044:  case dest_tab:",
          "6045:      generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);",
          "6046:      break;",
          "6047:  case dest_script:",
          "6048:      compile_load_scriptvar(cctx,",
          "6049:       name + (name[1] == ':' ? 2 : 0), NULL, NULL, TRUE);",
          "6050:      break;",
          "6051:  case dest_env:",
          "6053:      generate_LOAD(cctx, ISN_LOADENV, 0, name, type);",
          "6054:      break;",
          "6055:  case dest_reg:",
          "6056:      generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);",
          "6057:      break;",
          "6058:  case dest_vimvar:",
          "6059:      generate_LOADV(cctx, name + 2, TRUE);",
          "6060:      break;",
          "6061:  case dest_local:",
          "6062:      if (lvar->lv_from_outer > 0)",
          "6063:   generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,",
          "6064:           type);",
          "6065:      else",
          "6066:   generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);",
          "6067:      break;",
          "6068:  case dest_expr:",
          "6070:      break;",
          "6071:     }",
          "6072: }",
          "6078:     static char_u *",
          "6079: skip_index(char_u *start)",
          "6080: {",
          "6081:     char_u *p = start;",
          "6083:     if (*p == '[')",
          "6084:     {",
          "6085:  p = skipwhite(p + 1);",
          "6086:  (void)skip_expr(&p, NULL);",
          "6087:  p = skipwhite(p);",
          "6088:  if (*p == ']')",
          "6089:      return p + 1;",
          "6090:  return p;",
          "6091:     }",
          "6093:     return to_name_end(p + 1, TRUE);",
          "6094: }",
          "6096:     void",
          "6097: vim9_declare_error(char_u *name)",
          "6098: {",
          "6099:     char *scope = \"\";",
          "6101:     switch (*name)",
          "6102:     {",
          "6103:  case 'g': scope = _(\"global\"); break;",
          "6104:  case 'b': scope = _(\"buffer\"); break;",
          "6105:  case 'w': scope = _(\"window\"); break;",
          "6106:  case 't': scope = _(\"tab\"); break;",
          "6107:  case 'v': scope = \"v:\"; break;",
          "6108:  case '$': semsg(_(e_cannot_declare_an_environment_variable), name);",
          "6109:     return;",
          "6110:  case '&': semsg(_(e_cannot_declare_an_option), name);",
          "6111:     return;",
          "6112:  case '@': semsg(_(e_cannot_declare_a_register_str), name);",
          "6113:     return;",
          "6114:  default: return;",
          "6115:     }",
          "6116:     semsg(_(e_cannot_declare_a_scope_variable), scope, name);",
          "6117: }",
          "6127:     static int",
          "6128: get_var_dest(",
          "6129:  char_u  *name,",
          "6130:  assign_dest_T *dest,",
          "6131:  int  cmdidx,",
          "6132:  int  *option_scope,",
          "6133:  int  *vimvaridx,",
          "6134:  type_T  **type,",
          "6135:  cctx_T  *cctx)",
          "6136: {",
          "6137:     char_u *p;",
          "6139:     if (*name == '&')",
          "6140:     {",
          "6141:  int  cc;",
          "6142:  long  numval;",
          "6143:  getoption_T opt_type;",
          "6144:  int  opt_p_flags;",
          "6147:  if (cmdidx == CMD_final || cmdidx == CMD_const)",
          "6148:  {",
          "6149:      emsg(_(e_const_option));",
          "6150:      return FAIL;",
          "6151:  }",
          "6152:  p = name;",
          "6153:  p = find_option_end(&p, option_scope);",
          "6154:  if (p == NULL)",
          "6155:  {",
          "6157:      emsg(_(e_unexpected_characters_in_assignment));",
          "6158:      return FAIL;",
          "6159:  }",
          "6160:  cc = *p;",
          "6162:  opt_type = get_option_value(skip_option_env_lead(name),",
          "6163:        &numval, NULL, &opt_p_flags, *option_scope);",
          "6165:  switch (opt_type)",
          "6166:  {",
          "6167:      case gov_unknown:",
          "6168:       semsg(_(e_unknown_option_str), name);",
          "6169:       return FAIL;",
          "6170:      case gov_string:",
          "6171:      case gov_hidden_string:",
          "6172:       if (opt_p_flags & P_FUNC)",
          "6173:       {",
          "6177:       }",
          "6178:       else",
          "6179:       {",
          "6181:       }",
          "6182:       break;",
          "6183:      case gov_bool:",
          "6184:      case gov_hidden_bool:",
          "6186:       break;",
          "6187:      case gov_number:",
          "6188:      case gov_hidden_number:",
          "6190:       break;",
          "6191:  }",
          "6192:     }",
          "6193:     else if (*name == '$')",
          "6194:     {",
          "6197:     }",
          "6198:     else if (*name == '@')",
          "6199:     {",
          "6200:  if (name[1] != '@'",
          "6201:    && (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))",
          "6202:  {",
          "6203:      emsg_invreg(name[1]);",
          "6204:      return FAIL;",
          "6205:  }",
          "6208:     }",
          "6209:     else if (STRNCMP(name, \"g:\", 2) == 0)",
          "6210:     {",
          "6212:     }",
          "6213:     else if (STRNCMP(name, \"b:\", 2) == 0)",
          "6214:     {",
          "6216:     }",
          "6217:     else if (STRNCMP(name, \"w:\", 2) == 0)",
          "6218:     {",
          "6220:     }",
          "6221:     else if (STRNCMP(name, \"t:\", 2) == 0)",
          "6222:     {",
          "6224:     }",
          "6225:     else if (STRNCMP(name, \"v:\", 2) == 0)",
          "6226:     {",
          "6227:  typval_T *vtv;",
          "6228:  int  di_flags;",
          "6231:  if (*vimvaridx < 0)",
          "6232:  {",
          "6233:      semsg(_(e_variable_not_found_str), name);",
          "6234:      return FAIL;",
          "6235:  }",
          "6237:  if (var_check_ro(di_flags, name, FALSE))",
          "6238:      return FAIL;",
          "6240:  vtv = get_vim_var_tv(*vimvaridx);",
          "6242:     }",
          "6243:     return OK;",
          "6244: }",
          "6250:     static int",
          "6251: generate_store_var(",
          "6252:  cctx_T  *cctx,",
          "6253:  assign_dest_T dest,",
          "6254:  int  opt_flags,",
          "6255:  int  vimvaridx,",
          "6256:  int  scriptvar_idx,",
          "6257:  int  scriptvar_sid,",
          "6258:  type_T  *type,",
          "6259:  char_u  *name)",
          "6260: {",
          "6261:     switch (dest)",
          "6262:     {",
          "6263:  case dest_option:",
          "6264:      return generate_STOREOPT(cctx, ISN_STOREOPT,",
          "6265:      skip_option_env_lead(name), opt_flags);",
          "6266:  case dest_func_option:",
          "6267:      return generate_STOREOPT(cctx, ISN_STOREFUNCOPT,",
          "6268:      skip_option_env_lead(name), opt_flags);",
          "6269:  case dest_global:",
          "6271:      return generate_STORE(cctx, vim_strchr(name, AUTOLOAD_CHAR) == NULL",
          "6272:      ? ISN_STOREG : ISN_STOREAUTO, 0, name);",
          "6273:  case dest_buffer:",
          "6275:      return generate_STORE(cctx, ISN_STOREB, 0, name);",
          "6276:  case dest_window:",
          "6278:      return generate_STORE(cctx, ISN_STOREW, 0, name);",
          "6279:  case dest_tab:",
          "6281:      return generate_STORE(cctx, ISN_STORET, 0, name);",
          "6282:  case dest_env:",
          "6283:      return generate_STORE(cctx, ISN_STOREENV, 0, name + 1);",
          "6284:  case dest_reg:",
          "6285:      return generate_STORE(cctx, ISN_STOREREG,",
          "6286:       name[1] == '@' ? '\"' : name[1], NULL);",
          "6287:  case dest_vimvar:",
          "6288:      return generate_STORE(cctx, ISN_STOREV, vimvaridx, NULL);",
          "6289:  case dest_script:",
          "6290:      if (scriptvar_idx < 0)",
          "6292:   return generate_OLDSCRIPT(cctx, ISN_STORES, name,",
          "6293:          scriptvar_sid, type);",
          "6294:      return generate_VIM9SCRIPT(cctx, ISN_STORESCRIPT,",
          "6295:         scriptvar_sid, scriptvar_idx, type);",
          "6296:  case dest_local:",
          "6297:  case dest_expr:",
          "6299:      break;",
          "6300:     }",
          "6301:     return FAIL;",
          "6302: }",
          "6304:     static int",
          "6305: generate_store_lhs(cctx_T *cctx, lhs_T *lhs, int instr_count)",
          "6306: {",
          "6307:     if (lhs->lhs_dest != dest_local)",
          "6308:  return generate_store_var(cctx, lhs->lhs_dest,",
          "6309:        lhs->lhs_opt_flags, lhs->lhs_vimvaridx,",
          "6310:        lhs->lhs_scriptvar_idx, lhs->lhs_scriptvar_sid,",
          "6311:        lhs->lhs_type, lhs->lhs_name);",
          "6313:     if (lhs->lhs_lvar != NULL)",
          "6314:     {",
          "6315:  garray_T *instr = &cctx->ctx_instr;",
          "6316:  isn_T  *isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "6320:  if (lhs->lhs_lvar->lv_from_outer == 0",
          "6321:   && instr->ga_len == instr_count + 1",
          "6322:   && isn->isn_type == ISN_PUSHNR)",
          "6323:  {",
          "6324:      varnumber_T val = isn->isn_arg.number;",
          "6325:      garray_T    *stack = &cctx->ctx_type_stack;",
          "6327:      isn->isn_type = ISN_STORENR;",
          "6328:      isn->isn_arg.storenr.stnr_idx = lhs->lhs_lvar->lv_idx;",
          "6329:      isn->isn_arg.storenr.stnr_val = val;",
          "6330:      if (stack->ga_len > 0)",
          "6331:   --stack->ga_len;",
          "6332:  }",
          "6333:  else if (lhs->lhs_lvar->lv_from_outer > 0)",
          "6334:      generate_STOREOUTER(cctx, lhs->lhs_lvar->lv_idx,",
          "6335:        lhs->lhs_lvar->lv_from_outer);",
          "6336:  else",
          "6337:      generate_STORE(cctx, ISN_STORE, lhs->lhs_lvar->lv_idx, NULL);",
          "6338:     }",
          "6339:     return OK;",
          "6340: }",
          "6342:     static int",
          "6343: is_decl_command(int cmdidx)",
          "6344: {",
          "6345:     return cmdidx == CMD_let || cmdidx == CMD_var",
          "6346:      || cmdidx == CMD_final || cmdidx == CMD_const;",
          "6347: }",
          "6354:     static int",
          "6355: compile_lhs(",
          "6356:  char_u *var_start,",
          "6357:  lhs_T *lhs,",
          "6358:  int cmdidx,",
          "6359:  int heredoc,",
          "6360:  int oplen,",
          "6361:  cctx_T *cctx)",
          "6362: {",
          "6363:     char_u *var_end;",
          "6364:     int  is_decl = is_decl_command(cmdidx);",
          "6366:     CLEAR_POINTER(lhs);",
          "6367:     lhs->lhs_dest = dest_local;",
          "6368:     lhs->lhs_vimvaridx = -1;",
          "6369:     lhs->lhs_scriptvar_idx = -1;",
          "6374:     lhs->lhs_dest_end = skip_var_one(var_start, FALSE);",
          "6375:     if (*var_start == '@')",
          "6376:  var_end = var_start + 2;",
          "6377:     else",
          "6378:     {",
          "6380:  var_end = skip_option_env_lead(var_start);",
          "6381:  var_end = to_name_end(var_end, TRUE);",
          "6382:     }",
          "6385:     if (is_decl && lhs->lhs_dest_end == var_start + 2",
          "6386:             && lhs->lhs_dest_end[-1] == ':')",
          "6387:  --lhs->lhs_dest_end;",
          "6388:     if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')",
          "6389:  --var_end;",
          "6390:     lhs->lhs_end = lhs->lhs_dest_end;",
          "6393:     lhs->lhs_varlen = var_end - var_start;",
          "6394:     lhs->lhs_varlen_total = lhs->lhs_varlen;",
          "6395:     lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);",
          "6396:     if (lhs->lhs_name == NULL)",
          "6397:  return FAIL;",
          "6399:     if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)",
          "6401:  lhs->lhs_has_index = TRUE;",
          "6403:     if (heredoc)",
          "6404:  lhs->lhs_type = &t_list_string;",
          "6405:     else",
          "6406:  lhs->lhs_type = &t_any;",
          "6408:     if (cctx->ctx_skip != SKIP_YES)",
          "6409:     {",
          "6410:  int     declare_error = FALSE;",
          "6412:  if (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,",
          "6413:           &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,",
          "6414:        &lhs->lhs_type, cctx) == FAIL)",
          "6415:      return FAIL;",
          "6416:  if (lhs->lhs_dest != dest_local",
          "6417:      && cmdidx != CMD_const && cmdidx != CMD_final)",
          "6418:  {",
          "6420:      declare_error = is_decl;",
          "6421:  }",
          "6422:  else",
          "6423:  {",
          "6425:      if (check_reserved_name(lhs->lhs_name) == FAIL)",
          "6426:   return FAIL;",
          "6428:      if (lookup_local(var_start, lhs->lhs_varlen,",
          "6429:           &lhs->lhs_local_lvar, cctx) == OK)",
          "6430:   lhs->lhs_lvar = &lhs->lhs_local_lvar;",
          "6431:      else",
          "6432:      {",
          "6433:   CLEAR_FIELD(lhs->lhs_arg_lvar);",
          "6434:   if (arg_exists(var_start, lhs->lhs_varlen,",
          "6435:     &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,",
          "6436:        &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)",
          "6437:   {",
          "6438:       if (is_decl)",
          "6439:       {",
          "6440:    semsg(_(e_str_is_used_as_argument), lhs->lhs_name);",
          "6441:    return FAIL;",
          "6442:       }",
          "6443:       lhs->lhs_lvar = &lhs->lhs_arg_lvar;",
          "6444:   }",
          "6445:      }",
          "6446:      if (lhs->lhs_lvar != NULL)",
          "6447:      {",
          "6448:   if (is_decl)",
          "6449:   {",
          "6450:       semsg(_(e_variable_already_declared), lhs->lhs_name);",
          "6451:       return FAIL;",
          "6452:   }",
          "6453:      }",
          "6454:      else",
          "6455:      {",
          "6456:   int script_namespace = lhs->lhs_varlen > 1",
          "6457:            && STRNCMP(var_start, \"s:\", 2) == 0;",
          "6458:   int script_var = (script_namespace",
          "6459:    ? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,",
          "6460:            cctx)",
          "6461:      : script_var_exists(var_start, lhs->lhs_varlen,",
          "6462:           cctx)) == OK;",
          "6463:   imported_T  *import =",
          "6464:           find_imported(var_start, lhs->lhs_varlen, cctx);",
          "6466:   if (script_namespace || script_var || import != NULL)",
          "6467:   {",
          "6468:       char_u *rawname = lhs->lhs_name",
          "6469:         + (lhs->lhs_name[1] == ':' ? 2 : 0);",
          "6471:       if (is_decl)",
          "6472:       {",
          "6473:    if (script_namespace)",
          "6474:        semsg(_(e_cannot_declare_script_variable_in_function),",
          "6475:         lhs->lhs_name);",
          "6476:    else",
          "6477:        semsg(_(e_variable_already_declared_in_script_str),",
          "6478:         lhs->lhs_name);",
          "6479:    return FAIL;",
          "6480:       }",
          "6481:       else if (cctx->ctx_ufunc->uf_script_ctx_version",
          "6482:         == SCRIPT_VERSION_VIM9",
          "6483:         && script_namespace",
          "6484:         && !script_var && import == NULL)",
          "6485:       {",
          "6486:    semsg(_(e_unknown_variable_str), lhs->lhs_name);",
          "6487:    return FAIL;",
          "6488:       }",
          "6490:       lhs->lhs_dest = dest_script;",
          "6493:       lhs->lhs_scriptvar_sid = current_sctx.sc_sid;",
          "6494:       if (import != NULL)",
          "6495:    lhs->lhs_scriptvar_sid = import->imp_sid;",
          "6496:       if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))",
          "6497:       {",
          "6499:    lhs->lhs_scriptvar_idx = get_script_item_idx(",
          "6500:             lhs->lhs_scriptvar_sid, rawname,",
          "6501:          lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,",
          "6502:           cctx);",
          "6503:    if (lhs->lhs_scriptvar_idx >= 0)",
          "6504:    {",
          "6505:        scriptitem_T *si = SCRIPT_ITEM(",
          "6506:              lhs->lhs_scriptvar_sid);",
          "6507:        svar_T  *sv =",
          "6508:          ((svar_T *)si->sn_var_vals.ga_data)",
          "6509:             + lhs->lhs_scriptvar_idx;",
          "6510:        lhs->lhs_type = sv->sv_type;",
          "6511:    }",
          "6512:       }",
          "6513:   }",
          "6514:   else if (check_defined(var_start, lhs->lhs_varlen, cctx, FALSE)",
          "6515:                == FAIL)",
          "6516:       return FAIL;",
          "6517:      }",
          "6518:  }",
          "6520:  if (declare_error)",
          "6521:  {",
          "6522:      vim9_declare_error(lhs->lhs_name);",
          "6523:      return FAIL;",
          "6524:  }",
          "6525:     }",
          "6528:     if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')",
          "6529:  var_end = lhs->lhs_dest_end;",
          "6531:     if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)",
          "6532:     {",
          "6533:  if (is_decl && *var_end == ':')",
          "6534:  {",
          "6535:      char_u *p;",
          "6538:      if (!VIM_ISWHITE(var_end[1]))",
          "6539:      {",
          "6540:   semsg(_(e_white_space_required_after_str_str), \":\", var_end);",
          "6541:   return FAIL;",
          "6542:      }",
          "6543:      p = skipwhite(var_end + 1);",
          "6544:      lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);",
          "6545:      if (lhs->lhs_type == NULL)",
          "6546:   return FAIL;",
          "6547:      lhs->lhs_has_type = TRUE;",
          "6548:      lhs->lhs_end = p;",
          "6549:  }",
          "6550:  else if (lhs->lhs_lvar != NULL)",
          "6551:      lhs->lhs_type = lhs->lhs_lvar->lv_type;",
          "6552:     }",
          "6554:     if (oplen == 3 && !heredoc",
          "6555:      && lhs->lhs_dest != dest_global",
          "6556:      && !lhs->lhs_has_index",
          "6557:      && lhs->lhs_type->tt_type != VAR_STRING",
          "6558:      && lhs->lhs_type->tt_type != VAR_ANY)",
          "6559:     {",
          "6560:  emsg(_(e_can_only_concatenate_to_string));",
          "6561:  return FAIL;",
          "6562:     }",
          "6564:     if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local",
          "6565:        && cctx->ctx_skip != SKIP_YES)",
          "6566:     {",
          "6567:  if (oplen > 1 && !heredoc)",
          "6568:  {",
          "6570:      semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);",
          "6571:      return FAIL;",
          "6572:  }",
          "6573:  if (!is_decl)",
          "6574:  {",
          "6575:      semsg(_(e_unknown_variable_str), lhs->lhs_name);",
          "6576:      return FAIL;",
          "6577:  }",
          "6580:  if ((lhs->lhs_type->tt_type == VAR_FUNC",
          "6581:           || lhs->lhs_type->tt_type == VAR_PARTIAL)",
          "6582:   && var_wrong_func_name(lhs->lhs_name, TRUE))",
          "6583:      return FAIL;",
          "6586:  lhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,",
          "6587:       cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);",
          "6588:  if (lhs->lhs_lvar == NULL)",
          "6589:      return FAIL;",
          "6590:  lhs->lhs_new_local = TRUE;",
          "6591:     }",
          "6593:     lhs->lhs_member_type = lhs->lhs_type;",
          "6594:     if (lhs->lhs_has_index)",
          "6595:     {",
          "6596:  char_u *after = var_start + lhs->lhs_varlen;",
          "6597:  char_u *p;",
          "6600:  if (is_decl)",
          "6601:  {",
          "6602:      emsg(_(e_cannot_use_index_when_declaring_variable));",
          "6603:      return FAIL;",
          "6604:  }",
          "6610:  for (;;)",
          "6611:  {",
          "6612:      p = skip_index(after);",
          "6613:      if (*p != '[' && *p != '.')",
          "6614:      {",
          "6615:   lhs->lhs_varlen_total = p - var_start;",
          "6616:   break;",
          "6617:      }",
          "6618:      after = p;",
          "6619:  }",
          "6620:  if (after > var_start + lhs->lhs_varlen)",
          "6621:  {",
          "6622:      lhs->lhs_varlen = after - var_start;",
          "6623:      lhs->lhs_dest = dest_expr;",
          "6626:      lhs->lhs_type = &t_any;",
          "6627:  }",
          "6629:  if (lhs->lhs_type->tt_member == NULL)",
          "6630:      lhs->lhs_member_type = &t_any;",
          "6631:  else",
          "6632:      lhs->lhs_member_type = lhs->lhs_type->tt_member;",
          "6633:     }",
          "6634:     return OK;",
          "6635: }",
          "6640:     static int",
          "6641: compile_assign_lhs(",
          "6642:  char_u *var_start,",
          "6643:  lhs_T *lhs,",
          "6644:  int cmdidx,",
          "6645:  int is_decl,",
          "6646:  int heredoc,",
          "6647:  int oplen,",
          "6648:  cctx_T *cctx)",
          "6649: {",
          "6650:     if (compile_lhs(var_start, lhs, cmdidx, heredoc, oplen, cctx) == FAIL)",
          "6651:  return FAIL;",
          "6653:     if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)",
          "6654:     {",
          "6655:  semsg(_(e_cannot_assign_to_argument), lhs->lhs_name);",
          "6656:  return FAIL;",
          "6657:     }",
          "6658:     if (!is_decl && lhs->lhs_lvar != NULL",
          "6659:       && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)",
          "6660:     {",
          "6661:  semsg(_(e_cannot_assign_to_constant), lhs->lhs_name);",
          "6662:  return FAIL;",
          "6663:     }",
          "6664:     return OK;",
          "6665: }",
          "6670:     static int",
          "6671: has_list_index(char_u *idx_start, cctx_T *cctx)",
          "6672: {",
          "6673:     char_u  *p = idx_start;",
          "6674:     int     save_skip;",
          "6676:     if (*p != '[')",
          "6677:  return FALSE;",
          "6679:     p = skipwhite(p + 1);",
          "6680:     if (*p == ':')",
          "6681:  return TRUE;",
          "6683:     save_skip = cctx->ctx_skip;",
          "6684:     cctx->ctx_skip = SKIP_YES;",
          "6685:     (void)compile_expr0(&p, cctx);",
          "6686:     cctx->ctx_skip = save_skip;",
          "6687:     return *skipwhite(p) == ':';",
          "6688: }",
          "6694:     static int",
          "6695: compile_assign_index(",
          "6696:  char_u *var_start,",
          "6697:  lhs_T *lhs,",
          "6698:  int *range,",
          "6699:  cctx_T *cctx)",
          "6700: {",
          "6701:     size_t varlen = lhs->lhs_varlen;",
          "6702:     char_u *p;",
          "6703:     int  r = OK;",
          "6704:     int  need_white_before = TRUE;",
          "6705:     int  empty_second;",
          "6707:     p = var_start + varlen;",
          "6708:     if (*p == '[')",
          "6709:     {",
          "6710:  p = skipwhite(p + 1);",
          "6711:  if (*p == ':')",
          "6712:  {",
          "6714:      r = generate_PUSHNR(cctx, 0);",
          "6715:      need_white_before = FALSE;",
          "6716:  }",
          "6717:  else",
          "6718:      r = compile_expr0(&p, cctx);",
          "6720:  if (r == OK && *skipwhite(p) == ':')",
          "6721:  {",
          "6725:      p = skipwhite(p);",
          "6726:      empty_second = *skipwhite(p + 1) == ']';",
          "6727:      if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))",
          "6728:       || (!empty_second && !IS_WHITE_OR_NUL(p[1])))",
          "6729:      {",
          "6730:   semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "6731:               \":\", p);",
          "6732:   return FAIL;",
          "6733:      }",
          "6734:      p = skipwhite(p + 1);",
          "6735:      if (*p == ']')",
          "6737:   r = generate_PUSHSPEC(cctx, VVAL_NONE);",
          "6738:      else",
          "6739:   r = compile_expr0(&p, cctx);",
          "6740:  }",
          "6742:  if (r == OK && *skipwhite(p) != ']')",
          "6743:  {",
          "6745:      emsg(_(e_missing_closing_square_brace));",
          "6746:      r = FAIL;",
          "6747:  }",
          "6748:     }",
          "6749:     else // if (*p == '.')",
          "6750:     {",
          "6751:  char_u *key_end = to_name_end(p + 1, TRUE);",
          "6752:  char_u *key = vim_strnsave(p + 1, key_end - p - 1);",
          "6754:  r = generate_PUSHS(cctx, &key);",
          "6755:     }",
          "6756:     return r;",
          "6757: }",
          "6762:     static int",
          "6763: compile_load_lhs(",
          "6764:  lhs_T *lhs,",
          "6765:  char_u *var_start,",
          "6766:  type_T *rhs_type,",
          "6767:  cctx_T *cctx)",
          "6768: {",
          "6769:     if (lhs->lhs_dest == dest_expr)",
          "6770:     {",
          "6771:  size_t     varlen = lhs->lhs_varlen;",
          "6772:  int     c = var_start[varlen];",
          "6773:  int     lines_len = cctx->ctx_ufunc->uf_lines.ga_len;",
          "6774:  char_u     *p = var_start;",
          "6775:  garray_T    *stack = &cctx->ctx_type_stack;",
          "6776:  int     res;",
          "6780:  var_start[varlen] = NUL;",
          "6781:  cctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;",
          "6782:  res = compile_expr0(&p, cctx);",
          "6783:  var_start[varlen] = c;",
          "6784:  cctx->ctx_ufunc->uf_lines.ga_len = lines_len;",
          "6785:  if (res == FAIL || p != var_start + varlen)",
          "6786:  {",
          "6788:      if (res != FAIL)",
          "6789:   emsg(_(e_missing_closing_square_brace));",
          "6790:      return FAIL;",
          "6791:  }",
          "6793:  lhs->lhs_type = stack->ga_len == 0 ? &t_void",
          "6794:          : ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "6796:  if (rhs_type != NULL && lhs->lhs_type->tt_member != NULL",
          "6797:   && rhs_type != &t_void",
          "6798:   && need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,",
          "6799:         FALSE, FALSE) == FAIL)",
          "6800:      return FAIL;",
          "6801:     }",
          "6802:     else",
          "6803:  generate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,",
          "6804:        lhs->lhs_lvar, lhs->lhs_type);",
          "6805:     return OK;",
          "6806: }",
          "6812:     static int",
          "6813: compile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)",
          "6814: {",
          "6815:     compile_load_lhs(lhs, var_start, NULL, cctx);",
          "6817:     if (lhs->lhs_has_index)",
          "6818:     {",
          "6819:  int range = FALSE;",
          "6823:  if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)",
          "6824:      return FAIL;",
          "6825:  if (range)",
          "6826:  {",
          "6827:      semsg(_(e_cannot_use_range_with_assignment_operator_str),",
          "6828:             var_start);",
          "6829:      return FAIL;",
          "6830:  }",
          "6833:  if (compile_member(FALSE, NULL, cctx) == FAIL)",
          "6834:      return FAIL;",
          "6835:     }",
          "6836:     return OK;",
          "6837: }",
          "6844:     static int",
          "6845: compile_assign_unlet(",
          "6846:  char_u *var_start,",
          "6847:  lhs_T *lhs,",
          "6848:  int is_assign,",
          "6849:  type_T *rhs_type,",
          "6850:  cctx_T *cctx)",
          "6851: {",
          "6852:     vartype_T dest_type;",
          "6853:     garray_T    *stack = &cctx->ctx_type_stack;",
          "6854:     int  range = FALSE;",
          "6856:     if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)",
          "6857:  return FAIL;",
          "6858:     if (is_assign && range",
          "6859:      && lhs->lhs_type->tt_type != VAR_LIST",
          "6860:      && lhs->lhs_type != &t_blob",
          "6861:      && lhs->lhs_type != &t_any)",
          "6862:     {",
          "6863:  semsg(_(e_cannot_use_range_with_assignment_str), var_start);",
          "6864:  return FAIL;",
          "6865:     }",
          "6867:     if (lhs->lhs_type == &t_any)",
          "6868:     {",
          "6870:  dest_type = VAR_ANY;",
          "6871:     }",
          "6872:     else",
          "6873:     {",
          "6874:  dest_type = lhs->lhs_type->tt_type;",
          "6875:  if (dest_type == VAR_DICT && range)",
          "6876:  {",
          "6877:      emsg(e_cannot_use_range_with_dictionary);",
          "6878:      return FAIL;",
          "6879:  }",
          "6880:  if (dest_type == VAR_DICT",
          "6881:          && may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "6882:      return FAIL;",
          "6883:  if (dest_type == VAR_LIST || dest_type == VAR_BLOB)",
          "6884:  {",
          "6885:      type_T *type;",
          "6887:      if (range)",
          "6888:      {",
          "6889:   type = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "6890:   if (need_type(type, &t_number,",
          "6891:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "6892:   return FAIL;",
          "6893:      }",
          "6894:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "6895:      if ((dest_type != VAR_BLOB && type != &t_special)",
          "6896:       && need_type(type, &t_number,",
          "6897:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "6898:   return FAIL;",
          "6899:  }",
          "6900:     }",
          "6907:     if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)",
          "6908:  return FAIL;",
          "6910:     if (dest_type == VAR_LIST || dest_type == VAR_DICT",
          "6911:          || dest_type == VAR_BLOB || dest_type == VAR_ANY)",
          "6912:     {",
          "6913:  if (is_assign)",
          "6914:  {",
          "6915:      if (range)",
          "6916:      {",
          "6917:   if (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)",
          "6918:       return FAIL;",
          "6919:      }",
          "6920:      else",
          "6921:      {",
          "6922:   isn_T *isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);",
          "6924:   if (isn == NULL)",
          "6925:       return FAIL;",
          "6926:   isn->isn_arg.vartype = dest_type;",
          "6927:      }",
          "6928:  }",
          "6929:  else if (range)",
          "6930:  {",
          "6931:      if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)",
          "6932:   return FAIL;",
          "6933:  }",
          "6934:  else",
          "6935:  {",
          "6936:      if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)",
          "6937:   return FAIL;",
          "6938:  }",
          "6939:     }",
          "6940:     else",
          "6941:     {",
          "6942:  emsg(_(e_indexable_type_required));",
          "6943:  return FAIL;",
          "6944:     }",
          "6946:     return OK;",
          "6947: }",
          "6961:     static char_u *",
          "6962: compile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)",
          "6963: {",
          "6964:     char_u *var_start;",
          "6965:     char_u *p;",
          "6966:     char_u *end = arg;",
          "6967:     char_u *ret = NULL;",
          "6968:     int  var_count = 0;",
          "6969:     int  var_idx;",
          "6970:     int  semicolon = 0;",
          "6971:     int  did_generate_slice = FALSE;",
          "6972:     garray_T *instr = &cctx->ctx_instr;",
          "6973:     garray_T    *stack = &cctx->ctx_type_stack;",
          "6974:     char_u *op;",
          "6975:     int  oplen = 0;",
          "6976:     int  heredoc = FALSE;",
          "6977:     int  incdec = FALSE;",
          "6978:     type_T *rhs_type = &t_any;",
          "6979:     char_u *sp;",
          "6980:     int  is_decl = is_decl_command(cmdidx);",
          "6981:     lhs_T lhs;",
          "6982:     long start_lnum = SOURCING_LNUM;",
          "6985:     p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);",
          "6986:     if (p == NULL)",
          "6987:  return *arg == '[' ? arg : NULL;",
          "6989:     lhs.lhs_name = NULL;",
          "6991:     sp = p;",
          "6992:     p = skipwhite(p);",
          "6993:     op = p;",
          "6994:     oplen = assignment_len(p, &heredoc);",
          "6996:     if (var_count > 0 && oplen == 0)",
          "6998:  return arg;",
          "7000:     if (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))",
          "7001:     {",
          "7002:  error_white_both(op, oplen);",
          "7003:  return NULL;",
          "7004:     }",
          "7005:     if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)",
          "7006:     {",
          "7007:  if (VIM_ISWHITE(eap->cmd[2]))",
          "7008:  {",
          "7009:      semsg(_(e_no_white_space_allowed_after_str_str),",
          "7010:     eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);",
          "7011:      return NULL;",
          "7012:  }",
          "7013:  op = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");",
          "7014:  oplen = 2;",
          "7015:  incdec = TRUE;",
          "7016:     }",
          "7018:     if (heredoc)",
          "7019:     {",
          "7020:  list_T    *l;",
          "7021:  listitem_T *li;",
          "7024:  eap->getline = exarg_getline;",
          "7025:  eap->cookie = cctx;",
          "7026:  l = heredoc_get(eap, op + 3, FALSE);",
          "7027:  if (l == NULL)",
          "7028:      return NULL;",
          "7030:  if (cctx->ctx_skip != SKIP_YES)",
          "7031:  {",
          "7033:      FOR_ALL_LIST_ITEMS(l, li)",
          "7034:      {",
          "7035:   generate_PUSHS(cctx, &li->li_tv.vval.v_string);",
          "7036:   li->li_tv.vval.v_string = NULL;",
          "7037:      }",
          "7038:      generate_NEWLIST(cctx, l->lv_len);",
          "7039:  }",
          "7040:  list_free(l);",
          "7041:  p += STRLEN(p);",
          "7042:  end = p;",
          "7043:     }",
          "7044:     else if (var_count > 0)",
          "7045:     {",
          "7046:  char_u *wp;",
          "7052:  wp = op + oplen;",
          "7053:  if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "7054:      return FAIL;",
          "7055:  if (compile_expr0(&p, cctx) == FAIL)",
          "7056:      return NULL;",
          "7057:  end = p;",
          "7059:  if (cctx->ctx_skip != SKIP_YES)",
          "7060:  {",
          "7061:      type_T *stacktype;",
          "7062:      int  needed_list_len;",
          "7063:      int  did_check = FALSE;",
          "7065:      stacktype = stack->ga_len == 0 ? &t_void",
          "7066:          : ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "7067:      if (stacktype->tt_type == VAR_VOID)",
          "7068:      {",
          "7069:   emsg(_(e_cannot_use_void_value));",
          "7070:   goto theend;",
          "7071:      }",
          "7072:      if (need_type(stacktype, &t_list_any, -1, 0, cctx,",
          "7073:         FALSE, FALSE) == FAIL)",
          "7074:   goto theend;",
          "7076:      needed_list_len = semicolon ? var_count - 1 : var_count;",
          "7077:      if (instr->ga_len > 0)",
          "7078:      {",
          "7079:   isn_T *isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "7081:   if (isn->isn_type == ISN_NEWLIST)",
          "7082:   {",
          "7083:       did_check = TRUE;",
          "7084:       if (semicolon ? isn->isn_arg.number < needed_list_len",
          "7085:        : isn->isn_arg.number != needed_list_len)",
          "7086:       {",
          "7087:    semsg(_(e_expected_nr_items_but_got_nr),",
          "7088:       needed_list_len, isn->isn_arg.number);",
          "7089:    goto theend;",
          "7090:       }",
          "7091:   }",
          "7092:      }",
          "7093:      if (!did_check)",
          "7094:   generate_CHECKLEN(cctx, needed_list_len, semicolon);",
          "7095:      if (stacktype->tt_member != NULL)",
          "7096:   rhs_type = stacktype->tt_member;",
          "7097:  }",
          "7098:     }",
          "7104:     if (var_count > 0)",
          "7105:  var_start = skipwhite(arg + 1);  // skip over the \"[\"",
          "7106:     else",
          "7107:  var_start = arg;",
          "7108:     for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)",
          "7109:     {",
          "7110:  int instr_count = -1;",
          "7111:  int save_lnum;",
          "7113:  if (var_start[0] == '_' && !eval_isnamec(var_start[1]))",
          "7114:  {",
          "7116:      if (var_count > 0)",
          "7117:      {",
          "7118:   var_start = skipwhite(var_start + 2);",
          "7119:   continue;",
          "7120:      }",
          "7121:      emsg(_(e_cannot_use_underscore_here));",
          "7122:      goto theend;",
          "7123:  }",
          "7124:  vim_free(lhs.lhs_name);",
          "7129:  if (compile_assign_lhs(var_start, &lhs, cmdidx,",
          "7130:      is_decl, heredoc, oplen, cctx) == FAIL)",
          "7131:      goto theend;",
          "7132:  if (heredoc)",
          "7133:  {",
          "7134:      SOURCING_LNUM = start_lnum;",
          "7135:      if (lhs.lhs_has_type",
          "7136:       && need_type(&t_list_string, lhs.lhs_type,",
          "7137:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "7138:   goto theend;",
          "7139:  }",
          "7140:  else",
          "7141:  {",
          "7142:      if (cctx->ctx_skip == SKIP_YES)",
          "7143:      {",
          "7144:   if (oplen > 0 && var_count == 0)",
          "7145:   {",
          "7147:       p = skipwhite(op + oplen);",
          "7148:       (void)compile_expr0(&p, cctx);",
          "7149:   }",
          "7150:      }",
          "7151:      else if (oplen > 0)",
          "7152:      {",
          "7153:   int is_const = FALSE;",
          "7154:   char_u *wp;",
          "7157:   if (*op != '='",
          "7158:    && compile_load_lhs_with_index(&lhs, var_start,",
          "7159:          cctx) == FAIL)",
          "7160:       goto theend;",
          "7163:   if (var_count == 0)",
          "7164:   {",
          "7165:       int r;",
          "7168:       instr_count = instr->ga_len;",
          "7169:       if (incdec)",
          "7170:       {",
          "7171:    r = generate_PUSHNR(cctx, 1);",
          "7172:       }",
          "7173:       else",
          "7174:       {",
          "7177:    if (lhs.lhs_new_local)",
          "7178:        --cctx->ctx_locals.ga_len;",
          "7179:    wp = op + oplen;",
          "7180:    if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "7181:    {",
          "7182:        if (lhs.lhs_new_local)",
          "7183:     ++cctx->ctx_locals.ga_len;",
          "7184:        goto theend;",
          "7185:    }",
          "7186:    r = compile_expr0_ext(&p, cctx, &is_const);",
          "7187:    if (lhs.lhs_new_local)",
          "7188:        ++cctx->ctx_locals.ga_len;",
          "7189:    if (r == FAIL)",
          "7190:        goto theend;",
          "7191:       }",
          "7192:   }",
          "7193:   else if (semicolon && var_idx == var_count - 1)",
          "7194:   {",
          "7196:       did_generate_slice = TRUE;",
          "7197:       if (generate_SLICE(cctx, var_count - 1) == FAIL)",
          "7198:    goto theend;",
          "7199:   }",
          "7200:   else",
          "7201:   {",
          "7204:       if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)",
          "7205:    goto theend;",
          "7206:   }",
          "7208:   rhs_type = stack->ga_len == 0 ? &t_void",
          "7209:          : ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "7210:   if (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))",
          "7211:   {",
          "7212:       if ((rhs_type->tt_type == VAR_FUNC",
          "7213:     || rhs_type->tt_type == VAR_PARTIAL)",
          "7214:        && !lhs.lhs_has_index",
          "7215:        && var_wrong_func_name(lhs.lhs_name, TRUE))",
          "7216:    goto theend;",
          "7218:       if (lhs.lhs_new_local && !lhs.lhs_has_type)",
          "7219:       {",
          "7220:    if (rhs_type->tt_type == VAR_VOID)",
          "7221:    {",
          "7222:        emsg(_(e_cannot_use_void_value));",
          "7223:        goto theend;",
          "7224:    }",
          "7225:    else",
          "7226:    {",
          "7229:        if (rhs_type == &t_list_empty)",
          "7230:     lhs.lhs_lvar->lv_type = &t_list_any;",
          "7231:        else if (rhs_type == &t_dict_empty)",
          "7232:     lhs.lhs_lvar->lv_type = &t_dict_any;",
          "7233:        else if (rhs_type == &t_unknown)",
          "7234:     lhs.lhs_lvar->lv_type = &t_any;",
          "7235:        else",
          "7236:     lhs.lhs_lvar->lv_type = rhs_type;",
          "7237:    }",
          "7238:       }",
          "7239:       else if (*op == '=')",
          "7240:       {",
          "7241:    type_T *use_type = lhs.lhs_lvar->lv_type;",
          "7242:    where_T where = WHERE_INIT;",
          "7246:    SOURCING_LNUM = start_lnum;",
          "7247:    where.wt_index = var_count > 0 ? var_idx + 1 : 0;",
          "7248:    where.wt_variable = var_count > 0;",
          "7251:    if (lhs.lhs_has_index",
          "7252:     && !has_list_index(var_start + lhs.lhs_varlen,",
          "7253:           cctx))",
          "7254:        use_type = lhs.lhs_member_type;",
          "7255:    if (need_type_where(rhs_type, use_type, -1, where,",
          "7256:         cctx, FALSE, is_const) == FAIL)",
          "7257:        goto theend;",
          "7258:       }",
          "7259:   }",
          "7260:   else",
          "7261:   {",
          "7262:       type_T *lhs_type = lhs.lhs_member_type;",
          "7267:       if ((lhs_type == &t_number_or_string",
          "7268:     || lhs_type == &t_float)",
          "7269:        && rhs_type->tt_type == VAR_NUMBER)",
          "7270:    lhs_type = &t_number;",
          "7271:       if (*p != '=' && need_type(rhs_type, lhs_type,",
          "7272:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "7273:       goto theend;",
          "7274:   }",
          "7275:      }",
          "7276:      else if (cmdidx == CMD_final)",
          "7277:      {",
          "7278:   emsg(_(e_final_requires_a_value));",
          "7279:   goto theend;",
          "7280:      }",
          "7281:      else if (cmdidx == CMD_const)",
          "7282:      {",
          "7283:   emsg(_(e_const_requires_a_value));",
          "7284:   goto theend;",
          "7285:      }",
          "7286:      else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option",
          "7287:         || lhs.lhs_dest == dest_func_option)",
          "7288:      {",
          "7289:   emsg(_(e_type_or_initialization_required));",
          "7290:   goto theend;",
          "7291:      }",
          "7292:      else",
          "7293:      {",
          "7295:   if (GA_GROW_FAILS(instr, 1))",
          "7296:       goto theend;",
          "7297:   switch (lhs.lhs_member_type->tt_type)",
          "7298:   {",
          "7299:       case VAR_BOOL:",
          "7300:    generate_PUSHBOOL(cctx, VVAL_FALSE);",
          "7301:    break;",
          "7302:       case VAR_FLOAT:",
          "7303: #ifdef FEAT_FLOAT",
          "7304:    generate_PUSHF(cctx, 0.0);",
          "7305: #endif",
          "7306:    break;",
          "7307:       case VAR_STRING:",
          "7308:    generate_PUSHS(cctx, NULL);",
          "7309:    break;",
          "7310:       case VAR_BLOB:",
          "7311:    generate_PUSHBLOB(cctx, blob_alloc());",
          "7312:    break;",
          "7313:       case VAR_FUNC:",
          "7314:    generate_PUSHFUNC(cctx, NULL, &t_func_void);",
          "7315:    break;",
          "7316:       case VAR_LIST:",
          "7317:    generate_NEWLIST(cctx, 0);",
          "7318:    break;",
          "7319:       case VAR_DICT:",
          "7320:    generate_NEWDICT(cctx, 0);",
          "7321:    break;",
          "7322:       case VAR_JOB:",
          "7323:    generate_PUSHJOB(cctx, NULL);",
          "7324:    break;",
          "7325:       case VAR_CHANNEL:",
          "7326:    generate_PUSHCHANNEL(cctx, NULL);",
          "7327:    break;",
          "7328:       case VAR_NUMBER:",
          "7329:       case VAR_UNKNOWN:",
          "7330:       case VAR_ANY:",
          "7331:       case VAR_PARTIAL:",
          "7332:       case VAR_VOID:",
          "7333:       case VAR_INSTR:",
          "7334:       case VAR_SPECIAL:  // cannot happen",
          "7335:    generate_PUSHNR(cctx, 0);",
          "7336:    break;",
          "7337:   }",
          "7338:      }",
          "7339:      if (var_count == 0)",
          "7340:   end = p;",
          "7341:  }",
          "7344:  if (cctx->ctx_skip == SKIP_YES)",
          "7345:      break;",
          "7347:  if (oplen > 0 && *op != '=')",
          "7348:  {",
          "7349:      type_T     *expected;",
          "7350:      type_T     *stacktype = NULL;",
          "7352:      if (*op == '.')",
          "7353:      {",
          "7354:   if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "7355:       goto theend;",
          "7356:      }",
          "7357:      else",
          "7358:      {",
          "7359:   expected = lhs.lhs_member_type;",
          "7360:   stacktype = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "7361:   if (",
          "7362: #ifdef FEAT_FLOAT",
          "7364:       !(expected == &t_float && (stacktype == &t_number",
          "7365:        || stacktype == &t_number_bool)) &&",
          "7366: #endif",
          "7367:       need_type(stacktype, expected, -1, 0, cctx,",
          "7368:         FALSE, FALSE) == FAIL)",
          "7369:       goto theend;",
          "7370:      }",
          "7372:      if (*op == '.')",
          "7373:      {",
          "7374:   if (generate_instr_drop(cctx, ISN_CONCAT, 1) == NULL)",
          "7375:       goto theend;",
          "7376:      }",
          "7377:      else if (*op == '+')",
          "7378:      {",
          "7379:   if (generate_add_instr(cctx,",
          "7380:        operator_type(lhs.lhs_member_type, stacktype),",
          "7381:            lhs.lhs_member_type, stacktype,",
          "7382:          EXPR_APPEND) == FAIL)",
          "7383:       goto theend;",
          "7384:      }",
          "7385:      else if (generate_two_op(cctx, op) == FAIL)",
          "7386:   goto theend;",
          "7387:  }",
          "7390:  save_lnum = cctx->ctx_lnum;",
          "7391:  cctx->ctx_lnum = start_lnum - 1;",
          "7393:  if (lhs.lhs_has_index)",
          "7394:  {",
          "7397:      if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)",
          "7398:                == FAIL)",
          "7399:      {",
          "7400:   cctx->ctx_lnum = save_lnum;",
          "7401:   goto theend;",
          "7402:      }",
          "7403:  }",
          "7404:  else",
          "7405:  {",
          "7406:      if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script",
          "7407:       || lhs.lhs_dest == dest_global",
          "7408:       || lhs.lhs_dest == dest_local))",
          "7410:   generate_LOCKCONST(cctx);",
          "7412:      if (is_decl",
          "7413:       && (lhs.lhs_type->tt_type == VAR_DICT",
          "7414:        || lhs.lhs_type->tt_type == VAR_LIST)",
          "7415:       && lhs.lhs_type->tt_member != NULL",
          "7416:       && !(lhs.lhs_type->tt_member == &t_any",
          "7417:        && oplen > 0",
          "7418:        && rhs_type != NULL",
          "7419:        && rhs_type->tt_type == lhs.lhs_type->tt_type",
          "7420:        && rhs_type->tt_member != &t_unknown)",
          "7421:       && lhs.lhs_type->tt_member != &t_unknown)",
          "7425:   generate_SETTYPE(cctx, lhs.lhs_type);",
          "7427:      if (generate_store_lhs(cctx, &lhs, instr_count) == FAIL)",
          "7428:      {",
          "7429:   cctx->ctx_lnum = save_lnum;",
          "7430:   goto theend;",
          "7431:      }",
          "7432:  }",
          "7433:  cctx->ctx_lnum = save_lnum;",
          "7435:  if (var_idx + 1 < var_count)",
          "7436:      var_start = skipwhite(lhs.lhs_end + 1);",
          "7437:     }",
          "7441:     if (var_count > 0 && (!semicolon || !did_generate_slice))",
          "7442:     {",
          "7443:  if (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)",
          "7444:      goto theend;",
          "7445:     }",
          "7447:     ret = skipwhite(end);",
          "7449: theend:",
          "7450:     vim_free(lhs.lhs_name);",
          "7451:     return ret;",
          "7452: }",
          "7458:     static int",
          "7459: may_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)",
          "7460: {",
          "7461:     char_u  *pskip;",
          "7462:     char_u  *p;",
          "7468:     pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')",
          "7469:        ? eap->cmd + 1 : eap->cmd;",
          "7470:     p = to_name_end(pskip, TRUE);",
          "7471:     if (p > eap->cmd && *p != NUL)",
          "7472:     {",
          "7473:  char_u *var_end;",
          "7474:  int oplen;",
          "7475:  int heredoc;",
          "7477:  if (eap->cmd[0] == '@')",
          "7478:      var_end = eap->cmd + 2;",
          "7479:  else",
          "7480:      var_end = find_name_end(pskip, NULL, NULL,",
          "7481:      FNE_CHECK_START | FNE_INCL_BR);",
          "7482:  oplen = assignment_len(skipwhite(var_end), &heredoc);",
          "7483:  if (oplen > 0)",
          "7484:  {",
          "7485:      size_t len = p - eap->cmd;",
          "7496:      if (*eap->cmd == '&'",
          "7497:       || *eap->cmd == '$'",
          "7498:       || *eap->cmd == '@'",
          "7499:       || ((len) > 2 && eap->cmd[1] == ':')",
          "7500:       || variable_exists(eap->cmd, len, cctx))",
          "7501:      {",
          "7503:   if (*line == NULL || *line == eap->cmd)",
          "7504:       return FAIL;",
          "7505:   return OK;",
          "7506:      }",
          "7507:  }",
          "7508:     }",
          "7510:     if (*eap->cmd == '[')",
          "7511:     {",
          "7514:  if (*line == NULL)",
          "7515:      return FAIL;",
          "7516:  if (*line != eap->cmd)",
          "7517:      return OK;",
          "7518:     }",
          "7519:     return NOTDONE;",
          "7520: }",
          "7525:     int",
          "7526: check_vim9_unlet(char_u *name)",
          "7527: {",
          "7528:     if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)",
          "7529:     {",
          "7531:  if (*name == 's' && !script_is_vim9())",
          "7532:      return OK;",
          "7533:  semsg(_(e_cannot_unlet_str), name);",
          "7534:  return FAIL;",
          "7535:     }",
          "7536:     return OK;",
          "7537: }",
          "7542:     static int",
          "7543: compile_unlet(",
          "7544:     lval_T  *lvp,",
          "7545:     char_u  *name_end,",
          "7546:     exarg_T *eap,",
          "7547:     int     deep UNUSED,",
          "7548:     void    *coookie)",
          "7549: {",
          "7550:     cctx_T *cctx = coookie;",
          "7551:     char_u *p = lvp->ll_name;",
          "7552:     int  cc = *name_end;",
          "7553:     int  ret = OK;",
          "7555:     if (cctx->ctx_skip == SKIP_YES)",
          "7556:  return OK;",
          "7559:     if (*p == '$')",
          "7560:     {",
          "7562:  ret = generate_UNLET(cctx, ISN_UNLETENV, p + 1, eap->forceit);",
          "7563:     }",
          "7564:     else if (vim_strchr(p, '.') != NULL || vim_strchr(p, '[') != NULL)",
          "7565:     {",
          "7566:  lhs_T     lhs;",
          "7575:  ret = compile_lhs(p, &lhs, CMD_unlet, FALSE, 0, cctx);",
          "7578:  if (!lhs.lhs_has_index)",
          "7579:  {",
          "7580:      iemsg(\"called compile_lhs() without an index\");",
          "7581:      ret = FAIL;",
          "7582:  }",
          "7583:  else",
          "7584:  {",
          "7587:      ret = compile_assign_unlet(p, &lhs, FALSE, &t_void, cctx);",
          "7588:  }",
          "7590:  vim_free(lhs.lhs_name);",
          "7591:     }",
          "7592:     else if (check_vim9_unlet(p) == FAIL)",
          "7593:     {",
          "7594:  ret = FAIL;",
          "7595:     }",
          "7596:     else",
          "7597:     {",
          "7599:  ret = generate_UNLET(cctx, ISN_UNLET, p, eap->forceit);",
          "7600:     }",
          "7603:     return ret;",
          "7604: }",
          "7609:     static int",
          "7610: compile_lock_unlock(",
          "7611:     lval_T  *lvp,",
          "7612:     char_u  *name_end,",
          "7613:     exarg_T *eap,",
          "7614:     int     deep UNUSED,",
          "7615:     void    *coookie)",
          "7616: {",
          "7617:     cctx_T *cctx = coookie;",
          "7618:     int  cc = *name_end;",
          "7619:     char_u *p = lvp->ll_name;",
          "7620:     int  ret = OK;",
          "7621:     size_t len;",
          "7622:     char_u *buf;",
          "7623:     isntype_T isn = ISN_EXEC;",
          "7625:     if (cctx->ctx_skip == SKIP_YES)",
          "7626:  return OK;",
          "7629:     if (p[1] != ':')",
          "7630:     {",
          "7631:  char_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);",
          "7633:  if (lookup_local(p, end - p, NULL, cctx) == OK)",
          "7634:  {",
          "7635:      char_u *s = p;",
          "7637:      if (*end != '.' && *end != '[')",
          "7638:      {",
          "7639:   emsg(_(e_cannot_lock_unlock_local_variable));",
          "7640:   return FAIL;",
          "7641:      }",
          "7645:      if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)",
          "7646:   return FAIL;",
          "7647:      isn = ISN_LOCKUNLOCK;",
          "7648:  }",
          "7649:     }",
          "7653:     len = name_end - p + 20;",
          "7654:     buf = alloc(len);",
          "7655:     if (buf == NULL)",
          "7656:  ret = FAIL;",
          "7657:     else",
          "7658:     {",
          "7659:  vim_snprintf((char *)buf, len, \"%s %s\",",
          "7660:   eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\",",
          "7661:   p);",
          "7662:  ret = generate_EXEC_copy(cctx, isn, buf);",
          "7664:  vim_free(buf);",
          "7666:     }",
          "7667:     return ret;",
          "7668: }",
          "7674:     static char_u *",
          "7675: compile_unletlock(char_u *arg, exarg_T *eap, cctx_T *cctx)",
          "7676: {",
          "7677:     ex_unletlock(eap, arg, 0, GLV_NO_AUTOLOAD | GLV_COMPILING,",
          "7678:      eap->cmdidx == CMD_unlet ? compile_unlet : compile_lock_unlock,",
          "7679:      cctx);",
          "7680:     return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;",
          "7681: }",
          "7686:     static int",
          "7687: compile_jump_to_end(endlabel_T **el, jumpwhen_T when, cctx_T *cctx)",
          "7688: {",
          "7689:     garray_T *instr = &cctx->ctx_instr;",
          "7690:     endlabel_T  *endlabel = ALLOC_CLEAR_ONE(endlabel_T);",
          "7692:     if (endlabel == NULL)",
          "7693:  return FAIL;",
          "7694:     endlabel->el_next = *el;",
          "7696:     endlabel->el_end_label = instr->ga_len;",
          "7698:     generate_JUMP(cctx, when, 0);",
          "7699:     return OK;",
          "7700: }",
          "7702:     static void",
          "7703: compile_fill_jump_to_end(endlabel_T **el, int jump_where, cctx_T *cctx)",
          "7704: {",
          "7705:     garray_T *instr = &cctx->ctx_instr;",
          "7707:     while (*el != NULL)",
          "7708:     {",
          "7709:  endlabel_T  *cur = (*el);",
          "7710:  isn_T     *isn;",
          "7712:  isn = ((isn_T *)instr->ga_data) + cur->el_end_label;",
          "7713:  isn->isn_arg.jump.jump_where = jump_where;",
          "7715:  vim_free(cur);",
          "7716:     }",
          "7717: }",
          "7719:     static void",
          "7720: compile_free_jump_to_end(endlabel_T **el)",
          "7721: {",
          "7722:     while (*el != NULL)",
          "7723:     {",
          "7724:  endlabel_T  *cur = (*el);",
          "7727:  vim_free(cur);",
          "7728:     }",
          "7729: }",
          "7734:     static scope_T *",
          "7735: new_scope(cctx_T *cctx, scopetype_T type)",
          "7736: {",
          "7737:     scope_T *scope = ALLOC_CLEAR_ONE(scope_T);",
          "7739:     if (scope == NULL)",
          "7740:  return NULL;",
          "7741:     scope->se_outer = cctx->ctx_scope;",
          "7742:     cctx->ctx_scope = scope;",
          "7743:     scope->se_type = type;",
          "7744:     scope->se_local_count = cctx->ctx_locals.ga_len;",
          "7745:     return scope;",
          "7746: }",
          "7751:     static void",
          "7752: drop_scope(cctx_T *cctx)",
          "7753: {",
          "7754:     scope_T *scope = cctx->ctx_scope;",
          "7756:     if (scope == NULL)",
          "7757:     {",
          "7758:  iemsg(\"calling drop_scope() without a scope\");",
          "7759:  return;",
          "7760:     }",
          "7761:     cctx->ctx_scope = scope->se_outer;",
          "7762:     switch (scope->se_type)",
          "7763:     {",
          "7764:  case IF_SCOPE:",
          "7765:      compile_free_jump_to_end(&scope->se_u.se_if.is_end_label); break;",
          "7766:  case FOR_SCOPE:",
          "7767:      compile_free_jump_to_end(&scope->se_u.se_for.fs_end_label); break;",
          "7768:  case WHILE_SCOPE:",
          "7769:      compile_free_jump_to_end(&scope->se_u.se_while.ws_end_label); break;",
          "7770:  case TRY_SCOPE:",
          "7771:      compile_free_jump_to_end(&scope->se_u.se_try.ts_end_label); break;",
          "7772:  case NO_SCOPE:",
          "7773:  case BLOCK_SCOPE:",
          "7774:      break;",
          "7775:     }",
          "7776:     vim_free(scope);",
          "7777: }",
          "7811:     static char_u *",
          "7812: compile_if(char_u *arg, cctx_T *cctx)",
          "7813: {",
          "7814:     char_u *p = arg;",
          "7815:     garray_T *instr = &cctx->ctx_instr;",
          "7816:     int  instr_count = instr->ga_len;",
          "7817:     scope_T *scope;",
          "7818:     skip_T skip_save = cctx->ctx_skip;",
          "7819:     ppconst_T ppconst;",
          "7821:     CLEAR_FIELD(ppconst);",
          "7822:     if (compile_expr1(&p, cctx, &ppconst) == FAIL)",
          "7823:     {",
          "7824:  clear_ppconst(&ppconst);",
          "7825:  return NULL;",
          "7826:     }",
          "7827:     if (!ends_excmd2(arg, skipwhite(p)))",
          "7828:     {",
          "7829:  semsg(_(e_trailing_arg), p);",
          "7830:  return NULL;",
          "7831:     }",
          "7832:     if (cctx->ctx_skip == SKIP_YES)",
          "7833:  clear_ppconst(&ppconst);",
          "7834:     else if (instr->ga_len == instr_count && ppconst.pp_used == 1)",
          "7835:     {",
          "7836:  int error = FALSE;",
          "7837:  int v;",
          "7840:  v = tv_get_bool_chk(&ppconst.pp_tv[0], &error);",
          "7841:  clear_ppconst(&ppconst);",
          "7842:  if (error)",
          "7843:      return NULL;",
          "7844:  cctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;",
          "7845:     }",
          "7846:     else",
          "7847:     {",
          "7849:  cctx->ctx_skip = SKIP_UNKNOWN;",
          "7850:  if (generate_ppconst(cctx, &ppconst) == FAIL)",
          "7851:      return NULL;",
          "7852:  if (bool_on_stack(cctx) == FAIL)",
          "7853:      return NULL;",
          "7854:     }",
          "7857:     generate_undo_cmdmods(cctx);",
          "7859:     scope = new_scope(cctx, IF_SCOPE);",
          "7860:     if (scope == NULL)",
          "7861:  return NULL;",
          "7862:     scope->se_skip_save = skip_save;",
          "7864:     scope->se_u.se_if.is_had_return = TRUE;",
          "7866:     if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "7867:     {",
          "7869:  scope->se_u.se_if.is_if_label = instr->ga_len;",
          "7870:  generate_JUMP(cctx, JUMP_IF_FALSE, 0);",
          "7871:     }",
          "7872:     else",
          "7873:  scope->se_u.se_if.is_if_label = -1;",
          "7875: #ifdef FEAT_PROFILE",
          "7876:     if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES",
          "7877:             && skip_save != SKIP_YES)",
          "7878:     {",
          "7881:  cctx->ctx_skip = SKIP_NOT;",
          "7882:  generate_instr(cctx, ISN_PROF_END);",
          "7883:  cctx->ctx_skip = SKIP_YES;",
          "7884:     }",
          "7885: #endif",
          "7887:     return p;",
          "7888: }",
          "7890:     static char_u *",
          "7891: compile_elseif(char_u *arg, cctx_T *cctx)",
          "7892: {",
          "7893:     char_u *p = arg;",
          "7894:     garray_T *instr = &cctx->ctx_instr;",
          "7895:     int  instr_count;",
          "7896:     isn_T *isn;",
          "7897:     scope_T *scope = cctx->ctx_scope;",
          "7898:     ppconst_T ppconst;",
          "7899:     skip_T save_skip = cctx->ctx_skip;",
          "7901:     if (scope == NULL || scope->se_type != IF_SCOPE)",
          "7902:     {",
          "7903:  emsg(_(e_elseif_without_if));",
          "7904:  return NULL;",
          "7905:     }",
          "7906:     unwind_locals(cctx, scope->se_local_count);",
          "7907:     if (!cctx->ctx_had_return)",
          "7908:  scope->se_u.se_if.is_had_return = FALSE;",
          "7910:     if (cctx->ctx_skip == SKIP_NOT)",
          "7911:     {",
          "7913:  cctx->ctx_skip = SKIP_YES;",
          "7914:  scope->se_u.se_if.is_seen_skip_not = TRUE;",
          "7915:     }",
          "7916:     if (scope->se_u.se_if.is_seen_skip_not)",
          "7917:     {",
          "7920:  instr->ga_len = current_instr_idx(cctx);",
          "7922:  skip_expr_cctx(&p, cctx);",
          "7923:  return p;",
          "7924:     }",
          "7926:     if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "7927:     {",
          "7928:  int     moved_cmdmod = FALSE;",
          "7929:  int     saved_debug = FALSE;",
          "7930:  isn_T     debug_isn;",
          "7933:  if (((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type == ISN_CMDMOD)",
          "7934:  {",
          "7935:      if (GA_GROW_FAILS(instr, 1))",
          "7936:   return NULL;",
          "7937:      ((isn_T *)instr->ga_data)[instr->ga_len] =",
          "7938:       ((isn_T *)instr->ga_data)[instr->ga_len - 1];",
          "7939:      --instr->ga_len;",
          "7940:      moved_cmdmod = TRUE;",
          "7941:  }",
          "7945:  if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0",
          "7946:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "7947:        .isn_type == ISN_DEBUG)",
          "7948:  {",
          "7949:      --instr->ga_len;",
          "7950:      debug_isn = ((isn_T *)instr->ga_data)[instr->ga_len];",
          "7951:      saved_debug = TRUE;",
          "7952:  }",
          "7954:  if (compile_jump_to_end(&scope->se_u.se_if.is_end_label,",
          "7955:           JUMP_ALWAYS, cctx) == FAIL)",
          "7956:      return NULL;",
          "7958:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;",
          "7959:  isn->isn_arg.jump.jump_where = instr->ga_len;",
          "7961:  if (moved_cmdmod)",
          "7962:      ++instr->ga_len;",
          "7964:  if (saved_debug)",
          "7965:  {",
          "7967:      if (GA_GROW_FAILS(instr, 1))",
          "7968:   return NULL;",
          "7969:      ((isn_T *)instr->ga_data)[instr->ga_len] = debug_isn;",
          "7970:      ++instr->ga_len;",
          "7971:  }",
          "7972:     }",
          "7975:     CLEAR_FIELD(ppconst);",
          "7976:     if (cctx->ctx_skip == SKIP_YES)",
          "7977:     {",
          "7978:  cctx->ctx_skip = SKIP_UNKNOWN;",
          "7979: #ifdef FEAT_PROFILE",
          "7980:  if (cctx->ctx_compile_type == CT_PROFILE)",
          "7982:      generate_instr(cctx, ISN_PROF_START);",
          "7983: #endif",
          "7984:  if (cctx->ctx_compile_type == CT_DEBUG)",
          "7986:      generate_instr_debug(cctx);",
          "7987:     }",
          "7989:     instr_count = instr->ga_len;",
          "7990:     if (compile_expr1(&p, cctx, &ppconst) == FAIL)",
          "7991:     {",
          "7992:  clear_ppconst(&ppconst);",
          "7993:  return NULL;",
          "7994:     }",
          "7995:     cctx->ctx_skip = save_skip;",
          "7996:     if (!ends_excmd2(arg, skipwhite(p)))",
          "7997:     {",
          "7998:  clear_ppconst(&ppconst);",
          "7999:  semsg(_(e_trailing_arg), p);",
          "8000:  return NULL;",
          "8001:     }",
          "8002:     if (scope->se_skip_save == SKIP_YES)",
          "8003:  clear_ppconst(&ppconst);",
          "8004:     else if (instr->ga_len == instr_count && ppconst.pp_used == 1)",
          "8005:     {",
          "8006:  int error = FALSE;",
          "8007:  int v;",
          "8010:  v = tv_get_bool_chk(&ppconst.pp_tv[0], &error);",
          "8011:  if (error)",
          "8012:  {",
          "8013:      clear_ppconst(&ppconst);",
          "8014:      return NULL;",
          "8015:  }",
          "8016:  cctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;",
          "8017:  clear_ppconst(&ppconst);",
          "8018:  scope->se_u.se_if.is_if_label = -1;",
          "8019:     }",
          "8020:     else",
          "8021:     {",
          "8023:  cctx->ctx_skip = SKIP_UNKNOWN;",
          "8024:  if (generate_ppconst(cctx, &ppconst) == FAIL)",
          "8025:      return NULL;",
          "8026:  if (bool_on_stack(cctx) == FAIL)",
          "8027:      return NULL;",
          "8030:  generate_undo_cmdmods(cctx);",
          "8033:  scope->se_u.se_if.is_if_label = instr->ga_len;",
          "8034:  generate_JUMP(cctx, JUMP_IF_FALSE, 0);",
          "8035:     }",
          "8037:     return p;",
          "8038: }",
          "8040:     static char_u *",
          "8041: compile_else(char_u *arg, cctx_T *cctx)",
          "8042: {",
          "8043:     char_u *p = arg;",
          "8044:     garray_T *instr = &cctx->ctx_instr;",
          "8045:     isn_T *isn;",
          "8046:     scope_T *scope = cctx->ctx_scope;",
          "8048:     if (scope == NULL || scope->se_type != IF_SCOPE)",
          "8049:     {",
          "8050:  emsg(_(e_else_without_if));",
          "8051:  return NULL;",
          "8052:     }",
          "8053:     unwind_locals(cctx, scope->se_local_count);",
          "8054:     if (!cctx->ctx_had_return)",
          "8055:  scope->se_u.se_if.is_had_return = FALSE;",
          "8056:     scope->se_u.se_if.is_seen_else = TRUE;",
          "8058: #ifdef FEAT_PROFILE",
          "8059:     if (cctx->ctx_compile_type == CT_PROFILE)",
          "8060:     {",
          "8061:  if (cctx->ctx_skip == SKIP_NOT",
          "8062:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "8063:          .isn_type == ISN_PROF_START)",
          "8066:      --instr->ga_len;",
          "8067:  if (cctx->ctx_skip == SKIP_YES && !scope->se_u.se_if.is_seen_skip_not)",
          "8068:  {",
          "8071:      cctx->ctx_skip = SKIP_NOT;",
          "8072:      generate_instr(cctx, ISN_PROF_END);",
          "8073:      generate_instr(cctx, ISN_PROF_START);",
          "8074:      cctx->ctx_skip = SKIP_YES;",
          "8075:  }",
          "8076:     }",
          "8077: #endif",
          "8079:     if (!scope->se_u.se_if.is_seen_skip_not && scope->se_skip_save != SKIP_YES)",
          "8080:     {",
          "8082:  if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "8083:  {",
          "8084:      if (!cctx->ctx_had_return",
          "8085:       && compile_jump_to_end(&scope->se_u.se_if.is_end_label,",
          "8086:           JUMP_ALWAYS, cctx) == FAIL)",
          "8087:   return NULL;",
          "8088:  }",
          "8090:  if (cctx->ctx_skip == SKIP_UNKNOWN)",
          "8091:  {",
          "8092:      if (scope->se_u.se_if.is_if_label >= 0)",
          "8093:      {",
          "8095:   isn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;",
          "8096:   isn->isn_arg.jump.jump_where = instr->ga_len;",
          "8097:   scope->se_u.se_if.is_if_label = -1;",
          "8098:      }",
          "8099:  }",
          "8101:  if (cctx->ctx_skip != SKIP_UNKNOWN)",
          "8102:      cctx->ctx_skip = cctx->ctx_skip == SKIP_YES ? SKIP_NOT : SKIP_YES;",
          "8103:     }",
          "8105:     return p;",
          "8106: }",
          "8108:     static char_u *",
          "8109: compile_endif(char_u *arg, cctx_T *cctx)",
          "8110: {",
          "8111:     scope_T *scope = cctx->ctx_scope;",
          "8112:     ifscope_T *ifscope;",
          "8113:     garray_T *instr = &cctx->ctx_instr;",
          "8114:     isn_T *isn;",
          "8116:     if (misplaced_cmdmod(cctx))",
          "8117:  return NULL;",
          "8119:     if (scope == NULL || scope->se_type != IF_SCOPE)",
          "8120:     {",
          "8121:  emsg(_(e_endif_without_if));",
          "8122:  return NULL;",
          "8123:     }",
          "8124:     ifscope = &scope->se_u.se_if;",
          "8125:     unwind_locals(cctx, scope->se_local_count);",
          "8126:     if (!cctx->ctx_had_return)",
          "8127:  ifscope->is_had_return = FALSE;",
          "8129:     if (scope->se_u.se_if.is_if_label >= 0)",
          "8130:     {",
          "8132:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;",
          "8133:  isn->isn_arg.jump.jump_where = instr->ga_len;",
          "8134:     }",
          "8136:     compile_fill_jump_to_end(&ifscope->is_end_label, instr->ga_len, cctx);",
          "8138: #ifdef FEAT_PROFILE",
          "8141:     if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES",
          "8142:          && scope->se_skip_save != SKIP_YES)",
          "8143:     {",
          "8144:  cctx->ctx_skip = SKIP_NOT;",
          "8145:  generate_instr(cctx, ISN_PROF_START);",
          "8146:     }",
          "8147: #endif",
          "8148:     cctx->ctx_skip = scope->se_skip_save;",
          "8152:     cctx->ctx_had_return = ifscope->is_had_return && ifscope->is_seen_else;",
          "8154:     drop_scope(cctx);",
          "8155:     return arg;",
          "8156: }",
          "8178:     static char_u *",
          "8179: compile_for(char_u *arg_start, cctx_T *cctx)",
          "8180: {",
          "8181:     char_u *arg;",
          "8182:     char_u *arg_end;",
          "8183:     char_u *name = NULL;",
          "8184:     char_u *p;",
          "8185:     char_u *wp;",
          "8186:     int  var_count = 0;",
          "8187:     int  var_list = FALSE;",
          "8188:     int  semicolon = FALSE;",
          "8189:     size_t varlen;",
          "8190:     garray_T *stack = &cctx->ctx_type_stack;",
          "8191:     garray_T *instr = &cctx->ctx_instr;",
          "8192:     scope_T *scope;",
          "8193:     lvar_T *loop_lvar; // loop iteration variable",
          "8194:     lvar_T *var_lvar; // variable for \"var\"",
          "8195:     type_T *vartype;",
          "8196:     type_T *item_type = &t_any;",
          "8197:     int  idx;",
          "8198:     int  prev_lnum = cctx->ctx_prev_lnum;",
          "8200:     p = skip_var_list(arg_start, TRUE, &var_count, &semicolon, FALSE);",
          "8201:     if (p == NULL)",
          "8202:  return NULL;",
          "8203:     if (var_count == 0)",
          "8204:  var_count = 1;",
          "8205:     else",
          "8206:  var_list = TRUE;  // can also be a list of one variable",
          "8209:     wp = p;",
          "8210:     if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "8211:  return NULL;",
          "8212:     if (STRNCMP(p, \"in\", 2) != 0 || !IS_WHITE_OR_NUL(p[2]))",
          "8213:     {",
          "8214:  if (*p == ':' && wp != p)",
          "8215:      semsg(_(e_no_white_space_allowed_before_colon_str), p);",
          "8216:  else",
          "8217:      emsg(_(e_missing_in));",
          "8218:  return NULL;",
          "8219:     }",
          "8220:     wp = p + 2;",
          "8221:     if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "8222:  return NULL;",
          "8226:     if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0",
          "8227:      && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "8228:        .isn_type == ISN_DEBUG)",
          "8229:     {",
          "8230:  --instr->ga_len;",
          "8231:  prev_lnum = ((isn_T *)instr->ga_data)[instr->ga_len]",
          "8232:        .isn_arg.debug.dbg_break_lnum;",
          "8235:     scope = new_scope(cctx, FOR_SCOPE);",
          "8236:     if (scope == NULL)",
          "8237:  return NULL;",
          "8241:     loop_lvar = reserve_local(cctx, (char_u *)\"\", 0, FALSE, &t_number);",
          "8242:     if (loop_lvar == NULL)",
          "8245:  drop_scope(cctx);",
          "8246:  return NULL;",
          "8248:     generate_STORENR(cctx, loop_lvar->lv_idx, -1);",
          "8251:     arg = p;",
          "8252:     if (compile_expr0(&arg, cctx) == FAIL)",
          "8254:  drop_scope(cctx);",
          "8255:  return NULL;",
          "8257:     arg_end = arg;",
          "8259:     if (cctx->ctx_skip != SKIP_YES)",
          "8263:  vartype = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "8264:  if (vartype->tt_type != VAR_LIST && vartype->tt_type != VAR_STRING",
          "8265:   && vartype->tt_type != VAR_BLOB && vartype->tt_type != VAR_ANY)",
          "8267:      semsg(_(e_for_loop_on_str_not_supported),",
          "8268:             vartype_name(vartype->tt_type));",
          "8269:      drop_scope(cctx);",
          "8270:      return NULL;",
          "8273:  if (vartype->tt_type == VAR_STRING)",
          "8274:      item_type = &t_string;",
          "8275:  else if (vartype->tt_type == VAR_BLOB)",
          "8276:      item_type = &t_number;",
          "8277:  else if (vartype->tt_type == VAR_LIST",
          "8278:          && vartype->tt_member->tt_type != VAR_ANY)",
          "8280:      if (!var_list)",
          "8281:   item_type = vartype->tt_member;",
          "8282:      else if (vartype->tt_member->tt_type == VAR_LIST",
          "8283:      && vartype->tt_member->tt_member->tt_type != VAR_ANY)",
          "8284:   item_type = vartype->tt_member->tt_member;",
          "8288:  generate_undo_cmdmods(cctx);",
          "8291:  scope->se_u.se_for.fs_top_label = current_instr_idx(cctx);",
          "8293:  generate_FOR(cctx, loop_lvar->lv_idx);",
          "8295:  arg = arg_start;",
          "8296:  if (var_list)",
          "8298:      generate_UNPACK(cctx, var_count, semicolon);",
          "8299:      arg = skipwhite(arg + 1); // skip white after '['",
          "8302:      if (GA_GROW_FAILS(stack, var_count - 1))",
          "8303:      {",
          "8304:   drop_scope(cctx);",
          "8305:   return NULL;",
          "8306:      }",
          "8307:      --stack->ga_len;",
          "8308:      for (idx = 0; idx < var_count; ++idx)",
          "8309:      {",
          "8310:   ((type_T **)stack->ga_data)[stack->ga_len] =",
          "8311:      (semicolon && idx == 0) ? vartype : item_type;",
          "8312:   ++stack->ga_len;",
          "8313:      }",
          "8316:  for (idx = 0; idx < var_count; ++idx)",
          "8318:      assign_dest_T dest = dest_local;",
          "8319:      int   opt_flags = 0;",
          "8320:      int   vimvaridx = -1;",
          "8321:      type_T  *type = &t_any;",
          "8322:      type_T  *lhs_type = &t_any;",
          "8323:      where_T  where = WHERE_INIT;",
          "8325:      p = skip_var_one(arg, FALSE);",
          "8326:      varlen = p - arg;",
          "8327:      name = vim_strnsave(arg, varlen);",
          "8328:      if (name == NULL)",
          "8329:   goto failed;",
          "8330:      if (*p == ':')",
          "8331:      {",
          "8332:   p = skipwhite(p + 1);",
          "8333:   lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);",
          "8334:      }",
          "8336:      if (get_var_dest(name, &dest, CMD_for, &opt_flags,",
          "8337:            &vimvaridx, &type, cctx) == FAIL)",
          "8338:   goto failed;",
          "8339:      if (dest != dest_local)",
          "8340:      {",
          "8341:   if (generate_store_var(cctx, dest, opt_flags, vimvaridx,",
          "8342:            0, 0, type, name) == FAIL)",
          "8343:       goto failed;",
          "8344:      }",
          "8345:      else if (varlen == 1 && *arg == '_')",
          "8346:      {",
          "8348:   if (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)",
          "8349:       goto failed;",
          "8350:      }",
          "8351:      else",
          "8354:   if (STRNCMP(name, \"s:\", 2) == 0)",
          "8355:   {",
          "8356:       emsg(_(e_cannot_use_script_variable_in_for_loop));",
          "8357:       goto failed;",
          "8358:   }",
          "8360:   if (!valid_varname(arg, (int)varlen, FALSE))",
          "8361:       goto failed;",
          "8362:   if (lookup_local(arg, varlen, NULL, cctx) == OK)",
          "8363:   {",
          "8364:       semsg(_(e_variable_already_declared), arg);",
          "8365:       goto failed;",
          "8366:   }",
          "8369:   where.wt_index = var_list ? idx + 1 : 0;",
          "8370:   where.wt_variable = TRUE;",
          "8371:   if (lhs_type == &t_any)",
          "8372:       lhs_type = item_type;",
          "8373:   else if (item_type != &t_unknown",
          "8374:        && (item_type == &t_any",
          "8375:          ? need_type(item_type, lhs_type,",
          "8376:            -1, 0, cctx, FALSE, FALSE)",
          "8377:          : check_type(lhs_type, item_type, TRUE, where))",
          "8378:        == FAIL)",
          "8379:       goto failed;",
          "8380:   var_lvar = reserve_local(cctx, arg, varlen, TRUE, lhs_type);",
          "8381:   if (var_lvar == NULL)",
          "8383:       goto failed;",
          "8385:   if (semicolon && idx == var_count - 1)",
          "8386:       var_lvar->lv_type = vartype;",
          "8387:   else",
          "8388:       var_lvar->lv_type = item_type;",
          "8389:   generate_STORE(cctx, ISN_STORE, var_lvar->lv_idx, NULL);",
          "8392:      if (*p == ',' || *p == ';')",
          "8393:   ++p;",
          "8394:      arg = skipwhite(p);",
          "8395:      vim_free(name);",
          "8398:  if (cctx->ctx_compile_type == CT_DEBUG)",
          "8400:      int save_prev_lnum = cctx->ctx_prev_lnum;",
          "8404:      cctx->ctx_prev_lnum = prev_lnum;",
          "8405:      generate_instr_debug(cctx);",
          "8406:      cctx->ctx_prev_lnum = save_prev_lnum;",
          "8408:     }",
          "8410:     return arg_end;",
          "8412: failed:",
          "8413:     vim_free(name);",
          "8414:     drop_scope(cctx);",
          "8415:     return NULL;",
          "8416: }",
          "8421:     static char_u *",
          "8422: compile_endfor(char_u *arg, cctx_T *cctx)",
          "8423: {",
          "8424:     garray_T *instr = &cctx->ctx_instr;",
          "8425:     scope_T *scope = cctx->ctx_scope;",
          "8426:     forscope_T *forscope;",
          "8427:     isn_T *isn;",
          "8429:     if (misplaced_cmdmod(cctx))",
          "8430:  return NULL;",
          "8432:     if (scope == NULL || scope->se_type != FOR_SCOPE)",
          "8433:     {",
          "8434:  emsg(_(e_for));",
          "8435:  return NULL;",
          "8436:     }",
          "8437:     forscope = &scope->se_u.se_for;",
          "8438:     cctx->ctx_scope = scope->se_outer;",
          "8439:     if (cctx->ctx_skip != SKIP_YES)",
          "8440:     {",
          "8441:  unwind_locals(cctx, scope->se_local_count);",
          "8444:  generate_JUMP(cctx, JUMP_ALWAYS, forscope->fs_top_label);",
          "8447:  isn = ((isn_T *)instr->ga_data) + forscope->fs_top_label;",
          "8448:  isn->isn_arg.forloop.for_end = instr->ga_len;",
          "8451:  compile_fill_jump_to_end(&forscope->fs_end_label, instr->ga_len, cctx);",
          "8454:  if (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)",
          "8455:      return NULL;",
          "8458:     vim_free(scope);",
          "8460:     return arg;",
          "8474:     static char_u *",
          "8475: compile_while(char_u *arg, cctx_T *cctx)",
          "8477:     char_u *p = arg;",
          "8478:     scope_T *scope;",
          "8480:     scope = new_scope(cctx, WHILE_SCOPE);",
          "8481:     if (scope == NULL)",
          "8482:  return NULL;",
          "8485:     scope->se_u.se_while.ws_top_label = current_instr_idx(cctx);",
          "8488:     if (compile_expr0(&p, cctx) == FAIL)",
          "8489:  return NULL;",
          "8491:     if (!ends_excmd2(arg, skipwhite(p)))",
          "8493:  semsg(_(e_trailing_arg), p);",
          "8494:  return NULL;",
          "8497:     if (cctx->ctx_skip != SKIP_YES)",
          "8499:  if (bool_on_stack(cctx) == FAIL)",
          "8500:      return FAIL;",
          "8503:  generate_undo_cmdmods(cctx);",
          "8506:  if (compile_jump_to_end(&scope->se_u.se_while.ws_end_label,",
          "8507:         JUMP_IF_FALSE, cctx) == FAIL)",
          "8508:      return FAIL;",
          "8511:     return p;",
          "8517:     static char_u *",
          "8518: compile_endwhile(char_u *arg, cctx_T *cctx)",
          "8520:     scope_T *scope = cctx->ctx_scope;",
          "8521:     garray_T *instr = &cctx->ctx_instr;",
          "8523:     if (misplaced_cmdmod(cctx))",
          "8524:  return NULL;",
          "8525:     if (scope == NULL || scope->se_type != WHILE_SCOPE)",
          "8526:     {",
          "8527:  emsg(_(e_while));",
          "8528:  return NULL;",
          "8529:     }",
          "8530:     cctx->ctx_scope = scope->se_outer;",
          "8531:     if (cctx->ctx_skip != SKIP_YES)",
          "8532:     {",
          "8533:  unwind_locals(cctx, scope->se_local_count);",
          "8535: #ifdef FEAT_PROFILE",
          "8537:  may_generate_prof_end(cctx, cctx->ctx_lnum);",
          "8538: #endif",
          "8541:  generate_JUMP(cctx, JUMP_ALWAYS, scope->se_u.se_while.ws_top_label);",
          "8545:  compile_fill_jump_to_end(&scope->se_u.se_while.ws_end_label,",
          "8546:          instr->ga_len, cctx);",
          "8547:     }",
          "8549:     vim_free(scope);",
          "8551:     return arg;",
          "8557:     static char_u *",
          "8558: compile_continue(char_u *arg, cctx_T *cctx)",
          "8560:     scope_T *scope = cctx->ctx_scope;",
          "8561:     int  try_scopes = 0;",
          "8562:     int  loop_label;",
          "8564:     for (;;)",
          "8566:  if (scope == NULL)",
          "8568:      emsg(_(e_continue));",
          "8569:      return NULL;",
          "8571:  if (scope->se_type == FOR_SCOPE)",
          "8573:      loop_label = scope->se_u.se_for.fs_top_label;",
          "8574:      break;",
          "8576:  if (scope->se_type == WHILE_SCOPE)",
          "8578:      loop_label = scope->se_u.se_while.ws_top_label;",
          "8579:      break;",
          "8581:  if (scope->se_type == TRY_SCOPE)",
          "8582:      ++try_scopes;",
          "8583:  scope = scope->se_outer;",
          "8586:     if (try_scopes > 0)",
          "8589:  generate_TRYCONT(cctx, try_scopes, loop_label);",
          "8590:     else",
          "8592:  generate_JUMP(cctx, JUMP_ALWAYS, loop_label);",
          "8594:     return arg;",
          "8600:     static char_u *",
          "8601: compile_break(char_u *arg, cctx_T *cctx)",
          "8603:     scope_T *scope = cctx->ctx_scope;",
          "8604:     endlabel_T **el;",
          "8606:     for (;;)",
          "8608:  if (scope == NULL)",
          "8610:      emsg(_(e_break));",
          "8611:      return NULL;",
          "8613:  if (scope->se_type == FOR_SCOPE || scope->se_type == WHILE_SCOPE)",
          "8614:      break;",
          "8615:  scope = scope->se_outer;",
          "8616:     }",
          "8619:     if (scope->se_type == FOR_SCOPE)",
          "8620:  el = &scope->se_u.se_for.fs_end_label;",
          "8622:  el = &scope->se_u.se_while.ws_end_label;",
          "8623:     if (compile_jump_to_end(el, JUMP_ALWAYS, cctx) == FAIL)",
          "8624:  return FAIL;",
          "8626:     return arg;",
          "8627: }",
          "8632:     static char_u *",
          "8633: compile_block(char_u *arg, cctx_T *cctx)",
          "8634: {",
          "8635:     if (new_scope(cctx, BLOCK_SCOPE) == NULL)",
          "8636:  return NULL;",
          "8637:     return skipwhite(arg + 1);",
          "8638: }",
          "8643:     static void",
          "8644: compile_endblock(cctx_T *cctx)",
          "8645: {",
          "8646:     scope_T *scope = cctx->ctx_scope;",
          "8648:     cctx->ctx_scope = scope->se_outer;",
          "8649:     unwind_locals(cctx, scope->se_local_count);",
          "8650:     vim_free(scope);",
          "8685:     static char_u *",
          "8686: compile_try(char_u *arg, cctx_T *cctx)",
          "8688:     garray_T *instr = &cctx->ctx_instr;",
          "8689:     scope_T *try_scope;",
          "8690:     scope_T *scope;",
          "8692:     if (misplaced_cmdmod(cctx))",
          "8693:  return NULL;",
          "8696:     try_scope = new_scope(cctx, TRY_SCOPE);",
          "8697:     if (try_scope == NULL)",
          "8698:  return NULL;",
          "8700:     if (cctx->ctx_skip != SKIP_YES)",
          "8702:  isn_T *isn;",
          "8708:  try_scope->se_u.se_try.ts_try_label = instr->ga_len;",
          "8709:  if ((isn = generate_instr(cctx, ISN_TRY)) == NULL)",
          "8710:      return NULL;",
          "8711:  isn->isn_arg.try.try_ref = ALLOC_CLEAR_ONE(tryref_T);",
          "8712:  if (isn->isn_arg.try.try_ref == NULL)",
          "8713:      return NULL;",
          "8714:     }",
          "8717:     scope = new_scope(cctx, BLOCK_SCOPE);",
          "8718:     if (scope == NULL)",
          "8719:  return NULL;",
          "8721:     return arg;",
          "8727:     static char_u *",
          "8728: compile_catch(char_u *arg, cctx_T *cctx UNUSED)",
          "8730:     scope_T *scope = cctx->ctx_scope;",
          "8731:     garray_T *instr = &cctx->ctx_instr;",
          "8732:     char_u *p;",
          "8733:     isn_T *isn;",
          "8735:     if (misplaced_cmdmod(cctx))",
          "8736:  return NULL;",
          "8739:     if (scope != NULL && scope->se_type == BLOCK_SCOPE)",
          "8740:  compile_endblock(cctx);",
          "8741:     scope = cctx->ctx_scope;",
          "8744:     if (scope == NULL || scope->se_type != TRY_SCOPE)",
          "8745:     {",
          "8746:  emsg(_(e_catch));",
          "8747:  return NULL;",
          "8748:     }",
          "8750:     if (scope->se_u.se_try.ts_caught_all)",
          "8751:     {",
          "8752:  emsg(_(e_catch_unreachable_after_catch_all));",
          "8753:  return NULL;",
          "8754:     }",
          "8756:     if (cctx->ctx_skip != SKIP_YES)",
          "8758: #ifdef FEAT_PROFILE",
          "8760:  if (cctx->ctx_compile_type == CT_PROFILE",
          "8761:   && instr->ga_len > 0",
          "8762:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "8763:          .isn_type == ISN_PROF_START)",
          "8764:      --instr->ga_len;",
          "8765: #endif",
          "8767:  if (compile_jump_to_end(&scope->se_u.se_try.ts_end_label,",
          "8768:           JUMP_ALWAYS, cctx) == FAIL)",
          "8769:      return NULL;",
          "8772:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;",
          "8773:  if (isn->isn_arg.try.try_ref->try_catch == 0)",
          "8774:      isn->isn_arg.try.try_ref->try_catch = instr->ga_len;",
          "8775:  if (scope->se_u.se_try.ts_catch_label != 0)",
          "8776:  {",
          "8778:      isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;",
          "8779:      isn->isn_arg.jump.jump_where = instr->ga_len;",
          "8780:  }",
          "8781: #ifdef FEAT_PROFILE",
          "8782:  if (cctx->ctx_compile_type == CT_PROFILE)",
          "8783:  {",
          "8785:      generate_instr(cctx, ISN_PROF_END);",
          "8787:      generate_instr(cctx, ISN_PROF_START);",
          "8788:  }",
          "8789: #endif",
          "8790:  if (cctx->ctx_compile_type == CT_DEBUG)",
          "8791:      generate_instr_debug(cctx);",
          "8794:     p = skipwhite(arg);",
          "8795:     if (ends_excmd2(arg, p))",
          "8797:  scope->se_u.se_try.ts_caught_all = TRUE;",
          "8798:  scope->se_u.se_try.ts_catch_label = 0;",
          "8802:  char_u *end;",
          "8803:  char_u *pat;",
          "8804:  char_u *tofree = NULL;",
          "8805:  int dropped = 0;",
          "8806:  int len;",
          "8809:  generate_instr_type(cctx, ISN_PUSHEXC, &t_string);",
          "8811:  end = skip_regexp_ex(p + 1, *p, TRUE, &tofree, &dropped, NULL);",
          "8812:  if (*end != *p)",
          "8814:      semsg(_(e_separator_mismatch_str), p);",
          "8815:      vim_free(tofree);",
          "8818:  if (tofree == NULL)",
          "8819:      len = (int)(end - (p + 1));",
          "8820:  else",
          "8821:      len = (int)(end - tofree);",
          "8822:  pat = vim_strnsave(tofree == NULL ? p + 1 : tofree, len);",
          "8823:  vim_free(tofree);",
          "8824:  p += len + 2 + dropped;",
          "8825:  if (pat == NULL)",
          "8826:      return FAIL;",
          "8827:  if (generate_PUSHS(cctx, &pat) == FAIL)",
          "8830:  if (generate_COMPARE(cctx, EXPR_MATCH, FALSE) == FAIL)",
          "8831:      return NULL;",
          "8833:  scope->se_u.se_try.ts_catch_label = instr->ga_len;",
          "8834:  if (generate_JUMP(cctx, JUMP_IF_FALSE, 0) == FAIL)",
          "8835:      return NULL;",
          "8836:     }",
          "8838:     if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_CATCH) == NULL)",
          "8839:  return NULL;",
          "8841:     if (new_scope(cctx, BLOCK_SCOPE) == NULL)",
          "8842:  return NULL;",
          "8843:     return p;",
          "8844: }",
          "8846:     static char_u *",
          "8847: compile_finally(char_u *arg, cctx_T *cctx)",
          "8848: {",
          "8849:     scope_T *scope = cctx->ctx_scope;",
          "8850:     garray_T *instr = &cctx->ctx_instr;",
          "8851:     isn_T *isn;",
          "8852:     int  this_instr;",
          "8854:     if (misplaced_cmdmod(cctx))",
          "8855:  return NULL;",
          "8858:     if (scope != NULL && scope->se_type == BLOCK_SCOPE)",
          "8859:  compile_endblock(cctx);",
          "8860:     scope = cctx->ctx_scope;",
          "8863:     if (scope == NULL || scope->se_type != TRY_SCOPE)",
          "8864:     {",
          "8865:  emsg(_(e_finally));",
          "8866:  return NULL;",
          "8867:     }",
          "8869:     if (cctx->ctx_skip != SKIP_YES)",
          "8870:     {",
          "8872:  isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;",
          "8873:  if (isn->isn_arg.try.try_ref->try_finally != 0)",
          "8874:  {",
          "8875:      emsg(_(e_finally_dup));",
          "8876:      return NULL;",
          "8877:  }",
          "8879:  this_instr = instr->ga_len;",
          "8880: #ifdef FEAT_PROFILE",
          "8881:  if (cctx->ctx_compile_type == CT_PROFILE",
          "8882:   && ((isn_T *)instr->ga_data)[this_instr - 1]",
          "8883:          .isn_type == ISN_PROF_START)",
          "8884:  {",
          "8886:      --this_instr;",
          "8889:      if (this_instr > 0 && ((isn_T *)instr->ga_data)[this_instr - 1]",
          "8890:            .isn_type == ISN_PROF_END)",
          "8891:   --this_instr;",
          "8892:  }",
          "8893: #endif",
          "8896:  compile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,",
          "8897:             this_instr, cctx);",
          "8900:  if (isn->isn_arg.try.try_ref->try_catch == 0)",
          "8901:      isn->isn_arg.try.try_ref->try_catch = this_instr;",
          "8902:  isn->isn_arg.try.try_ref->try_finally = this_instr;",
          "8903:  if (scope->se_u.se_try.ts_catch_label != 0)",
          "8906:      isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;",
          "8907:      isn->isn_arg.jump.jump_where = this_instr;",
          "8908:      scope->se_u.se_try.ts_catch_label = 0;",
          "8909:  }",
          "8910:  if (generate_instr(cctx, ISN_FINALLY) == NULL)",
          "8911:      return NULL;",
          "8912:     }",
          "8914:     return arg;",
          "8915: }",
          "8917:     static char_u *",
          "8918: compile_endtry(char_u *arg, cctx_T *cctx)",
          "8919: {",
          "8920:     scope_T *scope = cctx->ctx_scope;",
          "8921:     garray_T *instr = &cctx->ctx_instr;",
          "8922:     isn_T *try_isn;",
          "8924:     if (misplaced_cmdmod(cctx))",
          "8925:  return NULL;",
          "8928:     if (scope != NULL && scope->se_type == BLOCK_SCOPE)",
          "8929:  compile_endblock(cctx);",
          "8930:     scope = cctx->ctx_scope;",
          "8933:     if (scope == NULL || scope->se_type != TRY_SCOPE)",
          "8934:     {",
          "8935:  if (scope == NULL)",
          "8936:      emsg(_(e_no_endtry));",
          "8937:  else if (scope->se_type == WHILE_SCOPE)",
          "8938:      emsg(_(e_endwhile));",
          "8939:  else if (scope->se_type == FOR_SCOPE)",
          "8940:      emsg(_(e_endfor));",
          "8941:  else",
          "8942:      emsg(_(e_endif));",
          "8943:  return NULL;",
          "8946:     try_isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;",
          "8947:     if (cctx->ctx_skip != SKIP_YES)",
          "8949:  if (try_isn->isn_arg.try.try_ref->try_catch == 0",
          "8950:           && try_isn->isn_arg.try.try_ref->try_finally == 0)",
          "8952:      emsg(_(e_missing_catch_or_finally));",
          "8953:      return NULL;",
          "8954:  }",
          "8956: #ifdef FEAT_PROFILE",
          "8957:  if (cctx->ctx_compile_type == CT_PROFILE",
          "8958:   && ((isn_T *)instr->ga_data)[instr->ga_len - 1]",
          "8959:       .isn_type == ISN_PROF_START)",
          "8962:      --instr->ga_len;",
          "8963: #endif",
          "8967:  compile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,",
          "8968:          instr->ga_len, cctx);",
          "8970:  if (scope->se_u.se_try.ts_catch_label != 0)",
          "8973:      isn_T *isn = ((isn_T *)instr->ga_data)",
          "8974:         + scope->se_u.se_try.ts_catch_label;",
          "8975:      isn->isn_arg.jump.jump_where = instr->ga_len;",
          "8979:     compile_endblock(cctx);",
          "8981:     if (cctx->ctx_skip != SKIP_YES)",
          "8985:  try_isn->isn_arg.try.try_ref->try_endtry = instr->ga_len;",
          "8986:  if (cctx->ctx_skip != SKIP_YES",
          "8987:        && generate_instr(cctx, ISN_ENDTRY) == NULL)",
          "8988:      return NULL;",
          "8989: #ifdef FEAT_PROFILE",
          "8990:  if (cctx->ctx_compile_type == CT_PROFILE)",
          "8991:      generate_instr(cctx, ISN_PROF_START);",
          "8992: #endif",
          "8994:     return arg;",
          "9001: compile_throw(char_u *arg, cctx_T *cctx UNUSED)",
          "9003:     char_u *p = skipwhite(arg);",
          "9005:     if (compile_expr0(&p, cctx) == FAIL)",
          "9006:  return NULL;",
          "9007:     if (cctx->ctx_skip == SKIP_YES)",
          "9008:  return p;",
          "9009:     if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "9010:  return NULL;",
          "9011:     if (generate_instr_drop(cctx, ISN_THROW, 1) == NULL)",
          "9012:  return NULL;",
          "9014:     return p;",
          "9015: }",
          "9017:     static char_u *",
          "9018: compile_eval(char_u *arg, cctx_T *cctx)",
          "9019: {",
          "9020:     char_u *p = arg;",
          "9021:     int  name_only;",
          "9022:     long lnum = SOURCING_LNUM;",
          "9027:     name_only = cmd_is_name_only(arg);",
          "9029:     if (compile_expr0(&p, cctx) == FAIL)",
          "9030:  return NULL;",
          "9032:     if (name_only && lnum == SOURCING_LNUM)",
          "9034:  semsg(_(e_expression_without_effect_str), arg);",
          "9039:     generate_instr_drop(cctx, ISN_DROP, 1);",
          "9041:     return skipwhite(p);",
          "9042: }",
          "9051:     static char_u *",
          "9052: compile_mult_expr(char_u *arg, int cmdidx, cctx_T *cctx)",
          "9053: {",
          "9054:     char_u *p = arg;",
          "9055:     char_u *prev = arg;",
          "9056:     char_u *expr_start;",
          "9057:     int  count = 0;",
          "9058:     int  start_ctx_lnum = cctx->ctx_lnum;",
          "9059:     garray_T *stack = &cctx->ctx_type_stack;",
          "9060:     type_T *type;",
          "9062:     for (;;)",
          "9064:  if (ends_excmd2(prev, p))",
          "9065:      break;",
          "9066:  expr_start = p;",
          "9067:  if (compile_expr0(&p, cctx) == FAIL)",
          "9073:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "9074:      if (type->tt_type == VAR_VOID)",
          "9076:   semsg(_(e_expression_does_not_result_in_value_str), expr_start);",
          "9077:   return NULL;",
          "9081:  ++count;",
          "9082:  prev = p;",
          "9083:  p = skipwhite(p);",
          "9086:     if (count > 0)",
          "9088:  long save_lnum = cctx->ctx_lnum;",
          "9091:  cctx->ctx_lnum = start_ctx_lnum;",
          "9093:  if (cmdidx == CMD_echo || cmdidx == CMD_echon)",
          "9094:      generate_ECHO(cctx, cmdidx == CMD_echo, count);",
          "9095:  else if (cmdidx == CMD_execute)",
          "9096:      generate_MULT_EXPR(cctx, ISN_EXECUTE, count);",
          "9097:  else if (cmdidx == CMD_echomsg)",
          "9098:      generate_MULT_EXPR(cctx, ISN_ECHOMSG, count);",
          "9099:  else if (cmdidx == CMD_echoconsole)",
          "9100:      generate_MULT_EXPR(cctx, ISN_ECHOCONSOLE, count);",
          "9101:  else",
          "9102:      generate_MULT_EXPR(cctx, ISN_ECHOERR, count);",
          "9104:  cctx->ctx_lnum = save_lnum;",
          "9105:     }",
          "9106:     return p;",
          "9107: }",
          "9114:     static int",
          "9115: compile_variable_range(exarg_T *eap, cctx_T *cctx)",
          "9116: {",
          "9117:     char_u *range_end = skip_range(eap->cmd, TRUE, NULL);",
          "9118:     char_u *p = skipdigits(eap->cmd);",
          "9120:     if (p == range_end)",
          "9121:  return FAIL;",
          "9122:     return generate_RANGE(cctx, vim_strnsave(eap->cmd, range_end - eap->cmd));",
          "9123: }",
          "9129:     static char_u *",
          "9130: compile_put(char_u *arg, exarg_T *eap, cctx_T *cctx)",
          "9131: {",
          "9132:     char_u *line = arg;",
          "9133:     linenr_T lnum;",
          "9134:     char *errormsg;",
          "9135:     int  above = eap->forceit;",
          "9137:     eap->regname = *line;",
          "9139:     if (eap->regname == '=')",
          "9140:     {",
          "9141:  char_u *p = line + 1;",
          "9145:  line = p;",
          "9146:     }",
          "9147:     else if (eap->regname != NUL)",
          "9148:  ++line;",
          "9150:     if (compile_variable_range(eap, cctx) == OK)",
          "9151:     {",
          "9152:  lnum = above ? LNUM_VARIABLE_RANGE_ABOVE : LNUM_VARIABLE_RANGE;",
          "9153:     }",
          "9154:     else",
          "9155:     {",
          "9158:  if (parse_cmd_address(eap, &errormsg, FALSE) == FAIL)",
          "9160:      return NULL;",
          "9161:  if (eap->addr_count == 0)",
          "9162:      lnum = -1;",
          "9163:  else",
          "9164:      lnum = eap->line2;",
          "9165:  if (above)",
          "9166:      --lnum;",
          "9167:     }",
          "9169:     generate_PUT(cctx, eap->regname, lnum);",
          "9170:     return line;",
          "9171: }",
          "9176:     static char_u *",
          "9177: compile_exec(char_u *line_arg, exarg_T *eap, cctx_T *cctx)",
          "9178: {",
          "9179:     char_u *line = line_arg;",
          "9180:     char_u *p;",
          "9181:     int  has_expr = FALSE;",
          "9182:     char_u *nextcmd = (char_u *)\"\";",
          "9183:     char_u *tofree = NULL;",
          "9184:     char_u *cmd_arg = NULL;",
          "9186:     if (cctx->ctx_skip == SKIP_YES)",
          "9187:  goto theend;",
          "9191:     if (cctx->ctx_has_cmdmod)",
          "9192:     {",
          "9193:  garray_T *instr = &cctx->ctx_instr;",
          "9194:  isn_T  *isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "9196:  if (isn->isn_type == ISN_CMDMOD)",
          "9197:  {",
          "9198:      vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod",
          "9199:             ->cmod_filter_regmatch.regprog);",
          "9200:      vim_free(isn->isn_arg.cmdmod.cf_cmdmod);",
          "9201:      --instr->ga_len;",
          "9202:      cctx->ctx_has_cmdmod = FALSE;",
          "9206:     if (eap->cmdidx >= 0 && eap->cmdidx < CMD_SIZE)",
          "9208:  long argt = eap->argt;",
          "9209:  int usefilter = FALSE;",
          "9211:  has_expr = argt & (EX_XFILE | EX_EXPAND);",
          "9216:  if ((eap->cmdidx == CMD_write || eap->cmdidx == CMD_read)",
          "9217:           && *eap->arg == '!')",
          "9219:      usefilter = TRUE;",
          "9220:  if ((argt & EX_TRLBAR) && !usefilter)",
          "9221:  {",
          "9222:      eap->argt = argt;",
          "9223:      separate_nextcmd(eap);",
          "9224:      if (eap->nextcmd != NULL)",
          "9225:   nextcmd = eap->nextcmd;",
          "9226:  }",
          "9227:  else if (eap->cmdidx == CMD_wincmd)",
          "9229:      p = eap->arg;",
          "9230:      if (*p != NUL)",
          "9231:   ++p;",
          "9232:      if (*p == 'g' || *p == Ctrl_G)",
          "9233:   ++p;",
          "9234:      p = skipwhite(p);",
          "9235:      if (*p == '|')",
          "9238:   nextcmd = p + 1;",
          "9241:  else if (eap->cmdidx == CMD_command || eap->cmdidx == CMD_autocmd)",
          "9244:      p = eap->arg + STRLEN(eap->arg) - 1;",
          "9245:      while (p > eap->arg && VIM_ISWHITE(*p))",
          "9246:   --p;",
          "9247:      if (*p == '{')",
          "9249:   exarg_T ea;",
          "9250:   int flags;  // unused",
          "9251:   int start_lnum = SOURCING_LNUM;",
          "9253:   CLEAR_FIELD(ea);",
          "9254:   ea.arg = eap->arg;",
          "9255:   fill_exarg_from_cctx(&ea, cctx);",
          "9256:   (void)may_get_cmd_block(&ea, p, &tofree, &flags);",
          "9257:   if (tofree != NULL)",
          "9260:       line = concat_str(line, tofree);",
          "9261:       if (line == NULL)",
          "9262:    goto theend;",
          "9263:       vim_free(tofree);",
          "9264:       tofree = line;",
          "9265:       SOURCING_LNUM = start_lnum;",
          "9268:  }",
          "9269:     }",
          "9271:     if (eap->cmdidx == CMD_syntax && STRNCMP(eap->arg, \"include \", 8) == 0)",
          "9272:     {",
          "9274:  has_expr = TRUE;",
          "9275:  eap->arg = skipwhite(eap->arg + 7);",
          "9276:  if (*eap->arg == '@')",
          "9277:      eap->arg = skiptowhite(eap->arg);",
          "9278:     }",
          "9280:     if ((eap->cmdidx == CMD_global || eap->cmdidx == CMD_vglobal)",
          "9281:              && STRLEN(eap->arg) > 4)",
          "9282:     {",
          "9283:  int delim = *eap->arg;",
          "9285:  p = skip_regexp_ex(eap->arg + 1, delim, TRUE, NULL, NULL, NULL);",
          "9286:  if (*p == delim)",
          "9287:      cmd_arg = p + 1;",
          "9288:     }",
          "9290:     if (eap->cmdidx == CMD_folddoopen || eap->cmdidx == CMD_folddoclosed)",
          "9291:  cmd_arg = eap->arg;",
          "9293:     if (cmd_arg != NULL)",
          "9294:     {",
          "9295:  exarg_T nea;",
          "9297:  CLEAR_FIELD(nea);",
          "9298:  nea.cmd = cmd_arg;",
          "9299:  p = find_ex_command(&nea, NULL, lookup_scriptitem, NULL);",
          "9300:  if (nea.cmdidx < CMD_SIZE)",
          "9301:  {",
          "9302:      has_expr = excmd_get_argt(nea.cmdidx) & (EX_XFILE | EX_EXPAND);",
          "9303:      if (has_expr)",
          "9304:   eap->arg = skiptowhite(eap->arg);",
          "9305:  }",
          "9306:     }",
          "9308:     if (has_expr && (p = (char_u *)strstr((char *)eap->arg, \"`=\")) != NULL)",
          "9309:     {",
          "9310:  int count = 0;",
          "9311:  char_u *start = skipwhite(line);",
          "9320:  for (;;)",
          "9321:  {",
          "9322:      if (p > start)",
          "9324:   char_u *val = vim_strnsave(start, p - start);",
          "9326:   generate_PUSHS(cctx, &val);",
          "9327:   ++count;",
          "9329:      p += 2;",
          "9330:      if (compile_expr0(&p, cctx) == FAIL)",
          "9331:   return NULL;",
          "9332:      may_generate_2STRING(-1, TRUE, cctx);",
          "9333:      ++count;",
          "9334:      p = skipwhite(p);",
          "9335:      if (*p != '`')",
          "9337:   emsg(_(e_missing_backtick));",
          "9338:   return NULL;",
          "9340:      start = p + 1;",
          "9342:      p = (char_u *)strstr((char *)start, \"`=\");",
          "9343:      if (p == NULL)",
          "9345:   if (*skipwhite(start) != NUL)",
          "9347:       char_u *val = vim_strsave(start);",
          "9349:       generate_PUSHS(cctx, &val);",
          "9350:       ++count;",
          "9352:   break;",
          "9355:  generate_EXECCONCAT(cctx, count);",
          "9356:     }",
          "9357:     else",
          "9358:  generate_EXEC_copy(cctx, ISN_EXEC, line);",
          "9360: theend:",
          "9361:     if (*nextcmd != NUL)",
          "9362:     {",
          "9364:  --nextcmd;",
          "9366:     }",
          "9367:     vim_free(tofree);",
          "9369:     return nextcmd;",
          "9370: }",
          "9381:     static char_u *",
          "9382: compile_script(char_u *line, cctx_T *cctx)",
          "9383: {",
          "9384:     if (cctx->ctx_skip != SKIP_YES)",
          "9385:     {",
          "9386:  isn_T *isn;",
          "9388:  if ((isn = generate_instr(cctx, ISN_EXEC_SPLIT)) == NULL)",
          "9389:      return NULL;",
          "9390:  isn->isn_arg.string = vim_strsave(line);",
          "9391:     }",
          "9392:     return (char_u *)\"\";",
          "9393: }",
          "9399:     static char_u *",
          "9400: compile_substitute(char_u *arg, exarg_T *eap, cctx_T *cctx)",
          "9401: {",
          "9402:     char_u  *cmd = eap->arg;",
          "9403:     char_u  *expr = (char_u *)strstr((char *)cmd, \"\\\\=\");",
          "9405:     if (expr != NULL)",
          "9406:     {",
          "9407:  int delimiter = *cmd++;",
          "9410:  cmd = skip_regexp_ex(cmd, delimiter, magic_isset(), NULL, NULL, NULL);",
          "9411:  if (cmd[0] == delimiter && cmd[1] == '\\\\' && cmd[2] == '=')",
          "9413:      garray_T save_ga = cctx->ctx_instr;",
          "9414:      char_u *end;",
          "9415:      int  expr_res;",
          "9416:      int  trailing_error;",
          "9417:      int  instr_count;",
          "9418:      isn_T *instr;",
          "9419:      isn_T *isn;",
          "9421:      cmd += 3;",
          "9422:      end = skip_substitute(cmd, delimiter);",
          "9426:      cctx->ctx_instr.ga_len = 0;",
          "9427:      cctx->ctx_instr.ga_maxlen = 0;",
          "9428:      cctx->ctx_instr.ga_data = NULL;",
          "9429:      expr_res = compile_expr0(&cmd, cctx);",
          "9430:      if (end[-1] == NUL)",
          "9431:   end[-1] = delimiter;",
          "9432:      cmd = skipwhite(cmd);",
          "9433:      trailing_error = *cmd != delimiter && *cmd != NUL;",
          "9435:      if (expr_res == FAIL || trailing_error",
          "9436:            || GA_GROW_FAILS(&cctx->ctx_instr, 1))",
          "9438:   if (trailing_error)",
          "9439:       semsg(_(e_trailing_arg), cmd);",
          "9440:   clear_instr_ga(&cctx->ctx_instr);",
          "9441:   cctx->ctx_instr = save_ga;",
          "9442:   return NULL;",
          "9448:      instr_count = cctx->ctx_instr.ga_len;",
          "9449:      instr = cctx->ctx_instr.ga_data;",
          "9450:      instr[instr_count].isn_type = ISN_FINISH;",
          "9452:      cctx->ctx_instr = save_ga;",
          "9453:      if ((isn = generate_instr(cctx, ISN_SUBSTITUTE)) == NULL)",
          "9455:   int idx;",
          "9457:   for (idx = 0; idx < instr_count; ++idx)",
          "9458:       delete_instr(instr + idx);",
          "9459:   vim_free(instr);",
          "9460:   return NULL;",
          "9462:      isn->isn_arg.subs.subs_cmd = vim_strsave(arg);",
          "9463:      isn->isn_arg.subs.subs_instr = instr;",
          "9466:      if (*end == '&')",
          "9467:   ++end;",
          "9468:      while (ASCII_ISALPHA(*end) || *end == '#')",
          "9469:   ++end;",
          "9470:      return end;",
          "9472:     }",
          "9474:     return compile_exec(arg, eap, cctx);",
          "9475: }",
          "9477:     static char_u *",
          "9478: compile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)",
          "9479: {",
          "9480:     char_u  *arg = eap->arg;",
          "9481:     lhs_T   *lhs = &cctx->ctx_redir_lhs;",
          "9483:     if (lhs->lhs_name != NULL)",
          "9484:     {",
          "9485:  if (STRNCMP(arg, \"END\", 3) == 0)",
          "9487:      if (lhs->lhs_append)",
          "9490:   if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,",
          "9491:          cctx) == FAIL)",
          "9492:       return NULL;",
          "9497:      generate_instr_type(cctx, ISN_REDIREND, &t_string);",
          "9499:      if (lhs->lhs_append)",
          "9500:   generate_instr_drop(cctx, ISN_CONCAT, 1);",
          "9502:      if (lhs->lhs_has_index)",
          "9506:   if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,",
          "9507:             &t_string, cctx) == FAIL)",
          "9508:       return NULL;",
          "9510:      else if (generate_store_lhs(cctx, lhs, -1) == FAIL)",
          "9511:   return NULL;",
          "9513:      VIM_CLEAR(lhs->lhs_name);",
          "9514:      VIM_CLEAR(lhs->lhs_whole);",
          "9515:      return arg + 3;",
          "9517:  emsg(_(e_cannot_nest_redir));",
          "9518:  return NULL;",
          "9521:     if (arg[0] == '=' && arg[1] == '>')",
          "9523:  int     append = FALSE;",
          "9526:  arg += 2;",
          "9527:  if (*arg == '>')",
          "9528:  {",
          "9529:      ++arg;",
          "9530:      append = TRUE;",
          "9531:  }",
          "9532:  arg = skipwhite(arg);",
          "9534:  if (compile_assign_lhs(arg, lhs, CMD_redir,",
          "9535:       FALSE, FALSE, 1, cctx) == FAIL)",
          "9536:      return NULL;",
          "9537:  if (need_type(&t_string, lhs->lhs_member_type,",
          "9538:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "9539:      return NULL;",
          "9540:  generate_instr(cctx, ISN_REDIRSTART);",
          "9541:  lhs->lhs_append = append;",
          "9542:  if (lhs->lhs_has_index)",
          "9543:  {",
          "9544:      lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);",
          "9545:      if (lhs->lhs_whole == NULL)",
          "9546:   return NULL;",
          "9547:  }",
          "9549:  return arg + lhs->lhs_varlen_total;",
          "9553:     return compile_exec(line, eap, cctx);",
          "9554: }",
          "9556: #ifdef FEAT_QUICKFIX",
          "9557:     static char_u *",
          "9558: compile_cexpr(char_u *line, exarg_T *eap, cctx_T *cctx)",
          "9559: {",
          "9560:     isn_T *isn;",
          "9561:     char_u *p;",
          "9563:     isn = generate_instr(cctx, ISN_CEXPR_AUCMD);",
          "9564:     if (isn == NULL)",
          "9565:  return NULL;",
          "9566:     isn->isn_arg.number = eap->cmdidx;",
          "9568:     p = eap->arg;",
          "9569:     if (compile_expr0(&p, cctx) == FAIL)",
          "9570:  return NULL;",
          "9572:     isn = generate_instr(cctx, ISN_CEXPR_CORE);",
          "9573:     if (isn == NULL)",
          "9574:  return NULL;",
          "9575:     isn->isn_arg.cexpr.cexpr_ref = ALLOC_ONE(cexprref_T);",
          "9576:     if (isn->isn_arg.cexpr.cexpr_ref == NULL)",
          "9577:  return NULL;",
          "9578:     isn->isn_arg.cexpr.cexpr_ref->cer_cmdidx = eap->cmdidx;",
          "9579:     isn->isn_arg.cexpr.cexpr_ref->cer_forceit = eap->forceit;",
          "9580:     isn->isn_arg.cexpr.cexpr_ref->cer_cmdline = vim_strsave(skipwhite(line));",
          "9582:     return p;",
          "9584: #endif",
          "9589:     int",
          "9590: check_global_and_subst(char_u *cmd, char_u *arg)",
          "9592:     if (arg == cmd + 1 && vim_strchr((char_u *)\":-.\", *arg) != NULL)",
          "9594:  semsg(_(e_separator_not_supported_str), arg);",
          "9595:  return FAIL;",
          "9597:     if (VIM_ISWHITE(cmd[1]))",
          "9599:  semsg(_(e_no_white_space_allowed_before_separator_str), cmd);",
          "9600:  return FAIL;",
          "9602:     return OK;",
          "",
          "[Added Lines]",
          "448:     lvar_T *",
          "449: reserve_local(",
          "450:  cctx_T *cctx,",
          "451:  char_u *name,",
          "452:  size_t len,",
          "453:  int isConst,",
          "454:  type_T *type)",
          "456:     lvar_T  *lvar;",
          "457:     dfunc_T *dfunc;",
          "459:     if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)",
          "460:     {",
          "461:  emsg_namelen(_(e_str_is_used_as_argument), name, (int)len);",
          "462:  return NULL;",
          "463:     }",
          "465:     if (GA_GROW_FAILS(&cctx->ctx_locals, 1))",
          "466:  return NULL;",
          "467:     lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;",
          "468:     CLEAR_POINTER(lvar);",
          "474:     dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;",
          "475:     lvar->lv_idx = dfunc->df_var_names.ga_len;",
          "477:     lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);",
          "478:     lvar->lv_const = isConst;",
          "479:     lvar->lv_type = type;",
          "482:     if (GA_GROW_FAILS(&dfunc->df_var_names, 1))",
          "483:  return NULL;",
          "484:     ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =",
          "485:           vim_strsave(lvar->lv_name);",
          "486:     ++dfunc->df_var_names.ga_len;",
          "488:     return lvar;",
          "497: check_item_writable(svar_T *sv, int check_writable, char_u *name)",
          "499:     if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)",
          "500:      || (check_writable == ASSIGN_FINAL",
          "501:            && sv->sv_const == ASSIGN_CONST))",
          "502:     {",
          "503:  semsg(_(e_cannot_change_readonly_variable_str), name);",
          "505:     }",
          "516:     int",
          "517: get_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx)",
          "519:     hashtab_T     *ht;",
          "520:     dictitem_T     *di;",
          "521:     scriptitem_T    *si = SCRIPT_ITEM(sid);",
          "522:     svar_T     *sv;",
          "523:     int      idx;",
          "525:     if (!SCRIPT_ID_VALID(sid))",
          "526:  return -1;",
          "527:     if (sid == current_sctx.sc_sid)",
          "528:     {",
          "529:  sallvar_T *sav = find_script_var(name, 0, cctx);",
          "531:  if (sav == NULL)",
          "532:      return -2;",
          "533:  idx = sav->sav_var_vals_idx;",
          "534:  sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;",
          "535:  if (check_item_writable(sv, check_writable, name) == FAIL)",
          "536:      return -2;",
          "537:  return idx;",
          "538:     }",
          "541:     ht = &SCRIPT_VARS(sid);",
          "542:     di = find_var_in_ht(ht, 0, name, TRUE);",
          "543:     if (di == NULL)",
          "544:  return -2;",
          "547:     for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)",
          "548:     {",
          "549:  sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;",
          "550:  if (sv->sv_tv == &di->di_tv)",
          "551:  {",
          "552:      if (check_item_writable(sv, check_writable, name) == FAIL)",
          "553:   return -2;",
          "554:      return idx;",
          "555:  }",
          "556:     }",
          "557:     return -1;",
          "564:     imported_T *",
          "565: find_imported(char_u *name, size_t len, cctx_T *cctx)",
          "567:     int      idx;",
          "569:     if (!SCRIPT_ID_VALID(current_sctx.sc_sid))",
          "570:  return NULL;",
          "571:     if (cctx != NULL)",
          "572:  for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)",
          "573:  {",
          "574:      imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data)",
          "575:           + idx;",
          "577:      if (len == 0 ? STRCMP(name, import->imp_name) == 0",
          "578:     : STRLEN(import->imp_name) == len",
          "579:       && STRNCMP(name, import->imp_name, len) == 0)",
          "580:   return import;",
          "581:  }",
          "583:     return find_imported_in_script(name, len, current_sctx.sc_sid);",
          "586:     imported_T *",
          "587: find_imported_in_script(char_u *name, size_t len, int sid)",
          "589:     scriptitem_T    *si;",
          "590:     int      idx;",
          "592:     if (!SCRIPT_ID_VALID(sid))",
          "593:  return NULL;",
          "594:     si = SCRIPT_ITEM(sid);",
          "595:     for (idx = 0; idx < si->sn_imports.ga_len; ++idx)",
          "597:  imported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;",
          "599:  if (len == 0 ? STRCMP(name, import->imp_name) == 0",
          "600:        : STRLEN(import->imp_name) == len",
          "601:       && STRNCMP(name, import->imp_name, len) == 0)",
          "602:      return import;",
          "603:     }",
          "604:     return NULL;",
          "610:     static void",
          "611: free_imported(cctx_T *cctx)",
          "613:     int idx;",
          "615:     for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)",
          "616:     {",
          "617:  imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data) + idx;",
          "619:  vim_free(import->imp_name);",
          "620:     }",
          "621:     ga_clear(&cctx->ctx_imports);",
          "630:     char_u *",
          "631: may_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)",
          "633:     char_u *p = skipwhite(arg);",
          "636:     if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))",
          "637:     {",
          "639:  if (*nextp != NULL)",
          "640:      return *nextp;",
          "641:     }",
          "642:     return p;",
          "650:     char_u *",
          "651: peek_next_line_from_context(cctx_T *cctx)",
          "653:     int lnum = cctx->ctx_lnum;",
          "655:     while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)",
          "656:     {",
          "657:  char_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];",
          "658:  char_u *p;",
          "661:  if (line != NULL)",
          "662:  {",
          "663:      p = skipwhite(line);",
          "664:      if (vim9_bad_comment(p))",
          "665:   return NULL;",
          "666:      if (*p != NUL && !vim9_comment_start(p))",
          "667:   return p;",
          "668:  }",
          "669:     }",
          "670:     return NULL;",
          "678:     char_u *",
          "679: next_line_from_context(cctx_T *cctx, int skip_comment)",
          "681:     char_u *line;",
          "683:     do",
          "685:  ++cctx->ctx_lnum;",
          "686:  if (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)",
          "688:      line = NULL;",
          "689:      break;",
          "691:  line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];",
          "692:  cctx->ctx_line_start = line;",
          "693:  SOURCING_LNUM = cctx->ctx_lnum + 1;",
          "694:     } while (line == NULL || *skipwhite(line) == NUL",
          "695:        || (skip_comment && vim9_comment_start(skipwhite(line))));",
          "696:     return line;",
          "705:     int",
          "706: may_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)",
          "709:     if (vim9_bad_comment(*arg))",
          "711:     if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))",
          "712:     {",
          "713:  char_u *next = next_line_from_context(cctx, TRUE);",
          "715:  if (next == NULL)",
          "716:      return FAIL;",
          "718:     }",
          "725:     int",
          "726: may_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)",
          "728:     if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "729:     {",
          "730:  SOURCING_LNUM = cctx->ctx_lnum + 1;",
          "731:  emsg(_(e_line_incomplete));",
          "733:     }",
          "742:     static char_u *",
          "743: exarg_getline(",
          "744:  int c UNUSED,",
          "745:  void *cookie,",
          "746:  int indent UNUSED,",
          "747:  getline_opt_T options UNUSED)",
          "749:     cctx_T  *cctx = (cctx_T *)cookie;",
          "750:     char_u  *p;",
          "752:     for (;;)",
          "753:     {",
          "754:  if (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)",
          "755:      return NULL;",
          "756:  ++cctx->ctx_lnum;",
          "757:  p = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];",
          "759:  if (p != NULL)",
          "760:      return vim_strsave(p);",
          "761:     }",
          "762: }",
          "764:     void",
          "765: fill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)",
          "766: {",
          "767:     eap->getline = exarg_getline;",
          "768:     eap->cookie = cctx;",
          "775:     int",
          "776: func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)",
          "778:     switch (ufunc->uf_def_status)",
          "779:     {",
          "780:  case UF_TO_BE_COMPILED:",
          "781:      return TRUE;",
          "783:  case UF_COMPILED:",
          "784:  {",
          "785:      dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "786:         + ufunc->uf_dfunc_idx;",
          "788:      switch (compile_type)",
          "789:      {",
          "790:   case CT_PROFILE:",
          "791: #ifdef FEAT_PROFILE",
          "792:       return dfunc->df_instr_prof == NULL;",
          "793: #endif",
          "794:   case CT_NONE:",
          "795:       return dfunc->df_instr == NULL;",
          "796:   case CT_DEBUG:",
          "797:       return dfunc->df_instr_debug == NULL;",
          "798:      }",
          "799:  }",
          "801:  case UF_NOT_COMPILED:",
          "802:  case UF_COMPILE_ERROR:",
          "803:  case UF_COMPILING:",
          "804:      break;",
          "805:     }",
          "806:     return FALSE;",
          "812:     static char_u *",
          "813: compile_nested_function(exarg_T *eap, cctx_T *cctx)",
          "815:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
          "816:     char_u *name_start = eap->arg;",
          "817:     char_u *name_end = to_name_end(eap->arg, TRUE);",
          "818:     char_u *lambda_name;",
          "819:     ufunc_T *ufunc;",
          "820:     int  r = FAIL;",
          "821:     compiletype_T   compile_type;",
          "823:     if (eap->forceit)",
          "824:     {",
          "825:  emsg(_(e_cannot_use_bang_with_nested_def));",
          "826:  return NULL;",
          "827:     }",
          "829:     if (*name_start == '/')",
          "830:     {",
          "831:  name_end = skip_regexp(name_start + 1, '/', TRUE);",
          "832:  if (*name_end == '/')",
          "833:      ++name_end;",
          "834:  set_nextcmd(eap, name_end);",
          "835:     }",
          "836:     if (name_end == name_start || *skipwhite(name_end) != '(')",
          "837:     {",
          "838:  if (!ends_excmd2(name_start, name_end))",
          "839:  {",
          "840:      semsg(_(e_invalid_command_str), eap->cmd);",
          "841:      return NULL;",
          "842:  }",
          "845:  if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)",
          "846:      return NULL;",
          "847:  return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;",
          "848:     }",
          "851:     if (name_start[1] == ':' && !is_global)",
          "852:     {",
          "853:  semsg(_(e_namespace_not_supported_str), name_start);",
          "854:  return NULL;",
          "855:     }",
          "856:     if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)",
          "857:  return NULL;",
          "859:     eap->arg = name_end;",
          "860:     fill_exarg_from_cctx(eap, cctx);",
          "862:     eap->forceit = FALSE;",
          "864:     lambda_name = vim_strsave(get_lambda_name());",
          "865:     if (lambda_name == NULL)",
          "866:  return NULL;",
          "867:     ufunc = define_function(eap, lambda_name);",
          "869:     if (ufunc == NULL)",
          "871:  r = eap->skip ? OK : FAIL;",
          "872:  goto theend;",
          "876:     if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)",
          "877:     {",
          "878:  int block_depth = cctx->ctx_ufunc->uf_block_depth;",
          "880:  ufunc->uf_block_ids = ALLOC_MULT(int, block_depth);",
          "881:  if (ufunc->uf_block_ids != NULL)",
          "882:  {",
          "883:      mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,",
          "884:           sizeof(int) * block_depth);",
          "885:      ufunc->uf_block_depth = block_depth;",
          "886:  }",
          "887:     }",
          "889:     compile_type = COMPILE_TYPE(ufunc);",
          "890: #ifdef FEAT_PROFILE",
          "893:     if (cctx->ctx_compile_type == CT_PROFILE)",
          "894:  compile_type = CT_PROFILE;",
          "895: #endif",
          "896:     if (func_needs_compiling(ufunc, compile_type)",
          "897:      && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)",
          "898:     {",
          "899:  func_ptr_unref(ufunc);",
          "900:  goto theend;",
          "901:     }",
          "903: #ifdef FEAT_PROFILE",
          "906:     if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))",
          "907:  compile_def_function(ufunc, FALSE, CT_NONE, cctx);",
          "908: #endif",
          "910:     if (is_global)",
          "911:     {",
          "912:  char_u *func_name = vim_strnsave(name_start + 2,",
          "913:           name_end - name_start - 2);",
          "915:  if (func_name == NULL)",
          "916:      r = FAIL;",
          "917:  else",
          "918:  {",
          "919:      r = generate_NEWFUNC(cctx, lambda_name, func_name);",
          "920:      lambda_name = NULL;",
          "921:  }",
          "922:     }",
          "924:     {",
          "926:  lvar_T *lvar = reserve_local(cctx, name_start, name_end - name_start,",
          "927:           TRUE, ufunc->uf_func_type);",
          "929:  if (lvar == NULL)",
          "930:      goto theend;",
          "931:  if (generate_FUNCREF(cctx, ufunc) == FAIL)",
          "932:      goto theend;",
          "933:  r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);",
          "934:     }",
          "936: theend:",
          "937:     vim_free(lambda_name);",
          "938:     return r == FAIL ? NULL : (char_u *)\"\";",
          "944:     int",
          "945: assignment_len(char_u *p, int *heredoc)",
          "947:     if (*p == '=')",
          "948:     {",
          "949:  if (p[1] == '<' && p[2] == '<')",
          "950:  {",
          "952:      return 3;",
          "953:  }",
          "954:  return 1;",
          "955:     }",
          "956:     if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')",
          "957:  return 2;",
          "958:     if (STRNCMP(p, \"..=\", 3) == 0)",
          "959:  return 3;",
          "960:     return 0;",
          "966:     static void",
          "967: generate_loadvar(",
          "968:  cctx_T  *cctx,",
          "969:  assign_dest_T dest,",
          "970:  char_u  *name,",
          "971:  lvar_T  *lvar,",
          "972:  type_T  *type)",
          "973: {",
          "974:     switch (dest)",
          "975:     {",
          "976:  case dest_option:",
          "977:  case dest_func_option:",
          "978:      generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);",
          "979:      break;",
          "980:  case dest_global:",
          "981:      if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)",
          "982:   generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);",
          "983:      else",
          "984:   generate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);",
          "985:      break;",
          "986:  case dest_buffer:",
          "987:      generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);",
          "988:      break;",
          "989:  case dest_window:",
          "990:      generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);",
          "991:      break;",
          "992:  case dest_tab:",
          "993:      generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);",
          "994:      break;",
          "995:  case dest_script:",
          "996:      compile_load_scriptvar(cctx,",
          "997:       name + (name[1] == ':' ? 2 : 0), NULL, NULL, TRUE);",
          "998:      break;",
          "999:  case dest_env:",
          "1001:      generate_LOAD(cctx, ISN_LOADENV, 0, name, type);",
          "1002:      break;",
          "1003:  case dest_reg:",
          "1004:      generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);",
          "1005:      break;",
          "1006:  case dest_vimvar:",
          "1007:      generate_LOADV(cctx, name + 2, TRUE);",
          "1008:      break;",
          "1009:  case dest_local:",
          "1010:      if (lvar->lv_from_outer > 0)",
          "1011:   generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,",
          "1012:           type);",
          "1013:      else",
          "1014:   generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);",
          "1015:      break;",
          "1016:  case dest_expr:",
          "1018:      break;",
          "1019:     }",
          "1026:     static char_u *",
          "1027: skip_index(char_u *start)",
          "1029:     char_u *p = start;",
          "1031:     if (*p == '[')",
          "1032:     {",
          "1033:  p = skipwhite(p + 1);",
          "1034:  (void)skip_expr(&p, NULL);",
          "1035:  p = skipwhite(p);",
          "1036:  if (*p == ']')",
          "1037:      return p + 1;",
          "1038:  return p;",
          "1039:     }",
          "1041:     return to_name_end(p + 1, TRUE);",
          "1044:     void",
          "1045: vim9_declare_error(char_u *name)",
          "1047:     char *scope = \"\";",
          "1049:     switch (*name)",
          "1051:  case 'g': scope = _(\"global\"); break;",
          "1052:  case 'b': scope = _(\"buffer\"); break;",
          "1053:  case 'w': scope = _(\"window\"); break;",
          "1054:  case 't': scope = _(\"tab\"); break;",
          "1055:  case 'v': scope = \"v:\"; break;",
          "1056:  case '$': semsg(_(e_cannot_declare_an_environment_variable), name);",
          "1057:     return;",
          "1058:  case '&': semsg(_(e_cannot_declare_an_option), name);",
          "1059:     return;",
          "1060:  case '@': semsg(_(e_cannot_declare_a_register_str), name);",
          "1061:     return;",
          "1062:  default: return;",
          "1064:     semsg(_(e_cannot_declare_a_scope_variable), scope, name);",
          "1075:     int",
          "1076: get_var_dest(",
          "1077:  char_u  *name,",
          "1078:  assign_dest_T *dest,",
          "1079:  int  cmdidx,",
          "1080:  int  *option_scope,",
          "1081:  int  *vimvaridx,",
          "1082:  type_T  **type,",
          "1083:  cctx_T  *cctx)",
          "1085:     char_u *p;",
          "1087:     if (*name == '&')",
          "1088:     {",
          "1089:  int  cc;",
          "1090:  long  numval;",
          "1091:  getoption_T opt_type;",
          "1092:  int  opt_p_flags;",
          "1095:  if (cmdidx == CMD_final || cmdidx == CMD_const)",
          "1096:  {",
          "1097:      emsg(_(e_const_option));",
          "1098:      return FAIL;",
          "1099:  }",
          "1100:  p = name;",
          "1101:  p = find_option_end(&p, option_scope);",
          "1102:  if (p == NULL)",
          "1103:  {",
          "1105:      emsg(_(e_unexpected_characters_in_assignment));",
          "1106:      return FAIL;",
          "1107:  }",
          "1108:  cc = *p;",
          "1110:  opt_type = get_option_value(skip_option_env_lead(name),",
          "1111:        &numval, NULL, &opt_p_flags, *option_scope);",
          "1113:  switch (opt_type)",
          "1114:  {",
          "1115:      case gov_unknown:",
          "1116:       semsg(_(e_unknown_option_str), name);",
          "1117:       return FAIL;",
          "1118:      case gov_string:",
          "1119:      case gov_hidden_string:",
          "1120:       if (opt_p_flags & P_FUNC)",
          "1121:       {",
          "1125:       }",
          "1126:       else",
          "1127:       {",
          "1129:       }",
          "1130:       break;",
          "1131:      case gov_bool:",
          "1132:      case gov_hidden_bool:",
          "1134:       break;",
          "1135:      case gov_number:",
          "1136:      case gov_hidden_number:",
          "1138:       break;",
          "1139:  }",
          "1140:     }",
          "1141:     else if (*name == '$')",
          "1142:     {",
          "1145:     }",
          "1146:     else if (*name == '@')",
          "1147:     {",
          "1148:  if (name[1] != '@'",
          "1149:    && (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))",
          "1150:  {",
          "1151:      emsg_invreg(name[1]);",
          "1152:      return FAIL;",
          "1153:  }",
          "1156:     }",
          "1157:     else if (STRNCMP(name, \"g:\", 2) == 0)",
          "1158:     {",
          "1160:     }",
          "1161:     else if (STRNCMP(name, \"b:\", 2) == 0)",
          "1162:     {",
          "1164:     }",
          "1165:     else if (STRNCMP(name, \"w:\", 2) == 0)",
          "1166:     {",
          "1168:     }",
          "1169:     else if (STRNCMP(name, \"t:\", 2) == 0)",
          "1170:     {",
          "1172:     }",
          "1173:     else if (STRNCMP(name, \"v:\", 2) == 0)",
          "1175:  typval_T *vtv;",
          "1176:  int  di_flags;",
          "1179:  if (*vimvaridx < 0)",
          "1180:  {",
          "1181:      semsg(_(e_variable_not_found_str), name);",
          "1183:  }",
          "1185:  if (var_check_ro(di_flags, name, FALSE))",
          "1186:      return FAIL;",
          "1188:  vtv = get_vim_var_tv(*vimvaridx);",
          "1195: is_decl_command(int cmdidx)",
          "1197:     return cmdidx == CMD_let || cmdidx == CMD_var",
          "1198:      || cmdidx == CMD_final || cmdidx == CMD_const;",
          "1206:     int",
          "1207: compile_lhs(",
          "1208:  char_u *var_start,",
          "1209:  lhs_T *lhs,",
          "1210:  int cmdidx,",
          "1211:  int heredoc,",
          "1212:  int oplen,",
          "1213:  cctx_T *cctx)",
          "1215:     char_u *var_end;",
          "1216:     int  is_decl = is_decl_command(cmdidx);",
          "1218:     CLEAR_POINTER(lhs);",
          "1219:     lhs->lhs_dest = dest_local;",
          "1220:     lhs->lhs_vimvaridx = -1;",
          "1221:     lhs->lhs_scriptvar_idx = -1;",
          "1226:     lhs->lhs_dest_end = skip_var_one(var_start, FALSE);",
          "1227:     if (*var_start == '@')",
          "1228:  var_end = var_start + 2;",
          "1229:     else",
          "1232:  var_end = skip_option_env_lead(var_start);",
          "1233:  var_end = to_name_end(var_end, TRUE);",
          "1237:     if (is_decl && lhs->lhs_dest_end == var_start + 2",
          "1238:             && lhs->lhs_dest_end[-1] == ':')",
          "1239:  --lhs->lhs_dest_end;",
          "1240:     if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')",
          "1241:  --var_end;",
          "1242:     lhs->lhs_end = lhs->lhs_dest_end;",
          "1245:     lhs->lhs_varlen = var_end - var_start;",
          "1246:     lhs->lhs_varlen_total = lhs->lhs_varlen;",
          "1247:     lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);",
          "1248:     if (lhs->lhs_name == NULL)",
          "1251:     if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)",
          "1253:  lhs->lhs_has_index = TRUE;",
          "1255:     if (heredoc)",
          "1256:  lhs->lhs_type = &t_list_string;",
          "1257:     else",
          "1258:  lhs->lhs_type = &t_any;",
          "1260:     if (cctx->ctx_skip != SKIP_YES)",
          "1262:  int     declare_error = FALSE;",
          "1264:  if (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,",
          "1265:           &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,",
          "1266:        &lhs->lhs_type, cctx) == FAIL)",
          "1267:      return FAIL;",
          "1268:  if (lhs->lhs_dest != dest_local",
          "1269:      && cmdidx != CMD_const && cmdidx != CMD_final)",
          "1272:      declare_error = is_decl;",
          "1274:  else",
          "1277:      if (check_reserved_name(lhs->lhs_name) == FAIL)",
          "1280:      if (lookup_local(var_start, lhs->lhs_varlen,",
          "1281:           &lhs->lhs_local_lvar, cctx) == OK)",
          "1282:   lhs->lhs_lvar = &lhs->lhs_local_lvar;",
          "1283:      else",
          "1285:   CLEAR_FIELD(lhs->lhs_arg_lvar);",
          "1286:   if (arg_exists(var_start, lhs->lhs_varlen,",
          "1287:     &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,",
          "1288:        &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)",
          "1289:   {",
          "1290:       if (is_decl)",
          "1291:       {",
          "1292:    semsg(_(e_str_is_used_as_argument), lhs->lhs_name);",
          "1293:    return FAIL;",
          "1294:       }",
          "1295:       lhs->lhs_lvar = &lhs->lhs_arg_lvar;",
          "1296:   }",
          "1298:      if (lhs->lhs_lvar != NULL)",
          "1300:   if (is_decl)",
          "1301:   {",
          "1302:       semsg(_(e_variable_already_declared), lhs->lhs_name);",
          "1303:       return FAIL;",
          "1304:   }",
          "1306:      else",
          "1308:   int script_namespace = lhs->lhs_varlen > 1",
          "1309:            && STRNCMP(var_start, \"s:\", 2) == 0;",
          "1310:   int script_var = (script_namespace",
          "1311:    ? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,",
          "1312:            cctx)",
          "1313:      : script_var_exists(var_start, lhs->lhs_varlen,",
          "1314:           cctx)) == OK;",
          "1315:   imported_T  *import =",
          "1316:           find_imported(var_start, lhs->lhs_varlen, cctx);",
          "1318:   if (script_namespace || script_var || import != NULL)",
          "1320:       char_u *rawname = lhs->lhs_name",
          "1321:         + (lhs->lhs_name[1] == ':' ? 2 : 0);",
          "1323:       if (is_decl)",
          "1325:    if (script_namespace)",
          "1326:        semsg(_(e_cannot_declare_script_variable_in_function),",
          "1327:         lhs->lhs_name);",
          "1328:    else",
          "1329:        semsg(_(e_variable_already_declared_in_script_str),",
          "1330:         lhs->lhs_name);",
          "1331:    return FAIL;",
          "1332:       }",
          "1333:       else if (cctx->ctx_ufunc->uf_script_ctx_version",
          "1334:         == SCRIPT_VERSION_VIM9",
          "1335:         && script_namespace",
          "1336:         && !script_var && import == NULL)",
          "1337:       {",
          "1338:    semsg(_(e_unknown_variable_str), lhs->lhs_name);",
          "1342:       lhs->lhs_dest = dest_script;",
          "1345:       lhs->lhs_scriptvar_sid = current_sctx.sc_sid;",
          "1346:       if (import != NULL)",
          "1347:    lhs->lhs_scriptvar_sid = import->imp_sid;",
          "1348:       if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))",
          "1349:       {",
          "1351:    lhs->lhs_scriptvar_idx = get_script_item_idx(",
          "1352:             lhs->lhs_scriptvar_sid, rawname,",
          "1353:          lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,",
          "1354:           cctx);",
          "1355:    if (lhs->lhs_scriptvar_idx >= 0)",
          "1356:    {",
          "1357:        scriptitem_T *si = SCRIPT_ITEM(",
          "1358:              lhs->lhs_scriptvar_sid);",
          "1359:        svar_T  *sv =",
          "1360:          ((svar_T *)si->sn_var_vals.ga_data)",
          "1361:             + lhs->lhs_scriptvar_idx;",
          "1362:        lhs->lhs_type = sv->sv_type;",
          "1363:    }",
          "1364:       }",
          "1365:   }",
          "1366:   else if (check_defined(var_start, lhs->lhs_varlen, cctx, FALSE)",
          "1367:                == FAIL)",
          "1368:       return FAIL;",
          "1369:      }",
          "1370:  }",
          "1372:  if (declare_error)",
          "1373:  {",
          "1374:      vim9_declare_error(lhs->lhs_name);",
          "1375:      return FAIL;",
          "1376:  }",
          "1380:     if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')",
          "1381:  var_end = lhs->lhs_dest_end;",
          "1383:     if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)",
          "1385:  if (is_decl && *var_end == ':')",
          "1386:  {",
          "1387:      char_u *p;",
          "1390:      if (!VIM_ISWHITE(var_end[1]))",
          "1391:      {",
          "1392:   semsg(_(e_white_space_required_after_str_str), \":\", var_end);",
          "1393:   return FAIL;",
          "1394:      }",
          "1395:      p = skipwhite(var_end + 1);",
          "1396:      lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);",
          "1397:      if (lhs->lhs_type == NULL)",
          "1398:   return FAIL;",
          "1399:      lhs->lhs_has_type = TRUE;",
          "1400:      lhs->lhs_end = p;",
          "1401:  }",
          "1402:  else if (lhs->lhs_lvar != NULL)",
          "1403:      lhs->lhs_type = lhs->lhs_lvar->lv_type;",
          "1406:     if (oplen == 3 && !heredoc",
          "1407:      && lhs->lhs_dest != dest_global",
          "1408:      && !lhs->lhs_has_index",
          "1409:      && lhs->lhs_type->tt_type != VAR_STRING",
          "1410:      && lhs->lhs_type->tt_type != VAR_ANY)",
          "1412:  emsg(_(e_can_only_concatenate_to_string));",
          "1413:  return FAIL;",
          "1416:     if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local",
          "1417:        && cctx->ctx_skip != SKIP_YES)",
          "1419:  if (oplen > 1 && !heredoc)",
          "1422:      semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);",
          "1423:      return FAIL;",
          "1425:  if (!is_decl)",
          "1427:      semsg(_(e_unknown_variable_str), lhs->lhs_name);",
          "1428:      return FAIL;",
          "1432:  if ((lhs->lhs_type->tt_type == VAR_FUNC",
          "1433:           || lhs->lhs_type->tt_type == VAR_PARTIAL)",
          "1434:   && var_wrong_func_name(lhs->lhs_name, TRUE))",
          "1435:      return FAIL;",
          "1438:  lhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,",
          "1439:       cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);",
          "1440:  if (lhs->lhs_lvar == NULL)",
          "1441:      return FAIL;",
          "1442:  lhs->lhs_new_local = TRUE;",
          "1443:     }",
          "1445:     lhs->lhs_member_type = lhs->lhs_type;",
          "1446:     if (lhs->lhs_has_index)",
          "1447:     {",
          "1448:  char_u *after = var_start + lhs->lhs_varlen;",
          "1449:  char_u *p;",
          "1452:  if (is_decl)",
          "1454:      emsg(_(e_cannot_use_index_when_declaring_variable));",
          "1455:      return FAIL;",
          "1462:  for (;;)",
          "1464:      p = skip_index(after);",
          "1465:      if (*p != '[' && *p != '.')",
          "1467:   lhs->lhs_varlen_total = p - var_start;",
          "1468:   break;",
          "1470:      after = p;",
          "1472:  if (after > var_start + lhs->lhs_varlen)",
          "1474:      lhs->lhs_varlen = after - var_start;",
          "1475:      lhs->lhs_dest = dest_expr;",
          "1478:      lhs->lhs_type = &t_any;",
          "1481:  if (lhs->lhs_type->tt_member == NULL)",
          "1482:      lhs->lhs_member_type = &t_any;",
          "1483:  else",
          "1484:      lhs->lhs_member_type = lhs->lhs_type->tt_member;",
          "1486:     return OK;",
          "1492:     int",
          "1493: compile_assign_lhs(",
          "1494:  char_u *var_start,",
          "1495:  lhs_T *lhs,",
          "1496:  int cmdidx,",
          "1497:  int is_decl,",
          "1498:  int heredoc,",
          "1499:  int oplen,",
          "1500:  cctx_T *cctx)",
          "1502:     if (compile_lhs(var_start, lhs, cmdidx, heredoc, oplen, cctx) == FAIL)",
          "1503:  return FAIL;",
          "1505:     if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)",
          "1507:  semsg(_(e_cannot_assign_to_argument), lhs->lhs_name);",
          "1508:  return FAIL;",
          "1510:     if (!is_decl && lhs->lhs_lvar != NULL",
          "1511:       && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)",
          "1513:  semsg(_(e_cannot_assign_to_constant), lhs->lhs_name);",
          "1514:  return FAIL;",
          "1516:     return OK;",
          "1522:     static int",
          "1523: has_list_index(char_u *idx_start, cctx_T *cctx)",
          "1525:     char_u  *p = idx_start;",
          "1526:     int     save_skip;",
          "1528:     if (*p != '[')",
          "1529:  return FALSE;",
          "1531:     p = skipwhite(p + 1);",
          "1532:     if (*p == ':')",
          "1533:  return TRUE;",
          "1535:     save_skip = cctx->ctx_skip;",
          "1536:     cctx->ctx_skip = SKIP_YES;",
          "1537:     (void)compile_expr0(&p, cctx);",
          "1538:     cctx->ctx_skip = save_skip;",
          "1539:     return *skipwhite(p) == ':';",
          "1546:     static int",
          "1547: compile_assign_index(",
          "1548:  char_u *var_start,",
          "1549:  lhs_T *lhs,",
          "1550:  int *range,",
          "1551:  cctx_T *cctx)",
          "1553:     size_t varlen = lhs->lhs_varlen;",
          "1554:     char_u *p;",
          "1555:     int  r = OK;",
          "1556:     int  need_white_before = TRUE;",
          "1557:     int  empty_second;",
          "1559:     p = var_start + varlen;",
          "1560:     if (*p == '[')",
          "1562:  p = skipwhite(p + 1);",
          "1563:  if (*p == ':')",
          "1566:      r = generate_PUSHNR(cctx, 0);",
          "1567:      need_white_before = FALSE;",
          "1569:  else",
          "1570:      r = compile_expr0(&p, cctx);",
          "1572:  if (r == OK && *skipwhite(p) == ':')",
          "1577:      p = skipwhite(p);",
          "1578:      empty_second = *skipwhite(p + 1) == ']';",
          "1579:      if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))",
          "1580:       || (!empty_second && !IS_WHITE_OR_NUL(p[1])))",
          "1581:      {",
          "1582:   semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "1583:               \":\", p);",
          "1584:   return FAIL;",
          "1585:      }",
          "1586:      p = skipwhite(p + 1);",
          "1587:      if (*p == ']')",
          "1589:   r = generate_PUSHSPEC(cctx, VVAL_NONE);",
          "1590:      else",
          "1591:   r = compile_expr0(&p, cctx);",
          "1594:  if (r == OK && *skipwhite(p) != ']')",
          "1597:      emsg(_(e_missing_closing_square_brace));",
          "1598:      r = FAIL;",
          "1601:     else // if (*p == '.')",
          "1602:     {",
          "1603:  char_u *key_end = to_name_end(p + 1, TRUE);",
          "1604:  char_u *key = vim_strnsave(p + 1, key_end - p - 1);",
          "1606:  r = generate_PUSHS(cctx, &key);",
          "1607:     }",
          "1608:     return r;",
          "1614:     static int",
          "1615: compile_load_lhs(",
          "1616:  lhs_T *lhs,",
          "1617:  char_u *var_start,",
          "1618:  type_T *rhs_type,",
          "1619:  cctx_T *cctx)",
          "1621:     if (lhs->lhs_dest == dest_expr)",
          "1623:  size_t     varlen = lhs->lhs_varlen;",
          "1624:  int     c = var_start[varlen];",
          "1625:  int     lines_len = cctx->ctx_ufunc->uf_lines.ga_len;",
          "1626:  char_u     *p = var_start;",
          "1627:  garray_T    *stack = &cctx->ctx_type_stack;",
          "1628:  int     res;",
          "1632:  var_start[varlen] = NUL;",
          "1633:  cctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;",
          "1634:  res = compile_expr0(&p, cctx);",
          "1635:  var_start[varlen] = c;",
          "1636:  cctx->ctx_ufunc->uf_lines.ga_len = lines_len;",
          "1637:  if (res == FAIL || p != var_start + varlen)",
          "1640:      if (res != FAIL)",
          "1641:   emsg(_(e_missing_closing_square_brace));",
          "1642:      return FAIL;",
          "1645:  lhs->lhs_type = stack->ga_len == 0 ? &t_void",
          "1646:          : ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1648:  if (rhs_type != NULL && lhs->lhs_type->tt_member != NULL",
          "1649:   && rhs_type != &t_void",
          "1650:   && need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,",
          "1651:         FALSE, FALSE) == FAIL)",
          "1652:      return FAIL;",
          "1653:     }",
          "1655:  generate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,",
          "1656:        lhs->lhs_lvar, lhs->lhs_type);",
          "1657:     return OK;",
          "1664:     int",
          "1665: compile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)",
          "1667:     compile_load_lhs(lhs, var_start, NULL, cctx);",
          "1669:     if (lhs->lhs_has_index)",
          "1671:  int range = FALSE;",
          "1675:  if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)",
          "1676:      return FAIL;",
          "1677:  if (range)",
          "1678:  {",
          "1679:      semsg(_(e_cannot_use_range_with_assignment_operator_str),",
          "1680:             var_start);",
          "1681:      return FAIL;",
          "1682:  }",
          "1685:  if (compile_member(FALSE, NULL, cctx) == FAIL)",
          "1686:      return FAIL;",
          "1687:     }",
          "1688:     return OK;",
          "1696:     int",
          "1697: compile_assign_unlet(",
          "1698:  char_u *var_start,",
          "1699:  lhs_T *lhs,",
          "1700:  int is_assign,",
          "1701:  type_T *rhs_type,",
          "1702:  cctx_T *cctx)",
          "1704:     vartype_T dest_type;",
          "1705:     garray_T    *stack = &cctx->ctx_type_stack;",
          "1706:     int  range = FALSE;",
          "1708:     if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)",
          "1709:  return FAIL;",
          "1710:     if (is_assign && range",
          "1711:      && lhs->lhs_type->tt_type != VAR_LIST",
          "1712:      && lhs->lhs_type != &t_blob",
          "1713:      && lhs->lhs_type != &t_any)",
          "1715:  semsg(_(e_cannot_use_range_with_assignment_str), var_start);",
          "1716:  return FAIL;",
          "1719:     if (lhs->lhs_type == &t_any)",
          "1722:  dest_type = VAR_ANY;",
          "1726:  dest_type = lhs->lhs_type->tt_type;",
          "1727:  if (dest_type == VAR_DICT && range)",
          "1729:      emsg(e_cannot_use_range_with_dictionary);",
          "1732:  if (dest_type == VAR_DICT",
          "1733:          && may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "1735:  if (dest_type == VAR_LIST || dest_type == VAR_BLOB)",
          "1737:      type_T *type;",
          "1739:      if (range)",
          "1740:      {",
          "1741:   type = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "1742:   if (need_type(type, &t_number,",
          "1743:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1744:   return FAIL;",
          "1745:      }",
          "1746:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1747:      if ((dest_type != VAR_BLOB && type != &t_special)",
          "1748:       && need_type(type, &t_number,",
          "1749:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1750:   return FAIL;",
          "1751:  }",
          "1759:     if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)",
          "1760:  return FAIL;",
          "1762:     if (dest_type == VAR_LIST || dest_type == VAR_DICT",
          "1763:          || dest_type == VAR_BLOB || dest_type == VAR_ANY)",
          "1765:  if (is_assign)",
          "1767:      if (range)",
          "1768:      {",
          "1769:   if (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)",
          "1770:       return FAIL;",
          "1771:      }",
          "1772:      else",
          "1773:      {",
          "1774:   isn_T *isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);",
          "1776:   if (isn == NULL)",
          "1777:       return FAIL;",
          "1778:   isn->isn_arg.vartype = dest_type;",
          "1779:      }",
          "1780:  }",
          "1781:  else if (range)",
          "1782:  {",
          "1783:      if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)",
          "1784:   return FAIL;",
          "1785:  }",
          "1786:  else",
          "1788:      if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)",
          "1789:   return FAIL;",
          "1792:     else",
          "1794:  emsg(_(e_indexable_type_required));",
          "1795:  return FAIL;",
          "1798:     return OK;",
          "1814: compile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)",
          "1816:     char_u *var_start;",
          "1817:     char_u *p;",
          "1818:     char_u *end = arg;",
          "1819:     char_u *ret = NULL;",
          "1820:     int  var_count = 0;",
          "1821:     int  var_idx;",
          "1822:     int  semicolon = 0;",
          "1823:     int  did_generate_slice = FALSE;",
          "1824:     garray_T *instr = &cctx->ctx_instr;",
          "1825:     garray_T    *stack = &cctx->ctx_type_stack;",
          "1826:     char_u *op;",
          "1827:     int  oplen = 0;",
          "1828:     int  heredoc = FALSE;",
          "1829:     int  incdec = FALSE;",
          "1830:     type_T *rhs_type = &t_any;",
          "1831:     char_u *sp;",
          "1832:     int  is_decl = is_decl_command(cmdidx);",
          "1833:     lhs_T lhs;",
          "1834:     long start_lnum = SOURCING_LNUM;",
          "1837:     p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);",
          "1838:     if (p == NULL)",
          "1839:  return *arg == '[' ? arg : NULL;",
          "1841:     lhs.lhs_name = NULL;",
          "1843:     sp = p;",
          "1844:     p = skipwhite(p);",
          "1845:     op = p;",
          "1846:     oplen = assignment_len(p, &heredoc);",
          "1848:     if (var_count > 0 && oplen == 0)",
          "1850:  return arg;",
          "1852:     if (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))",
          "1854:  error_white_both(op, oplen);",
          "1857:     if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)",
          "1858:     {",
          "1859:  if (VIM_ISWHITE(eap->cmd[2]))",
          "1860:  {",
          "1861:      semsg(_(e_no_white_space_allowed_after_str_str),",
          "1862:     eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);",
          "1863:      return NULL;",
          "1864:  }",
          "1865:  op = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");",
          "1866:  oplen = 2;",
          "1867:  incdec = TRUE;",
          "1868:     }",
          "1870:     if (heredoc)",
          "1872:  list_T    *l;",
          "1873:  listitem_T *li;",
          "1876:  eap->getline = exarg_getline;",
          "1877:  eap->cookie = cctx;",
          "1878:  l = heredoc_get(eap, op + 3, FALSE);",
          "1879:  if (l == NULL)",
          "1885:      FOR_ALL_LIST_ITEMS(l, li)",
          "1887:   generate_PUSHS(cctx, &li->li_tv.vval.v_string);",
          "1888:   li->li_tv.vval.v_string = NULL;",
          "1890:      generate_NEWLIST(cctx, l->lv_len);",
          "1892:  list_free(l);",
          "1893:  p += STRLEN(p);",
          "1894:  end = p;",
          "1896:     else if (var_count > 0)",
          "1898:  char_u *wp;",
          "1904:  wp = op + oplen;",
          "1905:  if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "1906:      return FAIL;",
          "1909:  end = p;",
          "1911:  if (cctx->ctx_skip != SKIP_YES)",
          "1912:  {",
          "1913:      type_T *stacktype;",
          "1914:      int  needed_list_len;",
          "1915:      int  did_check = FALSE;",
          "1917:      stacktype = stack->ga_len == 0 ? &t_void",
          "1918:          : ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1919:      if (stacktype->tt_type == VAR_VOID)",
          "1920:      {",
          "1921:   emsg(_(e_cannot_use_void_value));",
          "1922:   goto theend;",
          "1923:      }",
          "1924:      if (need_type(stacktype, &t_list_any, -1, 0, cctx,",
          "1925:         FALSE, FALSE) == FAIL)",
          "1926:   goto theend;",
          "1928:      needed_list_len = semicolon ? var_count - 1 : var_count;",
          "1929:      if (instr->ga_len > 0)",
          "1930:      {",
          "1931:   isn_T *isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "1933:   if (isn->isn_type == ISN_NEWLIST)",
          "1934:   {",
          "1935:       did_check = TRUE;",
          "1936:       if (semicolon ? isn->isn_arg.number < needed_list_len",
          "1937:        : isn->isn_arg.number != needed_list_len)",
          "1938:       {",
          "1939:    semsg(_(e_expected_nr_items_but_got_nr),",
          "1940:       needed_list_len, isn->isn_arg.number);",
          "1941:    goto theend;",
          "1942:       }",
          "1943:   }",
          "1944:      }",
          "1945:      if (!did_check)",
          "1946:   generate_CHECKLEN(cctx, needed_list_len, semicolon);",
          "1947:      if (stacktype->tt_member != NULL)",
          "1948:   rhs_type = stacktype->tt_member;",
          "1956:     if (var_count > 0)",
          "1957:  var_start = skipwhite(arg + 1);  // skip over the \"[\"",
          "1958:     else",
          "1959:  var_start = arg;",
          "1960:     for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)",
          "1962:  int instr_count = -1;",
          "1963:  int save_lnum;",
          "1965:  if (var_start[0] == '_' && !eval_isnamec(var_start[1]))",
          "1968:      if (var_count > 0)",
          "1970:   var_start = skipwhite(var_start + 2);",
          "1971:   continue;",
          "1973:      emsg(_(e_cannot_use_underscore_here));",
          "1974:      goto theend;",
          "1975:  }",
          "1976:  vim_free(lhs.lhs_name);",
          "1981:  if (compile_assign_lhs(var_start, &lhs, cmdidx,",
          "1982:      is_decl, heredoc, oplen, cctx) == FAIL)",
          "1983:      goto theend;",
          "1984:  if (heredoc)",
          "1985:  {",
          "1986:      SOURCING_LNUM = start_lnum;",
          "1987:      if (lhs.lhs_has_type",
          "1988:       && need_type(&t_list_string, lhs.lhs_type,",
          "1989:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1990:   goto theend;",
          "1992:  else",
          "1994:      if (cctx->ctx_skip == SKIP_YES)",
          "1996:   if (oplen > 0 && var_count == 0)",
          "1999:       p = skipwhite(op + oplen);",
          "2000:       (void)compile_expr0(&p, cctx);",
          "2003:      else if (oplen > 0)",
          "2004:      {",
          "2005:   int is_const = FALSE;",
          "2006:   char_u *wp;",
          "2009:   if (*op != '='",
          "2010:    && compile_load_lhs_with_index(&lhs, var_start,",
          "2011:          cctx) == FAIL)",
          "2012:       goto theend;",
          "2015:   if (var_count == 0)",
          "2016:   {",
          "2017:       int r;",
          "2020:       instr_count = instr->ga_len;",
          "2021:       if (incdec)",
          "2022:       {",
          "2023:    r = generate_PUSHNR(cctx, 1);",
          "2024:       }",
          "2025:       else",
          "2026:       {",
          "2029:    if (lhs.lhs_new_local)",
          "2030:        --cctx->ctx_locals.ga_len;",
          "2031:    wp = op + oplen;",
          "2032:    if (may_get_next_line_error(wp, &p, cctx) == FAIL)",
          "2033:    {",
          "2034:        if (lhs.lhs_new_local)",
          "2035:     ++cctx->ctx_locals.ga_len;",
          "2036:        goto theend;",
          "2037:    }",
          "2038:    r = compile_expr0_ext(&p, cctx, &is_const);",
          "2039:    if (lhs.lhs_new_local)",
          "2040:        ++cctx->ctx_locals.ga_len;",
          "2041:    if (r == FAIL)",
          "2042:        goto theend;",
          "2043:       }",
          "2044:   }",
          "2045:   else if (semicolon && var_idx == var_count - 1)",
          "2046:   {",
          "2048:       did_generate_slice = TRUE;",
          "2049:       if (generate_SLICE(cctx, var_count - 1) == FAIL)",
          "2050:    goto theend;",
          "2051:   }",
          "2052:   else",
          "2053:   {",
          "2056:       if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)",
          "2057:    goto theend;",
          "2058:   }",
          "2060:   rhs_type = stack->ga_len == 0 ? &t_void",
          "2061:          : ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "2062:   if (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))",
          "2063:   {",
          "2064:       if ((rhs_type->tt_type == VAR_FUNC",
          "2065:     || rhs_type->tt_type == VAR_PARTIAL)",
          "2066:        && !lhs.lhs_has_index",
          "2067:        && var_wrong_func_name(lhs.lhs_name, TRUE))",
          "2068:    goto theend;",
          "2070:       if (lhs.lhs_new_local && !lhs.lhs_has_type)",
          "2071:       {",
          "2072:    if (rhs_type->tt_type == VAR_VOID)",
          "2073:    {",
          "2074:        emsg(_(e_cannot_use_void_value));",
          "2075:        goto theend;",
          "2076:    }",
          "2077:    else",
          "2078:    {",
          "2081:        if (rhs_type == &t_list_empty)",
          "2082:     lhs.lhs_lvar->lv_type = &t_list_any;",
          "2083:        else if (rhs_type == &t_dict_empty)",
          "2084:     lhs.lhs_lvar->lv_type = &t_dict_any;",
          "2085:        else if (rhs_type == &t_unknown)",
          "2086:     lhs.lhs_lvar->lv_type = &t_any;",
          "2087:        else",
          "2088:     lhs.lhs_lvar->lv_type = rhs_type;",
          "2089:    }",
          "2090:       }",
          "2091:       else if (*op == '=')",
          "2092:       {",
          "2093:    type_T *use_type = lhs.lhs_lvar->lv_type;",
          "2094:    where_T where = WHERE_INIT;",
          "2098:    SOURCING_LNUM = start_lnum;",
          "2099:    where.wt_index = var_count > 0 ? var_idx + 1 : 0;",
          "2100:    where.wt_variable = var_count > 0;",
          "2103:    if (lhs.lhs_has_index",
          "2104:     && !has_list_index(var_start + lhs.lhs_varlen,",
          "2105:           cctx))",
          "2106:        use_type = lhs.lhs_member_type;",
          "2107:    if (need_type_where(rhs_type, use_type, -1, where,",
          "2108:         cctx, FALSE, is_const) == FAIL)",
          "2109:        goto theend;",
          "2110:       }",
          "2111:   }",
          "2112:   else",
          "2113:   {",
          "2114:       type_T *lhs_type = lhs.lhs_member_type;",
          "2119:       if ((lhs_type == &t_number_or_string",
          "2120:     || lhs_type == &t_float)",
          "2121:        && rhs_type->tt_type == VAR_NUMBER)",
          "2122:    lhs_type = &t_number;",
          "2123:       if (*p != '=' && need_type(rhs_type, lhs_type,",
          "2124:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "2125:       goto theend;",
          "2126:   }",
          "2127:      }",
          "2128:      else if (cmdidx == CMD_final)",
          "2130:   emsg(_(e_final_requires_a_value));",
          "2131:   goto theend;",
          "2133:      else if (cmdidx == CMD_const)",
          "2135:   emsg(_(e_const_requires_a_value));",
          "2136:   goto theend;",
          "2138:      else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option",
          "2139:         || lhs.lhs_dest == dest_func_option)",
          "2140:      {",
          "2141:   emsg(_(e_type_or_initialization_required));",
          "2142:   goto theend;",
          "2143:      }",
          "2144:      else",
          "2147:   if (GA_GROW_FAILS(instr, 1))",
          "2148:       goto theend;",
          "2149:   switch (lhs.lhs_member_type->tt_type)",
          "2151:       case VAR_BOOL:",
          "2152:    generate_PUSHBOOL(cctx, VVAL_FALSE);",
          "2153:    break;",
          "2154:       case VAR_FLOAT:",
          "2155: #ifdef FEAT_FLOAT",
          "2156:    generate_PUSHF(cctx, 0.0);",
          "2157: #endif",
          "2158:    break;",
          "2159:       case VAR_STRING:",
          "2160:    generate_PUSHS(cctx, NULL);",
          "2161:    break;",
          "2162:       case VAR_BLOB:",
          "2163:    generate_PUSHBLOB(cctx, blob_alloc());",
          "2164:    break;",
          "2165:       case VAR_FUNC:",
          "2166:    generate_PUSHFUNC(cctx, NULL, &t_func_void);",
          "2167:    break;",
          "2168:       case VAR_LIST:",
          "2169:    generate_NEWLIST(cctx, 0);",
          "2170:    break;",
          "2171:       case VAR_DICT:",
          "2172:    generate_NEWDICT(cctx, 0);",
          "2173:    break;",
          "2174:       case VAR_JOB:",
          "2175:    generate_PUSHJOB(cctx, NULL);",
          "2176:    break;",
          "2177:       case VAR_CHANNEL:",
          "2178:    generate_PUSHCHANNEL(cctx, NULL);",
          "2179:    break;",
          "2180:       case VAR_NUMBER:",
          "2181:       case VAR_UNKNOWN:",
          "2182:       case VAR_ANY:",
          "2183:       case VAR_PARTIAL:",
          "2184:       case VAR_VOID:",
          "2185:       case VAR_INSTR:",
          "2186:       case VAR_SPECIAL:  // cannot happen",
          "2187:    generate_PUSHNR(cctx, 0);",
          "2188:    break;",
          "2191:      if (var_count == 0)",
          "2192:   end = p;",
          "2196:  if (cctx->ctx_skip == SKIP_YES)",
          "2197:      break;",
          "2199:  if (oplen > 0 && *op != '=')",
          "2201:      type_T     *expected;",
          "2202:      type_T     *stacktype = NULL;",
          "2204:      if (*op == '.')",
          "2206:   if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "2207:       goto theend;",
          "2209:      else",
          "2211:   expected = lhs.lhs_member_type;",
          "2212:   stacktype = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "2213:   if (",
          "2214: #ifdef FEAT_FLOAT",
          "2216:       !(expected == &t_float && (stacktype == &t_number",
          "2217:        || stacktype == &t_number_bool)) &&",
          "2218: #endif",
          "2219:       need_type(stacktype, expected, -1, 0, cctx,",
          "2220:         FALSE, FALSE) == FAIL)",
          "2221:       goto theend;",
          "2222:      }",
          "2224:      if (*op == '.')",
          "2225:      {",
          "2226:   if (generate_instr_drop(cctx, ISN_CONCAT, 1) == NULL)",
          "2227:       goto theend;",
          "2228:      }",
          "2229:      else if (*op == '+')",
          "2230:      {",
          "2231:   if (generate_add_instr(cctx,",
          "2232:        operator_type(lhs.lhs_member_type, stacktype),",
          "2233:            lhs.lhs_member_type, stacktype,",
          "2234:          EXPR_APPEND) == FAIL)",
          "2235:       goto theend;",
          "2237:      else if (generate_two_op(cctx, op) == FAIL)",
          "2238:   goto theend;",
          "2242:  save_lnum = cctx->ctx_lnum;",
          "2243:  cctx->ctx_lnum = start_lnum - 1;",
          "2245:  if (lhs.lhs_has_index)",
          "2249:      if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)",
          "2250:                == FAIL)",
          "2252:   cctx->ctx_lnum = save_lnum;",
          "2253:   goto theend;",
          "2255:  }",
          "2256:  else",
          "2257:  {",
          "2258:      if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script",
          "2259:       || lhs.lhs_dest == dest_global",
          "2260:       || lhs.lhs_dest == dest_local))",
          "2262:   generate_LOCKCONST(cctx);",
          "2264:      if (is_decl",
          "2265:       && (lhs.lhs_type->tt_type == VAR_DICT",
          "2266:        || lhs.lhs_type->tt_type == VAR_LIST)",
          "2267:       && lhs.lhs_type->tt_member != NULL",
          "2268:       && !(lhs.lhs_type->tt_member == &t_any",
          "2269:        && oplen > 0",
          "2270:        && rhs_type != NULL",
          "2271:        && rhs_type->tt_type == lhs.lhs_type->tt_type",
          "2272:        && rhs_type->tt_member != &t_unknown)",
          "2273:       && lhs.lhs_type->tt_member != &t_unknown)",
          "2277:   generate_SETTYPE(cctx, lhs.lhs_type);",
          "2279:      if (generate_store_lhs(cctx, &lhs, instr_count) == FAIL)",
          "2281:   cctx->ctx_lnum = save_lnum;",
          "2282:   goto theend;",
          "2285:  cctx->ctx_lnum = save_lnum;",
          "2287:  if (var_idx + 1 < var_count)",
          "2288:      var_start = skipwhite(lhs.lhs_end + 1);",
          "2293:     if (var_count > 0 && (!semicolon || !did_generate_slice))",
          "2295:  if (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)",
          "2296:      goto theend;",
          "2299:     ret = skipwhite(end);",
          "2301: theend:",
          "2302:     vim_free(lhs.lhs_name);",
          "2303:     return ret;",
          "2310:     static int",
          "2311: may_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)",
          "2313:     char_u  *pskip;",
          "2314:     char_u  *p;",
          "2320:     pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')",
          "2321:        ? eap->cmd + 1 : eap->cmd;",
          "2322:     p = to_name_end(pskip, TRUE);",
          "2323:     if (p > eap->cmd && *p != NUL)",
          "2325:  char_u *var_end;",
          "2326:  int oplen;",
          "2327:  int heredoc;",
          "2329:  if (eap->cmd[0] == '@')",
          "2330:      var_end = eap->cmd + 2;",
          "2331:  else",
          "2332:      var_end = find_name_end(pskip, NULL, NULL,",
          "2333:      FNE_CHECK_START | FNE_INCL_BR);",
          "2334:  oplen = assignment_len(skipwhite(var_end), &heredoc);",
          "2335:  if (oplen > 0)",
          "2336:  {",
          "2337:      size_t len = p - eap->cmd;",
          "2348:      if (*eap->cmd == '&'",
          "2349:       || *eap->cmd == '$'",
          "2350:       || *eap->cmd == '@'",
          "2351:       || ((len) > 2 && eap->cmd[1] == ':')",
          "2352:       || variable_exists(eap->cmd, len, cctx))",
          "2353:      {",
          "2355:   if (*line == NULL || *line == eap->cmd)",
          "2356:       return FAIL;",
          "2357:   return OK;",
          "2358:      }",
          "2359:  }",
          "2362:     if (*eap->cmd == '[')",
          "2366:  if (*line == NULL)",
          "2367:      return FAIL;",
          "2368:  if (*line != eap->cmd)",
          "2369:      return OK;",
          "2371:     return NOTDONE;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "10448:         argcount, &ufunc->uf_type_list);",
          "10449: }",
          "",
          "[Removed Lines]",
          "10455:     void",
          "10456: delete_instr(isn_T *isn)",
          "10457: {",
          "10458:     switch (isn->isn_type)",
          "10459:     {",
          "10460:  case ISN_DEF:",
          "10461:  case ISN_EXEC:",
          "10462:  case ISN_EXECRANGE:",
          "10463:  case ISN_EXEC_SPLIT:",
          "10464:  case ISN_LEGACY_EVAL:",
          "10465:  case ISN_LOADAUTO:",
          "10466:  case ISN_LOADB:",
          "10467:  case ISN_LOADENV:",
          "10468:  case ISN_LOADG:",
          "10469:  case ISN_LOADOPT:",
          "10470:  case ISN_LOADT:",
          "10471:  case ISN_LOADW:",
          "10472:  case ISN_LOCKUNLOCK:",
          "10473:  case ISN_PUSHEXC:",
          "10474:  case ISN_PUSHFUNC:",
          "10475:  case ISN_PUSHS:",
          "10476:  case ISN_RANGE:",
          "10477:  case ISN_STOREAUTO:",
          "10478:  case ISN_STOREB:",
          "10479:  case ISN_STOREENV:",
          "10480:  case ISN_STOREG:",
          "10481:  case ISN_STORET:",
          "10482:  case ISN_STOREW:",
          "10483:  case ISN_STRINGMEMBER:",
          "10484:      vim_free(isn->isn_arg.string);",
          "10485:      break;",
          "10487:  case ISN_SUBSTITUTE:",
          "10488:      {",
          "10489:   int idx;",
          "10490:   isn_T *list = isn->isn_arg.subs.subs_instr;",
          "10492:   vim_free(isn->isn_arg.subs.subs_cmd);",
          "10493:   for (idx = 0; list[idx].isn_type != ISN_FINISH; ++idx)",
          "10494:       delete_instr(list + idx);",
          "10495:   vim_free(list);",
          "10496:      }",
          "10497:      break;",
          "10499:  case ISN_INSTR:",
          "10500:      {",
          "10501:   int idx;",
          "10502:   isn_T *list = isn->isn_arg.instr;",
          "10504:   for (idx = 0; list[idx].isn_type != ISN_FINISH; ++idx)",
          "10505:       delete_instr(list + idx);",
          "10506:   vim_free(list);",
          "10507:      }",
          "10508:      break;",
          "10510:  case ISN_LOADS:",
          "10511:  case ISN_STORES:",
          "10512:      vim_free(isn->isn_arg.loadstore.ls_name);",
          "10513:      break;",
          "10515:  case ISN_UNLET:",
          "10516:  case ISN_UNLETENV:",
          "10517:      vim_free(isn->isn_arg.unlet.ul_name);",
          "10518:      break;",
          "10520:  case ISN_STOREOPT:",
          "10521:  case ISN_STOREFUNCOPT:",
          "10522:      vim_free(isn->isn_arg.storeopt.so_name);",
          "10523:      break;",
          "10525:  case ISN_PUSHBLOB:   // push blob isn_arg.blob",
          "10526:      blob_unref(isn->isn_arg.blob);",
          "10527:      break;",
          "10529:  case ISN_PUSHJOB:",
          "10530: #ifdef FEAT_JOB_CHANNEL",
          "10531:      job_unref(isn->isn_arg.job);",
          "10532: #endif",
          "10533:      break;",
          "10535:  case ISN_PUSHCHANNEL:",
          "10536: #ifdef FEAT_JOB_CHANNEL",
          "10537:      channel_unref(isn->isn_arg.channel);",
          "10538: #endif",
          "10539:      break;",
          "10541:  case ISN_UCALL:",
          "10542:      vim_free(isn->isn_arg.ufunc.cuf_name);",
          "10543:      break;",
          "10545:  case ISN_FUNCREF:",
          "10546:      {",
          "10547:   if (isn->isn_arg.funcref.fr_func_name == NULL)",
          "10548:   {",
          "10549:       dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "10550:         + isn->isn_arg.funcref.fr_dfunc_idx;",
          "10551:       ufunc_T *ufunc = dfunc->df_ufunc;",
          "10553:       if (ufunc != NULL && func_name_refcount(ufunc->uf_name))",
          "10554:    func_ptr_unref(ufunc);",
          "10555:   }",
          "10556:   else",
          "10557:   {",
          "10558:       char_u *name = isn->isn_arg.funcref.fr_func_name;",
          "10560:       if (name != NULL)",
          "10561:    func_unref(name);",
          "10562:       vim_free(isn->isn_arg.funcref.fr_func_name);",
          "10563:   }",
          "10564:      }",
          "10565:      break;",
          "10567:  case ISN_DCALL:",
          "10568:      {",
          "10569:   dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "10570:             + isn->isn_arg.dfunc.cdf_idx;",
          "10572:   if (dfunc->df_ufunc != NULL",
          "10573:           && func_name_refcount(dfunc->df_ufunc->uf_name))",
          "10574:       func_ptr_unref(dfunc->df_ufunc);",
          "10575:      }",
          "10576:      break;",
          "10578:  case ISN_NEWFUNC:",
          "10579:      {",
          "10580:   char_u  *lambda = isn->isn_arg.newfunc.nf_lambda;",
          "10581:   ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);",
          "10583:   if (ufunc != NULL)",
          "10584:   {",
          "10585:       unlink_def_function(ufunc);",
          "10586:       func_ptr_unref(ufunc);",
          "10587:   }",
          "10589:   vim_free(lambda);",
          "10590:   vim_free(isn->isn_arg.newfunc.nf_global);",
          "10591:      }",
          "10592:      break;",
          "10594:  case ISN_CHECKTYPE:",
          "10595:  case ISN_SETTYPE:",
          "10596:      free_type(isn->isn_arg.type.ct_type);",
          "10597:      break;",
          "10599:  case ISN_CMDMOD:",
          "10600:      vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod",
          "10601:             ->cmod_filter_regmatch.regprog);",
          "10602:      vim_free(isn->isn_arg.cmdmod.cf_cmdmod);",
          "10603:      break;",
          "10605:  case ISN_LOADSCRIPT:",
          "10606:  case ISN_STORESCRIPT:",
          "10607:      vim_free(isn->isn_arg.script.scriptref);",
          "10608:      break;",
          "10610:  case ISN_TRY:",
          "10611:      vim_free(isn->isn_arg.try.try_ref);",
          "10612:      break;",
          "10614:  case ISN_CEXPR_CORE:",
          "10615:      vim_free(isn->isn_arg.cexpr.cexpr_ref->cer_cmdline);",
          "10616:      vim_free(isn->isn_arg.cexpr.cexpr_ref);",
          "10617:      break;",
          "10619:  case ISN_2BOOL:",
          "10620:  case ISN_2STRING:",
          "10621:  case ISN_2STRING_ANY:",
          "10622:  case ISN_ADDBLOB:",
          "10623:  case ISN_ADDLIST:",
          "10624:  case ISN_ANYINDEX:",
          "10625:  case ISN_ANYSLICE:",
          "10626:  case ISN_BCALL:",
          "10627:  case ISN_BLOBAPPEND:",
          "10628:  case ISN_BLOBINDEX:",
          "10629:  case ISN_BLOBSLICE:",
          "10630:  case ISN_CATCH:",
          "10631:  case ISN_CEXPR_AUCMD:",
          "10632:  case ISN_CHECKLEN:",
          "10633:  case ISN_CHECKNR:",
          "10634:  case ISN_CLEARDICT:",
          "10635:  case ISN_CMDMOD_REV:",
          "10636:  case ISN_COMPAREANY:",
          "10637:  case ISN_COMPAREBLOB:",
          "10638:  case ISN_COMPAREBOOL:",
          "10639:  case ISN_COMPAREDICT:",
          "10640:  case ISN_COMPAREFLOAT:",
          "10641:  case ISN_COMPAREFUNC:",
          "10642:  case ISN_COMPARELIST:",
          "10643:  case ISN_COMPARENR:",
          "10644:  case ISN_COMPARESPECIAL:",
          "10645:  case ISN_COMPARESTRING:",
          "10646:  case ISN_CONCAT:",
          "10647:  case ISN_COND2BOOL:",
          "10648:  case ISN_DEBUG:",
          "10649:  case ISN_DROP:",
          "10650:  case ISN_ECHO:",
          "10651:  case ISN_ECHOCONSOLE:",
          "10652:  case ISN_ECHOERR:",
          "10653:  case ISN_ECHOMSG:",
          "10654:  case ISN_ENDTRY:",
          "10655:  case ISN_EXECCONCAT:",
          "10656:  case ISN_EXECUTE:",
          "10657:  case ISN_FINALLY:",
          "10658:  case ISN_FINISH:",
          "10659:  case ISN_FOR:",
          "10660:  case ISN_GETITEM:",
          "10661:  case ISN_JUMP:",
          "10662:  case ISN_JUMP_IF_ARG_SET:",
          "10663:  case ISN_LISTAPPEND:",
          "10664:  case ISN_LISTINDEX:",
          "10665:  case ISN_LISTSLICE:",
          "10666:  case ISN_LOAD:",
          "10667:  case ISN_LOADBDICT:",
          "10668:  case ISN_LOADGDICT:",
          "10669:  case ISN_LOADOUTER:",
          "10670:  case ISN_LOADREG:",
          "10671:  case ISN_LOADTDICT:",
          "10672:  case ISN_LOADV:",
          "10673:  case ISN_LOADWDICT:",
          "10674:  case ISN_LOCKCONST:",
          "10675:  case ISN_MEMBER:",
          "10676:  case ISN_NEGATENR:",
          "10677:  case ISN_NEWDICT:",
          "10678:  case ISN_NEWLIST:",
          "10679:  case ISN_OPANY:",
          "10680:  case ISN_OPFLOAT:",
          "10681:  case ISN_OPNR:",
          "10682:  case ISN_PCALL:",
          "10683:  case ISN_PCALL_END:",
          "10684:  case ISN_PROF_END:",
          "10685:  case ISN_PROF_START:",
          "10686:  case ISN_PUSHBOOL:",
          "10687:  case ISN_PUSHF:",
          "10688:  case ISN_PUSHNR:",
          "10689:  case ISN_PUSHSPEC:",
          "10690:  case ISN_PUT:",
          "10691:  case ISN_REDIREND:",
          "10692:  case ISN_REDIRSTART:",
          "10693:  case ISN_RETURN:",
          "10694:  case ISN_RETURN_VOID:",
          "10695:  case ISN_SHUFFLE:",
          "10696:  case ISN_SLICE:",
          "10697:  case ISN_STORE:",
          "10698:  case ISN_STOREINDEX:",
          "10699:  case ISN_STORENR:",
          "10700:  case ISN_STOREOUTER:",
          "10701:  case ISN_STORERANGE:",
          "10702:  case ISN_STOREREG:",
          "10703:  case ISN_STOREV:",
          "10704:  case ISN_STRINDEX:",
          "10705:  case ISN_STRSLICE:",
          "10706:  case ISN_THROW:",
          "10707:  case ISN_TRYCONT:",
          "10708:  case ISN_UNLETINDEX:",
          "10709:  case ISN_UNLETRANGE:",
          "10710:  case ISN_UNPACK:",
          "10711:  case ISN_USEDICT:",
          "10713:      break;",
          "10714:     }",
          "10715: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #if defined(FEAT_EVAL) || defined(PROTO)",
          "21: #endif",
          "26: typedef struct {",
          "",
          "[Removed Lines]",
          "19: #ifdef VMS",
          "20: # include <float.h>",
          "23: #include \"vim9.h\"",
          "",
          "[Added Lines]",
          "20: #ifdef PROTO",
          "21: # include \"vim9.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5064:     if (ectx.ec_funcrefs.ga_len > 0)",
          "5065:     {",
          "5066:  handle_closure_in_use(&ectx, FALSE);",
          "5068:     }",
          "5070:     estack_pop();",
          "",
          "[Removed Lines]",
          "5067:  ga_clear(&ectx.ec_funcrefs);  // TODO: should not be needed?",
          "",
          "[Added Lines]",
          "5067:  ga_clear(&ectx.ec_funcrefs);",
          "",
          "---------------"
        ],
        "src/vim9expr.c||src/vim9expr.c": [
          "File: src/vim9expr.c -> src/vim9expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #define USING_FLOAT_STUFF",
          "15: #include \"vim.h\"",
          "17: #if defined(FEAT_EVAL) || defined(PROTO)",
          "20: #ifdef PROTO",
          "21: # include \"vim9.h\"",
          "22: #endif",
          "27:     int",
          "28: generate_ppconst(cctx_T *cctx, ppconst_T *ppconst)",
          "29: {",
          "30:     int     i;",
          "31:     int     ret = OK;",
          "32:     int     save_skip = cctx->ctx_skip;",
          "34:     cctx->ctx_skip = SKIP_NOT;",
          "35:     for (i = 0; i < ppconst->pp_used; ++i)",
          "36:  if (generate_tv_PUSH(cctx, &ppconst->pp_tv[i]) == FAIL)",
          "37:      ret = FAIL;",
          "38:     ppconst->pp_used = 0;",
          "39:     cctx->ctx_skip = save_skip;",
          "40:     return ret;",
          "41: }",
          "46:     static int",
          "47: check_ppconst_bool(ppconst_T *ppconst)",
          "48: {",
          "49:     if (ppconst->pp_used > 0)",
          "50:     {",
          "51:  typval_T    *tv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "52:  where_T     where = WHERE_INIT;",
          "54:  return check_typval_type(&t_bool, tv, where);",
          "55:     }",
          "56:     return OK;",
          "57: }",
          "62:     void",
          "63: clear_ppconst(ppconst_T *ppconst)",
          "64: {",
          "65:     int     i;",
          "67:     for (i = 0; i < ppconst->pp_used; ++i)",
          "68:  clear_tv(&ppconst->pp_tv[i]);",
          "69:     ppconst->pp_used = 0;",
          "70: }",
          "77:     int",
          "78: compile_member(int is_slice, int *keeping_dict, cctx_T *cctx)",
          "79: {",
          "80:     type_T **typep;",
          "81:     garray_T *stack = &cctx->ctx_type_stack;",
          "82:     vartype_T vartype;",
          "83:     type_T *idxtype;",
          "88:     typep = ((type_T **)stack->ga_data) + stack->ga_len",
          "89:         - (is_slice ? 3 : 2);",
          "90:     vartype = (*typep)->tt_type;",
          "91:     idxtype = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "93:     if (*typep == &t_any && idxtype == &t_string)",
          "94:  vartype = VAR_DICT;",
          "95:     if (vartype == VAR_STRING || vartype == VAR_LIST || vartype == VAR_BLOB)",
          "96:     {",
          "97:  if (need_type(idxtype, &t_number, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "98:      return FAIL;",
          "99:  if (is_slice)",
          "100:  {",
          "101:      idxtype = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "102:      if (need_type(idxtype, &t_number, -2, 0, cctx,",
          "103:         FALSE, FALSE) == FAIL)",
          "104:   return FAIL;",
          "105:  }",
          "106:     }",
          "108:     if (vartype == VAR_DICT)",
          "109:     {",
          "110:  if (is_slice)",
          "111:  {",
          "112:      emsg(_(e_cannot_slice_dictionary));",
          "113:      return FAIL;",
          "114:  }",
          "115:  if ((*typep)->tt_type == VAR_DICT)",
          "116:  {",
          "118:      if (*typep == &t_unknown)",
          "121:  }",
          "122:  else",
          "123:  {",
          "124:      if (need_type(*typep, &t_dict_any, -2, 0, cctx,",
          "125:         FALSE, FALSE) == FAIL)",
          "126:   return FAIL;",
          "128:  }",
          "129:  if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "130:      return FAIL;",
          "131:  if (generate_instr_drop(cctx, ISN_MEMBER, 1) == FAIL)",
          "132:      return FAIL;",
          "133:  if (keeping_dict != NULL)",
          "135:     }",
          "136:     else if (vartype == VAR_STRING)",
          "137:     {",
          "139:  if ((is_slice",
          "140:   ? generate_instr_drop(cctx, ISN_STRSLICE, 2)",
          "141:   : generate_instr_drop(cctx, ISN_STRINDEX, 1)) == FAIL)",
          "142:      return FAIL;",
          "143:     }",
          "144:     else if (vartype == VAR_BLOB)",
          "145:     {",
          "146:  if (is_slice)",
          "147:  {",
          "149:      if (generate_instr_drop(cctx, ISN_BLOBSLICE, 2) == FAIL)",
          "150:   return FAIL;",
          "151:  }",
          "152:  else",
          "153:  {",
          "155:      if (generate_instr_drop(cctx, ISN_BLOBINDEX, 1) == FAIL)",
          "156:   return FAIL;",
          "157:  }",
          "158:     }",
          "159:     else if (vartype == VAR_LIST || *typep == &t_any)",
          "160:     {",
          "161:  if (is_slice)",
          "162:  {",
          "163:      if (generate_instr_drop(cctx,",
          "164:        vartype == VAR_LIST ?  ISN_LISTSLICE : ISN_ANYSLICE,",
          "165:            2) == FAIL)",
          "166:   return FAIL;",
          "167:  }",
          "168:  else",
          "169:  {",
          "170:      if ((*typep)->tt_type == VAR_LIST)",
          "171:      {",
          "173:   if (*typep == &t_unknown)",
          "176:      }",
          "177:      if (generate_instr_drop(cctx,",
          "178:    vartype == VAR_LIST ?  ISN_LISTINDEX : ISN_ANYINDEX, 1)",
          "179:                == FAIL)",
          "180:   return FAIL;",
          "181:  }",
          "182:     }",
          "183:     else",
          "184:     {",
          "185:  switch (vartype)",
          "186:  {",
          "187:      case VAR_FUNC:",
          "188:      case VAR_PARTIAL:",
          "189:   emsg(_(e_cannot_index_a_funcref));",
          "190:   break;",
          "191:      case VAR_BOOL:",
          "192:      case VAR_SPECIAL:",
          "193:      case VAR_JOB:",
          "194:      case VAR_CHANNEL:",
          "195:      case VAR_INSTR:",
          "196:      case VAR_UNKNOWN:",
          "197:      case VAR_ANY:",
          "198:      case VAR_VOID:",
          "199:   emsg(_(e_cannot_index_special_variable));",
          "200:   break;",
          "201:      default:",
          "202:   emsg(_(e_string_list_dict_or_blob_required));",
          "203:  }",
          "204:  return FAIL;",
          "205:     }",
          "206:     return OK;",
          "207: }",
          "214:     int",
          "215: compile_load_scriptvar(",
          "216:  cctx_T *cctx,",
          "217:  char_u *name,     // variable NUL terminated",
          "218:  char_u *start,     // start of variable",
          "219:  char_u **end,     // end of variable",
          "220:  int    error)     // when TRUE may give error",
          "221: {",
          "222:     scriptitem_T    *si;",
          "223:     int      idx;",
          "224:     imported_T     *import;",
          "226:     if (!SCRIPT_ID_VALID(current_sctx.sc_sid))",
          "227:  return FAIL;",
          "228:     si = SCRIPT_ITEM(current_sctx.sc_sid);",
          "229:     idx = get_script_item_idx(current_sctx.sc_sid, name, 0, cctx);",
          "230:     if (idx == -1 || si->sn_version != SCRIPT_VERSION_VIM9)",
          "231:     {",
          "233:  return generate_OLDSCRIPT(cctx, ISN_LOADS, name, current_sctx.sc_sid,",
          "234:                &t_any);",
          "235:     }",
          "236:     if (idx >= 0)",
          "237:     {",
          "238:  svar_T  *sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;",
          "240:  generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "241:      current_sctx.sc_sid, idx, sv->sv_type);",
          "242:  return OK;",
          "243:     }",
          "245:     import = find_imported(name, 0, cctx);",
          "246:     if (import != NULL)",
          "247:     {",
          "248:  if (import->imp_flags & IMP_FLAGS_STAR)",
          "249:  {",
          "250:      char_u *p = skipwhite(*end);",
          "251:      char_u *exp_name;",
          "252:      int  cc;",
          "253:      ufunc_T *ufunc;",
          "254:      type_T *type;",
          "257:      if (*p != '.')",
          "258:      {",
          "259:   semsg(_(e_expected_dot_after_name_str), start);",
          "260:   return FAIL;",
          "261:      }",
          "262:      ++p;",
          "263:      if (VIM_ISWHITE(*p))",
          "264:      {",
          "265:   emsg(_(e_no_white_space_allowed_after_dot));",
          "266:   return FAIL;",
          "267:      }",
          "270:      exp_name = p;",
          "271:      while (eval_isnamec(*p))",
          "272:   ++p;",
          "273:      cc = *p;",
          "276:      idx = find_exported(import->imp_sid, exp_name, &ufunc, &type,",
          "277:            cctx, TRUE);",
          "279:      p = skipwhite(p);",
          "282:      if (idx < 0)",
          "283:      {",
          "284:   if (*p == '(' && ufunc != NULL)",
          "285:   {",
          "286:       generate_PUSHFUNC(cctx, ufunc->uf_name, import->imp_type);",
          "287:       return OK;",
          "288:   }",
          "289:   return FAIL;",
          "290:      }",
          "292:      generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "293:       import->imp_sid,",
          "294:       idx,",
          "295:       type);",
          "296:  }",
          "297:  else if (import->imp_funcname != NULL)",
          "298:      generate_PUSHFUNC(cctx, import->imp_funcname, import->imp_type);",
          "299:  else",
          "300:      generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "301:       import->imp_sid,",
          "302:       import->imp_var_vals_idx,",
          "303:       import->imp_type);",
          "304:  return OK;",
          "305:     }",
          "307:     if (error)",
          "308:  semsg(_(e_item_not_found_str), name);",
          "309:     return FAIL;",
          "310: }",
          "312:     static int",
          "313: generate_funcref(cctx_T *cctx, char_u *name)",
          "314: {",
          "315:     ufunc_T *ufunc = find_func(name, FALSE, cctx);",
          "317:     if (ufunc == NULL)",
          "318:  return FAIL;",
          "321:     if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))",
          "322:      && compile_def_function(ufunc, TRUE, COMPILE_TYPE(ufunc), NULL)",
          "323:                == FAIL)",
          "324:  return FAIL;",
          "325:     return generate_PUSHFUNC(cctx, ufunc->uf_name, ufunc->uf_func_type);",
          "326: }",
          "334:     int",
          "335: compile_load(",
          "336:  char_u **arg,",
          "337:  char_u *end_arg,",
          "338:  cctx_T *cctx,",
          "339:  int is_expr,",
          "340:  int error)",
          "341: {",
          "342:     type_T *type;",
          "343:     char_u *name = NULL;",
          "344:     char_u *end = end_arg;",
          "345:     int  res = FAIL;",
          "346:     int  prev_called_emsg = called_emsg;",
          "348:     if (*(*arg + 1) == ':')",
          "349:     {",
          "350:  if (end <= *arg + 2)",
          "351:  {",
          "352:      isntype_T  isn_type;",
          "355:      switch (**arg)",
          "356:      {",
          "357:   case 'g': isn_type = ISN_LOADGDICT; break;",
          "358:   case 'w': isn_type = ISN_LOADWDICT; break;",
          "359:   case 't': isn_type = ISN_LOADTDICT; break;",
          "360:   case 'b': isn_type = ISN_LOADBDICT; break;",
          "361:   default:",
          "362:       semsg(_(e_namespace_not_supported_str), *arg);",
          "363:       goto theend;",
          "364:      }",
          "365:      if (generate_instr_type(cctx, isn_type, &t_dict_any) == NULL)",
          "366:   goto theend;",
          "367:      res = OK;",
          "368:  }",
          "369:  else",
          "370:  {",
          "371:      isntype_T  isn_type = ISN_DROP;",
          "374:      name = vim_strnsave(*arg + 2, end - (*arg + 2));",
          "375:      if (name == NULL)",
          "376:   return FAIL;",
          "378:      switch (**arg)",
          "379:      {",
          "380:   case 'v': res = generate_LOADV(cctx, name, error);",
          "381:      break;",
          "382:   case 's': if (is_expr && ASCII_ISUPPER(*name)",
          "383:            && find_func(name, FALSE, cctx) != NULL)",
          "384:          res = generate_funcref(cctx, name);",
          "385:      else",
          "386:          res = compile_load_scriptvar(cctx, name,",
          "387:            NULL, &end, error);",
          "388:      break;",
          "389:   case 'g': if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)",
          "390:      {",
          "391:          if (is_expr && ASCII_ISUPPER(*name)",
          "392:            && find_func(name, FALSE, cctx) != NULL)",
          "393:       res = generate_funcref(cctx, name);",
          "394:          else",
          "395:       isn_type = ISN_LOADG;",
          "396:      }",
          "397:      else",
          "398:      {",
          "399:          isn_type = ISN_LOADAUTO;",
          "400:          vim_free(name);",
          "401:          name = vim_strnsave(*arg, end - *arg);",
          "402:          if (name == NULL)",
          "403:       return FAIL;",
          "404:      }",
          "405:      break;",
          "406:   case 'w': isn_type = ISN_LOADW; break;",
          "407:   case 't': isn_type = ISN_LOADT; break;",
          "408:   case 'b': isn_type = ISN_LOADB; break;",
          "409:   default:  // cannot happen, just in case",
          "410:      semsg(_(e_namespace_not_supported_str), *arg);",
          "411:      goto theend;",
          "412:      }",
          "413:      if (isn_type != ISN_DROP)",
          "414:      {",
          "418:   res = generate_LOAD(cctx, isn_type, 0, name, &t_any);",
          "419:      }",
          "420:  }",
          "421:     }",
          "422:     else",
          "423:     {",
          "424:  size_t     len = end - *arg;",
          "425:  int     idx;",
          "426:  int     gen_load = FALSE;",
          "427:  int     gen_load_outer = 0;",
          "429:  name = vim_strnsave(*arg, end - *arg);",
          "430:  if (name == NULL)",
          "431:      return FAIL;",
          "433:  if (vim_strchr(name, AUTOLOAD_CHAR) != NULL)",
          "434:  {",
          "435:      script_autoload(name, FALSE);",
          "436:      res = generate_LOAD(cctx, ISN_LOADAUTO, 0, name, &t_any);",
          "437:  }",
          "438:  else if (arg_exists(*arg, len, &idx, &type, &gen_load_outer, cctx)",
          "439:           == OK)",
          "440:  {",
          "441:      if (gen_load_outer == 0)",
          "442:   gen_load = TRUE;",
          "443:  }",
          "444:  else",
          "445:  {",
          "446:      lvar_T lvar;",
          "448:      if (lookup_local(*arg, len, &lvar, cctx) == OK)",
          "449:      {",
          "450:   type = lvar.lv_type;",
          "451:   idx = lvar.lv_idx;",
          "452:   if (lvar.lv_from_outer != 0)",
          "453:       gen_load_outer = lvar.lv_from_outer;",
          "454:   else",
          "455:       gen_load = TRUE;",
          "456:      }",
          "457:      else",
          "458:      {",
          "461:   if (script_var_exists(*arg, len, cctx) == OK",
          "462:    || find_imported(name, 0, cctx) != NULL)",
          "463:      res = compile_load_scriptvar(cctx, name, *arg, &end, FALSE);",
          "468:   if (res == FAIL && is_expr && ASCII_ISUPPER(*name))",
          "469:       res = generate_funcref(cctx, name);",
          "470:      }",
          "471:  }",
          "472:  if (gen_load)",
          "473:      res = generate_LOAD(cctx, ISN_LOAD, idx, NULL, type);",
          "474:  if (gen_load_outer > 0)",
          "475:  {",
          "476:      res = generate_LOADOUTER(cctx, idx, gen_load_outer, type);",
          "477:      cctx->ctx_outer_used = TRUE;",
          "478:  }",
          "479:     }",
          "483: theend:",
          "484:     if (res == FAIL && error && called_emsg == prev_called_emsg)",
          "485:  semsg(_(e_variable_not_found_str), name);",
          "486:     vim_free(name);",
          "487:     return res;",
          "488: }",
          "494:     static int",
          "495: compile_string(isn_T *isn, cctx_T *cctx)",
          "496: {",
          "497:     char_u *s = isn->isn_arg.string;",
          "498:     garray_T save_ga = cctx->ctx_instr;",
          "499:     int  expr_res;",
          "500:     int  trailing_error;",
          "501:     int  instr_count;",
          "502:     isn_T *instr = NULL;",
          "505:     --cctx->ctx_type_stack.ga_len;",
          "509:     cctx->ctx_instr.ga_len = 0;",
          "510:     cctx->ctx_instr.ga_maxlen = 0;",
          "511:     cctx->ctx_instr.ga_data = NULL;",
          "512:     expr_res = compile_expr0(&s, cctx);",
          "513:     s = skipwhite(s);",
          "514:     trailing_error = *s != NUL;",
          "516:     if (expr_res == FAIL || trailing_error",
          "517:            || GA_GROW_FAILS(&cctx->ctx_instr, 1))",
          "518:     {",
          "519:  if (trailing_error)",
          "520:      semsg(_(e_trailing_arg), s);",
          "521:  clear_instr_ga(&cctx->ctx_instr);",
          "522:  cctx->ctx_instr = save_ga;",
          "523:  ++cctx->ctx_type_stack.ga_len;",
          "524:  return FAIL;",
          "525:     }",
          "529:     instr_count = cctx->ctx_instr.ga_len;",
          "530:     instr = cctx->ctx_instr.ga_data;",
          "531:     instr[instr_count].isn_type = ISN_FINISH;",
          "533:     cctx->ctx_instr = save_ga;",
          "534:     vim_free(isn->isn_arg.string);",
          "535:     isn->isn_type = ISN_INSTR;",
          "536:     isn->isn_arg.instr = instr;",
          "537:     return OK;",
          "538: }",
          "544:     static int",
          "545: compile_arguments(char_u **arg, cctx_T *cctx, int *argcount, int is_searchpair)",
          "546: {",
          "547:     char_u  *p = *arg;",
          "548:     char_u  *whitep = *arg;",
          "549:     int     must_end = FALSE;",
          "550:     int     instr_count;",
          "552:     for (;;)",
          "553:     {",
          "554:  if (may_get_next_line(whitep, &p, cctx) == FAIL)",
          "555:      goto failret;",
          "556:  if (*p == ')')",
          "557:  {",
          "559:      return OK;",
          "560:  }",
          "561:  if (must_end)",
          "562:  {",
          "563:      semsg(_(e_missing_comma_before_argument_str), p);",
          "564:      return FAIL;",
          "565:  }",
          "567:  instr_count = cctx->ctx_instr.ga_len;",
          "568:  if (compile_expr0(&p, cctx) == FAIL)",
          "569:      return FAIL;",
          "570:  ++*argcount;",
          "572:  if (is_searchpair && *argcount == 5",
          "573:   && cctx->ctx_instr.ga_len == instr_count + 1)",
          "574:  {",
          "575:      isn_T *isn = ((isn_T *)cctx->ctx_instr.ga_data) + instr_count;",
          "578:      if (isn->isn_type == ISN_PUSHS && *isn->isn_arg.string != NUL)",
          "579:   compile_string(isn, cctx);",
          "580:  }",
          "582:  if (*p != ',' && *skipwhite(p) == ',')",
          "583:  {",
          "584:      semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);",
          "585:      p = skipwhite(p);",
          "586:  }",
          "587:  if (*p == ',')",
          "588:  {",
          "589:      ++p;",
          "590:      if (*p != NUL && !VIM_ISWHITE(*p))",
          "591:   semsg(_(e_white_space_required_after_str_str), \",\", p - 1);",
          "592:  }",
          "593:  else",
          "594:      must_end = TRUE;",
          "595:  whitep = p;",
          "596:  p = skipwhite(p);",
          "597:     }",
          "598: failret:",
          "599:     emsg(_(e_missing_closing_paren));",
          "600:     return FAIL;",
          "601: }",
          "612:     static int",
          "613: compile_call(",
          "614:  char_u     **arg,",
          "615:  size_t     varlen,",
          "616:  cctx_T     *cctx,",
          "617:  ppconst_T   *ppconst,",
          "618:  int     argcount_init)",
          "619: {",
          "620:     char_u *name = *arg;",
          "621:     char_u *p;",
          "622:     int  argcount = argcount_init;",
          "623:     char_u namebuf[100];",
          "624:     char_u fname_buf[FLEN_FIXED + 1];",
          "625:     char_u *tofree = NULL;",
          "626:     int  error = FCERR_NONE;",
          "627:     ufunc_T *ufunc = NULL;",
          "628:     int  res = FAIL;",
          "629:     int  is_autoload;",
          "630:     int  is_searchpair;",
          "634:     if ((varlen == 3 && STRNCMP(*arg, \"has\", 3) == 0)",
          "635:      || (varlen == 15 && STRNCMP(*arg, \"exists_compiled\", 6) == 0))",
          "636:     {",
          "637:  char_u     *s = skipwhite(*arg + varlen + 1);",
          "638:  typval_T    argvars[2];",
          "639:  int     is_has = **arg == 'h';",
          "641:  argvars[0].v_type = VAR_UNKNOWN;",
          "642:  if (*s == '\"')",
          "643:      (void)eval_string(&s, &argvars[0], TRUE);",
          "644:  else if (*s == '\\'')",
          "645:      (void)eval_lit_string(&s, &argvars[0], TRUE);",
          "646:  s = skipwhite(s);",
          "647:  if (*s == ')' && argvars[0].v_type == VAR_STRING",
          "648:         && ((is_has && !dynamic_feature(argvars[0].vval.v_string))",
          "649:       || !is_has))",
          "650:  {",
          "651:      typval_T *tv = &ppconst->pp_tv[ppconst->pp_used];",
          "654:      argvars[1].v_type = VAR_UNKNOWN;",
          "655:      tv->v_type = VAR_NUMBER;",
          "656:      tv->vval.v_number = 0;",
          "657:      if (is_has)",
          "658:   f_has(argvars, tv);",
          "659:      else",
          "660:   f_exists(argvars, tv);",
          "661:      clear_tv(&argvars[0]);",
          "662:      ++ppconst->pp_used;",
          "663:      return OK;",
          "664:  }",
          "665:  clear_tv(&argvars[0]);",
          "666:  if (!is_has)",
          "667:  {",
          "668:      emsg(_(e_argument_of_exists_compiled_must_be_literal_string));",
          "669:      return FAIL;",
          "670:  }",
          "671:     }",
          "673:     if (generate_ppconst(cctx, ppconst) == FAIL)",
          "674:  return FAIL;",
          "676:     if (varlen >= sizeof(namebuf))",
          "677:     {",
          "678:  semsg(_(e_name_too_long_str), name);",
          "679:  return FAIL;",
          "680:     }",
          "681:     vim_strncpy(namebuf, *arg, varlen);",
          "682:     name = fname_trans_sid(namebuf, fname_buf, &tofree, &error);",
          "686:     is_searchpair = (varlen == 6 && STRNCMP(*arg, \"search\", 6) == 0)",
          "687:           || (varlen == 9 && STRNCMP(*arg, \"searchpos\", 9) == 0)",
          "688:          || (varlen == 10 && STRNCMP(*arg, \"searchpair\", 10) == 0)",
          "689:          || (varlen == 13 && STRNCMP(*arg, \"searchpairpos\", 13) == 0);",
          "692:     if (compile_arguments(arg, cctx, &argcount, is_searchpair) == FAIL)",
          "693:  goto theend;",
          "695:     is_autoload = vim_strchr(name, AUTOLOAD_CHAR) != NULL;",
          "696:     if (ASCII_ISLOWER(*name) && name[1] != ':' && !is_autoload)",
          "697:     {",
          "698:  int     idx;",
          "701:  idx = find_internal_func(name);",
          "702:  if (idx >= 0)",
          "703:  {",
          "704:      if (STRCMP(name, \"flatten\") == 0)",
          "705:      {",
          "706:   emsg(_(e_cannot_use_flatten_in_vim9_script));",
          "707:   goto theend;",
          "708:      }",
          "710:      if (STRCMP(name, \"add\") == 0 && argcount == 2)",
          "711:      {",
          "712:   garray_T    *stack = &cctx->ctx_type_stack;",
          "713:   type_T     *type = ((type_T **)stack->ga_data)[",
          "714:            stack->ga_len - 2];",
          "717:   if (type->tt_type == VAR_LIST)",
          "718:   {",
          "720:       res = generate_LISTAPPEND(cctx);",
          "721:       idx = -1;",
          "722:   }",
          "723:   else if (type->tt_type == VAR_BLOB)",
          "724:   {",
          "726:       res = generate_BLOBAPPEND(cctx);",
          "727:       idx = -1;",
          "728:   }",
          "729:      }",
          "731:      if (idx >= 0)",
          "732:   res = generate_BCALL(cctx, idx, argcount, argcount_init == 1);",
          "733:  }",
          "734:  else",
          "735:      semsg(_(e_unknown_function_str), namebuf);",
          "736:  goto theend;",
          "737:     }",
          "741:     if (lookup_local(namebuf, varlen, NULL, cctx) == FAIL",
          "742:      && arg_exists(namebuf, varlen, NULL, NULL, NULL, cctx) != OK)",
          "743:     {",
          "746:  ufunc = find_func(name, FALSE, cctx);",
          "747:  if (ufunc != NULL && !func_is_global(ufunc))",
          "748:  {",
          "749:      res = generate_CALL(cctx, ufunc, argcount);",
          "750:      goto theend;",
          "751:  }",
          "752:     }",
          "757:     p = namebuf;",
          "758:     if (STRNCMP(namebuf, \"g:\", 2) != 0 && !is_autoload",
          "759:      && compile_load(&p, namebuf + varlen, cctx, FALSE, FALSE) == OK)",
          "760:     {",
          "761:  garray_T    *stack = &cctx->ctx_type_stack;",
          "762:  type_T     *type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "764:  res = generate_PCALL(cctx, argcount, namebuf, type, FALSE);",
          "765:  goto theend;",
          "766:     }",
          "769:     if (ufunc != NULL)",
          "770:     {",
          "771:  res = generate_CALL(cctx, ufunc, argcount);",
          "772:  goto theend;",
          "773:     }",
          "777:     if (STRNCMP(namebuf, \"g:\", 2) == 0 || is_autoload)",
          "778:  res = generate_UCALL(cctx, name, argcount);",
          "779:     else",
          "780:  semsg(_(e_unknown_function_str), namebuf);",
          "782: theend:",
          "783:     vim_free(tofree);",
          "784:     return res;",
          "785: }",
          "788: #define VIM9_NAMESPACE_CHAR (char_u *)\"bgstvw\"",
          "797:     char_u *",
          "798: to_name_end(char_u *arg, int use_namespace)",
          "799: {",
          "800:     char_u *p;",
          "803:     if (!eval_isnamec1(*arg))",
          "804:  return arg;",
          "806:     for (p = arg + 1; *p != NUL && eval_isnamec(*p); MB_PTR_ADV(p))",
          "809:  if (*p == ':' && (p != arg + 1",
          "810:         || !use_namespace",
          "811:         || vim_strchr(VIM9_NAMESPACE_CHAR, *arg) == NULL))",
          "812:      break;",
          "813:     return p;",
          "814: }",
          "821:     char_u *",
          "822: to_name_const_end(char_u *arg)",
          "823: {",
          "824:     char_u *p = arg;",
          "825:     typval_T rettv;",
          "827:     if (STRNCMP(p, \"<SNR>\", 5) == 0)",
          "828:  p = skipdigits(p + 5);",
          "829:     p = to_name_end(p, TRUE);",
          "830:     if (p == arg && *arg == '[')",
          "831:     {",
          "834:  if (eval_list(&p, &rettv, NULL, FALSE) == FAIL)",
          "835:      p = arg;",
          "836:     }",
          "837:     return p;",
          "838: }",
          "845:     static int",
          "846: compile_list(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "847: {",
          "848:     char_u *p = skipwhite(*arg + 1);",
          "849:     char_u *whitep = *arg + 1;",
          "850:     int  count = 0;",
          "851:     int  is_const;",
          "852:     int  is_all_const = TRUE; // reset when non-const encountered",
          "854:     for (;;)",
          "855:     {",
          "856:  if (may_get_next_line(whitep, &p, cctx) == FAIL)",
          "857:  {",
          "858:      semsg(_(e_list_end), *arg);",
          "859:      return FAIL;",
          "860:  }",
          "861:  if (*p == ',')",
          "862:  {",
          "863:      semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);",
          "864:      return FAIL;",
          "865:  }",
          "866:  if (*p == ']')",
          "867:  {",
          "868:      ++p;",
          "869:      break;",
          "870:  }",
          "871:  if (compile_expr0_ext(&p, cctx, &is_const) == FAIL)",
          "872:      return FAIL;",
          "873:  if (!is_const)",
          "874:      is_all_const = FALSE;",
          "875:  ++count;",
          "876:  if (*p == ',')",
          "877:  {",
          "878:      ++p;",
          "879:      if (*p != ']' && !IS_WHITE_OR_NUL(*p))",
          "880:      {",
          "881:   semsg(_(e_white_space_required_after_str_str), \",\", p - 1);",
          "882:   return FAIL;",
          "883:      }",
          "884:  }",
          "885:  whitep = p;",
          "886:  p = skipwhite(p);",
          "887:     }",
          "890:     ppconst->pp_is_const = is_all_const;",
          "891:     return generate_NEWLIST(cctx, count);",
          "892: }",
          "899:     static int",
          "900: compile_lambda(char_u **arg, cctx_T *cctx)",
          "901: {",
          "902:     int  r;",
          "903:     typval_T rettv;",
          "904:     ufunc_T *ufunc;",
          "905:     evalarg_T evalarg;",
          "907:     init_evalarg(&evalarg);",
          "908:     evalarg.eval_flags = EVAL_EVALUATE;",
          "909:     evalarg.eval_cctx = cctx;",
          "912:     r = get_lambda_tv(arg, &rettv, TRUE, &evalarg);",
          "913:     if (r != OK)",
          "914:     {",
          "915:  clear_evalarg(&evalarg, NULL);",
          "916:  return r;",
          "917:     }",
          "920:     ufunc = rettv.vval.v_partial->pt_func;",
          "921:     ++ufunc->uf_refcount;",
          "922:     clear_tv(&rettv);",
          "927:     if (ufunc->uf_ret_type->tt_type == VAR_VOID)",
          "928:  ufunc->uf_ret_type = &t_unknown;",
          "929:     compile_def_function(ufunc, FALSE, cctx->ctx_compile_type, cctx);",
          "934:     if (cctx->ctx_compile_type == CT_DEBUG",
          "935: #ifdef FEAT_PROFILE",
          "936:      || cctx->ctx_compile_type == CT_PROFILE",
          "937: #endif",
          "938:        )",
          "939:  compile_def_function(ufunc, FALSE, CT_NONE, cctx);",
          "944:     if (evalarg.eval_using_cmdline)",
          "945:     {",
          "946:  garray_T    *gap = &evalarg.eval_tofree_ga;",
          "947:  size_t     off = *arg - ((char_u **)gap->ga_data)[gap->ga_len - 1];",
          "950:           + off;",
          "951:     }",
          "953:     clear_evalarg(&evalarg, NULL);",
          "955:     if (ufunc->uf_def_status == UF_COMPILED)",
          "956:     {",
          "958:  set_function_type(ufunc);",
          "963:  return generate_FUNCREF(cctx, ufunc);",
          "964:     }",
          "966:     func_ptr_unref(ufunc);",
          "967:     return FAIL;",
          "968: }",
          "973:     int",
          "974: get_lambda_tv_and_compile(",
          "975:  char_u     **arg,",
          "976:  typval_T    *rettv,",
          "977:  int     types_optional,",
          "978:  evalarg_T   *evalarg)",
          "979: {",
          "980:     int  r;",
          "981:     ufunc_T *ufunc;",
          "982:     int  save_sc_version = current_sctx.sc_version;",
          "985:     current_sctx.sc_version = SCRIPT_VERSION_VIM9;",
          "986:     r = get_lambda_tv(arg, rettv, types_optional, evalarg);",
          "987:     current_sctx.sc_version = save_sc_version;",
          "988:     if (r != OK)",
          "989:  return r;",
          "992:     ufunc = rettv->vval.v_partial->pt_func;",
          "997:     if (ufunc->uf_ret_type == NULL || ufunc->uf_ret_type->tt_type == VAR_VOID)",
          "998:  ufunc->uf_ret_type = &t_unknown;",
          "999:     compile_def_function(ufunc, FALSE, CT_NONE, NULL);",
          "1001:     if (ufunc->uf_def_status == UF_COMPILED)",
          "1002:     {",
          "1004:  set_function_type(ufunc);",
          "1005:  return OK;",
          "1006:     }",
          "1007:     clear_tv(rettv);",
          "1008:     return FAIL;",
          "1009: }",
          "1016:     static int",
          "1017: compile_dict(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "1018: {",
          "1019:     garray_T *instr = &cctx->ctx_instr;",
          "1020:     int  count = 0;",
          "1021:     dict_T *d = dict_alloc();",
          "1022:     dictitem_T *item;",
          "1023:     char_u *whitep = *arg + 1;",
          "1024:     char_u *p;",
          "1025:     int  is_const;",
          "1026:     int  is_all_const = TRUE; // reset when non-const encountered",
          "1028:     if (d == NULL)",
          "1029:  return FAIL;",
          "1030:     if (generate_ppconst(cctx, ppconst) == FAIL)",
          "1031:  return FAIL;",
          "1032:     for (;;)",
          "1033:     {",
          "1034:  char_u     *key = NULL;",
          "1036:  if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "1037:  {",
          "1039:      goto failret;",
          "1040:  }",
          "1042:  if (**arg == '}')",
          "1043:      break;",
          "1045:  if (**arg == '[')",
          "1046:  {",
          "1047:      isn_T *isn;",
          "1051:      if (compile_expr0(arg, cctx) == FAIL)",
          "1052:   return FAIL;",
          "1053:      isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "1054:      if (isn->isn_type == ISN_PUSHNR)",
          "1055:      {",
          "1056:   char buf[NUMBUFLEN];",
          "1059:   vim_snprintf(buf, NUMBUFLEN, \"%lld\", isn->isn_arg.number);",
          "1060:   isn->isn_type = ISN_PUSHS;",
          "1061:   isn->isn_arg.string = vim_strsave((char_u *)buf);",
          "1062:      }",
          "1063:      if (isn->isn_type == ISN_PUSHS)",
          "1064:   key = isn->isn_arg.string;",
          "1065:      else if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "1066:   return FAIL;",
          "1068:      if (**arg != ']')",
          "1069:      {",
          "1070:   emsg(_(e_missing_matching_bracket_after_dict_key));",
          "1071:   return FAIL;",
          "1072:      }",
          "1073:      ++*arg;",
          "1074:  }",
          "1075:  else",
          "1076:  {",
          "1080:      key = get_literal_key(arg);",
          "1081:      if (key == NULL)",
          "1082:   return FAIL;",
          "1083:      if (generate_PUSHS(cctx, &key) == FAIL)",
          "1084:   return FAIL;",
          "1085:  }",
          "1088:  if (key != NULL)",
          "1089:  {",
          "1090:      item = dict_find(d, key, -1);",
          "1091:      if (item != NULL)",
          "1092:      {",
          "1093:   semsg(_(e_duplicate_key), key);",
          "1094:   goto failret;",
          "1095:      }",
          "1096:      item = dictitem_alloc(key);",
          "1097:      if (item != NULL)",
          "1098:      {",
          "1099:   item->di_tv.v_type = VAR_UNKNOWN;",
          "1100:   item->di_tv.v_lock = 0;",
          "1101:   if (dict_add(d, item) == FAIL)",
          "1102:       dictitem_free(item);",
          "1103:      }",
          "1104:  }",
          "1106:  if (**arg != ':')",
          "1107:  {",
          "1108:      if (*skipwhite(*arg) == ':')",
          "1109:   semsg(_(e_no_white_space_allowed_before_str_str), \":\", *arg);",
          "1110:      else",
          "1111:   semsg(_(e_missing_dict_colon), *arg);",
          "1112:      return FAIL;",
          "1113:  }",
          "1114:  whitep = *arg + 1;",
          "1115:  if (!IS_WHITE_OR_NUL(*whitep))",
          "1116:  {",
          "1117:      semsg(_(e_white_space_required_after_str_str), \":\", *arg);",
          "1118:      return FAIL;",
          "1119:  }",
          "1121:  if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "1122:  {",
          "1124:      goto failret;",
          "1125:  }",
          "1127:  if (compile_expr0_ext(arg, cctx, &is_const) == FAIL)",
          "1128:      return FAIL;",
          "1129:  if (!is_const)",
          "1130:      is_all_const = FALSE;",
          "1131:  ++count;",
          "1133:  whitep = *arg;",
          "1134:  if (may_get_next_line(whitep, arg, cctx) == FAIL)",
          "1135:  {",
          "1137:      goto failret;",
          "1138:  }",
          "1139:  if (**arg == '}')",
          "1140:      break;",
          "1141:  if (**arg != ',')",
          "1142:  {",
          "1143:      semsg(_(e_missing_dict_comma), *arg);",
          "1144:      goto failret;",
          "1145:  }",
          "1146:  if (IS_WHITE_OR_NUL(*whitep))",
          "1147:  {",
          "1148:      semsg(_(e_no_white_space_allowed_before_str_str), \",\", whitep);",
          "1149:      return FAIL;",
          "1150:  }",
          "1151:  whitep = *arg + 1;",
          "1152:  if (!IS_WHITE_OR_NUL(*whitep))",
          "1153:  {",
          "1154:      semsg(_(e_white_space_required_after_str_str), \",\", *arg);",
          "1155:      return FAIL;",
          "1156:  }",
          "1158:     }",
          "1163:     p = skipwhite(*arg);",
          "1164:     if (VIM_ISWHITE(**arg) && vim9_comment_start(p))",
          "1167:     dict_unref(d);",
          "1168:     ppconst->pp_is_const = is_all_const;",
          "1169:     return generate_NEWDICT(cctx, count);",
          "1171: failret:",
          "1172:     if (*arg == NULL)",
          "1173:     {",
          "1174:  semsg(_(e_missing_dict_end), _(\"[end of lines]\"));",
          "1176:     }",
          "1177:     dict_unref(d);",
          "1178:     return FAIL;",
          "1179: }",
          "1184:     static int",
          "1185: compile_get_option(char_u **arg, cctx_T *cctx)",
          "1186: {",
          "1187:     typval_T rettv;",
          "1188:     char_u *start = *arg;",
          "1189:     int  ret;",
          "1192:     rettv.v_type = VAR_UNKNOWN;",
          "1193:     ret = eval_option(arg, &rettv, TRUE);",
          "1194:     if (ret == OK)",
          "1195:     {",
          "1197:  char_u *name = vim_strnsave(start, *arg - start);",
          "1198:  type_T *type = rettv.v_type == VAR_BOOL ? &t_bool",
          "1199:      : rettv.v_type == VAR_NUMBER ? &t_number : &t_string;",
          "1201:  ret = generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);",
          "1202:  vim_free(name);",
          "1203:     }",
          "1204:     clear_tv(&rettv);",
          "1206:     return ret;",
          "1207: }",
          "1212:     static int",
          "1213: compile_get_env(char_u **arg, cctx_T *cctx)",
          "1214: {",
          "1215:     char_u *start = *arg;",
          "1216:     int  len;",
          "1217:     int  ret;",
          "1218:     char_u *name;",
          "1220:     ++*arg;",
          "1221:     len = get_env_len(arg);",
          "1222:     if (len == 0)",
          "1223:     {",
          "1224:  semsg(_(e_syntax_error_at_str), start - 1);",
          "1225:  return FAIL;",
          "1226:     }",
          "1229:     name = vim_strnsave(start, len + 1);",
          "1230:     ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);",
          "1231:     vim_free(name);",
          "1232:     return ret;",
          "1233: }",
          "1238:     static int",
          "1239: compile_get_register(char_u **arg, cctx_T *cctx)",
          "1240: {",
          "1241:     int  ret;",
          "1243:     ++*arg;",
          "1244:     if (**arg == NUL)",
          "1245:     {",
          "1246:  semsg(_(e_syntax_error_at_str), *arg - 1);",
          "1247:  return FAIL;",
          "1248:     }",
          "1249:     if (!valid_yank_reg(**arg, FALSE))",
          "1250:     {",
          "1251:  emsg_invreg(**arg);",
          "1252:  return FAIL;",
          "1253:     }",
          "1254:     ret = generate_LOAD(cctx, ISN_LOADREG, **arg, NULL, &t_string);",
          "1255:     ++*arg;",
          "1256:     return ret;",
          "1257: }",
          "1263:     static int",
          "1264: apply_leader(typval_T *rettv, int numeric_only, char_u *start, char_u **end)",
          "1265: {",
          "1266:     char_u *p = *end;",
          "1269:     while (p > start)",
          "1270:     {",
          "1271:  --p;",
          "1272:  if (*p == '-' || *p == '+')",
          "1273:  {",
          "1275: #ifdef FEAT_FLOAT",
          "1276:      if (rettv->v_type == VAR_FLOAT)",
          "1277:      {",
          "1278:   if (*p == '-')",
          "1279:       rettv->vval.v_float = -rettv->vval.v_float;",
          "1280:      }",
          "1281:      else",
          "1282: #endif",
          "1283:      {",
          "1284:   varnumber_T val;",
          "1285:   int  error = FALSE;",
          "1289:   if (check_not_string(rettv) == FAIL)",
          "1290:       return FAIL;",
          "1291:   val = tv_get_number_chk(rettv, &error);",
          "1292:   clear_tv(rettv);",
          "1293:   if (error)",
          "1294:       return FAIL;",
          "1295:   if (*p == '-')",
          "1296:       val = -val;",
          "1297:   rettv->v_type = VAR_NUMBER;",
          "1298:   rettv->vval.v_number = val;",
          "1299:      }",
          "1300:  }",
          "1301:  else if (numeric_only)",
          "1302:  {",
          "1303:      ++p;",
          "1304:      break;",
          "1305:  }",
          "1306:  else if (*p == '!')",
          "1307:  {",
          "1308:      int v = tv2bool(rettv);",
          "1311:      clear_tv(rettv);",
          "1312:      rettv->v_type = VAR_BOOL;",
          "1313:      rettv->vval.v_number = v ? VVAL_FALSE : VVAL_TRUE;",
          "1314:  }",
          "1315:     }",
          "1317:     return OK;",
          "1318: }",
          "1323:     static void",
          "1324: get_vim_constant(char_u **arg, typval_T *rettv)",
          "1325: {",
          "1326:     if (STRNCMP(*arg, \"v:true\", 6) == 0)",
          "1327:     {",
          "1328:  rettv->v_type = VAR_BOOL;",
          "1329:  rettv->vval.v_number = VVAL_TRUE;",
          "1331:     }",
          "1332:     else if (STRNCMP(*arg, \"v:false\", 7) == 0)",
          "1333:     {",
          "1334:  rettv->v_type = VAR_BOOL;",
          "1335:  rettv->vval.v_number = VVAL_FALSE;",
          "1337:     }",
          "1338:     else if (STRNCMP(*arg, \"v:null\", 6) == 0)",
          "1339:     {",
          "1340:  rettv->v_type = VAR_SPECIAL;",
          "1341:  rettv->vval.v_number = VVAL_NULL;",
          "1343:     }",
          "1344:     else if (STRNCMP(*arg, \"v:none\", 6) == 0)",
          "1345:     {",
          "1346:  rettv->v_type = VAR_SPECIAL;",
          "1347:  rettv->vval.v_number = VVAL_NONE;",
          "1349:     }",
          "1350: }",
          "1352:     exprtype_T",
          "1353: get_compare_type(char_u *p, int *len, int *type_is)",
          "1354: {",
          "1355:     exprtype_T type = EXPR_UNKNOWN;",
          "1356:     int  i;",
          "1358:     switch (p[0])",
          "1359:     {",
          "1360:  case '=':   if (p[1] == '=')",
          "1361:    type = EXPR_EQUAL;",
          "1362:       else if (p[1] == '~')",
          "1363:    type = EXPR_MATCH;",
          "1364:       break;",
          "1365:  case '!':   if (p[1] == '=')",
          "1366:    type = EXPR_NEQUAL;",
          "1367:       else if (p[1] == '~')",
          "1368:    type = EXPR_NOMATCH;",
          "1369:       break;",
          "1370:  case '>':   if (p[1] != '=')",
          "1371:       {",
          "1372:    type = EXPR_GREATER;",
          "1374:       }",
          "1375:       else",
          "1376:    type = EXPR_GEQUAL;",
          "1377:       break;",
          "1378:  case '<':   if (p[1] != '=')",
          "1379:       {",
          "1380:    type = EXPR_SMALLER;",
          "1382:       }",
          "1383:       else",
          "1384:    type = EXPR_SEQUAL;",
          "1385:       break;",
          "1386:  case 'i':   if (p[1] == 's')",
          "1387:       {",
          "1389:    if (p[2] == 'n' && p[3] == 'o' && p[4] == 't')",
          "1391:    i = p[*len];",
          "1392:    if (!isalnum(i) && i != '_')",
          "1393:    {",
          "1394:        type = *len == 2 ? EXPR_IS : EXPR_ISNOT;",
          "1396:    }",
          "1397:       }",
          "1398:       break;",
          "1399:     }",
          "1400:     return type;",
          "1401: }",
          "1406:     void",
          "1407: skip_expr_cctx(char_u **arg, cctx_T *cctx)",
          "1408: {",
          "1409:     evalarg_T evalarg;",
          "1411:     init_evalarg(&evalarg);",
          "1412:     evalarg.eval_cctx = cctx;",
          "1413:     skip_expr(arg, &evalarg);",
          "1414:     clear_evalarg(&evalarg, NULL);",
          "1415: }",
          "1421:     int",
          "1422: bool_on_stack(cctx_T *cctx)",
          "1423: {",
          "1424:     garray_T *stack = &cctx->ctx_type_stack;",
          "1425:     type_T *type;",
          "1427:     type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1428:     if (type == &t_bool)",
          "1429:  return OK;",
          "1431:     if (type == &t_any || type == &t_number || type == &t_number_bool)",
          "1434:  return generate_COND2BOOL(cctx);",
          "1436:     return need_type(type, &t_bool, -1, 0, cctx, FALSE, FALSE);",
          "1437: }",
          "1442:     void",
          "1443: error_white_both(char_u *op, int len)",
          "1444: {",
          "1445:     char_u buf[10];",
          "1447:     vim_strncpy(buf, op, len);",
          "1448:     semsg(_(e_white_space_required_before_and_after_str_at_str), buf, op);",
          "1449: }",
          "1455:     static int",
          "1456: compile_leader(cctx_T *cctx, int numeric_only, char_u *start, char_u **end)",
          "1457: {",
          "1458:     char_u *p = *end;",
          "1461:     while (p > start)",
          "1462:     {",
          "1463:  --p;",
          "1464:  while (VIM_ISWHITE(*p))",
          "1465:      --p;",
          "1466:  if (*p == '-' || *p == '+')",
          "1467:  {",
          "1468:      int  negate = *p == '-';",
          "1469:      isn_T *isn;",
          "1470:      garray_T    *stack = &cctx->ctx_type_stack;",
          "1471:      type_T *type;",
          "1473:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1474:      if (type != &t_float && need_type(type, &t_number,",
          "1475:          -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1476:   return FAIL;",
          "1478:      while (p > start && (p[-1] == '-' || p[-1] == '+'))",
          "1479:      {",
          "1480:   --p;",
          "1481:   if (*p == '-')",
          "1482:       negate = !negate;",
          "1483:      }",
          "1485:      if (negate)",
          "1486:      {",
          "1487:   isn = generate_instr(cctx, ISN_NEGATENR);",
          "1488:   if (isn == NULL)",
          "1489:       return FAIL;",
          "1490:      }",
          "1491:  }",
          "1492:  else if (numeric_only)",
          "1493:  {",
          "1494:      ++p;",
          "1495:      break;",
          "1496:  }",
          "1497:  else",
          "1498:  {",
          "1499:      int  invert = *p == '!';",
          "1501:      while (p > start && (p[-1] == '!' || VIM_ISWHITE(p[-1])))",
          "1502:      {",
          "1503:   if (p[-1] == '!')",
          "1504:       invert = !invert;",
          "1505:   --p;",
          "1506:      }",
          "1507:      if (generate_2BOOL(cctx, invert, -1) == FAIL)",
          "1508:   return FAIL;",
          "1509:  }",
          "1510:     }",
          "1512:     return OK;",
          "1513: }",
          "1519:     static int",
          "1520: compile_parenthesis(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "1521: {",
          "1522:     int     ret;",
          "1523:     char_u  *p = *arg + 1;",
          "1525:     if (may_get_next_line_error(p, arg, cctx) == FAIL)",
          "1526:  return FAIL;",
          "1527:     if (ppconst->pp_used <= PPSIZE - 10)",
          "1528:     {",
          "1529:  ret = compile_expr1(arg, cctx, ppconst);",
          "1530:     }",
          "1531:     else",
          "1532:     {",
          "1534:  if (generate_ppconst(cctx, ppconst) == FAIL)",
          "1535:      return FAIL;",
          "1536:  ret = compile_expr0(arg, cctx);",
          "1537:     }",
          "1538:     if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "1539:  return FAIL;",
          "1540:     if (**arg == ')')",
          "1541:  ++*arg;",
          "1542:     else if (ret == OK)",
          "1543:     {",
          "1544:  emsg(_(e_missing_closing_paren));",
          "1545:  ret = FAIL;",
          "1546:     }",
          "1547:     return ret;",
          "1548: }",
          "1554:     static int",
          "1555: compile_subscript(",
          "1556:  char_u **arg,",
          "1557:  cctx_T *cctx,",
          "1558:  char_u *start_leader,",
          "1559:  char_u **end_leader,",
          "1560:  ppconst_T *ppconst)",
          "1561: {",
          "1562:     char_u *name_start = *end_leader;",
          "1563:     int  keeping_dict = FALSE;",
          "1565:     for (;;)",
          "1566:     {",
          "1567:  char_u *p = skipwhite(*arg);",
          "1569:  if (*p == NUL || (VIM_ISWHITE(**arg) && vim9_comment_start(p)))",
          "1570:  {",
          "1571:      char_u *next = peek_next_line_from_context(cctx);",
          "1576:      if (next != NULL &&",
          "1577:       ((next[0] == '-' && next[1] == '>'",
          "1578:      && (next[2] == '{'",
          "1579:            || ASCII_ISALPHA(*skipwhite(next + 2))))",
          "1580:       || (next[0] == '.' && eval_isdictc(next[1]))))",
          "1581:      {",
          "1582:   next = next_line_from_context(cctx, TRUE);",
          "1583:   if (next == NULL)",
          "1584:       return FAIL;",
          "1586:   p = skipwhite(*arg);",
          "1587:      }",
          "1588:  }",
          "1592:  if (**arg == '(')",
          "1593:  {",
          "1594:      garray_T    *stack = &cctx->ctx_type_stack;",
          "1595:      type_T *type;",
          "1596:      int  argcount = 0;",
          "1598:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "1599:   return FAIL;",
          "1600:      ppconst->pp_is_const = FALSE;",
          "1603:      type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1606:      if (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)",
          "1607:   return FAIL;",
          "1608:      if (generate_PCALL(cctx, argcount, name_start, type, TRUE) == FAIL)",
          "1609:   return FAIL;",
          "1610:      if (keeping_dict)",
          "1611:      {",
          "1612:   keeping_dict = FALSE;",
          "1613:   if (generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "1614:       return FAIL;",
          "1615:      }",
          "1616:  }",
          "1617:  else if (*p == '-' && p[1] == '>')",
          "1618:  {",
          "1619:      char_u *pstart = p;",
          "1621:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "1622:   return FAIL;",
          "1623:      ppconst->pp_is_const = FALSE;",
          "1628:      if (compile_leader(cctx, TRUE, start_leader, end_leader) == FAIL)",
          "1629:   return FAIL;",
          "1631:      p += 2;",
          "1634:      if (**arg == '(')",
          "1635:      {",
          "1636:   int     argcount = 1;",
          "1637:   garray_T    *stack = &cctx->ctx_type_stack;",
          "1638:   int     type_idx_start = stack->ga_len;",
          "1639:   type_T     *type;",
          "1640:   int     expr_isn_start = cctx->ctx_instr.ga_len;",
          "1641:   int     expr_isn_end;",
          "1642:   int     arg_isn_count;",
          "1648:   if (compile_parenthesis(arg, cctx, ppconst) == FAIL)",
          "1649:       return FAIL;",
          "1653:   expr_isn_end = cctx->ctx_instr.ga_len;",
          "1656:   if (**arg != '(')",
          "1657:   {",
          "1658:       if (*skipwhite(*arg) == '(')",
          "1659:    emsg(_(e_nowhitespace));",
          "1660:       else",
          "1661:    semsg(_(e_missing_parenthesis_str), *arg);",
          "1662:       return FAIL;",
          "1663:   }",
          "1665:   if (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)",
          "1666:       return FAIL;",
          "1672:   stack = &cctx->ctx_type_stack;",
          "1673:   arg_isn_count = cctx->ctx_instr.ga_len - expr_isn_end;",
          "1674:   if (arg_isn_count > 0)",
          "1675:   {",
          "1676:       int     expr_isn_count = expr_isn_end - expr_isn_start;",
          "1677:       isn_T   *isn = ALLOC_MULT(isn_T, expr_isn_count);",
          "1679:       if (isn == NULL)",
          "1680:    return FAIL;",
          "1681:       mch_memmove(isn, ((isn_T *)cctx->ctx_instr.ga_data)",
          "1682:              + expr_isn_start,",
          "1683:             sizeof(isn_T) * expr_isn_count);",
          "1684:       mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)",
          "1685:              + expr_isn_start,",
          "1686:         ((isn_T *)cctx->ctx_instr.ga_data) + expr_isn_end,",
          "1687:       sizeof(isn_T) * arg_isn_count);",
          "1688:       mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)",
          "1689:            + expr_isn_start + arg_isn_count,",
          "1690:        isn, sizeof(isn_T) * expr_isn_count);",
          "1691:       vim_free(isn);",
          "1693:       type = ((type_T **)stack->ga_data)[type_idx_start];",
          "1694:       mch_memmove(((type_T **)stack->ga_data) + type_idx_start,",
          "1695:          ((type_T **)stack->ga_data) + type_idx_start + 1,",
          "1696:          sizeof(type_T *)",
          "1698:       ((type_T **)stack->ga_data)[stack->ga_len - 1] = type;",
          "1699:   }",
          "1701:   type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1702:   if (generate_PCALL(cctx, argcount, p - 2, type, FALSE) == FAIL)",
          "1703:       return FAIL;",
          "1704:      }",
          "1705:      else",
          "1706:      {",
          "1708:   p = *arg;",
          "1709:   if (!eval_isnamec1(*p))",
          "1710:   {",
          "1711:       semsg(_(e_trailing_arg), pstart);",
          "1712:       return FAIL;",
          "1713:   }",
          "1714:   if (ASCII_ISALPHA(*p) && p[1] == ':')",
          "1715:       p += 2;",
          "1716:   for ( ; eval_isnamec(*p); ++p)",
          "1717:       ;",
          "1718:   if (*p != '(')",
          "1719:   {",
          "1720:       semsg(_(e_missing_parenthesis_str), *arg);",
          "1721:       return FAIL;",
          "1722:   }",
          "1723:   if (compile_call(arg, p - *arg, cctx, ppconst, 1) == FAIL)",
          "1724:       return FAIL;",
          "1725:      }",
          "1726:      if (keeping_dict)",
          "1727:      {",
          "1728:   keeping_dict = FALSE;",
          "1729:   if (generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "1730:       return FAIL;",
          "1731:      }",
          "1732:  }",
          "1733:  else if (**arg == '[')",
          "1734:  {",
          "1735:      int  is_slice = FALSE;",
          "1741:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "1742:   return FAIL;",
          "1743:      ppconst->pp_is_const = FALSE;",
          "1745:      ++p;",
          "1746:      if (may_get_next_line_error(p, arg, cctx) == FAIL)",
          "1747:   return FAIL;",
          "1748:      if (**arg == ':')",
          "1749:      {",
          "1751:   generate_PUSHNR(cctx, 0);",
          "1752:      }",
          "1753:      else",
          "1754:      {",
          "1755:   if (compile_expr0(arg, cctx) == FAIL)",
          "1756:       return FAIL;",
          "1757:   if (**arg == ':')",
          "1758:   {",
          "1759:       semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "1760:             \":\", *arg);",
          "1761:       return FAIL;",
          "1762:   }",
          "1763:   if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "1764:       return FAIL;",
          "1766:      }",
          "1767:      if (**arg == ':')",
          "1768:      {",
          "1769:   is_slice = TRUE;",
          "1770:   ++*arg;",
          "1771:   if (!IS_WHITE_OR_NUL(**arg) && **arg != ']')",
          "1772:   {",
          "1773:       semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "1774:             \":\", *arg);",
          "1775:       return FAIL;",
          "1776:   }",
          "1777:   if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "1778:       return FAIL;",
          "1779:   if (**arg == ']')",
          "1781:       generate_PUSHNR(cctx, -1);",
          "1782:   else",
          "1783:   {",
          "1784:       if (compile_expr0(arg, cctx) == FAIL)",
          "1785:    return FAIL;",
          "1786:       if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "1787:    return FAIL;",
          "1789:   }",
          "1790:      }",
          "1792:      if (**arg != ']')",
          "1793:      {",
          "1794:   emsg(_(e_missing_closing_square_brace));",
          "1795:   return FAIL;",
          "1796:      }",
          "1799:      if (keeping_dict)",
          "1800:      {",
          "1801:   keeping_dict = FALSE;",
          "1802:   if (generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "1803:       return FAIL;",
          "1804:      }",
          "1805:      if (compile_member(is_slice, &keeping_dict, cctx) == FAIL)",
          "1806:   return FAIL;",
          "1807:  }",
          "1808:  else if (*p == '.' && p[1] != '.')",
          "1809:  {",
          "1811:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "1812:   return FAIL;",
          "1813:      ppconst->pp_is_const = FALSE;",
          "1816:      if (IS_WHITE_OR_NUL(**arg))",
          "1817:      {",
          "1818:   emsg(_(e_missing_name_after_dot));",
          "1819:   return FAIL;",
          "1820:      }",
          "1821:      p = *arg;",
          "1822:      if (eval_isdictc(*p))",
          "1823:   while (eval_isnamec(*p))",
          "1824:       MB_PTR_ADV(p);",
          "1825:      if (p == *arg)",
          "1826:      {",
          "1827:   semsg(_(e_syntax_error_at_str), *arg);",
          "1828:   return FAIL;",
          "1829:      }",
          "1830:      if (keeping_dict && generate_instr(cctx, ISN_CLEARDICT) == NULL)",
          "1831:   return FAIL;",
          "1832:      if (generate_STRINGMEMBER(cctx, *arg, p - *arg) == FAIL)",
          "1833:   return FAIL;",
          "1834:      keeping_dict = TRUE;",
          "1836:  }",
          "1837:  else",
          "1838:      break;",
          "1839:     }",
          "1843:     if (keeping_dict && generate_instr(cctx, ISN_USEDICT) == NULL)",
          "1844:  return FAIL;",
          "1846:     return OK;",
          "1847: }",
          "1882:     static int",
          "1883: compile_expr7(",
          "1884:  char_u **arg,",
          "1885:  cctx_T *cctx,",
          "1886:  ppconst_T *ppconst)",
          "1887: {",
          "1888:     char_u *start_leader, *end_leader;",
          "1889:     int  ret = OK;",
          "1890:     typval_T *rettv = &ppconst->pp_tv[ppconst->pp_used];",
          "1891:     int  used_before = ppconst->pp_used;",
          "1893:     ppconst->pp_is_const = FALSE;",
          "1898:     start_leader = *arg;",
          "1899:     if (eval_leader(arg, TRUE) == FAIL)",
          "1900:  return FAIL;",
          "1901:     end_leader = *arg;",
          "1903:     rettv->v_type = VAR_UNKNOWN;",
          "1904:     switch (**arg)",
          "1905:     {",
          "1909:  case '0': // also for blob starting with 0z",
          "1910:  case '1':",
          "1911:  case '2':",
          "1912:  case '3':",
          "1913:  case '4':",
          "1914:  case '5':",
          "1915:  case '6':",
          "1916:  case '7':",
          "1917:  case '8':",
          "1918:  case '9':",
          "1919:  case '.':   if (eval_number(arg, rettv, TRUE, FALSE) == FAIL)",
          "1920:    return FAIL;",
          "1924:       if (apply_leader(rettv, TRUE,",
          "1925:          start_leader, &end_leader) == FAIL)",
          "1926:       {",
          "1927:    clear_tv(rettv);",
          "1928:    return FAIL;",
          "1929:       }",
          "1930:       break;",
          "1935:  case '\"':   if (eval_string(arg, rettv, TRUE) == FAIL)",
          "1936:    return FAIL;",
          "1937:       break;",
          "1942:  case '\\'':  if (eval_lit_string(arg, rettv, TRUE) == FAIL)",
          "1943:    return FAIL;",
          "1944:       break;",
          "1949:  case 'v':   get_vim_constant(arg, rettv);",
          "1950:       ret = NOTDONE;",
          "1951:       break;",
          "1956:  case 't':   if (STRNCMP(*arg, \"true\", 4) == 0",
          "1957:          && !eval_isnamec((*arg)[4]))",
          "1958:       {",
          "1960:    rettv->v_type = VAR_BOOL;",
          "1961:    rettv->vval.v_number = VVAL_TRUE;",
          "1962:       }",
          "1963:       else",
          "1964:    ret = NOTDONE;",
          "1965:       break;",
          "1970:  case 'f':   if (STRNCMP(*arg, \"false\", 5) == 0",
          "1971:          && !eval_isnamec((*arg)[5]))",
          "1972:       {",
          "1974:    rettv->v_type = VAR_BOOL;",
          "1975:    rettv->vval.v_number = VVAL_FALSE;",
          "1976:       }",
          "1977:       else",
          "1978:    ret = NOTDONE;",
          "1979:       break;",
          "1984:  case 'n':   if (STRNCMP(*arg, \"null\", 4) == 0",
          "1985:          && !eval_isnamec((*arg)[4]))",
          "1986:       {",
          "1988:    rettv->v_type = VAR_SPECIAL;",
          "1989:    rettv->vval.v_number = VVAL_NULL;",
          "1990:       }",
          "1991:       else",
          "1992:    ret = NOTDONE;",
          "1993:       break;",
          "1998:  case '[':   if (generate_ppconst(cctx, ppconst) == FAIL)",
          "1999:    return FAIL;",
          "2000:       ret = compile_list(arg, cctx, ppconst);",
          "2001:       break;",
          "2006:  case '{':   if (generate_ppconst(cctx, ppconst) == FAIL)",
          "2007:    return FAIL;",
          "2008:       ret = compile_dict(arg, cctx, ppconst);",
          "2009:       break;",
          "2014:  case '&': if (generate_ppconst(cctx, ppconst) == FAIL)",
          "2015:        return FAIL;",
          "2016:    ret = compile_get_option(arg, cctx);",
          "2017:    break;",
          "2022:  case '$': if (generate_ppconst(cctx, ppconst) == FAIL)",
          "2023:        return FAIL;",
          "2024:    ret = compile_get_env(arg, cctx);",
          "2025:    break;",
          "2030:  case '@': if (generate_ppconst(cctx, ppconst) == FAIL)",
          "2031:        return FAIL;",
          "2032:    ret = compile_get_register(arg, cctx);",
          "2033:    break;",
          "2039:  case '(':   // if compile_lambda returns NOTDONE then it must be (expr)",
          "2040:       ret = compile_lambda(arg, cctx);",
          "2041:       if (ret == NOTDONE)",
          "2042:    ret = compile_parenthesis(arg, cctx, ppconst);",
          "2043:       break;",
          "2045:  default:    ret = NOTDONE;",
          "2046:       break;",
          "2047:     }",
          "2048:     if (ret == FAIL)",
          "2049:  return FAIL;",
          "2051:     if (rettv->v_type != VAR_UNKNOWN && used_before == ppconst->pp_used)",
          "2052:     {",
          "2053:  if (cctx->ctx_skip == SKIP_YES)",
          "2054:      clear_tv(rettv);",
          "2055:  else",
          "2058:      ++ppconst->pp_used;",
          "2059:     }",
          "2060:     else if (ret == NOTDONE)",
          "2061:     {",
          "2062:  char_u     *p;",
          "2063:  int     r;",
          "2065:  if (!eval_isnamec1(**arg))",
          "2066:  {",
          "2067:      if (!vim9_bad_comment(*arg))",
          "2068:      {",
          "2069:   if (ends_excmd(*skipwhite(*arg)))",
          "2070:       semsg(_(e_empty_expression_str), *arg);",
          "2071:   else",
          "2072:       semsg(_(e_name_expected_str), *arg);",
          "2073:      }",
          "2074:      return FAIL;",
          "2075:  }",
          "2078:  p = to_name_end(*arg, TRUE);",
          "2079:  if (p - *arg == (size_t)1 && **arg == '_')",
          "2080:  {",
          "2081:      emsg(_(e_cannot_use_underscore_here));",
          "2082:      return FAIL;",
          "2083:  }",
          "2085:  if (*p == '(')",
          "2086:  {",
          "2087:      r = compile_call(arg, p - *arg, cctx, ppconst, 0);",
          "2088:  }",
          "2089:  else",
          "2090:  {",
          "2091:      if (cctx->ctx_skip != SKIP_YES",
          "2092:         && generate_ppconst(cctx, ppconst) == FAIL)",
          "2093:   return FAIL;",
          "2094:      r = compile_load(arg, p, cctx, TRUE, TRUE);",
          "2095:  }",
          "2096:  if (r == FAIL)",
          "2097:      return FAIL;",
          "2098:     }",
          "2102:     if (compile_subscript(arg, cctx, start_leader, &end_leader,",
          "2103:             ppconst) == FAIL)",
          "2104:  return FAIL;",
          "2105:     if (ppconst->pp_used > 0)",
          "2106:     {",
          "2108:  rettv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "2109:  if (apply_leader(rettv, FALSE, start_leader, &end_leader) == FAIL)",
          "2110:      return FAIL;",
          "2111:  return OK;",
          "2112:     }",
          "2113:     if (compile_leader(cctx, FALSE, start_leader, &end_leader) == FAIL)",
          "2114:  return FAIL;",
          "2115:     return OK;",
          "2116: }",
          "2121:     static int",
          "2122: compile_expr7t(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "2123: {",
          "2124:     type_T *want_type = NULL;",
          "2127:     if (**arg == '<' && eval_isnamec1((*arg)[1]))",
          "2128:     {",
          "2129:  ++*arg;",
          "2130:  want_type = parse_type(arg, cctx->ctx_type_list, TRUE);",
          "2131:  if (want_type == NULL)",
          "2132:      return FAIL;",
          "2134:  if (**arg != '>')",
          "2135:  {",
          "2136:      if (*skipwhite(*arg) == '>')",
          "2137:   semsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);",
          "2138:      else",
          "2139:   emsg(_(e_missing_gt));",
          "2140:      return FAIL;",
          "2141:  }",
          "2142:  ++*arg;",
          "2143:  if (may_get_next_line_error(*arg, arg, cctx) == FAIL)",
          "2144:      return FAIL;",
          "2145:     }",
          "2147:     if (compile_expr7(arg, cctx, ppconst) == FAIL)",
          "2148:  return FAIL;",
          "2150:     if (want_type != NULL)",
          "2151:     {",
          "2152:  garray_T    *stack = &cctx->ctx_type_stack;",
          "2153:  type_T     *actual;",
          "2154:  where_T     where = WHERE_INIT;",
          "2156:  generate_ppconst(cctx, ppconst);",
          "2157:  actual = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "2158:  if (check_type(want_type, actual, FALSE, where) == FAIL)",
          "2159:  {",
          "2160:      if (need_type(actual, want_type, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "2161:   return FAIL;",
          "2162:  }",
          "2163:     }",
          "2165:     return OK;",
          "2166: }",
          "2173:     static int",
          "2174: compile_expr6(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "2175: {",
          "2176:     char_u *op;",
          "2177:     char_u *next;",
          "2178:     int  ppconst_used = ppconst->pp_used;",
          "2181:     if (compile_expr7t(arg, cctx, ppconst) == FAIL)",
          "2182:  return FAIL;",
          "2187:     for (;;)",
          "2188:     {",
          "2189:  op = may_peek_next_line(cctx, *arg, &next);",
          "2190:  if (*op != '*' && *op != '/' && *op != '%')",
          "2191:      break;",
          "2192:  if (next != NULL)",
          "2193:  {",
          "2195:      op = skipwhite(*arg);",
          "2196:  }",
          "2198:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[1]))",
          "2199:  {",
          "2200:      error_white_both(op, 1);",
          "2201:      return FAIL;",
          "2202:  }",
          "2203:  if (may_get_next_line_error(op + 1, arg, cctx) == FAIL)",
          "2204:      return FAIL;",
          "2207:  if (compile_expr7t(arg, cctx, ppconst) == FAIL)",
          "2208:      return FAIL;",
          "2210:  if (ppconst->pp_used == ppconst_used + 2",
          "2211:   && ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER",
          "2212:   && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)",
          "2213:  {",
          "2214:      typval_T     *tv1 = &ppconst->pp_tv[ppconst_used];",
          "2215:      typval_T     *tv2 = &ppconst->pp_tv[ppconst_used + 1];",
          "2216:      varnumber_T     res = 0;",
          "2217:      int      failed = FALSE;",
          "2220:      switch (*op)",
          "2221:      {",
          "2222:   case '*': res = tv1->vval.v_number * tv2->vval.v_number;",
          "2223:      break;",
          "2224:   case '/': res = num_divide(tv1->vval.v_number,",
          "2225:         tv2->vval.v_number, &failed);",
          "2226:      break;",
          "2227:   case '%': res = num_modulus(tv1->vval.v_number,",
          "2228:         tv2->vval.v_number, &failed);",
          "2229:      break;",
          "2230:      }",
          "2231:      if (failed)",
          "2232:   return FAIL;",
          "2233:      tv1->vval.v_number = res;",
          "2234:      --ppconst->pp_used;",
          "2235:  }",
          "2236:  else",
          "2237:  {",
          "2238:      generate_ppconst(cctx, ppconst);",
          "2239:      generate_two_op(cctx, op);",
          "2240:  }",
          "2241:     }",
          "2243:     return OK;",
          "2244: }",
          "2251:     static int",
          "2252: compile_expr5(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "2253: {",
          "2254:     char_u *op;",
          "2255:     char_u *next;",
          "2256:     int  oplen;",
          "2257:     int  ppconst_used = ppconst->pp_used;",
          "2260:     if (compile_expr6(arg, cctx, ppconst) == FAIL)",
          "2261:  return FAIL;",
          "2266:     for (;;)",
          "2267:     {",
          "2268:  op = may_peek_next_line(cctx, *arg, &next);",
          "2269:  if (*op != '+' && *op != '-' && !(*op == '.' && *(op + 1) == '.'))",
          "2270:      break;",
          "2271:  if (op[0] == op[1] && *op != '.' && next)",
          "2274:      break;",
          "2275:  oplen = (*op == '.' ? 2 : 1);",
          "2276:  if (next != NULL)",
          "2277:  {",
          "2279:      op = skipwhite(*arg);",
          "2280:  }",
          "2282:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[oplen]))",
          "2283:  {",
          "2284:      error_white_both(op, oplen);",
          "2285:      return FAIL;",
          "2286:  }",
          "2288:  if (may_get_next_line_error(op + oplen, arg, cctx) == FAIL)",
          "2289:      return FAIL;",
          "2292:  if (compile_expr6(arg, cctx, ppconst) == FAIL)",
          "2293:      return FAIL;",
          "2295:  if (ppconst->pp_used == ppconst_used + 2",
          "2296:   && (*op == '.'",
          "2297:       ? (ppconst->pp_tv[ppconst_used].v_type == VAR_STRING",
          "2298:       && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_STRING)",
          "2299:       : (ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER",
          "2300:       && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)))",
          "2301:  {",
          "2302:      typval_T *tv1 = &ppconst->pp_tv[ppconst_used];",
          "2303:      typval_T *tv2 = &ppconst->pp_tv[ppconst_used + 1];",
          "2306:      if (*op == '+')",
          "2307:   tv1->vval.v_number = tv1->vval.v_number + tv2->vval.v_number;",
          "2308:      else if (*op == '-')",
          "2309:   tv1->vval.v_number = tv1->vval.v_number - tv2->vval.v_number;",
          "2310:      else",
          "2311:      {",
          "2313:   char_u *s1 = tv1->vval.v_string;",
          "2314:   char_u *s2 = tv2->vval.v_string;",
          "2315:   size_t len1 = STRLEN(s1);",
          "2317:   tv1->vval.v_string = alloc((int)(len1 + STRLEN(s2) + 1));",
          "2318:   if (tv1->vval.v_string == NULL)",
          "2319:   {",
          "2320:       clear_ppconst(ppconst);",
          "2321:       return FAIL;",
          "2322:   }",
          "2323:   mch_memmove(tv1->vval.v_string, s1, len1);",
          "2324:   STRCPY(tv1->vval.v_string + len1, s2);",
          "2325:   vim_free(s1);",
          "2326:   vim_free(s2);",
          "2327:      }",
          "2328:      --ppconst->pp_used;",
          "2329:  }",
          "2330:  else",
          "2331:  {",
          "2332:      generate_ppconst(cctx, ppconst);",
          "2333:      ppconst->pp_is_const = FALSE;",
          "2334:      if (*op == '.')",
          "2335:      {",
          "2336:   if (may_generate_2STRING(-2, FALSE, cctx) == FAIL",
          "2337:    || may_generate_2STRING(-1, FALSE, cctx) == FAIL)",
          "2338:       return FAIL;",
          "2339:   generate_instr_drop(cctx, ISN_CONCAT, 1);",
          "2340:      }",
          "2341:      else",
          "2342:   generate_two_op(cctx, op);",
          "2343:  }",
          "2344:     }",
          "2346:     return OK;",
          "2347: }",
          "2366:     static int",
          "2367: compile_expr4(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "2368: {",
          "2369:     exprtype_T type = EXPR_UNKNOWN;",
          "2370:     char_u *p;",
          "2371:     char_u *next;",
          "2372:     int  len = 2;",
          "2373:     int  type_is = FALSE;",
          "2374:     int  ppconst_used = ppconst->pp_used;",
          "2377:     if (compile_expr5(arg, cctx, ppconst) == FAIL)",
          "2378:  return FAIL;",
          "2380:     p = may_peek_next_line(cctx, *arg, &next);",
          "2381:     type = get_compare_type(p, &len, &type_is);",
          "2386:     if (type != EXPR_UNKNOWN)",
          "2387:     {",
          "2388:  int ic = FALSE;  // Default: do not ignore case",
          "2390:  if (next != NULL)",
          "2391:  {",
          "2393:      p = skipwhite(*arg);",
          "2394:  }",
          "2395:  if (type_is && (p[len] == '?' || p[len] == '#'))",
          "2396:  {",
          "2397:      semsg(_(e_invalid_expression_str), *arg);",
          "2398:      return FAIL;",
          "2399:  }",
          "2401:  if (p[len] == '?')",
          "2402:  {",
          "2403:      ic = TRUE;",
          "2404:      ++len;",
          "2405:  }",
          "2407:  else if (p[len] == '#')",
          "2408:      ++len;",
          "2411:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[len]))",
          "2412:  {",
          "2413:      error_white_both(p, len);",
          "2414:      return FAIL;",
          "2415:  }",
          "2418:  if (may_get_next_line_error(p + len, arg, cctx) == FAIL)",
          "2419:      return FAIL;",
          "2421:  if (compile_expr5(arg, cctx, ppconst) == FAIL)",
          "2422:      return FAIL;",
          "2424:  if (ppconst->pp_used == ppconst_used + 2)",
          "2425:  {",
          "2426:      typval_T * tv1 = &ppconst->pp_tv[ppconst->pp_used - 2];",
          "2427:      typval_T *tv2 = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "2428:      int  ret;",
          "2433:      if (check_compare_types(type, tv1, tv2) == FAIL)",
          "2434:   ret = FAIL;",
          "2435:      else",
          "2436:      {",
          "2437:   ret = typval_compare(tv1, tv2, type, ic);",
          "2438:   tv1->v_type = VAR_BOOL;",
          "2439:   tv1->vval.v_number = tv1->vval.v_number",
          "2440:             ? VVAL_TRUE : VVAL_FALSE;",
          "2441:   clear_tv(tv2);",
          "2442:   --ppconst->pp_used;",
          "2443:      }",
          "2444:      return ret;",
          "2445:  }",
          "2447:  generate_ppconst(cctx, ppconst);",
          "2448:  return generate_COMPARE(cctx, type, ic);",
          "2449:     }",
          "2451:     return OK;",
          "2452: }",
          "2454: static int compile_expr3(char_u **arg,  cctx_T *cctx, ppconst_T *ppconst);",
          "2459:     static int",
          "2460: compile_and_or(",
          "2461:  char_u **arg,",
          "2462:  cctx_T *cctx,",
          "2463:  char *op,",
          "2464:  ppconst_T *ppconst,",
          "2465:  int ppconst_used UNUSED)",
          "2466: {",
          "2467:     char_u *next;",
          "2468:     char_u *p = may_peek_next_line(cctx, *arg, &next);",
          "2469:     int  opchar = *op;",
          "2471:     if (p[0] == opchar && p[1] == opchar)",
          "2472:     {",
          "2473:  garray_T *instr = &cctx->ctx_instr;",
          "2474:  garray_T end_ga;",
          "2475:  int  save_skip = cctx->ctx_skip;",
          "2480:  ga_init2(&end_ga, sizeof(int), 10);",
          "2481:  while (p[0] == opchar && p[1] == opchar)",
          "2482:  {",
          "2483:      long start_lnum = SOURCING_LNUM;",
          "2484:      long save_sourcing_lnum;",
          "2485:      int  start_ctx_lnum = cctx->ctx_lnum;",
          "2486:      int  save_lnum;",
          "2487:      int  const_used;",
          "2488:      int  status;",
          "2489:      jumpwhen_T jump_when = opchar == '|'",
          "2490:           ? JUMP_IF_COND_TRUE : JUMP_IF_COND_FALSE;",
          "2492:      if (next != NULL)",
          "2493:      {",
          "2495:   p = skipwhite(*arg);",
          "2496:      }",
          "2498:      if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[2]))",
          "2499:      {",
          "2500:   semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "2501:          op, p);",
          "2502:   ga_clear(&end_ga);",
          "2503:   return FAIL;",
          "2504:      }",
          "2506:      save_sourcing_lnum = SOURCING_LNUM;",
          "2507:      SOURCING_LNUM = start_lnum;",
          "2508:      save_lnum = cctx->ctx_lnum;",
          "2509:      cctx->ctx_lnum = start_ctx_lnum;",
          "2511:      status = check_ppconst_bool(ppconst);",
          "2512:      if (status != FAIL)",
          "2513:      {",
          "2515:   if (ppconst->pp_used > 0)",
          "2516:   {",
          "2517:       typval_T *tv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "2518:       int  is_true = tv2bool(tv);",
          "2520:       if ((is_true && opchar == '|')",
          "2521:       || (!is_true && opchar == '&'))",
          "2522:       {",
          "2525:    cctx->ctx_skip = SKIP_YES;",
          "2526:    clear_tv(tv);",
          "2527:    tv->v_type = VAR_BOOL;",
          "2528:    tv->vval.v_number = is_true ? VVAL_TRUE : VVAL_FALSE;",
          "2529:       }",
          "2530:       else",
          "2531:       {",
          "2534:    --ppconst->pp_used;",
          "2535:    jump_when = JUMP_NEVER;",
          "2536:       }",
          "2537:   }",
          "2538:   else",
          "2539:   {",
          "2541:       status = bool_on_stack(cctx);",
          "2542:   }",
          "2543:      }",
          "2544:      if (status != FAIL)",
          "2545:   status = ga_grow(&end_ga, 1);",
          "2546:      cctx->ctx_lnum = save_lnum;",
          "2547:      if (status == FAIL)",
          "2548:      {",
          "2549:   ga_clear(&end_ga);",
          "2550:   return FAIL;",
          "2551:      }",
          "2553:      if (jump_when != JUMP_NEVER)",
          "2554:      {",
          "2555:   if (cctx->ctx_skip != SKIP_YES)",
          "2556:   {",
          "2558:       ++end_ga.ga_len;",
          "2559:   }",
          "2560:   generate_JUMP(cctx, jump_when, 0);",
          "2561:      }",
          "2564:      SOURCING_LNUM = save_sourcing_lnum;",
          "2565:      if (may_get_next_line_error(p + 2, arg, cctx) == FAIL)",
          "2566:      {",
          "2567:   ga_clear(&end_ga);",
          "2568:   return FAIL;",
          "2569:      }",
          "2571:      const_used = ppconst->pp_used;",
          "2572:      if ((opchar == '|' ? compile_expr3(arg, cctx, ppconst)",
          "2573:       : compile_expr4(arg, cctx, ppconst)) == FAIL)",
          "2574:      {",
          "2575:   ga_clear(&end_ga);",
          "2576:   return FAIL;",
          "2577:      }",
          "2580:      if (ppconst->pp_used == const_used + 1)",
          "2581:      {",
          "2582:   typval_T *tv = &ppconst->pp_tv[ppconst->pp_used - 1];",
          "2584:   if (tv->v_type == VAR_NUMBER",
          "2585:     && (tv->vval.v_number == 1 || tv->vval.v_number == 0))",
          "2586:   {",
          "2587:       tv->vval.v_number = tv->vval.v_number == 1",
          "2588:             ? VVAL_TRUE : VVAL_FALSE;",
          "2589:       tv->v_type = VAR_BOOL;",
          "2590:   }",
          "2591:      }",
          "2593:      p = may_peek_next_line(cctx, *arg, &next);",
          "2594:  }",
          "2596:  if (check_ppconst_bool(ppconst) == FAIL)",
          "2597:  {",
          "2598:      ga_clear(&end_ga);",
          "2599:      return FAIL;",
          "2600:  }",
          "2602:  if (cctx->ctx_skip != SKIP_YES && ppconst->pp_used == 0)",
          "2604:      if (bool_on_stack(cctx) == FAIL)",
          "2605:      {",
          "2606:   ga_clear(&end_ga);",
          "2607:   return FAIL;",
          "2608:      }",
          "2610:  if (end_ga.ga_len > 0)",
          "2611:  {",
          "2613:      generate_ppconst(cctx, ppconst);",
          "2614:      while (end_ga.ga_len > 0)",
          "2615:      {",
          "2616:   isn_T *isn;",
          "2618:   --end_ga.ga_len;",
          "2619:   isn = ((isn_T *)instr->ga_data)",
          "2620:       + *(((int *)end_ga.ga_data) + end_ga.ga_len);",
          "2621:   isn->isn_arg.jump.jump_where = instr->ga_len;",
          "2622:      }",
          "2623:  }",
          "2624:  ga_clear(&end_ga);",
          "2626:  cctx->ctx_skip = save_skip;",
          "2627:     }",
          "2629:     return OK;",
          "2630: }",
          "2644:     static int",
          "2645: compile_expr3(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "2646: {",
          "2647:     int  ppconst_used = ppconst->pp_used;",
          "2650:     if (compile_expr4(arg, cctx, ppconst) == FAIL)",
          "2651:  return FAIL;",
          "2654:     return compile_and_or(arg, cctx, \"&&\", ppconst, ppconst_used);",
          "2655: }",
          "2669:     static int",
          "2670: compile_expr2(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "2671: {",
          "2672:     int  ppconst_used = ppconst->pp_used;",
          "2675:     if (compile_expr3(arg, cctx, ppconst) == FAIL)",
          "2676:  return FAIL;",
          "2679:     return compile_and_or(arg, cctx, \"||\", ppconst, ppconst_used);",
          "2680: }",
          "2699:     int",
          "2700: compile_expr1(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)",
          "2701: {",
          "2702:     char_u *p;",
          "2703:     int  ppconst_used = ppconst->pp_used;",
          "2704:     char_u *next;",
          "2707:     if (cctx->ctx_skip == SKIP_YES)",
          "2708:     {",
          "2709:  skip_expr_cctx(arg, cctx);",
          "2710:  return OK;",
          "2711:     }",
          "2714:     if (compile_expr2(arg, cctx, ppconst) == FAIL)",
          "2715:  return FAIL;",
          "2717:     p = may_peek_next_line(cctx, *arg, &next);",
          "2718:     if (*p == '?')",
          "2719:     {",
          "2720:  int  op_falsy = p[1] == '?';",
          "2721:  garray_T *instr = &cctx->ctx_instr;",
          "2722:  garray_T *stack = &cctx->ctx_type_stack;",
          "2723:  int  alt_idx = instr->ga_len;",
          "2724:  int  end_idx = 0;",
          "2725:  isn_T  *isn;",
          "2726:  type_T  *type1 = NULL;",
          "2727:  int  has_const_expr = FALSE;",
          "2728:  int  const_value = FALSE;",
          "2729:  int  save_skip = cctx->ctx_skip;",
          "2731:  if (next != NULL)",
          "2732:  {",
          "2734:      p = skipwhite(*arg);",
          "2735:  }",
          "2737:  if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1 + op_falsy]))",
          "2738:  {",
          "2739:      semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "2740:            op_falsy ? \"??\" : \"?\", p);",
          "2741:      return FAIL;",
          "2742:  }",
          "2744:  if (ppconst->pp_used == ppconst_used + 1)",
          "2745:  {",
          "2748:      has_const_expr = TRUE;",
          "2749:      if (op_falsy)",
          "2750:   const_value = tv2bool(&ppconst->pp_tv[ppconst_used]);",
          "2751:      else",
          "2752:      {",
          "2753:   int error = FALSE;",
          "2755:   const_value = tv_get_bool_chk(&ppconst->pp_tv[ppconst_used],",
          "2756:                &error);",
          "2757:   if (error)",
          "2758:       return FAIL;",
          "2759:      }",
          "2760:      cctx->ctx_skip = save_skip == SKIP_YES ||",
          "2761:    (op_falsy ? const_value : !const_value) ? SKIP_YES : SKIP_NOT;",
          "2763:      if (op_falsy && cctx->ctx_skip == SKIP_YES)",
          "2765:   generate_ppconst(cctx, ppconst);",
          "2766:      else",
          "2767:      {",
          "2768:   clear_tv(&ppconst->pp_tv[ppconst_used]);",
          "2769:   --ppconst->pp_used;",
          "2770:      }",
          "2771:  }",
          "2772:  else",
          "2773:  {",
          "2774:      generate_ppconst(cctx, ppconst);",
          "2775:      if (op_falsy)",
          "2776:   end_idx = instr->ga_len;",
          "2777:      generate_JUMP(cctx, op_falsy",
          "2778:        ? JUMP_AND_KEEP_IF_TRUE : JUMP_IF_FALSE, 0);",
          "2779:      if (op_falsy)",
          "2780:   type1 = ((type_T **)stack->ga_data)[stack->ga_len];",
          "2781:  }",
          "2784:  if (may_get_next_line_error(p + 1 + op_falsy, arg, cctx) == FAIL)",
          "2785:      return FAIL;",
          "2786:  if (compile_expr1(arg, cctx, ppconst) == FAIL)",
          "2787:      return FAIL;",
          "2789:  if (!has_const_expr)",
          "2790:  {",
          "2791:      generate_ppconst(cctx, ppconst);",
          "2793:      if (!op_falsy)",
          "2794:      {",
          "2796:   --stack->ga_len;",
          "2797:   type1 = ((type_T **)stack->ga_data)[stack->ga_len];",
          "2799:   end_idx = instr->ga_len;",
          "2800:   generate_JUMP(cctx, JUMP_ALWAYS, 0);",
          "2803:   isn = ((isn_T *)instr->ga_data) + alt_idx;",
          "2804:   isn->isn_arg.jump.jump_where = instr->ga_len;",
          "2805:      }",
          "2806:  }",
          "2808:  if (!op_falsy)",
          "2809:  {",
          "2811:      p = may_peek_next_line(cctx, *arg, &next);",
          "2812:      if (*p != ':')",
          "2813:      {",
          "2814:   emsg(_(e_missing_colon_after_questionmark));",
          "2815:   return FAIL;",
          "2816:      }",
          "2817:      if (next != NULL)",
          "2818:      {",
          "2820:   p = skipwhite(*arg);",
          "2821:      }",
          "2823:      if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1]))",
          "2824:      {",
          "2825:   semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "2826:                \":\", p);",
          "2827:   return FAIL;",
          "2828:      }",
          "2831:      if (has_const_expr)",
          "2832:   cctx->ctx_skip = save_skip == SKIP_YES || const_value",
          "2833:         ? SKIP_YES : SKIP_NOT;",
          "2834:      if (may_get_next_line_error(p + 1, arg, cctx) == FAIL)",
          "2835:   return FAIL;",
          "2836:      if (compile_expr1(arg, cctx, ppconst) == FAIL)",
          "2837:   return FAIL;",
          "2838:  }",
          "2840:  if (!has_const_expr)",
          "2841:  {",
          "2842:      type_T **typep;",
          "2844:      generate_ppconst(cctx, ppconst);",
          "2847:      typep = ((type_T **)stack->ga_data) + stack->ga_len - 1;",
          "2848:      common_type(type1, *typep, typep, cctx->ctx_type_list);",
          "2851:      isn = ((isn_T *)instr->ga_data) + end_idx;",
          "2852:      isn->isn_arg.jump.jump_where = instr->ga_len;",
          "2853:  }",
          "2855:  cctx->ctx_skip = save_skip;",
          "2856:     }",
          "2857:     return OK;",
          "2858: }",
          "2865:     int",
          "2866: compile_expr0_ext(char_u **arg,  cctx_T *cctx, int *is_const)",
          "2867: {",
          "2868:     ppconst_T ppconst;",
          "2870:     CLEAR_FIELD(ppconst);",
          "2871:     if (compile_expr1(arg, cctx, &ppconst) == FAIL)",
          "2872:     {",
          "2873:  clear_ppconst(&ppconst);",
          "2874:  return FAIL;",
          "2875:     }",
          "2876:     if (is_const != NULL)",
          "2878:     if (generate_ppconst(cctx, &ppconst) == FAIL)",
          "2879:  return FAIL;",
          "2880:     return OK;",
          "2881: }",
          "2886:     int",
          "2887: compile_expr0(char_u **arg,  cctx_T *cctx)",
          "2888: {",
          "2889:     return compile_expr0_ext(arg, cctx, NULL);",
          "2890: }",
          "2893: #endif // defined(FEAT_EVAL)",
          "",
          "---------------"
        ],
        "src/vim9instr.c||src/vim9instr.c": [
          "File: src/vim9instr.c -> src/vim9instr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #define USING_FLOAT_STUFF",
          "15: #include \"vim.h\"",
          "17: #if defined(FEAT_EVAL) || defined(PROTO)",
          "20: #ifdef PROTO",
          "21: # include \"vim9.h\"",
          "22: #endif",
          "28: #define RETURN_NULL_IF_SKIP(cctx) if (cctx->ctx_skip == SKIP_YES) return NULL",
          "29: #define RETURN_OK_IF_SKIP(cctx) if (cctx->ctx_skip == SKIP_YES) return OK",
          "35:     isn_T *",
          "36: generate_instr(cctx_T *cctx, isntype_T isn_type)",
          "37: {",
          "38:     garray_T *instr = &cctx->ctx_instr;",
          "39:     isn_T *isn;",
          "41:     RETURN_NULL_IF_SKIP(cctx);",
          "42:     if (GA_GROW_FAILS(instr, 1))",
          "43:  return NULL;",
          "44:     isn = ((isn_T *)instr->ga_data) + instr->ga_len;",
          "45:     isn->isn_type = isn_type;",
          "46:     isn->isn_lnum = cctx->ctx_lnum + 1;",
          "47:     ++instr->ga_len;",
          "49:     return isn;",
          "50: }",
          "57:     isn_T *",
          "58: generate_instr_drop(cctx_T *cctx, isntype_T isn_type, int drop)",
          "59: {",
          "60:     garray_T *stack = &cctx->ctx_type_stack;",
          "62:     RETURN_NULL_IF_SKIP(cctx);",
          "63:     stack->ga_len -= drop;",
          "64:     return generate_instr(cctx, isn_type);",
          "65: }",
          "70:     isn_T *",
          "71: generate_instr_type(cctx_T *cctx, isntype_T isn_type, type_T *type)",
          "72: {",
          "73:     isn_T *isn;",
          "74:     garray_T *stack = &cctx->ctx_type_stack;",
          "76:     if ((isn = generate_instr(cctx, isn_type)) == NULL)",
          "77:  return NULL;",
          "79:     if (GA_GROW_FAILS(stack, 1))",
          "80:  return NULL;",
          "81:     ((type_T **)stack->ga_data)[stack->ga_len] = type == NULL ? &t_any : type;",
          "82:     ++stack->ga_len;",
          "84:     return isn;",
          "85: }",
          "90:     isn_T *",
          "91: generate_instr_debug(cctx_T *cctx)",
          "92: {",
          "93:     isn_T *isn;",
          "94:     dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "95:             + cctx->ctx_ufunc->uf_dfunc_idx;",
          "97:     if ((isn = generate_instr(cctx, ISN_DEBUG)) == NULL)",
          "98:  return NULL;",
          "99:     isn->isn_arg.debug.dbg_var_names_len = dfunc->df_var_names.ga_len;",
          "100:     isn->isn_arg.debug.dbg_break_lnum = cctx->ctx_prev_lnum;",
          "101:     return isn;",
          "102: }",
          "109:     int",
          "110: may_generate_2STRING(int offset, int tolerant, cctx_T *cctx)",
          "111: {",
          "112:     isn_T *isn;",
          "113:     isntype_T isntype = ISN_2STRING;",
          "114:     garray_T *stack = &cctx->ctx_type_stack;",
          "115:     type_T **type;",
          "117:     RETURN_OK_IF_SKIP(cctx);",
          "118:     type = ((type_T **)stack->ga_data) + stack->ga_len + offset;",
          "119:     switch ((*type)->tt_type)",
          "120:     {",
          "122:  case VAR_STRING: return OK;",
          "125:  case VAR_SPECIAL:",
          "126:  case VAR_BOOL:",
          "127:  case VAR_NUMBER:",
          "128:  case VAR_FLOAT:",
          "129:     break;",
          "132:  case VAR_ANY:",
          "133:  case VAR_UNKNOWN:",
          "134:     isntype = ISN_2STRING_ANY;",
          "135:     break;",
          "138:  case VAR_LIST:",
          "139:     if (tolerant)",
          "140:     {",
          "141:         isntype = ISN_2STRING_ANY;",
          "142:         break;",
          "143:     }",
          "147:  case VAR_VOID:",
          "148:  case VAR_BLOB:",
          "149:  case VAR_FUNC:",
          "150:  case VAR_PARTIAL:",
          "151:  case VAR_DICT:",
          "152:  case VAR_JOB:",
          "153:  case VAR_CHANNEL:",
          "154:  case VAR_INSTR:",
          "155:     to_string_error((*type)->tt_type);",
          "156:     return FAIL;",
          "157:     }",
          "160:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "161:  return FAIL;",
          "162:     isn->isn_arg.tostring.offset = offset;",
          "163:     isn->isn_arg.tostring.tolerant = tolerant;",
          "165:     return OK;",
          "166: }",
          "168:     static int",
          "169: check_number_or_float(vartype_T type1, vartype_T type2, char_u *op)",
          "170: {",
          "171:     if (!((type1 == VAR_NUMBER || type1 == VAR_FLOAT || type1 == VAR_ANY)",
          "172:      && (type2 == VAR_NUMBER || type2 == VAR_FLOAT",
          "173:         || type2 == VAR_ANY)))",
          "174:     {",
          "175:  if (*op == '+')",
          "176:      emsg(_(e_wrong_argument_type_for_plus));",
          "177:  else",
          "178:      semsg(_(e_char_requires_number_or_float_arguments), *op);",
          "179:  return FAIL;",
          "180:     }",
          "181:     return OK;",
          "182: }",
          "187:     int",
          "188: generate_add_instr(",
          "189:  cctx_T *cctx,",
          "190:  vartype_T vartype,",
          "191:  type_T *type1,",
          "192:  type_T *type2,",
          "193:  exprtype_T expr_type)",
          "194: {",
          "195:     garray_T *stack = &cctx->ctx_type_stack;",
          "196:     isn_T *isn = generate_instr_drop(cctx,",
          "197:         vartype == VAR_NUMBER ? ISN_OPNR",
          "198:       : vartype == VAR_LIST ? ISN_ADDLIST",
          "199:       : vartype == VAR_BLOB ? ISN_ADDBLOB",
          "200: #ifdef FEAT_FLOAT",
          "201:       : vartype == VAR_FLOAT ? ISN_OPFLOAT",
          "202: #endif",
          "203:       : ISN_OPANY, 1);",
          "205:     if (vartype != VAR_LIST && vartype != VAR_BLOB",
          "206:      && type1->tt_type != VAR_ANY",
          "207:      && type2->tt_type != VAR_ANY",
          "208:      && check_number_or_float(",
          "209:    type1->tt_type, type2->tt_type, (char_u *)\"+\") == FAIL)",
          "210:  return FAIL;",
          "212:     if (isn != NULL)",
          "213:     {",
          "214:  if (isn->isn_type == ISN_ADDLIST)",
          "215:      isn->isn_arg.op.op_type = expr_type;",
          "216:  else",
          "217:      isn->isn_arg.op.op_type = EXPR_ADD;",
          "218:     }",
          "222:     if (vartype == VAR_LIST",
          "223:      && type1->tt_type == VAR_LIST && type2->tt_type == VAR_LIST",
          "224:      && type1->tt_member != type2->tt_member)",
          "225:  (((type_T **)stack->ga_data)[stack->ga_len - 1]) = &t_list_any;",
          "227:     return isn == NULL ? FAIL : OK;",
          "228: }",
          "235:     vartype_T",
          "236: operator_type(type_T *type1, type_T *type2)",
          "237: {",
          "238:     if (type1->tt_type == type2->tt_type",
          "239:      && (type1->tt_type == VAR_NUMBER",
          "240:   || type1->tt_type == VAR_LIST",
          "241: #ifdef FEAT_FLOAT",
          "242:   || type1->tt_type == VAR_FLOAT",
          "243: #endif",
          "244:   || type1->tt_type == VAR_BLOB))",
          "245:  return type1->tt_type;",
          "246:     return VAR_ANY;",
          "247: }",
          "253:     int",
          "254: generate_two_op(cctx_T *cctx, char_u *op)",
          "255: {",
          "256:     garray_T *stack = &cctx->ctx_type_stack;",
          "257:     type_T *type1;",
          "258:     type_T *type2;",
          "259:     vartype_T vartype;",
          "260:     isn_T *isn;",
          "262:     RETURN_OK_IF_SKIP(cctx);",
          "265:     type1 = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "266:     type2 = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "267:     vartype = operator_type(type1, type2);",
          "269:     switch (*op)",
          "270:     {",
          "271:  case '+':",
          "272:     if (generate_add_instr(cctx, vartype, type1, type2,",
          "273:            EXPR_COPY) == FAIL)",
          "274:         return FAIL;",
          "275:     break;",
          "277:  case '-':",
          "278:  case '*':",
          "279:  case '/': if (check_number_or_float(type1->tt_type, type2->tt_type,",
          "280:            op) == FAIL)",
          "281:         return FAIL;",
          "282:     if (vartype == VAR_NUMBER)",
          "283:         isn = generate_instr_drop(cctx, ISN_OPNR, 1);",
          "284: #ifdef FEAT_FLOAT",
          "285:     else if (vartype == VAR_FLOAT)",
          "286:         isn = generate_instr_drop(cctx, ISN_OPFLOAT, 1);",
          "287: #endif",
          "288:     else",
          "289:         isn = generate_instr_drop(cctx, ISN_OPANY, 1);",
          "290:     if (isn != NULL)",
          "291:         isn->isn_arg.op.op_type = *op == '*'",
          "292:      ? EXPR_MULT : *op == '/'? EXPR_DIV : EXPR_SUB;",
          "293:     break;",
          "295:  case '%': if ((type1->tt_type != VAR_ANY",
          "296:             && type1->tt_type != VAR_NUMBER)",
          "297:      || (type2->tt_type != VAR_ANY",
          "298:            && type2->tt_type != VAR_NUMBER))",
          "299:     {",
          "300:         emsg(_(e_percent_requires_number_arguments));",
          "301:         return FAIL;",
          "302:     }",
          "303:     isn = generate_instr_drop(cctx,",
          "304:          vartype == VAR_NUMBER ? ISN_OPNR : ISN_OPANY, 1);",
          "305:     if (isn != NULL)",
          "306:         isn->isn_arg.op.op_type = EXPR_REM;",
          "307:     break;",
          "308:     }",
          "311:     if (vartype == VAR_ANY)",
          "312:     {",
          "313:  type_T *type = &t_any;",
          "315: #ifdef FEAT_FLOAT",
          "317:  if ((type1->tt_type == VAR_NUMBER || type1->tt_type == VAR_FLOAT)",
          "318:   && (type2->tt_type == VAR_NUMBER || type2->tt_type == VAR_FLOAT))",
          "319:      type = &t_float;",
          "320: #endif",
          "321:  ((type_T **)stack->ga_data)[stack->ga_len - 1] = type;",
          "322:     }",
          "324:     return OK;",
          "325: }",
          "331:     static isntype_T",
          "332: get_compare_isn(exprtype_T exprtype, vartype_T type1, vartype_T type2)",
          "333: {",
          "334:     isntype_T isntype = ISN_DROP;",
          "336:     if (type1 == VAR_UNKNOWN)",
          "337:  type1 = VAR_ANY;",
          "338:     if (type2 == VAR_UNKNOWN)",
          "339:  type2 = VAR_ANY;",
          "341:     if (type1 == type2)",
          "342:     {",
          "343:  switch (type1)",
          "344:  {",
          "345:      case VAR_BOOL: isntype = ISN_COMPAREBOOL; break;",
          "346:      case VAR_SPECIAL: isntype = ISN_COMPARESPECIAL; break;",
          "347:      case VAR_NUMBER: isntype = ISN_COMPARENR; break;",
          "348:      case VAR_FLOAT: isntype = ISN_COMPAREFLOAT; break;",
          "349:      case VAR_STRING: isntype = ISN_COMPARESTRING; break;",
          "350:      case VAR_BLOB: isntype = ISN_COMPAREBLOB; break;",
          "351:      case VAR_LIST: isntype = ISN_COMPARELIST; break;",
          "352:      case VAR_DICT: isntype = ISN_COMPAREDICT; break;",
          "353:      case VAR_FUNC: isntype = ISN_COMPAREFUNC; break;",
          "354:      default: isntype = ISN_COMPAREANY; break;",
          "355:  }",
          "356:     }",
          "357:     else if (type1 == VAR_ANY || type2 == VAR_ANY",
          "358:      || ((type1 == VAR_NUMBER || type1 == VAR_FLOAT)",
          "359:        && (type2 == VAR_NUMBER || type2 == VAR_FLOAT)))",
          "360:  isntype = ISN_COMPAREANY;",
          "362:     if ((exprtype == EXPR_IS || exprtype == EXPR_ISNOT)",
          "363:      && (isntype == ISN_COMPAREBOOL",
          "364:      || isntype == ISN_COMPARESPECIAL",
          "365:      || isntype == ISN_COMPARENR",
          "366:      || isntype == ISN_COMPAREFLOAT))",
          "367:     {",
          "368:  semsg(_(e_cannot_use_str_with_str),",
          "369:   exprtype == EXPR_IS ? \"is\" : \"isnot\" , vartype_name(type1));",
          "370:  return ISN_DROP;",
          "371:     }",
          "372:     if (isntype == ISN_DROP",
          "373:      || ((exprtype != EXPR_EQUAL && exprtype != EXPR_NEQUAL",
          "374:       && (type1 == VAR_BOOL || type1 == VAR_SPECIAL",
          "375:          || type2 == VAR_BOOL || type2 == VAR_SPECIAL)))",
          "376:      || ((exprtype != EXPR_EQUAL && exprtype != EXPR_NEQUAL",
          "377:      && exprtype != EXPR_IS && exprtype != EXPR_ISNOT",
          "378:       && (type1 == VAR_BLOB || type2 == VAR_BLOB",
          "379:    || type1 == VAR_LIST || type2 == VAR_LIST))))",
          "380:     {",
          "381:  semsg(_(e_cannot_compare_str_with_str),",
          "382:   vartype_name(type1), vartype_name(type2));",
          "383:  return ISN_DROP;",
          "384:     }",
          "385:     return isntype;",
          "386: }",
          "388:     int",
          "389: check_compare_types(exprtype_T type, typval_T *tv1, typval_T *tv2)",
          "390: {",
          "391:     if (get_compare_isn(type, tv1->v_type, tv2->v_type) == ISN_DROP)",
          "392:  return FAIL;",
          "393:     return OK;",
          "394: }",
          "399:     int",
          "400: generate_COMPARE(cctx_T *cctx, exprtype_T exprtype, int ic)",
          "401: {",
          "402:     isntype_T isntype;",
          "403:     isn_T *isn;",
          "404:     garray_T *stack = &cctx->ctx_type_stack;",
          "405:     vartype_T type1;",
          "406:     vartype_T type2;",
          "408:     RETURN_OK_IF_SKIP(cctx);",
          "413:     type1 = ((type_T **)stack->ga_data)[stack->ga_len - 2]->tt_type;",
          "414:     type2 = ((type_T **)stack->ga_data)[stack->ga_len - 1]->tt_type;",
          "415:     isntype = get_compare_isn(exprtype, type1, type2);",
          "416:     if (isntype == ISN_DROP)",
          "417:  return FAIL;",
          "419:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "420:  return FAIL;",
          "421:     isn->isn_arg.op.op_type = exprtype;",
          "422:     isn->isn_arg.op.op_ic = ic;",
          "425:     if (stack->ga_len >= 2)",
          "426:     {",
          "427:  --stack->ga_len;",
          "428:  ((type_T **)stack->ga_data)[stack->ga_len - 1] = &t_bool;",
          "429:     }",
          "431:     return OK;",
          "432: }",
          "438:     int",
          "439: generate_2BOOL(cctx_T *cctx, int invert, int offset)",
          "440: {",
          "441:     isn_T *isn;",
          "442:     garray_T *stack = &cctx->ctx_type_stack;",
          "444:     RETURN_OK_IF_SKIP(cctx);",
          "445:     if ((isn = generate_instr(cctx, ISN_2BOOL)) == NULL)",
          "446:  return FAIL;",
          "447:     isn->isn_arg.tobool.invert = invert;",
          "448:     isn->isn_arg.tobool.offset = offset;",
          "451:     ((type_T **)stack->ga_data)[stack->ga_len + offset] = &t_bool;",
          "453:     return OK;",
          "454: }",
          "459:     int",
          "460: generate_COND2BOOL(cctx_T *cctx)",
          "461: {",
          "462:     isn_T *isn;",
          "463:     garray_T *stack = &cctx->ctx_type_stack;",
          "465:     RETURN_OK_IF_SKIP(cctx);",
          "466:     if ((isn = generate_instr(cctx, ISN_COND2BOOL)) == NULL)",
          "467:  return FAIL;",
          "470:     ((type_T **)stack->ga_data)[stack->ga_len - 1] = &t_bool;",
          "472:     return OK;",
          "473: }",
          "475:     int",
          "476: generate_TYPECHECK(",
          "477:  cctx_T     *cctx,",
          "478:  type_T     *expected,",
          "479:  int     offset,",
          "480:  int     argidx)",
          "481: {",
          "482:     isn_T *isn;",
          "483:     garray_T *stack = &cctx->ctx_type_stack;",
          "485:     RETURN_OK_IF_SKIP(cctx);",
          "486:     if ((isn = generate_instr(cctx, ISN_CHECKTYPE)) == NULL)",
          "487:  return FAIL;",
          "488:     isn->isn_arg.type.ct_type = alloc_type(expected);",
          "489:     isn->isn_arg.type.ct_off = (int8_T)offset;",
          "490:     isn->isn_arg.type.ct_arg_idx = (int8_T)argidx;",
          "493:     ((type_T **)stack->ga_data)[stack->ga_len + offset] = expected;",
          "495:     return OK;",
          "496: }",
          "498:     int",
          "499: generate_SETTYPE(",
          "500:  cctx_T     *cctx,",
          "501:  type_T     *expected)",
          "502: {",
          "503:     isn_T *isn;",
          "505:     RETURN_OK_IF_SKIP(cctx);",
          "506:     if ((isn = generate_instr(cctx, ISN_SETTYPE)) == NULL)",
          "507:  return FAIL;",
          "508:     isn->isn_arg.type.ct_type = alloc_type(expected);",
          "509:     return OK;",
          "510: }",
          "517:     int",
          "518: generate_tv_PUSH(cctx_T *cctx, typval_T *tv)",
          "519: {",
          "520:     if (tv != NULL)",
          "521:     {",
          "522:  switch (tv->v_type)",
          "523:  {",
          "524:      case VAR_UNKNOWN:",
          "525:   break;",
          "526:      case VAR_BOOL:",
          "527:   generate_PUSHBOOL(cctx, tv->vval.v_number);",
          "528:   break;",
          "529:      case VAR_SPECIAL:",
          "530:   generate_PUSHSPEC(cctx, tv->vval.v_number);",
          "531:   break;",
          "532:      case VAR_NUMBER:",
          "533:   generate_PUSHNR(cctx, tv->vval.v_number);",
          "534:   break;",
          "535: #ifdef FEAT_FLOAT",
          "536:      case VAR_FLOAT:",
          "537:   generate_PUSHF(cctx, tv->vval.v_float);",
          "538:   break;",
          "539: #endif",
          "540:      case VAR_BLOB:",
          "541:   generate_PUSHBLOB(cctx, tv->vval.v_blob);",
          "542:   tv->vval.v_blob = NULL;",
          "543:   break;",
          "544:      case VAR_STRING:",
          "545:   generate_PUSHS(cctx, &tv->vval.v_string);",
          "546:   tv->vval.v_string = NULL;",
          "547:   break;",
          "548:      default:",
          "549:   iemsg(\"constant type not supported\");",
          "550:   clear_tv(tv);",
          "551:   return FAIL;",
          "552:  }",
          "553:  tv->v_type = VAR_UNKNOWN;",
          "554:     }",
          "555:     return OK;",
          "556: }",
          "561:     int",
          "562: generate_PUSHNR(cctx_T *cctx, varnumber_T number)",
          "563: {",
          "564:     isn_T *isn;",
          "565:     garray_T *stack = &cctx->ctx_type_stack;",
          "567:     RETURN_OK_IF_SKIP(cctx);",
          "568:     if ((isn = generate_instr_type(cctx, ISN_PUSHNR, &t_number)) == NULL)",
          "569:  return FAIL;",
          "570:     isn->isn_arg.number = number;",
          "572:     if (number == 0 || number == 1)",
          "574:  ((type_T **)stack->ga_data)[stack->ga_len - 1] = &t_number_bool;",
          "575:     return OK;",
          "576: }",
          "581:     int",
          "582: generate_PUSHBOOL(cctx_T *cctx, varnumber_T number)",
          "583: {",
          "584:     isn_T *isn;",
          "586:     RETURN_OK_IF_SKIP(cctx);",
          "587:     if ((isn = generate_instr_type(cctx, ISN_PUSHBOOL, &t_bool)) == NULL)",
          "588:  return FAIL;",
          "589:     isn->isn_arg.number = number;",
          "591:     return OK;",
          "592: }",
          "597:     int",
          "598: generate_PUSHSPEC(cctx_T *cctx, varnumber_T number)",
          "599: {",
          "600:     isn_T *isn;",
          "602:     RETURN_OK_IF_SKIP(cctx);",
          "603:     if ((isn = generate_instr_type(cctx, ISN_PUSHSPEC, &t_special)) == NULL)",
          "604:  return FAIL;",
          "605:     isn->isn_arg.number = number;",
          "607:     return OK;",
          "608: }",
          "610: #if defined(FEAT_FLOAT) || defined(PROTO)",
          "614:     int",
          "615: generate_PUSHF(cctx_T *cctx, float_T fnumber)",
          "616: {",
          "617:     isn_T *isn;",
          "619:     RETURN_OK_IF_SKIP(cctx);",
          "620:     if ((isn = generate_instr_type(cctx, ISN_PUSHF, &t_float)) == NULL)",
          "621:  return FAIL;",
          "622:     isn->isn_arg.fnumber = fnumber;",
          "624:     return OK;",
          "625: }",
          "626: #endif",
          "632:     int",
          "633: generate_PUSHS(cctx_T *cctx, char_u **str)",
          "634: {",
          "635:     isn_T *isn;",
          "637:     if (cctx->ctx_skip == SKIP_YES)",
          "638:     {",
          "639:  if (str != NULL)",
          "640:      VIM_CLEAR(*str);",
          "641:  return OK;",
          "642:     }",
          "643:     if ((isn = generate_instr_type(cctx, ISN_PUSHS, &t_string)) == NULL)",
          "644:     {",
          "645:  if (str != NULL)",
          "646:      VIM_CLEAR(*str);",
          "647:  return FAIL;",
          "648:     }",
          "649:     isn->isn_arg.string = str == NULL ? NULL : *str;",
          "651:     return OK;",
          "652: }",
          "658:     int",
          "659: generate_PUSHCHANNEL(cctx_T *cctx, channel_T *channel)",
          "660: {",
          "661:     isn_T *isn;",
          "663:     RETURN_OK_IF_SKIP(cctx);",
          "664:     if ((isn = generate_instr_type(cctx, ISN_PUSHCHANNEL, &t_channel)) == NULL)",
          "665:  return FAIL;",
          "666:     isn->isn_arg.channel = channel;",
          "668:     return OK;",
          "669: }",
          "675:     int",
          "676: generate_PUSHJOB(cctx_T *cctx, job_T *job)",
          "677: {",
          "678:     isn_T *isn;",
          "680:     RETURN_OK_IF_SKIP(cctx);",
          "681:     if ((isn = generate_instr_type(cctx, ISN_PUSHJOB, &t_channel)) == NULL)",
          "682:  return FAIL;",
          "683:     isn->isn_arg.job = job;",
          "685:     return OK;",
          "686: }",
          "692:     int",
          "693: generate_PUSHBLOB(cctx_T *cctx, blob_T *blob)",
          "694: {",
          "695:     isn_T *isn;",
          "697:     RETURN_OK_IF_SKIP(cctx);",
          "698:     if ((isn = generate_instr_type(cctx, ISN_PUSHBLOB, &t_blob)) == NULL)",
          "699:  return FAIL;",
          "700:     isn->isn_arg.blob = blob;",
          "702:     return OK;",
          "703: }",
          "709:     int",
          "710: generate_PUSHFUNC(cctx_T *cctx, char_u *name, type_T *type)",
          "711: {",
          "712:     isn_T *isn;",
          "713:     char_u *funcname;",
          "715:     RETURN_OK_IF_SKIP(cctx);",
          "716:     if ((isn = generate_instr_type(cctx, ISN_PUSHFUNC, type)) == NULL)",
          "717:  return FAIL;",
          "718:     if (name == NULL)",
          "719:  funcname = NULL;",
          "720:     else if (*name == K_SPECIAL)  // script-local",
          "721:  funcname = vim_strsave(name);",
          "722:     else",
          "723:     {",
          "724:  funcname = alloc(STRLEN(name) + 3);",
          "725:  if (funcname != NULL)",
          "726:  {",
          "727:      STRCPY(funcname, \"g:\");",
          "728:      STRCPY(funcname + 2, name);",
          "729:  }",
          "730:     }",
          "732:     isn->isn_arg.string = funcname;",
          "733:     return OK;",
          "734: }",
          "741:     int",
          "742: generate_GETITEM(cctx_T *cctx, int index, int with_op)",
          "743: {",
          "744:     isn_T *isn;",
          "745:     garray_T *stack = &cctx->ctx_type_stack;",
          "746:     type_T *type = ((type_T **)stack->ga_data)[stack->ga_len",
          "747:          - (with_op ? 2 : 1)];",
          "748:     type_T *item_type = &t_any;",
          "750:     RETURN_OK_IF_SKIP(cctx);",
          "752:     if (type->tt_type != VAR_LIST)",
          "753:     {",
          "755:  emsg(_(e_listreq));",
          "756:  return FAIL;",
          "757:     }",
          "758:     item_type = type->tt_member;",
          "759:     if ((isn = generate_instr(cctx, ISN_GETITEM)) == NULL)",
          "760:  return FAIL;",
          "761:     isn->isn_arg.getitem.gi_index = index;",
          "762:     isn->isn_arg.getitem.gi_with_op = with_op;",
          "765:     if (GA_GROW_FAILS(stack, 1))",
          "766:  return FAIL;",
          "767:     ((type_T **)stack->ga_data)[stack->ga_len] = item_type;",
          "768:     ++stack->ga_len;",
          "769:     return OK;",
          "770: }",
          "775:     int",
          "776: generate_SLICE(cctx_T *cctx, int count)",
          "777: {",
          "778:     isn_T *isn;",
          "780:     RETURN_OK_IF_SKIP(cctx);",
          "781:     if ((isn = generate_instr(cctx, ISN_SLICE)) == NULL)",
          "782:  return FAIL;",
          "783:     isn->isn_arg.number = count;",
          "784:     return OK;",
          "785: }",
          "790:     int",
          "791: generate_CHECKLEN(cctx_T *cctx, int min_len, int more_OK)",
          "792: {",
          "793:     isn_T *isn;",
          "795:     RETURN_OK_IF_SKIP(cctx);",
          "797:     if ((isn = generate_instr(cctx, ISN_CHECKLEN)) == NULL)",
          "798:  return FAIL;",
          "799:     isn->isn_arg.checklen.cl_min_len = min_len;",
          "800:     isn->isn_arg.checklen.cl_more_OK = more_OK;",
          "802:     return OK;",
          "803: }",
          "808:     int",
          "809: generate_STORE(cctx_T *cctx, isntype_T isn_type, int idx, char_u *name)",
          "810: {",
          "811:     isn_T *isn;",
          "813:     RETURN_OK_IF_SKIP(cctx);",
          "814:     if ((isn = generate_instr_drop(cctx, isn_type, 1)) == NULL)",
          "815:  return FAIL;",
          "816:     if (name != NULL)",
          "817:  isn->isn_arg.string = vim_strsave(name);",
          "818:     else",
          "819:  isn->isn_arg.number = idx;",
          "821:     return OK;",
          "822: }",
          "827:     int",
          "828: generate_STOREOUTER(cctx_T *cctx, int idx, int level)",
          "829: {",
          "830:     isn_T *isn;",
          "832:     RETURN_OK_IF_SKIP(cctx);",
          "833:     if ((isn = generate_instr_drop(cctx, ISN_STOREOUTER, 1)) == NULL)",
          "834:  return FAIL;",
          "835:     isn->isn_arg.outer.outer_idx = idx;",
          "836:     isn->isn_arg.outer.outer_depth = level;",
          "838:     return OK;",
          "839: }",
          "844:     int",
          "845: generate_STORENR(cctx_T *cctx, int idx, varnumber_T value)",
          "846: {",
          "847:     isn_T *isn;",
          "849:     RETURN_OK_IF_SKIP(cctx);",
          "850:     if ((isn = generate_instr(cctx, ISN_STORENR)) == NULL)",
          "851:  return FAIL;",
          "852:     isn->isn_arg.storenr.stnr_idx = idx;",
          "853:     isn->isn_arg.storenr.stnr_val = value;",
          "855:     return OK;",
          "856: }",
          "861:     int",
          "862: generate_STOREOPT(",
          "863:  cctx_T     *cctx,",
          "864:  isntype_T   isn_type,",
          "865:  char_u     *name,",
          "866:  int     opt_flags)",
          "867: {",
          "868:     isn_T *isn;",
          "870:     RETURN_OK_IF_SKIP(cctx);",
          "871:     if ((isn = generate_instr_drop(cctx, isn_type, 1)) == NULL)",
          "872:  return FAIL;",
          "873:     isn->isn_arg.storeopt.so_name = vim_strsave(name);",
          "874:     isn->isn_arg.storeopt.so_flags = opt_flags;",
          "876:     return OK;",
          "877: }",
          "882:     int",
          "883: generate_LOAD(",
          "884:  cctx_T     *cctx,",
          "885:  isntype_T   isn_type,",
          "886:  int     idx,",
          "887:  char_u     *name,",
          "888:  type_T     *type)",
          "889: {",
          "890:     isn_T *isn;",
          "892:     RETURN_OK_IF_SKIP(cctx);",
          "893:     if ((isn = generate_instr_type(cctx, isn_type, type)) == NULL)",
          "894:  return FAIL;",
          "895:     if (name != NULL)",
          "896:  isn->isn_arg.string = vim_strsave(name);",
          "897:     else",
          "898:  isn->isn_arg.number = idx;",
          "900:     return OK;",
          "901: }",
          "906:     int",
          "907: generate_LOADOUTER(",
          "908:  cctx_T     *cctx,",
          "909:  int     idx,",
          "910:  int     nesting,",
          "911:  type_T     *type)",
          "912: {",
          "913:     isn_T *isn;",
          "915:     RETURN_OK_IF_SKIP(cctx);",
          "916:     if ((isn = generate_instr_type(cctx, ISN_LOADOUTER, type)) == NULL)",
          "917:  return FAIL;",
          "918:     isn->isn_arg.outer.outer_idx = idx;",
          "919:     isn->isn_arg.outer.outer_depth = nesting;",
          "921:     return OK;",
          "922: }",
          "927:     int",
          "928: generate_LOADV(",
          "929:  cctx_T     *cctx,",
          "930:  char_u     *name,",
          "931:  int     error)",
          "932: {",
          "933:     int     di_flags;",
          "934:     int     vidx = find_vim_var(name, &di_flags);",
          "935:     type_T  *type;",
          "937:     RETURN_OK_IF_SKIP(cctx);",
          "938:     if (vidx < 0)",
          "939:     {",
          "940:  if (error)",
          "941:      semsg(_(e_variable_not_found_str), name);",
          "942:  return FAIL;",
          "943:     }",
          "944:     type = typval2type_vimvar(get_vim_var_tv(vidx), cctx->ctx_type_list);",
          "946:     return generate_LOAD(cctx, ISN_LOADV, vidx, NULL, type);",
          "947: }",
          "952:     int",
          "953: generate_UNLET(cctx_T *cctx, isntype_T isn_type, char_u *name, int forceit)",
          "954: {",
          "955:     isn_T *isn;",
          "957:     RETURN_OK_IF_SKIP(cctx);",
          "958:     if ((isn = generate_instr(cctx, isn_type)) == NULL)",
          "959:  return FAIL;",
          "960:     isn->isn_arg.unlet.ul_name = vim_strsave(name);",
          "961:     isn->isn_arg.unlet.ul_forceit = forceit;",
          "963:     return OK;",
          "964: }",
          "969:     int",
          "970: generate_LOCKCONST(cctx_T *cctx)",
          "971: {",
          "972:     isn_T *isn;",
          "974:     RETURN_OK_IF_SKIP(cctx);",
          "975:     if ((isn = generate_instr(cctx, ISN_LOCKCONST)) == NULL)",
          "976:  return FAIL;",
          "977:     return OK;",
          "978: }",
          "983:     int",
          "984: generate_OLDSCRIPT(",
          "985:  cctx_T     *cctx,",
          "986:  isntype_T   isn_type,",
          "987:  char_u     *name,",
          "988:  int     sid,",
          "989:  type_T     *type)",
          "990: {",
          "991:     isn_T *isn;",
          "993:     RETURN_OK_IF_SKIP(cctx);",
          "994:     if (isn_type == ISN_LOADS)",
          "995:  isn = generate_instr_type(cctx, isn_type, type);",
          "996:     else",
          "997:  isn = generate_instr_drop(cctx, isn_type, 1);",
          "998:     if (isn == NULL)",
          "999:  return FAIL;",
          "1000:     isn->isn_arg.loadstore.ls_name = vim_strsave(name);",
          "1001:     isn->isn_arg.loadstore.ls_sid = sid;",
          "1003:     return OK;",
          "1004: }",
          "1009:     int",
          "1010: generate_VIM9SCRIPT(",
          "1011:  cctx_T     *cctx,",
          "1012:  isntype_T   isn_type,",
          "1013:  int     sid,",
          "1014:  int     idx,",
          "1015:  type_T     *type)",
          "1016: {",
          "1017:     isn_T *isn;",
          "1018:     scriptref_T *sref;",
          "1019:     scriptitem_T *si = SCRIPT_ITEM(sid);",
          "1021:     RETURN_OK_IF_SKIP(cctx);",
          "1022:     if (isn_type == ISN_LOADSCRIPT)",
          "1023:  isn = generate_instr_type(cctx, isn_type, type);",
          "1024:     else",
          "1025:  isn = generate_instr_drop(cctx, isn_type, 1);",
          "1026:     if (isn == NULL)",
          "1027:  return FAIL;",
          "1031:     sref = ALLOC_ONE(scriptref_T);",
          "1032:     if (sref == NULL)",
          "1033:  return FAIL;",
          "1034:     isn->isn_arg.script.scriptref = sref;",
          "1035:     sref->sref_sid = sid;",
          "1036:     sref->sref_idx = idx;",
          "1037:     sref->sref_seq = si->sn_script_seq;",
          "1038:     sref->sref_type = type;",
          "1039:     return OK;",
          "1040: }",
          "1045:     int",
          "1046: generate_NEWLIST(cctx_T *cctx, int count)",
          "1047: {",
          "1048:     isn_T *isn;",
          "1049:     garray_T *stack = &cctx->ctx_type_stack;",
          "1050:     type_T *type;",
          "1051:     type_T *member;",
          "1053:     RETURN_OK_IF_SKIP(cctx);",
          "1054:     if ((isn = generate_instr(cctx, ISN_NEWLIST)) == NULL)",
          "1055:  return FAIL;",
          "1056:     isn->isn_arg.number = count;",
          "1059:     if (count == 0)",
          "1060:  member = &t_unknown;",
          "1061:     else",
          "1062:  member = get_member_type_from_stack(",
          "1063:      ((type_T **)stack->ga_data) + stack->ga_len, count, 1,",
          "1064:          cctx->ctx_type_list);",
          "1065:     type = get_list_type(member, cctx->ctx_type_list);",
          "1068:     stack->ga_len -= count;",
          "1071:     if (GA_GROW_FAILS(stack, 1))",
          "1072:  return FAIL;",
          "1073:     ((type_T **)stack->ga_data)[stack->ga_len] = type;",
          "1074:     ++stack->ga_len;",
          "1076:     return OK;",
          "1077: }",
          "1082:     int",
          "1083: generate_NEWDICT(cctx_T *cctx, int count)",
          "1084: {",
          "1085:     isn_T *isn;",
          "1086:     garray_T *stack = &cctx->ctx_type_stack;",
          "1087:     type_T *type;",
          "1088:     type_T *member;",
          "1090:     RETURN_OK_IF_SKIP(cctx);",
          "1091:     if ((isn = generate_instr(cctx, ISN_NEWDICT)) == NULL)",
          "1092:  return FAIL;",
          "1093:     isn->isn_arg.number = count;",
          "1095:     if (count == 0)",
          "1096:  member = &t_void;",
          "1097:     else",
          "1098:  member = get_member_type_from_stack(",
          "1099:      ((type_T **)stack->ga_data) + stack->ga_len, count, 2,",
          "1100:          cctx->ctx_type_list);",
          "1101:     type = get_dict_type(member, cctx->ctx_type_list);",
          "1104:     stack->ga_len -= 2 * count;",
          "1107:     if (GA_GROW_FAILS(stack, 1))",
          "1108:  return FAIL;",
          "1109:     ((type_T **)stack->ga_data)[stack->ga_len] = type;",
          "1110:     ++stack->ga_len;",
          "1112:     return OK;",
          "1113: }",
          "1118:     int",
          "1119: generate_FUNCREF(cctx_T *cctx, ufunc_T *ufunc)",
          "1120: {",
          "1121:     isn_T *isn;",
          "1122:     garray_T *stack = &cctx->ctx_type_stack;",
          "1124:     RETURN_OK_IF_SKIP(cctx);",
          "1125:     if ((isn = generate_instr(cctx, ISN_FUNCREF)) == NULL)",
          "1126:  return FAIL;",
          "1127:     if (ufunc->uf_def_status == UF_NOT_COMPILED)",
          "1128:  isn->isn_arg.funcref.fr_func_name = vim_strsave(ufunc->uf_name);",
          "1129:     else",
          "1130:  isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;",
          "1131:     cctx->ctx_has_closure = 1;",
          "1135:     if (ufunc->uf_flags & FC_CLOSURE)",
          "1136:  cctx->ctx_ufunc->uf_flags |= FC_CLOSURE;",
          "1138:     if (GA_GROW_FAILS(stack, 1))",
          "1139:  return FAIL;",
          "1140:     ((type_T **)stack->ga_data)[stack->ga_len] =",
          "1141:         ufunc->uf_func_type == NULL ? &t_func_any : ufunc->uf_func_type;",
          "1142:     ++stack->ga_len;",
          "1144:     return OK;",
          "1145: }",
          "1152:     int",
          "1153: generate_NEWFUNC(cctx_T *cctx, char_u *lambda_name, char_u *func_name)",
          "1154: {",
          "1155:     isn_T *isn;",
          "1157:     if (cctx->ctx_skip == SKIP_YES)",
          "1158:     {",
          "1159:  vim_free(lambda_name);",
          "1160:  vim_free(func_name);",
          "1161:  return OK;",
          "1162:     }",
          "1163:     if ((isn = generate_instr(cctx, ISN_NEWFUNC)) == NULL)",
          "1164:     {",
          "1165:  vim_free(lambda_name);",
          "1166:  vim_free(func_name);",
          "1167:  return FAIL;",
          "1168:     }",
          "1169:     isn->isn_arg.newfunc.nf_lambda = lambda_name;",
          "1170:     isn->isn_arg.newfunc.nf_global = func_name;",
          "1172:     return OK;",
          "1173: }",
          "1178:     int",
          "1179: generate_DEF(cctx_T *cctx, char_u *name, size_t len)",
          "1180: {",
          "1181:     isn_T *isn;",
          "1183:     RETURN_OK_IF_SKIP(cctx);",
          "1184:     if ((isn = generate_instr(cctx, ISN_DEF)) == NULL)",
          "1185:  return FAIL;",
          "1186:     if (len > 0)",
          "1187:     {",
          "1188:  isn->isn_arg.string = vim_strnsave(name, len);",
          "1189:  if (isn->isn_arg.string == NULL)",
          "1190:      return FAIL;",
          "1191:     }",
          "1192:     return OK;",
          "1193: }",
          "1198:     int",
          "1199: generate_JUMP(cctx_T *cctx, jumpwhen_T when, int where)",
          "1200: {",
          "1201:     isn_T *isn;",
          "1202:     garray_T *stack = &cctx->ctx_type_stack;",
          "1204:     RETURN_OK_IF_SKIP(cctx);",
          "1205:     if ((isn = generate_instr(cctx, ISN_JUMP)) == NULL)",
          "1206:  return FAIL;",
          "1207:     isn->isn_arg.jump.jump_when = when;",
          "1208:     isn->isn_arg.jump.jump_where = where;",
          "1210:     if (when != JUMP_ALWAYS && stack->ga_len > 0)",
          "1211:  --stack->ga_len;",
          "1213:     return OK;",
          "1214: }",
          "1219:     int",
          "1220: generate_JUMP_IF_ARG_SET(cctx_T *cctx, int arg_off)",
          "1221: {",
          "1222:     isn_T *isn;",
          "1224:     RETURN_OK_IF_SKIP(cctx);",
          "1225:     if ((isn = generate_instr(cctx, ISN_JUMP_IF_ARG_SET)) == NULL)",
          "1226:  return FAIL;",
          "1227:     isn->isn_arg.jumparg.jump_arg_off = arg_off;",
          "1229:     return OK;",
          "1230: }",
          "1232:     int",
          "1233: generate_FOR(cctx_T *cctx, int loop_idx)",
          "1234: {",
          "1235:     isn_T *isn;",
          "1236:     garray_T *stack = &cctx->ctx_type_stack;",
          "1238:     RETURN_OK_IF_SKIP(cctx);",
          "1239:     if ((isn = generate_instr(cctx, ISN_FOR)) == NULL)",
          "1240:  return FAIL;",
          "1241:     isn->isn_arg.forloop.for_idx = loop_idx;",
          "1243:     if (GA_GROW_FAILS(stack, 1))",
          "1244:  return FAIL;",
          "1246:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_any;",
          "1247:     ++stack->ga_len;",
          "1249:     return OK;",
          "1250: }",
          "1254:     int",
          "1255: generate_TRYCONT(cctx_T *cctx, int levels, int where)",
          "1256: {",
          "1257:     isn_T *isn;",
          "1259:     RETURN_OK_IF_SKIP(cctx);",
          "1260:     if ((isn = generate_instr(cctx, ISN_TRYCONT)) == NULL)",
          "1261:  return FAIL;",
          "1262:     isn->isn_arg.trycont.tct_levels = levels;",
          "1263:     isn->isn_arg.trycont.tct_where = where;",
          "1265:     return OK;",
          "1266: }",
          "1274:     int",
          "1275: generate_BCALL(cctx_T *cctx, int func_idx, int argcount, int method_call)",
          "1276: {",
          "1277:     isn_T *isn;",
          "1278:     garray_T *stack = &cctx->ctx_type_stack;",
          "1279:     int  argoff;",
          "1280:     type_T **argtypes = NULL;",
          "1281:     type_T *shuffled_argtypes[MAX_FUNC_ARGS];",
          "1282:     type_T *maptype = NULL;",
          "1284:     RETURN_OK_IF_SKIP(cctx);",
          "1285:     argoff = check_internal_func(func_idx, argcount);",
          "1286:     if (argoff < 0)",
          "1287:  return FAIL;",
          "1289:     if (method_call && argoff > 1)",
          "1290:     {",
          "1291:  if ((isn = generate_instr(cctx, ISN_SHUFFLE)) == NULL)",
          "1292:      return FAIL;",
          "1293:  isn->isn_arg.shuffle.shfl_item = argcount;",
          "1294:  isn->isn_arg.shuffle.shfl_up = argoff - 1;",
          "1295:     }",
          "1297:     if (argcount > 0)",
          "1298:     {",
          "1300:  argtypes = ((type_T **)stack->ga_data) + stack->ga_len - argcount;",
          "1301:  if (method_call && argoff > 1)",
          "1302:  {",
          "1303:      int i;",
          "1305:      for (i = 0; i < argcount; ++i)",
          "1306:   shuffled_argtypes[i] = (i < argoff - 1)",
          "1307:        ? argtypes[i + 1]",
          "1308:        : (i == argoff - 1) ? argtypes[0] : argtypes[i];",
          "1309:      argtypes = shuffled_argtypes;",
          "1310:  }",
          "1311:  if (internal_func_check_arg_types(argtypes, func_idx, argcount,",
          "1312:          cctx) == FAIL)",
          "1313:      return FAIL;",
          "1314:  if (internal_func_is_map(func_idx))",
          "1315:      maptype = *argtypes;",
          "1316:     }",
          "1318:     if ((isn = generate_instr(cctx, ISN_BCALL)) == NULL)",
          "1319:  return FAIL;",
          "1320:     isn->isn_arg.bfunc.cbf_idx = func_idx;",
          "1321:     isn->isn_arg.bfunc.cbf_argcount = argcount;",
          "1324:     stack->ga_len -= argcount;",
          "1325:     if (GA_GROW_FAILS(stack, 1))",
          "1326:  return FAIL;",
          "1327:     ((type_T **)stack->ga_data)[stack->ga_len] =",
          "1328:      internal_func_ret_type(func_idx, argcount, argtypes);",
          "1329:     ++stack->ga_len;",
          "1331:     if (maptype != NULL && maptype->tt_member != NULL",
          "1332:             && maptype->tt_member != &t_any)",
          "1334:  generate_TYPECHECK(cctx, maptype, -1, 1);",
          "1336:     return OK;",
          "1337: }",
          "1343:     int",
          "1344: generate_LISTAPPEND(cctx_T *cctx)",
          "1345: {",
          "1346:     garray_T *stack = &cctx->ctx_type_stack;",
          "1347:     type_T *list_type;",
          "1348:     type_T *item_type;",
          "1349:     type_T *expected;",
          "1352:     list_type = ((type_T **)stack->ga_data)[stack->ga_len - 2];",
          "1353:     item_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1354:     expected = list_type->tt_member;",
          "1355:     if (need_type(item_type, expected, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1356:  return FAIL;",
          "1358:     if (generate_instr(cctx, ISN_LISTAPPEND) == NULL)",
          "1359:  return FAIL;",
          "1361:     --stack->ga_len;     // drop the argument",
          "1362:     return OK;",
          "1363: }",
          "1369:     int",
          "1370: generate_BLOBAPPEND(cctx_T *cctx)",
          "1371: {",
          "1372:     garray_T *stack = &cctx->ctx_type_stack;",
          "1373:     type_T *item_type;",
          "1376:     item_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1377:     if (need_type(item_type, &t_number, -1, 0, cctx, FALSE, FALSE) == FAIL)",
          "1378:  return FAIL;",
          "1380:     if (generate_instr(cctx, ISN_BLOBAPPEND) == NULL)",
          "1381:  return FAIL;",
          "1383:     --stack->ga_len;     // drop the argument",
          "1384:     return OK;",
          "1385: }",
          "1391:     int",
          "1392: generate_CALL(cctx_T *cctx, ufunc_T *ufunc, int pushed_argcount)",
          "1393: {",
          "1394:     isn_T *isn;",
          "1395:     garray_T *stack = &cctx->ctx_type_stack;",
          "1396:     int  regular_args = ufunc->uf_args.ga_len;",
          "1397:     int  argcount = pushed_argcount;",
          "1399:     RETURN_OK_IF_SKIP(cctx);",
          "1400:     if (argcount > regular_args && !has_varargs(ufunc))",
          "1401:     {",
          "1402:  semsg(_(e_too_many_arguments_for_function_str),",
          "1403:          printable_func_name(ufunc));",
          "1404:  return FAIL;",
          "1405:     }",
          "1406:     if (argcount < regular_args - ufunc->uf_def_args.ga_len)",
          "1407:     {",
          "1408:  semsg(_(e_not_enough_arguments_for_function_str),",
          "1409:          printable_func_name(ufunc));",
          "1410:  return FAIL;",
          "1411:     }",
          "1413:     if (ufunc->uf_def_status != UF_NOT_COMPILED",
          "1414:      && ufunc->uf_def_status != UF_COMPILE_ERROR)",
          "1415:     {",
          "1416:  int  i;",
          "1418:  for (i = 0; i < argcount; ++i)",
          "1419:  {",
          "1420:      type_T *expected;",
          "1421:      type_T *actual;",
          "1423:      actual = ((type_T **)stack->ga_data)[stack->ga_len - argcount + i];",
          "1424:      if (actual == &t_special",
          "1425:          && i >= regular_args - ufunc->uf_def_args.ga_len)",
          "1426:      {",
          "1428:   continue;",
          "1429:      }",
          "1430:      if (i < regular_args)",
          "1431:      {",
          "1432:   if (ufunc->uf_arg_types == NULL)",
          "1433:       continue;",
          "1434:   expected = ufunc->uf_arg_types[i];",
          "1435:      }",
          "1436:      else if (ufunc->uf_va_type == NULL",
          "1437:         || ufunc->uf_va_type == &t_list_any)",
          "1439:   expected = &t_any;",
          "1440:      else",
          "1441:   expected = ufunc->uf_va_type->tt_member;",
          "1442:      if (need_type(actual, expected, -argcount + i, i + 1, cctx,",
          "1443:          TRUE, FALSE) == FAIL)",
          "1444:      {",
          "1445:   arg_type_mismatch(expected, actual, i + 1);",
          "1446:   return FAIL;",
          "1447:      }",
          "1448:  }",
          "1449:  if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))",
          "1450:   && compile_def_function(ufunc, ufunc->uf_ret_type == NULL,",
          "1451:          COMPILE_TYPE(ufunc), NULL) == FAIL)",
          "1452:      return FAIL;",
          "1453:     }",
          "1454:     if (ufunc->uf_def_status == UF_COMPILE_ERROR)",
          "1455:     {",
          "1456:  emsg_funcname(_(e_call_to_function_that_failed_to_compile_str),",
          "1457:               ufunc->uf_name);",
          "1458:  return FAIL;",
          "1459:     }",
          "1461:     if ((isn = generate_instr(cctx,",
          "1462:       ufunc->uf_def_status != UF_NOT_COMPILED ? ISN_DCALL",
          "1463:         : ISN_UCALL)) == NULL)",
          "1464:  return FAIL;",
          "1465:     if (isn->isn_type == ISN_DCALL)",
          "1466:     {",
          "1467:  isn->isn_arg.dfunc.cdf_idx = ufunc->uf_dfunc_idx;",
          "1468:  isn->isn_arg.dfunc.cdf_argcount = argcount;",
          "1469:     }",
          "1470:     else",
          "1471:     {",
          "1474:  isn->isn_arg.ufunc.cuf_name = vim_strsave(ufunc->uf_name);",
          "1475:  isn->isn_arg.ufunc.cuf_argcount = argcount;",
          "1476:     }",
          "1478:     stack->ga_len -= argcount; // drop the arguments",
          "1479:     if (GA_GROW_FAILS(stack, 1))",
          "1480:  return FAIL;",
          "1482:     ((type_T **)stack->ga_data)[stack->ga_len] = ufunc->uf_ret_type;",
          "1483:     ++stack->ga_len;",
          "1485:     return OK;",
          "1486: }",
          "1491:     int",
          "1492: generate_UCALL(cctx_T *cctx, char_u *name, int argcount)",
          "1493: {",
          "1494:     isn_T *isn;",
          "1495:     garray_T *stack = &cctx->ctx_type_stack;",
          "1497:     RETURN_OK_IF_SKIP(cctx);",
          "1498:     if ((isn = generate_instr(cctx, ISN_UCALL)) == NULL)",
          "1499:  return FAIL;",
          "1500:     isn->isn_arg.ufunc.cuf_name = vim_strsave(name);",
          "1501:     isn->isn_arg.ufunc.cuf_argcount = argcount;",
          "1503:     stack->ga_len -= argcount; // drop the arguments",
          "1504:     if (GA_GROW_FAILS(stack, 1))",
          "1505:  return FAIL;",
          "1507:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_any;",
          "1508:     ++stack->ga_len;",
          "1510:     return OK;",
          "1511: }",
          "1517:     int",
          "1518: generate_PCALL(",
          "1519:  cctx_T *cctx,",
          "1520:  int argcount,",
          "1521:  char_u *name,",
          "1522:  type_T *type,",
          "1523:  int at_top)",
          "1524: {",
          "1525:     isn_T *isn;",
          "1526:     garray_T *stack = &cctx->ctx_type_stack;",
          "1527:     type_T *ret_type;",
          "1529:     RETURN_OK_IF_SKIP(cctx);",
          "1531:     if (type->tt_type == VAR_ANY)",
          "1532:  ret_type = &t_any;",
          "1533:     else if (type->tt_type == VAR_FUNC || type->tt_type == VAR_PARTIAL)",
          "1534:     {",
          "1535:  if (type->tt_argcount != -1)",
          "1536:  {",
          "1537:      int     varargs = (type->tt_flags & TTFLAG_VARARGS) ? 1 : 0;",
          "1539:      if (argcount < type->tt_min_argcount - varargs)",
          "1540:      {",
          "1541:   semsg(_(e_not_enough_arguments_for_function_str), name);",
          "1542:   return FAIL;",
          "1543:      }",
          "1544:      if (!varargs && argcount > type->tt_argcount)",
          "1545:      {",
          "1546:   semsg(_(e_too_many_arguments_for_function_str), name);",
          "1547:   return FAIL;",
          "1548:      }",
          "1549:      if (type->tt_args != NULL)",
          "1550:      {",
          "1551:   int i;",
          "1553:   for (i = 0; i < argcount; ++i)",
          "1554:   {",
          "1555:       int     offset = -argcount + i - (at_top ? 0 : 1);",
          "1556:       type_T *actual = ((type_T **)stack->ga_data)[",
          "1557:              stack->ga_len + offset];",
          "1558:       type_T *expected;",
          "1560:       if (varargs && i >= type->tt_argcount - 1)",
          "1561:    expected = type->tt_args[",
          "1562:           type->tt_argcount - 1]->tt_member;",
          "1563:       else if (i >= type->tt_min_argcount",
          "1564:              && actual == &t_special)",
          "1565:    expected = &t_any;",
          "1566:       else",
          "1567:    expected = type->tt_args[i];",
          "1568:       if (need_type(actual, expected, offset, i + 1,",
          "1569:           cctx, TRUE, FALSE) == FAIL)",
          "1570:       {",
          "1571:    arg_type_mismatch(expected, actual, i + 1);",
          "1572:    return FAIL;",
          "1573:       }",
          "1574:   }",
          "1575:      }",
          "1576:  }",
          "1577:  ret_type = type->tt_member;",
          "1578:  if (ret_type == &t_unknown)",
          "1580:      ret_type = &t_any;",
          "1581:     }",
          "1582:     else",
          "1583:     {",
          "1584:  semsg(_(e_not_callable_type_str), name);",
          "1585:  return FAIL;",
          "1586:     }",
          "1588:     if ((isn = generate_instr(cctx, ISN_PCALL)) == NULL)",
          "1589:  return FAIL;",
          "1590:     isn->isn_arg.pfunc.cpf_top = at_top;",
          "1591:     isn->isn_arg.pfunc.cpf_argcount = argcount;",
          "1593:     stack->ga_len -= argcount; // drop the arguments",
          "1596:     ((type_T **)stack->ga_data)[stack->ga_len - 1] = ret_type;",
          "1600:     if (at_top && generate_instr(cctx, ISN_PCALL_END) == NULL)",
          "1601:  return FAIL;",
          "1603:     return OK;",
          "1604: }",
          "1609:     int",
          "1610: generate_STRINGMEMBER(cctx_T *cctx, char_u *name, size_t len)",
          "1611: {",
          "1612:     isn_T *isn;",
          "1613:     garray_T *stack = &cctx->ctx_type_stack;",
          "1614:     type_T *type;",
          "1616:     RETURN_OK_IF_SKIP(cctx);",
          "1617:     if ((isn = generate_instr(cctx, ISN_STRINGMEMBER)) == NULL)",
          "1618:  return FAIL;",
          "1619:     isn->isn_arg.string = vim_strnsave(name, len);",
          "1622:     type = ((type_T **)stack->ga_data)[stack->ga_len - 1];",
          "1623:     if (type->tt_type != VAR_DICT && type != &t_any)",
          "1624:     {",
          "1625:  char *tofree;",
          "1627:  semsg(_(e_expected_dictionary_for_using_key_str_but_got_str),",
          "1628:             name, type_name(type, &tofree));",
          "1629:  vim_free(tofree);",
          "1630:  return FAIL;",
          "1631:     }",
          "1633:     if (type->tt_type == VAR_DICT)",
          "1634:     {",
          "1635:  ((type_T **)stack->ga_data)[stack->ga_len - 1] =",
          "1636:         type->tt_member == &t_unknown ? &t_any : type->tt_member;",
          "1637:     }",
          "1639:     return OK;",
          "1640: }",
          "1645:     int",
          "1646: generate_ECHO(cctx_T *cctx, int with_white, int count)",
          "1647: {",
          "1648:     isn_T *isn;",
          "1650:     RETURN_OK_IF_SKIP(cctx);",
          "1651:     if ((isn = generate_instr_drop(cctx, ISN_ECHO, count)) == NULL)",
          "1652:  return FAIL;",
          "1653:     isn->isn_arg.echo.echo_with_white = with_white;",
          "1654:     isn->isn_arg.echo.echo_count = count;",
          "1656:     return OK;",
          "1657: }",
          "1662:     int",
          "1663: generate_MULT_EXPR(cctx_T *cctx, isntype_T isn_type, int count)",
          "1664: {",
          "1665:     isn_T *isn;",
          "1667:     if ((isn = generate_instr_drop(cctx, isn_type, count)) == NULL)",
          "1668:  return FAIL;",
          "1669:     isn->isn_arg.number = count;",
          "1671:     return OK;",
          "1672: }",
          "1677:     int",
          "1678: generate_PUT(cctx_T *cctx, int regname, linenr_T lnum)",
          "1679: {",
          "1680:     isn_T *isn;",
          "1682:     RETURN_OK_IF_SKIP(cctx);",
          "1683:     if ((isn = generate_instr(cctx, ISN_PUT)) == NULL)",
          "1684:  return FAIL;",
          "1685:     isn->isn_arg.put.put_regname = regname;",
          "1686:     isn->isn_arg.put.put_lnum = lnum;",
          "1687:     return OK;",
          "1688: }",
          "1694:     int",
          "1695: generate_EXEC_copy(cctx_T *cctx, isntype_T isntype, char_u *line)",
          "1696: {",
          "1697:     isn_T *isn;",
          "1699:     RETURN_OK_IF_SKIP(cctx);",
          "1700:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "1701:  return FAIL;",
          "1702:     isn->isn_arg.string = vim_strsave(line);",
          "1703:     return OK;",
          "1704: }",
          "1710:     int",
          "1711: generate_EXEC(cctx_T *cctx, isntype_T isntype, char_u *str)",
          "1712: {",
          "1713:     isn_T *isn;",
          "1715:     if (cctx->ctx_skip == SKIP_YES)",
          "1716:     {",
          "1717:  vim_free(str);",
          "1718:  return OK;",
          "1719:     }",
          "1720:     if ((isn = generate_instr(cctx, isntype)) == NULL)",
          "1721:     {",
          "1722:  vim_free(str);",
          "1723:  return FAIL;",
          "1724:     }",
          "1725:     isn->isn_arg.string = str;",
          "1726:     return OK;",
          "1727: }",
          "1729:     int",
          "1730: generate_LEGACY_EVAL(cctx_T *cctx, char_u *line)",
          "1731: {",
          "1732:     isn_T *isn;",
          "1733:     garray_T *stack = &cctx->ctx_type_stack;",
          "1735:     RETURN_OK_IF_SKIP(cctx);",
          "1736:     if ((isn = generate_instr(cctx, ISN_LEGACY_EVAL)) == NULL)",
          "1737:  return FAIL;",
          "1738:     isn->isn_arg.string = vim_strsave(line);",
          "1740:     if (GA_GROW_FAILS(stack, 1))",
          "1741:  return FAIL;",
          "1742:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_any;",
          "1743:     ++stack->ga_len;",
          "1745:     return OK;",
          "1746: }",
          "1748:     int",
          "1749: generate_EXECCONCAT(cctx_T *cctx, int count)",
          "1750: {",
          "1751:     isn_T *isn;",
          "1753:     if ((isn = generate_instr_drop(cctx, ISN_EXECCONCAT, count)) == NULL)",
          "1754:  return FAIL;",
          "1755:     isn->isn_arg.number = count;",
          "1756:     return OK;",
          "1757: }",
          "1762:     int",
          "1763: generate_RANGE(cctx_T *cctx, char_u *range)",
          "1764: {",
          "1765:     isn_T *isn;",
          "1766:     garray_T *stack = &cctx->ctx_type_stack;",
          "1768:     if ((isn = generate_instr(cctx, ISN_RANGE)) == NULL)",
          "1769:  return FAIL;",
          "1770:     isn->isn_arg.string = range;",
          "1772:     if (GA_GROW_FAILS(stack, 1))",
          "1773:  return FAIL;",
          "1774:     ((type_T **)stack->ga_data)[stack->ga_len] = &t_number;",
          "1775:     ++stack->ga_len;",
          "1776:     return OK;",
          "1777: }",
          "1779:     int",
          "1780: generate_UNPACK(cctx_T *cctx, int var_count, int semicolon)",
          "1781: {",
          "1782:     isn_T *isn;",
          "1784:     RETURN_OK_IF_SKIP(cctx);",
          "1785:     if ((isn = generate_instr(cctx, ISN_UNPACK)) == NULL)",
          "1786:  return FAIL;",
          "1787:     isn->isn_arg.unpack.unp_count = var_count;",
          "1788:     isn->isn_arg.unpack.unp_semicolon = semicolon;",
          "1789:     return OK;",
          "1790: }",
          "1795:     int",
          "1796: generate_cmdmods(cctx_T *cctx, cmdmod_T *cmod)",
          "1797: {",
          "1798:     isn_T *isn;",
          "1800:     if (has_cmdmod(cmod, FALSE))",
          "1801:     {",
          "1802:  cctx->ctx_has_cmdmod = TRUE;",
          "1804:  if ((isn = generate_instr(cctx, ISN_CMDMOD)) == NULL)",
          "1805:      return FAIL;",
          "1806:  isn->isn_arg.cmdmod.cf_cmdmod = ALLOC_ONE(cmdmod_T);",
          "1807:  if (isn->isn_arg.cmdmod.cf_cmdmod == NULL)",
          "1808:      return FAIL;",
          "1809:  mch_memmove(isn->isn_arg.cmdmod.cf_cmdmod, cmod, sizeof(cmdmod_T));",
          "1811:  cmod->cmod_filter_regmatch.regprog = NULL;",
          "1812:     }",
          "1814:     return OK;",
          "1815: }",
          "1817:     int",
          "1818: generate_undo_cmdmods(cctx_T *cctx)",
          "1819: {",
          "1820:     if (cctx->ctx_has_cmdmod && generate_instr(cctx, ISN_CMDMOD_REV) == NULL)",
          "1821:  return FAIL;",
          "1822:     cctx->ctx_has_cmdmod = FALSE;",
          "1823:     return OK;",
          "1824: }",
          "1830:     int",
          "1831: generate_store_var(",
          "1832:  cctx_T  *cctx,",
          "1833:  assign_dest_T dest,",
          "1834:  int  opt_flags,",
          "1835:  int  vimvaridx,",
          "1836:  int  scriptvar_idx,",
          "1837:  int  scriptvar_sid,",
          "1838:  type_T  *type,",
          "1839:  char_u  *name)",
          "1840: {",
          "1841:     switch (dest)",
          "1842:     {",
          "1843:  case dest_option:",
          "1844:      return generate_STOREOPT(cctx, ISN_STOREOPT,",
          "1845:      skip_option_env_lead(name), opt_flags);",
          "1846:  case dest_func_option:",
          "1847:      return generate_STOREOPT(cctx, ISN_STOREFUNCOPT,",
          "1848:      skip_option_env_lead(name), opt_flags);",
          "1849:  case dest_global:",
          "1851:      return generate_STORE(cctx, vim_strchr(name, AUTOLOAD_CHAR) == NULL",
          "1852:      ? ISN_STOREG : ISN_STOREAUTO, 0, name);",
          "1853:  case dest_buffer:",
          "1855:      return generate_STORE(cctx, ISN_STOREB, 0, name);",
          "1856:  case dest_window:",
          "1858:      return generate_STORE(cctx, ISN_STOREW, 0, name);",
          "1859:  case dest_tab:",
          "1861:      return generate_STORE(cctx, ISN_STORET, 0, name);",
          "1862:  case dest_env:",
          "1863:      return generate_STORE(cctx, ISN_STOREENV, 0, name + 1);",
          "1864:  case dest_reg:",
          "1865:      return generate_STORE(cctx, ISN_STOREREG,",
          "1866:       name[1] == '@' ? '\"' : name[1], NULL);",
          "1867:  case dest_vimvar:",
          "1868:      return generate_STORE(cctx, ISN_STOREV, vimvaridx, NULL);",
          "1869:  case dest_script:",
          "1870:      if (scriptvar_idx < 0)",
          "1872:   return generate_OLDSCRIPT(cctx, ISN_STORES, name,",
          "1873:          scriptvar_sid, type);",
          "1874:      return generate_VIM9SCRIPT(cctx, ISN_STORESCRIPT,",
          "1875:         scriptvar_sid, scriptvar_idx, type);",
          "1876:  case dest_local:",
          "1877:  case dest_expr:",
          "1879:      break;",
          "1880:     }",
          "1881:     return FAIL;",
          "1882: }",
          "1884:     int",
          "1885: generate_store_lhs(cctx_T *cctx, lhs_T *lhs, int instr_count)",
          "1886: {",
          "1887:     if (lhs->lhs_dest != dest_local)",
          "1888:  return generate_store_var(cctx, lhs->lhs_dest,",
          "1889:        lhs->lhs_opt_flags, lhs->lhs_vimvaridx,",
          "1890:        lhs->lhs_scriptvar_idx, lhs->lhs_scriptvar_sid,",
          "1891:        lhs->lhs_type, lhs->lhs_name);",
          "1893:     if (lhs->lhs_lvar != NULL)",
          "1894:     {",
          "1895:  garray_T *instr = &cctx->ctx_instr;",
          "1896:  isn_T  *isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;",
          "1900:  if (lhs->lhs_lvar->lv_from_outer == 0",
          "1901:   && instr->ga_len == instr_count + 1",
          "1902:   && isn->isn_type == ISN_PUSHNR)",
          "1903:  {",
          "1904:      varnumber_T val = isn->isn_arg.number;",
          "1905:      garray_T    *stack = &cctx->ctx_type_stack;",
          "1907:      isn->isn_type = ISN_STORENR;",
          "1908:      isn->isn_arg.storenr.stnr_idx = lhs->lhs_lvar->lv_idx;",
          "1909:      isn->isn_arg.storenr.stnr_val = val;",
          "1910:      if (stack->ga_len > 0)",
          "1911:   --stack->ga_len;",
          "1912:  }",
          "1913:  else if (lhs->lhs_lvar->lv_from_outer > 0)",
          "1914:      generate_STOREOUTER(cctx, lhs->lhs_lvar->lv_idx,",
          "1915:        lhs->lhs_lvar->lv_from_outer);",
          "1916:  else",
          "1917:      generate_STORE(cctx, ISN_STORE, lhs->lhs_lvar->lv_idx, NULL);",
          "1918:     }",
          "1919:     return OK;",
          "1920: }",
          "1922: #if defined(FEAT_PROFILE) || defined(PROTO)",
          "1923:     void",
          "1924: may_generate_prof_end(cctx_T *cctx, int prof_lnum)",
          "1925: {",
          "1926:     if (cctx->ctx_compile_type == CT_PROFILE && prof_lnum >= 0)",
          "1927:  generate_instr(cctx, ISN_PROF_END);",
          "1928: }",
          "1929: #endif",
          "1935:     void",
          "1936: delete_instr(isn_T *isn)",
          "1937: {",
          "1938:     switch (isn->isn_type)",
          "1939:     {",
          "1940:  case ISN_DEF:",
          "1941:  case ISN_EXEC:",
          "1942:  case ISN_EXECRANGE:",
          "1943:  case ISN_EXEC_SPLIT:",
          "1944:  case ISN_LEGACY_EVAL:",
          "1945:  case ISN_LOADAUTO:",
          "1946:  case ISN_LOADB:",
          "1947:  case ISN_LOADENV:",
          "1948:  case ISN_LOADG:",
          "1949:  case ISN_LOADOPT:",
          "1950:  case ISN_LOADT:",
          "1951:  case ISN_LOADW:",
          "1952:  case ISN_LOCKUNLOCK:",
          "1953:  case ISN_PUSHEXC:",
          "1954:  case ISN_PUSHFUNC:",
          "1955:  case ISN_PUSHS:",
          "1956:  case ISN_RANGE:",
          "1957:  case ISN_STOREAUTO:",
          "1958:  case ISN_STOREB:",
          "1959:  case ISN_STOREENV:",
          "1960:  case ISN_STOREG:",
          "1961:  case ISN_STORET:",
          "1962:  case ISN_STOREW:",
          "1963:  case ISN_STRINGMEMBER:",
          "1964:      vim_free(isn->isn_arg.string);",
          "1965:      break;",
          "1967:  case ISN_SUBSTITUTE:",
          "1968:      {",
          "1969:   int idx;",
          "1970:   isn_T *list = isn->isn_arg.subs.subs_instr;",
          "1972:   vim_free(isn->isn_arg.subs.subs_cmd);",
          "1973:   for (idx = 0; list[idx].isn_type != ISN_FINISH; ++idx)",
          "1974:       delete_instr(list + idx);",
          "1975:   vim_free(list);",
          "1976:      }",
          "1977:      break;",
          "1979:  case ISN_INSTR:",
          "1980:      {",
          "1981:   int idx;",
          "1982:   isn_T *list = isn->isn_arg.instr;",
          "1984:   for (idx = 0; list[idx].isn_type != ISN_FINISH; ++idx)",
          "1985:       delete_instr(list + idx);",
          "1986:   vim_free(list);",
          "1987:      }",
          "1988:      break;",
          "1990:  case ISN_LOADS:",
          "1991:  case ISN_STORES:",
          "1992:      vim_free(isn->isn_arg.loadstore.ls_name);",
          "1993:      break;",
          "1995:  case ISN_UNLET:",
          "1996:  case ISN_UNLETENV:",
          "1997:      vim_free(isn->isn_arg.unlet.ul_name);",
          "1998:      break;",
          "2000:  case ISN_STOREOPT:",
          "2001:  case ISN_STOREFUNCOPT:",
          "2002:      vim_free(isn->isn_arg.storeopt.so_name);",
          "2003:      break;",
          "2005:  case ISN_PUSHBLOB:   // push blob isn_arg.blob",
          "2006:      blob_unref(isn->isn_arg.blob);",
          "2007:      break;",
          "2009:  case ISN_PUSHJOB:",
          "2010: #ifdef FEAT_JOB_CHANNEL",
          "2011:      job_unref(isn->isn_arg.job);",
          "2012: #endif",
          "2013:      break;",
          "2015:  case ISN_PUSHCHANNEL:",
          "2016: #ifdef FEAT_JOB_CHANNEL",
          "2017:      channel_unref(isn->isn_arg.channel);",
          "2018: #endif",
          "2019:      break;",
          "2021:  case ISN_UCALL:",
          "2022:      vim_free(isn->isn_arg.ufunc.cuf_name);",
          "2023:      break;",
          "2025:  case ISN_FUNCREF:",
          "2026:      {",
          "2027:   if (isn->isn_arg.funcref.fr_func_name == NULL)",
          "2028:   {",
          "2029:       dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "2030:         + isn->isn_arg.funcref.fr_dfunc_idx;",
          "2031:       ufunc_T *ufunc = dfunc->df_ufunc;",
          "2033:       if (ufunc != NULL && func_name_refcount(ufunc->uf_name))",
          "2034:    func_ptr_unref(ufunc);",
          "2035:   }",
          "2036:   else",
          "2037:   {",
          "2038:       char_u *name = isn->isn_arg.funcref.fr_func_name;",
          "2040:       if (name != NULL)",
          "2041:    func_unref(name);",
          "2042:       vim_free(isn->isn_arg.funcref.fr_func_name);",
          "2043:   }",
          "2044:      }",
          "2045:      break;",
          "2047:  case ISN_DCALL:",
          "2048:      {",
          "2049:   dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "2050:             + isn->isn_arg.dfunc.cdf_idx;",
          "2052:   if (dfunc->df_ufunc != NULL",
          "2053:           && func_name_refcount(dfunc->df_ufunc->uf_name))",
          "2054:       func_ptr_unref(dfunc->df_ufunc);",
          "2055:      }",
          "2056:      break;",
          "2058:  case ISN_NEWFUNC:",
          "2059:      {",
          "2060:   char_u  *lambda = isn->isn_arg.newfunc.nf_lambda;",
          "2061:   ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);",
          "2063:   if (ufunc != NULL)",
          "2064:   {",
          "2065:       unlink_def_function(ufunc);",
          "2066:       func_ptr_unref(ufunc);",
          "2067:   }",
          "2069:   vim_free(lambda);",
          "2070:   vim_free(isn->isn_arg.newfunc.nf_global);",
          "2071:      }",
          "2072:      break;",
          "2074:  case ISN_CHECKTYPE:",
          "2075:  case ISN_SETTYPE:",
          "2076:      free_type(isn->isn_arg.type.ct_type);",
          "2077:      break;",
          "2079:  case ISN_CMDMOD:",
          "2080:      vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod",
          "2081:             ->cmod_filter_regmatch.regprog);",
          "2082:      vim_free(isn->isn_arg.cmdmod.cf_cmdmod);",
          "2083:      break;",
          "2085:  case ISN_LOADSCRIPT:",
          "2086:  case ISN_STORESCRIPT:",
          "2087:      vim_free(isn->isn_arg.script.scriptref);",
          "2088:      break;",
          "2090:  case ISN_TRY:",
          "2091:      vim_free(isn->isn_arg.try.try_ref);",
          "2092:      break;",
          "2094:  case ISN_CEXPR_CORE:",
          "2095:      vim_free(isn->isn_arg.cexpr.cexpr_ref->cer_cmdline);",
          "2096:      vim_free(isn->isn_arg.cexpr.cexpr_ref);",
          "2097:      break;",
          "2099:  case ISN_2BOOL:",
          "2100:  case ISN_2STRING:",
          "2101:  case ISN_2STRING_ANY:",
          "2102:  case ISN_ADDBLOB:",
          "2103:  case ISN_ADDLIST:",
          "2104:  case ISN_ANYINDEX:",
          "2105:  case ISN_ANYSLICE:",
          "2106:  case ISN_BCALL:",
          "2107:  case ISN_BLOBAPPEND:",
          "2108:  case ISN_BLOBINDEX:",
          "2109:  case ISN_BLOBSLICE:",
          "2110:  case ISN_CATCH:",
          "2111:  case ISN_CEXPR_AUCMD:",
          "2112:  case ISN_CHECKLEN:",
          "2113:  case ISN_CHECKNR:",
          "2114:  case ISN_CLEARDICT:",
          "2115:  case ISN_CMDMOD_REV:",
          "2116:  case ISN_COMPAREANY:",
          "2117:  case ISN_COMPAREBLOB:",
          "2118:  case ISN_COMPAREBOOL:",
          "2119:  case ISN_COMPAREDICT:",
          "2120:  case ISN_COMPAREFLOAT:",
          "2121:  case ISN_COMPAREFUNC:",
          "2122:  case ISN_COMPARELIST:",
          "2123:  case ISN_COMPARENR:",
          "2124:  case ISN_COMPARESPECIAL:",
          "2125:  case ISN_COMPARESTRING:",
          "2126:  case ISN_CONCAT:",
          "2127:  case ISN_COND2BOOL:",
          "2128:  case ISN_DEBUG:",
          "2129:  case ISN_DROP:",
          "2130:  case ISN_ECHO:",
          "2131:  case ISN_ECHOCONSOLE:",
          "2132:  case ISN_ECHOERR:",
          "2133:  case ISN_ECHOMSG:",
          "2134:  case ISN_ENDTRY:",
          "2135:  case ISN_EXECCONCAT:",
          "2136:  case ISN_EXECUTE:",
          "2137:  case ISN_FINALLY:",
          "2138:  case ISN_FINISH:",
          "2139:  case ISN_FOR:",
          "2140:  case ISN_GETITEM:",
          "2141:  case ISN_JUMP:",
          "2142:  case ISN_JUMP_IF_ARG_SET:",
          "2143:  case ISN_LISTAPPEND:",
          "2144:  case ISN_LISTINDEX:",
          "2145:  case ISN_LISTSLICE:",
          "2146:  case ISN_LOAD:",
          "2147:  case ISN_LOADBDICT:",
          "2148:  case ISN_LOADGDICT:",
          "2149:  case ISN_LOADOUTER:",
          "2150:  case ISN_LOADREG:",
          "2151:  case ISN_LOADTDICT:",
          "2152:  case ISN_LOADV:",
          "2153:  case ISN_LOADWDICT:",
          "2154:  case ISN_LOCKCONST:",
          "2155:  case ISN_MEMBER:",
          "2156:  case ISN_NEGATENR:",
          "2157:  case ISN_NEWDICT:",
          "2158:  case ISN_NEWLIST:",
          "2159:  case ISN_OPANY:",
          "2160:  case ISN_OPFLOAT:",
          "2161:  case ISN_OPNR:",
          "2162:  case ISN_PCALL:",
          "2163:  case ISN_PCALL_END:",
          "2164:  case ISN_PROF_END:",
          "2165:  case ISN_PROF_START:",
          "2166:  case ISN_PUSHBOOL:",
          "2167:  case ISN_PUSHF:",
          "2168:  case ISN_PUSHNR:",
          "2169:  case ISN_PUSHSPEC:",
          "2170:  case ISN_PUT:",
          "2171:  case ISN_REDIREND:",
          "2172:  case ISN_REDIRSTART:",
          "2173:  case ISN_RETURN:",
          "2174:  case ISN_RETURN_VOID:",
          "2175:  case ISN_SHUFFLE:",
          "2176:  case ISN_SLICE:",
          "2177:  case ISN_STORE:",
          "2178:  case ISN_STOREINDEX:",
          "2179:  case ISN_STORENR:",
          "2180:  case ISN_STOREOUTER:",
          "2181:  case ISN_STORERANGE:",
          "2182:  case ISN_STOREREG:",
          "2183:  case ISN_STOREV:",
          "2184:  case ISN_STRINDEX:",
          "2185:  case ISN_STRSLICE:",
          "2186:  case ISN_THROW:",
          "2187:  case ISN_TRYCONT:",
          "2188:  case ISN_UNLETINDEX:",
          "2189:  case ISN_UNLETRANGE:",
          "2190:  case ISN_UNPACK:",
          "2191:  case ISN_USEDICT:",
          "2193:      break;",
          "2194:     }",
          "2195: }",
          "2197:     void",
          "2198: clear_instr_ga(garray_T *gap)",
          "2199: {",
          "2200:     int idx;",
          "2202:     for (idx = 0; idx < gap->ga_len; ++idx)",
          "2203:  delete_instr(((isn_T *)gap->ga_data) + idx);",
          "2204:     ga_clear(gap);",
          "2205: }",
          "2208: #endif  // defined(FEAT_EVAL)",
          "",
          "---------------"
        ],
        "src/vim9script.c||src/vim9script.c": [
          "File: src/vim9script.c -> src/vim9script.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include \"vim.h\"",
          "17: # include \"vim9.h\"",
          "18: #endif",
          "",
          "[Removed Lines]",
          "16: #if defined(FEAT_EVAL)",
          "",
          "[Added Lines]",
          "17: #ifdef PROTO",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "074f84c01fbe70554feb6a71c0d9cacf2ef77ca5",
      "candidate_info": {
        "commit_hash": "074f84c01fbe70554feb6a71c0d9cacf2ef77ca5",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/074f84c01fbe70554feb6a71c0d9cacf2ef77ca5",
        "files": [
          "src/testdir/test_vim9_func.vim",
          "src/userfunc.c",
          "src/version.c"
        ],
        "message": "patch 8.2.2864: Vim9: crash when using inline function\n\nProblem:    Vim9: crash when using inline function.\nSolution:   Check for NULL pointer. Make using inline function work inside\n            lambda. (closes #8217)",
        "before_after_code_files": [
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "2102:   CheckScriptSuccess(lines)",
          "2103: enddef",
          "2105: def Shadowed(): list<number>",
          "2106:   var FuncList: list<func: number> = [() => 42]",
          "2107:   return FuncList->mapnew((_, Shadowed) => Shadowed())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2105: def Test_nested_inline_lambda()",
          "2106:   # TODO: use the \"text\" argument",
          "2107:   var lines =<< trim END",
          "2108:       vim9script",
          "2109:       def F(text: string): func(string): func(string): string",
          "2110:         return (arg: string): func(string): string => ((sep: string): string => {",
          "2111:             return sep .. arg",
          "2112:           })",
          "2113:       enddef",
          "2114:       assert_equal('--there', F('unused')('there')('--'))",
          "2115:   END",
          "2116:   CheckScriptSuccess(lines)",
          "2117: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "945:      line_arg = NULL;",
          "946:     }",
          "951:  ret = OK;",
          "953: theend:",
          "",
          "[Removed Lines]",
          "950:     if (!eap->skip && !did_emsg)",
          "",
          "[Added Lines]",
          "950:     if (!did_emsg)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "974:  char_u     *ret_type)",
          "975: {",
          "976:     int  evaluate = (evalarg->eval_flags & EVAL_EVALUATE);",
          "977:     ufunc_T *ufunc = NULL;",
          "978:     exarg_T eap;",
          "979:     garray_T newlines;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "978:     garray_T *gap = &evalarg->eval_ga;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1010:  vim_free(cmdline);",
          "1011:  goto erret;",
          "1012:     }",
          "1013:     if (cmdline != NULL)",
          "1014:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1017:     evalarg->eval_break_count += newlines.ga_len;",
          "1018:     if (gap->ga_itemsize > 0)",
          "1019:     {",
          "1020:  int idx;",
          "1021:  char_u *last;",
          "1022:  size_t  plen;",
          "1023:  char_u  *pnl;",
          "1025:  for (idx = 0; idx < newlines.ga_len; ++idx)",
          "1026:  {",
          "1027:      char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);",
          "1029:      if (ga_grow(gap, 1) == FAIL)",
          "1030:   goto erret;",
          "1036:      if (*p == NUL || vim9_comment_start(p))",
          "1037:   p = (char_u *)\"\";",
          "1038:      plen = STRLEN(p);",
          "1039:      pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);",
          "1040:      if (pnl != NULL)",
          "1041:   mch_memmove(pnl + 1, p, plen + 1);",
          "1042:      ((char_u **)gap->ga_data)[gap->ga_len] = pnl;",
          "1043:      ++gap->ga_len;",
          "1044:  }",
          "1045:  if (ga_grow(gap, 1) == FAIL)",
          "1046:      goto erret;",
          "1047:  if (cmdline != NULL)",
          "1049:      last = cmdline;",
          "1050:  else",
          "1052:      last = (char_u *)\"}\";",
          "1053:  plen = STRLEN(last);",
          "1054:  pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);",
          "1055:  if (pnl != NULL)",
          "1056:      mch_memmove(pnl + 1, last, plen + 1);",
          "1057:  ((char_u **)gap->ga_data)[gap->ga_len] = pnl;",
          "1058:  ++gap->ga_len;",
          "1059:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1022:     else",
          "1025:     name = get_lambda_name();",
          "1026:     ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);",
          "1027:     if (ufunc == NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1073:     if (!evaluate)",
          "1074:     {",
          "1075:  ret = OK;",
          "1076:  goto erret;",
          "1077:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1078:  SOURCING_LNUM = lnum_save;",
          "1079:     vim_free(line_to_free);",
          "1080:     ga_clear_strings(&newlines);",
          "1082:     ga_clear_strings(default_args);",
          "1083:     if (ufunc != NULL)",
          "1084:     {",
          "",
          "[Removed Lines]",
          "1081:     ga_clear_strings(newargs);",
          "",
          "[Added Lines]",
          "1135:     if (newargs != NULL)",
          "1136:  ga_clear_strings(newargs);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1222:  int     len;",
          "1223:  int     flags = 0;",
          "1224:  char_u     *p;",
          "1225:  char_u     *name = get_lambda_name();",
          "1227:  fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1280:  char_u     *line_end;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1236:  if (ga_grow(&newlines, 1) == FAIL)",
          "1237:      goto errret;",
          "1241:  p = alloc(len);",
          "1242:  if (p == NULL)",
          "1243:      goto errret;",
          "1244:  ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;",
          "1245:  STRCPY(p, \"return \");",
          "1247:  if (strstr((char *)p + 7, \"a:\") == NULL)",
          "1249:      flags |= FC_NOARGS;",
          "",
          "[Removed Lines]",
          "1240:  len = 7 + (int)(end - start) + 1;",
          "1246:  vim_strncpy(p + 7, start, end - start);",
          "",
          "[Added Lines]",
          "1296:  line_end = vim_strchr(start, '\\n');",
          "1297:  if (line_end == NULL)",
          "1298:      line_end = end;",
          "1301:  len = 7 + (int)(line_end - start) + 1;",
          "1307:  vim_strncpy(p + 7, start, line_end - start);",
          "1309:  if (line_end != end)",
          "1310:  {",
          "1313:      while (*line_end == '\\n')",
          "1314:      {",
          "1315:   if (ga_grow(&newlines, 1) == FAIL)",
          "1316:       goto errret;",
          "1317:   start = line_end + 1;",
          "1318:   line_end = vim_strchr(start, '\\n');",
          "1319:   if (line_end == NULL)",
          "1320:       line_end = end;",
          "1321:   ((char_u **)(newlines.ga_data))[newlines.ga_len++] =",
          "1322:       vim_strnsave(start, line_end - start);",
          "1323:      }",
          "1324:  }",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2863,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2864,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "00b28d6c23d8e662cab27e461825777c0a2e387a",
      "candidate_info": {
        "commit_hash": "00b28d6c23d8e662cab27e461825777c0a2e387a",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/00b28d6c23d8e662cab27e461825777c0a2e387a",
        "files": [
          "runtime/doc/vim9class.txt",
          "src/errors.h",
          "src/eval.c",
          "src/evalfunc.c",
          "src/evalvars.c",
          "src/if_py_both.h",
          "src/json.c",
          "src/proto/userfunc.pro",
          "src/proto/vim9class.pro",
          "src/proto/vim9instr.pro",
          "src/proto/vim9script.pro",
          "src/proto/vim9type.pro",
          "src/structs.h",
          "src/testdir/Make_all.mak",
          "src/testdir/test_vim9_class.vim",
          "src/testing.c",
          "src/typval.c",
          "src/userfunc.c",
          "src/version.c",
          "src/vim.h",
          "src/vim9.h",
          "src/vim9class.c",
          "src/vim9compile.c",
          "src/vim9execute.c",
          "src/vim9expr.c",
          "src/vim9instr.c",
          "src/vim9script.c",
          "src/vim9type.c",
          "src/viminfo.c"
        ],
        "message": "patch 9.0.1031: Vim9 class is not implemented yet\n\nProblem:    Vim9 class is not implemented yet.\nSolution:   Add very basic class support.",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/eval.c||src/eval.c",
          "src/evalfunc.c||src/evalfunc.c",
          "src/evalvars.c||src/evalvars.c",
          "src/if_py_both.h||src/if_py_both.h",
          "src/json.c||src/json.c",
          "src/proto/userfunc.pro||src/proto/userfunc.pro",
          "src/proto/vim9class.pro||src/proto/vim9class.pro",
          "src/proto/vim9instr.pro||src/proto/vim9instr.pro",
          "src/proto/vim9script.pro||src/proto/vim9script.pro",
          "src/proto/vim9type.pro||src/proto/vim9type.pro",
          "src/structs.h||src/structs.h",
          "src/testdir/Make_all.mak||src/testdir/Make_all.mak",
          "src/testdir/test_vim9_class.vim||src/testdir/test_vim9_class.vim",
          "src/testing.c||src/testing.c",
          "src/typval.c||src/typval.c",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim.h||src/vim.h",
          "src/vim9.h||src/vim9.h",
          "src/vim9class.c||src/vim9class.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9execute.c||src/vim9execute.c",
          "src/vim9expr.c||src/vim9expr.c",
          "src/vim9instr.c||src/vim9instr.c",
          "src/vim9script.c||src/vim9script.c",
          "src/vim9type.c||src/vim9type.c",
          "src/viminfo.c||src/viminfo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ],
          "candidate": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3346: #ifdef FEAT_EVAL",
          "3347: EXTERN char e_class_name_must_start_with_uppercase_letter_str[]",
          "3348:  INIT(= N_(\"E1314: Class name must start with an uppercase letter: %s\"));",
          "3349: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3349: EXTERN char e_white_space_required_after_class_name_str[]",
          "3350:  INIT(= N_(\"E1315: White space required after class name: %s\"));",
          "3351: EXTERN char e_class_can_only_be_defined_in_vim9_script[]",
          "3352:  INIT(= N_(\"E1316: Class can only be defined in Vim9 script\"));",
          "3353: EXTERN char e_invalid_object_member_declaration_str[]",
          "3354:  INIT(= N_(\"E1317: Invalid object member declaration: %s\"));",
          "3355: EXTERN char e_not_valid_command_in_class_str[]",
          "3356:  INIT(= N_(\"E1318: Not a valid command in a class: %s\"));",
          "3357: EXTERN char e_using_class_as_number[]",
          "3358:  INIT(= N_(\"E1319: Using a class as a Number\"));",
          "3359: EXTERN char e_using_object_as_number[]",
          "3360:  INIT(= N_(\"E1320: Using an object as a Number\"));",
          "3361: EXTERN char e_using_class_as_float[]",
          "3362:  INIT(= N_(\"E1321: Using a class as a Float\"));",
          "3363: EXTERN char e_using_object_as_float[]",
          "3364:  INIT(= N_(\"E1322: Using an object as a Float\"));",
          "3365: EXTERN char e_using_class_as_string[]",
          "3366:  INIT(= N_(\"E1323: Using a class as a String\"));",
          "3367: EXTERN char e_using_object_as_string[]",
          "3368:  INIT(= N_(\"E1324: Using an object as a String\"));",
          "3369: EXTERN char e_method_not_found_on_class_str_str[]",
          "3370:  INIT(= N_(\"E1325: Method not found on class \\\"%s\\\": %s\"));",
          "3371: EXTERN char e_member_not_found_on_object_str_str[]",
          "3372:  INIT(= N_(\"E1326: Member not found on object \\\"%s\\\": %s\"));",
          "",
          "---------------"
        ],
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1548:     {",
          "1549:  cc = *endp;",
          "1552:      return;",
          "1554:  if (lp->ll_blob != NULL)",
          "",
          "[Removed Lines]",
          "1551:  if (in_vim9script() && check_reserved_name(lp->ll_name) == FAIL)",
          "",
          "[Added Lines]",
          "1551:  if (in_vim9script() && check_reserved_name(lp->ll_name, NULL) == FAIL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1724:      case VAR_JOB:",
          "1725:      case VAR_CHANNEL:",
          "1726:      case VAR_INSTR:",
          "1727:   break;",
          "1729:      case VAR_BLOB:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1727:      case VAR_CLASS:",
          "1728:      case VAR_OBJECT:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3850:       return OK;",
          "3851:   }",
          "3852:   break;",
          "3853:  case 11: if (STRNCMP(s, \"null_string\", 11) == 0)",
          "3854:   {",
          "3855:       rettv->v_type = VAR_STRING;",
          "3856:       rettv->vval.v_string = NULL;",
          "3857:       return OK;",
          "3858:   }",
          "3859:   break;",
          "3860:  case 12:",
          "3861:   if (STRNCMP(s, \"null_channel\", 12) == 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3855:  case 10: if (STRNCMP(s, \"null_class\", 10) == 0)",
          "3856:   {",
          "3857:       rettv->v_type = VAR_CLASS;",
          "3858:       rettv->vval.v_class = NULL;",
          "3859:       return OK;",
          "3860:   }",
          "3861:    break;",
          "3868:   if (STRNCMP(s, \"null_object\", 11) == 0)",
          "3869:   {",
          "3870:       rettv->v_type = VAR_OBJECT;",
          "3871:       rettv->vval.v_object = NULL;",
          "3872:       return OK;",
          "3873:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4685:  case VAR_JOB:",
          "4686:  case VAR_CHANNEL:",
          "4687:  case VAR_INSTR:",
          "4688:      if (verbose)",
          "4689:   emsg(_(e_cannot_index_special_variable));",
          "4690:      return FAIL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4703:  case VAR_CLASS:",
          "4704:  case VAR_OBJECT:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4788:  case VAR_JOB:",
          "4789:  case VAR_CHANNEL:",
          "4790:  case VAR_INSTR:",
          "4791:      break; // not evaluating, skipping over subscript",
          "4793:  case VAR_NUMBER:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4808:  case VAR_CLASS:",
          "4809:  case VAR_OBJECT:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5781:      r = (char_u *)\"instructions\";",
          "5782:      break;",
          "5784:  case VAR_FLOAT:",
          "5786:      vim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5803:  case VAR_CLASS:",
          "5805:      r = (char_u *)\"class\";",
          "5806:      break;",
          "5808:  case VAR_OBJECT:",
          "5810:      r = (char_u *)\"object\";",
          "5811:      break;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6588:   ret = FAIL;",
          "6589:      }",
          "6590:  }",
          "6591:  else",
          "6592:      break;",
          "6593:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6620:  else if (**arg == '.' && (rettv->v_type == VAR_CLASS",
          "6621:             || rettv->v_type == VAR_OBJECT))",
          "6622:  {",
          "6628:      if (class_object_index(arg, rettv, evalarg, verbose) == FAIL)",
          "6629:      {",
          "6630:   clear_tv(rettv);",
          "6631:   ret = FAIL;",
          "6632:      }",
          "6633:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6644:  case VAR_JOB:",
          "6645:  case VAR_CHANNEL:",
          "6646:  case VAR_INSTR:",
          "6647:      copy_tv(from, to);",
          "6648:      break;",
          "6649:  case VAR_LIST:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6690:  case VAR_CLASS:",
          "6691:  case VAR_OBJECT:",
          "",
          "---------------"
        ],
        "src/evalfunc.c||src/evalfunc.c": [
          "File: src/evalfunc.c -> src/evalfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3770:  case VAR_SPECIAL:",
          "3771:      n = argvars[0].vval.v_number != VVAL_TRUE;",
          "3772:      break;",
          "3774:  case VAR_BLOB:",
          "3775:      n = argvars[0].vval.v_blob == NULL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3773:  case VAR_CLASS:",
          "3774:      n = argvars[0].vval.v_class != NULL;",
          "3775:      break;",
          "3776:  case VAR_OBJECT:",
          "3777:      n = argvars[0].vval.v_object != NULL;",
          "3778:      break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7267:  case VAR_JOB:",
          "7268:  case VAR_CHANNEL:",
          "7269:  case VAR_INSTR:",
          "7270:      emsg(_(e_invalid_type_for_len));",
          "7271:      break;",
          "7272:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7276:  case VAR_CLASS:",
          "7277:  case VAR_OBJECT:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "10184:     if (argvars[2].v_type == VAR_FUNC",
          "10185:      || argvars[2].v_type == VAR_PARTIAL",
          "10187:  expr = &argvars[2];",
          "10188:     else",
          "10189:  sub = tv_get_string_buf_chk(&argvars[2], subbuf);",
          "",
          "[Removed Lines]",
          "10186:      || argvars[2].v_type == VAR_INSTR)",
          "",
          "[Added Lines]",
          "10194:      || argvars[2].v_type == VAR_INSTR",
          "10195:      || argvars[2].v_type == VAR_CLASS",
          "10196:      || argvars[2].v_type == VAR_OBJECT)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "10617:  case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;",
          "10618:  case VAR_BLOB:    n = VAR_TYPE_BLOB; break;",
          "10619:  case VAR_INSTR:   n = VAR_TYPE_INSTR; break;",
          "10620:  case VAR_UNKNOWN:",
          "10621:  case VAR_ANY:",
          "10622:  case VAR_VOID:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10630:  case VAR_CLASS:   n = VAR_TYPE_CLASS; break;",
          "10631:  case VAR_OBJECT:  n = VAR_TYPE_OBJECT; break;",
          "",
          "---------------"
        ],
        "src/evalvars.c||src/evalvars.c": [
          "File: src/evalvars.c -> src/evalvars.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2264:  case VAR_JOB:",
          "2265:  case VAR_CHANNEL:",
          "2266:  case VAR_INSTR:",
          "2267:      break;",
          "2269:  case VAR_BLOB:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2267:  case VAR_CLASS:",
          "2268:  case VAR_OBJECT:",
          "",
          "---------------"
        ],
        "src/if_py_both.h||src/if_py_both.h": [
          "File: src/if_py_both.h -> src/if_py_both.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6422:  case VAR_CHANNEL:",
          "6423:  case VAR_JOB:",
          "6424:  case VAR_INSTR:",
          "6425:      Py_INCREF(Py_None);",
          "6426:      return Py_None;",
          "6427:  case VAR_BOOL:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6425:  case VAR_CLASS:",
          "6426:  case VAR_OBJECT:",
          "",
          "---------------"
        ],
        "src/json.c||src/json.c": [
          "File: src/json.c -> src/json.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "308:  case VAR_JOB:",
          "309:  case VAR_CHANNEL:",
          "310:  case VAR_INSTR:",
          "311:      semsg(_(e_cannot_json_encode_str), vartype_name(val->v_type));",
          "312:      return FAIL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "311:  case VAR_CLASS:",
          "312:  case VAR_OBJECT:",
          "",
          "---------------"
        ],
        "src/proto/userfunc.pro||src/proto/userfunc.pro": [
          "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: int get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);",
          "8: char_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, type_T **type, int no_autoload, int new_function, int *found_var);",
          "9: void emsg_funcname(char *ermsg, char_u *name);",
          "10: int get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, evalarg_T *evalarg, funcexe_T *funcexe);",
          "11: char_u *fname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error);",
          "12: void func_name_with_sid(char_u *name, int sid, char_u *buffer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: int get_func_arguments(char_u **arg, evalarg_T *evalarg, int partial_argc, typval_T *argvars, int *argcount);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45: char_u *alloc_printable_func_name(char_u *fname);",
          "46: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
          "47: void list_functions(regmatch_T *regmatch);",
          "49: void ex_function(exarg_T *eap);",
          "50: ufunc_T *find_func_by_name(char_u *name, compiletype_T *compile_type);",
          "51: void ex_defcompile(exarg_T *eap);",
          "",
          "[Removed Lines]",
          "48: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free);",
          "",
          "[Added Lines]",
          "49: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free, class_T *class_arg);",
          "",
          "---------------"
        ],
        "src/proto/vim9class.pro||src/proto/vim9class.pro": [
          "File: src/proto/vim9class.pro -> src/proto/vim9class.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: void ex_class(exarg_T *eap);",
          "3: void ex_interface(exarg_T *eap);",
          "4: void ex_enum(exarg_T *eap);",
          "5: void ex_type(exarg_T *eap);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: type_T *class_member_type(class_T *cl, char_u *name, char_u *name_end, int *member_idx);",
          "7: int class_object_index(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int verbose);",
          "8: void copy_object(typval_T *from, typval_T *to);",
          "9: void object_unref(object_T *obj);",
          "10: void copy_class(typval_T *from, typval_T *to);",
          "11: void class_unref(typval_T *tv);",
          "",
          "---------------"
        ],
        "src/proto/vim9instr.pro||src/proto/vim9instr.pro": [
          "File: src/proto/vim9instr.pro -> src/proto/vim9instr.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: isn_T *generate_instr_drop(cctx_T *cctx, isntype_T isn_type, int drop);",
          "4: isn_T *generate_instr_type(cctx_T *cctx, isntype_T isn_type, type_T *type);",
          "5: isn_T *generate_instr_debug(cctx_T *cctx);",
          "6: int may_generate_2STRING(int offset, int tolerant, cctx_T *cctx);",
          "7: int generate_add_instr(cctx_T *cctx, vartype_T vartype, type_T *type1, type_T *type2, exprtype_T expr_type);",
          "8: vartype_T operator_type(type_T *type1, type_T *type2);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: int generate_CONSTRUCT(cctx_T *cctx, class_T *cl);",
          "",
          "---------------"
        ],
        "src/proto/vim9script.pro||src/proto/vim9script.pro": [
          "File: src/proto/vim9script.pro -> src/proto/vim9script.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: void hide_script_var(scriptitem_T *si, int idx, int func_defined);",
          "20: svar_T *find_typval_in_script(typval_T *dest, scid_T sid, int must_find);",
          "21: int check_script_var_type(svar_T *sv, typval_T *value, char_u *name, where_T where);",
          "",
          "[Removed Lines]",
          "22: int check_reserved_name(char_u *name);",
          "",
          "[Added Lines]",
          "22: int check_reserved_name(char_u *name, cctx_T *cctx);",
          "",
          "---------------"
        ],
        "src/proto/vim9type.pro||src/proto/vim9type.pro": [
          "File: src/proto/vim9type.pro -> src/proto/vim9type.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: type_T *copy_type(type_T *type, garray_T *type_gap);",
          "3: void clear_type_list(garray_T *gap);",
          "4: type_T *alloc_type(type_T *type);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: type_T *get_type_ptr(garray_T *type_gap);",
          "",
          "---------------"
        ],
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1406: typedef struct isn_S isn_T;     // instruction",
          "1407: typedef struct dfunc_S dfunc_T;     // :def function",
          "1409: typedef struct jobvar_S job_T;",
          "1410: typedef struct readq_S readq_T;",
          "1411: typedef struct writeq_S writeq_T;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1409: typedef struct type_S type_T;",
          "1410: typedef struct ufunc_S ufunc_T;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1415: typedef struct cctx_S cctx_T;",
          "1416: typedef struct ectx_S ectx_T;",
          "1417: typedef struct instr_S instr_T;",
          "1419: typedef enum",
          "1420: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1421: typedef struct class_S class_T;",
          "1422: typedef struct object_S object_T;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1434:     VAR_JOB,  // \"v_job\" is used",
          "1435:     VAR_CHANNEL, // \"v_channel\" is used",
          "1436:     VAR_INSTR,  // \"v_instr\" is used",
          "1437: } vartype_T;",
          "1441: struct type_S {",
          "1442:     vartype_T     tt_type;",
          "1443:     int8_T     tt_argcount;    // for func, incl. vararg, -1 for unknown",
          "1444:     int8_T     tt_min_argcount; // number of non-optional arguments",
          "1445:     char_u     tt_flags;     // TTFLAG_ values",
          "1446:     type_T     *tt_member;     // for list, dict, func return type",
          "1447:     type_T     **tt_args;     // func argument types, allocated",
          "1448: };",
          "",
          "[Removed Lines]",
          "1440: typedef struct type_S type_T;",
          "",
          "[Added Lines]",
          "1442:     VAR_CLASS,  // \"v_class\" is used",
          "1443:     VAR_OBJECT,  // \"v_object\" is used",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1452:     type_T *type_decl;     // declared type or equal to type_current",
          "1453: } type2_T;",
          "1455: #define TTFLAG_VARARGS 0x01     // func args ends with \"...\"",
          "1456: #define TTFLAG_BOOL_OK 0x02     // can be converted to bool",
          "1457: #define TTFLAG_STATIC 0x04     // one of the static types, e.g. t_any",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1465: typedef struct {",
          "1466:     char_u *om_name;  // allocated",
          "1467:     type_T *om_type;",
          "1468: } objmember_T;",
          "1471: struct class_S",
          "1472: {",
          "1473:     char_u *class_name;  // allocated",
          "1474:     int  class_refcount;",
          "1476:     int  class_obj_member_count;",
          "1477:     objmember_T *class_obj_members; // allocated",
          "1479:     int  class_obj_method_count;",
          "1480:     ufunc_T **class_obj_methods; // allocated",
          "1481:     ufunc_T *class_new_func; // new() function that was created",
          "1483:     garray_T class_type_list; // used for type pointers",
          "1484:     type_T class_type;",
          "1485: };",
          "1489: struct object_S {",
          "1490:     class_T *obj_class;  // class this object is created for",
          "1491:     int  obj_refcount;",
          "1492: };",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1467:     union",
          "1468:     {",
          "1469:  varnumber_T v_number; // number value",
          "1474:  partial_T *v_partial; // closure: function with args",
          "1475: #ifdef FEAT_JOB_CHANNEL",
          "1478: #endif",
          "1480:  instr_T  *v_instr; // instructions to execute",
          "1481:     }  vval;",
          "1482: } typval_T;",
          "",
          "[Removed Lines]",
          "1470:  float_T  v_float; // floating number value",
          "1471:  char_u  *v_string; // string value (can be NULL!)",
          "1472:  list_T  *v_list; // list value (can be NULL!)",
          "1473:  dict_T  *v_dict; // dict value (can be NULL!)",
          "1476:  job_T  *v_job;  // job value (can be NULL!)",
          "1477:  channel_T *v_channel; // channel value (can be NULL!)",
          "1479:  blob_T  *v_blob; // blob value (can be NULL!)",
          "",
          "[Added Lines]",
          "1509:  float_T  v_float; // floating point number value",
          "1510:  char_u  *v_string; // string value (can be NULL)",
          "1511:  list_T  *v_list; // list value (can be NULL)",
          "1512:  dict_T  *v_dict; // dict value (can be NULL)",
          "1515:  job_T  *v_job;  // job value (can be NULL)",
          "1516:  channel_T *v_channel; // channel value (can be NULL)",
          "1518:  blob_T  *v_blob; // blob value (can be NULL)",
          "1520:  class_T  *v_class; // class value (can be NULL)",
          "1521:  object_T *v_object; // object value (can be NULL)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1667: {",
          "1668:     int  uf_varargs; // variable nr of arguments (old style)",
          "1669:     int  uf_flags; // FC_ flags",
          "",
          "[Removed Lines]",
          "1666: typedef struct",
          "",
          "[Added Lines]",
          "1707: struct ufunc_S",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1671:     int  uf_cleared; // func_clear() was already called",
          "1672:     def_status_T uf_def_status; // UF_NOT_COMPILED, UF_TO_BE_COMPILED, etc.",
          "1673:     int  uf_dfunc_idx; // only valid if uf_def_status is UF_COMPILED",
          "1674:     garray_T uf_args; // arguments, including optional arguments",
          "1675:     garray_T uf_def_args; // default argument expressions",
          "1676:     int  uf_args_visible; // normally uf_args.ga_len, less when",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1716:     class_T *uf_class; // for object method and constructor",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1731:     char_u uf_name[4]; // name of function (actual size equals name);",
          "1737: #define FC_ABORT    0x01 // abort function on error",
          "",
          "[Removed Lines]",
          "1734: } ufunc_T;",
          "",
          "[Added Lines]",
          "1778: };",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1751: #define FC_LAMBDA   0x2000 // one line \"return {expr}\"",
          "1753: #define MAX_FUNC_ARGS 20 // maximum number of function arguments",
          "1754: #define VAR_SHORT_LEN 20 // short variable name length",
          "1755: #define FIXVAR_CNT 12 // number of fixed variables",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1797: #define FC_OBJECT   010000 // object method",
          "1798: #define FC_NEW     030000 // constructor (also an object method)",
          "",
          "---------------"
        ],
        "src/testdir/Make_all.mak||src/testdir/Make_all.mak": [
          "File: src/testdir/Make_all.mak -> src/testdir/Make_all.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: TEST_VIM9 = \\",
          "38:  test_vim9_assign \\",
          "39:  test_vim9_builtin \\",
          "40:  test_vim9_cmd \\",
          "41:  test_vim9_disassemble \\",
          "42:  test_vim9_expr \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:  test_vim9_class \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: TEST_VIM9_RES = \\",
          "49:  test_vim9_assign.res \\",
          "50:  test_vim9_builtin.res \\",
          "51:  test_vim9_cmd.res \\",
          "52:  test_vim9_disassemble.res \\",
          "53:  test_vim9_expr.res \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:  test_vim9_class.res \\",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_class.vim||src/testdir/test_vim9_class.vim": [
          "File: src/testdir/test_vim9_class.vim -> src/testdir/test_vim9_class.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \" Test Vim9 classes",
          "3: source check.vim",
          "4: import './vim9.vim' as v9",
          "6: def Test_class_basic()",
          "7:   var lines =<< trim END",
          "8:       class NotWorking",
          "9:       endclass",
          "10:   END",
          "11:   v9.CheckScriptFailure(lines, 'E1316:')",
          "13:   lines =<< trim END",
          "14:       vim9script",
          "15:       class notWorking",
          "16:       endclass",
          "17:   END",
          "18:   v9.CheckScriptFailure(lines, 'E1314:')",
          "20:   lines =<< trim END",
          "21:       vim9script",
          "22:       class Not@working",
          "23:       endclass",
          "24:   END",
          "25:   v9.CheckScriptFailure(lines, 'E1315:')",
          "27:   lines =<< trim END",
          "28:       vim9script",
          "29:       abstract noclass Something",
          "30:       endclass",
          "31:   END",
          "32:   v9.CheckScriptFailure(lines, 'E475:')",
          "34:   lines =<< trim END",
          "35:       vim9script",
          "36:       abstract classy Something",
          "37:       endclass",
          "38:   END",
          "39:   v9.CheckScriptFailure(lines, 'E475:')",
          "41:   lines =<< trim END",
          "42:       vim9script",
          "43:       class Something",
          "44:       endcl",
          "45:   END",
          "46:   v9.CheckScriptFailure(lines, 'E1065:')",
          "48:   lines =<< trim END",
          "49:       vim9script",
          "50:       class Something",
          "51:       endclass school's out",
          "52:   END",
          "53:   v9.CheckScriptFailure(lines, 'E488:')",
          "55:   lines =<< trim END",
          "56:       vim9script",
          "57:       class Something",
          "58:       endclass | echo 'done'",
          "59:   END",
          "60:   v9.CheckScriptFailure(lines, 'E488:')",
          "62:   lines =<< trim END",
          "63:       vim9script",
          "64:       class Something",
          "65:         this",
          "66:       endclass",
          "67:   END",
          "68:   v9.CheckScriptFailure(lines, 'E1317:')",
          "70:   lines =<< trim END",
          "71:       vim9script",
          "72:       class Something",
          "73:         this.",
          "74:       endclass",
          "75:   END",
          "76:   v9.CheckScriptFailure(lines, 'E1317:')",
          "78:   lines =<< trim END",
          "79:       vim9script",
          "80:       class Something",
          "81:         this .count",
          "82:       endclass",
          "83:   END",
          "84:   v9.CheckScriptFailure(lines, 'E1317:')",
          "86:   lines =<< trim END",
          "87:       vim9script",
          "88:       class Something",
          "89:         this. count",
          "90:       endclass",
          "91:   END",
          "92:   v9.CheckScriptFailure(lines, 'E1317:')",
          "94:   lines =<< trim END",
          "95:       vim9script",
          "96:       class Something",
          "97:         this.count: number",
          "98:         that.count",
          "99:       endclass",
          "100:   END",
          "101:   v9.CheckScriptFailure(lines, 'E1318: Not a valid command in a class: that.count')",
          "103:   lines =<< trim END",
          "104:       vim9script",
          "105:       class Something",
          "106:         this.count",
          "107:       endclass",
          "108:   END",
          "109:   v9.CheckScriptFailure(lines, 'E1022:')",
          "111:   lines =<< trim END",
          "112:       vim9script",
          "113:       class Something",
          "114:         this.count : number",
          "115:       endclass",
          "116:   END",
          "117:   v9.CheckScriptFailure(lines, 'E1059:')",
          "119:   lines =<< trim END",
          "120:       vim9script",
          "121:       class Something",
          "122:         this.count:number",
          "123:       endclass",
          "124:   END",
          "125:   v9.CheckScriptFailure(lines, 'E1069:')",
          "127:   lines =<< trim END",
          "128:       vim9script",
          "130:       class TextPosition",
          "131:         this.lnum: number",
          "132:  this.col: number",
          "133:       endclass",
          "135:       # # FIXME: this works but leaks memory",
          "136:       # # use the automatically generated new() method",
          "137:       # var pos = TextPosition.new(2, 12)",
          "138:       # assert_equal(2, pos.lnum)",
          "139:       # assert_equal(12, pos.col)",
          "140:   END",
          "141:   v9.CheckScriptSuccess(lines)",
          "142: enddef",
          "145: \" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker",
          "",
          "---------------"
        ],
        "src/testing.c||src/testing.c": [
          "File: src/testing.c -> src/testing.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1101:  case VAR_SPECIAL:",
          "1102:  case VAR_STRING:",
          "1103:  case VAR_INSTR:",
          "1104:      break;",
          "1105:  case VAR_JOB:",
          "1106: #ifdef FEAT_JOB_CHANNEL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1104:  case VAR_CLASS:",
          "1105:  case VAR_OBJECT:",
          "",
          "---------------"
        ],
        "src/typval.c||src/typval.c": [
          "File: src/typval.c -> src/typval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "84:   channel_unref(varp->vval.v_channel);",
          "85:   break;",
          "86: #endif",
          "87:      case VAR_NUMBER:",
          "88:      case VAR_FLOAT:",
          "89:      case VAR_ANY:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:      case VAR_CLASS:",
          "88:   class_unref(varp);",
          "89:   break;",
          "90:      case VAR_OBJECT:",
          "91:   object_unref(varp->vval.v_object);",
          "92:   break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:      case VAR_INSTR:",
          "154:   VIM_CLEAR(varp->vval.v_instr);",
          "155:   break;",
          "156:      case VAR_UNKNOWN:",
          "157:      case VAR_ANY:",
          "158:      case VAR_VOID:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:      case VAR_CLASS:",
          "164:   class_unref(varp);",
          "165:   break;",
          "166:      case VAR_OBJECT:",
          "167:   object_unref(varp->vval.v_object);",
          "168:   break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "234:  case VAR_BLOB:",
          "235:      emsg(_(e_using_blob_as_number));",
          "236:      break;",
          "237:  case VAR_VOID:",
          "238:      emsg(_(e_cannot_use_void_value));",
          "239:      break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "250:  case VAR_CLASS:",
          "251:      emsg(_(e_using_class_as_number));",
          "252:      break;",
          "253:  case VAR_OBJECT:",
          "254:      emsg(_(e_using_object_as_number));",
          "255:      break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "333:  case VAR_BLOB:",
          "334:      emsg(_(e_using_blob_as_float));",
          "335:      break;",
          "336:  case VAR_VOID:",
          "337:      emsg(_(e_cannot_use_void_value));",
          "338:      break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:  case VAR_CLASS:",
          "356:      emsg(_(e_using_class_as_float));",
          "357:      break;",
          "358:  case VAR_OBJECT:",
          "359:      emsg(_(e_using_object_as_float));",
          "360:      break;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1029:  case VAR_BLOB:",
          "1030:      emsg(_(e_using_blob_as_string));",
          "1031:      break;",
          "1032:  case VAR_JOB:",
          "1033: #ifdef FEAT_JOB_CHANNEL",
          "1034:      if (in_vim9script())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1057:  case VAR_CLASS:",
          "1058:      emsg(_(e_using_class_as_string));",
          "1059:      break;",
          "1060:  case VAR_OBJECT:",
          "1061:      emsg(_(e_using_object_as_string));",
          "1062:      break;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1158:      to->vval.v_instr = from->vval.v_instr;",
          "1159:      break;",
          "1161:  case VAR_STRING:",
          "1162:  case VAR_FUNC:",
          "1163:      if (from->vval.v_string == NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1192:  case VAR_CLASS:",
          "1193:      copy_class(from, to);",
          "1194:      break;",
          "1196:  case VAR_OBJECT:",
          "1197:      copy_object(from, to);",
          "1198:      break;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1878:  case VAR_INSTR:",
          "1879:      return tv1->vval.v_instr == tv2->vval.v_instr;",
          "1881:  case VAR_PARTIAL:",
          "1882:      return tv1->vval.v_partial == tv2->vval.v_partial;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1920:  case VAR_CLASS:",
          "1921:      return tv1->vval.v_class == tv2->vval.v_class;",
          "1923:  case VAR_OBJECT:",
          "1925:      return tv1->vval.v_object == tv2->vval.v_object;",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "214:     garray_T *default_args,",
          "215:     int  skip,",
          "216:     exarg_T *eap,  // can be NULL",
          "217:     garray_T *lines_to_free)",
          "218: {",
          "219:     int  mustend = FALSE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217:     class_T *class_arg,",
          "218:     garray_T *newlines, // function body lines",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "292:   }",
          "293:      }",
          "294:  }",
          "295:  else",
          "296:  {",
          "297:      char_u *np;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "297:  else if (class_arg != NULL && STRNCMP(p, \"this.\", 5) == 0)",
          "298:  {",
          "300:      p += 5;",
          "301:      arg = p;",
          "302:      while (ASCII_ISALNUM(*p) || *p == '_')",
          "303:   ++p;",
          "306:      if (newargs != NULL && ga_grow(newargs, 1) == FAIL)",
          "307:   return FAIL;",
          "308:      if (newargs != NULL)",
          "309:      {",
          "310:   ((char_u **)(newargs->ga_data))[newargs->ga_len] =",
          "311:           vim_strnsave(arg, p - arg);",
          "312:   newargs->ga_len++;",
          "314:   if (argtypes != NULL && ga_grow(argtypes, 1) == OK)",
          "315:   {",
          "317:       ((char_u **)argtypes->ga_data)[argtypes->ga_len++] =",
          "318:         vim_strsave((char_u *)\"any\");",
          "321:       if (ga_grow(newlines, 1) == OK)",
          "322:       {",
          "324:    int len = 5 + (p - arg) + 3 + (p - arg) + 1;",
          "325:    char_u *assignment = alloc(len);",
          "326:    if (assignment != NULL)",
          "327:    {",
          "328:        c = *p;",
          "330:        vim_snprintf((char *)assignment, len,",
          "331:            \"this.%s = %s\", arg, arg);",
          "333:        ((char_u **)(newlines->ga_data))[",
          "334:            newlines->ga_len++] = assignment;",
          "335:    }",
          "336:       }",
          "337:   }",
          "338:      }",
          "339:      if (*p == ',')",
          "340:   ++p;",
          "341:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1389:     s = *arg + 1;",
          "1390:     ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,",
          "1391:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "1393:     if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)",
          "1394:     {",
          "1395:  if (types_optional)",
          "",
          "[Removed Lines]",
          "1392:      NULL, &default_args, TRUE, NULL, NULL);",
          "",
          "[Added Lines]",
          "1439:        NULL, &default_args, TRUE, NULL, NULL, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1406:     ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,",
          "1407:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "1408:          &varargs, &default_args,",
          "1410:     if (ret == FAIL",
          "1411:     || (s = skip_arrow(*arg, equal_arrow, &ret_type,",
          "1412:   equal_arrow || vim9script ? &white_error : NULL)) == NULL)",
          "",
          "[Removed Lines]",
          "1409:          FALSE, NULL, NULL);",
          "",
          "[Added Lines]",
          "1456:          FALSE, NULL, NULL, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1737: get_func_arguments(",
          "1738:  char_u     **arg,",
          "1739:  evalarg_T   *evalarg,",
          "",
          "[Removed Lines]",
          "1736:     static int",
          "",
          "[Added Lines]",
          "1783:     int",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1809:     funcexe_T *funcexe) // various values",
          "1810: {",
          "1811:     char_u *argp;",
          "1813:     typval_T argvars[MAX_FUNC_ARGS + 1]; // vars for arguments",
          "1814:     int  argcount = 0;   // number of arguments found",
          "1815:     int  vim9script = in_vim9script();",
          "",
          "[Removed Lines]",
          "1812:     int  ret = OK;",
          "",
          "[Added Lines]",
          "1859:     int  ret;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4375:     ufunc_T *",
          "4377: {",
          "4378:     int  j;",
          "4379:     int  c;",
          "",
          "[Removed Lines]",
          "4376: define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)",
          "",
          "[Added Lines]",
          "4424: define_function(",
          "4425:  exarg_T     *eap,",
          "4426:  char_u     *name_arg,",
          "4427:  garray_T    *lines_to_free,",
          "4428:  class_T     *class_arg)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4488:      p = eap->arg;",
          "4489:  }",
          "4493:  paren = (vim_strchr(p, '(') != NULL);",
          "4494:  if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)",
          "4495:  {",
          "",
          "[Removed Lines]",
          "4491:  name = save_function_name(&p, &is_global, eap->skip,",
          "4492:      TFN_NO_AUTOLOAD | TFN_NEW_FUNC, &fudi);",
          "",
          "[Added Lines]",
          "4543:  int tfn_flags = TFN_NO_AUTOLOAD | TFN_NEW_FUNC",
          "4544:            | (class_arg == 0 ? 0 : TFN_INT);",
          "4545:  name = save_function_name(&p, &is_global, eap->skip, tfn_flags, &fudi);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4690:     if (get_function_args(&p, ')', &newargs,",
          "4691:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
          "4692:     NULL, &varargs, &default_args, eap->skip,",
          "4694:  goto errret_2;",
          "4695:     whitep = p;",
          "",
          "[Removed Lines]",
          "4693:     eap, lines_to_free) == FAIL)",
          "",
          "[Added Lines]",
          "4746:     eap, class_arg, &newlines, lines_to_free) == FAIL)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "5145:     garray_T lines_to_free;",
          "5147:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "5149:     ga_clear_strings(&lines_to_free);",
          "5150: }",
          "",
          "[Removed Lines]",
          "5148:     (void)define_function(eap, NULL, &lines_to_free);",
          "",
          "[Added Lines]",
          "5201:     (void)define_function(eap, NULL, &lines_to_free, NULL);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696: static int included_patches[] =",
          "699:     1030,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:     1031,",
          "",
          "---------------"
        ],
        "src/vim.h||src/vim.h": [
          "File: src/vim.h -> src/vim.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2120: #define VAR_TYPE_CHANNEL    9",
          "2121: #define VAR_TYPE_BLOB     10",
          "2122: #define VAR_TYPE_INSTR     11",
          "2124: #define DICT_MAXNEST 100 // maximum nesting of lists and dicts",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2123: #define VAR_TYPE_CLASS     12",
          "2124: #define VAR_TYPE_OBJECT     13",
          "",
          "---------------"
        ],
        "src/vim9.h||src/vim9.h": [
          "File: src/vim9.h -> src/vim9.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:     ISN_SOURCE,     // source autoload script, isn_arg.number is the script ID",
          "34:     ISN_INSTR,     // instructions compiled from expression",
          "37:     ISN_LOAD,     // push local variable isn_arg.number",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35:     ISN_CONSTRUCT,  // construct an object, using contstruct_T",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110:     ISN_PCALL_END,  // cleanup after ISN_PCALL with cpf_top set",
          "111:     ISN_RETURN,     // return, result is on top of stack",
          "112:     ISN_RETURN_VOID, // Push void, then return",
          "113:     ISN_FUNCREF,    // push a function ref to dfunc isn_arg.funcref",
          "114:     ISN_NEWFUNC,    // create a global function from a lambda function",
          "115:     ISN_DEF,     // list functions",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:     ISN_RETURN_OBJECT, // Push constructed object, then return",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "463:     long ewin_time;     // time argument (msec)",
          "464: } echowin_T;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "469: typedef struct {",
          "470:     int  construct_size;     // size of object in bytes",
          "471:     class_T *construct_class;   // class the object is created from",
          "472: } construct_T;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "514:  debug_T      debug;",
          "515:  deferins_T     defer;",
          "516:  echowin_T     echowin;",
          "517:     } isn_arg;",
          "518: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "525:  construct_T     construct;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "758:     int      lhs_has_type;   // type was specified",
          "759:     type_T     *lhs_type;",
          "762:     int      lhs_append;     // used by ISN_REDIREND",
          "763: } lhs_T;",
          "",
          "[Removed Lines]",
          "760:     type_T     *lhs_member_type;",
          "",
          "[Added Lines]",
          "769:     int      lhs_member_idx;    // object member index",
          "770:     type_T     *lhs_member_type;  // list/dict/object member type",
          "",
          "---------------"
        ],
        "src/vim9class.c||src/vim9class.c": [
          "File: src/vim9class.c -> src/vim9class.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     void",
          "28: ex_class(exarg_T *eap)",
          "29: {",
          "32:     char_u *arg = eap->arg;",
          "33:     if (is_abstract)",
          "34:     {",
          "35:  if (STRNCMP(arg, \"class\", 5) != 0 || !VIM_ISWHITE(arg[5]))",
          "",
          "[Removed Lines]",
          "30:     int is_abstract = eap->cmdidx == CMD_abstract;",
          "",
          "[Added Lines]",
          "30:     if (!current_script_is_vim9()",
          "31:   || (cmdmod.cmod_flags & CMOD_LEGACY)",
          "32:   || !getline_equal(eap->getline, eap->cookie, getsourceline))",
          "33:     {",
          "34:  emsg(_(e_class_can_only_be_defined_in_vim9_script));",
          "35:  return;",
          "36:     }",
          "39:     int is_abstract = eap->cmdidx == CMD_abstract;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:  semsg(_(e_class_name_must_start_with_uppercase_letter_str), arg);",
          "46:  return;",
          "47:     }",
          "80: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55:     char_u *name_end = find_name_end(arg, NULL, NULL, FNE_CHECK_START);",
          "56:     if (!IS_WHITE_OR_NUL(*name_end))",
          "57:     {",
          "58:  semsg(_(e_white_space_required_after_class_name_str), arg);",
          "59:  return;",
          "60:     }",
          "71:     garray_T type_list;     // list of pointers to allocated types",
          "72:     ga_init2(&type_list, sizeof(type_T *), 10);",
          "75:     garray_T objmembers;",
          "76:     ga_init2(&objmembers, sizeof(objmember_T), 10);",
          "79:     garray_T objmethods;",
          "80:     ga_init2(&objmethods, sizeof(ufunc_T), 10);",
          "85:     char_u *theline = NULL;",
          "86:     int success = FALSE;",
          "87:     for (;;)",
          "88:     {",
          "89:  vim_free(theline);",
          "90:  theline = eap->getline(':', eap->cookie, 0, GETLINE_CONCAT_ALL);",
          "91:  if (theline == NULL)",
          "92:      break;",
          "93:  char_u *line = skipwhite(theline);",
          "117:  char_u *p = line;",
          "118:  if (checkforcmd(&p, \"endclass\", 4))",
          "119:  {",
          "120:      if (STRNCMP(line, \"endclass\", 8) != 0)",
          "121:   semsg(_(e_command_cannot_be_shortened_str), line);",
          "122:      else if (*p == '|' || !ends_excmd2(line, p))",
          "123:   semsg(_(e_trailing_characters_str), p);",
          "125:      success = TRUE;",
          "126:      break;",
          "127:  }",
          "133:  if (STRNCMP(line, \"this\", 4) == 0)",
          "134:  {",
          "135:      if (line[4] != '.' || !eval_isnamec1(line[5]))",
          "136:      {",
          "137:   semsg(_(e_invalid_object_member_declaration_str), line);",
          "138:   break;",
          "139:      }",
          "140:      char_u *varname = line + 5;",
          "141:      char_u *varname_end = to_name_end(varname, FALSE);",
          "143:      char_u *colon = skipwhite(varname_end);",
          "145:      if (*colon != ':')",
          "146:      {",
          "147:   emsg(_(e_type_or_initialization_required));",
          "148:   break;",
          "149:      }",
          "150:      if (VIM_ISWHITE(*varname_end))",
          "151:      {",
          "152:   semsg(_(e_no_white_space_allowed_before_colon_str), varname);",
          "153:   break;",
          "154:      }",
          "155:      if (!VIM_ISWHITE(colon[1]))",
          "156:      {",
          "157:   semsg(_(e_white_space_required_after_str_str), \":\", varname);",
          "158:   break;",
          "159:      }",
          "161:      char_u *type_arg = skipwhite(colon + 1);",
          "162:      type_T *type = parse_type(&type_arg, &type_list, TRUE);",
          "163:      if (type == NULL)",
          "164:   break;",
          "166:      if (ga_grow(&objmembers, 1) == FAIL)",
          "167:   break;",
          "168:      objmember_T *m = ((objmember_T *)objmembers.ga_data)",
          "169:          + objmembers.ga_len;",
          "170:      m->om_name = vim_strnsave(varname, varname_end - varname);",
          "171:      m->om_type = type;",
          "172:      ++objmembers.ga_len;",
          "173:  }",
          "175:  else",
          "176:  {",
          "177:      semsg(_(e_not_valid_command_in_class_str), line);",
          "178:      break;",
          "179:  }",
          "180:     }",
          "181:     vim_free(theline);",
          "183:     if (success)",
          "184:     {",
          "185:  class_T *cl = ALLOC_CLEAR_ONE(class_T);",
          "186:  if (cl == NULL)",
          "187:      goto cleanup;",
          "188:  cl->class_refcount = 1;",
          "189:  cl->class_name = vim_strnsave(arg, name_end - arg);",
          "192:  cl->class_obj_member_count = objmembers.ga_len;",
          "193:  cl->class_obj_members = ALLOC_MULT(objmember_T, objmembers.ga_len);",
          "194:  if (cl->class_name == NULL",
          "195:   || cl->class_obj_members == NULL)",
          "196:  {",
          "197:      vim_free(cl->class_name);",
          "198:      vim_free(cl->class_obj_members);",
          "199:      vim_free(cl);",
          "200:      goto cleanup;",
          "201:  }",
          "202:  mch_memmove(cl->class_obj_members, objmembers.ga_data,",
          "203:           sizeof(objmember_T) * objmembers.ga_len);",
          "204:  vim_free(objmembers.ga_data);",
          "206:  int have_new = FALSE;",
          "207:  for (int i = 0; i < objmethods.ga_len; ++i)",
          "208:      if (STRCMP((((ufunc_T *)objmethods.ga_data) + i)->uf_name,",
          "209:            \"new\") == 0)",
          "210:      {",
          "211:   have_new = TRUE;",
          "212:   break;",
          "213:      }",
          "214:  if (!have_new)",
          "215:  {",
          "217:      garray_T fga;",
          "218:      ga_init2(&fga, 1, 1000);",
          "219:      ga_concat(&fga, (char_u *)\"new(\");",
          "220:      for (int i = 0; i < cl->class_obj_member_count; ++i)",
          "221:      {",
          "222:   if (i > 0)",
          "223:       ga_concat(&fga, (char_u *)\", \");",
          "224:   ga_concat(&fga, (char_u *)\"this.\");",
          "225:   objmember_T *m = cl->class_obj_members + i;",
          "226:   ga_concat(&fga, (char_u *)m->om_name);",
          "227:      }",
          "228:      ga_concat(&fga, (char_u *)\")\\nenddef\\n\");",
          "229:      ga_append(&fga, NUL);",
          "231:      exarg_T fea;",
          "232:      CLEAR_FIELD(fea);",
          "233:      fea.cmdidx = CMD_def;",
          "234:      fea.cmd = fea.arg = fga.ga_data;",
          "236:      garray_T lines_to_free;",
          "237:      ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "239:      ufunc_T *nf = define_function(&fea, NULL, &lines_to_free, cl);",
          "241:      ga_clear_strings(&lines_to_free);",
          "242:      vim_free(fga.ga_data);",
          "244:      if (nf != NULL && ga_grow(&objmethods, 1) == OK)",
          "245:      {",
          "246:   ((ufunc_T **)objmethods.ga_data)[objmethods.ga_len] = nf;",
          "247:   ++objmethods.ga_len;",
          "249:   nf->uf_flags |= FC_NEW;",
          "250:   nf->uf_class = cl;",
          "251:   nf->uf_ret_type = get_type_ptr(&type_list);",
          "252:   if (nf->uf_ret_type != NULL)",
          "253:   {",
          "254:       nf->uf_ret_type->tt_type = VAR_OBJECT;",
          "255:       nf->uf_ret_type->tt_member = (type_T *)cl;",
          "256:       nf->uf_ret_type->tt_argcount = 0;",
          "257:       nf->uf_ret_type->tt_args = NULL;",
          "258:   }",
          "259:   cl->class_new_func = nf;",
          "260:      }",
          "261:  }",
          "263:  cl->class_obj_method_count = objmethods.ga_len;",
          "264:  cl->class_obj_methods = ALLOC_MULT(ufunc_T *, objmethods.ga_len);",
          "265:  if (cl->class_obj_methods == NULL)",
          "266:  {",
          "267:      vim_free(cl->class_name);",
          "268:      vim_free(cl->class_obj_members);",
          "269:      vim_free(cl->class_obj_methods);",
          "270:      vim_free(cl);",
          "271:      goto cleanup;",
          "272:  }",
          "273:  mch_memmove(cl->class_obj_methods, objmethods.ga_data,",
          "274:      sizeof(ufunc_T *) * objmethods.ga_len);",
          "275:  vim_free(objmethods.ga_data);",
          "277:  cl->class_type.tt_type = VAR_CLASS;",
          "278:  cl->class_type.tt_member = (type_T *)cl;",
          "279:  cl->class_type_list = type_list;",
          "291:  typval_T tv;",
          "292:  tv.v_type = VAR_CLASS;",
          "293:  tv.vval.v_class = cl;",
          "294:  set_var_const(cl->class_name, current_sctx.sc_sid,",
          "295:           NULL, &tv, FALSE, ASSIGN_DECL, 0);",
          "296:  return;",
          "297:     }",
          "299: cleanup:",
          "300:     for (int i = 0; i < objmembers.ga_len; ++i)",
          "301:     {",
          "302:  objmember_T *m = ((objmember_T *)objmembers.ga_data) + i;",
          "303:  vim_free(m->om_name);",
          "304:     }",
          "305:     ga_clear(&objmembers);",
          "307:     ga_clear(&objmethods);",
          "308:     clear_type_list(&type_list);",
          "309: }",
          "315:     type_T *",
          "316: class_member_type(",
          "317:  class_T *cl,",
          "318:  char_u *name,",
          "319:  char_u *name_end,",
          "320:  int *member_idx)",
          "321: {",
          "323:     size_t len = name_end - name;",
          "325:     for (int i = 0; i < cl->class_obj_member_count; ++i)",
          "326:     {",
          "327:  objmember_T *m = cl->class_obj_members + i;",
          "328:  if (STRNCMP(m->om_name, name, len) == 0 && m->om_name[len] == NUL)",
          "329:  {",
          "331:      return m->om_type;",
          "332:  }",
          "333:     }",
          "334:     return &t_any;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107: }",
          "110: #endif // FEAT_EVAL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "377:     int",
          "378: class_object_index(",
          "379:     char_u **arg,",
          "380:     typval_T *rettv,",
          "381:     evalarg_T *evalarg,",
          "382:     int  verbose UNUSED) // give error messages",
          "383: {",
          "387:     if (VIM_ISWHITE((*arg)[1]))",
          "388:     {",
          "389:  semsg(_(e_no_white_space_allowed_after_str_str), \".\", *arg);",
          "390:  return FAIL;",
          "391:     }",
          "393:     ++*arg;",
          "394:     char_u *name = *arg;",
          "395:     char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);",
          "396:     if (name_end == name)",
          "397:  return FAIL;",
          "398:     size_t len = name_end - name;",
          "400:     class_T *cl = rettv->v_type == VAR_CLASS ? rettv->vval.v_class",
          "401:           : rettv->vval.v_object->obj_class;",
          "402:     if (*name_end == '(')",
          "403:     {",
          "404:  for (int i = 0; i < cl->class_obj_method_count; ++i)",
          "405:  {",
          "406:      ufunc_T *fp = cl->class_obj_methods[i];",
          "407:      if (STRNCMP(name, fp->uf_name, len) == 0 && fp->uf_name[len] == NUL)",
          "408:      {",
          "409:   typval_T    argvars[MAX_FUNC_ARGS + 1];",
          "410:   int     argcount = 0;",
          "412:   char_u *argp = name_end;",
          "413:   int ret = get_func_arguments(&argp, evalarg, 0,",
          "414:           argvars, &argcount);",
          "415:   if (ret == FAIL)",
          "416:       return FAIL;",
          "418:   funcexe_T   funcexe;",
          "419:   CLEAR_FIELD(funcexe);",
          "420:   funcexe.fe_evaluate = TRUE;",
          "424:   rettv->v_type = VAR_UNKNOWN;",
          "425:   int error = call_user_func_check(fp, argcount, argvars,",
          "426:        rettv, &funcexe, NULL);",
          "429:   for (int idx = 0; idx < argcount; ++idx)",
          "430:       clear_tv(&argvars[idx]);",
          "432:   if (error != FCERR_NONE)",
          "433:   {",
          "434:       user_func_error(error, printable_func_name(fp),",
          "435:         funcexe.fe_found_var);",
          "436:       return FAIL;",
          "437:   }",
          "439:   return OK;",
          "440:      }",
          "441:  }",
          "443:  semsg(_(e_method_not_found_on_class_str_str), cl->class_name, name);",
          "444:     }",
          "446:     else if (rettv->v_type == VAR_OBJECT)",
          "447:     {",
          "448:  for (int i = 0; i < cl->class_obj_member_count; ++i)",
          "449:  {",
          "450:      objmember_T *m = &cl->class_obj_members[i];",
          "451:      if (STRNCMP(name, m->om_name, len) == 0 && m->om_name[len] == NUL)",
          "452:      {",
          "455:   object_T *obj = rettv->vval.v_object;",
          "456:   typval_T *tv = (typval_T *)(obj + 1) + i;",
          "457:   copy_tv(tv, rettv);",
          "458:   object_unref(obj);",
          "461:   return OK;",
          "462:      }",
          "463:  }",
          "465:  semsg(_(e_member_not_found_on_object_str_str), cl->class_name, name);",
          "466:     }",
          "470:     return FAIL;",
          "471: }",
          "476:     void",
          "477: copy_object(typval_T *from, typval_T *to)",
          "478: {",
          "480:     if (to->vval.v_object != NULL)",
          "481:  ++to->vval.v_object->obj_refcount;",
          "482: }",
          "487:     static void",
          "488: object_clear(object_T *obj)",
          "489: {",
          "490:     class_T *cl = obj->obj_class;",
          "493:     typval_T *tv = (typval_T *)(obj + 1);",
          "494:     for (int i = 0; i < cl->class_obj_member_count; ++i)",
          "495:  clear_tv(tv + i);",
          "497:     vim_free(obj);",
          "498: }",
          "503:     void",
          "504: object_unref(object_T *obj)",
          "505: {",
          "506:     if (obj != NULL && --obj->obj_refcount <= 0)",
          "507:  object_clear(obj);",
          "508: }",
          "513:     void",
          "514: copy_class(typval_T *from, typval_T *to)",
          "515: {",
          "517:     if (to->vval.v_class != NULL)",
          "518:  ++to->vval.v_class->class_refcount;",
          "519: }",
          "524:     void",
          "525: class_unref(typval_T *tv)",
          "526: {",
          "527:     class_T *cl = tv->vval.v_class;",
          "528:     if (cl != NULL && --cl->class_refcount <= 0)",
          "529:     {",
          "530:  vim_free(cl->class_name);",
          "532:  for (int i = 0; i < cl->class_obj_member_count; ++i)",
          "533:  {",
          "534:      objmember_T *m = &cl->class_obj_members[i];",
          "535:      vim_free(m->om_name);",
          "536:  }",
          "537:  vim_free(cl->class_obj_members);",
          "539:  vim_free(cl->class_obj_methods);",
          "541:  if (cl->class_new_func != NULL)",
          "542:      func_ptr_unref(cl->class_new_func);",
          "544:  clear_type_list(&cl->class_type_list);",
          "546:  vim_free(cl);",
          "547:     }",
          "548: }",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     if (len == 0)",
          "44:  return FAIL;",
          "47:     for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)",
          "48:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:     if (len == 4 && STRNCMP(name, \"this\", 4) == 0",
          "47:      && cctx->ctx_ufunc != NULL",
          "48:      && (cctx->ctx_ufunc->uf_flags & FC_OBJECT))",
          "49:     {",
          "50:  if (lvar != NULL)",
          "51:  {",
          "52:      CLEAR_POINTER(lvar);",
          "53:      lvar->lv_name = (char_u *)\"this\";",
          "54:      if (cctx->ctx_ufunc->uf_class != NULL)",
          "55:   lvar->lv_type = &cctx->ctx_ufunc->uf_class->class_type;",
          "56:  }",
          "57:  return OK;",
          "58:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "296: {",
          "297:     return (cctx != NULL",
          "298:   && (lookup_local(name, len, NULL, cctx) == OK",
          "300:      || script_var_exists(name, len, cctx, NULL) == OK",
          "301:      || find_imported(name, len, FALSE) != NULL;",
          "302: }",
          "",
          "[Removed Lines]",
          "299:       || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))",
          "",
          "[Added Lines]",
          "313:       || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK",
          "314:       || (len == 4",
          "315:    && cctx->ctx_ufunc != NULL",
          "316:    && (cctx->ctx_ufunc->uf_flags & FC_OBJECT)",
          "317:    && STRNCMP(name, \"this\", 4) == 0)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "957:  goto theend;",
          "958:     }",
          "961:     if (ufunc == NULL)",
          "962:     {",
          "963:  r = eap->skip ? OK : FAIL;",
          "",
          "[Removed Lines]",
          "960:     ufunc = define_function(eap, lambda_name, lines_to_free);",
          "",
          "[Added Lines]",
          "978:     ufunc = define_function(eap, lambda_name, lines_to_free, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1450:     lhs->lhs_dest = dest_local;",
          "1451:     lhs->lhs_vimvaridx = -1;",
          "1452:     lhs->lhs_scriptvar_idx = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1471:     lhs->lhs_member_idx = -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1509:  else",
          "1510:  {",
          "1513:   return FAIL;",
          "1515:      if (lookup_local(var_start, lhs->lhs_varlen,",
          "",
          "[Removed Lines]",
          "1512:      if (check_reserved_name(lhs->lhs_name) == FAIL)",
          "",
          "[Added Lines]",
          "1531:      if (check_reserved_name(lhs->lhs_name, cctx) == FAIL)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1757:      lhs->lhs_type = &t_any;",
          "1758:  }",
          "1761:      lhs->lhs_member_type = &t_any;",
          "1762:  else",
          "1763:      lhs->lhs_member_type = lhs->lhs_type->tt_member;",
          "1764:     }",
          "",
          "[Removed Lines]",
          "1760:  if (lhs->lhs_type->tt_member == NULL)",
          "",
          "[Added Lines]",
          "1779:  if (lhs->lhs_type == NULL || lhs->lhs_type->tt_member == NULL)",
          "1781:  else if (lhs->lhs_type->tt_type == VAR_CLASS",
          "1782:   || lhs->lhs_type->tt_type == VAR_OBJECT)",
          "1783:  {",
          "1785:      class_T *cl = (class_T *)lhs->lhs_type->tt_member;",
          "1786:      lhs->lhs_member_type = class_member_type(cl, after + 1,",
          "1787:         lhs->lhs_end, &lhs->lhs_member_idx);",
          "1788:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1880:      r = FAIL;",
          "1881:  }",
          "1882:     }",
          "1883:     else // if (*p == '.')",
          "1884:     {",
          "1885:  char_u *key_end = to_name_end(p + 1, TRUE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1910:     else if (lhs->lhs_member_idx >= 0)",
          "1911:     {",
          "1913:  r = generate_PUSHNR(cctx, lhs->lhs_member_idx);",
          "1914:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1996:  return FAIL;",
          "1997:     }",
          "2000:     {",
          "2002:  dest_type = VAR_ANY;",
          "",
          "[Removed Lines]",
          "1999:     if (lhs->lhs_type == &t_any)",
          "",
          "[Added Lines]",
          "2031:     if (lhs->lhs_type == NULL || lhs->lhs_type == &t_any)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2042:     if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)",
          "2043:  return FAIL;",
          "2047:     {",
          "2048:  if (is_assign)",
          "2049:  {",
          "",
          "[Removed Lines]",
          "2045:     if (dest_type == VAR_LIST || dest_type == VAR_DICT",
          "2046:          || dest_type == VAR_BLOB || dest_type == VAR_ANY)",
          "",
          "[Added Lines]",
          "2077:     if (dest_type == VAR_LIST",
          "2078:      || dest_type == VAR_DICT",
          "2079:      || dest_type == VAR_BLOB",
          "2080:      || dest_type == VAR_CLASS",
          "2081:      || dest_type == VAR_OBJECT",
          "2082:      || dest_type == VAR_ANY)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2466:       case VAR_PARTIAL:",
          "2467:       case VAR_VOID:",
          "2468:       case VAR_INSTR:",
          "2469:       case VAR_SPECIAL:  // cannot happen",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2505:       case VAR_CLASS:",
          "2506:       case VAR_OBJECT:",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2897:     if (check_args_shadowing(ufunc, &cctx) == FAIL)",
          "2898:  goto erret;",
          "2900:     if (ufunc->uf_def_args.ga_len > 0)",
          "2901:     {",
          "2902:  int count = ufunc->uf_def_args.ga_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2939:     if (ufunc->uf_flags & FC_OBJECT)",
          "2940:     {",
          "2941:  dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)",
          "2942:         + ufunc->uf_dfunc_idx;",
          "2943:  if (GA_GROW_FAILS(&dfunc->df_var_names, 1))",
          "2944:      goto erret;",
          "2945:  ((char_u **)dfunc->df_var_names.ga_data)[0] =",
          "2946:        vim_strsave((char_u *)\"this\");",
          "2947:  ++dfunc->df_var_names.ga_len;",
          "2950:  if ((ufunc->uf_flags & FC_NEW) == FC_NEW)",
          "2951:      generate_CONSTRUCT(&cctx, ufunc->uf_class);",
          "2952:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3500:     {",
          "3501:  if (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)",
          "3502:      ufunc->uf_ret_type = &t_void;",
          "3504:  {",
          "3505:      emsg(_(e_missing_return_statement));",
          "3506:      goto erret;",
          "3507:  }",
          "3511:     }",
          "",
          "[Removed Lines]",
          "3503:  else if (ufunc->uf_ret_type->tt_type != VAR_VOID)",
          "3510:  generate_instr(&cctx, ISN_RETURN_VOID);",
          "",
          "[Added Lines]",
          "3557:  else if (ufunc->uf_ret_type->tt_type != VAR_VOID",
          "3558:   && (ufunc->uf_flags & FC_NEW) != FC_NEW)",
          "3566:  if ((ufunc->uf_flags & FC_NEW) == FC_NEW)",
          "3567:      generate_instr(&cctx, ISN_RETURN_OBJECT);",
          "3568:  else",
          "3569:      generate_instr(&cctx, ISN_RETURN_VOID);",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2029:     for (ni = iptr + 1; ni->isn_type != ISN_FINISH; ++ni)",
          "2030:  if (ni->isn_type == ISN_DEBUG",
          "2031:     || ni->isn_type == ISN_RETURN",
          "2032:     || ni->isn_type == ISN_RETURN_VOID)",
          "2033:  {",
          "2034:      end_lnum = ni->isn_lnum + (ni->isn_type == ISN_DEBUG ? 0 : 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2032:     || ni->isn_type == ISN_RETURN_OBJECT",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2203:   return FAIL;",
          "2204:      blob_set_append(blob, lidx, nr);",
          "2205:  }",
          "2206:  else",
          "2207:  {",
          "2208:      status = FAIL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2207:  else if (dest_type == VAR_CLASS || dest_type == VAR_OBJECT)",
          "2208:  {",
          "2209:      long     idx = (long)tv_idx->vval.v_number;",
          "2210:      object_T     *obj = tv_dest->vval.v_object;",
          "2211:      typval_T     *otv = (typval_T *)(obj + 1);",
          "2212:      otv[idx] = *tv;",
          "2213:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3001:  iptr = &ectx->ec_instr[ectx->ec_iidx++];",
          "3002:  switch (iptr->isn_type)",
          "3003:  {",
          "3005:      case ISN_EXEC:",
          "3006:   if (exec_command(iptr) == FAIL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3013:      case ISN_CONSTRUCT:",
          "3015:   tv = STACK_TV_VAR(0);",
          "3016:   tv->v_type = VAR_OBJECT;",
          "3017:   tv->vval.v_object = alloc_clear(",
          "3018:            iptr->isn_arg.construct.construct_size);",
          "3019:   tv->vval.v_object->obj_class =",
          "3020:            iptr->isn_arg.construct.construct_class;",
          "3021:   tv->vval.v_object->obj_refcount = 1;",
          "3022:   break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4092:       goto on_error;",
          "4093:   break;",
          "4096:      case ISN_RETURN_VOID:",
          "4097:   if (GA_GROW_FAILS(&ectx->ec_stack, 1))",
          "4098:       goto theend;",
          "4099:   tv = STACK_TV_BOT(0);",
          "4100:   ++ectx->ec_stack.ga_len;",
          "",
          "[Removed Lines]",
          "4101:   tv->v_type = VAR_VOID;",
          "4102:   tv->vval.v_number = 0;",
          "4103:   tv->v_lock = 0;",
          "",
          "[Added Lines]",
          "4118:      case ISN_RETURN_OBJECT:",
          "4123:   if (iptr->isn_type == ISN_RETURN_VOID)",
          "4124:   {",
          "4125:       tv->v_type = VAR_VOID;",
          "4126:       tv->vval.v_number = 0;",
          "4127:       tv->v_lock = 0;",
          "4128:   }",
          "4129:   else",
          "4130:   {",
          "4132:       ++tv->vval.v_object->obj_refcount;",
          "4133:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4193:       CLEAR_FIELD(ea);",
          "4194:       ea.cmd = ea.arg = iptr->isn_arg.string;",
          "4195:       ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "4197:       ga_clear_strings(&lines_to_free);",
          "4198:   }",
          "4199:   break;",
          "",
          "[Removed Lines]",
          "4196:       define_function(&ea, NULL, &lines_to_free);",
          "",
          "[Added Lines]",
          "4226:       define_function(&ea, NULL, &lines_to_free, NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6019:  switch (iptr->isn_type)",
          "6020:  {",
          "6021:      case ISN_EXEC:",
          "6022:   smsg(\"%s%4d EXEC %s\", pfx, current, iptr->isn_arg.string);",
          "6023:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6051:      case ISN_CONSTRUCT:",
          "6052:   smsg(\"%s%4d NEW %s size %d\", pfx, current,",
          "6053:    iptr->isn_arg.construct.construct_class->class_name,",
          "6054:       (int)iptr->isn_arg.construct.construct_size);",
          "6055:   break;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6447:      case ISN_RETURN_VOID:",
          "6448:   smsg(\"%s%4d RETURN void\", pfx, current);",
          "6449:   break;",
          "6450:      case ISN_FUNCREF:",
          "6451:   {",
          "6452:       funcref_T  *funcref = &iptr->isn_arg.funcref;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6485:      case ISN_RETURN_OBJECT:",
          "6486:   smsg(\"%s%4d RETURN object\", pfx, current);",
          "6487:   break;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6979:  case VAR_ANY:",
          "6980:  case VAR_VOID:",
          "6981:  case VAR_INSTR:",
          "6982:      break;",
          "6983:     }",
          "6984:     return FALSE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7020:  case VAR_CLASS:",
          "7021:  case VAR_OBJECT:",
          "",
          "---------------"
        ],
        "src/vim9expr.c||src/vim9expr.c": [
          "File: src/vim9expr.c -> src/vim9expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "235:      case VAR_JOB:",
          "236:      case VAR_CHANNEL:",
          "237:      case VAR_INSTR:",
          "238:      case VAR_UNKNOWN:",
          "239:      case VAR_ANY:",
          "240:      case VAR_VOID:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:      case VAR_CLASS:",
          "239:      case VAR_OBJECT:",
          "",
          "---------------"
        ],
        "src/vim9instr.c||src/vim9instr.c": [
          "File: src/vim9instr.c -> src/vim9instr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:     return isn;",
          "114: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "120:     int",
          "121: generate_CONSTRUCT(cctx_T *cctx, class_T *cl)",
          "122: {",
          "123:     isn_T *isn;",
          "125:     RETURN_OK_IF_SKIP(cctx);",
          "126:     if ((isn = generate_instr(cctx, ISN_CONSTRUCT)) == NULL)",
          "127:  return FAIL;",
          "128:     isn->isn_arg.construct.construct_size = sizeof(object_T)",
          "129:           + cl->class_obj_member_count * sizeof(typval_T);",
          "130:     isn->isn_arg.construct.construct_class = cl;",
          "131:     return OK;",
          "132: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:  case VAR_JOB:",
          "164:  case VAR_CHANNEL:",
          "165:  case VAR_INSTR:",
          "166:     to_string_error(type->tt_type);",
          "167:     return FAIL;",
          "168:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184:  case VAR_CLASS:",
          "185:  case VAR_OBJECT:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2403:  case ISN_COMPARESPECIAL:",
          "2404:  case ISN_COMPARESTRING:",
          "2405:  case ISN_CONCAT:",
          "2406:  case ISN_COND2BOOL:",
          "2407:  case ISN_DEBUG:",
          "2408:  case ISN_DEFER:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2426:  case ISN_CONSTRUCT:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2457:  case ISN_REDIRSTART:",
          "2458:  case ISN_RETURN:",
          "2459:  case ISN_RETURN_VOID:",
          "2460:  case ISN_SHUFFLE:",
          "2461:  case ISN_SLICE:",
          "2462:  case ISN_SOURCE:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2481:  case ISN_RETURN_OBJECT:",
          "",
          "---------------"
        ],
        "src/vim9script.c||src/vim9script.c": [
          "File: src/vim9script.c -> src/vim9script.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "839:     p = skipwhite(p + 1);",
          "840:     type = parse_type(&p, &si->sn_type_list, TRUE);",
          "842:     {",
          "843:  vim_free(name);",
          "844:  return p;",
          "",
          "[Removed Lines]",
          "841:     if (type == NULL || check_reserved_name(name) == FAIL)",
          "",
          "[Added Lines]",
          "841:     if (type == NULL || check_reserved_name(name, NULL) == FAIL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1126: };",
          "1128:     int",
          "1130: {",
          "1131:     int idx;",
          "1133:     for (idx = 0; reserved[idx] != NULL; ++idx)",
          "1135:  {",
          "1136:      semsg(_(e_cannot_use_reserved_name), name);",
          "1137:      return FAIL;",
          "",
          "[Removed Lines]",
          "1129: check_reserved_name(char_u *name)",
          "1134:  if (STRCMP(reserved[idx], name) == 0)",
          "",
          "[Added Lines]",
          "1129: check_reserved_name(char_u *name, cctx_T *cctx)",
          "1134:  if (STRCMP(reserved[idx], name) == 0",
          "1136:   && !(STRCMP(\"this\", name) == 0",
          "1137:       && cctx != NULL",
          "1138:       && cctx->ctx_ufunc != NULL",
          "1139:       && (cctx->ctx_ufunc->uf_flags & FC_OBJECT)))",
          "",
          "---------------"
        ],
        "src/vim9type.c||src/vim9type.c": [
          "File: src/vim9type.c -> src/vim9type.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: get_type_ptr(garray_T *type_gap)",
          "34: {",
          "35:     type_T *type;",
          "",
          "[Removed Lines]",
          "32:     static type_T *",
          "",
          "[Added Lines]",
          "32:     type_T *",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96:     if (ret->tt_member != NULL)",
          "98:     if (type->tt_args != NULL)",
          "99:     {",
          "100:  int i;",
          "",
          "[Removed Lines]",
          "97:  ret->tt_member = alloc_type(ret->tt_member);",
          "",
          "[Added Lines]",
          "97:     {",
          "99:  if (type->tt_type != VAR_CLASS && type->tt_type != VAR_OBJECT)",
          "100:      ret->tt_member = alloc_type(ret->tt_member);",
          "101:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "124:      free_type(type->tt_args[i]);",
          "125:  vim_free(type->tt_args);",
          "126:     }",
          "128:     vim_free(type);",
          "129: }",
          "",
          "[Removed Lines]",
          "127:     free_type(type->tt_member);",
          "",
          "[Added Lines]",
          "134:     if (type->tt_type != VAR_OBJECT && type->tt_type != VAR_CLASS)",
          "135:  free_type(type->tt_member);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1203:  case VAR_JOB:",
          "1204:  case VAR_CHANNEL:",
          "1205:  case VAR_INSTR:",
          "1206:      break;  // not composite is always OK",
          "1207:  case VAR_LIST:",
          "1208:  case VAR_DICT:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1215:  case VAR_CLASS:",
          "1216:  case VAR_OBJECT:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1451:  case VAR_LIST: return \"list\";",
          "1452:  case VAR_DICT: return \"dict\";",
          "1453:  case VAR_INSTR: return \"instr\";",
          "1455:  case VAR_FUNC:",
          "1456:  case VAR_PARTIAL: return \"func\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1465:  case VAR_CLASS: return \"class\";",
          "1466:  case VAR_OBJECT: return \"object\";",
          "",
          "---------------"
        ],
        "src/viminfo.c||src/viminfo.c": [
          "File: src/viminfo.c -> src/viminfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1370:       case VAR_JOB:",
          "1371:       case VAR_CHANNEL:",
          "1372:       case VAR_INSTR:",
          "1373:          continue;",
          "1374:   }",
          "1375:   fprintf(fp, \"!%s\\t%s\\t\", this_var->di_key, s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1373:       case VAR_CLASS:",
          "1374:       case VAR_OBJECT:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7473a84cf935f64ddd4ea7fe7eee0f9c51c50b60",
      "candidate_info": {
        "commit_hash": "7473a84cf935f64ddd4ea7fe7eee0f9c51c50b60",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/7473a84cf935f64ddd4ea7fe7eee0f9c51c50b60",
        "files": [
          "src/errors.h",
          "src/testdir/test_vim9_func.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c"
        ],
        "message": "patch 8.2.3924: Vim9: no error if something follows :enddef\n\nProblem:    Vim9: no error if something follows :enddef in a nested function.\nSolution:   Give an error.  Move common code to a function.",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "717:  INIT(= N_(\"E1171: Missing } after inline function\"));",
          "718: EXTERN char e_cannot_use_default_values_in_lambda[]",
          "719:  INIT(= N_(\"E1172: Cannot use default values in a lambda\"));",
          "722: EXTERN char e_string_required_for_argument_nr[]",
          "723:  INIT(= N_(\"E1174: String required for argument %d\"));",
          "724: EXTERN char e_non_empty_string_required_for_argument_nr[]",
          "",
          "[Removed Lines]",
          "720: EXTERN char e_text_found_after_enddef_str[]",
          "721:  INIT(= N_(\"E1173: Text found after enddef: %s\"));",
          "",
          "[Added Lines]",
          "720: EXTERN char e_text_found_after_str_str[]",
          "721:  INIT(= N_(\"E1173: Text found after %s: %s\"));",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1686:       # Compile all functions",
          "1687:       defcompile",
          "1688:   END",
          "1690: enddef",
          "1692: def Test_nested_function_with_args_split()",
          "",
          "[Removed Lines]",
          "1689:   CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')",
          "",
          "[Added Lines]",
          "1689:   CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1703:       # Compile all functions",
          "1704:       defcompile",
          "1705:   END",
          "1708: enddef",
          "1710: def Test_return_type_wrong()",
          "",
          "[Removed Lines]",
          "1706:   # FIXME: this should fail on the BBBB",
          "1707:   CheckScriptSuccess(lines)",
          "",
          "[Added Lines]",
          "1706:   CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')",
          "1708:   lines =<< trim END",
          "1709:       vim9script",
          "1710:       def FirstFunction()",
          "1711:         func SecondFunction()",
          "1712:         endfunc|BBBB",
          "1713:       enddef",
          "1714:       defcompile",
          "1715:   END",
          "1716:   CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:     return p;",
          "166: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173:     static char_u *",
          "174: get_function_line(",
          "175:  exarg_T  *eap,",
          "176:  char_u  **line_to_free,",
          "177:  getline_opt_T getline_options,",
          "178:  int  indent)",
          "179: {",
          "180:     char_u *theline;",
          "182:     if (eap->getline == NULL)",
          "183:  theline = getcmdline(':', 0L, indent, getline_options);",
          "184:     else",
          "185:  theline = eap->getline(':', eap->cookie, indent, getline_options);",
          "186:     if (theline != NULL)",
          "187:     {",
          "188:  if (*eap->cmdlinep == *line_to_free)",
          "190:  vim_free(*line_to_free);",
          "192:     }",
          "194:     return theline;",
          "195: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:  while (eap != NULL && eap->getline != NULL",
          "213:     && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))",
          "214:  {",
          "219:      if (theline == NULL)",
          "220:   break;",
          "225:      whitep = (char_u *)\" \";",
          "226:      p = skipwhite(theline);",
          "227:  }",
          "",
          "[Removed Lines]",
          "215:      char_u *theline;",
          "218:      theline = eap->getline(':', eap->cookie, 0, TRUE);",
          "221:      vim_free(*line_to_free);",
          "222:      if (*eap->cmdlinep == *line_to_free)",
          "",
          "[Added Lines]",
          "245:      char_u *theline = get_function_line(eap, line_to_free, 0, TRUE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "720:  }",
          "721:  else",
          "722:  {",
          "727:              getline_options);",
          "732:  }",
          "733:  if (KeyTyped)",
          "734:      lines_left = Rows - 1;",
          "",
          "[Removed Lines]",
          "723:      if (eap->getline == NULL)",
          "724:   theline = getcmdline(':', 0L, indent, getline_options);",
          "725:      else",
          "726:   theline = eap->getline(':', eap->cookie, indent,",
          "728:      if (*eap->cmdlinep == *line_to_free)",
          "730:      vim_free(*line_to_free);",
          "",
          "[Added Lines]",
          "747:      theline = get_function_line(eap, line_to_free, indent,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "827:    SOURCING_LNUM = sourcing_lnum_top",
          "828:        + newlines->ga_len + 1;",
          "829:    if (eap->cmdidx == CMD_def)",
          "831:    else",
          "832:        give_warning2((char_u *)",
          "833:        _(\"W22: Text found after :endfunction: %s\"),",
          "",
          "[Removed Lines]",
          "830:        semsg(_(e_text_found_after_enddef_str), p);",
          "",
          "[Added Lines]",
          "847:        semsg(_(e_text_found_after_str_str), \"enddef\", p);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3923,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3924,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "879:     }",
          "881:     ufunc = define_function(eap, lambda_name, line_to_free);",
          "883:     if (ufunc == NULL)",
          "884:     {",
          "885:  r = eap->skip ? OK : FAIL;",
          "886:  goto theend;",
          "887:     }",
          "890:     if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "887:     if (eap->nextcmd != NULL)",
          "888:     {",
          "889:  semsg(_(e_text_found_after_str_str),",
          "890:        eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);",
          "891:  r = FAIL;",
          "892:  goto theend;",
          "893:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a786e453a4c03c958feb30bfda4153a24bb393e6",
      "candidate_info": {
        "commit_hash": "a786e453a4c03c958feb30bfda4153a24bb393e6",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a786e453a4c03c958feb30bfda4153a24bb393e6",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/window.c"
        ],
        "message": "Simplify the windows frame code some. Add a comment explaining some of the VM code generated by sqlite3WindowCodeStep().\n\nFossilOrigin-Name: 6bd1a07949ff3d394056bfcc813444401ef00806e3f0e0423ff6962541e84bdb",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: e7bced731aa071c95bc398cdecd53c939841bf0c52fbcd06e47ba68f8c5cc35a",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1698:   return ret;",
          "1699: }",
          "1774: ){",
          "1775:   Window *pMWin = p->pWin;",
          "1776:   ExprList *pOrderBy = pMWin->pOrderBy;",
          "1777:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "1794:   int addrShortcut = 0;",
          "1810:   assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT",
          "1811:        || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED",
          "",
          "[Removed Lines]",
          "1768: static void windowCodeStep(",
          "1769:   Parse *pParse,",
          "1770:   Select *p,",
          "1771:   WhereInfo *pWInfo,",
          "1772:   int regGosub,",
          "1773:   int addrGosub",
          "1780:   int regArg;",
          "1781:   int csrWrite = pMWin->iEphCsr+1;",
          "1787:   int addrGoto;",
          "1788:   int addrIf;",
          "1789:   int addrGosubFlush;",
          "1790:   int addrInteger;",
          "1791:   int addrCacheRewind;",
          "1792:   int addrCacheNext;",
          "1795:   int addrEmpty = 0;",
          "1796:   int addrPeerJump = 0;",
          "1798:   int bCache = windowCachePartition(pMWin);",
          "1803:   int reg = pParse->nMem+1;",
          "1804:   int regRecord = reg+nSub;",
          "1805:   int regRowid = regRecord+1;",
          "1806:   int regPeer = 0;",
          "1807:   int regNewPeer = 0;",
          "1808:   WindowCodeArg s;",
          "",
          "[Added Lines]",
          "1707: Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){",
          "1708:   Window *pNew = 0;",
          "1709:   if( ALWAYS(p) ){",
          "1710:     pNew = sqlite3DbMallocZero(db, sizeof(Window));",
          "1711:     if( pNew ){",
          "1712:       pNew->zName = sqlite3DbStrDup(db, p->zName);",
          "1713:       pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);",
          "1714:       pNew->pFunc = p->pFunc;",
          "1715:       pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);",
          "1716:       pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);",
          "1717:       pNew->eType = p->eType;",
          "1718:       pNew->eEnd = p->eEnd;",
          "1719:       pNew->eStart = p->eStart;",
          "1720:       pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);",
          "1721:       pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);",
          "1722:       pNew->pOwner = pOwner;",
          "1723:     }",
          "1724:   }",
          "1725:   return pNew;",
          "1726: }",
          "1732: Window *sqlite3WindowListDup(sqlite3 *db, Window *p){",
          "1733:   Window *pWin;",
          "1734:   Window *pRet = 0;",
          "1735:   Window **pp = &pRet;",
          "1737:   for(pWin=p; pWin; pWin=pWin->pNextWin){",
          "1739:     if( *pp==0 ) break;",
          "1740:     pp = &((*pp)->pNextWin);",
          "1741:   }",
          "1743:   return pRet;",
          "1744: }",
          "1946: void sqlite3WindowCodeStep(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1814:        || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING",
          "1815:   );",
          "1817:   memset(&s, 0, sizeof(WindowCodeArg));",
          "1818:   s.pParse = pParse;",
          "1819:   s.pMWin = pMWin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1989:   bCache = windowCachePartition(pMWin);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1821:   s.regGosub = regGosub;",
          "1822:   s.addrGosub = addrGosub;",
          "1823:   s.current.csr = pMWin->iEphCsr;",
          "1824:   s.start.csr = s.current.csr+2;",
          "1825:   s.end.csr = s.current.csr+3;",
          "1829:   regFlushPart = ++pParse->nMem;",
          "1831:   if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING ){",
          "1832:     regStart = ++pParse->nMem;",
          "1833:   }",
          "",
          "[Removed Lines]",
          "1827:   pParse->nMem += 1 + nSub + 1;",
          "",
          "[Added Lines]",
          "1999:   csrWrite = s.current.csr+1;",
          "2003:   regNew = pParse->nMem+1;",
          "2004:   pParse->nMem += nInput;",
          "2005:   regRecord = ++pParse->nMem;",
          "2006:   regRowid = ++pParse->nMem;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1836:   }",
          "1841:   if( pMWin->eType!=TK_ROWS ){",
          "1842:     int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);",
          "1844:     if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;",
          "1846:     regPeer = pParse->nMem+1;       pParse->nMem += nPeer;",
          "1847:     s.start.reg = pParse->nMem+1;   pParse->nMem += nPeer;",
          "1848:     s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;",
          "",
          "[Removed Lines]",
          "1843:     regNewPeer = reg + pMWin->nBufferCol;",
          "",
          "[Added Lines]",
          "2024:     regNewPeer = regNew + pMWin->nBufferCol;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1850:   }",
          "1857:   }",
          "1866:   if( pMWin->pPartition ){",
          "1867:     int addr;",
          "1868:     ExprList *pPart = pMWin->pPartition;",
          "1869:     int nPart = pPart->nExpr;",
          "1871:     KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);",
          "1873:     addr = sqlite3VdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart, nPart);",
          "",
          "[Removed Lines]",
          "1855:   for(iCol=0; iCol<nSub; iCol++){",
          "1856:     sqlite3VdbeAddOp3(v, OP_Column, iSubCsr, iCol, reg+iCol);",
          "1858:   sqlite3VdbeAddOp3(v, OP_MakeRecord, reg, nSub, regRecord);",
          "1870:     int regNewPart = reg + pMWin->nBufferCol;",
          "",
          "[Added Lines]",
          "2035:   for(iInput=0; iInput<nInput; iInput++){",
          "2036:     sqlite3VdbeAddOp3(v, OP_Column, csrInput, iInput, regNew+iInput);",
          "2038:   sqlite3VdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);",
          "2049:     int regNewPart = regNew + pMWin->nBufferCol;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1893:     }",
          "1894:     addrCacheRewind = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);",
          "1895:   }else{",
          "1897:   }",
          "1902:   if( regStart ){",
          "1903:     sqlite3ExprCode(pParse, pMWin->pStart, regStart);",
          "",
          "[Removed Lines]",
          "1896:     addrIf = sqlite3VdbeAddOp1(v, OP_IfNot, pMWin->regFirst);",
          "1900:   s.regArg = regArg = windowInitAccum(pParse, pMWin);",
          "",
          "[Added Lines]",
          "2075:     addrIfNot = sqlite3VdbeAddOp1(v, OP_IfNot, pMWin->regFirst);",
          "2079:   s.regArg = windowInitAccum(pParse, pMWin);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1950:   addrGoto = sqlite3VdbeAddOp0(v, OP_Goto);",
          "1954:   if( bCache ){",
          "1955:     addrCacheNext = sqlite3VdbeCurrentAddr(v);",
          "1956:     if( pMWin->eType!=TK_ROWS ){",
          "1957:       windowReadPeerValues(&s, csrWrite, regNewPeer);",
          "1958:     }",
          "1959:   }else{",
          "1961:   }",
          "1962:   if( regPeer ){",
          "1963:     addrPeerJump = windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer);",
          "",
          "[Removed Lines]",
          "1953:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep.SECOND_ROW_CODE\"));",
          "1960:     sqlite3VdbeJumpHere(v, addrIf);",
          "",
          "[Added Lines]",
          "2132:   VdbeModuleComment((pParse->pVdbe, \"Begin WindowCodeStep.SECOND_ROW\"));",
          "2139:     sqlite3VdbeJumpHere(v, addrIfNot);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2011:   if( addrPeerJump ){",
          "2012:     sqlite3VdbeJumpHere(v, addrPeerJump);",
          "2013:   }",
          "2017:   sqlite3VdbeJumpHere(v, addrGoto);",
          "",
          "[Removed Lines]",
          "2014:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep.SECOND_ROW_CODE\"));",
          "",
          "[Added Lines]",
          "2193:   VdbeModuleComment((pParse->pVdbe, \"End WindowCodeStep.SECOND_ROW\"));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2029:     sqlite3VdbeJumpHere(v, addrGosubFlush);",
          "2030:   }",
          "2033:   addrEmpty = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);",
          "2034:   if( pMWin->eEnd==TK_PRECEDING ){",
          "2035:     windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);",
          "",
          "[Removed Lines]",
          "2032:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep.FLUSH_CODE\"));",
          "",
          "[Added Lines]",
          "2211:   VdbeModuleComment((pParse->pVdbe, \"Begin WindowCodeStep.FLUSH\"));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2079:   sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);",
          "2080:   sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regSize);",
          "2081:   if( bCache==0 ) sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regFirst);",
          "2083:   if( pMWin->pPartition ){",
          "2084:     sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));",
          "2085:     sqlite3VdbeAddOp1(v, OP_Return, regFlushPart);",
          "2086:   }",
          "2087: }",
          "",
          "[Removed Lines]",
          "2082:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep.FLUSH_CODE\"));",
          "2095: Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){",
          "2096:   Window *pNew = 0;",
          "2097:   if( ALWAYS(p) ){",
          "2098:     pNew = sqlite3DbMallocZero(db, sizeof(Window));",
          "2099:     if( pNew ){",
          "2100:       pNew->zName = sqlite3DbStrDup(db, p->zName);",
          "2101:       pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);",
          "2102:       pNew->pFunc = p->pFunc;",
          "2103:       pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);",
          "2104:       pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);",
          "2105:       pNew->eType = p->eType;",
          "2106:       pNew->eEnd = p->eEnd;",
          "2107:       pNew->eStart = p->eStart;",
          "2108:       pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);",
          "2109:       pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);",
          "2110:       pNew->pOwner = pOwner;",
          "2111:     }",
          "2112:   }",
          "2113:   return pNew;",
          "2114: }",
          "2120: Window *sqlite3WindowListDup(sqlite3 *db, Window *p){",
          "2121:   Window *pWin;",
          "2122:   Window *pRet = 0;",
          "2123:   Window **pp = &pRet;",
          "2125:   for(pWin=p; pWin; pWin=pWin->pNextWin){",
          "2127:     if( *pp==0 ) break;",
          "2128:     pp = &((*pp)->pNextWin);",
          "2129:   }",
          "2131:   return pRet;",
          "2132: }",
          "2141: void sqlite3WindowCodeStep(",
          "2147: ){",
          "2148:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep()\"));",
          "2149:   windowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);",
          "2150:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep()\"));",
          "2151: }",
          "",
          "[Added Lines]",
          "2261:   VdbeModuleComment((pParse->pVdbe, \"End WindowCodeStep.FLUSH\"));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ccf6e7d0f0cbcd829b13c482aa43c27a59ea335c",
      "candidate_info": {
        "commit_hash": "ccf6e7d0f0cbcd829b13c482aa43c27a59ea335c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ccf6e7d0f0cbcd829b13c482aa43c27a59ea335c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c"
        ],
        "message": "Remove a test from the index build logic which is no longer needed and is in fact unreachable.\n\nFossilOrigin-Name: 9b20ee10ff86c1f79706180310e02b6f78863e02b179062d8966573ae33a252f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 24ef3844692debc2db7b1d427f5dcf4050481a8c7f71c3b516766b819ecab587",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3161: #ifdef SQLITE_ALLOW_SQLITE_MASTER_INDEX",
          "3162:        && sqlite3StrICmp(&pTab->zName[7],\"master\")!=0",
          "3163: #endif",
          "3165:  ){",
          "3166:     sqlite3ErrorMsg(pParse, \"table %s may not be indexed\", pTab->zName);",
          "3167:     goto exit_create_index;",
          "",
          "[Removed Lines]",
          "3164:        && sqlite3StrNICmp(&pTab->zName[7],\"altertab_\",9)!=0",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3251a2031bfd29f338a5fda1a08c18878296d354",
      "candidate_info": {
        "commit_hash": "3251a2031bfd29f338a5fda1a08c18878296d354",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/3251a2031bfd29f338a5fda1a08c18878296d354",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c",
          "test/colname.test"
        ],
        "message": "Remove two incorrect assert() statements from the logic used to derive column names and types from subqueries.\n\nFossilOrigin-Name: 712e47714863a8ed7ff73324d9fec569633e8b901c436c633b0220d16a7a9302",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c",
          "test/colname.test||test/colname.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: eaf15d9bae6773058341d6219241f44ce728ad1cb9cf649f2efd4dddd81ec461",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1645:   assert( pExpr!=0 );",
          "1646:   assert( pNC->pSrcList!=0 );",
          "1649:   switch( pExpr->op ){",
          "1650:     case TK_COLUMN: {",
          "",
          "[Removed Lines]",
          "1647:   assert( pExpr->op!=TK_AGG_COLUMN );  /* This routine runes before aggregates",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1967:         pColExpr = pColExpr->pRight;",
          "1968:         assert( pColExpr!=0 );",
          "1969:       }",
          "1971:       if( pColExpr->op==TK_COLUMN ){",
          "1973:         int iCol = pColExpr->iColumn;",
          "",
          "[Removed Lines]",
          "1970:       assert( pColExpr->op!=TK_AGG_COLUMN );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/colname.test||test/colname.test": [
          "File: test/colname.test -> test/colname.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "399:     SELECT name FROM pragma_table_info('t2');",
          "400:   } {Bbb}",
          "401: }",
          "403: # Issue detected by OSSFuzz on 2017-12-24 (Christmas Eve)",
          "404: # caused by check-in https://sqlite.org/src/info/6b2ff26c25",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "402: do_execsql_test colname-9.330 { -- added 2019-08-10 to invalidate",
          "403:   DROP TABLE IF EXISTS t1;      -- a couple assert()s that were",
          "404:   CREATE TABLE t1(a);           -- added by ticket 3b44500725",
          "405:   INSERT INTO t1 VALUES(17),(2),(99),(-3),(7);",
          "406:   SELECT (SELECT avg(a) UNION SELECT min(a) OVER()) FROM t1;",
          "407: } {17}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "51e441da2b1901806e38537f118592a1a022ce6d",
      "candidate_info": {
        "commit_hash": "51e441da2b1901806e38537f118592a1a022ce6d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/51e441da2b1901806e38537f118592a1a022ce6d",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/pragma.c",
          "src/pragma.h",
          "tool/mkpragmatab.tcl"
        ],
        "message": "Combine the implementations of the key and hexkey pragmas into a single case.  Have both pragmas return \"ok\" if they are implemented.\n\nFossilOrigin-Name: b3692c406f7ba62587c9d3256f888748393519680e9e2db53f59557f1a300e05",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/pragma.c||src/pragma.c",
          "src/pragma.h||src/pragma.h",
          "tool/mkpragmatab.tcl||tool/mkpragmatab.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/pragma.c||src/pragma.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/pragma.c||src/pragma.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: a3e77c7776ab01dadb9d30d6067ac97e9d4b09ec54834558a5fa1ffed7b52c72",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/pragma.c||src/pragma.c": [
          "File: src/pragma.c -> src/pragma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2131:   case PragTyp_KEY: {",
          "2132:     if( zRight ){",
          "2136:       }else{",
          "2150:       }",
          "2151:       if( (pPragma->iArg & 1)==0 ){",
          "2153:       }else{",
          "2155:       }",
          "2156:     }",
          "2157:     break;",
          "",
          "[Removed Lines]",
          "2133:       int n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;",
          "2134:       if( (pPragma->iArg & 1)==0 ){",
          "2135:         sqlite3_key_v2(db, zDb, zRight, n);",
          "2137:         sqlite3_rekey_v2(db, zDb, zRight, n);",
          "2138:       }",
          "2139:     }",
          "2140:     break;",
          "2141:   }",
          "2142:   case PragTyp_HEXKEY: {",
          "2143:     if( zRight ){",
          "2144:       u8 iByte;",
          "2145:       int i;",
          "2146:       char zKey[40];",
          "2147:       for(i=0, iByte=0; i<sizeof(zKey)*2 && sqlite3Isxdigit(zRight[i]); i++){",
          "2148:         iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);",
          "2149:         if( (i&1)!=0 ) zKey[i/2] = iByte;",
          "2152:         sqlite3_key_v2(db, zDb, zKey, i/2);",
          "2154:         sqlite3_rekey_v2(db, zDb, zKey, i/2);",
          "",
          "[Added Lines]",
          "2133:       char zBuf[40];",
          "2134:       const char *zKey = zRight;",
          "2135:       int n;",
          "2136:       if( pPragma->iArg==2 || pPragma->iArg==3 ){",
          "2137:         u8 iByte;",
          "2138:         int i;",
          "2139:         for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++){",
          "2140:           iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);",
          "2141:           if( (i&1)!=0 ) zBuf[i/2] = iByte;",
          "2142:         }",
          "2143:         zKey = zBuf;",
          "2144:         n = i/2;",
          "2146:         n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;",
          "2149:         rc = sqlite3_key_v2(db, zDb, zKey, n);",
          "2151:         rc = sqlite3_rekey_v2(db, zDb, zKey, n);",
          "2152:       }",
          "2153:       if( rc==SQLITE_OK && n!=0 ){",
          "2154:         sqlite3VdbeSetNumCols(v, 1);",
          "2155:         sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"ok\", SQLITE_STATIC);",
          "2156:         returnSingleText(v, \"ok\");",
          "",
          "---------------"
        ],
        "src/pragma.h||src/pragma.h": [
          "File: src/pragma.h -> src/pragma.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #define PragTyp_WAL_AUTOCHECKPOINT            38",
          "47: #define PragTyp_WAL_CHECKPOINT                39",
          "48: #define PragTyp_ACTIVATE_EXTENSIONS           40",
          "",
          "[Removed Lines]",
          "49: #define PragTyp_HEXKEY                        41",
          "50: #define PragTyp_KEY                           42",
          "51: #define PragTyp_LOCK_STATUS                   43",
          "52: #define PragTyp_STATS                         44",
          "",
          "[Added Lines]",
          "49: #define PragTyp_KEY                           41",
          "50: #define PragTyp_LOCK_STATUS                   42",
          "51: #define PragTyp_STATS                         43",
          "",
          "---------------"
        ],
        "tool/mkpragmatab.tcl||tool/mkpragmatab.tcl": [
          "File: tool/mkpragmatab.tcl -> tool/mkpragmatab.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "381:   IF:   defined(SQLITE_HAS_CODEC)",
          "383:   NAME: hexkey",
          "385:   ARG:  2",
          "386:   IF:   defined(SQLITE_HAS_CODEC)",
          "388:   NAME: hexrekey",
          "390:   ARG:  3",
          "391:   IF:   defined(SQLITE_HAS_CODEC)",
          "",
          "[Removed Lines]",
          "384:   TYPE: HEXKEY",
          "389:   TYPE: HEXKEY",
          "",
          "[Added Lines]",
          "384:   TYPE: KEY",
          "389:   TYPE: KEY",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "53d30dd371832c13a62312b339cb0a86b1012b20",
      "candidate_info": {
        "commit_hash": "53d30dd371832c13a62312b339cb0a86b1012b20",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/53d30dd371832c13a62312b339cb0a86b1012b20",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/btree.h",
          "src/vdbemem.c"
        ],
        "message": "Early detection of implausibly sized records to avoid unnecessary large memory allocations.\n\nFossilOrigin-Name: 2c8769c69f301307db6663adb8b7c0b89f5959516bf6110cb8ff4b21bd903f70",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/btree.h||src/btree.h",
          "src/vdbemem.c||src/vdbemem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ada91aefe37efe3c009691b5599e4d6acf182e5ec3cf28dda0871d09858498b3",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4519:   return pCur->info.nPayload;",
          "4520: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4535: sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor *pCur){",
          "4536:   assert( cursorHoldsMutex(pCur) );",
          "4537:   assert( pCur->eState==CURSOR_VALID );",
          "4538:   return pCur->pBt->pageSize * (sqlite3_int64)pCur->pBt->nPage;",
          "4539: }",
          "",
          "---------------"
        ],
        "src/btree.h||src/btree.h": [
          "File: src/btree.h -> src/btree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "315: int sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*);",
          "316: const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);",
          "317: u32 sqlite3BtreePayloadSize(BtCursor*);",
          "319: char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*);",
          "320: struct Pager *sqlite3BtreePager(Btree*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "318: sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor*);",
          "",
          "---------------"
        ],
        "src/vdbemem.c||src/vdbemem.c": [
          "File: src/vdbemem.c -> src/vdbemem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1124: ){",
          "1125:   int rc;",
          "1126:   pMem->flags = MEM_Null;",
          "1127:   if( SQLITE_OK==(rc = sqlite3VdbeMemClearAndResize(pMem, amt+1)) ){",
          "1128:     rc = sqlite3BtreePayload(pCur, offset, amt, pMem->z);",
          "1129:     if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1127:   if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){",
          "1128:     return SQLITE_CORRUPT_BKPT;",
          "1129:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-3656",
  "cve_desc": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.",
  "repo": "torvalds/linux",
  "patch_hash": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc",
  "patch_info": {
    "commit_hash": "c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc",
    "files": [
      "arch/x86/kvm/svm/nested.c"
    ],
    "message": "KVM: nSVM: always intercept VMLOAD/VMSAVE when nested (CVE-2021-3656)\n\nIf L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable\nVirtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor),\nthen VMLOAD/VMSAVE must operate on the L1 physical memory, which is only\npossible by making L0 intercept these instructions.\n\nFailure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted,\nand thus read/write portions of the host physical memory.\n\nFixes: 89c8a4984fc9 (\"KVM: SVM: Enable Virtual VMLOAD VMSAVE feature\")\n\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/svm/nested.c||arch/x86/kvm/svm/nested.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/svm/nested.c||arch/x86/kvm/svm/nested.c": [
      "File: arch/x86/kvm/svm/nested.c -> arch/x86/kvm/svm/nested.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "159:  if (!intercept_smi)",
      "160:   vmcb_clr_intercept(c, INTERCEPT_SMI);",
      "161: }",
      "163: static void copy_vmcb_control_area(struct vmcb_control_area *dst,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "162:  vmcb_set_intercept(c, INTERCEPT_VMLOAD);",
      "163:  vmcb_set_intercept(c, INTERCEPT_VMSAVE);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b9f3973ab3a80141a6decc34f4740e6494ca7d51",
      "candidate_info": {
        "commit_hash": "b9f3973ab3a80141a6decc34f4740e6494ca7d51",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b9f3973ab3a80141a6decc34f4740e6494ca7d51",
        "files": [
          "arch/x86/kvm/svm/nested.c",
          "arch/x86/kvm/svm/svm.c",
          "arch/x86/kvm/svm/svm.h"
        ],
        "message": "KVM: x86: nSVM: implement nested VMLOAD/VMSAVE\n\nThis was tested by booting L1,L2,L3 (all Linux) and checking\nthat no VMLOAD/VMSAVE vmexits happened.\n\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nMessage-Id: <20220301143650.143749-4-mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/svm/nested.c||arch/x86/kvm/svm/nested.c",
          "arch/x86/kvm/svm/svm.c||arch/x86/kvm/svm/svm.c",
          "arch/x86/kvm/svm/svm.h||arch/x86/kvm/svm/svm.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/svm/nested.c||arch/x86/kvm/svm/nested.c"
          ],
          "candidate": [
            "arch/x86/kvm/svm/nested.c||arch/x86/kvm/svm/nested.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/svm/nested.c||arch/x86/kvm/svm/nested.c": [
          "File: arch/x86/kvm/svm/nested.c -> arch/x86/kvm/svm/nested.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "121:  vcpu->arch.walk_mmu = &vcpu->arch.root_mmu;",
          "122: }",
          "124: void recalc_intercepts(struct vcpu_svm *svm)",
          "125: {",
          "126:  struct vmcb_control_area *c, *h;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124: static bool nested_vmcb_needs_vls_intercept(struct vcpu_svm *svm)",
          "125: {",
          "126:  if (!svm->v_vmload_vmsave_enabled)",
          "127:   return true;",
          "129:  if (!nested_npt_enabled(svm))",
          "130:   return true;",
          "132:  if (!(svm->nested.ctl.virt_ext & VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK))",
          "133:   return true;",
          "135:  return false;",
          "136: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162:  if (!intercept_smi)",
          "163:   vmcb_clr_intercept(c, INTERCEPT_SMI);",
          "167: }",
          "",
          "[Removed Lines]",
          "165:  vmcb_set_intercept(c, INTERCEPT_VMLOAD);",
          "166:  vmcb_set_intercept(c, INTERCEPT_VMSAVE);",
          "",
          "[Added Lines]",
          "179:  if (nested_vmcb_needs_vls_intercept(svm)) {",
          "185:   vmcb_set_intercept(c, INTERCEPT_VMLOAD);",
          "186:   vmcb_set_intercept(c, INTERCEPT_VMSAVE);",
          "187:  } else {",
          "188:   WARN_ON(!(c->virt_ext & VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK));",
          "189:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "454:  vmcb12->control.exit_int_info = exit_int_info;",
          "455: }",
          "462: static void nested_svm_transition_tlb_flush(struct kvm_vcpu *vcpu)",
          "463: {",
          "",
          "[Removed Lines]",
          "457: static inline bool nested_npt_enabled(struct vcpu_svm *svm)",
          "458: {",
          "459:  return svm->nested.ctl.nested_ctl & SVM_NESTED_CTL_NP_ENABLE;",
          "460: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "621:  svm->vmcb->control.event_inj           = svm->nested.ctl.event_inj;",
          "622:  svm->vmcb->control.event_inj_err       = svm->nested.ctl.event_inj_err;",
          "624:  nested_svm_transition_tlb_flush(vcpu);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "642:  if (!nested_vmcb_needs_vls_intercept(svm))",
          "643:   svm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;",
          "",
          "---------------"
        ],
        "arch/x86/kvm/svm/svm.c||arch/x86/kvm/svm/svm.c": [
          "File: arch/x86/kvm/svm/svm.c -> arch/x86/kvm/svm/svm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "961:   set_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_EIP, 0, 0);",
          "962:   set_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_ESP, 0, 0);",
          "963:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "964:   svm->v_vmload_vmsave_enabled = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3948:  svm->tsc_scaling_enabled = tsc_scaling && guest_cpuid_has(vcpu, X86_FEATURE_TSCRATEMSR);",
          "3950:  svm_recalc_instruction_intercepts(vcpu, svm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3952:  svm->v_vmload_vmsave_enabled = vls && guest_cpuid_has(vcpu, X86_FEATURE_V_VMSAVE_VMLOAD);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4695:   if (tsc_scaling)",
          "4696:    kvm_cpu_cap_set(X86_FEATURE_TSCRATEMSR);",
          "4699:   kvm_cpu_cap_set(X86_FEATURE_SVME_ADDR_CHK);",
          "4700:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4702:   if (vls)",
          "4703:    kvm_cpu_cap_set(X86_FEATURE_V_VMSAVE_VMLOAD);",
          "",
          "---------------"
        ],
        "arch/x86/kvm/svm/svm.h||arch/x86/kvm/svm/svm.h": [
          "File: arch/x86/kvm/svm/svm.h -> arch/x86/kvm/svm/svm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "231:  unsigned int3_injected;",
          "232:  unsigned long int3_rip;",
          "235:  bool nrips_enabled                : 1;",
          "236:  bool tsc_scaling_enabled          : 1;",
          "238:  u32 ldr_reg;",
          "239:  u32 dfr_reg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:  bool v_vmload_vmsave_enabled      : 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "481:   return !!(svm->vcpu.arch.hflags & HF_GIF_MASK);",
          "482: }",
          "485: #define MSR_INVALID    0xffffffffU",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "485: static inline bool nested_npt_enabled(struct vcpu_svm *svm)",
          "486: {",
          "487:  return svm->nested.ctl.nested_ctl & SVM_NESTED_CTL_NP_ENABLE;",
          "488: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "98c5ad309fce1eeea6cfe624e1dfd341abca947a",
      "candidate_info": {
        "commit_hash": "98c5ad309fce1eeea6cfe624e1dfd341abca947a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/98c5ad309fce1eeea6cfe624e1dfd341abca947a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Have .recover store all orphaned rows in a single table, with extra columns to indicate the orphaned page and sub-tree they were discovered within.\n\nFossilOrigin-Name: 7221f6e33ed6a5a96ec61e25f2a1f70b84aae66e503d897eb7b7ff1aec42355d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: bee2652ac26370e612a8c81dd7554befc2d523442a2fbbc77dc73479e6a0d7fd",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "6226:     sqlite3_free(pTab->zQuoted);",
          "6227:     if( pTab->azlCol ){",
          "6228:       int i;",
          "6230:         sqlite3_free(pTab->azlCol[i]);",
          "6231:       }",
          "6232:       sqlite3_free(pTab->azlCol);",
          "",
          "[Removed Lines]",
          "6229:       for(i=0; i<pTab->nCol; i++){",
          "",
          "[Added Lines]",
          "6229:       for(i=0; i<=pTab->nCol; i++){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6235:   }",
          "6236: }",
          "6243:   int bIntkey,",
          "",
          "[Removed Lines]",
          "6238: static void recoverOldTable(",
          "6240:   RecoverTable *pTab,",
          "",
          "[Added Lines]",
          "6238: static RecoverTable *recoverOldTable(",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6245: ){",
          "6247:   int rc = *pRc;",
          "6249:   if( rc==SQLITE_OK ){",
          "6250:     int nSqlCol = 0;",
          "6251:     int bSqlIntkey = 0;",
          "6252:     sqlite3_stmt *pStmt = 0;",
          "6254:     rc = sqlite3_open(\"\", &dbtmp);",
          "6255:     if( rc==SQLITE_OK ){",
          "6256:       rc = sqlite3_exec(dbtmp, \"PRAGMA writable_schema = on\", 0, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6247:   RecoverTable *pTab = 0;",
          "6249:   pTab = (RecoverTable*)shellMalloc(&rc, sizeof(RecoverTable));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6285:     shellFinalize(&rc, pStmt);",
          "6287:     if( bIntkey==bSqlIntkey ){",
          "6288:       const char *zPk = \"_rowid_\";",
          "6289:       sqlite3_stmt *pPkFinder = 0;",
          "6292:           \"SELECT cid, name FROM pragma_table_info(%Q) \"",
          "6293:           \"  WHERE pk=1 AND type='integer' COLLATE nocase\"",
          "6300:       }",
          "6302:       pTab->zName = shellMPrintf(&rc, \"%s\", zName);",
          "6303:       pTab->zQuoted = shellMPrintf(&rc, \"%Q\", pTab->zName);",
          "6305:       pTab->nCol = nSqlCol;",
          "6308:         pTab->azlCol[0] = shellMPrintf(&rc, \"%Q\", zPk);",
          "6309:       }else{",
          "6314:           \"FROM pragma_table_info(%Q)\",",
          "6324:       }",
          "6325:       shellFinalize(&rc, pPkFinder);",
          "6326:     }",
          "6327:   }",
          "",
          "[Removed Lines]",
          "6291:       shellPreparePrintf(dbtmp, &rc, &pPkFinder,",
          "6294:           \"  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\",",
          "6295:           zName, zName",
          "6296:       );",
          "6297:       if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){",
          "6298:         pTab->iPk = sqlite3_column_int(pPkFinder, 0);",
          "6299:         zPk = (const char*)sqlite3_column_text(pPkFinder, 1);",
          "6304:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * nSqlCol);",
          "6307:       if( nSqlCol==1 && pTab->iPk==0 ){",
          "6310:         shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6311:           \"SELECT -1+row_number()          OVER (ORDER BY cid),\"",
          "6312:           \"    %Q||%Q||group_concat(name, ', ') FILTER (WHERE cid!=%d) \"",
          "6313:           \"           OVER (ORDER BY cid) \"",
          "6315:           (bIntkey ? zPk : \"\"), (bIntkey ? \", \" : \"\"),",
          "6316:           pTab->iPk, zName",
          "6317:         );",
          "6318:         while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6319:           int idx = sqlite3_column_int(pStmt, 0);",
          "6320:           const char *zText = (const char*)sqlite3_column_text(pStmt, 1);",
          "6321:           pTab->azlCol[idx] = shellMPrintf(&rc, \"%s\", zText);",
          "6322:         }",
          "6323:         shellFinalize(&rc, pStmt);",
          "",
          "[Added Lines]",
          "6289:       int i;",
          "6293:       pTab->iPk = -2;",
          "6294:       if( bIntkey ){",
          "6295:         shellPreparePrintf(dbtmp, &rc, &pPkFinder,",
          "6298:           \"  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\"",
          "6299:           , zName, zName",
          "6300:         );",
          "6301:         if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){",
          "6302:           pTab->iPk = sqlite3_column_int(pPkFinder, 0);",
          "6303:           zPk = (const char*)sqlite3_column_text(pPkFinder, 1);",
          "6304:         }",
          "6309:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * (nSqlCol+1));",
          "6312:       if( bIntkey ){",
          "6315:         pTab->azlCol[0] = shellMPrintf(&rc, \"\");",
          "6316:       }",
          "6317:       i = 1;",
          "6318:       shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6319:           \"SELECT %Q || group_concat(name, ', ') \"",
          "6320:           \"  FILTER (WHERE cid!=%d) OVER (ORDER BY cid) \"",
          "6322:           bIntkey ? \", \" : \"\", pTab->iPk, zName",
          "6323:       );",
          "6324:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6325:         const char *zText = (const char*)sqlite3_column_text(pStmt, 0);",
          "6326:         pTab->azlCol[i] = shellMPrintf(&rc, \"%s%s\", pTab->azlCol[0], zText);",
          "6327:         i++;",
          "6329:       shellFinalize(&rc, pStmt);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6329:  finished:",
          "6330:   sqlite3_close(dbtmp);",
          "6332: }",
          "6334: static RecoverTable *recoverNewTable(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6338:   if( rc!=SQLITE_OK ){",
          "6339:     recoverFreeTable(pTab);",
          "6340:     pTab = 0;",
          "6341:   }",
          "6342:   return pTab;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6336:   int *pRc,",
          "6337:   int iRoot,",
          "6338:   int bIntkey,",
          "6340: ){",
          "6341:   sqlite3_stmt *pStmt = 0;",
          "6342:   RecoverTable *pRet = 0;",
          "",
          "[Removed Lines]",
          "6339:   int nCol",
          "",
          "[Added Lines]",
          "6350:   int nCol,",
          "6351:   int *pbNoop",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6344:   const char *zSql = 0;",
          "6345:   const char *zName = 0;",
          "6351:   shellPreparePrintf(pState->db, pRc, &pStmt,",
          "",
          "[Removed Lines]",
          "6347:   pRet = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6348:   if( pRet ) pRet->iPk = -2;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6360:     if( sqlite3_stricmp(zType, \"table\")==0 ){",
          "6361:       zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6362:       zSql = (const char*)sqlite3_column_text(pStmt, 2);",
          "6364:       break;",
          "6365:     }",
          "6366:   }",
          "6387:     );",
          "6392:     }",
          "6402:       }",
          "6403:     }",
          "6409:   }",
          "6412: }",
          "",
          "[Removed Lines]",
          "6363:       recoverOldTable(pRc, pRet, zName, zSql, bIntkey, nCol);",
          "6367:   shellFinalize(pRc, pStmt);",
          "6368:   if( bNoop ){",
          "6369:     sqlite3_free(pRet);",
          "6370:     return 0;",
          "6371:   }",
          "6373:   if( pRet && pRet->zName==0 ){",
          "6374:     sqlite3_stmt *pStmt = 0;",
          "6376:     pRet->zName = shellMPrintf(pRc, \"orphan_%d_%d\", nCol, iRoot);",
          "6377:     pRet->zQuoted = shellMPrintf(pRc, \"%Q\", pRet->zName);",
          "6378:     pRet->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * nCol);",
          "6379:     pRet->nCol = nCol;",
          "6381:     shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6382:       \"WITH s(i) AS (\"",
          "6383:       \"  SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<%d\"",
          "6384:       \")\"",
          "6385:       \"SELECT i-1, %Q || group_concat('c' || i, ', ') OVER (ORDER BY i) FROM s\",",
          "6386:       nCol, (bIntkey ? \"id, \" : \"\")",
          "6388:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6389:       int idx = sqlite3_column_int(pStmt, 0);",
          "6390:       const char *zText = (const char*)sqlite3_column_text(pStmt, 1);",
          "6391:       pRet->azlCol[idx] = shellMPrintf(pRc, \"%s\", zText);",
          "6393:     shellFinalize(pRc, pStmt);",
          "6395:     if( *pRc==SQLITE_OK ){",
          "6396:       char *zCreate = shellMPrintf(pRc, \"CREATE TABLE %Q (%s)\",",
          "6397:         pRet->zName, pRet->azlCol[nCol-1]",
          "6398:       );",
          "6399:       if( zCreate ){",
          "6400:         raw_printf(pState->out, \"%s;\\n\", zCreate);",
          "6401:         sqlite3_free(zCreate);",
          "6404:   }",
          "6406:   if( *pRc!=SQLITE_OK ){",
          "6407:     recoverFreeTable(pRet);",
          "6408:     pRet = 0;",
          "6411:   return pRet;",
          "",
          "[Added Lines]",
          "6373:       pRet = recoverOldTable(pRc, zName, zSql, bIntkey, nCol);",
          "6378:   shellFinalize(pRc, pStmt);",
          "6380:   return pRet;",
          "6381: }",
          "6383: static RecoverTable *recoverOrphanTable(",
          "6384:   ShellState *pState,",
          "6385:   int *pRc,",
          "6386:   int nCol",
          "6387: ){",
          "6388:   RecoverTable *pTab = 0;",
          "6389:   if( nCol>=0 && *pRc==SQLITE_OK ){",
          "6390:     int i;",
          "6391:     raw_printf(pState->out,",
          "6392:         \"CREATE TABLE recover_orphan(rootpgno INTEGER, \"",
          "6393:         \"pgno INTEGER, nfield INTEGER, id INTEGER\"",
          "6395:     for(i=0; i<nCol; i++){",
          "6396:       raw_printf(pState->out, \", c%d\", i);",
          "6398:     raw_printf(pState->out, \");\\n\");",
          "6400:     pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6401:     if( pTab ){",
          "6402:       pTab->zName = shellMPrintf(pRc, \"%s\", \"recover_orphan\");",
          "6403:       pTab->zQuoted = shellMPrintf(pRc, \"%Q\", pTab->zName);",
          "6404:       pTab->nCol = nCol;",
          "6405:       pTab->iPk = -2;",
          "6406:       if( nCol>0 ){",
          "6407:         pTab->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * (nCol+1));",
          "6408:         if( pTab->azlCol ){",
          "6409:           pTab->azlCol[nCol] = shellMPrintf(pRc, \"\");",
          "6410:           for(i=nCol-1; i>=0; i--){",
          "6411:             pTab->azlCol[i] = shellMPrintf(pRc, \"%s, NULL\", pTab->azlCol[i+1]);",
          "6412:           }",
          "6413:         }",
          "6417:     if( *pRc!=SQLITE_OK ){",
          "6418:       recoverFreeTable(pTab);",
          "6419:       pTab = 0;",
          "6420:     }",
          "6422:   return pTab;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6425:   int i;",
          "6428:   for(i=1; i<nArg; i++){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6437:   int nOrphan = -1;",
          "6438:   RecoverTable *pOrphan = 0;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6545:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6546:     \")\"",
          "6547:     \"GROUP BY pgno, cell;\"",
          "6548:   );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6561:     \"CREATE INDEX recovery.schema_rootpage ON schema(rootpage);\"",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6566:     shellFinalize(&rc, pStmt);",
          "6567:   }",
          "6569:   shellPrepare(pState->db, &rc,",
          "6570:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "6571:   );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6585:   shellPrepare(pState->db, &rc,",
          "6586:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map\"",
          "6587:       \"  WHERE root>1 AND root NOT IN (SELECT rootpage FROM recovery.schema)\"",
          "6588:       , &pLoop",
          "6589:   );",
          "6590:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6591:     nOrphan = sqlite3_column_int(pLoop, 0);",
          "6592:   }",
          "6593:   shellFinalize(&rc, pLoop);",
          "6594:   pLoop = 0;",
          "6595:   pOrphan = recoverOrphanTable(pState, &rc, nOrphan);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "6586:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6587:     int bIntkey = sqlite3_column_int(pLoop, 1);",
          "6588:     int nCol = sqlite3_column_int(pLoop, 2);",
          "6589:     RecoverTable *pTab;",
          "6603:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6605:           );",
          "6606:         }",
          "6608:       }",
          "6610:     }",
          "6612:   }",
          "6613:   shellFinalize(&rc, pLoop);",
          "6614:   shellFinalize(&rc, pPages);",
          "6615:   shellFinalize(&rc, pCells);",
          "6618:   if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "6591:     pTab = recoverNewTable(pState, &rc, iRoot, bIntkey, nCol);",
          "6592:     if( pTab ){",
          "6593:       if( 0==sqlite3_stricmp(pTab->zName, \"sqlite_sequence\") ){",
          "6594:         raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6595:       }",
          "6596:       sqlite3_bind_int(pPages, 1, iRoot);",
          "6597:       sqlite3_bind_int(pCells, 2, pTab->iPk);",
          "6598:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){",
          "6599:         sqlite3_bind_int(pCells, 1, sqlite3_column_int(pPages, 0));",
          "6600:         while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6601:           int iMax = sqlite3_column_int(pCells, 0);",
          "6602:           const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6604:               pTab->zQuoted, pTab->azlCol[iMax>0?iMax:0], zVal",
          "6607:         shellReset(&rc, pCells);",
          "6609:       shellReset(&rc, pPages);",
          "6611:     recoverFreeTable(pTab);",
          "",
          "[Added Lines]",
          "6617:     int bNoop = 0;",
          "6620:     pTab = recoverNewTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6621:     if( bNoop || rc ) continue;",
          "6622:     if( pTab==0 ) pTab = pOrphan;",
          "6624:     if( 0==sqlite3_stricmp(pTab->zName, \"sqlite_sequence\") ){",
          "6625:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6626:     }",
          "6627:     sqlite3_bind_int(pPages, 1, iRoot);",
          "6628:     sqlite3_bind_int(pCells, 2, pTab->iPk);",
          "6630:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){",
          "6631:       int iPgno = sqlite3_column_int(pPages, 0);",
          "6632:       sqlite3_bind_int(pCells, 1, iPgno);",
          "6633:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6634:         int nField = sqlite3_column_int(pCells, 0);",
          "6635:         const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6637:         nField = nField+1;",
          "6638:         if( pTab==pOrphan ){",
          "6639:           raw_printf(pState->out,",
          "6640:               \"INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\\n\",",
          "6641:               pTab->zQuoted, iRoot, iPgno, nField,",
          "6642:               bIntkey ? \"\" : \"NULL, \", zVal, pTab->azlCol[nField]",
          "6643:           );",
          "6644:         }else{",
          "6646:               pTab->zQuoted, pTab->azlCol[nField], zVal",
          "6650:       shellReset(&rc, pCells);",
          "6652:     shellReset(&rc, pPages);",
          "6653:     if( pTab!=pOrphan ) recoverFreeTable(pTab);",
          "6658:   recoverFreeTable(pOrphan);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "41422656450bed94abee2edf1df83660325afc5c",
      "candidate_info": {
        "commit_hash": "41422656450bed94abee2edf1df83660325afc5c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/41422656450bed94abee2edf1df83660325afc5c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "test/fuzzdata8.db"
        ],
        "message": "Ensure that the BtShared.nPage value is reset correctly on a SAVEPOINT ROLLBACK.\n\nFossilOrigin-Name: e6d5fee8cdbdce8515957e8288e4d1e7b06f417fd3f9deeeb636fbf5b995af51",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7e4809eadfe99ebfd797a7c63501421021a720bbeed9fba81bebf630c58bb791",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4153:   return rc;",
          "4154: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4160: static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){",
          "4161:   int nPage = get4byte(&pPage1->aData[28]);",
          "4162:   testcase( nPage==0 );",
          "4163:   if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);",
          "4164:   testcase( pBt->nPage!=nPage );",
          "4165:   pBt->nPage = nPage;",
          "4166: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4200:     if( btreeGetPage(pBt, 1, &pPage1, 0)==SQLITE_OK ){",
          "4206:       releasePageOne(pPage1);",
          "4207:     }",
          "4208:     assert( countValidCursors(pBt, 1)==0 );",
          "",
          "[Removed Lines]",
          "4201:       int nPage = get4byte(28+(u8*)pPage1->aData);",
          "4202:       testcase( nPage==0 );",
          "4203:       if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);",
          "4204:       testcase( pBt->nPage!=nPage );",
          "4205:       pBt->nPage = nPage;",
          "",
          "[Added Lines]",
          "4213:       btreeSetNPage(pBt, pPage1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4282:         pBt->nPage = 0;",
          "4283:       }",
          "4284:       rc = newDatabase(pBt);",
          "",
          "[Removed Lines]",
          "4285:       pBt->nPage = get4byte(28 + pBt->pPage1->aData);",
          "",
          "[Added Lines]",
          "4293:       btreeSetNPage(pBt, pBt->pPage1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "de21ad704a15098f33b213ce37680f975eea67d5",
      "candidate_info": {
        "commit_hash": "de21ad704a15098f33b213ce37680f975eea67d5",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/de21ad704a15098f33b213ce37680f975eea67d5",
        "files": [
          "ext/fts5/test/fts5corrupt3.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Fix a test script problem in fts5corrupt3.test.\n\nFossilOrigin-Name: 858f62274eb727109d0452ad2d80c0e0acab0f569494b1218c404501e103ed39",
        "before_after_code_files": [
          "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test": [
          "File: ext/fts5/test/fts5corrupt3.test -> ext/fts5/test/fts5corrupt3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "7994: | end crash-2acc487d09f033.db",
          "7995: }]} {}",
          "8000: } {1 {database disk image is malformed}}",
          "8002: #-------------------------------------------------------------------------",
          "",
          "[Removed Lines]",
          "7997: do_catchsql_test 56.1 {",
          "7998:   INSERT INTO t1(b) VALUES(randomblob(250));",
          "7999:   INSERT INTO t1(b) VALUES(randomblob(250));",
          "",
          "[Added Lines]",
          "7997: do_test 56.1 {",
          "7998:   set res [catchsql {",
          "7999:     INSERT INTO t1(b) VALUES(randomblob(250));",
          "8000:     INSERT INTO t1(b) VALUES(randomblob(250));",
          "8001:   }]",
          "8003:   # For some permutations - those that use the page-cache - this test",
          "8004:   # may return SQLITE_CONSTRAINT instead of SQLITE_CORRUPT. This is because",
          "8005:   # the corrupt db in the test over-reads the page buffer slightly, with",
          "8006:   # different results depending on whether or not the page-cache is in use.",
          "8007:   if {$res==\"1 {constraint failed}\"} {",
          "8008:     set res \"1 {database disk image is malformed}\"",
          "8009:   }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 593a7e6e20a2f91fe3497edd7effad50ac876f7f03c9222e332dfeb43d26882e",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ec722c1088769846a58cc3c2b277222249e92c08",
      "candidate_info": {
        "commit_hash": "ec722c1088769846a58cc3c2b277222249e92c08",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ec722c1088769846a58cc3c2b277222249e92c08",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Do not change the OP_String8 opcode into OP_String until *after* any necessary encoding conversions are accomplished.  Otherwise, a rerun of the prepared statement after an OOM can result in errors.  Test case in TH3.\n\nFossilOrigin-Name: 8efd62594eae725decb719aa7777c020f982b7cdc2c92bab3b91bf349a5bc298",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ca0e3a83a1c015b346a791e6de03904d17a769c52dad0e3d71316c6e2e3f43c7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1144:   assert( pOp->p4.z!=0 );",
          "1145:   pOut = out2Prerelease(p, pOp);",
          "1147:   pOp->p1 = sqlite3Strlen30(pOp->p4.z);",
          "1149: #ifndef SQLITE_OMIT_UTF16",
          "",
          "[Removed Lines]",
          "1146:   pOp->opcode = OP_String;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1167:   if( pOp->p1>db->aLimit[SQLITE_LIMIT_LENGTH] ){",
          "1168:     goto too_big;",
          "1169:   }",
          "1170:   assert( rc==SQLITE_OK );",
          "1172: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1169:   pOp->opcode = OP_String;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ec796d00228854511e3e19772a477e19c99aaac",
      "candidate_info": {
        "commit_hash": "7ec796d00228854511e3e19772a477e19c99aaac",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/7ec796d00228854511e3e19772a477e19c99aaac",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "test/in.test"
        ],
        "message": "Add ALWAYS() to an always true conditional that results from the previous check-in.  Add a test case for ticket [dbaf8a6820be1ece] to supplement those already checked into TH3.\n\nFossilOrigin-Name: aff209804722ac902c7abfde80ad2677e0f51beb2c7f28f65d51105d984a1640",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "test/in.test||test/in.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7f5168a76a400fc2e1e40c6950470b1bfb38a0be54fc5518c17c29fdae7d8f1f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "802:         idxCols |= cMask;",
          "803:         pIdx->aiColumn[n] = pTerm->u.leftColumn;",
          "804:         pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);",
          "806:         n++;",
          "807:       }",
          "808:     }",
          "",
          "[Removed Lines]",
          "805:         pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;",
          "",
          "[Added Lines]",
          "805:         pIdx->azColl[n] = ALWAYS(pColl) ? pColl->zName : sqlite3StrBINARY;",
          "",
          "---------------"
        ],
        "test/in.test||test/in.test": [
          "File: test/in.test -> test/in.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "750:   SELECT 1 IN (CAST('1' AS text) COLLATE nocase);",
          "751: } 0",
          "753: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753: # 2019-08-27 ticket https://sqlite.org/src/info/dbaf8a6820be1ece",
          "754: #",
          "755: do_execsql_test in-18.1 {",
          "756:   DROP TABLE IF EXISTS t0;",
          "757:   CREATE TABLE t0(c0 INT UNIQUE);",
          "758:   INSERT INTO t0(c0) VALUES (1);",
          "759:   SELECT * FROM t0 WHERE '1' IN (t0.c0);",
          "760: } {}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19242",
  "cve_desc": "SQLite 3.30.1 mishandles pExpr->y.pTab, as demonstrated by the TK_COLUMN case in sqlite3ExprCodeTarget in expr.c.",
  "repo": "sqlite/sqlite",
  "patch_hash": "57f7ece78410a8aae86aa4625fb7556897db384c",
  "patch_info": {
    "commit_hash": "57f7ece78410a8aae86aa4625fb7556897db384c",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/57f7ece78410a8aae86aa4625fb7556897db384c",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/wherecode.c",
      "test/gencol1.test"
    ],
    "message": "Fix a problem that comes up when using generated columns that evaluate to a constant in an index and then making use of that index in a join.\n\nFossilOrigin-Name: 8b12e95fec7ce6e0de82a04ca3dfcf1a8e62e233b7382aa28a8a9be6e862b1af",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/wherecode.c||src/wherecode.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 2d53a30cc23e53033af8e8666457654db5dcc453ed6cd176ce1d0bff4f528159",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3607:         int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);",
      "3609:         if( aff>SQLITE_AFF_BLOB ){",
      "3610:           static const char zAff[] = \"B\\000C\\000D\\000E\";",
      "3611:           assert( SQLITE_AFF_BLOB=='A' );",
      "",
      "[Removed Lines]",
      "3608:         int aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);",
      "",
      "[Added Lines]",
      "3608:         int aff;",
      "3609:         if( pExpr->y.pTab ){",
      "3610:           aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);",
      "3611:         }else{",
      "3612:           aff = pExpr->affExpr;",
      "3613:         }",
      "",
      "---------------"
    ],
    "src/wherecode.c||src/wherecode.c": [
      "File: src/wherecode.c -> src/wherecode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1141:   if( pExpr->op==TK_COLUMN ){",
      "1142:     IdxExprTrans *pX = p->u.pIdxTrans;",
      "1143:     if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){",
      "1144:       pExpr->iTable = pX->iIdxCur;",
      "1145:       pExpr->iColumn = pX->iIdxCol;",
      "1146:       pExpr->y.pTab = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1144:       assert( pExpr->y.pTab!=0 );",
      "1145:       pExpr->affExpr = sqlite3TableColumnAffinity(pExpr->y.pTab,pExpr->iColumn);",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "243:   UPDATE t0 SET c0 = NULL;",
      "244: } {1 {generated column loop on \"c2\"}}",
      "247: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "246: # 2019-11-21 Problems in the new generated column logic",
      "247: # reported by Yongheng Chen and Rui Zhong",
      "248: do_execsql_test gencol1-9.10 {",
      "249:   DROP TABLE IF EXISTS t1;",
      "250:   DROP TABLE IF EXISTS t2;",
      "251:   CREATE TABLE t1(aa , bb AS (17) UNIQUE);",
      "252:   INSERT INTO t1 VALUES(17);",
      "253:   CREATE TABLE t2(cc);",
      "254:   INSERT INTO t2 VALUES(41);",
      "255:   SELECT * FROM t2 JOIN t1 WHERE t1.bb=t1.aa AND t1.bb=17;",
      "256: } {41 17 17}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ae104741257a7b32870bb9f1563bb5746db5ae3c",
      "candidate_info": {
        "commit_hash": "ae104741257a7b32870bb9f1563bb5746db5ae3c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ae104741257a7b32870bb9f1563bb5746db5ae3c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c"
        ],
        "message": "Fix possible integer overflow while running PRAGMA integrity_check on a database file with a badly corrupted freelist.\n\nFossilOrigin-Name: 395599116d801324f0763e59bc5e2fc8622aa5b7572e0c1c9a982efbb3cc8280",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 8ba3d9f38090c4bbbcffba1930e5c26f69ff61f49b72a4a5a59253d37341380f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9414:     }",
          "9415:     pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage);",
          "9416:     if( isFreeList ){",
          "9418: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "9419:       if( pCheck->pBt->autoVacuum ){",
          "9420:         checkPtrmap(pCheck, iPage, PTRMAP_FREEPAGE, 0);",
          "9421:       }",
          "9422: #endif",
          "9424:         checkAppendMsg(pCheck,",
          "9425:            \"freelist leaf count too big on page %d\", iPage);",
          "9426:         N--;",
          "9427:       }else{",
          "9429:           Pgno iFreePage = get4byte(&pOvflData[8+i*4]);",
          "9430: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "9431:           if( pCheck->pBt->autoVacuum ){",
          "",
          "[Removed Lines]",
          "9417:       int n = get4byte(&pOvflData[4]);",
          "9423:       if( n>(int)pCheck->pBt->usableSize/4-2 ){",
          "9428:         for(i=0; i<n; i++){",
          "",
          "[Added Lines]",
          "9417:       u32 n = (u32)get4byte(&pOvflData[4]);",
          "9423:       if( n>pCheck->pBt->usableSize/4-2 ){",
          "9428:         for(i=0; i<(int)n; i++){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c7d12f4ad4283f1b3a09d140c489319c9d2eb8f8",
      "candidate_info": {
        "commit_hash": "c7d12f4ad4283f1b3a09d140c489319c9d2eb8f8",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c7d12f4ad4283f1b3a09d140c489319c9d2eb8f8",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "src/whereInt.h",
          "src/whereexpr.c",
          "test/index6.test"
        ],
        "message": "When we play games with COLLATE in order to commute an operator in the WHERE clause processing, be sure not to use the commuted operator to qualify a partial index, as insufficient COLLATE information is preserved to verify that the expression will correctly qualify the index. Ticket [767a8cbc6d20bd68]\n\nFossilOrigin-Name: 5351e920f489562f959ab8a376ff720f845ea165e0cdc7c3a271aac53c2aa64a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "src/whereInt.h||src/whereInt.h",
          "src/whereexpr.c||src/whereexpr.c",
          "test/index6.test||test/index6.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6e7b4527d32cc1be0294614b9d7363d4b59cf654a954b86515b3f6888975ce73",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2800:   }",
          "2801:   if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;",
          "2802:   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){",
          "2804:     if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)",
          "2805:      && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)",
          "2806:     ){",
          "",
          "[Removed Lines]",
          "2803:     Expr *pExpr = pTerm->pExpr;",
          "",
          "[Added Lines]",
          "2803:     Expr *pExpr;",
          "2804:     if( pTerm->wtFlags & TERM_NOPARTIDX ) continue;",
          "2805:     pExpr = pTerm->pExpr;",
          "",
          "---------------"
        ],
        "src/whereInt.h||src/whereInt.h": [
          "File: src/whereInt.h -> src/whereInt.h"
        ],
        "src/whereexpr.c||src/whereexpr.c": [
          "File: src/whereexpr.c -> src/whereexpr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:   u16 expRight = (pExpr->pRight->flags & EP_Collate);",
          "123:   u16 expLeft = (pExpr->pLeft->flags & EP_Collate);",
          "124:   assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN );",
          "125:   if( expRight==expLeft ){",
          "",
          "[Removed Lines]",
          "121: static void exprCommute(Parse *pParse, Expr *pExpr){",
          "",
          "[Added Lines]",
          "126: static u16 exprCommute(Parse *pParse, Expr *pExpr){",
          "129:   u16 wtFlags = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:       pExpr->pRight->flags &= ~EP_Collate;",
          "131:     }else if( sqlite3ExprCollSeq(pParse, pExpr->pLeft)!=0 ){",
          "135:       pExpr->pLeft->flags |= EP_Collate;",
          "136:     }",
          "137:   }",
          "138:   SWAP(Expr*,pExpr->pRight,pExpr->pLeft);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137:       wtFlags |= TERM_NOPARTIDX;",
          "143:       wtFlags |= TERM_NOPARTIDX;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:     assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );",
          "145:     pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;",
          "146:   }",
          "147: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "155:   return wtFlags;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1140:         pDup = pExpr;",
          "1141:         pNew = pTerm;",
          "1142:       }",
          "1144:       pNew->leftCursor = aiCurCol[0];",
          "1145:       pNew->u.leftColumn = aiCurCol[1];",
          "1146:       testcase( (prereqLeft | extraRight) != prereqLeft );",
          "",
          "[Removed Lines]",
          "1143:       exprCommute(pParse, pDup);",
          "",
          "[Added Lines]",
          "1152:       pNew->wtFlags |= exprCommute(pParse, pDup);",
          "",
          "---------------"
        ],
        "test/index6.test||test/index6.test": [
          "File: test/index6.test -> test/index6.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "462:   SELECT 1 FROM t0 WHERE (c0 IS FALSE) IN (FALSE);",
          "463: } {1}",
          "466: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "465: # 2019-09-03",
          "466: # Ticket https://sqlite.org/src/info/767a8cbc6d20bd68",
          "467: do_execsql_test index6-16.1 {",
          "468:   DROP TABLE t0;",
          "469:   CREATE TABLE t0(c0 COLLATE NOCASE, c1);",
          "470:   CREATE INDEX i0 ON t0(0) WHERE c0 >= c1;",
          "471:   INSERT INTO t0 VALUES('a', 'B');",
          "472:   SELECT c1 <= c0, c0 >= c1 FROM t0;",
          "473: } {1 0}",
          "474: do_execsql_test index6-16.2 {",
          "475:   SELECT 2 FROM t0 WHERE c0 >= c1;",
          "476: } {}",
          "477: do_execsql_test index6-16.3 {",
          "478:   SELECT 3 FROM t0 WHERE c1 <= c0;",
          "479: } {3}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "920cf596e67ecccecb497cfa60cc65945048f866",
      "candidate_info": {
        "commit_hash": "920cf596e67ecccecb497cfa60cc65945048f866",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/920cf596e67ecccecb497cfa60cc65945048f866",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/analyze.c",
          "src/attach.c",
          "src/expr.c",
          "src/vdbe.c",
          "src/vdbe.h",
          "src/vdbeaux.c"
        ],
        "message": "Simplify the bytecode generation for SQL function calls such that the OP_Function or OP_PureFunc opcodes are coded directly, rather than using the intermediate OP_Function0 or OP_PureFunc0 - opcodes that are now removed.\n\nFossilOrigin-Name: 84e02d773d60cffe619104991d21d7f0c68616c0f6bb99686bf54f5306c756d0",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/analyze.c||src/analyze.c",
          "src/attach.c||src/attach.c",
          "src/expr.c||src/expr.c",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbe.h||src/vdbe.h",
          "src/vdbeaux.c||src/vdbeaux.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 13fe6978b7de208d2e27460d824f7fc778cf6ea0aabfe566b32bb410b8816f63",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/analyze.c||src/analyze.c": [
          "File: src/analyze.c -> src/analyze.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "916:   {0}",
          "917: };",
          "921: #ifdef SQLITE_ENABLE_STAT4",
          "923: #elif SQLITE_DEBUG",
          "924:   assert( iParam==STAT_GET_STAT1 );",
          "925: #else",
          "926:   UNUSED_PARAMETER( iParam );",
          "927: #endif",
          "931: }",
          "",
          "[Removed Lines]",
          "919: static void callStatGet(Vdbe *v, int regStat4, int iParam, int regOut){",
          "920:   assert( regOut!=regStat4 && regOut!=regStat4+1 );",
          "922:   sqlite3VdbeAddOp2(v, OP_Integer, iParam, regStat4+1);",
          "928:   sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4, regOut,",
          "929:                     (char*)&statGetFuncdef, P4_FUNCDEF);",
          "930:   sqlite3VdbeChangeP5(v, 1 + IsStat4);",
          "",
          "[Added Lines]",
          "919: static void callStatGet(Parse *pParse, int regStat4, int iParam, int regOut){",
          "921:   sqlite3VdbeAddOp2(pParse->pVdbe, OP_Integer, iParam, regStat4+1);",
          "927:   assert( regOut!=regStat4 && regOut!=regStat4+1 );",
          "928:   sqlite3VdbeAddFunctionCall(pParse, 0, regStat4, regOut, 1+IsStat4,",
          "929:                              &statGetFuncdef, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1095: #endif",
          "1096:     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat4+1);",
          "1097:     sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regStat4+2);",
          "",
          "[Removed Lines]",
          "1098:     sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4+1, regStat4,",
          "1099:                      (char*)&statInitFuncdef, P4_FUNCDEF);",
          "1100:     sqlite3VdbeChangeP5(v, 2+IsStat4);",
          "",
          "[Added Lines]",
          "1097:     sqlite3VdbeAddFunctionCall(pParse, 0, regStat4+1, regStat4, 2+IsStat4,",
          "1098:                                &statInitFuncdef, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1192:     }",
          "1193: #endif",
          "1194:     assert( regChng==(regStat4+1) );",
          "1198:     sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);",
          "1202:     assert( \"BBB\"[0]==SQLITE_AFF_TEXT );",
          "1203:     sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, \"BBB\", 0);",
          "1204:     sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);",
          "",
          "[Removed Lines]",
          "1195:     sqlite3VdbeAddOp4(v, OP_Function0, 1, regStat4, regTemp,",
          "1196:                      (char*)&statPushFuncdef, P4_FUNCDEF);",
          "1197:     sqlite3VdbeChangeP5(v, 2+IsStat4);",
          "1201:     callStatGet(v, regStat4, STAT_GET_STAT1, regStat1);",
          "",
          "[Added Lines]",
          "1193:     sqlite3VdbeAddFunctionCall(pParse, 1, regStat4, regTemp, 2+IsStat4,",
          "1194:                                &statPushFuncdef, 0);",
          "1198:     callStatGet(pParse, regStat4, STAT_GET_STAT1, regStat1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1224:       pParse->nMem = MAX(pParse->nMem, regCol+nCol);",
          "1226:       addrNext = sqlite3VdbeCurrentAddr(v);",
          "1228:       addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);",
          "1229:       VdbeCoverage(v);",
          "1233:       sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);",
          "1234:       VdbeCoverage(v);",
          "1235:       for(i=0; i<nCol; i++){",
          "",
          "[Removed Lines]",
          "1227:       callStatGet(v, regStat4, STAT_GET_ROWID, regSampleRowid);",
          "1230:       callStatGet(v, regStat4, STAT_GET_NEQ, regEq);",
          "1231:       callStatGet(v, regStat4, STAT_GET_NLT, regLt);",
          "1232:       callStatGet(v, regStat4, STAT_GET_NDLT, regDLt);",
          "",
          "[Added Lines]",
          "1224:       callStatGet(pParse, regStat4, STAT_GET_ROWID, regSampleRowid);",
          "1227:       callStatGet(pParse, regStat4, STAT_GET_NEQ, regEq);",
          "1228:       callStatGet(pParse, regStat4, STAT_GET_NLT, regLt);",
          "1229:       callStatGet(pParse, regStat4, STAT_GET_NDLT, regDLt);",
          "",
          "---------------"
        ],
        "src/attach.c||src/attach.c": [
          "File: src/attach.c -> src/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "402:   assert( v || db->mallocFailed );",
          "403:   if( v ){",
          "",
          "[Removed Lines]",
          "404:     sqlite3VdbeAddOp4(v, OP_Function0, 0, regArgs+3-pFunc->nArg, regArgs+3,",
          "405:                       (char *)pFunc, P4_FUNCDEF);",
          "406:     assert( pFunc->nArg==-1 || (pFunc->nArg&0xff)==pFunc->nArg );",
          "407:     sqlite3VdbeChangeP5(v, (u8)(pFunc->nArg));",
          "",
          "[Added Lines]",
          "404:     sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,",
          "405:                                pFunc->nArg, pFunc, 0);",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4032:       }else",
          "4033: #endif",
          "4034:       {",
          "4038:       }",
          "4039:       if( nFarg && constMask==0 ){",
          "4040:         sqlite3ReleaseTempRange(pParse, r1, nFarg);",
          "",
          "[Removed Lines]",
          "4035:         sqlite3VdbeAddOp4(v, pParse->iSelfTab ? OP_PureFunc0 : OP_Function0,",
          "4036:                           constMask, r1, target, (char*)pDef, P4_FUNCDEF);",
          "4037:         sqlite3VdbeChangeP5(v, (u8)nFarg);",
          "",
          "[Added Lines]",
          "4035:         sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,",
          "4036:                                    pDef, pParse->iSelfTab);",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7513:   int i;",
          "",
          "[Removed Lines]",
          "7488:   int n;",
          "7489:   sqlite3_context *pCtx;",
          "7491:   assert( pOp->p4type==P4_FUNCDEF );",
          "7492:   n = pOp->p5;",
          "7493:   assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );",
          "7494:   assert( n==0 || (pOp->p2>0 && pOp->p2+n<=(p->nMem+1 - p->nCursor)+1) );",
          "7495:   assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n );",
          "7496:   pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*));",
          "7497:   if( pCtx==0 ) goto no_mem;",
          "7498:   pCtx->pOut = 0;",
          "7499:   pCtx->pFunc = pOp->p4.pFunc;",
          "7500:   pCtx->iOp = (int)(pOp - aOp);",
          "7501:   pCtx->pVdbe = p;",
          "7502:   pCtx->isError = 0;",
          "7503:   pCtx->argc = n;",
          "7504:   pOp->p4type = P4_FUNCCTX;",
          "7505:   pOp->p4.pCtx = pCtx;",
          "7506:   assert( OP_PureFunc == OP_PureFunc0+2 );",
          "7507:   assert( OP_Function == OP_Function0+2 );",
          "7508:   pOp->opcode += 2;",
          "7510: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7523:   pOut = &aMem[pOp->p3];",
          "7524:   if( pCtx->pOut != pOut ){",
          "7525:     pCtx->pOut = pOut;",
          "7526:     for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];",
          "7527:   }",
          "7529:   memAboutToChange(p, pOut);",
          "7530: #ifdef SQLITE_DEBUG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7505:     pCtx->pVdbe = p;",
          "7509:   assert( pCtx->pVdbe==p );",
          "",
          "---------------"
        ],
        "src/vdbe.h||src/vdbe.h": [
          "File: src/vdbe.h -> src/vdbe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);",
          "191: int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);",
          "192: int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);",
          "193: void sqlite3VdbeEndCoroutine(Vdbe*,int);",
          "194: #if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)",
          "195:   void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: int sqlite3VdbeAddFunctionCall(Parse*,int,int,int,int,const FuncDef*,int);",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include \"sqliteInt.h\"",
          "16: #include \"vdbeInt.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef);",
          "20: static void vdbeFreeOpArray(sqlite3 *, Op *, int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "328:   return addr;",
          "329: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345: int sqlite3VdbeAddFunctionCall(",
          "353: ){",
          "354:   Vdbe *v = pParse->pVdbe;",
          "355:   int nByte;",
          "356:   int addr;",
          "357:   sqlite3_context *pCtx;",
          "358:   assert( v );",
          "359:   nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);",
          "360:   pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);",
          "361:   if( pCtx==0 ){",
          "362:     assert( pParse->db->mallocFailed );",
          "363:     freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);",
          "364:     return 0;",
          "365:   }",
          "366:   pCtx->pOut = 0;",
          "367:   pCtx->pFunc = (FuncDef*)pFunc;",
          "368:   pCtx->pVdbe = v;",
          "369:   pCtx->isError = 0;",
          "370:   pCtx->argc = nArg;",
          "371:   addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,",
          "372:                            p1, p2, p3, (char*)pCtx, P4_FUNCCTX);",
          "373:   pCtx->iOp = addr;",
          "374:   return addr;",
          "375: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1020:   }",
          "1021: }",
          "",
          "[Removed Lines]",
          "1023: static void vdbeFreeOpArray(sqlite3 *, Op *, int);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1031: }",
          "1032: static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){",
          "1033:   freeEphemeralFunction(db, p->pFunc);",
          "1035: }",
          "1036: static void freeP4(sqlite3 *db, int p4type, void *p4){",
          "1037:   assert( db );",
          "",
          "[Removed Lines]",
          "1034:  sqlite3DbFreeNN(db, p);",
          "",
          "[Added Lines]",
          "1078:   sqlite3DbFreeNN(db, p);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1537:       sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);",
          "1538:       break;",
          "1539:     }",
          "1541:     case P4_FUNCCTX: {",
          "1542:       FuncDef *pDef = pOp->p4.pCtx->pFunc;",
          "1543:       sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);",
          "1544:       break;",
          "1545:     }",
          "1547:     case P4_INT64: {",
          "1548:       sqlite3_str_appendf(&x, \"%lld\", *pOp->p4.pI64);",
          "1549:       break;",
          "",
          "[Removed Lines]",
          "1540: #if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)",
          "1546: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4961:   if( pCtx->pVdbe==0 ) return 1;",
          "4962: #endif",
          "4963:   if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==OP_PureFunc ){",
          "4964:     sqlite3_result_error(pCtx,",
          "4965:        \"non-deterministic function in index expression or CHECK constraint\",",
          "4966:        -1);",
          "4967:     return 0;",
          "4968:   }",
          "4969:   return 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5006: #if 0",
          "5007:     char *zMsg = sqlite3_mprintf(",
          "5008:        \"non-deterministic use of %s() in an index, CHECK constraint, \"",
          "5009:        \"or generated column\", pCtx->pFunc->zName);",
          "5010:     sqlite3_result_error(pCtx, zMsg, -1);",
          "5011:     sqlite3_free(zMsg);",
          "5012: #else",
          "5016: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a7c3b93fa634109dafd4170373d838faf6008d8a",
      "candidate_info": {
        "commit_hash": "a7c3b93fa634109dafd4170373d838faf6008d8a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a7c3b93fa634109dafd4170373d838faf6008d8a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c",
          "src/update.c"
        ],
        "message": "On an INSERT or UPDATE, generate the new table record prior to running foreign key checks, in case the foreign key checks changes datatypes on the registers holding column values.  Proposed fix for ticket [e63cbcfd3378afe6980d626].\n\nFossilOrigin-Name: 3f1c8051648a341db4dffad66d3b1f9980d8a2b314cb0ce879cb2a10d1779b84",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c",
          "src/update.c||src/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 8b6691f619ed9a56f6aecbd878ebb447c40984f8767508b248494fd9ec68fbaa",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "814:     int nIdx;",
          "815:     nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,",
          "816:                                       &iDataCur, &iIdxCur);",
          "818:     if( aRegIdx==0 ){",
          "819:       goto insert_cleanup;",
          "820:     }",
          "",
          "[Removed Lines]",
          "817:     aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+1));",
          "",
          "[Added Lines]",
          "817:     aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1845:     sqlite3VdbeJumpHere(v, ipkBottom);",
          "1846:   }",
          "1849:   VdbeModuleComment((v, \"END: GenCnstCks(%d)\", seenReplace));",
          "1850: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1858:   if( HasRowid(pTab) ){",
          "1859:     int regRec = aRegIdx[ix];",
          "1860:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nCol, regRec);",
          "1861:     sqlite3SetMakeRecordP5(v, pTab);",
          "1862:     if( !bAffinityDone ){",
          "1863:       sqlite3TableAffinity(v, pTab, 0);",
          "1864:     }",
          "1865:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1910:   for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){",
          "1911:     if( aRegIdx[i]==0 ) continue;",
          "1913:     if( pIdx->pPartIdxWhere ){",
          "1914:       sqlite3VdbeAddOp2(v, OP_IsNull, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);",
          "1915:       VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "1912:     bAffinityDone = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1937:     sqlite3VdbeChangeP5(v, pik_flags);",
          "1938:   }",
          "1939:   if( !HasRowid(pTab) ) return;",
          "1947:   if( pParse->nested ){",
          "1948:     pik_flags = 0;",
          "1949:   }else{",
          "",
          "[Removed Lines]",
          "1940:   regData = regNewData + 1;",
          "1941:   regRec = sqlite3GetTempReg(pParse);",
          "1942:   sqlite3VdbeAddOp3(v, OP_MakeRecord, regData, pTab->nCol, regRec);",
          "1943:   sqlite3SetMakeRecordP5(v, pTab);",
          "1944:   if( !bAffinityDone ){",
          "1945:     sqlite3TableAffinity(v, pTab, 0);",
          "1946:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1956:   if( useSeekResult ){",
          "1957:     pik_flags |= OPFLAG_USESEEKRESULT;",
          "1958:   }",
          "1960:   if( !pParse->nested ){",
          "1961:     sqlite3VdbeAppendP4(v, pTab, P4_TABLE);",
          "1962:   }",
          "",
          "[Removed Lines]",
          "1959:   sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, regRec, regNewData);",
          "",
          "[Added Lines]",
          "1967:   sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, aRegIdx[i], regNewData);",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277:   if( aXRef==0 ) goto update_cleanup;",
          "278:   aRegIdx = aXRef+pTab->nCol;",
          "280:   memset(aToOpen, 1, nIdx+1);",
          "281:   aToOpen[nIdx+1] = 0;",
          "282:   for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;",
          "",
          "[Removed Lines]",
          "276:   aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx) + nIdx+2 );",
          "279:   aToOpen = (u8*)(aRegIdx+nIdx);",
          "",
          "[Added Lines]",
          "276:   aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );",
          "279:   aToOpen = (u8*)(aRegIdx+nIdx+1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
      "candidate_info": {
        "commit_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1cf197583de15d352dc169437f619d2e4631cf4b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/malloc.c",
          "src/sqliteInt.h",
          "src/tokenize.c"
        ],
        "message": "Give the sqlite3 object a pointer to the current Parse so that if an OOM occurs, it can automatically set the Parse.rc value to SQLITE_NOMEM.  This avoids a frequent extra test of db.mallocFailed in the innermost parser loop.\n\nFossilOrigin-Name: 5c6638040b3017c6be016441422d965a3ca00dd6ae1f78cadc0b54562978f64e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/malloc.c||src/malloc.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/tokenize.c||src/tokenize.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 440a7cda000164d3b46109caf2e1dde80681ba9b0d94ba9be6847d2b917445cf",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/malloc.c||src/malloc.c": [
          "File: src/malloc.c -> src/malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "661:       db->u1.isInterrupted = 1;",
          "662:     }",
          "663:     db->lookaside.bDisable++;",
          "664:   }",
          "665: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "664:     if( db->pParse ){",
          "665:       db->pParse->rc = SQLITE_NOMEM_BKPT;",
          "666:     }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/tokenize.c||src/tokenize.c": [
          "File: src/tokenize.c -> src/tokenize.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "563: #ifdef sqlite3Parser_ENGINEALWAYSONSTACK",
          "565: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:   VVA_ONLY( u8 startedWithOom = db->mallocFailed );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "594:   assert( pParse->pNewTrigger==0 );",
          "595:   assert( pParse->nVar==0 );",
          "596:   assert( pParse->pVList==0 );",
          "597:   while( 1 ){",
          "598:     n = sqlite3GetToken((u8*)zSql, &tokenType);",
          "599:     mxSqlLen -= n;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "598:   pParse->pParentParse = db->pParse;",
          "599:   db->pParse = pParse;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "650:     sqlite3Parser(pEngine, tokenType, pParse->sLastToken);",
          "651:     lastTokenParsed = tokenType;",
          "652:     zSql += n;",
          "654:   }",
          "655:   assert( nErr==0 );",
          "656: #ifdef YYTRACKMAXSTACKDEPTH",
          "",
          "[Removed Lines]",
          "653:     if( pParse->rc!=SQLITE_OK || db->mallocFailed ) break;",
          "",
          "[Added Lines]",
          "656:     assert( db->mallocFailed==0 || pParse->rc!=SQLITE_OK || startedWithOom );",
          "657:     if( pParse->rc!=SQLITE_OK ) break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "718:     pParse->pZombieTab = p->pNextZombie;",
          "719:     sqlite3DeleteTable(db, p);",
          "720:   }",
          "721:   assert( nErr==0 || pParse->rc!=SQLITE_OK );",
          "722:   return nErr;",
          "723: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "725:   db->pParse = pParse->pParentParse;",
          "726:   pParse->pParentParse = 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
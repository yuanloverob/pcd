{
  "cve_id": "CVE-2018-18445",
  "cve_desc": "In the Linux kernel 4.14.x, 4.15.x, 4.16.x, 4.17.x, and 4.18.x before 4.18.13, faulty computation of numeric bounds in the BPF verifier permits out-of-bounds memory accesses because adjust_scalar_min_max_vals in kernel/bpf/verifier.c mishandles 32-bit right shifts.",
  "repo": "torvalds/linux",
  "patch_hash": "b799207e1e1816b09e7a5920fbb2d5fcf6edd681",
  "patch_info": {
    "commit_hash": "b799207e1e1816b09e7a5920fbb2d5fcf6edd681",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b799207e1e1816b09e7a5920fbb2d5fcf6edd681",
    "files": [
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: 32-bit RSH verification must truncate input before the ALU op\n\nWhen I wrote commit 468f6eafa6c4 (\"bpf: fix 32-bit ALU op verification\"), I\nassumed that, in order to emulate 64-bit arithmetic with 32-bit logic, it\nis sufficient to just truncate the output to 32 bits; and so I just moved\nthe register size coercion that used to be at the start of the function to\nthe end of the function.\n\nThat assumption is true for almost every op, but not for 32-bit right\nshifts, because those can propagate information towards the least\nsignificant bit. Fix it by always truncating inputs for 32-bit ops to 32\nbits.\n\nAlso get rid of the coerce_reg_to_size() after the ALU op, since that has\nno effect.\n\nFixes: 468f6eafa6c4 (\"bpf: fix 32-bit ALU op verification\")\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "before_after_code_files": [
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2896:  u64 umin_val, umax_val;",
      "2897:  u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;",
      "2899:  smin_val = src_reg.smin_value;",
      "2900:  smax_val = src_reg.smax_value;",
      "2901:  umin_val = src_reg.umin_value;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2899:  if (insn_bitness == 32) {",
      "2904:   coerce_reg_to_size(dst_reg, 4);",
      "2905:   coerce_reg_to_size(&src_reg, 4);",
      "2906:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3131:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
      "3133:   coerce_reg_to_size(dst_reg, 4);",
      "3135:  }",
      "3137:  __reg_deduce_bounds(dst_reg);",
      "",
      "[Removed Lines]",
      "3134:   coerce_reg_to_size(&src_reg, 4);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9cbe1f5a32dcd6d0508326f7d9098e5bc380a4fe",
      "candidate_info": {
        "commit_hash": "9cbe1f5a32dcd6d0508326f7d9098e5bc380a4fe",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9cbe1f5a32dcd6d0508326f7d9098e5bc380a4fe",
        "files": [
          "include/linux/tnum.h",
          "kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf/verifier: improve register value range tracking with ARSH\n\nWhen helpers like bpf_get_stack returns an int value\nand later on used for arithmetic computation, the LSH and ARSH\noperations are often required to get proper sign extension into\n64-bit. For example, without this patch:\n    54: R0=inv(id=0,umax_value=800)\n    54: (bf) r8 = r0\n    55: R0=inv(id=0,umax_value=800) R8_w=inv(id=0,umax_value=800)\n    55: (67) r8 <<= 32\n    56: R8_w=inv(id=0,umax_value=3435973836800,var_off=(0x0; 0x3ff00000000))\n    56: (c7) r8 s>>= 32\n    57: R8=inv(id=0)\nWith this patch:\n    54: R0=inv(id=0,umax_value=800)\n    54: (bf) r8 = r0\n    55: R0=inv(id=0,umax_value=800) R8_w=inv(id=0,umax_value=800)\n    55: (67) r8 <<= 32\n    56: R8_w=inv(id=0,umax_value=3435973836800,var_off=(0x0; 0x3ff00000000))\n    56: (c7) r8 s>>= 32\n    57: R8=inv(id=0, umax_value=800,var_off=(0x0; 0x3ff))\nWith better range of \"R8\", later on when \"R8\" is added to other register,\ne.g., a map pointer or scalar-value register, the better register\nrange can be derived and verifier failure may be avoided.\n\nIn our later example,\n    ......\n    usize = bpf_get_stack(ctx, raw_data, max_len, BPF_F_USER_STACK);\n    if (usize < 0)\n        return 0;\n    ksize = bpf_get_stack(ctx, raw_data + usize, max_len - usize, 0);\n    ......\nWithout improving ARSH value range tracking, the register representing\n\"max_len - usize\" will have smin_value equal to S64_MIN and will be\nrejected by verifier.\n\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Yonghong Song <yhs@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "include/linux/tnum.h||include/linux/tnum.h",
          "kernel/bpf/tnum.c||kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/tnum.h||include/linux/tnum.h": [
          "File: include/linux/tnum.h -> include/linux/tnum.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: struct tnum tnum_lshift(struct tnum a, u8 shift);",
          "27: struct tnum tnum_rshift(struct tnum a, u8 shift);",
          "29: struct tnum tnum_add(struct tnum a, struct tnum b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: struct tnum tnum_arshift(struct tnum a, u8 min_shift);",
          "",
          "---------------"
        ],
        "kernel/bpf/tnum.c||kernel/bpf/tnum.c": [
          "File: kernel/bpf/tnum.c -> kernel/bpf/tnum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:  return TNUM(a.value >> shift, a.mask >> shift);",
          "44: }",
          "46: struct tnum tnum_add(struct tnum a, struct tnum b)",
          "47: {",
          "48:  u64 sm, sv, sigma, chi, mu;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: struct tnum tnum_arshift(struct tnum a, u8 min_shift)",
          "47: {",
          "53:  return TNUM((s64)a.value >> min_shift, (s64)a.mask >> min_shift);",
          "54: }",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2975:   __update_reg_bounds(dst_reg);",
          "2976:   break;",
          "2977:  default:",
          "2978:   mark_reg_unknown(env, regs, insn->dst_reg);",
          "2979:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2977:  case BPF_ARSH:",
          "2978:   if (umax_val >= insn_bitness) {",
          "2982:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "2983:    break;",
          "2984:   }",
          "2989:   dst_reg->smin_value >>= umin_val;",
          "2990:   dst_reg->smax_value >>= umin_val;",
          "2991:   dst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);",
          "2996:   dst_reg->umin_value = 0;",
          "2997:   dst_reg->umax_value = U64_MAX;",
          "2998:   __update_reg_bounds(dst_reg);",
          "2999:   break;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-9731",
  "cve_desc": "The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing \\0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c.",
  "repo": "torvalds/linux",
  "patch_hash": "0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14",
  "patch_info": {
    "commit_hash": "0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14",
    "files": [
      "fs/udf/dir.c",
      "fs/udf/namei.c",
      "fs/udf/symlink.c",
      "fs/udf/udfdecl.h",
      "fs/udf/unicode.c"
    ],
    "message": "udf: Check path length when reading symlink\n\nSymlink reading code does not check whether the resulting path fits into\nthe page provided by the generic code. This isn't as easy as just\nchecking the symlink size because of various encoding conversions we\nperform on path. So we have to check whether there is still enough space\nin the buffer on the fly.\n\nCC: stable@vger.kernel.org\nReported-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nSigned-off-by: Jan Kara <jack@suse.cz>",
    "before_after_code_files": [
      "fs/udf/dir.c||fs/udf/dir.c",
      "fs/udf/namei.c||fs/udf/namei.c",
      "fs/udf/symlink.c||fs/udf/symlink.c",
      "fs/udf/udfdecl.h||fs/udf/udfdecl.h",
      "fs/udf/unicode.c||fs/udf/unicode.c"
    ]
  },
  "patch_diff": {
    "fs/udf/dir.c||fs/udf/dir.c": [
      "File: fs/udf/dir.c -> fs/udf/dir.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "167:    continue;",
      "168:   }",
      "171:   if (!flen)",
      "172:    continue;",
      "",
      "[Removed Lines]",
      "170:   flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);",
      "",
      "[Added Lines]",
      "170:   flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,",
      "171:      UDF_NAME_LEN);",
      "",
      "---------------"
    ],
    "fs/udf/namei.c||fs/udf/namei.c": [
      "File: fs/udf/namei.c -> fs/udf/namei.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "233:   if (!lfi)",
      "234:    continue;",
      "237:   if (flen && udf_match(flen, fname, child->len, child->name))",
      "238:    goto out_ok;",
      "239:  }",
      "",
      "[Removed Lines]",
      "236:   flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);",
      "",
      "[Added Lines]",
      "236:   flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,",
      "237:      UDF_NAME_LEN);",
      "",
      "---------------"
    ],
    "fs/udf/symlink.c||fs/udf/symlink.c": [
      "File: fs/udf/symlink.c -> fs/udf/symlink.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: #include <linux/buffer_head.h>",
      "31: #include \"udf_i.h\"",
      "35: {",
      "36:  struct pathComponent *pc;",
      "37:  int elen = 0;",
      "38:  unsigned char *p = to;",
      "40:  while (elen < fromlen) {",
      "41:   pc = (struct pathComponent *)(from + elen);",
      "42:   switch (pc->componentType) {",
      "",
      "[Removed Lines]",
      "33: static void udf_pc_to_char(struct super_block *sb, unsigned char *from,",
      "34:       int fromlen, unsigned char *to)",
      "",
      "[Added Lines]",
      "33: static int udf_pc_to_char(struct super_block *sb, unsigned char *from,",
      "34:      int fromlen, unsigned char *to, int tolen)",
      "38:  int comp_len;",
      "42:  tolen--;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "49:     break;",
      "51:   case 2:",
      "52:    p = to;",
      "54:    break;",
      "55:   case 3:",
      "56:    memcpy(p, \"../\", 3);",
      "57:    p += 3;",
      "58:    break;",
      "59:   case 4:",
      "60:    memcpy(p, \"./\", 2);",
      "61:    p += 2;",
      "63:    break;",
      "64:   case 5:",
      "68:    break;",
      "69:   }",
      "70:   elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;",
      "",
      "[Removed Lines]",
      "65:    p += udf_get_filename(sb, pc->componentIdent, p,",
      "66:            pc->lengthComponentIdent);",
      "",
      "[Added Lines]",
      "55:    if (tolen == 0)",
      "56:     return -ENAMETOOLONG;",
      "59:    tolen--;",
      "62:    if (tolen < 3)",
      "63:     return -ENAMETOOLONG;",
      "66:    tolen -= 3;",
      "69:    if (tolen < 2)",
      "70:     return -ENAMETOOLONG;",
      "73:    tolen -= 2;",
      "77:    comp_len = udf_get_filename(sb, pc->componentIdent,",
      "78:           pc->lengthComponentIdent,",
      "79:           p, tolen);",
      "80:    p += comp_len;",
      "81:    tolen -= comp_len;",
      "82:    if (tolen == 0)",
      "83:     return -ENAMETOOLONG;",
      "85:    tolen--;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "73:   p[-1] = '\\0';",
      "74:  else",
      "75:   p[0] = '\\0';",
      "76: }",
      "78: static int udf_symlink_filler(struct file *file, struct page *page)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "94:  return 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "108:   symlink = bh->b_data;",
      "109:  }",
      "112:  brelse(bh);",
      "114:  up_read(&iinfo->i_data_sem);",
      "115:  SetPageUptodate(page);",
      "",
      "[Removed Lines]",
      "111:  udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);",
      "",
      "[Added Lines]",
      "130:  err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);",
      "132:  if (err)",
      "133:   goto out_unlock_inode;",
      "",
      "---------------"
    ],
    "fs/udf/udfdecl.h||fs/udf/udfdecl.h": [
      "File: fs/udf/udfdecl.h -> fs/udf/udfdecl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "211: }",
      "215: extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,",
      "216:        int);",
      "217: extern int udf_build_ustr(struct ustr *, dstring *, int);",
      "",
      "[Removed Lines]",
      "214: extern int udf_get_filename(struct super_block *, uint8_t *, uint8_t *, int);",
      "",
      "[Added Lines]",
      "214: extern int udf_get_filename(struct super_block *, uint8_t *, int, uint8_t *,",
      "215:        int);",
      "",
      "---------------"
    ],
    "fs/udf/unicode.c||fs/udf/unicode.c": [
      "File: fs/udf/unicode.c -> fs/udf/unicode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #include \"udf_sb.h\"",
      "33: static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)",
      "34: {",
      "",
      "[Removed Lines]",
      "31: static int udf_translate_to_linux(uint8_t *, uint8_t *, int, uint8_t *, int);",
      "",
      "[Added Lines]",
      "31: static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,",
      "32:       int);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "333:  return u_len + 1;",
      "334: }",
      "338: {",
      "339:  struct ustr *filename, *unifilename;",
      "340:  int len = 0;",
      "",
      "[Removed Lines]",
      "336: int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,",
      "337:        int flen)",
      "",
      "[Added Lines]",
      "337: int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,",
      "338:        uint8_t *dname, int dlen)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "347:  if (!unifilename)",
      "348:   goto out1;",
      "351:   goto out2;",
      "353:  if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {",
      "",
      "[Removed Lines]",
      "350:  if (udf_build_ustr_exact(unifilename, sname, flen))",
      "",
      "[Added Lines]",
      "351:  if (udf_build_ustr_exact(unifilename, sname, slen))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "366:  } else",
      "367:   goto out2;",
      "370:          unifilename->u_name, unifilename->u_len);",
      "371: out2:",
      "372:  kfree(unifilename);",
      "",
      "[Removed Lines]",
      "369:  len = udf_translate_to_linux(dname, filename->u_name, filename->u_len,",
      "",
      "[Added Lines]",
      "370:  len = udf_translate_to_linux(dname, dlen,",
      "371:          filename->u_name, filename->u_len,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "403: #define EXT_MARK  '.'",
      "404: #define CRC_MARK  '#'",
      "405: #define EXT_SIZE   5",
      "410: {",
      "411:  int index, newIndex = 0, needsCRC = 0;",
      "412:  int extIndex = 0, newExtIndex = 0, hasExt = 0;",
      "",
      "[Removed Lines]",
      "407: static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,",
      "408:       int udfLen, uint8_t *fidName,",
      "409:       int fidNameLen)",
      "",
      "[Added Lines]",
      "409: #define CRC_LEN   5",
      "411: static int udf_translate_to_linux(uint8_t *newName, int newLen,",
      "412:       uint8_t *udfName, int udfLen,",
      "413:       uint8_t *fidName, int fidNameLen)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "439:      newExtIndex = newIndex;",
      "440:     }",
      "441:    }",
      "443:     newName[newIndex++] = curr;",
      "444:    else",
      "445:     needsCRC = 1;",
      "",
      "[Removed Lines]",
      "442:    if (newIndex < 256)",
      "",
      "[Added Lines]",
      "446:    if (newIndex < newLen)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "467:     }",
      "468:     ext[localExtIndex++] = curr;",
      "469:    }",
      "471:    if (newIndex > maxFilenameLen)",
      "472:     newIndex = maxFilenameLen;",
      "473:    else",
      "474:     newIndex = newExtIndex;",
      "477:   newName[newIndex++] = CRC_MARK;",
      "478:   valueCRC = crc_itu_t(0, fidName, fidNameLen);",
      "479:   newName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);",
      "",
      "[Removed Lines]",
      "470:    maxFilenameLen = 250 - localExtIndex;",
      "475:   } else if (newIndex > 250)",
      "476:    newIndex = 250;",
      "",
      "[Added Lines]",
      "474:    maxFilenameLen = newLen - CRC_LEN - localExtIndex;",
      "479:   } else if (newIndex > newLen - CRC_LEN)",
      "480:    newIndex = newLen - CRC_LEN;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a1d47b262952a45aae62bd49cfaf33dd76c11a2c",
      "candidate_info": {
        "commit_hash": "a1d47b262952a45aae62bd49cfaf33dd76c11a2c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a1d47b262952a45aae62bd49cfaf33dd76c11a2c",
        "files": [
          "fs/udf/symlink.c"
        ],
        "message": "udf: Verify symlink size before loading it\n\nUDF specification allows arbitrarily large symlinks. However we support\nonly symlinks at most one block large. Check the length of the symlink\nso that we don't access memory beyond end of the symlink block.\n\nCC: stable@vger.kernel.org\nReported-by: Carl Henrik Lunde <chlunde@gmail.com>\nSigned-off-by: Jan Kara <jack@suse.cz>",
        "before_after_code_files": [
          "fs/udf/symlink.c||fs/udf/symlink.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/udf/symlink.c||fs/udf/symlink.c"
          ],
          "candidate": [
            "fs/udf/symlink.c||fs/udf/symlink.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/udf/symlink.c||fs/udf/symlink.c": [
          "File: fs/udf/symlink.c -> fs/udf/symlink.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:  struct inode *inode = page->mapping->host;",
          "81:  struct buffer_head *bh = NULL;",
          "82:  unsigned char *symlink;",
          "84:  unsigned char *p = kmap(page);",
          "85:  struct udf_inode_info *iinfo;",
          "86:  uint32_t pos;",
          "88:  iinfo = UDF_I(inode);",
          "89:  pos = udf_block_map(inode, 0);",
          "",
          "[Removed Lines]",
          "83:  int err = -EIO;",
          "",
          "[Added Lines]",
          "83:  int err;",
          "89:  if (inode->i_size > inode->i_sb->s_blocksize) {",
          "90:   err = -ENAMETOOLONG;",
          "91:   goto out_unmap;",
          "92:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94:  } else {",
          "95:   bh = sb_bread(inode->i_sb, pos);",
          "100:   symlink = bh->b_data;",
          "101:  }",
          "",
          "[Removed Lines]",
          "97:   if (!bh)",
          "98:    goto out;",
          "",
          "[Added Lines]",
          "103:   if (!bh) {",
          "104:    err = -EIO;",
          "105:    goto out_unlock_inode;",
          "106:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "109:  unlock_page(page);",
          "110:  return 0;",
          "113:  up_read(&iinfo->i_data_sem);",
          "114:  SetPageError(page);",
          "115:  kunmap(page);",
          "116:  unlock_page(page);",
          "117:  return err;",
          "",
          "[Removed Lines]",
          "112: out:",
          "",
          "[Added Lines]",
          "120: out_unlock_inode:",
          "123: out_unmap:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "31f2566f33a6a25ac0baf402316e37e76632445f",
      "candidate_info": {
        "commit_hash": "31f2566f33a6a25ac0baf402316e37e76632445f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/31f2566f33a6a25ac0baf402316e37e76632445f",
        "files": [
          "fs/udf/unicode.c"
        ],
        "message": "udf: remove unnecessary test in udf_build_ustr_exact()\n\nWe can remove parameter checks:\n\nudf_build_ustr_exact() is only called by udf_get_filename()\nwhich now assures dest is not NULL\n\nudf_find_entry() and udf_readdir() call udf_get_filename()\nafter checking sname\nudf_symlink_filler() calls udf_pc_to_char() with sname=kmap(page).\n\nudf_find_entry() and udf_readdir() call udf_get_filename with UDF_NAME_LEN\nudf_pc_to_char() with PAGE_SIZE\n\nSuggested-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Fabian Frederick <fabf@skynet.be>\nSigned-off-by: Jan Kara <jack@suse.cz>",
        "before_after_code_files": [
          "fs/udf/unicode.c||fs/udf/unicode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/udf/unicode.c||fs/udf/unicode.c"
          ],
          "candidate": [
            "fs/udf/unicode.c||fs/udf/unicode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/udf/unicode.c||fs/udf/unicode.c": [
          "File: fs/udf/unicode.c -> fs/udf/unicode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: {",
          "76:  memset(dest, 0, sizeof(struct ustr));",
          "77:  dest->u_cmpID = ptr[0];",
          "78:  dest->u_len = exactsize - 1;",
          "79:  memcpy(dest->u_name, ptr + 1, exactsize - 1);",
          "82: }",
          "",
          "[Removed Lines]",
          "71: static int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)",
          "73:  if ((!dest) || (!ptr) || (!exactsize))",
          "74:   return -1;",
          "81:  return 0;",
          "",
          "[Added Lines]",
          "71: static void udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:  struct ustr *filename, *unifilename;",
          "341:  int ret = 0;",
          "343:  filename = kmalloc(sizeof(struct ustr), GFP_NOFS);",
          "344:  if (!filename)",
          "345:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  if (!slen)",
          "339:   return -EIO;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "350:   goto out1;",
          "351:  }",
          "356:  if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {",
          "357:   if (!udf_CS0toUTF8(filename, unifilename)) {",
          "358:    udf_debug(\"Failed in udf_get_filename: sname = %s\\n\",",
          "",
          "[Removed Lines]",
          "353:  if (udf_build_ustr_exact(unifilename, sname, slen))",
          "354:   goto out2;",
          "",
          "[Added Lines]",
          "351:  udf_build_ustr_exact(unifilename, sname, slen);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ee3039c5b4d121d56dc6b7deeeee3ba4150a260",
      "candidate_info": {
        "commit_hash": "3ee3039c5b4d121d56dc6b7deeeee3ba4150a260",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3ee3039c5b4d121d56dc6b7deeeee3ba4150a260",
        "files": [
          "fs/udf/dir.c",
          "fs/udf/namei.c"
        ],
        "message": "udf: Reduce repeated dereferences\n\nReplace repeated dereferences like dir->i_sb by storing superblock\npointer in a variable and using that.\n\nSigned-off-by: Jan Kara <jack@suse.cz>",
        "before_after_code_files": [
          "fs/udf/dir.c||fs/udf/dir.c",
          "fs/udf/namei.c||fs/udf/namei.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/udf/dir.c||fs/udf/dir.c",
            "fs/udf/namei.c||fs/udf/namei.c"
          ],
          "candidate": [
            "fs/udf/dir.c||fs/udf/dir.c",
            "fs/udf/namei.c||fs/udf/namei.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/udf/dir.c||fs/udf/dir.c": [
          "File: fs/udf/dir.c -> fs/udf/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:  sector_t offset;",
          "58:  int i, num, ret = 0;",
          "59:  struct extent_position epos = { NULL, 0, {0, 0} };",
          "61:  if (ctx->pos == 0) {",
          "62:   if (!dir_emit_dot(file, ctx))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60:  struct super_block *sb = dir->i_sb;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:  if (nf_pos == 0)",
          "77:   nf_pos = udf_ext0_offset(dir);",
          "80:  if (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {",
          "82:       &epos, &eloc, &elen, &offset)",
          "83:       != (EXT_RECORDED_ALLOCATED >> 30)) {",
          "84:    ret = -ENOENT;",
          "85:    goto out;",
          "86:   }",
          "89:    if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)",
          "90:     epos.offset -= sizeof(struct short_ad);",
          "91:    else if (iinfo->i_alloc_type ==",
          "",
          "[Removed Lines]",
          "79:  fibh.soffset = fibh.eoffset = nf_pos & (dir->i_sb->s_blocksize - 1);",
          "81:   if (inode_bmap(dir, nf_pos >> dir->i_sb->s_blocksize_bits,",
          "87:   block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);",
          "88:   if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {",
          "",
          "[Added Lines]",
          "80:  fibh.soffset = fibh.eoffset = nf_pos & (sb->s_blocksize - 1);",
          "82:   if (inode_bmap(dir, nf_pos >> sb->s_blocksize_bits,",
          "88:   block = udf_get_lb_pblock(sb, &eloc, offset);",
          "89:   if ((++offset << sb->s_blocksize_bits) < elen) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95:    offset = 0;",
          "96:   }",
          "99:    ret = -EIO;",
          "100:    goto out;",
          "101:   }",
          "107:    for (num = 0; i > 0; i--) {",
          "110:     if (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))",
          "111:      bha[num++] = tmp;",
          "112:     else",
          "",
          "[Removed Lines]",
          "98:   if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {",
          "103:   if (!(offset & ((16 >> (dir->i_sb->s_blocksize_bits - 9)) - 1))) {",
          "104:    i = 16 >> (dir->i_sb->s_blocksize_bits - 9);",
          "105:    if (i + offset > (elen >> dir->i_sb->s_blocksize_bits))",
          "106:     i = (elen >> dir->i_sb->s_blocksize_bits) - offset;",
          "108:     block = udf_get_lb_pblock(dir->i_sb, &eloc, offset + i);",
          "109:     tmp = udf_tgetblk(dir->i_sb, block);",
          "",
          "[Added Lines]",
          "99:   if (!(fibh.sbh = fibh.ebh = udf_tread(sb, block))) {",
          "104:   if (!(offset & ((16 >> (sb->s_blocksize_bits - 9)) - 1))) {",
          "105:    i = 16 >> (sb->s_blocksize_bits - 9);",
          "106:    if (i + offset > (elen >> sb->s_blocksize_bits))",
          "107:     i = (elen >> sb->s_blocksize_bits) - offset;",
          "109:     block = udf_get_lb_pblock(sb, &eloc, offset + i);",
          "110:     tmp = udf_tgetblk(sb, block);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "152:   }",
          "154:   if ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {",
          "156:     continue;",
          "157:   }",
          "159:   if ((cfi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {",
          "161:     continue;",
          "162:   }",
          "",
          "[Removed Lines]",
          "155:    if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))",
          "160:    if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))",
          "",
          "[Added Lines]",
          "156:    if (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))",
          "161:    if (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "167:    continue;",
          "168:   }",
          "172:   if (!flen)",
          "173:    continue;",
          "175:   tloc = lelb_to_cpu(cfi.icb.extLocation);",
          "177:   if (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))",
          "178:    goto out;",
          "",
          "[Removed Lines]",
          "170:   flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,",
          "171:      UDF_NAME_LEN);",
          "176:   iblock = udf_get_lb_pblock(dir->i_sb, &tloc, 0);",
          "",
          "[Added Lines]",
          "171:   flen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);",
          "176:   iblock = udf_get_lb_pblock(sb, &tloc, 0);",
          "",
          "---------------"
        ],
        "fs/udf/namei.c||fs/udf/namei.c": [
          "File: fs/udf/namei.c -> fs/udf/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:  struct udf_inode_info *dinfo = UDF_I(dir);",
          "160:  int isdotdot = child->len == 2 &&",
          "161:   child->name[0] == '.' && child->name[1] == '.';",
          "163:  size = udf_ext0_offset(dir) + dir->i_size;",
          "164:  f_pos = udf_ext0_offset(dir);",
          "166:  fibh->sbh = fibh->ebh = NULL;",
          "168:  if (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {",
          "170:       &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))",
          "171:    goto out_err;",
          "174:    if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)",
          "175:     epos.offset -= sizeof(struct short_ad);",
          "176:    else if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)",
          "",
          "[Removed Lines]",
          "167:  fibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);",
          "169:   if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,",
          "172:   block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);",
          "173:   if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {",
          "",
          "[Added Lines]",
          "162:  struct super_block *sb = dir->i_sb;",
          "168:  fibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);",
          "170:   if (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,",
          "173:   block = udf_get_lb_pblock(sb, &eloc, offset);",
          "174:   if ((++offset << sb->s_blocksize_bits) < elen) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "178:   } else",
          "179:    offset = 0;",
          "182:   if (!fibh->sbh)",
          "183:    goto out_err;",
          "184:  }",
          "",
          "[Removed Lines]",
          "181:   fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);",
          "",
          "[Added Lines]",
          "182:   fibh->sbh = fibh->ebh = udf_tread(sb, block);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "217:   }",
          "219:   if ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {",
          "221:     continue;",
          "222:   }",
          "224:   if ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {",
          "226:     continue;",
          "227:   }",
          "",
          "[Removed Lines]",
          "220:    if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))",
          "225:    if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))",
          "",
          "[Added Lines]",
          "221:    if (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))",
          "226:    if (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "233:   if (!lfi)",
          "234:    continue;",
          "238:   if (flen && udf_match(flen, fname, child->len, child->name))",
          "239:    goto out_ok;",
          "240:  }",
          "",
          "[Removed Lines]",
          "236:   flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,",
          "237:      UDF_NAME_LEN);",
          "",
          "[Added Lines]",
          "237:   flen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5ceb8b554dcaaf6844415cd2616ce2e0132530fa",
      "candidate_info": {
        "commit_hash": "5ceb8b554dcaaf6844415cd2616ce2e0132530fa",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5ceb8b554dcaaf6844415cd2616ce2e0132530fa",
        "files": [
          "fs/udf/dir.c",
          "fs/udf/namei.c",
          "fs/udf/symlink.c",
          "fs/udf/unicode.c"
        ],
        "message": "udf: Return -ENOMEM when allocation fails in udf_get_filename()\n\nReturn -ENOMEM when allocation fails in udf_get_filename(). Update\nudf_pc_to_char(), udf_readdir(), and udf_find_entry() to handle the\nerror appropriately. This allows us to pass appropriate error to\nuserspace instead of corrupting symlink contents by omitting some path\nelements.\n\nSigned-off-by: Fabian Frederick <fabf@skynet.be>\nSigned-off-by: Jan Kara <jack@suse.cz>",
        "before_after_code_files": [
          "fs/udf/dir.c||fs/udf/dir.c",
          "fs/udf/namei.c||fs/udf/namei.c",
          "fs/udf/symlink.c||fs/udf/symlink.c",
          "fs/udf/unicode.c||fs/udf/unicode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/udf/dir.c||fs/udf/dir.c",
            "fs/udf/namei.c||fs/udf/namei.c",
            "fs/udf/symlink.c||fs/udf/symlink.c",
            "fs/udf/unicode.c||fs/udf/unicode.c"
          ],
          "candidate": [
            "fs/udf/dir.c||fs/udf/dir.c",
            "fs/udf/namei.c||fs/udf/namei.c",
            "fs/udf/symlink.c||fs/udf/symlink.c",
            "fs/udf/unicode.c||fs/udf/unicode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/udf/dir.c||fs/udf/dir.c": [
          "File: fs/udf/dir.c -> fs/udf/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:   }",
          "170:   flen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);",
          "172:    continue;",
          "174:   tloc = lelb_to_cpu(cfi.icb.extLocation);",
          "",
          "[Removed Lines]",
          "171:   if (!flen)",
          "",
          "[Added Lines]",
          "171:   if (flen <= 0)",
          "",
          "---------------"
        ],
        "fs/udf/namei.c||fs/udf/namei.c": [
          "File: fs/udf/namei.c -> fs/udf/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:    continue;",
          "236:   flen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);",
          "238:    goto out_ok;",
          "239:  }",
          "",
          "[Removed Lines]",
          "237:   if (flen && udf_match(flen, fname, child->len, child->name))",
          "",
          "[Added Lines]",
          "237:   if (flen > 0 && udf_match(flen, fname, child->len, child->name))",
          "",
          "---------------"
        ],
        "fs/udf/symlink.c||fs/udf/symlink.c": [
          "File: fs/udf/symlink.c -> fs/udf/symlink.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:    comp_len = udf_get_filename(sb, pc->componentIdent,",
          "83:           pc->lengthComponentIdent,",
          "84:           p, tolen);",
          "85:    p += comp_len;",
          "86:    tolen -= comp_len;",
          "87:    if (tolen == 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85:    if (comp_len < 0)",
          "86:     return comp_len;",
          "",
          "---------------"
        ],
        "fs/udf/unicode.c||fs/udf/unicode.c": [
          "File: fs/udf/unicode.c -> fs/udf/unicode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "338:        uint8_t *dname, int dlen)",
          "339: {",
          "340:  struct ustr *filename, *unifilename;",
          "343:  filename = kmalloc(sizeof(struct ustr), GFP_NOFS);",
          "344:  if (!filename)",
          "347:  unifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);",
          "349:   goto out1;",
          "351:  if (udf_build_ustr_exact(unifilename, sname, slen))",
          "352:   goto out2;",
          "",
          "[Removed Lines]",
          "341:  int len = 0;",
          "345:   return 0;",
          "348:  if (!unifilename)",
          "",
          "[Added Lines]",
          "341:  int ret = 0;",
          "345:   return -ENOMEM;",
          "348:  if (!unifilename) {",
          "349:   ret = -ENOMEM;",
          "351:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "367:  } else",
          "368:   goto out2;",
          "371:          filename->u_name, filename->u_len,",
          "372:          unifilename->u_name, unifilename->u_len);",
          "373: out2:",
          "374:  kfree(unifilename);",
          "375: out1:",
          "376:  kfree(filename);",
          "378: }",
          "380: int udf_put_filename(struct super_block *sb, const uint8_t *sname,",
          "",
          "[Removed Lines]",
          "370:  len = udf_translate_to_linux(dname, dlen,",
          "377:  return len;",
          "",
          "[Added Lines]",
          "372:  ret = udf_translate_to_linux(dname, dlen,",
          "379:  return ret;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
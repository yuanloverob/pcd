{
  "cve_id": "CVE-2017-15126",
  "cve_desc": "A use-after-free flaw was found in fs/userfaultfd.c in the Linux kernel before 4.13.6. The issue is related to the handling of fork failure when dealing with event messages. Failure to fork correctly can lead to a situation where a fork event will be removed from an already freed list of events with userfaultfd_ctx_put().",
  "repo": "torvalds/linux",
  "patch_hash": "384632e67e0829deb8015ee6ad916b180049d252",
  "patch_info": {
    "commit_hash": "384632e67e0829deb8015ee6ad916b180049d252",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252",
    "files": [
      "fs/userfaultfd.c"
    ],
    "message": "userfaultfd: non-cooperative: fix fork use after free\n\nWhen reading the event from the uffd, we put it on a temporary\nfork_event list to detect if we can still access it after releasing and\nretaking the event_wqh.lock.\n\nIf fork aborts and removes the event from the fork_event all is fine as\nlong as we're still in the userfault read context and fork_event head is\nstill alive.\n\nWe've to put the event allocated in the fork kernel stack, back from\nfork_event list-head to the event_wqh head, before returning from\nuserfaultfd_ctx_read, because the fork_event head lifetime is limited to\nthe userfaultfd_ctx_read stack lifetime.\n\nForgetting to move the event back to its event_wqh place then results in\n__remove_wait_queue(&ctx->event_wqh, &ewq->wq); in\nuserfaultfd_event_wait_completion to remove it from a head that has been\nalready freed from the reader stack.\n\nThis could only happen if resolve_userfault_fork failed (for example if\nthere are no file descriptors available to allocate the fork uffd).  If\nit succeeded it was put back correctly.\n\nFurthermore, after find_userfault_evt receives a fork event, the forked\nuserfault context in fork_nctx and uwq->msg.arg.reserved.reserved1 can\nbe released by the fork thread as soon as the event_wqh.lock is\nreleased.  Taking a reference on the fork_nctx before dropping the lock\nprevents an use after free in resolve_userfault_fork().\n\nIf the fork side aborted and it already released everything, we still\ntry to succeed resolve_userfault_fork(), if possible.\n\nFixes: 893e26e61d04eac9 (\"userfaultfd: non-cooperative: Add fork() event\")\nLink: http://lkml.kernel.org/r/20170920180413.26713-1-aarcange@redhat.com\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nReported-by: Mark Rutland <mark.rutland@arm.com>\nTested-by: Mark Rutland <mark.rutland@arm.com>\nCc: Pavel Emelyanov <xemul@virtuozzo.com>\nCc: Mike Rapoport <rppt@linux.vnet.ibm.com>\nCc: \"Dr. David Alan Gilbert\" <dgilbert@redhat.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "fs/userfaultfd.c||fs/userfaultfd.c"
    ]
  },
  "patch_diff": {
    "fs/userfaultfd.c||fs/userfaultfd.c": [
      "File: fs/userfaultfd.c -> fs/userfaultfd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1061:      (unsigned long)",
      "1062:      uwq->msg.arg.reserved.reserved1;",
      "1063:     list_move(&uwq->wq.entry, &fork_event);",
      "1064:     spin_unlock(&ctx->event_wqh.lock);",
      "1065:     ret = 0;",
      "1066:     break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1075:     userfaultfd_ctx_get(fork_nctx);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1092:  if (!ret && msg->event == UFFD_EVENT_FORK) {",
      "1093:   ret = resolve_userfault_fork(ctx, fork_nctx, msg);",
      "1103:     userfaultfd_event_complete(ctx, uwq);",
      "1106:   }",
      "1107:  }",
      "1109:  return ret;",
      "",
      "[Removed Lines]",
      "1095:   if (!ret) {",
      "1096:    spin_lock(&ctx->event_wqh.lock);",
      "1097:    if (!list_empty(&fork_event)) {",
      "1098:     uwq = list_first_entry(&fork_event,",
      "1099:              typeof(*uwq),",
      "1100:              wq.entry);",
      "1101:     list_del(&uwq->wq.entry);",
      "1102:     __add_wait_queue(&ctx->event_wqh, &uwq->wq);",
      "1104:    }",
      "1105:    spin_unlock(&ctx->event_wqh.lock);",
      "",
      "[Added Lines]",
      "1106:   spin_lock(&ctx->event_wqh.lock);",
      "1107:   if (!list_empty(&fork_event)) {",
      "1112:    userfaultfd_ctx_put(fork_nctx);",
      "1114:    uwq = list_first_entry(&fork_event,",
      "1115:             typeof(*uwq),",
      "1116:             wq.entry);",
      "1127:    list_del(&uwq->wq.entry);",
      "1128:    __add_wait_queue(&ctx->event_wqh, &uwq->wq);",
      "1135:    if (likely(!ret))",
      "1137:   } else {",
      "1149:    if (ret)",
      "1150:     userfaultfd_ctx_put(fork_nctx);",
      "1152:   spin_unlock(&ctx->event_wqh.lock);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "893e26e61d04eac974ded0c11e1647b335c8cb7b",
      "candidate_info": {
        "commit_hash": "893e26e61d04eac974ded0c11e1647b335c8cb7b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/893e26e61d04eac974ded0c11e1647b335c8cb7b",
        "files": [
          "fs/userfaultfd.c",
          "include/linux/userfaultfd_k.h",
          "include/uapi/linux/userfaultfd.h",
          "kernel/fork.c"
        ],
        "message": "userfaultfd: non-cooperative: Add fork() event\n\nWhen the mm with uffd-ed vmas fork()-s the respective vmas notify their\nuffds with the event which contains a descriptor with new uffd.  This\nnew descriptor can then be used to get events from the child and\npopulate its mm with data.  Note, that there can be different uffd-s\ncontrolling different vmas within one mm, so first we should collect all\nthose uffds (and ctx-s) in a list and then notify them all one by one\nbut only once per fork().\n\nThe context is created at fork() time but the descriptor, file struct\nand anon inode object is created at event read time.  So some trickery\nis added to the userfaultfd_ctx_read() to handle the ctx queues' locking\nvs file creation.\n\nAnother thing worth noticing is that the task that fork()-s waits for\nthe uffd event to get processed WITHOUT the mmap sem.\n\n[aarcange@redhat.com: build warning fix]\n  Link: http://lkml.kernel.org/r/20161216144821.5183-10-aarcange@redhat.com\nLink: http://lkml.kernel.org/r/20161216144821.5183-9-aarcange@redhat.com\nSigned-off-by: Pavel Emelyanov <xemul@parallels.com>\nSigned-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nCc: \"Dr. David Alan Gilbert\" <dgilbert@redhat.com>\nCc: Hillf Danton <hillf.zj@alibaba-inc.com>\nCc: Michael Rapoport <RAPOPORT@il.ibm.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/userfaultfd.c||fs/userfaultfd.c",
          "include/linux/userfaultfd_k.h||include/linux/userfaultfd_k.h",
          "include/uapi/linux/userfaultfd.h||include/uapi/linux/userfaultfd.h",
          "kernel/fork.c||kernel/fork.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/userfaultfd.c||fs/userfaultfd.c"
          ],
          "candidate": [
            "fs/userfaultfd.c||fs/userfaultfd.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/userfaultfd.c||fs/userfaultfd.c": [
          "File: fs/userfaultfd.c -> fs/userfaultfd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:  struct mm_struct *mm;",
          "65: };",
          "67: struct userfaultfd_wait_queue {",
          "68:  struct uffd_msg msg;",
          "69:  wait_queue_t wq;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: struct userfaultfd_fork_ctx {",
          "68:  struct userfaultfd_ctx *orig;",
          "69:  struct userfaultfd_ctx *new;",
          "70:  struct list_head list;",
          "71: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "465:  return ret;",
          "466: }",
          "471: {",
          "472:  int ret = 0;",
          "",
          "[Removed Lines]",
          "468: static int __maybe_unused userfaultfd_event_wait_completion(",
          "469:   struct userfaultfd_ctx *ctx,",
          "470:   struct userfaultfd_wait_queue *ewq)",
          "",
          "[Added Lines]",
          "474: static int userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,",
          "475:           struct userfaultfd_wait_queue *ewq)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "518:  __remove_wait_queue(&ctx->event_wqh, &ewq->wq);",
          "519: }",
          "521: static int userfaultfd_release(struct inode *inode, struct file *file)",
          "522: {",
          "523:  struct userfaultfd_ctx *ctx = file->private_data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "526: int dup_userfaultfd(struct vm_area_struct *vma, struct list_head *fcs)",
          "527: {",
          "528:  struct userfaultfd_ctx *ctx = NULL, *octx;",
          "529:  struct userfaultfd_fork_ctx *fctx;",
          "531:  octx = vma->vm_userfaultfd_ctx.ctx;",
          "532:  if (!octx || !(octx->features & UFFD_FEATURE_EVENT_FORK)) {",
          "533:   vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;",
          "534:   vma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);",
          "535:   return 0;",
          "536:  }",
          "538:  list_for_each_entry(fctx, fcs, list)",
          "539:   if (fctx->orig == octx) {",
          "540:    ctx = fctx->new;",
          "541:    break;",
          "542:   }",
          "544:  if (!ctx) {",
          "545:   fctx = kmalloc(sizeof(*fctx), GFP_KERNEL);",
          "546:   if (!fctx)",
          "547:    return -ENOMEM;",
          "549:   ctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);",
          "550:   if (!ctx) {",
          "551:    kfree(fctx);",
          "552:    return -ENOMEM;",
          "553:   }",
          "555:   atomic_set(&ctx->refcount, 1);",
          "556:   ctx->flags = octx->flags;",
          "557:   ctx->state = UFFD_STATE_RUNNING;",
          "558:   ctx->features = octx->features;",
          "559:   ctx->released = false;",
          "560:   ctx->mm = vma->vm_mm;",
          "561:   atomic_inc(&ctx->mm->mm_users);",
          "563:   userfaultfd_ctx_get(octx);",
          "564:   fctx->orig = octx;",
          "565:   fctx->new = ctx;",
          "566:   list_add_tail(&fctx->list, fcs);",
          "567:  }",
          "569:  vma->vm_userfaultfd_ctx.ctx = ctx;",
          "570:  return 0;",
          "571: }",
          "573: static int dup_fctx(struct userfaultfd_fork_ctx *fctx)",
          "574: {",
          "575:  struct userfaultfd_ctx *ctx = fctx->orig;",
          "576:  struct userfaultfd_wait_queue ewq;",
          "578:  msg_init(&ewq.msg);",
          "580:  ewq.msg.event = UFFD_EVENT_FORK;",
          "581:  ewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;",
          "583:  return userfaultfd_event_wait_completion(ctx, &ewq);",
          "584: }",
          "586: void dup_userfaultfd_complete(struct list_head *fcs)",
          "587: {",
          "588:  int ret = 0;",
          "589:  struct userfaultfd_fork_ctx *fctx, *n;",
          "591:  list_for_each_entry_safe(fctx, n, fcs, list) {",
          "592:   if (!ret)",
          "593:    ret = dup_fctx(fctx);",
          "594:   list_del(&fctx->list);",
          "595:   kfree(fctx);",
          "596:  }",
          "597: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "653:  }",
          "654: }",
          "656: static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,",
          "657:         struct uffd_msg *msg)",
          "658: {",
          "659:  ssize_t ret;",
          "660:  DECLARE_WAITQUEUE(wait, current);",
          "661:  struct userfaultfd_wait_queue *uwq;",
          "664:  spin_lock(&ctx->fd_wqh.lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "734: static const struct file_operations userfaultfd_fops;",
          "736: static int resolve_userfault_fork(struct userfaultfd_ctx *ctx,",
          "737:       struct userfaultfd_ctx *new,",
          "738:       struct uffd_msg *msg)",
          "739: {",
          "740:  int fd;",
          "741:  struct file *file;",
          "742:  unsigned int flags = new->flags & UFFD_SHARED_FCNTL_FLAGS;",
          "744:  fd = get_unused_fd_flags(flags);",
          "745:  if (fd < 0)",
          "746:   return fd;",
          "748:  file = anon_inode_getfile(\"[userfaultfd]\", &userfaultfd_fops, new,",
          "749:       O_RDWR | flags);",
          "750:  if (IS_ERR(file)) {",
          "751:   put_unused_fd(fd);",
          "752:   return PTR_ERR(file);",
          "753:  }",
          "755:  fd_install(fd, file);",
          "756:  msg->arg.reserved.reserved1 = 0;",
          "757:  msg->arg.fork.ufd = fd;",
          "759:  return 0;",
          "760: }",
          "775:  LIST_HEAD(fork_event);",
          "776:  struct userfaultfd_ctx *fork_nctx = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "716:   if (uwq) {",
          "719:    userfaultfd_event_complete(ctx, uwq);",
          "720:    spin_unlock(&ctx->event_wqh.lock);",
          "721:    ret = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "834:    if (uwq->msg.event == UFFD_EVENT_FORK) {",
          "835:     fork_nctx = (struct userfaultfd_ctx *)",
          "836:      (unsigned long)",
          "837:      uwq->msg.arg.reserved.reserved1;",
          "838:     list_move(&uwq->wq.task_list, &fork_event);",
          "839:     spin_unlock(&ctx->event_wqh.lock);",
          "840:     ret = 0;",
          "841:     break;",
          "842:    }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "739:  __set_current_state(TASK_RUNNING);",
          "740:  spin_unlock(&ctx->fd_wqh.lock);",
          "742:  return ret;",
          "743: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "867:  if (!ret && msg->event == UFFD_EVENT_FORK) {",
          "868:   ret = resolve_userfault_fork(ctx, fork_nctx, msg);",
          "870:   if (!ret) {",
          "871:    spin_lock(&ctx->event_wqh.lock);",
          "872:    if (!list_empty(&fork_event)) {",
          "873:     uwq = list_first_entry(&fork_event,",
          "874:              typeof(*uwq),",
          "875:              wq.task_list);",
          "876:     list_del(&uwq->wq.task_list);",
          "877:     __add_wait_queue(&ctx->event_wqh, &uwq->wq);",
          "878:     userfaultfd_event_complete(ctx, uwq);",
          "879:    }",
          "880:    spin_unlock(&ctx->event_wqh.lock);",
          "881:   }",
          "882:  }",
          "",
          "---------------"
        ],
        "include/linux/userfaultfd_k.h||include/linux/userfaultfd_k.h": [
          "File: include/linux/userfaultfd_k.h -> include/linux/userfaultfd_k.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:  return vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP);",
          "53: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: extern int dup_userfaultfd(struct vm_area_struct *, struct list_head *);",
          "56: extern void dup_userfaultfd_complete(struct list_head *);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:  return false;",
          "77: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82: static inline int dup_userfaultfd(struct vm_area_struct *vma,",
          "83:       struct list_head *l)",
          "84: {",
          "85:  return 0;",
          "86: }",
          "88: static inline void dup_userfaultfd_complete(struct list_head *l)",
          "89: {",
          "90: }",
          "",
          "---------------"
        ],
        "include/uapi/linux/userfaultfd.h||include/uapi/linux/userfaultfd.h": [
          "File: include/uapi/linux/userfaultfd.h -> include/uapi/linux/userfaultfd.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define UFFD_API ((__u64)0xAA)",
          "27: #define UFFD_API_IOCTLS    \\",
          "28:  ((__u64)1 << _UFFDIO_REGISTER |  \\",
          "29:   (__u64)1 << _UFFDIO_UNREGISTER | \\",
          "",
          "[Removed Lines]",
          "26: #define UFFD_API_FEATURES (0)",
          "",
          "[Added Lines]",
          "21: #define UFFD_API_FEATURES (UFFD_FEATURE_EVENT_FORK)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:    __u64 address;",
          "78:   } pagefault;",
          "80:   struct {",
          "82:    __u64 reserved1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75:   struct {",
          "76:    __u32 ufd;",
          "77:   } fork;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92: #define UFFD_EVENT_PAGEFAULT 0x12",
          "94: #define UFFD_EVENT_FORK  0x13",
          "",
          "[Removed Lines]",
          "95: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "115: #define UFFD_FEATURE_PAGEFAULT_FLAG_WP  (1<<0)",
          "116: #define UFFD_FEATURE_EVENT_FORK   (1<<1)",
          "118:  __u64 features;",
          "120:  __u64 ioctls;",
          "",
          "[Removed Lines]",
          "117: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/fork.c||kernel/fork.c": [
          "File: kernel/fork.c -> kernel/fork.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: #include <linux/rmap.h>",
          "56: #include <linux/ksm.h>",
          "57: #include <linux/acct.h>",
          "58: #include <linux/tsacct_kern.h>",
          "59: #include <linux/cn_proc.h>",
          "60: #include <linux/freezer.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58: #include <linux/userfaultfd_k.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "561:  struct rb_node **rb_link, *rb_parent;",
          "562:  int retval;",
          "563:  unsigned long charge;",
          "565:  uprobe_start_dup_mmap();",
          "566:  if (down_write_killable(&oldmm->mmap_sem)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "565:  LIST_HEAD(uf);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "617:   if (retval)",
          "618:    goto fail_nomem_policy;",
          "619:   tmp->vm_mm = mm;",
          "620:   if (anon_vma_fork(tmp, mpnt))",
          "621:    goto fail_nomem_anon_vma_fork;",
          "624:   tmp->vm_next = tmp->vm_prev = NULL;",
          "626:   file = tmp->vm_file;",
          "627:   if (file) {",
          "628:    struct inode *inode = file_inode(file);",
          "",
          "[Removed Lines]",
          "622:   tmp->vm_flags &=",
          "623:    ~(VM_LOCKED|VM_LOCKONFAULT|VM_UFFD_MISSING|VM_UFFD_WP);",
          "625:   tmp->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;",
          "",
          "[Added Lines]",
          "622:   retval = dup_userfaultfd(tmp, &uf);",
          "623:   if (retval)",
          "624:    goto fail_nomem_anon_vma_fork;",
          "627:   tmp->vm_flags &= ~(VM_LOCKED | VM_LOCKONFAULT);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "678:  up_write(&mm->mmap_sem);",
          "679:  flush_tlb_mm(oldmm);",
          "680:  up_write(&oldmm->mmap_sem);",
          "681: fail_uprobe_end:",
          "682:  uprobe_end_dup_mmap();",
          "683:  return retval;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "684:  dup_userfaultfd_complete(&uf);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
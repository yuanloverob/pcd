{
  "cve_id": "CVE-2017-6197",
  "cve_desc": "The r_read_* functions in libr/include/r_endian.h in radare2 1.2.1 allow remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted binary file, as demonstrated by the r_read_le32 function.",
  "repo": "radare/radare2",
  "patch_hash": "1ea23bd6040441a21fbcfba69dce9a01af03f989",
  "patch_info": {
    "commit_hash": "1ea23bd6040441a21fbcfba69dce9a01af03f989",
    "repo": "radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/1ea23bd6040441a21fbcfba69dce9a01af03f989",
    "files": [
      "doc/uncrustify.cfg",
      "libr/bin/p/bin_dex.c",
      "libr/include/r_endian.h"
    ],
    "message": "Fix #6816 - null deref in r_read_*",
    "before_after_code_files": [
      "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c",
      "libr/include/r_endian.h||libr/include/r_endian.h"
    ]
  },
  "patch_diff": {
    "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c": [
      "File: libr/bin/p/bin_dex.c -> libr/bin/p/bin_dex.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1322:      c->interfaces_offset <",
      "1323:       bin->header.data_offset + bin->header.data_size) {",
      "1324:   p = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);",
      "1326:   if (types_list_size < 0 || types_list_size >= bin->header.types_size ) {",
      "1327:    return;",
      "1328:   }",
      "",
      "[Removed Lines]",
      "1325:   int types_list_size = r_read_le32(p);",
      "",
      "[Added Lines]",
      "1325:   int types_list_size = r_read_le32 (p);",
      "",
      "---------------"
    ],
    "libr/include/r_endian.h||libr/include/r_endian.h": [
      "File: libr/include/r_endian.h -> libr/include/r_endian.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: static inline ut8 r_read_ble8(const void *src) {",
      "11:  return *(ut8 *)src;",
      "12: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11:  if (!src) {",
      "12:   return UT8_MAX;",
      "13:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "116: static inline ut8 r_read_le8(const void *src) {",
      "117:  return r_read_ble8 (src);",
      "118: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "120:  if (!src) {",
      "121:   return UT8_MAX;",
      "122:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "130: }",
      "132: static inline ut16 r_read_le16(const void *src) {",
      "133:  const ut8 *s = (const ut8*)src;",
      "134:  return (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);",
      "135: }",
      "137: static inline ut16 r_read_at_le16(const void *src, size_t offset) {",
      "138:  const ut8 *s = (const ut8*)src + offset;",
      "139:  return r_read_le16 (s);",
      "140: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "139:  if (!src) {",
      "140:   return UT16_MAX;",
      "141:  }",
      "147:  if (!src) {",
      "148:   return UT16_MAX;",
      "149:  }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "157: }",
      "159: static inline ut32 r_read_le32(const void *src) {",
      "160:  const ut8 *s = (const ut8*)src;",
      "161:  return (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |",
      "162:   (((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);",
      "163: }",
      "165: static inline ut32 r_read_at_le32(const void *src, size_t offset) {",
      "166:  const ut8 *s = (const ut8*)src + offset;",
      "167:  return r_read_le32 (s);",
      "168: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "172:  if (!src) {",
      "173:   return UT32_MAX;",
      "174:  }",
      "181:  if (!src) {",
      "182:   return UT32_MAX;",
      "183:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0b32cf7c90a5f96024da7c28ea2101760e494c88",
      "candidate_info": {
        "commit_hash": "0b32cf7c90a5f96024da7c28ea2101760e494c88",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/0b32cf7c90a5f96024da7c28ea2101760e494c88",
        "files": [
          "libr/bin/format/dex/dex.c",
          "libr/bin/p/bin_dex.c",
          "libr/util/str.c"
        ],
        "message": "Fix recent regressions for DEX, fix entrypoints, {s,i}fields and lot of segfaults!",
        "before_after_code_files": [
          "libr/bin/format/dex/dex.c||libr/bin/format/dex/dex.c",
          "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c",
          "libr/util/str.c||libr/util/str.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ],
          "candidate": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/dex/dex.c||libr/bin/format/dex/dex.c": [
          "File: libr/bin/format/dex/dex.c -> libr/bin/format/dex/dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <r_util.h>",
          "5: #include \"dex.h\"",
          "8:  if (bin) {",
          "13:  }",
          "14:  return NULL;",
          "15: }",
          "17: #define FAIL(x) { eprintf(x\"\\n\"); goto fail; }",
          "20:  int i;",
          "21:  ut8 *bufptr;",
          "22:  struct dex_header_t *dexhdr;",
          "",
          "[Removed Lines]",
          "7: char* r_bin_dex_get_version(struct r_bin_dex_obj_t* bin) {",
          "9:   char *version = malloc (8);",
          "10:   memset (version, 0, 8);",
          "11:   memcpy (version, bin->b->buf + 4, 3);",
          "12:   return version;",
          "18: struct r_bin_dex_obj_t* r_bin_dex_new_buf(RBuffer *buf) {",
          "19:  struct r_bin_dex_obj_t *bin = R_NEW0 (struct r_bin_dex_obj_t);",
          "",
          "[Added Lines]",
          "7: char* r_bin_dex_get_version(RBinDexObj *bin) {",
          "9:   ut8* version = calloc (1, 8);",
          "10:   r_buf_read_at (bin->b, 4, version, 3);",
          "11:   return (char *)version;",
          "17: RBinDexObj *r_bin_dex_new_buf(RBuffer *buf) {",
          "18:  RBinDexObj *bin = R_NEW0 (RBinDexObj);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29:   goto fail;",
          "30:  }",
          "33:   goto fail;",
          "34:  bufptr = bin->b->buf;",
          "35:  dexhdr = &bin->header;",
          "",
          "[Removed Lines]",
          "32:  if (bin->size < sizeof(struct dex_header_t))",
          "",
          "[Added Lines]",
          "31:  if (bin->size < sizeof(struct dex_header_t)) {",
          "33:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "133:  if (dexhdr->fields_offset + fields_size >= bin->size) {",
          "134:   fields_size = bin->size - dexhdr->fields_offset;",
          "135:  }",
          "137:   fields_size = 0;",
          "138:  }",
          "139:  dexhdr->fields_size = fields_size / sizeof (struct dex_field_t);",
          "",
          "[Removed Lines]",
          "136:  if (fields_size<0) {",
          "",
          "[Added Lines]",
          "136:  if (fields_size < 0) {",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c": [
          "File: libr/bin/p/bin_dex.c -> libr/bin/p/bin_dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "218:  return off;",
          "219: }",
          "220: #endif",
          "221: static char *getstr (RBinDexObj *bin, int idx) {",
          "222:  ut8 buf[6];",
          "223:  ut64 len;",
          "224:  int uleblen;",
          "226:   return NULL;",
          "227:  r_buf_read_at (bin->b, bin->strings[idx], buf, sizeof (buf));",
          "228:  uleblen = r_uleb128 (buf, sizeof (buf), &len) - buf;",
          "236:  }",
          "237:  return NULL;",
          "238: }",
          "",
          "[Removed Lines]",
          "225:  if (idx<0 || idx >= bin->header.strings_size || !bin->strings)",
          "229:  if (len>0 && len < R_BIN_SIZEOF_STRINGS) {",
          "230:   char *str = calloc (1, len+1);",
          "231:   if (!str) return NULL;",
          "232:   r_buf_read_at (bin->b, (bin->strings[idx])+uleblen,",
          "233:     (ut8*)str, len);",
          "234:   str[len] = 0;",
          "235:   return str;",
          "",
          "[Added Lines]",
          "226:  if (idx < 0 || idx >= bin->header.strings_size || !bin->strings) {",
          "228:  }",
          "231:  if ((int)len > 0 && len < R_BIN_SIZEOF_STRINGS) {",
          "232:   char *str = calloc (1, len + 1);",
          "233:   if (str) {",
          "234:    r_buf_read_at (bin->b, (bin->strings[idx]) + uleblen, (ut8*)str, len);",
          "235:    str[len] = 0;",
          "236:    return str;",
          "237:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "310:  return NULL;",
          "311: }",
          "313: static char *dexFieldName(RBinDexObj *dex, RBinDexClass *c, int fn) {",
          "314:  DexField field = { 0 };",
          "315:  ut8 ff[sizeof (DexField)] = {0};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315: #if DEX_UNUSED",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "338:  return getstr (dex, field.type_id);",
          "339: }",
          "342:  int cid, tid;",
          "344:   return NULL;",
          "345:  }",
          "348:  if (cid < 0 || cid >= bin->header.types_size) {",
          "349:   return NULL;",
          "350:  }",
          "351:  tid = bin->types [cid].descriptor_id;",
          "354: }",
          "357:  int cid, tid;",
          "359:   return NULL;",
          "360:  }",
          "362:  if (cid < 0 || cid >= bin->header.types_size) {",
          "363:   return NULL;",
          "364:  }",
          "365:  tid = bin->types [cid].descriptor_id;",
          "368: }",
          "370: static char *dex_class_super_name (RBinDexObj *bin, RBinDexClass *c) {",
          "",
          "[Removed Lines]",
          "341: static char *dex_class_name (RBinDexObj *bin, RBinDexClass *c) {",
          "343:  if (!bin || !c || !bin->types) {",
          "346:  cid = c->class_id;",
          "353:  return get_string (bin, cid, tid);",
          "356: static char *dex_type_name (RBinDexObj *bin, int id) {",
          "358:  if (!bin || !bin->types) {",
          "361:  cid = id;",
          "367:  return get_string (bin, cid, tid);// cid, tid);",
          "",
          "[Added Lines]",
          "344: static char *dex_type_name (RBinDexObj *bin, int id) {",
          "346:  if (!bin || !bin->types) {",
          "349:  cid = id;",
          "355:  return get_string (bin, cid, tid);// cid, tid);",
          "357: #endif",
          "359: static char *dex_class_name (RBinDexObj *bin, RBinDexClass *c) {",
          "361:  if (!bin || !c || !bin->types) {",
          "364:  cid = c->class_id;",
          "371:  return get_string (bin, cid, tid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "373:   return NULL;",
          "374:  }",
          "375:  cid = c->super_class;",
          "377:   return NULL;",
          "378:  }",
          "379:  tid = bin->types [cid].descriptor_id;",
          "",
          "[Removed Lines]",
          "376:  if (cid<0 || cid >= bin->header.types_size) {",
          "",
          "[Added Lines]",
          "380:  if (cid < 0 || cid >= bin->header.types_size) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "381:  return get_string (bin, cid, tid);",
          "382: }",
          "385:  int total, i, *methods;",
          "387:  const ut8 *p, *p_end;",
          "392:  if (!c || !c->class_data_offset) {",
          "396:   return NULL;",
          "397:  }",
          "399:  class_name = dex_class_name (bin, c);",
          "401:   return NULL;",
          "402:  }",
          "404:  methods = calloc (sizeof (int), bin->header.method_size);",
          "405:  if (!methods) {",
          "406:   free (class_name);",
          "",
          "[Removed Lines]",
          "384: static int *parse_class(RBinFile *binfile, struct r_bin_dex_obj_t *bin, struct dex_class_t *c, RBinClass *cls) {",
          "386:  ut64 SF, IF, DM, VM;",
          "388:  char *class_name;",
          "389:  ut8 ff[sizeof (DexField)] = {0};",
          "390:  char *cln;",
          "400:  if (!class_name || *class_name == '\\0') {",
          "403:  cln = class_name;",
          "",
          "[Added Lines]",
          "388: static int *parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, RBinClass *cls) {",
          "389:  ut64 SF, IF, DM, VM, lastIndex;",
          "390:  ut8 ff[sizeof (DexField)] = {0};",
          "391:  char *class_name, *cln = NULL;",
          "394:  DexField field;",
          "401:  if (!class_name || !*class_name) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "408:  }",
          "409:  dprintf (\"  class_data_offset: %d\\n\", c->class_data_offset);",
          "410:  p = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);",
          "414:  p = r_uleb128 (p, p_end - p, &SF);",
          "415:  p = r_uleb128 (p, p_end - p, &IF);",
          "416:  p = r_uleb128 (p, p_end - p, &DM);",
          "417:  p = r_uleb128 (p, p_end - p, &VM);",
          "420:  dprintf (\"  static fields: %u\\n\", (ut32)SF);",
          "425:  const ut8 *op = p;",
          "426:  for (i = 0; i < SF; i++) {",
          "452:   p = r_uleb128 (p, p_end - p, &accessFlags); // accessFlags",
          "468:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "470:    sym->type = r_str_const (\"STATIC\");",
          "472:    r_list_append (bin->methods_list, sym);",
          "473:   }",
          "475:  }",
          "479:  op = p;",
          "480:  for (i = 0; i < IF; i++) {",
          "484:   p = r_uleb128 (p, p_end - p, &accessFlags); // accessFlags",
          "493:   cln = r_str_replace (cln, \";\", \"_\", 0);",
          "494:   if (accessFlags == 0) {",
          "496:   }",
          "499:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "501:    sym->type = r_str_const (\"FIELD\");",
          "503:    r_list_append (bin->methods_list, sym);",
          "504:   }",
          "506:  }",
          "508:  dprintf (\"  direct methods: %u\\n\", (ut32)DM);",
          "509:  ut64 omi = 0;",
          "",
          "[Removed Lines]",
          "411:  p_end = p + (binfile->buf->length - c->class_data_offset);",
          "422:  int lastidx = 0;",
          "423:  DexField fields[SF];",
          "427: #if 0",
          "428:   ut64 FI, FA, FN;",
          "429: #if 0",
          "430:   p = r_uleb128 (p, p_end - p, &FI);",
          "431:   p = r_uleb128 (p, p_end - p, &FA);",
          "432:   dprintf (\"    field_idx: %u\\n\", (ut32)FI);",
          "433:   char *field_name = get_string (bin, c, (ut32)FA); //bin->methods[i].class_id);",
          "434: #endif",
          "436:   p = r_uleb128 (p, p_end - p, &FI); // name",
          "437:   p = r_uleb128 (p, p_end - p, &FA); // access",
          "446:   eprintf (\"    field access_flags: 0x%x\\n\", (ut32)FA);",
          "447: #endif",
          "448:   ut64 fieldIdx, accessFlags;",
          "449:   int fieldOffset = bin->header.fields_offset + (p - op);",
          "450:   char *name = NULL;",
          "451:   p = r_uleb128 (p, p_end - p, &fieldIdx); // fieldIdx",
          "453:   fieldIdx += lastidx;",
          "454:   total = bin->header.fields_offset + sizeof (DexField) * fieldIdx;",
          "455:   if (total > bin->size) {",
          "456:    free (methods);",
          "457:    return NULL;",
          "458:   }",
          "459:   r_buf_read_at (binfile->buf, total, ff, sizeof (DexField));",
          "460:   fields[fieldIdx].class_id = r_read_le16 (ff);",
          "461:   fields[fieldIdx].type_id = r_read_le16 (ff + 2);",
          "462:   fields[fieldIdx].name_id = r_read_le32 (ff + 4);",
          "463:   name = getstr (bin, fields[fieldIdx].name_id); //fields[lastidx].name_id);",
          "464:   cln = r_str_replace (class_name, \"method.\", \"\", 0);",
          "465:   cln = r_str_replace (cln, \";\", \"_\", 0);",
          "467:   {",
          "469:    sym->name = r_str_newf (\"%s.static.%d_%s\", cln, i, name);",
          "471:    sym->paddr = sym->vaddr = fieldOffset;",
          "474:   lastidx = fieldIdx;",
          "478:  lastidx = 0;",
          "481:   ut64 fieldIdx, accessFlags;",
          "482:   int fieldOffset = bin->header.fields_offset + (p - op);",
          "483:   p = r_uleb128 (p, p_end - p, &fieldIdx); // fieldIdx",
          "485:   fieldIdx += lastidx;",
          "486:   r_buf_read_at (binfile->buf, bin->header.fields_offset +",
          "487:     fieldIdx * sizeof (DexField), ff, sizeof (DexField));",
          "488:   fields[fieldIdx].class_id = r_read_le16 (ff);",
          "489:   fields[fieldIdx].type_id = r_read_le16 (ff + 2);",
          "490:   fields[fieldIdx].name_id = r_read_le32 (ff + 4);",
          "491:   char *name = getstr (bin, fields[fieldIdx].name_id); //fields[lastidx].name_id);",
          "492:   cln = r_str_replace (class_name, \"method.\", \"\", 0);",
          "498:   {",
          "500:    sym->name = r_str_newf (\"%s.field.%d_%s\", cln, i, name);",
          "502:    sym->paddr = sym->vaddr = fieldOffset;",
          "505:   lastidx = fieldIdx;",
          "",
          "[Added Lines]",
          "411:  p_end = p + binfile->buf->length - c->class_data_offset;",
          "428:  lastIndex = 0;",
          "430:   ut64 fieldIndex, accessFlags;",
          "432:   p = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex",
          "434:   fieldIndex += lastIndex;",
          "435:   total = bin->header.fields_offset + (sizeof (DexField) * fieldIndex);",
          "436:   if (r_buf_read_at (binfile->buf, total, ff, sizeof (DexField)) != sizeof (DexField)) {",
          "437:    break;",
          "438:   }",
          "439:   field.class_id = r_read_le16 (ff);",
          "440:   field.type_id = r_read_le16 (ff + 2);",
          "441:   field.name_id = r_read_le32 (ff + 4);",
          "442:   char *fieldName = getstr (bin, field.name_id);",
          "443:   if (1) {",
          "446:    sym->name = r_str_newf (\"sfield.%s.%d_%s\", class_name, i, fieldName);",
          "447:    sym->name = r_str_replace (sym->name, \"method.\", \"\", 0);",
          "448:    sym->name = r_str_replace (sym->name, \";\", \"\", 0);",
          "450:    sym->paddr = sym->vaddr = total;",
          "453:   lastIndex = fieldIndex;",
          "457:  lastIndex = 0;",
          "460:   DexField field;",
          "461:   ut64 fieldIndex, accessFlags;",
          "463:   p = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex",
          "465:   fieldIndex += lastIndex;",
          "466:   total = bin->header.fields_offset + (sizeof (DexField) * fieldIndex);",
          "467:   if ((int)fieldIndex < 0) {",
          "468:    eprintf (\"Invalid field index %d\\n\", (int)fieldIndex);",
          "469:    continue;",
          "470:   }",
          "471:   if (r_buf_read_at (binfile->buf, bin->header.fields_offset +",
          "472:     fieldIndex * sizeof (DexField), ff, sizeof (DexField)) != sizeof (DexField)) {",
          "473:    break;",
          "474:   }",
          "475:   field.class_id = r_read_le16 (ff);",
          "476:   field.type_id = r_read_le16 (ff + 2);",
          "477:   field.name_id = r_read_le32 (ff + 4);",
          "478:   char *name = getstr (bin, field.name_id);",
          "479:   cln = r_str_replace (strdup (class_name), \"method.\", \"\", 0);",
          "485:   if (1) {",
          "487:    sym->name = r_str_newf (\"ifield.%s.%d_%s\", class_name, i, name);",
          "489:    sym->paddr = sym->vaddr = total;",
          "493:   lastIndex = fieldIndex;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "533:   if (!method_name) {",
          "534:    method_name = strdup (\"unknown\");",
          "535:   }",
          "537:   if (!flag_name) {",
          "538:    continue;",
          "539:   }",
          "",
          "[Removed Lines]",
          "536:   flag_name = flagname (cln, method_name);",
          "",
          "[Added Lines]",
          "525:   flag_name = flagname (class_name, method_name);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "595:   p = r_uleb128 (p, p_end-p, &MA);",
          "596:   p = r_uleb128 (p, p_end-p, &MC);",
          "602:   char *name = dex_method_name (bin, MI);",
          "603:   dprintf (\"    method name: %s\\n\", name);",
          "604:   dprintf (\"    method_idx: %u\\n\", (ut32)MI);",
          "",
          "[Removed Lines]",
          "598:   if (MI < bin->header.method_size) methods[MI] = 1;",
          "599:   if (MC > 0 && bin->code_from > MC) bin->code_from = MC;",
          "600:   if (MC > 0 && bin->code_to < MC) bin->code_to = MC;",
          "",
          "[Added Lines]",
          "587:   if ((int)MI >= 0 && MI < bin->header.method_size) {",
          "588:    methods[MI] = 1;",
          "589:   }",
          "590:   if ((int)MC > 0 && bin->code_from > MC) {",
          "591:    bin->code_from = MC;",
          "592:   }",
          "593:   if ((int)MC > 0 && bin->code_to < MC) {",
          "594:    bin->code_to = MC;",
          "595:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "607:   {",
          "608:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "611:    sym->type = r_str_const (\"METH\");",
          "612:    sym->paddr = sym->vaddr = MC;",
          "613:    r_list_append (bin->methods_list, sym);",
          "",
          "[Removed Lines]",
          "610:    sym->name = r_str_newf (\"%s.%s\", cln, name);",
          "",
          "[Added Lines]",
          "604:    sym->name = r_str_newf (\"%s.%s\", class_name, name);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "920:  }",
          "921:  bin = (RBinDexObj*) arch->o->bin_obj;",
          "922:  ret = r_list_new ();",
          "925:  if (!bin->methods_list) {",
          "926:   dex_loadcode (arch, bin);",
          "927:  }",
          "929:  r_list_foreach (bin->methods_list, iter, m) {",
          "931:    dprintf (\"ENTRY -> %s\\n\", m->name);",
          "937:     }",
          "938:    }",
          "939:   }",
          "940:  }",
          "945:   }",
          "946:  }",
          "947:  return ret;",
          "",
          "[Removed Lines]",
          "923:  ptr = R_NEW0 (RBinAddr);",
          "930:   if (strlen (m->name)>=4 && !strcmp (m->name+strlen (m->name)-4, \"main\")) {",
          "932:    ptr->paddr = ptr->vaddr = m->paddr;",
          "933:    if (!already_entry (ret, ptr->vaddr)) {",
          "934:     r_list_append (ret, ptr);",
          "935:     if (!(ptr = R_NEW0 (RBinAddr))) {",
          "936:      break;",
          "941:  if (ptr && r_list_empty (ret)) {",
          "942:   ptr->paddr = ptr->vaddr = bin->code_from;",
          "943:   if (!already_entry (ret, ptr->vaddr)) {",
          "944:    r_list_append (ret, ptr);",
          "",
          "[Added Lines]",
          "921: #if 1",
          "924:   if (strlen (m->name) > 4 && !strcmp (m->name + strlen (m->name) - 5, \".main\")) {",
          "926:    if (!already_entry (ret, m->paddr)) {",
          "927:     if ((ptr = R_NEW0 (RBinAddr))) {",
          "928:      ptr->paddr = ptr->vaddr = m->paddr;",
          "929:      r_list_append (ret, ptr);",
          "934: #endif",
          "935:  if (r_list_empty (ret)) {",
          "936:   if (!already_entry (ret, bin->code_from)) {",
          "937:    ptr = R_NEW0 (RBinAddr);",
          "938:    if (ptr) {",
          "939:     ptr->paddr = ptr->vaddr = bin->code_from;",
          "940:     r_list_append (ret, ptr);",
          "941:    }",
          "",
          "---------------"
        ],
        "libr/util/str.c||libr/util/str.c": [
          "File: libr/util/str.c -> libr/util/str.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "907:   scnd = strdup (p+klen);",
          "908:   slen += vlen - klen;",
          "911:   if (!newstr) {",
          "912:    eprintf (\"realloc fail\\n\");",
          "913:    free (str);",
          "",
          "[Removed Lines]",
          "910:   newstr = realloc (str, slen+klen+1);",
          "",
          "[Added Lines]",
          "910:   newstr = realloc (str, slen + klen + 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c585f914396c33afe33e51a6b220fce96522bb42",
      "candidate_info": {
        "commit_hash": "c585f914396c33afe33e51a6b220fce96522bb42",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/c585f914396c33afe33e51a6b220fce96522bb42",
        "files": [
          "libr/anal/op.c",
          "libr/anal/p/anal_dalvik.c",
          "libr/bin/format/dex/dex.c",
          "libr/bin/format/dex/dex.h",
          "libr/bin/p/bin_dex.c",
          "libr/core/cbin.c",
          "libr/core/cmd_info.c",
          "libr/include/r_anal.h",
          "libr/include/r_bin.h",
          "libr/include/r_core.h",
          "libr/include/r_util/r_uleb128.h",
          "libr/util/uleb128.c"
        ],
        "message": "Dalvik analysis and bin parsing enhancements (#6320)\n\n* Initial work to enhance the dalvik analysis with rbin info\n* fix ptr addr in new-instance instruction in Dalvik Anal (#6082)\n* dalvik anal:fix ptr addr in new-instance\n* first ESIL instructions for Dalvik\n* more ESIL instructions for Dalvik\n* parse more data in dex format\n* code refactor and several fixes",
        "before_after_code_files": [
          "libr/anal/op.c||libr/anal/op.c",
          "libr/anal/p/anal_dalvik.c||libr/anal/p/anal_dalvik.c",
          "libr/bin/format/dex/dex.c||libr/bin/format/dex/dex.c",
          "libr/bin/format/dex/dex.h||libr/bin/format/dex/dex.h",
          "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c",
          "libr/core/cbin.c||libr/core/cbin.c",
          "libr/core/cmd_info.c||libr/core/cmd_info.c",
          "libr/include/r_anal.h||libr/include/r_anal.h",
          "libr/include/r_bin.h||libr/include/r_bin.h",
          "libr/include/r_core.h||libr/include/r_core.h",
          "libr/include/r_util/r_uleb128.h||libr/include/r_util/r_uleb128.h",
          "libr/util/uleb128.c||libr/util/uleb128.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ],
          "candidate": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/anal/op.c||libr/anal/op.c": [
          "File: libr/anal/op.c -> libr/anal/op.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "230:  case R_ANAL_OP_TYPE_LEA   : return \"lea\";",
          "231:  case R_ANAL_OP_TYPE_LEAVE : return \"leave\";",
          "232:  case R_ANAL_OP_TYPE_LOAD  : return \"load\";",
          "233:  case R_ANAL_OP_TYPE_MOD   : return \"mod\";",
          "234:  case R_ANAL_OP_TYPE_CMOV  : return \"cmov\";",
          "235:  case R_ANAL_OP_TYPE_MOV   : return \"mov\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:  case R_ANAL_OP_TYPE_NEW   : return \"new\";",
          "",
          "---------------"
        ],
        "libr/anal/p/anal_dalvik.c||libr/anal/p/anal_dalvik.c": [
          "File: libr/anal/p/anal_dalvik.c -> libr/anal/p/anal_dalvik.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <r_lib.h>",
          "5: #include <r_asm.h>",
          "6: #include <r_anal.h>",
          "8: #include \"../../asm/arch/dalvik/opcode.h\"",
          "11: static int dalvik_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {",
          "12:  int sz = dalvik_opcodes[data[0]].len;",
          "",
          "[Removed Lines]",
          "9: #include \"../../bin/format/dex/dex.h\"",
          "",
          "[Added Lines]",
          "7: #include \"esil.h\"",
          "10: #include \"../../bin/format/dex/dex.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29:   op->family = R_ANAL_OP_FAMILY_FPU;",
          "31:  case 0x1b: // const-string/jumbo",
          "45:  case 0x14: // const",
          "46:  case 0x15: // const",
          "47:  case 0x16: // const",
          "48:  case 0x17: // const",
          "49:  case 0x42: // const",
          "50:  case 0x18: // const-wide",
          "51:  case 0x19: // const-wide",
          "53:  case 0x0b: // move-result-wide",
          "54:   op->type = R_ANAL_OP_TYPE_MOV;",
          "58:   break;",
          "59:  case 0x1a: // const-string",
          "60:   op->type = R_ANAL_OP_TYPE_MOV;",
          "61:   {",
          "62:    ut32 vB = (data[3]<<8) | data[2];",
          "63:    ut64 offset = R_ANAL_GET_OFFSET (anal, 's', vB);",
          "64:    op->ptr = offset;",
          "65:   }",
          "66:   break;",
          "67:  case 0x1c: // const-class",
          "",
          "[Removed Lines]",
          "32:  case 0x01: // move",
          "33:  case 0x02: // move",
          "34:  case 0x03: // move/16",
          "35:  case 0x04: // mov-wide",
          "36:  case 0x05: // mov-wide",
          "37:  case 0x06: // mov-wide",
          "38:  case 0x07: //",
          "39:  case 0x08: //",
          "40:  case 0x09: //",
          "41:  case 0x0a: //",
          "42:  case 0x0d: // move-exception",
          "43:  case 0x12: // const/4",
          "44:  case 0x13: // const/16",
          "52:  case 0x0c: // move-result-object // TODO: add MOVRET OP TYPE ??",
          "55:   int vA = (int) -data[1];",
          "56:   op->stackop = R_ANAL_STACK_SET;",
          "57:   op->ptr = vA;",
          "",
          "[Added Lines]",
          "38:  case 0x12: // const/4",
          "39:   op->type = R_ANAL_OP_TYPE_MOV;",
          "40:   {",
          "41:    ut32 vB = (data[1] & 0x0f);",
          "42:    ut32 vA = (data[1] & 0xf0) >> 4;",
          "43:    op->stackop = R_ANAL_STACK_SET;",
          "44:    op->ptr = -vA;",
          "45:    esilprintf (op, \"0x%\"PFMT64x\",v%d,=\", vA, vB);",
          "46:   }",
          "47:   break;",
          "48:  case 0x01: // move",
          "49:  case 0x07: // move-object",
          "50:  case 0x04: // mov-wide",
          "51:   op->type = R_ANAL_OP_TYPE_MOV;",
          "52:   {",
          "53:    ut32 vB = (data[1] & 0x0f);",
          "54:    ut32 vA = (data[1] & 0xf0) >> 4;",
          "55:    op->stackop = R_ANAL_STACK_SET;",
          "56:    op->ptr = -vA;",
          "57:    esilprintf (op, \"v%d,v%d,=\", vA, vB);",
          "58:   }",
          "59:   break;",
          "60:  case 0x02: // move/from16",
          "61:  case 0x03: // move/16",
          "62:  case 0x05: // move-wide/from16",
          "63:  case 0x06: // mov-wide&17",
          "64:  case 0x08: // move-object/from16",
          "65:  case 0x09: // move-object/16",
          "66:  case 0x13: // const/16",
          "69:   op->type = R_ANAL_OP_TYPE_MOV;",
          "70:   {",
          "71:    int vA = (int) data[1];",
          "72:    ut32 vB = (data[3] << 8) | data[2];",
          "73:    esilprintf (op, \"v%d,v%d,=\", vA, vB);",
          "74:   }",
          "75:   break;",
          "76:  case 0x0a: // move-result",
          "77:  case 0x0d: // move-exception",
          "78:  case 0x0c: // move-result-object",
          "82:   {",
          "83:    ut32 vA = data[1];",
          "84:    esilprintf (op, \"sp,v%d,=[8],8,sp,+=,8\", vA);",
          "85:   }",
          "90:    ut32 vA = data[1];",
          "94:    esilprintf (op, \"0x%\"PFMT64x\",v%d,=\", offset, vA);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "154:  case 0x6c: // sput-wide",
          "155:  case 0xfe: // sput",
          "156:   op->type = R_ANAL_OP_TYPE_STORE;",
          "157:   break;",
          "158:  case 0x9d:",
          "159:  case 0xad: // mul-double",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187:   {",
          "188:    ut32 vA = (data[1] & 0x0f);",
          "189:    ut32 vB = (data[1] & 0xf0) >> 4;",
          "190:    esilprintf (op, \"v%d,v%d,=\", vA, vB);",
          "191:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "226:  case 0xf1: // return-void-barrier",
          "227:   op->type = R_ANAL_OP_TYPE_RET;",
          "228:   op->eob = true;",
          "229:   break;",
          "230:  case 0x28: // goto",
          "231:   op->jump = addr + ((char)data[1])*2;",
          "232:   op->type = R_ANAL_OP_TYPE_JMP;",
          "233:   op->eob = true;",
          "234:   break;",
          "235:  case 0x29: // goto/16",
          "236:   op->jump = addr + (short)(data[2]|data[3]<<8)*2;",
          "237:   op->type = R_ANAL_OP_TYPE_JMP;",
          "238:   op->eob = true;",
          "239:   break;",
          "240:  case 0x2a: // goto/32",
          "241:   op->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;",
          "242:   op->type = R_ANAL_OP_TYPE_JMP;",
          "243:   op->eob = true;",
          "244:   break;",
          "245:  case 0x2c:",
          "246:  case 0x2b:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265:   if (data[0] == 0x0e) {// return-void",
          "266:    esilprintf (op, \"sp,[8],ip,=,8,sp,+=\");",
          "267:   } else {",
          "268:    ut32 vA = data[1];",
          "269:    esilprintf (op, \"sp,[8],ip,=,8,sp,+=,8,sp,-=,v%d,sp,=[8]\", vA);",
          "270:   }",
          "276:   esilprintf (op, \"0x%\"PFMT64x\",ip,=\", op->jump);",
          "282:   esilprintf (op, \"0x%\"PFMT64x\",ip,=\", op->jump);",
          "288:   esilprintf (op, \"0x%\"PFMT64x\",ip,=\", op->jump);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "305:   ut32 vB = len > 3?(data[3] << 8) | data[2] : 0;",
          "308:   op->fail = addr + sz;",
          "309:   op->type = R_ANAL_OP_TYPE_CALL;",
          "310:   }",
          "311:   break;",
          "312:  case 0x27: // throw",
          "",
          "[Removed Lines]",
          "306:   op->jump = anal->binb.get_offset (",
          "307:    anal->binb.bin, 'm', vB);",
          "",
          "[Added Lines]",
          "351:   op->jump = anal->binb.get_offset (anal->binb.bin, 'm', vB);",
          "355:   esilprintf (op, \"8,sp,-=,0x%\"PFMT64x\",sp,=[8],0x%\"PFMT64x\",ip,=\", addr);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "326:  case 0x25: // filled-new-array-range",
          "327:  case 0x26: // filled-new-array-data",
          "328:   op->type = R_ANAL_OP_TYPE_NEW;",
          "329:   break;",
          "330:  case 0x00: // nop",
          "331:   op->type = R_ANAL_OP_TYPE_NOP;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "377:   {",
          "379:    int vB = (data[3] << 8) | data[2];",
          "381:    ut64 off = R_ANAL_GET_OFFSET (anal, 't', vB);",
          "382:    op->ptr = off;",
          "383:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "380:   op->type = R_ANAL_OP_TYPE_SHL;",
          "381:   break;",
          "382:  }",
          "384:  return sz;",
          "385: }",
          "387: static int set_reg_profile(RAnal *anal) {",
          "389:  \"=PC ip\\n\"",
          "390:  \"=SP sp\\n\"",
          "391:  \"=BP bp\\n\"",
          "",
          "[Removed Lines]",
          "388:  const char *p =",
          "",
          "[Added Lines]",
          "442:  const char *p =",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "397:  \"gpr v1 .32 4 0\\n\"",
          "398:  \"gpr v2 .32 8 0\\n\"",
          "399:  \"gpr v3 .32 12 0\\n\"",
          "402:  ;",
          "403:  return r_reg_set_profile_string (anal->reg, p);",
          "404: }",
          "",
          "[Removed Lines]",
          "400:  \"gpr ip .32 40 0\\n\"",
          "401:  \"gpr sp .32 44 0\\n\"",
          "",
          "[Added Lines]",
          "454:  \"gpr v4 .32 16 0\\n\"",
          "455:  \"gpr v5 .32 20 0\\n\"",
          "456:  \"gpr v6 .32 24 0\\n\"",
          "457:  \"gpr v7 .32 28 0\\n\"",
          "458:  \"gpr v8 .32 32 0\\n\"",
          "459:  \"gpr v9 .32 36 0\\n\"",
          "460:  \"gpr v10 .32 40 0\\n\"",
          "461:  \"gpr v11 .32 44 0\\n\"",
          "462:  \"gpr v12 .32 48 0\\n\"",
          "463:  \"gpr v13 .32 52 0\\n\"",
          "464:  \"gpr v14 .32 56 0\\n\"",
          "465:  \"gpr v15 .32 60 0\\n\"",
          "466:  \"gpr ip .32 64 0\\n\"",
          "467:  \"gpr sp .32 68 0\\n\"",
          "468:  \"gpr bp .32 72 0\\n\"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "408:  return addr >= bin_dex->code_from && addr <= bin_dex->code_to;",
          "409: }",
          "412:  .name = \"dalvik\",",
          "413:  .arch = \"dalvik\",",
          "414:  .set_reg_profile = &set_reg_profile,",
          "",
          "[Removed Lines]",
          "411: struct r_anal_plugin_t r_anal_plugin_dalvik = {",
          "",
          "[Added Lines]",
          "478: RAnalPlugin r_anal_plugin_dalvik = {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "420: };",
          "422: #ifndef CORELIB",
          "424:  .type = R_LIB_TYPE_ANAL,",
          "425:  .data = &r_anal_plugin_dalvik,",
          "426:  .version = R2_VERSION",
          "",
          "[Removed Lines]",
          "423: struct r_lib_struct_t radare_plugin = {",
          "",
          "[Added Lines]",
          "490: RLibStruct radare_plugin = {",
          "",
          "---------------"
        ],
        "libr/bin/format/dex/dex.c||libr/bin/format/dex/dex.c": [
          "File: libr/bin/format/dex/dex.c -> libr/bin/format/dex/dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <r_util.h>",
          "5: #include \"dex.h\"",
          "15: char* r_bin_dex_get_version(RBinDexObj *bin) {",
          "16:  if (bin) {",
          "17:   ut8* version = calloc (1, 8);",
          "",
          "[Removed Lines]",
          "7: #define DEBUG_PRINTF 0",
          "9: #if DEBUG_PRINTF",
          "10: #define dprintf eprintf",
          "11: #else",
          "12: #define dprintf if (0)eprintf",
          "13: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:   goto fail;",
          "37:  }",
          "40:   goto fail;",
          "41:  }",
          "42:  bufptr = bin->b->buf;",
          "",
          "[Removed Lines]",
          "39:  if (bin->size < sizeof(struct dex_header_t)) {",
          "",
          "[Added Lines]",
          "31:  if (bin->size < sizeof (struct dex_header_t)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:  dexhdr->data_size = r_read_le32 (bufptr + 104);",
          "71:  dexhdr->data_offset = r_read_le32 (bufptr + 108);",
          "100:  bin->strings = (ut32 *) calloc (dexhdr->strings_size + 1, sizeof (ut32));",
          "101:  if (!bin->strings) {",
          "102:   goto fail;",
          "",
          "[Removed Lines]",
          "73: #if DEBUG_PRINTF",
          "74:  dprintf (\"DEX file header:\\n\");",
          "75:  dprintf (\"magic               : 'dex\\\\n035\\\\0'\\n\");",
          "76:  dprintf (\"checksum            : %x\\n\", dexhdr->checksum);",
          "77:  dprintf (\"signature           : %02x%02x...%02x%02x\\n\", dexhdr->signature[0], dexhdr->signature[1], dexhdr->signature[18], dexhdr->signature[19]);",
          "78:  dprintf (\"file_size           : %d\\n\", dexhdr->size);",
          "79:  dprintf (\"header_size         : %d\\n\", dexhdr->header_size);",
          "80:  dprintf (\"link_size           : %d\\n\", dexhdr->linksection_size);",
          "81:  dprintf (\"link_off            : %d (0x%06x)\\n\", dexhdr->linksection_offset, dexhdr->linksection_offset);",
          "82:  dprintf (\"string_ids_size     : %d\\n\", dexhdr->strings_size);",
          "83:  dprintf (\"string_ids_off      : %d (0x%06x)\\n\", dexhdr->strings_offset, dexhdr->strings_offset);",
          "84:  dprintf (\"type_ids_size       : %d\\n\", dexhdr->types_size);",
          "85:  dprintf (\"type_ids_off        : %d (0x%06x)\\n\", dexhdr->types_offset, dexhdr->types_offset);",
          "86:  dprintf (\"proto_ids_size       : %d\\n\", dexhdr->prototypes_size);",
          "87:  dprintf (\"proto_ids_off        : %d (0x%06x)\\n\", dexhdr->prototypes_offset, dexhdr->prototypes_offset);",
          "88:  dprintf (\"field_ids_size      : %d\\n\", dexhdr->fields_size);",
          "89:  dprintf (\"field_ids_off       : %d (0x%06x)\\n\", dexhdr->fields_offset, dexhdr->fields_offset);",
          "90:  dprintf (\"method_ids_size     : %d\\n\", dexhdr->method_size);",
          "91:  dprintf (\"method_ids_off      : %d (0x%06x)\\n\", dexhdr->method_offset, dexhdr->method_offset);",
          "92:  dprintf (\"class_defs_size     : %d\\n\", dexhdr->class_size);",
          "93:  dprintf (\"class_defs_off      : %d (0x%06x)\\n\", dexhdr->class_offset, dexhdr->class_offset);",
          "94:  dprintf (\"data_size           : %d\\n\", dexhdr->data_size);",
          "95:  dprintf (\"data_off            : %d (0x%06x)\\n\\n\", dexhdr->data_offset, dexhdr->data_offset);",
          "96: #endif",
          "99:  #define STRINGS_SIZE ((dexhdr->strings_size+1)*sizeof(ut32))",
          "",
          "[Added Lines]",
          "69:  #define STRINGS_SIZE ((dexhdr->strings_size + 1) * sizeof (ut32))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "115:   bin->strings[i] = r_read_le32 (bufptr + offset);",
          "116:  }",
          "119:  if (dexhdr->class_offset + classes_size >= bin->size) {",
          "120:   classes_size = bin->size - dexhdr->class_offset;",
          "121:  }",
          "122:  if (classes_size < 0) {",
          "123:   classes_size = 0;",
          "124:  }",
          "127:  for (i = 0; i < dexhdr->class_size; i++) {",
          "129:   if (offset + 32 > bin->size) {",
          "130:    free (bin->strings);",
          "131:    free (bin->classes);",
          "",
          "[Removed Lines]",
          "118:  int classes_size = dexhdr->class_size * sizeof (struct dex_class_t);",
          "125:  dexhdr->class_size = classes_size / sizeof (struct dex_class_t);",
          "126:  bin->classes = (struct dex_class_t *) malloc (classes_size);",
          "128:   ut64 offset = dexhdr->class_offset + i * sizeof (struct dex_class_t);",
          "",
          "[Added Lines]",
          "89:  int classes_size = dexhdr->class_size * DEX_CLASS_SIZE;",
          "97:  dexhdr->class_size = classes_size / DEX_CLASS_SIZE;",
          "98:  bin->classes = (struct dex_class_t *) malloc (sizeof (struct dex_class_t) * dexhdr->class_size);",
          "100:   ut64 offset = dexhdr->class_offset + i * DEX_CLASS_SIZE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "249: }",
          "253:  ut8 len = dex_uleb128_len (ptr);",
          "254:  const ut8 *in = ptr + len - 1;",
          "255:  ut32 result = 0;",
          "",
          "[Removed Lines]",
          "252: int dex_read_uleb128 (const ut8 *ptr) {",
          "",
          "[Added Lines]",
          "224: int dex_read_uleb128(const ut8 *ptr) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "268: }",
          "270: #define LEB_MAX_SIZE 6",
          "272:  int i = 1, result = *(ptr++);",
          "273:  while (result > 0x7f && i <= LEB_MAX_SIZE) {",
          "274:   result = *(ptr++);",
          "",
          "[Removed Lines]",
          "271: int dex_uleb128_len (const ut8 *ptr) {",
          "",
          "[Added Lines]",
          "243: int dex_uleb128_len(const ut8 *ptr) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "278: }",
          "280: #define SIG_EXTEND(X,Y) X = (X << Y) >> Y",
          "282:  int cur, result;",
          "283:  ut8 len = dex_uleb128_len ((const ut8*)ptr);",
          "284:  ptr += len - 1;",
          "",
          "[Removed Lines]",
          "281: int dex_read_sleb128 (const char *ptr) {",
          "",
          "[Added Lines]",
          "253: int dex_read_sleb128(const char *ptr) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "309:   }",
          "310:  }",
          "311:  return result;",
          "",
          "[Removed Lines]",
          "312: }",
          "",
          "[Added Lines]",
          "284: }",
          "",
          "---------------"
        ],
        "libr/bin/format/dex/dex.h||libr/bin/format/dex/dex.h": [
          "File: libr/bin/format/dex/dex.h -> libr/bin/format/dex/dex.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <r_bin.h>",
          "6: #define R_BIN_DEX_MAXSTR 256",
          "8: #pragma pack(4)",
          "9: typedef struct dex_header_t {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #define DEX_CLASS_SIZE (32)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53: #pragma pack(1)",
          "54: typedef struct dex_method_t {",
          "58: } RBinDexMethod;",
          "60: #pragma pack(1)",
          "",
          "[Removed Lines]",
          "55:         ut16 class_id;",
          "56:         ut16 proto_id;",
          "57:         ut32 name_id;",
          "",
          "[Added Lines]",
          "56:  ut16 class_id;",
          "57:  ut16 proto_id;",
          "58:  ut32 name_id;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "67:  ut32 anotations_offset;",
          "68:  ut32 class_data_offset;",
          "69:  ut32 static_values_offset;",
          "70: } RBinDexClass;",
          "72: typedef struct r_bin_dex_obj_t {",
          "73:  int size;",
          "74:  const char *file;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71:  struct dex_class_data_item_t *class_data;",
          "74: #pragma pack(1)",
          "75: typedef struct dex_class_data_item_t {",
          "76:  ut64 static_fields_size;",
          "77:  ut64 instance_fields_size;",
          "78:  ut64 direct_methods_size;",
          "79:  ut64 virtual_methods_size;",
          "80: } RBinDexClassData;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "96:  int last;",
          "97: };",
          "99: char* r_bin_dex_get_version(struct r_bin_dex_obj_t* bin);",
          "100: struct r_bin_dex_obj_t *r_bin_dex_new_buf(struct r_buf_t *buf);",
          "101: struct r_bin_dex_str_t *r_bin_dex_get_strings (struct r_bin_dex_obj_t* bin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109: struct dex_encoded_type_addr_pair_t {",
          "110:  ut64 type_idx;",
          "111:  ut64 addr;",
          "112: };",
          "114: struct dex_encoded_catch_handler_t {",
          "115:  st64 size;",
          "116:  struct dex_encoded_type_addr_pair_t *handlers;",
          "117:  ut64 catch_all_addr;",
          "118: };",
          "120: struct dex_debug_position_t {",
          "121:  ut64 address;",
          "122:  ut64 line;",
          "123: };",
          "125: struct dex_debug_local_t {",
          "126:  const char *name;",
          "127:  const char *descriptor;",
          "128:  const char *signature;",
          "129:  ut16 startAddress;",
          "130:  bool live;",
          "131:  int reg;",
          "132:  ut16 endAddress;",
          "133: };",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c": [
          "File: libr/bin/p/bin_dex.c -> libr/bin/p/bin_dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include <r_types.h>",
          "3: #include <r_util.h>",
          "4: #include <r_lib.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include <r_cons.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "15: #define dprintf if (0)eprintf",
          "16: #endif",
          "18: static Sdb *mdb = NULL;",
          "20: static char *getstr(RBinDexObj *bin, int idx) {",
          "21:  ut8 buf[6];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: static bool dexdump = false;",
          "22: static Sdb *cdb = NULL; // TODO: remove if it is not used",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "69:  return count;",
          "70: }",
          "75: typedef enum {",
          "76:  kAccessForClass = 0, kAccessForMethod = 1, kAccessForField = 2,",
          "77:  kAccessForMAX",
          "78: } AccessFor;",
          "86: static char *createAccessFlagStr(ut32 flags, AccessFor forWhat) {",
          "88:  static const char* kAccessStrings[kAccessForMAX][NUM_FLAGS] = {",
          "89:   {",
          "",
          "[Removed Lines]",
          "87: #define NUM_FLAGS 18",
          "",
          "[Added Lines]",
          "78:  #define NUM_FLAGS 18",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "151:   },",
          "152:  };",
          "154:  int i, count;",
          "155:  char* str;",
          "156:  char* cp;",
          "163:  count = countOnes(flags);",
          "164:  cp = str = (char*) malloc(count * (kLongest+1) +1);",
          "165:  for (i = 0; i < NUM_FLAGS; i++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144:  const int kLongest = 21;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "210:  }",
          "211:  bufptr = bin->b->buf;",
          "212:  list_size = r_read_le32 (bufptr + params_off); // size of the list, in entries",
          "214:  if (!signature) {",
          "215:   return NULL;",
          "216:  }",
          "220:  for (i = 0; i < list_size; i++) {",
          "221:   int buff_len = 0;",
          "222:   if (params_off + 4 + (i*2) >= bin->size) {",
          "",
          "[Removed Lines]",
          "213:  signature = calloc (0, sizeof (char));",
          "",
          "[Added Lines]",
          "197:  signature = calloc (0, sizeof(char));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "236:   strcpy (signature + pos, buff);",
          "237:   pos += buff_len;",
          "238:  }",
          "241:  free (buff);",
          "242:  r = r_str_newf (\"(%s)%s\", signature, return_type);",
          "243:  free (signature);",
          "244:  return r;",
          "245: }",
          "247: static int check (RBinFile *arch);",
          "248: static int check_bytes (const ut8 *buf, ut64 length);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226: static RList *dex_method_signature2(RBinDexObj *bin, int method_idx) {",
          "227:  ut32 proto_id, params_off, list_size;",
          "228:  char *buff = NULL;",
          "229:  ut8 *bufptr;",
          "230:  ut16 type_idx;",
          "231:  int i;",
          "233:  RList *params = r_list_new();",
          "235:  if (method_idx < 0 || method_idx >= bin->header.method_size) {",
          "236:   return NULL;",
          "237:  }",
          "238:  proto_id = bin->methods[method_idx].proto_id;",
          "239:  if (proto_id >= bin->header.prototypes_size) {",
          "240:   return NULL;",
          "241:  }",
          "242:  params_off = bin->protos[proto_id].parameters_off;",
          "243:  if (params_off  >= bin->size) {",
          "244:   return NULL;",
          "245:  }",
          "246:  if (!params_off) {",
          "247:   return params;",
          "248:  }",
          "250:  bufptr = bin->b->buf;",
          "251:  list_size = r_read_le32 (bufptr + params_off); // size of the list, in entries",
          "253:  for (i = 0; i < list_size; i++) {",
          "254:   if (params_off + 4 + (i*2) >= bin->size) {",
          "255:    continue;",
          "256:   }",
          "257:   type_idx = r_read_le16 (bufptr + params_off + 4 + (i*2));",
          "258:   if (type_idx < 0 || type_idx >= bin->header.types_size) {",
          "259:    continue;",
          "260:   }",
          "261:   buff = getstr (bin, bin->types[type_idx].descriptor_id);",
          "262:   if (!buff) {",
          "263:    continue;",
          "264:   }",
          "265:   r_list_append (params, buff);",
          "266:  }",
          "267:  return params;",
          "268: }",
          "273: static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, int MI, int MA, int ins_size, int insns_size, char* class_name, int regsz, int debug_info_off) {",
          "274:  struct r_bin_t *rbin = binfile->rbin;",
          "275:  const ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);",
          "276:  const ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;",
          "277:  ut64 line_start;",
          "278:  ut64 parameters_size;",
          "279:  ut64 param_type_idx;",
          "280:  ut16 argReg = regsz - ins_size; // ins_size or insns_size",
          "282:  p4 = r_uleb128 (p4, p4_end - p4, &line_start);",
          "283:  p4 = r_uleb128 (p4, p4_end - p4, &parameters_size);",
          "287:  ut32 address = 0;",
          "288:  ut32 line = line_start;",
          "293:  RList *debug_positions = r_list_new ();",
          "294:  RList *emitted_debug_locals = r_list_new ();",
          "296:  struct dex_debug_local_t debug_locals[regsz];",
          "297:  memset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);",
          "299:  if ((MA & 0x0008) == 0) {",
          "300:   debug_locals[argReg].name = \"this\";",
          "301:   debug_locals[argReg].descriptor = class_name;",
          "302:   debug_locals[argReg].startAddress = 0;",
          "303:   debug_locals[argReg].signature = NULL;",
          "304:   debug_locals[argReg].live = true;",
          "305:   argReg++;",
          "306:  }",
          "308:  RList *params = dex_method_signature2 (bin, MI);",
          "310:  if (!params || r_list_empty (params)) {",
          "311:   return;",
          "312:  }",
          "314:  RListIter *iter = r_list_iterator (params);",
          "315:  char *name;",
          "316:  char *type;",
          "317:  int reg;",
          "318:  while (parameters_size-- != 0) {",
          "319:   type = (char *) r_list_iter_get (iter);",
          "321:   if ((argReg >= regsz) || !type || r_list_empty (params)) {",
          "322:    return;",
          "323:   }",
          "325:   p4 = r_uleb128 (p4, p4_end - p4, &param_type_idx);",
          "326:   name = getstr (bin, bin->types[param_type_idx].descriptor_id);",
          "327:   reg = argReg;",
          "329:   switch (type[0]) {",
          "330:    case 'D':",
          "331:    case 'J':",
          "332:     argReg += 2;",
          "333:     break;",
          "334:    default:",
          "335:     argReg += 1;",
          "336:     break;",
          "337:   }",
          "339:   if (name != NULL) {",
          "340:    debug_locals[reg].name = name;",
          "341:    debug_locals[reg].descriptor = type;",
          "342:    debug_locals[reg].signature = NULL;",
          "343:    debug_locals[reg].startAddress = address;",
          "344:    debug_locals[reg].live = true;",
          "345:   }",
          "347:   r_list_iter_next (iter);",
          "348:  }",
          "350:  ut8 opcode = *(p4++) & 0xff;",
          "351:  while (true) {",
          "352:   if (opcode == 0x0) { // DBG_END_SEQUENCE",
          "354:    break;",
          "355:   } else if (opcode == 0x1) { // DBG_ADVANCE_PC",
          "356:    ut64 addr_diff;",
          "357:    p4 = r_uleb128 (p4, p4_end - p4, &addr_diff);",
          "358:    address += addr_diff;",
          "359:   } else if (opcode == 0x2) { // DBG_ADVANCE_LINE",
          "360:    st64 line_diff = gum_read_sleb128 ((const ut8**)&p4, p4_end - p4);",
          "361:    line += line_diff;",
          "362:   } else if (opcode == 0x3) { // DBG_START_LOCAL",
          "363:    ut64 register_num;",
          "364:    ut64 name_idx;",
          "365:    ut64 type_idx;",
          "366:    p4 = r_uleb128 (p4, p4_end - p4, &register_num);",
          "367:    p4 = r_uleb128 (p4, p4_end - p4, &name_idx); name_idx -= 1;",
          "368:    p4 = r_uleb128 (p4, p4_end - p4, &type_idx); type_idx -= 1;",
          "370:    if (register_num > regsz) {",
          "371:     return;",
          "372:    }",
          "376:    if (debug_locals[register_num].live) {",
          "377:     struct dex_debug_local_t *local = malloc(sizeof(struct dex_debug_local_t));",
          "378:     local->name = debug_locals[register_num].name;",
          "379:     local->descriptor = debug_locals[register_num].descriptor;",
          "380:     local->startAddress = debug_locals[register_num].startAddress;",
          "381:     local->signature = debug_locals[register_num].signature;",
          "382:     local->live = true;",
          "383:     local->reg = register_num;",
          "384:     local->endAddress = address;",
          "385:     r_list_append (emitted_debug_locals, local);",
          "386:    }",
          "388:    debug_locals[register_num].name = getstr (bin, name_idx);",
          "389:    debug_locals[register_num].descriptor = getstr (bin, bin->types[type_idx].descriptor_id);",
          "390:    debug_locals[register_num].startAddress = address;",
          "391:    debug_locals[register_num].signature = NULL;",
          "392:    debug_locals[register_num].live = true;",
          "394:   } else if (opcode == 0x4) { //DBG_START_LOCAL_EXTENDED",
          "395:    ut64 register_num;",
          "396:    ut64 name_idx;",
          "397:    ut64 type_idx;",
          "398:    ut64 sig_idx;",
          "399:    p4 = r_uleb128 (p4, p4_end - p4, &register_num);",
          "400:    p4 = r_uleb128 (p4, p4_end - p4, &name_idx); name_idx -= 1;",
          "401:    p4 = r_uleb128 (p4, p4_end - p4, &type_idx); type_idx -= 1;",
          "402:    p4 = r_uleb128 (p4, p4_end - p4, &sig_idx); sig_idx -= 1;",
          "404:    if (register_num > regsz) {",
          "405:     return;",
          "406:    }",
          "410:    if (debug_locals[register_num].live) {",
          "411:     struct dex_debug_local_t *local = malloc(sizeof(struct dex_debug_local_t));",
          "412:     local->name = debug_locals[register_num].name;",
          "413:     local->descriptor = debug_locals[register_num].descriptor;",
          "414:     local->startAddress = debug_locals[register_num].startAddress;",
          "415:     local->signature = debug_locals[register_num].signature;",
          "416:     local->live = true;",
          "417:     local->reg = register_num;",
          "418:     local->endAddress = address;",
          "419:     r_list_append (emitted_debug_locals, local);",
          "420:    }",
          "422:    debug_locals[register_num].name = getstr (bin, name_idx);",
          "423:    debug_locals[register_num].descriptor = getstr (bin, bin->types[type_idx].descriptor_id);",
          "424:    debug_locals[register_num].startAddress = address;",
          "425:    debug_locals[register_num].signature = getstr (bin, sig_idx);",
          "426:    debug_locals[register_num].live = true;",
          "427:   } else if (opcode == 0x5) { // DBG_END_LOCAL",
          "428:    ut64 register_num;",
          "429:    p4 = r_uleb128 (p4, p4_end - p4, &register_num);",
          "431:    if (debug_locals[register_num].live) {",
          "432:     struct dex_debug_local_t *local = malloc(sizeof(struct dex_debug_local_t));",
          "433:     local->name = debug_locals[register_num].name;",
          "434:     local->descriptor = debug_locals[register_num].descriptor;",
          "435:     local->startAddress = debug_locals[register_num].startAddress;",
          "436:     local->signature = debug_locals[register_num].signature;",
          "437:     local->live = true;",
          "438:     local->reg = register_num;",
          "439:     local->endAddress = address;",
          "440:     r_list_append (emitted_debug_locals, local);",
          "441:    }",
          "442:    debug_locals[register_num].live = false;",
          "443:   } else if (opcode == 0x6) { // DBG_RESTART_LOCAL",
          "444:    ut64 register_num;",
          "445:    p4 = r_uleb128 (p4, p4_end - p4, &register_num);",
          "446:    if (!debug_locals[register_num].live) {",
          "447:     debug_locals[register_num].startAddress = address;",
          "448:     debug_locals[register_num].live = true;",
          "449:    }",
          "450:   } else if (opcode == 0x7) {//DBG_SET_PROLOGUE_END",
          "453:   } else if (opcode == 0x8) {// DBG_SET_EPILOGUE_BEGIN",
          "456:   } else if (opcode == 0x9) {",
          "457:    ut64 name_idx;",
          "458:    p4 = r_uleb128 (p4, p4_end - p4, &name_idx); name_idx -= 1;",
          "459:   } else {",
          "460:    int adjusted_opcode = opcode - 0x0a;",
          "461:    address += (adjusted_opcode / 15);",
          "462:    line += -4 + (adjusted_opcode % 15);",
          "464:    struct dex_debug_position_t *position = malloc (sizeof (struct dex_debug_position_t));",
          "465:    position->address = address;",
          "466:    position->line = line;",
          "467:    r_list_append (debug_positions, position);",
          "470:   }",
          "471:   opcode = *(p4++) & 0xff;",
          "472:  }",
          "474:  if (!dexdump) {",
          "475:   return;",
          "476:  }",
          "478:  RListIter *iter2;",
          "479:  struct dex_debug_position_t *position;",
          "481:  rbin->cb_printf (\"      positions     : \\n\");",
          "482:  r_list_foreach (debug_positions, iter2, position) {",
          "483:   rbin->cb_printf (\"        0x%04llx line=%llu\\n\", position->address, position->line);",
          "484:  }",
          "486:  rbin->cb_printf (\"      locals        : \\n\");",
          "488:  RListIter *iter3;",
          "489:  struct dex_debug_local_t *local;",
          "490:  r_list_foreach (emitted_debug_locals, iter3, local) {",
          "491:   if (local->signature) {",
          "492:    rbin->cb_printf (\"        0x%04x - 0x%04x reg=%d %s %s; %s\\n\", local->startAddress, local->endAddress, local->reg, local->name, local->descriptor, local->signature);",
          "493:   } else {",
          "494:    rbin->cb_printf (\"        0x%04x - 0x%04x reg=%d %s %s; \\n\", local->startAddress, local->endAddress, local->reg, local->name, local->descriptor);",
          "495:   }",
          "496:  }",
          "498:  for (reg = 0; reg < regsz; reg++) {",
          "499:   if (debug_locals[reg].live) {",
          "500:    if (debug_locals[reg].signature) {",
          "501:     rbin->cb_printf (\"        0x%04x - 0x%04x reg=%d %s %s; %s\\n\", debug_locals[reg].startAddress, insns_size, reg, debug_locals[reg].name, debug_locals[reg].descriptor, debug_locals[reg].signature);",
          "502:    } else {",
          "503:     rbin->cb_printf (\"        0x%04x - 0x%04x reg=%d %s %s; \\n\", debug_locals[reg].startAddress, insns_size, reg, debug_locals[reg].name, debug_locals[reg].descriptor);",
          "504:    }",
          "505:   }",
          "506:  }",
          "507: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "352:   ut32  cc = __adler32 (arch->buf->buf + 12, arch->buf->length - 12);",
          "353:   if (*fc != cc) {",
          "354:    eprintf (\"# adler32 checksum doesn't match. Type this to fix it:\\n\");",
          "358:   }",
          "359:  }",
          "360:  ret->arch = strdup (\"dalvik\");",
          "",
          "[Removed Lines]",
          "355:    eprintf (\"# found 0x%08x   should be 0x%08x\\n\", *fc, cc);",
          "356:    eprintf (\"wv 0x%08x @ 8\\n\", cc);",
          "357:    eprintf (\"wx `ph sha1 $s-32 @32` @ 12 ; wx `ph adler32 $s-12 @ 12` @ 8\\n\");",
          "",
          "[Added Lines]",
          "617:    eprintf (\"wx `#sha1 $s-32 @32` @12 ; wx `#adler32 $s-12 @12` @8\\n\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "397:   len = dex_read_uleb128 (buf);",
          "399:   if (len > 1 && len < R_BIN_SIZEOF_STRINGS) {",
          "401:    if (!ptr->string) {",
          "402:     goto out_error;",
          "403:    }",
          "404:    off = bin->strings[i] + dex_uleb128_len (buf);",
          "405:    if (off > bin->size || off + len > bin->size) {",
          "407:     goto out_error;",
          "408:    }",
          "409:    r_buf_read_at (bin->b, off, (ut8*)ptr->string, len);",
          "",
          "[Removed Lines]",
          "400:    ptr->string = calloc (len + 1, 1);",
          "406:     R_FREE (ptr->string);",
          "",
          "[Added Lines]",
          "660:    ptr->string = malloc (len + 1);",
          "666:     free (ptr->string);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "424:  return NULL;",
          "425: }",
          "458: static char *dex_method_name(RBinDexObj *bin, int idx) {",
          "459:  if (idx < 0 || idx >= bin->header.method_size) {",
          "460:   return NULL;",
          "461:  }",
          "462:  int cid = bin->methods[idx].class_id;",
          "464:  if (cid < 0 || cid >= bin->header.strings_size) {",
          "465:   return NULL;",
          "466:  }",
          "467:  if (tid < 0 || tid >= bin->header.strings_size) {",
          "468:   return NULL;",
          "469:  }",
          "",
          "[Removed Lines]",
          "428: static char *get_string(RBinDexObj *bin, int cid, int idx) {",
          "429:  char *c_name, *m_name, *res;",
          "430:  if (idx < 0 || idx >= bin->header.strings_size) {",
          "431:   return NULL;",
          "432:  }",
          "433:  if (cid < 0 || cid >= bin->header.strings_size) {",
          "434:   return NULL;",
          "435:  }",
          "436:  c_name = getstr (bin, cid);",
          "437:  m_name = getstr (bin, idx);",
          "438:  if (c_name && *c_name == ',') {",
          "439:   res = r_str_newf (\"%s\", m_name);",
          "440:  } else {",
          "441:   if (c_name && m_name) {",
          "442:    res = r_str_newf (\"%s\", m_name);",
          "443:   } else {",
          "444:    if (c_name && m_name) {",
          "445:     res = r_str_newf (\"unk.%s\", c_name);",
          "446:    } else {",
          "447:     res = r_str_newf (\"UNKNOWN\");",
          "448:    }",
          "449:   }",
          "450:  }",
          "451:  free (c_name);",
          "452:  free (m_name);",
          "453:  return res;",
          "454: }",
          "463:  int tid = bin->methods[idx].name_id;",
          "",
          "[Added Lines]",
          "695:  int tid = bin->methods[idx].name_id;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "482:  return getstr (bin, tid);",
          "483: }",
          "485: static char *dex_field_name(RBinDexObj *bin, int fid) {",
          "486:  int tid;",
          "487:  if (!bin || !bin->fields) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "714: static char *dex_class_name(RBinDexObj *bin, RBinDexClass *c) {",
          "715:  return dex_class_name_byid (bin, c->class_id);",
          "716: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "523:  return flagname;",
          "524: }",
          "547:  }",
          "551:  }",
          "554: }",
          "557: static void __r_bin_class_free(RBinClass *p) {",
          "558:  r_list_free (p->methods);",
          "559:  r_list_free (p->fields);",
          "",
          "[Removed Lines]",
          "527: static char *getClassName(const char *name) {",
          "528:  const char *p;",
          "529:  if (!name) {",
          "530:   return NULL;",
          "531:  }",
          "532:  p = strstr (name, \".L\");",
          "533:  if (p) {",
          "534:   char *q, *r = strdup (p + 2);",
          "535:   q = strchr (r, ';');",
          "536:   if (q) *q = 0;",
          "537:   return r;",
          "538:  }",
          "539:  return NULL;",
          "540: }",
          "543: static char *dex_class_name(RBinDexObj *bin, RBinDexClass *c) {",
          "544:  int cid, tid;",
          "545:  if (!bin || !c || !bin->types) {",
          "546:   return NULL;",
          "548:  cid = c->class_id;",
          "549:  if (cid < 0 || cid >= bin->header.types_size) {",
          "550:   return NULL;",
          "552:  tid = bin->types[cid].descriptor_id;",
          "553:  return getstr (bin, tid);",
          "",
          "[Added Lines]",
          "755: static ut64 dex_get_type_offset(RBinFile *arch, int type_idx) {",
          "756:  RBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;",
          "757:  if (!bin || !bin->types) {",
          "758:   return 0;",
          "760:  if (type_idx < 0 || type_idx >= bin->header.types_size) {",
          "761:   return 0;",
          "763:  return bin->header.types_offset + type_idx * 0x04; //&bin->types[type_idx];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "573:  return getstr (bin, tid);",
          "574: }",
          "578:  ut8 ff[sizeof (DexField)] = {0};",
          "583:  DexField field;",
          "635:   ut64 fieldIndex, accessFlags;",
          "637:   p = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex",
          "",
          "[Removed Lines]",
          "576: static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, int class_index, int *methods, int *sym_count) {",
          "577:  ut64 SF, IF, DM, VM, lastIndex;",
          "579:  ut8 ff2[16] = {0};",
          "580:  char *class_name, *cln = NULL;",
          "581:  int total, i;",
          "582:  const ut8 *p, *p_end;",
          "585:  if (!c || !c->class_data_offset) {",
          "586:   return;",
          "587:  }",
          "589:  class_name = dex_class_name (bin, c);",
          "590:  class_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func",
          "592:  if (!class_name || !*class_name) {",
          "593:   return;",
          "594:  }",
          "596:  dprintf(\"  Class descriptor  : '%s'\\n\", dex_class_name (bin, c));",
          "597:  dprintf(\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags, createAccessFlagStr(c->access_flags, kAccessForClass));",
          "598:  dprintf(\"  Superclass        : '%s'\\n\", dex_class_super_name (bin, c));",
          "599:  dprintf(\"  Interfaces        -\\n\");",
          "601:  p = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);",
          "602:  p_end = p + binfile->buf->length - c->class_data_offset;",
          "606:  p = r_uleb128 (p, p_end - p, &SF);",
          "607:  p = r_uleb128 (p, p_end - p, &IF);",
          "608:  p = r_uleb128 (p, p_end - p, &DM);",
          "609:  p = r_uleb128 (p, p_end - p, &VM);",
          "617:  RBinClass *cls = R_NEW0 (RBinClass);",
          "621:  cls->name = class_name;",
          "622:  cls->index = class_index;",
          "623:  cls->addr = c->class_id + bin->header.class_offset;",
          "624:  cls->methods = r_list_new ();",
          "626:  cls->fields = r_list_new ();",
          "629:  r_list_append (bin->classes_list, cls);",
          "631:  dprintf(\"  Static fields     -\\n\");",
          "633:  lastIndex = 0;",
          "634:  for (i = 0; i < SF; i++) {",
          "",
          "[Added Lines]",
          "785: static const ut8* parse_dex_class_fields(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, RBinClass *cls, const ut8 *p, const ut8 *p_end, int *sym_count, ut64 fields_count, bool is_sfield) {",
          "786:  struct r_bin_t *rbin = binfile->rbin;",
          "787:  ut64 lastIndex = 0;",
          "789:  int total, i, tid;",
          "791:  const char* type_str;",
          "793:  for (i = 0; i < fields_count; i++) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "646:   field.name_id = r_read_le32 (ff + 4);",
          "647:   char *fieldName = getstr (bin, field.name_id);",
          "650:   if (field.type_id < 0 || field.type_id >= bin->header.types_size) {",
          "651:    break;",
          "652:   }",
          "662:    sym->type = r_str_const (\"STATIC\");",
          "695:   }",
          "707:   }",
          "728:   lastIndex = fieldIndex;",
          "729:  }",
          "733:  ut64 omi = 0;",
          "734:  for (i = 0; i < DM; i++) {",
          "735:   char *method_name, *flag_name;",
          "736:   ut64 MI, MA, MC;",
          "737:   p = r_uleb128 (p, p_end - p, &MI);",
          "738:   MI += omi;",
          "739:   omi = MI;",
          "744:   p = r_uleb128 (p, p_end - p, &MA);",
          "745:   p = r_uleb128 (p, p_end - p, &MC);",
          "",
          "[Removed Lines]",
          "649:   const char* accessStr = createAccessFlagStr(accessFlags, kAccessForField);",
          "653:   int tid = bin->types[field.type_id].descriptor_id;",
          "654:   const char* type_str = getstr (bin, tid);//get_string(bin, field.type_id, tid);",
          "656:   if (1) {",
          "657:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "659:    sym->name = r_str_newf (\"%s.sfield_%s:%s\", class_name, fieldName, type_str);",
          "660:    sym->name = r_str_replace (sym->name, \"method.\", \"\", 0);",
          "661:    sym->name = r_str_replace (sym->name, \";\", \"\", 0);",
          "663:    sym->paddr = sym->vaddr = total;",
          "664:    sym->ordinal = (*sym_count)++;",
          "666:    dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "667:    dprintf(\"      name          : '%s'\\n\", fieldName);",
          "668:    dprintf(\"      type          : '%s'\\n\", type_str);",
          "669:    dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)accessFlags, accessStr);",
          "671:    r_list_append (bin->methods_list, sym);",
          "672:    r_list_append (cls->fields, sym);",
          "673:   }",
          "674:   lastIndex = fieldIndex;",
          "675:  }",
          "677:  dprintf(\"  Instance fields   -\\n\");",
          "679:  lastIndex = 0;",
          "680:  for (i = 0; i < IF; i++) {",
          "681:   DexField field;",
          "682:   ut64 fieldIndex, accessFlags;",
          "684:   p = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex",
          "685:   p = r_uleb128 (p, p_end - p, &accessFlags); // accessFlags",
          "686:   fieldIndex += lastIndex;",
          "687:   total = bin->header.fields_offset + (sizeof (DexField) * fieldIndex);",
          "688:   if ((int)fieldIndex < 0) {",
          "689:    eprintf (\"Invalid field index %d\\n\", (int)fieldIndex);",
          "690:    continue;",
          "691:   }",
          "692:   if (r_buf_read_at (binfile->buf, bin->header.fields_offset +",
          "693:     fieldIndex * sizeof (DexField), ff, sizeof (DexField)) != sizeof (DexField)) {",
          "694:    break;",
          "696:   field.class_id = r_read_le16 (ff);",
          "697:   field.type_id = r_read_le16 (ff + 2);",
          "698:   field.name_id = r_read_le32 (ff + 4);",
          "699:   char *name = getstr (bin, field.name_id);",
          "700:   cln = r_str_replace (strdup (class_name), \"method.\", \"\", 0);",
          "701:   cln = r_str_replace (cln, \";\", \"_\", 0);",
          "704:   const char* accessStr = createAccessFlagStr(accessFlags, kAccessForField);",
          "705:   if (field.type_id < 0 || field.type_id >= bin->header.types_size) {",
          "706:    break;",
          "708:   int tid = bin->types[field.type_id].descriptor_id;",
          "709:   const char* type_str = getstr (bin, tid);",
          "711:   if (1) {",
          "712:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "713:    sym->name = r_str_newf (\"%s.ifield_%s:%s\", class_name, name, type_str);",
          "714:    sym->name = r_str_replace (sym->name, \"method.\", \"\", 0);",
          "715:    sym->name = r_str_replace (sym->name, \";\", \"\", 0);",
          "716:    sym->type = r_str_const (\"FIELD\");",
          "717:    sym->paddr = sym->vaddr = total;",
          "718:    sym->ordinal = (*sym_count)++;",
          "720:    dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "721:    dprintf(\"      name          : '%s'\\n\", name);",
          "722:    dprintf(\"      type          : '%s'\\n\", type_str);",
          "723:    dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)accessFlags, accessStr);",
          "725:    r_list_append (bin->methods_list, sym);",
          "726:    r_list_append (cls->fields, sym);",
          "727:   }",
          "731:  dprintf (\"  Direct methods    -\\n\");",
          "741: #if 0",
          "742:   index into the method_ids list for the identity of this method (includes the name and descriptor), represented as a difference from the index of previous element in the list. The index of the first element in a list is represented directly.",
          "743: #endif",
          "",
          "[Added Lines]",
          "811:   tid = bin->types[field.type_id].descriptor_id;",
          "812:   type_str = getstr (bin, tid);",
          "814:   RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "815:   if (is_sfield) {",
          "816:    sym->name = r_str_newf (\"%s.sfield_%s:%s\", cls->name, fieldName, type_str);",
          "818:   } else {",
          "819:    sym->name = r_str_newf (\"%s.ifield_%s:%s\", cls->name, fieldName, type_str);",
          "820:    sym->type = r_str_const (\"FIELD\");",
          "822:   sym->name = r_str_replace (sym->name, \"method.\", \"\", 0);",
          "823:   sym->name = r_str_replace (sym->name, \";\", \"\", 0);",
          "824:   sym->paddr = sym->vaddr = total;",
          "825:   sym->ordinal = (*sym_count)++;",
          "827:   if (dexdump) {",
          "828:    const char* accessStr = createAccessFlagStr (accessFlags, kAccessForField);",
          "829:    rbin->cb_printf (\"    #%d              : (in %s;)\\n\", i, cls->name);",
          "830:    rbin->cb_printf (\"      name          : '%s'\\n\", fieldName);",
          "831:    rbin->cb_printf (\"      type          : '%s'\\n\", type_str);",
          "832:    rbin->cb_printf (\"      access        : 0x%04x (%s)\\n\", (unsigned int)accessFlags, accessStr);",
          "835:   r_list_append (bin->methods_list, sym);",
          "836:   r_list_append (cls->fields, sym);",
          "841:  return p;",
          "842: }",
          "845: static ut8* parse_dex_class_method(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, RBinClass *cls, const ut8 *p, const ut8 *p_end, int *sym_count, ut64 DM, int *methods, bool is_direct) {",
          "846:  struct r_bin_t *rbin = binfile->rbin;",
          "847:  ut8 ff2[16] = {0};",
          "848:  ut8 ff3[8] = {0};",
          "849:  int i;",
          "851:  bool catchAll;",
          "852:  ut16 regsz;",
          "853:  ut16 ins_size;",
          "854:  ut16 outs_size;",
          "855:  ut16 tries_size;",
          "856:  ut16 start_addr;",
          "857:  ut16 insn_count;",
          "858:  ut16 handler_off;",
          "859:  ut32 debug_info_off;",
          "860:  ut32 insns_size;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "752:   }",
          "754:   method_name = dex_method_name (bin, MI);",
          "757:   if (!method_name) {",
          "758:    method_name = strdup (\"unknown\");",
          "759:   }",
          "763:   if (!flag_name) {",
          "764:    continue;",
          "765:   }",
          "775:   if (*flag_name) {",
          "776:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "777:    sym->name = flag_name;",
          "779:    sym->bind = r_str_const (\"GLOBAL\");",
          "780:    sym->paddr = MC;// + 0x10;",
          "781:    sym->vaddr = MC;// + 0x10;",
          "782:    sym->ordinal = (*sym_count)++;",
          "783:    if (MC > 0) {",
          "800:     if (r_buf_read_at (binfile->buf, binfile->buf->base + MC, ff2, 16) < 1) {",
          "801:      free (sym);",
          "",
          "[Removed Lines]",
          "755:   char *signature = dex_method_signature(bin, MI);",
          "761:   flag_name = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);",
          "767:   const char* accessStr = createAccessFlagStr(MA, kAccessForMethod);",
          "769:   dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "770:   dprintf(\"      name          : '%s'\\n\", method_name);",
          "771:   dprintf(\"      type          : '%s'\\n\", signature);",
          "772:   dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)MA, accessStr);",
          "778:    sym->type = r_str_const (\"FUNC\");",
          "785: #if 0",
          "787:     ut16 regsz;",
          "788:     ut16 ins_size",
          "789:     ut16 outs_size",
          "790:     ut16 tries_size",
          "791:     ut32 debug_info_off",
          "792:     ut32 insns_size",
          "793:     ut16[insn_size] insns;",
          "794:     ut16 padding = 0",
          "795:     try_item[tries_size] tries",
          "796:     encoded_catch_handler_list handlers",
          "797: #endif",
          "",
          "[Added Lines]",
          "881:   char *signature = dex_method_signature (bin, MI);",
          "887:   flag_name = r_str_newf (\"%s.method.%s%s\", cls->name, method_name, signature);",
          "895:   ut64 v2, handler_type, handler_addr;",
          "896:   int t;",
          "898:   if (MC > 0) {",
          "900:    if (r_buf_read_at (binfile->buf, binfile->buf->base + MC, ff2, 16) < 1) {",
          "901:     continue;",
          "902:    }",
          "904:    regsz = r_read_le16 (ff2);",
          "905:    ins_size = r_read_le16 (ff2 + 2);",
          "906:    outs_size = r_read_le16 (ff2 + 4);",
          "907:    tries_size = r_read_le16 (ff2 + 6);",
          "908:    debug_info_off = r_read_le32 (ff2 + 8);",
          "909:    insns_size = r_read_le32 (ff2 + 12);",
          "911:    int padd = 0;",
          "912:    if (tries_size > 0 && insns_size%2 != 0) padd = 2;",
          "913:    t = 16 + 2*insns_size + padd;",
          "914:   }",
          "916:   if (dexdump) {",
          "917:    const char* accessStr = createAccessFlagStr (MA, kAccessForMethod);",
          "918:    rbin->cb_printf (\"    #%d              : (in %s;)\\n\", i, cls->name);",
          "919:    rbin->cb_printf (\"      name          : '%s'\\n\", method_name);",
          "920:    rbin->cb_printf (\"      type          : '%s'\\n\", signature);",
          "921:    rbin->cb_printf (\"      access        : 0x%04x (%s)\\n\", (unsigned int)MA, accessStr);",
          "922:   }",
          "924:   if (MC > 0) {",
          "925:    if (dexdump) {",
          "926:     rbin->cb_printf (\"      code          -\\n\");",
          "927:     rbin->cb_printf (\"      registers     : %d\\n\", regsz);",
          "928:     rbin->cb_printf (\"      ins           : %d\\n\", ins_size);",
          "929:     rbin->cb_printf (\"      outs          : %d\\n\", outs_size);",
          "930:     rbin->cb_printf (\"      insns size    : %d 16-bit code units\\n\", insns_size);",
          "931:    }",
          "932:    if (tries_size > 0) {",
          "933:     if (dexdump) {",
          "934:      rbin->cb_printf (\"      catches       : %d\\n\", tries_size);",
          "935:     }",
          "936:     int j, m = 0;",
          "937:     for (j=0; j < tries_size; ++j) {",
          "938:      if (r_buf_read_at (binfile->buf, binfile->buf->base + MC + t + j*8, ff3, 8) < 1) {",
          "939:       continue;",
          "940:      }",
          "941:      start_addr = r_read_le32 (ff3);",
          "942:      insn_count = r_read_le16 (ff3 + 4);",
          "943:      handler_off = r_read_le16 (ff3 + 6);",
          "944:      char* s = NULL;",
          "945:      if (dexdump) {",
          "946:       rbin->cb_printf (\"        0x%04x - 0x%04x\\n\", start_addr, (start_addr + insn_count));",
          "947:      }",
          "949:      const ut8 *p3, *p3_end;",
          "950:      int off = MC + t + tries_size*8 + handler_off;",
          "951:      p3 = r_buf_get_at (binfile->buf, off, NULL);",
          "952:      p3_end = p3 + binfile->buf->length - off;",
          "953:      st64 size = gum_read_sleb128 (&p3, p3_end);",
          "957:      if (size <= 0) {",
          "958:       catchAll = true;",
          "959:       size = -size;",
          "960:      } else {",
          "961:       catchAll = false;",
          "962:      }",
          "964:      for (m = 0; m < size; m++) {",
          "965:       p3 = r_uleb128 (p3, p3_end - p3, &handler_type);",
          "966:       p3 = r_uleb128 (p3, p3_end - p3, &handler_addr);",
          "968:       if (dexdump && handler_type > 0 && handler_type < bin->header.types_size) {",
          "969:        s = getstr (bin, bin->types[handler_type].descriptor_id);",
          "970:        rbin->cb_printf (\"          %s -> 0x%04llx\\n\", s, handler_addr);",
          "971:       } else {",
          "972:        rbin->cb_printf (\"          (error) -> 0x%04llx\\n\", handler_addr);",
          "973:       }",
          "974:      }",
          "976:      if (catchAll) {",
          "977:       p3 = r_uleb128 (p3, p3_end - p3, &v2);",
          "978:       if (dexdump) {",
          "979:        rbin->cb_printf (\"          <any> -> 0x%04llx\\n\", v2);",
          "980:       }",
          "981:      }",
          "982:     }",
          "984:    } else {",
          "985:     if (dexdump) {",
          "986:      rbin->cb_printf (\"      catches       : (none)\\n\");",
          "987:     }",
          "988:    }",
          "989:   } else {",
          "990:    if (dexdump) {",
          "991:     rbin->cb_printf (\"      code          : (none)\\n\");",
          "992:    }",
          "993:   }",
          "995:   if (MC > 0 && debug_info_off > 0 && bin->header.data_offset < debug_info_off",
          "996:   && debug_info_off < bin->header.data_offset + bin->header.data_size) {",
          "997:    dex_parse_debug_item (binfile, bin, c, MI, MA, ins_size,",
          "998:     insns_size, cls->name, regsz, debug_info_off);",
          "999:   } else if (MC > 0) {",
          "1000:    if (dexdump) {",
          "1001:     rbin->cb_printf (\"      positions     : \\n\");",
          "1002:     rbin->cb_printf (\"      locals        : \\n\");",
          "1003:    }",
          "1004:   }",
          "1009:    if (is_direct) {",
          "1010:     sym->type = r_str_const (\"FUNC\");",
          "1011:    } else {",
          "1012:     sym->type = r_str_const (\"METH\");",
          "1013:    }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "816:     sym->paddr = MC + prolog_size;// + 0x10;",
          "817:     sym->vaddr = MC + prolog_size;// + 0x10;",
          "820:     r_list_append (bin->methods_list, sym);",
          "821:     r_list_append (cls->methods, sym);",
          "",
          "[Removed Lines]",
          "818:     sym->size = insns_size * 2;",
          "",
          "[Added Lines]",
          "1038:     if (is_direct) {",
          "1039:      sym->size = insns_size * 2;",
          "1040:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "827:      bin->code_to = sym->paddr;",
          "828:     }",
          "831:     if (!mdb) {",
          "832:      mdb = sdb_new0 ();",
          "833:     }",
          "834:     sdb_num_set (mdb, sdb_fmt (0, \"method.%d\", MI), sym->paddr, 0);",
          "835:    } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1059:     if (0) {",
          "1060:      if (MA & 0x10000) { //ACC_CONSTRUCTOR",
          "1061:       if (!cdb) {",
          "1062:        cdb = sdb_new0 ();",
          "1063:       }",
          "1064:       sdb_num_set (cdb, sdb_fmt (0, \"%d\", c->class_id), sym->paddr, 0);",
          "1065:      }",
          "1066:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "842:   }",
          "843:   free (method_name);",
          "844:  }",
          "866:    }",
          "867:   }",
          "899:   }",
          "902:  }",
          "906: }",
          "908: static int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {",
          "909:  int i;",
          "910:  int *methods = NULL;",
          "911:  int sym_count = 0;",
          "",
          "[Removed Lines]",
          "847:  dprintf (\"  Virtual methods   -\\n\");",
          "848:  omi = 0;",
          "849:  for (i = 0; i < VM; i++) {",
          "850:   ut64 MI, MA, MC;",
          "851:   p = r_uleb128 (p, p_end-p, &MI);",
          "852:   p = r_uleb128 (p, p_end-p, &MA);",
          "853:   p = r_uleb128 (p, p_end-p, &MC);",
          "859:   MI += omi;",
          "860:   omi = MI;",
          "863:   if ((int)MI >= 0 && MI < bin->header.method_size) {",
          "864:    if (methods) {",
          "865:     methods[MI] = 1;",
          "869:   char *name = dex_method_name (bin, MI);",
          "870:   char *signature = dex_method_signature(bin, MI);",
          "871:   char* accessStr = createAccessFlagStr(MA, kAccessForMethod);",
          "873:   dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "874:   dprintf(\"      name          : '%s'\\n\", name);",
          "875:   dprintf(\"      type          : '%s'\\n\", signature);",
          "876:   dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)MA, accessStr);",
          "877:   free (accessStr);",
          "879:   {",
          "880:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "882:    sym->name = r_str_newf (\"%s.method.%s%s\", class_name, name, signature);",
          "885:    sym->type = r_str_const (\"METH\");",
          "886:    sym->bind = r_str_const (\"GLOBAL\");",
          "887:    sym->paddr = sym->vaddr = MC + 0x10;",
          "888:    sym->ordinal = (*sym_count)++;",
          "889:    r_list_append (bin->methods_list, sym);",
          "890:    r_list_append (cls->methods, sym);",
          "892:    if (bin->code_from > sym->paddr) {",
          "893:     bin->code_from = sym->paddr;",
          "894:    }",
          "895:    if (bin->code_to < sym->paddr) {",
          "896:     bin->code_to = sym->paddr;",
          "897:    }",
          "900:   free (name);",
          "901:   free(signature);",
          "",
          "[Added Lines]",
          "1078:  return p;",
          "1079: }",
          "1081: static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, int class_index, int *methods, int *sym_count) {",
          "1082:  struct r_bin_t *rbin = binfile->rbin;",
          "1084:  char *class_name;",
          "1085:  int z;",
          "1086:  const ut8 *p, *p_end;",
          "1088:  if (!c) {",
          "1089:   return;",
          "1090:  }",
          "1092:  class_name = dex_class_name (bin, c);",
          "1093:  class_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func",
          "1095:  if (!class_name || !*class_name) {",
          "1096:   return;",
          "1097:  }",
          "1099:  RBinClass *cls = R_NEW0 (RBinClass);",
          "1100:  cls->name = class_name;",
          "1101:  cls->index = class_index;",
          "1102:  cls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;",
          "1103:  cls->methods = r_list_new ();",
          "1104:  cls->fields = r_list_new ();",
          "1106:  r_list_append (bin->classes_list, cls);",
          "1108:  if (dexdump) {",
          "1109:   rbin->cb_printf (\"  Class descriptor  : '%s'\\n\", dex_class_name (bin, c));",
          "1110:   rbin->cb_printf (\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags, createAccessFlagStr (c->access_flags, kAccessForClass));",
          "1111:   rbin->cb_printf (\"  Superclass        : '%s'\\n\", dex_class_super_name (bin, c));",
          "1112:   rbin->cb_printf (\"  Interfaces        -\\n\");",
          "1113:  }",
          "1115:  if (c->interfaces_offset > 0 && bin->header.data_offset < c->interfaces_offset",
          "1116:   && c->interfaces_offset < bin->header.data_offset + bin->header.data_size) {",
          "1117:   p = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);",
          "1118:   int types_list_size = r_read_le32(p);",
          "1119:   for (z = 0; z < types_list_size; z++) {",
          "1120:    int t = r_read_le16 (p + 4 + z * 2);",
          "1121:    int tid = bin->types[t].descriptor_id;",
          "1122:    if (dexdump) {",
          "1123:     rbin->cb_printf (\"    #%d              : '%s'\\n\", z, getstr (bin, tid));",
          "1126:  }",
          "1129:  if (!c || !c->class_data_offset) {",
          "1130:   if (dexdump) {",
          "1131:    rbin->cb_printf (\"  Static fields     -\\n  Instance fields   -\\n  Direct methods    -\\n  Virtual methods   -\\n\");",
          "1132:   }",
          "1133:  } else {",
          "1137:   if (bin->header.class_offset > c->class_data_offset",
          "1138:    || c->class_data_offset <  bin->header.class_offset + bin->header.class_size * DEX_CLASS_SIZE ) {",
          "1139:    return;",
          "1140:   }",
          "1142:   p = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);",
          "1143:   p_end = p + binfile->buf->length - c->class_data_offset;",
          "1145:   c->class_data = (struct dex_class_data_item_t *) malloc (sizeof (struct dex_class_data_item_t));",
          "1147:   p = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);",
          "1148:   p = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);",
          "1149:   p = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);",
          "1150:   p = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);",
          "1152:   if (dexdump) {",
          "1153:    rbin->cb_printf (\"  Static fields     -\\n\");",
          "1154:   }",
          "1155:   p = parse_dex_class_fields (binfile, bin, c, cls, p, p_end, sym_count, c->class_data->static_fields_size, true);",
          "1157:   if (dexdump) {",
          "1158:    rbin->cb_printf (\"  Instance fields   -\\n\");",
          "1159:   }",
          "1160:   p = parse_dex_class_fields (binfile, bin, c, cls, p, p_end, sym_count, c->class_data->instance_fields_size, false);",
          "1162:   if (dexdump) {",
          "1163:    rbin->cb_printf (\"  Direct methods    -\\n\");",
          "1164:   }",
          "1165:   p = parse_dex_class_method (binfile, bin, c, cls, p, p_end, sym_count, c->class_data->direct_methods_size, methods, true);",
          "1167:   if (dexdump) {",
          "1168:    rbin->cb_printf (\"  Virtual methods   -\\n\");",
          "1169:   }",
          "1170:   p = parse_dex_class_method (binfile, bin, c, cls, p, p_end, sym_count, c->class_data->virtual_methods_size, methods, false);",
          "1171:  }",
          "1173:  if (dexdump) {",
          "1174:   char *source_file = getstr (bin, c->source_file);",
          "1175:   if (source_file == NULL) {",
          "1176:    rbin->cb_printf (\"  source_file_idx   : %d (unknown)\\n\\n\", c->source_file);",
          "1177:   } else {",
          "1178:    rbin->cb_printf (\"  source_file_idx   : %d (%s)\\n\\n\", c->source_file, source_file);",
          "1189:  struct r_bin_t *rbin = arch->rbin;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "933:  bin->header.class_size = R_MIN (bin->header.class_size, bin->size);",
          "934:  bin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);",
          "936:  if (bin->header.strings_size > bin->size) {",
          "937:   eprintf (\"Invalid strings size\\n\");",
          "938:   return false;",
          "939:  }",
          "957:  if (bin->classes) {",
          "958:   methods = calloc (sizeof (int), bin->header.method_size);",
          "959:   for (i = 0; i < bin->header.class_size; i++) {",
          "",
          "[Removed Lines]",
          "943:  for (i = 0; i < bin->header.prototypes_size; i++) {",
          "944:   dprintf(\"PROTO[%d], %d, %d, %d\\n\", i, bin->protos[i].shorty_id, bin->protos[i].return_type_id, bin->protos[i].parameters_off );",
          "945:  }",
          "951:  for (i = 0; i < bin->header.strings_size; i++) {",
          "952:   dprintf(\"STR[%d], %s\\n\", i, getstr(bin, i));",
          "953:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "961:    struct dex_class_t *c = &bin->classes[i];",
          "962:    class_name = dex_class_name (bin, c);",
          "963:    super_name = dex_class_super_name (bin, c);",
          "965:    parse_class (arch, bin, c, i, methods, &sym_count);",
          "966:    free (class_name);",
          "967:    free (super_name);",
          "",
          "[Removed Lines]",
          "964:    dprintf(\"Class #%d            -\\n\", i); // TODO: rename this to idx",
          "",
          "[Added Lines]",
          "1230:    if (dexdump) {",
          "1231:     rbin->cb_printf (\"Class #%d            -\\n\", i);",
          "1232:    }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1032:  }",
          "1033:  dex_loadcode (arch, bin);",
          "1034:  return bin->imports_list;",
          "1079: }",
          "1081: static RList *methods(RBinFile *arch) {",
          "",
          "[Removed Lines]",
          "1035: #if 0",
          "1036:  struct r_bin_dex_obj_t *bin = (struct r_bin_dex_obj_t *) arch->o->bin_obj;",
          "1037:  int i;",
          "1038:  RList *ret = NULL;",
          "1039:  RBinImport *ptr;",
          "1041:  if (!(ret = r_list_new ()))",
          "1042:   return NULL;",
          "1043:  ret->free = free;",
          "1044:  dprintf (\"Importing %d methods... \\n\", bin->header.method_size);",
          "1045:  for (i = 0; i<bin->header.method_size; i++) {",
          "1046:   if (!(ptr = R_NEW (RBinImport)))",
          "1047:    break;",
          "1048:   char *methodname = get_string (bin, bin->methods[i].name_id);",
          "1049:   char *classname = get_string (bin, bin->methods[i].class_id);",
          "1051: dprintf (\"----> %d\\n\", bin->methods[i].name_id);",
          "1053:   if (!methodname) {",
          "1054:    dprintf (\"string index out of range\\n\");",
          "1055:    break;",
          "1056:   }",
          "1057:   snprintf (ptr->name, sizeof (ptr->name), \"import.%s.%s\",",
          "1058:     classname, methodname);",
          "1059:   ptr->ordinal = i+1;",
          "1060:   ptr->size = 0;",
          "1061:   ptr->vaddr = ptr->offset = getmethodoffset (bin,",
          "1062:    (int)ptr->ordinal, (ut32*)&ptr->size);",
          "1063: dprintf (\"____%s__%s____  (%d)  %llx\\n\", classname,",
          "1064:  methodname, bin->methods[i].name_id, ptr->vaddr);",
          "1065: free (classname);",
          "1066: free (methodname);",
          "1068:   strncpy (ptr->bind, \"NONE\", R_BIN_SIZEOF_STRINGS);",
          "1069:   if (ptr->vaddr) {",
          "1070:    free (ptr);",
          "1071:    continue;",
          "1072:   }",
          "1073:   strncpy (ptr->type, \"IMPORT\", R_BIN_SIZEOF_STRINGS);",
          "1074:   r_list_append (ret, ptr);",
          "1075:  }",
          "1076:  dprintf (\"Done\\n\");",
          "1077:  return ret;",
          "1078: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1100:   dex_loadcode (arch, bin);",
          "1101:  }",
          "1102:  return bin->classes_list;",
          "1187: }",
          "1189: static int already_entry(RList *entries, ut64 vaddr) {",
          "",
          "[Removed Lines]",
          "1104:  struct r_bin_dex_obj_t *bin;",
          "1105:  struct dex_class_t entry;",
          "1106:  int i, class_index = 0;",
          "1107:  RList *ret = NULL;",
          "1108:  RBinClass *class;",
          "1109:  char name[128];",
          "1111:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "1112:   return NULL;",
          "1113:  }",
          "1114:  bin = (struct r_bin_dex_obj_t *) arch->o->bin_obj;",
          "1115:  if (bin->header.class_size > bin->size) {",
          "1116:   eprintf (\"Too many classes %d\\n\", bin->header.class_size);",
          "1117:   return NULL;",
          "1118:  }",
          "1119:  if (!(ret = r_list_new ())) {",
          "1120:   return NULL;",
          "1121:  }",
          "1122:  ret->free = (RListFree)__r_bin_class_free;",
          "1123:  for (i = 0; i < bin->header.class_size; i++) {",
          "1124:   ut64 class_addr = (ut64) bin->header.class_offset \\",
          "1125:    + (sizeof (struct dex_class_t)*i);",
          "1126: #if 0 // Wrong old method - reading bytes direct into struct at some offset",
          "1128:   r_buf_read_at (bin->b, class_addr, (ut8*)&entry,",
          "1129:    sizeof (struct dex_class_t));",
          "1130: #endif",
          "1131:   ut8 cls[sizeof (struct dex_class_t)] = {0};",
          "1132:   r_buf_read_at (bin->b, class_addr, cls, sizeof (struct dex_class_t));",
          "1133:   entry.class_id = r_read_le32 (cls + 0);",
          "1134:   entry.access_flags = r_read_le32 (cls + 4);",
          "1135:   entry.super_class = r_read_le32 (cls + 8);",
          "1136:   entry.interfaces_offset = r_read_le32 (cls + 12);",
          "1137:   entry.source_file = r_read_le32 (cls + 16);",
          "1138:   entry.anotations_offset = r_read_le32 (cls + 20);",
          "1139:   entry.class_data_offset = r_read_le32 (cls + 24);",
          "1140:   entry.static_values_offset = r_read_le32 (cls + 28);",
          "1144:   if (!bin->strings) {",
          "1146:    break;",
          "1147:   }",
          "1148:   if (entry.source_file >= bin->size) {",
          "1149:    continue;",
          "1150:   }",
          "1152:   if (entry.source_file >= bin->header.strings_size) {",
          "1153:    continue;",
          "1154:   }",
          "1155:   if (bin->strings[entry.source_file] > bin->size) {",
          "1156:    continue;",
          "1157:   }",
          "1158:   r_buf_read_at (bin->b, bin->strings[entry.source_file], (ut8*)name, sizeof (name));",
          "1160:   class = R_NEW0 (RBinClass);",
          "1164:   class->name = dex_class_name_byid (bin, entry.class_id);",
          "1166:   char *cn = dex_class_name (bin, &entry);",
          "1167:   if (cn) {",
          "1168:    free (class->name);",
          "1169:    class->index = class_index++;",
          "1170:    class->addr = entry.class_id + bin->header.class_offset;",
          "1171:    class->name = r_str_replace (cn, \";\", \"\", 0);",
          "1177:    r_list_append (ret, class);",
          "1179:   } else {",
          "1180:    dprintf(\"INVALID CLASS NAME\");",
          "1181:    free (class->name);",
          "1182:    free (class);",
          "1183:   }",
          "1184:  }",
          "1185:  return ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1241: }",
          "1243: static ut64 offset_of_method_idx(RBinFile *arch, struct r_bin_dex_obj_t *dex, int idx) {",
          "1249:  off = sdb_num_get (mdb, sdb_fmt (0, \"method.%d\", idx), 0);",
          "1253: }",
          "1257:  struct r_bin_dex_obj_t *dex = arch->o->bin_obj;",
          "1258:  switch (type) {",
          "1259:  case 'm': // methods",
          "",
          "[Removed Lines]",
          "1244:  int off = dex->header.method_offset + idx;",
          "1252:  return off;",
          "1256: static int getoffset(RBinFile *arch, int type, int idx) {",
          "",
          "[Added Lines]",
          "1382:  ut64 off = dex->header.method_offset + idx;",
          "1384:  return (ut64) off;",
          "1387: static ut64 getoffset(RBinFile *arch, int type, int idx) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1266:    if (dex->strings) return dex->strings[idx];",
          "1267:   }",
          "1268:   break;",
          "1271:  }",
          "1272:  return -1;",
          "1273: }",
          "",
          "[Removed Lines]",
          "1269:  case 't': // things",
          "1270:   break;",
          "",
          "[Added Lines]",
          "1400:  case 't': // type",
          "1401:   return dex_get_type_offset (arch, idx);",
          "1402:  case 'c': // class",
          "1403:   return dex_get_type_offset (arch, idx);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1360:  return ret;",
          "1361: }",
          "1363: static ut64 size(RBinFile *arch) {",
          "1364:  int ret;",
          "1365:  ut32 off = 0, len = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1497: static void *header(RBinFile *arch) {",
          "1498:  struct r_bin_dex_obj_t *bin = arch->o->bin_obj;",
          "1499:  struct r_bin_t *rbin = arch->rbin;",
          "1501:  rbin->cb_printf (\"DEX file header:\\n\");",
          "1502:  rbin->cb_printf (\"magic               : 'dex\\\\n035\\\\0'\\n\");",
          "1503:  rbin->cb_printf (\"checksum            : %x\\n\", bin->header.checksum);",
          "1504:  rbin->cb_printf (\"signature           : %02x%02x...%02x%02x\\n\", bin->header.signature[0], bin->header.signature[1], bin->header.signature[18], bin->header.signature[19]);",
          "1505:  rbin->cb_printf (\"file_size           : %d\\n\", bin->header.size);",
          "1506:  rbin->cb_printf (\"header_size         : %d\\n\", bin->header.header_size);",
          "1507:  rbin->cb_printf (\"link_size           : %d\\n\", bin->header.linksection_size);",
          "1508:  rbin->cb_printf (\"link_off            : %d (0x%06x)\\n\", bin->header.linksection_offset, bin->header.linksection_offset);",
          "1509:  rbin->cb_printf (\"string_ids_size     : %d\\n\", bin->header.strings_size);",
          "1510:  rbin->cb_printf (\"string_ids_off      : %d (0x%06x)\\n\", bin->header.strings_offset, bin->header.strings_offset);",
          "1511:  rbin->cb_printf (\"type_ids_size       : %d\\n\", bin->header.types_size);",
          "1512:  rbin->cb_printf (\"type_ids_off        : %d (0x%06x)\\n\", bin->header.types_offset, bin->header.types_offset);",
          "1513:  rbin->cb_printf (\"proto_ids_size       : %d\\n\", bin->header.prototypes_size);",
          "1514:  rbin->cb_printf (\"proto_ids_off        : %d (0x%06x)\\n\", bin->header.prototypes_offset, bin->header.prototypes_offset);",
          "1515:  rbin->cb_printf (\"field_ids_size      : %d\\n\", bin->header.fields_size);",
          "1516:  rbin->cb_printf (\"field_ids_off       : %d (0x%06x)\\n\", bin->header.fields_offset, bin->header.fields_offset);",
          "1517:  rbin->cb_printf (\"method_ids_size     : %d\\n\", bin->header.method_size);",
          "1518:  rbin->cb_printf (\"method_ids_off      : %d (0x%06x)\\n\", bin->header.method_offset, bin->header.method_offset);",
          "1519:  rbin->cb_printf (\"class_defs_size     : %d\\n\", bin->header.class_size);",
          "1520:  rbin->cb_printf (\"class_defs_off      : %d (0x%06x)\\n\", bin->header.class_offset, bin->header.class_offset);",
          "1521:  rbin->cb_printf (\"data_size           : %d\\n\", bin->header.data_size);",
          "1522:  rbin->cb_printf (\"data_off            : %d (0x%06x)\\n\\n\", bin->header.data_offset, bin->header.data_offset);",
          "1525:  dexdump = true;",
          "1526:  bin->methods_list = NULL;",
          "1527:  dex_loadcode (arch, bin);",
          "1528:  dexdump = false;",
          "1529: }",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1395:  .imports = imports,",
          "1396:  .strings = strings,",
          "1397:  .info = &info,",
          "1398:  .size = &size,",
          "1399:  .get_offset = &getoffset,",
          "1400:  .get_name = &getname",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1566:  .header = &header,",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1406:  .data = &r_bin_plugin_dex,",
          "1407:  .version = R2_VERSION",
          "1408: };",
          "",
          "[Removed Lines]",
          "1409: #endif",
          "",
          "[Added Lines]",
          "1578: #endif",
          "",
          "---------------"
        ],
        "libr/core/cbin.c||libr/core/cbin.c": [
          "File: libr/core/cbin.c -> libr/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2581:  }",
          "2582: }",
          "2584: R_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {",
          "2585:  int ret = true;",
          "2586:  const char *name = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2585: static int bin_header(RCore *r, int mode) {",
          "2586:  RBinFile *cur = r_bin_cur (r->bin);",
          "2587:  RBinPlugin *plg = r_bin_file_cur_plugin (cur);",
          "2588:  if (plg && plg->header) {",
          "2589:   plg->header (cur);",
          "2590:   return true;",
          "2591:  }",
          "2592:  return false;",
          "2594: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2612:  if ((action & R_CORE_BIN_ACC_MEM)) ret &= bin_mem (core, mode);",
          "2613:  if ((action & R_CORE_BIN_ACC_VERSIONINFO)) ret &= bin_versioninfo (core, mode);",
          "2614:  if ((action & R_CORE_BIN_ACC_SIGNATURE)) ret &= bin_signature (core, mode);",
          "2615:  return ret;",
          "2616: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2627:  if ((action & R_CORE_BIN_ACC_HEADER)) ret &= bin_header (core, mode);",
          "",
          "---------------"
        ],
        "libr/core/cmd_info.c||libr/core/cmd_info.c": [
          "File: libr/core/cmd_info.c -> libr/core/cmd_info.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:    }",
          "322:    break;",
          "323:   case 'H':",
          "324:   case 'h': RBININFO (\"fields\", R_CORE_BIN_ACC_FIELDS, NULL); break;",
          "325:   case 'l': RBININFO (\"libs\", R_CORE_BIN_ACC_LIBS, NULL); break;",
          "326:   case 'L': r_bin_list (core->bin, input[1]=='j'); break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "324:    if (input[1] == 'H') { //iHH",
          "325:     RBININFO (\"header\", R_CORE_BIN_ACC_HEADER, NULL);",
          "326:     break;",
          "327:    }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "486:     \"ie\", \"\", \"Entrypoint\",",
          "487:     \"iE\", \"\", \"Exports (global symbols)\",",
          "488:     \"ih\", \"\", \"Headers (alias for iH)\",",
          "489:     \"ii\", \"\", \"Imports\",",
          "490:     \"iI\", \"\", \"Binary info\",",
          "491:     \"ik\", \" [query]\", \"Key-value database from RBinObject\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "493:     \"iHH\", \"\", \"Verbose Headers in raw text\",",
          "",
          "---------------"
        ],
        "libr/include/r_anal.h||libr/include/r_anal.h": [
          "File: libr/include/r_anal.h -> libr/include/r_anal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: #define R_ANAL_ARCHINFO_MAX_OP_SIZE 1",
          "104: #define R_ANAL_ARCHINFO_ALIGN 2",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108: #define R_ANAL_GET_OFFSET(x,y,z) \\",
          "109:         (x && x->binb.bin && x->binb.get_offset)? \\",
          "110:                 x->binb.get_offset (x->binb.bin, y, z): -1",
          "112: #define R_ANAL_GET_NAME(x,y,z) \\",
          "113:         (x && x->binb.bin && x->binb.get_name)? \\",
          "114:                 x->binb.get_name (x->binb.bin, y, z): NULL",
          "",
          "---------------"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "320:  RList/*<RBinClass>*/* (*classes)(RBinFile *arch);",
          "321:  RList/*<RBinMem>*/* (*mem)(RBinFile *arch);",
          "322:  RList/*<RBinReloc>*/* (*patch_relocs)(RBin *bin);",
          "323:  char* (*signature)(RBinFile *arch);",
          "324:  int (*demangle_type)(const char *str);",
          "325:  struct r_bin_dbginfo_t *dbginfo;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "323:  void (*header)(RBinFile *arch);",
          "",
          "---------------"
        ],
        "libr/include/r_core.h||libr/include/r_core.h": [
          "File: libr/include/r_core.h -> libr/include/r_core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "458: #define R_CORE_BIN_ACC_VERSIONINFO 0x10000",
          "459: #define R_CORE_BIN_ACC_SIGNATURE 0x20000",
          "460: #define R_CORE_BIN_ACC_RAW_STRINGS 0x40000",
          "461: #define R_CORE_BIN_ACC_ALL 0x4FFF",
          "463: #define R_CORE_PRJ_FLAGS 0x0001",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "461: #define R_CORE_BIN_ACC_HEADER 0x80000",
          "",
          "---------------"
        ],
        "libr/include/r_util/r_uleb128.h||libr/include/r_util/r_uleb128.h": [
          "File: libr/include/r_util/r_uleb128.h -> libr/include/r_util/r_uleb128.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: R_API const ut8 *r_uleb128_decode(const ut8 *data, int *datalen, ut64 *v);",
          "10: R_API const ut8 *r_uleb128_encode(const ut64 s, int *len);",
          "11: R_API const ut8 *r_leb128(const ut8 *data, st64 *v);",
          "12: #endif //  R_ULEB128_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: R_API st64 gum_read_sleb128 (const ut8 **data, const ut8 *end);",
          "",
          "---------------"
        ],
        "libr/util/uleb128.c||libr/util/uleb128.c": [
          "File: libr/util/uleb128.c -> libr/util/uleb128.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:  ut8 c;",
          "9:  ut64 s, sum = 0;",
          "10:  const ut8 *data_end;",
          "",
          "[Removed Lines]",
          "7: R_API const ut8 *r_uleb128 (const ut8 *data, int datalen, ut64 *v) {",
          "",
          "[Added Lines]",
          "7: R_API const ut8 *r_uleb128(const ut8 *data, int datalen, ut64 *v) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40:  ut8 c = 0xff;",
          "41:  ut64 s = 0, sum = 0, l = 0;",
          "42:  if (data && *data) {",
          "",
          "[Removed Lines]",
          "39: R_API const ut8 *r_uleb128_decode (const ut8 *data, int *datalen, ut64 *v) {",
          "",
          "[Added Lines]",
          "39: R_API const ut8 *r_uleb128_decode(const ut8 *data, int *datalen, ut64 *v) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:  return data;",
          "53: }",
          "56:  ut8 c = 0;",
          "57:  int l = 0;",
          "58:  ut8 *otarget = NULL, *target = NULL;",
          "",
          "[Removed Lines]",
          "55: R_API const ut8 *r_uleb128_encode (const ut64 s, int *len) {",
          "",
          "[Added Lines]",
          "55: R_API const ut8 *r_uleb128_encode(const ut64 s, int *len) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "74:  return otarget;",
          "75: }",
          "78:  ut8 c = 0;",
          "79:  st64 s = 0, sum = 0;",
          "80:  if (data) {",
          "",
          "[Removed Lines]",
          "77: R_API const ut8 *r_leb128 (const ut8 *data, st64 *v) {",
          "",
          "[Added Lines]",
          "77: R_API const ut8 *r_leb128(const ut8 *data, st64 *v) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "92:  return data;",
          "93: }",
          "95: #if 0",
          "96: main() {",
          "97:  ut32 n;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: #define G_GINT64_CONSTANT(val) (val##L)",
          "97: R_API st64 gum_read_sleb128(const ut8 **data, const ut8 *end) {",
          "98:  const ut8 *p = *data;",
          "99:  st64 result = 0;",
          "100:  int offset = 0;",
          "101:  ut8 value;",
          "102:   do {",
          "103:   st64 chunk;",
          "104:   value = *p;",
          "105:   chunk = value & 0x7f;",
          "106:   result |= (chunk << offset);",
          "107:   offset += 7;",
          "108:  }",
          "109:  while (*p++ & 0x80);",
          "111:    if ((value & 0x40) != 0) {",
          "112:     result |= G_GINT64_CONSTANT (-1) << offset;",
          "113:    }",
          "115:  return result;",
          "116: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0c0cba3398466661afed716f709f1fc404a752e",
      "candidate_info": {
        "commit_hash": "c0c0cba3398466661afed716f709f1fc404a752e",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/c0c0cba3398466661afed716f709f1fc404a752e",
        "files": [
          "libr/bin/format/dex/dex.h",
          "libr/bin/p/bin_dex.c"
        ],
        "message": "fix #5465, #5745, 'ic' command and some memory leaks (#5764)",
        "before_after_code_files": [
          "libr/bin/format/dex/dex.h||libr/bin/format/dex/dex.h",
          "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ],
          "candidate": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/dex/dex.h||libr/bin/format/dex/dex.h": [
          "File: libr/bin/format/dex/dex.h -> libr/bin/format/dex/dex.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:  struct dex_class_t *classes;",
          "83:  RList *methods_list;",
          "84:  RList *imports_list;",
          "85:  ut64 code_from;",
          "86:  ut64 code_to;",
          "87:  Sdb *kv;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85:  RList *classes_list;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c": [
          "File: libr/bin/p/bin_dex.c -> libr/bin/p/bin_dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:  ut8 buf[6];",
          "23:  ut64 len;",
          "24:  int uleblen;",
          "26:   return NULL;",
          "27:  }",
          "29:  r_buf_read_at (bin->b, bin->strings[idx], buf, sizeof (buf));",
          "30:  uleblen = r_uleb128 (buf, sizeof (buf), &len) - buf;",
          "33:  char c = 'a';",
          "34:  while (c) {",
          "",
          "[Removed Lines]",
          "25:  if (idx < 0 || idx >= bin->header.strings_size || !bin->strings) {",
          "",
          "[Added Lines]",
          "24:  if (!bin || idx < 0 || idx >= bin->header.strings_size || !bin->strings) {",
          "25:   return NULL;",
          "26:  }",
          "27:  if (bin->strings[idx] >= bin->size) {",
          "33:  if (!uleblen || uleblen >= bin->size) {",
          "34:   return NULL;",
          "35:  }",
          "36:  if (!len || len >= bin->size) {",
          "37:   return NULL;",
          "38:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "182:  }",
          "183:  ut32 proto_id = bin->methods[method_idx].proto_id;",
          "186:   return NULL;",
          "187:  }",
          "188:  ut32 params_off = bin->protos[proto_id].parameters_off;",
          "192:   return NULL;",
          "193:  }",
          "195:  char* return_type = getstr(bin, bin->types[type_id].descriptor_id);",
          "197:  if (params_off == 0) {",
          "198:   return r_str_newf(\"()%s\", return_type);;",
          "199:  }",
          "",
          "[Removed Lines]",
          "185:  if (proto_id < 0 || proto_id >= bin->header.prototypes_size) {",
          "189:  ut32 type_id = bin->protos[bin->methods[method_idx].proto_id].return_type_id;",
          "191:  if (type_id < 0 || proto_id >= bin->header.types_size ) {",
          "",
          "[Added Lines]",
          "192:  if (proto_id >= bin->header.prototypes_size) {",
          "197:  if (params_off  >= bin->size) {",
          "198:   return NULL;",
          "199:  }",
          "201:  ut32 type_id = bin->protos[proto_id].return_type_id;",
          "203:  if (type_id >= bin->header.types_size ) {",
          "209:  if (!return_type) {",
          "210:   return NULL;",
          "211:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "212:  int size = 1; // TODO: NOT_SURE_ABOUT_IT",
          "213:  int pos = 0;",
          "214:  int i;",
          "216:   type_idx = r_read_le16 (bufptr + params_off + 4 + (i*2));",
          "217:   buff = getstr (bin, bin->types[type_idx].descriptor_id);",
          "218:   int buff_len = strlen (buff);",
          "219:   size += buff_len + 1;",
          "220:   signature = realloc (signature, size);",
          "",
          "[Removed Lines]",
          "215:  for (i = 0; i < list_size; i++) {",
          "",
          "[Added Lines]",
          "231:  for (i = 0; i < list_size; i++) {",
          "232:   if (params_off + 4 + (i*2) >= bin->size) {",
          "233:    continue;",
          "234:   }",
          "236:   if (type_idx < 0 || type_idx >= bin->header.types_size) {",
          "237:    continue;",
          "238:   }",
          "240:   if (!buff) {",
          "241:    continue;",
          "242:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "451:  return getstr(bin, tid);",
          "452: }",
          "454: static char *dex_class_name_byid (RBinDexObj *bin, int cid) {",
          "455:  int tid;",
          "456:  if (!bin || !bin->types) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "478: #if 0",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "462:  tid = bin->types[cid].descriptor_id;",
          "463:  return getstr(bin, tid);",
          "464: }",
          "467: static char *getClassName(const char *name) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "490: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "493:  return getstr(bin, tid);",
          "494: }",
          "496: static char *dex_class_super_name (RBinDexObj *bin, RBinDexClass *c) {",
          "497:  int cid, tid;",
          "498:  if (!bin || !c || !bin->types) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "523: static void __r_bin_class_free(RBinClass *p) {",
          "524:  r_list_free (p->methods);",
          "525:  r_list_free (p->fields);",
          "526:  r_bin_class_free (p);",
          "527: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "506:  return getstr(bin, tid);",
          "507: }",
          "510:  ut64 SF, IF, DM, VM, lastIndex;",
          "511:  ut8 ff[sizeof (DexField)] = {0};",
          "512:  char *class_name, *cln = NULL;",
          "514:  const ut8 *p, *p_end;",
          "515:  DexField field;",
          "517:  if (!c || !c->class_data_offset) {",
          "519:  }",
          "521:  class_name = dex_class_name (bin, c);",
          "522:  class_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func",
          "524:  if (!class_name || !*class_name) {",
          "531:  }",
          "533:  dprintf(\"  Class descriptor  : '%s'\\n\", dex_class_name (bin, c));",
          "",
          "[Removed Lines]",
          "509: static int *parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, RBinClass *cls) {",
          "513:  int total, i, *methods;",
          "518:   return NULL;",
          "525:   return NULL;",
          "526:  }",
          "527:  methods = calloc (sizeof (int), bin->header.method_size);",
          "528:  if (!methods) {",
          "529:   free (class_name);",
          "530:   return false;",
          "",
          "[Added Lines]",
          "542: static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, int class_index, int *methods) {",
          "546:  int total, i;",
          "551:   return;",
          "558:   return;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "557:  lastIndex = 0;",
          "558:  for (i = 0; i < SF; i++) {",
          "559:   ut64 fieldIndex, accessFlags;",
          "",
          "[Removed Lines]",
          "554:   dprintf(\"  Static fields     -\\n\");",
          "556:  const ut8 *op = p;",
          "",
          "[Added Lines]",
          "582:  RBinClass *cls = R_NEW0 (RBinClass);",
          "586:  cls->name = class_name;",
          "587:  cls->index = class_index;",
          "588:  cls->addr = c->class_id + bin->header.class_offset;",
          "589:  cls->methods = r_list_new ();",
          "591:  cls->fields = r_list_new ();",
          "594:  r_list_append (bin->classes_list, cls);",
          "596:  dprintf(\"  Static fields     -\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "589:    dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "590:    dprintf(\"      name          : '%s'\\n\", fieldName);",
          "591:    dprintf(\"      type          : '%s'\\n\", type_str);",
          "594:    r_list_append (bin->methods_list, sym);",
          "595:   }",
          "596:   lastIndex = fieldIndex;",
          "597:  }",
          "",
          "[Removed Lines]",
          "592:    dprintf(\"      access        : 0x%04x (%s)\\n\", accessFlags, accessStr);",
          "",
          "[Added Lines]",
          "633:    dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)accessFlags, accessStr);",
          "636:    r_list_append (cls->fields, sym);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "599:  dprintf(\"  Instance fields   -\\n\");",
          "601:  lastIndex = 0;",
          "603:  for (i = 0; i < IF; i++) {",
          "604:   DexField field;",
          "605:   ut64 fieldIndex, accessFlags;",
          "",
          "[Removed Lines]",
          "602:  op = p;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "642:    dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "643:    dprintf(\"      name          : '%s'\\n\", name);",
          "644:    dprintf(\"      type          : '%s'\\n\", type_str);",
          "647:    r_list_append (bin->methods_list, sym);",
          "648:   }",
          "649:   lastIndex = fieldIndex;",
          "650:  }",
          "",
          "[Removed Lines]",
          "645:    dprintf(\"      access        : 0x%04x (%s)\\n\", accessFlags, accessStr);",
          "",
          "[Added Lines]",
          "686:    dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)accessFlags, accessStr);",
          "689:    r_list_append (cls->fields, sym);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "665:   p = r_uleb128 (p, p_end - p, &MA);",
          "666:   p = r_uleb128 (p, p_end - p, &MC);",
          "669:   if (MC > 0 && bin->code_from > MC) {",
          "670:    bin->code_from = MC;",
          "671:   }",
          "",
          "[Removed Lines]",
          "668:   if (MI<bin->header.method_size) methods[MI] = 1;",
          "",
          "[Added Lines]",
          "711:   if (MI<bin->header.method_size) {",
          "712:    if (methods) {",
          "713:     methods[MI] = 1;",
          "714:    }",
          "715:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "691:   dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "692:   dprintf(\"      name          : '%s'\\n\", method_name);",
          "693:   dprintf(\"      type          : '%s'\\n\", signature);",
          "697:   if (*flag_name) {",
          "698:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "699:    sym->name = flag_name;",
          "700:    sym->type = r_str_const (\"FUNC\");",
          "701:    sym->paddr = MC + 0x10;",
          "702:    sym->vaddr = MC + 0x10;",
          "",
          "[Removed Lines]",
          "694:   dprintf(\"      access        : 0x%04x (%s)\\n\", MA, accessStr);",
          "",
          "[Added Lines]",
          "741:   dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)MA, accessStr);",
          "748:    sym->bind = r_str_const (\"GLOBAL\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "715:     encoded_catch_handler_list handlers",
          "716: #endif",
          "717:     r_list_append (bin->methods_list, sym);",
          "727:     if (!mdb) {",
          "728:      mdb = sdb_new0 ();",
          "",
          "[Removed Lines]",
          "719:     if (cls) {",
          "720:      if (!cls->methods) {",
          "722:       cls->methods = r_list_new ();",
          "723:      }",
          "724:      r_list_append (cls->methods, sym);",
          "725:     }",
          "",
          "[Added Lines]",
          "766:     r_list_append (cls->methods, sym);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "751:   MI += omi;",
          "752:   omi = MI;",
          "754:   if ((int)MI >= 0 && MI < bin->header.method_size) {",
          "756:   }",
          "757:   if ((int)MC > 0 && bin->code_from > MC) {",
          "758:    bin->code_from = MC;",
          "",
          "[Removed Lines]",
          "755:    methods[MI] = 1;",
          "",
          "[Added Lines]",
          "798:    if (methods) {",
          "799:     methods[MI] = 1;",
          "800:    }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "768:   dprintf(\"    #%d              : (in %s)\\n\", i, class_name);",
          "769:   dprintf(\"      name          : '%s'\\n\", name);",
          "770:   dprintf(\"      type          : '%s'\\n\", signature);",
          "773:   {",
          "774:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "",
          "[Removed Lines]",
          "771:   dprintf(\"      access        : 0x%04x (%s)\\n\", MA, accessStr);",
          "",
          "[Added Lines]",
          "816:   dprintf(\"      access        : 0x%04x (%s)\\n\", (unsigned int)MA, accessStr);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "779:    sym->type = r_str_const (\"METH\");",
          "780:    sym->paddr = sym->vaddr = MC;",
          "781:    r_list_append (bin->methods_list, sym);",
          "782:   }",
          "783:   free (name);",
          "784:   free(signature);",
          "785:  }",
          "788: }",
          "",
          "[Removed Lines]",
          "786:  free (class_name);",
          "787:  return methods;",
          "",
          "[Added Lines]",
          "825:    sym->bind = r_str_const (\"GLOBAL\");",
          "828:    r_list_append (cls->methods, sym);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "803:  bin->methods_list->free = free;",
          "804:  bin->imports_list = r_list_new ();",
          "805:  bin->imports_list->free = free;",
          "807:  if (bin->header.method_size>bin->size) {",
          "808:   bin->header.method_size = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "854:  bin->classes_list = r_list_new ();",
          "855:  bin->classes_list->free = (RListFree)__r_bin_class_free;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "838:  if (bin->classes) {",
          "839:   for (i = 0; i < bin->header.class_size; i++) {",
          "840:    char *super_name, *class_name;",
          "841:    struct dex_class_t *c = &bin->classes[i];",
          "842:    class_name = dex_class_name (bin, c);",
          "843:    super_name = dex_class_super_name (bin, c);",
          "846:    dprintf(\"Class #%d            -\\n\", i); // TODO: rename this to idx",
          "850:    free (class_name);",
          "851:    free (super_name);",
          "852:   }",
          "853:  }",
          "854:  if (methods) {",
          "856:   for (i = 0; i < bin->header.method_size; i++) {",
          "858:    if (methods[i]) {",
          "859:     continue;",
          "860:    }",
          "862:     continue;",
          "863:    }",
          "867:     free (class_name);",
          "868:     continue;",
          "869:    }",
          "870:    char *method_name = dex_method_name (bin, i);",
          "872:    if (method_name && *method_name) {",
          "873:     RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "876:     sym->type = r_str_const (\"IMPORT\");",
          "879:     RBinImport *imp = R_NEW0 (RBinImport);",
          "889:     imp->type = r_str_const (\"FUNC\");",
          "893:     r_list_append (bin->imports_list, imp);",
          "894:    }",
          "",
          "[Removed Lines]",
          "845:    free (methods);",
          "847:    methods = parse_class (arch, bin, c, NULL);",
          "861:    if (i >= bin->header.class_size) {",
          "864:    struct dex_class_t *c = &bin->classes[i];",
          "865:    char *class_name = dex_class_name (bin, c);",
          "866:    if (class_name) {",
          "871:    eprintf (\"import %d (%s  %s)\\n\", i, class_name, method_name);",
          "874:     sym->name = r_str_newf (\"imp.%s\", method_name);",
          "875:     sym->vaddr = sym->paddr = i; // ordinal",
          "877:     r_list_append (bin->methods_list, sym);",
          "880: #if DEADCODE",
          "881:     if (class_name) {",
          "882:      imp->name = r_str_newf (\"%s.%s\", class_name, method_name);",
          "883:      eprintf (\"ERROR\\n\");",
          "884:     }",
          "885: #endif",
          "886:     imp->name = r_str_newf (\"imp.%s\", method_name);",
          "888:     r_str_replace_char (imp->name, ';', '_');",
          "890:     imp->ordinal = i;",
          "891:     imp->bind = \"NONE\";",
          "",
          "[Added Lines]",
          "889:   methods = calloc (sizeof (int), bin->header.method_size);",
          "897:    parse_class (arch, bin, c, i, methods);",
          "912:    if (bin->methods[i].class_id < 0  || bin->methods[i].class_id > bin->header.types_size) {",
          "916:    char *class_name = getstr(bin, bin->types[bin->methods[i].class_id].descriptor_id);",
          "917:    if (!class_name) {",
          "921:    int len = strlen(class_name);",
          "922:    if (len < 1) {",
          "923:     continue;",
          "924:    }",
          "925:    class_name[len-1] = 0; // remove last char \";\"",
          "928:    char *signature = dex_method_signature(bin, i);",
          "932:     sym->name = r_str_newf (\"imp.%s.method.%s%s\", class_name, method_name, signature);",
          "934:     sym->bind = r_str_const (\"NONE\");",
          "938:     imp->name = r_str_newf (\"imp.%s.method.%s%s\", class_name, method_name, signature);",
          "941:     imp->bind = r_str_const (\"NONE\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "968:  return bin->methods_list;",
          "969: }",
          "976: static RList* classes (RBinFile *arch) {",
          "977:  struct r_bin_dex_obj_t *bin;",
          "978:  struct dex_class_t entry;",
          "979:  int i, class_index = 0;",
          "",
          "[Removed Lines]",
          "972: static void __r_bin_class_free(RBinClass *p) {",
          "973:  r_bin_class_free (p);",
          "974: }",
          "",
          "[Added Lines]",
          "1022:  RBinDexObj *bin;",
          "1023:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "1024:   return NULL;",
          "1025:  }",
          "1026:  bin = (RBinDexObj*) arch->o->bin_obj;",
          "1027:  if (!bin->classes_list) {",
          "1028:   dex_loadcode (arch, bin);",
          "1029:  }",
          "1030:  return bin->classes_list;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1044:    class->name = r_str_replace (cn, \";\", \"\", 0);",
          "1049:    r_list_append (ret, class);",
          "",
          "[Removed Lines]",
          "1047:    free (parse_class (arch, bin, &entry, class));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b50a06f57cb0e392ebe56ed2bc2dc08f7710ce84",
      "candidate_info": {
        "commit_hash": "b50a06f57cb0e392ebe56ed2bc2dc08f7710ce84",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/b50a06f57cb0e392ebe56ed2bc2dc08f7710ce84",
        "files": [
          "libr/bin/p/bin_dex.c"
        ],
        "message": "Load virtual methods from Dex files",
        "before_after_code_files": [
          "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ],
          "candidate": [
            "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c": [
          "File: libr/bin/p/bin_dex.c -> libr/bin/p/bin_dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "388:  dprintf (\"  static fields: %u\\n\", (ut32)SF);",
          "391:   ut64 FI, FA;",
          "392:   p = r_uleb128 (p, p_end-p, &FI);",
          "393:   p = r_uleb128 (p, p_end-p, &FA);",
          "",
          "[Removed Lines]",
          "390:  for (i=0; i<SF; i++) {",
          "",
          "[Added Lines]",
          "390:  for (i = 0; i < SF; i++) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "398:  }",
          "400:  dprintf (\"  instance fields: %u\\n\", (ut32)IF);",
          "402:   ut64 FI, FA;",
          "403:   p = r_uleb128 (p, p_end-p, &FI);",
          "404:   p = r_uleb128 (p, p_end-p, &FA);",
          "",
          "[Removed Lines]",
          "401:  for (i=0; i<IF; i++) {",
          "",
          "[Added Lines]",
          "401:  for (i = 0; i < IF; i++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "414:  }",
          "415: #endif",
          "416:  ut64 omi = 0;",
          "418:   char *method_name, *flag_name;",
          "419:   ut64 MI, MA, MC;",
          "420:   p = r_uleb128 (p, p_end-p, &MI);",
          "",
          "[Removed Lines]",
          "417:  for (i=0; i<DM; i++) {",
          "",
          "[Added Lines]",
          "417:  for (i = 0; i < DM; i++) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "435:   dprintf (\"METHOD NAME %u\\n\", (ut32)MI);",
          "436:   if (!method_name) method_name = strdup (\"unknown\");",
          "437:   flag_name = flagname (class_name, method_name);",
          "439:    continue;",
          "440:   dprintf (\"f %s @ 0x%x\\n\", flag_name, (ut32)MC);",
          "441:   dprintf (\"    { name: %d %d %s,\\n\", (ut32)MC, (ut32)MI, method_name);",
          "442:   dprintf (\"      idx: %u,\\n\", (ut32)MI);",
          "",
          "[Removed Lines]",
          "438:   if (!flag_name)",
          "",
          "[Added Lines]",
          "438:   if (!flag_name) {",
          "440:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "487:  }",
          "489:  dprintf (\"  virtual methods: %u\\n\", (ut32)VM);",
          "491:   ut64 MI, MA, MC;",
          "492:   p = r_uleb128 (p, p_end-p, &MI);",
          "493:   p = r_uleb128 (p, p_end-p, &MA);",
          "494:   p = r_uleb128 (p, p_end-p, &MC);",
          "500:   char *name = dex_method_name (bin, MI);",
          "501:   dprintf (\"    method name: %s\\n\", name);",
          "502:   dprintf (\"    method_idx: %u\\n\", (ut32)MI);",
          "503:   dprintf (\"    method access_flags: %u\\n\", (ut32)MA);",
          "504:   dprintf (\"    method code_offset: %u\\n\", (ut32)MC);",
          "505:   free (name);",
          "506:  }",
          "507:  free (class_name);",
          "",
          "[Removed Lines]",
          "490:  for (i=0; i<VM; i++) {",
          "496:   if (MI<bin->header.method_size) methods[MI] = 1;",
          "497:   if (MC>0 && bin->code_from>MC) bin->code_from = MC;",
          "498:   if (MC>0 && bin->code_to<MC) bin->code_to = MC;",
          "",
          "[Added Lines]",
          "491:  for (i = 0; i < VM; i++) {",
          "497:   if (MI < bin->header.method_size) methods[MI] = 1;",
          "498:   if (MC > 0 && bin->code_from > MC) bin->code_from = MC;",
          "499:   if (MC > 0 && bin->code_to < MC) bin->code_to = MC;",
          "506:   {",
          "507:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "508:    sym->name = r_str_newf (\"virtual.%s\", name);",
          "509:    sym->type = r_str_const (\"FUNC\");",
          "510:    sym->paddr = sym->vaddr = MC;",
          "511:    r_list_append (bin->methods_list, sym);",
          "512:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "538:  }",
          "540:  dprintf (\"Walking %d classes\\n\", bin->header.class_size);",
          "559:   }",
          "567:  }",
          "568:  if (methods) {",
          "569:   dprintf (\"imports: \\n\");",
          "572:    if (!methods[i]) {",
          "573:     char *method_name = dex_method_name (bin, i);",
          "",
          "[Removed Lines]",
          "541:  if (bin->classes)",
          "542:  for (i=0; i<bin->header.class_size; i++) {",
          "543:   char *super_name, *class_name;",
          "544:   struct dex_class_t *c = &bin->classes[i];",
          "545:   class_name = dex_class_name (bin, c);",
          "546:   super_name = dex_class_super_name (bin, c);",
          "547:   dprintf (\"{\\n\");",
          "548:   dprintf (\"  class: 0x%x,\\n\", c->class_id); // indexed by ordinal",
          "549:   dprintf (\"  super: \\\"%s\\\",\\n\", super_name); // indexed by name",
          "550:   dprintf (\"  name: \\\"%s\\\",\\n\", class_name);",
          "551:   dprintf (\"  methods: [\\n\");",
          "555: #if 0",
          "556:   if (c->class_data_offset == 0) {",
          "557:    eprintf (\"Skip class\\n\");",
          "558:    continue;",
          "560: #endif",
          "561:   free (methods);",
          "562:   methods = parse_class (arch, bin, c, NULL);",
          "563:   dprintf (\"  ],\\n\");",
          "564:   dprintf (\"},\");",
          "565:   free (class_name);",
          "566:   free (super_name);",
          "570:   for (i = 0; i<bin->header.method_size; i++) {",
          "",
          "[Added Lines]",
          "549:  if (bin->classes) {",
          "550:   for (i = 0; i < bin->header.class_size; i++) {",
          "551:    char *super_name, *class_name;",
          "552:    struct dex_class_t *c = &bin->classes[i];",
          "553:    class_name = dex_class_name (bin, c);",
          "554:    super_name = dex_class_super_name (bin, c);",
          "556:    dprintf (\"{\\n\");",
          "557:    dprintf (\"  class: 0x%x,\\n\", c->class_id); // indexed by ordinal",
          "558:    dprintf (\"  super: \\\"%s\\\",\\n\", super_name); // indexed by name",
          "559:    dprintf (\"  name: \\\"%s\\\",\\n\", class_name);",
          "560:    dprintf (\"  methods: [\\n\");",
          "564:  #if 0",
          "565:    if (c->class_data_offset == 0) {",
          "566:     eprintf (\"Skip class\\n\");",
          "567:     continue;",
          "568:    }",
          "569:  #endif",
          "570:    free (methods);",
          "571:    methods = parse_class (arch, bin, c, NULL);",
          "572:    dprintf (\"  ],\\n\");",
          "573:    dprintf (\"},\");",
          "574:    free (class_name);",
          "575:    free (super_name);",
          "580:   for (i = 0; i < bin->header.method_size; i++) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "646: static RList* methods (RBinFile *arch) {",
          "647:  RBinDexObj *bin;",
          "649:   return NULL;",
          "650:  bin = (RBinDexObj*) arch->o->bin_obj;",
          "652:   dex_loadcode (arch, bin);",
          "653:  return bin->methods_list;",
          "654: }",
          "",
          "[Removed Lines]",
          "648:  if (!arch || !arch->o || !arch->o->bin_obj)",
          "651:  if (!bin->methods_list)",
          "",
          "[Added Lines]",
          "658:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "660:  }",
          "662:  if (!bin->methods_list) {",
          "664:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "700:    continue;",
          "701:   }",
          "704:    continue;",
          "705:   r_buf_read_at (bin->b, bin->strings[entry.source_file],",
          "706:     (ut8*)name, len);",
          "",
          "[Removed Lines]",
          "703:   if (entry.source_file >= bin->header.strings_size)",
          "",
          "[Added Lines]",
          "715:   if (entry.source_file >= bin->header.strings_size) {",
          "717:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "712:   class->name = dex_class_name_byid (bin, entry.class_id);",
          "715:   if (cn) {",
          "716:    free (class->name);",
          "717:    class->index = class_index++;",
          "",
          "[Removed Lines]",
          "714:   char *cn = getClassName(class->name);",
          "",
          "[Added Lines]",
          "727:   char *cn = getClassName (class->name);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "719:    class->name = cn;",
          "725:    r_list_append (ret, class);",
          "726:    dprintf (\"class.%s=%d\\n\", name[0]==12?name+1:name, entry.class_id);",
          "",
          "[Removed Lines]",
          "722:    int *methods = parse_class (arch, bin, &entry, class);",
          "723:    free (methods);",
          "",
          "[Added Lines]",
          "735:    free (parse_class (arch, bin, &entry, class));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
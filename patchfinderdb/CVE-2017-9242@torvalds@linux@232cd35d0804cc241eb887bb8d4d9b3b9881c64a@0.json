{
  "cve_id": "CVE-2017-9242",
  "cve_desc": "The __ip6_append_data function in net/ipv6/ip6_output.c in the Linux kernel through 4.11.3 is too late in checking whether an overwrite of an skb data structure may occur, which allows local users to cause a denial of service (system crash) via crafted system calls.",
  "repo": "torvalds/linux",
  "patch_hash": "232cd35d0804cc241eb887bb8d4d9b3b9881c64a",
  "patch_info": {
    "commit_hash": "232cd35d0804cc241eb887bb8d4d9b3b9881c64a",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/232cd35d0804cc241eb887bb8d4d9b3b9881c64a",
    "files": [
      "net/ipv6/ip6_output.c"
    ],
    "message": "ipv6: fix out of bound writes in __ip6_append_data()\n\nAndrey Konovalov and idaifish@gmail.com reported crashes caused by\none skb shared_info being overwritten from __ip6_append_data()\n\nAndrey program lead to following state :\n\ncopy -4200 datalen 2000 fraglen 2040\nmaxfraglen 2040 alloclen 2048 transhdrlen 0 offset 0 fraggap 6200\n\nThe skb_copy_and_csum_bits(skb_prev, maxfraglen, data + transhdrlen,\nfraggap, 0); is overwriting skb->head and skb_shared_info\n\nSince we apparently detect this rare condition too late, move the\ncode earlier to even avoid allocating skb and risking crashes.\n\nOnce again, many thanks to Andrey and syzkaller team.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nReported-by: <idaifish@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
      "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1467:    alloclen += sizeof(struct frag_hdr);",
      "1469:    if (transhdrlen) {",
      "1470:     skb = sock_alloc_send_skb(sk,",
      "1471:       alloclen + hh_len,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1469:    copy = datalen - transhdrlen - fraggap;",
      "1470:    if (copy < 0) {",
      "1471:     err = -EINVAL;",
      "1472:     goto error;",
      "1473:    }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1515:     data += fraggap;",
      "1516:     pskb_trim_unique(skb_prev, maxfraglen);",
      "1517:    }",
      "1525:     err = -EFAULT;",
      "1526:     kfree_skb(skb);",
      "1527:     goto error;",
      "",
      "[Removed Lines]",
      "1518:    copy = datalen - transhdrlen - fraggap;",
      "1520:    if (copy < 0) {",
      "1521:     err = -EINVAL;",
      "1522:     kfree_skb(skb);",
      "1523:     goto error;",
      "1524:    } else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {",
      "",
      "[Added Lines]",
      "1523:    if (copy > 0 &&",
      "1524:        getfrag(from, data + transhdrlen, offset,",
      "1525:         copy, fraggap, skb) < 0) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "15e36f5b8e982debe43e425d2e12d34e022d51e9",
      "candidate_info": {
        "commit_hash": "15e36f5b8e982debe43e425d2e12d34e022d51e9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/15e36f5b8e982debe43e425d2e12d34e022d51e9",
        "files": [
          "net/ipv4/ip_output.c",
          "net/ipv6/ip6_output.c"
        ],
        "message": "udp: paged allocation with gso\n\nWhen sending large datagrams that are later segmented, store data in\npage frags to avoid copying from linear in skb_segment.\n\nSigned-off-by: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/ip_output.c||net/ipv4/ip_output.c",
          "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
          ],
          "candidate": [
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/ip_output.c||net/ipv4/ip_output.c": [
          "File: net/ipv4/ip_output.c -> net/ipv4/ip_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "878:  struct rtable *rt = (struct rtable *)cork->dst;",
          "879:  unsigned int wmem_alloc_delta = 0;",
          "880:  u32 tskey = 0;",
          "882:  skb = skb_peek_tail(queue);",
          "884:  exthdrlen = !skb ? rt->dst.header_len : 0;",
          "885:  mtu = cork->gso_size ? IP_MAX_MTU : cork->fragsize;",
          "887:  if (cork->tx_flags & SKBTX_ANY_SW_TSTAMP &&",
          "888:      sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "881:  bool paged;",
          "887:  paged = !!cork->gso_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "934:    unsigned int fraglen;",
          "935:    unsigned int fraggap;",
          "936:    unsigned int alloclen;",
          "937:    struct sk_buff *skb_prev;",
          "938: alloc_new_skb:",
          "939:    skb_prev = skb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "939:    unsigned int pagedlen = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "954:    if ((flags & MSG_MORE) &&",
          "955:        !(rt->dst.dev->features&NETIF_F_SG))",
          "956:     alloclen = mtu;",
          "958:     alloclen = fraglen;",
          "960:    alloclen += exthdrlen;",
          "",
          "[Removed Lines]",
          "957:    else",
          "",
          "[Added Lines]",
          "960:    else if (!paged)",
          "962:    else {",
          "963:     alloclen = min_t(int, fraglen, MAX_HEADER);",
          "964:     pagedlen = fraglen - alloclen;",
          "965:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1003:    skb_set_network_header(skb, exthdrlen);",
          "1004:    skb->transport_header = (skb->network_header +",
          "1005:        fragheaderlen);",
          "",
          "[Removed Lines]",
          "1002:    data = skb_put(skb, fraglen + exthdrlen);",
          "",
          "[Added Lines]",
          "1009:    data = skb_put(skb, fraglen + exthdrlen - pagedlen);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1015:     pskb_trim_unique(skb_prev, maxfraglen);",
          "1016:    }",
          "1019:    if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {",
          "1020:     err = -EFAULT;",
          "1021:     kfree_skb(skb);",
          "",
          "[Removed Lines]",
          "1018:    copy = datalen - transhdrlen - fraggap;",
          "",
          "[Added Lines]",
          "1025:    copy = datalen - transhdrlen - fraggap - pagedlen;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1023:    }",
          "1025:    offset += copy;",
          "1027:    transhdrlen = 0;",
          "1028:    exthdrlen = 0;",
          "1029:    csummode = CHECKSUM_NONE;",
          "",
          "[Removed Lines]",
          "1026:    length -= datalen - fraggap;",
          "",
          "[Added Lines]",
          "1033:    length -= copy + transhdrlen;",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
          "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1276:  int csummode = CHECKSUM_NONE;",
          "1277:  unsigned int maxnonfragsize, headersize;",
          "1278:  unsigned int wmem_alloc_delta = 0;",
          "1280:  skb = skb_peek_tail(queue);",
          "1281:  if (!skb) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1279:  bool paged;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1283:   dst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;",
          "1284:  }",
          "1286:  mtu = cork->gso_size ? IP6_MAX_MTU : cork->fragsize;",
          "1287:  orig_mtu = mtu;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1287:  paged = !!cork->gso_size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1374:    unsigned int fraglen;",
          "1375:    unsigned int fraggap;",
          "1376:    unsigned int alloclen;",
          "1377: alloc_new_skb:",
          "1379:    if (skb)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1379:    unsigned int pagedlen = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1397:    if (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)",
          "1398:     datalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;",
          "1399:    if ((flags & MSG_MORE) &&",
          "1400:        !(rt->dst.dev->features&NETIF_F_SG))",
          "1401:     alloclen = mtu;",
          "1405:    alloclen += dst_exthdrlen;",
          "",
          "[Removed Lines]",
          "1402:    else",
          "1403:     alloclen = datalen + fragheaderlen;",
          "",
          "[Added Lines]",
          "1402:    fraglen = datalen + fragheaderlen;",
          "1407:    else if (!paged)",
          "1408:     alloclen = fraglen;",
          "1409:    else {",
          "1410:     alloclen = min_t(int, fraglen, MAX_HEADER);",
          "1411:     pagedlen = fraglen - alloclen;",
          "1412:    }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1423:    alloclen += sizeof(struct frag_hdr);",
          "1426:    if (copy < 0) {",
          "1427:     err = -EINVAL;",
          "1428:     goto error;",
          "",
          "[Removed Lines]",
          "1425:    copy = datalen - transhdrlen - fraggap;",
          "",
          "[Added Lines]",
          "1434:    copy = datalen - transhdrlen - fraggap - pagedlen;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1465:    skb_set_network_header(skb, exthdrlen);",
          "1466:    data += fragheaderlen;",
          "1467:    skb->transport_header = (skb->network_header +",
          "",
          "[Removed Lines]",
          "1464:    data = skb_put(skb, fraglen);",
          "",
          "[Added Lines]",
          "1473:    data = skb_put(skb, fraglen - pagedlen);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1484:    }",
          "1486:    offset += copy;",
          "1488:    transhdrlen = 0;",
          "1489:    exthdrlen = 0;",
          "1490:    dst_exthdrlen = 0;",
          "",
          "[Removed Lines]",
          "1487:    length -= datalen - fraggap;",
          "",
          "[Added Lines]",
          "1496:    length -= copy + transhdrlen;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
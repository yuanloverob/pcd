{
  "cve_id": "CVE-2020-13974",
  "cve_desc": "An issue was discovered in the Linux kernel 4.4 through 5.7.1. drivers/tty/vt/keyboard.c has an integer overflow if k_ascii is called several times in a row, aka CID-b86dab054059. NOTE: Members in the community argue that the integer overflow does not lead to a security issue in this case.",
  "repo": "torvalds/linux",
  "patch_hash": "b86dab054059b970111b5516ae548efaae5b3aae",
  "patch_info": {
    "commit_hash": "b86dab054059b970111b5516ae548efaae5b3aae",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b86dab054059b970111b5516ae548efaae5b3aae",
    "files": [
      "drivers/tty/vt/keyboard.c"
    ],
    "message": "vt: keyboard: avoid signed integer overflow in k_ascii\n\nWhen k_ascii is invoked several times in a row there is a potential for\nsigned integer overflow:\n\nUBSAN: Undefined behaviour in drivers/tty/vt/keyboard.c:888:19 signed integer overflow:\n10 * 1111111111 cannot be represented in type 'int'\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.6.11 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\nCall Trace:\n <IRQ>\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xce/0x128 lib/dump_stack.c:118\n ubsan_epilogue+0xe/0x30 lib/ubsan.c:154\n handle_overflow+0xdc/0xf0 lib/ubsan.c:184\n __ubsan_handle_mul_overflow+0x2a/0x40 lib/ubsan.c:205\n k_ascii+0xbf/0xd0 drivers/tty/vt/keyboard.c:888\n kbd_keycode drivers/tty/vt/keyboard.c:1477 [inline]\n kbd_event+0x888/0x3be0 drivers/tty/vt/keyboard.c:1495\n\nWhile it can be worked around by using check_mul_overflow()/\ncheck_add_overflow(), it is better to introduce a separate flag to\nsignal that number pad is being used to compose a symbol, and\nchange type of the accumulator from signed to unsigned, thus\navoiding undefined behavior when it overflows.\n\nReported-by: Kyungtae Kim <kt0755@gmail.com>\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>\nCc: stable <stable@vger.kernel.org>\nLink: https://lore.kernel.org/r/20200525232740.GA262061@dtor-ws\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/tty/vt/keyboard.c||drivers/tty/vt/keyboard.c"
    ]
  },
  "patch_diff": {
    "drivers/tty/vt/keyboard.c||drivers/tty/vt/keyboard.c": [
      "File: drivers/tty/vt/keyboard.c -> drivers/tty/vt/keyboard.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "129: static bool dead_key_next;",
      "131: static unsigned int diacr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "132: static bool npadch_active;",
      "133: static unsigned int npadch_value;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "845:   shift_state &= ~(1 << value);",
      "849:   if (kbd->kbdmode == VC_UNICODE)",
      "851:   else",
      "854:  }",
      "855: }",
      "",
      "[Removed Lines]",
      "848:  if (up_flag && shift_state != old_state && npadch != -1) {",
      "850:    to_utf8(vc, npadch);",
      "852:    put_queue(vc, npadch & 0xff);",
      "853:   npadch = -1;",
      "",
      "[Added Lines]",
      "852:  if (up_flag && shift_state != old_state && npadch_active) {",
      "854:    to_utf8(vc, npadch_value);",
      "856:    put_queue(vc, npadch_value & 0xff);",
      "857:   npadch_active = false;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "869: static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)",
      "870: {",
      "873:  if (up_flag)",
      "874:   return;",
      "",
      "[Removed Lines]",
      "871:  int base;",
      "",
      "[Added Lines]",
      "875:  unsigned int base;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "882:   base = 16;",
      "883:  }",
      "889: }",
      "891: static void k_lock(struct vc_data *vc, unsigned char value, char up_flag)",
      "",
      "[Removed Lines]",
      "885:  if (npadch == -1)",
      "886:   npadch = value;",
      "887:  else",
      "888:   npadch = npadch * base + value;",
      "",
      "[Added Lines]",
      "889:  if (!npadch_active) {",
      "890:   npadch_value = 0;",
      "891:   npadch_active = true;",
      "892:  }",
      "894:  npadch_value = npadch_value * base + value;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2b86cb8299765688c5119fd18d5f436716c81010",
      "candidate_info": {
        "commit_hash": "2b86cb8299765688c5119fd18d5f436716c81010",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2b86cb8299765688c5119fd18d5f436716c81010",
        "files": [
          "net/dsa/slave.c"
        ],
        "message": "net: dsa: declare lockless TX feature for slave ports\n\nBe there a platform with the following layout:\n\n      Regular NIC\n       |\n       +----> DSA master for switch port\n               |\n               +----> DSA master for another switch port\n\nAfter changing DSA back to static lockdep class keys in commit\n1a33e10e4a95 (\"net: partially revert dynamic lockdep key changes\"), this\nkernel splat can be seen:\n\n[   13.361198] ============================================\n[   13.366524] WARNING: possible recursive locking detected\n[   13.371851] 5.7.0-rc4-02121-gc32a05ecd7af-dirty #988 Not tainted\n[   13.377874] --------------------------------------------\n[   13.383201] swapper/0/0 is trying to acquire lock:\n[   13.388004] ffff0000668ff298 (&dsa_slave_netdev_xmit_lock_key){+.-.}-{2:2}, at: __dev_queue_xmit+0x84c/0xbe0\n[   13.397879]\n[   13.397879] but task is already holding lock:\n[   13.403727] ffff0000661a1698 (&dsa_slave_netdev_xmit_lock_key){+.-.}-{2:2}, at: __dev_queue_xmit+0x84c/0xbe0\n[   13.413593]\n[   13.413593] other info that might help us debug this:\n[   13.420140]  Possible unsafe locking scenario:\n[   13.420140]\n[   13.426075]        CPU0\n[   13.428523]        ----\n[   13.430969]   lock(&dsa_slave_netdev_xmit_lock_key);\n[   13.435946]   lock(&dsa_slave_netdev_xmit_lock_key);\n[   13.440924]\n[   13.440924]  *** DEADLOCK ***\n[   13.440924]\n[   13.446860]  May be due to missing lock nesting notation\n[   13.446860]\n[   13.453668] 6 locks held by swapper/0/0:\n[   13.457598]  #0: ffff800010003de0 ((&idev->mc_ifc_timer)){+.-.}-{0:0}, at: call_timer_fn+0x0/0x400\n[   13.466593]  #1: ffffd4d3fb478700 (rcu_read_lock){....}-{1:2}, at: mld_sendpack+0x0/0x560\n[   13.474803]  #2: ffffd4d3fb478728 (rcu_read_lock_bh){....}-{1:2}, at: ip6_finish_output2+0x64/0xb10\n[   13.483886]  #3: ffffd4d3fb478728 (rcu_read_lock_bh){....}-{1:2}, at: __dev_queue_xmit+0x6c/0xbe0\n[   13.492793]  #4: ffff0000661a1698 (&dsa_slave_netdev_xmit_lock_key){+.-.}-{2:2}, at: __dev_queue_xmit+0x84c/0xbe0\n[   13.503094]  #5: ffffd4d3fb478728 (rcu_read_lock_bh){....}-{1:2}, at: __dev_queue_xmit+0x6c/0xbe0\n[   13.512000]\n[   13.512000] stack backtrace:\n[   13.516369] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.7.0-rc4-02121-gc32a05ecd7af-dirty #988\n[   13.530421] Call trace:\n[   13.532871]  dump_backtrace+0x0/0x1d8\n[   13.536539]  show_stack+0x24/0x30\n[   13.539862]  dump_stack+0xe8/0x150\n[   13.543271]  __lock_acquire+0x1030/0x1678\n[   13.547290]  lock_acquire+0xf8/0x458\n[   13.550873]  _raw_spin_lock+0x44/0x58\n[   13.554543]  __dev_queue_xmit+0x84c/0xbe0\n[   13.558562]  dev_queue_xmit+0x24/0x30\n[   13.562232]  dsa_slave_xmit+0xe0/0x128\n[   13.565988]  dev_hard_start_xmit+0xf4/0x448\n[   13.570182]  __dev_queue_xmit+0x808/0xbe0\n[   13.574200]  dev_queue_xmit+0x24/0x30\n[   13.577869]  neigh_resolve_output+0x15c/0x220\n[   13.582237]  ip6_finish_output2+0x244/0xb10\n[   13.586430]  __ip6_finish_output+0x1dc/0x298\n[   13.590709]  ip6_output+0x84/0x358\n[   13.594116]  mld_sendpack+0x2bc/0x560\n[   13.597786]  mld_ifc_timer_expire+0x210/0x390\n[   13.602153]  call_timer_fn+0xcc/0x400\n[   13.605822]  run_timer_softirq+0x588/0x6e0\n[   13.609927]  __do_softirq+0x118/0x590\n[   13.613597]  irq_exit+0x13c/0x148\n[   13.616918]  __handle_domain_irq+0x6c/0xc0\n[   13.621023]  gic_handle_irq+0x6c/0x160\n[   13.624779]  el1_irq+0xbc/0x180\n[   13.627927]  cpuidle_enter_state+0xb4/0x4d0\n[   13.632120]  cpuidle_enter+0x3c/0x50\n[   13.635703]  call_cpuidle+0x44/0x78\n[   13.639199]  do_idle+0x228/0x2c8\n[   13.642433]  cpu_startup_entry+0x2c/0x48\n[   13.646363]  rest_init+0x1ac/0x280\n[   13.649773]  arch_call_rest_init+0x14/0x1c\n[   13.653878]  start_kernel+0x490/0x4bc\n\nLockdep keys themselves were added in commit ab92d68fc22f (\"net: core:\nadd generic lockdep keys\"), and it's very likely that this splat existed\nsince then, but I have no real way to check, since this stacked platform\nwasn't supported by mainline back then.\n\n>From Taehee's own words:\n\n  This patch was considered that all stackable devices have LLTX flag.\n  But the dsa doesn't have LLTX, so this splat happened.\n  After this patch, dsa shares the same lockdep class key.\n  On the nested dsa interface architecture, which you illustrated,\n  the same lockdep class key will be used in __dev_queue_xmit() because\n  dsa doesn't have LLTX.\n  So that lockdep detects deadlock because the same lockdep class key is\n  used recursively although actually the different locks are used.\n  There are some ways to fix this problem.\n\n  1. using NETIF_F_LLTX flag.\n  If possible, using the LLTX flag is a very clear way for it.\n  But I'm so sorry I don't know whether the dsa could have LLTX or not.\n\n  2. using dynamic lockdep again.\n  It means that each interface uses a separate lockdep class key.\n  So, lockdep will not detect recursive locking.\n  But this way has a problem that it could consume lockdep class key\n  too many.\n  Currently, lockdep can have 8192 lockdep class keys.\n   - you can see this number with the following command.\n     cat /proc/lockdep_stats\n     lock-classes:                         1251 [max: 8192]\n     ...\n     The [max: 8192] means that the maximum number of lockdep class keys.\n  If too many lockdep class keys are registered, lockdep stops to work.\n  So, using a dynamic(separated) lockdep class key should be considered\n  carefully.\n  In addition, updating lockdep class key routine might have to be existing.\n  (lockdep_register_key(), lockdep_set_class(), lockdep_unregister_key())\n\n  3. Using lockdep subclass.\n  A lockdep class key could have 8 subclasses.\n  The different subclass is considered different locks by lockdep\n  infrastructure.\n  But \"lock-classes\" is not counted by subclasses.\n  So, it could avoid stopping lockdep infrastructure by an overflow of\n  lockdep class keys.\n  This approach should also have an updating lockdep class key routine.\n  (lockdep_set_subclass())\n\n  4. Using nonvalidate lockdep class key.\n  The lockdep infrastructure supports nonvalidate lockdep class key type.\n  It means this lockdep is not validated by lockdep infrastructure.\n  So, the splat will not happen but lockdep couldn't detect real deadlock\n  case because lockdep really doesn't validate it.\n  I think this should be used for really special cases.\n  (lockdep_set_novalidate_class())\n\nFurther discussion here:\nhttps://patchwork.ozlabs.org/project/netdev/patch/20200503052220.4536-2-xiyou.wangcong@gmail.com/\n\nThere appears to be no negative side-effect to declaring lockless TX for\nthe DSA virtual interfaces, which means they handle their own locking.\nSo that's what we do to make the splat go away.\n\nPatch tested in a wide variety of cases: unicast, multicast, PTP, etc.\n\nFixes: ab92d68fc22f (\"net: core: add generic lockdep keys\")\nSuggested-by: Taehee Yoo <ap420073@gmail.com>\nSigned-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>\nReviewed-by: Florian Fainelli <f.fainelli@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/dsslave.c||net/dsa/slave.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/dsslave.c||net/dsa/slave.c": [
          "File: net/dsslave.c -> net/dsa/slave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1739:  slave_dev->features |= NETIF_F_LLTX;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2473d24f2b77da0ffabcbb916793e58e7f57440b",
      "candidate_info": {
        "commit_hash": "2473d24f2b77da0ffabcbb916793e58e7f57440b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2473d24f2b77da0ffabcbb916793e58e7f57440b",
        "files": [
          "fs/btrfs/scrub.c"
        ],
        "message": "btrfs: fix a race between scrub and block group removal/allocation\n\nWhen scrub is verifying the extents of a block group for a device, it is\npossible that the corresponding block group gets removed and its logical\naddress and device extents get used for a new block group allocation.\nWhen this happens scrub incorrectly reports that errors were detected\nand, if the the new block group has a different profile then the old one,\ndeleted block group, we can crash due to a null pointer dereference.\nPossibly other unexpected and weird consequences can happen as well.\n\nConsider the following sequence of actions that leads to the null pointer\ndereference crash when scrub is running in parallel with balance:\n\n1) Balance sets block group X to read-only mode and starts relocating it.\n   Block group X is a metadata block group, has a raid1 profile (two\n   device extents, each one in a different device) and a logical address\n   of 19424870400;\n\n2) Scrub is running and finds device extent E, which belongs to block\n   group X. It enters scrub_stripe() to find all extents allocated to\n   block group X, the search is done using the extent tree;\n\n3) Balance finishes relocating block group X and removes block group X;\n\n4) Balance starts relocating another block group and when trying to\n   commit the current transaction as part of the preparation step\n   (prepare_to_relocate()), it blocks because scrub is running;\n\n5) The scrub task finds the metadata extent at the logical address\n   19425001472 and marks the pages of the extent to be read by a bio\n   (struct scrub_bio). The extent item's flags, which have the bit\n   BTRFS_EXTENT_FLAG_TREE_BLOCK set, are added to each page (struct\n   scrub_page). It is these flags in the scrub pages that tells the\n   bio's end io function (scrub_bio_end_io_worker) which type of extent\n   it is dealing with. At this point we end up with 4 pages in a bio\n   which is ready for submission (the metadata extent has a size of\n   16Kb, so that gives 4 pages on x86);\n\n6) At the next iteration of scrub_stripe(), scrub checks that there is a\n   pause request from the relocation task trying to commit a transaction,\n   therefore it submits the pending bio and pauses, waiting for the\n   transaction commit to complete before resuming;\n\n7) The relocation task commits the transaction. The device extent E, that\n   was used by our block group X, is now available for allocation, since\n   the commit root for the device tree was swapped by the transaction\n   commit;\n\n8) Another task doing a direct IO write allocates a new data block group Y\n   which ends using device extent E. This new block group Y also ends up\n   getting the same logical address that block group X had: 19424870400.\n   This happens because block group X was the block group with the highest\n   logical address and, when allocating Y, find_next_chunk() returns the\n   end offset of the current last block group to be used as the logical\n   address for the new block group, which is\n\n        18351128576 + 1073741824 = 19424870400\n\n   So our new block group Y has the same logical address and device extent\n   that block group X had. However Y is a data block group, while X was\n   a metadata one, and Y has a raid0 profile, while X had a raid1 profile;\n\n9) After allocating block group Y, the direct IO submits a bio to write\n   to device extent E;\n\n10) The read bio submitted by scrub reads the 4 pages (16Kb) from device\n    extent E, which now correspond to the data written by the task that\n    did a direct IO write. Then at the end io function associated with\n    the bio, scrub_bio_end_io_worker(), we call scrub_block_complete()\n    which calls scrub_checksum(). This later function checks the flags\n    of the first page, and sees that the bit BTRFS_EXTENT_FLAG_TREE_BLOCK\n    is set in the flags, so it assumes it has a metadata extent and\n    then calls scrub_checksum_tree_block(). That functions returns an\n    error, since interpreting data as a metadata extent causes the\n    checksum verification to fail.\n\n    So this makes scrub_checksum() call scrub_handle_errored_block(),\n    which determines 'failed_mirror_index' to be 1, since the device\n    extent E was allocated as the second mirror of block group X.\n\n    It allocates BTRFS_MAX_MIRRORS scrub_block structures as an array at\n    'sblocks_for_recheck', and all the memory is initialized to zeroes by\n    kcalloc().\n\n    After that it calls scrub_setup_recheck_block(), which is responsible\n    for filling each of those structures. However, when that function\n    calls btrfs_map_sblock() against the logical address of the metadata\n    extent, 19425001472, it gets a struct btrfs_bio ('bbio') that matches\n    the current block group Y. However block group Y has a raid0 profile\n    and not a raid1 profile like X had, so the following call returns 1:\n\n       scrub_nr_raid_mirrors(bbio)\n\n    And as a result scrub_setup_recheck_block() only initializes the\n    first (index 0) scrub_block structure in 'sblocks_for_recheck'.\n\n    Then scrub_recheck_block() is called by scrub_handle_errored_block()\n    with the second (index 1) scrub_block structure as the argument,\n    because 'failed_mirror_index' was previously set to 1.\n    This scrub_block was not initialized by scrub_setup_recheck_block(),\n    so it has zero pages, its 'page_count' member is 0 and its 'pagev'\n    page array has all members pointing to NULL.\n\n    Finally when scrub_recheck_block() calls scrub_recheck_block_checksum()\n    we have a NULL pointer dereference when accessing the flags of the first\n    page, as pavev[0] is NULL:\n\n    static void scrub_recheck_block_checksum(struct scrub_block *sblock)\n    {\n        (...)\n        if (sblock->pagev[0]->flags & BTRFS_EXTENT_FLAG_DATA)\n            scrub_checksum_data(sblock);\n        (...)\n    }\n\n    Producing a stack trace like the following:\n\n    [542998.008985] BUG: kernel NULL pointer dereference, address: 0000000000000028\n    [542998.010238] #PF: supervisor read access in kernel mode\n    [542998.010878] #PF: error_code(0x0000) - not-present page\n    [542998.011516] PGD 0 P4D 0\n    [542998.011929] Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC PTI\n    [542998.012786] CPU: 3 PID: 4846 Comm: kworker/u8:1 Tainted: G    B   W         5.6.0-rc7-btrfs-next-58 #1\n    [542998.014524] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\n    [542998.016065] Workqueue: btrfs-scrub btrfs_work_helper [btrfs]\n    [542998.017255] RIP: 0010:scrub_recheck_block_checksum+0xf/0x20 [btrfs]\n    [542998.018474] Code: 4c 89 e6 ...\n    [542998.021419] RSP: 0018:ffffa7af0375fbd8 EFLAGS: 00010202\n    [542998.022120] RAX: 0000000000000000 RBX: ffff9792e674d120 RCX: 0000000000000000\n    [542998.023178] RDX: 0000000000000001 RSI: ffff9792e674d120 RDI: ffff9792e674d120\n    [542998.024465] RBP: 0000000000000000 R08: 0000000000000067 R09: 0000000000000001\n    [542998.025462] R10: ffffa7af0375fa50 R11: 0000000000000000 R12: ffff9791f61fe800\n    [542998.026357] R13: ffff9792e674d120 R14: 0000000000000001 R15: ffffffffc0e3dfc0\n    [542998.027237] FS:  0000000000000000(0000) GS:ffff9792fb200000(0000) knlGS:0000000000000000\n    [542998.028327] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    [542998.029261] CR2: 0000000000000028 CR3: 00000000b3b18003 CR4: 00000000003606e0\n    [542998.030301] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    [542998.031316] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n    [542998.032380] Call Trace:\n    [542998.032752]  scrub_recheck_block+0x162/0x400 [btrfs]\n    [542998.033500]  ? __alloc_pages_nodemask+0x31e/0x460\n    [542998.034228]  scrub_handle_errored_block+0x6f8/0x1920 [btrfs]\n    [542998.035170]  scrub_bio_end_io_worker+0x100/0x520 [btrfs]\n    [542998.035991]  btrfs_work_helper+0xaa/0x720 [btrfs]\n    [542998.036735]  process_one_work+0x26d/0x6a0\n    [542998.037275]  worker_thread+0x4f/0x3e0\n    [542998.037740]  ? process_one_work+0x6a0/0x6a0\n    [542998.038378]  kthread+0x103/0x140\n    [542998.038789]  ? kthread_create_worker_on_cpu+0x70/0x70\n    [542998.039419]  ret_from_fork+0x3a/0x50\n    [542998.039875] Modules linked in: dm_snapshot dm_thin_pool ...\n    [542998.047288] CR2: 0000000000000028\n    [542998.047724] ---[ end trace bde186e176c7f96a ]---\n\nThis issue has been around for a long time, possibly since scrub exists.\nThe last time I ran into it was over 2 years ago. After recently fixing\nfstests to pass the \"--full-balance\" command line option to btrfs-progs\nwhen doing balance, several tests started to more heavily exercise balance\nwith fsstress, scrub and other operations in parallel, and therefore\nstarted to hit this issue again (with btrfs/061 for example).\n\nFix this by having scrub increment the 'trimming' counter of the block\ngroup, which pins the block group in such a way that it guarantees neither\nits logical address nor device extents can be reused by future block group\nallocations until we decrement the 'trimming' counter. Also make sure that\non each iteration of scrub_stripe() we stop scrubbing the block group if\nit was removed already.\n\nA later patch in the series will rename the block group's 'trimming'\ncounter and its helpers to a more generic name, since now it is not used\nexclusively for pinning while trimming anymore.\n\nCC: stable@vger.kernel.org # 4.4+\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/scrub.c||fs/btrfs/scrub.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/scrub.c||fs/btrfs/scrub.c": [
          "File: fs/btrfs/scrub.c -> fs/btrfs/scrub.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3046: static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,",
          "3047:         struct map_lookup *map,",
          "3048:         struct btrfs_device *scrub_dev,",
          "3050: {",
          "3051:  struct btrfs_path *path, *ppath;",
          "3052:  struct btrfs_fs_info *fs_info = sctx->fs_info;",
          "",
          "[Removed Lines]",
          "3049:         int num, u64 base, u64 length)",
          "",
          "[Added Lines]",
          "3049:         int num, u64 base, u64 length,",
          "3050:         struct btrfs_block_group *cache)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3284:     break;",
          "3285:    }",
          "3287:    extent = btrfs_item_ptr(l, slot,",
          "3288:       struct btrfs_extent_item);",
          "3289:    flags = btrfs_extent_flags(l, extent);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3294:    spin_lock(&cache->lock);",
          "3295:    if (cache->removed) {",
          "3296:     spin_unlock(&cache->lock);",
          "3297:     ret = 0;",
          "3298:     goto out;",
          "3299:    }",
          "3300:    spin_unlock(&cache->lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3457:   if (map->stripes[i].dev->bdev == scrub_dev->bdev &&",
          "3458:       map->stripes[i].physical == dev_offset) {",
          "3459:    ret = scrub_stripe(sctx, map, scrub_dev, i,",
          "3461:    if (ret)",
          "3462:     goto out;",
          "3463:   }",
          "",
          "[Removed Lines]",
          "3460:         chunk_offset, length);",
          "",
          "[Added Lines]",
          "3475:         chunk_offset, length, cache);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3554:   if (!cache)",
          "3555:    goto skip;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3580:   spin_lock(&cache->lock);",
          "3581:   if (cache->removed) {",
          "3582:    spin_unlock(&cache->lock);",
          "3583:    btrfs_put_block_group(cache);",
          "3584:    goto skip;",
          "3585:   }",
          "3586:   btrfs_get_block_group_trimming(cache);",
          "3587:   spin_unlock(&cache->lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3609:   } else {",
          "3610:    btrfs_warn(fs_info,",
          "3611:        \"failed setting block group ro: %d\", ret);",
          "3612:    btrfs_put_block_group(cache);",
          "3613:    scrub_pause_off(fs_info);",
          "3614:    break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3644:    btrfs_put_block_group_trimming(cache);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3695:    spin_unlock(&cache->lock);",
          "3696:   }",
          "3698:   btrfs_put_block_group(cache);",
          "3699:   if (ret)",
          "3700:    break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3731:   btrfs_put_block_group_trimming(cache);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "99a1ae29360980e79fa2d616819a6fe7411e4eda",
      "candidate_info": {
        "commit_hash": "99a1ae29360980e79fa2d616819a6fe7411e4eda",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/99a1ae29360980e79fa2d616819a6fe7411e4eda",
        "files": [
          "drivers/clk/bcm/clk-bcm2835.c"
        ],
        "message": "clk: bcm2835: Remove casting to bcm2835_clk_register\n\nThere are four different callback functions that are used for the\nclk_register callback that all have different second parameter types.\n\nbcm2835_register_pll -> struct bcm2835_pll_data\nbcm2835_register_pll_divider -> struct bcm2835_pll_divider_data\nbcm2835_register_clock -> struct bcm2835_clock_data\nbcm2835_register_date -> struct bcm2835_gate_data\n\nThese callbacks are cast to bcm2835_clk_register so that there is no\nerror about incompatible pointer types. Unfortunately, this is a control\nflow integrity violation, which verifies that the callback function's\ntypes match the prototypes exactly before jumping.\n\n[    0.857913] CFI failure (target: 0xffffff9334a81820):\n[    0.857977] WARNING: CPU: 3 PID: 35 at kernel/cfi.c:29 __cfi_check_fail+0x50/0x58\n[    0.857985] Modules linked in:\n[    0.858007] CPU: 3 PID: 35 Comm: kworker/3:1 Not tainted 4.19.123-v8-01301-gdbb48f16956e4-dirty #1\n[    0.858015] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT)\n[    0.858031] Workqueue: events 0xffffff9334a925c8\n[    0.858046] pstate: 60000005 (nZCv daif -PAN -UAO)\n[    0.858058] pc : __cfi_check_fail+0x50/0x58\n[    0.858070] lr : __cfi_check_fail+0x50/0x58\n[    0.858078] sp : ffffff800814ba90\n[    0.858086] x29: ffffff800814ba90 x28: 000fffffffdfff3d\n[    0.858101] x27: 00000000002000c2 x26: ffffff93355fdb18\n[    0.858116] x25: 0000000000000000 x24: ffffff9334a81820\n[    0.858131] x23: ffffff93357f3580 x22: ffffff9334af1000\n[    0.858146] x21: a79b57e88f8ebc81 x20: ffffff93357f3580\n[    0.858161] x19: ffffff9334a81820 x18: fffffff679769070\n[    0.858175] x17: 0000000000000000 x16: 0000000000000000\n[    0.858190] x15: 0000000000000004 x14: 000000000000003c\n[    0.858205] x13: 0000000000003044 x12: 0000000000000000\n[    0.858220] x11: b57e91cd641bae00 x10: b57e91cd641bae00\n[    0.858235] x9 : b57e91cd641bae00 x8 : b57e91cd641bae00\n[    0.858250] x7 : 0000000000000000 x6 : ffffff933591d4e5\n[    0.858264] x5 : 0000000000000000 x4 : 0000000000000000\n[    0.858279] x3 : ffffff800814b718 x2 : ffffff9334a84818\n[    0.858293] x1 : ffffff9334bba66c x0 : 0000000000000029\n[    0.858308] Call trace:\n[    0.858321]  __cfi_check_fail+0x50/0x58\n[    0.858337]  __cfi_check+0x3ab3c/0x4467c\n[    0.858351]  bcm2835_clk_probe+0x210/0x2dc\n[    0.858369]  platform_drv_probe+0xb0/0xfc\n[    0.858380]  really_probe+0x4a0/0x5a8\n[    0.858391]  driver_probe_device+0x68/0x104\n[    0.858403]  __device_attach_driver+0x100/0x148\n[    0.858418]  bus_for_each_drv+0xb0/0x12c\n[    0.858431]  __device_attach.llvm.17225159516306086099+0xc0/0x168\n[    0.858443]  bus_probe_device+0x44/0xfc\n[    0.858455]  deferred_probe_work_func+0xa0/0xe0\n[    0.858472]  process_one_work+0x210/0x538\n[    0.858485]  worker_thread+0x2e8/0x478\n[    0.858500]  kthread+0x154/0x164\n[    0.858515]  ret_from_fork+0x10/0x18\n\nTo fix this, change the second parameter of all functions void * and use\na local variable with the correct type so that everything works\nproperly. With this, the only use of bcm2835_clk_register is in struct\nbcm2835_clk_desc so we can just remove it and use the type directly.\n\nFixes: 56eb3a2ed972 (\"clk: bcm2835: remove use of BCM2835_CLOCK_COUNT in driver\")\nLink: https://github.com/ClangBuiltLinux/linux/issues/1028\nSigned-off-by: Nathan Chancellor <natechancellor@gmail.com>\nLink: https://lkml.kernel.org/r/20200516080806.1459784-2-natechancellor@gmail.com\nSigned-off-by: Stephen Boyd <sboyd@kernel.org>",
        "before_after_code_files": [
          "drivers/clk/bcm/clk-bcm2835.c||drivers/clk/bcm/clk-bcm2835.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/clk/bcm/clk-bcm2835.c||drivers/clk/bcm/clk-bcm2835.c": [
          "File: drivers/clk/bcm/clk-bcm2835.c -> drivers/clk/bcm/clk-bcm2835.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1296: };",
          "1298: static struct clk_hw *bcm2835_register_pll(struct bcm2835_cprman *cprman,",
          "1300: {",
          "1301:  struct bcm2835_pll *pll;",
          "1302:  struct clk_init_data init;",
          "1303:  int ret;",
          "",
          "[Removed Lines]",
          "1299:         const struct bcm2835_pll_data *data)",
          "",
          "[Added Lines]",
          "1299:         const void *data)",
          "1301:  const struct bcm2835_pll_data *pll_data = data;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1308:  init.parent_names = &cprman->real_parent_names[0];",
          "1309:  init.num_parents = 1;",
          "1311:  init.ops = &bcm2835_pll_clk_ops;",
          "1312:  init.flags = CLK_IGNORE_UNUSED;",
          "",
          "[Removed Lines]",
          "1310:  init.name = data->name;",
          "",
          "[Added Lines]",
          "1311:  init.name = pll_data->name;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1316:   return NULL;",
          "1318:  pll->cprman = cprman;",
          "1320:  pll->hw.init = &init;",
          "1322:  ret = devm_clk_hw_register(cprman->dev, &pll->hw);",
          "",
          "[Removed Lines]",
          "1319:  pll->data = data;",
          "",
          "[Added Lines]",
          "1320:  pll->data = pll_data;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1328: static struct clk_hw *",
          "1329: bcm2835_register_pll_divider(struct bcm2835_cprman *cprman,",
          "1331: {",
          "1332:  struct bcm2835_pll_divider *divider;",
          "1333:  struct clk_init_data init;",
          "1334:  const char *divider_name;",
          "1335:  int ret;",
          "1338:   divider_name = devm_kasprintf(cprman->dev, GFP_KERNEL,",
          "1340:   if (!divider_name)",
          "1341:    return NULL;",
          "1342:  } else {",
          "1344:  }",
          "1346:  memset(&init, 0, sizeof(init));",
          "1349:  init.num_parents = 1;",
          "1350:  init.name = divider_name;",
          "1351:  init.ops = &bcm2835_pll_divider_clk_ops;",
          "1354:  divider = devm_kzalloc(cprman->dev, sizeof(*divider), GFP_KERNEL);",
          "1355:  if (!divider)",
          "1356:   return NULL;",
          "1359:  divider->div.shift = A2W_PLL_DIV_SHIFT;",
          "1360:  divider->div.width = A2W_PLL_DIV_BITS;",
          "1361:  divider->div.flags = CLK_DIVIDER_MAX_AT_ZERO;",
          "",
          "[Removed Lines]",
          "1330:         const struct bcm2835_pll_divider_data *data)",
          "1337:  if (data->fixed_divider != 1) {",
          "1339:            \"%s_prediv\", data->name);",
          "1343:   divider_name = data->name;",
          "1348:  init.parent_names = &data->source_pll;",
          "1352:  init.flags = data->flags | CLK_IGNORE_UNUSED;",
          "1358:  divider->div.reg = cprman->regs + data->a2w_reg;",
          "",
          "[Added Lines]",
          "1331:         const void *data)",
          "1333:  const struct bcm2835_pll_divider_data *divider_data = data;",
          "1339:  if (divider_data->fixed_divider != 1) {",
          "1341:            \"%s_prediv\", divider_data->name);",
          "1345:   divider_name = divider_data->name;",
          "1350:  init.parent_names = &divider_data->source_pll;",
          "1354:  init.flags = divider_data->flags | CLK_IGNORE_UNUSED;",
          "1360:  divider->div.reg = cprman->regs + divider_data->a2w_reg;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1364:  divider->div.table = NULL;",
          "1366:  divider->cprman = cprman;",
          "1369:  ret = devm_clk_hw_register(cprman->dev, &divider->div.hw);",
          "1370:  if (ret)",
          "",
          "[Removed Lines]",
          "1367:  divider->data = data;",
          "",
          "[Added Lines]",
          "1369:  divider->data = divider_data;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1379:           divider_name,",
          "1380:           CLK_SET_RATE_PARENT,",
          "1381:           1,",
          "1383:  }",
          "1385:  return &divider->div.hw;",
          "1386: }",
          "1388: static struct clk_hw *bcm2835_register_clock(struct bcm2835_cprman *cprman,",
          "1390: {",
          "1391:  struct bcm2835_clock *clock;",
          "1392:  struct clk_init_data init;",
          "1393:  const char *parents[1 << CM_SRC_BITS];",
          "",
          "[Removed Lines]",
          "1377:  if (data->fixed_divider != 1) {",
          "1378:   return clk_hw_register_fixed_factor(cprman->dev, data->name,",
          "1382:           data->fixed_divider);",
          "1389:        const struct bcm2835_clock_data *data)",
          "",
          "[Added Lines]",
          "1379:  if (divider_data->fixed_divider != 1) {",
          "1380:   return clk_hw_register_fixed_factor(cprman->dev,",
          "1381:           divider_data->name,",
          "1385:           divider_data->fixed_divider);",
          "1392:           const void *data)",
          "1394:  const struct bcm2835_clock_data *clock_data = data;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1404:   ret = match_string(cprman_parent_names,",
          "1405:        ARRAY_SIZE(cprman_parent_names),",
          "",
          "[Removed Lines]",
          "1401:  for (i = 0; i < data->num_mux_parents; i++) {",
          "1402:   parents[i] = data->parents[i];",
          "",
          "[Added Lines]",
          "1405:  for (i = 0; i < clock_data->num_mux_parents; i++) {",
          "1406:   parents[i] = clock_data->parents[i];",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1411:  memset(&init, 0, sizeof(init));",
          "1412:  init.parent_names = parents;",
          "1422:   init.flags |= CLK_SET_RATE_PARENT;",
          "1425:   init.ops = &bcm2835_vpu_clock_clk_ops;",
          "1426:  } else {",
          "1427:   init.ops = &bcm2835_clock_clk_ops;",
          "",
          "[Removed Lines]",
          "1413:  init.num_parents = data->num_mux_parents;",
          "1414:  init.name = data->name;",
          "1415:  init.flags = data->flags | CLK_IGNORE_UNUSED;",
          "1421:  if (data->set_rate_parent)",
          "1424:  if (data->is_vpu_clock) {",
          "",
          "[Added Lines]",
          "1417:  init.num_parents = clock_data->num_mux_parents;",
          "1418:  init.name = clock_data->name;",
          "1419:  init.flags = clock_data->flags | CLK_IGNORE_UNUSED;",
          "1425:  if (clock_data->set_rate_parent)",
          "1428:  if (clock_data->is_vpu_clock) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1434:    init.flags &= ~CLK_IS_CRITICAL;",
          "1435:  }",
          "",
          "[Removed Lines]",
          "1433:   if (!(cprman_read(cprman, data->ctl_reg) & CM_ENABLE))",
          "",
          "[Added Lines]",
          "1437:   if (!(cprman_read(cprman, clock_data->ctl_reg) & CM_ENABLE))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1439:   return NULL;",
          "1441:  clock->cprman = cprman;",
          "1443:  clock->hw.init = &init;",
          "1445:  ret = devm_clk_hw_register(cprman->dev, &clock->hw);",
          "",
          "[Removed Lines]",
          "1442:  clock->data = data;",
          "",
          "[Added Lines]",
          "1446:  clock->data = clock_data;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1449: }",
          "1451: static struct clk_hw *bcm2835_register_gate(struct bcm2835_cprman *cprman,",
          "1453: {",
          "1455:         CLK_IGNORE_UNUSED | CLK_SET_RATE_GATE,",
          "1457:         CM_GATE_BIT, 0, &cprman->regs_lock);",
          "1458: }",
          "1462: struct bcm2835_clk_desc {",
          "1464:  unsigned int supported;",
          "1465:  const void *data;",
          "1466: };",
          "1470:           .supported = s,    \\",
          "1471:           .data = __VA_ARGS__ }",
          "1472: #define REGISTER_PLL(s, ...) _REGISTER(&bcm2835_register_pll, \\",
          "",
          "[Removed Lines]",
          "1452:       const struct bcm2835_gate_data *data)",
          "1454:  return clk_hw_register_gate(cprman->dev, data->name, data->parent,",
          "1456:         cprman->regs + data->ctl_reg,",
          "1460: typedef struct clk_hw *(*bcm2835_clk_register)(struct bcm2835_cprman *cprman,",
          "1461:             const void *data);",
          "1463:  bcm2835_clk_register clk_register;",
          "1469: #define _REGISTER(f, s, ...) { .clk_register = (bcm2835_clk_register)f, \\",
          "",
          "[Added Lines]",
          "1456:          const void *data)",
          "1458:  const struct bcm2835_gate_data *gate_data = data;",
          "1460:  return clk_hw_register_gate(cprman->dev, gate_data->name,",
          "1461:         gate_data->parent,",
          "1463:         cprman->regs + gate_data->ctl_reg,",
          "1468:  struct clk_hw *(*clk_register)(struct bcm2835_cprman *cprman,",
          "1469:            const void *data);",
          "1475: #define _REGISTER(f, s, ...) { .clk_register = f, \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e2d4a80f93fcfaf72e2e20daf6a28e39c3b90677",
      "candidate_info": {
        "commit_hash": "e2d4a80f93fcfaf72e2e20daf6a28e39c3b90677",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e2d4a80f93fcfaf72e2e20daf6a28e39c3b90677",
        "files": [
          "net/mac80211/mesh_hwmp.c"
        ],
        "message": "mac80211: mesh: fix discovery timer re-arming issue / crash\n\nOn a non-forwarding 802.11s link between two fairly busy\nneighboring nodes (iperf with -P 16 at ~850MBit/s TCP;\n1733.3 MBit/s VHT-MCS 9 80MHz short GI VHT-NSS 4), so with\nfrequent PREQ retries, usually after around 30-40 seconds the\nfollowing crash would occur:\n\n[ 1110.822428] Unable to handle kernel read from unreadable memory at virtual address 00000000\n[ 1110.830786] Mem abort info:\n[ 1110.833573]   Exception class = IABT (current EL), IL = 32 bits\n[ 1110.839494]   SET = 0, FnV = 0\n[ 1110.842546]   EA = 0, S1PTW = 0\n[ 1110.845678] user pgtable: 4k pages, 48-bit VAs, pgd = ffff800076386000\n[ 1110.852204] [0000000000000000] *pgd=00000000f6322003, *pud=00000000f62de003, *pmd=0000000000000000\n[ 1110.861167] Internal error: Oops: 86000004 [#1] PREEMPT SMP\n[ 1110.866730] Modules linked in: pppoe ppp_async batman_adv ath10k_pci ath10k_core ath pppox ppp_generic nf_conntrack_ipv6 mac80211 iptable_nat ipt_REJECT ipt_MASQUERADE cfg80211 xt_time xt_tcpudp xt_state xt_nat xt_multiport xt_mark xt_mac xt_limit xt_conntrack xt_comment xt_TCPMSS xt_REDIRECT xt_LOG xt_FLOWOFFLOAD slhc nf_reject_ipv4 nf_nat_redirect nf_nat_masquerade_ipv4 nf_conntrack_ipv4 nf_nat_ipv4 nf_nat nf_log_ipv4 nf_flow_table_hw nf_flow_table nf_defrag_ipv6 nf_defrag_ipv4 nf_conntrack_rtcache nf_conntrack iptable_mangle iptable_filter ip_tables crc_ccitt compat nf_log_ipv6 nf_log_common ip6table_mangle ip6table_filter ip6_tables ip6t_REJECT x_tables nf_reject_ipv6 usb_storage xhci_plat_hcd xhci_pci xhci_hcd dwc3 usbcore usb_common\n[ 1110.932190] Process swapper/3 (pid: 0, stack limit = 0xffff0000090c8000)\n[ 1110.938884] CPU: 3 PID: 0 Comm: swapper/3 Not tainted 4.14.162 #0\n[ 1110.944965] Hardware name: LS1043A RGW Board (DT)\n[ 1110.949658] task: ffff8000787a81c0 task.stack: ffff0000090c8000\n[ 1110.955568] PC is at 0x0\n[ 1110.958097] LR is at call_timer_fn.isra.27+0x24/0x78\n[ 1110.963055] pc : [<0000000000000000>] lr : [<ffff0000080ff29c>] pstate: 00400145\n[ 1110.970440] sp : ffff00000801be10\n[ 1110.973744] x29: ffff00000801be10 x28: ffff000008bf7018\n[ 1110.979047] x27: ffff000008bf87c8 x26: ffff000008c160c0\n[ 1110.984352] x25: 0000000000000000 x24: 0000000000000000\n[ 1110.989657] x23: dead000000000200 x22: 0000000000000000\n[ 1110.994959] x21: 0000000000000000 x20: 0000000000000101\n[ 1111.000262] x19: ffff8000787a81c0 x18: 0000000000000000\n[ 1111.005565] x17: ffff0000089167b0 x16: 0000000000000058\n[ 1111.010868] x15: ffff0000089167b0 x14: 0000000000000000\n[ 1111.016172] x13: ffff000008916788 x12: 0000000000000040\n[ 1111.021475] x11: ffff80007fda9af0 x10: 0000000000000001\n[ 1111.026777] x9 : ffff00000801bea0 x8 : 0000000000000004\n[ 1111.032080] x7 : 0000000000000000 x6 : ffff80007fda9aa8\n[ 1111.037383] x5 : ffff00000801bea0 x4 : 0000000000000010\n[ 1111.042685] x3 : ffff00000801be98 x2 : 0000000000000614\n[ 1111.047988] x1 : 0000000000000000 x0 : 0000000000000000\n[ 1111.053290] Call trace:\n[ 1111.055728] Exception stack(0xffff00000801bcd0 to 0xffff00000801be10)\n[ 1111.062158] bcc0:                                   0000000000000000 0000000000000000\n[ 1111.069978] bce0: 0000000000000614 ffff00000801be98 0000000000000010 ffff00000801bea0\n[ 1111.077798] bd00: ffff80007fda9aa8 0000000000000000 0000000000000004 ffff00000801bea0\n[ 1111.085618] bd20: 0000000000000001 ffff80007fda9af0 0000000000000040 ffff000008916788\n[ 1111.093437] bd40: 0000000000000000 ffff0000089167b0 0000000000000058 ffff0000089167b0\n[ 1111.101256] bd60: 0000000000000000 ffff8000787a81c0 0000000000000101 0000000000000000\n[ 1111.109075] bd80: 0000000000000000 dead000000000200 0000000000000000 0000000000000000\n[ 1111.116895] bda0: ffff000008c160c0 ffff000008bf87c8 ffff000008bf7018 ffff00000801be10\n[ 1111.124715] bdc0: ffff0000080ff29c ffff00000801be10 0000000000000000 0000000000400145\n[ 1111.132534] bde0: ffff8000787a81c0 ffff00000801bde8 0000ffffffffffff 000001029eb19be8\n[ 1111.140353] be00: ffff00000801be10 0000000000000000\n[ 1111.145220] [<          (null)>]           (null)\n[ 1111.149917] [<ffff0000080ff77c>] run_timer_softirq+0x184/0x398\n[ 1111.155741] [<ffff000008081938>] __do_softirq+0x100/0x1fc\n[ 1111.161130] [<ffff0000080a2e28>] irq_exit+0x80/0xd8\n[ 1111.166002] [<ffff0000080ea708>] __handle_domain_irq+0x88/0xb0\n[ 1111.171825] [<ffff000008081678>] gic_handle_irq+0x68/0xb0\n[ 1111.177213] Exception stack(0xffff0000090cbe30 to 0xffff0000090cbf70)\n[ 1111.183642] be20:                                   0000000000000020 0000000000000000\n[ 1111.191461] be40: 0000000000000001 0000000000000000 00008000771af000 0000000000000000\n[ 1111.199281] be60: ffff000008c95180 0000000000000000 ffff000008c19360 ffff0000090cbef0\n[ 1111.207101] be80: 0000000000000810 0000000000000400 0000000000000098 ffff000000000000\n[ 1111.214920] bea0: 0000000000000001 ffff0000089167b0 0000000000000000 ffff0000089167b0\n[ 1111.222740] bec0: 0000000000000000 ffff000008c198e8 ffff000008bf7018 ffff000008c19000\n[ 1111.230559] bee0: 0000000000000000 0000000000000000 ffff8000787a81c0 ffff000008018000\n[ 1111.238380] bf00: ffff00000801c000 ffff00000913ba34 ffff8000787a81c0 ffff0000090cbf70\n[ 1111.246199] bf20: ffff0000080857cc ffff0000090cbf70 ffff0000080857d0 0000000000400145\n[ 1111.254020] bf40: ffff000008018000 ffff00000801c000 ffffffffffffffff ffff0000080fa574\n[ 1111.261838] bf60: ffff0000090cbf70 ffff0000080857d0\n[ 1111.266706] [<ffff0000080832e8>] el1_irq+0xe8/0x18c\n[ 1111.271576] [<ffff0000080857d0>] arch_cpu_idle+0x10/0x18\n[ 1111.276880] [<ffff0000080d7de4>] do_idle+0xec/0x1b8\n[ 1111.281748] [<ffff0000080d8020>] cpu_startup_entry+0x20/0x28\n[ 1111.287399] [<ffff00000808f81c>] secondary_start_kernel+0x104/0x110\n[ 1111.293662] Code: bad PC value\n[ 1111.296710] ---[ end trace 555b6ca4363c3edd ]---\n[ 1111.301318] Kernel panic - not syncing: Fatal exception in interrupt\n[ 1111.307661] SMP: stopping secondary CPUs\n[ 1111.311574] Kernel Offset: disabled\n[ 1111.315053] CPU features: 0x0002000\n[ 1111.318530] Memory Limit: none\n[ 1111.321575] Rebooting in 3 seconds..\n\nWith some added debug output / delays we were able to push the crash from\nthe timer callback runner into the callback function and by that shedding\nsome light on which object holding the timer gets corrupted:\n\n[  401.720899] Unable to handle kernel read from unreadable memory at virtual address 00000868\n[...]\n[  402.335836] [<ffff0000088fafa4>] _raw_spin_lock_bh+0x14/0x48\n[  402.341548] [<ffff000000dbe684>] mesh_path_timer+0x10c/0x248 [mac80211]\n[  402.348154] [<ffff0000080ff29c>] call_timer_fn.isra.27+0x24/0x78\n[  402.354150] [<ffff0000080ff77c>] run_timer_softirq+0x184/0x398\n[  402.359974] [<ffff000008081938>] __do_softirq+0x100/0x1fc\n[  402.365362] [<ffff0000080a2e28>] irq_exit+0x80/0xd8\n[  402.370231] [<ffff0000080ea708>] __handle_domain_irq+0x88/0xb0\n[  402.376053] [<ffff000008081678>] gic_handle_irq+0x68/0xb0\n\nThe issue happens due to the following sequence of events:\n\n1) mesh_path_start_discovery():\n-> spin_unlock_bh(&mpath->state_lock) before mesh_path_sel_frame_tx()\n\n2) mesh_path_free_rcu()\n-> del_timer_sync(&mpath->timer)\n   [...]\n-> kfree_rcu(mpath)\n\n3) mesh_path_start_discovery():\n-> mod_timer(&mpath->timer, ...)\n   [...]\n-> rcu_read_unlock()\n\n4) mesh_path_free_rcu()'s kfree_rcu():\n-> kfree(mpath)\n\n5) mesh_path_timer() starts after timeout, using freed mpath object\n\nSo a use-after-free issue due to a timer re-arming bug caused by an\nearly spin-unlocking.\n\nThis patch fixes this issue by re-checking if mpath is about to be\nfree'd and if so bails out of re-arming the timer.\n\nCc: stable@vger.kernel.org\nFixes: 050ac52cbe1f (\"mac80211: code for on-demand Hybrid Wireless Mesh Protocol\")\nCc: Simon Wunderlich <sw@simonwunderlich.de>\nSigned-off-by: Linus L\u00fcssing <ll@simonwunderlich.de>\nLink: https://lore.kernel.org/r/20200522170413.14973-1-linus.luessing@c0d3.blue\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
        "before_after_code_files": [
          "net/mac80211/mesh_hwmp.c||net/mac80211/mesh_hwmp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/mac80211/mesh_hwmp.c||net/mac80211/mesh_hwmp.c": [
          "File: net/mac80211/mesh_hwmp.c -> net/mac80211/mesh_hwmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1103:  mesh_path_sel_frame_tx(MPATH_PREQ, 0, sdata->vif.addr, ifmsh->sn,",
          "1104:           target_flags, mpath->dst, mpath->sn, da, 0,",
          "1105:           ttl, lifetime, 0, ifmsh->preq_id++, sdata);",
          "1106:  mod_timer(&mpath->timer, jiffies + mpath->discovery_timeout);",
          "1108: enddiscovery:",
          "1109:  rcu_read_unlock();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1107:  spin_lock_bh(&mpath->state_lock);",
          "1108:  if (mpath->flags & MESH_PATH_DELETED) {",
          "1109:   spin_unlock_bh(&mpath->state_lock);",
          "1110:   goto enddiscovery;",
          "1111:  }",
          "1113:  spin_unlock_bh(&mpath->state_lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6dcde60efd946e38fac8d276a6ca47492103e856",
      "candidate_info": {
        "commit_hash": "6dcde60efd946e38fac8d276a6ca47492103e856",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6dcde60efd946e38fac8d276a6ca47492103e856",
        "files": [
          "fs/xfs/kmem.h",
          "fs/xfs/libxfs/xfs_attr_leaf.c"
        ],
        "message": "xfs: more lockdep whackamole with kmem_alloc*\n\nDave Airlie reported the following lockdep complaint:\n\n>  ======================================================\n>  WARNING: possible circular locking dependency detected\n>  5.7.0-0.rc5.20200515git1ae7efb38854.1.fc33.x86_64 #1 Not tainted\n>  ------------------------------------------------------\n>  kswapd0/159 is trying to acquire lock:\n>  ffff9b38d01a4470 (&xfs_nondir_ilock_class){++++}-{3:3},\n>  at: xfs_ilock+0xde/0x2c0 [xfs]\n>\n>  but task is already holding lock:\n>  ffffffffbbb8bd00 (fs_reclaim){+.+.}-{0:0}, at:\n>  __fs_reclaim_acquire+0x5/0x30\n>\n>  which lock already depends on the new lock.\n>\n>\n>  the existing dependency chain (in reverse order) is:\n>\n>  -> #1 (fs_reclaim){+.+.}-{0:0}:\n>         fs_reclaim_acquire+0x34/0x40\n>         __kmalloc+0x4f/0x270\n>         kmem_alloc+0x93/0x1d0 [xfs]\n>         kmem_alloc_large+0x4c/0x130 [xfs]\n>         xfs_attr_copy_value+0x74/0xa0 [xfs]\n>         xfs_attr_get+0x9d/0xc0 [xfs]\n>         xfs_get_acl+0xb6/0x200 [xfs]\n>         get_acl+0x81/0x160\n>         posix_acl_xattr_get+0x3f/0xd0\n>         vfs_getxattr+0x148/0x170\n>         getxattr+0xa7/0x240\n>         path_getxattr+0x52/0x80\n>         do_syscall_64+0x5c/0xa0\n>         entry_SYSCALL_64_after_hwframe+0x49/0xb3\n>\n>  -> #0 (&xfs_nondir_ilock_class){++++}-{3:3}:\n>         __lock_acquire+0x1257/0x20d0\n>         lock_acquire+0xb0/0x310\n>         down_write_nested+0x49/0x120\n>         xfs_ilock+0xde/0x2c0 [xfs]\n>         xfs_reclaim_inode+0x3f/0x400 [xfs]\n>         xfs_reclaim_inodes_ag+0x20b/0x410 [xfs]\n>         xfs_reclaim_inodes_nr+0x31/0x40 [xfs]\n>         super_cache_scan+0x190/0x1e0\n>         do_shrink_slab+0x184/0x420\n>         shrink_slab+0x182/0x290\n>         shrink_node+0x174/0x680\n>         balance_pgdat+0x2d0/0x5f0\n>         kswapd+0x21f/0x510\n>         kthread+0x131/0x150\n>         ret_from_fork+0x3a/0x50\n>\n>  other info that might help us debug this:\n>\n>   Possible unsafe locking scenario:\n>\n>         CPU0                    CPU1\n>         ----                    ----\n>    lock(fs_reclaim);\n>                                 lock(&xfs_nondir_ilock_class);\n>                                 lock(fs_reclaim);\n>    lock(&xfs_nondir_ilock_class);\n>\n>   *** DEADLOCK ***\n>\n>  4 locks held by kswapd0/159:\n>   #0: ffffffffbbb8bd00 (fs_reclaim){+.+.}-{0:0}, at:\n>  __fs_reclaim_acquire+0x5/0x30\n>   #1: ffffffffbbb7cef8 (shrinker_rwsem){++++}-{3:3}, at:\n>  shrink_slab+0x115/0x290\n>   #2: ffff9b39f07a50e8\n>  (&type->s_umount_key#56){++++}-{3:3}, at: super_cache_scan+0x38/0x1e0\n>   #3: ffff9b39f077f258\n>  (&pag->pag_ici_reclaim_lock){+.+.}-{3:3}, at:\n>  xfs_reclaim_inodes_ag+0x82/0x410 [xfs]\n\nThis is a known false positive because inodes cannot simultaneously be\ngetting reclaimed and the target of a getxattr operation, but lockdep\ndoesn't know that.  We can (selectively) shut up lockdep until either\nit gets smarter or we change inode reclaim not to require the ILOCK by\napplying a stupid GFP_NOLOCKDEP bandaid.\n\nReported-by: Dave Airlie <airlied@gmail.com>\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>\nTested-by: Dave Airlie <airlied@gmail.com>\nReviewed-by: Brian Foster <bfoster@redhat.com>",
        "before_after_code_files": [
          "fs/xfs/kmem.h||fs/xfs/kmem.h",
          "fs/xfs/libxfs/xfs_attr_leaf.c||fs/xfs/libxfs/xfs_attr_leaf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/xfs/kmem.h||fs/xfs/kmem.h": [
          "File: fs/xfs/kmem.h -> fs/xfs/kmem.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #define KM_NOFS  ((__force xfs_km_flags_t)0x0004u)",
          "20: #define KM_MAYFAIL ((__force xfs_km_flags_t)0x0008u)",
          "21: #define KM_ZERO  ((__force xfs_km_flags_t)0x0010u)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #define KM_NOLOCKDEP ((__force xfs_km_flags_t)0x0020u)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: {",
          "31:  gfp_t lflags;",
          "35:  lflags = GFP_KERNEL | __GFP_NOWARN;",
          "36:  if (flags & KM_NOFS)",
          "",
          "[Removed Lines]",
          "33:  BUG_ON(flags & ~(KM_NOFS|KM_MAYFAIL|KM_ZERO));",
          "",
          "[Added Lines]",
          "34:  BUG_ON(flags & ~(KM_NOFS | KM_MAYFAIL | KM_ZERO | KM_NOLOCKDEP));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "49:  if (flags & KM_ZERO)",
          "50:   lflags |= __GFP_ZERO;",
          "52:  return lflags;",
          "53: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53:  if (flags & KM_NOLOCKDEP)",
          "54:   lflags |= __GFP_NOLOCKDEP;",
          "",
          "---------------"
        ],
        "fs/xfs/libxfs/xfs_attr_leaf.c||fs/xfs/libxfs/xfs_attr_leaf.c": [
          "File: fs/xfs/libxfs/xfs_attr_leaf.c -> fs/xfs/libxfs/xfs_attr_leaf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "488:  }",
          "490:  if (!args->value) {",
          "492:   if (!args->value)",
          "493:    return -ENOMEM;",
          "494:  }",
          "",
          "[Removed Lines]",
          "491:   args->value = kmem_alloc_large(valuelen, 0);",
          "",
          "[Added Lines]",
          "491:   args->value = kmem_alloc_large(valuelen, KM_NOLOCKDEP);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
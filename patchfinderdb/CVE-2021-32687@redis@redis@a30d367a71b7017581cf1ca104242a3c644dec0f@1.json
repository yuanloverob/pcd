{
  "cve_id": "CVE-2021-32687",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
  "repo": "redis/redis",
  "patch_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
  "patch_info": {
    "commit_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
    "files": [
      "src/intset.c",
      "src/rdb.c",
      "src/t_set.c"
    ],
    "message": "Fix Integer overflow issue with intsets (CVE-2021-32687)\n\nThe vulnerability involves changing the default set-max-intset-entries\nconfiguration parameter to a very large value and constructing specially\ncrafted commands to manipulate sets",
    "before_after_code_files": [
      "src/intset.c||src/intset.c",
      "src/rdb.c||src/rdb.c",
      "src/t_set.c||src/t_set.c"
    ]
  },
  "patch_diff": {
    "src/intset.c||src/intset.c": [
      "File: src/intset.c -> src/intset.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: #include \"intset.h\"",
      "35: #include \"zmalloc.h\"",
      "36: #include \"endianconv.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37: #include \"redisassert.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105: static intset *intsetResize(intset *is, uint32_t len) {",
      "107:     is = zrealloc(is,sizeof(intset)+size);",
      "108:     return is;",
      "109: }",
      "",
      "[Removed Lines]",
      "106:     uint32_t size = len*intrev32ifbe(is->encoding);",
      "",
      "[Added Lines]",
      "107:     uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);",
      "108:     assert(size <= SIZE_MAX - sizeof(intset));",
      "",
      "---------------"
    ],
    "src/rdb.c||src/rdb.c": [
      "File: src/rdb.c -> src/rdb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1518:         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
      "1522:             o = createSetObject();",
      "",
      "[Removed Lines]",
      "1521:         if (len > server.set_max_intset_entries) {",
      "",
      "[Added Lines]",
      "1521:         size_t max_entries = server.set_max_intset_entries;",
      "1522:         if (max_entries >= 1<<30) max_entries = 1<<30;",
      "1523:         if (len > max_entries) {",
      "",
      "---------------"
    ],
    "src/t_set.c||src/t_set.c": [
      "File: src/t_set.c -> src/t_set.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "66:             if (success) {",
      "70:                     setTypeConvert(subject,OBJ_ENCODING_HT);",
      "71:                 return 1;",
      "72:             }",
      "",
      "[Removed Lines]",
      "69:                 if (intsetLen(subject->ptr) > server.set_max_intset_entries)",
      "",
      "[Added Lines]",
      "69:                 size_t max_entries = server.set_max_intset_entries;",
      "71:                 if (max_entries >= 1<<30) max_entries = 1<<30;",
      "72:                 if (intsetLen(subject->ptr) > max_entries)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
      "candidate_info": {
        "commit_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
        "files": [
          "src/scripting.c",
          "tests/unit/scripting.tcl"
        ],
        "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c",
          "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2030:     sds *argv = NULL;",
          "2031:     int argc = 0;",
          "2032:     if (sdslen(ldb.cbuf) == 0) return NULL;",
          "",
          "[Removed Lines]",
          "2029: sds *ldbReplParseCommand(int *argcp) {",
          "",
          "[Added Lines]",
          "2029: sds *ldbReplParseCommand(int *argcp, char** err) {",
          "2030:     static char* protocol_error = \"protocol error\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2044:     p = strchr(p,'*'); if (!p) goto protoerr;",
          "2049:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
          "",
          "[Removed Lines]",
          "2046:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2047:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2052:     argv = zmalloc(sizeof(sds)*(*argcp));",
          "2053:     argc = 0;",
          "2054:     while(argc < *argcp) {",
          "2055:         if (*p != '$') goto protoerr;",
          "2060:         if (slen <= 0 || slen > 1024) goto protoerr;",
          "2061:         argv[argc++] = sdsnewlen(p,slen);",
          "2063:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
          "",
          "[Removed Lines]",
          "2057:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2057:         if (*p == '\\0') goto keep_reading;",
          "2061:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "2065:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2067:     return argv;",
          "2069: protoerr:",
          "2070:     sdsfreesplitres(argv,argc);",
          "2071:     sdsfree(copy);",
          "2072:     return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2076: keep_reading:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2555: int ldbRepl(lua_State *lua) {",
          "2556:     sds *argv;",
          "2557:     int argc;",
          "2561:     while(1) {",
          "2563:             char buf[1024];",
          "2564:             int nread = connRead(ldb.conn,buf,sizeof(buf));",
          "2565:             if (nread <= 0) {",
          "",
          "[Removed Lines]",
          "2562:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
          "",
          "[Added Lines]",
          "2565:     char* err = NULL;",
          "2570:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
          "2572:             if (err) {",
          "2573:                 lua_pushstring(lua, err);",
          "2574:                 lua_error(lua);",
          "2575:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2570:                 return C_ERR;",
          "2571:             }",
          "2572:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
          "2573:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2588:             if (sdslen(ldb.cbuf) > 1<<20) {",
          "2589:                 sdsfree(ldb.cbuf);",
          "2590:                 ldb.cbuf = sdsempty();",
          "2591:                 lua_pushstring(lua, \"max client buffer reached\");",
          "2592:                 lua_error(lua);",
          "2593:             }",
          "",
          "---------------"
        ],
        "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
          "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "820:     r eval {return 'hello'} 0",
          "821:     r eval {return 'hello'} 0",
          "822: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "824: start_server {tags {\"scripting needs:debug external:skip\"}} {",
          "825:     test {Test scripting debug protocol parsing} {",
          "826:         r script debug sync",
          "827:         r eval {return 'hello'} 0",
          "828:         catch {r 'hello\\0world'} e",
          "829:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "830:         catch {r 'hello\\0'} e",
          "831:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "832:         catch {r '\\0hello'} e",
          "833:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "834:         catch {r '\\0hello\\0'} e",
          "835:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "836:     }",
          "837: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12a6b438a34b064389f347a09970237fc5f616d1",
      "candidate_info": {
        "commit_hash": "12a6b438a34b064389f347a09970237fc5f616d1",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/12a6b438a34b064389f347a09970237fc5f616d1",
        "files": [
          "src/rio.c"
        ],
        "message": "Fix harmless bug in rioConnRead (#7557)\n\nthis code is in use only if the master is disk-based, and the replica is\ndiskless. In this case we use a buffered reader, but we must avoid reading\npast the rdb file, into the command stream. which Luckly rdb.c doesn't\nreally attempt to do (it knows how much it should read).\n\nWhen rioConnRead detects that the extra buffering attempt reaches beyond\nthe read limit it should read less, but if the caller actually requested\nmore, then it should return with an error rather than a short read. the\nbug would have resulted in short read.\n\nin order to fix it, the code must consider the real requested size, and\nnot the extra buffering size.\n\n(cherry picked from commit 40d7fca3685d8439bae8480ddbd59775a2390411)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:     while (len > sdslen(r->io.conn.buf) - r->io.conn.pos) {",
          "192:         size_t buffered = sdslen(r->io.conn.buf) - r->io.conn.pos;",
          "197:         if (toread > sdsavail(r->io.conn.buf)) toread = sdsavail(r->io.conn.buf);",
          "198:         if (r->io.conn.read_limit != 0 &&",
          "199:             r->io.conn.read_so_far + buffered + toread > r->io.conn.read_limit)",
          "200:         {",
          "202:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "203:             else {",
          "204:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "193:         size_t toread = len - buffered;",
          "196:         if (toread < PROTO_IOBUF_LEN) toread = PROTO_IOBUF_LEN;",
          "201:             if (r->io.conn.read_limit >= r->io.conn.read_so_far - buffered)",
          "",
          "[Added Lines]",
          "193:         size_t needs = len - buffered;",
          "196:         size_t toread = needs < PROTO_IOBUF_LEN ? PROTO_IOBUF_LEN: needs;",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
      "candidate_info": {
        "commit_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "files": [
          "src/rio.c"
        ],
        "message": "more strict check in rioConnRead (#7564)\n\n(cherry picked from commit da840e9851bab8d1674e245a812b2105be111208)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "[Added Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
      "candidate_info": {
        "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "files": [
          "src/scripting.c"
        ],
        "message": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\u00a0 \u00a0to explode the LUA stack (notice that currently there is no such\n\u00a0 \u00a0command in Redis that returns such a nested reply, but modules might\n\u00a0 \u00a0do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n\u00a0 \u00a0explode the LUA stack (all the arguments will be pushed to the LUA\n\u00a0 \u00a0stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130: char *redisProtocolToLuaType(lua_State *lua, char* reply) {",
          "131:     char *p = reply;",
          "133:     switch(*p) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:     if (!lua_checkstack(lua, 5)) {",
          "138:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "139:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:             if (atype == '%') {",
          "221:                 p = redisProtocolToLuaType(lua,p);",
          "222:             } else {",
          "223:                 lua_pushboolean(lua,1);",
          "224:             }",
          "225:             lua_settable(lua,-3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:                 if (!lua_checkstack(lua, 1)) {",
          "236:                     serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "237:                 }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "341: void luaReplyToRedisReply(client *c, lua_State *lua) {",
          "342:     int t = lua_type(lua,-1);",
          "344:     switch(t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "358:     if (!lua_checkstack(lua, 4)) {",
          "363:         addReplyErrorFormat(c, \"reached lua stack limit\");",
          "364:         lua_pop(lua,1); // pop the element from the stack",
          "365:         return;",
          "366:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2506: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
          "2507:     int j, saved_rc = server.lua_replicate_commands;",
          "2509:     lua_getglobal(lua,\"redis\");",
          "2510:     lua_pushstring(lua,\"call\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2539:     if (!lua_checkstack(lua, argc + 1)) {",
          "2546:         ldbLogRedisReply(\"max lua stack reached\");",
          "2547:         return;",
          "2548:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
      "candidate_info": {
        "commit_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/dde1c975b88f2e305ad4df720230474e30f6b100",
        "files": [
          "src/replication.c",
          "src/rio.c"
        ],
        "message": "Minor refactoring for rioConnRead and adding errno (#9280)\n\nminor refactoring for rioConnRead and adding errno\n\n(cherry picked from commit a40381640502439f751f42c4b23d4c6d396993e3)",
        "before_after_code_files": [
          "src/replication.c||src/replication.c",
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/replication.c||src/replication.c": [
          "File: src/replication.c -> src/replication.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1667:         if (rdbLoadRio(&rdb,RDBFLAGS_REPLICATION,&rsi) != C_OK) {",
          "1670:             serverLog(LL_WARNING,",
          "1673:             cancelReplicationHandshake();",
          "1674:             rioFreeConn(&rdb, NULL);",
          "",
          "[Removed Lines]",
          "1669:             stopLoading(0);",
          "1671:                 \"Failed trying to load the MASTER synchronization DB \"",
          "1672:                 \"from socket\");",
          "",
          "[Added Lines]",
          "1670:                       \"Failed trying to load the MASTER synchronization DB \"",
          "1671:                       \"from socket: %s\", strerror(errno));",
          "1672:             stopLoading(0);",
          "",
          "---------------"
        ],
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:         r->io.conn.pos = 0;",
          "188:     }",
          "191:     while (len > sdslen(r->io.conn.buf) - r->io.conn.pos) {",
          "192:         size_t buffered = sdslen(r->io.conn.buf) - r->io.conn.pos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:     if (r->io.conn.read_limit != 0 && r->io.conn.read_limit < r->io.conn.read_so_far + len) {",
          "194:         errno = EOVERFLOW;",
          "195:         return 0;",
          "196:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "198:         if (r->io.conn.read_limit != 0 &&",
          "199:             r->io.conn.read_so_far + buffered + toread > r->io.conn.read_limit)",
          "200:         {",
          "210:         }",
          "211:         int retval = connRead(r->io.conn.conn,",
          "212:                           (char*)r->io.conn.buf + sdslen(r->io.conn.buf),",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "208:                 return 0;",
          "209:             }",
          "",
          "[Added Lines]",
          "209:             toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
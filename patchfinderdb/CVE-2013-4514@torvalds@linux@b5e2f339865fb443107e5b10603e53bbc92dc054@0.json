{
  "cve_id": "CVE-2013-4514",
  "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.",
  "repo": "torvalds/linux",
  "patch_hash": "b5e2f339865fb443107e5b10603e53bbc92dc054",
  "patch_info": {
    "commit_hash": "b5e2f339865fb443107e5b10603e53bbc92dc054",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054",
    "files": [
      "drivers/staging/wlags49_h2/wl_priv.c"
    ],
    "message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "drivers/staging/wlags49_h2/wl_priv.c||drivers/staging/wlags49_h2/wl_priv.c"
    ]
  },
  "patch_diff": {
    "drivers/staging/wlags49_h2/wl_priv.c||drivers/staging/wlags49_h2/wl_priv.c": [
      "File: drivers/staging/wlags49_h2/wl_priv.c -> drivers/staging/wlags49_h2/wl_priv.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "570:  ltv_t                   *pLtv;",
      "571:  bool_t                  ltvAllocated = FALSE;",
      "572:  ENCSTRCT                sEncryption;",
      "574: #ifdef USE_WDS",
      "575:  hcf_16                  hcfPort  = HCF_PORT_0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "573:  size_t   len;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "686:      break;",
      "687:     case CFG_CNF_OWN_NAME:",
      "688:      memset(lp->StationName, 0, sizeof(lp->StationName));",
      "690:      pLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
      "691:      break;",
      "692:     case CFG_CNF_LOAD_BALANCING:",
      "",
      "[Removed Lines]",
      "689:      memcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);",
      "",
      "[Added Lines]",
      "690:      len = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));",
      "691:      strlcpy(lp->StationName, &pLtv->u.u8[2], len);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1783: {",
      "1784:  struct wl_private *lp = wl_priv(dev);",
      "1785:  unsigned long flags;",
      "1786:  int         ret = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1788:  size_t len;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1793:  wl_lock(lp, &flags);",
      "1795:  memset(lp->StationName, 0, sizeof(lp->StationName));",
      "1800:  wl_apply(lp);",
      "",
      "[Removed Lines]",
      "1797:  memcpy(lp->StationName, extra, wrqu->data.length);",
      "",
      "[Added Lines]",
      "1799:  len = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));",
      "1800:  strlcpy(lp->StationName, extra, len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ceb121ae22a4c24f3382145e9407ef7322b7cd1c",
      "candidate_info": {
        "commit_hash": "ceb121ae22a4c24f3382145e9407ef7322b7cd1c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ceb121ae22a4c24f3382145e9407ef7322b7cd1c",
        "files": [
          "drivers/staging/wlags49_h2/wl_priv.c"
        ],
        "message": "staging: wlags49_h2: wl_priv: fixes spacing around parentheses\n\nThis commit fixes many instances where the spacing in and around\nparentheses was applied incorrectly.\n\nSigned-off-by: Johan Meiring <johanmeiring@gmail.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/staging/wlags49_h2/wl_priv.c||drivers/staging/wlags49_h2/wl_priv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/staging/wlags49_h2/wl_priv.c||drivers/staging/wlags49_h2/wl_priv.c"
          ],
          "candidate": [
            "drivers/staging/wlags49_h2/wl_priv.c||drivers/staging/wlags49_h2/wl_priv.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/staging/wlags49_h2/wl_priv.c||drivers/staging/wlags49_h2/wl_priv.c": [
          "File: drivers/staging/wlags49_h2/wl_priv.c -> drivers/staging/wlags49_h2/wl_priv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: #include <wl_util.h>",
          "82: #include <wl_netdev.h>",
          "",
          "[Removed Lines]",
          "84: int wvlan_uil_connect( struct uilreq *urq, struct wl_private *lp );",
          "85: int wvlan_uil_disconnect( struct uilreq *urq, struct wl_private *lp );",
          "86: int wvlan_uil_action( struct uilreq *urq, struct wl_private *lp );",
          "87: int wvlan_uil_block( struct uilreq *urq, struct wl_private *lp );",
          "88: int wvlan_uil_unblock( struct uilreq *urq, struct wl_private *lp );",
          "89: int wvlan_uil_send_diag_msg( struct uilreq *urq, struct wl_private *lp );",
          "90: int wvlan_uil_put_info( struct uilreq *urq, struct wl_private *lp );",
          "91: int wvlan_uil_get_info( struct uilreq *urq, struct wl_private *lp );",
          "93: int cfg_driver_info( struct uilreq *urq, struct wl_private *lp );",
          "94: int cfg_driver_identity( struct uilreq *urq, struct wl_private *lp );",
          "",
          "[Added Lines]",
          "84: int wvlan_uil_connect(struct uilreq *urq, struct wl_private *lp);",
          "85: int wvlan_uil_disconnect(struct uilreq *urq, struct wl_private *lp);",
          "86: int wvlan_uil_action(struct uilreq *urq, struct wl_private *lp);",
          "87: int wvlan_uil_block(struct uilreq *urq, struct wl_private *lp);",
          "88: int wvlan_uil_unblock(struct uilreq *urq, struct wl_private *lp);",
          "89: int wvlan_uil_send_diag_msg(struct uilreq *urq, struct wl_private *lp);",
          "90: int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp);",
          "91: int wvlan_uil_get_info(struct uilreq *urq, struct wl_private *lp);",
          "93: int cfg_driver_info(struct uilreq *urq, struct wl_private *lp);",
          "94: int cfg_driver_identity(struct uilreq *urq, struct wl_private *lp);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131: {",
          "132:  int ioctl_ret = 0;",
          "139:    case UIL_FUN_CONNECT:",
          "140:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_CONNECT\\n\");",
          "142:   break;",
          "143:    case UIL_FUN_DISCONNECT:",
          "144:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_DISCONNECT\\n\");",
          "146:   break;",
          "147:    case UIL_FUN_ACTION:",
          "150:   break;",
          "151:    case UIL_FUN_SEND_DIAG_MSG:",
          "152:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_SEND_DIAG_MSG\\n\");",
          "154:   break;",
          "155:    case UIL_FUN_GET_INFO:",
          "156:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_GET_INFO\\n\");",
          "158:   break;",
          "159:    case UIL_FUN_PUT_INFO:",
          "160:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_PUT_INFO\\n\");",
          "162:   break;",
          "163:  default:",
          "165:   ioctl_ret = -EOPNOTSUPP;",
          "166:   break;",
          "167:  }",
          "169:  return ioctl_ret;",
          "170: } // wvlan_uil",
          "",
          "[Removed Lines]",
          "130: int wvlan_uil( struct uilreq *urq, struct wl_private *lp )",
          "135:  DBG_FUNC( \"wvlan_uil\" );",
          "136:  DBG_ENTER( DbgInfo );",
          "138:  switch( urq->command ) {",
          "141:   ioctl_ret = wvlan_uil_connect( urq, lp );",
          "145:   ioctl_ret = wvlan_uil_disconnect( urq, lp );",
          "148:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_ACTION\\n\" );",
          "149:   ioctl_ret = wvlan_uil_action( urq, lp );",
          "153:   ioctl_ret = wvlan_uil_send_diag_msg( urq, lp );",
          "157:   ioctl_ret = wvlan_uil_get_info( urq, lp );",
          "161:   ioctl_ret = wvlan_uil_put_info( urq, lp );",
          "164:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- UNSUPPORTED UIL CODE: 0x%X\", urq->command );",
          "168:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "130: int wvlan_uil(struct uilreq *urq, struct wl_private *lp)",
          "135:  DBG_FUNC(\"wvlan_uil\");",
          "136:  DBG_ENTER(DbgInfo);",
          "138:  switch(urq->command) {",
          "141:   ioctl_ret = wvlan_uil_connect(urq, lp);",
          "145:   ioctl_ret = wvlan_uil_disconnect(urq, lp);",
          "148:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_ACTION\\n\");",
          "149:   ioctl_ret = wvlan_uil_action(urq, lp);",
          "153:   ioctl_ret = wvlan_uil_send_diag_msg(urq, lp);",
          "157:   ioctl_ret = wvlan_uil_get_info(urq, lp);",
          "161:   ioctl_ret = wvlan_uil_put_info(urq, lp);",
          "164:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- UNSUPPORTED UIL CODE: 0x%X\", urq->command);",
          "168:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "196: {",
          "197:  int result = 0;",
          "206:   lp->flags |= WVLAN2_UIL_CONNECTED;",
          "208:   urq->result = UIL_SUCCESS;",
          "209:  } else {",
          "211:   urq->result = UIL_ERR_IN_USE;",
          "212:  }",
          "215:  return result;",
          "216: } // wvlan_uil_connect",
          "",
          "[Removed Lines]",
          "195: int wvlan_uil_connect( struct uilreq *urq, struct wl_private *lp )",
          "201:  DBG_FUNC( \"wvlan_uil_connect\" );",
          "202:  DBG_ENTER( DbgInfo );",
          "205:  if( !( lp->flags & WVLAN2_UIL_CONNECTED )) {",
          "207:   urq->hcfCtx = &( lp->hcfCtx );",
          "210:   DBG_WARNING( DbgInfo, \"UIL_ERR_IN_USE\\n\" );",
          "214:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "195: int wvlan_uil_connect(struct uilreq *urq, struct wl_private *lp)",
          "201:  DBG_FUNC(\"wvlan_uil_connect\");",
          "202:  DBG_ENTER(DbgInfo);",
          "205:  if(!(lp->flags & WVLAN2_UIL_CONNECTED)) {",
          "207:   urq->hcfCtx = &(lp->hcfCtx);",
          "210:   DBG_WARNING(DbgInfo, \"UIL_ERR_IN_USE\\n\");",
          "214:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "242: {",
          "243:  int result = 0;",
          "252:   if (lp->flags & WVLAN2_UIL_CONNECTED) {",
          "253:    lp->flags &= ~WVLAN2_UIL_CONNECTED;",
          "",
          "[Removed Lines]",
          "241: int wvlan_uil_disconnect( struct uilreq *urq, struct wl_private *lp )",
          "247:  DBG_FUNC( \"wvlan_uil_disconnect\" );",
          "248:  DBG_ENTER( DbgInfo );",
          "251:  if( urq->hcfCtx == &( lp->hcfCtx )) {",
          "",
          "[Added Lines]",
          "241: int wvlan_uil_disconnect(struct uilreq *urq, struct wl_private *lp)",
          "247:  DBG_FUNC(\"wvlan_uil_disconnect\");",
          "248:  DBG_ENTER(DbgInfo);",
          "251:  if(urq->hcfCtx == &(lp->hcfCtx)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "262:   urq->hcfCtx = NULL;",
          "263:   urq->result = UIL_SUCCESS;",
          "264:  } else {",
          "266:   urq->result = UIL_ERR_WRONG_IFB;",
          "267:  }",
          "270:  return result;",
          "271: } // wvlan_uil_disconnect",
          "",
          "[Removed Lines]",
          "265:   DBG_ERROR( DbgInfo, \"UIL_ERR_WRONG_IFB\\n\" );",
          "269:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "265:   DBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");",
          "269:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "297: {",
          "298:  int     result = 0;",
          "299:  ltv_t   *ltv;",
          "309:   ltv = (ltv_t *)urq->data;",
          "314:    case UIL_ACT_BLOCK:",
          "317:     break;",
          "318:    case UIL_ACT_UNBLOCK:",
          "321:     break;",
          "322:    case UIL_ACT_SCAN:",
          "325:     break;",
          "326:    case UIL_ACT_APPLY:",
          "329:     break;",
          "330:    case UIL_ACT_RESET:",
          "333:     break;",
          "334:    default:",
          "336:     break;",
          "337:    }",
          "338:   } else {",
          "340:    urq->result = UIL_ERR_LEN;",
          "341:   }",
          "342:  } else {",
          "344:   urq->result = UIL_ERR_WRONG_IFB;",
          "345:  }",
          "348:  return result;",
          "349: } // wvlan_uil_action",
          "",
          "[Removed Lines]",
          "296: int wvlan_uil_action( struct uilreq *urq, struct wl_private *lp )",
          "303:  DBG_FUNC( \"wvlan_uil_action\" );",
          "304:  DBG_ENTER( DbgInfo );",
          "307:  if( urq->hcfCtx == &( lp->hcfCtx )) {",
          "310:   if( ltv != NULL ) {",
          "313:    switch( ltv->typ ) {",
          "315:     DBG_TRACE( DbgInfo, \"UIL_ACT_BLOCK\\n\" );",
          "316:     result = wvlan_uil_block( urq, lp );",
          "319:     DBG_TRACE( DbgInfo, \"UIL_ACT_UNBLOCK\\n\" );",
          "320:     result = wvlan_uil_unblock( urq, lp );",
          "323:     DBG_TRACE( DbgInfo, \"UIL_ACT_SCAN\\n\" );",
          "324:     urq->result = hcf_action( &( lp->hcfCtx ), MDD_ACT_SCAN );",
          "327:     DBG_TRACE( DbgInfo, \"UIL_ACT_APPLY\\n\" );",
          "328:     urq->result = wl_apply( lp );",
          "331:     DBG_TRACE( DbgInfo, \"UIL_ACT_RESET\\n\" );",
          "332:     urq->result = wl_go( lp );",
          "335:     DBG_WARNING( DbgInfo, \"Unknown action code: 0x%x\\n\", ltv->typ );",
          "339:    DBG_ERROR( DbgInfo, \"Bad LTV for this action\\n\" );",
          "343:   DBG_ERROR( DbgInfo, \"UIL_ERR_WRONG_IFB\\n\" );",
          "347:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "296: int wvlan_uil_action(struct uilreq *urq, struct wl_private *lp)",
          "303:  DBG_FUNC(\"wvlan_uil_action\");",
          "304:  DBG_ENTER(DbgInfo);",
          "307:  if(urq->hcfCtx == &(lp->hcfCtx)) {",
          "310:   if(ltv != NULL) {",
          "313:    switch(ltv->typ) {",
          "315:     DBG_TRACE(DbgInfo, \"UIL_ACT_BLOCK\\n\");",
          "316:     result = wvlan_uil_block(urq, lp);",
          "319:     DBG_TRACE(DbgInfo, \"UIL_ACT_UNBLOCK\\n\");",
          "320:     result = wvlan_uil_unblock(urq, lp);",
          "323:     DBG_TRACE(DbgInfo, \"UIL_ACT_SCAN\\n\");",
          "324:     urq->result = hcf_action(&(lp->hcfCtx), MDD_ACT_SCAN);",
          "327:     DBG_TRACE(DbgInfo, \"UIL_ACT_APPLY\\n\");",
          "328:     urq->result = wl_apply(lp);",
          "331:     DBG_TRACE(DbgInfo, \"UIL_ACT_RESET\\n\");",
          "332:     urq->result = wl_go(lp);",
          "335:     DBG_WARNING(DbgInfo, \"Unknown action code: 0x%x\\n\", ltv->typ);",
          "339:    DBG_ERROR(DbgInfo, \"Bad LTV for this action\\n\");",
          "343:   DBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");",
          "347:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "377: {",
          "378:  int result = 0;",
          "387:    lp->flags |= WVLAN2_UIL_BUSY;",
          "388:    netif_stop_queue(lp->dev);",
          "390:    urq->result = UIL_SUCCESS;",
          "391:   } else {",
          "393:    urq->result = UIL_FAILURE;",
          "394:    result = -EPERM;",
          "395:   }",
          "396:  } else {",
          "398:   urq->result = UIL_ERR_WRONG_IFB;",
          "399:  }",
          "402:  return result;",
          "403: } // wvlan_uil_block",
          "",
          "[Removed Lines]",
          "376: int wvlan_uil_block( struct uilreq *urq, struct wl_private *lp )",
          "382:  DBG_FUNC( \"wvlan_uil_block\" );",
          "383:  DBG_ENTER( DbgInfo );",
          "385:  if( urq->hcfCtx == &( lp->hcfCtx )) {",
          "386:   if( capable( CAP_NET_ADMIN )) {",
          "389:    WL_WDS_NETIF_STOP_QUEUE( lp );",
          "392:    DBG_ERROR( DbgInfo, \"EPERM\\n\" );",
          "397:   DBG_ERROR( DbgInfo, \"UIL_ERR_WRONG_IFB\\n\" );",
          "401:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "376: int wvlan_uil_block(struct uilreq *urq, struct wl_private *lp)",
          "382:  DBG_FUNC(\"wvlan_uil_block\");",
          "383:  DBG_ENTER(DbgInfo);",
          "385:  if(urq->hcfCtx == &(lp->hcfCtx)) {",
          "386:   if(capable(CAP_NET_ADMIN)) {",
          "389:    WL_WDS_NETIF_STOP_QUEUE(lp);",
          "392:    DBG_ERROR(DbgInfo, \"EPERM\\n\");",
          "397:   DBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");",
          "401:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "429: {",
          "430:  int result = 0;",
          "439:    if (lp->flags & WVLAN2_UIL_BUSY) {",
          "440:     lp->flags &= ~WVLAN2_UIL_BUSY;",
          "441:     netif_wake_queue(lp->dev);",
          "443:    }",
          "444:   } else {",
          "446:    urq->result = UIL_FAILURE;",
          "447:    result = -EPERM;",
          "448:   }",
          "449:  } else {",
          "451:   urq->result = UIL_ERR_WRONG_IFB;",
          "452:  }",
          "455:  return result;",
          "456: } // wvlan_uil_unblock",
          "",
          "[Removed Lines]",
          "428: int wvlan_uil_unblock( struct uilreq *urq, struct wl_private *lp )",
          "434:  DBG_FUNC( \"wvlan_uil_unblock\" );",
          "435:  DBG_ENTER( DbgInfo );",
          "437:  if( urq->hcfCtx == &( lp->hcfCtx )) {",
          "438:   if( capable( CAP_NET_ADMIN )) {",
          "442:     WL_WDS_NETIF_WAKE_QUEUE( lp );",
          "445:    DBG_ERROR( DbgInfo, \"EPERM\\n\" );",
          "450:   DBG_ERROR( DbgInfo, \"UIL_ERR_WRONG_IFB\\n\" );",
          "454:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "428: int wvlan_uil_unblock(struct uilreq *urq, struct wl_private *lp)",
          "434:  DBG_FUNC(\"wvlan_uil_unblock\");",
          "435:  DBG_ENTER(DbgInfo);",
          "437:  if(urq->hcfCtx == &(lp->hcfCtx)) {",
          "438:   if(capable(CAP_NET_ADMIN)) {",
          "442:     WL_WDS_NETIF_WAKE_QUEUE(lp);",
          "445:    DBG_ERROR(DbgInfo, \"EPERM\\n\");",
          "450:   DBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");",
          "454:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "482: {",
          "483:  int         result = 0;",
          "484:  DESC_STRCT  Descp[1];",
          "493:    if ((urq->data != NULL) && (urq->len != 0)) {",
          "494:     if (lp->hcfCtx.IFB_RscInd != 0) {",
          "495:      u_char *data;",
          "",
          "[Removed Lines]",
          "481: int wvlan_uil_send_diag_msg( struct uilreq *urq, struct wl_private *lp )",
          "488:  DBG_FUNC( \"wvlan_uil_send_diag_msg\" );",
          "489:  DBG_ENTER( DbgInfo );",
          "491:  if( urq->hcfCtx == &( lp->hcfCtx )) {",
          "492:   if( capable( CAP_NET_ADMIN )) {",
          "",
          "[Added Lines]",
          "481: int wvlan_uil_send_diag_msg(struct uilreq *urq, struct wl_private *lp)",
          "488:  DBG_FUNC(\"wvlan_uil_send_diag_msg\");",
          "489:  DBG_ENTER(DbgInfo);",
          "491:  if(urq->hcfCtx == &(lp->hcfCtx)) {",
          "492:   if(capable(CAP_NET_ADMIN)) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "498:      result = verify_area(VERIFY_READ, urq->data, urq->len);",
          "499:      if (result != 0) {",
          "501:       urq->result = UIL_FAILURE;",
          "503:       return result;",
          "504:      }",
          "506:      data = kmalloc(urq->len, GFP_KERNEL);",
          "507:      if (data != NULL) {",
          "511:       Descp[0].buf_addr       = (wci_bufp)data;",
          "512:       Descp[0].BUF_CNT        = urq->len;",
          "513:       Descp[0].next_desc_addr = 0;    // terminate list",
          "517:      } else {",
          "519:       urq->result = UIL_FAILURE;",
          "520:       result = -ENOMEM;",
          "522:       return result;",
          "523:      }",
          "",
          "[Removed Lines]",
          "500:       DBG_ERROR( DbgInfo, \"verify_area failed, result: %d\\n\", result );",
          "502:       DBG_LEAVE( DbgInfo );",
          "508:       memset( Descp, 0, sizeof( DESC_STRCT ));",
          "509:       memcpy( data, urq->data, urq->len );",
          "515:       hcf_send_msg( &(lp->hcfCtx),  &Descp[0], HCF_PORT_0 );",
          "516:       kfree( data );",
          "518:       DBG_ERROR( DbgInfo, \"ENOMEM\\n\" );",
          "521:       DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "500:       DBG_ERROR(DbgInfo, \"verify_area failed, result: %d\\n\", result);",
          "502:       DBG_LEAVE(DbgInfo);",
          "508:       memset(Descp, 0, sizeof(DESC_STRCT));",
          "509:       memcpy(data, urq->data, urq->len);",
          "515:       hcf_send_msg(&(lp->hcfCtx),  &Descp[0], HCF_PORT_0);",
          "516:       kfree(data);",
          "518:       DBG_ERROR(DbgInfo, \"ENOMEM\\n\");",
          "521:       DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "530:     urq->result = UIL_FAILURE;",
          "531:    }",
          "532:   } else {",
          "534:    urq->result = UIL_FAILURE;",
          "535:    result = -EPERM;",
          "536:   }",
          "537:  } else {",
          "539:   urq->result = UIL_ERR_WRONG_IFB;",
          "540:  }",
          "543:  return result;",
          "544: } // wvlan_uil_send_diag_msg",
          "",
          "[Removed Lines]",
          "533:    DBG_ERROR( DbgInfo, \"EPERM\\n\" );",
          "538:   DBG_ERROR( DbgInfo, \"UIL_ERR_WRONG_IFB\\n\" );",
          "542:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "533:    DBG_ERROR(DbgInfo, \"EPERM\\n\");",
          "538:   DBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");",
          "542:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "568: {",
          "569:  int                     result = 0;",
          "570:  ltv_t                   *pLtv;",
          "",
          "[Removed Lines]",
          "567: int wvlan_uil_put_info( struct uilreq *urq, struct wl_private *lp )",
          "",
          "[Added Lines]",
          "567: int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "575:  hcf_16                  hcfPort  = HCF_PORT_0;",
          "588:      urq->result = UIL_ERR_LEN;",
          "592:      return result;",
          "593:     }",
          "598:      urq->result = UIL_FAILURE;",
          "601:      return result;",
          "602:     }",
          "611:      urq->result = UIL_ERR_LEN;",
          "614:      return result;",
          "615:     }",
          "618:        LTV record, try to allocate it from the kernel stack.",
          "621:      pLtv = kmalloc(urq->len, GFP_KERNEL);",
          "622:      if (pLtv != NULL) {",
          "623:       ltvAllocated = TRUE;",
          "624:      } else {",
          "627:       urq->result = UIL_ERR_LEN;",
          "628:       result = -ENOMEM;",
          "630:       return result;",
          "631:      }",
          "632:     } else {",
          "634:     }",
          "642:        need to store for the purposes of a reset or start/stop",
          "645:     case CFG_CNF_PORT_TYPE:",
          "646:      lp->PortType    = pLtv->u.u16[0];",
          "648:      break;",
          "649:     case CFG_CNF_OWN_MAC_ADDR:",
          "651:      break;",
          "652:     case CFG_CNF_OWN_CHANNEL:",
          "653:      lp->Channel     = pLtv->u.u16[0];",
          "655:      break;",
          "659:     case CFG_CNF_OWN_ATIM_WINDOW:",
          "660:      lp->atimWindow  = pLtv->u.u16[0];",
          "662:      break;",
          "663:     case CFG_CNF_SYSTEM_SCALE:",
          "664:      lp->DistanceBetweenAPs  = pLtv->u.u16[0];",
          "667:     case CFG_CNF_MAX_DATA_LEN:",
          "",
          "[Removed Lines]",
          "578:  DBG_FUNC( \"wvlan_uil_put_info\" );",
          "579:  DBG_ENTER( DbgInfo );",
          "582:  if( urq->hcfCtx == &( lp->hcfCtx )) {",
          "583:   if( capable( CAP_NET_ADMIN )) {",
          "584:    if(( urq->data != NULL ) && ( urq->len != 0 )) {",
          "586:     if( urq->len < ( sizeof( hcf_16 ) * 2 )) {",
          "587:      urq->len = sizeof( lp->ltvRecord );",
          "589:      DBG_ERROR( DbgInfo, \"No Length/Type in LTV!!!\\n\" );",
          "590:      DBG_ERROR( DbgInfo, \"UIL_ERR_LEN\\n\" );",
          "591:      DBG_LEAVE( DbgInfo );",
          "596:     result = verify_area( VERIFY_READ, urq->data, urq->len );",
          "597:     if( result != 0 ) {",
          "599:      DBG_ERROR( DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\" );",
          "600:      DBG_LEAVE( DbgInfo );",
          "605:     copy_from_user( &( lp->ltvRecord ), urq->data, sizeof( hcf_16 ) * 2 );",
          "609:     if((( lp->ltvRecord.len + 1 ) * sizeof( hcf_16 )) > urq->len ) {",
          "610:      urq->len = sizeof( lp->ltvRecord );",
          "612:      DBG_ERROR( DbgInfo, \"UIL_ERR_LEN\\n\" );",
          "613:      DBG_LEAVE( DbgInfo );",
          "620:     if( urq->len > sizeof( lp->ltvRecord )) {",
          "625:       DBG_ERROR( DbgInfo, \"Alloc FAILED\\n\" );",
          "626:       urq->len = sizeof( lp->ltvRecord );",
          "629:       DBG_LEAVE( DbgInfo );",
          "633:      pLtv = &( lp->ltvRecord );",
          "638:     copy_from_user( pLtv, urq->data, urq->len );",
          "644:     switch( pLtv->typ ) {",
          "647:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "654:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "661:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "665:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "",
          "[Added Lines]",
          "578:  DBG_FUNC(\"wvlan_uil_put_info\");",
          "579:  DBG_ENTER(DbgInfo);",
          "582:  if(urq->hcfCtx == &(lp->hcfCtx)) {",
          "583:   if(capable(CAP_NET_ADMIN)) {",
          "584:    if((urq->data != NULL) && (urq->len != 0)) {",
          "586:     if(urq->len < (sizeof(hcf_16) * 2)) {",
          "587:      urq->len = sizeof(lp->ltvRecord);",
          "589:      DBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");",
          "590:      DBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");",
          "591:      DBG_LEAVE(DbgInfo);",
          "596:     result = verify_area(VERIFY_READ, urq->data, urq->len);",
          "597:     if(result != 0) {",
          "599:      DBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");",
          "600:      DBG_LEAVE(DbgInfo);",
          "605:     copy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);",
          "609:     if(((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {",
          "610:      urq->len = sizeof(lp->ltvRecord);",
          "612:      DBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");",
          "613:      DBG_LEAVE(DbgInfo);",
          "620:     if(urq->len > sizeof(lp->ltvRecord)) {",
          "625:       DBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");",
          "626:       urq->len = sizeof(lp->ltvRecord);",
          "629:       DBG_LEAVE(DbgInfo);",
          "633:      pLtv = &(lp->ltvRecord);",
          "638:     copy_from_user(pLtv, urq->data, urq->len);",
          "644:     switch(pLtv->typ) {",
          "647:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "654:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "661:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "665:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "670:      break;",
          "671:     case CFG_CNF_PM_ENABLED:",
          "672:      lp->PMEnabled   = pLtv->u.u16[0];",
          "674:      break;",
          "675:     case CFG_CNF_MCAST_RX:",
          "676:      lp->MulticastReceive    = pLtv->u.u16[0];",
          "678:      break;",
          "679:     case CFG_CNF_MAX_SLEEP_DURATION:",
          "680:      lp->MaxSleepDuration    = pLtv->u.u16[0];",
          "682:      break;",
          "683:     case CFG_CNF_HOLDOVER_DURATION:",
          "684:      lp->holdoverDuration    = pLtv->u.u16[0];",
          "686:      break;",
          "687:     case CFG_CNF_OWN_NAME:",
          "691:      break;",
          "692:     case CFG_CNF_LOAD_BALANCING:",
          "693:      lp->loadBalancing       = pLtv->u.u16[0];",
          "695:      break;",
          "696:     case CFG_CNF_MEDIUM_DISTRIBUTION:",
          "697:      lp->mediumDistribution  = pLtv->u.u16[0];",
          "699:      break;",
          "700: #ifdef WARP",
          "701:     case CFG_CNF_TX_POW_LVL:",
          "702:      lp->txPowLevel          = pLtv->u.u16[0];",
          "704:      break;",
          "707:     case CFG_SUPPORTED_RATE_SET_CNTL:        // Supported Rate Set Control",
          "708:      lp->srsc[0]             = pLtv->u.u16[0];",
          "709:      lp->srsc[1]             = pLtv->u.u16[1];",
          "712:      break;",
          "713:     case CFG_BASIC_RATE_SET_CNTL:        // Basic Rate Set Control",
          "714:      lp->brsc[0]             = pLtv->u.u16[0];",
          "715:      lp->brsc[1]             = pLtv->u.u16[1];",
          "718:      break;",
          "719:     case CFG_CNF_CONNECTION_CNTL:",
          "720:      lp->connectionControl   = pLtv->u.u16[0];",
          "722:      break;",
          "724: #endif  // HERMES25",
          "",
          "[Removed Lines]",
          "673:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "677:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "681:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "685:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "688:      memset( lp->StationName, 0, sizeof( lp->StationName ));",
          "689:      memcpy( (void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);",
          "690:      pLtv->u.u16[0] = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "694:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "698:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "703:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "710:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "711:      pLtv->u.u16[1]          = CNV_INT_TO_LITTLE( pLtv->u.u16[1] );",
          "716:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "717:      pLtv->u.u16[1]          = CNV_INT_TO_LITTLE( pLtv->u.u16[1] );",
          "721:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "",
          "[Added Lines]",
          "673:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "677:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "681:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "685:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "688:      memset(lp->StationName, 0, sizeof(lp->StationName));",
          "689:      memcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);",
          "690:      pLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "694:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "698:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "703:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "710:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "711:      pLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);",
          "716:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "717:      pLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);",
          "721:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "729:     case CFG_CNF_OWN_DTIM_PERIOD:",
          "730:      lp->DTIMPeriod  = pLtv->u.u16[0];",
          "732:      break;",
          "733: #ifdef WARP",
          "734:     case CFG_CNF_OWN_BEACON_INTERVAL:        // Own Beacon Interval",
          "735:      lp->ownBeaconInterval   = pLtv->u.u16[0];",
          "737:      break;",
          "738: #endif // WARP",
          "739:     case CFG_COEXISTENSE_BEHAVIOUR:         // Coexistence behavior",
          "740:      lp->coexistence         = pLtv->u.u16[0];",
          "742:      break;",
          "743: #ifdef USE_WDS",
          "744:     case CFG_CNF_WDS_ADDR1:",
          "746:      hcfPort = HCF_PORT_1;",
          "747:      break;",
          "748:     case CFG_CNF_WDS_ADDR2:",
          "750:      hcfPort = HCF_PORT_2;",
          "751:      break;",
          "752:     case CFG_CNF_WDS_ADDR3:",
          "754:      hcfPort = HCF_PORT_3;",
          "755:      break;",
          "756:     case CFG_CNF_WDS_ADDR4:",
          "758:      hcfPort = HCF_PORT_4;",
          "759:      break;",
          "760:     case CFG_CNF_WDS_ADDR5:",
          "762:      hcfPort = HCF_PORT_5;",
          "763:      break;",
          "764:     case CFG_CNF_WDS_ADDR6:",
          "766:      hcfPort = HCF_PORT_6;",
          "767:      break;",
          "770:     case CFG_CNF_MCAST_PM_BUF:",
          "771:      lp->multicastPMBuffering    = pLtv->u.u16[0];",
          "773:      break;",
          "774:     case CFG_CNF_REJECT_ANY:",
          "775:      lp->RejectAny   = pLtv->u.u16[0];",
          "777:      break;",
          "778: #endif",
          "780:     case CFG_CNF_ENCRYPTION:",
          "781:      lp->EnableEncryption    = pLtv->u.u16[0];",
          "783:      break;",
          "784:     case CFG_CNF_AUTHENTICATION:",
          "785:      lp->authentication  = pLtv->u.u16[0];",
          "787:      break;",
          "788: #if 1 //;? (HCF_TYPE) & HCF_TYPE_AP",
          "795:     case CFG_CNF_MCAST_RATE:",
          "797:      break;",
          "798:     case CFG_CNF_INTRA_BSS_RELAY:",
          "799:      lp->intraBSSRelay   = pLtv->u.u16[0];",
          "801:      break;",
          "802: #endif",
          "",
          "[Removed Lines]",
          "731:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "736:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "741:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "745:      memcpy( &lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN );",
          "749:      memcpy( &lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN );",
          "753:      memcpy( &lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN );",
          "757:      memcpy( &lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN );",
          "761:      memcpy( &lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN );",
          "765:      memcpy( &lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN );",
          "772:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "776:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "782:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "786:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "800:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "",
          "[Added Lines]",
          "731:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "736:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "741:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "745:      memcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);",
          "749:      memcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);",
          "753:      memcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);",
          "757:      memcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);",
          "761:      memcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);",
          "765:      memcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);",
          "772:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "776:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "782:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "786:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "800:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "819:     case CFG_CNF_OWN_SSID:",
          "821:     case CFG_DESIRED_SSID:",
          "832:       pLtv->u.u16[0] = 0;",
          "",
          "[Removed Lines]",
          "822:      memset( lp->NetworkName, 0, sizeof( lp->NetworkName ));",
          "823:      memcpy( (void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0] );",
          "824:      pLtv->u.u16[0] = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "827:      if(( strlen( &pLtv->u.u8[2]        ) == 0 ) ||",
          "828:         ( strcmp( &pLtv->u.u8[2], \"ANY\" ) == 0 ) ||",
          "829:         ( strcmp( &pLtv->u.u8[2], \"any\" ) == 0 )) {",
          "",
          "[Added Lines]",
          "822:      memset(lp->NetworkName, 0, sizeof(lp->NetworkName));",
          "823:      memcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);",
          "824:      pLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "827:      if((strlen(&pLtv->u.u8[2]       ) == 0) ||",
          "828:         (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||",
          "829:         (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "838:      break;",
          "839:     case CFG_CREATE_IBSS:",
          "840:      lp->CreateIBSS  = pLtv->u.u16[0];",
          "842:      break;",
          "843:     case CFG_RTS_THRH:",
          "844:      lp->RTSThreshold    = pLtv->u.u16[0];",
          "846:      break;",
          "847:     case CFG_TX_RATE_CNTL:",
          "848:      lp->TxRateControl[0]    = pLtv->u.u16[0];",
          "849:      lp->TxRateControl[1]    = pLtv->u.u16[1];",
          "852:      break;",
          "853:     case CFG_PROMISCUOUS_MODE:",
          "",
          "[Removed Lines]",
          "841:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "845:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "850:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "851:      pLtv->u.u16[1]          = CNV_INT_TO_LITTLE( pLtv->u.u16[1] );",
          "",
          "[Added Lines]",
          "841:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "845:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "850:      pLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "851:      pLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "861:     case CFG_RTS_THRH0:",
          "862:      lp->RTSThreshold    = pLtv->u.u16[0];",
          "864:      break;",
          "865:     case CFG_TX_RATE_CNTL0:",
          "868:      break;",
          "869: #ifdef USE_WDS",
          "870:     case CFG_RTS_THRH1:",
          "871:      lp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];",
          "873:      hcfPort                         = HCF_PORT_1;",
          "874:      break;",
          "875:     case CFG_RTS_THRH2:",
          "876:      lp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];",
          "878:      hcfPort                         = HCF_PORT_2;",
          "879:      break;",
          "880:     case CFG_RTS_THRH3:",
          "881:      lp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];",
          "883:      hcfPort                         = HCF_PORT_3;",
          "884:      break;",
          "885:     case CFG_RTS_THRH4:",
          "886:      lp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];",
          "888:      hcfPort                         = HCF_PORT_4;",
          "889:      break;",
          "890:     case CFG_RTS_THRH5:",
          "891:      lp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];",
          "893:      hcfPort                         = HCF_PORT_5;",
          "894:      break;",
          "895:     case CFG_RTS_THRH6:",
          "896:      lp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];",
          "898:      hcfPort                         = HCF_PORT_6;",
          "899:      break;",
          "900:     case CFG_TX_RATE_CNTL1:",
          "901:      lp->wds_port[0].txRateCntl  = pLtv->u.u16[0];",
          "903:      hcfPort                     = HCF_PORT_1;",
          "904:      break;",
          "905:     case CFG_TX_RATE_CNTL2:",
          "906:      lp->wds_port[1].txRateCntl  = pLtv->u.u16[0];",
          "908:      hcfPort                     = HCF_PORT_2;",
          "909:      break;",
          "910:     case CFG_TX_RATE_CNTL3:",
          "911:      lp->wds_port[2].txRateCntl  = pLtv->u.u16[0];",
          "913:      hcfPort                     = HCF_PORT_3;",
          "914:      break;",
          "915:     case CFG_TX_RATE_CNTL4:",
          "916:      lp->wds_port[3].txRateCntl  = pLtv->u.u16[0];",
          "918:      hcfPort                     = HCF_PORT_4;",
          "919:      break;",
          "920:     case CFG_TX_RATE_CNTL5:",
          "921:      lp->wds_port[4].txRateCntl  = pLtv->u.u16[0];",
          "923:      hcfPort                     = HCF_PORT_5;",
          "924:      break;",
          "925:     case CFG_TX_RATE_CNTL6:",
          "926:      lp->wds_port[5].txRateCntl  = pLtv->u.u16[0];",
          "928:      hcfPort                     = HCF_PORT_6;",
          "929:      break;",
          "",
          "[Removed Lines]",
          "863:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "867:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "872:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "877:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "882:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "887:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "892:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "897:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "902:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "907:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "912:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "917:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "922:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "927:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "",
          "[Added Lines]",
          "863:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "867:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "872:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "877:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "882:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "887:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "892:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "897:      pLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "902:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "907:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "912:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "917:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "922:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "927:      pLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "934:      {",
          "935:       CFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;",
          "944:      }",
          "945:      break;",
          "946:     case CFG_TX_KEY_ID:",
          "947:      lp->TransmitKeyID   = pLtv->u.u16[0];",
          "949:      break;",
          "950:     case CFG_SCAN_SSID:",
          "",
          "[Removed Lines]",
          "937:       pKeys->key[0].len = CNV_INT_TO_LITTLE( pKeys->key[0].len );",
          "938:       pKeys->key[1].len = CNV_INT_TO_LITTLE( pKeys->key[1].len );",
          "939:       pKeys->key[2].len = CNV_INT_TO_LITTLE( pKeys->key[2].len );",
          "940:       pKeys->key[3].len = CNV_INT_TO_LITTLE( pKeys->key[3].len );",
          "942:       memcpy( (void *)&(lp->DefaultKeys), (void *)pKeys,",
          "943:         sizeof( CFG_DEFAULT_KEYS_STRCT ));",
          "948:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "",
          "[Added Lines]",
          "937:       pKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);",
          "938:       pKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);",
          "939:       pKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);",
          "940:       pKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);",
          "942:       memcpy((void *)&(lp->DefaultKeys), (void *)pKeys,",
          "943:         sizeof(CFG_DEFAULT_KEYS_STRCT));",
          "948:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1001:     case CFG_SUPPORTED_DATA_RATES:",
          "1002:      break;",
          "1003:     case CFG_AP_MODE:",
          "1006:      break;",
          "1007:     case CFG_ENCRYPT_STRING:",
          "1016:      convert to 0-3 when sending to the card.  The Windows code",
          "",
          "[Removed Lines]",
          "1005:      DBG_ERROR( DbgInfo, \"set CFG_AP_MODE no longer supported\\n\" );",
          "1009:      memset( lp->szEncryption, 0, sizeof( lp->szEncryption ));",
          "1010:      memcpy( (void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],",
          "1011:        ( pLtv->len * sizeof( hcf_16 )) );",
          "1012:      wl_wep_decode( CRYPT_CODE, &sEncryption,",
          "1013:             lp->szEncryption );",
          "",
          "[Added Lines]",
          "1005:      DBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");",
          "1009:      memset(lp->szEncryption, 0, sizeof(lp->szEncryption));",
          "1010:      memcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],",
          "1011:        (pLtv->len * sizeof(hcf_16)));",
          "1012:      wl_wep_decode(CRYPT_CODE, &sEncryption,",
          "1013:             lp->szEncryption);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1022:      lp->TransmitKeyID    = sEncryption.wTxKeyID + 1;",
          "1023:      lp->EnableEncryption = sEncryption.wEnabled;",
          "1027:      break;",
          "1031:      break;",
          "1034:     case CFG_DRIVER_ENABLE:",
          "1035:      lp->driverEnable    = pLtv->u.u16[0];",
          "1037:      break;",
          "1038:     case CFG_WOLAS_ENABLE:",
          "1039:      lp->wolasEnable = pLtv->u.u16[0];",
          "1041:      break;",
          "1042:     case CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:",
          "1043:      lp->AuthKeyMgmtSuite = pLtv->u.u16[0];",
          "1045:      break;",
          "1046:     case CFG_DISASSOCIATE_ADDR:",
          "1048:      break;",
          "1049:     case CFG_ADD_TKIP_DEFAULT_KEY:",
          "1050:     case CFG_REMOVE_TKIP_DEFAULT_KEY:",
          "1053:      break;",
          "1054:     case CFG_ADD_TKIP_MAPPED_KEY:",
          "1055:      break;",
          "",
          "[Removed Lines]",
          "1025:      memcpy( &lp->DefaultKeys, &sEncryption.EncStr,",
          "1026:        sizeof( CFG_DEFAULT_KEYS_STRCT ));",
          "1029:      memset( lp->countryString, 0, sizeof( lp->countryString ));",
          "1030:      memcpy( (void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);",
          "1036:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "1040:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "1044:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "1047:      pLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE( pLtv->u.u16[ETH_ALEN / 2] );",
          "1052:      pLtv->u.u16[0] = CNV_INT_TO_LITTLE( pLtv->u.u16[0] );",
          "",
          "[Added Lines]",
          "1025:      memcpy(&lp->DefaultKeys, &sEncryption.EncStr,",
          "1026:        sizeof(CFG_DEFAULT_KEYS_STRCT));",
          "1029:      memset(lp->countryString, 0, sizeof(lp->countryString));",
          "1030:      memcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);",
          "1036:      pLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "1040:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "1044:      pLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "1047:      pLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);",
          "1052:      pLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1066:        being sent to the card, as they require a call to",
          "1067:        UIL_ACT_APPLY to take effect. Dynamic Entities will be sent",
          "1070:     case CFG_CNF_PORT_TYPE:",
          "1071:     case CFG_CNF_OWN_MAC_ADDR:",
          "1072:     case CFG_CNF_OWN_CHANNEL:",
          "",
          "[Removed Lines]",
          "1069:     switch( pLtv->typ ) {",
          "",
          "[Added Lines]",
          "1069:     switch(pLtv->typ) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1129:      break;",
          "1131:     case CFG_DRIVER_ENABLE:",
          "1142:      } else {",
          "1152:      }",
          "1153:      break;",
          "1154:     default:",
          "1156:      urq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);",
          "1158:      break;",
          "1159:     }",
          "1163:     }",
          "1164:    } else {",
          "1165:     urq->result = UIL_FAILURE;",
          "1166:    }",
          "1167:   } else {",
          "1169:    urq->result = UIL_FAILURE;",
          "1170:    result = -EPERM;",
          "1171:   }",
          "1172:  } else {",
          "1174:   urq->result = UIL_ERR_WRONG_IFB;",
          "1175:  }",
          "1178:  return result;",
          "1179: } // wvlan_uil_put_info",
          "",
          "[Removed Lines]",
          "1132:      if( lp->driverEnable ) {",
          "1140:       hcf_cntl( &( lp->hcfCtx ), HCF_CNTL_ENABLE | HCF_PORT_0 );",
          "1141:       hcf_cntl( &( lp->hcfCtx ), HCF_CNTL_CONNECT );",
          "1150:       hcf_cntl( &( lp->hcfCtx ), HCF_CNTL_DISABLE | HCF_PORT_0 );",
          "1151:       hcf_cntl( &( lp->hcfCtx ), HCF_CNTL_DISCONNECT );",
          "1155:          wl_act_int_off( lp );",
          "1157:          wl_act_int_on( lp );",
          "1161:     if( ltvAllocated ) {",
          "1162:      kfree( pLtv );",
          "1168:    DBG_ERROR( DbgInfo, \"EPERM\\n\" );",
          "1173:   DBG_ERROR( DbgInfo, \"UIL_ERR_WRONG_IFB\\n\" );",
          "1177:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1132:      if(lp->driverEnable) {",
          "1140:       hcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);",
          "1141:       hcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);",
          "1150:       hcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);",
          "1151:       hcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);",
          "1155:          wl_act_int_off(lp);",
          "1157:          wl_act_int_on(lp);",
          "1161:     if(ltvAllocated) {",
          "1162:      kfree(pLtv);",
          "1168:    DBG_ERROR(DbgInfo, \"EPERM\\n\");",
          "1173:   DBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");",
          "1177:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1203: {",
          "1204:  int result = 0;",
          "1205:  int i;",
          "1213:    ltv_t      *pLtv;",
          "1214:    bool_t      ltvAllocated = FALSE;",
          "1221:     urq->result = UIL_ERR_LEN;",
          "1223:     return result;",
          "1224:    }",
          "1230:     urq->result = UIL_FAILURE;",
          "1232:     return result;",
          "1233:    }",
          "1243:     urq->result = UIL_ERR_LEN;",
          "1245:     return result;",
          "1246:    }",
          "1250:    case CFG_NIC_IDENTITY:",
          "1252:     break;",
          "1253:    case CFG_PRI_IDENTITY:",
          "1255:     break;",
          "1256:    case CFG_AP_MODE:",
          "1258:     lp->ltvRecord.u.u16[0] =",
          "1260:     break;",
          "1262:    case CFG_ENCRYPT_STRING:",
          "",
          "[Removed Lines]",
          "1202: int wvlan_uil_get_info( struct uilreq *urq, struct wl_private *lp )",
          "1208:  DBG_FUNC( \"wvlan_uil_get_info\" );",
          "1209:  DBG_ENTER( DbgInfo );",
          "1211:  if( urq->hcfCtx == &( lp->hcfCtx )) {",
          "1212:   if(( urq->data != NULL ) && ( urq->len != 0 )) {",
          "1217:    if( urq->len < ( sizeof( hcf_16 ) * 2 )) {",
          "1218:     urq->len = sizeof( lp->ltvRecord );",
          "1219:     DBG_ERROR( DbgInfo, \"No Length/Type in LTV!!!\\n\" );",
          "1220:     DBG_ERROR( DbgInfo, \"UIL_ERR_LEN\\n\" );",
          "1222:     DBG_LEAVE( DbgInfo );",
          "1227:    result = verify_area( VERIFY_READ, urq->data, sizeof( hcf_16 ) * 2 );",
          "1228:    if( result != 0 ) {",
          "1229:     DBG_ERROR( DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\" );",
          "1231:     DBG_LEAVE( DbgInfo );",
          "1236:    result = copy_from_user( &( lp->ltvRecord ), urq->data, sizeof( hcf_16 ) * 2 );",
          "1240:    if((( lp->ltvRecord.len + 1 ) * sizeof( hcf_16 )) > urq->len ) {",
          "1241:     DBG_ERROR( DbgInfo, \"Incoming LTV too big\\n\" );",
          "1242:     urq->len = sizeof( lp->ltvRecord );",
          "1244:     DBG_LEAVE( DbgInfo );",
          "1249:    switch ( lp->ltvRecord.typ ) {",
          "1251:     memcpy( &lp->ltvRecord.u.u8[0], &lp->NICIdentity, sizeof( lp->NICIdentity ));",
          "1254:     memcpy( &lp->ltvRecord.u.u8[0], &lp->PrimaryIdentity, sizeof( lp->PrimaryIdentity ));",
          "1257:     DBG_ERROR( DbgInfo, \"set CFG_AP_MODE no longer supported, so is get useful ????\\n\" );",
          "1259:      CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP;",
          "",
          "[Added Lines]",
          "1202: int wvlan_uil_get_info(struct uilreq *urq, struct wl_private *lp)",
          "1208:  DBG_FUNC(\"wvlan_uil_get_info\");",
          "1209:  DBG_ENTER(DbgInfo);",
          "1211:  if(urq->hcfCtx == &(lp->hcfCtx)) {",
          "1212:   if((urq->data != NULL) && (urq->len != 0)) {",
          "1217:    if(urq->len < (sizeof(hcf_16) * 2)) {",
          "1218:     urq->len = sizeof(lp->ltvRecord);",
          "1219:     DBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");",
          "1220:     DBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");",
          "1222:     DBG_LEAVE(DbgInfo);",
          "1227:    result = verify_area(VERIFY_READ, urq->data, sizeof(hcf_16) * 2);",
          "1228:    if(result != 0) {",
          "1229:     DBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");",
          "1231:     DBG_LEAVE(DbgInfo);",
          "1236:    result = copy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);",
          "1240:    if(((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {",
          "1241:     DBG_ERROR(DbgInfo, \"Incoming LTV too big\\n\");",
          "1242:     urq->len = sizeof(lp->ltvRecord);",
          "1244:     DBG_LEAVE(DbgInfo);",
          "1249:    switch (lp->ltvRecord.typ) {",
          "1251:     memcpy(&lp->ltvRecord.u.u8[0], &lp->NICIdentity, sizeof(lp->NICIdentity));",
          "1254:     memcpy(&lp->ltvRecord.u.u8[0], &lp->PrimaryIdentity, sizeof(lp->PrimaryIdentity));",
          "1257:     DBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported, so is get useful ????\\n\");",
          "1259:      CNV_INT_TO_LITTLE(lp->hcfCtx.IFB_FWIdentity.comp_id) == COMP_ID_FW_AP;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1267:     urq->result = UIL_FAILURE;",
          "1268:     break;",
          "1269:    case CFG_DRV_INFO:",
          "1272:     break;",
          "1273:    case CFG_DRV_IDENTITY:",
          "1276:     break;",
          "1277:    case CFG_IFB:",
          "1280:      result = -EPERM;",
          "1281:      break;",
          "1282:     }",
          "",
          "[Removed Lines]",
          "1270:     DBG_TRACE( DbgInfo, \"Intercept CFG_DRV_INFO\\n\" );",
          "1271:     result = cfg_driver_info( urq, lp );",
          "1274:     DBG_TRACE( DbgInfo, \"Intercept CFG_DRV_IDENTITY\\n\" );",
          "1275:     result = cfg_driver_identity( urq, lp );",
          "1279:     if( !capable( CAP_NET_ADMIN )) {",
          "",
          "[Added Lines]",
          "1270:     DBG_TRACE(DbgInfo, \"Intercept CFG_DRV_INFO\\n\");",
          "1271:     result = cfg_driver_info(urq, lp);",
          "1274:     DBG_TRACE(DbgInfo, \"Intercept CFG_DRV_IDENTITY\\n\");",
          "1275:     result = cfg_driver_identity(urq, lp);",
          "1279:     if(!capable(CAP_NET_ADMIN)) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1287:    default:",
          "1293:      urq->result = UIL_FAILURE;",
          "1294:      break;",
          "1295:     }",
          "",
          "[Removed Lines]",
          "1290:     result = verify_area( VERIFY_WRITE, urq->data, urq->len );",
          "1291:     if( result != 0 ) {",
          "1292:      DBG_ERROR( DbgInfo, \"verify_area(), VERIFY_WRITE FAILED\\n\" );",
          "",
          "[Added Lines]",
          "1290:     result = verify_area(VERIFY_WRITE, urq->data, urq->len);",
          "1291:     if(result != 0) {",
          "1292:      DBG_ERROR(DbgInfo, \"verify_area(), VERIFY_WRITE FAILED\\n\");",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1298:        LTV record, try to allocate it from the kernel stack.",
          "1301:      pLtv = kmalloc(urq->len, GFP_KERNEL);",
          "1302:      if (pLtv != NULL) {",
          "1303:       ltvAllocated = TRUE;",
          "1307:      } else {",
          "1309:       urq->result = UIL_ERR_LEN;",
          "1312:       result = -ENOMEM;",
          "1313:       break;",
          "1314:      }",
          "1315:     } else {",
          "1317:     }",
          "",
          "[Removed Lines]",
          "1300:     if( urq->len > sizeof( lp->ltvRecord )) {",
          "1306:       memcpy( pLtv, &( lp->ltvRecord ), sizeof( hcf_16 ) * 2 );",
          "1308:       urq->len = sizeof( lp->ltvRecord );",
          "1310:       DBG_ERROR( DbgInfo, \"kmalloc FAILED\\n\" );",
          "1311:       DBG_ERROR( DbgInfo, \"UIL_ERR_LEN\\n\" );",
          "1316:      pLtv = &( lp->ltvRecord );",
          "1319:         wl_act_int_off( lp );",
          "1320:     urq->result = hcf_get_info( &( lp->hcfCtx ), (LTVP) pLtv );",
          "1321:         wl_act_int_on( lp );",
          "",
          "[Added Lines]",
          "1300:     if(urq->len > sizeof(lp->ltvRecord)) {",
          "1306:       memcpy(pLtv, &(lp->ltvRecord), sizeof(hcf_16) * 2);",
          "1308:       urq->len = sizeof(lp->ltvRecord);",
          "1310:       DBG_ERROR(DbgInfo, \"kmalloc FAILED\\n\");",
          "1311:       DBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");",
          "1316:      pLtv = &(lp->ltvRecord);",
          "1319:         wl_act_int_off(lp);",
          "1320:     urq->result = hcf_get_info(&(lp->hcfCtx), (LTVP) pLtv);",
          "1321:         wl_act_int_on(lp);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1333:    }",
          "1338:    case CFG_CNF_PORT_TYPE:",
          "1339:    case CFG_CNF_OWN_CHANNEL:",
          "",
          "[Removed Lines]",
          "1336:    switch( lp->ltvRecord.typ ) {",
          "",
          "[Added Lines]",
          "1336:    switch(lp->ltvRecord.typ) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1415:    case CFG_DESIRED_SSID:",
          "1416:    case CFG_SCAN_SSID:",
          "1417:    case CFG_CUR_SSID:",
          "1419:     break;",
          "1421:    case CFG_CNF_OWN_MAC_ADDR:",
          "",
          "[Removed Lines]",
          "1418:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[0] );",
          "",
          "[Added Lines]",
          "1418:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1443:     }",
          "1444:     break;",
          "",
          "[Removed Lines]",
          "1438:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[0] );",
          "1439:     lp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[3] );",
          "1441:     for( i = 4; i < lp->ltvRecord.len; i++ ) {",
          "1442:      lp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[i] );",
          "",
          "[Added Lines]",
          "1438:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);",
          "1439:     lp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);",
          "1441:     for(i = 4; i < lp->ltvRecord.len; i++) {",
          "1442:      lp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[i]);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1448:     {",
          "1449:      CFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)&lp->ltvRecord.u.u8[0];",
          "1455:     }",
          "1456:     break;",
          "1457:    case CFG_CNF_MCAST_RATE:",
          "1458:    case CFG_TX_RATE_CNTL:",
          "1459:    case CFG_SUPPORTED_RATE_SET_CNTL:    // Supported Rate Set Control",
          "1460:    case CFG_BASIC_RATE_SET_CNTL:    // Basic Rate Set Control",
          "1463:     break;",
          "1464:    case CFG_DL_BUF:",
          "1465:    case CFG_NIC_IDENTITY:",
          "1466:    case CFG_COMMS_QUALITY:",
          "1467:    case CFG_PCF_INFO:",
          "1471:     break;",
          "1472:    case CFG_FW_IDENTITY:",
          "1477:     break;",
          "1479:    case CFG_NIC_MFI_SUP_RANGE:",
          "1480:    case CFG_NIC_CFI_SUP_RANGE:",
          "1481:    case CFG_NIC_PROFILE:",
          "1482:    case CFG_FW_SUP_RANGE:",
          "1488:     break;",
          "1489:    case CFG_MFI_ACT_RANGES_STA:",
          "1490:    case CFG_CFI_ACT_RANGES_STA:",
          "1491:    case CFG_CUR_SCALE_THRH:",
          "1492:    case CFG_AUTHENTICATION_ALGORITHMS:",
          "1495:     }",
          "1496:     break;",
          "1498:    case CFG_PRI_IDENTITY:",
          "1499:     break;",
          "1500:    case CFG_MB_INFO:",
          "1502:     break;",
          "1504:    case CFG_IFB:",
          "",
          "[Removed Lines]",
          "1451:      pKeys[0].len = CNV_INT_TO_LITTLE( pKeys[0].len );",
          "1452:      pKeys[1].len = CNV_INT_TO_LITTLE( pKeys[1].len );",
          "1453:      pKeys[2].len = CNV_INT_TO_LITTLE( pKeys[2].len );",
          "1454:      pKeys[3].len = CNV_INT_TO_LITTLE( pKeys[3].len );",
          "1461:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[0] );",
          "1462:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[1] );",
          "1468:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[0] );",
          "1469:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[1] );",
          "1470:     lp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[2] );",
          "1473:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[0] );",
          "1474:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[1] );",
          "1475:     lp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[2] );",
          "1476:     lp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[3] );",
          "1483:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[0] );",
          "1484:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[1] );",
          "1485:     lp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[2] );",
          "1486:     lp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[3] );",
          "1487:     lp->ltvRecord.u.u16[4] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[4] );",
          "1493:     for( i = 0; i < ( lp->ltvRecord.len - 1 ); i++ ) {",
          "1494:      lp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE( lp->ltvRecord.u.u16[i] );",
          "",
          "[Added Lines]",
          "1451:      pKeys[0].len = CNV_INT_TO_LITTLE(pKeys[0].len);",
          "1452:      pKeys[1].len = CNV_INT_TO_LITTLE(pKeys[1].len);",
          "1453:      pKeys[2].len = CNV_INT_TO_LITTLE(pKeys[2].len);",
          "1454:      pKeys[3].len = CNV_INT_TO_LITTLE(pKeys[3].len);",
          "1461:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);",
          "1462:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);",
          "1468:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);",
          "1469:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);",
          "1470:     lp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);",
          "1473:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);",
          "1474:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);",
          "1475:     lp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);",
          "1476:     lp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);",
          "1483:     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);",
          "1484:     lp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);",
          "1485:     lp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);",
          "1486:     lp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);",
          "1487:     lp->ltvRecord.u.u16[4] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[4]);",
          "1493:     for(i = 0; i < (lp->ltvRecord.len - 1); i++) {",
          "1494:      lp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[i]);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1513:    }",
          "1520:    }",
          "1522:    urq->result = UIL_SUCCESS;",
          "",
          "[Removed Lines]",
          "1516:    copy_to_user( urq->data, &( lp->ltvRecord ), urq->len );",
          "1518:    if( ltvAllocated ) {",
          "1519:     kfree( &( lp->ltvRecord ));",
          "",
          "[Added Lines]",
          "1516:    copy_to_user(urq->data, &(lp->ltvRecord), urq->len);",
          "1518:    if(ltvAllocated) {",
          "1519:     kfree(&(lp->ltvRecord));",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1524:    urq->result = UIL_FAILURE;",
          "1525:   }",
          "1526:  } else {",
          "1528:   urq->result = UIL_ERR_WRONG_IFB;",
          "1529:  }",
          "1532:  return result;",
          "1533: } // wvlan_uil_get_info",
          "",
          "[Removed Lines]",
          "1527:   DBG_ERROR( DbgInfo, \"UIL_ERR_WRONG_IFB\\n\" );",
          "1531:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1527:   DBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");",
          "1531:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1560: {",
          "1561:  int result = 0;",
          "1572:   urq->result = UIL_ERR_LEN;",
          "1574:   return result;",
          "1575:  }",
          "1580:   urq->result = UIL_FAILURE;",
          "1582:   return result;",
          "1583:  }",
          "",
          "[Removed Lines]",
          "1559: int cfg_driver_info( struct uilreq *urq, struct wl_private *lp )",
          "1565:  DBG_FUNC( \"cfg_driver_info\" );",
          "1566:  DBG_ENTER( DbgInfo );",
          "1570:  if( urq->len < sizeof( lp->driverInfo )) {",
          "1571:   urq->len = sizeof( lp->driverInfo );",
          "1573:   DBG_LEAVE( DbgInfo );",
          "1578:  result = verify_area( VERIFY_WRITE, urq->data, sizeof( lp->driverInfo ));",
          "1579:  if( result != 0 ) {",
          "1581:   DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1559: int cfg_driver_info(struct uilreq *urq, struct wl_private *lp)",
          "1565:  DBG_FUNC(\"cfg_driver_info\");",
          "1566:  DBG_ENTER(DbgInfo);",
          "1570:  if(urq->len < sizeof(lp->driverInfo)) {",
          "1571:   urq->len = sizeof(lp->driverInfo);",
          "1573:   DBG_LEAVE(DbgInfo);",
          "1578:  result = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverInfo));",
          "1579:  if(result != 0) {",
          "1581:   DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1588:  urq->result = UIL_SUCCESS;",
          "1592:  return result;",
          "1593: } // cfg_driver_info",
          "",
          "[Removed Lines]",
          "1589:  copy_to_user( urq->data, &( lp->driverInfo ), sizeof( lp->driverInfo ));",
          "1591:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1589:  copy_to_user(urq->data, &(lp->driverInfo), sizeof(lp->driverInfo));",
          "1591:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1619: {",
          "1620:  int result = 0;",
          "1631:   urq->result = UIL_ERR_LEN;",
          "1633:   return result;",
          "1634:  }",
          "1639:   urq->result = UIL_FAILURE;",
          "1641:   return result;",
          "1642:  }",
          "1645:  urq->result = UIL_SUCCESS;",
          "1649:  return result;",
          "1650: } // cfg_driver_identity",
          "",
          "[Removed Lines]",
          "1618: int cfg_driver_identity( struct uilreq *urq, struct wl_private *lp )",
          "1624:  DBG_FUNC( \"wvlan_driver_identity\" );",
          "1625:  DBG_ENTER( DbgInfo );",
          "1629:  if( urq->len < sizeof( lp->driverIdentity )) {",
          "1630:   urq->len = sizeof( lp->driverIdentity );",
          "1632:   DBG_LEAVE( DbgInfo );",
          "1637:  result = verify_area( VERIFY_WRITE, urq->data, sizeof( lp->driverIdentity ));",
          "1638:  if( result != 0 ) {",
          "1640:   DBG_LEAVE( DbgInfo );",
          "1646:  copy_to_user( urq->data, &( lp->driverIdentity ), sizeof( lp->driverIdentity ));",
          "1648:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1618: int cfg_driver_identity(struct uilreq *urq, struct wl_private *lp)",
          "1624:  DBG_FUNC(\"wvlan_driver_identity\");",
          "1625:  DBG_ENTER(DbgInfo);",
          "1629:  if(urq->len < sizeof(lp->driverIdentity)) {",
          "1630:   urq->len = sizeof(lp->driverIdentity);",
          "1632:   DBG_LEAVE(DbgInfo);",
          "1637:  result = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverIdentity));",
          "1638:  if(result != 0) {",
          "1640:   DBG_LEAVE(DbgInfo);",
          "1646:  copy_to_user(urq->data, &(lp->driverIdentity), sizeof(lp->driverIdentity));",
          "1648:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1696:         wl_lock(lp, &flags);",
          "1702:  wl_apply(lp);",
          "1703:         wl_unlock(lp, &flags);",
          "1706:  return ret;",
          "1707: } // wvlan_set_netname",
          "",
          "[Removed Lines]",
          "1693:  DBG_FUNC( \"wvlan_set_netname\" );",
          "1694:  DBG_ENTER( DbgInfo );",
          "1698:         memset( lp->NetworkName, 0, sizeof( lp->NetworkName ));",
          "1699:         memcpy( lp->NetworkName, extra, wrqu->data.length);",
          "1705:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1693:  DBG_FUNC(\"wvlan_set_netname\");",
          "1694:  DBG_ENTER(DbgInfo);",
          "1698:         memset(lp->NetworkName, 0, sizeof(lp->NetworkName));",
          "1699:         memcpy(lp->NetworkName, extra, wrqu->data.length);",
          "1705:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1748:         wl_lock(lp, &flags);",
          "1752:         lp->ltvRecord.typ = CFG_CUR_SSID;",
          "1759:   memset(extra, '\\0', HCF_MAX_NAME_LEN);",
          "1760:   wrqu->data.length = pName->length;",
          "",
          "[Removed Lines]",
          "1745:         DBG_FUNC( \"wvlan_get_netname\" );",
          "1746:         DBG_ENTER( DbgInfo );",
          "1751:         lp->ltvRecord.len = 1 + ( sizeof( *pName ) / sizeof( hcf_16 ));",
          "1754:         status = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));",
          "1756:         if( status == HCF_SUCCESS ) {",
          "1757:                 pName = (wvName_t *)&( lp->ltvRecord.u.u32 );",
          "",
          "[Added Lines]",
          "1745:         DBG_FUNC(\"wvlan_get_netname\");",
          "1746:         DBG_ENTER(DbgInfo);",
          "1751:         lp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));",
          "1754:         status = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));",
          "1756:         if(status == HCF_SUCCESS) {",
          "1757:                 pName = (wvName_t *)&(lp->ltvRecord.u.u32);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1767:         wl_unlock(lp, &flags);",
          "1770:         return ret;",
          "1771: } // wvlan_get_netname",
          "",
          "[Removed Lines]",
          "1769:         DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1769:         DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1810:         wl_lock(lp, &flags);",
          "1818:         wl_unlock(lp, &flags);",
          "1821:         return ret;",
          "1822: } // wvlan_set_station_nickname",
          "",
          "[Removed Lines]",
          "1807:         DBG_FUNC( \"wvlan_set_station_nickname\" );",
          "1808:         DBG_ENTER( DbgInfo );",
          "1812:         memset( lp->StationName, 0, sizeof( lp->StationName ));",
          "1814:         memcpy( lp->StationName, extra, wrqu->data.length);",
          "1817:         wl_apply( lp );",
          "1820:         DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1807:         DBG_FUNC(\"wvlan_set_station_nickname\");",
          "1808:         DBG_ENTER(DbgInfo);",
          "1812:         memset(lp->StationName, 0, sizeof(lp->StationName));",
          "1814:         memcpy(lp->StationName, extra, wrqu->data.length);",
          "1817:         wl_apply(lp);",
          "1820:         DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1867:         lp->ltvRecord.typ = CFG_CNF_OWN_NAME;",
          "1874:   memset(extra, '\\0', HCF_MAX_NAME_LEN);",
          "1875:   wrqu->data.length = pName->length;",
          "",
          "[Removed Lines]",
          "1860:         DBG_FUNC( \"wvlan_get_station_nickname\" );",
          "1861:         DBG_ENTER( DbgInfo );",
          "1863:         wl_lock( lp, &flags );",
          "1866:         lp->ltvRecord.len = 1 + ( sizeof( *pName ) / sizeof( hcf_16 ));",
          "1869:         status = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));",
          "1871:         if( status == HCF_SUCCESS ) {",
          "1872:                 pName = (wvName_t *)&( lp->ltvRecord.u.u32 );",
          "",
          "[Added Lines]",
          "1860:         DBG_FUNC(\"wvlan_get_station_nickname\");",
          "1861:         DBG_ENTER(DbgInfo);",
          "1863:         wl_lock(lp, &flags);",
          "1866:         lp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));",
          "1869:         status = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));",
          "1871:         if(status == HCF_SUCCESS) {",
          "1872:                 pName = (wvName_t *)&(lp->ltvRecord.u.u32);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1881:         wl_unlock(lp, &flags);",
          "1885:  return ret;",
          "1886: } // wvlan_get_station_nickname",
          "",
          "[Removed Lines]",
          "1884:         DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1884:         DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1926:         wl_lock(lp, &flags);",
          "1929:         portType = *((__u32 *)extra);",
          "1932:                 ret = -EINVAL;",
          "1933:   goto out_unlock;",
          "1934:         }",
          "",
          "[Removed Lines]",
          "1923:         DBG_FUNC( \"wvlan_set_porttype\" );",
          "1924:         DBG_ENTER( DbgInfo );",
          "1931:         if( !(( portType == 1 ) || ( portType == 3 ))) {",
          "",
          "[Added Lines]",
          "1923:         DBG_FUNC(\"wvlan_set_porttype\");",
          "1924:         DBG_ENTER(DbgInfo);",
          "1931:         if(!((portType == 1) || (portType == 3))) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1936:         lp->PortType = portType;",
          "1941: out_unlock:",
          "1942:         wl_unlock(lp, &flags);",
          "1946:         return ret;",
          "1947: }",
          "",
          "[Removed Lines]",
          "1939:         wl_apply( lp );",
          "1945:         DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "1939:         wl_apply(lp);",
          "1945:         DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1992:         lp->ltvRecord.typ = CFG_CNF_PORT_TYPE;",
          "2000:         } else {",
          "2001:             ret = -EFAULT;",
          "2002:  }",
          "",
          "[Removed Lines]",
          "1985:         DBG_FUNC( \"wvlan_get_porttype\" );",
          "1986:         DBG_ENTER( DbgInfo );",
          "1988:         wl_lock( lp, &flags );",
          "1991:         lp->ltvRecord.len = 1 + ( sizeof( *pPortType ) / sizeof( hcf_16 ));",
          "1994:         status = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));",
          "1996:         if( status == HCF_SUCCESS ) {",
          "1997:                 pPortType = (hcf_16 *)&( lp->ltvRecord.u.u32 );",
          "",
          "[Added Lines]",
          "1985:         DBG_FUNC(\"wvlan_get_porttype\");",
          "1986:         DBG_ENTER(DbgInfo);",
          "1988:         wl_lock(lp, &flags);",
          "1991:         lp->ltvRecord.len = 1 + (sizeof(*pPortType) / sizeof(hcf_16));",
          "1994:         status = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));",
          "1996:         if(status == HCF_SUCCESS) {",
          "1997:                 pPortType = (hcf_16 *)&(lp->ltvRecord.u.u32);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2004:         wl_unlock(lp, &flags);",
          "2008:         return ret;",
          "2009: } // wvlan_get_porttype",
          "",
          "[Removed Lines]",
          "2007:         DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "2007:         DBG_LEAVE(DbgInfo);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2038: {",
          "2039:  int ioctl_ret = 0;",
          "2050:    case WL_IOCTL_RTS_READ:",
          "2051:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_READ\\n\");",
          "2054:   break;",
          "2055:    case WL_IOCTL_RTS_WRITE:",
          "2056:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_WRITE\\n\");",
          "2059:   break;",
          "2060:    case WL_IOCTL_RTS_BATCH_READ:",
          "2061:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_READ\\n\");",
          "2064:   break;",
          "2065:    case WL_IOCTL_RTS_BATCH_WRITE:",
          "2066:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_WRITE\\n\");",
          "2069:   break;",
          "2070:  default:",
          "2073:   ioctl_ret = -EOPNOTSUPP;",
          "2074:   break;",
          "2075:  }",
          "2078:  return ioctl_ret;",
          "2079: } // wvlan_rts",
          "",
          "[Removed Lines]",
          "2037: int wvlan_rts( struct rtsreq *rrq, __u32 io_base )",
          "2043:  DBG_FUNC( \"wvlan_rts\" );",
          "2044:  DBG_ENTER( DbgInfo );",
          "2047:  DBG_PRINT( \"io_base: 0x%08x\\n\", io_base );",
          "2049:  switch( rrq->typ ) {",
          "2052:   rrq->data[0] = IN_PORT_WORD( io_base + rrq->reg );",
          "2053:   DBG_TRACE( DbgInfo, \"  reg 0x%04x ==> 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT( rrq->data[0] ) );",
          "2057:   OUT_PORT_WORD( io_base + rrq->reg, rrq->data[0] );",
          "2058:   DBG_TRACE( DbgInfo, \"  reg 0x%04x <== 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT( rrq->data[0] ) );",
          "2062:   IN_PORT_STRING_16( io_base + rrq->reg, rrq->data, rrq->len );",
          "2063:   DBG_TRACE( DbgInfo, \"  reg 0x%04x ==> %d bytes\\n\", rrq->reg, rrq->len * sizeof (__u16 ) );",
          "2067:   OUT_PORT_STRING_16( io_base + rrq->reg, rrq->data, rrq->len );",
          "2068:   DBG_TRACE( DbgInfo, \"  reg 0x%04x <== %d bytes\\n\", rrq->reg, rrq->len * sizeof (__u16) );",
          "2072:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- UNSUPPORTED RTS CODE: 0x%X\", rrq->typ );",
          "2077:  DBG_LEAVE( DbgInfo );",
          "",
          "[Added Lines]",
          "2037: int wvlan_rts(struct rtsreq *rrq, __u32 io_base)",
          "2043:  DBG_FUNC(\"wvlan_rts\");",
          "2044:  DBG_ENTER(DbgInfo);",
          "2047:  DBG_PRINT(\"io_base: 0x%08x\\n\", io_base);",
          "2049:  switch(rrq->typ) {",
          "2052:   rrq->data[0] = IN_PORT_WORD(io_base + rrq->reg);",
          "2053:   DBG_TRACE(DbgInfo, \"  reg 0x%04x ==> 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));",
          "2057:   OUT_PORT_WORD(io_base + rrq->reg, rrq->data[0]);",
          "2058:   DBG_TRACE(DbgInfo, \"  reg 0x%04x <== 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));",
          "2062:   IN_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);",
          "2063:   DBG_TRACE(DbgInfo, \"  reg 0x%04x ==> %d bytes\\n\", rrq->reg, rrq->len * sizeof (__u16));",
          "2067:   OUT_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);",
          "2068:   DBG_TRACE(DbgInfo, \"  reg 0x%04x <== %d bytes\\n\", rrq->reg, rrq->len * sizeof (__u16));",
          "2072:   DBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- UNSUPPORTED RTS CODE: 0x%X\", rrq->typ);",
          "2077:  DBG_LEAVE(DbgInfo);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
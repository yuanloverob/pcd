{
  "cve_id": "CVE-2020-36407",
  "cve_desc": "libavif 0.8.0 and 0.8.1 has an out-of-bounds write in avifDecoderDataFillImageGrid.",
  "repo": "AOMediaCodec/libavif",
  "patch_hash": "0a8e7244d494ae98e9756355dfbfb6697ded2ff9",
  "patch_info": {
    "commit_hash": "0a8e7244d494ae98e9756355dfbfb6697ded2ff9",
    "repo": "AOMediaCodec/libavif",
    "commit_url": "https://github.com/AOMediaCodec/libavif/commit/0a8e7244d494ae98e9756355dfbfb6697ded2ff9",
    "files": [
      "include/avif/internal.h",
      "src/read.c"
    ],
    "message": "Set max image size to 16384 * 16384\n\nFix https://crbug.com/oss-fuzz/24728 and\nhttps://crbug.com/oss-fuzz/24734.",
    "before_after_code_files": [
      "include/avif/internal.h||include/avif/internal.h",
      "src/read.c||src/read.c"
    ]
  },
  "patch_diff": {
    "include/avif/internal.h||include/avif/internal.h": [
      "File: include/avif/internal.h -> include/avif/internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "241: } avifSequenceHeader;",
      "242: avifBool avifSequenceHeaderParse(avifSequenceHeader * header, const avifROData * sample);",
      "244: #ifdef __cplusplus",
      "245: } // extern \"C\"",
      "246: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "246: #define AVIF_MAX_IMAGE_SIZE (16384 * 16384)",
      "",
      "---------------"
    ],
    "src/read.c||src/read.c": [
      "File: src/read.c -> src/read.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "980:         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;",
      "981:         CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;",
      "982:     }",
      "983:     return AVIF_TRUE;",
      "984: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "983:     if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {",
      "984:         return AVIF_FALSE;",
      "985:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2fb636141296abdf608f381aa006ddad21a9507a",
      "candidate_info": {
        "commit_hash": "2fb636141296abdf608f381aa006ddad21a9507a",
        "repo": "AOMediaCodec/libavif",
        "commit_url": "https://github.com/AOMediaCodec/libavif/commit/2fb636141296abdf608f381aa006ddad21a9507a",
        "files": [
          "src/codec_dav1d.c"
        ],
        "message": "Update codec_dav1d.c",
        "before_after_code_files": [
          "src/codec_dav1d.c||src/codec_dav1d.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AOMediaCodec/libavif/pull/256"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/codec_dav1d.c||src/codec_dav1d.c": [
          "File: src/codec_dav1d.c -> src/codec_dav1d.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "207:     memset(codec->internal, 0, sizeof(struct avifCodecInternal));",
          "208:     dav1d_default_settings(&codec->internal->dav1dSettings);",
          "211:     return codec;",
          "212: }",
          "",
          "[Removed Lines]",
          "210:     codec->internal->dav1dSettings.frame_size_limit = 16384 * 16384;",
          "",
          "[Added Lines]",
          "210:     codec->internal->dav1dSettings.frame_size_limit = AVIF_MAX_IMAGE_SIZE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "21167c9f472487200cd1527e90c7f20a3eaf209f",
      "candidate_info": {
        "commit_hash": "21167c9f472487200cd1527e90c7f20a3eaf209f",
        "repo": "AOMediaCodec/libavif",
        "commit_url": "https://github.com/AOMediaCodec/libavif/commit/21167c9f472487200cd1527e90c7f20a3eaf209f",
        "files": [
          "apps/avifdec.c",
          "include/avif/avif.h",
          "src/avif.c",
          "src/read.c",
          "src/reformat.c"
        ],
        "message": "Rename AVIF_MAX_IMAGE_SIZE to AVIF_DEFAULT_MAX_IMAGE_SIZE, set defaults in avifDecoder, promote some indexing math vars to uint32_t, update some comments",
        "before_after_code_files": [
          "apps/avifdec.c||apps/avifdec.c",
          "include/avif/avif.h||include/avif/avif.h",
          "src/avif.c||src/avif.c",
          "src/read.c||src/read.c",
          "src/reformat.c||src/reformat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/read.c||src/read.c"
          ],
          "candidate": [
            "src/read.c||src/read.c"
          ]
        }
      },
      "candidate_diff": {
        "apps/avifdec.c||apps/avifdec.c": [
          "File: apps/avifdec.c -> apps/avifdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:     printf(\"    -u,--upsampling U : Chroma upsampling (for 420/422). automatic (default), fastest, best, nearest, or bilinear\\n\");",
          "37:     printf(\"    -i,--info         : Decode all frames and display all image information instead of saving to disk\\n\");",
          "38:     printf(\"    --ignore-icc      : If the input file contains an embedded ICC profile, ignore it (no-op if absent)\\n\");",
          "41:     printf(\"\\n\");",
          "42:     avifPrintVersions();",
          "43: }",
          "",
          "[Removed Lines]",
          "39:     printf(\"    --size-limit C    : Specifies the image size limit (in total pixels) that the AV1 codec should tolerate.\\n\");",
          "40:     printf(\"                        Default: %u, set to 0 to disable. Supported codecs: dav1d.\\n\", AVIF_MAX_IMAGE_SIZE);",
          "",
          "[Added Lines]",
          "39:     printf(\"    --size-limit C    : Specifies the image size limit (in total pixels) that should be tolerated.\\n\");",
          "40:     printf(\"                        Default: %u, set to 0 to disable.\\n\", AVIF_DEFAULT_MAX_IMAGE_SIZE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:     avifBool infoOnly = AVIF_FALSE;",
          "94:     avifChromaUpsampling chromaUpsampling = AVIF_CHROMA_UPSAMPLING_AUTOMATIC;",
          "95:     avifBool ignoreICC = AVIF_FALSE;",
          "98:     if (argc < 2) {",
          "99:         syntax();",
          "",
          "[Removed Lines]",
          "96:     uint32_t imageSizeLimit = AVIF_MAX_IMAGE_SIZE;",
          "",
          "[Added Lines]",
          "96:     uint32_t imageSizeLimit = AVIF_DEFAULT_MAX_IMAGE_SIZE;",
          "",
          "---------------"
        ],
        "include/avif/avif.h||include/avif/avif.h": [
          "File: include/avif/avif.h -> include/avif/avif.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: #define AVIF_SPEED_SLOWEST 0",
          "77: #define AVIF_SPEED_FASTEST 10",
          "83: enum avifPlanesFlags",
          "84: {",
          "",
          "[Removed Lines]",
          "81: #define AVIF_MAX_IMAGE_SIZE (16384 * 16384)",
          "",
          "[Added Lines]",
          "81: #define AVIF_DEFAULT_MAX_IMAGE_SIZE (16384 * 16384)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "144:     AVIF_RESULT_IO_ERROR,",
          "145:     AVIF_RESULT_WAITING_ON_IO, // similar to EAGAIN/EWOULDBLOCK, this means the avifIO doesn't have necessary data available yet",
          "146:     AVIF_RESULT_INVALID_ARGUMENT, // an argument passed into this function is invalid",
          "148: } avifResult;",
          "150: AVIF_API const char * avifResultToString(avifResult result);",
          "",
          "[Removed Lines]",
          "147:     AVIF_RESULT_NOT_IMPLEMENTED   // a requested code path is not (yet) implemented",
          "",
          "[Added Lines]",
          "147:     AVIF_RESULT_NOT_IMPLEMENTED,  // a requested code path is not (yet) implemented",
          "148:     AVIF_RESULT_IMAGE_TOO_LARGE   // The image exceeds the configured imageSizeLimit",
          "",
          "---------------"
        ],
        "src/avif.c||src/avif.c": [
          "File: src/avif.c -> src/avif.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:         case AVIF_RESULT_WAITING_ON_IO:                 return \"Waiting on IO\";",
          "94:         case AVIF_RESULT_INVALID_ARGUMENT:              return \"Invalid argument\";",
          "95:         case AVIF_RESULT_NOT_IMPLEMENTED:               return \"Not implemented\";",
          "96:         case AVIF_RESULT_UNKNOWN_ERROR:",
          "97:         default:",
          "98:             break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96:         case AVIF_RESULT_IMAGE_TOO_LARGE:               return \"Image too large\";",
          "",
          "---------------"
        ],
        "src/read.c||src/read.c": [
          "File: src/read.c -> src/read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1182:     return AVIF_TRUE;",
          "1183: }",
          "1186: {",
          "1187:     BEGIN_STREAM(s, raw, rawLen);",
          "1189:     uint8_t version, flags;",
          "1190:     CHECK(avifROStreamRead(&s, &version, 1)); // unsigned int(8) version = 0;",
          "1191:     if (version != 0) {",
          "1193:     }",
          "1194:     uint8_t rowsMinusOne, columnsMinusOne;",
          "1195:     CHECK(avifROStreamRead(&s, &flags, 1));           // unsigned int(8) flags;",
          "",
          "[Removed Lines]",
          "1185: static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)",
          "1192:         return AVIF_FALSE;",
          "",
          "[Added Lines]",
          "1185: static avifResult avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen, uint32_t imageSizeLimit)",
          "1192:         return AVIF_RESULT_INVALID_IMAGE_GRID;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1208:     } else {",
          "1209:         if (fieldLength != 32) {",
          "1212:         }",
          "1213:         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;",
          "1214:         CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;",
          "1215:     }",
          "1218:     }",
          "1220: }",
          "1222: static avifBool avifParseImageSpatialExtentsProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)",
          "",
          "[Removed Lines]",
          "1211:             return AVIF_FALSE;",
          "1216:     if ((grid->outputWidth == 0) || (grid->outputHeight == 0) || (grid->outputWidth > (AVIF_MAX_IMAGE_SIZE / grid->outputHeight))) {",
          "1217:         return AVIF_FALSE;",
          "1219:     return avifROStreamRemainingBytes(&s) == 0;",
          "",
          "[Added Lines]",
          "1211:             return AVIF_RESULT_INVALID_IMAGE_GRID;",
          "1216:     if ((grid->outputWidth == 0) || (grid->outputHeight == 0) || (avifROStreamRemainingBytes(&s) != 0)) {",
          "1217:         return AVIF_RESULT_INVALID_IMAGE_GRID;",
          "1219:     if (imageSizeLimit && (grid->outputWidth > (imageSizeLimit / grid->outputHeight))) {",
          "1220:         return AVIF_RESULT_IMAGE_TOO_LARGE;",
          "1221:     }",
          "1222:     return AVIF_RESULT_OK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2233:     avifDecoder * decoder = (avifDecoder *)avifAlloc(sizeof(avifDecoder));",
          "2234:     memset(decoder, 0, sizeof(avifDecoder));",
          "2235:     decoder->maxThreads = 1;",
          "2236:     return decoder;",
          "2237: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2239:     decoder->imageSizeLimit = AVIF_DEFAULT_MAX_IMAGE_SIZE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2632:                 if (readResult != AVIF_RESULT_OK) {",
          "2633:                     return readResult;",
          "2634:                 }",
          "2637:                 }",
          "2638:             }",
          "",
          "[Removed Lines]",
          "2635:                 if (!avifParseImageGridBox(&data->colorGrid, readData.data, readData.size)) {",
          "2636:                     return AVIF_RESULT_INVALID_IMAGE_GRID;",
          "",
          "[Added Lines]",
          "2639:                 avifResult parseResult = avifParseImageGridBox(&data->colorGrid, readData.data, readData.size, decoder->imageSizeLimit);",
          "2640:                 if (parseResult != AVIF_RESULT_OK) {",
          "2641:                     return parseResult;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2671:                     if (readResult != AVIF_RESULT_OK) {",
          "2672:                         return readResult;",
          "2673:                     }",
          "2676:                     }",
          "2677:                 }",
          "",
          "[Removed Lines]",
          "2674:                     if (!avifParseImageGridBox(&data->alphaGrid, readData.data, readData.size)) {",
          "2675:                         return AVIF_RESULT_INVALID_IMAGE_GRID;",
          "",
          "[Added Lines]",
          "2679:                     avifResult parseResult =",
          "2680:                         avifParseImageGridBox(&data->alphaGrid, readData.data, readData.size, decoder->imageSizeLimit);",
          "2681:                     if (parseResult != AVIF_RESULT_OK) {",
          "2682:                         return parseResult;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2747:         if (ispeProp) {",
          "2748:             decoder->image->width = ispeProp->u.ispe.width;",
          "2749:             decoder->image->height = ispeProp->u.ispe.height;",
          "2750:         } else {",
          "2751:             decoder->image->width = 0;",
          "2752:             decoder->image->height = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2757:             if (!decoder->image->width || !decoder->image->height) {",
          "2758:                 return AVIF_RESULT_BMFF_PARSE_FAILED;",
          "2759:             }",
          "2760:             if (decoder->imageSizeLimit && (decoder->image->width > (decoder->imageSizeLimit / decoder->image->height))) {",
          "2761:                 return AVIF_RESULT_IMAGE_TOO_LARGE;",
          "2762:             }",
          "",
          "---------------"
        ],
        "src/reformat.c||src/reformat.c": [
          "File: src/reformat.c -> src/reformat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "180:     uint32_t * yuvRowBytes = image->yuvRowBytes;",
          "181:     for (uint32_t outerJ = 0; outerJ < image->height; outerJ += 2) {",
          "182:         for (uint32_t outerI = 0; outerI < image->width; outerI += 2) {",
          "184:             if ((outerI + 1) >= image->width) {",
          "185:                 blockW = 1;",
          "186:             }",
          "",
          "[Removed Lines]",
          "183:             int blockW = 2, blockH = 2;",
          "",
          "[Added Lines]",
          "183:             uint32_t blockW = 2, blockH = 2;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "189:             }",
          "198:                     if (state.rgbChannelBytes > 1) {",
          "",
          "[Removed Lines]",
          "192:             for (int bJ = 0; bJ < blockH; ++bJ) {",
          "193:                 for (int bI = 0; bI < blockW; ++bI) {",
          "194:                     int i = outerI + bI;",
          "195:                     int j = outerJ + bJ;",
          "",
          "[Added Lines]",
          "192:             for (uint32_t bJ = 0; bJ < blockH; ++bJ) {",
          "193:                 for (uint32_t bI = 0; bI < blockW; ++bI) {",
          "194:                     uint32_t i = outerI + bI;",
          "195:                     uint32_t j = outerJ + bJ;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "298:                 float sumU = 0.0f;",
          "299:                 float sumV = 0.0f;",
          "302:                         sumU += yuvBlock[bI][bJ].u;",
          "303:                         sumV += yuvBlock[bI][bJ].v;",
          "304:                     }",
          "",
          "[Removed Lines]",
          "300:                 for (int bJ = 0; bJ < blockH; ++bJ) {",
          "301:                     for (int bI = 0; bI < blockW; ++bI) {",
          "",
          "[Added Lines]",
          "300:                 for (uint32_t bJ = 0; bJ < blockH; ++bJ) {",
          "301:                     for (uint32_t bI = 0; bI < blockW; ++bI) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "307:                 float avgU = sumU / totalSamples;",
          "308:                 float avgV = sumV / totalSamples;",
          "314:                 if (state.yuvChannelBytes > 1) {",
          "315:                     uint16_t * pU = (uint16_t *)&yuvPlanes[AVIF_CHAN_U][(uvI * 2) + (uvJ * yuvRowBytes[AVIF_CHAN_U])];",
          "",
          "[Removed Lines]",
          "310:                 const int chromaShiftX = 1;",
          "311:                 const int chromaShiftY = 1;",
          "312:                 int uvI = outerI >> chromaShiftX;",
          "313:                 int uvJ = outerJ >> chromaShiftY;",
          "",
          "[Added Lines]",
          "310:                 const uint32_t chromaShiftX = 1;",
          "311:                 const uint32_t chromaShiftY = 1;",
          "312:                 uint32_t uvI = outerI >> chromaShiftX;",
          "313:                 uint32_t uvJ = outerJ >> chromaShiftY;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "323:             } else if (image->yuvFormat == AVIF_PIXEL_FORMAT_YUV422) {",
          "327:                     float sumU = 0.0f;",
          "328:                     float sumV = 0.0f;",
          "330:                         sumU += yuvBlock[bI][bJ].u;",
          "331:                         sumV += yuvBlock[bI][bJ].v;",
          "332:                     }",
          "",
          "[Removed Lines]",
          "326:                 for (int bJ = 0; bJ < blockH; ++bJ) {",
          "329:                     for (int bI = 0; bI < blockW; ++bI) {",
          "",
          "[Added Lines]",
          "326:                 for (uint32_t bJ = 0; bJ < blockH; ++bJ) {",
          "329:                     for (uint32_t bI = 0; bI < blockW; ++bI) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "334:                     float avgU = sumU / totalSamples;",
          "335:                     float avgV = sumV / totalSamples;",
          "340:                     if (state.yuvChannelBytes > 1) {",
          "341:                         uint16_t * pU = (uint16_t *)&yuvPlanes[AVIF_CHAN_U][(uvI * 2) + (uvJ * yuvRowBytes[AVIF_CHAN_U])];",
          "",
          "[Removed Lines]",
          "337:                     const int chromaShiftX = 1;",
          "338:                     int uvI = outerI >> chromaShiftX;",
          "339:                     int uvJ = outerJ + bJ;",
          "",
          "[Added Lines]",
          "337:                     const uint32_t chromaShiftX = 1;",
          "338:                     uint32_t uvI = outerI >> chromaShiftX;",
          "339:                     uint32_t uvJ = outerJ + bJ;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "488:                     uint16_t unormU[2][2], unormV[2][2];",
          "492:                     if ((i == 0) || ((i == (image->width - 1)) && ((i % 2) != 0))) {",
          "493:                         uAdjCol = 0;",
          "494:                         vAdjCol = 0;",
          "",
          "[Removed Lines]",
          "491:                     int uAdjCol, vAdjCol, uAdjRow, vAdjRow;",
          "",
          "[Added Lines]",
          "491:                     uint32_t uAdjCol, vAdjCol, uAdjRow, vAdjRow;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "538:                         unormV[1][1] = *((const uint16_t *)&vPlane[(uvJ * vRowBytes) + (uvI * yuvChannelBytes) + vAdjCol + vAdjRow]);",
          "543:                                 unormU[bI][bJ] = AVIF_MIN(unormU[bI][bJ], yuvMaxChannel);",
          "544:                                 unormV[bI][bJ] = AVIF_MIN(unormV[bI][bJ], yuvMaxChannel);",
          "545:                             }",
          "",
          "[Removed Lines]",
          "541:                         for (int bJ = 0; bJ < 2; ++bJ) {",
          "542:                             for (int bI = 0; bI < 2; ++bI) {",
          "",
          "[Added Lines]",
          "541:                         for (uint32_t bJ = 0; bJ < 2; ++bJ) {",
          "542:                             for (uint32_t bI = 0; bI < 2; ++bI) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd1492e1812fff842c31c0f4da84d48f1349265c",
      "candidate_info": {
        "commit_hash": "bd1492e1812fff842c31c0f4da84d48f1349265c",
        "repo": "AOMediaCodec/libavif",
        "commit_url": "https://github.com/AOMediaCodec/libavif/commit/bd1492e1812fff842c31c0f4da84d48f1349265c",
        "files": [
          "src/read.c",
          "src/scale.c"
        ],
        "message": "Add diagnostic messages if imageSizeLimit exceeded\n\nAdd custom diagnostic messages if item size, track size, or grid\ndimensions exceed imageSizeLimit.\n\nRelated to https://github.com/AOMediaCodec/libavif/issues/263.",
        "before_after_code_files": [
          "src/read.c||src/read.c",
          "src/scale.c||src/scale.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/read.c||src/read.c"
          ],
          "candidate": [
            "src/read.c||src/read.c"
          ]
        }
      },
      "candidate_diff": {
        "src/read.c||src/read.c": [
          "File: src/read.c -> src/read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1631:         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;",
          "1632:         CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;",
          "1633:     }",
          "1635:         avifDiagnosticsPrintf(diag, \"Grid box contains illegal dimensions: [%u x %u]\", grid->outputWidth, grid->outputHeight);",
          "1636:         return AVIF_FALSE;",
          "1637:     }",
          "1638:     return avifROStreamRemainingBytes(&s) == 0;",
          "1639: }",
          "",
          "[Removed Lines]",
          "1634:     if ((grid->outputWidth == 0) || (grid->outputHeight == 0) || (grid->outputWidth > (imageSizeLimit / grid->outputHeight))) {",
          "",
          "[Added Lines]",
          "1634:     if ((grid->outputWidth == 0) || (grid->outputHeight == 0)) {",
          "1638:     if (grid->outputWidth > (imageSizeLimit / grid->outputHeight)) {",
          "1639:         avifDiagnosticsPrintf(diag, \"Grid box dimensions are too large: [%u x %u]\", grid->outputWidth, grid->outputHeight);",
          "1640:         return AVIF_FALSE;",
          "1641:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2365:     track->width = width >> 16;",
          "2366:     track->height = height >> 16;",
          "2369:         avifDiagnosticsPrintf(diag, \"Track ID [%u] has an invalid size [%ux%u]\", track->id, track->width, track->height);",
          "2370:         return AVIF_FALSE;",
          "2371:     }",
          "",
          "[Removed Lines]",
          "2368:     if ((track->width == 0) || (track->height == 0) || (track->width > (imageSizeLimit / track->height))) {",
          "",
          "[Added Lines]",
          "2372:     if ((track->width == 0) || (track->height == 0)) {",
          "2376:     if (track->width > (imageSizeLimit / track->height)) {",
          "2377:         avifDiagnosticsPrintf(diag, \"Track ID [%u] size is too large [%ux%u]\", track->id, track->width, track->height);",
          "2378:         return AVIF_FALSE;",
          "2379:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3079:             item->width = ispeProp->u.ispe.width;",
          "3080:             item->height = ispeProp->u.ispe.height;",
          "3083:                 avifDiagnosticsPrintf(data->diag, \"Item ID [%u] has an invalid size [%ux%u]\", item->id, item->width, item->height);",
          "3084:                 return AVIF_RESULT_BMFF_PARSE_FAILED;",
          "3085:             }",
          "3086:         } else {",
          "3087:             avifDiagnosticsPrintf(data->diag, \"Item ID [%u] is missing a mandatory ispe property\", item->id);",
          "3088:             return AVIF_RESULT_BMFF_PARSE_FAILED;",
          "",
          "[Removed Lines]",
          "3082:             if ((item->width == 0) || (item->height == 0) || (item->width > (decoder->imageSizeLimit / item->height))) {",
          "",
          "[Added Lines]",
          "3090:             if ((item->width == 0) || (item->height == 0)) {",
          "3094:             if (item->width > (decoder->imageSizeLimit / item->height)) {",
          "3095:                 avifDiagnosticsPrintf(data->diag, \"Item ID [%u] size is too large [%ux%u]\", item->id, item->width, item->height);",
          "3096:                 return AVIF_RESULT_BMFF_PARSE_FAILED;",
          "3097:             }",
          "",
          "---------------"
        ],
        "src/scale.c||src/scale.c": [
          "File: src/scale.c -> src/scale.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:         return AVIF_TRUE;",
          "37:     }",
          "40:         avifDiagnosticsPrintf(diag, \"avifImageScale requested invalid dst dimensions [%ux%u]\", dstWidth, dstHeight);",
          "41:         return AVIF_FALSE;",
          "42:     }",
          "44:     uint8_t * srcYUVPlanes[AVIF_PLANE_COUNT_YUV];",
          "45:     uint32_t srcYUVRowBytes[AVIF_PLANE_COUNT_YUV];",
          "",
          "[Removed Lines]",
          "39:     if ((dstWidth == 0) || (dstHeight == 0) || (dstWidth > (imageSizeLimit / dstHeight))) {",
          "",
          "[Added Lines]",
          "39:     if ((dstWidth == 0) || (dstHeight == 0)) {",
          "43:     if (dstWidth > (imageSizeLimit / dstHeight)) {",
          "44:         avifDiagnosticsPrintf(diag, \"avifImageScale requested dst dimensions that are too large [%ux%u]\", dstWidth, dstHeight);",
          "45:         return AVIF_FALSE;",
          "46:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d8d6057d33c1284d052ae605515e254906861bce",
      "candidate_info": {
        "commit_hash": "d8d6057d33c1284d052ae605515e254906861bce",
        "repo": "AOMediaCodec/libavif",
        "commit_url": "https://github.com/AOMediaCodec/libavif/commit/d8d6057d33c1284d052ae605515e254906861bce",
        "files": [
          "src/read.c"
        ],
        "message": "Disallow zero grid output_width or output_height (#265)\n\nFix https://crbug.com/oss-fuzz/24818 and\nhttps://crbug.com/oss-fuzz/24821. These bugs were introduced by my fix\nfor https://crbug.com/oss-fuzz/24728 and\nhttps://crbug.com/oss-fuzz/24734.",
        "before_after_code_files": [
          "src/read.c||src/read.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/read.c||src/read.c"
          ],
          "candidate": [
            "src/read.c||src/read.c"
          ]
        }
      },
      "candidate_diff": {
        "src/read.c||src/read.c": [
          "File: src/read.c -> src/read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "983:         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;",
          "984:         CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;",
          "985:     }",
          "987:         return AVIF_FALSE;",
          "988:     }",
          "989:     return AVIF_TRUE;",
          "",
          "[Removed Lines]",
          "986:     if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {",
          "",
          "[Added Lines]",
          "986:     if (grid->outputWidth == 0 || grid->outputHeight == 0 || grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "980d585b6f43da0a599fd0e1674ac2ba85e9a880",
      "candidate_info": {
        "commit_hash": "980d585b6f43da0a599fd0e1674ac2ba85e9a880",
        "repo": "AOMediaCodec/libavif",
        "commit_url": "https://github.com/AOMediaCodec/libavif/commit/980d585b6f43da0a599fd0e1674ac2ba85e9a880",
        "files": [
          "apps/avifdec.c",
          "include/avif/avif.h",
          "include/avif/internal.h",
          "src/codec_dav1d.c",
          "src/read.c",
          "src/scale.c",
          "tests/oss-fuzz/avif_decode_fuzzer.cc"
        ],
        "message": "Make image size limit configurable, expose to avifdec\n\nAdapted from Joe Drago's pull request\nhttps://github.com/AOMediaCodec/libavif/pull/527, with the limitation\nthat decoder->imageSizeLimit must be less than or equal to the default\nvalue and must not be set to 0 (reserved for future use). This way we\ndon't need to audit our code for integer overflows due to a large image\nwidth or height.\n\nSet decoder->imageSizeLimit to 11 * 1024 * 10 * 1024 in\navif_decode_fuzzer.cc to keep its memory consumption under 2560 MB.\n\nhttps://github.com/AOMediaCodec/libavif/issues/263",
        "before_after_code_files": [
          "apps/avifdec.c||apps/avifdec.c",
          "include/avif/avif.h||include/avif/avif.h",
          "include/avif/internal.h||include/avif/internal.h",
          "src/codec_dav1d.c||src/codec_dav1d.c",
          "src/read.c||src/read.c",
          "src/scale.c||src/scale.c",
          "tests/oss-fuzz/avif_decode_fuzzer.cc||tests/oss-fuzz/avif_decode_fuzzer.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/avif/internal.h||include/avif/internal.h",
            "src/read.c||src/read.c"
          ],
          "candidate": [
            "include/avif/internal.h||include/avif/internal.h",
            "src/read.c||src/read.c"
          ]
        }
      },
      "candidate_diff": {
        "apps/avifdec.c||apps/avifdec.c": [
          "File: apps/avifdec.c -> apps/avifdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     printf(\"    --no-strict       : Disable strict decoding, which disables strict validation checks and errors\\n\");",
          "44:     printf(\"    -i,--info         : Decode all frames and display all image information instead of saving to disk\\n\");",
          "45:     printf(\"    --ignore-icc      : If the input file contains an embedded ICC profile, ignore it (no-op if absent)\\n\");",
          "46:     printf(\"\\n\");",
          "47:     avifPrintVersions();",
          "48: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:     printf(\"    --size-limit C    : Specifies the image size limit (in total pixels) that should be tolerated.\\n\");",
          "47:     printf(\"                        Default: %u, set to a smaller value to further restrict.\\n\", AVIF_DEFAULT_IMAGE_SIZE_LIMIT);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:     avifBool allowProgressive = AVIF_FALSE;",
          "64:     avifStrictFlags strictFlags = AVIF_STRICT_ENABLED;",
          "65:     uint32_t frameIndex = 0;",
          "67:     if (argc < 2) {",
          "68:         syntax();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:     uint32_t imageSizeLimit = AVIF_DEFAULT_IMAGE_SIZE_LIMIT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "154:             infoOnly = AVIF_TRUE;",
          "155:         } else if (!strcmp(arg, \"--ignore-icc\")) {",
          "156:             ignoreICC = AVIF_TRUE;",
          "157:         } else {",
          "159:             if (!inputFilename) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "160:         } else if (!strcmp(arg, \"--size-limit\")) {",
          "161:             NEXTARG();",
          "162:             imageSizeLimit = strtoul(arg, NULL, 10);",
          "163:             if ((imageSizeLimit > AVIF_DEFAULT_IMAGE_SIZE_LIMIT) || (imageSizeLimit == 0)) {",
          "164:                 fprintf(stderr, \"ERROR: invalid image size limit: %s\\n\", arg);",
          "165:                 return 1;",
          "166:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "184:         avifDecoder * decoder = avifDecoderCreate();",
          "185:         decoder->maxThreads = jobs;",
          "186:         decoder->codecChoice = codecChoice;",
          "187:         decoder->strictFlags = strictFlags;",
          "188:         decoder->allowProgressive = allowProgressive;",
          "189:         avifResult result = avifDecoderSetIOFile(decoder, inputFilename);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197:         decoder->imageSizeLimit = imageSizeLimit;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "251:     avifDecoder * decoder = avifDecoderCreate();",
          "252:     decoder->maxThreads = jobs;",
          "253:     decoder->codecChoice = codecChoice;",
          "254:     decoder->strictFlags = strictFlags;",
          "255:     decoder->allowProgressive = allowProgressive;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265:     decoder->imageSizeLimit = imageSizeLimit;",
          "",
          "---------------"
        ],
        "include/avif/avif.h||include/avif/avif.h": [
          "File: include/avif/avif.h -> include/avif/avif.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: #define AVIF_DIAGNOSTICS_ERROR_BUFFER_SIZE 256",
          "72: #define AVIF_DEFAULT_IMAGE_COUNT_LIMIT (12 * 3600 * 60)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: #define AVIF_DEFAULT_IMAGE_SIZE_LIMIT (16384 * 16384)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "810:     avifBool ignoreExif;",
          "811:     avifBool ignoreXMP;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "821:     uint32_t imageSizeLimit;",
          "",
          "---------------"
        ],
        "include/avif/internal.h||include/avif/internal.h": [
          "File: include/avif/internal.h -> include/avif/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "162: avifBool avifImageScale(avifImage * image, uint32_t dstWidth, uint32_t dstHeight, avifDiagnostics * diag);",
          "",
          "[Added Lines]",
          "162: avifBool avifImageScale(avifImage * image, uint32_t dstWidth, uint32_t dstHeight, uint32_t imageSizeLimit, avifDiagnostics * diag);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "367: } avifSequenceHeader;",
          "368: avifBool avifSequenceHeaderParse(avifSequenceHeader * header, const avifROData * sample);",
          "374: #ifdef __cplusplus",
          "375: } // extern \"C\"",
          "376: #endif",
          "",
          "[Removed Lines]",
          "372: #define AVIF_MAX_IMAGE_SIZE (16384 * 16384)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/codec_dav1d.c||src/codec_dav1d.c": [
          "File: src/codec_dav1d.c -> src/codec_dav1d.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:         codec->internal->dav1dSettings.n_frame_threads = 1;",
          "61:         codec->internal->dav1dSettings.n_tile_threads = AVIF_CLAMP(decoder->maxThreads, 1, DAV1D_MAX_TILE_THREADS);",
          "62:         codec->internal->dav1dSettings.operating_point = codec->operatingPoint;",
          "63:         codec->internal->dav1dSettings.all_layers = codec->allLayers;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:         codec->internal->dav1dSettings.frame_size_limit = (sizeof(size_t) < 8) ? AVIF_MIN(decoder->imageSizeLimit, 8192 * 8192)",
          "67:                                                                                : decoder->imageSizeLimit;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "215:     memset(codec->internal, 0, sizeof(struct avifCodecInternal));",
          "216:     dav1d_default_settings(&codec->internal->dav1dSettings);",
          "",
          "[Removed Lines]",
          "221:     codec->internal->dav1dSettings.frame_size_limit = (sizeof(size_t) < 8) ? (8192 * 8192) : AVIF_MAX_IMAGE_SIZE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/read.c||src/read.c": [
          "File: src/read.c -> src/read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1598:     return AVIF_TRUE;",
          "1599: }",
          "1602: {",
          "1603:     BEGIN_STREAM(s, raw, rawLen, diag, \"Box[grid]\");",
          "",
          "[Removed Lines]",
          "1601: static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen, avifDiagnostics * diag)",
          "",
          "[Added Lines]",
          "1601: static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen, uint32_t imageSizeLimit, avifDiagnostics * diag)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1631:         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;",
          "1632:         CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;",
          "1633:     }",
          "1635:         avifDiagnosticsPrintf(diag, \"Grid box contains illegal dimensions: [%u x %u]\", grid->outputWidth, grid->outputHeight);",
          "1636:         return AVIF_FALSE;",
          "1637:     }",
          "",
          "[Removed Lines]",
          "1634:     if ((grid->outputWidth == 0) || (grid->outputHeight == 0) || (grid->outputWidth > (AVIF_MAX_IMAGE_SIZE / grid->outputHeight))) {",
          "",
          "[Added Lines]",
          "1634:     if ((grid->outputWidth == 0) || (grid->outputHeight == 0) || (grid->outputWidth > (imageSizeLimit / grid->outputHeight))) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2322:     return AVIF_TRUE;",
          "2323: }",
          "2326: {",
          "2327:     BEGIN_STREAM(s, raw, rawLen, diag, \"Box[tkhd]\");",
          "",
          "[Removed Lines]",
          "2325: static avifBool avifParseTrackHeaderBox(avifTrack * track, const uint8_t * raw, size_t rawLen, avifDiagnostics * diag)",
          "",
          "[Added Lines]",
          "2325: static avifBool avifParseTrackHeaderBox(avifTrack * track, const uint8_t * raw, size_t rawLen, uint32_t imageSizeLimit, avifDiagnostics * diag)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2365:     track->width = width >> 16;",
          "2366:     track->height = height >> 16;",
          "2369:         avifDiagnosticsPrintf(diag, \"Track ID [%u] has an invalid size [%ux%u]\", track->id, track->width, track->height);",
          "2370:         return AVIF_FALSE;",
          "2371:     }",
          "",
          "[Removed Lines]",
          "2368:     if ((track->width == 0) || (track->height == 0) || (track->width > (AVIF_MAX_IMAGE_SIZE / track->height))) {",
          "",
          "[Added Lines]",
          "2368:     if ((track->width == 0) || (track->height == 0) || (track->width > (imageSizeLimit / track->height))) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2644:     return AVIF_TRUE;",
          "2645: }",
          "2648: {",
          "2649:     BEGIN_STREAM(s, raw, rawLen, data->diag, \"Box[trak]\");",
          "",
          "[Removed Lines]",
          "2647: static avifBool avifParseTrackBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen)",
          "",
          "[Added Lines]",
          "2647: static avifBool avifParseTrackBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen, uint32_t imageSizeLimit)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2655:         CHECK(avifROStreamReadBoxHeader(&s, &header));",
          "2657:         if (!memcmp(header.type, \"tkhd\", 4)) {",
          "2659:         } else if (!memcmp(header.type, \"meta\", 4)) {",
          "2660:             CHECK(avifParseMetaBox(track->meta, avifROStreamCurrent(&s), header.size, data->diag));",
          "2661:         } else if (!memcmp(header.type, \"mdia\", 4)) {",
          "",
          "[Removed Lines]",
          "2658:             CHECK(avifParseTrackHeaderBox(track, avifROStreamCurrent(&s), header.size, data->diag));",
          "",
          "[Added Lines]",
          "2658:             CHECK(avifParseTrackHeaderBox(track, avifROStreamCurrent(&s), header.size, imageSizeLimit, data->diag));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2669:     return AVIF_TRUE;",
          "2670: }",
          "2673: {",
          "2674:     BEGIN_STREAM(s, raw, rawLen, data->diag, \"Box[moov]\");",
          "",
          "[Removed Lines]",
          "2672: static avifBool avifParseMoovBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen)",
          "",
          "[Added Lines]",
          "2672: static avifBool avifParseMoovBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen, uint32_t imageSizeLimit)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2678:         CHECK(avifROStreamReadBoxHeader(&s, &header));",
          "2680:         if (!memcmp(header.type, \"trak\", 4)) {",
          "2682:         }",
          "2684:         CHECK(avifROStreamSkip(&s, header.size));",
          "",
          "[Removed Lines]",
          "2681:             CHECK(avifParseTrackBox(data, avifROStreamCurrent(&s), header.size));",
          "",
          "[Added Lines]",
          "2681:             CHECK(avifParseTrackBox(data, avifROStreamCurrent(&s), header.size, imageSizeLimit));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2779:             metaSeen = AVIF_TRUE;",
          "2780:         } else if (!memcmp(header.type, \"moov\", 4)) {",
          "2781:             CHECKERR(!moovSeen, AVIF_RESULT_BMFF_PARSE_FAILED);",
          "2783:             moovSeen = AVIF_TRUE;",
          "2784:         }",
          "",
          "[Removed Lines]",
          "2782:             CHECKERR(avifParseMoovBox(data, boxContents.data, boxContents.size), AVIF_RESULT_BMFF_PARSE_FAILED);",
          "",
          "[Added Lines]",
          "2782:             CHECKERR(avifParseMoovBox(data, boxContents.data, boxContents.size, decoder->imageSizeLimit), AVIF_RESULT_BMFF_PARSE_FAILED);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2847:     avifDecoder * decoder = (avifDecoder *)avifAlloc(sizeof(avifDecoder));",
          "2848:     memset(decoder, 0, sizeof(avifDecoder));",
          "2849:     decoder->maxThreads = 1;",
          "2850:     decoder->imageCountLimit = AVIF_DEFAULT_IMAGE_COUNT_LIMIT;",
          "2851:     decoder->strictFlags = AVIF_STRICT_ENABLED;",
          "2852:     return decoder;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2850:     decoder->imageSizeLimit = AVIF_DEFAULT_IMAGE_SIZE_LIMIT;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3033: {",
          "3034:     avifDiagnosticsClearError(&decoder->diag);",
          "3036:     if (!decoder->io || !decoder->io->read) {",
          "3037:         return AVIF_RESULT_IO_NOT_SET;",
          "3038:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3039:     if ((decoder->imageSizeLimit > AVIF_DEFAULT_IMAGE_SIZE_LIMIT) || (decoder->imageSizeLimit == 0)) {",
          "3040:         return AVIF_RESULT_NOT_IMPLEMENTED;",
          "3041:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3073:             item->width = ispeProp->u.ispe.width;",
          "3074:             item->height = ispeProp->u.ispe.height;",
          "3077:                 avifDiagnosticsPrintf(data->diag, \"Item ID [%u] has an invalid size [%ux%u]\", item->id, item->width, item->height);",
          "3078:                 return AVIF_RESULT_BMFF_PARSE_FAILED;",
          "3079:             }",
          "",
          "[Removed Lines]",
          "3076:             if ((item->width == 0) || (item->height == 0) || (item->width > (AVIF_MAX_IMAGE_SIZE / item->height))) {",
          "",
          "[Added Lines]",
          "3082:             if ((item->width == 0) || (item->height == 0) || (item->width > (decoder->imageSizeLimit / item->height))) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3302:                 if (readResult != AVIF_RESULT_OK) {",
          "3303:                     return readResult;",
          "3304:                 }",
          "3306:                     return AVIF_RESULT_INVALID_IMAGE_GRID;",
          "3307:                 }",
          "3308:             }",
          "",
          "[Removed Lines]",
          "3305:                 if (!avifParseImageGridBox(&data->colorGrid, readData.data, readData.size, data->diag)) {",
          "",
          "[Added Lines]",
          "3311:                 if (!avifParseImageGridBox(&data->colorGrid, readData.data, readData.size, decoder->imageSizeLimit, data->diag)) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3342:                     if (readResult != AVIF_RESULT_OK) {",
          "3343:                         return readResult;",
          "3344:                     }",
          "3346:                         return AVIF_RESULT_INVALID_IMAGE_GRID;",
          "3347:                     }",
          "3348:                 }",
          "",
          "[Removed Lines]",
          "3345:                     if (!avifParseImageGridBox(&data->alphaGrid, readData.data, readData.size, data->diag)) {",
          "",
          "[Added Lines]",
          "3351:                     if (!avifParseImageGridBox(&data->alphaGrid, readData.data, readData.size, decoder->imageSizeLimit, data->diag)) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3613:         if ((tile->width != tile->image->width) || (tile->height != tile->image->height)) {",
          "3615:                 avifDiagnosticsPrintf(&decoder->diag, \"avifImageScale() failed\");",
          "3616:                 return tile->input->alpha ? AVIF_RESULT_DECODE_ALPHA_FAILED : AVIF_RESULT_DECODE_COLOR_FAILED;",
          "3617:             }",
          "",
          "[Removed Lines]",
          "3614:             if (!avifImageScale(tile->image, tile->width, tile->height, &decoder->diag)) {",
          "",
          "[Added Lines]",
          "3620:             if (!avifImageScale(tile->image, tile->width, tile->height, decoder->imageSizeLimit, &decoder->diag)) {",
          "",
          "---------------"
        ],
        "src/scale.c||src/scale.c": [
          "File: src/scale.c -> src/scale.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #if !defined(AVIF_LIBYUV_ENABLED)",
          "9: {",
          "10:     (void)image;",
          "11:     (void)dstWidth;",
          "12:     (void)dstHeight;",
          "13:     avifDiagnosticsPrintf(diag, \"avifImageScale() called, but is unimplemented without libyuv!\");",
          "14:     return AVIF_FALSE;",
          "15: }",
          "",
          "[Removed Lines]",
          "8: avifBool avifImageScale(avifImage * image, uint32_t dstWidth, uint32_t dstHeight, avifDiagnostics * diag)",
          "",
          "[Added Lines]",
          "8: avifBool avifImageScale(avifImage * image, uint32_t dstWidth, uint32_t dstHeight, uint32_t imageSizeLimit, avifDiagnostics * diag)",
          "13:     (void)imageSizeLimit;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #define AVIF_LIBYUV_FILTER_MODE kFilterBox",
          "32: {",
          "33:     if ((image->width == dstWidth) && (image->height == dstHeight)) {",
          "35:         return AVIF_TRUE;",
          "36:     }",
          "39:         avifDiagnosticsPrintf(diag, \"avifImageScale requested invalid dst dimensions [%ux%u]\", dstWidth, dstHeight);",
          "40:         return AVIF_FALSE;",
          "41:     }",
          "",
          "[Removed Lines]",
          "31: avifBool avifImageScale(avifImage * image, uint32_t dstWidth, uint32_t dstHeight, avifDiagnostics * diag)",
          "38:     if ((dstWidth == 0) || (dstHeight == 0) || (dstWidth > (AVIF_MAX_IMAGE_SIZE / dstHeight))) {",
          "",
          "[Added Lines]",
          "32: avifBool avifImageScale(avifImage * image, uint32_t dstWidth, uint32_t dstHeight, uint32_t imageSizeLimit, avifDiagnostics * diag)",
          "39:     if ((dstWidth == 0) || (dstHeight == 0) || (dstWidth > (imageSizeLimit / dstHeight))) {",
          "",
          "---------------"
        ],
        "tests/oss-fuzz/avif_decode_fuzzer.cc||tests/oss-fuzz/avif_decode_fuzzer.cc": [
          "File: tests/oss-fuzz/avif_decode_fuzzer.cc -> tests/oss-fuzz/avif_decode_fuzzer.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:     static size_t yuvDepthsCount = sizeof(yuvDepths) / sizeof(yuvDepths[0]);",
          "20:     avifDecoder * decoder = avifDecoderCreate();",
          "21:     avifResult result = avifDecoderSetIOMemory(decoder, Data, Size);",
          "22:     if (result == AVIF_RESULT_OK) {",
          "23:         result = avifDecoderParse(decoder);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24:     static_assert(11 * 1024 * 10 * 1024 <= AVIF_DEFAULT_IMAGE_SIZE_LIMIT, \"\");",
          "25:     decoder->imageSizeLimit = 11 * 1024 * 10 * 1024;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-26243",
  "cve_desc": "Nanopb is a small code-size Protocol Buffers implementation. In Nanopb before versions 0.4.4 and 0.3.9.7, decoding specifically formed message can leak memory if dynamic allocation is enabled and an oneof field contains a static submessage that contains a dynamic field, and the message being decoded contains the submessage multiple times. This is rare in normal messages, but it is a concern when untrusted data is parsed. This is fixed in versions 0.3.9.7 and 0.4.4. The following workarounds are available: 1) Set the option `no_unions` for the oneof field. This will generate fields as separate instead of C union, and avoids triggering the problematic code. 2) Set the type of the submessage field inside oneof to `FT_POINTER`. This way the whole submessage will be dynamically allocated and the problematic code is not executed. 3) Use an arena allocator for nanopb, to make sure all memory can be released afterwards.",
  "repo": "nanopb/nanopb",
  "patch_hash": "4fe23595732b6f1254cfc11a9b8d6da900b55b0c",
  "patch_info": {
    "commit_hash": "4fe23595732b6f1254cfc11a9b8d6da900b55b0c",
    "repo": "nanopb/nanopb",
    "commit_url": "https://github.com/nanopb/nanopb/commit/4fe23595732b6f1254cfc11a9b8d6da900b55b0c",
    "files": [
      "pb_decode.c"
    ],
    "message": "Fix memory leak with oneofs and PB_ENABLE_MALLOC (#615)\n\nNanopb would leak memory when all of the following conditions were true:\n- PB_ENABLE_MALLOC is defined at the compile time\n- Message definitions contains an oneof field,\n  the oneof contains a static submessage, and\n  the static submessage contains a pointer field.\n- Data being decoded contains two values for the submessage.\n\nThe logic in pb_release_union_field would detect that the same\nsubmessage occurs twice, and wouldn't release it because keeping\nthe old values is necessary to match the C++ library behavior\nregarding message merges.\n\nBut then decode_static_field() would go to memset() the whole\nsubmessage to zero, because it unconditionally assumed it to\nbe uninitialized memory. This would normally happen when the\ncontents of the union field is switched to a different oneof\nitem, instead of merging with the same one.\n\nThis commit changes it so that the field is memset() only when\n`which_field` contains a different tag.",
    "before_after_code_files": [
      "pb_decode.c||pb_decode.c"
    ]
  },
  "patch_diff": {
    "pb_decode.c||pb_decode.c": [
      "File: pb_decode.c -> pb_decode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "464:             }",
      "466:         case PB_HTYPE_ONEOF:",
      "469:             {",
      "472:                 memset(iter->pData, 0, iter->pos->data_size);",
      "473:                 pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);",
      "474:             }",
      "475:             return func(stream, iter->pos, iter->pData);",
      "477:         default:",
      "",
      "[Removed Lines]",
      "468:             if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)",
      "",
      "[Added Lines]",
      "467:             if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d9d5dfd869aca4d00a81f671b2445fb4cea0352f",
      "candidate_info": {
        "commit_hash": "d9d5dfd869aca4d00a81f671b2445fb4cea0352f",
        "repo": "nanopb/nanopb",
        "commit_url": "https://github.com/nanopb/nanopb/commit/d9d5dfd869aca4d00a81f671b2445fb4cea0352f",
        "files": [
          "tests/mem_release/mem_release.c"
        ],
        "message": "Expand mem_release testcase to cover submessage merge (#615)\n\nThis also covers the fairly rarely used behavior of protobuf C++\nlibrary regarding oneof merges: if an oneof submessage occurs\nmultiple times in a message, their contents are merged together.\nThis behavior was also previously broken in nanopb.",
        "before_after_code_files": [
          "tests/mem_release/mem_release.c||tests/mem_release/mem_release.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/mem_release/mem_release.c||tests/mem_release/mem_release.c": [
          "File: tests/mem_release/mem_release.c -> tests/mem_release/mem_release.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:             }",
          "134:         }",
          "137:         {",
          "138:             OneofMessage msg = OneofMessage_init_zero;",
          "139:             msg.which_msgs = OneofMessage_msg2_tag;",
          "141:             msg.first = 999;",
          "142:             msg.msgs.msg2.dynamic_str = \"ABCD\";",
          "143:             msg.last = 888;",
          "145:             if (!pb_encode(&stream, OneofMessage_fields, &msg))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139:             char *teststr = \"1\";",
          "144:             msg.msgs.msg2.dynamic_str_arr_count = 1;",
          "145:             msg.msgs.msg2.dynamic_str_arr = &teststr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "148:                 return false;",
          "149:             }",
          "150:         }",
          "151:         msgsize = stream.bytes_written;",
          "152:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156:         {",
          "157:             OneofMessage msg = OneofMessage_init_zero;",
          "158:             char *teststr = \"2\";",
          "159:             msg.which_msgs = OneofMessage_msg2_tag;",
          "161:             msg.first = 99;",
          "162:             msg.msgs.msg2.dynamic_str = \"EFGH\";",
          "163:             msg.msgs.msg2.dynamic_str_arr_count = 1;",
          "164:             msg.msgs.msg2.dynamic_str_arr = &teststr;",
          "165:             msg.last = 88;",
          "167:             if (!pb_encode(&stream, OneofMessage_fields, &msg))",
          "168:             {",
          "169:                 fprintf(stderr, \"Encode failed: %s\\n\", PB_GET_ERROR(&stream));",
          "170:                 return false;",
          "171:             }",
          "172:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "160:             return false;",
          "161:         }",
          "164:         TEST(msg.which_msgs == OneofMessage_msg2_tag);",
          "165:         TEST(msg.msgs.msg2.dynamic_str);",
          "168:         TEST(msg.msgs.msg2.dynamic_submsg == NULL);",
          "171:         pb_release(OneofMessage_fields, &msg);",
          "172:         TEST(get_alloc_count() == 0);",
          "",
          "[Removed Lines]",
          "163:         TEST(msg.first == 999);",
          "166:         TEST(strcmp(msg.msgs.msg2.dynamic_str, \"ABCD\") == 0);",
          "167:         TEST(msg.msgs.msg2.dynamic_str_arr == NULL);",
          "169:         TEST(msg.last == 888);",
          "",
          "[Added Lines]",
          "185:         TEST(msg.first == 99);",
          "188:         TEST(strcmp(msg.msgs.msg2.dynamic_str, \"EFGH\") == 0);",
          "189:         TEST(msg.msgs.msg2.dynamic_str_arr != NULL);",
          "190:         TEST(msg.msgs.msg2.dynamic_str_arr_count == 2);",
          "191:         TEST(strcmp(msg.msgs.msg2.dynamic_str_arr[0], \"1\") == 0);",
          "192:         TEST(strcmp(msg.msgs.msg2.dynamic_str_arr[1], \"2\") == 0);",
          "194:         TEST(msg.last == 88);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
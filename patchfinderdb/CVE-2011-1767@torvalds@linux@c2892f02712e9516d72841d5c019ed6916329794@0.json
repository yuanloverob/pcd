{
  "cve_id": "CVE-2011-1767",
  "cve_desc": "net/ipv4/ip_gre.c in the Linux kernel before 2.6.34, when ip_gre is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading.",
  "repo": "torvalds/linux",
  "patch_hash": "c2892f02712e9516d72841d5c019ed6916329794",
  "patch_info": {
    "commit_hash": "c2892f02712e9516d72841d5c019ed6916329794",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c2892f02712e9516d72841d5c019ed6916329794",
    "files": [
      "net/ipv4/ip_gre.c"
    ],
    "message": "gre: fix netns vs proto registration ordering\n\nGRE protocol receive hook can be called right after protocol addition is done.\nIf netns stuff is not yet initialized, we're going to oops in\nnet_generic().\n\nThis is remotely oopsable if ip_gre is compiled as module and packet\ncomes at unfortunate moment of module loading.\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
    ]
  },
  "patch_diff": {
    "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c": [
      "File: net/ipv4/ip_gre.c -> net/ipv4/ip_gre.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1666:  printk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");",
      "1673:  err = register_pernet_device(&ipgre_net_ops);",
      "1674:  if (err < 0)",
      "1677:  err = rtnl_link_register(&ipgre_link_ops);",
      "1678:  if (err < 0)",
      "",
      "[Removed Lines]",
      "1668:  if (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {",
      "1669:   printk(KERN_INFO \"ipgre init: can't add protocol\\n\");",
      "1670:   return -EAGAIN;",
      "1671:  }",
      "1675:   goto gen_device_failed;",
      "",
      "[Added Lines]",
      "1670:   return err;",
      "1672:  err = inet_add_protocol(&ipgre_protocol, IPPROTO_GRE);",
      "1673:  if (err < 0) {",
      "1674:   printk(KERN_INFO \"ipgre init: can't add protocol\\n\");",
      "1675:   goto add_proto_failed;",
      "1676:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1688: tap_ops_failed:",
      "1689:  rtnl_link_unregister(&ipgre_link_ops);",
      "1690: rtnl_link_failed:",
      "1693:  inet_del_protocol(&ipgre_protocol, IPPROTO_GRE);",
      "1694:  goto out;",
      "1695: }",
      "",
      "[Removed Lines]",
      "1691:  unregister_pernet_device(&ipgre_net_ops);",
      "1692: gen_device_failed:",
      "",
      "[Added Lines]",
      "1693: add_proto_failed:",
      "1694:  unregister_pernet_device(&ipgre_net_ops);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1698: {",
      "1699:  rtnl_link_unregister(&ipgre_tap_ops);",
      "1700:  rtnl_link_unregister(&ipgre_link_ops);",
      "1702:  if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)",
      "1703:   printk(KERN_INFO \"ipgre close: can't remove protocol\\n\");",
      "1704: }",
      "1706: module_init(ipgre_init);",
      "",
      "[Removed Lines]",
      "1701:  unregister_pernet_device(&ipgre_net_ops);",
      "",
      "[Added Lines]",
      "1704:  unregister_pernet_device(&ipgre_net_ops);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "00959ade36acadc00e757f87060bf6e4501d545f",
      "candidate_info": {
        "commit_hash": "00959ade36acadc00e757f87060bf6e4501d545f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/00959ade36acadc00e757f87060bf6e4501d545f",
        "files": [
          "MAINTAINERS",
          "drivers/net/Kconfig",
          "drivers/net/Makefile",
          "drivers/net/pptp.c",
          "include/linux/if_pppox.h",
          "include/net/gre.h",
          "net/ipv4/Kconfig",
          "net/ipv4/Makefile",
          "net/ipv4/gre.c",
          "net/ipv4/ip_gre.c"
        ],
        "message": "PPTP: PPP over IPv4 (Point-to-Point Tunneling Protocol)\n\nPPP: introduce \"pptp\" module which implements point-to-point tunneling protocol using pppox framework\nNET: introduce the \"gre\" module for demultiplexing GRE packets on version criteria\n     (required to pptp and ip_gre may coexists)\nNET: ip_gre: update to use the \"gre\" module\n\nThis patch introduces then pptp support to the linux kernel which\ndramatically speeds up pptp vpn connections and decreases cpu usage in\ncomparison of existing user-space implementation\n(poptop/pptpclient). There is accel-pptp project\n(https://sourceforge.net/projects/accel-pptp/) to utilize this module,\nit contains plugin for pppd to use pptp in client-mode and modified\npptpd (poptop) to build high-performance pptp NAS.\n\nThere was many changes from initial submitted patch, most important are:\n1. using rcu instead of read-write locks\n2. using static bitmap instead of dynamically allocated\n3. using vmalloc for memory allocation instead of BITS_PER_LONG + __get_free_pages\n4. fixed many coding style issues\nThanks to Eric Dumazet.\n\nSigned-off-by: Dmitry Kozlov <xeb@mail.ru>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/pptp.c||drivers/net/pptp.c",
          "include/linux/if_pppox.h||include/linux/if_pppox.h",
          "include/net/gre.h||include/net/gre.h",
          "net/ipv4/gre.c||net/ipv4/gre.c",
          "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
          ],
          "candidate": [
            "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/pptp.c||drivers/net/pptp.c": [
          "File: drivers/net/pptp.c -> drivers/net/pptp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <linux/string.h>",
          "14: #include <linux/module.h>",
          "15: #include <linux/kernel.h>",
          "16: #include <linux/slab.h>",
          "17: #include <linux/errno.h>",
          "18: #include <linux/netdevice.h>",
          "19: #include <linux/net.h>",
          "20: #include <linux/skbuff.h>",
          "21: #include <linux/vmalloc.h>",
          "22: #include <linux/init.h>",
          "23: #include <linux/ppp_channel.h>",
          "24: #include <linux/ppp_defs.h>",
          "25: #include <linux/if_pppox.h>",
          "26: #include <linux/if_ppp.h>",
          "27: #include <linux/notifier.h>",
          "28: #include <linux/file.h>",
          "29: #include <linux/in.h>",
          "30: #include <linux/ip.h>",
          "31: #include <linux/netfilter.h>",
          "32: #include <linux/netfilter_ipv4.h>",
          "33: #include <linux/version.h>",
          "34: #include <linux/rcupdate.h>",
          "35: #include <linux/spinlock.h>",
          "37: #include <net/sock.h>",
          "38: #include <net/protocol.h>",
          "39: #include <net/ip.h>",
          "40: #include <net/icmp.h>",
          "41: #include <net/route.h>",
          "42: #include <net/gre.h>",
          "44: #include <linux/uaccess.h>",
          "46: #define PPTP_DRIVER_VERSION \"0.8.5\"",
          "48: #define MAX_CALLID 65535",
          "50: static DECLARE_BITMAP(callid_bitmap, MAX_CALLID + 1);",
          "51: static struct pppox_sock **callid_sock;",
          "53: static DEFINE_SPINLOCK(chan_lock);",
          "55: static struct proto pptp_sk_proto __read_mostly;",
          "56: static struct ppp_channel_ops pptp_chan_ops;",
          "57: static const struct proto_ops pptp_ops;",
          "59: #define PPP_LCP_ECHOREQ 0x09",
          "60: #define PPP_LCP_ECHOREP 0x0A",
          "61: #define SC_RCV_BITS (SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)",
          "63: #define MISSING_WINDOW 20",
          "64: #define WRAPPED(curseq, lastseq)\\",
          "65:  ((((curseq) & 0xffffff00) == 0) &&\\",
          "66:  (((lastseq) & 0xffffff00) == 0xffffff00))",
          "68: #define PPTP_GRE_PROTO  0x880B",
          "69: #define PPTP_GRE_VER    0x1",
          "71: #define PPTP_GRE_FLAG_C 0x80",
          "72: #define PPTP_GRE_FLAG_R 0x40",
          "73: #define PPTP_GRE_FLAG_K 0x20",
          "74: #define PPTP_GRE_FLAG_S 0x10",
          "75: #define PPTP_GRE_FLAG_A 0x80",
          "77: #define PPTP_GRE_IS_C(f) ((f)&PPTP_GRE_FLAG_C)",
          "78: #define PPTP_GRE_IS_R(f) ((f)&PPTP_GRE_FLAG_R)",
          "79: #define PPTP_GRE_IS_K(f) ((f)&PPTP_GRE_FLAG_K)",
          "80: #define PPTP_GRE_IS_S(f) ((f)&PPTP_GRE_FLAG_S)",
          "81: #define PPTP_GRE_IS_A(f) ((f)&PPTP_GRE_FLAG_A)",
          "83: #define PPTP_HEADER_OVERHEAD (2+sizeof(struct pptp_gre_header))",
          "84: struct pptp_gre_header {",
          "85:  u8  flags;",
          "86:  u8  ver;",
          "87:  u16 protocol;",
          "88:  u16 payload_len;",
          "89:  u16 call_id;",
          "90:  u32 seq;",
          "91:  u32 ack;",
          "92: } __packed;",
          "94: static struct pppox_sock *lookup_chan(u16 call_id, __be32 s_addr)",
          "95: {",
          "96:  struct pppox_sock *sock;",
          "97:  struct pptp_opt *opt;",
          "99:  rcu_read_lock();",
          "100:  sock = rcu_dereference(callid_sock[call_id]);",
          "101:  if (sock) {",
          "102:   opt = &sock->proto.pptp;",
          "103:   if (opt->dst_addr.sin_addr.s_addr != s_addr)",
          "104:    sock = NULL;",
          "105:   else",
          "106:    sock_hold(sk_pppox(sock));",
          "107:  }",
          "108:  rcu_read_unlock();",
          "110:  return sock;",
          "111: }",
          "113: static int lookup_chan_dst(u16 call_id, __be32 d_addr)",
          "114: {",
          "115:  struct pppox_sock *sock;",
          "116:  struct pptp_opt *opt;",
          "117:  int i;",
          "119:  rcu_read_lock();",
          "120:  for (i = find_next_bit(callid_bitmap, MAX_CALLID, 1); i < MAX_CALLID;",
          "121:       i = find_next_bit(callid_bitmap, MAX_CALLID, i + 1)) {",
          "122:   sock = rcu_dereference(callid_sock[i]);",
          "123:   if (!sock)",
          "124:    continue;",
          "125:   opt = &sock->proto.pptp;",
          "126:   if (opt->dst_addr.call_id == call_id &&",
          "127:      opt->dst_addr.sin_addr.s_addr == d_addr)",
          "128:    break;",
          "129:  }",
          "130:  rcu_read_unlock();",
          "132:  return i < MAX_CALLID;",
          "133: }",
          "135: static int add_chan(struct pppox_sock *sock)",
          "136: {",
          "137:  static int call_id;",
          "139:  spin_lock(&chan_lock);",
          "140:  if (!sock->proto.pptp.src_addr.call_id) {",
          "141:   call_id = find_next_zero_bit(callid_bitmap, MAX_CALLID, call_id + 1);",
          "142:   if (call_id == MAX_CALLID) {",
          "143:    call_id = find_next_zero_bit(callid_bitmap, MAX_CALLID, 1);",
          "144:    if (call_id == MAX_CALLID)",
          "145:     goto out_err;",
          "146:   }",
          "147:   sock->proto.pptp.src_addr.call_id = call_id;",
          "148:  } else if (test_bit(sock->proto.pptp.src_addr.call_id, callid_bitmap))",
          "149:   goto out_err;",
          "151:  set_bit(sock->proto.pptp.src_addr.call_id, callid_bitmap);",
          "152:  rcu_assign_pointer(callid_sock[sock->proto.pptp.src_addr.call_id], sock);",
          "153:  spin_unlock(&chan_lock);",
          "155:  return 0;",
          "157: out_err:",
          "158:  spin_unlock(&chan_lock);",
          "159:  return -1;",
          "160: }",
          "162: static void del_chan(struct pppox_sock *sock)",
          "163: {",
          "164:  spin_lock(&chan_lock);",
          "165:  clear_bit(sock->proto.pptp.src_addr.call_id, callid_bitmap);",
          "166:  rcu_assign_pointer(callid_sock[sock->proto.pptp.src_addr.call_id], NULL);",
          "167:  spin_unlock(&chan_lock);",
          "168:  synchronize_rcu();",
          "169: }",
          "171: static int pptp_xmit(struct ppp_channel *chan, struct sk_buff *skb)",
          "172: {",
          "173:  struct sock *sk = (struct sock *) chan->private;",
          "174:  struct pppox_sock *po = pppox_sk(sk);",
          "175:  struct pptp_opt *opt = &po->proto.pptp;",
          "176:  struct pptp_gre_header *hdr;",
          "177:  unsigned int header_len = sizeof(*hdr);",
          "178:  int err = 0;",
          "179:  int islcp;",
          "180:  int len;",
          "181:  unsigned char *data;",
          "182:  __u32 seq_recv;",
          "185:  struct rtable *rt;",
          "186:  struct net_device *tdev;",
          "187:  struct iphdr  *iph;",
          "188:  int    max_headroom;",
          "190:  if (sk_pppox(po)->sk_state & PPPOX_DEAD)",
          "191:   goto tx_error;",
          "193:  {",
          "194:   struct flowi fl = { .oif = 0,",
          "195:    .nl_u = {",
          "196:     .ip4_u = {",
          "197:      .daddr = opt->dst_addr.sin_addr.s_addr,",
          "198:      .saddr = opt->src_addr.sin_addr.s_addr,",
          "199:      .tos = RT_TOS(0) } },",
          "200:    .proto = IPPROTO_GRE };",
          "201:   err = ip_route_output_key(&init_net, &rt, &fl);",
          "202:   if (err)",
          "203:    goto tx_error;",
          "204:  }",
          "205:  tdev = rt->dst.dev;",
          "207:  max_headroom = LL_RESERVED_SPACE(tdev) + sizeof(*iph) + sizeof(*hdr) + 2;",
          "209:  if (skb_headroom(skb) < max_headroom || skb_cloned(skb) || skb_shared(skb)) {",
          "210:   struct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);",
          "211:   if (!new_skb) {",
          "212:    ip_rt_put(rt);",
          "213:    goto tx_error;",
          "214:   }",
          "215:   if (skb->sk)",
          "216:    skb_set_owner_w(new_skb, skb->sk);",
          "217:   kfree_skb(skb);",
          "218:   skb = new_skb;",
          "219:  }",
          "221:  data = skb->data;",
          "222:  islcp = ((data[0] << 8) + data[1]) == PPP_LCP && 1 <= data[2] && data[2] <= 7;",
          "225:  if ((opt->ppp_flags & SC_COMP_PROT) && data[0] == 0 && !islcp)",
          "226:   skb_pull(skb, 1);",
          "229:  if ((opt->ppp_flags & SC_COMP_AC) == 0 || islcp) {",
          "230:   data = skb_push(skb, 2);",
          "231:   data[0] = PPP_ALLSTATIONS;",
          "232:   data[1] = PPP_UI;",
          "233:  }",
          "235:  len = skb->len;",
          "237:  seq_recv = opt->seq_recv;",
          "239:  if (opt->ack_sent == seq_recv)",
          "240:   header_len -= sizeof(hdr->ack);",
          "243:  skb_push(skb, header_len);",
          "244:  hdr = (struct pptp_gre_header *)(skb->data);",
          "246:  hdr->flags       = PPTP_GRE_FLAG_K;",
          "247:  hdr->ver         = PPTP_GRE_VER;",
          "248:  hdr->protocol    = htons(PPTP_GRE_PROTO);",
          "249:  hdr->call_id     = htons(opt->dst_addr.call_id);",
          "251:  hdr->flags      |= PPTP_GRE_FLAG_S;",
          "252:  hdr->seq         = htonl(++opt->seq_sent);",
          "253:  if (opt->ack_sent != seq_recv) {",
          "255:   hdr->ver |= PPTP_GRE_FLAG_A;",
          "256:   hdr->ack  = htonl(seq_recv);",
          "257:   opt->ack_sent = seq_recv;",
          "258:  }",
          "259:  hdr->payload_len = htons(len);",
          "263:  skb_reset_transport_header(skb);",
          "264:  skb_push(skb, sizeof(*iph));",
          "265:  skb_reset_network_header(skb);",
          "266:  memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));",
          "267:  IPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED | IPSKB_REROUTED);",
          "269:  iph = ip_hdr(skb);",
          "270:  iph->version = 4;",
          "271:  iph->ihl = sizeof(struct iphdr) >> 2;",
          "272:  if (ip_dont_fragment(sk, &rt->dst))",
          "273:   iph->frag_off = htons(IP_DF);",
          "274:  else",
          "275:   iph->frag_off = 0;",
          "276:  iph->protocol = IPPROTO_GRE;",
          "277:  iph->tos      = 0;",
          "278:  iph->daddr    = rt->rt_dst;",
          "279:  iph->saddr    = rt->rt_src;",
          "280:  iph->ttl      = dst_metric(&rt->dst, RTAX_HOPLIMIT);",
          "281:  iph->tot_len  = htons(skb->len);",
          "283:  skb_dst_drop(skb);",
          "284:  skb_dst_set(skb, &rt->dst);",
          "286:  nf_reset(skb);",
          "288:  skb->ip_summed = CHECKSUM_NONE;",
          "289:  ip_select_ident(iph, &rt->dst, NULL);",
          "290:  ip_send_check(iph);",
          "292:  ip_local_out(skb);",
          "294: tx_error:",
          "295:  return 1;",
          "296: }",
          "298: static int pptp_rcv_core(struct sock *sk, struct sk_buff *skb)",
          "299: {",
          "300:  struct pppox_sock *po = pppox_sk(sk);",
          "301:  struct pptp_opt *opt = &po->proto.pptp;",
          "302:  int headersize, payload_len, seq;",
          "303:  __u8 *payload;",
          "304:  struct pptp_gre_header *header;",
          "306:  if (!(sk->sk_state & PPPOX_CONNECTED)) {",
          "307:   if (sock_queue_rcv_skb(sk, skb))",
          "308:    goto drop;",
          "309:   return NET_RX_SUCCESS;",
          "310:  }",
          "312:  header = (struct pptp_gre_header *)(skb->data);",
          "315:  if (PPTP_GRE_IS_A(header->ver)) {",
          "316:   __u32 ack = (PPTP_GRE_IS_S(header->flags)) ?",
          "319:   ack = ntohl(ack);",
          "321:   if (ack > opt->ack_recv)",
          "322:    opt->ack_recv = ack;",
          "324:   if (WRAPPED(ack, opt->ack_recv))",
          "325:    opt->ack_recv = ack;",
          "326:  }",
          "329:  if (!PPTP_GRE_IS_S(header->flags))",
          "330:   goto drop;",
          "332:  headersize  = sizeof(*header);",
          "333:  payload_len = ntohs(header->payload_len);",
          "334:  seq         = ntohl(header->seq);",
          "337:  if (!PPTP_GRE_IS_A(header->ver))",
          "338:   headersize -= sizeof(header->ack);",
          "340:  if (skb->len - headersize < payload_len)",
          "341:   goto drop;",
          "343:  payload = skb->data + headersize;",
          "345:  if (seq < opt->seq_recv + 1 || WRAPPED(opt->seq_recv, seq)) {",
          "346:   if ((payload[0] == PPP_ALLSTATIONS) && (payload[1] == PPP_UI) &&",
          "347:     (PPP_PROTOCOL(payload) == PPP_LCP) &&",
          "348:     ((payload[4] == PPP_LCP_ECHOREQ) || (payload[4] == PPP_LCP_ECHOREP)))",
          "349:    goto allow_packet;",
          "350:  } else {",
          "351:   opt->seq_recv = seq;",
          "352: allow_packet:",
          "353:   skb_pull(skb, headersize);",
          "355:   if (payload[0] == PPP_ALLSTATIONS && payload[1] == PPP_UI) {",
          "357:    if (skb->len < 3)",
          "358:     goto drop;",
          "359:    skb_pull(skb, 2);",
          "360:   }",
          "362:   if ((*skb->data) & 1) {",
          "364:    skb_push(skb, 1)[0] = 0;",
          "365:   }",
          "367:   skb->ip_summed = CHECKSUM_NONE;",
          "368:   skb_set_network_header(skb, skb->head-skb->data);",
          "369:   ppp_input(&po->chan, skb);",
          "371:   return NET_RX_SUCCESS;",
          "372:  }",
          "373: drop:",
          "374:  kfree_skb(skb);",
          "375:  return NET_RX_DROP;",
          "376: }",
          "378: static int pptp_rcv(struct sk_buff *skb)",
          "379: {",
          "380:  struct pppox_sock *po;",
          "381:  struct pptp_gre_header *header;",
          "382:  struct iphdr *iph;",
          "384:  if (skb->pkt_type != PACKET_HOST)",
          "385:   goto drop;",
          "387:  if (!pskb_may_pull(skb, 12))",
          "388:   goto drop;",
          "390:  iph = ip_hdr(skb);",
          "392:  header = (struct pptp_gre_header *)skb->data;",
          "400:   goto drop;",
          "402:  po = lookup_chan(htons(header->call_id), iph->saddr);",
          "403:  if (po) {",
          "404:   skb_dst_drop(skb);",
          "405:   nf_reset(skb);",
          "406:   return sk_receive_skb(sk_pppox(po), skb, 0);",
          "407:  }",
          "408: drop:",
          "409:  kfree_skb(skb);",
          "410:  return NET_RX_DROP;",
          "411: }",
          "413: static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,",
          "414:  int sockaddr_len)",
          "415: {",
          "416:  struct sock *sk = sock->sk;",
          "417:  struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;",
          "418:  struct pppox_sock *po = pppox_sk(sk);",
          "419:  struct pptp_opt *opt = &po->proto.pptp;",
          "420:  int error = 0;",
          "422:  lock_sock(sk);",
          "424:  opt->src_addr = sp->sa_addr.pptp;",
          "425:  if (add_chan(po)) {",
          "426:   release_sock(sk);",
          "427:   error = -EBUSY;",
          "428:  }",
          "430:  release_sock(sk);",
          "431:  return error;",
          "432: }",
          "434: static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,",
          "435:  int sockaddr_len, int flags)",
          "436: {",
          "437:  struct sock *sk = sock->sk;",
          "438:  struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;",
          "439:  struct pppox_sock *po = pppox_sk(sk);",
          "440:  struct pptp_opt *opt = &po->proto.pptp;",
          "441:  struct rtable *rt;",
          "442:  int error = 0;",
          "444:  if (sp->sa_protocol != PX_PROTO_PPTP)",
          "445:   return -EINVAL;",
          "447:  if (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))",
          "448:   return -EALREADY;",
          "450:  lock_sock(sk);",
          "452:  if (sk->sk_state & PPPOX_CONNECTED) {",
          "453:   error = -EBUSY;",
          "454:   goto end;",
          "455:  }",
          "458:  if (sk->sk_state & PPPOX_DEAD) {",
          "459:   error = -EALREADY;",
          "460:   goto end;",
          "461:  }",
          "463:  if (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {",
          "464:   error = -EINVAL;",
          "465:   goto end;",
          "466:  }",
          "468:  po->chan.private = sk;",
          "469:  po->chan.ops = &pptp_chan_ops;",
          "471:  {",
          "472:   struct flowi fl = {",
          "473:    .nl_u = {",
          "474:     .ip4_u = {",
          "475:      .daddr = opt->dst_addr.sin_addr.s_addr,",
          "476:      .saddr = opt->src_addr.sin_addr.s_addr,",
          "477:      .tos = RT_CONN_FLAGS(sk) } },",
          "478:    .proto = IPPROTO_GRE };",
          "479:   security_sk_classify_flow(sk, &fl);",
          "480:   if (ip_route_output_key(&init_net, &rt, &fl)) {",
          "481:    error = -EHOSTUNREACH;",
          "482:    goto end;",
          "483:   }",
          "484:   sk_setup_caps(sk, &rt->dst);",
          "485:  }",
          "486:  po->chan.mtu = dst_mtu(&rt->dst);",
          "487:  if (!po->chan.mtu)",
          "488:   po->chan.mtu = PPP_MTU;",
          "489:  ip_rt_put(rt);",
          "490:  po->chan.mtu -= PPTP_HEADER_OVERHEAD;",
          "492:  po->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);",
          "493:  error = ppp_register_channel(&po->chan);",
          "494:  if (error) {",
          "495:   pr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);",
          "496:   goto end;",
          "497:  }",
          "499:  opt->dst_addr = sp->sa_addr.pptp;",
          "500:  sk->sk_state = PPPOX_CONNECTED;",
          "502:  end:",
          "503:  release_sock(sk);",
          "504:  return error;",
          "505: }",
          "507: static int pptp_getname(struct socket *sock, struct sockaddr *uaddr,",
          "508:  int *usockaddr_len, int peer)",
          "509: {",
          "510:  int len = sizeof(struct sockaddr_pppox);",
          "511:  struct sockaddr_pppox sp;",
          "513:  sp.sa_family   = AF_PPPOX;",
          "514:  sp.sa_protocol  = PX_PROTO_PPTP;",
          "515:  sp.sa_addr.pptp = pppox_sk(sock->sk)->proto.pptp.src_addr;",
          "517:  memcpy(uaddr, &sp, len);",
          "521:  return 0;",
          "522: }",
          "524: static int pptp_release(struct socket *sock)",
          "525: {",
          "526:  struct sock *sk = sock->sk;",
          "527:  struct pppox_sock *po;",
          "528:  struct pptp_opt *opt;",
          "529:  int error = 0;",
          "531:  if (!sk)",
          "532:   return 0;",
          "534:  lock_sock(sk);",
          "536:  if (sock_flag(sk, SOCK_DEAD)) {",
          "537:   release_sock(sk);",
          "538:   return -EBADF;",
          "539:  }",
          "541:  po = pppox_sk(sk);",
          "542:  opt = &po->proto.pptp;",
          "543:  del_chan(po);",
          "545:  pppox_unbind_sock(sk);",
          "546:  sk->sk_state = PPPOX_DEAD;",
          "548:  sock_orphan(sk);",
          "549:  sock->sk = NULL;",
          "551:  release_sock(sk);",
          "552:  sock_put(sk);",
          "554:  return error;",
          "555: }",
          "557: static void pptp_sock_destruct(struct sock *sk)",
          "558: {",
          "559:  if (!(sk->sk_state & PPPOX_DEAD)) {",
          "560:   del_chan(pppox_sk(sk));",
          "561:   pppox_unbind_sock(sk);",
          "562:  }",
          "563:  skb_queue_purge(&sk->sk_receive_queue);",
          "564: }",
          "566: static int pptp_create(struct net *net, struct socket *sock)",
          "567: {",
          "568:  int error = -ENOMEM;",
          "569:  struct sock *sk;",
          "570:  struct pppox_sock *po;",
          "571:  struct pptp_opt *opt;",
          "573:  sk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pptp_sk_proto);",
          "574:  if (!sk)",
          "575:   goto out;",
          "577:  sock_init_data(sock, sk);",
          "579:  sock->state = SS_UNCONNECTED;",
          "580:  sock->ops   = &pptp_ops;",
          "582:  sk->sk_backlog_rcv = pptp_rcv_core;",
          "583:  sk->sk_state       = PPPOX_NONE;",
          "584:  sk->sk_type        = SOCK_STREAM;",
          "585:  sk->sk_family      = PF_PPPOX;",
          "586:  sk->sk_protocol    = PX_PROTO_PPTP;",
          "587:  sk->sk_destruct    = pptp_sock_destruct;",
          "589:  po = pppox_sk(sk);",
          "590:  opt = &po->proto.pptp;",
          "592:  opt->seq_sent = 0; opt->seq_recv = 0;",
          "593:  opt->ack_recv = 0; opt->ack_sent = 0;",
          "595:  error = 0;",
          "596: out:",
          "597:  return error;",
          "598: }",
          "600: static int pptp_ppp_ioctl(struct ppp_channel *chan, unsigned int cmd,",
          "601:  unsigned long arg)",
          "602: {",
          "603:  struct sock *sk = (struct sock *) chan->private;",
          "604:  struct pppox_sock *po = pppox_sk(sk);",
          "605:  struct pptp_opt *opt = &po->proto.pptp;",
          "606:  void __user *argp = (void __user *)arg;",
          "607:  int __user *p = argp;",
          "608:  int err, val;",
          "610:  err = -EFAULT;",
          "611:  switch (cmd) {",
          "612:  case PPPIOCGFLAGS:",
          "613:   val = opt->ppp_flags;",
          "614:   if (put_user(val, p))",
          "615:    break;",
          "616:   err = 0;",
          "617:   break;",
          "618:  case PPPIOCSFLAGS:",
          "619:   if (get_user(val, p))",
          "620:    break;",
          "621:   opt->ppp_flags = val & ~SC_RCV_BITS;",
          "622:   err = 0;",
          "623:   break;",
          "624:  default:",
          "625:   err = -ENOTTY;",
          "626:  }",
          "628:  return err;",
          "629: }",
          "631: static struct ppp_channel_ops pptp_chan_ops = {",
          "632:  .start_xmit = pptp_xmit,",
          "633:  .ioctl      = pptp_ppp_ioctl,",
          "634: };",
          "636: static struct proto pptp_sk_proto __read_mostly = {",
          "637:  .name     = \"PPTP\",",
          "638:  .owner    = THIS_MODULE,",
          "639:  .obj_size = sizeof(struct pppox_sock),",
          "640: };",
          "642: static const struct proto_ops pptp_ops = {",
          "643:  .family     = AF_PPPOX,",
          "644:  .owner      = THIS_MODULE,",
          "645:  .release    = pptp_release,",
          "646:  .bind       = pptp_bind,",
          "647:  .connect    = pptp_connect,",
          "648:  .socketpair = sock_no_socketpair,",
          "649:  .accept     = sock_no_accept,",
          "650:  .getname    = pptp_getname,",
          "651:  .poll       = sock_no_poll,",
          "652:  .listen     = sock_no_listen,",
          "653:  .shutdown   = sock_no_shutdown,",
          "654:  .setsockopt = sock_no_setsockopt,",
          "655:  .getsockopt = sock_no_getsockopt,",
          "656:  .sendmsg    = sock_no_sendmsg,",
          "657:  .recvmsg    = sock_no_recvmsg,",
          "658:  .mmap       = sock_no_mmap,",
          "659:  .ioctl      = pppox_ioctl,",
          "660: };",
          "662: static struct pppox_proto pppox_pptp_proto = {",
          "663:  .create = pptp_create,",
          "664:  .owner  = THIS_MODULE,",
          "665: };",
          "667: static struct gre_protocol gre_pptp_protocol = {",
          "668:  .handler = pptp_rcv,",
          "669: };",
          "671: static int __init pptp_init_module(void)",
          "672: {",
          "673:  int err = 0;",
          "674:  pr_info(\"PPTP driver version \" PPTP_DRIVER_VERSION \"\\n\");",
          "676:  callid_sock = __vmalloc((MAX_CALLID + 1) * sizeof(void *),",
          "677:   GFP_KERNEL | __GFP_ZERO, PAGE_KERNEL);",
          "678:  if (!callid_sock) {",
          "679:   pr_err(\"PPTP: cann't allocate memory\\n\");",
          "680:   return -ENOMEM;",
          "681:  }",
          "683:  err = gre_add_protocol(&gre_pptp_protocol, GREPROTO_PPTP);",
          "684:  if (err) {",
          "685:   pr_err(\"PPTP: can't add gre protocol\\n\");",
          "686:   goto out_mem_free;",
          "687:  }",
          "689:  err = proto_register(&pptp_sk_proto, 0);",
          "690:  if (err) {",
          "691:   pr_err(\"PPTP: can't register sk_proto\\n\");",
          "692:   goto out_gre_del_protocol;",
          "693:  }",
          "695:  err = register_pppox_proto(PX_PROTO_PPTP, &pppox_pptp_proto);",
          "696:  if (err) {",
          "697:   pr_err(\"PPTP: can't register pppox_proto\\n\");",
          "698:   goto out_unregister_sk_proto;",
          "699:  }",
          "701:  return 0;",
          "703: out_unregister_sk_proto:",
          "704:  proto_unregister(&pptp_sk_proto);",
          "705: out_gre_del_protocol:",
          "706:  gre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);",
          "707: out_mem_free:",
          "708:  vfree(callid_sock);",
          "710:  return err;",
          "711: }",
          "713: static void __exit pptp_exit_module(void)",
          "714: {",
          "715:  unregister_pppox_proto(PX_PROTO_PPTP);",
          "716:  proto_unregister(&pptp_sk_proto);",
          "717:  gre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);",
          "718:  vfree(callid_sock);",
          "719: }",
          "721: module_init(pptp_init_module);",
          "722: module_exit(pptp_exit_module);",
          "724: MODULE_DESCRIPTION(\"Point-to-Point Tunneling Protocol\");",
          "725: MODULE_AUTHOR(\"D. Kozlov (xeb@mail.ru)\");",
          "726: MODULE_LICENSE(\"GPL\");",
          "",
          "---------------"
        ],
        "include/linux/if_pppox.h||include/linux/if_pppox.h": [
          "File: include/linux/if_pppox.h -> include/linux/if_pppox.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: typedef __be16 sid_t;",
          "47: };",
          "62: } __packed;",
          "",
          "[Removed Lines]",
          "43: struct pppoe_addr{",
          "54: #define PX_MAX_PROTO   2",
          "56: struct sockaddr_pppox {",
          "59:        union{",
          "60:                struct pppoe_addr       pppoe;",
          "61:        }sa_addr;",
          "",
          "[Added Lines]",
          "43: struct pppoe_addr {",
          "52: struct pptp_addr {",
          "53:  u16             call_id;",
          "54:  struct in_addr  sin_addr;",
          "55: };",
          "62: #define PX_PROTO_PPTP  2",
          "63: #define PX_MAX_PROTO   3",
          "65: struct sockaddr_pppox {",
          "68:  union {",
          "69:   struct pppoe_addr  pppoe;",
          "70:   struct pptp_addr   pptp;",
          "71:  } sa_addr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101:  __be16 tag_type;",
          "102:  __be16 tag_len;",
          "103:  char tag_data[0];",
          "107: #define PTT_EOL  __cpu_to_be16(0x0000)",
          "",
          "[Removed Lines]",
          "104: } __attribute ((packed));",
          "",
          "[Added Lines]",
          "114: } __packed;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "151: };",
          "153: #include <net/sock.h>",
          "155: struct pppox_sock {",
          "160:  union {",
          "161:   struct pppoe_opt pppoe;",
          "162:  } proto;",
          "163:  __be16   num;",
          "164: };",
          "",
          "[Removed Lines]",
          "157:  struct sock  sk;",
          "158:  struct ppp_channel chan;",
          "",
          "[Added Lines]",
          "163: struct pptp_opt {",
          "164:  struct pptp_addr src_addr;",
          "165:  struct pptp_addr dst_addr;",
          "166:  u32 ack_sent, ack_recv;",
          "167:  u32 seq_sent, seq_recv;",
          "168:  int ppp_flags;",
          "169: };",
          "174:  struct sock sk;",
          "175:  struct ppp_channel chan;",
          "179:   struct pptp_opt  pptp;",
          "",
          "---------------"
        ],
        "include/net/gre.h||include/net/gre.h": [
          "File: include/net/gre.h -> include/net/gre.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef __LINUX_GRE_H",
          "2: #define __LINUX_GRE_H",
          "4: #include <linux/skbuff.h>",
          "6: #define GREPROTO_CISCO  0",
          "7: #define GREPROTO_PPTP  1",
          "8: #define GREPROTO_MAX  2",
          "10: struct gre_protocol {",
          "11:  int  (*handler)(struct sk_buff *skb);",
          "12:  void (*err_handler)(struct sk_buff *skb, u32 info);",
          "13: };",
          "15: int gre_add_protocol(const struct gre_protocol *proto, u8 version);",
          "16: int gre_del_protocol(const struct gre_protocol *proto, u8 version);",
          "18: #endif",
          "",
          "---------------"
        ],
        "net/ipv4/gre.c||net/ipv4/gre.c": [
          "File: net/ipv4/gre.c -> net/ipv4/gre.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <linux/module.h>",
          "14: #include <linux/kernel.h>",
          "15: #include <linux/kmod.h>",
          "16: #include <linux/skbuff.h>",
          "17: #include <linux/in.h>",
          "18: #include <linux/netdevice.h>",
          "19: #include <linux/version.h>",
          "20: #include <linux/spinlock.h>",
          "21: #include <net/protocol.h>",
          "22: #include <net/gre.h>",
          "25: const struct gre_protocol *gre_proto[GREPROTO_MAX] __read_mostly;",
          "26: static DEFINE_SPINLOCK(gre_proto_lock);",
          "28: int gre_add_protocol(const struct gre_protocol *proto, u8 version)",
          "29: {",
          "30:  if (version >= GREPROTO_MAX)",
          "31:   goto err_out;",
          "33:  spin_lock(&gre_proto_lock);",
          "34:  if (gre_proto[version])",
          "35:   goto err_out_unlock;",
          "37:  rcu_assign_pointer(gre_proto[version], proto);",
          "38:  spin_unlock(&gre_proto_lock);",
          "39:  return 0;",
          "41: err_out_unlock:",
          "42:  spin_unlock(&gre_proto_lock);",
          "43: err_out:",
          "44:  return -1;",
          "45: }",
          "46: EXPORT_SYMBOL_GPL(gre_add_protocol);",
          "48: int gre_del_protocol(const struct gre_protocol *proto, u8 version)",
          "49: {",
          "50:  if (version >= GREPROTO_MAX)",
          "51:   goto err_out;",
          "53:  spin_lock(&gre_proto_lock);",
          "54:  if (gre_proto[version] != proto)",
          "55:   goto err_out_unlock;",
          "56:  rcu_assign_pointer(gre_proto[version], NULL);",
          "57:  spin_unlock(&gre_proto_lock);",
          "58:  synchronize_rcu();",
          "59:  return 0;",
          "61: err_out_unlock:",
          "62:  spin_unlock(&gre_proto_lock);",
          "63: err_out:",
          "64:  return -1;",
          "65: }",
          "66: EXPORT_SYMBOL_GPL(gre_del_protocol);",
          "68: static int gre_rcv(struct sk_buff *skb)",
          "69: {",
          "70:  const struct gre_protocol *proto;",
          "71:  u8 ver;",
          "72:  int ret;",
          "74:  if (!pskb_may_pull(skb, 12))",
          "75:   goto drop;",
          "77:  ver = skb->data[1]&0x7f;",
          "78:  if (ver >= GREPROTO_MAX)",
          "79:   goto drop;",
          "81:  rcu_read_lock();",
          "82:  proto = rcu_dereference(gre_proto[ver]);",
          "83:  if (!proto || !proto->handler)",
          "84:   goto drop_unlock;",
          "85:  ret = proto->handler(skb);",
          "86:  rcu_read_unlock();",
          "87:  return ret;",
          "89: drop_unlock:",
          "90:  rcu_read_unlock();",
          "91: drop:",
          "92:  kfree_skb(skb);",
          "93:  return NET_RX_DROP;",
          "94: }",
          "96: static void gre_err(struct sk_buff *skb, u32 info)",
          "97: {",
          "98:  const struct gre_protocol *proto;",
          "99:  u8 ver;",
          "101:  if (!pskb_may_pull(skb, 12))",
          "102:   goto drop;",
          "104:  ver = skb->data[1]&0x7f;",
          "105:  if (ver >= GREPROTO_MAX)",
          "106:   goto drop;",
          "108:  rcu_read_lock();",
          "109:  proto = rcu_dereference(gre_proto[ver]);",
          "110:  if (!proto || !proto->err_handler)",
          "111:   goto drop_unlock;",
          "112:  proto->err_handler(skb, info);",
          "113:  rcu_read_unlock();",
          "114:  return;",
          "116: drop_unlock:",
          "117:  rcu_read_unlock();",
          "118: drop:",
          "119:  kfree_skb(skb);",
          "120: }",
          "122: static const struct net_protocol net_gre_protocol = {",
          "123:  .handler     = gre_rcv,",
          "124:  .err_handler = gre_err,",
          "125:  .netns_ok    = 1,",
          "126: };",
          "128: static int __init gre_init(void)",
          "129: {",
          "130:  pr_info(\"GRE over IPv4 demultiplexor driver\");",
          "132:  if (inet_add_protocol(&net_gre_protocol, IPPROTO_GRE) < 0) {",
          "133:   pr_err(\"gre: can't add protocol\\n\");",
          "134:   return -EAGAIN;",
          "135:  }",
          "137:  return 0;",
          "138: }",
          "140: static void __exit gre_exit(void)",
          "141: {",
          "142:  inet_del_protocol(&net_gre_protocol, IPPROTO_GRE);",
          "143: }",
          "145: module_init(gre_init);",
          "146: module_exit(gre_exit);",
          "148: MODULE_DESCRIPTION(\"GRE over IPv4 demultiplexer driver\");",
          "149: MODULE_AUTHOR(\"D. Kozlov (xeb@mail.ru)\");",
          "150: MODULE_LICENSE(\"GPL\");",
          "",
          "---------------"
        ],
        "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c": [
          "File: net/ipv4/ip_gre.c -> net/ipv4/ip_gre.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: #include <net/net_namespace.h>",
          "45: #include <net/netns/generic.h>",
          "46: #include <net/rtnetlink.h>",
          "48: #ifdef CONFIG_IPV6",
          "49: #include <net/ipv6.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #include <net/gre.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1278: }",
          "1285: };",
          "1287: static void ipgre_destroy_tunnels(struct ipgre_net *ign, struct list_head *head)",
          "",
          "[Removed Lines]",
          "1281: static const struct net_protocol ipgre_protocol = {",
          "1282:  .handler = ipgre_rcv,",
          "1283:  .err_handler = ipgre_err,",
          "1284:  .netns_ok = 1,",
          "",
          "[Added Lines]",
          "1282: static const struct gre_protocol ipgre_protocol = {",
          "1283:  .handler     = ipgre_rcv,",
          "1284:  .err_handler = ipgre_err,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1663:  if (err < 0)",
          "1664:   return err;",
          "1667:  if (err < 0) {",
          "1668:   printk(KERN_INFO \"ipgre init: can't add protocol\\n\");",
          "1669:   goto add_proto_failed;",
          "",
          "[Removed Lines]",
          "1666:  err = inet_add_protocol(&ipgre_protocol, IPPROTO_GRE);",
          "",
          "[Added Lines]",
          "1666:  err = gre_add_protocol(&ipgre_protocol, GREPROTO_CISCO);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1683: tap_ops_failed:",
          "1684:  rtnl_link_unregister(&ipgre_link_ops);",
          "1685: rtnl_link_failed:",
          "1687: add_proto_failed:",
          "1688:  unregister_pernet_device(&ipgre_net_ops);",
          "1689:  goto out;",
          "",
          "[Removed Lines]",
          "1686:  inet_del_protocol(&ipgre_protocol, IPPROTO_GRE);",
          "",
          "[Added Lines]",
          "1686:  gre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1693: {",
          "1694:  rtnl_link_unregister(&ipgre_tap_ops);",
          "1695:  rtnl_link_unregister(&ipgre_link_ops);",
          "1697:   printk(KERN_INFO \"ipgre close: can't remove protocol\\n\");",
          "1698:  unregister_pernet_device(&ipgre_net_ops);",
          "1699: }",
          "",
          "[Removed Lines]",
          "1696:  if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)",
          "",
          "[Added Lines]",
          "1696:  if (gre_del_protocol(&ipgre_protocol, GREPROTO_CISCO) < 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cfb8fbf2299d0e028ac59afd5b8c94ebe53d0859",
      "candidate_info": {
        "commit_hash": "cfb8fbf2299d0e028ac59afd5b8c94ebe53d0859",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cfb8fbf2299d0e028ac59afd5b8c94ebe53d0859",
        "files": [
          "net/ipv4/ip_gre.c"
        ],
        "message": "net: Simplify ip_gre pernet operations.\n\nTake advantage of the new pernet automatic storage management,\nand stop using compatibility network namespace functions.\n\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
          ],
          "candidate": [
            "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c": [
          "File: net/ipv4/ip_gre.c -> net/ipv4/ip_gre.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1310: static int ipgre_init_net(struct net *net)",
          "1311: {",
          "1312:  int err;",
          "1324:  ign->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"gre0\",",
          "1325:         ipgre_tunnel_setup);",
          "",
          "[Removed Lines]",
          "1313:  struct ipgre_net *ign;",
          "1315:  err = -ENOMEM;",
          "1316:  ign = kzalloc(sizeof(struct ipgre_net), GFP_KERNEL);",
          "1317:  if (ign == NULL)",
          "1318:   goto err_alloc;",
          "1320:  err = net_assign_generic(net, ipgre_net_id, ign);",
          "1321:  if (err < 0)",
          "1322:   goto err_assign;",
          "",
          "[Added Lines]",
          "1312:  struct ipgre_net *ign = net_generic(net, ipgre_net_id);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1340: err_reg_dev:",
          "1341:  free_netdev(ign->fb_tunnel_dev);",
          "1342: err_alloc_dev:",
          "1347:  return err;",
          "1348: }",
          "",
          "[Removed Lines]",
          "1344: err_assign:",
          "1345:  kfree(ign);",
          "1346: err_alloc:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1357:  ipgre_destroy_tunnels(ign, &list);",
          "1358:  unregister_netdevice_many(&list);",
          "1359:  rtnl_unlock();",
          "1361: }",
          "1363: static struct pernet_operations ipgre_net_ops = {",
          "1364:  .init = ipgre_init_net,",
          "1365:  .exit = ipgre_exit_net,",
          "1366: };",
          "1368: static int ipgre_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])",
          "",
          "[Removed Lines]",
          "1360:  kfree(ign);",
          "",
          "[Added Lines]",
          "1352:  .id   = &ipgre_net_id,",
          "1353:  .size = sizeof(struct ipgre_net),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1682:   return -EAGAIN;",
          "1683:  }",
          "1686:  if (err < 0)",
          "1687:   goto gen_device_failed;",
          "",
          "[Removed Lines]",
          "1685:  err = register_pernet_gen_device(&ipgre_net_id, &ipgre_net_ops);",
          "",
          "[Added Lines]",
          "1673:  err = register_pernet_device(&ipgre_net_ops);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1700: tap_ops_failed:",
          "1701:  rtnl_link_unregister(&ipgre_link_ops);",
          "1702: rtnl_link_failed:",
          "1704: gen_device_failed:",
          "1705:  inet_del_protocol(&ipgre_protocol, IPPROTO_GRE);",
          "1706:  goto out;",
          "",
          "[Removed Lines]",
          "1703:  unregister_pernet_gen_device(ipgre_net_id, &ipgre_net_ops);",
          "",
          "[Added Lines]",
          "1691:  unregister_pernet_device(&ipgre_net_ops);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1710: {",
          "1711:  rtnl_link_unregister(&ipgre_tap_ops);",
          "1712:  rtnl_link_unregister(&ipgre_link_ops);",
          "1714:  if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)",
          "1715:   printk(KERN_INFO \"ipgre close: can't remove protocol\\n\");",
          "1716: }",
          "",
          "[Removed Lines]",
          "1713:  unregister_pernet_gen_device(ipgre_net_id, &ipgre_net_ops);",
          "",
          "[Added Lines]",
          "1701:  unregister_pernet_device(&ipgre_net_ops);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
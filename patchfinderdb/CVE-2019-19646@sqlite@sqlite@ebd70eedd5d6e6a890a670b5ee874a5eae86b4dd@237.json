{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "855b5d144aaa7ff9e52741a039e53ffcaaac7d65",
      "candidate_info": {
        "commit_hash": "855b5d144aaa7ff9e52741a039e53ffcaaac7d65",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/855b5d144aaa7ff9e52741a039e53ffcaaac7d65",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c",
          "test/subquery2.test"
        ],
        "message": "Ensure that when an ephemeral cursor is reopened with a second invocation of to OP_OpenEphemeral, the sequence counter is reset and the cache marked as stale. Fix for [9cdc5c46].\n\nFossilOrigin-Name: 5fd20e09a522b62a529cf4d76fbdf0a09426f67ffa30430cac6b81ebf32ba43e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c",
          "test/subquery2.test||test/subquery2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1c58522e49cd91426bca7efccf0d99e0f2803dcd5991ae5d56166fc5510e4c62",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3755:     assert( pCx->isEphemeral );",
          "3756:     if( pCx->pBtx ){",
          "3757:       rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);",
          "3758:     }",
          "3759:   }else{",
          "3760:     pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);",
          "3761:     if( pCx==0 ) goto no_mem;",
          "3763:     pCx->isEphemeral = 1;",
          "3764:     rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,",
          "3765:                           BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5,",
          "",
          "[Removed Lines]",
          "3762:     pCx->nullRow = 1;",
          "",
          "[Added Lines]",
          "3756:     pCx->seqCount = 0;",
          "3757:     pCx->cacheStatus = CACHE_STALE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3795:     pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);",
          "3796:   }",
          "3797:   if( rc ) goto abort_due_to_error;",
          "3798:   break;",
          "3799: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3799:   pCx->nullRow = 1;",
          "",
          "---------------"
        ],
        "test/subquery2.test||test/subquery2.test": [
          "File: test/subquery2.test -> test/subquery2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "197:   }]",
          "198: }",
          "201: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200: #-------------------------------------------------------------------------",
          "201: # Test that ticket [9cdc5c46] is fixed.",
          "202: #",
          "203: reset_db",
          "204: do_execsql_test 5.0 {",
          "205:   CREATE TABLE t1(x);",
          "206:   INSERT INTO t1 VALUES('ALFKI');",
          "207:   INSERT INTO t1 VALUES('ANATR');",
          "209:   CREATE TABLE t2(y, z);",
          "210:   CREATE INDEX t2y ON t2 (y);",
          "211:   INSERT INTO t2 VALUES('ANATR', '1997-08-08 00:00:00');",
          "212:   INSERT INTO t2 VALUES('ALFKI', '1997-08-25 00:00:00');",
          "213: }",
          "214: do_execsql_test 5.1 {",
          "215:   SELECT ( SELECT y FROM t2 WHERE x = y ORDER BY y, z) FROM t1;",
          "216: } {ALFKI ANATR}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e20a894a34894eeb4eca0252d4ff25f99ac311e8",
      "candidate_info": {
        "commit_hash": "e20a894a34894eeb4eca0252d4ff25f99ac311e8",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e20a894a34894eeb4eca0252d4ff25f99ac311e8",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/parse.y",
          "test/altertab3.test"
        ],
        "message": "Handle renaming a column or table when the schema contains a (meaningless) index on the constant expression ('text' IN ()) or ('text' NOT IN()).\n\nFossilOrigin-Name: 567b13093956185b5d5e971b81ba4788fd9d26c03688f643b380f0f1c1a94da0",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/parse.y||src/parse.y",
          "test/altertab3.test||test/altertab3.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 94b58ab059cba9771e75f16d1460f313104a8fb879f9f8805725d362aa58cbcd",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "1176:       if( IN_RENAME_OBJECT==0 ){",
          "1177:         sqlite3ExprDelete(pParse->db, A);",
          "1178:         A = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[N],1);",
          "1179:       }",
          "1180:     }else if( Y->nExpr==1 ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1185:       }else{",
          "1186:         A = sqlite3PExpr(pParse, TK_UPLUS, A, 0);",
          "",
          "---------------"
        ],
        "test/altertab3.test||test/altertab3.test": [
          "File: test/altertab3.test -> test/altertab3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "175:   ALTER TABLE t1x RENAME TO t1;",
          "176: } {1 {error in trigger AFTER: no such column: d}}",
          "178: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "178: #-------------------------------------------------------------------------",
          "179: reset_db",
          "180: do_execsql_test 8.0 {",
          "181:   CREATE TABLE t0(c0);",
          "182:   CREATE INDEX i0 ON t0('1' IN ());",
          "183: }",
          "184: do_execsql_test 8.1 {",
          "185:   ALTER TABLE t0 RENAME TO t1;",
          "186:   SELECT sql FROM sqlite_master;",
          "187: } {",
          "188:   {CREATE TABLE \"t1\"(c0)}",
          "189:   {CREATE INDEX i0 ON \"t1\"('1' IN ())}",
          "190: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "427b96aedf422b1a8e906e47e8852033c70939c4",
      "candidate_info": {
        "commit_hash": "427b96aedf422b1a8e906e47e8852033c70939c4",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/427b96aedf422b1a8e906e47e8852033c70939c4",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/insert.c",
          "src/sqliteInt.h",
          "src/update.c"
        ],
        "message": "New testcase() macros.  Fix a problem with INSERT when the IPK is to the right of generated columns.\n\nFossilOrigin-Name: 412799fc5527aaca987e4e04b8a4f774dcdb70fb80e3a126dc3a26d48a66935c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/insert.c||src/insert.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/update.c||src/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ba123b8c201053d8f9387de38f3513b06f7721b28d79fab8489f96d336105117",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2207:   }",
          "2209: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "2211:     int ii;",
          "2212:     for(ii=0; ii<p->nCol; ii++){",
          "2213:       u32 colFlags = p->aCol[ii].colFlags;",
          "2215:         sqlite3ResolveSelfReference(pParse, p, NC_GenCol,",
          "2216:                                     p->aCol[ii].pDflt, 0);",
          "2217:       }",
          "",
          "[Removed Lines]",
          "2210:   if( p->tabFlags & (TF_HasVirtual|TF_HasStored) ){",
          "2214:       if( (colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL))!=0 ){",
          "",
          "[Added Lines]",
          "2210:   if( p->tabFlags & TF_HasGenerated ){",
          "2212:     testcase( p->tabFlags & TF_HasVirtual );",
          "2213:     testcase( p->tabFlags & TF_HasStored );",
          "2216:       if( (colFlags & COLFLAG_GENERATED)!=0 ){",
          "2217:         testcase( colFlags & COLFLAG_VIRTUAL );",
          "2218:         testcase( colFlags & COLFLAG_STORED );",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:   for(i=0; i<pTab->nCol; i++){",
          "224:     if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "225:       pTab->aCol[i].colFlags |= COLFLAG_NOTAVAIL;",
          "226:     }",
          "227:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225:       testcase( pTab->aCol[i].colflags & COLFLAG_VIRTUAL );",
          "226:       testcase( pTab->aCol[i].colflags & COLFLAG_STORED );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "855:   if( pColumn==0 && nColumn>0 ){",
          "856:     ipkColumn = pTab->iPKey;",
          "857:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "859: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "860:     if( pTab->tabFlags & TF_HasGenerated ){",
          "861:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "862:       testcase( pTab->tabFlags & TF_HasGenerated );",
          "863:       for(i=ipkColumn-1; i>=0; i--){",
          "864:         if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "865:           testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "866:           testcase( pTab->aCol[i].colFlags & COLFLAG_GENERATED );",
          "867:           ipkColumn--;",
          "868:         }",
          "869:       }",
          "870:     }",
          "871: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1074:       sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab);",
          "1075:     }",
          "1076: #endif",
          "",
          "[Removed Lines]",
          "1073:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "1088:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1089:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1090:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1143:       sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab);",
          "1144:     }",
          "1145: #endif",
          "",
          "[Removed Lines]",
          "1142:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "1159:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1160:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1161:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1486:     testcase( i!=sqlite3TableColumnToStorage(pTab, i) );",
          "1487:     testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "1488:     testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "1490:     iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;",
          "1491:     switch( onError ){",
          "1492:       case OE_Replace: {",
          "",
          "[Removed Lines]",
          "1489:     testcase( pTab->aCol[i].colFlags & COLFLAG_GENERATED );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2423:     if( (pDestCol->colFlags & COLFLAG_GENERATED)!=0 ){",
          "2424:       if( sqlite3ExprCompare(0, pSrcCol->pDflt, pDestCol->pDflt, -1)!=0 ){",
          "2426:       }",
          "2427:     }",
          "2428:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2443:         testcase( pDestCol->colflags & COLFLAG_VIRTUAL );",
          "2444:         testcase( pDestCol->colflags & COLFLAG_STORED );",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:           chngPk = 1;",
          "314:         }",
          "315: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "317:           sqlite3ErrorMsg(pParse,",
          "318:              \"cannot UPDATE generated column \\\"%s\\\"\",",
          "319:              pTab->aCol[j].zName);",
          "",
          "[Removed Lines]",
          "316:         else if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){",
          "",
          "[Added Lines]",
          "316:         else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){",
          "317:           testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "318:           testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "693:     }",
          "694:   }",
          "695: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "697:     sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "698:   }",
          "699: #endif",
          "",
          "[Removed Lines]",
          "696:   if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "698:   if( pTab->tabFlags & TF_HasGenerated ){",
          "699:     testcase( pTab->tabFlags & TF_HasVirtual );",
          "700:     testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:       }",
          "738:     }",
          "739: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "741:       sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "742:     }",
          "743: #endif",
          "",
          "[Removed Lines]",
          "740:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "744:     if( pTab->tabFlags & TF_HasGenerated ){",
          "745:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "746:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "47bcc34271435e376b57a8482e06803f4a7a6c4f",
      "candidate_info": {
        "commit_hash": "47bcc34271435e376b57a8482e06803f4a7a6c4f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/47bcc34271435e376b57a8482e06803f4a7a6c4f",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/window.c",
          "test/window1.test"
        ],
        "message": "Fix a potential NULL pointer dereference on a RENAME TABLE that references a VIEW with a logic error in a window function in the ORDER BY clause.\n\nFossilOrigin-Name: 0adb273f7e7671efb0e0a1619887e369500dfd2db7ef1b1e125c2414ea96e96f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/window.c||src/window.c",
          "test/window1.test||test/window1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 8f4a3750b7d272daf96831655ffee80d457875ee121fc4537008046b9a00d0e7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1246: void sqlite3WindowLink(Select *pSel, Window *pWin){",
          "1249:   ){",
          "1250:     pWin->pNextWin = pSel->pWin;",
          "1251:     if( pSel->pWin ){",
          "",
          "[Removed Lines]",
          "1247:   if( 0==pSel->pWin",
          "1248:    || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0)",
          "",
          "[Added Lines]",
          "1247:   if( pSel!=0",
          "1248:    && (0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0))",
          "",
          "---------------"
        ],
        "test/window1.test||test/window1.test": [
          "File: test/window1.test -> test/window1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1234:   );",
          "1235: } {1 {frame ending offset must be a non-negative integer}}",
          "1237: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1237: # 2019-11-16 chromium issue 1025467",
          "1238: db close",
          "1239: sqlite3 db :memory:",
          "1240: do_catchsql_test 32.10 {",
          "1241:   CREATE VIEW a AS SELECT NULL INTERSECT SELECT NULL ORDER BY s() OVER R;",
          "1242:   CREATE TABLE a0 AS SELECT 0;",
          "1243:   ALTER TABLE a0 RENAME TO S;",
          "1244: } {1 {error in view a: 1st ORDER BY term does not match any column in the result set}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "211a0857b9bfe094297a0004d0344dcb1d06492e",
      "candidate_info": {
        "commit_hash": "211a0857b9bfe094297a0004d0344dcb1d06492e",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/211a0857b9bfe094297a0004d0344dcb1d06492e",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbeaux.c",
          "src/window.c"
        ],
        "message": "Window functions that can abort should indicate this, so that if they are used in DML statement, a statement journal will be used.\n\nFossilOrigin-Name: 0ea05a0eb96acb860d8af2e788e29a5ae3b161e7892ab62f1ff2f3e722c0dcb6",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbeaux.c||src/vdbeaux.c",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 004f7d9bbeee049c22a7e1c82c6cc0ea79a237967de3ff57686acea3060d5f45",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "638:     if( opcode==OP_Destroy || opcode==OP_VUpdate || opcode==OP_VRename",
          "639:      || opcode==OP_VDestroy",
          "640:      || ((opcode==OP_Halt || opcode==OP_HaltIfNull)",
          "642:     ){",
          "643:       hasAbort = 1;",
          "644:       break;",
          "",
          "[Removed Lines]",
          "641:       && ((pOp->p1&0xff)==SQLITE_CONSTRAINT && pOp->p2==OE_Abort))",
          "",
          "[Added Lines]",
          "641:       && ((pOp->p1)!=SQLITE_OK && pOp->p2==OE_Abort))",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1075:   VdbeCoverageNeverNullIf(v, eCond==0);",
          "1076:   VdbeCoverageNeverNullIf(v, eCond==1);",
          "1077:   VdbeCoverageNeverNullIf(v, eCond==2);",
          "1078:   sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_ERROR, OE_Abort);",
          "1079:   sqlite3VdbeAppendP4(v, (void*)azErr[eCond], P4_STATIC);",
          "1080:   sqlite3ReleaseTempReg(pParse, regZero);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1078:   sqlite3MayAbort(pParse);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
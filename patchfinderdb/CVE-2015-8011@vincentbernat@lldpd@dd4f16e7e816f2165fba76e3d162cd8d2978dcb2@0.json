{
  "cve_id": "CVE-2015-8011",
  "cve_desc": "Buffer overflow in the lldp_decode function in daemon/protocols/lldp.c in lldpd before 0.8.0 allows remote attackers to cause a denial of service (daemon crash) and possibly execute arbitrary code via vectors involving large management addresses and TLV boundaries.",
  "repo": "vincentbernat/lldpd",
  "patch_hash": "dd4f16e7e816f2165fba76e3d162cd8d2978dcb2",
  "patch_info": {
    "commit_hash": "dd4f16e7e816f2165fba76e3d162cd8d2978dcb2",
    "repo": "vincentbernat/lldpd",
    "commit_url": "https://github.com/vincentbernat/lldpd/commit/dd4f16e7e816f2165fba76e3d162cd8d2978dcb2",
    "files": [
      "src/daemon/protocols/lldp.c"
    ],
    "message": "lldp: fix a buffer overflow when handling management address TLV\n\nWhen a remote device was advertising a too large management address\nwhile still respecting TLV boundaries, lldpd would crash due to a buffer\noverflow. However, the buffer being a static one, this buffer overflow\nis not exploitable if hardening was not disabled. This bug exists since\nversion 0.5.6.",
    "before_after_code_files": [
      "src/daemon/protocols/lldp.c||src/daemon/protocols/lldp.c"
    ]
  },
  "patch_diff": {
    "src/daemon/protocols/lldp.c||src/daemon/protocols/lldp.c": [
      "File: src/daemon/protocols/lldp.c -> src/daemon/protocols/lldp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "726:   case LLDP_TLV_MGMT_ADDR:",
      "727:    CHECK_TLV_SIZE(1, \"Management address\");",
      "728:    addr_str_length = PEEK_UINT8;",
      "729:    CHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");",
      "730:    PEEK_BYTES(addr_str_buffer, addr_str_length);",
      "731:    addr_length = addr_str_length - 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "729:    if (addr_str_length > sizeof(addr_str_buffer)) {",
      "730:     log_warnx(\"lldp\", \"too large management address on %s\",",
      "731:         hardware->h_ifname);",
      "732:     goto malformed;",
      "733:    }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "752:    TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);",
      "753:    break;",
      "754:   case LLDP_TLV_ORG:",
      "756:    PEEK_BYTES(orgid, sizeof(orgid));",
      "757:    tlv_subtype = PEEK_UINT8;",
      "758:    if (memcmp(dot1, orgid, sizeof(orgid)) == 0) {",
      "",
      "[Removed Lines]",
      "755:    CHECK_TLV_SIZE(4, \"Organisational\");",
      "",
      "[Added Lines]",
      "760:    CHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3779e6ccb3522b023461a5e0536be804b354a35a",
      "candidate_info": {
        "commit_hash": "3779e6ccb3522b023461a5e0536be804b354a35a",
        "repo": "vincentbernat/lldpd",
        "commit_url": "https://github.com/vincentbernat/lldpd/commit/3779e6ccb3522b023461a5e0536be804b354a35a",
        "files": [
          "src/daemon/protocols/lldp.c"
        ],
        "message": "lldp: fix a buffer overflow when handling management address TLV\n\nWhen a remote device was advertising a too large management address\nwhile still respecting TLV boundaries, lldpd would crash due to a buffer\noverflow. However, the buffer being a static one, this buffer overflow\nis not exploitable if hardening was not disabled. This bug exists since\nversion 0.5.6.",
        "before_after_code_files": [
          "src/daemon/protocols/lldp.c||src/daemon/protocols/lldp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "src/daemon/protocols/lldp.c||src/daemon/protocols/lldp.c"
          ],
          "candidate": [
            "src/daemon/protocols/lldp.c||src/daemon/protocols/lldp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/daemon/protocols/lldp.c||src/daemon/protocols/lldp.c": [
          "File: src/daemon/protocols/lldp.c -> src/daemon/protocols/lldp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "726:   case LLDP_TLV_MGMT_ADDR:",
          "727:    CHECK_TLV_SIZE(1, \"Management address\");",
          "728:    addr_str_length = PEEK_UINT8;",
          "729:    CHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");",
          "730:    PEEK_BYTES(addr_str_buffer, addr_str_length);",
          "731:    addr_length = addr_str_length - 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "729:    if (addr_str_length > sizeof(addr_str_buffer)) {",
          "730:     log_warnx(\"lldp\", \"too large management address on %s\",",
          "731:         hardware->h_ifname);",
          "732:     goto malformed;",
          "733:    }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "752:    TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);",
          "753:    break;",
          "754:   case LLDP_TLV_ORG:",
          "756:    PEEK_BYTES(orgid, sizeof(orgid));",
          "757:    tlv_subtype = PEEK_UINT8;",
          "758:    if (memcmp(dot1, orgid, sizeof(orgid)) == 0) {",
          "",
          "[Removed Lines]",
          "755:    CHECK_TLV_SIZE(4, \"Organisational\");",
          "",
          "[Added Lines]",
          "760:    CHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
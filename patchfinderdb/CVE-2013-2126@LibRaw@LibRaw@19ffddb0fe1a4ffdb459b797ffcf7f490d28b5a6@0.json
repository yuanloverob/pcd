{
  "cve_id": "CVE-2013-2126",
  "cve_desc": "Multiple double free vulnerabilities in the LibRaw::unpack function in libraw_cxx.cpp in LibRaw before 0.15.2 allow context-dependent attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a malformed full-color (1) Foveon or (2) sRAW image file.",
  "repo": "LibRaw/LibRaw",
  "patch_hash": "19ffddb0fe1a4ffdb459b797ffcf7f490d28b5a6",
  "patch_info": {
    "commit_hash": "19ffddb0fe1a4ffdb459b797ffcf7f490d28b5a6",
    "repo": "LibRaw/LibRaw",
    "commit_url": "https://github.com/LibRaw/LibRaw/commit/19ffddb0fe1a4ffdb459b797ffcf7f490d28b5a6",
    "files": [
      "src/libraw_cxx.cpp"
    ],
    "message": "prevent double-free() on broken full-color images error handling",
    "before_after_code_files": [
      "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
    ]
  },
  "patch_diff": {
    "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
      "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "1144:                 IO.shrink = 0;",
      "1145:     S.raw_pitch = S.width*8;",
      "1149:               }",
      "1150:             ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
      "",
      "[Removed Lines]",
      "1147:                 imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
      "1148:                 imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
      "",
      "[Added Lines]",
      "1147:                 imgdata.rawdata.raw_alloc = 0;",
      "1148:                 imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1155:             (this->*load_raw)();",
      "1156:    if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
      "1157:     C.maximum = m_save;",
      "1158:           }",
      "1160:         if(imgdata.rawdata.raw_image)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1158:    if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
      "1159:    {",
      "1161:     imgdata.rawdata.raw_alloc = imgdata.image;",
      "1162:     imgdata.image = 0;",
      "1163:    }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1da24b1930f71514645558f5a64796f4a7ad95d0",
      "candidate_info": {
        "commit_hash": "1da24b1930f71514645558f5a64796f4a7ad95d0",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/1da24b1930f71514645558f5a64796f4a7ad95d0",
        "files": [
          "Changelog.rus",
          "Changelog.txt",
          "Makefile.devel",
          "Makefile.dist",
          "README.RawSpeed.rus",
          "README.RawSpeed.txt",
          "RawSpeed/rawspeed.cpucount-unix.patch",
          "RawSpeed/rawspeed.qmake-pro-files.patch",
          "RawSpeed/rawspeed.win32-dll.patch",
          "RawSpeed/rawspeed_xmldata.cpp",
          "libraw/libraw.h",
          "libraw/libraw_version.h",
          "src/libraw_cxx.cpp",
          "src/libraw_datastream.cpp"
        ],
        "message": "0.15 Alpha4",
        "before_after_code_files": [
          "Changelog.rus||Changelog.rus",
          "Makefile.devel||Makefile.devel",
          "Makefile.dist||Makefile.dist",
          "README.RawSpeed.rus||README.RawSpeed.rus",
          "RawSpeed/rawspeed_xmldata.cpp||RawSpeed/rawspeed_xmldata.cpp",
          "libraw/libraw.h||libraw/libraw.h",
          "libraw/libraw_version.h||libraw/libraw_version.h",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp",
          "src/libraw_datastream.cpp||src/libraw_datastream.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "Changelog.rus||Changelog.rus": [
          "File: Changelog.rus -> Changelog.rus",
          "--- Hunk 1 ---",
          "[Context before]",
          "3:      - \u0411\u044b\u0441\u0442\u0440\u044b\u0439 \u0434\u0435\u043a\u043e\u0434\u0435\u0440 LJPEG",
          "4:      - OpenMP \u0432 AHD/PPG-\u0438\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0442\u043e\u0440\u0430\u0445 \u0438 \u0432 Wavelet Denoise",
          "",
          "[Removed Lines]",
          "1: \ufeff2012-09-04 Alex Tutubalin <lexa@lexa.ru>",
          "",
          "[Added Lines]",
          "1: \ufeff2012-09-17  Alex Tutubalin <lexa@lexa.ru>",
          "4:      \u0420\u0430\u0441\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 (LibRaw::unpack()) \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0445 \u0444\u043e\u0440\u043c\u0430\u0442\u043e\u0432 \u0441\u0442\u0430\u043b\u043e \u0432 1.5-3",
          "5:      \u0440\u0430\u0437\u0430 \u0431\u044b\u0441\u0442\u0440\u0435\u0435.",
          "7:     = \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f API:",
          "8:      -- imgdata.params.use_rawspeed \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442/\u0432\u044b\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 RawSpeed",
          "9:   (\u043f\u043e-\u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e - \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u043e!)",
          "10:      -- LibRaw::set_rawspeed_camerafile(char *path_to_cameras_xml) -",
          "11:       \u0447\u0438\u0442\u0430\u0435\u0442 XML-\u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u0430\u043c\u0435\u0440 RawSpeed. \u0415\u0441\u043b\u0438 \u043d\u0435 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u044d\u0442\u0443 \u0444\u0443\u043d\u043a\u0446\u0438\u044e,",
          "12:  \u0442\u043e \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043e \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435, \u0432\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0432 LibRaw",
          "13:      -- \u041f\u043e\u0442\u043e\u043a\u0438 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430 LibRaw (Libraw*datastream) \u0434\u043e\u043b\u0436\u043d\u044b \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0442\u044c",
          "14:         \u043c\u0435\u0442\u043e\u0434 size(), \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u043e\u043b\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 \u0444\u0430\u0439\u043b\u0430.",
          "15:  \u042d\u0442\u043e\u0442 \u043c\u0435\u0442\u043e\u0434 \u0438\u043c\u043f\u043b\u0435\u043c\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043f\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0445 LibRaw*datastream.",
          "16:      -- \u041d\u043e\u0432\u043e\u0435 \u043f\u043e\u043b\u0435 \u0434\u0430\u043d\u043d\u044b\u0445: imgdata.sizes.raw_pitch - \u0448\u0430\u0433 \u0441\u0442\u0440\u043e\u043a (\u0432 \u043f\u0438\u043a\u0441\u0435\u043b\u044f\u0445)",
          "17:       \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435 imgdata.rawdata.raw_image.",
          "18:  \u0415\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0438\u0437 \u044d\u0442\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e, \u0432\u0430\u043c",
          "19:  \u043d\u0443\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c",
          "20:         raw_image[row*raw_pitch+col] \u0432\u043c\u0435\u0441\u0442\u043e [row*raw_width+col]",
          "22:     = \u041f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 RawSpeed \u0430\u043b\u043b\u043e\u0446\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0431\u0443\u0444\u0435\u0440, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439",
          "23:       RAW-\u0444\u0430\u0439\u043b \u0446\u0435\u043b\u0438\u043a\u043e\u043c. \u0421\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438 - \u0432\u044b\u0448\u0435.",
          "25:     = \u041f\u0440\u043e\u0447\u0438\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f:",
          "26:      -- dcraw_emu: \u041e\u043f\u0446\u0438\u044f \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 -disars \u0432\u044b\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435",
          "27:         RawSpeed",
          "28:      -- postprocessing_benchmark: \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 -c \u0434\u043b\u044f \u0432\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f RawSpeed",
          "30:     = \u0421\u0431\u043e\u0440\u043a\u0430",
          "31:      - \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u0435\u0444\u0430\u0439\u043d -DUSE_RAWSPEED \u0447\u0442\u043e\u0431\u044b \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 RawSpeed",
          "32:        \u043f\u0440\u0438 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0446\u0438\u0438.",
          "33:        \u0411\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 RawSpeed \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e, \u0441\u043c. \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0432",
          "34:        README.RawSpeed.rus",
          "35:      - \u0438\u0437\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0434\u0435\u0444\u0430\u0439\u043d -DNOSONY_RAWSPEED \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u043f\u0440\u0435\u0442\u0438\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u0444\u0430\u0439\u043b\u043e\u0432",
          "36:        \u0441 \u043a\u0430\u043c\u0435\u0440 Sony (RawSpeed \u0440\u0430\u0441\u043f\u0430\u043a\u043e\u0432\u044b\u0432\u0430\u0435\u0442 \u0438\u0445 \u0438\u043d\u0430\u0447\u0435, \u0445\u043e\u0442\u044f \u043d\u0430 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u0449\u0435\u043c",
          "37:        \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0438 \u0432\u0438\u0434\u0438\u043c\u044b\u0445 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439 \u043d\u0435\u0442)",
          "39:      - ./configure \u043f\u043e\u043a\u0430 \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0430\u043d\u043e, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 Makefile.dist \u043d\u0430 Unix/Mac \u0438",
          "40:        Makefile.msvc \u043d\u0430 Win32",
          "42:      - (Unix) \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 RAWSPEED_XMLDATA=../path/to/cameras.xml \u0432",
          "43:        Makefile.dist \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u0442 \u043a \u043f\u0435\u0440\u0435\u0441\u0431\u043e\u0440\u043a\u0435 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0433\u043e \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f",
          "44:        cameras.xml",
          "46:     = TODO:",
          "47:         -- \u0420\u0430\u0441\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u0435-\u0431\u0430\u0439\u0435\u0440\u043e\u0432\u0441\u043a\u0438\u0445 RAW \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 RawSpeed",
          "48:         -- \u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0434\u0432\u043e\u0439\u043d\u043e\u0439 \u0431\u0443\u0444\u0435\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438",
          "49:     LibRaw_buffer_datstream",
          "51:   \u041f\u0440\u043e\u0447\u0438\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f",
          "54:      \u0432\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u043e. \u0427\u0442\u043e\u0431\u044b \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u044c - \u0432\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c LibJPEG v8 \u0438",
          "55:      \u0443\u043a\u0430\u0437\u0430\u0442\u044c -DUSE_JPEG8 \u043f\u0440\u0438 \u0441\u0431\u043e\u0440\u043a\u0435 LibRaw",
          "57:      \u0434\u043b\u044f \u043e\u0431\u043b\u0435\u0433\u0447\u0435\u043d\u0438\u044f \u0438\u0445 \u0443\u0441\u043a\u043e\u0440\u0435\u043d\u0438\u044f \u0432 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0445 \u043a\u043b\u0430\u0441\u0441\u0430\u0445.",
          "62:      \u0447\u0435\u0440\u043d\u043e\u0433\u043e \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043a\u0430\u043a \u043e\u0436\u0438\u0434\u0430\u0435\u0442\u0441\u044f",
          "65:      \u043d\u0443\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u0442\u044c",
          "69: 2012-09-04 Alex Tutubalin <lexa@lexa.ru>",
          "",
          "---------------"
        ],
        "Makefile.devel||Makefile.devel": [
          "File: Makefile.devel -> Makefile.devel",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: CC=gcc",
          "6: CXX=g++",
          "21: # LCMS support",
          "",
          "[Removed Lines]",
          "8: #CFLAGS=-O4 -march=core2 -march=core2 -mtune=core2 -fomit-frame-pointer -ffast-math -fstrict-aliasing -funsafe-math-optimizations -mfpmath=sse -msse2 -I.",
          "9: #CFLAGS=-g -Wall -I.",
          "10: #CFLAGS=-g -I. -Wall",
          "11: CFLAGS= -O4 -g -I. -Wall -Wno-long-long -Wno-conversion -Wno-sign-compare -Wno-overflow -fpack-struct=8 -fopenmp",
          "12: #CFLAGS=-g -I. -Wall -Wno-long-long -Wno-conversion -Wno-sign-compare -fpack-struct=8 -fopenmp",
          "14: # GCC 4.6 section",
          "15: #CC=gcc46",
          "16: #CXX=g++46",
          "17: #CFLAGS= -O4 -g -march=corei7 -mtune=corei7 -I. -pedantic  -Wno-long-long -Wno-overflow -msse4.2 -mfpmath=sse  -fopenmp",
          "18: #CFLAGS= -O -I. -pedantic  -Wno-long-long -Wno-overflow -g",
          "",
          "[Added Lines]",
          "8: # RawSpeed Support",
          "9: CFLAGS+=-DUSE_RAWSPEED -I../RawSpeed -I/usr/local/include/libxml2",
          "10: LDADD+=-L../RawSpeed/RawSpeed -lrawspeed -L/usr/local/include -ljpeg -lxml2",
          "11: RAWSPEED_DATA=../RawSpeed/data/cameras.xml",
          "14: CC=gcc46",
          "15: CXX=g++46",
          "16: CFLAGS+= -O4 -g -march=corei7 -mtune=corei7 -I. -pedantic  -Wno-long-long -Wno-overflow -msse4.2 -mfpmath=sse  -fopenmp",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: all_samples: bin/raw-identify bin/simple_dcraw  bin/dcraw_emu bin/dcraw_half bin/half_mt bin/mem_image \\",
          "55:         bin/unprocessed_raw bin/4channels bin/multirender_test bin/postprocessing_benchmark",
          "57: ## Demosaic Pack(s)",
          "59: object/demosaic_packs.o: internal/demosaic_packs.cpp ${LR_INCLUDES}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: ## RawSpeed xml file",
          "56: RawSpeed/rawspeed_xmldata.cpp: ${RAWSPEED_DATA}",
          "57:  ./rsxml2c.sh ${RAWSPEED_DATA} > RawSpeed/rawspeed_xmldata.cpp",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "118: object/dcraw_fileio.o: internal/dcraw_fileio.cpp ${LR_INCLUDES}",
          "119:  $(CXX) -c -DLIBRAW_NOTHREADS ${CFLAGS} ${LCMS_DEF} -o object/dcraw_fileio.o internal/dcraw_fileio.cpp",
          "122:  $(CXX) -c -DLIBRAW_NOTHREADS ${LCMS_DEF} ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp",
          "124: object/libraw_datastream.o: src/libraw_datastream.cpp ${LR_INCLUDES}",
          "",
          "[Removed Lines]",
          "121: object/libraw_cxx.o: src/libraw_cxx.cpp ${LR_INCLUDES}",
          "",
          "[Added Lines]",
          "123: object/libraw_cxx.o: src/libraw_cxx.cpp ${LR_INCLUDES} RawSpeed/rawspeed_xmldata.cpp",
          "",
          "---------------"
        ],
        "Makefile.dist||Makefile.dist": [
          "File: Makefile.dist -> Makefile.dist",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: # OpenMP support",
          "6: #CFLAGS+=-fopenmp",
          "8: # Jasper support for RedCine",
          "9: CFLAGS+=-DUSE_JASPER -I/usr/local/include",
          "10: LDADD+=-L/usr/local/lib -ljasper",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: # RawSpeed Support",
          "9: CFLAGS+=-pthread -DUSE_RAWSPEED -I../RawSpeed -I/usr/local/include/libxml2",
          "10: LDADD+=-L../RawSpeed/RawSpeed -lrawspeed -L/usr/local/include -ljpeg -lxml2",
          "11: RAWSPEED_DATA=../RawSpeed/data/cameras.xml",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:  @if [ -d /usr/local/bin ] ; then cp bin/[a-z]* /usr/local/bin/ ; else echo 'no /usr/local/bin' ; fi",
          "51: #binaries",
          "53: bin/raw-identify: lib/libraw.a samples/raw-identify.cpp",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: ## RawSpeed xml file",
          "59: RawSpeed/rawspeed_xmldata.cpp: ${RAWSPEED_DATA}",
          "60:  ./rsxml2c.sh ${RAWSPEED_DATA} > RawSpeed/rawspeed_xmldata.cpp",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "91: object/dcraw_fileio.o: internal/dcraw_fileio.cpp",
          "92:  g++ -c -DLIBRAW_NOTHREADS ${CFLAGS}  -o object/dcraw_fileio.o internal/dcraw_fileio.cpp",
          "95:  g++ -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp",
          "97: object/libraw_datastream.o: src/libraw_datastream.cpp",
          "",
          "[Removed Lines]",
          "94: object/libraw_cxx.o: src/libraw_cxx.cpp",
          "",
          "[Added Lines]",
          "105: object/libraw_cxx.o: src/libraw_cxx.cpp RawSpeed/rawspeed_xmldata.cpp",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "126: object/dcraw_fileio_mt.o: internal/dcraw_fileio.cpp",
          "127:  g++ -c -pthread  ${CFLAGS} -o object/dcraw_fileio_mt.o internal/dcraw_fileio.cpp",
          "130:  g++ -c   -pthread ${CFLAGS} -o object/libraw_cxx_mt.o src/libraw_cxx.cpp",
          "132: object/libraw_datastream_mt.o: src/libraw_datastream.cpp",
          "",
          "[Removed Lines]",
          "129: object/libraw_cxx_mt.o: src/libraw_cxx.cpp",
          "",
          "[Added Lines]",
          "140: object/libraw_cxx_mt.o: src/libraw_cxx.cpp RawSpeed/rawspeed_xmldata.cpp",
          "",
          "---------------"
        ],
        "README.RawSpeed.rus||README.RawSpeed.rus": [
          "File: README.RawSpeed.rus -> README.RawSpeed.rus",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ======================= \u0421\u0431\u043e\u0440\u043a\u0430LibRaw \u0441 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u043e\u0439 RawSpeed ==================",
          "3: 1) \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f:",
          "5: \u0414\u043b\u044f \u0441\u0431\u043e\u0440\u043a\u0438 RawSpeed \u0432 \u0432\u0430\u0448\u0435\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u044b \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438",
          "6: libxml2, iconv \u0438 LibJPEG",
          "8: 2) \u0421\u0431\u043e\u0440\u043a\u0430 RawSpeed",
          "9:   -- \u0421\u0431\u043e\u0440\u043a\u0430 \u043e\u043f\u0438\u0441\u0430\u043d\u0430 \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435 http://rawstudio.org/blog/?p=800",
          "11:   -- Win32: \u043f\u043e\u043c\u0438\u043c\u043e \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0445 \u0432\u044b\u0448\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a, \u0432\u0430\u043c \u043f\u043e\u043d\u0430\u0434\u043e\u0431\u0438\u0442\u0441\u044f \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430",
          "12:      POSIX Threads for Win32 (http://sources.redhat.com/pthreads-win32/)",
          "14:   -- \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c .pro-\u0444\u0430\u0439\u043b\u044b \u0434\u043b\u044f qmake, \u043f\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0435 \u0441 LibRaw",
          "15:      (RawSpeed/rawspeed.qmake-pro-files.patch)",
          "16:      \u041f\u043e\u043f\u0440\u0430\u0432\u044c\u0442\u0435 \u043f\u0443\u0442\u0438 \u0434\u043e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a \u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441",
          "17:      \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430\u043c\u0438 \u0432\u0430\u0448\u0435\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b.",
          "19:   -- Win32: \u0414\u043b\u044f \u0441\u0431\u043e\u0440\u043a\u0438 RawSpeed \u043a\u0430\u043a .DLL \u0432\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435",
          "20:      __declspec(..) \u043a\u043e \u0432\u0441\u0435\u043c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u043c \u043a\u043b\u0430\u0441\u0441\u0430\u043c.",
          "21:      \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043f\u0430\u0442\u0447, \u043f\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0439 \u0441 LibRaw",
          "22:      (RawSpeed/rawspeed.win32-dll.patch)",
          "24:   -- Unix: \u0432\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e rawspeed_get_number_of_processor_cores()",
          "25:      \u0414\u043b\u044f \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u0430 Unix-\u0441\u0438\u0441\u0442\u0435\u043c \u043f\u043e\u0434\u043e\u0439\u0434\u0435\u0442 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0447\u0435\u0440\u0435\u0437 \u0432\u044b\u0437\u043e\u0432 sysconf().",
          "26:      \u0412 \u0441\u043e\u0441\u0442\u0430\u0432\u0435 LibRaw \u0435\u0441\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u043f\u0430\u0442\u0447",
          "27:      (RawSpeed/rawspeed.cpucount-unix.patch)",
          "29: 3) \u0421\u0431\u043e\u0440\u043a\u0430 LibRaw \u0441 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u043e\u0439 RawSpeed",
          "31:    Win32:",
          "32:      --\u0420\u0430\u0441\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u0442\u0440\u043e\u0447\u043a\u0438 CFLAGS_RAWSPEED \u0438 LDFLAGS_RAWSPEED \u0432",
          "33:        Makefile.msvc. \u041f\u043e\u043f\u0440\u0430\u0432\u044c\u0442\u0435 \u0432 \u043d\u0438\u0445 \u043f\u0443\u0442\u0438 \u043a \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430\u043c \u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u043c",
          "34:        \u0444\u0430\u0439\u043b\u0430\u043c, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u043d\u0443\u0436\u043d\u043e.",
          "35:      -- \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 nmake -f Makefile.msvc",
          "37:    Unix/MacOS:",
          "38:      -- \u0420\u0430\u0441\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 CFLAGS/LDADD \u0432 \u0441\u0435\u043a\u0446\u0438\u0438 RawSpeed \u0432 \u0444\u0430\u0439\u043b\u0435",
          "39:         Makefile.dist",
          "40:      -- \u0420\u0430\u0441\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u0442\u0440\u043e\u0447\u043a\u0443 RAWSPEED_DATA (\u043e\u043d\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043d\u0430",
          "41:         \u0444\u0430\u0439\u043b cameras.xml \u0438\u0437 \u0434\u0438\u0441\u0442\u0440\u0438\u0431\u0443\u0442\u0438\u0432\u0430 RawSpeed), \u0435\u0441\u043b\u0438 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c",
          "42:  \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0435 \u0432 LibRaw \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u0430\u043c\u0435\u0440 RawSpeed",
          "43:      -- \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 make -f Makefile.dist",
          "45:    \u041e\u043f\u0446\u0438\u0438 \u0441\u0431\u043e\u0440\u043a\u0438:",
          "46:     -- \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0434\u0435\u0444\u0430\u0439\u043d -DNOSONY_RAWSPEED \u0435\u0441\u043b\u0438 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0437\u0430\u043f\u0440\u0435\u0442\u0438\u0442\u044c",
          "47:        \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u0444\u0430\u0439\u043b\u043e\u0432 \u0441 \u043a\u0430\u043c\u0435\u0440 Sony \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e RawSpeed (\u044d\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043d\u0443\u0436\u043d\u043e,",
          "48:        \u0435\u0441\u043b\u0438 \u0432\u044b \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442\u0435 \u0441 RAW-\u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0442.\u043a. \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0440\u0430\u0441\u043f\u0430\u043a\u043e\u0432\u043a\u0438",
          "49:        LibRaw \u0438 RawSpeed \u043e\u0442\u043b\u0438\u0447\u0430\u0435\u0442\u0441\u044f. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u043f\u043e\u0441\u0442\u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0438\u043d\u0433\u0430 \u043f\u0440\u0438 \u044d\u0442\u043e\u043c -",
          "50:        \u043d\u0435 \u043e\u0442\u043b\u0438\u0447\u0430\u044e\u0442\u0441\u044f)",
          "52: 4) \u0421\u0431\u043e\u0440\u043a\u0430 \u0432\u0430\u0448\u0438\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u0441 LibRaw+RawSpeed",
          "54:    -- \u0421\u043e\u0431\u0438\u0440\u0430\u0439\u0442\u0435 \u043a\u0430\u043a \u043e\u0431\u044b\u0447\u043d\u043e, \u043d\u0438\u043a\u0430\u043a\u0438\u0445 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439 \u0432 \u0432\u0430\u0448\u0438\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u0445",
          "55:     \u043d\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f, \u0435\u0441\u043b\u0438 \u0432\u044b \u043d\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442\u0435 \u0441 raw-\u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e.",
          "56:     \u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0435 \u043f\u0443\u0442\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 (open_file/unpack/dcraw_process \u0438",
          "57:     open_file/unpack/raw2image) \u043f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u043c\u044b \u0441 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u043c\u0438 \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.",
          "59:    -- \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u044b\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 RawSpeed \u043d\u0430 \u0440\u0430\u043d\u0442\u0430\u0439\u043c\u0435, \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0432",
          "60:       imgdata.params.use_rawspeed = 0.",
          "62:    -- \u0412\u0430\u0448\u0435\u043c\u0443 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044e \u043f\u043e\u0442\u0440\u0435\u0431\u0443\u044e\u0442\u0441\u044f \u0432\u0441\u0435 \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u043c\u044b\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438/DLL,",
          "63:      \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438 \u0441\u0431\u043e\u0440\u043a\u0435 (iconv, LibJPEG, posix threads \u043d\u0430 Win32).",
          "",
          "---------------"
        ],
        "RawSpeed/rawspeed_xmldata.cpp||RawSpeed/rawspeed_xmldata.cpp": [
          "File: RawSpeed/rawspeed_xmldata.cpp -> RawSpeed/rawspeed_xmldata.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: \"  <Alias>Canon EOS 350D</Alias>\\n\",",
          "111: \" </Aliases>\\n\",",
          "112: \"\\t</Camera>\\n\",",
          "114: \"\\t\\t<CFA width=\\\"2\\\" height=\\\"2\\\">\\n\",",
          "115: \"\\t\\t\\t<Color x=\\\"0\\\" y=\\\"0\\\">RED</Color>\\n\",",
          "116: \"\\t\\t\\t<Color x=\\\"1\\\" y=\\\"0\\\">GREEN</Color>\\n\",",
          "",
          "[Removed Lines]",
          "113: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 40D\\\" decoder_version=\\\"1\\\">\\n\",",
          "",
          "[Added Lines]",
          "113: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 40D\\\" decoder_version=\\\"2\\\">\\n\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 40D\\\" mode=\\\"sRaw2\\\">\\n\",",
          "131: \"\\t\\t<Crop x=\\\"0\\\" y=\\\"0\\\" width=\\\"1944\\\" height=\\\"1296\\\"/>\\n\",",
          "132: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"65535\\\"/>\\n\",",
          "133: \"\\t</Camera>\\n\",",
          "134: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 450D\\\">\\n\",",
          "135: \"\\t\\t<CFA width=\\\"2\\\" height=\\\"2\\\">\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: \"  <Hints>\\n\",",
          "134: \"   <Hint name=\\\"sraw_40d\\\" value=\\\"\\\"/>\\n\",",
          "135: \"  </Hints>\\n\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "303: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"57200\\\" iso_list=\\\"160 320 640 1250\\\"/>\\n\",",
          "304: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"64948\\\"/>\\n\",",
          "305: \"\\t</Camera>\\n\",",
          "307: \"\\t\\t<CFA width=\\\"2\\\" height=\\\"2\\\">\\n\",",
          "308: \"\\t\\t\\t<Color x=\\\"0\\\" y=\\\"0\\\">RED</Color>\\n\",",
          "309: \"\\t\\t\\t<Color x=\\\"1\\\" y=\\\"0\\\">GREEN</Color>\\n\",",
          "",
          "[Removed Lines]",
          "306: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 5D Mark III\\\" decoder_version=\\\"1\\\">\\n\",",
          "",
          "[Added Lines]",
          "309: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 5D Mark III\\\" decoder_version=\\\"2\\\">\\n\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "316: \"\\t\\t<Vertical x=\\\"0\\\" width=\\\"120\\\"/>\\n\",",
          "317: \"\\t\\t<Horizontal y=\\\"2\\\" height=\\\"78\\\"/>\\n\",",
          "318: \"\\t</BlackAreas>\\n\",",
          "322: \"\\t</Camera>\\n\",",
          "323: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 5D Mark III\\\" mode=\\\"sRaw1\\\">\\n\",",
          "324: \"\\t\\t<Crop x=\\\"0\\\" y=\\\"0\\\" width=\\\"0\\\" height=\\\"0\\\"/>\\n\",",
          "326: \"\\t</Camera>\\n\",",
          "327: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 5D Mark III\\\" mode=\\\"sRaw2\\\">\\n\",",
          "328: \"\\t\\t<Crop x=\\\"0\\\" y=\\\"0\\\" width=\\\"0\\\" height=\\\"0\\\"/>\\n\",",
          "330: \"\\t</Camera>\\n\",",
          "331: \"\\t<Camera make=\\\"Canon\\\" model=\\\"Canon EOS 7D\\\" decoder_version=\\\"1\\\">\\n\",",
          "332: \"\\t\\t<CFA width=\\\"2\\\" height=\\\"2\\\">\\n\",",
          "",
          "[Removed Lines]",
          "319: \"  <Hints>\\n\",",
          "320: \"   <Hint name=\\\"sraw_new\\\" value=\\\"\\\"/>\\n\",",
          "321: \"  </Hints>\\n\",",
          "325: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"65535\\\"/>\\n\",",
          "329: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"65535\\\"/>\\n\",",
          "",
          "[Added Lines]",
          "325: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"48664\\\"/>\\n\",",
          "326: \"\\t\\t<Hints>\\n\",",
          "327: \"\\t\\t\\t<Hint name=\\\"sraw_new\\\" value=\\\"\\\"/>\\n\",",
          "328: \"\\t\\t\\t<Hint name=\\\"invert_sraw_wb\\\" value=\\\"\\\"/>\\n\",",
          "329: \"\\t\\t</Hints>\\n\",",
          "333: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"48664\\\"/>\\n\",",
          "334: \"\\t\\t<Hints>\\n\",",
          "335: \"\\t\\t\\t<Hint name=\\\"sraw_new\\\" value=\\\"\\\"/>\\n\",",
          "336: \"\\t\\t\\t<Hint name=\\\"invert_sraw_wb\\\" value=\\\"\\\"/>\\n\",",
          "337: \"\\t\\t</Hints>\\n\",",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1940: \"\\t\\t<Crop x=\\\"0\\\" y=\\\"0\\\" width=\\\"3900\\\" height=\\\"2616\\\"/>\\n\",",
          "1941: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"4095\\\"/>\\n\",",
          "1942: \"\\t</Camera>\\n\",",
          "1943: \"\\t<Camera make=\\\"SAMSUNG\\\" model=\\\"EX1\\\">\\n\",",
          "1944: \"\\t\\t<CFA width=\\\"2\\\" height=\\\"2\\\">\\n\",",
          "1945: \"\\t\\t\\t<Color x=\\\"0\\\" y=\\\"0\\\">RED</Color><Color x=\\\"1\\\" y=\\\"0\\\">GREEN</Color>\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1951: \"\\t<Camera make=\\\"SAMSUNG\\\" model=\\\"EX2F\\\">\\n\",",
          "1952: \"\\t\\t<CFA width=\\\"2\\\" height=\\\"2\\\">\\n\",",
          "1953: \"\\t\\t\\t<Color x=\\\"0\\\" y=\\\"0\\\">RED</Color><Color x=\\\"1\\\" y=\\\"0\\\">GREEN</Color>\\n\",",
          "1954: \"\\t\\t\\t<Color x=\\\"0\\\" y=\\\"1\\\">GREEN</Color><Color x=\\\"1\\\" y=\\\"1\\\">BLUE</Color>\\n\",",
          "1955: \"\\t\\t</CFA>\\n\",",
          "1956: \"\\t\\t<Crop x=\\\"22\\\" y=\\\"12\\\" width=\\\"-148\\\" height=\\\"-18\\\"/>\\n\",",
          "1957: \"\\t\\t<Sensor black=\\\"0\\\" white=\\\"4095\\\"/>\\n\",",
          "1958: \"\\t</Camera>\\n\",",
          "",
          "---------------"
        ],
        "libraw/libraw.h||libraw/libraw.h": [
          "File: libraw/libraw.h -> libraw/libraw.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:     int                         wf_remove_banding();",
          "162: protected:",
          "",
          "[Removed Lines]",
          "157:     void phase_one_subtract_black(ushort *src, ushort *dest);",
          "158:     void        phase_one_correct();",
          "159:  int set_rawspeed_camerafile(char *filename);",
          "",
          "[Added Lines]",
          "157:   void phase_one_subtract_black(ushort *src, ushort *dest);",
          "158:   void        phase_one_correct();",
          "159:   int set_rawspeed_camerafile(char *filename);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:     int         flip_index (int row, int col);",
          "271:     void        gamma_curve (double pwr, double ts, int mode, int imax);",
          "279: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "274:  void  *_rawspeed_camerameta;",
          "275:  void     *_rawspeed_decoder;",
          "276:  void  fix_after_rawspeed();",
          "",
          "[Added Lines]",
          "274:   void  *_rawspeed_camerameta;",
          "275:   void     *_rawspeed_decoder;",
          "276:   void  fix_after_rawspeed();",
          "",
          "---------------"
        ],
        "libraw/libraw_version.h||libraw/libraw_version.h": [
          "File: libraw/libraw_version.h -> libraw/libraw_version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #define LIBRAW_MAJOR_VERSION  0",
          "27: #define LIBRAW_MINOR_VERSION  15",
          "28: #define LIBRAW_PATCH_VERSION  0",
          "32: #define LIBRAW_SHLIB_REVISION  0",
          "33: #define LIBRAW_SHLIB_AGE      0",
          "",
          "[Removed Lines]",
          "29: #define LIBRAW_VERSION_TAIL   Alpha3",
          "31: #define LIBRAW_SHLIB_CURRENT   6",
          "",
          "[Added Lines]",
          "29: #define LIBRAW_VERSION_TAIL   Alpha4",
          "31: #define LIBRAW_SHLIB_CURRENT   7",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "534:     else if (load_raw == &LibRaw::packed_load_raw )",
          "535:         {",
          "536:             d_info->decoder_name = \"packed_load_raw()\";",
          "538:         }",
          "539:     else if (load_raw == &LibRaw::nokia_load_raw )",
          "540:         {",
          "",
          "[Removed Lines]",
          "537:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD  | LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "[Added Lines]",
          "537:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "538: #ifndef NOSONY_RAWSPEED",
          "539:             d_info->decoder_flags |= LIBRAW_DECODER_TRYRAWSPEED;",
          "540: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "632:     else if (load_raw == &LibRaw::sony_arw_load_raw )",
          "633:         {",
          "634:             d_info->decoder_name = \"sony_arw_load_raw()\";",
          "636:         }",
          "637:     else if (load_raw == &LibRaw::sony_arw2_load_raw )",
          "638:         {",
          "639:             d_info->decoder_name = \"sony_arw2_load_raw()\";",
          "640:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "641:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "644: #endif",
          "645:             d_info->decoder_flags |= LIBRAW_DECODER_ITSASONY;",
          "646:         }",
          "",
          "[Removed Lines]",
          "635:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_TRYRAWSPEED;",
          "642: #ifndef NOARW2_RAWSPEED",
          "643:    d_info->decoder_flags |= LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "[Added Lines]",
          "639:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "640: #ifndef NOSONY_RAWSPEED",
          "641:             d_info->decoder_flags |= LIBRAW_DECODER_TRYRAWSPEED;",
          "642: #endif",
          "649: #ifndef NOSONY_RAWSPEED",
          "650:             d_info->decoder_flags |= LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "913:     C.maximum = 0xffff;",
          "914:   else if (load_raw == &LibRaw::sony_load_raw)",
          "915:     C.maximum = 0x3ff0;",
          "917:  {",
          "918:   C.maximum *=4;",
          "919:   C.black *=4;",
          "",
          "[Removed Lines]",
          "916: else if (load_raw == &LibRaw::sony_arw2_load_raw)",
          "",
          "[Added Lines]",
          "923:   else if (load_raw == &LibRaw::sony_arw2_load_raw || load_raw == &LibRaw::packed_load_raw )",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "979:                     rheight = S.height + S.top_margin;",
          "980:             }",
          "981:         S.raw_pitch = S.raw_width;",
          "984: #ifdef USE_RAWSPEED",
          "1023: #endif",
          "1047:         if(imgdata.rawdata.raw_image)",
          "1048:           crop_masked_pixels(); // calculate black levels",
          "1050: #if 0",
          "1054: #endif",
          "1056:         if( decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "",
          "[Removed Lines]",
          "982:   imgdata.rawdata.raw_image = 0;",
          "983:   imgdata.rawdata.color_image = 0;",
          "986:   if(O.use_rawspeed && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "987:   {",
          "988:    INT64 spos = ID.input->tell();",
          "989:    try",
          "990:    {",
          "991:     ID.input->seek(0,SEEK_SET);",
          "992:     INT64 _rawspeed_buffer_sz = ID.input->size();",
          "993:     void *_rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "994:     if(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;",
          "995:     ID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);",
          "996:     FileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);",
          "997:     RawParser t(&map);",
          "998:     RawDecoder *d = 0;",
          "999:     CameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "1000:     d = t.getDecoder();",
          "1001:     d->checkSupport(meta);",
          "1002:        d->decodeRaw();",
          "1003:        d->decodeMetaData(meta);",
          "1004:     RawImage r = d->mRaw;",
          "1005:     if (r->isCFA) {",
          "1007:      _rawspeed_decoder = static_cast<void*>(d);",
          "1008:      imgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);",
          "1009:      S.raw_pitch = r->pitch/2;",
          "1010:      fix_after_rawspeed();",
          "1011:     }",
          "1012:     else",
          "1013:     {",
          "1014:      delete d;",
          "1015:     }",
          "1016:     free(_rawspeed_buffer);",
          "1017:    } catch (...) {",
          "1018:     imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "1020:    }",
          "1021:    ID.input->seek(spos,SEEK_SET);",
          "1022:   }",
          "1024:   if(!imgdata.rawdata.raw_image && !imgdata.rawdata.color_image)",
          "1025:    {",
          "1027:     if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "1028:     {",
          "1029:      imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "1030:      imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1031:     }",
          "1032:     else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1033:     {",
          "1036:      S.iwidth = S.width;",
          "1037:      S.iheight= S.height;",
          "1038:      IO.shrink = 0;",
          "1040:      imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
          "1041:      imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "1042:     }",
          "1043:           ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "1044:     (this->*load_raw)();",
          "1045:    }",
          "1051:   printf(\"B=%d,%d,%d,%d,%d M=%d\\n\",C.black,C.cblack[0],C.cblack[1],C.cblack[2],C.cblack[3],C.maximum);",
          "1052:   if(imgdata.rawdata.raw_image)",
          "1053:    printf(\"V=%d %d %d %d %d\",imgdata.rawdata.raw_image[0],imgdata.rawdata.raw_image[17],imgdata.rawdata.raw_image[40000],imgdata.rawdata.raw_image[64000],imgdata.rawdata.raw_image[200000]);",
          "",
          "[Added Lines]",
          "989:         imgdata.rawdata.raw_image = 0;",
          "990:         imgdata.rawdata.color_image = 0;",
          "993:         if(O.use_rawspeed && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "994:           {",
          "995:             INT64 spos = ID.input->tell();",
          "996:             try",
          "997:               {",
          "999:                 ID.input->seek(0,SEEK_SET);",
          "1000:                 INT64 _rawspeed_buffer_sz = ID.input->size();",
          "1001:                 void *_rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "1002:                 if(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;",
          "1003:                 ID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);",
          "1004:                 FileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);",
          "1005:                 RawParser t(&map);",
          "1006:                 RawDecoder *d = 0;",
          "1007:                 CameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "1008:                 d = t.getDecoder();",
          "1009:                 d->checkSupport(meta);",
          "1010:                 d->decodeRaw();",
          "1011:                 d->decodeMetaData(meta);",
          "1012:                 RawImage r = d->mRaw;",
          "1013:                 if (r->isCFA) {",
          "1015:                   _rawspeed_decoder = static_cast<void*>(d);",
          "1016:                   imgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);",
          "1017:                   S.raw_pitch = r->pitch/2;",
          "1018:                   fix_after_rawspeed();",
          "1019:                 }",
          "1020:                 else",
          "1021:                   {",
          "1022:                     delete d;",
          "1023:                   }",
          "1024:                 free(_rawspeed_buffer);",
          "1025:               } catch (...) {",
          "1026:               imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "1028:             }",
          "1029:             ID.input->seek(spos,SEEK_SET);",
          "1030:           }",
          "1032:         if(!imgdata.rawdata.raw_image && !imgdata.rawdata.color_image)",
          "1033:           {",
          "1035:             if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "1036:               {",
          "1037:                 imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "1038:                 imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1039:               }",
          "1040:             else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1041:               {",
          "1044:                 S.iwidth = S.width;",
          "1045:                 S.iheight= S.height;",
          "1046:                 IO.shrink = 0;",
          "1048:                 imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
          "1049:                 imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "1050:               }",
          "1051:             ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "1052:             (this->*load_raw)();",
          "1053:           }",
          "1059:         printf(\"B=%d,%d,%d,%d,%d M=%d\\n\",C.black,C.cblack[0],C.cblack[1],C.cblack[2],C.cblack[3],C.maximum);",
          "1060:         if(imgdata.rawdata.raw_image)",
          "1061:           printf(\"V=%d %d %d %d %d\\n\",imgdata.rawdata.raw_image[0],imgdata.rawdata.raw_image[17],imgdata.rawdata.raw_image[1000001],imgdata.rawdata.raw_image[1000002],imgdata.rawdata.raw_image[1000003]);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1074:         C.black += i;",
          "1076: #if 0",
          "1085: #endif",
          "1087:         memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "",
          "[Removed Lines]",
          "1077:   if(imgdata.rawdata.raw_image)",
          "1078:   {",
          "1079:    char fnbuf[25];",
          "1080:    sprintf(fnbuf,\"%d.dat\",time(NULL));",
          "1081:    FILE *f = fopen(fnbuf,\"wb\");",
          "1082:    fwrite(imgdata.rawdata.raw_image,S.raw_pitch*sizeof(ushort),S.raw_height,f);",
          "1083:    fclose(f);",
          "1084:   }",
          "",
          "[Added Lines]",
          "1085:         if(imgdata.rawdata.raw_image)",
          "1086:           {",
          "1087:             char fnbuf[25];",
          "1088:             sprintf(fnbuf,\"%d.dat\",time(NULL));",
          "1089:             FILE *f = fopen(fnbuf,\"wb\");",
          "1090:             fwrite(imgdata.rawdata.raw_image,S.raw_pitch*sizeof(ushort),S.raw_height,f);",
          "1091:             fclose(f);",
          "1092:           }",
          "",
          "---------------"
        ],
        "src/libraw_datastream.cpp||src/libraw_datastream.cpp": [
          "File: src/libraw_datastream.cpp -> src/libraw_datastream.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: #ifndef WIN32",
          "82:   struct stat st;",
          "83:   if(!stat(filename,&st))",
          "85: #else",
          "86:   struct _stati64 st;",
          "87:   if(!_stati64(filename,&st))",
          "",
          "[Removed Lines]",
          "84:    fsize = st.st_size;",
          "",
          "[Added Lines]",
          "84:    _fsize = st.st_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "467:     if(fname)",
          "468:         {",
          "469: #ifndef WIN32",
          "473: #else",
          "477: #endif",
          "479: #ifndef WIN32SECURECALLS",
          "481: #else",
          "484: #endif",
          "485:         }",
          "486:     else",
          "488:     sav=0;",
          "489: }",
          "",
          "[Removed Lines]",
          "470:    struct stat st;",
          "471:    if(!stat(fname,&st))",
          "472:     fsize = st.st_size;",
          "474:    struct _stati64 st;",
          "475:    if(!_stati64(fname,&st))",
          "476:     _fsize = st.st_size;",
          "480:             f = fopen(fname,\"rb\");",
          "482:             if(fopen_s(&f,fname,\"rb\"))",
          "483:                 f = 0;",
          "487:         {filename=0;f=0;}",
          "",
          "[Added Lines]",
          "470:           struct stat st;",
          "471:           if(!stat(fname,&st))",
          "472:             _fsize = st.st_size;",
          "474:           struct _stati64 st;",
          "475:           if(!_stati64(fname,&st))",
          "476:             _fsize = st.st_size;",
          "480:           f = fopen(fname,\"rb\");",
          "482:           if(fopen_s(&f,fname,\"rb\"))",
          "483:             f = 0;",
          "487:       {filename=0;f=0;}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e86e1f7a82d4d5c280b499c54f35a4d6b0d08fe",
      "candidate_info": {
        "commit_hash": "6e86e1f7a82d4d5c280b499c54f35a4d6b0d08fe",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/6e86e1f7a82d4d5c280b499c54f35a4d6b0d08fe",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp",
          "internal/demosaic_packs.cpp",
          "internal/libraw_internal_funcs.h",
          "libraw/libraw.h",
          "libraw/libraw_const.h",
          "libraw/libraw_datastream.h",
          "libraw/libraw_types.h",
          "samples/dcraw_emu.cpp",
          "src/libraw_cxx.cpp"
        ],
        "message": "dcraw 915 merge, phase 2a",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp",
          "internal/demosaic_packs.cpp||internal/demosaic_packs.cpp",
          "internal/libraw_internal_funcs.h||internal/libraw_internal_funcs.h",
          "libraw/libraw.h||libraw/libraw.h",
          "libraw/libraw_const.h||libraw/libraw_const.h",
          "libraw/libraw_datastream.h||libraw/libraw_datastream.h",
          "libraw/libraw_types.h||libraw/libraw_types.h",
          "samples/dcraw_emu.cpp||samples/dcraw_emu.cpp",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2363:       rgb[1] = y-((cb + cr + 2) >> 2);",
          "2364:       rgb[2] = rgb[1] + cb;",
          "2365:       rgb[0] = rgb[1] + cr;",
          "2367:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];",
          "2371:     }",
          "2372:   }",
          "2373:   free (pixel);",
          "",
          "[Removed Lines]",
          "2366: #ifndef LIBRAW_LIBRARY_BUILD",
          "2368: #else",
          "2369:       FORC3 color_image[(row+top_margin)*raw_width+col+left_margin][c] = curve[LIM(rgb[c],0,255)];",
          "2370: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2497:  for (j=0; j < 2; j++)",
          "2498:    for (k=0; k < 2; k++) {",
          "2499:      if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();",
          "2501:      ip = image[(row+j)*width + col+i+k];",
          "2502:      FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];",
          "2507:    }",
          "2508:       }",
          "2509:     }",
          "",
          "[Removed Lines]",
          "2500: #ifndef LIBRAW_LIBRARY_BUILD",
          "2503: #else",
          "2504:      ip = color_image[(row+top_margin+j)*raw_width + col+i+k+left_margin];",
          "2505:             FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];",
          "2506: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2524:       len = MIN (256, width-col);",
          "2525:       kodak_65000_decode (buf, len*3);",
          "2526:       memset (rgb, 0, sizeof rgb);",
          "2530:       for (bp=buf, i=0; i < len; i++, ip+=4)",
          "2531:  FORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();",
          "2532:     }",
          "",
          "[Removed Lines]",
          "2527: #ifdef LIBRAW_LIBRARY_BUILD",
          "2528:       ip = &color_image[(row+top_margin)*raw_width+left_margin][0];",
          "2529: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3576: void CLASS crop_masked_pixels()",
          "3577: {",
          "3578:   int row, col;",
          "3581:   if (load_raw == &CLASS phase_one_load_raw ||",
          "3582:       load_raw == &CLASS phase_one_load_raw_c)",
          "3583:     phase_one_correct();",
          "3584:   if (fuji_width) {",
          "3585:     for (row=0; row < raw_height-top_margin*2; row++) {",
          "3586:       for (col=0; col < fuji_width << !fuji_layout; col++) {",
          "",
          "[Removed Lines]",
          "3579:   unsigned r, c, m, mblack[8], zero, val;",
          "",
          "[Added Lines]",
          "3568:   unsigned",
          "3569: #ifndef LIBRAW_LIBRARY_BUILD",
          "3570:     r,",
          "3571: #endif",
          "3572:     c, m, mblack[8], zero, val;",
          "3573:   printf(\"Entering crop masked!\\n\");",
          "3578: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3600:       for (col=0; col < width; col++)",
          "3601:  BAYER2(row,col) = RAW(row+top_margin,col+left_margin);",
          "3602:   }",
          "3603:   if (mask[0][3]) goto mask_set;",
          "3604:   if (load_raw == &CLASS canon_load_raw ||",
          "3605:       load_raw == &CLASS lossless_jpeg_load_raw) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3598: #endif",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2094:       rgb[1] = y-((cb + cr + 2) >> 2);",
          "2095:       rgb[2] = rgb[1] + cb;",
          "2096:       rgb[0] = rgb[1] + cr;",
          "2098:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];",
          "2102:     }",
          "2103:   }",
          "2104:   free (pixel);",
          "",
          "[Removed Lines]",
          "2097: #ifndef LIBRAW_LIBRARY_BUILD",
          "2099: #else",
          "2100:       FORC3 color_image[(row+top_margin)*raw_width+col+left_margin][c] = curve[LIM(rgb[c],0,255)];",
          "2101: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2228:  for (j=0; j < 2; j++)",
          "2229:    for (k=0; k < 2; k++) {",
          "2230:      if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();",
          "2232:      ip = image[(row+j)*width + col+i+k];",
          "2233:      FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];",
          "2238:    }",
          "2239:       }",
          "2240:     }",
          "",
          "[Removed Lines]",
          "2231: #ifndef LIBRAW_LIBRARY_BUILD",
          "2234: #else",
          "2235:      ip = color_image[(row+top_margin+j)*raw_width + col+i+k+left_margin];",
          "2236:             FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];",
          "2237: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2255:       len = MIN (256, width-col);",
          "2256:       kodak_65000_decode (buf, len*3);",
          "2257:       memset (rgb, 0, sizeof rgb);",
          "2261:       for (bp=buf, i=0; i < len; i++, ip+=4)",
          "2262:  FORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();",
          "2263:     }",
          "",
          "[Removed Lines]",
          "2258: #ifdef LIBRAW_LIBRARY_BUILD",
          "2259:       ip = &color_image[(row+top_margin)*raw_width+left_margin][0];",
          "2260: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2599:   jas_stream_close (in);",
          "2600: #endif",
          "2601: }",
          "2603: void CLASS remove_zeroes()",
          "2604: {",
          "2605:   unsigned row, col, tot, n, r, c;",
          "",
          "[Removed Lines]",
          "2602: #line 3648 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "2590: #line 3565 \"dcraw/dcraw.c\"",
          "2591: void CLASS crop_masked_pixels()",
          "2592: {",
          "2593:   int row, col;",
          "2594:   unsigned",
          "2595: #ifndef LIBRAW_LIBRARY_BUILD",
          "2596:     r,",
          "2597: #endif",
          "2598:     c, m, mblack[8], zero, val;",
          "2599:   printf(\"Entering crop masked!\\n\");",
          "2601:   if (load_raw == &CLASS phase_one_load_raw ||",
          "2602:       load_raw == &CLASS phase_one_load_raw_c)",
          "2603:     phase_one_correct();",
          "2604: #ifndef LIBRAW_LIBRARY_BUILD",
          "2605:   if (fuji_width) {",
          "2606:     for (row=0; row < raw_height-top_margin*2; row++) {",
          "2607:       for (col=0; col < fuji_width << !fuji_layout; col++) {",
          "2608:  if (fuji_layout) {",
          "2609:    r = fuji_width - 1 - col + (row >> 1);",
          "2610:    c = col + ((row+1) >> 1);",
          "2611:  } else {",
          "2612:    r = fuji_width - 1 + row - (col >> 1);",
          "2613:    c = row + ((col+1) >> 1);",
          "2614:  }",
          "2615:  if (r < height && c < width)",
          "2616:    BAYER(r,c) = RAW(row+top_margin,col+left_margin);",
          "2617:       }",
          "2618:     }",
          "2619:   } else {",
          "2620:     for (row=0; row < height; row++)",
          "2621:       for (col=0; col < width; col++)",
          "2622:  BAYER2(row,col) = RAW(row+top_margin,col+left_margin);",
          "2623:   }",
          "2624: #endif",
          "2625:   if (mask[0][3]) goto mask_set;",
          "2626:   if (load_raw == &CLASS canon_load_raw ||",
          "2627:       load_raw == &CLASS lossless_jpeg_load_raw) {",
          "2628:     mask[0][1] = mask[1][1] = 2;",
          "2629:     mask[0][3] = -2;",
          "2630:     goto sides;",
          "2631:   }",
          "2632:   if (load_raw == &CLASS sony_load_raw) {",
          "2633:     mask[0][3] = 9;",
          "2634:     goto sides;",
          "2635:   }",
          "2636:   if (load_raw == &CLASS canon_600_load_raw ||",
          "2637:      (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||",
          "2638:       load_raw == &CLASS kodak_262_load_raw ||",
          "2639:      (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {",
          "2640: sides:",
          "2641:     mask[0][0] = mask[1][0] = top_margin;",
          "2642:     mask[0][2] = mask[1][2] = top_margin+height;",
          "2643:     mask[0][3] += left_margin;",
          "2644:     mask[1][1] += left_margin+width;",
          "2645:     mask[1][3] += raw_width;",
          "2646:   }",
          "2647:   if (load_raw == &CLASS nokia_load_raw) {",
          "2648:     mask[0][2] = top_margin;",
          "2649:     mask[0][3] = width;",
          "2650:   }",
          "2651: mask_set:",
          "2652:   memset (mblack, 0, sizeof mblack);",
          "2653:   for (zero=m=0; m < 8; m++)",
          "2654:     for (row=mask[m][0]; row < mask[m][2]; row++)",
          "2655:       for (col=mask[m][1]; col < mask[m][3]; col++) {",
          "2656:  c = FC(row-top_margin,col-left_margin);",
          "2657:  mblack[c] += val = RAW(row,col);",
          "2658:  mblack[4+c]++;",
          "2659:  zero += !val;",
          "2660:       }",
          "2661:   if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {",
          "2662:     black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /",
          "2663:      (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;",
          "2664:     canon_600_correct();",
          "2665:   } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])",
          "2666:     FORC4 cblack[c] = mblack[c] / mblack[4+c];",
          "2667: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2623:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);",
          "2624: #endif",
          "2625: }",
          "2627: void CLASS gamma_curve (double pwr, double ts, int mode, int imax)",
          "2628: {",
          "2629:   int i;",
          "",
          "[Removed Lines]",
          "2626: #line 3837 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "2692: #line 3832 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3691:     fseek (ifp, save, SEEK_SET);",
          "3692:   }",
          "3693: }",
          "3695: void CLASS parse_makernote (int base, int uptag)",
          "3696: {",
          "3697:   static const uchar xlat[2][256] = {",
          "",
          "[Removed Lines]",
          "3694: #line 4909 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "3760: #line 4904 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4206:     fseek (ifp, save, SEEK_SET);",
          "4207:   }",
          "4208: }",
          "4210: int CLASS parse_tiff_ifd (int base)",
          "4211: {",
          "4212:   unsigned entries, tag, type, len, plen=16, save;",
          "",
          "[Removed Lines]",
          "4209: #line 5429 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "4275: #line 5424 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5450:     data_offset = get4();",
          "5451:   }",
          "5452: }",
          "5455:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "",
          "[Removed Lines]",
          "5453: #line 6779 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "5519: #line 6774 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "7825:   RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "7826: #endif",
          "7827: }",
          "7829: void CLASS convert_to_rgb()",
          "7830: {",
          "7831: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "7828: #line 9243 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "7894: #line 9238 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "8048:   if (flip & 1) col = iwidth  - 1 - col;",
          "8049:   return row * iwidth + col;",
          "8050: }",
          "8052: void CLASS tiff_set (ushort *ntag,",
          "8053:  ushort tag, ushort type, int count, int val)",
          "8054: {",
          "",
          "[Removed Lines]",
          "8051: #line 9491 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8117: #line 9486 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp": [
          "File: internal/dcraw_fileio.cpp -> internal/dcraw_fileio.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:    for more information",
          "25: #include <math.h>",
          "26: #define CLASS LibRaw::",
          "27: #include \"libraw/libraw_types.h\"",
          "",
          "[Removed Lines]",
          "24: #line 3674 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "24: #line 3669 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #include \"libraw/libraw.h\"",
          "30: #include \"internal/defines.h\"",
          "31: #include \"internal/var_defines.h\"",
          "34:    Seach from the current directory up to the root looking for",
          "35:    a \".badpixels\" file, and fix those pixels now.",
          "",
          "[Removed Lines]",
          "32: #line 3685 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "32: #line 3680 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54: #endif",
          "55:   if (cfname)",
          "56:     fp = fopen (cfname, \"r\");",
          "58:   if (!fp)",
          "59:       {",
          "60: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "57: #line 3735 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "57: #line 3730 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "154:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "155: #endif",
          "156: }",
          "158: #ifndef NO_LCMS",
          "159: void CLASS apply_profile (const char *input, const char *output)",
          "160: {",
          "",
          "[Removed Lines]",
          "157: #line 9156 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "157: #line 9151 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/demosaic_packs.cpp||internal/demosaic_packs.cpp": [
          "File: internal/demosaic_packs.cpp -> internal/demosaic_packs.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "95: #include <dcraw_foveon.c>",
          "96: #else",
          "97: void CLASS foveon_interpolate(){}",
          "99: void CLASS parse_foveon(){}",
          "100: void CLASS foveon_thumb_loader(){}",
          "101: void CLASS foveon_thumb(){}",
          "",
          "[Removed Lines]",
          "98: void CLASS foveon_load_raw(){}",
          "",
          "[Added Lines]",
          "98: void CLASS foveon_dp_load_raw(){}",
          "99: void CLASS foveon_sd_load_raw(){}",
          "",
          "---------------"
        ],
        "internal/libraw_internal_funcs.h||internal/libraw_internal_funcs.h": [
          "File: internal/libraw_internal_funcs.h -> internal/libraw_internal_funcs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "166:     void        foveon_load_camf();",
          "168:     const char* foveon_camf_param (const char *block, const char *param);",
          "169:     void *      foveon_camf_matrix (unsigned dim[3], const char *name);",
          "170:     int         foveon_fixed (void *ptr, int size, const char *name);",
          "",
          "[Removed Lines]",
          "167:     void        foveon_load_raw();",
          "",
          "[Added Lines]",
          "167:     void        foveon_sd_load_raw();",
          "168:     void        foveon_dp_load_raw();",
          "",
          "---------------"
        ],
        "libraw/libraw.h||libraw/libraw.h": [
          "File: libraw/libraw.h -> libraw/libraw.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "9: LibRaw is free software; you can redistribute it and/or modify",
          "10: it under the terms of the one of three licenses as you choose:",
          "12: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "13:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "15: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "16:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "18: 3. LibRaw Software License 27032010",
          "19:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "23: #ifndef _LIBRAW_CLASS_H",
          "24: #define _LIBRAW_CLASS_H",
          "26: #ifdef __linux__",
          "27: #define _FILE_OFFSET_BITS 64",
          "28: #endif",
          "31: #define LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE (250*1024L*1024L)",
          "34: #include <limits.h>",
          "35: #include <memory.h>",
          "36: #include <stdio.h>",
          "37: #include <stdlib.h>",
          "40: #include \"libraw_datastream.h\"",
          "41: #include \"libraw_types.h\"",
          "42: #include \"libraw_const.h\"",
          "43: #include \"libraw_internal.h\"",
          "44: #include \"libraw_alloc.h\"",
          "46: #ifdef __cplusplus",
          "47: extern \"C\"",
          "48: {",
          "49: #endif",
          "50: DllDef    const char          *libraw_strerror(int errorcode);",
          "51: DllDef    const char          *libraw_strprogress(enum LibRaw_progress);",
          "53: DllDef    libraw_data_t       *libraw_init(unsigned int flags);",
          "54: DllDef    int                 libraw_open_file(libraw_data_t*, const char *);",
          "55: DllDef    int                 libraw_open_file_ex(libraw_data_t*, const char *, INT64 max_buff_sz);",
          "56: DllDef    int                 libraw_open_buffer(libraw_data_t*, void * buffer, size_t size);",
          "57: DllDef    int                 libraw_unpack(libraw_data_t*);",
          "58: DllDef    int                 libraw_unpack_thumb(libraw_data_t*);",
          "59: DllDef    void                libraw_recycle(libraw_data_t*);",
          "60: DllDef    void                libraw_close(libraw_data_t*);",
          "61: DllDef    void                libraw_subtract_black(libraw_data_t*);",
          "62: DllDef    int                 libraw_raw2image(libraw_data_t*);",
          "63: DllDef    void                libraw_free_image(libraw_data_t*);",
          "65: DllDef    const char*         libraw_version();",
          "66: DllDef    int                 libraw_versionNumber();",
          "68: DllDef    const char**        libraw_cameraList();",
          "69: DllDef    int                 libraw_cameraCount();",
          "71: DllDef    void                libraw_set_memerror_handler(libraw_data_t*, memory_callback cb, void *datap);",
          "72: DllDef    void                libraw_set_dataerror_handler(libraw_data_t*,data_callback func,void *datap);",
          "73: DllDef    void                libraw_set_progress_handler(libraw_data_t*,progress_callback cb,void *datap);",
          "74: DllDef    const char *        libraw_unpack_function_name(libraw_data_t* lr);",
          "75: DllDef    int                 libraw_get_decoder_info(libraw_data_t* lr,libraw_decoder_info_t* d);",
          "78: DllDef    int                 libraw_adjust_sizes_info_only(libraw_data_t*);",
          "79: DllDef    int                 libraw_dcraw_document_mode_processing(libraw_data_t*);",
          "80: DllDef    int                 libraw_dcraw_ppm_tiff_writer(libraw_data_t* lr,const char *filename);",
          "81: DllDef    int                 libraw_dcraw_thumb_writer(libraw_data_t* lr,const char *fname);",
          "82: DllDef    int                 libraw_dcraw_process(libraw_data_t* lr);",
          "83: DllDef    libraw_processed_image_t* libraw_dcraw_make_mem_image(libraw_data_t* lr, int *errc);",
          "84: DllDef    libraw_processed_image_t* libraw_dcraw_make_mem_thumb(libraw_data_t* lr, int *errc);",
          "85: DllDef    void libraw_dcraw_clear_mem(libraw_processed_image_t*);",
          "86: #ifdef __cplusplus",
          "87: }",
          "88: #endif",
          "91: #ifdef __cplusplus",
          "93: class DllDef LibRaw",
          "94: {",
          "95:   public:",
          "96:     libraw_data_t imgdata;",
          "97:     int verbose;",
          "99:     LibRaw(unsigned int flags = LIBRAW_OPTIONS_NONE);",
          "101:     libraw_output_params_t*     output_params_ptr() { return &imgdata.params;}",
          "102:     int                         open_file(const char *fname, INT64 max_buffered_sz=LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "103: #ifdef WIN32",
          "104:  int                         open_file(const wchar_t *fname, INT64 max_buffered_sz=LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "105: #endif",
          "106:     int                         open_buffer(void *buffer, size_t size);",
          "107:     int                         open_datastream(LibRaw_abstract_datastream *);",
          "108:     int                         unpack(void);",
          "109:     int                         unpack_thumb(void);",
          "111:     int                         adjust_sizes_info_only(void);",
          "112:     void                        subtract_black();",
          "113:     int                         raw2image();",
          "114:     int                         raw2image_ex();",
          "115:     void                        raw2image_start();",
          "116:     void                        free_image();",
          "117:     int                         adjust_maximum();",
          "118:     void                        set_memerror_handler( memory_callback cb,void *data) {callbacks.memcb_data = data; callbacks.mem_cb = cb; }",
          "119:     void                        set_dataerror_handler(data_callback func, void *data) { callbacks.datacb_data = data; callbacks.data_cb = func;}",
          "120:     void                        set_progress_handler(progress_callback pcb, void *data) { callbacks.progresscb_data = data; callbacks.progress_cb = pcb;}",
          "123:     static const char*          version();",
          "124:     static int                  versionNumber();",
          "125:     static const char**         cameraList();",
          "126:     static int                  cameraCount();",
          "127:     static const char*          strprogress(enum LibRaw_progress);",
          "128:     static const char*          strerror(int p);",
          "130:     int                         dcraw_document_mode_processing();",
          "131:     int                         dcraw_ppm_tiff_writer(const char *filename);",
          "132:     int                         dcraw_thumb_writer(const char *fname);",
          "133:     int                         dcraw_process(void);",
          "135:     virtual libraw_processed_image_t*   dcraw_make_mem_image(int *errcode=NULL);",
          "136:     virtual libraw_processed_image_t*   dcraw_make_mem_thumb(int *errcode=NULL);",
          "137:     static void                 dcraw_clear_mem(libraw_processed_image_t*);",
          "140:     void get_mem_image_format(int* width, int* height, int* colors, int* bps) const;",
          "141:     int  copy_mem_image(void* scan0, int stride, int bgr);",
          "144:     void         recycle();",
          "145:     ~LibRaw(void) { recycle(); delete tls; }",
          "147:     int COLOR(int row, int col) { return libraw_internal_data.internal_output_params.fuji_width? FCF(row,col):FC(row,col);}",
          "149:     int FC(int row,int col) { return (imgdata.idata.filters >> (((row << 1 & 14) | (col & 1)) << 1) & 3);}",
          "150:     int         fcol (int row, int col);",
          "152:     const char *unpack_function_name();",
          "153:     int get_decoder_info(libraw_decoder_info_t* d_info);",
          "154:     libraw_internal_data_t * get_internal_data_pointer(){ return &libraw_internal_data; }",
          "157:     int                         wf_remove_banding();",
          "160: protected:",
          "162:     int FCF(int row,int col) {",
          "163:         int rr,cc;",
          "164:         if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "165:             rr = libraw_internal_data.internal_output_params.fuji_width - 1 - col + (row >> 1);",
          "166:             cc = col + ((row+1) >> 1);",
          "167:         } else {",
          "168:             rr = libraw_internal_data.internal_output_params.fuji_width - 1 + row - (col >> 1);",
          "169:             cc = row + ((col+1) >> 1);",
          "170:         }",
          "171:         return FC(rr,cc);",
          "172:     }",
          "174:     void*        malloc(size_t t);",
          "175:     void*        calloc(size_t n,size_t t);",
          "176:     void*        realloc(void *p, size_t s);",
          "177:     void        free(void *p);",
          "178:     void        merror (void *ptr, const char *where);",
          "179:     void        derror();",
          "181:     LibRaw_TLS  *tls;",
          "182:     libraw_internal_data_t libraw_internal_data;",
          "183:     decode      first_decode[2048], *second_decode, *free_decode;",
          "184:     tiff_ifd_t  tiff_ifd[10];",
          "185:     libraw_memmgr memmgr;",
          "186:     libraw_callbacks_t callbacks;",
          "188:     LibRaw_constants rgb_constants;",
          "189:     void        (LibRaw:: *write_thumb)();",
          "190:     void        (LibRaw:: *write_fun)();",
          "191:     void        (LibRaw:: *load_raw)();",
          "192:     void        (LibRaw:: *thumb_load_raw)();",
          "194:     void        kodak_thumb_loader();",
          "195:     void        write_thumb_ppm_tiff(FILE *);",
          "196:     void        foveon_thumb_loader (void);",
          "198:     int         own_filtering_supported(){ return 0;}",
          "199:     void        identify();",
          "200:     void        identify2(unsigned, unsigned, char*);",
          "201:     void        write_ppm_tiff ();",
          "202:     void        convert_to_rgb();",
          "203:  virtual  void convert_to_rgb_loop(float out_cam[3][4]);",
          "204:     void        remove_zeroes();",
          "205: #ifndef NO_LCMS",
          "206:     void apply_profile(const char*,const char*);",
          "207: #endif",
          "208:     void        pre_interpolate();",
          "209:     void        border_interpolate (int border);",
          "210:     void        lin_interpolate();",
          "211:     void        vng_interpolate();",
          "212:     void        ppg_interpolate();",
          "213:     void        ahd_interpolate();",
          "216:     void        ahd_interpolate_mod();",
          "217:     void        afd_interpolate_pl(int afd_passes, int clip_on);",
          "218:     void        afd_noise_filter_pl();",
          "219:     void lmmse_interpolate(int gamma_apply);",
          "220:     void        dcb(int iterations, int dcb_enhance);",
          "221:     void        fbdd(int noiserd);",
          "222:     void        vcd_interpolate(int ahd_cutoff);",
          "223:     void        amaze_demosaic_RT();",
          "224:     void exp_bef(float expos, float preser);",
          "225:     void        CA_correct_RT(float cared, float cablue);",
          "226:     void        cfa_linedn(float linenoise);",
          "227:     void        cfa_impulse_gauss(float lclean, float cclean);",
          "228:     void        green_equilibrate(float thresh);",
          "232:     void        bad_pixels(const char*);",
          "233:     void        subtract(const char*);",
          "234:     void        hat_transform (float *temp, float *base, int st, int size, int sc);",
          "235:     void        wavelet_denoise();",
          "236:     void        scale_colors();",
          "237:  virtual void scale_colors_loop(float scale_mul[4]);",
          "238:     void        median_filter ();",
          "239:     void        blend_highlights();",
          "240:     void        recover_highlights();",
          "241:     void        green_matching();",
          "243:     void        fuji_rotate();",
          "244:     void        stretch();",
          "246:     void        foveon_thumb ();",
          "247:     void        jpeg_thumb_writer (FILE *tfp,char *thumb,int thumb_length);",
          "248:     void        jpeg_thumb ();",
          "249:     void        ppm_thumb ();",
          "250:     void        ppm16_thumb();",
          "251:     void        layer_thumb ();",
          "252:     void        rollei_thumb ();",
          "253:     void        kodak_thumb_load_raw();",
          "255:     void        foveon_decoder (unsigned size, unsigned code);",
          "256:     unsigned    get4();",
          "258:     int         flip_index (int row, int col);",
          "259:     void        gamma_curve (double pwr, double ts, int mode, int imax);",
          "262: #ifdef LIBRAW_LIBRARY_BUILD",
          "263: #include \"internal/libraw_internal_funcs.h\"",
          "264: #endif",
          "266: };",
          "268: #ifdef LIBRAW_LIBRARY_BUILD",
          "269: #define RUN_CALLBACK(stage,iter,expect)  if(callbacks.progress_cb) { \\",
          "270:         int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,stage,iter,expect); \\",
          "271:         if(rr!=0) throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK; \\",
          "272:     }",
          "273: #endif",
          "",
          "[Added Lines]",
          "9: LibRaw is free software; you can redistribute it and/or modify",
          "10: it under the terms of the one of three licenses as you choose:",
          "12: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "13:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "15: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "16:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "18: 3. LibRaw Software License 27032010",
          "19:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "23: #ifndef _LIBRAW_CLASS_H",
          "24: #define _LIBRAW_CLASS_H",
          "26: #ifdef __linux__",
          "27: #define _FILE_OFFSET_BITS 64",
          "28: #endif",
          "31: #define LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE (250*1024L*1024L)",
          "34: #include <limits.h>",
          "35: #include <memory.h>",
          "36: #include <stdio.h>",
          "37: #include <stdlib.h>",
          "40: #include \"libraw_datastream.h\"",
          "41: #include \"libraw_types.h\"",
          "42: #include \"libraw_const.h\"",
          "43: #include \"libraw_internal.h\"",
          "44: #include \"libraw_alloc.h\"",
          "46: #ifdef __cplusplus",
          "47: extern \"C\"",
          "48: {",
          "49: #endif",
          "50: DllDef    const char          *libraw_strerror(int errorcode);",
          "51: DllDef    const char          *libraw_strprogress(enum LibRaw_progress);",
          "53: DllDef    libraw_data_t       *libraw_init(unsigned int flags);",
          "54: DllDef    int                 libraw_open_file(libraw_data_t*, const char *);",
          "55: DllDef    int                 libraw_open_file_ex(libraw_data_t*, const char *, INT64 max_buff_sz);",
          "56: DllDef    int                 libraw_open_buffer(libraw_data_t*, void * buffer, size_t size);",
          "57: DllDef    int                 libraw_unpack(libraw_data_t*);",
          "58: DllDef    int                 libraw_unpack_thumb(libraw_data_t*);",
          "59: DllDef    void                libraw_recycle(libraw_data_t*);",
          "60: DllDef    void                libraw_close(libraw_data_t*);",
          "61: DllDef    void                libraw_subtract_black(libraw_data_t*);",
          "62: DllDef    int                 libraw_raw2image(libraw_data_t*);",
          "63: DllDef    void                libraw_free_image(libraw_data_t*);",
          "65: DllDef    const char*         libraw_version();",
          "66: DllDef    int                 libraw_versionNumber();",
          "68: DllDef    const char**        libraw_cameraList();",
          "69: DllDef    int                 libraw_cameraCount();",
          "71: DllDef    void                libraw_set_memerror_handler(libraw_data_t*, memory_callback cb, void *datap);",
          "72: DllDef    void                libraw_set_dataerror_handler(libraw_data_t*,data_callback func,void *datap);",
          "73: DllDef    void                libraw_set_progress_handler(libraw_data_t*,progress_callback cb,void *datap);",
          "74: DllDef    const char *        libraw_unpack_function_name(libraw_data_t* lr);",
          "75: DllDef    int                 libraw_get_decoder_info(libraw_data_t* lr,libraw_decoder_info_t* d);",
          "78: DllDef    int                 libraw_adjust_sizes_info_only(libraw_data_t*);",
          "79: DllDef    int                 libraw_dcraw_document_mode_processing(libraw_data_t*);",
          "80: DllDef    int                 libraw_dcraw_ppm_tiff_writer(libraw_data_t* lr,const char *filename);",
          "81: DllDef    int                 libraw_dcraw_thumb_writer(libraw_data_t* lr,const char *fname);",
          "82: DllDef    int                 libraw_dcraw_process(libraw_data_t* lr);",
          "83: DllDef    libraw_processed_image_t* libraw_dcraw_make_mem_image(libraw_data_t* lr, int *errc);",
          "84: DllDef    libraw_processed_image_t* libraw_dcraw_make_mem_thumb(libraw_data_t* lr, int *errc);",
          "85: DllDef    void libraw_dcraw_clear_mem(libraw_processed_image_t*);",
          "86: #ifdef __cplusplus",
          "87: }",
          "88: #endif",
          "91: #ifdef __cplusplus",
          "93: class DllDef LibRaw",
          "94: {",
          "95:   public:",
          "96:     libraw_data_t imgdata;",
          "97:     int verbose;",
          "99:     LibRaw(unsigned int flags = LIBRAW_OPTIONS_NONE);",
          "101:     libraw_output_params_t*     output_params_ptr() { return &imgdata.params;}",
          "102:     int                         open_file(const char *fname, INT64 max_buffered_sz=LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "103: #ifdef WIN32",
          "104:  int                         open_file(const wchar_t *fname, INT64 max_buffered_sz=LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "105: #endif",
          "106:     int                         open_buffer(void *buffer, size_t size);",
          "107:     int                         open_datastream(LibRaw_abstract_datastream *);",
          "108:     int                         unpack(void);",
          "109:     int                         unpack_thumb(void);",
          "111:     int                         adjust_sizes_info_only(void);",
          "112:     void                        subtract_black();",
          "113:     int                         raw2image();",
          "114:     int                         raw2image_ex();",
          "115:     void                        raw2image_start();",
          "116:     void                        free_image();",
          "117:     int                         adjust_maximum();",
          "118:     void                        set_memerror_handler( memory_callback cb,void *data) {callbacks.memcb_data = data; callbacks.mem_cb = cb; }",
          "119:     void                        set_dataerror_handler(data_callback func, void *data) { callbacks.datacb_data = data; callbacks.data_cb = func;}",
          "120:     void                        set_progress_handler(progress_callback pcb, void *data) { callbacks.progresscb_data = data; callbacks.progress_cb = pcb;}",
          "123:     static const char*          version();",
          "124:     static int                  versionNumber();",
          "125:     static const char**         cameraList();",
          "126:     static int                  cameraCount();",
          "127:     static const char*          strprogress(enum LibRaw_progress);",
          "128:     static const char*          strerror(int p);",
          "130:     int                         dcraw_document_mode_processing();",
          "131:     int                         dcraw_ppm_tiff_writer(const char *filename);",
          "132:     int                         dcraw_thumb_writer(const char *fname);",
          "133:     int                         dcraw_process(void);",
          "135:     virtual libraw_processed_image_t*   dcraw_make_mem_image(int *errcode=NULL);",
          "136:     virtual libraw_processed_image_t*   dcraw_make_mem_thumb(int *errcode=NULL);",
          "137:     static void                 dcraw_clear_mem(libraw_processed_image_t*);",
          "140:     void get_mem_image_format(int* width, int* height, int* colors, int* bps) const;",
          "141:     int  copy_mem_image(void* scan0, int stride, int bgr);",
          "144:     void         recycle();",
          "145:     ~LibRaw(void) { recycle(); delete tls; }",
          "147:     int COLOR(int row, int col) { return libraw_internal_data.internal_output_params.fuji_width? FCF(row,col):FC(row,col);}",
          "149:     int FC(int row,int col) { return (imgdata.idata.filters >> (((row << 1 & 14) | (col & 1)) << 1) & 3);}",
          "150:     int         fcol (int row, int col);",
          "152:     const char *unpack_function_name();",
          "153:     int get_decoder_info(libraw_decoder_info_t* d_info);",
          "154:     libraw_internal_data_t * get_internal_data_pointer(){ return &libraw_internal_data; }",
          "157:     int                         wf_remove_banding();",
          "160: protected:",
          "162:     int FCF(int row,int col) {",
          "163:         int rr,cc;",
          "164:         if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "165:             rr = libraw_internal_data.internal_output_params.fuji_width - 1 - col + (row >> 1);",
          "166:             cc = col + ((row+1) >> 1);",
          "167:         } else {",
          "168:             rr = libraw_internal_data.internal_output_params.fuji_width - 1 + row - (col >> 1);",
          "169:             cc = row + ((col+1) >> 1);",
          "170:         }",
          "171:         return FC(rr,cc);",
          "172:     }",
          "174:     void*        malloc(size_t t);",
          "175:     void*        calloc(size_t n,size_t t);",
          "176:     void*        realloc(void *p, size_t s);",
          "177:     void        free(void *p);",
          "178:     void        merror (void *ptr, const char *where);",
          "179:     void        derror();",
          "181:     LibRaw_TLS  *tls;",
          "182:     libraw_internal_data_t libraw_internal_data;",
          "183:     decode      first_decode[2048], *second_decode, *free_decode;",
          "184:     tiff_ifd_t  tiff_ifd[10];",
          "185:     libraw_memmgr memmgr;",
          "186:     libraw_callbacks_t callbacks;",
          "188:     LibRaw_constants rgb_constants;",
          "189:     void        (LibRaw:: *write_thumb)();",
          "190:     void        (LibRaw:: *write_fun)();",
          "191:     void        (LibRaw:: *load_raw)();",
          "192:     void        (LibRaw:: *thumb_load_raw)();",
          "194:     void        kodak_thumb_loader();",
          "195:     void        write_thumb_ppm_tiff(FILE *);",
          "196:     void        foveon_thumb_loader (void);",
          "198:     int         own_filtering_supported(){ return 0;}",
          "199:     void        identify();",
          "200:     void        identify2(unsigned, unsigned, char*);",
          "201:     void        write_ppm_tiff ();",
          "202:     void        convert_to_rgb();",
          "203:  virtual  void convert_to_rgb_loop(float out_cam[3][4]);",
          "204:     void        remove_zeroes();",
          "205:     void        crop_masked_pixels();",
          "206: #ifndef NO_LCMS",
          "207:     void apply_profile(const char*,const char*);",
          "208: #endif",
          "209:     void        pre_interpolate();",
          "210:     void        border_interpolate (int border);",
          "211:     void        lin_interpolate();",
          "212:     void        vng_interpolate();",
          "213:     void        ppg_interpolate();",
          "214:     void        ahd_interpolate();",
          "217:     void        ahd_interpolate_mod();",
          "218:     void        afd_interpolate_pl(int afd_passes, int clip_on);",
          "219:     void        afd_noise_filter_pl();",
          "220:     void lmmse_interpolate(int gamma_apply);",
          "221:     void        dcb(int iterations, int dcb_enhance);",
          "222:     void        fbdd(int noiserd);",
          "223:     void        vcd_interpolate(int ahd_cutoff);",
          "224:     void        amaze_demosaic_RT();",
          "225:     void exp_bef(float expos, float preser);",
          "226:     void        CA_correct_RT(float cared, float cablue);",
          "227:     void        cfa_linedn(float linenoise);",
          "228:     void        cfa_impulse_gauss(float lclean, float cclean);",
          "229:     void        green_equilibrate(float thresh);",
          "233:     void        bad_pixels(const char*);",
          "234:     void        subtract(const char*);",
          "235:     void        hat_transform (float *temp, float *base, int st, int size, int sc);",
          "236:     void        wavelet_denoise();",
          "237:     void        scale_colors();",
          "238:  virtual void scale_colors_loop(float scale_mul[4]);",
          "239:     void        median_filter ();",
          "240:     void        blend_highlights();",
          "241:     void        recover_highlights();",
          "242:     void        green_matching();",
          "244:     void        fuji_rotate();",
          "245:     void        stretch();",
          "247:     void        foveon_thumb ();",
          "248:     void        jpeg_thumb_writer (FILE *tfp,char *thumb,int thumb_length);",
          "249:     void        jpeg_thumb ();",
          "250:     void        ppm_thumb ();",
          "251:     void        ppm16_thumb();",
          "252:     void        layer_thumb ();",
          "253:     void        rollei_thumb ();",
          "254:     void        kodak_thumb_load_raw();",
          "256:     void        foveon_decoder (unsigned size, unsigned code);",
          "257:     unsigned    get4();",
          "259:     int         flip_index (int row, int col);",
          "260:     void        gamma_curve (double pwr, double ts, int mode, int imax);",
          "263: #ifdef LIBRAW_LIBRARY_BUILD",
          "264: #include \"internal/libraw_internal_funcs.h\"",
          "265: #endif",
          "267: };",
          "269: #ifdef LIBRAW_LIBRARY_BUILD",
          "270: #define RUN_CALLBACK(stage,iter,expect)  if(callbacks.progress_cb) { \\",
          "271:         int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,stage,iter,expect); \\",
          "272:         if(rr!=0) throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK; \\",
          "273:     }",
          "274: #endif",
          "",
          "---------------"
        ],
        "libraw/libraw_const.h||libraw/libraw_const.h": [
          "File: libraw/libraw_const.h -> libraw/libraw_const.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "7: LibRaw is free software; you can redistribute it and/or modify",
          "8: it under the terms of the one of three licenses as you choose:",
          "10: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "11:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "13: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "14:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "16: 3. LibRaw Software License 27032010",
          "17:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "21: #ifndef _LIBRAW_ERRORS_H",
          "22: #define _LIBRAW_ERRORS_H",
          "24: #define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75",
          "25: #define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01",
          "27: enum LibRaw_decoder_flags",
          "28: {",
          "29:     LIBRAW_DECODER_LEGACY = 1,",
          "30:     LIBRAW_DECODER_FLATFIELD = 1<<1,",
          "31:     LIBRAW_DECODER_4COMPONENT = 1<<2,",
          "32:     LIBRAW_DECODER_USEBAYER2 = 1<<3,",
          "33:     LIBRAW_DECODER_HASCURVE = 1<<4,",
          "34:  LIBRAW_DECODER_ITSASONY = 1<<5,",
          "35:     LIBRAW_DECODER_NOTSET = 1<<15",
          "36: };",
          "39: enum LibRaw_constructor_flags",
          "40: {",
          "41:     LIBRAW_OPTIONS_NONE         =0,",
          "42:     LIBRAW_OPIONS_NO_MEMERR_CALLBACK=1,",
          "43:     LIBRAW_OPIONS_NO_DATAERR_CALLBACK=1<<1",
          "44: };",
          "46: enum LibRaw_warnings",
          "47: {",
          "48:     LIBRAW_WARN_NONE            =0,",
          "49:     LIBRAW_WARN_FOVEON_NOMATRIX =1,",
          "50:     LIBRAW_WARN_FOVEON_INVALIDWB =1<<1,",
          "51:     LIBRAW_WARN_BAD_CAMERA_WB   =1<<2,",
          "52:     LIBRAW_WARN_NO_METADATA     =1<<3,",
          "53:     LIBRAW_WARN_NO_JPEGLIB     = 1<<4,",
          "54:     LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1<<5,",
          "55:     LIBRAW_WARN_NO_INPUT_PROFILE = 1<<6,",
          "56:     LIBRAW_WARN_BAD_OUTPUT_PROFILE= 1<<7,",
          "57:     LIBRAW_WARN_NO_BADPIXELMAP=1<<8,",
          "58:     LIBRAW_WARN_BAD_DARKFRAME_FILE=1<<9,",
          "59:     LIBRAW_WARN_BAD_DARKFRAME_DIM=1<<10,",
          "60:     LIBRAW_WARN_NO_JASPER = 1<<11",
          "61: };",
          "63: enum LibRaw_exceptions",
          "64: {",
          "65:     LIBRAW_EXCEPTION_NONE       =0,",
          "66:     LIBRAW_EXCEPTION_ALLOC      =1,",
          "67:     LIBRAW_EXCEPTION_DECODE_RAW =2,",
          "68:     LIBRAW_EXCEPTION_DECODE_JPEG=3,",
          "69:     LIBRAW_EXCEPTION_IO_EOF     =4,",
          "70:     LIBRAW_EXCEPTION_IO_CORRUPT =5,",
          "71:     LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK=6,",
          "72:     LIBRAW_EXCEPTION_BAD_CROP =7,",
          "73:     LIBRAW_EXCEPTION_IO_BADFILE =8,",
          "74:     LIBRAW_EXCEPTION_DECODE_JPEG2000=9",
          "75: };",
          "78: enum LibRaw_colorstate",
          "79: {",
          "80:     LIBRAW_COLORSTATE_UNKNOWN   =0,",
          "81:     LIBRAW_COLORSTATE_INIT      =1,",
          "82:     LIBRAW_COLORSTATE_CONST     =2,",
          "83:     LIBRAW_COLORSTATE_LOADED    =3,",
          "84:     LIBRAW_COLORSTATE_CALCULATED=4,",
          "85:     LIBRAW_COLORSTATE_RESERVED1 =5,",
          "86:     LIBRAW_COLORSTATE_RESERVED2 =6,",
          "87:     LIBRAW_COLORSTATE_RESERVED3 =7",
          "88: };",
          "90: enum LibRaw_progress",
          "91: {",
          "92:     LIBRAW_PROGRESS_START               = 0,",
          "93:     LIBRAW_PROGRESS_OPEN                = 1,",
          "94:     LIBRAW_PROGRESS_IDENTIFY            = 1<<1,",
          "95:     LIBRAW_PROGRESS_SIZE_ADJUST         = 1<<2,",
          "96:     LIBRAW_PROGRESS_LOAD_RAW            = 1<<3,",
          "97:     LIBRAW_PROGRESS_REMOVE_ZEROES       = 1<<4,",
          "98:     LIBRAW_PROGRESS_BAD_PIXELS          = 1<<5,",
          "99:     LIBRAW_PROGRESS_DARK_FRAME          = 1<<6,",
          "100:     LIBRAW_PROGRESS_FOVEON_INTERPOLATE  = 1<<7,",
          "101:     LIBRAW_PROGRESS_SCALE_COLORS        = 1<<8,",
          "102:     LIBRAW_PROGRESS_PRE_INTERPOLATE     = 1<<9,",
          "103:     LIBRAW_PROGRESS_INTERPOLATE         = 1<<10,",
          "104:     LIBRAW_PROGRESS_MIX_GREEN           = 1<<11,",
          "105:     LIBRAW_PROGRESS_MEDIAN_FILTER       = 1<<12,",
          "106:     LIBRAW_PROGRESS_HIGHLIGHTS          = 1<<13,",
          "107:     LIBRAW_PROGRESS_FUJI_ROTATE         = 1<<14,",
          "108:     LIBRAW_PROGRESS_FLIP                = 1<<15,",
          "109:     LIBRAW_PROGRESS_APPLY_PROFILE       = 1<<16,",
          "110:     LIBRAW_PROGRESS_CONVERT_RGB         = 1<<17,",
          "111:     LIBRAW_PROGRESS_STRETCH             = 1<<18,",
          "113:     LIBRAW_PROGRESS_STAGE19             = 1<<19,",
          "114:     LIBRAW_PROGRESS_STAGE20             = 1<<20,",
          "115:     LIBRAW_PROGRESS_STAGE21             = 1<<21,",
          "116:     LIBRAW_PROGRESS_STAGE22             = 1<<22,",
          "117:     LIBRAW_PROGRESS_STAGE23             = 1<<23,",
          "118:     LIBRAW_PROGRESS_STAGE24             = 1<<24,",
          "119:     LIBRAW_PROGRESS_STAGE25             = 1<<25,",
          "120:     LIBRAW_PROGRESS_STAGE26             = 1<<26,",
          "121:     LIBRAW_PROGRESS_STAGE27             = 1<<27,",
          "123:     LIBRAW_PROGRESS_THUMB_LOAD          = 1<<28,",
          "124:     LIBRAW_PROGRESS_TRESERVED1          = 1<<29,",
          "125:     LIBRAW_PROGRESS_TRESERVED2          = 1<<30,",
          "126:     LIBRAW_PROGRESS_TRESERVED3          = 1<<31",
          "127: };",
          "128: #define LIBRAW_PROGRESS_THUMB_MASK 0x0fffffff",
          "130: enum LibRaw_errors",
          "131: {",
          "132:     LIBRAW_SUCCESS = 0,",
          "133:     LIBRAW_UNSPECIFIED_ERROR=-1,",
          "134:     LIBRAW_FILE_UNSUPPORTED = -2,",
          "135:     LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE=-3,",
          "136:     LIBRAW_OUT_OF_ORDER_CALL=-4,",
          "137:     LIBRAW_NO_THUMBNAIL=-5,",
          "138:     LIBRAW_UNSUPPORTED_THUMBNAIL=-6,",
          "139:     LIBRAW_UNSUFFICIENT_MEMORY=-100007,",
          "140:     LIBRAW_DATA_ERROR=-100008,",
          "141:     LIBRAW_IO_ERROR=-100009,",
          "142:     LIBRAW_CANCELLED_BY_CALLBACK=-100010,",
          "143:     LIBRAW_BAD_CROP=-100011",
          "144: };",
          "146: #define LIBRAW_FATAL_ERROR(ec) ((ec)<-100000)",
          "148: enum LibRaw_thumbnail_formats",
          "149: {",
          "150:     LIBRAW_THUMBNAIL_UNKNOWN=0,",
          "151:     LIBRAW_THUMBNAIL_JPEG=1,",
          "152:     LIBRAW_THUMBNAIL_BITMAP=2,",
          "153:     LIBRAW_THUMBNAIL_LAYER=4,",
          "154:     LIBRAW_THUMBNAIL_ROLLEI=5",
          "155: };",
          "157: enum LibRaw_image_formats",
          "158: {",
          "159:     LIBRAW_IMAGE_JPEG=1,",
          "160:     LIBRAW_IMAGE_BITMAP=2",
          "161: };",
          "163: #endif",
          "",
          "[Added Lines]",
          "6: LibRaw is free software; you can redistribute it and/or modify",
          "7: it under the terms of the one of three licenses as you choose:",
          "9: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "10:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "12: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "13:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "15: 3. LibRaw Software License 27032010",
          "16:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "20: #ifndef _LIBRAW_ERRORS_H",
          "21: #define _LIBRAW_ERRORS_H",
          "23: #define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75",
          "24: #define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01",
          "26: enum LibRaw_decoder_flags",
          "27: {",
          "28:     LIBRAW_DECODER_LEGACY = 1,",
          "29:     LIBRAW_DECODER_FLATFIELD = 1<<1,",
          "30:     LIBRAW_DECODER_USEBAYER2 = 1<<3,",
          "31:     LIBRAW_DECODER_HASCURVE = 1<<4,",
          "32:     LIBRAW_DECODER_ITSASONY = 1<<5,",
          "33:     LIBRAW_DECODER_NOTSET = 1<<15",
          "34: };",
          "37: enum LibRaw_constructor_flags",
          "38: {",
          "39:     LIBRAW_OPTIONS_NONE         =0,",
          "40:     LIBRAW_OPIONS_NO_MEMERR_CALLBACK=1,",
          "41:     LIBRAW_OPIONS_NO_DATAERR_CALLBACK=1<<1",
          "42: };",
          "44: enum LibRaw_warnings",
          "45: {",
          "46:     LIBRAW_WARN_NONE            =0,",
          "47:     LIBRAW_WARN_FOVEON_NOMATRIX =1,",
          "48:     LIBRAW_WARN_FOVEON_INVALIDWB =1<<1,",
          "49:     LIBRAW_WARN_BAD_CAMERA_WB   =1<<2,",
          "50:     LIBRAW_WARN_NO_METADATA     =1<<3,",
          "51:     LIBRAW_WARN_NO_JPEGLIB     = 1<<4,",
          "52:     LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1<<5,",
          "53:     LIBRAW_WARN_NO_INPUT_PROFILE = 1<<6,",
          "54:     LIBRAW_WARN_BAD_OUTPUT_PROFILE= 1<<7,",
          "55:     LIBRAW_WARN_NO_BADPIXELMAP=1<<8,",
          "56:     LIBRAW_WARN_BAD_DARKFRAME_FILE=1<<9,",
          "57:     LIBRAW_WARN_BAD_DARKFRAME_DIM=1<<10,",
          "58:     LIBRAW_WARN_NO_JASPER = 1<<11",
          "59: };",
          "61: enum LibRaw_exceptions",
          "62: {",
          "63:     LIBRAW_EXCEPTION_NONE       =0,",
          "64:     LIBRAW_EXCEPTION_ALLOC      =1,",
          "65:     LIBRAW_EXCEPTION_DECODE_RAW =2,",
          "66:     LIBRAW_EXCEPTION_DECODE_JPEG=3,",
          "67:     LIBRAW_EXCEPTION_IO_EOF     =4,",
          "68:     LIBRAW_EXCEPTION_IO_CORRUPT =5,",
          "69:     LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK=6,",
          "70:     LIBRAW_EXCEPTION_BAD_CROP =7,",
          "71:     LIBRAW_EXCEPTION_IO_BADFILE =8,",
          "72:     LIBRAW_EXCEPTION_DECODE_JPEG2000=9",
          "73: };",
          "76: enum LibRaw_colorstate",
          "77: {",
          "78:     LIBRAW_COLORSTATE_UNKNOWN   =0,",
          "79:     LIBRAW_COLORSTATE_INIT      =1,",
          "80:     LIBRAW_COLORSTATE_CONST     =2,",
          "81:     LIBRAW_COLORSTATE_LOADED    =3,",
          "82:     LIBRAW_COLORSTATE_CALCULATED=4,",
          "83:     LIBRAW_COLORSTATE_RESERVED1 =5,",
          "84:     LIBRAW_COLORSTATE_RESERVED2 =6,",
          "85:     LIBRAW_COLORSTATE_RESERVED3 =7",
          "86: };",
          "88: enum LibRaw_progress",
          "89: {",
          "90:     LIBRAW_PROGRESS_START               = 0,",
          "91:     LIBRAW_PROGRESS_OPEN                = 1,",
          "92:     LIBRAW_PROGRESS_IDENTIFY            = 1<<1,",
          "93:     LIBRAW_PROGRESS_SIZE_ADJUST         = 1<<2,",
          "94:     LIBRAW_PROGRESS_LOAD_RAW            = 1<<3,",
          "95:     LIBRAW_PROGRESS_REMOVE_ZEROES       = 1<<4,",
          "96:     LIBRAW_PROGRESS_BAD_PIXELS          = 1<<5,",
          "97:     LIBRAW_PROGRESS_DARK_FRAME          = 1<<6,",
          "98:     LIBRAW_PROGRESS_FOVEON_INTERPOLATE  = 1<<7,",
          "99:     LIBRAW_PROGRESS_SCALE_COLORS        = 1<<8,",
          "100:     LIBRAW_PROGRESS_PRE_INTERPOLATE     = 1<<9,",
          "101:     LIBRAW_PROGRESS_INTERPOLATE         = 1<<10,",
          "102:     LIBRAW_PROGRESS_MIX_GREEN           = 1<<11,",
          "103:     LIBRAW_PROGRESS_MEDIAN_FILTER       = 1<<12,",
          "104:     LIBRAW_PROGRESS_HIGHLIGHTS          = 1<<13,",
          "105:     LIBRAW_PROGRESS_FUJI_ROTATE         = 1<<14,",
          "106:     LIBRAW_PROGRESS_FLIP                = 1<<15,",
          "107:     LIBRAW_PROGRESS_APPLY_PROFILE       = 1<<16,",
          "108:     LIBRAW_PROGRESS_CONVERT_RGB         = 1<<17,",
          "109:     LIBRAW_PROGRESS_STRETCH             = 1<<18,",
          "111:     LIBRAW_PROGRESS_STAGE19             = 1<<19,",
          "112:     LIBRAW_PROGRESS_STAGE20             = 1<<20,",
          "113:     LIBRAW_PROGRESS_STAGE21             = 1<<21,",
          "114:     LIBRAW_PROGRESS_STAGE22             = 1<<22,",
          "115:     LIBRAW_PROGRESS_STAGE23             = 1<<23,",
          "116:     LIBRAW_PROGRESS_STAGE24             = 1<<24,",
          "117:     LIBRAW_PROGRESS_STAGE25             = 1<<25,",
          "118:     LIBRAW_PROGRESS_STAGE26             = 1<<26,",
          "119:     LIBRAW_PROGRESS_STAGE27             = 1<<27,",
          "121:     LIBRAW_PROGRESS_THUMB_LOAD          = 1<<28,",
          "122:     LIBRAW_PROGRESS_TRESERVED1          = 1<<29,",
          "123:     LIBRAW_PROGRESS_TRESERVED2          = 1<<30,",
          "124:     LIBRAW_PROGRESS_TRESERVED3          = 1<<31",
          "125: };",
          "126: #define LIBRAW_PROGRESS_THUMB_MASK 0x0fffffff",
          "128: enum LibRaw_errors",
          "129: {",
          "130:     LIBRAW_SUCCESS = 0,",
          "131:     LIBRAW_UNSPECIFIED_ERROR=-1,",
          "132:     LIBRAW_FILE_UNSUPPORTED = -2,",
          "133:     LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE=-3,",
          "134:     LIBRAW_OUT_OF_ORDER_CALL=-4,",
          "135:     LIBRAW_NO_THUMBNAIL=-5,",
          "136:     LIBRAW_UNSUPPORTED_THUMBNAIL=-6,",
          "137:     LIBRAW_UNSUFFICIENT_MEMORY=-100007,",
          "138:     LIBRAW_DATA_ERROR=-100008,",
          "139:     LIBRAW_IO_ERROR=-100009,",
          "140:     LIBRAW_CANCELLED_BY_CALLBACK=-100010,",
          "141:     LIBRAW_BAD_CROP=-100011",
          "142: };",
          "144: #define LIBRAW_FATAL_ERROR(ec) ((ec)<-100000)",
          "146: enum LibRaw_thumbnail_formats",
          "147: {",
          "148:     LIBRAW_THUMBNAIL_UNKNOWN=0,",
          "149:     LIBRAW_THUMBNAIL_JPEG=1,",
          "150:     LIBRAW_THUMBNAIL_BITMAP=2,",
          "151:     LIBRAW_THUMBNAIL_LAYER=4,",
          "152:     LIBRAW_THUMBNAIL_ROLLEI=5",
          "153: };",
          "155: enum LibRaw_image_formats",
          "156: {",
          "157:     LIBRAW_IMAGE_JPEG=1,",
          "158:     LIBRAW_IMAGE_BITMAP=2",
          "159: };",
          "161: #endif",
          "",
          "---------------"
        ],
        "libraw/libraw_datastream.h||libraw/libraw_datastream.h": [
          "File: libraw/libraw_datastream.h -> libraw/libraw_datastream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "8: LibRaw is free software; you can redistribute it and/or modify",
          "9: it under the terms of the one of three licenses as you choose:",
          "11: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "12:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "14: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "15:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "17: 3. LibRaw Software License 27032010",
          "18:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "22: #ifndef __LIBRAW_DATASTREAM_H",
          "23: #define __LIBRAW_DATASTREAM_H",
          "25: #include <stdio.h>",
          "26: #include <sys/types.h>",
          "27: #include <errno.h>",
          "28: #include <string.h>",
          "30: #ifndef __cplusplus",
          "35: #include \"libraw_const.h\"",
          "36: #include \"libraw_types.h\"",
          "37: #include <fstream>",
          "38: #include <memory>",
          "40: #if defined (WIN32)",
          "41: #include <winsock2.h>",
          "44: #if _MSC_VER >= 1500",
          "45: #define WIN32SECURECALLS",
          "46: #endif",
          "47: #endif",
          "49: #define IOERROR() do { throw LIBRAW_EXCEPTION_IO_EOF; } while(0)",
          "51: class LibRaw_buffer_datastream;",
          "52: class LibRaw_byte_buffer;",
          "53: class LibRaw_bit_buffer;",
          "55: class DllDef LibRaw_abstract_datastream",
          "56: {",
          "57:   public:",
          "58:     LibRaw_abstract_datastream(){ substream=0;};",
          "59:     virtual             ~LibRaw_abstract_datastream(void){if(substream) delete substream;}",
          "60:     virtual int         valid() = 0;",
          "61:     virtual int         read(void *,size_t, size_t ) = 0;",
          "62:     virtual int         seek(INT64 , int ) = 0;",
          "63:     virtual INT64       tell() = 0;",
          "64:     virtual int         get_char() = 0;",
          "65:     virtual char*       gets(char *, int) = 0;",
          "66:     virtual int         scanf_one(const char *, void *) = 0;",
          "67:     virtual int         eof() = 0;",
          "68:     virtual void *      make_jas_stream() = 0;",
          "70:     virtual LibRaw_byte_buffer *make_byte_buffer(unsigned int sz);",
          "73:     virtual const char* fname(){ return NULL;};",
          "74: #ifdef WIN32",
          "75:  virtual const wchar_t* wfname(){ return NULL;};",
          "76:  virtual int         subfile_open(const wchar_t*) { return -1;}",
          "77: #endif",
          "78:     virtual int         subfile_open(const char*) { return -1;}",
          "79:     virtual void        subfile_close() { }",
          "82:     virtual int  tempbuffer_open(void*, size_t);",
          "83:     virtual void tempbuffer_close();",
          "85:   protected:",
          "86:     LibRaw_abstract_datastream *substream;",
          "87: };",
          "89: #ifdef WIN32",
          "90: template class DllDef std::auto_ptr<std::streambuf>;",
          "91: #endif",
          "93: class DllDef  LibRaw_file_datastream: public LibRaw_abstract_datastream",
          "94: {",
          "95:   protected:",
          "98:     const char *filename;",
          "99: #ifdef WIN32",
          "100:  const wchar_t *wfilename;",
          "101:  FILE *jas_file;",
          "102: #endif",
          "103:   public:",
          "104:     virtual             ~LibRaw_file_datastream();",
          "105:                         LibRaw_file_datastream(const char *fname);",
          "106: #ifdef WIN32",
          "107:       LibRaw_file_datastream(const wchar_t *fname);",
          "108: #endif",
          "109:     virtual void        *make_jas_stream();",
          "110:     virtual int         valid();",
          "111:     virtual int         read(void * ptr,size_t size, size_t nmemb);",
          "112:     virtual int         eof();",
          "113:     virtual int         seek(INT64 o, int whence);",
          "114:     virtual INT64       tell();",
          "115:     virtual int         get_char()",
          "116:         {",
          "117:             if(substream) return substream->get_char();",
          "118:             return f->sbumpc();",
          "119:         }",
          "120:     virtual char*       gets(char *str, int sz);",
          "121:     virtual int         scanf_one(const char *fmt, void*val);",
          "122:     virtual const char* fname();",
          "123: #ifdef WIN32",
          "124:  virtual const wchar_t* wfname() { return wfilename;}",
          "125:  virtual int         subfile_open(const wchar_t *fn);",
          "126: #endif",
          "127:     virtual int         subfile_open(const char *fn);",
          "128:     virtual void        subfile_close();",
          "129: };",
          "132: class DllDef  LibRaw_buffer_datastream : public LibRaw_abstract_datastream",
          "133: {",
          "134:   public:",
          "135:                         LibRaw_buffer_datastream(void *buffer, size_t bsize);",
          "136:     virtual             ~LibRaw_buffer_datastream();",
          "137:     virtual int         valid();",
          "138:     virtual void        *make_jas_stream();",
          "139:     virtual LibRaw_byte_buffer *make_byte_buffer(unsigned int sz);",
          "140:     virtual int         read(void * ptr,size_t sz, size_t nmemb);",
          "141:     virtual int         eof();",
          "142:     virtual int         seek(INT64 o, int whence);",
          "143:     virtual INT64       tell();",
          "144:     virtual char*       gets(char *s, int sz);",
          "145:     virtual int         scanf_one(const char *fmt, void* val);",
          "146:     virtual int         get_char()",
          "147:     {",
          "148:         if(substream) return substream->get_char();",
          "149:         if(streampos>=streamsize)",
          "150:             return -1;",
          "151:         return buf[streampos++];",
          "152:     }",
          "154:   private:",
          "155:     unsigned char *buf;",
          "156:     size_t   streampos,streamsize;",
          "157: };",
          "159: class DllDef LibRaw_bigfile_datastream : public LibRaw_abstract_datastream",
          "160: {",
          "161:   public:",
          "162:                         LibRaw_bigfile_datastream(const char *fname);",
          "163: #ifdef WIN32",
          "164:       LibRaw_bigfile_datastream(const wchar_t *fname);",
          "165: #endif",
          "166:     virtual             ~LibRaw_bigfile_datastream();",
          "167:     virtual int         valid();",
          "168:     virtual void *make_jas_stream();",
          "170:     virtual int         read(void * ptr,size_t size, size_t nmemb);",
          "171:     virtual int         eof();",
          "172:     virtual int         seek(INT64 o, int whence);",
          "173:     virtual INT64       tell();",
          "174:     virtual char*       gets(char *str, int sz);",
          "175:     virtual int         scanf_one(const char *fmt, void*val);",
          "176:     virtual const char *fname();",
          "177: #ifdef WIN32",
          "178:  virtual const wchar_t* wfname() { return wfilename;}",
          "179:  virtual int         subfile_open(const wchar_t *fn);",
          "180: #endif",
          "181:     virtual int         subfile_open(const char *fn);",
          "182:     virtual void        subfile_close();",
          "183:     virtual int         get_char()",
          "184:     {",
          "185: #ifndef WIN32",
          "186:         return substream?substream->get_char():getc_unlocked(f);",
          "187: #else",
          "188:         return substream?substream->get_char():fgetc(f);",
          "189: #endif",
          "190:     }",
          "192:   private:",
          "193:     FILE *f,*sav;",
          "194:     const char *filename;",
          "195: #ifdef WIN32",
          "196:  const wchar_t *wfilename;",
          "197: #endif",
          "198: };",
          "200: #ifdef WIN32",
          "201: class DllDef  LibRaw_windows_datastream : public LibRaw_buffer_datastream",
          "202: {",
          "203: public:",
          "205:     LibRaw_windows_datastream(const TCHAR* sFile);",
          "207:     LibRaw_windows_datastream(HANDLE hFile);",
          "209:     virtual ~LibRaw_windows_datastream();",
          "211: protected:",
          "212:     void Open(HANDLE hFile);",
          "213:     inline void reconstruct_base()",
          "214:  {",
          "216:             (LibRaw_buffer_datastream&)*this = LibRaw_buffer_datastream(pView_, (size_t)cbView_);",
          "217:  }",
          "222: };",
          "224: #endif",
          "229: #endif",
          "",
          "[Added Lines]",
          "8: LibRaw is free software; you can redistribute it and/or modify",
          "9: it under the terms of the one of three licenses as you choose:",
          "11: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "12:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "14: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "15:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "17: 3. LibRaw Software License 27032010",
          "18:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "22: #ifndef __LIBRAW_DATASTREAM_H",
          "23: #define __LIBRAW_DATASTREAM_H",
          "25: #include <stdio.h>",
          "26: #include <sys/types.h>",
          "27: #include <errno.h>",
          "28: #include <string.h>",
          "30: #ifndef __cplusplus",
          "35: #include \"libraw_const.h\"",
          "36: #include \"libraw_types.h\"",
          "37: #include <fstream>",
          "38: #include <memory>",
          "40: #if defined (WIN32)",
          "41: #include <winsock2.h>",
          "44: #if _MSC_VER >= 1500",
          "45: #define WIN32SECURECALLS",
          "46: #endif",
          "47: #endif",
          "49: #define IOERROR() do { throw LIBRAW_EXCEPTION_IO_EOF; } while(0)",
          "51: class LibRaw_buffer_datastream;",
          "52: class LibRaw_byte_buffer;",
          "53: class LibRaw_bit_buffer;",
          "55: class DllDef LibRaw_abstract_datastream",
          "56: {",
          "57:   public:",
          "58:     LibRaw_abstract_datastream(){ substream=0;};",
          "59:     virtual             ~LibRaw_abstract_datastream(void){if(substream) delete substream;}",
          "60:     virtual int         valid() = 0;",
          "61:     virtual int         read(void *,size_t, size_t ) = 0;",
          "62:     virtual int         seek(INT64 , int ) = 0;",
          "63:     virtual INT64       tell() = 0;",
          "64:     virtual int         get_char() = 0;",
          "65:     virtual char*       gets(char *, int) = 0;",
          "66:     virtual int         scanf_one(const char *, void *) = 0;",
          "67:     virtual int         eof() = 0;",
          "68:     virtual void *      make_jas_stream() = 0;",
          "70:     virtual LibRaw_byte_buffer *make_byte_buffer(unsigned int sz);",
          "73:     virtual const char* fname(){ return NULL;};",
          "74: #ifdef WIN32",
          "75:  virtual const wchar_t* wfname(){ return NULL;};",
          "76:  virtual int         subfile_open(const wchar_t*) { return -1;}",
          "77: #endif",
          "78:     virtual int         subfile_open(const char*) { return -1;}",
          "79:     virtual void        subfile_close() { }",
          "82:     virtual int  tempbuffer_open(void*, size_t);",
          "83:     virtual void tempbuffer_close();",
          "85:   protected:",
          "86:     LibRaw_abstract_datastream *substream;",
          "87: };",
          "89: #ifdef WIN32",
          "90: template class DllDef std::auto_ptr<std::streambuf>;",
          "91: #endif",
          "93: class DllDef  LibRaw_file_datastream: public LibRaw_abstract_datastream",
          "94: {",
          "95:   protected:",
          "98:     const char *filename;",
          "99: #ifdef WIN32",
          "100:  const wchar_t *wfilename;",
          "101:  FILE *jas_file;",
          "102: #endif",
          "103:   public:",
          "104:     virtual             ~LibRaw_file_datastream();",
          "105:                         LibRaw_file_datastream(const char *fname);",
          "106: #ifdef WIN32",
          "107:       LibRaw_file_datastream(const wchar_t *fname);",
          "108: #endif",
          "109:     virtual void        *make_jas_stream();",
          "110:     virtual int         valid();",
          "111:     virtual int         read(void * ptr,size_t size, size_t nmemb);",
          "112:     virtual int         eof();",
          "113:     virtual int         seek(INT64 o, int whence);",
          "114:     virtual INT64       tell();",
          "115:     virtual int         get_char()",
          "116:         {",
          "117:             if(substream) return substream->get_char();",
          "118:             return f->sbumpc();",
          "119:         }",
          "120:     virtual char*       gets(char *str, int sz);",
          "121:     virtual int         scanf_one(const char *fmt, void*val);",
          "122:     virtual const char* fname();",
          "123: #ifdef WIN32",
          "124:  virtual const wchar_t* wfname() { return wfilename;}",
          "125:  virtual int         subfile_open(const wchar_t *fn);",
          "126: #endif",
          "127:     virtual int         subfile_open(const char *fn);",
          "128:     virtual void        subfile_close();",
          "129: };",
          "132: class DllDef  LibRaw_buffer_datastream : public LibRaw_abstract_datastream",
          "133: {",
          "134:   public:",
          "135:                         LibRaw_buffer_datastream(void *buffer, size_t bsize);",
          "136:     virtual             ~LibRaw_buffer_datastream();",
          "137:     virtual int         valid();",
          "138:     virtual void        *make_jas_stream();",
          "139:     virtual LibRaw_byte_buffer *make_byte_buffer(unsigned int sz);",
          "140:     virtual int         read(void * ptr,size_t sz, size_t nmemb);",
          "141:     virtual int         eof();",
          "142:     virtual int         seek(INT64 o, int whence);",
          "143:     virtual INT64       tell();",
          "144:     virtual char*       gets(char *s, int sz);",
          "145:     virtual int         scanf_one(const char *fmt, void* val);",
          "146:     virtual int         get_char()",
          "147:     {",
          "148:         if(substream) return substream->get_char();",
          "149:         if(streampos>=streamsize)",
          "150:             return -1;",
          "151:         return buf[streampos++];",
          "152:     }",
          "154:   private:",
          "155:     unsigned char *buf;",
          "156:     size_t   streampos,streamsize;",
          "157: };",
          "159: class DllDef LibRaw_bigfile_datastream : public LibRaw_abstract_datastream",
          "160: {",
          "161:   public:",
          "162:                         LibRaw_bigfile_datastream(const char *fname);",
          "163: #ifdef WIN32",
          "164:       LibRaw_bigfile_datastream(const wchar_t *fname);",
          "165: #endif",
          "166:     virtual             ~LibRaw_bigfile_datastream();",
          "167:     virtual int         valid();",
          "168:     virtual void *make_jas_stream();",
          "170:     virtual int         read(void * ptr,size_t size, size_t nmemb);",
          "171:     virtual int         eof();",
          "172:     virtual int         seek(INT64 o, int whence);",
          "173:     virtual INT64       tell();",
          "174:     virtual char*       gets(char *str, int sz);",
          "175:     virtual int         scanf_one(const char *fmt, void*val);",
          "176:     virtual const char *fname();",
          "177: #ifdef WIN32",
          "178:  virtual const wchar_t* wfname() { return wfilename;}",
          "179:  virtual int         subfile_open(const wchar_t *fn);",
          "180: #endif",
          "181:     virtual int         subfile_open(const char *fn);",
          "182:     virtual void        subfile_close();",
          "183:     virtual int         get_char()",
          "184:     {",
          "185: #ifndef WIN32",
          "186:         return substream?substream->get_char():getc_unlocked(f);",
          "187: #else",
          "188:         return substream?substream->get_char():fgetc(f);",
          "189: #endif",
          "190:     }",
          "192:   private:",
          "193:     FILE *f,*sav;",
          "194:     const char *filename;",
          "195: #ifdef WIN32",
          "196:  const wchar_t *wfilename;",
          "197: #endif",
          "198: };",
          "200: #ifdef WIN32",
          "201: class DllDef  LibRaw_windows_datastream : public LibRaw_buffer_datastream",
          "202: {",
          "203: public:",
          "205:     LibRaw_windows_datastream(const TCHAR* sFile);",
          "207:     LibRaw_windows_datastream(HANDLE hFile);",
          "209:     virtual ~LibRaw_windows_datastream();",
          "211: protected:",
          "212:     void Open(HANDLE hFile);",
          "213:     inline void reconstruct_base()",
          "214:  {",
          "216:             (LibRaw_buffer_datastream&)*this = LibRaw_buffer_datastream(pView_, (size_t)cbView_);",
          "217:  }",
          "222: };",
          "224: #endif",
          "229: #endif",
          "",
          "---------------"
        ],
        "libraw/libraw_types.h||libraw/libraw_types.h": [
          "File: libraw/libraw_types.h -> libraw/libraw_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "9: LibRaw is free software; you can redistribute it and/or modify",
          "10: it under the terms of the one of three licenses as you choose:",
          "12: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "13:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "15: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "16:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "18: 3. LibRaw Software License 27032010",
          "19:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "23: #ifndef _LIBRAW_TYPES_H",
          "24: #define _LIBRAW_TYPES_H",
          "26: #include <sys/types.h>",
          "27: #ifndef WIN32",
          "28: #include <sys/time.h>",
          "29: #endif",
          "30: #include <stdio.h>",
          "32: #if defined (_OPENMP)",
          "34: #if defined(WIN32)",
          "35: # if defined (_MSC_VER) && (_MSC_VER >= 1600 || (_MSC_VER == 1500 && _MSC_FULL_VER >= 150030729) )",
          "37: #   define LIBRAW_USE_OPENMP",
          "38: #elif defined (__INTEL_COMPILER) && (__INTEL_COMPILER >=910)",
          "40: #   define LIBRAW_USE_OPENMP",
          "41: #else",
          "42: #  undef LIBRAW_USE_OPENMP",
          "43: #endif",
          "45: # elif (defined(__APPLE__) || defined(__MACOSX__)) && defined(_REENTRANT)",
          "46: #   undef LIBRAW_USE_OPENMP",
          "47: # else",
          "48: #   define LIBRAW_USE_OPENMP",
          "49: # endif",
          "50: #endif",
          "52: #ifdef LIBRAW_USE_OPENMP",
          "53: #include <omp.h>",
          "54: #endif",
          "57: #ifdef __cplusplus",
          "58: extern \"C\" {",
          "59: #endif",
          "61: #if defined(USE_LCMS)",
          "62: #include <lcms.h>",
          "63: #elif defined(USE_LCMS2)",
          "64: #include <lcms2.h>",
          "65: #else",
          "66: #define NO_LCMS",
          "67: #endif",
          "69: #include \"libraw_const.h\"",
          "70: #include \"libraw_version.h\"",
          "72: #ifdef WIN32",
          "73: typedef __int64 INT64;",
          "74: typedef unsigned __int64 UINT64;",
          "75: #else",
          "76: typedef long long INT64;",
          "77: typedef unsigned long long UINT64;",
          "78: #endif",
          "80: typedef unsigned char uchar;",
          "81: typedef unsigned short ushort;",
          "83: #ifdef WIN32",
          "84: #ifdef LIBRAW_NODLL",
          "85: # define DllDef",
          "86: #else",
          "87: # ifdef LIBRAW_BUILDLIB",
          "88: #    define DllDef   __declspec( dllexport )",
          "89: # else",
          "90: #    define DllDef   __declspec( dllimport )",
          "91: # endif",
          "92: #endif",
          "93: #else",
          "94: #  define DllDef",
          "95: #endif",
          "97: typedef struct",
          "98: {",
          "99:     const char          *decoder_name;",
          "100:     unsigned             decoder_flags;",
          "101: }libraw_decoder_info_t;",
          "103: typedef struct",
          "104: {",
          "105:     unsigned    mix_green;",
          "106:     unsigned    raw_color;",
          "107:     unsigned    zero_is_bad;",
          "108:     ushort      shrink;",
          "109:     ushort      fuji_width;",
          "110:     ushort      fwidth,fheight;",
          "111: } libraw_internal_output_params_t;",
          "114: typedef void (* memory_callback)(void * data, const char *file, const char *where);",
          "116: DllDef void default_memory_callback(void *data,const char *file, const char *where);",
          "118: typedef void (*data_callback)(void *data,const char *file, const int offset);",
          "120: DllDef void default_data_callback(void *data,const char *file, const int offset);",
          "122: typedef int (* progress_callback) (void *data,enum LibRaw_progress stage, int iteration,int expected);",
          "124: typedef struct",
          "125: {",
          "126:     memory_callback mem_cb;",
          "127:     void*  memcb_data;",
          "129:     data_callback data_cb;",
          "130:     void*       datacb_data;",
          "132:     progress_callback progress_cb;",
          "133:     void *progresscb_data;",
          "134: } libraw_callbacks_t;",
          "137: typedef struct",
          "138: {",
          "139:     enum LibRaw_image_formats type;",
          "140:     ushort      height,",
          "141:                 width,",
          "142:                 colors,",
          "143:                 bits;",
          "144:     unsigned int  data_size;",
          "145:     unsigned char data[1];",
          "146: }libraw_processed_image_t;",
          "149: typedef struct",
          "150: {",
          "151:     char        make[64];",
          "152:     char        model[64];",
          "154:     unsigned    raw_count;",
          "155:     unsigned    dng_version;",
          "156:     unsigned    is_foveon;",
          "157:     int         colors;",
          "159:     unsigned    filters;",
          "160:     char        cdesc[5];",
          "162: }libraw_iparams_t;",
          "164: typedef struct",
          "165: {",
          "166:     ushort      raw_height,",
          "167:                 raw_width,",
          "168:                 height,",
          "169:                 width,",
          "170:                 top_margin,",
          "171:                 left_margin;",
          "172:     ushort      iheight,",
          "173:                 iwidth;",
          "174:     double      pixel_aspect;",
          "175:     int         flip;",
          "176:   int         mask[8][4];",
          "178: } libraw_image_sizes_t;",
          "180: struct ph1_t",
          "181: {",
          "182:     int format, key_off, t_black, black_off, split_col, tag_21a;",
          "183:     float tag_210;",
          "184: };",
          "186: typedef struct",
          "187: {",
          "188:  ushort      curve[0x10000];",
          "189:  unsigned    cblack[8];",
          "190:  unsigned    black;",
          "191:  unsigned    maximum;",
          "192:  unsigned    channel_maximum[4];",
          "193:     ushort      white[8][8];",
          "194:     float       cam_mul[4];",
          "195:     float       pre_mul[4];",
          "196:     float       cmatrix[3][4];",
          "197:     float       rgb_cam[3][4];",
          "198:     float       cam_xyz[4][3];",
          "199:     struct ph1_t       phase_one_data;",
          "200:     float       flash_used;",
          "201:     float       canon_ev;",
          "202:     char        model2[64];",
          "203:     void        *profile;",
          "204:     unsigned    profile_length;",
          "205:     short  (*ph1_black)[2];",
          "206: }libraw_colordata_t;",
          "208: typedef struct",
          "209: {",
          "210:     enum LibRaw_thumbnail_formats tformat;",
          "211:     ushort      twidth,",
          "212:                 theight;",
          "213:     unsigned    tlength;",
          "214:     int         tcolors;",
          "216:     char       *thumb;",
          "217: }libraw_thumbnail_t;",
          "219: typedef struct",
          "220: {",
          "221:     float       iso_speed;",
          "222:     float       shutter;",
          "223:     float       aperture;",
          "224:     float       focal_len;",
          "225:     time_t      timestamp;",
          "226:     unsigned    shot_order;",
          "227:     unsigned    gpsdata[32];",
          "228:     char        desc[512],",
          "229:                 artist[64];",
          "230: } libraw_imgother_t;",
          "232: typedef struct",
          "233: {",
          "259:     int  user_cblack[4];",
          "260:     int  sony_arw2_hack;",
          "264:     float       auto_bright_thr;",
          "265:     float       adjust_maximum_thr;",
          "268:     int         green_matching;",
          "269: #if 0",
          "271:     int         afd_noise_att;",
          "272:     int         afd_noise_thres;",
          "273:     int         afd_luminance_passes;",
          "274:     int         afd_chrominance_method;",
          "275:     int         afd_luminance_only;",
          "276: #endif",
          "278:     int         dcb_iterations;",
          "279:     int         dcb_enhance_fl;",
          "280:     int         fbdd_noiserd;",
          "282:     int         eeci_refine;",
          "283:     int         es_med_passes;",
          "285:     int         ca_correc;",
          "286:     float       cared;",
          "287:     float cablue;",
          "288:     int cfaline;",
          "289:     float linenoise;",
          "290:     int cfa_clean;",
          "291:     float lclean;",
          "292:     float cclean;",
          "293:     int cfa_green;",
          "294:     float green_thresh;",
          "295:     int exp_correc;",
          "296:     float exp_shift;",
          "297:     float exp_preser;",
          "299:     int   wf_debanding;",
          "300:     float wf_deband_treshold[4];",
          "301: }libraw_output_params_t;",
          "303: typedef struct",
          "304: {",
          "306:     void        *raw_alloc;",
          "308:     ushort                      *raw_image;",
          "310:     ushort                      (*color_image)[4] ;",
          "313:     short  (*ph1_black)[2];",
          "314:     int         use_ph1_correct;",
          "316:     libraw_iparams_t  iparams;",
          "317:     libraw_image_sizes_t sizes;",
          "318:     libraw_internal_output_params_t ioparams;",
          "319:     libraw_colordata_t color;",
          "320: } libraw_rawdata_t;",
          "323: typedef struct",
          "324: {",
          "325:  ushort                      (*image)[4] ;",
          "326:  libraw_image_sizes_t        sizes;",
          "327:  libraw_iparams_t            idata;",
          "328:  libraw_output_params_t  params;",
          "329:     unsigned int                progress_flags;",
          "330:     unsigned int                process_warnings;",
          "331:     libraw_colordata_t          color;",
          "332:     libraw_imgother_t           other;",
          "333:     libraw_thumbnail_t          thumbnail;",
          "334:     libraw_rawdata_t            rawdata;",
          "335:     void                *parent_class;",
          "336: } libraw_data_t;",
          "339: #ifdef __cplusplus",
          "340: }",
          "341: #endif",
          "343: #endif",
          "",
          "[Added Lines]",
          "9: LibRaw is free software; you can redistribute it and/or modify",
          "10: it under the terms of the one of three licenses as you choose:",
          "12: 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1",
          "13:    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).",
          "15: 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0",
          "16:    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).",
          "18: 3. LibRaw Software License 27032010",
          "19:    (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).",
          "23: #ifndef _LIBRAW_TYPES_H",
          "24: #define _LIBRAW_TYPES_H",
          "26: #include <sys/types.h>",
          "27: #ifndef WIN32",
          "28: #include <sys/time.h>",
          "29: #endif",
          "30: #include <stdio.h>",
          "32: #if defined (_OPENMP)",
          "34: #if defined(WIN32)",
          "35: # if defined (_MSC_VER) && (_MSC_VER >= 1600 || (_MSC_VER == 1500 && _MSC_FULL_VER >= 150030729) )",
          "37: #   define LIBRAW_USE_OPENMP",
          "38: #elif defined (__INTEL_COMPILER) && (__INTEL_COMPILER >=910)",
          "40: #   define LIBRAW_USE_OPENMP",
          "41: #else",
          "42: #  undef LIBRAW_USE_OPENMP",
          "43: #endif",
          "45: # elif (defined(__APPLE__) || defined(__MACOSX__)) && defined(_REENTRANT)",
          "46: #   undef LIBRAW_USE_OPENMP",
          "47: # else",
          "48: #   define LIBRAW_USE_OPENMP",
          "49: # endif",
          "50: #endif",
          "52: #ifdef LIBRAW_USE_OPENMP",
          "53: #include <omp.h>",
          "54: #endif",
          "57: #ifdef __cplusplus",
          "58: extern \"C\" {",
          "59: #endif",
          "61: #if defined(USE_LCMS)",
          "62: #include <lcms.h>",
          "63: #elif defined(USE_LCMS2)",
          "64: #include <lcms2.h>",
          "65: #else",
          "66: #define NO_LCMS",
          "67: #endif",
          "69: #include \"libraw_const.h\"",
          "70: #include \"libraw_version.h\"",
          "72: #ifdef WIN32",
          "73: typedef __int64 INT64;",
          "74: typedef unsigned __int64 UINT64;",
          "75: #else",
          "76: typedef long long INT64;",
          "77: typedef unsigned long long UINT64;",
          "78: #endif",
          "80: typedef unsigned char uchar;",
          "81: typedef unsigned short ushort;",
          "83: #ifdef WIN32",
          "84: #ifdef LIBRAW_NODLL",
          "85: # define DllDef",
          "86: #else",
          "87: # ifdef LIBRAW_BUILDLIB",
          "88: #    define DllDef   __declspec( dllexport )",
          "89: # else",
          "90: #    define DllDef   __declspec( dllimport )",
          "91: # endif",
          "92: #endif",
          "93: #else",
          "94: #  define DllDef",
          "95: #endif",
          "97: typedef struct",
          "98: {",
          "99:     const char          *decoder_name;",
          "100:     unsigned             decoder_flags;",
          "101: }libraw_decoder_info_t;",
          "103: typedef struct",
          "104: {",
          "105:     unsigned    mix_green;",
          "106:     unsigned    raw_color;",
          "107:     unsigned    zero_is_bad;",
          "108:     ushort      shrink;",
          "109:     ushort      fuji_width;",
          "110:     ushort      fwidth,fheight;",
          "111: } libraw_internal_output_params_t;",
          "114: typedef void (* memory_callback)(void * data, const char *file, const char *where);",
          "116: DllDef void default_memory_callback(void *data,const char *file, const char *where);",
          "118: typedef void (*data_callback)(void *data,const char *file, const int offset);",
          "120: DllDef void default_data_callback(void *data,const char *file, const int offset);",
          "122: typedef int (* progress_callback) (void *data,enum LibRaw_progress stage, int iteration,int expected);",
          "124: typedef struct",
          "125: {",
          "126:     memory_callback mem_cb;",
          "127:     void*  memcb_data;",
          "129:     data_callback data_cb;",
          "130:     void*       datacb_data;",
          "132:     progress_callback progress_cb;",
          "133:     void *progresscb_data;",
          "134: } libraw_callbacks_t;",
          "137: typedef struct",
          "138: {",
          "139:     enum LibRaw_image_formats type;",
          "140:     ushort      height,",
          "141:                 width,",
          "142:                 colors,",
          "143:                 bits;",
          "144:     unsigned int  data_size;",
          "145:     unsigned char data[1];",
          "146: }libraw_processed_image_t;",
          "149: typedef struct",
          "150: {",
          "151:     char        make[64];",
          "152:     char        model[64];",
          "154:     unsigned    raw_count;",
          "155:     unsigned    dng_version;",
          "156:     unsigned    is_foveon;",
          "157:     int         colors;",
          "159:     unsigned    filters;",
          "160:     char        cdesc[5];",
          "162: }libraw_iparams_t;",
          "164: typedef struct",
          "165: {",
          "166:     ushort      raw_height,",
          "167:                 raw_width,",
          "168:                 height,",
          "169:                 width,",
          "170:                 top_margin,",
          "171:                 left_margin;",
          "172:     ushort      iheight,",
          "173:                 iwidth;",
          "174:     double      pixel_aspect;",
          "175:     int         flip;",
          "176:   int         mask[8][4];",
          "178: } libraw_image_sizes_t;",
          "180: struct ph1_t",
          "181: {",
          "182:     int format, key_off, t_black, black_off, split_col, tag_21a;",
          "183:     float tag_210;",
          "184: };",
          "186: typedef struct",
          "187: {",
          "188:  ushort      curve[0x10000];",
          "189:  unsigned    cblack[8];",
          "190:  unsigned    black;",
          "191:  unsigned    maximum;",
          "192:  unsigned    channel_maximum[4];",
          "193:     ushort      white[8][8];",
          "194:     float       cam_mul[4];",
          "195:     float       pre_mul[4];",
          "196:     float       cmatrix[3][4];",
          "197:     float       rgb_cam[3][4];",
          "198:     float       cam_xyz[4][3];",
          "199:     struct ph1_t       phase_one_data;",
          "200:     float       flash_used;",
          "201:     float       canon_ev;",
          "202:     char        model2[64];",
          "203:     void        *profile;",
          "204:     unsigned    profile_length;",
          "205: }libraw_colordata_t;",
          "207: typedef struct",
          "208: {",
          "209:     enum LibRaw_thumbnail_formats tformat;",
          "210:     ushort      twidth,",
          "211:                 theight;",
          "212:     unsigned    tlength;",
          "213:     int         tcolors;",
          "215:     char       *thumb;",
          "216: }libraw_thumbnail_t;",
          "218: typedef struct",
          "219: {",
          "220:     float       iso_speed;",
          "221:     float       shutter;",
          "222:     float       aperture;",
          "223:     float       focal_len;",
          "224:     time_t      timestamp;",
          "225:     unsigned    shot_order;",
          "226:     unsigned    gpsdata[32];",
          "227:     char        desc[512],",
          "228:                 artist[64];",
          "229: } libraw_imgother_t;",
          "231: typedef struct",
          "232: {",
          "258:     int  user_cblack[4];",
          "259:     int  sony_arw2_hack;",
          "263:     float       auto_bright_thr;",
          "264:     float       adjust_maximum_thr;",
          "267:     int         green_matching;",
          "268: #if 0",
          "270:     int         afd_noise_att;",
          "271:     int         afd_noise_thres;",
          "272:     int         afd_luminance_passes;",
          "273:     int         afd_chrominance_method;",
          "274:     int         afd_luminance_only;",
          "275: #endif",
          "277:     int         dcb_iterations;",
          "278:     int         dcb_enhance_fl;",
          "279:     int         fbdd_noiserd;",
          "281:     int         eeci_refine;",
          "282:     int         es_med_passes;",
          "284:     int         ca_correc;",
          "285:     float       cared;",
          "286:     float cablue;",
          "287:     int cfaline;",
          "288:     float linenoise;",
          "289:     int cfa_clean;",
          "290:     float lclean;",
          "291:     float cclean;",
          "292:     int cfa_green;",
          "293:     float green_thresh;",
          "294:     int exp_correc;",
          "295:     float exp_shift;",
          "296:     float exp_preser;",
          "298:     int   wf_debanding;",
          "299:     float wf_deband_treshold[4];",
          "300: }libraw_output_params_t;",
          "302: typedef struct",
          "303: {",
          "305:     void        *raw_alloc;",
          "307:     ushort                      *raw_image;",
          "309:     ushort                      (*color_image)[4] ;",
          "312:     short  (*ph1_black)[2];",
          "314:     libraw_iparams_t  iparams;",
          "315:     libraw_image_sizes_t sizes;",
          "316:     libraw_internal_output_params_t ioparams;",
          "317:     libraw_colordata_t color;",
          "318: } libraw_rawdata_t;",
          "321: typedef struct",
          "322: {",
          "323:  ushort                      (*image)[4] ;",
          "324:  libraw_image_sizes_t        sizes;",
          "325:  libraw_iparams_t            idata;",
          "326:  libraw_output_params_t  params;",
          "327:     unsigned int                progress_flags;",
          "328:     unsigned int                process_warnings;",
          "329:     libraw_colordata_t          color;",
          "330:     libraw_imgother_t           other;",
          "331:     libraw_thumbnail_t          thumbnail;",
          "332:     libraw_rawdata_t            rawdata;",
          "333:     void                *parent_class;",
          "334: } libraw_data_t;",
          "337: #ifdef __cplusplus",
          "338: }",
          "339: #endif",
          "341: #endif",
          "",
          "---------------"
        ],
        "samples/dcraw_emu.cpp||samples/dcraw_emu.cpp": [
          "File: samples/dcraw_emu.cpp -> samples/dcraw_emu.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "438:                         }",
          "439:      if(!(iobuffer = malloc(st.st_size)))",
          "440:      {",
          "442:       close(file);",
          "443:       continue;",
          "444:      }",
          "445:      int rd;",
          "446:      if(st.st_size!=(rd=read(file,iobuffer,st.st_size)))",
          "447:      {",
          "449:       close(file);",
          "450:       free(iobuffer);",
          "451:       continue;",
          "",
          "[Removed Lines]",
          "441:       fprintf(stderr,\"Cannot allocate %lld kbytes for memory buffer\\n\",st.st_size/1024);",
          "448:       fprintf(stderr,\"Cannot read %d bytes instead of  %lld to memory buffer\\n\",rd,st.st_size);",
          "",
          "[Added Lines]",
          "441:                                           fprintf(stderr,\"Cannot allocate %d kbytes for memory buffer\\n\",(int)(st.st_size/1024));",
          "448:                                           fprintf(stderr,\"Cannot read %d bytes instead of  %d to memory buffer\\n\",(int)rd,(int)st.st_size);",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "310:     d_info->decoder_flags = LIBRAW_DECODER_NOTSET;",
          "335:         {",
          "336:             d_info->decoder_name = \"canon_600_load_raw()\";",
          "337:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD; // WB set within decoder, no need to load raw",
          "",
          "[Removed Lines]",
          "313:     if (load_raw == &LibRaw::lossless_dng_load_raw)",
          "314:         {",
          "316:             d_info->decoder_name = \"lossless_dng_load_raw()\";",
          "317:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_4COMPONENT ;",
          "318:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "319:         }",
          "320:     else if (load_raw == &LibRaw::packed_dng_load_raw)",
          "321:         {",
          "323:             d_info->decoder_name = \"packed_dng_load_raw()\";",
          "324:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_4COMPONENT;",
          "325:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "326:         }",
          "327:     else if (load_raw == &LibRaw::lossy_dng_load_raw)",
          "328:         {",
          "330:             d_info->decoder_name = \"lossy_dng_load_raw()\";",
          "331:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_4COMPONENT;",
          "332:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "333:         }",
          "334:     else if (load_raw == &LibRaw::canon_600_load_raw)",
          "",
          "[Added Lines]",
          "313:     if (load_raw == &LibRaw::canon_600_load_raw)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "341:             d_info->decoder_name = \"canon_load_raw()\";",
          "342:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "343:         }",
          "344:     else if (load_raw == &LibRaw::canon_sraw_load_raw)",
          "345:         {",
          "346:             d_info->decoder_name = \"canon_sraw_load_raw()\";",
          "347:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "348:         }",
          "350:         {",
          "353:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "354:         }",
          "356:         {",
          "359:         }",
          "364:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "365:         }",
          "368:         {",
          "370:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "371:         }",
          "373:         {",
          "376:         }",
          "378:         {",
          "380:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "382:         }",
          "384:         {",
          "386:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "388:         }",
          "390:         {",
          "392:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "393:         }",
          "395:         {",
          "399:         }",
          "401:         {",
          "404:         }",
          "406:         {",
          "410:         }",
          "412:         {",
          "416:         }",
          "418:         {",
          "423:         }",
          "425:         {",
          "428:         }",
          "430:         {",
          "434:         }",
          "435:     else if (load_raw == &LibRaw::minolta_rd175_load_raw )",
          "436:         {",
          "",
          "[Removed Lines]",
          "349:     else if (load_raw == &LibRaw::eight_bit_load_raw )",
          "351:             d_info->decoder_name = \"eight_bit_load_raw()\";",
          "352:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "355:     else if (load_raw == &LibRaw::foveon_load_raw )",
          "357:             d_info->decoder_name = \"foveon_load_raw()\";",
          "358:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "360: #if 0",
          "361:     else if (load_raw == &LibRaw::fuji_load_raw )",
          "362:         {",
          "363:             d_info->decoder_name = \"fuji_load_raw()\";",
          "366: #endif",
          "367:     else if (load_raw == &LibRaw::hasselblad_load_raw )",
          "369:             d_info->decoder_name = \"hasselblad_load_raw()\";",
          "372:     else if (load_raw == &LibRaw::imacon_full_load_raw )",
          "374:             d_info->decoder_name = \"imacon_full_load_raw()\";",
          "375:             d_info->decoder_flags = LIBRAW_DECODER_4COMPONENT;",
          "377:     else if (load_raw == &LibRaw::kodak_262_load_raw )",
          "379:             d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!",
          "381:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "383:     else if (load_raw == &LibRaw::kodak_65000_load_raw )",
          "385:             d_info->decoder_name = \"kodak_65000_load_raw()\";",
          "387:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "389:     else if (load_raw == &LibRaw::kodak_dc120_load_raw )",
          "391:             d_info->decoder_name = \"kodak_dc120_load_raw()\";",
          "394:     else if (load_raw == &LibRaw::kodak_jpeg_load_raw )",
          "397:             d_info->decoder_name = \"kodak_jpeg_load_raw()\";",
          "398:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "400:     else if (load_raw == &LibRaw::kodak_radc_load_raw )",
          "402:             d_info->decoder_name = \"kodak_radc_load_raw()\";",
          "403:             d_info->decoder_flags = LIBRAW_DECODER_4COMPONENT;",
          "405:     else if (load_raw == &LibRaw::kodak_rgb_load_raw )",
          "408:             d_info->decoder_name = \"kodak_rgb_load_raw()\";",
          "409:             d_info->decoder_flags = LIBRAW_DECODER_4COMPONENT;",
          "411:     else if (load_raw == &LibRaw::kodak_yrgb_load_raw )",
          "413:             d_info->decoder_name = \"kodak_yrgb_load_raw()\";",
          "414:             d_info->decoder_flags = LIBRAW_DECODER_4COMPONENT;",
          "415:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "417:     else if (load_raw == &LibRaw::kodak_ycbcr_load_raw )",
          "420:             d_info->decoder_name = \"kodak_ycbcr_load_raw()\";",
          "421:             d_info->decoder_flags = LIBRAW_DECODER_4COMPONENT;",
          "422:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "424:     else if (load_raw == &LibRaw::leaf_hdr_load_raw )",
          "426:             d_info->decoder_name = \"leaf_hdr_load_raw()\";",
          "427:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_4COMPONENT;",
          "429:     else if (load_raw == &LibRaw::lossless_jpeg_load_raw)",
          "432:             d_info->decoder_name = \"lossless_jpeg_load_raw()\";",
          "433:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_HASCURVE;",
          "",
          "[Added Lines]",
          "323:     else if (load_raw == &LibRaw::lossless_jpeg_load_raw)",
          "324:         {",
          "326:             d_info->decoder_name = \"lossless_jpeg_load_raw()\";",
          "327:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_HASCURVE;",
          "328:         }",
          "334:     else if (load_raw == &LibRaw::lossless_dng_load_raw)",
          "337:             d_info->decoder_name = \"lossless_dng_load_raw()\";",
          "338:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_LEGACY ;",
          "341:     else if (load_raw == &LibRaw::packed_dng_load_raw)",
          "344:             d_info->decoder_name = \"packed_dng_load_raw()\";",
          "345:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_LEGACY;",
          "346:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "348:     else if (load_raw == &LibRaw::pentax_load_raw )",
          "349:         {",
          "350:             d_info->decoder_name = \"pentax_load_raw()\";",
          "353:     else if (load_raw == &LibRaw::nikon_load_raw)",
          "356:             d_info->decoder_name = \"nikon_load_raw()\";",
          "359:     else if (load_raw == &LibRaw::rollei_load_raw )",
          "362:             d_info->decoder_name = \"rollei_load_raw()\";",
          "363:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "365:     else if (load_raw == &LibRaw::phase_one_load_raw )",
          "367:             d_info->decoder_name = \"phase_one_load_raw()\";",
          "370:     else if (load_raw == &LibRaw::phase_one_load_raw_c )",
          "372:             d_info->decoder_name = \"phase_one_load_raw_c()\";",
          "375:     else if (load_raw == &LibRaw::hasselblad_load_raw )",
          "377:             d_info->decoder_name = \"hasselblad_load_raw()\";",
          "380:     else if (load_raw == &LibRaw::leaf_hdr_load_raw )",
          "382:             d_info->decoder_name = \"leaf_hdr_load_raw()\";",
          "383:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_LEGACY;",
          "385:     else if (load_raw == &LibRaw::unpacked_load_raw )",
          "387:             d_info->decoder_name = \"unpacked_load_raw()\";",
          "388:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_USEBAYER2;",
          "390:     else if (load_raw == &LibRaw::sinar_4shot_load_raw )",
          "393:             d_info->decoder_name = \"sinar_4shot_load_raw()\";",
          "394:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "396:     else if (load_raw == &LibRaw::imacon_full_load_raw )",
          "398:             d_info->decoder_name = \"imacon_full_load_raw()\";",
          "399:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "401:     else if (load_raw == &LibRaw::packed_load_raw )",
          "402:         {",
          "403:             d_info->decoder_name = \"packed_load_raw()\";",
          "404:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "405:         }",
          "406:     else if (load_raw == &LibRaw::nokia_load_raw )",
          "409:             d_info->decoder_name = \"nokia_load_raw()\";",
          "410:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "412:     else if (load_raw == &LibRaw::panasonic_load_raw )",
          "414:             d_info->decoder_name = \"panasonic_load_raw()\";",
          "415:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "417:     else if (load_raw == &LibRaw::olympus_load_raw )",
          "419:             d_info->decoder_name = \"olympus_load_raw()\";",
          "420:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "438:             d_info->decoder_name = \"minolta_rd175_load_raw()\";",
          "439:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "440:         }",
          "448:         {",
          "451:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "452:         }",
          "454:         {",
          "456:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "457:         }",
          "459:         {",
          "461:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "462:         }",
          "464:         {",
          "467:         }",
          "469:         {",
          "471:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "472:         }",
          "474:         {",
          "476:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "477:         }",
          "479:         {",
          "482:         }",
          "484:         {",
          "487:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "488:         }",
          "490:         {",
          "493:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "494:         }",
          "502:         {",
          "506:         }",
          "508:         {",
          "512:         }",
          "513:     else if (load_raw == &LibRaw::sony_load_raw )",
          "514:         {",
          "",
          "[Removed Lines]",
          "441:     else if (load_raw == &LibRaw::nikon_load_raw)",
          "442:         {",
          "444:             d_info->decoder_name = \"nikon_load_raw()\";",
          "445:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "446:         }",
          "447:     else if (load_raw == &LibRaw::nokia_load_raw )",
          "450:             d_info->decoder_name = \"nokia_load_raw()\";",
          "453:     else if (load_raw == &LibRaw::olympus_load_raw )",
          "455:             d_info->decoder_name = \"olympus_load_raw()\";",
          "458:     else if (load_raw == &LibRaw::packed_load_raw )",
          "460:             d_info->decoder_name = \"packed_load_raw()\";",
          "463:     else if (load_raw == &LibRaw::panasonic_load_raw )",
          "465:             d_info->decoder_name = \"panasonic_load_raw()\";",
          "466:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "468:     else if (load_raw == &LibRaw::pentax_load_raw )",
          "470:             d_info->decoder_name = \"pentax_load_raw()\";",
          "473:     else if (load_raw == &LibRaw::phase_one_load_raw )",
          "475:             d_info->decoder_name = \"phase_one_load_raw()\";",
          "478:     else if (load_raw == &LibRaw::phase_one_load_raw_c )",
          "480:             d_info->decoder_name = \"phase_one_load_raw_c()\";",
          "481:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "483:     else if (load_raw == &LibRaw::quicktake_100_load_raw )",
          "486:             d_info->decoder_name = \"quicktake_100_load_raw()\";",
          "489:     else if (load_raw == &LibRaw::rollei_load_raw )",
          "492:             d_info->decoder_name = \"rollei_load_raw()\";",
          "495:     else if (load_raw == &LibRaw::sinar_4shot_load_raw )",
          "496:         {",
          "498:             d_info->decoder_name = \"sinar_4shot_load_raw()\";",
          "499:             d_info->decoder_flags = LIBRAW_DECODER_4COMPONENT;",
          "500:         }",
          "501:     else if (load_raw == &LibRaw::smal_v6_load_raw )",
          "504:             d_info->decoder_name = \"smal_v6_load_raw()\";",
          "505:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "507:     else if (load_raw == &LibRaw::smal_v9_load_raw )",
          "510:             d_info->decoder_name = \"smal_v9_load_raw()\";",
          "511:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "",
          "[Added Lines]",
          "428:     else if (load_raw == &LibRaw::quicktake_100_load_raw )",
          "431:             d_info->decoder_name = \"quicktake_100_load_raw()\";",
          "434:     else if (load_raw == &LibRaw::kodak_radc_load_raw )",
          "436:             d_info->decoder_name = \"kodak_radc_load_raw()\";",
          "439:     else if (load_raw == &LibRaw::kodak_jpeg_load_raw )",
          "442:             d_info->decoder_name = \"kodak_jpeg_load_raw()\";",
          "445:     else if (load_raw == &LibRaw::lossy_dng_load_raw)",
          "448:             d_info->decoder_name = \"lossy_dng_load_raw()\";",
          "449:             d_info->decoder_flags = imgdata.idata.filters ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_LEGACY;",
          "450:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "452:     else if (load_raw == &LibRaw::kodak_dc120_load_raw )",
          "454:             d_info->decoder_name = \"kodak_dc120_load_raw()\";",
          "457:     else if (load_raw == &LibRaw::eight_bit_load_raw )",
          "459:             d_info->decoder_name = \"eight_bit_load_raw()\";",
          "461:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "463:     else if (load_raw == &LibRaw::kodak_yrgb_load_raw )",
          "465:             d_info->decoder_name = \"kodak_yrgb_load_raw()\";",
          "466:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "467:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "469:     else if (load_raw == &LibRaw::kodak_262_load_raw )",
          "471:             d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!",
          "473:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "475:     else if (load_raw == &LibRaw::kodak_65000_load_raw )",
          "477:             d_info->decoder_name = \"kodak_65000_load_raw()\";",
          "479:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "481:     else if (load_raw == &LibRaw::kodak_ycbcr_load_raw )",
          "484:             d_info->decoder_name = \"kodak_ycbcr_load_raw()\";",
          "485:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "486:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "488:     else if (load_raw == &LibRaw::kodak_rgb_load_raw )",
          "491:             d_info->decoder_name = \"kodak_rgb_load_raw()\";",
          "492:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "527:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "528:    d_info->decoder_flags |= LIBRAW_DECODER_ITSASONY;",
          "529:         }",
          "531:         {",
          "534:         }",
          "535:     else  if (load_raw == &LibRaw::redcine_load_raw)",
          "536:         {",
          "",
          "[Removed Lines]",
          "530:     else if (load_raw == &LibRaw::unpacked_load_raw )",
          "532:             d_info->decoder_name = \"unpacked_load_raw()\";",
          "533:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_USEBAYER2;",
          "",
          "[Added Lines]",
          "511:     else if (load_raw == &LibRaw::smal_v6_load_raw )",
          "514:             d_info->decoder_name = \"smal_v6_load_raw()\";",
          "515:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "516:         }",
          "517:     else if (load_raw == &LibRaw::smal_v9_load_raw )",
          "518:         {",
          "520:             d_info->decoder_name = \"smal_v9_load_raw()\";",
          "521:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "538:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "539:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "540:         }",
          "541:     else",
          "542:         {",
          "543:             d_info->decoder_name = \"Unknown unpack function\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "529:     else if (load_raw == &LibRaw::foveon_sd_load_raw )",
          "530:         {",
          "531:             d_info->decoder_name = \"foveon_sd_load_raw()\";",
          "532:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "533:         }",
          "534:     else if (load_raw == &LibRaw::foveon_dp_load_raw )",
          "535:         {",
          "536:             d_info->decoder_name = \"foveon_dp_load_raw()\";",
          "537:             d_info->decoder_flags = LIBRAW_DECODER_LEGACY;",
          "538:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "808:                 imgdata.image = 0;",
          "809:             }",
          "811:         if (libraw_internal_data.unpacker_data.meta_length)",
          "812:             {",
          "813:                 libraw_internal_data.internal_data.meta_data =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "809:         printf(\"Entering unpack\\n\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "836:         if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "837:             {",
          "839:                 imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "840:             }",
          "849:         else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "850:             {",
          "",
          "[Removed Lines]",
          "838:                 imgdata.rawdata.raw_alloc = malloc(rwidth*rheight*sizeof(imgdata.rawdata.raw_image[0]));",
          "841:         else if (decoder_info.decoder_flags &  LIBRAW_DECODER_4COMPONENT)",
          "842:             {",
          "843:                 S.iwidth = S.width;",
          "844:                 S.iheight= S.height;",
          "845:                 IO.shrink = 0;",
          "846:                 imgdata.rawdata.raw_alloc = calloc(rwidth*rheight,sizeof(*imgdata.rawdata.color_image));",
          "847:                 imgdata.rawdata.color_image = (ushort(*)[4]) imgdata.rawdata.raw_alloc;",
          "848:             }",
          "",
          "[Added Lines]",
          "838:               imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "857:                 imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
          "858:                 imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "859:             }",
          "862:         (this->*load_raw)();",
          "866:         if( decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "851:                 imgdata.rawdata.raw_image = 0; // for adobe decoder!",
          "856:         if(imgdata.rawdata.raw_image)",
          "857:           crop_masked_pixels(); // calculate black levels",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "886:                                 C.channel_maximum[3]=imgdata.rawdata.color_image[rc][3];",
          "887:                         }",
          "888:                 }",
          "905:             else if (decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "906:                 {",
          "907:                         for(int row = 0; row < S.height; row++)",
          "",
          "[Removed Lines]",
          "889:             else if(decoder_info.decoder_flags &  LIBRAW_DECODER_4COMPONENT)",
          "890:                 {",
          "891:                     for(int row = S.top_margin; row < S.height+S.top_margin; row++)",
          "892:                         for(int col = S.left_margin; col < S.width+S.left_margin; col++)",
          "893:                         {",
          "894:                             int rc = row*S.raw_width+col;",
          "895:                             if(C.channel_maximum[0]<imgdata.rawdata.color_image[rc][0])",
          "896:                                 C.channel_maximum[0]=imgdata.rawdata.color_image[rc][0];",
          "897:                             if(C.channel_maximum[1]<imgdata.rawdata.color_image[rc][1])",
          "898:                                 C.channel_maximum[1]=imgdata.rawdata.color_image[rc][1];",
          "899:                             if(C.channel_maximum[2]<imgdata.rawdata.color_image[rc][2])",
          "900:                                 C.channel_maximum[2]=imgdata.rawdata.color_image[rc][2];",
          "901:                             if(C.channel_maximum[3]<imgdata.rawdata.color_image[rc][3])",
          "902:                                 C.channel_maximum[3]=imgdata.rawdata.color_image[rc][4];",
          "903:                         }",
          "904:                 }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "927:         S.iheight = save_iheight;",
          "928:         IO.shrink = save_shrink;",
          "933:         O.document_mode = save_document_mode;",
          "",
          "[Removed Lines]",
          "931:         if(imgdata.rawdata.ph1_black)",
          "932:             C.ph1_black = imgdata.rawdata.ph1_black;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1022:     int do_crop = 0;",
          "1024:     unsigned save_width = S.width;",
          "1025:     if (~O.cropbox[2] && ~O.cropbox[3])",
          "1026:         {",
          "",
          "[Removed Lines]",
          "1023:     unsigned save_filters = imgdata.idata.filters;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1168:                                         }",
          "1169:                                 }",
          "1170:                     }",
          "1194:                 else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1195:                     {",
          "1196:                         if(do_crop)",
          "",
          "[Removed Lines]",
          "1171:                 else if (decoder_info.decoder_flags & LIBRAW_DECODER_4COMPONENT)",
          "1172:                     {",
          "1173: #define FC0(row,col) (save_filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)",
          "1174:                         if(IO.shrink)",
          "1175: #if defined(LIBRAW_USE_OPENMP)",
          "1176: #pragma omp parallel for default(shared)",
          "1177: #endif",
          "1178:                             for(int row = 0; row < S.height; row++)",
          "1179:                                 for(int col = 0; col < S.width; col++)",
          "1180:                                     imgdata.image[(row >> IO.shrink)*S.iwidth + (col>>IO.shrink)][FC(row,col)]",
          "1181:                                         = imgdata.rawdata.color_image[(row+S.top_margin)*S.raw_width",
          "1182:                                                                       +S.left_margin+col]",
          "1183:                                         [FC0(row+S.top_margin,col+S.left_margin)];",
          "1184: #undef FC0",
          "1185:                         else",
          "1186: #if defined(LIBRAW_USE_OPENMP)",
          "1187: #pragma omp parallel for default(shared)",
          "1188: #endif",
          "1189:                             for(int row = 0; row < S.height; row++)",
          "1190:                                 memmove(&imgdata.image[row*S.width],",
          "1191:                                         &imgdata.rawdata.color_image[(row+S.top_margin)*S.raw_width+S.left_margin],",
          "1192:                                         S.width*sizeof(*imgdata.image));",
          "1193:                     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1206:                             memmove(imgdata.image,imgdata.rawdata.color_image,",
          "1207:                                     S.width*S.height*sizeof(*imgdata.image));",
          "1208:                     }",
          "1212:             }",
          "1213:     return LIBRAW_SUCCESS;",
          "1214: }",
          "",
          "[Removed Lines]",
          "1210:                 if(imgdata.rawdata.use_ph1_correct) // Phase one unpacked!",
          "1211:                         phase_one_correct();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1268:                             }",
          "1269:                     }",
          "1270:             }",
          "1290:         else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1291:             {",
          "1293:                 memmove(imgdata.image,imgdata.rawdata.color_image,S.width*S.height*sizeof(*imgdata.image));",
          "1294:             }",
          "1300:         imgdata.progress_flags",
          "1301:             = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "",
          "[Removed Lines]",
          "1271:         else if (decoder_info.decoder_flags & LIBRAW_DECODER_4COMPONENT)",
          "1272:             {",
          "1273:                 if(IO.shrink)",
          "1274:                     {",
          "1275:                         for(int row = 0; row < S.height; row++)",
          "1276:                             for(int col = 0; col < S.width; col++)",
          "1277:                                 {",
          "1278:                                     int cc = FC(row,col);",
          "1279:                                     imgdata.image[(row >> IO.shrink)*S.iwidth + (col>>IO.shrink)][cc]",
          "1280:                                         = imgdata.rawdata.color_image[(row+S.top_margin)*S.raw_width",
          "1281:                                                                       +S.left_margin+col][cc];",
          "1282:                                 }",
          "1283:                     }",
          "1284:                 else",
          "1285:                     for(int row = 0; row < S.height; row++)",
          "1286:                         memmove(&imgdata.image[row*S.width],",
          "1287:                                 &imgdata.rawdata.color_image[(row+S.top_margin)*S.raw_width+S.left_margin],",
          "1288:                                 S.width*sizeof(*imgdata.image));",
          "1289:             }",
          "1296:         if(imgdata.rawdata.use_ph1_correct) // Phase one unpacked!",
          "1297:             phase_one_correct();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1890:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "1891:                         return 0;",
          "1893:                     }",
          "1894:                 else if (write_thumb == &LibRaw::foveon_thumb)",
          "1895:                     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1820:                     }",
          "1821:                 else if (write_thumb == &LibRaw::ppm16_thumb)",
          "1822:                     {",
          "1823:                         T.tlength = T.twidth * T.theight*3;",
          "1824:                         ushort *t_thumb = (ushort*)calloc(T.tlength,2);",
          "1825:                         ID.input->read(t_thumb,2,T.tlength);",
          "1826:                         if ((libraw_internal_data.unpacker_data.order= 0x4949) == (ntohs(0x1234) == 0x1234))",
          "1827:                           swab (t_thumb, t_thumb, T.tlength*2);",
          "1829:                         if(T.thumb) free(T.thumb);",
          "1830:                         T.thumb = (char *) malloc (T.tlength);",
          "1831:                         merror (T.thumb, \"ppm_thumb()\");",
          "1832:                         for (int i=0; i < T.tlength; i++)",
          "1833:                           T.thumb[i] = t_thumb[i] >> 8;",
          "1834:                         free(t_thumb);",
          "1835:                         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "1836:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "1837:                         return 0;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2003: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "2038:         {",
          "2039:             int cblk[4],i,row,col,val,cc;",
          "2040:             for(i=0;i<4;i++)",
          "",
          "[Removed Lines]",
          "2005:     if(C.ph1_black)",
          "2006:         {",
          "2008:             int row,col,val,cc;",
          "2009:             for(row=0;row<S.height;row++)",
          "2010:                 for(col=0;col<S.width;col++)",
          "2011:                     {",
          "2012:                         cc=FC(row,col);",
          "2013:                         val = BAYERC(row,col,cc)",
          "2014:                             - C.phase_one_data.t_black",
          "2015:                             + C.ph1_black[row+S.top_margin][(col + S.left_margin)",
          "2016:                                                                                 >=C.phase_one_data.split_col];",
          "2017:                         if(val<0) val = 0;",
          "2018:                         BAYERC(row,col,cc) = val;",
          "2019:                     }",
          "2020:             C.maximum -= C.black;",
          "2021:             phase_one_correct();",
          "2023:             ZERO(C.channel_maximum);",
          "2024:             for(row=0;row<S.height;row++)",
          "2025:                 for(col=0;col<S.width;col++)",
          "2026:                     {",
          "2027:                         cc=FC(row,col);",
          "2028:                         val = BAYERC(row,col,cc);",
          "2029:                         if(C.channel_maximum[cc] > val) C.channel_maximum[cc] = val;",
          "2030:                     }",
          "2032:             imgdata.color.phase_one_data.t_black = 0;",
          "2033:             C.ph1_black = 0;",
          "2034:             ZERO(C.cblack);",
          "2035:             C.black = 0;",
          "2036:         }",
          "2037:     else if((C.black || C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "",
          "[Added Lines]",
          "1951:     if((C.black || C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2071:                         }",
          "2073:         }",
          "2074: }",
          "2076: #define TBLN 65535",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1988: #undef BAYERC",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "583575e5871c6dad5ce8b5a438fe8e9eee8765ab",
      "candidate_info": {
        "commit_hash": "583575e5871c6dad5ce8b5a438fe8e9eee8765ab",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/583575e5871c6dad5ce8b5a438fe8e9eee8765ab",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp",
          "internal/defines.h",
          "internal/var_defines.h",
          "libraw/libraw_const.h",
          "libraw/libraw_types.h",
          "src/libraw_cxx.cpp"
        ],
        "message": "raw pitch try 1: panasonic problem",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp",
          "internal/defines.h||internal/defines.h",
          "internal/var_defines.h||internal/var_defines.h",
          "libraw/libraw_const.h||libraw/libraw_const.h",
          "libraw/libraw_types.h||libraw/libraw_types.h",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "143: unsigned black, cblack[4], maximum, mix_green, raw_color, zero_is_bad;",
          "144: unsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;",
          "145: unsigned tile_width, tile_length, gpsdata[32], load_flags;",
          "147: ushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;",
          "148: ushort *raw_image, (*image)[4];",
          "149: ushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];",
          "",
          "[Removed Lines]",
          "146: ushort raw_height, raw_width, height, width, top_margin, left_margin;",
          "",
          "[Added Lines]",
          "146: ushort raw_height, raw_width, raw_pitch, height, width, top_margin, left_margin;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "240: #define RAW(row,col) \\",
          "244: #define FC(row,col) \\",
          "",
          "[Removed Lines]",
          "241:  raw_image[(row)*raw_width+(col)]",
          "",
          "[Added Lines]",
          "241:  raw_image[(row)*raw_pitch+(col)]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "530:   for (irow=row=0; irow < height; irow++) {",
          "531:     if (fread (data, 1, 1120, ifp) < 1120) derror();",
          "533:     for (dp=data; dp < data+1120;  dp+=10, pix+=8) {",
          "534:       pix[0] = (dp[0] << 2) + (dp[1] >> 6    );",
          "535:       pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);",
          "",
          "[Removed Lines]",
          "532:     pix = raw_image + row*raw_width;",
          "",
          "[Added Lines]",
          "532:     pix = raw_image + row*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "762:   zero_after_ff = 1;",
          "763:   getbits(-1);",
          "764:   for (row=0; row < raw_height; row+=8) {",
          "766:     nblocks = MIN (8, raw_height-row) * raw_width >> 6;",
          "767:     for (block=0; block < nblocks; block++) {",
          "768:       memset (diffbuf, 0, sizeof diffbuf);",
          "",
          "[Removed Lines]",
          "765:     pixel = raw_image + row*raw_width;",
          "",
          "[Added Lines]",
          "765:     pixel = raw_image + row*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1675:       todo[i+1] = buffer >> (14-i)*5;",
          "1676:     }",
          "1677:     for (i=0; i < 16; i+=2)",
          "1679:   }",
          "1680:   maximum = 0x3ff;",
          "1681: }",
          "",
          "[Removed Lines]",
          "1678:       raw_image[todo[i]] = (todo[i+1] & 0x3ff);",
          "",
          "[Added Lines]",
          "1678:       {",
          "1679:         int row = todo[i]/raw_width;",
          "1680:         int col = todo[i]%raw_width;",
          "1681:         RAW(row,col) = (todo[i+1] & 0x3ff);",
          "1682:       }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1864:   bkey = get2();",
          "1865:   t_mask = ph1.format == 1 ? 0x5555:0x1354;",
          "1866:   fseek (ifp, data_offset, SEEK_SET);",
          "1868:   if (ph1.format)",
          "1869:     for (i=0; i < raw_width*raw_height; i+=2) {",
          "1870:       a = raw_image[i+0] ^ akey;",
          "1871:       b = raw_image[i+1] ^ bkey;",
          "1872:       raw_image[i+0] = (a & t_mask) | (b & ~t_mask);",
          "1873:       raw_image[i+1] = (b & t_mask) | (a & ~t_mask);",
          "1874:     }",
          "1875: }",
          "",
          "[Removed Lines]",
          "1867:   read_shorts (raw_image, raw_width*raw_height);",
          "",
          "[Added Lines]",
          "1871: #if 0",
          "1872:   read_shorts (raw_image, raw_width*raw_height); // raw_pitch should be exactly raw_width",
          "1873: #else",
          "1874:   for(int row = 0; row < raw_height; row++)",
          "1875:     read_shorts(raw_image+row*raw_pitch,raw_width);",
          "1876: #endif",
          "1879: #if 0",
          "1884: #else",
          "1885:       int row = i/raw_width;",
          "1886:       int col = i%raw_height;",
          "1887:       a = RAW(row,col) ^ akey;",
          "1888:       b = RAW(row,col+1) ^ bkey;",
          "1889:       RAW(row,col) = (a & t_mask) | (b & ~t_mask);",
          "1890:       RAW(row,col+1) = (b & t_mask) | (a & ~t_mask);",
          "1891: #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1917:   pixel = (ushort *) calloc (raw_width + raw_height*4, 2);",
          "1918:   merror (pixel, \"phase_one_load_raw_c()\");",
          "1920:   fseek (ifp, strip_offset, SEEK_SET);",
          "1921:   for (row=0; row < raw_height; row++)",
          "1922:     offset[row] = get4();",
          "",
          "[Removed Lines]",
          "1919:   offset = (int *) (pixel + raw_width);",
          "",
          "[Added Lines]",
          "1937:   offset = (int *) (pixel + raw_width);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2009:  fseek (ifp, get4(), SEEK_SET);",
          "2010:       }",
          "2011:       if (filters && c != shot_select) continue;",
          "2013:       read_shorts (pixel, raw_width);",
          "2014:       if (!filters && (row = r - top_margin) < height)",
          "2015:  for (col=0; col < width; col++)",
          "",
          "[Removed Lines]",
          "2012:       if (filters) pixel = raw_image + r*raw_width;",
          "",
          "[Added Lines]",
          "2030:       if (filters) pixel = raw_image + r*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2027:   int row, col, bits=0;",
          "2029:   while (1 << ++bits < maximum);",
          "2030:   read_shorts (raw_image, raw_width*raw_height);",
          "2031:   for (row=0; row < raw_height; row++)",
          "2032:     for (col=0; col < raw_width; col++)",
          "2033:       if ((RAW(row,col) >>= load_flags) >> bits",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2048: #if 0",
          "2050: #else",
          "2051:   for(row=0;row<raw_height;row++)",
          "2052:     read_shorts(raw_image+row*raw_pitch,raw_width);",
          "2053: #endif",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2446:    RAW(y,x) = val;",
          "2447:  }",
          "2448:   }",
          "2449:   for (i=0; i < height*width; i++)",
          "2450:     raw_image[i] = curve[raw_image[i]];",
          "2451:   maximum = 0x3fff;",
          "2452: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2472: #if 0",
          "2475: #else",
          "2476:   for (i=0; i < height*width; i++)",
          "2477:     {",
          "2478:       int row = i/width;",
          "2479:       int col = i%width;",
          "2480:       RAW(row,col) = curve[RAW(row,col)];",
          "2481:     }",
          "2482: #endif",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2855:     key = key << 8 | head[i];",
          "2856:   fseek (ifp, data_offset, SEEK_SET);",
          "2857:   for (row=0; row < raw_height; row++) {",
          "2859:     if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();",
          "2860:     sony_decrypt ((unsigned int *) pixel, raw_width/2, !row, key);",
          "2861:     for (col=0; col < raw_width; col++)",
          "",
          "[Removed Lines]",
          "2858:     pixel = raw_image + row*raw_width;",
          "",
          "[Added Lines]",
          "2890:     pixel = raw_image + row*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3024:       diff = diff ? -diff : 0x80;",
          "3025:     if (ftell(ifp) + 12 >= seg[1][1])",
          "3026:       diff = 0;",
          "3027:     raw_image[pix] = pred[pix & 1] += diff;",
          "3028:     if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;",
          "3029:   }",
          "3030:   maximum = 0xff;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3059: #if 0",
          "3061: #else",
          "3062:     RAW(pix/raw_width,pix%raw_width) = pred[pix & 1] += diff;",
          "3063: #endif",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "10794:       merror (meta_data, \"main()\");",
          "10795:     }",
          "10796:     if (filters || colors == 1) {",
          "10798:       merror (raw_image, \"main()\");",
          "10799:     }",
          "10800:     if (verbose)",
          "",
          "[Removed Lines]",
          "10797:       raw_image = (ushort *) calloc ((raw_height+7)*raw_width, 2);",
          "",
          "[Added Lines]",
          "10833:       raw_pitch = ((raw_width*2+15)/16)*8; // !!! CHANGE ME",
          "10834:       printf(\"ifname=%s raw_width=%d raw_pitch=%d\\n\",ifname,raw_width,raw_pitch);",
          "10835:       raw_image = (ushort *) calloc ((raw_height+7)*raw_pitch, 2);",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "276:   for (irow=row=0; irow < height; irow++) {",
          "277:     if (fread (data, 1, 1120, ifp) < 1120) derror();",
          "279:     for (dp=data; dp < data+1120;  dp+=10, pix+=8) {",
          "280:       pix[0] = (dp[0] << 2) + (dp[1] >> 6    );",
          "281:       pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);",
          "",
          "[Removed Lines]",
          "278:     pix = raw_image + row*raw_width;",
          "",
          "[Added Lines]",
          "278:     pix = raw_image + row*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "508:   zero_after_ff = 1;",
          "509:   getbits(-1);",
          "510:   for (row=0; row < raw_height; row+=8) {",
          "512:     nblocks = MIN (8, raw_height-row) * raw_width >> 6;",
          "513:     for (block=0; block < nblocks; block++) {",
          "514:       memset (diffbuf, 0, sizeof diffbuf);",
          "",
          "[Removed Lines]",
          "511:     pixel = raw_image + row*raw_width;",
          "",
          "[Added Lines]",
          "511:     pixel = raw_image + row*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1406:       todo[i+1] = buffer >> (14-i)*5;",
          "1407:     }",
          "1408:     for (i=0; i < 16; i+=2)",
          "1410:   }",
          "1411:   maximum = 0x3ff;",
          "1412: }",
          "",
          "[Removed Lines]",
          "1409:       raw_image[todo[i]] = (todo[i+1] & 0x3ff);",
          "",
          "[Added Lines]",
          "1409:       {",
          "1410:         int row = todo[i]/raw_width;",
          "1411:         int col = todo[i]%raw_width;",
          "1412:         RAW(row,col) = (todo[i+1] & 0x3ff);",
          "1413:       }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1595:   bkey = get2();",
          "1596:   t_mask = ph1.format == 1 ? 0x5555:0x1354;",
          "1597:   fseek (ifp, data_offset, SEEK_SET);",
          "1599:   if (ph1.format)",
          "1600:     for (i=0; i < raw_width*raw_height; i+=2) {",
          "1601:       a = raw_image[i+0] ^ akey;",
          "1602:       b = raw_image[i+1] ^ bkey;",
          "1603:       raw_image[i+0] = (a & t_mask) | (b & ~t_mask);",
          "1604:       raw_image[i+1] = (b & t_mask) | (a & ~t_mask);",
          "1605:     }",
          "1606: }",
          "",
          "[Removed Lines]",
          "1598:   read_shorts (raw_image, raw_width*raw_height);",
          "",
          "[Added Lines]",
          "1602: #if 0",
          "1603:   read_shorts (raw_image, raw_width*raw_height); // raw_pitch should be exactly raw_width",
          "1604: #else",
          "1605:   for(int row = 0; row < raw_height; row++)",
          "1606:     read_shorts(raw_image+row*raw_pitch,raw_width);",
          "1607: #endif",
          "1610: #if 0",
          "1615: #else",
          "1616:       int row = i/raw_width;",
          "1617:       int col = i%raw_height;",
          "1618:       a = RAW(row,col) ^ akey;",
          "1619:       b = RAW(row,col+1) ^ bkey;",
          "1620:       RAW(row,col) = (a & t_mask) | (b & ~t_mask);",
          "1621:       RAW(row,col+1) = (b & t_mask) | (a & ~t_mask);",
          "1622: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1648:   pixel = (ushort *) calloc (raw_width + raw_height*4, 2);",
          "1649:   merror (pixel, \"phase_one_load_raw_c()\");",
          "1651:   fseek (ifp, strip_offset, SEEK_SET);",
          "1652:   for (row=0; row < raw_height; row++)",
          "1653:     offset[row] = get4();",
          "",
          "[Removed Lines]",
          "1650:   offset = (int *) (pixel + raw_width);",
          "",
          "[Added Lines]",
          "1668:   offset = (int *) (pixel + raw_width);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1740:  fseek (ifp, get4(), SEEK_SET);",
          "1741:       }",
          "1742:       if (filters && c != shot_select) continue;",
          "1744:       read_shorts (pixel, raw_width);",
          "1745:       if (!filters && (row = r - top_margin) < height)",
          "1746:  for (col=0; col < width; col++)",
          "",
          "[Removed Lines]",
          "1743:       if (filters) pixel = raw_image + r*raw_width;",
          "",
          "[Added Lines]",
          "1761:       if (filters) pixel = raw_image + r*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1758:   int row, col, bits=0;",
          "1760:   while (1 << ++bits < maximum);",
          "1761:   read_shorts (raw_image, raw_width*raw_height);",
          "1762:   for (row=0; row < raw_height; row++)",
          "1763:     for (col=0; col < raw_width; col++)",
          "1764:       if ((RAW(row,col) >>= load_flags) >> bits",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1779: #if 0",
          "1781: #else",
          "1782:   for(row=0;row<raw_height;row++)",
          "1783:     read_shorts(raw_image+row*raw_pitch,raw_width);",
          "1784: #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2177:    RAW(y,x) = val;",
          "2178:  }",
          "2179:   }",
          "2180:   for (i=0; i < height*width; i++)",
          "2181:     raw_image[i] = curve[raw_image[i]];",
          "2182:   maximum = 0x3fff;",
          "2183: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2203: #if 0",
          "2206: #else",
          "2207:   for (i=0; i < height*width; i++)",
          "2208:     {",
          "2209:       int row = i/width;",
          "2210:       int col = i%width;",
          "2211:       RAW(row,col) = curve[RAW(row,col)];",
          "2212:     }",
          "2213: #endif",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2586:     key = key << 8 | head[i];",
          "2587:   fseek (ifp, data_offset, SEEK_SET);",
          "2588:   for (row=0; row < raw_height; row++) {",
          "2590:     if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();",
          "2591:     sony_decrypt ((unsigned int *) pixel, raw_width/2, !row, key);",
          "2592:     for (col=0; col < raw_width; col++)",
          "",
          "[Removed Lines]",
          "2589:     pixel = raw_image + row*raw_width;",
          "",
          "[Added Lines]",
          "2621:     pixel = raw_image + row*raw_pitch;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2755:       diff = diff ? -diff : 0x80;",
          "2756:     if (ftell(ifp) + 12 >= seg[1][1])",
          "2757:       diff = 0;",
          "2758:     raw_image[pix] = pred[pix & 1] += diff;",
          "2759:     if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;",
          "2760:   }",
          "2761:   maximum = 0xff;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2790: #if 0",
          "2792: #else",
          "2793:     RAW(pix/raw_width,pix%raw_width) = pred[pix & 1] += diff;",
          "2794: #endif",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2897:   jas_stream_close (in);",
          "2898: #endif",
          "2899: }",
          "2901: void CLASS crop_masked_pixels()",
          "2902: {",
          "2903:   int row, col;",
          "",
          "[Removed Lines]",
          "2900: #line 3877 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "2936: #line 3913 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2998:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);",
          "2999: #endif",
          "3000: }",
          "3002: void CLASS gamma_curve (double pwr, double ts, int mode, int imax)",
          "3003: {",
          "3004:   int i;",
          "",
          "[Removed Lines]",
          "3001: #line 4143 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "3037: #line 4179 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4496:     fseek (ifp, save, SEEK_SET);",
          "4497:   }",
          "4498: }",
          "4500: void CLASS parse_makernote (int base, int uptag)",
          "4501: {",
          "4502:   static const uchar xlat[2][256] = {",
          "",
          "[Removed Lines]",
          "4499: #line 5645 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "4535: #line 5681 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "5011:     fseek (ifp, save, SEEK_SET);",
          "5012:   }",
          "5013: }",
          "5015: int CLASS parse_tiff_ifd (int base)",
          "5016: {",
          "5017:   unsigned entries, tag, type, len, plen=16, save;",
          "",
          "[Removed Lines]",
          "5014: #line 6165 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "5050: #line 6201 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "6255:     data_offset = get4();",
          "6256:   }",
          "6257: }",
          "6259: char * CLASS foveon_gets (int offset, char *str, int len)",
          "6260: {",
          "6261:   int i;",
          "",
          "[Removed Lines]",
          "6258: #line 7411 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "6294: #line 7447 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "6356:   }",
          "6357:   is_foveon = 1;",
          "6358: }",
          "6361:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "",
          "[Removed Lines]",
          "6359: #line 7514 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "6395: #line 7550 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "8799: }",
          "8803: void CLASS convert_to_rgb()",
          "8804: {",
          "8805: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "8802: #line 10048 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8838: #line 10084 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "9030:   if (flip & 1) col = iwidth  - 1 - col;",
          "9031:   return row * iwidth + col;",
          "9032: }",
          "9034: void CLASS tiff_set (ushort *ntag,",
          "9035:  ushort tag, ushort type, int count, int val)",
          "9036: {",
          "",
          "[Removed Lines]",
          "9033: #line 10304 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "9069: #line 10340 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp": [
          "File: internal/dcraw_fileio.cpp -> internal/dcraw_fileio.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:    for more information",
          "25: #include <math.h>",
          "26: #define CLASS LibRaw::",
          "27: #include \"libraw/libraw_types.h\"",
          "",
          "[Removed Lines]",
          "24: #line 3980 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "24: #line 4016 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #include \"libraw/libraw.h\"",
          "30: #include \"internal/defines.h\"",
          "31: #include \"internal/var_defines.h\"",
          "34:    Seach from the current directory up to the root looking for",
          "35:    a \".badpixels\" file, and fix those pixels now.",
          "",
          "[Removed Lines]",
          "32: #line 3991 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "32: #line 4027 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54: #endif",
          "55:   if (cfname)",
          "56:     fp = fopen (cfname, \"r\");",
          "58:   if (!fp)",
          "59:       {",
          "60: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "57: #line 4041 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "57: #line 4077 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "154:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "155: #endif",
          "156: }",
          "158: #ifndef NO_LCMS",
          "159: void CLASS apply_profile (const char *input, const char *output)",
          "160: {",
          "",
          "[Removed Lines]",
          "157: #line 9959 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "157: #line 9995 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/defines.h||internal/defines.h": [
          "File: internal/defines.h -> internal/defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "151: #define RAW(row,col) \\",
          "153: #line 248 \"dcraw/dcraw.c\"",
          "154: #define BAYER(row,col) \\",
          "155:  image[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]",
          "",
          "[Removed Lines]",
          "152:  raw_image[(row)*raw_width+(col)]",
          "",
          "[Added Lines]",
          "152:  raw_image[(row)*raw_pitch+(col)]",
          "",
          "---------------"
        ],
        "internal/var_defines.h||internal/var_defines.h": [
          "File: internal/var_defines.h -> internal/var_defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #define raw_height      (imgdata.sizes.raw_height)",
          "41: #define raw_width       (imgdata.sizes.raw_width)",
          "42: #define height          (imgdata.sizes.height)",
          "43: #define width           (imgdata.sizes.width)",
          "44: #define top_margin      (imgdata.sizes.top_margin)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: #define raw_pitch       (imgdata.sizes.raw_pitch)",
          "",
          "---------------"
        ],
        "libraw/libraw_const.h||libraw/libraw_const.h": [
          "File: libraw/libraw_const.h -> libraw/libraw_const.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:     LIBRAW_DECODER_USEBAYER2 = 1<<3,",
          "31:     LIBRAW_DECODER_HASCURVE = 1<<4,",
          "32:     LIBRAW_DECODER_ITSASONY = 1<<5,",
          "33:     LIBRAW_DECODER_NOTSET = 1<<15",
          "34: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33:     LIBRAW_DECODER_TRYRAWSPEED = 1<<6,",
          "",
          "---------------"
        ],
        "libraw/libraw_types.h||libraw/libraw_types.h": [
          "File: libraw/libraw_types.h -> libraw/libraw_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "163: typedef struct",
          "164: {",
          "165:     ushort      raw_height,",
          "167:                 height,",
          "168:                 width,",
          "169:                 top_margin,",
          "",
          "[Removed Lines]",
          "166:                 raw_width,",
          "",
          "[Added Lines]",
          "166:                 raw_width,",
          "167:                 raw_pitch,",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "300:         {",
          "302:             d_info->decoder_name = \"lossless_jpeg_load_raw()\";",
          "304:         }",
          "305:     else if (load_raw == &LibRaw::canon_sraw_load_raw)",
          "306:         {",
          "",
          "[Removed Lines]",
          "303:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_HASCURVE;",
          "",
          "[Added Lines]",
          "303:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "313:             d_info->decoder_name = \"lossless_dng_load_raw()\";",
          "314:             d_info->decoder_flags = rawdata? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_LEGACY ;",
          "315:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "316:         }",
          "317:     else if (load_raw == &LibRaw::packed_dng_load_raw)",
          "318:         {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "316:             if(rawdata)",
          "317:               d_info->decoder_flags |= LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "320:             d_info->decoder_name = \"packed_dng_load_raw()\";",
          "321:             d_info->decoder_flags = rawdata ? LIBRAW_DECODER_FLATFIELD : LIBRAW_DECODER_LEGACY;",
          "322:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "323:         }",
          "324:     else if (load_raw == &LibRaw::pentax_load_raw )",
          "325:         {",
          "326:             d_info->decoder_name = \"pentax_load_raw()\";",
          "328:         }",
          "329:     else if (load_raw == &LibRaw::nikon_load_raw)",
          "330:         {",
          "332:             d_info->decoder_name = \"nikon_load_raw()\";",
          "334:         }",
          "335:     else if (load_raw == &LibRaw::rollei_load_raw )",
          "336:         {",
          "",
          "[Removed Lines]",
          "327:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "333:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "",
          "[Added Lines]",
          "325:             if(rawdata)",
          "326:               d_info->decoder_flags |= LIBRAW_DECODER_TRYRAWSPEED;",
          "331:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD  | LIBRAW_DECODER_TRYRAWSPEED;",
          "337:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "377:     else if (load_raw == &LibRaw::packed_load_raw )",
          "378:         {",
          "379:             d_info->decoder_name = \"packed_load_raw()\";",
          "381:         }",
          "382:     else if (load_raw == &LibRaw::nokia_load_raw )",
          "383:         {",
          "",
          "[Removed Lines]",
          "380:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "",
          "[Added Lines]",
          "384:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD  | LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "388:     else if (load_raw == &LibRaw::panasonic_load_raw )",
          "389:         {",
          "390:             d_info->decoder_name = \"panasonic_load_raw()\";",
          "392:         }",
          "393:     else if (load_raw == &LibRaw::olympus_load_raw )",
          "394:         {",
          "395:             d_info->decoder_name = \"olympus_load_raw()\";",
          "397:         }",
          "398:     else if (load_raw == &LibRaw::minolta_rd175_load_raw )",
          "399:         {",
          "",
          "[Removed Lines]",
          "391:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "396:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "",
          "[Added Lines]",
          "395:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD  | LIBRAW_DECODER_TRYRAWSPEED;",
          "400:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "470:     else if (load_raw == &LibRaw::sony_load_raw )",
          "471:         {",
          "472:             d_info->decoder_name = \"sony_load_raw()\";",
          "474:         }",
          "475:     else if (load_raw == &LibRaw::sony_arw_load_raw )",
          "476:         {",
          "477:             d_info->decoder_name = \"sony_arw_load_raw()\";",
          "479:         }",
          "480:     else if (load_raw == &LibRaw::sony_arw2_load_raw )",
          "481:         {",
          "482:             d_info->decoder_name = \"sony_arw2_load_raw()\";",
          "483:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "485:             d_info->decoder_flags |= LIBRAW_DECODER_ITSASONY;",
          "486:         }",
          "487:     else if (load_raw == &LibRaw::smal_v6_load_raw )",
          "",
          "[Removed Lines]",
          "473:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "478:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "484:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "",
          "[Added Lines]",
          "477:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_TRYRAWSPEED;",
          "482:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_TRYRAWSPEED;",
          "488:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "791:                 if(rheight < S.height + S.top_margin)",
          "792:                     rheight = S.height + S.top_margin;",
          "793:             }",
          "795:         if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "796:             {",
          "798:               imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "799:             }",
          "800:         else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "",
          "[Removed Lines]",
          "797:               imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "",
          "[Added Lines]",
          "798:         S.raw_pitch = S.raw_width;",
          "801:               S.raw_pitch = ((rwidth*2+15)/16)*8;",
          "802:               if(S.raw_pitch!=S.raw_width)",
          "803:                 fprintf(stderr,\"File %s pitch=%d width=%d\\n\",ID.input->fname(),S.raw_pitch,S.raw_width);",
          "804:               imgdata.rawdata.raw_alloc = malloc(S.raw_pitch*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "948:                     }",
          "949:                     if (r < S.height && c < S.width)",
          "950:                       imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "952:                   }",
          "953:                 }",
          "954:               }",
          "",
          "[Removed Lines]",
          "951:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "",
          "[Added Lines]",
          "958:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch+(col+S.left_margin)];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "957:                 for (row=0; row < S.height; row++)",
          "958:                   for (col=0; col < S.width; col++)",
          "959:                     imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "961:               }",
          "962:             }",
          "963:         else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "",
          "[Removed Lines]",
          "960:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "",
          "[Added Lines]",
          "967:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch+(col+S.left_margin)];",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "985: void LibRaw::phase_one_allocate_tempbuffer()",
          "986: {",
          "989:   merror (imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");",
          "990: }",
          "991: void LibRaw::phase_one_free_tempbuffer()",
          "",
          "[Removed Lines]",
          "988:   imgdata.rawdata.raw_image = (ushort*)malloc(S.raw_width*S.raw_height*sizeof(ushort));",
          "",
          "[Added Lines]",
          "995:   imgdata.rawdata.raw_image = (ushort*)malloc(S.raw_pitch*S.raw_height*sizeof(ushort));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1058:                         }",
          "1059:                         if (r < S.height && c < S.width)",
          "1060:                           {",
          "1062:                             int cc = FC(r,c);",
          "1063:                             if(val>cblack[cc])",
          "1064:                               {",
          "",
          "[Removed Lines]",
          "1061:                             unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "",
          "[Added Lines]",
          "1068:                             unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch+(col+S.left_margin)];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1093:       unsigned short ldmax = 0;",
          "1094:       for (col=0; col < S.width; col++)",
          "1095:         {",
          "1097:           int cc = fcol(row,col);",
          "1098:           if(val>cblack[cc])",
          "1099:             {",
          "",
          "[Removed Lines]",
          "1096:           unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "",
          "[Added Lines]",
          "1103:           unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch+(col+S.left_margin)];",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1250:                           c = row + ((col+1) >> 1);",
          "1251:                         }",
          "1254:                                                             +(col+S.left_margin)];",
          "1255:                         int cc = FCF(row,col);",
          "1256:                         if(val > cblack[cc])",
          "",
          "[Removed Lines]",
          "1253:                         unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "",
          "[Added Lines]",
          "1260:                         unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0871f9f0a3c7dd565442b4cfcf88fda3ba39d333",
      "candidate_info": {
        "commit_hash": "0871f9f0a3c7dd565442b4cfcf88fda3ba39d333",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/0871f9f0a3c7dd565442b4cfcf88fda3ba39d333",
        "files": [
          "src/libraw_cxx.cpp"
        ],
        "message": "libraw_cxx formatted",
        "before_after_code_files": [
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: extern \"C\"",
          "50: {",
          "51: #endif",
          "100: #ifdef __cplusplus",
          "101: }",
          "",
          "[Removed Lines]",
          "52:     void default_memory_callback(void *,const char *file,const char *where)",
          "53:     {",
          "54:         fprintf (stderr,\"%s: Out of memory in %s\\n\", file?file:\"unknown file\", where);",
          "55:     }",
          "57:     void default_data_callback(void*,const char *file, const int offset)",
          "58:     {",
          "59:         if(offset < 0)",
          "60:             fprintf (stderr,\"%s: Unexpected end of file\\n\", file?file:\"unknown file\");",
          "61:         else",
          "62:             fprintf (stderr,\"%s: data corrupted at %d\\n\",file?file:\"unknown file\",offset);",
          "63:     }",
          "64:     const char *libraw_strerror(int e)",
          "65:     {",
          "66:         enum LibRaw_errors errorcode = (LibRaw_errors)e;",
          "67:         switch(errorcode)",
          "68:             {",
          "69:             case        LIBRAW_SUCCESS:",
          "70:                 return \"No error\";",
          "71:             case        LIBRAW_UNSPECIFIED_ERROR:",
          "72:                 return \"Unspecified error\";",
          "73:             case        LIBRAW_FILE_UNSUPPORTED:",
          "74:                 return \"Unsupported file format or not RAW file\";",
          "75:             case        LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:",
          "76:                 return \"Request for nonexisting image number\";",
          "77:             case        LIBRAW_OUT_OF_ORDER_CALL:",
          "78:                 return \"Out of order call of libraw function\";",
          "79:             case    LIBRAW_NO_THUMBNAIL:",
          "80:                 return \"No thumbnail in file\";",
          "81:             case    LIBRAW_UNSUPPORTED_THUMBNAIL:",
          "82:                 return \"Unsupported thumbnail format\";",
          "83:    case LIBRAW_INPUT_CLOSED:",
          "84:     return \"No input stream, or input stream closed\";",
          "85:             case    LIBRAW_UNSUFFICIENT_MEMORY:",
          "86:                 return \"Unsufficient memory\";",
          "87:             case    LIBRAW_DATA_ERROR:",
          "88:                 return \"Corrupted data or unexpected EOF\";",
          "89:             case    LIBRAW_IO_ERROR:",
          "90:                 return \"Input/output error\";",
          "91:             case LIBRAW_CANCELLED_BY_CALLBACK:",
          "92:                 return \"Cancelled by user callback\";",
          "93:             case LIBRAW_BAD_CROP:",
          "94:                 return \"Bad crop box\";",
          "95:             default:",
          "96:                 return \"Unknown error code\";",
          "97:         }",
          "98:     }",
          "",
          "[Added Lines]",
          "52:   void default_memory_callback(void *,const char *file,const char *where)",
          "53:   {",
          "54:     fprintf (stderr,\"%s: Out of memory in %s\\n\", file?file:\"unknown file\", where);",
          "55:   }",
          "57:   void default_data_callback(void*,const char *file, const int offset)",
          "58:   {",
          "59:     if(offset < 0)",
          "60:       fprintf (stderr,\"%s: Unexpected end of file\\n\", file?file:\"unknown file\");",
          "61:     else",
          "62:       fprintf (stderr,\"%s: data corrupted at %d\\n\",file?file:\"unknown file\",offset);",
          "63:   }",
          "64:   const char *libraw_strerror(int e)",
          "65:   {",
          "66:     enum LibRaw_errors errorcode = (LibRaw_errors)e;",
          "67:     switch(errorcode)",
          "68:       {",
          "69:       case        LIBRAW_SUCCESS:",
          "70:         return \"No error\";",
          "71:       case        LIBRAW_UNSPECIFIED_ERROR:",
          "72:         return \"Unspecified error\";",
          "73:       case        LIBRAW_FILE_UNSUPPORTED:",
          "74:         return \"Unsupported file format or not RAW file\";",
          "75:       case        LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:",
          "76:         return \"Request for nonexisting image number\";",
          "77:       case        LIBRAW_OUT_OF_ORDER_CALL:",
          "78:         return \"Out of order call of libraw function\";",
          "79:       case    LIBRAW_NO_THUMBNAIL:",
          "80:         return \"No thumbnail in file\";",
          "81:       case    LIBRAW_UNSUPPORTED_THUMBNAIL:",
          "82:         return \"Unsupported thumbnail format\";",
          "83:       case LIBRAW_INPUT_CLOSED:",
          "84:         return \"No input stream, or input stream closed\";",
          "85:       case    LIBRAW_UNSUFFICIENT_MEMORY:",
          "86:         return \"Unsufficient memory\";",
          "87:       case    LIBRAW_DATA_ERROR:",
          "88:         return \"Corrupted data or unexpected EOF\";",
          "89:       case    LIBRAW_IO_ERROR:",
          "90:         return \"Input/output error\";",
          "91:       case LIBRAW_CANCELLED_BY_CALLBACK:",
          "92:         return \"Cancelled by user callback\";",
          "93:       case LIBRAW_BAD_CROP:",
          "94:         return \"Bad crop box\";",
          "95:       default:",
          "96:         return \"Unknown error code\";",
          "97:       }",
          "98:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120: #define ID libraw_internal_data.internal_data",
          "122: #define EXCEPTION_HANDLER(e) do{                        \\",
          "151: const char* LibRaw::version() { return LIBRAW_VERSION_STR;}",
          "152: int LibRaw::versionNumber() { return LIBRAW_VERSION; }",
          "",
          "[Removed Lines]",
          "124:         switch(e)                                       \\",
          "125:             {                                           \\",
          "126:             case LIBRAW_EXCEPTION_ALLOC:                \\",
          "127:                 recycle();                              \\",
          "128:                 return LIBRAW_UNSUFFICIENT_MEMORY;      \\",
          "129:             case LIBRAW_EXCEPTION_DECODE_RAW:           \\",
          "130:             case LIBRAW_EXCEPTION_DECODE_JPEG:          \\",
          "131:                 recycle();                              \\",
          "132:                 return LIBRAW_DATA_ERROR;               \\",
          "133:             case LIBRAW_EXCEPTION_DECODE_JPEG2000:      \\",
          "134:                 recycle();                              \\",
          "135:                 return LIBRAW_DATA_ERROR;               \\",
          "136:             case LIBRAW_EXCEPTION_IO_EOF:               \\",
          "137:             case LIBRAW_EXCEPTION_IO_CORRUPT:           \\",
          "138:                 recycle();                              \\",
          "139:                 return LIBRAW_IO_ERROR;                 \\",
          "140:             case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:\\",
          "141:                 recycle();                              \\",
          "142:                 return LIBRAW_CANCELLED_BY_CALLBACK;    \\",
          "143:             case LIBRAW_EXCEPTION_BAD_CROP:             \\",
          "144:                 recycle();                              \\",
          "145:                 return LIBRAW_BAD_CROP;                 \\",
          "146:             default:                                    \\",
          "147:                 return LIBRAW_UNSPECIFIED_ERROR;        \\",
          "148:             } \\",
          "149:     }while(0)",
          "",
          "[Added Lines]",
          "124:     switch(e)                                           \\",
          "125:       {                                                 \\",
          "126:       case LIBRAW_EXCEPTION_ALLOC:                      \\",
          "127:         recycle();                                      \\",
          "128:         return LIBRAW_UNSUFFICIENT_MEMORY;              \\",
          "129:       case LIBRAW_EXCEPTION_DECODE_RAW:                 \\",
          "130:       case LIBRAW_EXCEPTION_DECODE_JPEG:                \\",
          "131:         recycle();                                      \\",
          "132:         return LIBRAW_DATA_ERROR;                       \\",
          "133:       case LIBRAW_EXCEPTION_DECODE_JPEG2000:            \\",
          "134:         recycle();                                      \\",
          "135:         return LIBRAW_DATA_ERROR;                       \\",
          "136:       case LIBRAW_EXCEPTION_IO_EOF:                     \\",
          "137:       case LIBRAW_EXCEPTION_IO_CORRUPT:                 \\",
          "138:         recycle();                                      \\",
          "139:         return LIBRAW_IO_ERROR;                                 \\",
          "140:       case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:              \\",
          "141:         recycle();                                              \\",
          "142:         return LIBRAW_CANCELLED_BY_CALLBACK;                    \\",
          "143:       case LIBRAW_EXCEPTION_BAD_CROP:                           \\",
          "144:         recycle();                                              \\",
          "145:         return LIBRAW_BAD_CROP;                                 \\",
          "146:       default:                                                  \\",
          "147:         return LIBRAW_UNSPECIFIED_ERROR;                        \\",
          "148:       }                                                         \\",
          "149:   }while(0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "156: void LibRaw::derror()",
          "157: {",
          "159:         {",
          "173:         }",
          "175: }",
          "177: void LibRaw::dcraw_clear_mem(libraw_processed_image_t* p)",
          "",
          "[Removed Lines]",
          "158:     if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)",
          "160:             if (libraw_internal_data.internal_data.input->eof())",
          "161:                 {",
          "162:                     if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "163:                                                               libraw_internal_data.internal_data.input->fname(),-1);",
          "164:                     throw LIBRAW_EXCEPTION_IO_EOF;",
          "165:                 }",
          "166:             else",
          "167:                 {",
          "168:                     if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "169:                                                               libraw_internal_data.internal_data.input->fname(),",
          "170:                                                               libraw_internal_data.internal_data.input->tell());",
          "171:                     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "172:                 }",
          "174:     libraw_internal_data.unpacker_data.data_error++;",
          "",
          "[Added Lines]",
          "158:   if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)",
          "159:     {",
          "160:       if (libraw_internal_data.internal_data.input->eof())",
          "162:           if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "163:                                                     libraw_internal_data.internal_data.input->fname(),-1);",
          "164:           throw LIBRAW_EXCEPTION_IO_EOF;",
          "165:         }",
          "166:       else",
          "167:         {",
          "168:           if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "169:                                                     libraw_internal_data.internal_data.input->fname(),",
          "170:                                                     libraw_internal_data.internal_data.input->tell());",
          "171:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "173:     }",
          "174:   libraw_internal_data.unpacker_data.data_error++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "184: class CameraMetaDataLR : public CameraMetaData",
          "185: {",
          "186: public:",
          "190: };",
          "192: CameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData() {",
          "",
          "[Removed Lines]",
          "187:  CameraMetaDataLR() : CameraMetaData() {}",
          "188:  CameraMetaDataLR(char *filename) : CameraMetaData(filename){}",
          "189:  CameraMetaDataLR(char *data, int sz);",
          "",
          "[Added Lines]",
          "187:   CameraMetaDataLR() : CameraMetaData() {}",
          "188:   CameraMetaDataLR(char *filename) : CameraMetaData(filename){}",
          "189:   CameraMetaDataLR(char *data, int sz);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "277: LibRaw:: LibRaw(unsigned int flags)",
          "278: {",
          "283: #ifdef DCRAW_VERBOSE",
          "285: #else",
          "287: #endif",
          "294: #ifdef USE_RAWSPEED",
          "297: #endif",
          "325: }",
          "327: int LibRaw::set_rawspeed_camerafile(char *filename)",
          "",
          "[Removed Lines]",
          "279:     double aber[4] = {1,1,1,1};",
          "280:     double gamm[6] = { 0.45,4.5,0,0,0,0 };",
          "281:     unsigned greybox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "282:     unsigned cropbox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "284:     verbose = 1;",
          "286:     verbose = 0;",
          "288:     ZERO(imgdata);",
          "289:     ZERO(libraw_internal_data);",
          "290:     ZERO(callbacks);",
          "292:     _rawspeed_camerameta = _rawspeed_decoder = NULL;",
          "295:  CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()",
          "296:  _rawspeed_camerameta = static_cast<void*>(camerameta);",
          "298:     callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL:  &default_memory_callback;",
          "299:     callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK)? NULL : &default_data_callback;",
          "300:     memmove(&imgdata.params.aber,&aber,sizeof(aber));",
          "301:     memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));",
          "302:     memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));",
          "303:     memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));",
          "305:     imgdata.params.bright=1;",
          "306:     imgdata.params.use_camera_matrix=-1;",
          "307:     imgdata.params.user_flip=-1;",
          "308:     imgdata.params.user_black=-1;",
          "309:  imgdata.params.user_cblack[0]=imgdata.params.user_cblack[1]=imgdata.params.user_cblack[2]=imgdata.params.user_cblack[3]=-1000001;",
          "310:     imgdata.params.user_sat=-1;",
          "311:     imgdata.params.user_qual=-1;",
          "312:     imgdata.params.output_color=1;",
          "313:     imgdata.params.output_bps=8;",
          "314:     imgdata.params.use_fuji_rotate=1;",
          "315:     imgdata.params.exp_shift = 1.0;",
          "316:     imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;",
          "317:     imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "318:     imgdata.params.use_rawspeed = 1;",
          "319:     imgdata.params.no_auto_scale = 0;",
          "320:     imgdata.params.green_matching = 0;",
          "321:     imgdata.parent_class = this;",
          "322:     imgdata.progress_flags = 0;",
          "323:     tls = new LibRaw_TLS;",
          "324:     tls->init();",
          "",
          "[Added Lines]",
          "279:   double aber[4] = {1,1,1,1};",
          "280:   double gamm[6] = { 0.45,4.5,0,0,0,0 };",
          "281:   unsigned greybox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "282:   unsigned cropbox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "284:   verbose = 1;",
          "286:   verbose = 0;",
          "288:   ZERO(imgdata);",
          "289:   ZERO(libraw_internal_data);",
          "290:   ZERO(callbacks);",
          "292:   _rawspeed_camerameta = _rawspeed_decoder = NULL;",
          "295:   CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()",
          "296:   _rawspeed_camerameta = static_cast<void*>(camerameta);",
          "298:   callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL:  &default_memory_callback;",
          "299:   callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK)? NULL : &default_data_callback;",
          "300:   memmove(&imgdata.params.aber,&aber,sizeof(aber));",
          "301:   memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));",
          "302:   memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));",
          "303:   memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));",
          "305:   imgdata.params.bright=1;",
          "306:   imgdata.params.use_camera_matrix=-1;",
          "307:   imgdata.params.user_flip=-1;",
          "308:   imgdata.params.user_black=-1;",
          "309:   imgdata.params.user_cblack[0]=imgdata.params.user_cblack[1]=imgdata.params.user_cblack[2]=imgdata.params.user_cblack[3]=-1000001;",
          "310:   imgdata.params.user_sat=-1;",
          "311:   imgdata.params.user_qual=-1;",
          "312:   imgdata.params.output_color=1;",
          "313:   imgdata.params.output_bps=8;",
          "314:   imgdata.params.use_fuji_rotate=1;",
          "315:   imgdata.params.exp_shift = 1.0;",
          "316:   imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;",
          "317:   imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "318:   imgdata.params.use_rawspeed = 1;",
          "319:   imgdata.params.no_auto_scale = 0;",
          "320:   imgdata.params.green_matching = 0;",
          "321:   imgdata.parent_class = this;",
          "322:   imgdata.progress_flags = 0;",
          "323:   tls = new LibRaw_TLS;",
          "324:   tls->init();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "740: int LibRaw::open_file(const char *fname, INT64 max_buf_size)",
          "741: {",
          "742: #ifndef WIN32",
          "747: #else",
          "752: #endif",
          "778:     else",
          "784: }",
          "786: #if defined(WIN32) && !defined(__MINGW32__)",
          "787: int LibRaw::open_file(const wchar_t *fname, INT64 max_buf_size)",
          "788: {",
          "824: }",
          "825: #endif",
          "827: int LibRaw::open_buffer(void *buffer, size_t size)",
          "828: {",
          "836:     }",
          "859: }",
          "861: void LibRaw::hasselblad_full_load_raw()",
          "",
          "[Removed Lines]",
          "743:     struct stat st;",
          "744:     if(stat(fname,&st))",
          "745:         return LIBRAW_IO_ERROR;",
          "746:     int big = (st.st_size > max_buf_size)?1:0;",
          "748:  struct _stati64 st;",
          "749:     if(_stati64(fname,&st))",
          "750:         return LIBRAW_IO_ERROR;",
          "751:     int big = (st.st_size > max_buf_size)?1:0;",
          "754:     LibRaw_abstract_datastream *stream;",
          "755:     try {",
          "756:         if(big)",
          "757:          stream = new LibRaw_bigfile_datastream(fname);",
          "758:         else",
          "759:          stream = new LibRaw_file_datastream(fname);",
          "760:     }",
          "762:     catch (std::bad_alloc)",
          "763:         {",
          "764:             recycle();",
          "765:             return LIBRAW_UNSUFFICIENT_MEMORY;",
          "766:         }",
          "767:     if(!stream->valid())",
          "768:         {",
          "769:             delete stream;",
          "770:             return LIBRAW_IO_ERROR;",
          "771:         }",
          "772:     ID.input_internal = 0; // preserve from deletion on error",
          "773:     int ret = open_datastream(stream);",
          "774:     if (ret == LIBRAW_SUCCESS)",
          "775:         {",
          "776:             ID.input_internal =1 ; // flag to delete datastream on recycle",
          "777:         }",
          "779:         {",
          "780:             delete stream;",
          "781:             ID.input_internal = 0;",
          "782:         }",
          "783:     return ret;",
          "789:  struct _stati64 st;",
          "790:  if(_wstati64(fname,&st))",
          "791:   return LIBRAW_IO_ERROR;",
          "792:  int big = (st.st_size > max_buf_size)?1:0;",
          "794:  LibRaw_abstract_datastream *stream;",
          "795:  try {",
          "796:   if(big)",
          "797:    stream = new LibRaw_bigfile_datastream(fname);",
          "798:   else",
          "799:    stream = new LibRaw_file_datastream(fname);",
          "800:  }",
          "802:  catch (std::bad_alloc)",
          "803:  {",
          "804:   recycle();",
          "805:   return LIBRAW_UNSUFFICIENT_MEMORY;",
          "806:  }",
          "807:  if(!stream->valid())",
          "808:  {",
          "809:   delete stream;",
          "810:   return LIBRAW_IO_ERROR;",
          "811:  }",
          "812:  ID.input_internal = 0; // preserve from deletion on error",
          "813:  int ret = open_datastream(stream);",
          "814:  if (ret == LIBRAW_SUCCESS)",
          "815:  {",
          "816:   ID.input_internal =1 ; // flag to delete datastream on recycle",
          "817:  }",
          "818:  else",
          "819:  {",
          "820:   delete stream;",
          "821:   ID.input_internal = 0;",
          "822:  }",
          "823:  return ret;",
          "830:     if(!buffer  || buffer==(void*)-1)",
          "831:         return LIBRAW_IO_ERROR;",
          "833:     LibRaw_buffer_datastream *stream;",
          "834:     try {",
          "835:         stream = new LibRaw_buffer_datastream(buffer,size);",
          "837:     catch (std::bad_alloc)",
          "838:         {",
          "839:             recycle();",
          "840:             return LIBRAW_UNSUFFICIENT_MEMORY;",
          "841:         }",
          "842:     if(!stream->valid())",
          "843:         {",
          "844:             delete stream;",
          "845:             return LIBRAW_IO_ERROR;",
          "846:         }",
          "847:     ID.input_internal = 0; // preserve from deletion on error",
          "848:     int ret = open_datastream(stream);",
          "849:     if (ret == LIBRAW_SUCCESS)",
          "850:         {",
          "851:             ID.input_internal =1 ; // flag to delete datastream on recycle",
          "852:         }",
          "853:     else",
          "854:         {",
          "855:             delete stream;",
          "856:             ID.input_internal = 0;",
          "857:         }",
          "858:     return ret;",
          "",
          "[Added Lines]",
          "744:   struct stat st;",
          "745:   if(stat(fname,&st))",
          "746:     return LIBRAW_IO_ERROR;",
          "747:   int big = (st.st_size > max_buf_size)?1:0;",
          "749:   struct _stati64 st;",
          "750:   if(_stati64(fname,&st))",
          "751:     return LIBRAW_IO_ERROR;",
          "752:   int big = (st.st_size > max_buf_size)?1:0;",
          "755:   LibRaw_abstract_datastream *stream;",
          "756:   try {",
          "757:     if(big)",
          "758:       stream = new LibRaw_bigfile_datastream(fname);",
          "760:       stream = new LibRaw_file_datastream(fname);",
          "761:   }",
          "763:   catch (std::bad_alloc)",
          "764:     {",
          "765:       recycle();",
          "766:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "767:     }",
          "768:   if(!stream->valid())",
          "769:     {",
          "770:       delete stream;",
          "771:       return LIBRAW_IO_ERROR;",
          "772:     }",
          "773:   ID.input_internal = 0; // preserve from deletion on error",
          "774:   int ret = open_datastream(stream);",
          "775:   if (ret == LIBRAW_SUCCESS)",
          "776:     {",
          "777:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "778:     }",
          "779:   else",
          "780:     {",
          "781:       delete stream;",
          "782:       ID.input_internal = 0;",
          "783:     }",
          "784:   return ret;",
          "790:   struct _stati64 st;",
          "791:   if(_wstati64(fname,&st))",
          "792:     return LIBRAW_IO_ERROR;",
          "793:   int big = (st.st_size > max_buf_size)?1:0;",
          "795:   LibRaw_abstract_datastream *stream;",
          "796:   try {",
          "797:     if(big)",
          "798:       stream = new LibRaw_bigfile_datastream(fname);",
          "799:     else",
          "800:       stream = new LibRaw_file_datastream(fname);",
          "801:   }",
          "803:   catch (std::bad_alloc)",
          "804:     {",
          "805:       recycle();",
          "806:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "807:     }",
          "808:   if(!stream->valid())",
          "809:     {",
          "810:       delete stream;",
          "811:       return LIBRAW_IO_ERROR;",
          "812:     }",
          "813:   ID.input_internal = 0; // preserve from deletion on error",
          "814:   int ret = open_datastream(stream);",
          "815:   if (ret == LIBRAW_SUCCESS)",
          "816:     {",
          "817:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "818:     }",
          "819:   else",
          "820:     {",
          "821:       delete stream;",
          "822:       ID.input_internal = 0;",
          "823:     }",
          "824:   return ret;",
          "831:   if(!buffer  || buffer==(void*)-1)",
          "832:     return LIBRAW_IO_ERROR;",
          "834:   LibRaw_buffer_datastream *stream;",
          "835:   try {",
          "836:     stream = new LibRaw_buffer_datastream(buffer,size);",
          "837:   }",
          "838:   catch (std::bad_alloc)",
          "839:     {",
          "840:       recycle();",
          "841:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "843:   if(!stream->valid())",
          "844:     {",
          "845:       delete stream;",
          "846:       return LIBRAW_IO_ERROR;",
          "847:     }",
          "848:   ID.input_internal = 0; // preserve from deletion on error",
          "849:   int ret = open_datastream(stream);",
          "850:   if (ret == LIBRAW_SUCCESS)",
          "851:     {",
          "852:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "853:     }",
          "854:   else",
          "855:     {",
          "856:       delete stream;",
          "857:       ID.input_internal = 0;",
          "858:     }",
          "859:   return ret;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "875: int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)",
          "876: {",
          "892: #if 0",
          "908: #endif",
          "955: }",
          "957: #ifdef USE_RAWSPEED",
          "",
          "[Removed Lines]",
          "878:     if(!stream)",
          "879:         return ENOENT;",
          "880:     if(!stream->valid())",
          "881:         return LIBRAW_IO_ERROR;",
          "882:     recycle();",
          "884:     try {",
          "885:         ID.input = stream;",
          "886:         SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);",
          "888:         if (O.use_camera_matrix < 0)",
          "889:             O.use_camera_matrix = O.use_camera_wb;",
          "891:         identify();",
          "893:         size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;",
          "894:         float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);",
          "895:         float bpp2 = float(bytes)/float(S.width)/float(S.height);",
          "896:         printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);",
          "897:         if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)",
          "898:           {",
          "899:             load_raw = &LibRaw::hasselblad_full_load_raw;",
          "900:             S.width = S.raw_width;",
          "901:             S.height = S.raw_height;",
          "902:             P1.filters = 0;",
          "903:             P1.colors=3;",
          "904:             P1.raw_count=1;",
          "905:             C.maximum=0xffff;",
          "906:             printf(\"3 channel hassy found\\n\");",
          "907:           }",
          "909:         if(C.profile_length)",
          "910:             {",
          "911:                 if(C.profile) free(C.profile);",
          "912:                 C.profile = malloc(C.profile_length);",
          "913:                 merror(C.profile,\"LibRaw::open_file()\");",
          "914:                 ID.input->seek(ID.profile_offset,SEEK_SET);",
          "915:                 ID.input->read(C.profile,C.profile_length,1);",
          "916:             }",
          "918:         SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);",
          "919:     }",
          "920:     catch ( LibRaw_exceptions err) {",
          "921:         EXCEPTION_HANDLER(err);",
          "922:     }",
          "923:     catch (std::exception ee) {",
          "924:         EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "925:     }",
          "927:     if(P1.raw_count < 1)",
          "928:         return LIBRAW_FILE_UNSUPPORTED;",
          "931:     write_fun = &LibRaw::write_ppm_tiff;",
          "933:     if (load_raw == &LibRaw::kodak_ycbcr_load_raw)",
          "934:         {",
          "935:             S.height += S.height & 1;",
          "936:             S.width  += S.width  & 1;",
          "937:         }",
          "939:     IO.shrink = P1.filters && (O.half_size ||",
          "940:  ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "942:     S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "943:     S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "946:     memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "947:     memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "948:     memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "949:     memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "951:     SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);",
          "954:     return LIBRAW_SUCCESS;",
          "",
          "[Added Lines]",
          "879:   if(!stream)",
          "880:     return ENOENT;",
          "881:   if(!stream->valid())",
          "882:     return LIBRAW_IO_ERROR;",
          "883:   recycle();",
          "885:   try {",
          "886:     ID.input = stream;",
          "887:     SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);",
          "889:     if (O.use_camera_matrix < 0)",
          "890:       O.use_camera_matrix = O.use_camera_wb;",
          "892:     identify();",
          "894:     size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;",
          "895:     float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);",
          "896:     float bpp2 = float(bytes)/float(S.width)/float(S.height);",
          "897:     printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);",
          "898:     if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)",
          "899:       {",
          "900:         load_raw = &LibRaw::hasselblad_full_load_raw;",
          "901:         S.width = S.raw_width;",
          "902:         S.height = S.raw_height;",
          "903:         P1.filters = 0;",
          "904:         P1.colors=3;",
          "905:         P1.raw_count=1;",
          "906:         C.maximum=0xffff;",
          "907:         printf(\"3 channel hassy found\\n\");",
          "908:       }",
          "910:     if(C.profile_length)",
          "911:       {",
          "912:         if(C.profile) free(C.profile);",
          "913:         C.profile = malloc(C.profile_length);",
          "914:         merror(C.profile,\"LibRaw::open_file()\");",
          "915:         ID.input->seek(ID.profile_offset,SEEK_SET);",
          "916:         ID.input->read(C.profile,C.profile_length,1);",
          "917:       }",
          "919:     SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);",
          "920:   }",
          "921:   catch ( LibRaw_exceptions err) {",
          "922:     EXCEPTION_HANDLER(err);",
          "923:   }",
          "924:   catch (std::exception ee) {",
          "925:     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "926:   }",
          "928:   if(P1.raw_count < 1)",
          "929:     return LIBRAW_FILE_UNSUPPORTED;",
          "932:   write_fun = &LibRaw::write_ppm_tiff;",
          "934:   if (load_raw == &LibRaw::kodak_ycbcr_load_raw)",
          "935:     {",
          "936:       S.height += S.height & 1;",
          "937:       S.width  += S.width  & 1;",
          "938:     }",
          "940:   IO.shrink = P1.filters && (O.half_size ||",
          "941:                              ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "943:   S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "944:   S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "947:   memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "948:   memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "949:   memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "950:   memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "952:   SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);",
          "955:   return LIBRAW_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "981: int LibRaw::unpack(void)",
          "982: {",
          "1038: #ifdef USE_RAWSPEED",
          "1041:           {",
          "1096:             }",
          "1104:               {",
          "1107:               }",
          "1109:               {",
          "1119:               }",
          "1129:               {",
          "1138:               }",
          "1139:           }",
          "1182: }",
          "1184: void LibRaw::free_image(void)",
          "1185: {",
          "1194: }",
          "1197: void LibRaw::raw2image_start()",
          "1198: {",
          "1222: }",
          "",
          "[Removed Lines]",
          "983:     CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);",
          "984:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "985:     try {",
          "987:  if(!libraw_internal_data.internal_data.input)",
          "988:           return LIBRAW_INPUT_CLOSED;",
          "990:         RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);",
          "991:         if (O.shot_select >= P1.raw_count)",
          "992:             return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;",
          "994:         if(!load_raw)",
          "995:             return LIBRAW_UNSPECIFIED_ERROR;",
          "997:         if (O.use_camera_matrix && C.cmatrix[0][0] > 0.25)",
          "998:             {",
          "999:                 memcpy (C.rgb_cam, C.cmatrix, sizeof (C.cmatrix));",
          "1000:                 IO.raw_color = 0;",
          "1001:             }",
          "1003:         if(imgdata.image)",
          "1004:             {",
          "1005:                 free(imgdata.image);",
          "1006:                 imgdata.image = 0;",
          "1007:             }",
          "1008:         if(imgdata.rawdata.raw_alloc)",
          "1009:           {",
          "1010:             free(imgdata.rawdata.raw_alloc);",
          "1011:             imgdata.rawdata.raw_alloc = 0;",
          "1012:           }",
          "1013:         if (libraw_internal_data.unpacker_data.meta_length)",
          "1014:             {",
          "1015:                 libraw_internal_data.internal_data.meta_data =",
          "1016:                     (char *) malloc (libraw_internal_data.unpacker_data.meta_length);",
          "1017:                 merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");",
          "1018:             }",
          "1020:         libraw_decoder_info_t decoder_info;",
          "1021:         get_decoder_info(&decoder_info);",
          "1023:         int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;",
          "1025:         int rwidth = S.raw_width, rheight = S.raw_height;",
          "1026:         if( !IO.fuji_width)",
          "1027:             {",
          "1029:                 if(rwidth < S.width + S.left_margin)",
          "1030:                     rwidth = S.width + S.left_margin;",
          "1031:                 if(rheight < S.height + S.top_margin)",
          "1032:                     rheight = S.height + S.top_margin;",
          "1033:             }",
          "1034:         S.raw_pitch = S.raw_width*2;",
          "1035:         imgdata.rawdata.raw_image = 0;",
          "1036:         imgdata.rawdata.color4_image = 0;",
          "1037:  imgdata.rawdata.color3_image = 0;",
          "1040:         if(O.use_rawspeed && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "1042:             INT64 spos = ID.input->tell();",
          "1043:             try",
          "1044:               {",
          "1046:                 ID.input->seek(0,SEEK_SET);",
          "1047:                 INT64 _rawspeed_buffer_sz = ID.input->size()+32;",
          "1048:                 void *_rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "1049:                 if(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;",
          "1050:                 ID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);",
          "1051:                 FileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);",
          "1052:                 RawParser t(&map);",
          "1053:                 RawDecoder *d = 0;",
          "1054:                 CameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "1055:                 d = t.getDecoder();",
          "1056:                 try {",
          "1057:                   d->checkSupport(meta);",
          "1058:                 }",
          "1059:                 catch (const RawDecoderException& e)",
          "1060:                   {",
          "1061:                     imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;",
          "1062:                     throw e;",
          "1063:                   }",
          "1064:                 d->decodeRaw();",
          "1065:                 d->decodeMetaData(meta);",
          "1066:                 RawImage r = d->mRaw;",
          "1067:                 if (r->isCFA) {",
          "1069:                   _rawspeed_decoder = static_cast<void*>(d);",
          "1070:                   imgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);",
          "1071:                   S.raw_pitch = r->pitch;",
          "1072:                   fix_after_rawspeed(r->blackLevel);",
          "1073:                 } else if(r->getCpp()==4) {",
          "1074:                   _rawspeed_decoder = static_cast<void*>(d);",
          "1075:                   imgdata.rawdata.color4_image = (ushort(*)[4]) r->getDataUncropped(0,0);",
          "1076:                   S.raw_pitch = r->pitch;",
          "1077:                   C.maximum = r->whitePoint;",
          "1078:                   fix_after_rawspeed(r->blackLevel);",
          "1079:                 } else if(r->getCpp() == 3)",
          "1080:                   {",
          "1081:                     _rawspeed_decoder = static_cast<void*>(d);",
          "1082:                     imgdata.rawdata.color3_image = (ushort(*)[3]) r->getDataUncropped(0,0);",
          "1083:                     S.raw_pitch = r->pitch;",
          "1084:                     C.maximum = r->whitePoint;",
          "1085:                     fix_after_rawspeed(r->blackLevel);",
          "1086:                   }",
          "1087:                 else",
          "1088:                   {",
          "1089:                     delete d;",
          "1090:                   }",
          "1091:                 free(_rawspeed_buffer);",
          "1092:                 imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;",
          "1093:               } catch (...) {",
          "1094:               imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "1097:             ID.input->seek(spos,SEEK_SET);",
          "1098:           }",
          "1099: #endif",
          "1100:         if(!imgdata.rawdata.raw_image && !imgdata.rawdata.color4_image && !imgdata.rawdata.color3_image) // RawSpeed failed!",
          "1101:           {",
          "1103:             if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "1105:                 imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "1106:                 imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1108:             else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1112:                 S.iwidth = S.width;",
          "1113:                 S.iheight= S.height;",
          "1114:                 IO.shrink = 0;",
          "1115:   S.raw_pitch = S.width*8;",
          "1117:                 imgdata.rawdata.raw_alloc = 0;",
          "1118:                 imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
          "1120:             ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "1122:             unsigned m_save = C.maximum;",
          "1123:             if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1124:               C.maximum=65535;",
          "1125:             (this->*load_raw)();",
          "1126:             if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1127:               C.maximum = m_save;",
          "1128:             if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1131:                 imgdata.rawdata.raw_alloc = imgdata.image;",
          "1132:                 imgdata.image = 0;",
          "1134:                 S.raw_width = S.width;",
          "1135:                 S.left_margin = 0;",
          "1136:                 S.raw_height = S.height;",
          "1137:                 S.top_margin = 0;",
          "1141:         if(imgdata.rawdata.raw_image)",
          "1142:           crop_masked_pixels(); // calculate black levels",
          "1145:         if( (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY) && !imgdata.rawdata.color4_image)",
          "1146:             {",
          "1147:                 imgdata.image = 0;",
          "1148:                 imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "1149:             }",
          "1152:         S.iwidth = save_iwidth;",
          "1153:         S.iheight = save_iheight;",
          "1154:         IO.shrink = save_shrink;",
          "1157:         unsigned int i = C.cblack[3];",
          "1158:         unsigned int c;",
          "1159:         for(c=0;c<3;c++)",
          "1160:             if (i > C.cblack[c]) i = C.cblack[c];",
          "1161:         for (c=0;c<4;c++)",
          "1162:             C.cblack[c] -= i;",
          "1163:         C.black += i;",
          "1166:         memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "1167:         memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "1168:         memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "1169:         memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "1171:         SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);",
          "1172:         RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);",
          "1174:         return 0;",
          "1175:     }",
          "1176:     catch ( LibRaw_exceptions err) {",
          "1177:         EXCEPTION_HANDLER(err);",
          "1178:     }",
          "1179:     catch (std::exception ee) {",
          "1180:         EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "1181:     }",
          "1186:     if(imgdata.image)",
          "1187:         {",
          "1188:             free(imgdata.image);",
          "1189:             imgdata.image = 0;",
          "1190:             imgdata.progress_flags",
          "1191:                 = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "1192:                 |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1193:         }",
          "1200:         memmove(&imgdata.color,&imgdata.rawdata.color,sizeof(imgdata.color));",
          "1201:         memmove(&imgdata.sizes,&imgdata.rawdata.sizes,sizeof(imgdata.sizes));",
          "1202:         memmove(&imgdata.idata,&imgdata.rawdata.iparams,sizeof(imgdata.idata));",
          "1203:         memmove(&libraw_internal_data.internal_output_params,&imgdata.rawdata.ioparams,sizeof(libraw_internal_data.internal_output_params));",
          "1205:         if (O.user_flip >= 0)",
          "1206:             S.flip = O.user_flip;",
          "1208:         switch ((S.flip+3600) % 360)",
          "1209:             {",
          "1210:             case 270:  S.flip = 5;  break;",
          "1211:             case 180:  S.flip = 3;  break;",
          "1212:             case  90:  S.flip = 6;  break;",
          "1213:             }",
          "1216:         IO.shrink = P1.filters && (O.half_size ||",
          "1217:                                    ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "1219:         S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "1220:         S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "",
          "[Added Lines]",
          "984:   CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);",
          "985:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "986:   try {",
          "988:     if(!libraw_internal_data.internal_data.input)",
          "989:       return LIBRAW_INPUT_CLOSED;",
          "991:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);",
          "992:     if (O.shot_select >= P1.raw_count)",
          "993:       return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;",
          "995:     if(!load_raw)",
          "996:       return LIBRAW_UNSPECIFIED_ERROR;",
          "998:     if (O.use_camera_matrix && C.cmatrix[0][0] > 0.25)",
          "999:       {",
          "1000:         memcpy (C.rgb_cam, C.cmatrix, sizeof (C.cmatrix));",
          "1001:         IO.raw_color = 0;",
          "1002:       }",
          "1004:     if(imgdata.image)",
          "1005:       {",
          "1006:         free(imgdata.image);",
          "1007:         imgdata.image = 0;",
          "1008:       }",
          "1009:     if(imgdata.rawdata.raw_alloc)",
          "1010:       {",
          "1011:         free(imgdata.rawdata.raw_alloc);",
          "1012:         imgdata.rawdata.raw_alloc = 0;",
          "1013:       }",
          "1014:     if (libraw_internal_data.unpacker_data.meta_length)",
          "1015:       {",
          "1016:         libraw_internal_data.internal_data.meta_data =",
          "1017:           (char *) malloc (libraw_internal_data.unpacker_data.meta_length);",
          "1018:         merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");",
          "1019:       }",
          "1021:     libraw_decoder_info_t decoder_info;",
          "1022:     get_decoder_info(&decoder_info);",
          "1024:     int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;",
          "1026:     int rwidth = S.raw_width, rheight = S.raw_height;",
          "1027:     if( !IO.fuji_width)",
          "1028:       {",
          "1030:         if(rwidth < S.width + S.left_margin)",
          "1031:           rwidth = S.width + S.left_margin;",
          "1032:         if(rheight < S.height + S.top_margin)",
          "1033:           rheight = S.height + S.top_margin;",
          "1034:       }",
          "1035:     S.raw_pitch = S.raw_width*2;",
          "1036:     imgdata.rawdata.raw_image = 0;",
          "1037:     imgdata.rawdata.color4_image = 0;",
          "1038:     imgdata.rawdata.color3_image = 0;",
          "1041:     if(O.use_rawspeed && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "1042:       {",
          "1043:         INT64 spos = ID.input->tell();",
          "1044:         try",
          "1047:             ID.input->seek(0,SEEK_SET);",
          "1048:             INT64 _rawspeed_buffer_sz = ID.input->size()+32;",
          "1049:             void *_rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "1050:             if(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;",
          "1051:             ID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);",
          "1052:             FileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);",
          "1053:             RawParser t(&map);",
          "1054:             RawDecoder *d = 0;",
          "1055:             CameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "1056:             d = t.getDecoder();",
          "1057:             try {",
          "1058:               d->checkSupport(meta);",
          "1060:             catch (const RawDecoderException& e)",
          "1062:                 imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;",
          "1063:                 throw e;",
          "1065:             d->decodeRaw();",
          "1066:             d->decodeMetaData(meta);",
          "1067:             RawImage r = d->mRaw;",
          "1068:             if (r->isCFA) {",
          "1070:               _rawspeed_decoder = static_cast<void*>(d);",
          "1071:               imgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);",
          "1072:               S.raw_pitch = r->pitch;",
          "1073:               fix_after_rawspeed(r->blackLevel);",
          "1074:             } else if(r->getCpp()==4) {",
          "1075:               _rawspeed_decoder = static_cast<void*>(d);",
          "1076:               imgdata.rawdata.color4_image = (ushort(*)[4]) r->getDataUncropped(0,0);",
          "1077:               S.raw_pitch = r->pitch;",
          "1078:               C.maximum = r->whitePoint;",
          "1079:               fix_after_rawspeed(r->blackLevel);",
          "1080:             } else if(r->getCpp() == 3)",
          "1082:                 _rawspeed_decoder = static_cast<void*>(d);",
          "1083:                 imgdata.rawdata.color3_image = (ushort(*)[3]) r->getDataUncropped(0,0);",
          "1084:                 S.raw_pitch = r->pitch;",
          "1085:                 C.maximum = r->whitePoint;",
          "1086:                 fix_after_rawspeed(r->blackLevel);",
          "1088:             else",
          "1090:                 delete d;",
          "1092:             free(_rawspeed_buffer);",
          "1093:             imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;",
          "1094:           } catch (...) {",
          "1095:           imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "1097:         }",
          "1098:         ID.input->seek(spos,SEEK_SET);",
          "1099:       }",
          "1100: #endif",
          "1101:     if(!imgdata.rawdata.raw_image && !imgdata.rawdata.color4_image && !imgdata.rawdata.color3_image) // RawSpeed failed!",
          "1102:       {",
          "1104:         if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "1105:           {",
          "1106:             imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "1107:             imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1108:           }",
          "1109:         else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1110:           {",
          "1113:             S.iwidth = S.width;",
          "1114:             S.iheight= S.height;",
          "1115:             IO.shrink = 0;",
          "1116:             S.raw_pitch = S.width*8;",
          "1118:             imgdata.rawdata.raw_alloc = 0;",
          "1119:             imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
          "1121:         ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "1123:         unsigned m_save = C.maximum;",
          "1124:         if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1125:           C.maximum=65535;",
          "1126:         (this->*load_raw)();",
          "1127:         if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1128:           C.maximum = m_save;",
          "1129:         if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1130:           {",
          "1132:             imgdata.rawdata.raw_alloc = imgdata.image;",
          "1133:             imgdata.image = 0;",
          "1135:             S.raw_width = S.width;",
          "1136:             S.left_margin = 0;",
          "1137:             S.raw_height = S.height;",
          "1138:             S.top_margin = 0;",
          "1139:           }",
          "1140:       }",
          "1142:     if(imgdata.rawdata.raw_image)",
          "1143:       crop_masked_pixels(); // calculate black levels",
          "1146:     if( (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY) && !imgdata.rawdata.color4_image)",
          "1147:       {",
          "1148:         imgdata.image = 0;",
          "1149:         imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "1150:       }",
          "1153:     S.iwidth = save_iwidth;",
          "1154:     S.iheight = save_iheight;",
          "1155:     IO.shrink = save_shrink;",
          "1158:     unsigned int i = C.cblack[3];",
          "1159:     unsigned int c;",
          "1160:     for(c=0;c<3;c++)",
          "1161:       if (i > C.cblack[c]) i = C.cblack[c];",
          "1162:     for (c=0;c<4;c++)",
          "1163:       C.cblack[c] -= i;",
          "1164:     C.black += i;",
          "1167:     memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "1168:     memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "1169:     memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "1170:     memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "1172:     SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);",
          "1173:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);",
          "1175:     return 0;",
          "1176:   }",
          "1177:   catch ( LibRaw_exceptions err) {",
          "1178:     EXCEPTION_HANDLER(err);",
          "1179:   }",
          "1180:   catch (std::exception ee) {",
          "1181:     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "1182:   }",
          "1187:   if(imgdata.image)",
          "1188:     {",
          "1189:       free(imgdata.image);",
          "1190:       imgdata.image = 0;",
          "1191:       imgdata.progress_flags",
          "1192:         = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "1193:         |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1194:     }",
          "1201:   memmove(&imgdata.color,&imgdata.rawdata.color,sizeof(imgdata.color));",
          "1202:   memmove(&imgdata.sizes,&imgdata.rawdata.sizes,sizeof(imgdata.sizes));",
          "1203:   memmove(&imgdata.idata,&imgdata.rawdata.iparams,sizeof(imgdata.idata));",
          "1204:   memmove(&libraw_internal_data.internal_output_params,&imgdata.rawdata.ioparams,sizeof(libraw_internal_data.internal_output_params));",
          "1206:   if (O.user_flip >= 0)",
          "1207:     S.flip = O.user_flip;",
          "1209:   switch ((S.flip+3600) % 360)",
          "1210:     {",
          "1211:     case 270:  S.flip = 5;  break;",
          "1212:     case 180:  S.flip = 3;  break;",
          "1213:     case  90:  S.flip = 6;  break;",
          "1214:     }",
          "1217:   IO.shrink = P1.filters && (O.half_size ||",
          "1218:                              ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "1220:   S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "1221:   S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1229: int LibRaw::raw2image(void)",
          "1230: {",
          "1285:               }",
          "1286:             }",
          "1325:           {",
          "1327:           }",
          "1331:           {",
          "1333:           }",
          "1343: }",
          "1345: void LibRaw::phase_one_allocate_tempbuffer()",
          "",
          "[Removed Lines]",
          "1232:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1234:     try {",
          "1235:         raw2image_start();",
          "1237:         if (is_phaseone_compressed())",
          "1238:           {",
          "1239:      phase_one_allocate_tempbuffer();",
          "1240:      phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1241:            phase_one_correct();",
          "1242:           }",
          "1245:         if(imgdata.image)",
          "1246:             {",
          "1247:                 imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1248:                 memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1249:             }",
          "1250:         else",
          "1251:             imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1253:         merror (imgdata.image, \"raw2image()\");",
          "1255:         libraw_decoder_info_t decoder_info;",
          "1256:         get_decoder_info(&decoder_info);",
          "1259:         if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "1260:             {",
          "1261:               if (IO.fuji_width) {",
          "1262:                 unsigned r,c;",
          "1263:                 int row,col;",
          "1264:                 for (row=0; row < S.raw_height-S.top_margin*2; row++) {",
          "1265:                   for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {",
          "1266:                     if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "1267:                       r = IO.fuji_width - 1 - col + (row >> 1);",
          "1268:                       c = col + ((row+1) >> 1);",
          "1269:                     } else {",
          "1270:                       r = IO.fuji_width - 1 + row - (col >> 1);",
          "1271:                       c = row + ((col+1) >> 1);",
          "1272:                     }",
          "1273:                     if (r < S.height && c < S.width)",
          "1274:                       imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "1275:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1276:                   }",
          "1277:                 }",
          "1278:               }",
          "1279:               else {",
          "1280:                 int row,col;",
          "1281:                 for (row=0; row < S.height; row++)",
          "1282:                   for (col=0; col < S.width; col++)",
          "1283:                     imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "1284:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1287:         else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1288:             {",
          "1289:               if(imgdata.rawdata.color4_image)",
          "1290:                 {",
          "1291:                   if(S.width*8 == S.raw_pitch)",
          "1292:                     memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));",
          "1293:                   else",
          "1294:                     {",
          "1295:                       for(int row = 0; row < S.height; row++)",
          "1296:                         memmove(&imgdata.image[row*S.width],",
          "1297:                                 &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],",
          "1298:                                 S.width*sizeof(*imgdata.image));",
          "1299:                     }",
          "1300:                 }",
          "1301:               else if(imgdata.rawdata.color3_image)",
          "1302:                 {",
          "1303:                   unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;",
          "1304:                   for(int row = 0; row < S.height; row++)",
          "1305:                     {",
          "1306:                       ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];",
          "1307:                       ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];",
          "1308:                       for(int col=0; col < S.width; col++)",
          "1309:                         {",
          "1310:                           for(int c=0; c< 3; c++)",
          "1311:                             dstrow[col][c] = srcrow[S.left_margin+col][c];",
          "1312:                           dstrow[col][3]=0;",
          "1313:                         }",
          "1314:                     }",
          "1315:                 }",
          "1316:               else",
          "1317:                 {",
          "1319:                   throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1320:                 }",
          "1321:             }",
          "1324:         if (is_phaseone_compressed())",
          "1326:      phase_one_free_tempbuffer();",
          "1330:         if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "1332:             canon_600_correct();",
          "1335:         imgdata.progress_flags",
          "1336:             = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE",
          "1337:             |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1338:         return 0;",
          "1339:     }",
          "1340:     catch ( LibRaw_exceptions err) {",
          "1341:         EXCEPTION_HANDLER(err);",
          "1342:     }",
          "",
          "[Added Lines]",
          "1233:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1235:   try {",
          "1236:     raw2image_start();",
          "1238:     if (is_phaseone_compressed())",
          "1239:       {",
          "1240:         phase_one_allocate_tempbuffer();",
          "1241:         phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1242:         phase_one_correct();",
          "1243:       }",
          "1246:     if(imgdata.image)",
          "1247:       {",
          "1248:         imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1249:         memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1250:       }",
          "1251:     else",
          "1252:       imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1254:     merror (imgdata.image, \"raw2image()\");",
          "1256:     libraw_decoder_info_t decoder_info;",
          "1257:     get_decoder_info(&decoder_info);",
          "1260:     if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "1261:       {",
          "1262:         if (IO.fuji_width) {",
          "1263:           unsigned r,c;",
          "1264:           int row,col;",
          "1265:           for (row=0; row < S.raw_height-S.top_margin*2; row++) {",
          "1266:             for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {",
          "1267:               if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "1268:                 r = IO.fuji_width - 1 - col + (row >> 1);",
          "1269:                 c = col + ((row+1) >> 1);",
          "1270:               } else {",
          "1271:                 r = IO.fuji_width - 1 + row - (col >> 1);",
          "1272:                 c = row + ((col+1) >> 1);",
          "1274:               if (r < S.height && c < S.width)",
          "1275:                 imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "1276:                   = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1278:           }",
          "1279:         }",
          "1280:         else {",
          "1281:           int row,col;",
          "1282:           for (row=0; row < S.height; row++)",
          "1283:             for (col=0; col < S.width; col++)",
          "1284:               imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "1285:                 = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1286:         }",
          "1287:       }",
          "1288:     else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1289:       {",
          "1290:         if(imgdata.rawdata.color4_image)",
          "1292:             if(S.width*8 == S.raw_pitch)",
          "1293:               memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));",
          "1294:             else",
          "1295:               {",
          "1296:                 for(int row = 0; row < S.height; row++)",
          "1297:                   memmove(&imgdata.image[row*S.width],",
          "1298:                           &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],",
          "1299:                           S.width*sizeof(*imgdata.image));",
          "1300:               }",
          "1302:         else if(imgdata.rawdata.color3_image)",
          "1304:             unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;",
          "1305:             for(int row = 0; row < S.height; row++)",
          "1306:               {",
          "1307:                 ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];",
          "1308:                 ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];",
          "1309:                 for(int col=0; col < S.width; col++)",
          "1310:                   {",
          "1311:                     for(int c=0; c< 3; c++)",
          "1312:                       dstrow[col][c] = srcrow[S.left_margin+col][c];",
          "1313:                     dstrow[col][3]=0;",
          "1314:                   }",
          "1315:               }",
          "1316:           }",
          "1317:         else",
          "1318:           {",
          "1320:             throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1322:       }",
          "1325:     if (is_phaseone_compressed())",
          "1326:       {",
          "1327:         phase_one_free_tempbuffer();",
          "1328:       }",
          "1331:     if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "1332:       {",
          "1333:         canon_600_correct();",
          "1334:       }",
          "1336:     imgdata.progress_flags",
          "1337:       = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE",
          "1338:       |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1339:     return 0;",
          "1340:   }",
          "1341:   catch ( LibRaw_exceptions err) {",
          "1342:     EXCEPTION_HANDLER(err);",
          "1343:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1488:     if (is_phaseone_compressed())",
          "1489:       {",
          "1493:       }",
          "",
          "[Removed Lines]",
          "1490:     phase_one_allocate_tempbuffer();",
          "1491:     phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1492:           phase_one_correct();",
          "",
          "[Added Lines]",
          "1491:         phase_one_allocate_tempbuffer();",
          "1492:         phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1493:         phase_one_correct();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1713: libraw_processed_image_t * LibRaw::dcraw_make_mem_thumb(int *errcode)",
          "1714: {",
          "1729:         {",
          "1749:         }",
          "1751:         {",
          "1791:         }",
          "1793:         {",
          "1797:         }",
          "1798: }",
          "",
          "[Removed Lines]",
          "1715:     if(!T.thumb)",
          "1716:       {",
          "1717:         if ( !ID.toffset)",
          "1718:           {",
          "1719:             if(errcode) *errcode= LIBRAW_NO_THUMBNAIL;",
          "1720:           }",
          "1721:         else",
          "1722:           {",
          "1723:             if(errcode) *errcode= LIBRAW_OUT_OF_ORDER_CALL;",
          "1724:           }",
          "1725:         return NULL;",
          "1726:       }",
          "1728:     if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "1730:             libraw_processed_image_t * ret =",
          "1731:                 (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+T.tlength);",
          "1733:             if(!ret)",
          "1734:                 {",
          "1735:                     if(errcode) *errcode= ENOMEM;",
          "1736:                     return NULL;",
          "1737:                 }",
          "1739:             memset(ret,0,sizeof(libraw_processed_image_t));",
          "1740:             ret->type   = LIBRAW_IMAGE_BITMAP;",
          "1741:             ret->height = T.theight;",
          "1742:             ret->width  = T.twidth;",
          "1743:             ret->colors = 3;",
          "1744:             ret->bits   = 8;",
          "1745:             ret->data_size = T.tlength;",
          "1746:             memmove(ret->data,T.thumb,T.tlength);",
          "1747:             if(errcode) *errcode= 0;",
          "1748:             return ret;",
          "1750:     else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "1752:             ushort exif[5];",
          "1753:             int mk_exif = 0;",
          "1754:             if(strcmp(T.thumb+6,\"Exif\")) mk_exif = 1;",
          "1756:             int dsize = T.tlength + mk_exif * (sizeof(exif)+sizeof(tiff_hdr));",
          "1758:             libraw_processed_image_t * ret =",
          "1759:                 (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+dsize);",
          "1761:             if(!ret)",
          "1762:                 {",
          "1763:                     if(errcode) *errcode= ENOMEM;",
          "1764:                     return NULL;",
          "1765:                 }",
          "1767:             memset(ret,0,sizeof(libraw_processed_image_t));",
          "1769:             ret->type = LIBRAW_IMAGE_JPEG;",
          "1770:             ret->data_size = dsize;",
          "1772:             ret->data[0] = 0xff;",
          "1773:             ret->data[1] = 0xd8;",
          "1774:             if(mk_exif)",
          "1775:                 {",
          "1776:                     struct tiff_hdr th;",
          "1777:                     memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "1778:                     exif[1] = htons (8 + sizeof th);",
          "1779:                     memmove(ret->data+2,exif,sizeof(exif));",
          "1780:                     tiff_head (&th, 0);",
          "1781:                     memmove(ret->data+(2+sizeof(exif)),&th,sizeof(th));",
          "1782:                     memmove(ret->data+(2+sizeof(exif)+sizeof(th)),T.thumb+2,T.tlength-2);",
          "1783:                 }",
          "1784:             else",
          "1785:                 {",
          "1786:                     memmove(ret->data+2,T.thumb+2,T.tlength-2);",
          "1787:                 }",
          "1788:             if(errcode) *errcode= 0;",
          "1789:             return ret;",
          "1792:     else",
          "1794:             if(errcode) *errcode= LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "1795:             return NULL;",
          "",
          "[Added Lines]",
          "1716:   if(!T.thumb)",
          "1717:     {",
          "1718:       if ( !ID.toffset)",
          "1720:           if(errcode) *errcode= LIBRAW_NO_THUMBNAIL;",
          "1722:       else",
          "1723:         {",
          "1724:           if(errcode) *errcode= LIBRAW_OUT_OF_ORDER_CALL;",
          "1725:         }",
          "1726:       return NULL;",
          "1727:     }",
          "1729:   if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "1730:     {",
          "1731:       libraw_processed_image_t * ret =",
          "1732:         (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+T.tlength);",
          "1734:       if(!ret)",
          "1736:           if(errcode) *errcode= ENOMEM;",
          "1737:           return NULL;",
          "1738:         }",
          "1740:       memset(ret,0,sizeof(libraw_processed_image_t));",
          "1741:       ret->type   = LIBRAW_IMAGE_BITMAP;",
          "1742:       ret->height = T.theight;",
          "1743:       ret->width  = T.twidth;",
          "1744:       ret->colors = 3;",
          "1745:       ret->bits   = 8;",
          "1746:       ret->data_size = T.tlength;",
          "1747:       memmove(ret->data,T.thumb,T.tlength);",
          "1748:       if(errcode) *errcode= 0;",
          "1749:       return ret;",
          "1750:     }",
          "1751:   else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "1752:     {",
          "1753:       ushort exif[5];",
          "1754:       int mk_exif = 0;",
          "1755:       if(strcmp(T.thumb+6,\"Exif\")) mk_exif = 1;",
          "1757:       int dsize = T.tlength + mk_exif * (sizeof(exif)+sizeof(tiff_hdr));",
          "1759:       libraw_processed_image_t * ret =",
          "1760:         (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+dsize);",
          "1762:       if(!ret)",
          "1763:         {",
          "1764:           if(errcode) *errcode= ENOMEM;",
          "1765:           return NULL;",
          "1766:         }",
          "1768:       memset(ret,0,sizeof(libraw_processed_image_t));",
          "1770:       ret->type = LIBRAW_IMAGE_JPEG;",
          "1771:       ret->data_size = dsize;",
          "1773:       ret->data[0] = 0xff;",
          "1774:       ret->data[1] = 0xd8;",
          "1775:       if(mk_exif)",
          "1776:         {",
          "1777:           struct tiff_hdr th;",
          "1778:           memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "1779:           exif[1] = htons (8 + sizeof th);",
          "1780:           memmove(ret->data+2,exif,sizeof(exif));",
          "1781:           tiff_head (&th, 0);",
          "1782:           memmove(ret->data+(2+sizeof(exif)),&th,sizeof(th));",
          "1783:           memmove(ret->data+(2+sizeof(exif)+sizeof(th)),T.thumb+2,T.tlength-2);",
          "1785:       else",
          "1787:           memmove(ret->data+2,T.thumb+2,T.tlength-2);",
          "1789:       if(errcode) *errcode= 0;",
          "1790:       return ret;",
          "1792:     }",
          "1793:   else",
          "1794:     {",
          "1795:       if(errcode) *errcode= LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "1796:       return NULL;",
          "1797:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1807: void LibRaw::get_mem_image_format(int* width, int* height, int* colors, int* bps) const",
          "1809: {",
          "1820: }",
          "1822: int LibRaw::copy_mem_image(void* scan0, int stride, int bgr)",
          "",
          "[Removed Lines]",
          "1810:     if (S.flip & 4) {",
          "1813:     }",
          "1814:     else {",
          "1817:     }",
          "",
          "[Added Lines]",
          "1810:   if (S.flip & 4) {",
          "1813:   }",
          "1814:   else {",
          "1817:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1827:         return LIBRAW_OUT_OF_ORDER_CALL;",
          "1829:     if(libraw_internal_data.output_data.histogram)",
          "1843:     int s_iheight = S.iheight;",
          "1844:     int s_iwidth = S.iwidth;",
          "1845:     int s_width = S.width;",
          "",
          "[Removed Lines]",
          "1830:         {",
          "1831:           int perc, val, total, t_white=0x2000,c;",
          "1833:           if (IO.fuji_width) perc /= 2;",
          "1834:           if (!((O.highlight & ~2) || O.no_auto_bright))",
          "1835:             for (t_white=c=0; c < P1.colors; c++) {",
          "1836:               for (val=0x2000, total=0; --val > 32; )",
          "1837:                 if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "1838:               if (t_white < val) t_white = val;",
          "1839:             }",
          "1840:           gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "1841:         }",
          "",
          "[Added Lines]",
          "1830:       {",
          "1831:         int perc, val, total, t_white=0x2000,c;",
          "1833:         if (IO.fuji_width) perc /= 2;",
          "1834:         if (!((O.highlight & ~2) || O.no_auto_bright))",
          "1835:           for (t_white=c=0; c < P1.colors; c++) {",
          "1836:             for (val=0x2000, total=0; --val > 32; )",
          "1837:               if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "1838:             if (t_white < val) t_white = val;",
          "1839:           }",
          "1840:         gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "1841:       }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1936: int LibRaw::dcraw_ppm_tiff_writer(const char *filename)",
          "1937: {",
          "1968: }",
          "1970: void LibRaw::kodak_thumb_loader()",
          "1971: {",
          "1997: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "1998: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "1999: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "2000: #define CLIP(x) LIM(x,0,65535)",
          "2001: #define SWAP(a,b) { a ^= b; a ^= (b ^= a); }",
          "2131: }",
          "2132: #undef MIN",
          "2133: #undef MAX",
          "",
          "[Removed Lines]",
          "1938:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1940:     if(!imgdata.image)",
          "1941:         return LIBRAW_OUT_OF_ORDER_CALL;",
          "1943:     if(!filename)",
          "1944:         return ENOENT;",
          "1945:     FILE *f = fopen(filename,\"wb\");",
          "1947:     if(!f)",
          "1948:         return errno;",
          "1950:     try {",
          "1951:         if(!libraw_internal_data.output_data.histogram)",
          "1952:             {",
          "1953:                 libraw_internal_data.output_data.histogram =",
          "1954:                     (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "1955:                 merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_ppm_tiff_writer()\");",
          "1956:             }",
          "1957:         libraw_internal_data.internal_data.output = f;",
          "1958:         write_ppm_tiff();",
          "1959:         SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "1960:         libraw_internal_data.internal_data.output = NULL;",
          "1961:         fclose(f);",
          "1962:         return 0;",
          "1963:     }",
          "1964:     catch ( LibRaw_exceptions err) {",
          "1965:         fclose(f);",
          "1966:         EXCEPTION_HANDLER(err);",
          "1967:     }",
          "1973:     ushort s_height = S.height, s_width = S.width,s_iwidth = S.iwidth,s_iheight=S.iheight;",
          "1974:     int s_colors = P1.colors;",
          "1975:     unsigned s_filters = P1.filters;",
          "1976:     ushort (*s_image)[4] = imgdata.image;",
          "1979:     S.height = T.theight;",
          "1980:     S.width  = T.twidth;",
          "1981:     P1.filters = 0;",
          "1983:     if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)",
          "1984:         {",
          "1985:             S.height += S.height & 1;",
          "1986:             S.width  += S.width  & 1;",
          "1987:         }",
          "1989:     imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1990:     merror (imgdata.image, \"LibRaw::kodak_thumb_loader()\");",
          "1992:     ID.input->seek(ID.toffset, SEEK_SET);",
          "1994:     (this->*thumb_load_raw)();",
          "2004:     {",
          "2005:         double   dmax;",
          "2006:         float scale_mul[4];",
          "2007:         int c,val;",
          "2008:         for (dmax=DBL_MAX, c=0; c < 3; c++)",
          "2009:                 if (dmax > C.pre_mul[c])",
          "2010:                     dmax = C.pre_mul[c];",
          "2012:         for( c=0; c< 3; c++)",
          "2013:                 scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;",
          "2014:         scale_mul[3] = scale_mul[1];",
          "2016:         size_t size = S.height * S.width;",
          "2017:         for (unsigned i=0; i < size*4 ; i++)",
          "2018:             {",
          "2019:                 val = imgdata.image[0][i];",
          "2020:                 if(!val) continue;",
          "2021:                 val *= scale_mul[i & 3];",
          "2022:                 imgdata.image[0][i] = CLIP(val);",
          "2023:             }",
          "2024:     }",
          "2027:     ushort *img;",
          "2028:     int row,col;",
          "2030:     int  (*t_hist)[LIBRAW_HISTOGRAM_SIZE] =  (int (*)[LIBRAW_HISTOGRAM_SIZE]) calloc(sizeof(*t_hist),4);",
          "2031:     merror (t_hist, \"LibRaw::kodak_thumb_loader()\");",
          "2033:     float out[3],",
          "2034:         out_cam[3][4] =",
          "2035:         {",
          "2036:             {2.81761312, -1.98369181, 0.166078627, 0},",
          "2037:             {-0.111855984, 1.73688626, -0.625030339, 0},",
          "2038:             {-0.0379119813, -0.891268849, 1.92918086, 0}",
          "2039:         };",
          "2041:     for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2042:         for (col=0; col < S.width; col++, img+=4)",
          "2043:             {",
          "2044:                 out[0] = out[1] = out[2] = 0;",
          "2045:                 int c;",
          "2046:                 for(c=0;c<3;c++)",
          "2047:                     {",
          "2048:                         out[0] += out_cam[0][c] * img[c];",
          "2049:                         out[1] += out_cam[1][c] * img[c];",
          "2050:                         out[2] += out_cam[2][c] * img[c];",
          "2051:                     }",
          "2052:                 for(c=0; c<3; c++)",
          "2053:                     img[c] = CLIP((int) out[c]);",
          "2054:                 for(c=0; c<P1.colors;c++)",
          "2055:                     t_hist[c][img[c] >> 3]++;",
          "2057:             }",
          "2060:     int  (*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;",
          "2061:     libraw_internal_data.output_data.histogram = t_hist;",
          "2064:     ushort (*t_curve) = (ushort*) calloc(sizeof(C.curve),1);",
          "2065:     merror (t_curve, \"LibRaw::kodak_thumb_loader()\");",
          "2066:     memmove(t_curve,C.curve,sizeof(C.curve));",
          "2067:     memset(C.curve,0,sizeof(C.curve));",
          "2068:         {",
          "2069:             int perc, val, total, t_white=0x2000,c;",
          "2072:             if (IO.fuji_width) perc /= 2;",
          "2073:             if (!((O.highlight & ~2) || O.no_auto_bright))",
          "2074:                 for (t_white=c=0; c < P1.colors; c++) {",
          "2075:                     for (val=0x2000, total=0; --val > 32; )",
          "2076:                         if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "2077:                     if (t_white < val) t_white = val;",
          "2078:                 }",
          "2079:             gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "2080:         }",
          "2082:     libraw_internal_data.output_data.histogram = save_hist;",
          "2083:     free(t_hist);",
          "2087:     S.iheight = S.height;",
          "2088:     S.iwidth  = S.width;",
          "2089:     if (S.flip & 4) SWAP(S.height,S.width);",
          "2091:     if(T.thumb) free(T.thumb);",
          "2092:     T.thumb = (char*) calloc (S.width * S.height, P1.colors);",
          "2093:     merror (T.thumb, \"LibRaw::kodak_thumb_loader()\");",
          "2094:     T.tlength = S.width * S.height * P1.colors;",
          "2097:     {",
          "2098:         int soff  = flip_index (0, 0);",
          "2099:         int cstep = flip_index (0, 1) - soff;",
          "2100:         int rstep = flip_index (1, 0) - flip_index (0, S.width);",
          "2102:         for (int row=0; row < S.height; row++, soff += rstep)",
          "2103:             {",
          "2104:                 char *ppm = T.thumb + row*S.width*P1.colors;",
          "2105:                 for (int col=0; col < S.width; col++, soff += cstep)",
          "2106:                     for(int c = 0; c < P1.colors; c++)",
          "2107:                         ppm [col*P1.colors+c] = imgdata.color.curve[imgdata.image[soff][c]]>>8;",
          "2108:             }",
          "2109:     }",
          "2111:     memmove(C.curve,t_curve,sizeof(C.curve));",
          "2112:     free(t_curve);",
          "2115:     free(imgdata.image);",
          "2116:     imgdata.image  = s_image;",
          "2118:     T.twidth = S.width;",
          "2119:     S.width = s_width;",
          "2121:     S.iwidth = s_iwidth;",
          "2122:     S.iheight = s_iheight;",
          "2124:     T.theight = S.height;",
          "2125:     S.height = s_height;",
          "2127:     T.tcolors = P1.colors;",
          "2128:     P1.colors = s_colors;",
          "2130:     P1.filters = s_filters;",
          "",
          "[Added Lines]",
          "1938:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1940:   if(!imgdata.image)",
          "1941:     return LIBRAW_OUT_OF_ORDER_CALL;",
          "1943:   if(!filename)",
          "1944:     return ENOENT;",
          "1945:   FILE *f = fopen(filename,\"wb\");",
          "1947:   if(!f)",
          "1948:     return errno;",
          "1950:   try {",
          "1951:     if(!libraw_internal_data.output_data.histogram)",
          "1952:       {",
          "1953:         libraw_internal_data.output_data.histogram =",
          "1954:           (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "1955:         merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_ppm_tiff_writer()\");",
          "1956:       }",
          "1957:     libraw_internal_data.internal_data.output = f;",
          "1958:     write_ppm_tiff();",
          "1959:     SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "1960:     libraw_internal_data.internal_data.output = NULL;",
          "1961:     fclose(f);",
          "1962:     return 0;",
          "1963:   }",
          "1964:   catch ( LibRaw_exceptions err) {",
          "1965:     fclose(f);",
          "1966:     EXCEPTION_HANDLER(err);",
          "1967:   }",
          "1973:   ushort s_height = S.height, s_width = S.width,s_iwidth = S.iwidth,s_iheight=S.iheight;",
          "1974:   int s_colors = P1.colors;",
          "1975:   unsigned s_filters = P1.filters;",
          "1976:   ushort (*s_image)[4] = imgdata.image;",
          "1979:   S.height = T.theight;",
          "1980:   S.width  = T.twidth;",
          "1981:   P1.filters = 0;",
          "1983:   if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)",
          "1984:     {",
          "1985:       S.height += S.height & 1;",
          "1986:       S.width  += S.width  & 1;",
          "1987:     }",
          "1989:   imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1990:   merror (imgdata.image, \"LibRaw::kodak_thumb_loader()\");",
          "1992:   ID.input->seek(ID.toffset, SEEK_SET);",
          "1994:   (this->*thumb_load_raw)();",
          "2004:   {",
          "2005:     double   dmax;",
          "2006:     float scale_mul[4];",
          "2007:     int c,val;",
          "2008:     for (dmax=DBL_MAX, c=0; c < 3; c++)",
          "2009:       if (dmax > C.pre_mul[c])",
          "2010:         dmax = C.pre_mul[c];",
          "2012:     for( c=0; c< 3; c++)",
          "2013:       scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;",
          "2014:     scale_mul[3] = scale_mul[1];",
          "2016:     size_t size = S.height * S.width;",
          "2017:     for (unsigned i=0; i < size*4 ; i++)",
          "2018:       {",
          "2019:         val = imgdata.image[0][i];",
          "2020:         if(!val) continue;",
          "2021:         val *= scale_mul[i & 3];",
          "2022:         imgdata.image[0][i] = CLIP(val);",
          "2023:       }",
          "2024:   }",
          "2027:   ushort *img;",
          "2028:   int row,col;",
          "2030:   int  (*t_hist)[LIBRAW_HISTOGRAM_SIZE] =  (int (*)[LIBRAW_HISTOGRAM_SIZE]) calloc(sizeof(*t_hist),4);",
          "2031:   merror (t_hist, \"LibRaw::kodak_thumb_loader()\");",
          "2033:   float out[3],",
          "2034:     out_cam[3][4] =",
          "2035:     {",
          "2036:       {2.81761312, -1.98369181, 0.166078627, 0},",
          "2037:       {-0.111855984, 1.73688626, -0.625030339, 0},",
          "2038:       {-0.0379119813, -0.891268849, 1.92918086, 0}",
          "2039:     };",
          "2041:   for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2042:     for (col=0; col < S.width; col++, img+=4)",
          "2043:       {",
          "2044:         out[0] = out[1] = out[2] = 0;",
          "2045:         int c;",
          "2046:         for(c=0;c<3;c++)",
          "2047:           {",
          "2048:             out[0] += out_cam[0][c] * img[c];",
          "2049:             out[1] += out_cam[1][c] * img[c];",
          "2050:             out[2] += out_cam[2][c] * img[c];",
          "2051:           }",
          "2052:         for(c=0; c<3; c++)",
          "2053:           img[c] = CLIP((int) out[c]);",
          "2054:         for(c=0; c<P1.colors;c++)",
          "2055:           t_hist[c][img[c] >> 3]++;",
          "2057:       }",
          "2060:   int  (*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;",
          "2061:   libraw_internal_data.output_data.histogram = t_hist;",
          "2064:   ushort (*t_curve) = (ushort*) calloc(sizeof(C.curve),1);",
          "2065:   merror (t_curve, \"LibRaw::kodak_thumb_loader()\");",
          "2066:   memmove(t_curve,C.curve,sizeof(C.curve));",
          "2067:   memset(C.curve,0,sizeof(C.curve));",
          "2068:   {",
          "2069:     int perc, val, total, t_white=0x2000,c;",
          "2072:     if (IO.fuji_width) perc /= 2;",
          "2073:     if (!((O.highlight & ~2) || O.no_auto_bright))",
          "2074:       for (t_white=c=0; c < P1.colors; c++) {",
          "2075:         for (val=0x2000, total=0; --val > 32; )",
          "2076:           if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "2077:         if (t_white < val) t_white = val;",
          "2078:       }",
          "2079:     gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "2080:   }",
          "2082:   libraw_internal_data.output_data.histogram = save_hist;",
          "2083:   free(t_hist);",
          "2087:   S.iheight = S.height;",
          "2088:   S.iwidth  = S.width;",
          "2089:   if (S.flip & 4) SWAP(S.height,S.width);",
          "2091:   if(T.thumb) free(T.thumb);",
          "2092:   T.thumb = (char*) calloc (S.width * S.height, P1.colors);",
          "2093:   merror (T.thumb, \"LibRaw::kodak_thumb_loader()\");",
          "2094:   T.tlength = S.width * S.height * P1.colors;",
          "2097:   {",
          "2098:     int soff  = flip_index (0, 0);",
          "2099:     int cstep = flip_index (0, 1) - soff;",
          "2100:     int rstep = flip_index (1, 0) - flip_index (0, S.width);",
          "2102:     for (int row=0; row < S.height; row++, soff += rstep)",
          "2103:       {",
          "2104:         char *ppm = T.thumb + row*S.width*P1.colors;",
          "2105:         for (int col=0; col < S.width; col++, soff += cstep)",
          "2106:           for(int c = 0; c < P1.colors; c++)",
          "2107:             ppm [col*P1.colors+c] = imgdata.color.curve[imgdata.image[soff][c]]>>8;",
          "2108:       }",
          "2109:   }",
          "2111:   memmove(C.curve,t_curve,sizeof(C.curve));",
          "2112:   free(t_curve);",
          "2115:   free(imgdata.image);",
          "2116:   imgdata.image  = s_image;",
          "2118:   T.twidth = S.width;",
          "2119:   S.width = s_width;",
          "2121:   S.iwidth = s_iwidth;",
          "2122:   S.iheight = s_iheight;",
          "2124:   T.theight = S.height;",
          "2125:   S.height = s_height;",
          "2127:   T.tcolors = P1.colors;",
          "2128:   P1.colors = s_colors;",
          "2130:   P1.filters = s_filters;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2140: int LibRaw::unpack_thumb(void)",
          "2141: {",
          "2229: }",
          "",
          "[Removed Lines]",
          "2142:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2143:     CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2145:     try {",
          "2146:   if(!libraw_internal_data.internal_data.input)",
          "2147:    return LIBRAW_INPUT_CLOSED;",
          "2149:         if ( !ID.toffset)",
          "2150:             {",
          "2151:                 return LIBRAW_NO_THUMBNAIL;",
          "2152:             }",
          "2153:         else if (thumb_load_raw)",
          "2154:             {",
          "2155:                 kodak_thumb_loader();",
          "2156:                 T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2157:                 SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2158:                 return 0;",
          "2159:             }",
          "2160:         else",
          "2161:             {",
          "2162:                 ID.input->seek(ID.toffset, SEEK_SET);",
          "2163:                 if ( write_thumb == &LibRaw::jpeg_thumb)",
          "2164:                     {",
          "2165:                         if(T.thumb) free(T.thumb);",
          "2166:                         T.thumb = (char *) malloc (T.tlength);",
          "2167:                         merror (T.thumb, \"jpeg_thumb()\");",
          "2168:                         ID.input->read (T.thumb, 1, T.tlength);",
          "2169:                         T.tcolors = 3;",
          "2170:                         T.tformat = LIBRAW_THUMBNAIL_JPEG;",
          "2171:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2172:                         return 0;",
          "2173:                     }",
          "2174:                 else if (write_thumb == &LibRaw::ppm_thumb)",
          "2175:                     {",
          "2176:                         T.tlength = T.twidth * T.theight*3;",
          "2177:                         if(T.thumb) free(T.thumb);",
          "2179:                         T.thumb = (char *) malloc (T.tlength);",
          "2180:                         merror (T.thumb, \"ppm_thumb()\");",
          "2182:                         ID.input->read(T.thumb, 1, T.tlength);",
          "2184:                         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2185:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2186:                         return 0;",
          "2188:                     }",
          "2189:                 else if (write_thumb == &LibRaw::ppm16_thumb)",
          "2190:                     {",
          "2191:                         T.tlength = T.twidth * T.theight*3;",
          "2192:                         ushort *t_thumb = (ushort*)calloc(T.tlength,2);",
          "2193:                         ID.input->read(t_thumb,2,T.tlength);",
          "2194:                         if ((libraw_internal_data.unpacker_data.order= 0x4949) == (ntohs(0x1234) == 0x1234))",
          "2195:                           swab ((char*)t_thumb, (char*)t_thumb, T.tlength*2);",
          "2197:                         if(T.thumb) free(T.thumb);",
          "2198:                         T.thumb = (char *) malloc (T.tlength);",
          "2199:                         merror (T.thumb, \"ppm_thumb()\");",
          "2200:                         for (int i=0; i < T.tlength; i++)",
          "2201:                           T.thumb[i] = t_thumb[i] >> 8;",
          "2202:                         free(t_thumb);",
          "2203:                         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2204:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2205:                         return 0;",
          "2207:                     }",
          "2208:                 else if (write_thumb == &LibRaw::foveon_thumb)",
          "2209:                     {",
          "2210:                         foveon_thumb_loader();",
          "2213:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2214:                         return 0;",
          "2215:                     }",
          "2217:                 else",
          "2218:                     {",
          "2219:                         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2220:                     }",
          "2221:             }",
          "2223:         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2224:     }",
          "2225:     catch ( LibRaw_exceptions err) {",
          "2226:         EXCEPTION_HANDLER(err);",
          "2227:     }",
          "",
          "[Added Lines]",
          "2142:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2143:   CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2145:   try {",
          "2146:     if(!libraw_internal_data.internal_data.input)",
          "2147:       return LIBRAW_INPUT_CLOSED;",
          "2149:     if ( !ID.toffset)",
          "2150:       {",
          "2151:         return LIBRAW_NO_THUMBNAIL;",
          "2152:       }",
          "2153:     else if (thumb_load_raw)",
          "2154:       {",
          "2155:         kodak_thumb_loader();",
          "2156:         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2157:         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2158:         return 0;",
          "2159:       }",
          "2160:     else",
          "2161:       {",
          "2162:         ID.input->seek(ID.toffset, SEEK_SET);",
          "2163:         if ( write_thumb == &LibRaw::jpeg_thumb)",
          "2164:           {",
          "2165:             if(T.thumb) free(T.thumb);",
          "2166:             T.thumb = (char *) malloc (T.tlength);",
          "2167:             merror (T.thumb, \"jpeg_thumb()\");",
          "2168:             ID.input->read (T.thumb, 1, T.tlength);",
          "2169:             T.tcolors = 3;",
          "2170:             T.tformat = LIBRAW_THUMBNAIL_JPEG;",
          "2171:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2172:             return 0;",
          "2173:           }",
          "2174:         else if (write_thumb == &LibRaw::ppm_thumb)",
          "2175:           {",
          "2176:             T.tlength = T.twidth * T.theight*3;",
          "2177:             if(T.thumb) free(T.thumb);",
          "2179:             T.thumb = (char *) malloc (T.tlength);",
          "2180:             merror (T.thumb, \"ppm_thumb()\");",
          "2182:             ID.input->read(T.thumb, 1, T.tlength);",
          "2184:             T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2185:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2186:             return 0;",
          "2188:           }",
          "2189:         else if (write_thumb == &LibRaw::ppm16_thumb)",
          "2190:           {",
          "2191:             T.tlength = T.twidth * T.theight*3;",
          "2192:             ushort *t_thumb = (ushort*)calloc(T.tlength,2);",
          "2193:             ID.input->read(t_thumb,2,T.tlength);",
          "2194:             if ((libraw_internal_data.unpacker_data.order= 0x4949) == (ntohs(0x1234) == 0x1234))",
          "2195:               swab ((char*)t_thumb, (char*)t_thumb, T.tlength*2);",
          "2197:             if(T.thumb) free(T.thumb);",
          "2198:             T.thumb = (char *) malloc (T.tlength);",
          "2199:             merror (T.thumb, \"ppm_thumb()\");",
          "2200:             for (int i=0; i < T.tlength; i++)",
          "2201:               T.thumb[i] = t_thumb[i] >> 8;",
          "2202:             free(t_thumb);",
          "2203:             T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2204:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2205:             return 0;",
          "2207:           }",
          "2208:         else if (write_thumb == &LibRaw::foveon_thumb)",
          "2209:           {",
          "2210:             foveon_thumb_loader();",
          "2213:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2214:             return 0;",
          "2215:           }",
          "2217:         else",
          "2218:           {",
          "2219:             return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2220:           }",
          "2221:       }",
          "2223:     return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2224:   }",
          "2225:   catch ( LibRaw_exceptions err) {",
          "2226:     EXCEPTION_HANDLER(err);",
          "2227:   }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2232: {",
          "2265:     }",
          "2267:         fclose(tfp);",
          "2270: }",
          "2272: int LibRaw::adjust_sizes_info_only(void)",
          "2273: {",
          "2278:         {",
          "2293:         {",
          "2298:         }",
          "2300: }",
          "2303: int LibRaw::subtract_black()",
          "2304: {",
          "2308:     if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "2310: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "2316: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "2317: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "2318: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "2319: #define CLIP(x) LIM(x,0,65535)",
          "2329: #undef MIN",
          "2330: #undef MAX",
          "2331: #undef LIM",
          "2332: #undef CLIP",
          "2336: #undef BAYERC",
          "2338:     else",
          "2355: }",
          "",
          "[Removed Lines]",
          "2235:     if(!fname)",
          "2236:         return ENOENT;",
          "2238:     FILE *tfp = fopen(fname,\"wb\");",
          "2240:     if(!tfp)",
          "2241:         return errno;",
          "2243:     if(!T.thumb)",
          "2244:  {",
          "2245:   fclose(tfp);",
          "2246:          return LIBRAW_OUT_OF_ORDER_CALL;",
          "2247:  }",
          "2249:     try {",
          "2250:         switch (T.tformat)",
          "2251:             {",
          "2252:             case LIBRAW_THUMBNAIL_JPEG:",
          "2253:                 jpeg_thumb_writer (tfp,T.thumb,T.tlength);",
          "2254:                 break;",
          "2255:             case LIBRAW_THUMBNAIL_BITMAP:",
          "2256:                 fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);",
          "2257:                 fwrite (T.thumb, 1, T.tlength, tfp);",
          "2258:                 break;",
          "2259:             default:",
          "2260:                 fclose(tfp);",
          "2261:                 return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2262:            }",
          "2263:         fclose(tfp);",
          "2264:         return 0;",
          "2266:     catch ( LibRaw_exceptions err) {",
          "2268:         EXCEPTION_HANDLER(err);",
          "2269:     }",
          "2274:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2276:     raw2image_start();",
          "2277:     if (O.use_fuji_rotate)",
          "2279:             if (IO.fuji_width)",
          "2280:                 {",
          "2281:                     IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;",
          "2282:                     S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));",
          "2283:                     S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));",
          "2284:                 }",
          "2285:             else",
          "2286:                 {",
          "2287:                     if (S.pixel_aspect < 1) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);",
          "2288:                     if (S.pixel_aspect > 1) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);",
          "2289:                 }",
          "2290:         }",
          "2291:     SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2292:     if ( S.flip & 4)",
          "2294:             unsigned short t = S.iheight;",
          "2295:             S.iheight=S.iwidth;",
          "2296:             S.iwidth = t;",
          "2297:             SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "2299:     return 0;",
          "2305:  CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);",
          "2307:  try {",
          "2309:         {",
          "2311:             int cblk[4],i;",
          "2312:             for(i=0;i<4;i++)",
          "2313:                 cblk[i] = C.cblack[i];",
          "2315:             int size = S.iheight * S.iwidth;",
          "2320:    int dmax = 0;",
          "2321:    for(i=0; i< size*4; i++)",
          "2322:               {",
          "2323:                 int val = imgdata.image[0][i];",
          "2324:                 val -= cblk[i & 3];",
          "2325:                 imgdata.image[0][i] = CLIP(val);",
          "2326:                 if(dmax < val) dmax = val;",
          "2327:               }",
          "2328:    C.data_maximum = dmax & 0xffff;",
          "2333:             C.maximum -= C.black;",
          "2334:             ZERO(C.cblack);",
          "2335:             C.black = 0;",
          "2337:         }",
          "2339:         {",
          "2342:           int idx;",
          "2343:           ushort *p = (ushort*)imgdata.image;",
          "2344:     int dmax = 0;",
          "2345:           for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
          "2346:             if(dmax < p[idx]) dmax = p[idx];",
          "2347:     C.data_maximum = dmax;",
          "2348:         }",
          "2349:   return 0;",
          "2350:  }",
          "2351:  catch ( LibRaw_exceptions err) {",
          "2352:   EXCEPTION_HANDLER(err);",
          "2353:  }",
          "",
          "[Added Lines]",
          "2235:   if(!fname)",
          "2236:     return ENOENT;",
          "2238:   FILE *tfp = fopen(fname,\"wb\");",
          "2240:   if(!tfp)",
          "2241:     return errno;",
          "2243:   if(!T.thumb)",
          "2244:     {",
          "2245:       fclose(tfp);",
          "2246:       return LIBRAW_OUT_OF_ORDER_CALL;",
          "2249:   try {",
          "2250:     switch (T.tformat)",
          "2251:       {",
          "2252:       case LIBRAW_THUMBNAIL_JPEG:",
          "2253:         jpeg_thumb_writer (tfp,T.thumb,T.tlength);",
          "2254:         break;",
          "2255:       case LIBRAW_THUMBNAIL_BITMAP:",
          "2256:         fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);",
          "2257:         fwrite (T.thumb, 1, T.tlength, tfp);",
          "2258:         break;",
          "2259:       default:",
          "2261:         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2262:       }",
          "2263:     fclose(tfp);",
          "2264:     return 0;",
          "2265:   }",
          "2266:   catch ( LibRaw_exceptions err) {",
          "2267:     fclose(tfp);",
          "2268:     EXCEPTION_HANDLER(err);",
          "2269:   }",
          "2274:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2276:   raw2image_start();",
          "2277:   if (O.use_fuji_rotate)",
          "2278:     {",
          "2279:       if (IO.fuji_width)",
          "2281:           IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;",
          "2282:           S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));",
          "2283:           S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));",
          "2284:         }",
          "2285:       else",
          "2287:           if (S.pixel_aspect < 1) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);",
          "2288:           if (S.pixel_aspect > 1) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);",
          "2290:     }",
          "2291:   SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2292:   if ( S.flip & 4)",
          "2293:     {",
          "2294:       unsigned short t = S.iheight;",
          "2295:       S.iheight=S.iwidth;",
          "2296:       S.iwidth = t;",
          "2297:       SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "2298:     }",
          "2299:   return 0;",
          "2305:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);",
          "2307:   try {",
          "2309:       {",
          "2311:         int cblk[4],i;",
          "2312:         for(i=0;i<4;i++)",
          "2313:           cblk[i] = C.cblack[i];",
          "2315:         int size = S.iheight * S.iwidth;",
          "2320:         int dmax = 0;",
          "2321:         for(i=0; i< size*4; i++)",
          "2322:           {",
          "2323:             int val = imgdata.image[0][i];",
          "2324:             val -= cblk[i & 3];",
          "2325:             imgdata.image[0][i] = CLIP(val);",
          "2326:             if(dmax < val) dmax = val;",
          "2327:           }",
          "2328:         C.data_maximum = dmax & 0xffff;",
          "2333:         C.maximum -= C.black;",
          "2334:         ZERO(C.cblack);",
          "2335:         C.black = 0;",
          "2337:       }",
          "2339:       {",
          "2342:         int idx;",
          "2343:         ushort *p = (ushort*)imgdata.image;",
          "2344:         int dmax = 0;",
          "2345:         for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
          "2346:           if(dmax < p[idx]) dmax = p[idx];",
          "2347:         C.data_maximum = dmax;",
          "2348:       }",
          "2349:     return 0;",
          "2350:   }",
          "2351:   catch ( LibRaw_exceptions err) {",
          "2352:     EXCEPTION_HANDLER(err);",
          "2353:   }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2359: void LibRaw::exp_bef(float shift, float smooth)",
          "2360: {",
          "2400:         {",
          "2405:         }",
          "2413: }",
          "2415: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "",
          "[Removed Lines]",
          "2362:     if(shift>8) shift = 8;",
          "2363:     if(shift<0.25) shift = 0.25;",
          "2364:     if(smooth < 0.0) smooth = 0.0;",
          "2365:     if(smooth > 1.0) smooth = 1.0;",
          "2367:     unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));",
          "2369:     if(shift <=1.0)",
          "2370:         {",
          "2371:             for(int i=0;i<=TBLN;i++)",
          "2372:                 lut[i] = (unsigned short)((float)i*shift);",
          "2373:         }",
          "2374:     else",
          "2375:         {",
          "2376:             float x1,x2,y1,y2;",
          "2378:             float cstops = log(shift)/log(2.0f);",
          "2379:             float room = cstops*2;",
          "2380:             float roomlin = powf(2.0f,room);",
          "2381:             x2 = (float)TBLN;",
          "2382:             x1 = (x2+1)/roomlin-1;",
          "2383:             y1 = x1*shift;",
          "2384:             y2 = x2*(1+(1-smooth)*(shift-1));",
          "2385:             float sq3x=powf(x1*x1*x2,1.0f/3.0f);",
          "2386:             float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);",
          "2387:             float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);",
          "2388:             float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;",
          "2389:             for(int i=0;i<=TBLN;i++)",
          "2390:                 {",
          "2391:                     float X = (float)i;",
          "2392:                     float Y = A*powf(X,1.0f/3.0f)+B*X+CC;",
          "2393:                     if(i<x1)",
          "2394:                         lut[i] = (unsigned short)((float)i*shift);",
          "2395:                     else",
          "2396:                         lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));",
          "2397:                 }",
          "2398:         }",
          "2399:     for(int i=0; i< S.height*S.width; i++)",
          "2401:             imgdata.image[i][0] = lut[imgdata.image[i][0]];",
          "2402:             imgdata.image[i][1] = lut[imgdata.image[i][1]];",
          "2403:             imgdata.image[i][2] = lut[imgdata.image[i][2]];",
          "2404:             imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "2407:  if(C.data_maximum <=TBLN)",
          "2408:   C.data_maximum = lut[C.data_maximum];",
          "2409:  if(C.maximum <= TBLN)",
          "2410:   C.maximum = lut[C.maximum];",
          "2412:     free(lut);",
          "",
          "[Added Lines]",
          "2362:   if(shift>8) shift = 8;",
          "2363:   if(shift<0.25) shift = 0.25;",
          "2364:   if(smooth < 0.0) smooth = 0.0;",
          "2365:   if(smooth > 1.0) smooth = 1.0;",
          "2367:   unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));",
          "2369:   if(shift <=1.0)",
          "2370:     {",
          "2371:       for(int i=0;i<=TBLN;i++)",
          "2372:         lut[i] = (unsigned short)((float)i*shift);",
          "2373:     }",
          "2374:   else",
          "2375:     {",
          "2376:       float x1,x2,y1,y2;",
          "2378:       float cstops = log(shift)/log(2.0f);",
          "2379:       float room = cstops*2;",
          "2380:       float roomlin = powf(2.0f,room);",
          "2381:       x2 = (float)TBLN;",
          "2382:       x1 = (x2+1)/roomlin-1;",
          "2383:       y1 = x1*shift;",
          "2384:       y2 = x2*(1+(1-smooth)*(shift-1));",
          "2385:       float sq3x=powf(x1*x1*x2,1.0f/3.0f);",
          "2386:       float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);",
          "2387:       float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);",
          "2388:       float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;",
          "2389:       for(int i=0;i<=TBLN;i++)",
          "2391:           float X = (float)i;",
          "2392:           float Y = A*powf(X,1.0f/3.0f)+B*X+CC;",
          "2393:           if(i<x1)",
          "2394:             lut[i] = (unsigned short)((float)i*shift);",
          "2395:           else",
          "2396:             lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));",
          "2398:     }",
          "2399:   for(int i=0; i< S.height*S.width; i++)",
          "2400:     {",
          "2401:       imgdata.image[i][0] = lut[imgdata.image[i][0]];",
          "2402:       imgdata.image[i][1] = lut[imgdata.image[i][1]];",
          "2403:       imgdata.image[i][2] = lut[imgdata.image[i][2]];",
          "2404:       imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "2405:     }",
          "2407:   if(C.data_maximum <=TBLN)",
          "2408:     C.data_maximum = lut[C.data_maximum];",
          "2409:   if(C.maximum <= TBLN)",
          "2410:     C.maximum = lut[C.maximum];",
          "2412:   free(lut);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2421: void LibRaw::convert_to_rgb_loop(float out_cam[3][4])",
          "2422: {",
          "2441: }",
          "",
          "[Removed Lines]",
          "2423:  int row,col,c;",
          "2424:  float out[3];",
          "2425:  ushort *img;",
          "2426:  memset(libraw_internal_data.output_data.histogram,0,sizeof(int)*LIBRAW_HISTOGRAM_SIZE*4);",
          "2427:  for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2428:   for (col=0; col < S.width; col++, img+=4) {",
          "2429:    if (!libraw_internal_data.internal_output_params.raw_color) {",
          "2430:     out[0] = out[1] = out[2] = 0;",
          "2431:     for(c=0; c< imgdata.idata.colors; c++) {",
          "2432:      out[0] += out_cam[0][c] * img[c];",
          "2433:      out[1] += out_cam[1][c] * img[c];",
          "2434:      out[2] += out_cam[2][c] * img[c];",
          "2435:     }",
          "2436:     for(c=0;c<3;c++) img[c] = CLIP((int) out[c]);",
          "2437:    }",
          "2438:    for(c=0; c< imgdata.idata.colors; c++) libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;",
          "2439:   }",
          "",
          "[Added Lines]",
          "2423:   int row,col,c;",
          "2424:   float out[3];",
          "2425:   ushort *img;",
          "2426:   memset(libraw_internal_data.output_data.histogram,0,sizeof(int)*LIBRAW_HISTOGRAM_SIZE*4);",
          "2427:   for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2428:     for (col=0; col < S.width; col++, img+=4) {",
          "2429:       if (!libraw_internal_data.internal_output_params.raw_color) {",
          "2430:         out[0] = out[1] = out[2] = 0;",
          "2431:         for(c=0; c< imgdata.idata.colors; c++) {",
          "2432:           out[0] += out_cam[0][c] * img[c];",
          "2433:           out[1] += out_cam[1][c] * img[c];",
          "2434:           out[2] += out_cam[2][c] * img[c];",
          "2435:         }",
          "2436:         for(c=0;c<3;c++) img[c] = CLIP((int) out[c]);",
          "2437:       }",
          "2438:       for(c=0; c< imgdata.idata.colors; c++) libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;",
          "2439:     }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2487: int LibRaw::dcraw_process(void)",
          "2488: {",
          "2666:             }",
          "2691: #ifndef NO_LCMS",
          "2697: #endif",
          "2714: }",
          "",
          "[Removed Lines]",
          "2489:     int quality,i;",
          "2491:     int iterations=-1, dcb_enhance=1, noiserd=0;",
          "2492:     int eeci_refine_fl=0, es_med_passes_fl=0;",
          "2493:     float cared=0,cablue=0;",
          "2494:     float linenoise=0;",
          "2495:     float lclean=0,cclean=0;",
          "2496:     float thresh=0;",
          "2497:     float preser=0;",
          "2498:     float expos=1.0;",
          "2501:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "2504:     try {",
          "2506:         int no_crop = 1;",
          "2508:         if (~O.cropbox[2] && ~O.cropbox[3])",
          "2509:             no_crop=0;",
          "2511:         libraw_decoder_info_t di;",
          "2512:         get_decoder_info(&di);",
          "2514:         int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY) && !IO.zero_is_bad;",
          "2516:         raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
          "2518:   int save_4color = O.four_color_rgb;",
          "2520:         if (IO.zero_is_bad)",
          "2521:           {",
          "2522:                 remove_zeroes();",
          "2523:                 SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "2524:             }",
          "2526:         if(O.bad_pixels && no_crop)",
          "2527:             {",
          "2528:                 bad_pixels(O.bad_pixels);",
          "2529:                 SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);",
          "2530:             }",
          "2532:         if (O.dark_frame && no_crop)",
          "2533:             {",
          "2534:                 subtract (O.dark_frame);",
          "2535:                 SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);",
          "2536:             }",
          "2538:  if (O.wf_debanding)",
          "2539:  {",
          "2540:   wf_remove_banding();",
          "2541:  }",
          "2543:         quality = 2 + !IO.fuji_width;",
          "2545:         if (O.user_qual >= 0) quality = O.user_qual;",
          "2547:         if(!subtract_inline || !C.data_maximum)",
          "2548:           {",
          "2549:             adjust_bl();",
          "2550:             subtract_black();",
          "2551:           }",
          "2553:         adjust_maximum();",
          "2555:         if (O.user_sat > 0) C.maximum = O.user_sat;",
          "2557:         if (P1.is_foveon)",
          "2558:             {",
          "2559:               if(load_raw == &LibRaw::foveon_dp_load_raw)",
          "2560:                 {",
          "2561:                   for (int i=0; i < S.height*S.width*4; i++)",
          "2562:                     if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;",
          "2563:                 }",
          "2564:               else",
          "2565:                 foveon_interpolate();",
          "2566:                 SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);",
          "2567:             }",
          "2569:         if (O.green_matching && !O.half_size)",
          "2570:             {",
          "2571:                 green_matching();",
          "2572:             }",
          "2574:         if (!P1.is_foveon && !O.no_auto_scale)",
          "2575:             {",
          "2576:                 scale_colors();",
          "2577:                 SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);",
          "2578:             }",
          "2580:         pre_interpolate();",
          "2582:         SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);",
          "2584:         if (O.dcb_iterations >= 0) iterations = O.dcb_iterations;",
          "2585:         if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl;",
          "2586:         if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd;",
          "2587:         if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine;",
          "2588:         if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes;",
          "2592:         if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);}",
          "2593:         if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);}",
          "2594:         if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);}",
          "2595:         if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);}",
          "2596:         if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);}",
          "2598:         if (P1.filters)",
          "2599:             {",
          "2600:                 if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd);",
          "2601:                 if (quality == 0)",
          "2602:                     lin_interpolate();",
          "2603:                 else if (quality == 1 || P1.colors > 3)",
          "2604:                     vng_interpolate();",
          "2605:                 else if (quality == 2 && P1.filters > 1000)",
          "2606:                     ppg_interpolate();",
          "2607:                 else if (P1.filters == 9)",
          "2608:                   {",
          "2610:                     fprintf(stderr,\"Xtrans int\\n\");",
          "2611:                     xtrans_interpolate(quality>2?3:1);",
          "2612:                   }",
          "2613:                 else if (quality == 3)",
          "2614:                   ahd_interpolate(); // really don't need it here due to fallback op",
          "2615:                 else if (quality == 4)",
          "2616:                   dcb(iterations, dcb_enhance);",
          "2618:                 else if (quality == 5)",
          "2619:                   ahd_interpolate_mod();",
          "2620:                 else if (quality == 6)",
          "2621:                   afd_interpolate_pl(2,1);",
          "2622:                 else if (quality == 7)",
          "2623:                   vcd_interpolate(0);",
          "2624:                 else if (quality == 8)",
          "2625:                   vcd_interpolate(12);",
          "2626:                 else if (quality == 9)",
          "2627:                   lmmse_interpolate(1);",
          "2630:                 else if (quality == 10)",
          "2631:                   amaze_demosaic_RT();",
          "2633:                 else if (quality == 11)",
          "2634:                   dht_interpolate();",
          "2635:                 else if (quality == 12)",
          "2636:                   aahd_interpolate();",
          "2638:                 else",
          "2639:                   ahd_interpolate();",
          "2641:                 SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);",
          "2642:             }",
          "2643:         if (IO.mix_green)",
          "2644:             {",
          "2645:                 for (P1.colors=3, i=0; i < S.height * S.width; i++)",
          "2646:                     imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;",
          "2647:                 SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);",
          "2648:             }",
          "2650:         if(!P1.is_foveon)",
          "2651:             {",
          "2652:                 if (P1.colors == 3)",
          "2653:                     {",
          "2655:                         if (quality == 8)",
          "2656:                             {",
          "2657:                                 if (eeci_refine_fl == 1) refinement();",
          "2658:                                 if (O.med_passes > 0)    median_filter_new();",
          "2659:                                 if (es_med_passes_fl > 0) es_median_filter();",
          "2660:                             }",
          "2661:                         else {",
          "2662:                             median_filter();",
          "2663:                         }",
          "2664:                         SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);",
          "2665:                     }",
          "2668:         if (O.highlight == 2)",
          "2669:             {",
          "2670:                 blend_highlights();",
          "2671:                 SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2672:             }",
          "2674:         if (O.highlight > 2)",
          "2675:             {",
          "2676:                 recover_highlights();",
          "2677:                 SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2678:             }",
          "2680:         if (O.use_fuji_rotate)",
          "2681:             {",
          "2682:                 fuji_rotate();",
          "2683:                 SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2684:             }",
          "2686:         if(!libraw_internal_data.output_data.histogram)",
          "2687:             {",
          "2688:                 libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "2689:                 merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_process()\");",
          "2690:             }",
          "2692:  if(O.camera_profile)",
          "2693:             {",
          "2694:                 apply_profile(O.camera_profile,O.output_profile);",
          "2695:                 SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);",
          "2696:             }",
          "2699:         convert_to_rgb();",
          "2700:         SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);",
          "2702:         if (O.use_fuji_rotate)",
          "2703:             {",
          "2704:                 stretch();",
          "2705:                 SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);",
          "2706:             }",
          "2707:         O.four_color_rgb = save_4color; // also, restore",
          "2709:         return 0;",
          "2710:     }",
          "2711:     catch ( LibRaw_exceptions err) {",
          "2712:         EXCEPTION_HANDLER(err);",
          "2713:     }",
          "",
          "[Added Lines]",
          "2489:   int quality,i;",
          "2491:   int iterations=-1, dcb_enhance=1, noiserd=0;",
          "2492:   int eeci_refine_fl=0, es_med_passes_fl=0;",
          "2493:   float cared=0,cablue=0;",
          "2494:   float linenoise=0;",
          "2495:   float lclean=0,cclean=0;",
          "2496:   float thresh=0;",
          "2497:   float preser=0;",
          "2498:   float expos=1.0;",
          "2501:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "2504:   try {",
          "2506:     int no_crop = 1;",
          "2508:     if (~O.cropbox[2] && ~O.cropbox[3])",
          "2509:       no_crop=0;",
          "2511:     libraw_decoder_info_t di;",
          "2512:     get_decoder_info(&di);",
          "2514:     int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY) && !IO.zero_is_bad;",
          "2516:     raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
          "2518:     int save_4color = O.four_color_rgb;",
          "2520:     if (IO.zero_is_bad)",
          "2521:       {",
          "2522:         remove_zeroes();",
          "2523:         SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "2524:       }",
          "2526:     if(O.bad_pixels && no_crop)",
          "2527:       {",
          "2528:         bad_pixels(O.bad_pixels);",
          "2529:         SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);",
          "2530:       }",
          "2532:     if (O.dark_frame && no_crop)",
          "2533:       {",
          "2534:         subtract (O.dark_frame);",
          "2535:         SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);",
          "2536:       }",
          "2538:     if (O.wf_debanding)",
          "2539:       {",
          "2540:         wf_remove_banding();",
          "2541:       }",
          "2543:     quality = 2 + !IO.fuji_width;",
          "2545:     if (O.user_qual >= 0) quality = O.user_qual;",
          "2547:     if(!subtract_inline || !C.data_maximum)",
          "2548:       {",
          "2549:         adjust_bl();",
          "2550:         subtract_black();",
          "2551:       }",
          "2553:     adjust_maximum();",
          "2555:     if (O.user_sat > 0) C.maximum = O.user_sat;",
          "2557:     if (P1.is_foveon)",
          "2558:       {",
          "2559:         if(load_raw == &LibRaw::foveon_dp_load_raw)",
          "2560:           {",
          "2561:             for (int i=0; i < S.height*S.width*4; i++)",
          "2562:               if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;",
          "2563:           }",
          "2564:         else",
          "2565:           foveon_interpolate();",
          "2566:         SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);",
          "2567:       }",
          "2569:     if (O.green_matching && !O.half_size)",
          "2570:       {",
          "2571:         green_matching();",
          "2572:       }",
          "2574:     if (!P1.is_foveon && !O.no_auto_scale)",
          "2575:       {",
          "2576:         scale_colors();",
          "2577:         SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);",
          "2578:       }",
          "2580:     pre_interpolate();",
          "2582:     SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);",
          "2584:     if (O.dcb_iterations >= 0) iterations = O.dcb_iterations;",
          "2585:     if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl;",
          "2586:     if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd;",
          "2587:     if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine;",
          "2588:     if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes;",
          "2592:     if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);}",
          "2593:     if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);}",
          "2594:     if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);}",
          "2595:     if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);}",
          "2596:     if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);}",
          "2598:     if (P1.filters)",
          "2599:       {",
          "2600:         if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd);",
          "2601:         if (quality == 0)",
          "2602:           lin_interpolate();",
          "2603:         else if (quality == 1 || P1.colors > 3)",
          "2604:           vng_interpolate();",
          "2605:         else if (quality == 2 && P1.filters > 1000)",
          "2606:           ppg_interpolate();",
          "2607:         else if (P1.filters == 9)",
          "2608:           {",
          "2610:             fprintf(stderr,\"Xtrans int\\n\");",
          "2611:             xtrans_interpolate(quality>2?3:1);",
          "2612:           }",
          "2613:         else if (quality == 3)",
          "2614:           ahd_interpolate(); // really don't need it here due to fallback op",
          "2615:         else if (quality == 4)",
          "2616:           dcb(iterations, dcb_enhance);",
          "2618:         else if (quality == 5)",
          "2619:           ahd_interpolate_mod();",
          "2620:         else if (quality == 6)",
          "2621:           afd_interpolate_pl(2,1);",
          "2622:         else if (quality == 7)",
          "2623:           vcd_interpolate(0);",
          "2624:         else if (quality == 8)",
          "2625:           vcd_interpolate(12);",
          "2626:         else if (quality == 9)",
          "2627:           lmmse_interpolate(1);",
          "2630:         else if (quality == 10)",
          "2631:           amaze_demosaic_RT();",
          "2633:         else if (quality == 11)",
          "2634:           dht_interpolate();",
          "2635:         else if (quality == 12)",
          "2636:           aahd_interpolate();",
          "2638:         else",
          "2639:           ahd_interpolate();",
          "2641:         SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);",
          "2642:       }",
          "2643:     if (IO.mix_green)",
          "2644:       {",
          "2645:         for (P1.colors=3, i=0; i < S.height * S.width; i++)",
          "2646:           imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;",
          "2647:         SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);",
          "2648:       }",
          "2650:     if(!P1.is_foveon)",
          "2651:       {",
          "2652:         if (P1.colors == 3)",
          "2653:           {",
          "2655:             if (quality == 8)",
          "2656:               {",
          "2657:                 if (eeci_refine_fl == 1) refinement();",
          "2658:                 if (O.med_passes > 0)    median_filter_new();",
          "2659:                 if (es_med_passes_fl > 0) es_median_filter();",
          "2660:               }",
          "2661:             else {",
          "2662:               median_filter();",
          "2664:             SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);",
          "2665:           }",
          "2666:       }",
          "2668:     if (O.highlight == 2)",
          "2669:       {",
          "2670:         blend_highlights();",
          "2671:         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2672:       }",
          "2674:     if (O.highlight > 2)",
          "2675:       {",
          "2676:         recover_highlights();",
          "2677:         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2678:       }",
          "2680:     if (O.use_fuji_rotate)",
          "2681:       {",
          "2682:         fuji_rotate();",
          "2683:         SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2684:       }",
          "2686:     if(!libraw_internal_data.output_data.histogram)",
          "2687:       {",
          "2688:         libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "2689:         merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_process()\");",
          "2690:       }",
          "2692:     if(O.camera_profile)",
          "2693:       {",
          "2694:         apply_profile(O.camera_profile,O.output_profile);",
          "2695:         SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);",
          "2696:       }",
          "2699:     convert_to_rgb();",
          "2700:     SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);",
          "2702:     if (O.use_fuji_rotate)",
          "2703:       {",
          "2704:         stretch();",
          "2705:         SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);",
          "2706:       }",
          "2707:     O.four_color_rgb = save_4color; // also, restore",
          "2709:     return 0;",
          "2710:   }",
          "2711:   catch ( LibRaw_exceptions err) {",
          "2712:     EXCEPTION_HANDLER(err);",
          "2713:   }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3279: const char * LibRaw::strprogress(enum LibRaw_progress p)",
          "3280: {",
          "3328: }",
          "",
          "[Removed Lines]",
          "3281:     switch(p)",
          "3282:         {",
          "3283:         case LIBRAW_PROGRESS_START:",
          "3284:             return \"Starting\";",
          "3285:         case LIBRAW_PROGRESS_OPEN :",
          "3286:             return \"Opening file\";",
          "3287:         case LIBRAW_PROGRESS_IDENTIFY :",
          "3288:             return \"Reading metadata\";",
          "3289:         case LIBRAW_PROGRESS_SIZE_ADJUST:",
          "3290:             return \"Adjusting size\";",
          "3291:         case LIBRAW_PROGRESS_LOAD_RAW:",
          "3292:             return \"Reading RAW data\";",
          "3293:         case LIBRAW_PROGRESS_REMOVE_ZEROES:",
          "3294:             return \"Clearing zero values\";",
          "3295:         case LIBRAW_PROGRESS_BAD_PIXELS :",
          "3296:             return \"Removing dead pixels\";",
          "3297:         case LIBRAW_PROGRESS_DARK_FRAME:",
          "3298:             return \"Subtracting dark frame data\";",
          "3299:         case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:",
          "3300:             return \"Interpolating Foveon sensor data\";",
          "3301:         case LIBRAW_PROGRESS_SCALE_COLORS:",
          "3302:             return \"Scaling colors\";",
          "3303:         case LIBRAW_PROGRESS_PRE_INTERPOLATE:",
          "3304:             return \"Pre-interpolating\";",
          "3305:         case LIBRAW_PROGRESS_INTERPOLATE:",
          "3306:             return \"Interpolating\";",
          "3307:         case LIBRAW_PROGRESS_MIX_GREEN :",
          "3308:             return \"Mixing green channels\";",
          "3309:         case LIBRAW_PROGRESS_MEDIAN_FILTER   :",
          "3310:             return \"Median filter\";",
          "3311:         case LIBRAW_PROGRESS_HIGHLIGHTS:",
          "3312:             return \"Highlight recovery\";",
          "3313:         case LIBRAW_PROGRESS_FUJI_ROTATE :",
          "3314:             return \"Rotating Fuji diagonal data\";",
          "3315:         case LIBRAW_PROGRESS_FLIP :",
          "3316:             return \"Flipping image\";",
          "3317:         case LIBRAW_PROGRESS_APPLY_PROFILE:",
          "3318:             return \"ICC conversion\";",
          "3319:         case LIBRAW_PROGRESS_CONVERT_RGB:",
          "3320:             return \"Converting to RGB\";",
          "3321:         case LIBRAW_PROGRESS_STRETCH:",
          "3322:             return \"Stretching image\";",
          "3323:         case LIBRAW_PROGRESS_THUMB_LOAD:",
          "3324:             return \"Loading thumbnail\";",
          "3325:         default:",
          "3326:             return \"Some strange things\";",
          "3327:         }",
          "",
          "[Added Lines]",
          "3281:   switch(p)",
          "3282:     {",
          "3283:     case LIBRAW_PROGRESS_START:",
          "3284:       return \"Starting\";",
          "3285:     case LIBRAW_PROGRESS_OPEN :",
          "3286:       return \"Opening file\";",
          "3287:     case LIBRAW_PROGRESS_IDENTIFY :",
          "3288:       return \"Reading metadata\";",
          "3289:     case LIBRAW_PROGRESS_SIZE_ADJUST:",
          "3290:       return \"Adjusting size\";",
          "3291:     case LIBRAW_PROGRESS_LOAD_RAW:",
          "3292:       return \"Reading RAW data\";",
          "3293:     case LIBRAW_PROGRESS_REMOVE_ZEROES:",
          "3294:       return \"Clearing zero values\";",
          "3295:     case LIBRAW_PROGRESS_BAD_PIXELS :",
          "3296:       return \"Removing dead pixels\";",
          "3297:     case LIBRAW_PROGRESS_DARK_FRAME:",
          "3298:       return \"Subtracting dark frame data\";",
          "3299:     case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:",
          "3300:       return \"Interpolating Foveon sensor data\";",
          "3301:     case LIBRAW_PROGRESS_SCALE_COLORS:",
          "3302:       return \"Scaling colors\";",
          "3303:     case LIBRAW_PROGRESS_PRE_INTERPOLATE:",
          "3304:       return \"Pre-interpolating\";",
          "3305:     case LIBRAW_PROGRESS_INTERPOLATE:",
          "3306:       return \"Interpolating\";",
          "3307:     case LIBRAW_PROGRESS_MIX_GREEN :",
          "3308:       return \"Mixing green channels\";",
          "3309:     case LIBRAW_PROGRESS_MEDIAN_FILTER   :",
          "3310:       return \"Median filter\";",
          "3311:     case LIBRAW_PROGRESS_HIGHLIGHTS:",
          "3312:       return \"Highlight recovery\";",
          "3313:     case LIBRAW_PROGRESS_FUJI_ROTATE :",
          "3314:       return \"Rotating Fuji diagonal data\";",
          "3315:     case LIBRAW_PROGRESS_FLIP :",
          "3316:       return \"Flipping image\";",
          "3317:     case LIBRAW_PROGRESS_APPLY_PROFILE:",
          "3318:       return \"ICC conversion\";",
          "3319:     case LIBRAW_PROGRESS_CONVERT_RGB:",
          "3320:       return \"Converting to RGB\";",
          "3321:     case LIBRAW_PROGRESS_STRETCH:",
          "3322:       return \"Stretching image\";",
          "3323:     case LIBRAW_PROGRESS_THUMB_LOAD:",
          "3324:       return \"Loading thumbnail\";",
          "3325:     default:",
          "3326:       return \"Some strange things\";",
          "3327:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "59b781fb1a804e1d1950a2640cb5d5182d498421",
      "candidate_info": {
        "commit_hash": "59b781fb1a804e1d1950a2640cb5d5182d498421",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/59b781fb1a804e1d1950a2640cb5d5182d498421",
        "files": [
          "Changelog.txt",
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp",
          "internal/libraw_internal_funcs.h",
          "src/libraw_cxx.cpp"
        ],
        "message": "PhaseOne: black level subtracted on postprocessing stage",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp",
          "internal/libraw_internal_funcs.h||internal/libraw_internal_funcs.h",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1698:  pixel[col] = curve[pixel[col]];",
          "1699:     }",
          "1700:     for (col=0; col < raw_width; col++) {",
          "1701:       i = (pixel[col] << 2) - ph1.t_black + t_black[row][col >= ph1.split_col];",
          "1703:     }",
          "1704:   }",
          "1705:   free (pixel);",
          "",
          "[Removed Lines]",
          "1702:  if (i > 0) RAW(row,col) = i;",
          "",
          "[Added Lines]",
          "1701: #ifndef LIBRAW_LIBRARY_BUILD",
          "1703:       if (i > 0) RAW(row,col) = i;",
          "1704: #else",
          "1705:       RAW(row,col) = pixel[col] << 2;",
          "1706: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3577: #endif",
          "3578:     c, m, mblack[8], zero, val;",
          "3580:   if (load_raw == &CLASS phase_one_load_raw ||",
          "3581:       load_raw == &CLASS phase_one_load_raw_c)",
          "3582:     phase_one_correct();",
          "3584:   if (fuji_width) {",
          "3585:     for (row=0; row < raw_height-top_margin*2; row++) {",
          "3586:       for (col=0; col < fuji_width << !fuji_layout; col++) {",
          "",
          "[Removed Lines]",
          "3583: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Added Lines]",
          "3584: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1429:  pixel[col] = curve[pixel[col]];",
          "1430:     }",
          "1431:     for (col=0; col < raw_width; col++) {",
          "1432:       i = (pixel[col] << 2) - ph1.t_black + t_black[row][col >= ph1.split_col];",
          "1434:     }",
          "1435:   }",
          "1436:   free (pixel);",
          "",
          "[Removed Lines]",
          "1433:  if (i > 0) RAW(row,col) = i;",
          "",
          "[Added Lines]",
          "1432: #ifndef LIBRAW_LIBRARY_BUILD",
          "1434:       if (i > 0) RAW(row,col) = i;",
          "1435: #else",
          "1436:       RAW(row,col) = pixel[col] << 2;",
          "1437: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2591:   jas_stream_close (in);",
          "2592: #endif",
          "2593: }",
          "2595: void CLASS crop_masked_pixels()",
          "2596: {",
          "2597:   int row, col;",
          "",
          "[Removed Lines]",
          "2594: #line 3571 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "2598: #line 3575 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2601: #endif",
          "2602:     c, m, mblack[8], zero, val;",
          "2604:   if (load_raw == &CLASS phase_one_load_raw ||",
          "2605:       load_raw == &CLASS phase_one_load_raw_c)",
          "2606:     phase_one_correct();",
          "2608:   if (fuji_width) {",
          "2609:     for (row=0; row < raw_height-top_margin*2; row++) {",
          "2610:       for (col=0; col < fuji_width << !fuji_layout; col++) {",
          "",
          "[Removed Lines]",
          "2607: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Added Lines]",
          "2608: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2692:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);",
          "2693: #endif",
          "2694: }",
          "2696: void CLASS gamma_curve (double pwr, double ts, int mode, int imax)",
          "2697: {",
          "2698:   int i;",
          "",
          "[Removed Lines]",
          "2695: #line 3837 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "2699: #line 3841 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3757:     fseek (ifp, save, SEEK_SET);",
          "3758:   }",
          "3759: }",
          "3761: void CLASS parse_makernote (int base, int uptag)",
          "3762: {",
          "3763:   static const uchar xlat[2][256] = {",
          "",
          "[Removed Lines]",
          "3760: #line 4906 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "3764: #line 4910 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4272:     fseek (ifp, save, SEEK_SET);",
          "4273:   }",
          "4274: }",
          "4276: int CLASS parse_tiff_ifd (int base)",
          "4277: {",
          "4278:   unsigned entries, tag, type, len, plen=16, save;",
          "",
          "[Removed Lines]",
          "4275: #line 5426 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "4279: #line 5430 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5516:     data_offset = get4();",
          "5517:   }",
          "5518: }",
          "5520: char * CLASS foveon_gets (int offset, char *str, int len)",
          "5521: {",
          "5522:   int i;",
          "",
          "[Removed Lines]",
          "5519: #line 6672 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "5523: #line 6676 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5617:   }",
          "5618:   is_foveon = 1;",
          "5619: }",
          "5622:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "",
          "[Removed Lines]",
          "5620: #line 6775 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "5624: #line 6779 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "8060: }",
          "8064: void CLASS convert_to_rgb()",
          "8065: {",
          "8066: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "8063: #line 9307 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8067: #line 9311 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "8290:   if (flip & 1) col = iwidth  - 1 - col;",
          "8291:   return row * iwidth + col;",
          "8292: }",
          "8294: void CLASS tiff_set (ushort *ntag,",
          "8295:  ushort tag, ushort type, int count, int val)",
          "8296: {",
          "",
          "[Removed Lines]",
          "8293: #line 9562 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8297: #line 9566 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp": [
          "File: internal/dcraw_fileio.cpp -> internal/dcraw_fileio.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:    for more information",
          "25: #include <math.h>",
          "26: #define CLASS LibRaw::",
          "27: #include \"libraw/libraw_types.h\"",
          "",
          "[Removed Lines]",
          "24: #line 3674 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "24: #line 3678 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #include \"libraw/libraw.h\"",
          "30: #include \"internal/defines.h\"",
          "31: #include \"internal/var_defines.h\"",
          "34:    Seach from the current directory up to the root looking for",
          "35:    a \".badpixels\" file, and fix those pixels now.",
          "",
          "[Removed Lines]",
          "32: #line 3685 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "32: #line 3689 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54: #endif",
          "55:   if (cfname)",
          "56:     fp = fopen (cfname, \"r\");",
          "58:   if (!fp)",
          "59:       {",
          "60: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "57: #line 3735 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "57: #line 3739 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "154:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "155: #endif",
          "156: }",
          "158: #ifndef NO_LCMS",
          "159: void CLASS apply_profile (const char *input, const char *output)",
          "160: {",
          "",
          "[Removed Lines]",
          "157: #line 9220 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "157: #line 9224 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/libraw_internal_funcs.h||internal/libraw_internal_funcs.h": [
          "File: internal/libraw_internal_funcs.h -> internal/libraw_internal_funcs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:     void        phase_one_flat_field (int is_float, int nc);",
          "111:     void        phase_one_correct();",
          "112:     void        phase_one_load_raw();",
          "113:     unsigned    ph1_bits (int nbits);",
          "114:     void        phase_one_load_raw_c();",
          "115:     void        hasselblad_load_raw();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113:     void        phase_one_prepare_to_correct();",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "794:         if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "795:             {",
          "796:               imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "798:             }",
          "799:         else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "800:             {",
          "",
          "[Removed Lines]",
          "797:                 imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "",
          "[Added Lines]",
          "797:               imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "909:     try {",
          "910:         raw2image_start();",
          "913:         if(imgdata.image)",
          "914:             {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "912:         if (load_raw == &CLASS phase_one_load_raw ||",
          "913:             load_raw == &CLASS phase_one_load_raw_c)",
          "914:           {",
          "915:             phase_one_prepare_to_correct();",
          "916:             phase_one_correct();",
          "917:           }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "969:     }",
          "970: }",
          "972: int LibRaw::raw2image_ex(void)",
          "973: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "979: void LibRaw::phase_one_prepare_to_correct()",
          "980: {",
          "982:   imgdata.rawdata.raw_image = (ushort*)calloc(S.raw_width*S.raw_height,sizeof(ushort));",
          "983:   merror (imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");",
          "984:   printf(\"Preparing to correct\\n\");",
          "985:   if (load_raw == &CLASS phase_one_load_raw || !imgdata.rawdata.ph1_black)",
          "986:     {",
          "988:       memmove(imgdata.rawdata.raw_image,imgdata.rawdata.raw_alloc,S.raw_width*S.raw_height*sizeof(ushort));",
          "989:     }",
          "990:   else",
          "991:     {",
          "992:       ushort *src = (ushort*)imgdata.rawdata.raw_alloc;",
          "993:       for(int row = 0; row < S.raw_height; row++)",
          "994:         for(int col=0; col < S.raw_width; col++)",
          "995:           {",
          "996:             int idx  = row*S.raw_width + col;",
          "997:             ushort val = src[idx];",
          "998:             ushort bl = imgdata.color.phase_one_data.t_black",
          "999:               - imgdata.rawdata.ph1_black[row][col >= imgdata.color.phase_one_data.split_col];",
          "1000:             imgdata.rawdata.raw_image[idx] = val>bl?val-bl:0;",
          "1001:           }",
          "1002:     }",
          "1004:     if (load_raw == &CLASS phase_one_load_raw ||",
          "1005:         load_raw == &CLASS phase_one_load_raw_c)",
          "1006:       {",
          "1007:         free(imgdata.rawdata.raw_image);",
          "1008:         imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1009:       }",
          "1010: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "977:   try {",
          "978:     raw2image_start();",
          "980:     int do_crop = 0;",
          "981:     unsigned save_width = S.width;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1020:     if (load_raw == &CLASS phase_one_load_raw ||",
          "1021:         load_raw == &CLASS phase_one_load_raw_c)",
          "1022:       {",
          "1023:         phase_one_prepare_to_correct();",
          "1024:         phase_one_correct();",
          "1025:       }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1147:           }",
          "1148:       }",
          "1151:     imgdata.progress_flags",
          "1152:       = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1199:     if (load_raw == &CLASS phase_one_load_raw ||",
          "1200:         load_raw == &CLASS phase_one_load_raw_c)",
          "1201:       {",
          "1202:         free(imgdata.rawdata.raw_image);",
          "1203:         imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1204:       }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-3798",
  "cve_desc": "A flaw was found in openCryptoki. The openCryptoki Soft token does not check if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey is used with ECDH public data. This may allow a malicious user to extract the private key by performing an invalid curve attack.",
  "repo": "opencryptoki/opencryptoki",
  "patch_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
  "patch_info": {
    "commit_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
    "repo": "opencryptoki/opencryptoki",
    "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0",
    "files": [
      "usr/lib/soft_stdll/soft_specific.c"
    ],
    "message": "SOFT: Check the EC Key on C_CreateObject and C_DeriveKey\n\nWhen constructing an OpenSSL EC public or private key from PKCS#11\nattributes or ECDH public data, check that the key is valid, i.e. that\nthe point is on the curve.\n\nThis prevents one from creating an EC key object via C_CreateObject with\ninvalid key data. It also prevents C_DeriveKey to derive a secret using\nECDH with an EC public key (public data) that uses a different curve\nor is invalid by other means.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
    "before_after_code_files": [
      "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
    ]
  },
  "patch_diff": {
    "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c": [
      "File: usr/lib/soft_stdll/soft_specific.c -> usr/lib/soft_stdll/soft_specific.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4365:         goto out;",
      "4366:     }",
      "4368: out:",
      "4369:     if (allocated && ecpoint != NULL)",
      "4370:         free(ecpoint);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4368:     if (!EC_KEY_check_key(ec_key)) {",
      "4369:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "4370:         rc = CKR_PUBLIC_KEY_INVALID;",
      "4371:         goto out;",
      "4372:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4404:         goto out;",
      "4405:     }",
      "4407: out:",
      "4408:     if (point != NULL)",
      "4409:         EC_POINT_free(point);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4413:     if (!EC_KEY_check_key(ec_key)) {",
      "4414:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "4415:         rc = CKR_FUNCTION_FAILED;",
      "4416:         goto out;",
      "4417:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7d5188407d7c146485fd2703fb578e5e966abbc7",
      "candidate_info": {
        "commit_hash": "7d5188407d7c146485fd2703fb578e5e966abbc7",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/7d5188407d7c146485fd2703fb578e5e966abbc7",
        "files": [
          "usr/lib/common/key.c"
        ],
        "message": "Don't allow to set CKA_PUBLIC_KEY_INFO for private keys\n\nPer PKCS#11 the CKA_PUBLIC_KEY_INFO attribute: \"DER-encoding of\nthe SubjectPublicKeyInfo for the associated public key (MAY be\nempty; DEFAULT derived from the underlying private key data;\nMAY be manually set for specific key types; if set; MUST be\nconsistent with the underlying private key data)\"\n\nAnd further: \"If this attribute is supplied as part of a template\nfor C_CreateObject, C_CopyObject or C_SetAttributeValue for a private\nkey, the token MUST verify correspondence between the private key\ndata and the public key data as supplied in CKA_PUBLIC_KEY_INFO. This\ncan be done either by deriving a public key from the private key and\ncomparing the values, or by doing a sign and verify operation. If there\nis a mismatch, the command SHALL return CKR_ATTRIBUTE_VALUE_INVALID. A\ntoken MAY choose not to support the CKA_PUBLIC_KEY_INFO attribute for\ncommands which create new private keys. If it does not support the\nattribute, the command SHALL return CKR_ATTRIBUTE_TYPE_INVALID.\"\n\nSince checking for a consistent SubjectPublicKeyInfo when this attribute\nis supplied via template is quite difficult, don't allow it to be\nspecified in commands which create new private keys for now.\n\nWhen keys are generated, the SubjectPublicKeyInfo is computed\nautomatically (if possible) and set to CKA_PUBLIC_KEY_INFO during key\ncreation.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/common/key.c||usr/lib/common/key.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/common/key.c||usr/lib/common/key.c": [
          "File: usr/lib/common/key.c -> usr/lib/common/key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1249:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_ATTRIBUTE_READ_ONLY));",
          "1250:         return CKR_ATTRIBUTE_READ_ONLY;",
          "1251:     case CKA_PUBLIC_KEY_INFO:",
          "1255:     case CKA_UNWRAP_TEMPLATE:",
          "1256:         if ((attr->ulValueLen > 0 && attr->pValue == NULL) ||",
          "1257:             attr->ulValueLen % sizeof(CK_ATTRIBUTE)) {",
          "",
          "[Removed Lines]",
          "1252:         if (mode == MODE_CREATE || mode == MODE_UNWRAP)",
          "1253:             return CKR_OK;",
          "1254:         return CKR_ATTRIBUTE_READ_ONLY;",
          "",
          "[Added Lines]",
          "1258:         return CKR_ATTRIBUTE_TYPE_INVALID;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7a23c12214688b287b9591133445e593da633caa",
      "candidate_info": {
        "commit_hash": "7a23c12214688b287b9591133445e593da633caa",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/7a23c12214688b287b9591133445e593da633caa",
        "files": [
          "usr/include/apictl.h",
          "usr/lib/api/api.mk",
          "usr/lib/api/api_interface.c",
          "usr/lib/api/socket_client.c"
        ],
        "message": "API: Use own OpenSSL library context for Opencryptoki's use of OpenSSL\n\nCreate a separate library context for Opencryptoki's use of OpenSSL services\nand explicitly load the 'default' provider for this context.\n\nThis prevents call-loops when the calling application has configured a PKCS#11\nprovider that uses Opencryptoki under the covers. This could produce a loop\nwith the following calling tree:\n  Application -> Openssl -> PKCS11-provider -> Opencryptoki -> OpenSSL\n  -> PKCS11-provider -> Opencryptoki -> ...\nExplicitly using the 'default' provider only for Opencrypoki's OpenSSL usage\nbreaks this loop.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/include/apictl.h||usr/include/apictl.h",
          "usr/lib/api/api.mk||usr/lib/api/api.mk",
          "usr/lib/api/api_interface.c||usr/lib/api/api_interface.c",
          "usr/lib/api/socket_client.c||usr/lib/api/socket_client.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/include/apictl.h||usr/include/apictl.h": [
          "File: usr/include/apictl.h -> usr/include/apictl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include <local_types.h>",
          "14: #include <stdll.h>",
          "15: #include <slotmgr.h>",
          "19: #ifndef _APILOCAL_H",
          "20: #define _APILOCAL_H",
          "",
          "[Removed Lines]",
          "17: #include \"local_types.h\"",
          "",
          "[Added Lines]",
          "16: #include <defs.h>",
          "21: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "22:     #include <openssl/crypto.h>",
          "23:     #include <openssl/provider.h>",
          "24: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:     int socketfd;",
          "61:     pthread_t event_thread;",
          "62: } API_Proc_Struct_t;",
          "64: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "67:     OSSL_LIB_CTX *openssl_libctx;",
          "68:     OSSL_PROVIDER *openssl_default_provider;",
          "69: #endif",
          "",
          "---------------"
        ],
        "usr/lib/api/api.mk||usr/lib/api/api.mk": [
          "File: usr/lib/api/api.mk -> usr/lib/api/api.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:  -DSTDLL_NAME=\\\"api\\\"",
          "14: opencryptoki_libopencryptoki_la_LDFLAGS =    \\",
          "16:  -version-info $(SO_CURRENT):$(SO_REVISION):$(SO_AGE)  \\",
          "17:  -Wl,--version-script=${srcdir}/opencryptoki.map",
          "",
          "[Removed Lines]",
          "15:  -shared -Wl,-z,defs,-Bsymbolic -lc -ldl -lpthread  \\",
          "",
          "[Added Lines]",
          "15:  -shared -Wl,-z,defs,-Bsymbolic -lc -ldl -lpthread -lcrypto \\",
          "",
          "---------------"
        ],
        "usr/lib/api/api_interface.c||usr/lib/api/api_interface.c": [
          "File: usr/lib/api/api_interface.c -> usr/lib/api/api_interface.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: void api_init();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "41: #define BEGIN_OPENSSL_LIBCTX(ossl_ctx, rc)                                  \\",
          "42:         do {                                                                \\",
          "43:             OSSL_LIB_CTX  *prev_ctx = OSSL_LIB_CTX_set0_default((ossl_ctx));\\",
          "44:             if (prev_ctx == NULL) {                                         \\",
          "45:                 (rc) = CKR_FUNCTION_FAILED;                                 \\",
          "46:                 TRACE_ERROR(\"OSSL_LIB_CTX_set0_default failed\\n\");          \\",
          "47:                 break;                                                      \\",
          "48:             }",
          "50: #define END_OPENSSL_LIBCTX(rc)                                              \\",
          "51:             if (OSSL_LIB_CTX_set0_default(prev_ctx) == NULL) {              \\",
          "52:                 if ((rc) == CKR_OK)                                         \\",
          "53:                     (rc) = CKR_FUNCTION_FAILED;                             \\",
          "54:                 TRACE_ERROR(\"OSSL_LIB_CTX_set0_default failed\\n\");          \\",
          "55:             }                                                               \\",
          "56:         } while (0);",
          "57: #else",
          "58: #define BEGIN_OPENSSL_LIBCTX(ossl_ctx, rc)  do {",
          "59: #define END_OPENSSL_LIBCTX(rc)              } while (0);",
          "60: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "348: CK_RV C_CloseAllSessions(CK_SLOT_ID slotID)",
          "349: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "372:     CK_RV rc = CKR_OK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "368:     CloseAllSessions(slotID, FALSE);",
          "371: }                               // end of C_CloseAllSessions",
          "",
          "[Removed Lines]",
          "370:     return CKR_OK;",
          "",
          "[Added Lines]",
          "391:     BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rc)",
          "393:     END_OPENSSL_LIBCTX(rc)",
          "395:     return rc;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "408:         return CKR_TOKEN_NOT_PRESENT;",
          "409:     }",
          "410:     if (fcn->ST_CloseSession) {",
          "412:         rv = fcn->ST_CloseSession(sltp->TokData, &rSession, FALSE);",
          "413:         TRACE_DEVEL(\"Called STDLL rv = 0x%lx\\n\", rv);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "436:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "440:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "488:         return CKR_TOKEN_NOT_PRESENT;",
          "489:     }",
          "490:     if (fcn->ST_CopyObject) {",
          "492:         rv = fcn->ST_CopyObject(sltp->TokData, &rSession, hObject,",
          "493:                                 pTemplate, ulCount, phNewObject);",
          "494:     } else {",
          "495:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "496:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "519:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "523:         TRACE_DEVEL(\"fcn->ST_CopyObject returned:0x%lx\\n\", rv);",
          "524:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "558:         return CKR_TOKEN_NOT_PRESENT;",
          "559:     }",
          "560:     if (fcn->ST_CreateObject) {",
          "562:         rv = fcn->ST_CreateObject(sltp->TokData, &rSession, pTemplate,",
          "563:                                   ulCount, phObject);",
          "564:         TRACE_DEVEL(\"fcn->ST_CreateObject returned:0x%lx\\n\", rv);",
          "565:     } else {",
          "566:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "567:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "592:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "597:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "611:         return CKR_TOKEN_NOT_PRESENT;",
          "612:     }",
          "613:     if (fcn->ST_Decrypt) {",
          "615:         rv = fcn->ST_Decrypt(sltp->TokData, &rSession, pEncryptedData,",
          "616:                              ulEncryptedDataLen, pData, pulDataLen);",
          "617:         TRACE_DEVEL(\"fcn->ST_Decrypt returned:0x%lx\\n\", rv);",
          "618:     } else {",
          "619:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "620:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "647:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "652:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "661:         return CKR_TOKEN_NOT_PRESENT;",
          "662:     }",
          "663:     if (fcn->ST_DecryptDigestUpdate) {",
          "665:         rv = fcn->ST_DecryptDigestUpdate(sltp->TokData, &rSession,",
          "666:                                          pEncryptedPart,",
          "667:                                          ulEncryptedPartLen, pPart, pulPartLen);",
          "668:         TRACE_DEVEL(\"fcn->ST_DecryptDigestUpdate returned:0x%lx\\n\", rv);",
          "669:     } else {",
          "670:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "671:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "705:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "714:         return CKR_TOKEN_NOT_PRESENT;",
          "715:     }",
          "716:     if (fcn->ST_DecryptFinal) {",
          "718:         rv = fcn->ST_DecryptFinal(sltp->TokData, &rSession, pLastPart,",
          "719:                                   pulLastPartLen);",
          "720:         TRACE_DEVEL(\"fcn->ST_DecryptFinal returned: 0x%lx\\n\", rv);",
          "721:     } else {",
          "722:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "723:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "759:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "771:         return CKR_TOKEN_NOT_PRESENT;",
          "772:     }",
          "773:     if (fcn->ST_DecryptInit) {",
          "775:         rv = fcn->ST_DecryptInit(sltp->TokData, &rSession, pMechanism, hKey);",
          "776:         TRACE_DEVEL(\"fcn->ST_DecryptInit returned:0x%lx\\n\", rv);",
          "777:     } else {",
          "778:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "779:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "813:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "817:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "823:         return CKR_TOKEN_NOT_PRESENT;",
          "824:     }",
          "825:     if (fcn->ST_DecryptUpdate) {",
          "827:         rv = fcn->ST_DecryptUpdate(sltp->TokData, &rSession,",
          "828:                                    pEncryptedPart, ulEncryptedPartLen,",
          "829:                                    pPart, pulPartLen);",
          "830:         TRACE_DEVEL(\"fcn->ST_DecryptUpdate:0x%lx\\n\", rv);",
          "831:     } else {",
          "832:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "833:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "867:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "873:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "873:         return CKR_TOKEN_NOT_PRESENT;",
          "874:     }",
          "875:     if (fcn->ST_DecryptVerifyUpdate) {",
          "877:         rv = fcn->ST_DecryptVerifyUpdate(sltp->TokData, &rSession,",
          "878:                                          pEncryptedPart, ulEncryptedPartLen,",
          "879:                                          pPart, pulPartLen);",
          "880:         TRACE_DEVEL(\"fcn->ST_DecryptVerifyUpdate returned:0x%lx\\n\", rv);",
          "881:     } else {",
          "882:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "883:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "919:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "925:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "941:         return CKR_TOKEN_NOT_PRESENT;",
          "942:     }",
          "943:     if (fcn->ST_DeriveKey) {",
          "945:         rv = fcn->ST_DeriveKey(sltp->TokData, &rSession, pMechanism,",
          "946:                                hBaseKey, pTemplate, ulAttributeCount, phKey);",
          "947:         TRACE_DEVEL(\"fcn->ST_DeriveKey returned:0x%lx\\n\", rv);",
          "948:     } else {",
          "949:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "950:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "989:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "994:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "992:         return CKR_TOKEN_NOT_PRESENT;",
          "993:     }",
          "994:     if (fcn->ST_DestroyObject) {",
          "996:         rv = fcn->ST_DestroyObject(sltp->TokData, &rSession, hObject);",
          "997:         TRACE_DEVEL(\"fcn->ST_DestroyObject returned:0x%lx\\n\", rv);",
          "998:     } else {",
          "999:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1000:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1042:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1046:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1040:         return CKR_TOKEN_NOT_PRESENT;",
          "1041:     }",
          "1042:     if (fcn->ST_Digest) {",
          "1044:         rv = fcn->ST_Digest(sltp->TokData, &rSession, pData, ulDataLen,",
          "1045:                             pDigest, pulDigestLen);",
          "1046:         TRACE_DEVEL(\"fcn->ST_Digest:0x%lx\\n\", rv);",
          "1047:     } else {",
          "1048:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1049:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1092:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1097:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1091:         return CKR_TOKEN_NOT_PRESENT;",
          "1092:     }",
          "1093:     if (fcn->ST_DigestEncryptUpdate) {",
          "1095:         rv = fcn->ST_DigestEncryptUpdate(sltp->TokData, &rSession,",
          "1096:                                          pPart, ulPartLen,",
          "1097:                                          pEncryptedPart, pulEncryptedPartLen);",
          "1098:         TRACE_DEVEL(\"fcn->ST_DigestEncryptUpdate returned:0x%lx\\n\", rv);",
          "1099:     } else {",
          "1100:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1101:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1145:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1151:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1139:         return CKR_TOKEN_NOT_PRESENT;",
          "1140:     }",
          "1141:     if (fcn->ST_DigestFinal) {",
          "1143:         rv = fcn->ST_DigestFinal(sltp->TokData, &rSession, pDigest,",
          "1144:                                  pulDigestLen);",
          "1145:         TRACE_DEVEL(\"fcn->ST_DigestFinal returned:0x%lx\\n\", rv);",
          "1146:     } else {",
          "1147:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1148:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1195:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1200:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1189:         return CKR_TOKEN_NOT_PRESENT;",
          "1190:     }",
          "1191:     if (fcn->ST_DigestInit) {",
          "1193:         rv = fcn->ST_DigestInit(sltp->TokData, &rSession, pMechanism);",
          "1194:         TRACE_DEVEL(\"fcn->ST_DigestInit returned:0x%lx\\n\", rv);",
          "1195:     } else {",
          "1196:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1197:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1247:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1251:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1234:         return CKR_TOKEN_NOT_PRESENT;",
          "1235:     }",
          "1236:     if (fcn->ST_DigestKey) {",
          "1238:         rv = fcn->ST_DigestKey(sltp->TokData, &rSession, hKey);",
          "1239:         TRACE_DEBUG(\"fcn->ST_DigestKey returned:0x%lx\\n\", rv);",
          "1240:     } else {",
          "1241:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1242:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1294:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1298:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1280:         return CKR_TOKEN_NOT_PRESENT;",
          "1281:     }",
          "1282:     if (fcn->ST_DigestUpdate) {",
          "1284:         rv = fcn->ST_DigestUpdate(sltp->TokData, &rSession, pPart, ulPartLen);",
          "1285:         TRACE_DEVEL(\"fcn->ST_DigestUpdate returned:0x%lx\\n\", rv);",
          "1286:     } else {",
          "1287:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1288:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1342:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1346:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1328:         return CKR_TOKEN_NOT_PRESENT;",
          "1329:     }",
          "1330:     if (fcn->ST_Encrypt) {",
          "1332:         rv = fcn->ST_Encrypt(sltp->TokData, &rSession, pData,",
          "1333:                              ulDataLen, pEncryptedData, pulEncryptedDataLen);",
          "1334:         TRACE_DEVEL(\"fcn->ST_Encrypt returned: 0x%lx\\n\", rv);",
          "1335:     } else {",
          "1336:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1337:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1392:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1397:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1376:         return CKR_TOKEN_NOT_PRESENT;",
          "1377:     }",
          "1378:     if (fcn->ST_EncryptFinal) {",
          "1380:         rv = fcn->ST_EncryptFinal(sltp->TokData, &rSession,",
          "1381:                                   pLastEncryptedPart, pulLastEncryptedPartLen);",
          "1382:         TRACE_DEVEL(\"fcn->ST_EncryptFinal: 0x%lx\\n\", rv);",
          "1383:     } else {",
          "1384:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1385:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1442:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1447:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1427:         return CKR_TOKEN_NOT_PRESENT;",
          "1428:     }",
          "1429:     if (fcn->ST_EncryptInit) {",
          "1431:         rv = fcn->ST_EncryptInit(sltp->TokData, &rSession, pMechanism, hKey);",
          "1432:         TRACE_INFO(\"fcn->ST_EncryptInit returned:0x%lx\\n\", rv);",
          "1433:     } else {",
          "1434:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1435:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1495:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1499:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1476:         return CKR_TOKEN_NOT_PRESENT;",
          "1477:     }",
          "1478:     if (fcn->ST_EncryptUpdate) {",
          "1480:         rv = fcn->ST_EncryptUpdate(sltp->TokData, &rSession, pPart,",
          "1481:                                    ulPartLen, pEncryptedPart,",
          "1482:                                    pulEncryptedPartLen);",
          "1483:         TRACE_DEVEL(\"fcn->ST_EncryptUpdate returned:0x%lx\\n\", rv);",
          "1484:     } else {",
          "1485:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1486:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1546:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1552:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1546:     for (slotID = 0; slotID < NUMBER_SLOTS_MANAGED; slotID++) {",
          "1547:         sltp = &(Anchor->SltList[slotID]);",
          "1548:         if (slot_loaded[slotID]) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1615:     BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rc)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1565:         if (!in_child_fork_initializer)",
          "1566:             DL_UnLoad(sltp, slotID);",
          "1567:     }",
          "1570:     API_UnRegister();",
          "1572:     bt_destroy(&Anchor->sess_btree);",
          "1574:     detach_shared_memory(Anchor->SharedMemP);",
          "1575:     free(Anchor);               // Free API Proc Struct",
          "1576:     Anchor = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1638:     END_OPENSSL_LIBCTX(rc)",
          "1645: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "1646:     if (Anchor->openssl_default_provider != NULL)",
          "1647:         OSSL_PROVIDER_unload(Anchor->openssl_default_provider);",
          "1648:     if (Anchor->openssl_libctx != NULL)",
          "1649:         OSSL_LIB_CTX_free(Anchor->openssl_libctx);",
          "1650: #endif",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1632:         return CKR_TOKEN_NOT_PRESENT;",
          "1633:     }",
          "1634:     if (fcn->ST_FindObjects) {",
          "1636:         rv = fcn->ST_FindObjects(sltp->TokData, &rSession, phObject,",
          "1637:                                  ulMaxObjectCount, pulObjectCount);",
          "1638:         TRACE_DEVEL(\"fcn->ST_FindObjects returned:0x%lx\\n\", rv);",
          "1639:     } else {",
          "1640:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1641:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1713:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1718:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1683:         return CKR_TOKEN_NOT_PRESENT;",
          "1684:     }",
          "1685:     if (fcn->ST_FindObjectsFinal) {",
          "1687:         rv = fcn->ST_FindObjectsFinal(sltp->TokData, &rSession);",
          "1688:         TRACE_DEVEL(\"fcn->ST_FindObjectsFinal returned: 0x%lx\\n\", rv);",
          "1689:     } else {",
          "1690:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1691:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1766:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1770:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1736:         return CKR_TOKEN_NOT_PRESENT;",
          "1737:     }",
          "1738:     if (fcn->ST_FindObjectsInit) {",
          "1740:         rv = fcn->ST_FindObjectsInit(sltp->TokData, &rSession,",
          "1741:                                      pTemplate, ulCount);",
          "1742:         TRACE_DEVEL(\"fcn->ST_FindObjectsInit returned:0x%lx\\n\", rv);",
          "1743:     } else {",
          "1744:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1745:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1821:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1826:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1794:         return CKR_TOKEN_NOT_PRESENT;",
          "1795:     }",
          "1796:     if (fcn->ST_GenerateKey) {",
          "1798:         rv = fcn->ST_GenerateKey(sltp->TokData, &rSession, pMechanism,",
          "1799:                                  pTemplate, ulCount, phKey);",
          "1800:         TRACE_DEVEL(\"fcn->ST_GenerateKey returned:0x%lx\\n\", rv);",
          "1801:     } else {",
          "1802:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1803:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1881:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "1886:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1861:         return CKR_TOKEN_NOT_PRESENT;",
          "1862:     }",
          "1863:     if (fcn->ST_GenerateKeyPair) {",
          "1865:         rv = fcn->ST_GenerateKeyPair(sltp->TokData, &rSession,",
          "1866:                                      pMechanism,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1950:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1870:                                      ulPrivateKeyAttributeCount,",
          "1871:                                      phPublicKey, phPrivateKey);",
          "1872:         TRACE_DEVEL(\"fcn->ST_GenerateKeyPair returned:0x%lx\\n\", rv);",
          "1873:     } else {",
          "1874:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1875:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1960:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1917:         return CKR_TOKEN_NOT_PRESENT;",
          "1918:     }",
          "1919:     if (fcn->ST_GenerateRandom) {",
          "1921:         rv = fcn->ST_GenerateRandom(sltp->TokData, &rSession,",
          "1922:                                     RandomData, ulRandomLen);",
          "1923:         TRACE_DEVEL(\"fcn->ST_GenerateRandom returned:0x%lx\\n\", rv);",
          "1924:     } else {",
          "1925:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1926:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2008:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "2013:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1977:         return CKR_TOKEN_NOT_PRESENT;",
          "1978:     }",
          "1979:     if (fcn->ST_GetAttributeValue) {",
          "1981:         rv = fcn->ST_GetAttributeValue(sltp->TokData, &rSession,",
          "1982:                                        hObject, pTemplate, ulCount);",
          "1983:         TRACE_DEVEL(\"fcn->ST_GetAttributeValue returned:0x%lx\\n\", rv);",
          "1984:     } else {",
          "1985:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "1986:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2070:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "2075:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2098:         return CKR_TOKEN_NOT_PRESENT;",
          "2099:     }",
          "2100:     if (fcn->ST_GetMechanismInfo) {",
          "2101:         rv = fcn->ST_GetMechanismInfo(sltp->TokData, slotID, type, pInfo);",
          "2102:         TRACE_DEVEL(\"fcn->ST_GetMechanismInfo returned:0x%lx\\n\", rv);",
          "2103:     } else {",
          "2104:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "2105:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2193:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "2196:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2156:         return CKR_TOKEN_NOT_PRESENT;",
          "2157:     }",
          "2158:     if (fcn->ST_GetMechanismList) {",
          "2159:         rv = fcn->ST_GetMechanismList(sltp->TokData, slotID,",
          "2160:                                       pMechanismList, pulCount);",
          "2161:         TRACE_DEVEL(\"fcn->ST_GetMechanismList returned: 0x%lx\\n\", rv);",
          "2162:     } else {",
          "2163:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "2164:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2253:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "2257:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2220:         return CKR_TOKEN_NOT_PRESENT;",
          "2221:     }",
          "2222:     if (fcn->ST_GetObjectSize) {",
          "2224:         rv = fcn->ST_GetObjectSize(sltp->TokData, &rSession, hObject, pulSize);",
          "2225:         TRACE_DEVEL(\"fcn->ST_GetObjectSize retuned: 0x%lx\\n\", rv);",
          "2226:     } else {",
          "2227:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "2228:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2319:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "2323:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2272:         return CKR_TOKEN_NOT_PRESENT;",
          "2273:     }",
          "2274:     if (fcn->ST_GetOperationState) {",
          "2276:         rv = fcn->ST_GetOperationState(sltp->TokData, &rSession,",
          "2277:                                        pOperationState, pulOperationStateLen);",
          "2278:         TRACE_DEVEL(\"fcn->ST_GetOperationState returned:0x%lx\\n\", rv);",
          "2279:     } else {",
          "2280:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "2281:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2373:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "2378:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2328:         return CKR_TOKEN_NOT_PRESENT;",
          "2329:     }",
          "2330:     if (fcn->ST_GetSessionInfo) {",
          "2332:         rv = fcn->ST_GetSessionInfo(sltp->TokData, &rSession, pInfo);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2431:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "2335:         TRACE_DEVEL(\"Slot %lu  State %lx  Flags %lx DevErr %lx\\n\",",
          "2336:                     pInfo->slotID, pInfo->state, pInfo->flags,",
          "2337:                     pInfo->ulDeviceError);",
          "2339:     } else {",
          "2340:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2439:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2650:         return CKR_TOKEN_NOT_PRESENT;",
          "2651:     }",
          "2652:     if (fcn->ST_GetTokenInfo) {",
          "2653:         rv = fcn->ST_GetTokenInfo(sltp->TokData, slotID, pInfo);",
          "2654:         if (rv == CKR_OK) {",
          "2655:             get_sess_count(slotID, &(pInfo->ulSessionCount));",
          "2656:         }",
          "2657:         TRACE_DEVEL(\"rv %lu CK_TOKEN_INFO Flags %lx\\n\", rv, pInfo->flags);",
          "2658:     } else {",
          "2659:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "2660:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2755:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "2761:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2814:     bt_init(&Anchor->sess_btree, free);",
          "2815:     Anchor->Pid = getpid();",
          "2818:     if ((Anchor->SharedMemP = attach_shared_memory()) == NULL) {",
          "2819:         OCK_SYSLOG(LOG_ERR, \"C_Initialize: Module failed to attach to \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2921: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "2934:     Anchor->openssl_libctx = OSSL_LIB_CTX_new();",
          "2935:     if (Anchor->openssl_libctx == NULL) {",
          "2936:         TRACE_ERROR(\"OSSL_LIB_CTX_new failed.\\n\");",
          "2937:         rc = CKR_FUNCTION_FAILED;",
          "2938:         goto error;",
          "2939:     }",
          "2941:     Anchor->openssl_default_provider =",
          "2942:                     OSSL_PROVIDER_load(Anchor->openssl_libctx, \"default\");",
          "2943:     if (Anchor->openssl_default_provider == NULL) {",
          "2944:         TRACE_ERROR(\"OSSL_PROVIDER_load for 'default' failed.\\n\");",
          "2945:         rc = CKR_FUNCTION_FAILED;",
          "2946:         goto error;",
          "2947:     }",
          "2948: #endif",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2870:     }",
          "2873:     for (slotID = 0; slotID < NUMBER_SLOTS_MANAGED; slotID++) {",
          "2874:         sltp = &(Anchor->SltList[slotID]);",
          "2875:         slot_loaded[slotID] = DL_Load_and_Init(sltp, slotID);",
          "2876:     }",
          "2879:     if ((Anchor->SocketDataP.flags & FLAG_EVENT_SUPPORT_DISABLED) == 0 &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3006:     BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rc)",
          "3011:     END_OPENSSL_LIBCTX(rc)",
          "3012:     if (rc != CKR_OK)",
          "3013:         goto error_shm;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2886:         for (slotID = 0; slotID < NUMBER_SLOTS_MANAGED; slotID++) {",
          "2887:             sltp = &(Anchor->SltList[slotID]);",
          "2888:             if (slot_loaded[slotID]) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3023:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rc)",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2895:             }",
          "2896:             DL_UnLoad(sltp, slotID);",
          "2897:         }",
          "2899:         API_UnRegister();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3036:         END_OPENSSL_LIBCTX(rc)",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2913:     if (Anchor->socketfd >= 0)",
          "2914:         close(Anchor->socketfd);",
          "2916:     free((void *) Anchor);",
          "2917:     Anchor = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3055: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "3056:     if (Anchor->openssl_default_provider != NULL)",
          "3057:         OSSL_PROVIDER_unload(Anchor->openssl_default_provider);",
          "3058:     if (Anchor->openssl_libctx != NULL)",
          "3059:         OSSL_LIB_CTX_free(Anchor->openssl_libctx);",
          "3060: #endif",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2974:         return CKR_TOKEN_NOT_PRESENT;",
          "2975:     }",
          "2976:     if (fcn->ST_InitPIN) {",
          "2978:         rv = fcn->ST_InitPIN(sltp->TokData, &rSession, pPin, ulPinLen);",
          "2979:         TRACE_DEVEL(\"fcn->ST_InitPIN returned: 0x%lx\\n\", rv);",
          "2980:     } else {",
          "2981:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "2982:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3123:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3127:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3042:         return CKR_TOKEN_NOT_PRESENT;",
          "3043:     }",
          "3044:     if (fcn->ST_InitToken) {",
          "3045:         rv = fcn->ST_InitToken(sltp->TokData, slotID, pPin, ulPinLen, pLabel);",
          "3046:         TRACE_DEVEL(\"fcn->ST_InitToken returned: 0x%lx\\n\", rv);",
          "3047:     } else {",
          "3048:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3049:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3193:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3196:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3097:         return CKR_TOKEN_NOT_PRESENT;",
          "3098:     }",
          "3099:     if (fcn->ST_Login) {",
          "3101:         rv = fcn->ST_Login(sltp->TokData, &rSession, userType, pPin, ulPinLen);",
          "3102:         TRACE_DEVEL(\"fcn->ST_Login returned:0x%lx\\n\", rv);",
          "3103:     } else {",
          "3104:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3105:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3250:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3254:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3147:         return CKR_TOKEN_NOT_PRESENT;",
          "3148:     }",
          "3149:     if (fcn->ST_Logout) {",
          "3151:         rv = fcn->ST_Logout(sltp->TokData, &rSession);",
          "3152:         TRACE_DEVEL(\"fcn->ST_Logout returned:0x%lx\\n\", rv);",
          "3153:     } else {",
          "3154:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3155:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3302:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3306:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3223:     }",
          "3225:     if (fcn->ST_OpenSession) {",
          "3226:         rv = fcn->ST_OpenSession(sltp->TokData, slotID, flags,",
          "3227:                                  &(apiSessp->sessionh));",
          "3228:         TRACE_DEVEL(\"fcn->ST_OpenSession returned: 0x%lx\\n\", rv);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3380:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3384:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3239:             if (*phSession == 0) {",
          "3243:                 fcn->ST_CloseSession(sltp->TokData, apiSessp, FALSE);",
          "3244:                 free(apiSessp);",
          "3245:                 rv = CKR_HOST_MEMORY;",
          "3246:                 goto done;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3396:                 BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3401:                 END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3310:         return CKR_TOKEN_NOT_PRESENT;",
          "3311:     }",
          "3312:     if (fcn->ST_SeedRandom) {",
          "3314:         rv = fcn->ST_SeedRandom(sltp->TokData, &rSession, pSeed, ulSeedLen);",
          "3315:         TRACE_DEVEL(\"fcn->ST_SeedRandom returned: 0x%lx\\n\", rv);",
          "3316:     } else {",
          "3317:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3318:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3471:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3475:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3371:         return CKR_TOKEN_NOT_PRESENT;",
          "3372:     }",
          "3373:     if (fcn->ST_SetAttributeValue) {",
          "3375:         rv = fcn->ST_SetAttributeValue(sltp->TokData, &rSession,",
          "3376:                                        hObject, pTemplate, ulCount);",
          "3377:         TRACE_DEVEL(\"fcn->ST_SetAttributeValue returned:0x%lx\\n\", rv);",
          "3378:     } else {",
          "3379:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3380:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3534:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3539:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "3426:         return CKR_TOKEN_NOT_PRESENT;",
          "3427:     }",
          "3428:     if (fcn->ST_SetOperationState) {",
          "3430:         rv = fcn->ST_SetOperationState(sltp->TokData, &rSession,",
          "3431:                                        pOperationState,",
          "3432:                                        ulOperationStateLen,",
          "3433:                                        hEncryptionKey, hAuthenticationKey);",
          "3434:         TRACE_DEVEL(\"fcn->ST_SetOperationState returned:0x%lx\\n\", rv);",
          "3435:     } else {",
          "3436:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3437:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3591:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3598:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "3486:         return CKR_TOKEN_NOT_PRESENT;",
          "3487:     }",
          "3488:     if (fcn->ST_SetPIN) {",
          "3490:         rv = fcn->ST_SetPIN(sltp->TokData, &rSession, pOldPin,",
          "3491:                             ulOldLen, pNewPin, ulNewLen);",
          "3492:         TRACE_DEVEL(\"fcn->ST_SetPIN returned: 0x%lx\\n\", rv);",
          "3493:     } else {",
          "3494:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3495:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3653:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3658:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "3540:         return CKR_TOKEN_NOT_PRESENT;",
          "3541:     }",
          "3542:     if (fcn->ST_Sign) {",
          "3544:         rv = fcn->ST_Sign(sltp->TokData, &rSession, pData, ulDataLen,",
          "3545:                           pSignature, pulSignatureLen);",
          "3546:         TRACE_DEVEL(\"fcn->ST_Sign returned: 0x%lx\\n\", rv);",
          "3547:     } else {",
          "3548:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3549:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3709:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3714:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "3590:         return CKR_TOKEN_NOT_PRESENT;",
          "3591:     }",
          "3592:     if (fcn->ST_SignEncryptUpdate) {",
          "3594:         rv = fcn->ST_SignEncryptUpdate(sltp->TokData, &rSession, pPart,",
          "3595:                                        ulPartLen, pEncryptedPart,",
          "3596:                                        pulEncryptedPartLen);",
          "3597:         TRACE_DEVEL(\"fcn->ST_SignEncryptUpdate return: 0x%lx\\n\", rv);",
          "3598:     } else {",
          "3599:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3600:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3761:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3767:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "3642:         return CKR_TOKEN_NOT_PRESENT;",
          "3643:     }",
          "3644:     if (fcn->ST_SignFinal) {",
          "3646:         rv = fcn->ST_SignFinal(sltp->TokData, &rSession, pSignature,",
          "3647:                                pulSignatureLen);",
          "3648:         TRACE_DEVEL(\"fcn->ST_SignFinal returned: 0x%lx\\n\", rv);",
          "3649:     } else {",
          "3650:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3651:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3815:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3820:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "3697:         return CKR_TOKEN_NOT_PRESENT;",
          "3698:     }",
          "3699:     if (fcn->ST_SignInit) {",
          "3701:         rv = fcn->ST_SignInit(sltp->TokData, &rSession, pMechanism, hKey);",
          "3702:         TRACE_DEVEL(\"fcn->ST_SignInit returned: 0x%lx\\n\", rv);",
          "3703:     } else {",
          "3704:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3705:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3872:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3876:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "3745:         return CKR_TOKEN_NOT_PRESENT;",
          "3746:     }",
          "3747:     if (fcn->ST_SignRecover) {",
          "3749:         rv = fcn->ST_SignRecover(sltp->TokData, &rSession, pData,",
          "3750:                                  ulDataLen, pSignature, pulSignatureLen);",
          "3751:         TRACE_DEVEL(\"fcn->ST_SignRecover returned:0x%lx\\n\", rv);",
          "3752:     } else {",
          "3753:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3754:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3922:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3927:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "3796:         return CKR_TOKEN_NOT_PRESENT;",
          "3797:     }",
          "3798:     if (fcn->ST_SignRecoverInit) {",
          "3800:         rv = fcn->ST_SignRecoverInit(sltp->TokData, &rSession,",
          "3801:                                      pMechanism, hKey);",
          "3802:         TRACE_DEVEL(\"fcn->ST_SignRecoverInit returned: 0x%lx\\n\", rv);",
          "3803:     } else {",
          "3804:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3805:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3975:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "3980:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "3847:         return CKR_TOKEN_NOT_PRESENT;",
          "3848:     }",
          "3849:     if (fcn->ST_SignUpdate) {",
          "3851:         rv = fcn->ST_SignUpdate(sltp->TokData, &rSession, pPart, ulPartLen);",
          "3852:         TRACE_DEVEL(\"fcn->ST_SignUpdate returned: 0x%lx\\n\", rv);",
          "3853:     } else {",
          "3854:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3855:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4028:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4032:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "3910:         return CKR_TOKEN_NOT_PRESENT;",
          "3911:     }",
          "3912:     if (fcn->ST_UnwrapKey) {",
          "3914:         rv = fcn->ST_UnwrapKey(sltp->TokData, &rSession, pMechanism,",
          "3915:                                hUnwrappingKey, pWrappedKey,",
          "3916:                                ulWrappedKeyLen, pTemplate,",
          "3917:                                ulAttributeCount, phKey);",
          "3918:         TRACE_DEVEL(\"fcn->ST_UnwrapKey returned: 0x%lx\\n\", rv);",
          "3919:     } else {",
          "3920:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3921:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4093:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4100:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "3962:         return CKR_TOKEN_NOT_PRESENT;",
          "3963:     }",
          "3964:     if (fcn->ST_Verify) {",
          "3966:         rv = fcn->ST_Verify(sltp->TokData, &rSession, pData, ulDataLen,",
          "3967:                             pSignature, ulSignatureLen);",
          "3968:         TRACE_DEVEL(\"fcn->ST_Verify returned: 0x%lx\\n\", rv);",
          "3969:     } else {",
          "3970:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "3971:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4147:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4152:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "4009:         return CKR_TOKEN_NOT_PRESENT;",
          "4010:     }",
          "4011:     if (fcn->ST_VerifyFinal) {",
          "4013:         rv = fcn->ST_VerifyFinal(sltp->TokData, &rSession, pSignature,",
          "4014:                                  ulSignatureLen);",
          "4015:         TRACE_DEVEL(\"fcn->ST_VerifyFinal returned: 0x%lx\\n\", rv);",
          "4016:     } else {",
          "4017:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "4018:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4196:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4201:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "4060:         return CKR_TOKEN_NOT_PRESENT;",
          "4061:     }",
          "4062:     if (fcn->ST_VerifyInit) {",
          "4064:         rv = fcn->ST_VerifyInit(sltp->TokData, &rSession, pMechanism, hKey);",
          "4065:         TRACE_DEVEL(\"fcn->ST_VerifyInit returned: 0x%lx\\n\", rv);",
          "4066:     } else {",
          "4067:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "4068:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4249:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4253:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "4109:         return CKR_TOKEN_NOT_PRESENT;",
          "4110:     }",
          "4111:     if (fcn->ST_VerifyRecover) {",
          "4113:         rv = fcn->ST_VerifyRecover(sltp->TokData, &rSession, pSignature,",
          "4114:                                    ulSignatureLen, pData, pulDataLen);",
          "4115:         TRACE_DEVEL(\"fcn->ST_VerifyRecover returned: 0x%lx\\n\", rv);",
          "4116:     } else {",
          "4117:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "4118:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4300:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4305:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "4160:         return CKR_TOKEN_NOT_PRESENT;",
          "4161:     }",
          "4162:     if (fcn->ST_VerifyRecoverInit) {",
          "4164:         rv = fcn->ST_VerifyRecoverInit(sltp->TokData, &rSession,",
          "4165:                                        pMechanism, hKey);",
          "4166:         TRACE_DEVEL(\"fcn->ST_VerifyRecoverInit returned:0x%lx\\n\", rv);",
          "4167:     } else {",
          "4168:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "4169:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4353:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4358:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "4207:         return CKR_TOKEN_NOT_PRESENT;",
          "4208:     }",
          "4209:     if (fcn->ST_VerifyUpdate) {",
          "4211:         rv = fcn->ST_VerifyUpdate(sltp->TokData, &rSession, pPart, ulPartLen);",
          "4212:         TRACE_DEVEL(\"fcn->ST_VerifyUpdate returned: 0x%lx\\n\", rv);",
          "4213:     } else {",
          "4214:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "4215:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4402:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4406:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "4407:         return CKR_TOKEN_NOT_PRESENT;",
          "4408:     }",
          "4409:     if (fcn->ST_WrapKey) {",
          "4411:         rv = fcn->ST_WrapKey(sltp->TokData, &rSession, pMechanism,",
          "4412:                              hWrappingKey, hKey, pWrappedKey, pulWrappedKeyLen);",
          "4413:         TRACE_DEVEL(\"fcn->ST_WrapKey returned: 0x%lx\\n\", rv);",
          "4414:     } else {",
          "4415:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "4416:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4604:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "4609:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "5110:         return CKR_TOKEN_NOT_PRESENT;",
          "5111:     }",
          "5112:     if (fcn->ST_IBM_ReencryptSingle) {",
          "5114:         rv = fcn->ST_IBM_ReencryptSingle(sltp->TokData, &rSession, pDecrMech,",
          "5115:                                          hDecrKey, pEncrMech, hEncrKey,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5309:         BEGIN_OPENSSL_LIBCTX(Anchor->openssl_libctx, rv)",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "5117:                                          pReencryptedData,",
          "5118:                                          pulReencryptedDataLen);",
          "5119:         TRACE_DEVEL(\"fcn->ST_IBM_ReencryptSingle returned: 0x%lx\\n\", rv);",
          "5120:     } else {",
          "5121:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_NOT_SUPPORTED));",
          "5122:         rv = CKR_FUNCTION_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5317:         END_OPENSSL_LIBCTX(rv)",
          "",
          "---------------"
        ],
        "usr/lib/api/socket_client.c||usr/lib/api/socket_client.c": [
          "File: usr/lib/api/socket_client.c -> usr/lib/api/socket_client.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "245:     return 0;",
          "246: }",
          "248: static void event_thread_cleanup(void *arg)",
          "249: {",
          "254:     TRACE_DEVEL(\"Event thread %lu terminating\\n\", pthread_self());",
          "255: }",
          "",
          "[Removed Lines]",
          "250:     API_Proc_Struct_t *anchor = arg;",
          "252:     UNUSED(anchor);",
          "",
          "[Added Lines]",
          "248: struct cleanup_data {",
          "249:     API_Proc_Struct_t *anchor;",
          "250: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "251:     OSSL_LIB_CTX *prev_libctx;",
          "252: #endif",
          "253: };",
          "257:     struct cleanup_data *cleanup = arg;",
          "259: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "260:     OSSL_LIB_CTX_set0_default(cleanup->prev_libctx);",
          "261: #else",
          "262:     UNUSED(cleanup);",
          "263: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "257: static void *event_thread(void *arg)",
          "258: {",
          "259:     API_Proc_Struct_t *anchor = arg;",
          "260:     int oldstate, oldtype;",
          "261:     struct pollfd pollfd;",
          "262:     event_msg_t event;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "271:     struct cleanup_data cleanup;",
          "272: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "273:     OSSL_LIB_CTX *prev_libctx;",
          "274: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "275:         return NULL;",
          "276:     }",
          "279:     pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);",
          "280:     pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);",
          "283:     pollfd.fd = anchor->socketfd;",
          "284:     pollfd.events = POLLIN | POLLHUP | POLLERR;",
          "",
          "[Removed Lines]",
          "281:     pthread_cleanup_push(event_thread_cleanup, anchor);",
          "",
          "[Added Lines]",
          "293: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "295:     prev_libctx = OSSL_LIB_CTX_set0_default(Anchor->openssl_libctx);",
          "296:     if (prev_libctx == NULL) {",
          "297:         TRACE_ERROR(\"OSSL_LIB_CTX_set0_default failed\\n\");",
          "298:         TRACE_DEVEL(\"Event thread %lu terminating\\n\", pthread_self());",
          "299:         return NULL;",
          "300:     }",
          "301: #endif",
          "306:     cleanup.anchor = anchor;",
          "307: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "308:     cleanup.prev_libctx = prev_libctx;",
          "309: #endif",
          "310:     pthread_cleanup_push(event_thread_cleanup, &cleanup);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "395:     close(anchor->socketfd);",
          "396:     anchor->socketfd = -1;",
          "398:     pthread_cleanup_pop(1);",
          "399:     return NULL;",
          "400: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "427: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "428:     OSSL_LIB_CTX_set0_default(prev_libctx);",
          "429: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "075902a641dc285d90d0ccd9c0259b8298dc71e9",
      "candidate_info": {
        "commit_hash": "075902a641dc285d90d0ccd9c0259b8298dc71e9",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/075902a641dc285d90d0ccd9c0259b8298dc71e9",
        "files": [
          "usr/lib/common/h_extern.h",
          "usr/lib/common/mech_ec.c",
          "usr/lib/ep11_stdll/ep11_specific.c"
        ],
        "message": "Key derivation via CKM_ECDH1_DERIVE: Make CKA_VALUE_LEN optional\n\nPKCS#11 states: 'This mechanism derives a secret value, and truncates\nthe result according to the CKA_KEY_TYPE attribute of the template and,\nif it has one and the key type supports it, the CKA_VALUE_LEN attribute\nof the template. (The truncation removes bytes from the leading end of\nthe secret value.)'\n\nThis implies that CKA_VALUE_LEN is optional. If not specified,\nthe key type determines the derived key size, or a default is used.\nWhen no KDF is specified in the mechanism parameter, the size of the\nderived secret is used as the key size, otherwise the digest size of\nthe KDF is used.\n\nFor keys of type CKK_AES the derived key size must be one of the 3 possible\nAES key sizes, otherwise the function fails.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/common/h_extern.h||usr/lib/common/h_extern.h",
          "usr/lib/common/mech_ec.c||usr/lib/common/mech_ec.c",
          "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/common/h_extern.h||usr/lib/common/h_extern.h": [
          "File: usr/lib/common/h_extern.h -> usr/lib/common/h_extern.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "841: CK_RV pkcs_get_keytype(CK_ATTRIBUTE *attrs, CK_ULONG attrs_len,",
          "842:                        CK_MECHANISM_PTR mech, CK_ULONG *type, CK_ULONG *class);",
          "844: CK_RV ecdh_pkcs_derive(STDLL_TokData_t *tokdata, SESSION *sess,",
          "845:                  CK_MECHANISM *mech, CK_OBJECT_HANDLE base_key,",
          "846:                  CK_ATTRIBUTE *pTemplate, CK_ULONG ulCount,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "844: CK_RV ecdh_get_derived_key_size(CK_ULONG prime_len, CK_BYTE *curve_oid,",
          "845:                                 CK_ULONG curve_oid_len, CK_EC_KDF_TYPE kdf,",
          "846:                                 CK_ULONG key_type, CK_ULONG value_len,",
          "847:                                 CK_ULONG *key_len);",
          "",
          "---------------"
        ],
        "usr/lib/common/mech_ec.c||usr/lib/common/mech_ec.c": [
          "File: usr/lib/common/mech_ec.c -> usr/lib/common/mech_ec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1116:     }",
          "1117: }",
          "1119: CK_RV ecdh_pkcs_derive(STDLL_TokData_t *tokdata, SESSION *sess,",
          "1120:                        CK_MECHANISM *mech, CK_OBJECT_HANDLE base_key,",
          "1121:                        CK_ATTRIBUTE *pTemplate, CK_ULONG ulCount,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1119: CK_RV ecdh_get_derived_key_size(CK_ULONG prime_len, CK_BYTE *curve_oid,",
          "1120:                                 CK_ULONG curve_oid_len, CK_EC_KDF_TYPE kdf,",
          "1121:                                 CK_ULONG key_type, CK_ULONG value_len,",
          "1122:                                 CK_ULONG *key_len)",
          "1123: {",
          "1124:     CK_RV rc;",
          "1125:     CK_ULONG key_len_type;",
          "1126:     CK_MECHANISM_TYPE digest_mech;",
          "1127:     int i;",
          "1130:     key_len_type = keylen_from_keytype(key_type);",
          "1132:     if (*key_len == 0) {",
          "1134:     } else if (key_len_type != 0 && *key_len != key_len_type) {",
          "1135:         TRACE_ERROR(\"Derived key length does not work for the key type\\n\");",
          "1136:         return CKR_TEMPLATE_INCONSISTENT;",
          "1137:     }",
          "1139:     if (prime_len == 0) {",
          "1140:         for (i = 0; i < NUMEC; i++) {",
          "1141:             if (der_ec_supported[i].data_size == curve_oid_len &&",
          "1142:                 memcmp(der_ec_supported[i].data, curve_oid,",
          "1143:                        curve_oid_len) == 0)",
          "1144:                 prime_len = (der_ec_supported[i].len_bits + 7) / 8;",
          "1145:         }",
          "1147:         if (prime_len == 0) {",
          "1148:             TRACE_ERROR(\"Curve not supported\\n\");",
          "1149:             return CKR_CURVE_NOT_SUPPORTED;",
          "1150:         }",
          "1151:     }",
          "1158:     if (*key_len == 0) {",
          "1160:         if (kdf != CKD_NULL) {",
          "1161:             rc = digest_from_kdf(kdf, &digest_mech);",
          "1162:             if (rc != CKR_OK) {",
          "1163:                 TRACE_ERROR(\"Cannot determine mech from kdf.\\n\");",
          "1164:                 return CKR_ARGUMENTS_BAD;",
          "1165:             }",
          "1166:             rc = get_sha_size(digest_mech, key_len);",
          "1167:             if (rc != CKR_OK) {",
          "1168:                 TRACE_ERROR(\"Cannot determine SHA digest size.\\n\");",
          "1169:                 return CKR_ARGUMENTS_BAD;",
          "1170:             }",
          "1171:         } else {",
          "1173:         }",
          "1175:         switch (key_type) {",
          "1176:         case CKK_AES:",
          "1177:             if (*key_len != AES_KEY_SIZE_128 &&",
          "1180:                 TRACE_ERROR(\"Derived key length does not work for the key \"",
          "1181:                             \"type\\n\");",
          "1182:                 return CKR_TEMPLATE_INCONSISTENT;",
          "1183:             }",
          "1184:             break;",
          "1185:         default:",
          "1187:             break;",
          "1188:         }",
          "1189:     }",
          "1192:     if (kdf == CKD_NULL && *key_len > prime_len) {",
          "1193:         TRACE_ERROR(\"Can only provide %ld key bytes without a KDF, \"",
          "1194:                     \"but %ld bytes requested.\\n\", prime_len, *key_len);",
          "1195:         return CKR_ARGUMENTS_BAD;",
          "1196:     }",
          "1198:     return CKR_OK;",
          "1199: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1157:         return CKR_TEMPLATE_INCOMPLETE;",
          "1158:     }",
          "1177:     if (pParms->kdf == CKD_NULL",
          "",
          "[Removed Lines]",
          "1161:     rc = get_ulong_attribute_by_type(pTemplate, ulCount, CKA_VALUE_LEN,",
          "1162:                                      &key_len);",
          "1163:     if (rc == CKR_ATTRIBUTE_VALUE_INVALID) {",
          "1164:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_ATTRIBUTE_VALUE_INVALID));",
          "1165:         return rc;",
          "1166:     }",
          "1168:     if (key_len == 0) {",
          "1169:         key_len = keylen_from_keytype(keytype);",
          "1170:         if (key_len == 0) {",
          "1171:             TRACE_ERROR(\"Derived key length not specified in template.\\n\");",
          "1172:             return CKR_TEMPLATE_INCOMPLETE;",
          "1173:         }",
          "1174:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1189:         return rc;",
          "1190:     }",
          "1198:     }",
          "",
          "[Removed Lines]",
          "1193:     if (pParms->kdf == CKD_NULL && key_len > z_len) {",
          "1194:         TRACE_ERROR(\"Can only provide %ld key bytes without a KDF, \"",
          "1195:                     \"but %ld bytes requested.\\n\",",
          "1196:                     (pParms->ulPublicDataLen / 2), key_len);",
          "1197:         return CKR_ARGUMENTS_BAD;",
          "",
          "[Added Lines]",
          "1260:     rc = get_ulong_attribute_by_type(pTemplate, ulCount, CKA_VALUE_LEN,",
          "1261:                                      &key_len);",
          "1262:     if (rc == CKR_ATTRIBUTE_VALUE_INVALID) {",
          "1263:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_ATTRIBUTE_VALUE_INVALID));",
          "1264:         return rc;",
          "1265:     }",
          "1267:     rc = ecdh_get_derived_key_size(z_len, NULL, 0, pParms->kdf, keytype,",
          "1268:                                    key_len, &key_len);",
          "1269:     if (rc != CKR_OK) {",
          "1270:         TRACE_ERROR(\"Can not determine the derived key length\\n\");",
          "1271:         return rc;",
          "",
          "---------------"
        ],
        "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c": [
          "File: usr/lib/ep11_stdll/ep11_specific.c -> usr/lib/ep11_stdll/ep11_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3723:     size_t newblobsize = sizeof(newblob);",
          "3724:     CK_BYTE csum[MAX_BLOBSIZE];",
          "3725:     CK_ULONG cslen = sizeof(csum);",
          "3727:     OBJECT *base_key_obj = NULL;",
          "3728:     OBJECT *key_obj = NULL;",
          "3729:     CK_ULONG ktype;",
          "",
          "[Removed Lines]",
          "3726:     CK_ATTRIBUTE *opaque_attr = NULL, *chk_attr = NULL;",
          "",
          "[Added Lines]",
          "3726:     CK_ATTRIBUTE *opaque_attr = NULL, *chk_attr = NULL, *ec_parms_attr = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3733:     unsigned char *ep11_pin_blob = NULL;",
          "3734:     CK_ULONG ep11_pin_blob_len = 0;",
          "3735:     ep11_session_t *ep11_session = (ep11_session_t *) session->private_data;",
          "3737:     CK_ECDH1_DERIVE_PARAMS ecdh1_parms2;",
          "3738:     CK_MECHANISM ecdh1_mech, ecdh1_mech2;",
          "3739:     CK_BYTE *ecpoint;",
          "3742:     memset(newblob, 0, sizeof(newblob));",
          "",
          "[Removed Lines]",
          "3736:     CK_ECDH1_DERIVE_PARAMS *ecdh1_parms;",
          "3740:     CK_ULONG ecpoint_len, field_len;",
          "",
          "[Added Lines]",
          "3736:     CK_ECDH1_DERIVE_PARAMS *ecdh1_parms = NULL;",
          "3740:     CK_ULONG ecpoint_len, field_len, key_len = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3840:         goto error;",
          "3841:     }",
          "3843:     ep11_get_pin_blob(ep11_session, ep11_is_session_object(attrs, attrs_len),",
          "3844:                       &ep11_pin_blob, &ep11_pin_blob_len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3843:     if (mech->mechanism == CKM_ECDH1_DERIVE ||",
          "3844:         mech->mechanism == CKM_IBM_EC_X25519 ||",
          "3845:         mech->mechanism == CKM_IBM_EC_X448) {",
          "3847:         rc = template_attribute_get_non_empty(base_key_obj->template,",
          "3848:                                               CKA_EC_PARAMS,",
          "3849:                                               &ec_parms_attr);",
          "3850:         if (rc != CKR_OK) {",
          "3851:             TRACE_ERROR(\"Could not find CKA_EC_PARAMS in base key\\n\");",
          "3852:             return rc;",
          "3853:         }",
          "3856:         get_ulong_attribute_by_type(new_attrs, new_attrs_len, CKA_VALUE_LEN,",
          "3857:                                     &key_len);",
          "3859:         rc = ecdh_get_derived_key_size(0, ec_parms_attr->pValue,",
          "3860:                                        ec_parms_attr->ulValueLen,",
          "3861:                                        ecdh1_parms->kdf, ktype,",
          "3862:                                        key_len, &key_len);",
          "3863:         if (rc != CKR_OK) {",
          "3864:             TRACE_ERROR(\"Can not determine the derived key length\\n\");",
          "3865:             goto error;",
          "3866:         }",
          "3869:         if (get_attribute_by_type(new_attrs, new_attrs_len,",
          "3870:                                   CKA_VALUE_LEN) == NULL) {",
          "3871:             rc = add_to_attribute_array(&new_attrs, &new_attrs_len,",
          "3872:                                         CKA_VALUE_LEN, (CK_BYTE *)&key_len,",
          "3873:                                         sizeof(CK_ULONG));",
          "3874:             if (rc != CKR_OK) {",
          "3875:                 TRACE_ERROR(\"add_to_attribute_array failed\\n\");",
          "3876:                 goto error;",
          "3877:             }",
          "3878:         }",
          "3879:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7b773fe12cff0c06d03261baa4e1378556b6dcb1",
      "candidate_info": {
        "commit_hash": "7b773fe12cff0c06d03261baa4e1378556b6dcb1",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/7b773fe12cff0c06d03261baa4e1378556b6dcb1",
        "files": [
          "usr/lib/ep11_stdll/ep11_specific.c",
          "usr/lib/ica_s390_stdll/ica_specific.c",
          "usr/lib/soft_stdll/soft_specific.c"
        ],
        "message": "Fix detection of DER encoded or raw ECDH public data\n\nFrom PKCS#11: \"pPublicData: pointer to other party\u2019s EC public\nkey value. A token MUST be able to accept this value encoded as\na raw octet string (as per section A.5.2 of [ANSI X9.62]). A\ntoken MAY, in addition, support accepting this value as a DER-\nencoded ECPoint (as per section E.6 of [ANSI X9.62]) i.e. the\nsame as a CKA_EC_POINT encoding.\"\n\nIt can happen that the specified  public data looks like it would\nbe an DER encoded ECPoint, but in fact it is not. This happens when\nthe public data starts with 0x04 (either an OCTET STRING DER tag,\nor a point conversion indicator byte for \"uncompressed\") followed\nby a byte who's value is 2 less than the length of the public data.\nThat way the second byte looks like a valid single-byte length octet\nof a DER encoded tag.\n\nAdd an additional check if the resulting length after DER decoding\nis less than expected (2 times prime length of the curve plus one\nformat conversion byte). If so, then check if the raw length would\nfit better, and use it as raw if the raw length is exactly the\nexpected length.\n\nNote that OCK also supports ECPoints without a format conversion byte,\nso we can not simply always check for the expected length.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c",
          "usr/lib/ica_s390_stdll/ica_specific.c||usr/lib/ica_s390_stdll/ica_specific.c",
          "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
          ],
          "candidate": [
            "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
          ]
        }
      },
      "candidate_diff": {
        "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c": [
          "File: usr/lib/ep11_stdll/ep11_specific.c -> usr/lib/ep11_stdll/ep11_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #include <ica_api.h>",
          "58: #include <openssl/crypto.h>",
          "60: #include \"ep11_func.h\"",
          "61: #include \"ep11_specific.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: #include <openssl/ec.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4916:     CK_ULONG ecpoint_len, field_len, key_len = 0;",
          "4917:     CK_ATTRIBUTE *new_attrs2 = NULL;",
          "4918:     CK_ULONG new_attrs2_len = 0;",
          "4919:     int curve_type;",
          "4921:     memset(newblob, 0, sizeof(newblob));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4920:     CK_ULONG privlen;",
          "4922:     CK_BYTE form;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4955:                 ecpoint_len = ecdh1_parms->ulPublicDataLen;",
          "4956:             }",
          "4958:             ecdh1_parms2.pPublicData = ecpoint;",
          "4959:             ecdh1_parms2.ulPublicDataLen = ecpoint_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4961:             rc = h_opaque_2_blob(tokdata, hBaseKey, &keyblob, &keyblobsize,",
          "4962:                                  &base_key_obj, READ_LOCK);",
          "4963:             if (rc != CKR_OK) {",
          "4964:                 TRACE_ERROR(\"%s failed hBaseKey=0x%lx\\n\", __func__, hBaseKey);",
          "4965:                 return rc;",
          "4966:             }",
          "4968:             rc = get_ecsiglen(base_key_obj, &privlen);",
          "4970:             object_put(tokdata, base_key_obj, TRUE);",
          "4971:             base_key_obj = NULL;",
          "4973:             if (rc != CKR_OK) {",
          "4974:                 TRACE_ERROR(\"%s get_ecsiglen failed\\n\", __func__);",
          "4975:                 return rc;",
          "4976:             }",
          "4977:             form  = ecpoint[0] & ~0x01;",
          "4978:             if (ecpoint_len <= 2 * privlen &&",
          "4979:                 form != POINT_CONVERSION_COMPRESSED &&",
          "4980:                 form != POINT_CONVERSION_UNCOMPRESSED &&",
          "4981:                 form != POINT_CONVERSION_HYBRID) {",
          "4983:                 if (ecpoint_len != ecdh1_parms->ulPublicDataLen &&",
          "4984:                     ecdh1_parms->ulPublicDataLen == 2 * privlen + 1) {",
          "4985:                     form  = ecdh1_parms->pPublicData[0] & ~0x01;",
          "4986:                     if (form == POINT_CONVERSION_COMPRESSED ||",
          "4987:                         form == POINT_CONVERSION_UNCOMPRESSED ||",
          "4988:                         form == POINT_CONVERSION_HYBRID) {",
          "4989:                         ecpoint = ecdh1_parms->pPublicData;",
          "4990:                         ecpoint_len = ecdh1_parms->ulPublicDataLen;",
          "4991:                     }",
          "4992:                 }",
          "4993:             }",
          "",
          "---------------"
        ],
        "usr/lib/ica_s390_stdll/ica_specific.c||usr/lib/ica_s390_stdll/ica_specific.c": [
          "File: usr/lib/ica_s390_stdll/ica_specific.c -> usr/lib/ica_s390_stdll/ica_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4694:     int rc, nid;",
          "4695:     CK_BYTE *ecpoint;",
          "4696:     CK_ULONG ecpoint_len, field_len;",
          "4698:     UNUSED(tokdata);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4697:     CK_BYTE form;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4733:         ecpoint_len = pub_length;",
          "4734:     }",
          "4737:     ret = set_pubkey_coordinates(nid, ecpoint, ecpoint_len,",
          "4738:                                  privlen, x_array, y_array);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4737:     form  = ecpoint[0] & ~0x01;",
          "4738:     if (ecpoint_len <= 2 * privlen &&",
          "4739:         form != POINT_CONVERSION_COMPRESSED &&",
          "4740:         form != POINT_CONVERSION_UNCOMPRESSED &&",
          "4741:         form != POINT_CONVERSION_HYBRID) {",
          "4743:         if (ecpoint_len != pub_length && pub_length == 2 * privlen + 1) {",
          "4744:             form  = pub_bytes[0] & ~0x01;",
          "4745:             if (form == POINT_CONVERSION_COMPRESSED ||",
          "4746:                 form == POINT_CONVERSION_UNCOMPRESSED ||",
          "4747:                 form == POINT_CONVERSION_HYBRID) {",
          "4748:                 ecpoint = pub_bytes;",
          "4749:                 ecpoint_len = pub_length;",
          "4750:             }",
          "4751:         }",
          "4752:     }",
          "",
          "---------------"
        ],
        "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c": [
          "File: usr/lib/soft_stdll/soft_specific.c -> usr/lib/soft_stdll/soft_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4371:         form != POINT_CONVERSION_COMPRESSED &&",
          "4372:         form != POINT_CONVERSION_UNCOMPRESSED &&",
          "4373:         form != POINT_CONVERSION_HYBRID) {",
          "4374:         temp = malloc(1 + 2 * privlen);",
          "4375:         if (temp == NULL) {",
          "4376:             rc = CKR_HOST_MEMORY;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4375:         if (ecpoint_len != data_len && data_len == 2 * privlen + 1) {",
          "4376:             form  = data[0] & ~0x01;",
          "4377:             if (form == POINT_CONVERSION_COMPRESSED ||",
          "4378:                 form == POINT_CONVERSION_UNCOMPRESSED ||",
          "4379:                 form == POINT_CONVERSION_HYBRID) {",
          "4380:                 ecpoint = (CK_BYTE *)data;",
          "4381:                 ecpoint_len = data_len;",
          "4382:                 goto parse;",
          "4383:             }",
          "4384:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4386:         ecpoint_len = 1 + 2 * privlen;",
          "4387:     }",
          "4389:     if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {",
          "4390:         TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");",
          "4391:         rc = CKR_FUNCTION_FAILED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4401: parse:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "484b6833e676a031607c6883c76b02389b09e120",
      "candidate_info": {
        "commit_hash": "484b6833e676a031607c6883c76b02389b09e120",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/484b6833e676a031607c6883c76b02389b09e120",
        "files": [
          "usr/lib/common/h_extern.h",
          "usr/lib/common/mech_openssl.c",
          "usr/lib/soft_stdll/soft_specific.c"
        ],
        "message": "SOFT: Extract EC functions to mech_openssl.c\n\nExtract the OpenSSL based EC keygen, sign, verify, and derive functions into\nfile mech_openssl.c, so that they can be used by other tokens as well.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/common/h_extern.h||usr/lib/common/h_extern.h",
          "usr/lib/common/mech_openssl.c||usr/lib/common/mech_openssl.c",
          "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
          ],
          "candidate": [
            "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
          ]
        }
      },
      "candidate_diff": {
        "usr/lib/common/h_extern.h||usr/lib/common/h_extern.h": [
          "File: usr/lib/common/h_extern.h -> usr/lib/common/h_extern.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <stdio.h>",
          "27: #include \"dlist.h\"",
          "31: #define SO_PIN_DEFAULT   \"87654321\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include <openssl/evp.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2885:                                         CK_ULONG *, CK_BYTE *, CK_ULONG,",
          "2886:                                         t_rsa_decrypt);",
          "2888: #include \"tok_spec_struct.h\"",
          "2889: extern token_spec_t token_specific;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2890: CK_RV openssl_make_ec_key_from_template(TEMPLATE *template, EVP_PKEY **pkey);",
          "2891: CK_RV openssl_specific_ec_generate_keypair(STDLL_TokData_t *tokdata,",
          "2892:                                            TEMPLATE *publ_tmpl,",
          "2893:                                            TEMPLATE *priv_tmpl);",
          "2894: CK_RV openssl_specific_ec_sign(STDLL_TokData_t *tokdata,  SESSION *sess,",
          "2895:                                CK_BYTE *in_data, CK_ULONG in_data_len,",
          "2896:                                CK_BYTE *out_data, CK_ULONG *out_data_len,",
          "2897:                                OBJECT *key_obj);",
          "2898: CK_RV openssl_specific_ec_verify(STDLL_TokData_t *tokdata,",
          "2899:                                  SESSION *sess,",
          "2900:                                  CK_BYTE *in_data,",
          "2901:                                  CK_ULONG in_data_len,",
          "2902:                                  CK_BYTE *signature,",
          "2903:                                  CK_ULONG signature_len, OBJECT *key_obj);",
          "2904: CK_RV openssl_specific_ecdh_pkcs_derive(STDLL_TokData_t *tokdata,",
          "2905:                                         CK_BYTE *priv_bytes,",
          "2906:                                         CK_ULONG priv_length,",
          "2907:                                         CK_BYTE *pub_bytes,",
          "2908:                                         CK_ULONG pub_length,",
          "2909:                                         CK_BYTE *secret_value,",
          "2910:                                         CK_ULONG *secret_value_len,",
          "2911:                                         CK_BYTE *oid, CK_ULONG oid_length);",
          "",
          "---------------"
        ],
        "usr/lib/common/mech_openssl.c||usr/lib/common/mech_openssl.c": [
          "File: usr/lib/common/mech_openssl.c -> usr/lib/common/mech_openssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"trace.h\"",
          "26: #include <openssl/crypto.h>",
          "27: #include <openssl/evp.h>",
          "28: #include <openssl/rsa.h>",
          "29: #include <openssl/bn.h>",
          "30: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "31: #include <openssl/core_names.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <openssl/err.h>",
          "30: #include <openssl/ec.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1696:     return rc;",
          "1697: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1702: #ifndef NO_EC",
          "1704: static int curve_nid_from_params(const CK_BYTE *params, CK_ULONG params_len)",
          "1705: {",
          "1706:     const unsigned char *oid;",
          "1707:     ASN1_OBJECT *obj = NULL;",
          "1708:     int nid;",
          "1710:     oid = params;",
          "1711:     obj = d2i_ASN1_OBJECT(NULL, &oid, params_len);",
          "1712:     if (obj == NULL || oid != params + params_len) {",
          "1713:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "1714:         return NID_undef;",
          "1715:     }",
          "1717:     nid = OBJ_obj2nid(obj);",
          "1718:     ASN1_OBJECT_free(obj);",
          "1720:     return nid;",
          "1721: }",
          "1723: static int ec_prime_len_from_nid(int nid)",
          "1724: {",
          "1725:     EC_GROUP *group;",
          "1726:     int primelen;",
          "1728:     group = EC_GROUP_new_by_curve_name(nid);",
          "1729:     if (group == NULL)",
          "1730:         return -1;",
          "1732:     primelen = EC_GROUP_order_bits(group);",
          "1734:     EC_GROUP_free(group);",
          "1736:     return (primelen + 7) / 8;",
          "1737: }",
          "1739: static int ec_prime_len_from_pkey(EVP_PKEY *pkey)",
          "1740: {",
          "1741: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "1742:     return (EC_GROUP_order_bits(EC_KEY_get0_group(",
          "1743:                              EVP_PKEY_get0_EC_KEY(pkey))) + 7) / 8;",
          "1744: #else",
          "1745:     size_t curve_len;",
          "1746:     char curve[80];",
          "1748:     if (!EVP_PKEY_get_utf8_string_param(pkey, OSSL_PKEY_PARAM_GROUP_NAME,",
          "1749:                                         curve, sizeof(curve), &curve_len))",
          "1750:         return -1;",
          "1752:     return ec_prime_len_from_nid(OBJ_sn2nid(curve));",
          "1753: #endif",
          "1754: }",
          "1757: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "1758: static CK_RV make_ec_key_from_params(const CK_BYTE *params, CK_ULONG params_len,",
          "1759:                                      EC_KEY **key)",
          "1760: {",
          "1761:     EC_KEY *ec_key = NULL;",
          "1762:     int nid;",
          "1763:     CK_RV rc = CKR_OK;",
          "1765:     nid = curve_nid_from_params(params, params_len);",
          "1766:     if (nid == NID_undef) {",
          "1767:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "1768:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "1769:         goto out;",
          "1770:     }",
          "1772:     ec_key = EC_KEY_new_by_curve_name(nid);",
          "1773:     if (ec_key == NULL) {",
          "1774:        TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "1775:        rc = CKR_CURVE_NOT_SUPPORTED;",
          "1776:        goto out;",
          "1777:     }",
          "1779: out:",
          "1780:     if (rc != CKR_OK) {",
          "1781:         if (ec_key != NULL)",
          "1782:             EC_KEY_free(ec_key);",
          "1784:         return rc;",
          "1785:     }",
          "1789:     return CKR_OK;",
          "1790: }",
          "1791: #endif",
          "1793: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "1794: static CK_RV build_pkey_from_params(OSSL_PARAM_BLD *tmpl, int selection,",
          "1795:                                     EVP_PKEY **pkey)",
          "1796: {",
          "1798:     OSSL_PARAM *params = NULL;",
          "1799:     EVP_PKEY_CTX *pctx = NULL;",
          "1800:     CK_RV rc = CKR_OK;",
          "1802:     params = OSSL_PARAM_BLD_to_param(tmpl);",
          "1803:     if (params == NULL) {",
          "1804:         TRACE_ERROR(\"OSSL_PARAM_BLD_to_param failed\\n\");",
          "1805:         rc = CKR_FUNCTION_FAILED;",
          "1806:         goto out;",
          "1807:     }",
          "1809:     pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);",
          "1810:     if (pctx == NULL) {",
          "1811:         TRACE_ERROR(\"EVP_PKEY_CTX_new_id failed\\n\");",
          "1812:         rc = CKR_FUNCTION_FAILED;",
          "1813:         goto out;",
          "1814:     }",
          "1816:     if (!EVP_PKEY_fromdata_init(pctx) ||",
          "1817:         !EVP_PKEY_fromdata(pctx, pkey, selection, params)) {",
          "1818:         TRACE_ERROR(\"EVP_PKEY_fromdata failed\\n\");",
          "1819:         rc = CKR_FUNCTION_FAILED;",
          "1820:         goto out;",
          "1821:     }",
          "1823:     EVP_PKEY_CTX_free(pctx);",
          "1824:     pctx = EVP_PKEY_CTX_new(*pkey, NULL);",
          "1825:     if (pctx == NULL) {",
          "1826:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "1827:         rc = CKR_FUNCTION_FAILED;",
          "1828:         goto out;",
          "1829:     }",
          "1831:     if (selection & OSSL_KEYMGMT_SELECT_PRIVATE_KEY) {",
          "1832:         if (EVP_PKEY_check(pctx) != 1) {",
          "1833:             TRACE_ERROR(\"EVP_PKEY_check failed\\n\");",
          "1834:             rc = CKR_FUNCTION_FAILED;",
          "1835:             goto out;",
          "1836:         }",
          "1837:     } else {",
          "1838:         if (EVP_PKEY_public_check(pctx) != 1) {",
          "1839:             TRACE_ERROR(\"EVP_PKEY_public_check failed\\n\");",
          "1840:             rc = CKR_FUNCTION_FAILED;",
          "1841:             goto out;",
          "1842:         }",
          "1843:     }",
          "1845: out:",
          "1846:     if (pctx != NULL)",
          "1847:         EVP_PKEY_CTX_free(pctx);",
          "1848:     if (params != NULL)",
          "1849:         OSSL_PARAM_free(params);",
          "1851:     if (rc != 0 && *pkey != NULL) {",
          "1852:         EVP_PKEY_free(*pkey);",
          "1854:     }",
          "1856:     return rc;",
          "1857: }",
          "1858: #endif",
          "1860: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "1861: static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,",
          "1862:                                      CK_ULONG data_len, CK_BBOOL allow_raw,",
          "1863:                                      int nid, EVP_PKEY **ec_pkey)",
          "1864: #else",
          "1865: static CK_RV fill_ec_key_from_pubkey(OSSL_PARAM_BLD *tmpl, const CK_BYTE *data,",
          "1866:                                      CK_ULONG data_len, CK_BBOOL allow_raw,",
          "1867:                                      int nid, EVP_PKEY **ec_pkey)",
          "1868: #endif",
          "1869: {",
          "1870:     CK_BYTE *ecpoint = NULL;",
          "1871:     CK_ULONG ecpoint_len, privlen;",
          "1872:     CK_BBOOL allocated = FALSE;",
          "1874:     CK_RV rc;",
          "1876:     privlen = ec_prime_len_from_nid(nid);",
          "1877:     if (privlen <= 0) {",
          "1878:         TRACE_ERROR(\"ec_prime_len_from_nid failed\\n\");",
          "1879:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "1880:         goto out;",
          "1881:     }",
          "1883:     rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,",
          "1884:                                    &allocated, &ecpoint, &ecpoint_len);",
          "1885:     if (rc != CKR_OK) {",
          "1886:         TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");",
          "1887:         goto out;",
          "1888:     }",
          "1890: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "1891:     if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {",
          "1892:         TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");",
          "1893:         rc = CKR_FUNCTION_FAILED;",
          "1894:         goto out;",
          "1895:     }",
          "1897:     if (!EC_KEY_check_key(ec_key)) {",
          "1898:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
          "1899:         rc = CKR_PUBLIC_KEY_INVALID;",
          "1900:         goto out;",
          "1901:     }",
          "1904:     if (*ec_pkey == NULL) {",
          "1905:        TRACE_ERROR(\"EVP_PKEY_CTX_new failed.\\n\");",
          "1906:        rc = CKR_HOST_MEMORY;",
          "1907:        goto out;",
          "1908:     }",
          "1910:     if (!EVP_PKEY_assign_EC_KEY(*ec_pkey, ec_key)) {",
          "1911:         TRACE_ERROR(\"EVP_PKEY_assign_EC_KEY failed.\\n\");",
          "1912:         rc = CKR_FUNCTION_FAILED;",
          "1913:         goto out;",
          "1914:     }",
          "1915: #else",
          "1916:     if (!OSSL_PARAM_BLD_push_octet_string(tmpl,",
          "1917:                                           OSSL_PKEY_PARAM_PUB_KEY,",
          "1918:                                           ecpoint, ecpoint_len)) {",
          "1919:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_octet_string failed\\n\");",
          "1920:         rc = CKR_FUNCTION_FAILED;",
          "1921:         goto out;",
          "1922:     }",
          "1924:     rc = build_pkey_from_params(tmpl, EVP_PKEY_PUBLIC_KEY, ec_pkey);",
          "1925:     if (rc != CKR_OK) {",
          "1926:         TRACE_ERROR(\"build_pkey_from_params failed\\n\");",
          "1927:         goto out;",
          "1928:     }",
          "1929:  #endif",
          "1931: out:",
          "1932:     if (allocated && ecpoint != NULL)",
          "1933:         free(ecpoint);",
          "1935:     return rc;",
          "1936: }",
          "1938: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "1939: static CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,",
          "1940:                                       CK_ULONG data_len, EVP_PKEY **ec_pkey)",
          "1941: #else",
          "1942: static CK_RV fill_ec_key_from_privkey(OSSL_PARAM_BLD *tmpl, const CK_BYTE *data,",
          "1943:                                       CK_ULONG data_len, int nid,",
          "1944:                                       EVP_PKEY **ec_pkey)",
          "1945: #endif",
          "1946: {",
          "1947:     EC_POINT *point = NULL;",
          "1948: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "1949:     EC_GROUP *group = NULL;",
          "1950:     BIGNUM *bn_priv = NULL;",
          "1951:     unsigned char *pub_key = NULL;",
          "1952:     unsigned int pub_key_len;",
          "1953:     point_conversion_form_t form;",
          "1954: #endif",
          "1955:     CK_RV rc = CKR_OK;",
          "1957: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "1958:     if (!EC_KEY_oct2priv(ec_key, data, data_len)) {",
          "1959:         TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");",
          "1960:         rc = CKR_FUNCTION_FAILED;",
          "1961:         goto out;",
          "1962:     }",
          "1964:     point = EC_POINT_new(EC_KEY_get0_group(ec_key));",
          "1965:     if (point == NULL) {",
          "1966:         TRACE_ERROR(\"EC_POINT_new failed\\n\");",
          "1967:         rc = CKR_FUNCTION_FAILED;",
          "1968:         goto out;",
          "1969:     }",
          "1971:     if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,",
          "1972:                       EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {",
          "1973:         TRACE_ERROR(\"EC_POINT_mul failed\\n\");",
          "1974:         rc = CKR_FUNCTION_FAILED;",
          "1975:         goto out;",
          "1976:     }",
          "1978:     if (!EC_KEY_set_public_key(ec_key, point)) {",
          "1979:         TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");",
          "1980:         rc = CKR_FUNCTION_FAILED;",
          "1981:         goto out;",
          "1982:     }",
          "1984:     if (!EC_KEY_check_key(ec_key)) {",
          "1985:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
          "1986:         rc = CKR_FUNCTION_FAILED;",
          "1987:         goto out;",
          "1988:     }",
          "1991:     if (*ec_pkey == NULL) {",
          "1992:        TRACE_ERROR(\"EVP_PKEY_CTX_new failed.\\n\");",
          "1993:        rc = CKR_HOST_MEMORY;",
          "1994:        goto out;",
          "1995:     }",
          "1997:     if (!EVP_PKEY_assign_EC_KEY(*ec_pkey, ec_key)) {",
          "1998:         TRACE_ERROR(\"EVP_PKEY_assign_EC_KEY failed.\\n\");",
          "1999:         rc = CKR_FUNCTION_FAILED;",
          "2000:         goto out;",
          "2001:     }",
          "2002: #else",
          "2003:     group = EC_GROUP_new_by_curve_name(nid);",
          "2004:     if (group == NULL) {",
          "2005:         TRACE_ERROR(\"EC_GROUP_new_by_curve_name failed\\n\");",
          "2006:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2007:         goto out;",
          "2008:     }",
          "2010:     point = EC_POINT_new(group);",
          "2011:     if (point == NULL) {",
          "2012:         TRACE_ERROR(\"EC_POINT_new failed\\n\");",
          "2013:         rc = CKR_FUNCTION_FAILED;",
          "2014:         goto out;",
          "2015:     }",
          "2017:     bn_priv = BN_bin2bn(data, data_len, NULL);",
          "2018:     if (bn_priv == NULL) {",
          "2019:         rc = CKR_FUNCTION_FAILED;",
          "2020:         goto out;",
          "2021:     }",
          "2023:     if (!EC_POINT_mul(group, point, bn_priv, NULL, NULL, NULL)) {",
          "2024:         TRACE_ERROR(\"EC_POINT_mul failed\\n\");",
          "2025:         rc = CKR_FUNCTION_FAILED;",
          "2026:         goto out;",
          "2027:     }",
          "2029:     form = EC_GROUP_get_point_conversion_form(group);",
          "2030:     pub_key_len = EC_POINT_point2buf(group, point, form, &pub_key,",
          "2031:                                      NULL);",
          "2032:     if (pub_key_len == 0) {",
          "2033:         TRACE_ERROR(\"EC_POINT_point2buf failed\\n\");",
          "2034:         rc = CKR_FUNCTION_FAILED;",
          "2035:         goto out;",
          "2036:     }",
          "2038:     if (!OSSL_PARAM_BLD_push_octet_string(tmpl, OSSL_PKEY_PARAM_PUB_KEY,",
          "2039:                                           pub_key, pub_key_len)) {",
          "2040:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_octet_string failed\\n\");",
          "2041:         rc = CKR_FUNCTION_FAILED;",
          "2042:         goto out;",
          "2043:     }",
          "2045:     if (!OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_PRIV_KEY, bn_priv)) {",
          "2046:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_BN failed\\n\");",
          "2047:         rc = CKR_FUNCTION_FAILED;",
          "2048:         goto out;",
          "2049:     }",
          "2051:     rc = build_pkey_from_params(tmpl, EVP_PKEY_KEYPAIR, ec_pkey);",
          "2052:     if (rc != CKR_OK) {",
          "2053:         TRACE_ERROR(\"build_pkey_from_params failed\\n\");",
          "2054:         goto out;",
          "2055:     }",
          "2056: #endif",
          "2058: out:",
          "2059:     if (point != NULL)",
          "2060:         EC_POINT_free(point);",
          "2061: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "2062:     if (group != NULL)",
          "2063:         EC_GROUP_free(group);",
          "2064:     if (bn_priv != NULL)",
          "2065:         BN_free(bn_priv);",
          "2066:     if (pub_key != NULL)",
          "2067:         OPENSSL_free(pub_key);",
          "2068: #endif",
          "2070:     return rc;",
          "2071: }",
          "2073: CK_RV openssl_make_ec_key_from_template(TEMPLATE *template, EVP_PKEY **pkey)",
          "2074: {",
          "2075:     CK_ATTRIBUTE *attr = NULL;",
          "2076:     CK_OBJECT_CLASS keyclass;",
          "2077:     EVP_PKEY *ec_pkey = NULL;",
          "2078:     int nid;",
          "2079: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2080:     EC_KEY *ec_key = NULL;",
          "2081: #else",
          "2082:     OSSL_PARAM_BLD *tmpl = NULL;",
          "2083: #endif",
          "2084:     CK_RV rc;",
          "2086:     rc = template_attribute_get_ulong(template, CKA_CLASS, &keyclass);",
          "2087:     if (rc != CKR_OK) {",
          "2088:         TRACE_ERROR(\"Could not find CKA_CLASS in the template\\n\");",
          "2089:         goto out;",
          "2090:     }",
          "2092:     rc = template_attribute_get_non_empty(template, CKA_ECDSA_PARAMS, &attr);",
          "2093:     if (rc != CKR_OK) {",
          "2094:         TRACE_ERROR(\"Could not find CKA_ECDSA_PARAMS in the template\\n\");",
          "2095:         goto out;",
          "2096:     }",
          "2098:     nid = curve_nid_from_params(attr->pValue, attr->ulValueLen);",
          "2099:     if (nid == NID_undef) {",
          "2100:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2101:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2102:         goto out;",
          "2103:     }",
          "2105: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2106:     rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);",
          "2107:     if (rc != CKR_OK)",
          "2108:         goto out;",
          "2109: #else",
          "2110:     tmpl = OSSL_PARAM_BLD_new();",
          "2111:     if (tmpl == NULL) {",
          "2112:         TRACE_ERROR(\"OSSL_PARAM_BLD_new failed\\n\");",
          "2113:         rc = CKR_HOST_MEMORY;",
          "2114:         goto out;",
          "2115:     }",
          "2117:     if (!OSSL_PARAM_BLD_push_utf8_string(tmpl, OSSL_PKEY_PARAM_GROUP_NAME,",
          "2118:                                          OBJ_nid2sn(nid), 0)) {",
          "2119:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_utf8_string failed\\n\");",
          "2120:         rc = CKR_FUNCTION_FAILED;",
          "2121:         goto out;",
          "2122:     }",
          "2123: #endif",
          "2125:     switch (keyclass) {",
          "2126:     case CKO_PUBLIC_KEY:",
          "2127:         rc = template_attribute_get_non_empty(template, CKA_EC_POINT, &attr);",
          "2128:         if (rc != CKR_OK) {",
          "2129:             TRACE_ERROR(\"Could not find CKA_EC_POINT in the template\\n\");",
          "2130:             goto out;",
          "2131:         }",
          "2133: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2134:         rc = fill_ec_key_from_pubkey(ec_key, attr->pValue, attr->ulValueLen,",
          "2135:                                      FALSE, nid, &ec_pkey);",
          "2136: #else",
          "2137:         rc = fill_ec_key_from_pubkey(tmpl, attr->pValue, attr->ulValueLen,",
          "2138:                                      FALSE, nid, &ec_pkey);",
          "2139: #endif",
          "2140:         if (rc != CKR_OK) {",
          "2141:             TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");",
          "2142:             goto out;",
          "2143:         }",
          "2144:         break;",
          "2146:     case CKO_PRIVATE_KEY:",
          "2147:         rc = template_attribute_get_non_empty(template, CKA_VALUE, &attr);",
          "2148:         if (rc != CKR_OK) {",
          "2149:             TRACE_ERROR(\"Could not find CKA_VALUE in the template\\n\");",
          "2150:             goto out;",
          "2151:         }",
          "2153: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2154:         rc = fill_ec_key_from_privkey(ec_key, attr->pValue, attr->ulValueLen,",
          "2155:                                       &ec_pkey);",
          "2156: #else",
          "2157:         rc = fill_ec_key_from_privkey(tmpl, attr->pValue, attr->ulValueLen,",
          "2158:                                       nid, &ec_pkey);",
          "2160: #endif",
          "2161:         if (rc != CKR_OK) {",
          "2162:             TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");",
          "2163:             goto out;",
          "2164:         }",
          "2165:         break;",
          "2167:     default:",
          "2168:         rc = CKR_KEY_FUNCTION_NOT_PERMITTED;",
          "2169:         goto out;",
          "2170:     }",
          "2172: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2173:     ec_key = NULL;",
          "2174: #endif",
          "2176:     rc = CKR_OK;",
          "2178: out:",
          "2179: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "2180:     if (tmpl != NULL)",
          "2181:         OSSL_PARAM_BLD_free(tmpl);",
          "2182: #endif",
          "2184:     if (rc != CKR_OK) {",
          "2185:         if (ec_pkey != NULL)",
          "2186:             EVP_PKEY_free(ec_pkey);",
          "2187: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2188:         if (ec_key != NULL)",
          "2189:             EC_KEY_free(ec_key);",
          "2190: #endif",
          "2192:         return rc;",
          "2193:     }",
          "2197:     return CKR_OK;",
          "2198: }",
          "2200: CK_RV openssl_specific_ec_generate_keypair(STDLL_TokData_t *tokdata,",
          "2201:                                            TEMPLATE *publ_tmpl,",
          "2202:                                            TEMPLATE *priv_tmpl)",
          "2203: {",
          "2205:     CK_ATTRIBUTE *attr = NULL, *ec_point_attr, *value_attr, *parms_attr;",
          "2206: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2207:     const EC_KEY *ec_key = NULL;",
          "2208:     BN_CTX *bnctx = NULL;",
          "2209: #else",
          "2210:     BIGNUM *bn_d = NULL;",
          "2211: #endif",
          "2212:     CK_BYTE *ecpoint = NULL, *enc_ecpoint = NULL, *d = NULL;",
          "2213:     CK_ULONG ecpoint_len, enc_ecpoint_len, d_len;",
          "2214:     EVP_PKEY_CTX *ctx = NULL;",
          "2215:     EVP_PKEY *ec_pkey = NULL;",
          "2216:     int nid;",
          "2217:     CK_RV rc;",
          "2219:     UNUSED(tokdata);",
          "2221:     rc = template_attribute_get_non_empty(publ_tmpl, CKA_ECDSA_PARAMS, &attr);",
          "2222:     if (rc != CKR_OK)",
          "2223:         goto out;",
          "2225:     nid = curve_nid_from_params(attr->pValue, attr->ulValueLen);",
          "2226:     if (nid == NID_undef) {",
          "2227:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2228:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2229:         goto out;",
          "2230:     }",
          "2232:     ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);",
          "2233:     if (ctx == NULL) {",
          "2234:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "2235:         rc = CKR_FUNCTION_FAILED;",
          "2236:         goto out;",
          "2237:     }",
          "2239:     if (EVP_PKEY_keygen_init(ctx) <= 0) {",
          "2240:         TRACE_ERROR(\"EVP_PKEY_keygen_init failed\\n\");",
          "2241:         rc = CKR_FUNCTION_FAILED;",
          "2242:         goto out;",
          "2243:     }",
          "2245:     if (EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid) <= 0) {",
          "2246:         TRACE_ERROR(\"EVP_PKEY_CTX_set_ec_paramgen_curve_nid failed\\n\");",
          "2247:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2248:         goto out;",
          "2249:     }",
          "2251:     if (EVP_PKEY_keygen(ctx, &ec_pkey) <= 0) {",
          "2252:         TRACE_ERROR(\"EVP_PKEY_keygen failed\\n\");",
          "2253:         if (ERR_GET_REASON(ERR_peek_last_error()) == EC_R_INVALID_CURVE)",
          "2254:             rc = CKR_CURVE_NOT_SUPPORTED;",
          "2255:         else",
          "2256:             rc = CKR_FUNCTION_FAILED;",
          "2257:         goto out;",
          "2258:     }",
          "2260: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2261:     ec_key = EVP_PKEY_get0_EC_KEY(ec_pkey);",
          "2262:     if (ec_key == NULL) {",
          "2263:        TRACE_ERROR(\"EVP_PKEY_get0_EC_KEY failed\\n\");",
          "2264:        rc = CKR_FUNCTION_FAILED;",
          "2265:        goto out;",
          "2266:    }",
          "2268:     bnctx = BN_CTX_new();",
          "2269:     if (bnctx == NULL) {",
          "2270:         rc = CKR_HOST_MEMORY;",
          "2271:         goto out;",
          "2272:     }",
          "2274:     ecpoint_len = EC_KEY_key2buf(ec_key, POINT_CONVERSION_UNCOMPRESSED,",
          "2275:                                  &ecpoint, bnctx);",
          "2276:     if (ecpoint_len == 0) {",
          "2277:         TRACE_ERROR(\"Failed to get the EC Point compressed.\\n\");",
          "2278:         rc = CKR_FUNCTION_FAILED;",
          "2279:         goto out;",
          "2280:     }",
          "2281: #else",
          "2282:     if (!EVP_PKEY_get_octet_string_param(ec_pkey,",
          "2283:                                          OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,",
          "2284:                                          NULL, 0, &ecpoint_len)) {",
          "2285:         TRACE_ERROR(\"EVP_PKEY_get_octet_string_param failed\\n\");",
          "2286:         rc = CKR_FUNCTION_FAILED;",
          "2287:         goto out;",
          "2288:     }",
          "2290:     ecpoint = OPENSSL_zalloc(ecpoint_len);",
          "2291:     if (ecpoint == NULL) {",
          "2292:         TRACE_ERROR(\"OPENSSL_zalloc failed\\n\");",
          "2293:         rc = CKR_HOST_MEMORY;",
          "2294:         goto out;",
          "2295:     }",
          "2297:     if (!EVP_PKEY_get_octet_string_param(ec_pkey,",
          "2298:                                          OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,",
          "2299:                                          ecpoint, ecpoint_len, &ecpoint_len)) {",
          "2300:         TRACE_ERROR(\"EVP_PKEY_get_octet_string_param failed\\n\");",
          "2301:         rc = CKR_FUNCTION_FAILED;",
          "2302:         goto out;",
          "2303:     }",
          "2304: #endif",
          "2306:     rc = ber_encode_OCTET_STRING(FALSE, &enc_ecpoint, &enc_ecpoint_len,",
          "2307:                                  ecpoint, ecpoint_len);",
          "2308:     if (rc != CKR_OK) {",
          "2309:         TRACE_DEVEL(\"ber_encode_OCTET_STRING failed\\n\");",
          "2310:         goto out;",
          "2311:     }",
          "2313:     rc = build_attribute(CKA_EC_POINT, enc_ecpoint, enc_ecpoint_len,",
          "2314:                          &ec_point_attr);",
          "2315:     if (rc != CKR_OK) {",
          "2316:         TRACE_ERROR(\"build_attribute for CKA_EC_POINT failed rc=0x%lx\\n\", rc);",
          "2317:         goto out;",
          "2318:     }",
          "2319:     rc = template_update_attribute(publ_tmpl, ec_point_attr);",
          "2320:     if (rc != CKR_OK) {",
          "2321:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2322:         free(ec_point_attr);",
          "2323:         goto out;",
          "2324:     }",
          "2326: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2327:     d_len = EC_KEY_priv2buf(ec_key, &d);",
          "2328:     if (d_len == 0) {",
          "2329:         TRACE_ERROR(\"Failed to get the EC private key.\\n\");",
          "2330:         rc = CKR_FUNCTION_FAILED;",
          "2331:         goto out;",
          "2332:     }",
          "2333: #else",
          "2334:     if (!EVP_PKEY_get_bn_param(ec_pkey, OSSL_PKEY_PARAM_PRIV_KEY, &bn_d)) {",
          "2335:         TRACE_ERROR(\"EVP_PKEY_get_bn_param failed\\n\");",
          "2336:         rc = CKR_FUNCTION_FAILED;",
          "2337:         goto out;",
          "2338:     }",
          "2340:     d_len = ec_prime_len_from_nid(nid);",
          "2341:     d = OPENSSL_zalloc(d_len);",
          "2342:     if (d == NULL) {",
          "2343:         TRACE_ERROR(\"OPENSSL_zalloc failed\\n\");",
          "2344:         rc = CKR_HOST_MEMORY;",
          "2345:         goto out;",
          "2346:     }",
          "2348:     BN_bn2binpad(bn_d, d, d_len);",
          "2349: #endif",
          "2351:     rc = build_attribute(CKA_VALUE, d, d_len, &value_attr);",
          "2352:     if (rc != CKR_OK) {",
          "2353:         TRACE_ERROR(\"build_attribute for CKA_VALUE failed, rc=0x%lx\\n\", rc);",
          "2354:         goto out;",
          "2355:     }",
          "2356:     rc = template_update_attribute(priv_tmpl, value_attr);",
          "2357:     if (rc != CKR_OK) {",
          "2358:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2359:         free(value_attr);",
          "2360:         goto out;",
          "2361:     }",
          "2365:     rc = build_attribute(CKA_ECDSA_PARAMS, attr->pValue, attr->ulValueLen,",
          "2366:                          &parms_attr);",
          "2367:     if (rc != CKR_OK) {",
          "2368:         TRACE_ERROR(\"build_attribute for CKA_ECDSA_PARAMS failed, rc=0x%lx\\n\",",
          "2369:                      rc);",
          "2370:         goto out;",
          "2371:     }",
          "2372:     rc = template_update_attribute(priv_tmpl, parms_attr);",
          "2373:     if (rc != CKR_OK) {",
          "2374:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2375:         free(parms_attr);",
          "2376:         goto out;",
          "2377:     }",
          "2379:     rc = CKR_OK;",
          "2381: out:",
          "2382:     if (ctx != NULL)",
          "2383:         EVP_PKEY_CTX_free(ctx);",
          "2384: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2385:     if (bnctx != NULL)",
          "2386:         BN_CTX_free(bnctx);",
          "2387: #else",
          "2388:     if (bn_d != NULL)",
          "2389:         BN_free(bn_d);",
          "2390: #endif",
          "2391:     if (ec_pkey != NULL)",
          "2392:         EVP_PKEY_free(ec_pkey);",
          "2393:     if (ecpoint != NULL)",
          "2394:         OPENSSL_free(ecpoint);",
          "2395:     if (enc_ecpoint != NULL)",
          "2396:         free(enc_ecpoint);",
          "2397:     if (d != NULL)",
          "2398:         OPENSSL_free(d);",
          "2400:     return rc;",
          "2401: }",
          "2403: CK_RV openssl_specific_ec_sign(STDLL_TokData_t *tokdata,  SESSION *sess,",
          "2404:                                CK_BYTE *in_data, CK_ULONG in_data_len,",
          "2405:                                CK_BYTE *out_data, CK_ULONG *out_data_len,",
          "2406:                                OBJECT *key_obj)",
          "2407: {",
          "2408:     EVP_PKEY *ec_key;",
          "2409:     ECDSA_SIG *sig = NULL;",
          "2410:     const BIGNUM *r, *s;",
          "2411:     CK_ULONG privlen, n;",
          "2412:     CK_RV rc = CKR_OK;",
          "2413:     EVP_PKEY_CTX *ctx = NULL;",
          "2414:     size_t siglen;",
          "2415:     CK_BYTE *sigbuf = NULL;",
          "2416:     const unsigned char *p;",
          "2418:     UNUSED(tokdata);",
          "2419:     UNUSED(sess);",
          "2423:     rc = openssl_make_ec_key_from_template(key_obj->template, &ec_key);",
          "2424:     if (rc != CKR_OK)",
          "2425:         return rc;",
          "2427:     ctx = EVP_PKEY_CTX_new(ec_key, NULL);",
          "2428:     if (ctx == NULL) {",
          "2429:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "2430:         rc = CKR_FUNCTION_FAILED;",
          "2431:         goto out;",
          "2432:     }",
          "2434:     if (EVP_PKEY_sign_init(ctx) <= 0) {",
          "2435:         TRACE_ERROR(\"EVP_PKEY_sign_init failed\\n\");",
          "2436:         rc = CKR_FUNCTION_FAILED;",
          "2437:         goto out;",
          "2438:     }",
          "2440:     if (EVP_PKEY_sign(ctx, NULL, &siglen, in_data, in_data_len) <= 0) {",
          "2441:         TRACE_ERROR(\"EVP_PKEY_sign failed\\n\");",
          "2442:         rc = CKR_FUNCTION_FAILED;",
          "2443:         goto out;",
          "2444:     }",
          "2446:     sigbuf = malloc(siglen);",
          "2447:     if (sigbuf == NULL) {",
          "2448:         TRACE_ERROR(\"malloc failed\\n\");",
          "2449:         rc = CKR_HOST_MEMORY;",
          "2450:         goto out;",
          "2451:     }",
          "2453:     if (EVP_PKEY_sign(ctx, sigbuf, &siglen, in_data, in_data_len) <= 0) {",
          "2454:         TRACE_ERROR(\"EVP_PKEY_sign failed\\n\");",
          "2455:         rc = CKR_FUNCTION_FAILED;",
          "2456:         goto out;",
          "2457:     }",
          "2459:     p = sigbuf;",
          "2460:     sig = d2i_ECDSA_SIG(NULL, &p, siglen);",
          "2461:     if (sig == NULL) {",
          "2462:         TRACE_ERROR(\"d2i_ECDSA_SIG failed\\n\");",
          "2463:         rc = CKR_FUNCTION_FAILED;",
          "2464:         goto out;",
          "2465:     }",
          "2467:     ECDSA_SIG_get0(sig, &r, &s);",
          "2469:     privlen = ec_prime_len_from_pkey(ec_key);",
          "2470:     if (privlen <= 0) {",
          "2471:         TRACE_ERROR(\"ec_prime_len_from_pkey failed\\n\");",
          "2472:         rc = CKR_FUNCTION_FAILED;",
          "2473:         goto out;",
          "2474:     }",
          "2477:     n = privlen - BN_num_bytes(r);",
          "2478:     memset(out_data, 0, n);",
          "2479:     BN_bn2bin(r, &out_data[n]);",
          "2481:     n = privlen - BN_num_bytes(s);",
          "2482:     memset(out_data + privlen, 0x00, n);",
          "2483:     BN_bn2bin(s, &out_data[privlen + n]);",
          "2487: out:",
          "2488:     if (sig != NULL)",
          "2489:         ECDSA_SIG_free(sig);",
          "2490:     if (ec_key != NULL)",
          "2491:         EVP_PKEY_free(ec_key);",
          "2492:     if (sigbuf != NULL)",
          "2493:         free(sigbuf);",
          "2494:     if (ctx != NULL)",
          "2495:         EVP_PKEY_CTX_free(ctx);",
          "2497:     return rc;",
          "2498: }",
          "2500: CK_RV openssl_specific_ec_verify(STDLL_TokData_t *tokdata,",
          "2501:                                  SESSION *sess,",
          "2502:                                  CK_BYTE *in_data,",
          "2503:                                  CK_ULONG in_data_len,",
          "2504:                                  CK_BYTE *signature,",
          "2505:                                  CK_ULONG signature_len, OBJECT *key_obj)",
          "2506: {",
          "2507:     EVP_PKEY *ec_key;",
          "2508:     CK_ULONG privlen;",
          "2509:     ECDSA_SIG *sig = NULL;",
          "2510:     BIGNUM *r = NULL, *s = NULL;",
          "2511:     CK_RV rc = CKR_OK;",
          "2512:     size_t siglen;",
          "2513:     CK_BYTE *sigbuf = NULL;",
          "2514:     EVP_PKEY_CTX *ctx = NULL;",
          "2516:     UNUSED(tokdata);",
          "2517:     UNUSED(sess);",
          "2519:     rc = openssl_make_ec_key_from_template(key_obj->template, &ec_key);",
          "2520:     if (rc != CKR_OK)",
          "2521:         return rc;",
          "2523:     privlen = ec_prime_len_from_pkey(ec_key);",
          "2524:     if (privlen <= 0) {",
          "2525:         TRACE_ERROR(\"ec_prime_len_from_pkey failed\\n\");",
          "2526:         rc = CKR_FUNCTION_FAILED;",
          "2527:         goto out;",
          "2528:     }",
          "2530:     if (signature_len < 2 * privlen) {",
          "2531:         TRACE_ERROR(\"Signature is too short\\n\");",
          "2532:         rc = CKR_SIGNATURE_LEN_RANGE;",
          "2533:         goto out;",
          "2534:     }",
          "2536:     sig = ECDSA_SIG_new();",
          "2537:     if (sig == NULL) {",
          "2538:         rc = CKR_HOST_MEMORY;",
          "2539:         goto out;",
          "2540:     }",
          "2542:     r = BN_bin2bn(signature, privlen, NULL);",
          "2543:     s = BN_bin2bn(signature + privlen, privlen, NULL);",
          "2544:     if (r == NULL || s == NULL) {",
          "2545:         TRACE_ERROR(\"BN_bin2bn failed\\n\");",
          "2546:         rc = CKR_FUNCTION_FAILED;",
          "2547:         goto out;",
          "2548:     }",
          "2550:     if (!ECDSA_SIG_set0(sig, r, s)) {",
          "2551:         TRACE_ERROR(\"ECDSA_SIG_set0 failed\\n\");",
          "2552:         rc = CKR_FUNCTION_FAILED;",
          "2553:         goto out;",
          "2554:     }",
          "2556:     siglen = i2d_ECDSA_SIG(sig, &sigbuf);",
          "2557:     if (siglen <= 0) {",
          "2558:         TRACE_ERROR(\"i2d_ECDSA_SIG failed\\n\");",
          "2559:         rc = CKR_FUNCTION_FAILED;",
          "2560:         goto out;",
          "2561:     }",
          "2563:     ctx = EVP_PKEY_CTX_new(ec_key, NULL);",
          "2564:     if (ctx == NULL) {",
          "2565:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "2566:         rc = CKR_FUNCTION_FAILED;",
          "2567:         goto out;",
          "2568:     }",
          "2570:     if (EVP_PKEY_verify_init(ctx) <= 0) {",
          "2571:         TRACE_ERROR(\"EVP_PKEY_verify_init failed\\n\");",
          "2572:         rc = CKR_FUNCTION_FAILED;",
          "2573:         goto out;",
          "2574:     }",
          "2576:     rc = EVP_PKEY_verify(ctx, sigbuf, siglen, in_data, in_data_len);",
          "2577:     switch (rc) {",
          "2578:     case 0:",
          "2579:         rc = CKR_SIGNATURE_INVALID;",
          "2580:         break;",
          "2581:     case 1:",
          "2582:         rc = CKR_OK;",
          "2583:         break;",
          "2584:     default:",
          "2585:         rc = CKR_FUNCTION_FAILED;",
          "2586:         break;",
          "2587:     }",
          "2589: out:",
          "2590:     if (sig != NULL)",
          "2591:         ECDSA_SIG_free(sig);",
          "2592:     if (ec_key != NULL)",
          "2593:         EVP_PKEY_free(ec_key);",
          "2594:     if (sigbuf != NULL)",
          "2595:         OPENSSL_free(sigbuf);",
          "2596:     if (ctx != NULL)",
          "2597:         EVP_PKEY_CTX_free(ctx);",
          "2599:     return rc;",
          "2600: }",
          "2602: CK_RV openssl_specific_ecdh_pkcs_derive(STDLL_TokData_t *tokdata,",
          "2603:                                         CK_BYTE *priv_bytes,",
          "2604:                                         CK_ULONG priv_length,",
          "2605:                                         CK_BYTE *pub_bytes,",
          "2606:                                         CK_ULONG pub_length,",
          "2607:                                         CK_BYTE *secret_value,",
          "2608:                                         CK_ULONG *secret_value_len,",
          "2609:                                         CK_BYTE *oid, CK_ULONG oid_length)",
          "2610: {",
          "2611: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2612:     EC_KEY *pub = NULL, *priv = NULL;",
          "2613: #else",
          "2614:     OSSL_PARAM_BLD *tmpl = NULL;",
          "2615: #endif",
          "2616:     EVP_PKEY *ec_pub = NULL, *ec_priv = NULL;",
          "2617:     EVP_PKEY_CTX *ctx = NULL;",
          "2618:     size_t secret_len;",
          "2619:     int nid;",
          "2620:     CK_RV rc;",
          "2622:     UNUSED(tokdata);",
          "2624:     nid = curve_nid_from_params(oid, oid_length);",
          "2625:     if (nid == NID_undef) {",
          "2626:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2627:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2628:         goto out;",
          "2629:     }",
          "2631: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2632:     rc = make_ec_key_from_params(oid, oid_length, &priv);",
          "2633:     if (rc != CKR_OK) {",
          "2634:         TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");",
          "2635:         goto out;",
          "2636:     }",
          "2637: #else",
          "2638:     tmpl = OSSL_PARAM_BLD_new();",
          "2639:     if (tmpl == NULL) {",
          "2640:         TRACE_ERROR(\"OSSL_PARAM_BLD_new failed\\n\");",
          "2641:         rc = CKR_HOST_MEMORY;",
          "2642:         goto out;",
          "2643:     }",
          "2645:     if (!OSSL_PARAM_BLD_push_utf8_string(tmpl, OSSL_PKEY_PARAM_GROUP_NAME,",
          "2646:                                          OBJ_nid2sn(nid), 0)) {",
          "2647:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_utf8_string failed\\n\");",
          "2648:         rc = CKR_FUNCTION_FAILED;",
          "2649:         goto out;",
          "2650:     }",
          "2651: #endif",
          "2653: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2654:     rc = fill_ec_key_from_privkey(priv, priv_bytes, priv_length, &ec_priv);",
          "2655: #else",
          "2656:     rc = fill_ec_key_from_privkey(tmpl, priv_bytes, priv_length, nid, &ec_priv);",
          "2657: #endif",
          "2658:     if (rc != CKR_OK) {",
          "2659:         TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");",
          "2660:         goto out;",
          "2661:     }",
          "2662: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2663:     priv = NULL;",
          "2664: #else",
          "2665:     OSSL_PARAM_BLD_free(tmpl);",
          "2666:     tmpl = NULL;",
          "2667: #endif",
          "2669: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2670:     rc = make_ec_key_from_params(oid, oid_length, &pub);",
          "2671:     if (rc != CKR_OK) {",
          "2672:         TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");",
          "2673:         goto out;",
          "2674:     }",
          "2675: #else",
          "2676:     tmpl = OSSL_PARAM_BLD_new();",
          "2677:     if (tmpl == NULL) {",
          "2678:         TRACE_ERROR(\"OSSL_PARAM_BLD_new failed\\n\");",
          "2679:         rc = CKR_HOST_MEMORY;",
          "2680:         goto out;",
          "2681:     }",
          "2683:     if (!OSSL_PARAM_BLD_push_utf8_string(tmpl, OSSL_PKEY_PARAM_GROUP_NAME,",
          "2684:                                          OBJ_nid2sn(nid), 0)) {",
          "2685:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_utf8_string failed\\n\");",
          "2686:         rc = CKR_FUNCTION_FAILED;",
          "2687:         goto out;",
          "2688:     }",
          "2689: #endif",
          "2691: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2692:     rc = fill_ec_key_from_pubkey(pub, pub_bytes, pub_length, TRUE, nid,",
          "2693:                                  &ec_pub);",
          "2694: #else",
          "2695:     rc = fill_ec_key_from_pubkey(tmpl, pub_bytes, pub_length, TRUE, nid,",
          "2696:                                  &ec_pub);",
          "2697: #endif",
          "2698:     if (rc != CKR_OK) {",
          "2699:         TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");",
          "2700:         goto out;",
          "2701:     }",
          "2702: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2703:     pub = NULL;",
          "2704: #else",
          "2705:     OSSL_PARAM_BLD_free(tmpl);",
          "2706:     tmpl = NULL;",
          "2707: #endif",
          "2709:     ctx = EVP_PKEY_CTX_new(ec_priv, NULL);",
          "2710:     if (ctx == NULL) {",
          "2711:         TRACE_DEVEL(\"EVP_PKEY_CTX_new failed\\n\");",
          "2712:         goto out;",
          "2713:     }",
          "2715:     if (EVP_PKEY_derive_init(ctx) <= 0 ||",
          "2716:         EVP_PKEY_derive_set_peer(ctx, ec_pub) <= 0) {",
          "2717:         TRACE_DEVEL(\"EVP_PKEY_derive_init/EVP_PKEY_derive_set_peer failed\\n\");",
          "2718:         goto out;",
          "2719:     }",
          "2721:     secret_len = ec_prime_len_from_nid(nid);",
          "2722:     if (EVP_PKEY_derive(ctx, secret_value, &secret_len) <= 0) {",
          "2723:         TRACE_DEVEL(\"ECDH_compute_key failed\\n\");",
          "2724:         rc = CKR_FUNCTION_FAILED;",
          "2726:         goto out;",
          "2727:     }",
          "2731: out:",
          "2732: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2733:     if (priv != NULL)",
          "2734:         EC_KEY_free(priv);",
          "2735:     if (pub != NULL)",
          "2736:         EC_KEY_free(pub);",
          "2737: #else",
          "2738:     if (tmpl != NULL)",
          "2739:         OSSL_PARAM_BLD_free(tmpl);",
          "2740: #endif",
          "2741:     if (ec_priv != NULL)",
          "2742:         EVP_PKEY_free(ec_priv);",
          "2743:     if (ec_pub != NULL)",
          "2744:         EVP_PKEY_free(ec_pub);",
          "2745:     if (ctx != NULL)",
          "2746:         EVP_PKEY_CTX_free(ctx);",
          "2748:     return rc;",
          "2749: }",
          "2751: #endif",
          "",
          "---------------"
        ],
        "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c": [
          "File: usr/lib/soft_stdll/soft_specific.c -> usr/lib/soft_stdll/soft_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #include <openssl/sha.h>",
          "49: #include <openssl/crypto.h>",
          "50: #include <openssl/cmac.h>",
          "52: #include <openssl/bn.h>",
          "53: #include <openssl/err.h>",
          "54: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "",
          "[Removed Lines]",
          "51: #include <openssl/ec.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2461: #ifndef NO_EC",
          "3165: }",
          "3167: CK_RV token_specific_ec_sign(STDLL_TokData_t *tokdata,  SESSION *sess,",
          "",
          "[Removed Lines]",
          "2463: static int curve_nid_from_params(const CK_BYTE *params, CK_ULONG params_len)",
          "2464: {",
          "2465:     const unsigned char *oid;",
          "2466:     ASN1_OBJECT *obj = NULL;",
          "2467:     int nid;",
          "2469:     oid = params;",
          "2470:     obj = d2i_ASN1_OBJECT(NULL, &oid, params_len);",
          "2471:     if (obj == NULL) {",
          "2472:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2473:         return NID_undef;",
          "2474:     }",
          "2476:     nid = OBJ_obj2nid(obj);",
          "2477:     ASN1_OBJECT_free(obj);",
          "2479:     return nid;",
          "2480: }",
          "2482: static int ec_prime_len_from_nid(int nid)",
          "2483: {",
          "2484:     EC_GROUP *group;",
          "2485:     int primelen;",
          "2487:     group = EC_GROUP_new_by_curve_name(nid);",
          "2488:     if (group == NULL)",
          "2489:         return -1;",
          "2491:     primelen = EC_GROUP_order_bits(group);",
          "2493:     EC_GROUP_free(group);",
          "2495:     if ((primelen % 8) == 0)",
          "2496:         return primelen / 8;",
          "2497:     else",
          "2498:         return (primelen / 8) + 1;",
          "2499: }",
          "2501: int ec_prime_len_from_pkey(EVP_PKEY *pkey)",
          "2502: {",
          "2503: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2504:     return (EC_GROUP_order_bits(EC_KEY_get0_group(",
          "2505:                              EVP_PKEY_get0_EC_KEY(pkey))) + 7) / 8;",
          "2506: #else",
          "2507:     size_t curve_len;",
          "2508:     char curve[80];",
          "2510:     if (!EVP_PKEY_get_utf8_string_param(pkey, OSSL_PKEY_PARAM_GROUP_NAME,",
          "2511:                                         curve, sizeof(curve), &curve_len))",
          "2512:         return -1;",
          "2514:     return ec_prime_len_from_nid(OBJ_sn2nid(curve));",
          "2515: #endif",
          "2516: }",
          "2519: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2520: static CK_RV make_ec_key_from_params(const CK_BYTE *params, CK_ULONG params_len,",
          "2521:                                      EC_KEY **key)",
          "2522: {",
          "2523:     EC_KEY *ec_key = NULL;",
          "2524:     int nid;",
          "2525:     CK_RV rc = CKR_OK;",
          "2527:     nid = curve_nid_from_params(params, params_len);",
          "2528:     if (nid == NID_undef) {",
          "2529:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2530:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2531:         goto out;",
          "2532:     }",
          "2534:     ec_key = EC_KEY_new_by_curve_name(nid);",
          "2535:     if (ec_key == NULL) {",
          "2536:        TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2537:        rc = CKR_CURVE_NOT_SUPPORTED;",
          "2538:        goto out;",
          "2539:     }",
          "2541: out:",
          "2542:     if (rc != CKR_OK) {",
          "2543:         if (ec_key != NULL)",
          "2544:             EC_KEY_free(ec_key);",
          "2546:         return rc;",
          "2547:     }",
          "2551:     return CKR_OK;",
          "2552: }",
          "2553: #endif",
          "2555: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "2556: static CK_RV build_pkey_from_params(OSSL_PARAM_BLD *tmpl, int selection,",
          "2557:                                     EVP_PKEY **pkey)",
          "2558: {",
          "2560:     OSSL_PARAM *params = NULL;",
          "2561:     EVP_PKEY_CTX *pctx = NULL;",
          "2562:     CK_RV rc = CKR_OK;",
          "2564:     params = OSSL_PARAM_BLD_to_param(tmpl);",
          "2565:     if (params == NULL) {",
          "2566:         TRACE_ERROR(\"OSSL_PARAM_BLD_to_param failed\\n\");",
          "2567:         rc = CKR_FUNCTION_FAILED;",
          "2568:         goto out;",
          "2569:     }",
          "2571:     pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);",
          "2572:     if (pctx == NULL) {",
          "2573:         TRACE_ERROR(\"EVP_PKEY_CTX_new_id failed\\n\");",
          "2574:         rc = CKR_FUNCTION_FAILED;",
          "2575:         goto out;",
          "2576:     }",
          "2578:     if (!EVP_PKEY_fromdata_init(pctx) ||",
          "2579:         !EVP_PKEY_fromdata(pctx, pkey, selection, params)) {",
          "2580:         TRACE_ERROR(\"EVP_PKEY_fromdata failed\\n\");",
          "2581:         rc = CKR_FUNCTION_FAILED;",
          "2582:         goto out;",
          "2583:     }",
          "2585:     EVP_PKEY_CTX_free(pctx);",
          "2586:     pctx = EVP_PKEY_CTX_new(*pkey, NULL);",
          "2587:     if (pctx == NULL) {",
          "2588:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "2589:         rc = CKR_FUNCTION_FAILED;",
          "2590:         goto out;",
          "2591:     }",
          "2593:     if (selection & OSSL_KEYMGMT_SELECT_PRIVATE_KEY) {",
          "2594:         if (EVP_PKEY_check(pctx) != 1) {",
          "2595:             TRACE_ERROR(\"EVP_PKEY_check failed\\n\");",
          "2596:             rc = CKR_FUNCTION_FAILED;",
          "2597:             goto out;",
          "2598:         }",
          "2599:     } else {",
          "2600:         if (EVP_PKEY_public_check(pctx) != 1) {",
          "2601:             TRACE_ERROR(\"EVP_PKEY_public_check failed\\n\");",
          "2602:             rc = CKR_FUNCTION_FAILED;",
          "2603:             goto out;",
          "2604:         }",
          "2605:     }",
          "2607: out:",
          "2608:     if (pctx != NULL)",
          "2609:         EVP_PKEY_CTX_free(pctx);",
          "2610:     if (params != NULL)",
          "2611:         OSSL_PARAM_free(params);",
          "2613:     if (rc != 0 && *pkey != NULL) {",
          "2614:         EVP_PKEY_free(*pkey);",
          "2616:     }",
          "2618:     return rc;",
          "2619: }",
          "2620: #endif",
          "2622: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2623: static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,",
          "2624:                                      CK_ULONG data_len, CK_BBOOL allow_raw,",
          "2625:                                      int nid, EVP_PKEY **ec_pkey)",
          "2626: #else",
          "2627: static CK_RV fill_ec_key_from_pubkey(OSSL_PARAM_BLD *tmpl, const CK_BYTE *data,",
          "2628:                                      CK_ULONG data_len, CK_BBOOL allow_raw,",
          "2629:                                      int nid, EVP_PKEY **ec_pkey)",
          "2630: #endif",
          "2631: {",
          "2632:     CK_BYTE *ecpoint = NULL;",
          "2633:     CK_ULONG ecpoint_len, privlen;",
          "2634:     CK_BBOOL allocated = FALSE;",
          "2636:     CK_RV rc;",
          "2638:     privlen = ec_prime_len_from_nid(nid);",
          "2639:     if (privlen <= 0) {",
          "2640:         TRACE_ERROR(\"ec_prime_len_from_nid failed\\n\");",
          "2641:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2642:         goto out;",
          "2643:     }",
          "2645:     rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,",
          "2646:                                    &allocated, &ecpoint, &ecpoint_len);",
          "2647:     if (rc != CKR_OK) {",
          "2648:         TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");",
          "2649:         goto out;",
          "2650:     }",
          "2652: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2653:     if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {",
          "2654:         TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");",
          "2655:         rc = CKR_FUNCTION_FAILED;",
          "2656:         goto out;",
          "2657:     }",
          "2659:     if (!EC_KEY_check_key(ec_key)) {",
          "2660:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
          "2661:         rc = CKR_PUBLIC_KEY_INVALID;",
          "2662:         goto out;",
          "2663:     }",
          "2666:     if (*ec_pkey == NULL) {",
          "2667:        TRACE_ERROR(\"EVP_PKEY_CTX_new failed.\\n\");",
          "2668:        rc = CKR_HOST_MEMORY;",
          "2669:        goto out;",
          "2670:     }",
          "2672:     if (!EVP_PKEY_assign_EC_KEY(*ec_pkey, ec_key)) {",
          "2673:         TRACE_ERROR(\"EVP_PKEY_assign_EC_KEY failed.\\n\");",
          "2674:         rc = CKR_FUNCTION_FAILED;",
          "2675:         goto out;",
          "2676:     }",
          "2677: #else",
          "2678:     if (!OSSL_PARAM_BLD_push_octet_string(tmpl,",
          "2679:                                           OSSL_PKEY_PARAM_PUB_KEY,",
          "2680:                                           ecpoint, ecpoint_len)) {",
          "2681:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_octet_string failed\\n\");",
          "2682:         rc = CKR_FUNCTION_FAILED;",
          "2683:         goto out;",
          "2684:     }",
          "2686:     rc = build_pkey_from_params(tmpl, EVP_PKEY_PUBLIC_KEY, ec_pkey);",
          "2687:     if (rc != CKR_OK) {",
          "2688:         TRACE_ERROR(\"build_pkey_from_params failed\\n\");",
          "2689:         goto out;",
          "2690:     }",
          "2691:  #endif",
          "2693: out:",
          "2694:     if (allocated && ecpoint != NULL)",
          "2695:         free(ecpoint);",
          "2697:     return rc;",
          "2698: }",
          "2700: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2701: static CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,",
          "2702:                                       CK_ULONG data_len, EVP_PKEY **ec_pkey)",
          "2703: #else",
          "2704: static CK_RV fill_ec_key_from_privkey(OSSL_PARAM_BLD *tmpl, const CK_BYTE *data,",
          "2705:                                       CK_ULONG data_len, int nid,",
          "2706:                                       EVP_PKEY **ec_pkey)",
          "2707: #endif",
          "2708: {",
          "2709:     EC_POINT *point = NULL;",
          "2710: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "2711:     EC_GROUP *group = NULL;",
          "2712:     BIGNUM *bn_priv = NULL;",
          "2713:     unsigned char *pub_key = NULL;",
          "2714:     unsigned int pub_key_len;",
          "2715:     point_conversion_form_t form;",
          "2716: #endif",
          "2717:     CK_RV rc = CKR_OK;",
          "2719: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2720:     if (!EC_KEY_oct2priv(ec_key, data, data_len)) {",
          "2721:         TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");",
          "2722:         rc = CKR_FUNCTION_FAILED;",
          "2723:         goto out;",
          "2724:     }",
          "2726:     point = EC_POINT_new(EC_KEY_get0_group(ec_key));",
          "2727:     if (point == NULL) {",
          "2728:         TRACE_ERROR(\"EC_POINT_new failed\\n\");",
          "2729:         rc = CKR_FUNCTION_FAILED;",
          "2730:         goto out;",
          "2731:     }",
          "2733:     if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,",
          "2734:                       EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {",
          "2735:         TRACE_ERROR(\"EC_POINT_mul failed\\n\");",
          "2736:         rc = CKR_FUNCTION_FAILED;",
          "2737:         goto out;",
          "2738:     }",
          "2740:     if (!EC_KEY_set_public_key(ec_key, point)) {",
          "2741:         TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");",
          "2742:         rc = CKR_FUNCTION_FAILED;",
          "2743:         goto out;",
          "2744:     }",
          "2746:     if (!EC_KEY_check_key(ec_key)) {",
          "2747:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
          "2748:         rc = CKR_FUNCTION_FAILED;",
          "2749:         goto out;",
          "2750:     }",
          "2753:     if (*ec_pkey == NULL) {",
          "2754:        TRACE_ERROR(\"EVP_PKEY_CTX_new failed.\\n\");",
          "2755:        rc = CKR_HOST_MEMORY;",
          "2756:        goto out;",
          "2757:     }",
          "2759:     if (!EVP_PKEY_assign_EC_KEY(*ec_pkey, ec_key)) {",
          "2760:         TRACE_ERROR(\"EVP_PKEY_assign_EC_KEY failed.\\n\");",
          "2761:         rc = CKR_FUNCTION_FAILED;",
          "2762:         goto out;",
          "2763:     }",
          "2764: #else",
          "2765:     group = EC_GROUP_new_by_curve_name(nid);",
          "2766:     if (group == NULL) {",
          "2767:         TRACE_ERROR(\"EC_GROUP_new_by_curve_name failed\\n\");",
          "2768:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2769:         goto out;",
          "2770:     }",
          "2772:     point = EC_POINT_new(group);",
          "2773:     if (point == NULL) {",
          "2774:         TRACE_ERROR(\"EC_POINT_new failed\\n\");",
          "2775:         rc = CKR_FUNCTION_FAILED;",
          "2776:         goto out;",
          "2777:     }",
          "2779:     bn_priv = BN_bin2bn(data, data_len, NULL);",
          "2780:     if (bn_priv == NULL) {",
          "2781:         rc = CKR_FUNCTION_FAILED;",
          "2782:         goto out;",
          "2783:     }",
          "2785:     if (!EC_POINT_mul(group, point, bn_priv, NULL, NULL, NULL)) {",
          "2786:         TRACE_ERROR(\"EC_POINT_mul failed\\n\");",
          "2787:         rc = CKR_FUNCTION_FAILED;",
          "2788:         goto out;",
          "2789:     }",
          "2791:     form = EC_GROUP_get_point_conversion_form(group);",
          "2792:     pub_key_len = EC_POINT_point2buf(group, point, form, &pub_key,",
          "2793:                                      NULL);",
          "2794:     if (pub_key_len == 0) {",
          "2795:         TRACE_ERROR(\"EC_POINT_point2buf failed\\n\");",
          "2796:         rc = CKR_FUNCTION_FAILED;",
          "2797:         goto out;",
          "2798:     }",
          "2800:     if (!OSSL_PARAM_BLD_push_octet_string(tmpl, OSSL_PKEY_PARAM_PUB_KEY,",
          "2801:                                           pub_key, pub_key_len)) {",
          "2802:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_octet_string failed\\n\");",
          "2803:         rc = CKR_FUNCTION_FAILED;",
          "2804:         goto out;",
          "2805:     }",
          "2807:     if (!OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_PRIV_KEY, bn_priv)) {",
          "2808:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_BN failed\\n\");",
          "2809:         rc = CKR_FUNCTION_FAILED;",
          "2810:         goto out;",
          "2811:     }",
          "2813:     rc = build_pkey_from_params(tmpl, EVP_PKEY_KEYPAIR, ec_pkey);",
          "2814:     if (rc != CKR_OK) {",
          "2815:         TRACE_ERROR(\"build_pkey_from_params failed\\n\");",
          "2816:         goto out;",
          "2817:     }",
          "2818: #endif",
          "2820: out:",
          "2821:     if (point != NULL)",
          "2822:         EC_POINT_free(point);",
          "2823: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "2824:     if (group != NULL)",
          "2825:         EC_GROUP_free(group);",
          "2826:     if (bn_priv != NULL)",
          "2827:         BN_free(bn_priv);",
          "2828:     if (pub_key != NULL)",
          "2829:         OPENSSL_free(pub_key);",
          "2830: #endif",
          "2832:     return rc;",
          "2833: }",
          "2837: static CK_RV make_ec_key_from_template(TEMPLATE *template, EVP_PKEY **pkey)",
          "2838: {",
          "2839:     CK_ATTRIBUTE *attr = NULL;",
          "2840:     CK_OBJECT_CLASS keyclass;",
          "2841:     EVP_PKEY *ec_pkey = NULL;",
          "2842:     int nid;",
          "2843: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2844:     EC_KEY *ec_key = NULL;",
          "2845: #else",
          "2846:     OSSL_PARAM_BLD *tmpl = NULL;",
          "2847: #endif",
          "2848:     CK_RV rc;",
          "2850:     rc = template_attribute_get_ulong(template, CKA_CLASS, &keyclass);",
          "2851:     if (rc != CKR_OK) {",
          "2852:         TRACE_ERROR(\"Could not find CKA_CLASS in the template\\n\");",
          "2853:         goto out;",
          "2854:     }",
          "2856:     rc = template_attribute_get_non_empty(template, CKA_ECDSA_PARAMS, &attr);",
          "2857:     if (rc != CKR_OK) {",
          "2858:         TRACE_ERROR(\"Could not find CKA_ECDSA_PARAMS in the template\\n\");",
          "2859:         goto out;",
          "2860:     }",
          "2862:     nid = curve_nid_from_params(attr->pValue, attr->ulValueLen);",
          "2863:     if (nid == NID_undef) {",
          "2864:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2865:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2866:         goto out;",
          "2867:     }",
          "2869: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2870:     rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);",
          "2871:     if (rc != CKR_OK)",
          "2872:         goto out;",
          "2873: #else",
          "2874:     tmpl = OSSL_PARAM_BLD_new();",
          "2875:     if (tmpl == NULL) {",
          "2876:         TRACE_ERROR(\"OSSL_PARAM_BLD_new failed\\n\");",
          "2877:         rc = CKR_HOST_MEMORY;",
          "2878:         goto out;",
          "2879:     }",
          "2881:     if (!OSSL_PARAM_BLD_push_utf8_string(tmpl, OSSL_PKEY_PARAM_GROUP_NAME,",
          "2882:                                          OBJ_nid2sn(nid), 0)) {",
          "2883:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_utf8_string failed\\n\");",
          "2884:         rc = CKR_FUNCTION_FAILED;",
          "2885:         goto out;",
          "2886:     }",
          "2887: #endif",
          "2889:     switch (keyclass) {",
          "2890:     case CKO_PUBLIC_KEY:",
          "2891:         rc = template_attribute_get_non_empty(template, CKA_EC_POINT, &attr);",
          "2892:         if (rc != CKR_OK) {",
          "2893:             TRACE_ERROR(\"Could not find CKA_EC_POINT in the template\\n\");",
          "2894:             goto out;",
          "2895:         }",
          "2897: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2898:         rc = fill_ec_key_from_pubkey(ec_key, attr->pValue, attr->ulValueLen,",
          "2899:                                      FALSE, nid, &ec_pkey);",
          "2900: #else",
          "2901:         rc = fill_ec_key_from_pubkey(tmpl, attr->pValue, attr->ulValueLen,",
          "2902:                                      FALSE, nid, &ec_pkey);",
          "2903: #endif",
          "2904:         if (rc != CKR_OK) {",
          "2905:             TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");",
          "2906:             goto out;",
          "2907:         }",
          "2908:         break;",
          "2910:     case CKO_PRIVATE_KEY:",
          "2911:         rc = template_attribute_get_non_empty(template, CKA_VALUE, &attr);",
          "2912:         if (rc != CKR_OK) {",
          "2913:             TRACE_ERROR(\"Could not find CKA_VALUE in the template\\n\");",
          "2914:             goto out;",
          "2915:         }",
          "2917: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2918:         rc = fill_ec_key_from_privkey(ec_key, attr->pValue, attr->ulValueLen,",
          "2919:                                       &ec_pkey);",
          "2920: #else",
          "2921:         rc = fill_ec_key_from_privkey(tmpl, attr->pValue, attr->ulValueLen,",
          "2922:                                       nid, &ec_pkey);",
          "2924: #endif",
          "2925:         if (rc != CKR_OK) {",
          "2926:             TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");",
          "2927:             goto out;",
          "2928:         }",
          "2929:         break;",
          "2931:     default:",
          "2932:         rc = CKR_KEY_FUNCTION_NOT_PERMITTED;",
          "2933:         goto out;",
          "2934:     }",
          "2936: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2937:     ec_key = NULL;",
          "2938: #endif",
          "2940:     rc = CKR_OK;",
          "2942: out:",
          "2943: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "2944:     if (tmpl != NULL)",
          "2945:         OSSL_PARAM_BLD_free(tmpl);",
          "2946: #endif",
          "2948:     if (rc != CKR_OK) {",
          "2949:         if (ec_pkey != NULL)",
          "2950:             EVP_PKEY_free(ec_pkey);",
          "2951: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2952:         if (ec_key != NULL)",
          "2953:             EC_KEY_free(ec_key);",
          "2954: #endif",
          "2956:         return rc;",
          "2957:     }",
          "2961:     return CKR_OK;",
          "2962: }",
          "2964: CK_RV token_specific_ec_generate_keypair(STDLL_TokData_t *tokdata,",
          "2965:                                          TEMPLATE *publ_tmpl,",
          "2966:                                          TEMPLATE *priv_tmpl)",
          "2967: {",
          "2969:     CK_ATTRIBUTE *attr = NULL, *ec_point_attr, *value_attr, *parms_attr;",
          "2970: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "2971:     const EC_KEY *ec_key = NULL;",
          "2972:     BN_CTX *bnctx = NULL;",
          "2973: #else",
          "2974:     BIGNUM *bn_d = NULL;",
          "2975: #endif",
          "2976:     CK_BYTE *ecpoint = NULL, *enc_ecpoint = NULL, *d = NULL;",
          "2977:     CK_ULONG ecpoint_len, enc_ecpoint_len, d_len;",
          "2978:     EVP_PKEY_CTX *ctx = NULL;",
          "2979:     EVP_PKEY *ec_pkey = NULL;",
          "2980:     int nid;",
          "2981:     CK_RV rc;",
          "2983:     UNUSED(tokdata);",
          "2985:     rc = template_attribute_get_non_empty(publ_tmpl, CKA_ECDSA_PARAMS, &attr);",
          "2986:     if (rc != CKR_OK)",
          "2987:         goto out;",
          "2989:     nid = curve_nid_from_params(attr->pValue, attr->ulValueLen);",
          "2990:     if (nid == NID_undef) {",
          "2991:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "2992:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "2993:         goto out;",
          "2994:     }",
          "2996:     ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);",
          "2997:     if (ctx == NULL) {",
          "2998:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "2999:         rc = CKR_FUNCTION_FAILED;",
          "3000:         goto out;",
          "3001:     }",
          "3003:     if (EVP_PKEY_keygen_init(ctx) <= 0) {",
          "3004:         TRACE_ERROR(\"EVP_PKEY_keygen_init failed\\n\");",
          "3005:         rc = CKR_FUNCTION_FAILED;",
          "3006:         goto out;",
          "3007:     }",
          "3009:     if (EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid) <= 0) {",
          "3010:         TRACE_ERROR(\"EVP_PKEY_CTX_set_ec_paramgen_curve_nid failed\\n\");",
          "3011:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "3012:         goto out;",
          "3013:     }",
          "3015:     if (EVP_PKEY_keygen(ctx, &ec_pkey) <= 0) {",
          "3016:         TRACE_ERROR(\"EVP_PKEY_keygen failed\\n\");",
          "3017:         if (ERR_GET_REASON(ERR_peek_last_error()) == EC_R_INVALID_CURVE)",
          "3018:             rc = CKR_CURVE_NOT_SUPPORTED;",
          "3019:         else",
          "3020:             rc = CKR_FUNCTION_FAILED;",
          "3021:         goto out;",
          "3022:     }",
          "3024: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3025:     ec_key = EVP_PKEY_get0_EC_KEY(ec_pkey);",
          "3026:     if (ec_key == NULL) {",
          "3027:        TRACE_ERROR(\"EVP_PKEY_get0_EC_KEY failed\\n\");",
          "3028:        rc = CKR_FUNCTION_FAILED;",
          "3029:        goto out;",
          "3030:    }",
          "3032:     bnctx = BN_CTX_new();",
          "3033:     if (bnctx == NULL) {",
          "3034:         rc = CKR_HOST_MEMORY;",
          "3035:         goto out;",
          "3036:     }",
          "3038:     ecpoint_len = EC_KEY_key2buf(ec_key, POINT_CONVERSION_UNCOMPRESSED,",
          "3039:                                  &ecpoint, bnctx);",
          "3040:     if (ecpoint_len == 0) {",
          "3041:         TRACE_ERROR(\"Failed to get the EC Point compressed.\\n\");",
          "3042:         rc = CKR_FUNCTION_FAILED;",
          "3043:         goto out;",
          "3044:     }",
          "3045: #else",
          "3046:     if (!EVP_PKEY_get_octet_string_param(ec_pkey,",
          "3047:                                          OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,",
          "3048:                                          NULL, 0, &ecpoint_len)) {",
          "3049:         TRACE_ERROR(\"EVP_PKEY_get_octet_string_param failed\\n\");",
          "3050:         rc = CKR_FUNCTION_FAILED;",
          "3051:         goto out;",
          "3052:     }",
          "3054:     ecpoint = OPENSSL_zalloc(ecpoint_len);",
          "3055:     if (ecpoint == NULL) {",
          "3056:         TRACE_ERROR(\"OPENSSL_zalloc failed\\n\");",
          "3057:         rc = CKR_HOST_MEMORY;",
          "3058:         goto out;",
          "3059:     }",
          "3061:     if (!EVP_PKEY_get_octet_string_param(ec_pkey,",
          "3062:                                          OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,",
          "3063:                                          ecpoint, ecpoint_len, &ecpoint_len)) {",
          "3064:         TRACE_ERROR(\"EVP_PKEY_get_octet_string_param failed\\n\");",
          "3065:         rc = CKR_FUNCTION_FAILED;",
          "3066:         goto out;",
          "3067:     }",
          "3068: #endif",
          "3070:     rc = ber_encode_OCTET_STRING(FALSE, &enc_ecpoint, &enc_ecpoint_len,",
          "3071:                                  ecpoint, ecpoint_len);",
          "3072:     if (rc != CKR_OK) {",
          "3073:         TRACE_DEVEL(\"ber_encode_OCTET_STRING failed\\n\");",
          "3074:         goto out;",
          "3075:     }",
          "3077:     rc = build_attribute(CKA_EC_POINT, enc_ecpoint, enc_ecpoint_len,",
          "3078:                          &ec_point_attr);",
          "3079:     if (rc != CKR_OK) {",
          "3080:         TRACE_ERROR(\"build_attribute for CKA_EC_POINT failed rc=0x%lx\\n\", rc);",
          "3081:         goto out;",
          "3082:     }",
          "3083:     rc = template_update_attribute(publ_tmpl, ec_point_attr);",
          "3084:     if (rc != CKR_OK) {",
          "3085:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "3086:         free(ec_point_attr);",
          "3087:         goto out;",
          "3088:     }",
          "3090: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3091:     d_len = EC_KEY_priv2buf(ec_key, &d);",
          "3092:     if (d_len == 0) {",
          "3093:         TRACE_ERROR(\"Failed to get the EC private key.\\n\");",
          "3094:         rc = CKR_FUNCTION_FAILED;",
          "3095:         goto out;",
          "3096:     }",
          "3097: #else",
          "3098:     if (!EVP_PKEY_get_bn_param(ec_pkey, OSSL_PKEY_PARAM_PRIV_KEY, &bn_d)) {",
          "3099:         TRACE_ERROR(\"EVP_PKEY_get_bn_param failed\\n\");",
          "3100:         rc = CKR_FUNCTION_FAILED;",
          "3101:         goto out;",
          "3102:     }",
          "3104:     d_len = ec_prime_len_from_nid(nid);",
          "3105:     d = OPENSSL_zalloc(d_len);",
          "3106:     if (d == NULL) {",
          "3107:         TRACE_ERROR(\"OPENSSL_zalloc failed\\n\");",
          "3108:         rc = CKR_HOST_MEMORY;",
          "3109:         goto out;",
          "3110:     }",
          "3112:     BN_bn2binpad(bn_d, d, d_len);",
          "3113: #endif",
          "3115:     rc = build_attribute(CKA_VALUE, d, d_len, &value_attr);",
          "3116:     if (rc != CKR_OK) {",
          "3117:         TRACE_ERROR(\"build_attribute for CKA_VALUE failed, rc=0x%lx\\n\", rc);",
          "3118:         goto out;",
          "3119:     }",
          "3120:     rc = template_update_attribute(priv_tmpl, value_attr);",
          "3121:     if (rc != CKR_OK) {",
          "3122:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "3123:         free(value_attr);",
          "3124:         goto out;",
          "3125:     }",
          "3129:     rc = build_attribute(CKA_ECDSA_PARAMS, attr->pValue, attr->ulValueLen,",
          "3130:                          &parms_attr);",
          "3131:     if (rc != CKR_OK) {",
          "3132:         TRACE_ERROR(\"build_attribute for CKA_ECDSA_PARAMS failed, rc=0x%lx\\n\",",
          "3133:                      rc);",
          "3134:         goto out;",
          "3135:     }",
          "3136:     rc = template_update_attribute(priv_tmpl, parms_attr);",
          "3137:     if (rc != CKR_OK) {",
          "3138:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "3139:         free(parms_attr);",
          "3140:         goto out;",
          "3141:     }",
          "3143:     rc = CKR_OK;",
          "3145: out:",
          "3146:     if (ctx != NULL)",
          "3147:         EVP_PKEY_CTX_free(ctx);",
          "3148: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3149:     if (bnctx != NULL)",
          "3150:         BN_CTX_free(bnctx);",
          "3151: #else",
          "3152:     if (bn_d != NULL)",
          "3153:         BN_free(bn_d);",
          "3154: #endif",
          "3155:     if (ec_pkey != NULL)",
          "3156:         EVP_PKEY_free(ec_pkey);",
          "3157:     if (ecpoint != NULL)",
          "3158:         OPENSSL_free(ecpoint);",
          "3159:     if (enc_ecpoint != NULL)",
          "3160:         free(enc_ecpoint);",
          "3161:     if (d != NULL)",
          "3162:         OPENSSL_free(d);",
          "3164:     return rc;",
          "",
          "[Added Lines]",
          "2462: CK_RV token_specific_ec_generate_keypair(STDLL_TokData_t *tokdata,",
          "2463:                                          TEMPLATE *publ_tmpl,",
          "2464:                                          TEMPLATE *priv_tmpl)",
          "2465: {",
          "2466:     return openssl_specific_ec_generate_keypair(tokdata, publ_tmpl, priv_tmpl);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3169:                              CK_BYTE *out_data, CK_ULONG *out_data_len,",
          "3170:                              OBJECT *key_obj)",
          "3171: {",
          "3262: }",
          "3264: CK_RV token_specific_ec_verify(STDLL_TokData_t *tokdata,",
          "",
          "[Removed Lines]",
          "3172:     EVP_PKEY *ec_key;",
          "3173:     ECDSA_SIG *sig = NULL;",
          "3174:     const BIGNUM *r, *s;",
          "3175:     CK_ULONG privlen, n;",
          "3176:     CK_RV rc = CKR_OK;",
          "3177:     EVP_PKEY_CTX *ctx = NULL;",
          "3178:     size_t siglen;",
          "3179:     CK_BYTE *sigbuf = NULL;",
          "3180:     const unsigned char *p;",
          "3182:     UNUSED(tokdata);",
          "3183:     UNUSED(sess);",
          "3187:     rc = make_ec_key_from_template(key_obj->template, &ec_key);",
          "3188:     if (rc != CKR_OK)",
          "3189:         return rc;",
          "3191:     ctx = EVP_PKEY_CTX_new(ec_key, NULL);",
          "3192:     if (ctx == NULL) {",
          "3193:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "3194:         rc = CKR_FUNCTION_FAILED;",
          "3195:         goto out;",
          "3196:     }",
          "3198:     if (EVP_PKEY_sign_init(ctx) <= 0) {",
          "3199:         TRACE_ERROR(\"EVP_PKEY_sign_init failed\\n\");",
          "3200:         rc = CKR_FUNCTION_FAILED;",
          "3201:         goto out;",
          "3202:     }",
          "3204:     if (EVP_PKEY_sign(ctx, NULL, &siglen, in_data, in_data_len) <= 0) {",
          "3205:         TRACE_ERROR(\"EVP_PKEY_sign failed\\n\");",
          "3206:         rc = CKR_FUNCTION_FAILED;",
          "3207:         goto out;",
          "3208:     }",
          "3210:     sigbuf = malloc(siglen);",
          "3211:     if (sigbuf == NULL) {",
          "3212:         TRACE_ERROR(\"malloc failed\\n\");",
          "3213:         rc = CKR_HOST_MEMORY;",
          "3214:         goto out;",
          "3215:     }",
          "3217:     if (EVP_PKEY_sign(ctx, sigbuf, &siglen, in_data, in_data_len) <= 0) {",
          "3218:         TRACE_ERROR(\"EVP_PKEY_sign failed\\n\");",
          "3219:         rc = CKR_FUNCTION_FAILED;",
          "3220:         goto out;",
          "3221:     }",
          "3223:     p = sigbuf;",
          "3224:     sig = d2i_ECDSA_SIG(NULL, &p, siglen);",
          "3225:     if (sig == NULL) {",
          "3226:         TRACE_ERROR(\"d2i_ECDSA_SIG failed\\n\");",
          "3227:         rc = CKR_FUNCTION_FAILED;",
          "3228:         goto out;",
          "3229:     }",
          "3231:     ECDSA_SIG_get0(sig, &r, &s);",
          "3233:     privlen = ec_prime_len_from_pkey(ec_key);",
          "3234:     if (privlen <= 0) {",
          "3235:         TRACE_ERROR(\"ec_prime_len_from_pkey failed\\n\");",
          "3236:         rc = CKR_FUNCTION_FAILED;",
          "3237:         goto out;",
          "3238:     }",
          "3241:     n = privlen - BN_num_bytes(r);",
          "3242:     memset(out_data, 0x00, n);",
          "3243:     BN_bn2bin(r, &out_data[n]);",
          "3245:     n = privlen - BN_num_bytes(s);",
          "3246:     memset(out_data + privlen, 0x00, n);",
          "3247:     BN_bn2bin(s, &out_data[privlen + n]);",
          "3251: out:",
          "3252:     if (sig != NULL)",
          "3253:         ECDSA_SIG_free(sig);",
          "3254:     if (ec_key != NULL)",
          "3255:         EVP_PKEY_free(ec_key);",
          "3256:     if (sigbuf != NULL)",
          "3257:         free(sigbuf);",
          "3258:     if (ctx != NULL)",
          "3259:         EVP_PKEY_CTX_free(ctx);",
          "3261:     return rc;",
          "",
          "[Added Lines]",
          "2474:     return openssl_specific_ec_sign(tokdata, sess, in_data, in_data_len,",
          "2475:                                     out_data, out_data_len, key_obj);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3268:                                CK_BYTE *signature,",
          "3269:                                CK_ULONG signature_len, OBJECT *key_obj)",
          "3270: {",
          "3364: }",
          "3366: CK_RV token_specific_ecdh_pkcs_derive(STDLL_TokData_t *tokdata,",
          "",
          "[Removed Lines]",
          "3271:     EVP_PKEY *ec_key;",
          "3272:     CK_ULONG privlen;",
          "3273:     ECDSA_SIG *sig = NULL;",
          "3274:     BIGNUM *r = NULL, *s = NULL;",
          "3275:     CK_RV rc = CKR_OK;",
          "3276:     size_t siglen;",
          "3277:     CK_BYTE *sigbuf = NULL;",
          "3278:     EVP_PKEY_CTX *ctx = NULL;",
          "3280:     UNUSED(tokdata);",
          "3281:     UNUSED(sess);",
          "3283:     rc = make_ec_key_from_template(key_obj->template, &ec_key);",
          "3284:     if (rc != CKR_OK)",
          "3285:         return rc;",
          "3287:     privlen = ec_prime_len_from_pkey(ec_key);",
          "3288:     if (privlen <= 0) {",
          "3289:         TRACE_ERROR(\"ec_prime_len_from_pkey failed\\n\");",
          "3290:         rc = CKR_FUNCTION_FAILED;",
          "3291:         goto out;",
          "3292:     }",
          "3294:     if (signature_len < 2 * privlen) {",
          "3295:         TRACE_ERROR(\"Signature is too short\\n\");",
          "3296:         rc = CKR_SIGNATURE_LEN_RANGE;",
          "3297:         goto out;",
          "3298:     }",
          "3300:     sig = ECDSA_SIG_new();",
          "3301:     if (sig == NULL) {",
          "3302:         rc = CKR_HOST_MEMORY;",
          "3303:         goto out;",
          "3304:     }",
          "3306:     r = BN_bin2bn(signature, privlen, NULL);",
          "3307:     s = BN_bin2bn(signature + privlen, privlen, NULL);",
          "3308:     if (r == NULL || s == NULL) {",
          "3309:         TRACE_ERROR(\"BN_bin2bn failed\\n\");",
          "3310:         rc = CKR_FUNCTION_FAILED;",
          "3311:         goto out;",
          "3312:     }",
          "3314:     if (!ECDSA_SIG_set0(sig, r, s)) {",
          "3315:         TRACE_ERROR(\"ECDSA_SIG_set0 failed\\n\");",
          "3316:         rc = CKR_FUNCTION_FAILED;",
          "3317:         goto out;",
          "3318:     }",
          "3320:     siglen = i2d_ECDSA_SIG(sig, &sigbuf);",
          "3321:     if (siglen <= 0) {",
          "3322:         TRACE_ERROR(\"i2d_ECDSA_SIG failed\\n\");",
          "3323:         rc = CKR_FUNCTION_FAILED;",
          "3324:         goto out;",
          "3325:     }",
          "3327:     ctx = EVP_PKEY_CTX_new(ec_key, NULL);",
          "3328:     if (ctx == NULL) {",
          "3329:         TRACE_ERROR(\"EVP_PKEY_CTX_new failed\\n\");",
          "3330:         rc = CKR_FUNCTION_FAILED;",
          "3331:         goto out;",
          "3332:     }",
          "3334:     if (EVP_PKEY_verify_init(ctx) <= 0) {",
          "3335:         TRACE_ERROR(\"EVP_PKEY_verify_init failed\\n\");",
          "3336:         rc = CKR_FUNCTION_FAILED;",
          "3337:         goto out;",
          "3338:     }",
          "3340:     rc = EVP_PKEY_verify(ctx, sigbuf, siglen, in_data, in_data_len);",
          "3341:     switch (rc) {",
          "3342:     case 0:",
          "3343:         rc = CKR_SIGNATURE_INVALID;",
          "3344:         break;",
          "3345:     case 1:",
          "3346:         rc = CKR_OK;",
          "3347:         break;",
          "3348:     default:",
          "3349:         rc = CKR_FUNCTION_FAILED;",
          "3350:         break;",
          "3351:     }",
          "3353: out:",
          "3354:     if (sig != NULL)",
          "3355:         ECDSA_SIG_free(sig);",
          "3356:     if (ec_key != NULL)",
          "3357:         EVP_PKEY_free(ec_key);",
          "3358:     if (sigbuf != NULL)",
          "3359:         OPENSSL_free(sigbuf);",
          "3360:     if (ctx != NULL)",
          "3361:         EVP_PKEY_CTX_free(ctx);",
          "3363:     return rc;",
          "",
          "[Added Lines]",
          "2485:     return openssl_specific_ec_verify(tokdata, sess, in_data, in_data_len,",
          "2486:                                       signature, signature_len, key_obj);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3372:                                       CK_ULONG *secret_value_len,",
          "3373:                                       CK_BYTE *oid, CK_ULONG oid_length)",
          "3374: {",
          "3513: }",
          "3515: #endif",
          "",
          "[Removed Lines]",
          "3375: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3376:     EC_KEY *pub = NULL, *priv = NULL;",
          "3377: #else",
          "3378:     OSSL_PARAM_BLD *tmpl = NULL;",
          "3379: #endif",
          "3380:     EVP_PKEY *ec_pub = NULL, *ec_priv = NULL;",
          "3381:     EVP_PKEY_CTX *ctx = NULL;",
          "3382:     size_t secret_len;",
          "3383:     int nid;",
          "3384:     CK_RV rc;",
          "3386:     UNUSED(tokdata);",
          "3388:     nid = curve_nid_from_params(oid, oid_length);",
          "3389:     if (nid == NID_undef) {",
          "3390:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "3391:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "3392:         goto out;",
          "3393:     }",
          "3395: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3396:     rc = make_ec_key_from_params(oid, oid_length, &priv);",
          "3397:     if (rc != CKR_OK) {",
          "3398:         TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");",
          "3399:         goto out;",
          "3400:     }",
          "3401: #else",
          "3402:     tmpl = OSSL_PARAM_BLD_new();",
          "3403:     if (tmpl == NULL) {",
          "3404:         TRACE_ERROR(\"OSSL_PARAM_BLD_new failed\\n\");",
          "3405:         rc = CKR_HOST_MEMORY;",
          "3406:         goto out;",
          "3407:     }",
          "3409:     if (!OSSL_PARAM_BLD_push_utf8_string(tmpl, OSSL_PKEY_PARAM_GROUP_NAME,",
          "3410:                                          OBJ_nid2sn(nid), 0)) {",
          "3411:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_utf8_string failed\\n\");",
          "3412:         rc = CKR_FUNCTION_FAILED;",
          "3413:         goto out;",
          "3414:     }",
          "3415: #endif",
          "3417: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3418:     rc = fill_ec_key_from_privkey(priv, priv_bytes, priv_length, &ec_priv);",
          "3419: #else",
          "3420:     rc = fill_ec_key_from_privkey(tmpl, priv_bytes, priv_length, nid, &ec_priv);",
          "3421: #endif",
          "3422:     if (rc != CKR_OK) {",
          "3423:         TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");",
          "3424:         goto out;",
          "3425:     }",
          "3426: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3427:     priv = NULL;",
          "3428: #else",
          "3429:     OSSL_PARAM_BLD_free(tmpl);",
          "3430:     tmpl = NULL;",
          "3431: #endif",
          "3433: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3434:     rc = make_ec_key_from_params(oid, oid_length, &pub);",
          "3435:     if (rc != CKR_OK) {",
          "3436:         TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");",
          "3437:         goto out;",
          "3438:     }",
          "3439: #else",
          "3440:     tmpl = OSSL_PARAM_BLD_new();",
          "3441:     if (tmpl == NULL) {",
          "3442:         TRACE_ERROR(\"OSSL_PARAM_BLD_new failed\\n\");",
          "3443:         rc = CKR_HOST_MEMORY;",
          "3444:         goto out;",
          "3445:     }",
          "3447:     if (!OSSL_PARAM_BLD_push_utf8_string(tmpl, OSSL_PKEY_PARAM_GROUP_NAME,",
          "3448:                                          OBJ_nid2sn(nid), 0)) {",
          "3449:         TRACE_ERROR(\"OSSL_PARAM_BLD_push_utf8_string failed\\n\");",
          "3450:         rc = CKR_FUNCTION_FAILED;",
          "3451:         goto out;",
          "3452:     }",
          "3453: #endif",
          "3455: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3456:     rc = fill_ec_key_from_pubkey(pub, pub_bytes, pub_length, TRUE, nid,",
          "3457:                                  &ec_pub);",
          "3458: #else",
          "3459:     rc = fill_ec_key_from_pubkey(tmpl, pub_bytes, pub_length, TRUE, nid,",
          "3460:                                  &ec_pub);",
          "3461: #endif",
          "3462:     if (rc != CKR_OK) {",
          "3463:         TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");",
          "3464:         goto out;",
          "3465:     }",
          "3466: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3467:     pub = NULL;",
          "3468: #else",
          "3469:     OSSL_PARAM_BLD_free(tmpl);",
          "3470:     tmpl = NULL;",
          "3471: #endif",
          "3473:     ctx = EVP_PKEY_CTX_new(ec_priv, NULL);",
          "3474:     if (ctx == NULL) {",
          "3475:         TRACE_DEVEL(\"EVP_PKEY_CTX_new failed\\n\");",
          "3476:         goto out;",
          "3477:     }",
          "3479:     if (EVP_PKEY_derive_init(ctx) <= 0 ||",
          "3480:         EVP_PKEY_derive_set_peer(ctx, ec_pub) <= 0) {",
          "3481:         TRACE_DEVEL(\"EVP_PKEY_derive_init/EVP_PKEY_derive_set_peer failed\\n\");",
          "3482:         goto out;",
          "3483:     }",
          "3485:     secret_len = ec_prime_len_from_nid(nid);",
          "3486:     if (EVP_PKEY_derive(ctx, secret_value, &secret_len) <= 0) {",
          "3487:         TRACE_DEVEL(\"ECDH_compute_key failed\\n\");",
          "3488:         rc = CKR_FUNCTION_FAILED;",
          "3490:         goto out;",
          "3491:     }",
          "3495: out:",
          "3496: #if !OPENSSL_VERSION_PREREQ(3, 0)",
          "3497:     if (priv != NULL)",
          "3498:         EC_KEY_free(priv);",
          "3499:     if (pub != NULL)",
          "3500:         EC_KEY_free(pub);",
          "3501: #else",
          "3502:     if (tmpl != NULL)",
          "3503:         OSSL_PARAM_BLD_free(tmpl);",
          "3504: #endif",
          "3505:     if (ec_priv != NULL)",
          "3506:         EVP_PKEY_free(ec_priv);",
          "3507:     if (ec_pub != NULL)",
          "3508:         EVP_PKEY_free(ec_pub);",
          "3509:     if (ctx != NULL)",
          "3510:         EVP_PKEY_CTX_free(ctx);",
          "3512:     return rc;",
          "",
          "[Added Lines]",
          "2498:     return openssl_specific_ecdh_pkcs_derive(tokdata, priv_bytes, priv_length,",
          "2499:                                              pub_bytes, pub_length,",
          "2500:                                              secret_value, secret_value_len,",
          "2501:                                              oid, oid_length);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3534: #ifndef NO_EC",
          "3535:     case CKK_EC:",
          "3538:         if (ec_key != NULL)",
          "3539:                 EVP_PKEY_free(ec_key);",
          "3540:         return rc;",
          "3541: #endif",
          "3543:     default:",
          "3545:     }",
          "3546: }",
          "",
          "[Removed Lines]",
          "3537:         rc = make_ec_key_from_template(obj->template, &ec_key);",
          "3544:         return CKR_OK;;",
          "",
          "[Added Lines]",
          "2526:         rc = openssl_make_ec_key_from_template(obj->template, &ec_key);",
          "2533:         return CKR_OK;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
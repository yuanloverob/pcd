{
  "cve_id": "CVE-2012-2686",
  "cve_desc": "crypto/evp/e_aes_cbc_hmac_sha1.c in the AES-NI functionality in the TLS 1.1 and 1.2 implementations in OpenSSL 1.0.1 before 1.0.1d allows remote attackers to cause a denial of service (application crash) via crafted CBC data.",
  "repo": "openssl/openssl",
  "patch_hash": "9970308c88dda1e55a10c970b73ff64e8f678d8f",
  "patch_info": {
    "commit_hash": "9970308c88dda1e55a10c970b73ff64e8f678d8f",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/9970308c88dda1e55a10c970b73ff64e8f678d8f",
    "files": [
      "crypto/evp/c_allc.c",
      "crypto/evp/e_aes_cbc_hmac_sha1.c",
      "ssl/s3_cbc.c",
      "ssl/ssl_algs.c"
    ],
    "message": "e_aes_cbc_hmac_sha1.c: address the CBC decrypt timing issues.\n\nAddress CBC decrypt timing issues and reenable the AESNI+SHA1 stitch.\n(cherry picked from commit 125093b59f3c2a2d33785b5563d929d0472f1721)",
    "before_after_code_files": [
      "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
      "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
      "ssl/s3_cbc.c||ssl/s3_cbc.c",
      "ssl/ssl_algs.c||ssl/ssl_algs.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/c_allc.c||crypto/evp/c_allc.c": [
      "File: crypto/evp/c_allc.c -> crypto/evp/c_allc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "195:  EVP_add_cipher(EVP_aes_256_xts());",
      "196:  EVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");",
      "197:  EVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");",
      "199: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
      "200:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
      "201:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
      "202: #endif",
      "203: #endif",
      "206: #ifndef OPENSSL_NO_CAMELLIA",
      "207:  EVP_add_cipher(EVP_camellia_128_ecb());",
      "",
      "[Removed Lines]",
      "204: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
      "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "89:  defined(_M_AMD64) || defined(_M_X64) || \\",
      "90:  defined(__INTEL__) )",
      "92: extern unsigned int OPENSSL_ia32cap_P[2];",
      "93: #define AESNI_CAPABLE   (1<<(57-32))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "92: #if defined(__GNUC__) && __GNUC__>=2 && !defined(PEDANTIC)",
      "93: # define BSWAP(x) ({ unsigned int r=(x); asm (\"bswapl %0\":\"=r\"(r):\"0\"(r)); r; })",
      "94: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "166:   SHA1_Update(c,ptr,res);",
      "167: }",
      "169: #define SHA1_Update sha1_update",
      "171: static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "173: #ifdef SHA1_Update",
      "174: #undef SHA1_Update",
      "175: #endif",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "183:  sha_off = SHA_CBLOCK-key->md.num;",
      "184: #endif",
      "186:  if (len%AES_BLOCK_SIZE) return 0;",
      "188:  if (ctx->encrypt) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "193:  key->payload_length = NO_PAYLOAD_LENGTH;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "233:      &key->ks,ctx->iv,1);",
      "234:   }",
      "235:  } else {",
      "239:   aesni_cbc_encrypt(in,out,len,",
      "240:     &key->ks,ctx->iv,0);",
      "249:    if ((key->aux.tls_aad[plen-4]<<8|key->aux.tls_aad[plen-3])",
      "252:     iv = AES_BLOCK_SIZE;",
      "259:    key->md = key->head;",
      "260:    SHA1_Update(&key->md,key->aux.tls_aad,plen);",
      "264:    key->md = key->tail;",
      "270:   } else {",
      "271:    SHA1_Update(&key->md,out,len);",
      "272:   }",
      "273:  }",
      "277:  return 1;",
      "278:  }",
      "",
      "[Removed Lines]",
      "236:   unsigned char mac[SHA_DIGEST_LENGTH];",
      "244:    if (len<(size_t)(out[len-1]+1+SHA_DIGEST_LENGTH))",
      "245:     return 0;",
      "247:    len -= (out[len-1]+1+SHA_DIGEST_LENGTH);",
      "250:        >= TLS1_1_VERSION) {",
      "251:     len -= AES_BLOCK_SIZE;",
      "253:    }",
      "255:    key->aux.tls_aad[plen-2] = len>>8;",
      "256:    key->aux.tls_aad[plen-1] = len;",
      "261:    SHA1_Update(&key->md,out+iv,len);",
      "262:    SHA1_Final(mac,&key->md);",
      "265:    SHA1_Update(&key->md,mac,SHA_DIGEST_LENGTH);",
      "266:    SHA1_Final(mac,&key->md);",
      "268:    if (memcmp(out+iv+len,mac,SHA_DIGEST_LENGTH))",
      "269:     return 0;",
      "275:  key->payload_length = NO_PAYLOAD_LENGTH;",
      "",
      "[Added Lines]",
      "245:   union { unsigned int  u[SHA_DIGEST_LENGTH/sizeof(unsigned int)];",
      "246:    unsigned char c[SHA_DIGEST_LENGTH]; } mac;",
      "253:    size_t inp_len, mask, j, i;",
      "254:    unsigned int res, maxpad, pad, bitlen;",
      "255:    int ret = 1;",
      "256:    union { unsigned int  u[SHA_LBLOCK];",
      "257:     unsigned char c[SHA_CBLOCK]; }",
      "261:        >= TLS1_1_VERSION)",
      "264:    if (len<(iv+SHA_DIGEST_LENGTH+1))",
      "265:     return 0;",
      "268:    out += iv;",
      "269:    len -= iv;",
      "272:    pad = out[len-1];",
      "273:    maxpad = len-(SHA_DIGEST_LENGTH+1);",
      "274:    maxpad |= (255-maxpad)>>(sizeof(maxpad)*8-8);",
      "275:    maxpad &= 255;",
      "277:    inp_len = len - (SHA_DIGEST_LENGTH+pad+1);",
      "278:    mask = (0-((inp_len-len)>>(sizeof(inp_len)*8-1)));",
      "279:    inp_len &= mask;",
      "280:    ret &= (int)mask;",
      "282:    key->aux.tls_aad[plen-2] = inp_len>>8;",
      "283:    key->aux.tls_aad[plen-1] = inp_len;",
      "289: #if 1",
      "291:    if (len>=(256+SHA_CBLOCK)) {",
      "292:     j = (len-(256+SHA_CBLOCK))&(0-SHA_CBLOCK);",
      "293:     j += SHA_CBLOCK-key->md.num;",
      "294:     SHA1_Update(&key->md,out,j);",
      "295:     out += j;",
      "296:     len -= j;",
      "297:     inp_len -= j;",
      "298:    }",
      "302:    mac.c[0] = 0;",
      "303:    mac.c[1] = (unsigned char)(bitlen>>16);",
      "304:    mac.c[2] = (unsigned char)(bitlen>>8);",
      "305:    mac.c[3] = (unsigned char)bitlen;",
      "306:    bitlen = mac.u[0];",
      "308:    mac.u[0]=0;",
      "309:    mac.u[1]=0;",
      "310:    mac.u[2]=0;",
      "311:    mac.u[3]=0;",
      "312:    mac.u[4]=0;",
      "314:    for (res=key->md.num, j=0;j<len;j++) {",
      "315:     size_t c = out[j];",
      "316:     mask = (j-inp_len)>>(sizeof(j)*8-8);",
      "317:     c &= mask;",
      "318:     c |= 0x80&~mask&~((inp_len-j)>>(sizeof(j)*8-8));",
      "319:     data->c[res++]=(unsigned char)c;",
      "321:     if (res!=SHA_CBLOCK) continue;",
      "323:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
      "324:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
      "325:     sha1_block_data_order(&key->md,data,1);",
      "326:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "327:     mac.u[0] |= key->md.h0 & mask;",
      "328:     mac.u[1] |= key->md.h1 & mask;",
      "329:     mac.u[2] |= key->md.h2 & mask;",
      "330:     mac.u[3] |= key->md.h3 & mask;",
      "331:     mac.u[4] |= key->md.h4 & mask;",
      "332:     res=0;",
      "333:    }",
      "335:    for(i=res;i<SHA_CBLOCK;i++,j++) data->c[i]=0;",
      "337:    if (res>SHA_CBLOCK-8) {",
      "338:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
      "339:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
      "340:     sha1_block_data_order(&key->md,data,1);",
      "341:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "342:     mac.u[0] |= key->md.h0 & mask;",
      "343:     mac.u[1] |= key->md.h1 & mask;",
      "344:     mac.u[2] |= key->md.h2 & mask;",
      "345:     mac.u[3] |= key->md.h3 & mask;",
      "346:     mac.u[4] |= key->md.h4 & mask;",
      "348:     memset(data,0,SHA_CBLOCK);",
      "349:     j+=64;",
      "350:    }",
      "351:    data->u[SHA_LBLOCK-1] = bitlen;",
      "352:    sha1_block_data_order(&key->md,data,1);",
      "353:    mask = 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "354:    mac.u[0] |= key->md.h0 & mask;",
      "355:    mac.u[1] |= key->md.h1 & mask;",
      "356:    mac.u[2] |= key->md.h2 & mask;",
      "357:    mac.u[3] |= key->md.h3 & mask;",
      "358:    mac.u[4] |= key->md.h4 & mask;",
      "360: #ifdef BSWAP",
      "361:    mac.u[0] = BSWAP(mac.u[0]);",
      "362:    mac.u[1] = BSWAP(mac.u[1]);",
      "363:    mac.u[2] = BSWAP(mac.u[2]);",
      "364:    mac.u[3] = BSWAP(mac.u[3]);",
      "365:    mac.u[4] = BSWAP(mac.u[4]);",
      "366: #else",
      "367:    for (i=0;i<5;i++) {",
      "368:     res = mac.u[i];",
      "369:     mac.c[4*i+0]=(unsigned char)(res>>24);",
      "370:     mac.c[4*i+1]=(unsigned char)(res>>16);",
      "371:     mac.c[4*i+2]=(unsigned char)(res>>8);",
      "372:     mac.c[4*i+3]=(unsigned char)res;",
      "373:    }",
      "374: #endif",
      "375:    len += SHA_DIGEST_LENGTH;",
      "376: #else",
      "377:    SHA1_Update(&key->md,out,inp_len);",
      "378:    res = key->md.num;",
      "379:    SHA1_Final(mac.c,&key->md);",
      "381:    {",
      "382:    unsigned int inp_blocks, pad_blocks;",
      "385:    inp_blocks = 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
      "386:    res += (unsigned int)(len-inp_len);",
      "387:    pad_blocks = res / SHA_CBLOCK;",
      "388:    res %= SHA_CBLOCK;",
      "389:    pad_blocks += 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
      "390:    for (;inp_blocks<pad_blocks;inp_blocks++)",
      "391:     sha1_block_data_order(&key->md,data,1);",
      "392:    }",
      "393: #endif",
      "395:    SHA1_Update(&key->md,mac.c,SHA_DIGEST_LENGTH);",
      "396:    SHA1_Final(mac.c,&key->md);",
      "399:    out += inp_len;",
      "400:    len -= inp_len;",
      "401: #if 1",
      "402:    {",
      "403:    unsigned char *p = out+len-1-maxpad-SHA_DIGEST_LENGTH;",
      "404:    size_t off = out-p;",
      "405:    unsigned int c, cmask;",
      "407:    maxpad += SHA_DIGEST_LENGTH;",
      "408:    for (res=0,i=0,j=0;j<maxpad;j++) {",
      "409:     c = p[j];",
      "410:     cmask = ((int)(j-off-SHA_DIGEST_LENGTH))>>(sizeof(int)*8-1);",
      "412:     cmask &= ((int)(off-1-j))>>(sizeof(int)*8-1);",
      "413:     res |= (c^mac.c[i])&cmask;",
      "414:     i += 1&cmask;",
      "415:    }",
      "416:    maxpad -= SHA_DIGEST_LENGTH;",
      "418:    res = 0-((0-res)>>(sizeof(res)*8-1));",
      "419:    ret &= (int)~res;",
      "420:    }",
      "421: #else",
      "422:    for (res=0,i=0;i<SHA_DIGEST_LENGTH;i++)",
      "423:     res |= out[i]^mac.c[i];",
      "424:    res = 0-((0-res)>>(sizeof(res)*8-1));",
      "425:    ret &= (int)~res;",
      "428:    pad = (pad&~res) | (maxpad&res);",
      "429:    out = out+len-1-pad;",
      "430:    for (res=0,i=0;i<pad;i++)",
      "431:     res |= out[i]^pad;",
      "433:    res = (0-res)>>(sizeof(res)*8-1);",
      "434:    ret &= (int)~res;",
      "435: #endif",
      "436:    return ret;",
      "",
      "---------------"
    ],
    "ssl/s3_cbc.c||ssl/s3_cbc.c": [
      "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:  if (overhead > rec->length)",
      "151:   return 0;",
      "153:  padding_length = rec->data[rec->length-1];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "161:  if (has_explicit_iv)",
      "162:   {",
      "163:   rec->data += block_size;",
      "164:   rec->input += block_size;",
      "165:   rec->length -= block_size;",
      "166:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "172:    }",
      "173:   }",
      "175:  good = constant_time_ge(rec->length, overhead+padding_length);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "190:  if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)",
      "191:   {",
      "193:   rec->length -= padding_length;",
      "194:   return 1;",
      "195:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "209:  rec->length -= padding_length;",
      "227:  return (int)((good & 1) | (~good & -1));",
      "228:  }",
      "",
      "[Removed Lines]",
      "220:  if (has_explicit_iv)",
      "221:   {",
      "222:   rec->data += block_size;",
      "223:   rec->input += block_size;",
      "224:   rec->length -= block_size;",
      "225:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "ssl/ssl_algs.c||ssl/ssl_algs.c": [
      "File: ssl/ssl_algs.c -> ssl/ssl_algs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "90:  EVP_add_cipher(EVP_aes_256_cbc());",
      "91:  EVP_add_cipher(EVP_aes_128_gcm());",
      "92:  EVP_add_cipher(EVP_aes_256_gcm());",
      "94: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
      "95:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
      "96:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
      "97: #endif",
      "100: #endif",
      "101: #ifndef OPENSSL_NO_CAMELLIA",
      "",
      "[Removed Lines]",
      "98: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2f3af3dc36b6341990e4159b6e630878adad57e4",
      "candidate_info": {
        "commit_hash": "2f3af3dc36b6341990e4159b6e630878adad57e4",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/2f3af3dc36b6341990e4159b6e630878adad57e4",
        "files": [
          "crypto/aes/asm/aesni-sha1-x86_64.pl",
          "crypto/evp/e_aes_cbc_hmac_sha1.c",
          "crypto/evp/e_aes_cbc_hmac_sha256.c"
        ],
        "message": "aesni-sha1-x86_64.pl: add stiched decrypt procedure, but keep it disabled, too little gain... Add some Atom-specific optimization.",
        "before_after_code_files": [
          "crypto/aes/asm/aesni-sha1-x86_64.pl||crypto/aes/asm/aesni-sha1-x86_64.pl",
          "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
          "crypto/evp/e_aes_cbc_hmac_sha256.c||crypto/evp/e_aes_cbc_hmac_sha256.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ],
          "candidate": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/aes/asm/aesni-sha1-x86_64.pl||crypto/aes/asm/aesni-sha1-x86_64.pl": [
          "File: crypto/aes/asm/aesni-sha1-x86_64.pl -> crypto/aes/asm/aesni-sha1-x86_64.pl",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: # subroutine:",
          "22: #",
          "23: #  AES-128-CBC +SHA1  stitch      gain",
          "26: # Ivy Bridge 5.05[+4.6] 9.65  5.54        +74%",
          "28: # Bulldozer 5.77[+6.0] 11.72  6.37        +84%",
          "29: #",
          "30: #  AES-192-CBC",
          "31: # Westmere 4.51  10.00  6.87     +46%",
          "32: # Sandy Bridge 6.05  11.06(12.21) 6.11(7.20)  +81%(+70%)",
          "33: # Ivy Bridge 6.05  10.65  6.07        +75%",
          "35: # Bulldozer 6.89  12.84  6.96        +84%",
          "36: #",
          "37: #  AES-256-CBC",
          "40: # Ivy Bridge 7.05  11.65  7.12        +64%",
          "42: # Bulldozer 8.00  13.95  8.25        +69%",
          "43: #",
          "44: # (*) There are two code paths: SSSE3 and AVX. See sha1-568.pl for",
          "",
          "[Removed Lines]",
          "24: # Westmere 3.77[+5.5] 9.26  6.58     +41%",
          "25: # Sandy Bridge 5.05[+5.0(6.2)] 10.06(11.21) 5.98(7.05)  +68%(+59%)",
          "27: # Haswell 4.43[+3.6(4.4)] 8.00(8.80) 4.55(5.21)  +75%(+69%)",
          "34: # Haswell 5.29  8.86(9.65) 5.32(5.32)  +67%(+81%)",
          "38: # Westmere 5.25  10.74  7.19     +49%",
          "39: # Sandy Bridge 7.05  12.06(13.21) 7.12(7.68)  +69%(+72%)",
          "41: # Haswell 6.19  9.76(10.6) 6.21(6.41)  +57%(+65%)",
          "",
          "[Added Lines]",
          "24: # Westmere 3.77[+5.5] 9.26  6.66     +39%",
          "25: # Sandy Bridge 5.05[+5.0(6.2)] 10.06(11.21) 5.98(7.01)  +68%(+60%)",
          "27: # Haswell 4.43[+3.6(4.1)] 8.00(8.55) 4.55(5.21)  +75%(+64%)",
          "34: # Haswell 5.29  8.86(9.42) 5.32(5.32)  +67%(+77%)",
          "38: # Westmere 5.25  10.74  7.24     +48%",
          "39: # Sandy Bridge 7.05  12.06(13.21) 7.12(7.63)  +69%(+73%)",
          "41: # Haswell 6.19  9.76(10.3) 6.21(6.25)  +57%(+65%)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60: # Haswell 0.63  0.76  0.88",
          "61: # Bulldozer 0.70  0.85  0.99",
          "63: $flavour = shift;",
          "64: $output  = shift;",
          "65: if ($flavour =~ /\\./) { $output = $flavour; undef $flavour; }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: # And indeed:",
          "64: #",
          "65: #  AES-256-CBC +SHA1  stitch      gain",
          "66: # Westmere 1.75  7.20  6.68        +7.8%",
          "67: # Sandy Bridge 1.09  6.09(7.22) 5.82(6.95)  +4.6%(+3.9%)",
          "68: # Ivy Bridge 1.11  5.70  5.45        +4.6%",
          "69: # Haswell 0.88  4.45(5.00) 4.39(4.69)  +1.4%(+6.6%)",
          "70: # Bulldozer 0.99  6.95  5.95        +17%",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:     `ml64 2>&1` =~ /Version ([0-9]+)\\./ &&",
          "82:     $1>=10);",
          "84: open OUT,\"| \\\"$^X\\\" $xlate $flavour $output\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93: $stitched_decrypt=0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "126: my @T=(\"%esi\",\"%edi\");",
          "127: my $j=0; my $jj=0; my $r=0; my $sn=0; my $rx=0;",
          "128: my $K_XX_XX=\"%r11\";",
          "137: }",
          "139: sub AUTOLOAD()  # thunk [simplified] 32-bit style perlasm",
          "",
          "[Removed Lines]",
          "129: my ($iv,$in,$rndkey0)=map(\"%xmm$_\",(11..13));",
          "130: my @rndkey=(\"%xmm14\",\"%xmm15\");",
          "132: if (1) {",
          "133:     @X=map(\"%xmm$_\",(4..11));",
          "134:     @Tx=map(\"%xmm$_\",(12..14));",
          "135:     ($iv,$in,$rndkey0)=map(\"%xmm$_\",(2,3,15));",
          "136:     @rndkey=(\"%xmm0\",\"%xmm1\");",
          "",
          "[Added Lines]",
          "140: my ($rndkey0,$iv,$in)=map(\"%xmm$_\",(11..13));   # for enc",
          "141: my @rndkey=(\"%xmm14\",\"%xmm15\");     # for enc",
          "142: my ($inout0,$inout1,$inout2,$inout3)=map(\"%xmm$_\",(12..15)); # for dec",
          "144: if (1) { # reassign for Atom Silvermont",
          "145:     @X=map(\"%xmm$_\",(8..15));",
          "146:     @Tx=map(\"%xmm$_\",(5..7));",
          "147:     ($iv,$in,$rndkey0)=map(\"%xmm$_\",(2..4));   # for enc",
          "148:     @rndkey=(\"%xmm0\",\"%xmm1\");     # for enc",
          "149:     ($inout0,$inout1,$inout2,$inout3)=map(\"%xmm$_\",(0..3)); # for dec",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "184:  movdqu ($ivp),$iv   # load IV",
          "185:  mov $ivp,88(%rsp)   # save $ivp",
          "186: ___",
          "188: my $rounds=\"${ivp}d\";",
          "189: $code.=<<___;",
          "190:  shl \\$6,$len",
          "",
          "[Removed Lines]",
          "187: my ($in0,$out,$len,$key)=map(\"%r$_\",(12..15)); # reassign arguments",
          "",
          "[Added Lines]",
          "200: ($in0,$out,$len,$key)=map(\"%r$_\",(12..15)); # reassign arguments",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "277:   my @insns = (&$body,&$body,&$body,&$body); # 40 instructions",
          "278:   my ($a,$b,$c,$d,$e);",
          "281:   eval(shift(@insns));",
          "282:   eval(shift(@insns));",
          "283:  &movdqa (@Tx[0],@X[-1&7]);",
          "285:   eval(shift(@insns));",
          "286:   eval(shift(@insns));",
          "",
          "[Removed Lines]",
          "280:  &movdqa (@X[0],@X[-3&7]);",
          "284:  &palignr(@X[0],@X[-4&7],8); # compose \"X[-14]\" in \"X[0]\"",
          "",
          "[Added Lines]",
          "293:  &pshufd (@X[0],@X[-4&7],0xee); # was &movdqa(@X[0],@X[-3&7]);",
          "297:  &punpcklqdq(@X[0],@X[-3&7]); # compose \"X[-14]\" in \"X[0]\", was &palignr(@X[0],@X[-4&7],8);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "358:   my @insns = (&$body,&$body,&$body,&$body); # 32 to 48 instructions",
          "359:   my ($a,$b,$c,$d,$e);",
          "362:   eval(shift(@insns));  # body_20_39",
          "363:  &pxor (@X[0],@X[-4&7]); # \"X[0]\"=\"X[-32]\"^\"X[-16]\"",
          "365:   eval(shift(@insns));",
          "366:   eval(shift(@insns));",
          "367:   eval(shift(@insns));  # rol",
          "",
          "[Removed Lines]",
          "361:  &movdqa (@Tx[0],@X[-1&7]) if ($Xi==8);",
          "364:  &palignr(@Tx[0],@X[-2&7],8); # compose \"X[-6]\"",
          "",
          "[Added Lines]",
          "374:  &pshufd (@Tx[0],@X[-2&7],0xee) if ($Xi==8); # was &movdqa (@Tx[0],@X[-1&7])",
          "377:  &punpcklqdq(@Tx[0],@X[-1&7]); # compose \"X[-6]\", was &palignr(@Tx[0],@X[-2&7],8);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "405:  &por (@X[0],@Tx[0]);  # \"X[0]\"<<<=2",
          "406:   eval(shift(@insns));  # body_20_39",
          "407:   eval(shift(@insns));",
          "409:   eval(shift(@insns));",
          "410:   eval(shift(@insns));  # rol",
          "411:   eval(shift(@insns));",
          "",
          "[Removed Lines]",
          "408:    &movdqa (@Tx[1],@X[0]) if ($Xi<19);",
          "",
          "[Added Lines]",
          "421:    &pshufd(@Tx[1],@X[-1&7],0xee) if ($Xi<19); # was &movdqa (@Tx[1],@X[0])",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "437:   foreach (@insns) { eval; }  # remaining instructions",
          "439:  &cmp ($inp,$len);",
          "442:  unshift(@Tx,pop(@Tx));",
          "445:  &movdqa (@Tx[1],\"0($K_XX_XX)\");  # K_00_19",
          "446:  &movdqu (@X[-4&7],\"0($inp)\");  # load input",
          "447:  &movdqu (@X[-3&7],\"16($inp)\");",
          "448:  &movdqu (@X[-2&7],\"32($inp)\");",
          "449:  &movdqu (@X[-1&7],\"48($inp)\");",
          "451:  &add ($inp,64);",
          "453:   $Xi=0;",
          "",
          "[Removed Lines]",
          "440:  &je (\".Ldone_ssse3\");",
          "444:  &movdqa (@X[2],\"64($K_XX_XX)\");  # pbswap mask",
          "450:  &pshufb (@X[-4&7],@X[2]);  # byte swap",
          "",
          "[Added Lines]",
          "453:  &je (shift);",
          "457:  &movdqa (@Tx[2],\"64($K_XX_XX)\"); # pbswap mask",
          "463:  &pshufb (@X[-4&7],@Tx[2]);  # byte swap",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "462:   eval(shift(@insns));",
          "463:   eval(shift(@insns));",
          "465:   eval(shift(@insns));",
          "466:   eval(shift(@insns));",
          "467:  &paddd (@X[($Xi-4)&7],@Tx[1]);",
          "",
          "[Removed Lines]",
          "464:  &pshufb (@X[($Xi-3)&7],@X[2]);",
          "",
          "[Added Lines]",
          "477:  &pshufb (@X[($Xi-3)&7],@Tx[2]);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "487:  foreach (@insns) { eval; }",
          "488: }",
          "497:  '($a,$b,$c,$d,$e)=@V;'.",
          "498:  '&$_ror ($b,$j?7:2);', # $b>>>2",
          "499:  '&xor (@T[0],$d);',",
          "",
          "[Removed Lines]",
          "490: sub body_00_19 () { # ((c^d)&b)^d",
          "491:   # on start @T[0]=(c^d)&b",
          "492:   return &body_20_39() if ($rx==19); $rx++;",
          "494:   use integer;",
          "495:   my ($k,$n);",
          "496:   my @r=(",
          "",
          "[Added Lines]",
          "503: my @body_00_19 = (",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "509:  '&xor ($b,$c);', # restore $b",
          "510:  '&add ($e,$a);' .'$j++; unshift(@V,pop(@V)); unshift(@T,pop(@T));'",
          "511:  );",
          "512:  $n = scalar(@r);",
          "513:  $k = (($jj+1)*12/20)*20*$n/12; # 12 aesencs per these 20 rounds",
          "514:  @r[$k%$n].='&$aesenc();' if ($jj==$k/$n);",
          "515:  $jj++;",
          "516:     return @r;",
          "517: }",
          "526:  '($a,$b,$c,$d,$e)=@V;'.",
          "527:  '&add ($e,eval(4*($j&15)).\"(%rsp)\");',# X[]+K xfer",
          "528:  '&xor (@T[0],$d) if($j==19);'.",
          "",
          "[Removed Lines]",
          "519: sub body_20_39 () { # b^d^c",
          "520:   # on entry @T[0]=b^d",
          "521:   return &body_40_59() if ($rx==39); $rx++;",
          "523:   use integer;",
          "524:   my ($k,$n);",
          "525:   my @r=(",
          "",
          "[Added Lines]",
          "520: sub body_00_19 () { # ((c^d)&b)^d",
          "521:     # on start @T[0]=(c^d)&b",
          "522:     return &body_20_39() if ($rx==19); $rx++;",
          "524:     use integer;",
          "525:     my ($k,$n);",
          "526:     my @r=@body_00_19;",
          "536: my @body_20_39 = (",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "536:  '&$_ror ($b,7);', # $b>>>2",
          "537:  '&add ($e,$a);' .'$j++; unshift(@V,pop(@V)); unshift(@T,pop(@T));'",
          "538:  );",
          "539:  $n = scalar(@r);",
          "540:  $k = (($jj+1)*8/20)*20*$n/8; # 8 aesencs per these 20 rounds",
          "541:  @r[$k%$n].='&$aesenc();' if ($jj==$k/$n && $rx!=20);",
          "542:  $jj++;",
          "543:     return @r;",
          "544: }",
          "553:  '($a,$b,$c,$d,$e)=@V;'.",
          "554:  '&add ($e,eval(4*($j&15)).\"(%rsp)\");',# X[]+K xfer",
          "555:  '&and (@T[0],$c) if ($j>=40);', # (b^c)&(c^d)",
          "",
          "[Removed Lines]",
          "546: sub body_40_59 () { # ((b^c)&(c^d))^c",
          "547:   # on entry @T[0]=(b^c), (c^=d)",
          "548:   $rx++;",
          "550:   use integer;",
          "551:   my ($k,$n);",
          "552:   my @r=(",
          "",
          "[Added Lines]",
          "551: sub body_20_39 () { # b^d^c",
          "552:     # on entry @T[0]=b^d",
          "553:     return &body_40_59() if ($rx==39); $rx++;",
          "555:     use integer;",
          "556:     my ($k,$n);",
          "557:     my @r=@body_20_39;",
          "567: my @body_40_59 = (",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "567:  '&xor ($b,$c)  if ($j< 59);', # c^d for next round",
          "568:  '&add ($e,$a);' .'$j++; unshift(@V,pop(@V)); unshift(@T,pop(@T));'",
          "569:  );",
          "570:  $n = scalar(@r);",
          "571:  $k=(($jj+1)*12/20)*20*$n/12; # 12 aesencs per these 20 rounds",
          "572:  @r[$k%$n].='&$aesenc();' if ($jj==$k/$n && $rx!=40);",
          "573:  $jj++;",
          "574:     return @r;",
          "575: }",
          "576: $code.=<<___;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "586: sub body_40_59 () { # ((b^c)&(c^d))^c",
          "587:     # on entry @T[0]=(b^c), (c^=d)",
          "588:     $rx++;",
          "590:     use integer;",
          "591:     my ($k,$n);",
          "592:     my @r=@body_40_59;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "593:  &Xupdate_ssse3_32_79(\\&body_40_59);",
          "594:  &Xupdate_ssse3_32_79(\\&body_40_59);",
          "595:  &Xupdate_ssse3_32_79(\\&body_20_39);",
          "598:     $saved_j=$j; @saved_V=@V;",
          "599:     $saved_r=$r; @saved_rndkey=@rndkey;",
          "",
          "[Removed Lines]",
          "596:  &Xuplast_ssse3_80(\\&body_20_39); # can jump to \"done\"",
          "",
          "[Added Lines]",
          "621:  &Xuplast_ssse3_80(\\&body_20_39,\".Ldone_ssse3\"); # can jump to \"done\"",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "673: .size aesni_cbc_sha1_enc_ssse3,.-aesni_cbc_sha1_enc_ssse3",
          "674: ___",
          "676: $j=$jj=$r=$sn=$rx=0;",
          "678: if ($avx) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "701:       if ($stitched_decrypt) {{{",
          "702: # reset",
          "703: ($in0,$out,$len,$key,$ivp,$ctx,$inp)=(\"%rdi\",\"%rsi\",\"%rdx\",\"%rcx\",\"%r8\",\"%r9\",\"%r10\");",
          "704: $j=$jj=$r=$sn=$rx=0;",
          "705: $Xi=4;",
          "707: my @aes256_dec = (",
          "708:  '&movdqu($inout0,\"0x00($in0)\");',",
          "709:  '&movdqu($inout1,\"0x10($in0)\"); &pxor ($inout0,$rndkey0);',",
          "710:  '&movdqu($inout2,\"0x20($in0)\"); &pxor ($inout1,$rndkey0);',",
          "711:  '&movdqu($inout3,\"0x30($in0)\"); &pxor ($inout2,$rndkey0);',",
          "713:  '&pxor ($inout3,$rndkey0); &movups ($rndkey0,\"16-112($key)\");',",
          "714:  '&movaps(\"64(%rsp)\",@X[2]);', # save IV, originally @X[3]",
          "715:  undef,undef",
          "716:  );",
          "717: for ($i=0;$i<13;$i++) {",
          "718:     push (@aes256_dec,(",
          "719:  '&aesdec ($inout0,$rndkey0);',",
          "720:  '&aesdec ($inout1,$rndkey0);',",
          "721:  '&aesdec ($inout2,$rndkey0);',",
          "722:  '&aesdec ($inout3,$rndkey0); &movups($rndkey0,\"'.(16*($i+2)-112).'($key)\");'",
          "723:  ));",
          "724:     push (@aes256_dec,(undef,undef)) if (($i>=3 && $i<=5) || $i>=11);",
          "725:     push (@aes256_dec,(undef,undef)) if ($i==5);",
          "726: }",
          "727: push(@aes256_dec,(",
          "728:  '&aesdeclast ($inout0,$rndkey0); &movups (@X[0],\"0x00($in0)\");',",
          "729:  '&aesdeclast ($inout1,$rndkey0); &movups (@X[1],\"0x10($in0)\");',",
          "730:  '&aesdeclast ($inout2,$rndkey0); &movups (@X[2],\"0x20($in0)\");',",
          "731:  '&aesdeclast ($inout3,$rndkey0); &movups (@X[3],\"0x30($in0)\");',",
          "733:  '&xorps  ($inout0,\"64(%rsp)\"); &movdqu ($rndkey0,\"-112($key)\");',",
          "734:  '&xorps  ($inout1,@X[0]); &movups (\"0x00($out,$in0)\",$inout0);',",
          "735:  '&xorps  ($inout2,@X[1]); &movups (\"0x10($out,$in0)\",$inout1);',",
          "736:  '&xorps  ($inout3,@X[2]); &movups (\"0x20($out,$in0)\",$inout2);',",
          "738:  '&movups (\"0x30($out,$in0)\",$inout3);'",
          "739:  ));",
          "741: sub body_00_19_dec () { # ((c^d)&b)^d",
          "742:     # on start @T[0]=(c^d)&b",
          "743:     return &body_20_39_dec() if ($rx==19);",
          "745:     my @r=@body_00_19;",
          "747:  unshift (@r,@aes256_dec[$rx]) if (@aes256_dec[$rx]);",
          "748:  $rx++;",
          "750:     return @r;",
          "751: }",
          "753: sub body_20_39_dec () { # b^d^c",
          "754:     # on entry @T[0]=b^d",
          "755:     return &body_40_59_dec() if ($rx==39);",
          "757:     my @r=@body_20_39;",
          "759:  unshift (@r,@aes256_dec[$rx]) if (@aes256_dec[$rx]);",
          "760:  $rx++;",
          "762:     return @r;",
          "763: }",
          "765: sub body_40_59_dec () { # ((b^c)&(c^d))^c",
          "766:     # on entry @T[0]=(b^c), (c^=d)",
          "768:     my @r=@body_40_59;",
          "770:  unshift (@r,@aes256_dec[$rx]) if (@aes256_dec[$rx]);",
          "771:  $rx++;",
          "773:     return @r;",
          "774: }",
          "776: $code.=<<___;",
          "777: .globl aesni256_cbc_sha1_dec",
          "778: .type aesni256_cbc_sha1_dec,\\@abi-omnipotent",
          "779: .align 32",
          "780: aesni256_cbc_sha1_dec:",
          "781:  # caller should check for SSSE3 and AES-NI bits",
          "782:  mov OPENSSL_ia32cap_P+0(%rip),%r10d",
          "783:  mov OPENSSL_ia32cap_P+4(%rip),%r11d",
          "784: ___",
          "785: $code.=<<___ if ($avx);",
          "786:  and \\$`1<<28`,%r11d  # mask AVX bit",
          "787:  and \\$`1<<30`,%r10d  # mask \"Intel CPU\" bit",
          "788:  or %r11d,%r10d",
          "789:  cmp \\$`1<<28|1<<30`,%r10d",
          "790:  je aesni256_cbc_sha1_dec_avx",
          "791: ___",
          "792: $code.=<<___;",
          "793:  jmp aesni256_cbc_sha1_dec_ssse3",
          "794:  ret",
          "795: .size aesni256_cbc_sha1_dec,.-aesni256_cbc_sha1_dec",
          "797: .type aesni256_cbc_sha1_dec_ssse3,\\@function,6",
          "798: .align 32",
          "799: aesni256_cbc_sha1_dec_ssse3:",
          "800:  mov `($win64?56:8)`(%rsp),$inp # load 7th argument",
          "801:  push %rbx",
          "802:  push %rbp",
          "803:  push %r12",
          "804:  push %r13",
          "805:  push %r14",
          "806:  push %r15",
          "807:  lea `-104-($win64?10*16:0)`(%rsp),%rsp",
          "808: ___",
          "809: $code.=<<___ if ($win64);",
          "810:  movaps %xmm6,96+0(%rsp)",
          "811:  movaps %xmm7,96+16(%rsp)",
          "812:  movaps %xmm8,96+32(%rsp)",
          "813:  movaps %xmm9,96+48(%rsp)",
          "814:  movaps %xmm10,96+64(%rsp)",
          "815:  movaps %xmm11,96+80(%rsp)",
          "816:  movaps %xmm12,96+96(%rsp)",
          "817:  movaps %xmm13,96+112(%rsp)",
          "818:  movaps %xmm14,96+128(%rsp)",
          "819:  movaps %xmm15,96+144(%rsp)",
          "820: .Lprologue_dec_ssse3:",
          "821: ___",
          "822: $code.=<<___;",
          "823:  mov $in0,%r12   # reassign arguments",
          "824:  mov $out,%r13",
          "825:  mov $len,%r14",
          "826:  lea 112($key),%r15   # size optimization",
          "827:  movdqu ($ivp),@X[3]   # load IV",
          "828:  #mov $ivp,88(%rsp)   # save $ivp",
          "829: ___",
          "830: ($in0,$out,$len,$key)=map(\"%r$_\",(12..15)); # reassign arguments",
          "831: $code.=<<___;",
          "832:  shl \\$6,$len",
          "833:  sub $in0,$out",
          "834:  add $inp,$len  # end of input",
          "836:  lea K_XX_XX(%rip),$K_XX_XX",
          "837:  mov 0($ctx),$A  # load context",
          "838:  mov 4($ctx),$B",
          "839:  mov 8($ctx),$C",
          "840:  mov 12($ctx),$D",
          "841:  mov $B,@T[0]  # magic seed",
          "842:  mov 16($ctx),$E",
          "843:  mov $C,@T[1]",
          "844:  xor $D,@T[1]",
          "845:  and @T[1],@T[0]",
          "847:  movdqa 64($K_XX_XX),@X[2] # pbswap mask",
          "848:  movdqa 0($K_XX_XX),@Tx[1] # K_00_19",
          "849:  movdqu 0($inp),@X[-4&7] # load input to %xmm[0-3]",
          "850:  movdqu 16($inp),@X[-3&7]",
          "851:  movdqu 32($inp),@X[-2&7]",
          "852:  movdqu 48($inp),@X[-1&7]",
          "853:  pshufb @X[2],@X[-4&7]  # byte swap",
          "854:  add \\$64,$inp",
          "855:  pshufb @X[2],@X[-3&7]",
          "856:  pshufb @X[2],@X[-2&7]",
          "857:  pshufb @X[2],@X[-1&7]",
          "858:  paddd @Tx[1],@X[-4&7]  # add K_00_19",
          "859:  paddd @Tx[1],@X[-3&7]",
          "860:  paddd @Tx[1],@X[-2&7]",
          "861:  movdqa @X[-4&7],0(%rsp) # X[]+K xfer to IALU",
          "862:  psubd @Tx[1],@X[-4&7]  # restore X[]",
          "863:  movdqa @X[-3&7],16(%rsp)",
          "864:  psubd @Tx[1],@X[-3&7]",
          "865:  movdqa @X[-2&7],32(%rsp)",
          "866:  psubd @Tx[1],@X[-2&7]",
          "867:  movdqu -112($key),$rndkey0 # $key[0]",
          "868:  jmp .Loop_dec_ssse3",
          "870: .align 32",
          "871: .Loop_dec_ssse3:",
          "872: ___",
          "873:  &Xupdate_ssse3_16_31(\\&body_00_19_dec);",
          "874:  &Xupdate_ssse3_16_31(\\&body_00_19_dec);",
          "875:  &Xupdate_ssse3_16_31(\\&body_00_19_dec);",
          "876:  &Xupdate_ssse3_16_31(\\&body_00_19_dec);",
          "877:  &Xupdate_ssse3_32_79(\\&body_00_19_dec);",
          "878:  &Xupdate_ssse3_32_79(\\&body_20_39_dec);",
          "879:  &Xupdate_ssse3_32_79(\\&body_20_39_dec);",
          "880:  &Xupdate_ssse3_32_79(\\&body_20_39_dec);",
          "881:  &Xupdate_ssse3_32_79(\\&body_20_39_dec);",
          "882:  &Xupdate_ssse3_32_79(\\&body_20_39_dec);",
          "883:  &Xupdate_ssse3_32_79(\\&body_40_59_dec);",
          "884:  &Xupdate_ssse3_32_79(\\&body_40_59_dec);",
          "885:  &Xupdate_ssse3_32_79(\\&body_40_59_dec);",
          "886:  &Xupdate_ssse3_32_79(\\&body_40_59_dec);",
          "887:  &Xupdate_ssse3_32_79(\\&body_40_59_dec);",
          "888:  &Xupdate_ssse3_32_79(\\&body_20_39_dec);",
          "889:  &Xuplast_ssse3_80(\\&body_20_39_dec,\".Ldone_dec_ssse3\"); # can jump to \"done\"",
          "891:     $saved_j=$j;   @saved_V=@V;",
          "892:     $saved_rx=$rx;",
          "894:  &Xloop_ssse3(\\&body_20_39_dec);",
          "895:  &Xloop_ssse3(\\&body_20_39_dec);",
          "896:  &Xloop_ssse3(\\&body_20_39_dec);",
          "898:  eval(@aes256_dec[-1]);   # last store",
          "899: $code.=<<___;",
          "900:  lea 64($in0),$in0",
          "902:  add 0($ctx),$A   # update context",
          "903:  add 4($ctx),@T[0]",
          "904:  add 8($ctx),$C",
          "905:  add 12($ctx),$D",
          "906:  mov $A,0($ctx)",
          "907:  add 16($ctx),$E",
          "908:  mov @T[0],4($ctx)",
          "909:  mov @T[0],$B   # magic seed",
          "910:  mov $C,8($ctx)",
          "911:  mov $C,@T[1]",
          "912:  mov $D,12($ctx)",
          "913:  xor $D,@T[1]",
          "914:  mov $E,16($ctx)",
          "915:  and @T[1],@T[0]",
          "916:  jmp .Loop_dec_ssse3",
          "918: .Ldone_dec_ssse3:",
          "919: ___",
          "920:     $jj=$j=$saved_j; @V=@saved_V;",
          "921:     $rx=$saved_rx;",
          "923:  &Xtail_ssse3(\\&body_20_39_dec);",
          "924:  &Xtail_ssse3(\\&body_20_39_dec);",
          "925:  &Xtail_ssse3(\\&body_20_39_dec);",
          "927:  eval(@aes256_dec[-1]);   # last store",
          "928: $code.=<<___;",
          "929:  add 0($ctx),$A   # update context",
          "930:  add 4($ctx),@T[0]",
          "931:  add 8($ctx),$C",
          "932:  mov $A,0($ctx)",
          "933:  add 12($ctx),$D",
          "934:  mov @T[0],4($ctx)",
          "935:  add 16($ctx),$E",
          "936:  mov $C,8($ctx)",
          "937:  mov $D,12($ctx)",
          "938:  mov $E,16($ctx)",
          "939:  movups @X[3],($ivp)   # write IV",
          "940: ___",
          "941: $code.=<<___ if ($win64);",
          "942:  movaps 96+0(%rsp),%xmm6",
          "943:  movaps 96+16(%rsp),%xmm7",
          "944:  movaps 96+32(%rsp),%xmm8",
          "945:  movaps 96+48(%rsp),%xmm9",
          "946:  movaps 96+64(%rsp),%xmm10",
          "947:  movaps 96+80(%rsp),%xmm11",
          "948:  movaps 96+96(%rsp),%xmm12",
          "949:  movaps 96+112(%rsp),%xmm13",
          "950:  movaps 96+128(%rsp),%xmm14",
          "951:  movaps 96+144(%rsp),%xmm15",
          "952: ___",
          "953: $code.=<<___;",
          "954:  lea `104+($win64?10*16:0)`(%rsp),%rsi",
          "955:  mov 0(%rsi),%r15",
          "956:  mov 8(%rsi),%r14",
          "957:  mov 16(%rsi),%r13",
          "958:  mov 24(%rsi),%r12",
          "959:  mov 32(%rsi),%rbp",
          "960:  mov 40(%rsi),%rbx",
          "961:  lea 48(%rsi),%rsp",
          "962: .Lepilogue_dec_ssse3:",
          "963:  ret",
          "964: .size aesni256_cbc_sha1_dec_ssse3,.-aesni256_cbc_sha1_dec_ssse3",
          "965: ___",
          "966:       }}}",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "683: my @Tx=map(\"%xmm$_\",(8..10));",
          "684: my @V=($A,$B,$C,$D,$E)=(\"%eax\",\"%ebx\",\"%ecx\",\"%edx\",\"%ebp\"); # size optimization",
          "685: my @T=(\"%esi\",\"%edi\");",
          "687: my @rndkey=(\"%xmm14\",\"%xmm15\");",
          "690: my $_rol=sub { &shld(@_[0],@_) };",
          "691: my $_ror=sub { &shrd(@_[0],@_) };",
          "",
          "[Removed Lines]",
          "686: my ($iv,$in,$rndkey0)=map(\"%xmm$_\",(11..13));",
          "688: my $Kx=$rndkey0;",
          "",
          "[Added Lines]",
          "977: my ($rndkey0,$iv,$in)=map(\"%xmm$_\",(11..13));",
          "979: my ($inout0,$inout1,$inout2,$inout3)=map(\"%xmm$_\",(12..15)); # for dec",
          "980: my $Kx=@Tx[2];",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "729:  vmovdqu ($ivp),$iv   # load IV",
          "730:  mov $ivp,88(%rsp)   # save $ivp",
          "731: ___",
          "733: my $rounds=\"${ivp}d\";",
          "734: $code.=<<___;",
          "735:  shl \\$6,$len",
          "",
          "[Removed Lines]",
          "732: my ($in0,$out,$len,$key)=map(\"%r$_\",(12..15)); # reassign arguments",
          "",
          "[Added Lines]",
          "1024: ($in0,$out,$len,$key)=map(\"%r$_\",(12..15)); # reassign arguments",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "856:   eval(shift(@insns));",
          "857:   eval(shift(@insns));",
          "860:  &vpaddd (@X[0],@X[0],@X[0]);",
          "861:   eval(shift(@insns));",
          "862:   eval(shift(@insns));",
          "863:   eval(shift(@insns));",
          "864:   eval(shift(@insns));",
          "867:  &vpor (@X[0],@X[0],@Tx[0]);  # \"X[0]\"<<<=1",
          "868:   eval(shift(@insns));",
          "869:   eval(shift(@insns));",
          "870:   eval(shift(@insns));",
          "871:   eval(shift(@insns));",
          "875:   eval(shift(@insns));",
          "876:   eval(shift(@insns));",
          "877:   eval(shift(@insns));",
          "878:   eval(shift(@insns));",
          "881:   eval(shift(@insns));",
          "882:   eval(shift(@insns));",
          "883:    &vmovdqa ($Kx,eval(16*(($Xi)/5)).\"($K_XX_XX)\") if ($Xi%5==0); # K_XX_XX",
          "",
          "[Removed Lines]",
          "859:  &vpslldq(@Tx[2],@X[0],12);  # \"X[0]\"<<96, extract one dword",
          "866:  &vpsrld (@Tx[1],@Tx[2],30);",
          "873:  &vpslld (@Tx[2],@Tx[2],2);",
          "874:  &vpxor (@X[0],@X[0],@Tx[1]);",
          "880:  &vpxor (@X[0],@X[0],@Tx[2]);  # \"X[0]\"^=(\"X[0]\">>96)<<<2",
          "",
          "[Added Lines]",
          "1151:  &vpslldq(@Tx[1],@X[0],12);  # \"X[0]\"<<96, extract one dword",
          "1159:  &vpsrld (@Tx[0],@Tx[1],30);",
          "1165:  &vpslld (@Tx[1],@Tx[1],2);",
          "1166:  &vpxor (@X[0],@X[0],@Tx[0]);",
          "1172:  &vpxor (@X[0],@X[0],@Tx[1]);  # \"X[0]\"^=(\"X[0]\">>96)<<<2",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "967:   foreach (@insns) { eval; }  # remaining instructions",
          "969:  &cmp ($inp,$len);",
          "975:  &vmovdqa($Kx,\"0($K_XX_XX)\");  # K_00_19",
          "976:  &vmovdqu(@X[-4&7],\"0($inp)\");  # load input",
          "977:  &vmovdqu(@X[-3&7],\"16($inp)\");",
          "978:  &vmovdqu(@X[-2&7],\"32($inp)\");",
          "979:  &vmovdqu(@X[-1&7],\"48($inp)\");",
          "981:  &add ($inp,64);",
          "983:   $Xi=0;",
          "",
          "[Removed Lines]",
          "970:  &je (\".Ldone_avx\");",
          "972:  unshift(@Tx,pop(@Tx));",
          "974:  &vmovdqa(@X[2],\"64($K_XX_XX)\");  # pbswap mask",
          "980:  &vpshufb(@X[-4&7],@X[-4&7],@X[2]); # byte swap",
          "",
          "[Added Lines]",
          "1262:  &je (shift);",
          "1264:  &vmovdqa(@Tx[1],\"64($K_XX_XX)\"); # pbswap mask",
          "1270:  &vpshufb(@X[-4&7],@X[-4&7],@Tx[1]); # byte swap",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "992:   eval(shift(@insns));",
          "993:   eval(shift(@insns));",
          "995:   eval(shift(@insns));",
          "996:   eval(shift(@insns));",
          "998:   eval(shift(@insns));",
          "999:   eval(shift(@insns));",
          "1000:   eval(shift(@insns));",
          "1001:   eval(shift(@insns));",
          "1003:   eval(shift(@insns));",
          "1004:   eval(shift(@insns));",
          "",
          "[Removed Lines]",
          "994:  &vpshufb(@X[($Xi-3)&7],@X[($Xi-3)&7],@X[2]);",
          "997:  &vpaddd (@X[$Xi&7],@X[($Xi-4)&7],$Kx);",
          "1002:  &vmovdqa(eval(16*$Xi).\"(%rsp)\",@X[$Xi&7]); # X[]+K xfer to IALU",
          "",
          "[Added Lines]",
          "1284:  &vpshufb(@X[($Xi-3)&7],@X[($Xi-3)&7],@Tx[1]);",
          "1287:  &vpaddd (@Tx[0],@X[($Xi-4)&7],$Kx);",
          "1292:  &vmovdqa(eval(16*$Xi).\"(%rsp)\",@Tx[0]); # X[]+K xfer to IALU",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1036:  &Xupdate_avx_32_79(\\&body_40_59);",
          "1037:  &Xupdate_avx_32_79(\\&body_40_59);",
          "1038:  &Xupdate_avx_32_79(\\&body_20_39);",
          "1041:     $saved_j=$j; @saved_V=@V;",
          "1042:     $saved_r=$r; @saved_rndkey=@rndkey;",
          "",
          "[Removed Lines]",
          "1039:  &Xuplast_avx_80(\\&body_20_39); # can jump to \"done\"",
          "",
          "[Added Lines]",
          "1329:  &Xuplast_avx_80(\\&body_20_39,\".Ldone_avx\"); # can jump to \"done\"",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1116:  ret",
          "1117: .size aesni_cbc_sha1_enc_avx,.-aesni_cbc_sha1_enc_avx",
          "1118: ___",
          "1119: }",
          "1120: $code.=<<___;",
          "1121: .align 64",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1410:       if ($stiched_decrypt) {{{",
          "1411: # reset",
          "1412: ($in0,$out,$len,$key,$ivp,$ctx,$inp)=(\"%rdi\",\"%rsi\",\"%rdx\",\"%rcx\",\"%r8\",\"%r9\",\"%r10\");",
          "1414: $j=$jj=$r=$sn=$rx=0;",
          "1415: $Xi=4;",
          "1417: @aes256_dec = (",
          "1418:  '&vpxor ($inout0,$rndkey0,\"0x00($in0)\");',",
          "1419:  '&vpxor ($inout1,$rndkey0,\"0x10($in0)\");',",
          "1420:  '&vpxor ($inout2,$rndkey0,\"0x20($in0)\");',",
          "1421:  '&vpxor ($inout3,$rndkey0,\"0x30($in0)\");',",
          "1423:  '&vmovups($rndkey0,\"16-112($key)\");',",
          "1424:  '&vmovups(\"64(%rsp)\",@X[2]);',  # save IV, originally @X[3]",
          "1425:  undef,undef",
          "1426:  );",
          "1427: for ($i=0;$i<13;$i++) {",
          "1428:     push (@aes256_dec,(",
          "1429:  '&vaesdec ($inout0,$inout0,$rndkey0);',",
          "1430:  '&vaesdec ($inout1,$inout1,$rndkey0);',",
          "1431:  '&vaesdec ($inout2,$inout2,$rndkey0);',",
          "1432:  '&vaesdec ($inout3,$inout3,$rndkey0); &vmovups($rndkey0,\"'.(16*($i+2)-112).'($key)\");'",
          "1433:  ));",
          "1434:     push (@aes256_dec,(undef,undef)) if (($i>=3 && $i<=5) || $i>=11);",
          "1435:     push (@aes256_dec,(undef,undef)) if ($i==5);",
          "1436: }",
          "1437: push(@aes256_dec,(",
          "1438:  '&vaesdeclast ($inout0,$inout0,$rndkey0); &vmovups(@X[0],\"0x00($in0)\");',",
          "1439:  '&vaesdeclast ($inout1,$inout1,$rndkey0); &vmovups(@X[1],\"0x10($in0)\");',",
          "1440:  '&vaesdeclast ($inout2,$inout2,$rndkey0); &vmovups(@X[2],\"0x20($in0)\");',",
          "1441:  '&vaesdeclast ($inout3,$inout3,$rndkey0); &vmovups(@X[3],\"0x30($in0)\");',",
          "1443:  '&vxorps ($inout0,$inout0,\"64(%rsp)\"); &vmovdqu($rndkey0,\"-112($key)\");',",
          "1444:  '&vxorps ($inout1,$inout1,@X[0]); &vmovups(\"0x00($out,$in0)\",$inout0);',",
          "1445:  '&vxorps ($inout2,$inout2,@X[1]); &vmovups(\"0x10($out,$in0)\",$inout1);',",
          "1446:  '&vxorps ($inout3,$inout3,@X[2]); &vmovups(\"0x20($out,$in0)\",$inout2);',",
          "1448:  '&vmovups (\"0x30($out,$in0)\",$inout3);'",
          "1449:  ));",
          "1451: $code.=<<___;",
          "1452: .type aesni256_cbc_sha1_dec_avx,\\@function,6",
          "1453: .align 32",
          "1454: aesni256_cbc_sha1_dec_avx:",
          "1455:  mov `($win64?56:8)`(%rsp),$inp # load 7th argument",
          "1456:  push %rbx",
          "1457:  push %rbp",
          "1458:  push %r12",
          "1459:  push %r13",
          "1460:  push %r14",
          "1461:  push %r15",
          "1462:  lea `-104-($win64?10*16:0)`(%rsp),%rsp",
          "1463: ___",
          "1464: $code.=<<___ if ($win64);",
          "1465:  movaps %xmm6,96+0(%rsp)",
          "1466:  movaps %xmm7,96+16(%rsp)",
          "1467:  movaps %xmm8,96+32(%rsp)",
          "1468:  movaps %xmm9,96+48(%rsp)",
          "1469:  movaps %xmm10,96+64(%rsp)",
          "1470:  movaps %xmm11,96+80(%rsp)",
          "1471:  movaps %xmm12,96+96(%rsp)",
          "1472:  movaps %xmm13,96+112(%rsp)",
          "1473:  movaps %xmm14,96+128(%rsp)",
          "1474:  movaps %xmm15,96+144(%rsp)",
          "1475: .Lprologue_dec_avx:",
          "1476: ___",
          "1477: $code.=<<___;",
          "1478:  vzeroall",
          "1479:  mov $in0,%r12   # reassign arguments",
          "1480:  mov $out,%r13",
          "1481:  mov $len,%r14",
          "1482:  lea 112($key),%r15   # size optimization",
          "1483:  vmovdqu ($ivp),@X[3]   # load IV",
          "1484: ___",
          "1485: ($in0,$out,$len,$key)=map(\"%r$_\",(12..15)); # reassign arguments",
          "1486: $code.=<<___;",
          "1487:  shl \\$6,$len",
          "1488:  sub $in0,$out",
          "1489:  add $inp,$len  # end of input",
          "1491:  lea K_XX_XX(%rip),$K_XX_XX",
          "1492:  mov 0($ctx),$A  # load context",
          "1493:  mov 4($ctx),$B",
          "1494:  mov 8($ctx),$C",
          "1495:  mov 12($ctx),$D",
          "1496:  mov $B,@T[0]  # magic seed",
          "1497:  mov 16($ctx),$E",
          "1498:  mov $C,@T[1]",
          "1499:  xor $D,@T[1]",
          "1500:  and @T[1],@T[0]",
          "1502:  vmovdqa 64($K_XX_XX),@X[2] # pbswap mask",
          "1503:  vmovdqa 0($K_XX_XX),$Kx  # K_00_19",
          "1504:  vmovdqu 0($inp),@X[-4&7] # load input to %xmm[0-3]",
          "1505:  vmovdqu 16($inp),@X[-3&7]",
          "1506:  vmovdqu 32($inp),@X[-2&7]",
          "1507:  vmovdqu 48($inp),@X[-1&7]",
          "1508:  vpshufb @X[2],@X[-4&7],@X[-4&7] # byte swap",
          "1509:  add \\$64,$inp",
          "1510:  vpshufb @X[2],@X[-3&7],@X[-3&7]",
          "1511:  vpshufb @X[2],@X[-2&7],@X[-2&7]",
          "1512:  vpshufb @X[2],@X[-1&7],@X[-1&7]",
          "1513:  vpaddd $Kx,@X[-4&7],@X[0] # add K_00_19",
          "1514:  vpaddd $Kx,@X[-3&7],@X[1]",
          "1515:  vpaddd $Kx,@X[-2&7],@X[2]",
          "1516:  vmovdqa @X[0],0(%rsp)  # X[]+K xfer to IALU",
          "1517:  vmovdqa @X[1],16(%rsp)",
          "1518:  vmovdqa @X[2],32(%rsp)",
          "1519:  vmovups -112($key),$rndkey0 # $key[0]",
          "1520:  jmp .Loop_dec_avx",
          "1522: .align 32",
          "1523: .Loop_dec_avx:",
          "1524: ___",
          "1525:  &Xupdate_avx_16_31(\\&body_00_19_dec);",
          "1526:  &Xupdate_avx_16_31(\\&body_00_19_dec);",
          "1527:  &Xupdate_avx_16_31(\\&body_00_19_dec);",
          "1528:  &Xupdate_avx_16_31(\\&body_00_19_dec);",
          "1529:  &Xupdate_avx_32_79(\\&body_00_19_dec);",
          "1530:  &Xupdate_avx_32_79(\\&body_20_39_dec);",
          "1531:  &Xupdate_avx_32_79(\\&body_20_39_dec);",
          "1532:  &Xupdate_avx_32_79(\\&body_20_39_dec);",
          "1533:  &Xupdate_avx_32_79(\\&body_20_39_dec);",
          "1534:  &Xupdate_avx_32_79(\\&body_20_39_dec);",
          "1535:  &Xupdate_avx_32_79(\\&body_40_59_dec);",
          "1536:  &Xupdate_avx_32_79(\\&body_40_59_dec);",
          "1537:  &Xupdate_avx_32_79(\\&body_40_59_dec);",
          "1538:  &Xupdate_avx_32_79(\\&body_40_59_dec);",
          "1539:  &Xupdate_avx_32_79(\\&body_40_59_dec);",
          "1540:  &Xupdate_avx_32_79(\\&body_20_39_dec);",
          "1541:  &Xuplast_avx_80(\\&body_20_39_dec,\".Ldone_dec_avx\"); # can jump to \"done\"",
          "1543:     $saved_j=$j; @saved_V=@V;",
          "1544:     $saved_rx=$rx;",
          "1546:  &Xloop_avx(\\&body_20_39_dec);",
          "1547:  &Xloop_avx(\\&body_20_39_dec);",
          "1548:  &Xloop_avx(\\&body_20_39_dec);",
          "1550:  eval(@aes256_dec[-1]);   # last store",
          "1551: $code.=<<___;",
          "1552:  lea 64($in0),$in0",
          "1554:  add 0($ctx),$A   # update context",
          "1555:  add 4($ctx),@T[0]",
          "1556:  add 8($ctx),$C",
          "1557:  add 12($ctx),$D",
          "1558:  mov $A,0($ctx)",
          "1559:  add 16($ctx),$E",
          "1560:  mov @T[0],4($ctx)",
          "1561:  mov @T[0],$B   # magic seed",
          "1562:  mov $C,8($ctx)",
          "1563:  mov $C,@T[1]",
          "1564:  mov $D,12($ctx)",
          "1565:  xor $D,@T[1]",
          "1566:  mov $E,16($ctx)",
          "1567:  and @T[1],@T[0]",
          "1568:  jmp .Loop_dec_avx",
          "1570: .Ldone_dec_avx:",
          "1571: ___",
          "1572:     $jj=$j=$saved_j; @V=@saved_V;",
          "1573:     $rx=$saved_rx;",
          "1575:  &Xtail_avx(\\&body_20_39_dec);",
          "1576:  &Xtail_avx(\\&body_20_39_dec);",
          "1577:  &Xtail_avx(\\&body_20_39_dec);",
          "1579:  eval(@aes256_dec[-1]);   # last store",
          "1580: $code.=<<___;",
          "1582:  add 0($ctx),$A   # update context",
          "1583:  add 4($ctx),@T[0]",
          "1584:  add 8($ctx),$C",
          "1585:  mov $A,0($ctx)",
          "1586:  add 12($ctx),$D",
          "1587:  mov @T[0],4($ctx)",
          "1588:  add 16($ctx),$E",
          "1589:  mov $C,8($ctx)",
          "1590:  mov $D,12($ctx)",
          "1591:  mov $E,16($ctx)",
          "1592:  vmovups @X[3],($ivp)   # write IV",
          "1593:  vzeroall",
          "1594: ___",
          "1595: $code.=<<___ if ($win64);",
          "1596:  movaps 96+0(%rsp),%xmm6",
          "1597:  movaps 96+16(%rsp),%xmm7",
          "1598:  movaps 96+32(%rsp),%xmm8",
          "1599:  movaps 96+48(%rsp),%xmm9",
          "1600:  movaps 96+64(%rsp),%xmm10",
          "1601:  movaps 96+80(%rsp),%xmm11",
          "1602:  movaps 96+96(%rsp),%xmm12",
          "1603:  movaps 96+112(%rsp),%xmm13",
          "1604:  movaps 96+128(%rsp),%xmm14",
          "1605:  movaps 96+144(%rsp),%xmm15",
          "1606: ___",
          "1607: $code.=<<___;",
          "1608:  lea `104+($win64?10*16:0)`(%rsp),%rsi",
          "1609:  mov 0(%rsi),%r15",
          "1610:  mov 8(%rsi),%r14",
          "1611:  mov 16(%rsi),%r13",
          "1612:  mov 24(%rsi),%r12",
          "1613:  mov 32(%rsi),%rbp",
          "1614:  mov 40(%rsi),%rbx",
          "1615:  lea 48(%rsi),%rsp",
          "1616: .Lepilogue_dec_avx:",
          "1617:  ret",
          "1618: .size aesni256_cbc_sha1_dec_avx,.-aesni256_cbc_sha1_dec_avx",
          "1619: ___",
          "1620:       }}}",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1277:     if ($line=~/(aes[a-z]+)\\s+%xmm([0-9]+),\\s*%xmm([0-9]+)/) {",
          "1278:  my %opcodelet = (",
          "1280:  );",
          "1281:  return undef if (!defined($opcodelet{$1}));",
          "1282:  rex(\\@opcode,$3,$2);",
          "",
          "[Removed Lines]",
          "1279:   \"aesenc\" => 0xdc, \"aesenclast\" => 0xdd",
          "",
          "[Added Lines]",
          "1781:   \"aesenc\" => 0xdc, \"aesenclast\" => 0xdd,",
          "1782:   \"aesdec\" => 0xde, \"aesdeclast\" => 0xdf",
          "",
          "---------------"
        ],
        "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:   const AES_KEY *key, unsigned char iv[16],",
          "114:   SHA_CTX *ctx,const void *in0);",
          "116: #define data(ctx) ((EVP_AES_HMAC_SHA1 *)(ctx)->cipher_data)",
          "118: static int aesni_cbc_hmac_sha1_init_key(EVP_CIPHER_CTX *ctx,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: void aesni256_cbc_sha1_dec (const void *inp, void *out, size_t blocks,",
          "117:   const AES_KEY *key, unsigned char iv[16],",
          "118:   SHA_CTX *ctx,const void *in0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "137:  }",
          "139: #define STITCHED_CALL",
          "141: #if !defined(STITCHED_CALL)",
          "142: #define aes_off 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144: #undef STITCHED_DECRYPT_CALL",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "436:   pmac = (void *)(((size_t)mac.c+31)&((size_t)0-32));",
          "443:    size_t inp_len, mask, j, i;",
          "444:    unsigned int res, maxpad, pad, bitlen;",
          "445:    int ret = 1;",
          "446:    union { unsigned int  u[SHA_LBLOCK];",
          "447:     unsigned char c[SHA_CBLOCK]; }",
          "450:    if ((key->aux.tls_aad[plen-4]<<8|key->aux.tls_aad[plen-3])",
          "455:     return 0;",
          "462:    pad = out[len-1];",
          "",
          "[Removed Lines]",
          "439:   aesni_cbc_encrypt(in,out,len,",
          "440:     &key->ks,ctx->iv,0);",
          "451:        >= TLS1_1_VERSION)",
          "452:     iv = AES_BLOCK_SIZE;",
          "454:    if (len<(iv+SHA_DIGEST_LENGTH+1))",
          "458:    out += iv;",
          "459:    len -= iv;",
          "",
          "[Added Lines]",
          "450: #if defined(STITCHED_DECRYPT_CALL)",
          "451:    unsigned char tail_iv[AES_BLOCK_SIZE];",
          "452:    int stitch=0;",
          "453: #endif",
          "456:        >= TLS1_1_VERSION) {",
          "457:         if (len<(AES_BLOCK_SIZE+SHA_DIGEST_LENGTH+1))",
          "458:      return 0;",
          "461:     memcpy(ctx->iv,in,AES_BLOCK_SIZE);",
          "462:     in  += AES_BLOCK_SIZE;",
          "463:     out += AES_BLOCK_SIZE;",
          "464:     len -= AES_BLOCK_SIZE;",
          "465:    }",
          "466:    else if (len<(SHA_DIGEST_LENGTH+1))",
          "469: #if defined(STITCHED_DECRYPT_CALL)",
          "470:    if (len>=1024 && ctx->key_len==32) {",
          "472:     memcpy(tail_iv,in+len-2*AES_BLOCK_SIZE,AES_BLOCK_SIZE);",
          "473:     aesni_cbc_encrypt(in+len-AES_BLOCK_SIZE,",
          "474:       out+len-AES_BLOCK_SIZE,AES_BLOCK_SIZE,",
          "475:       &key->ks,tail_iv,0);",
          "476:     stitch=1;",
          "477:    } else",
          "478: #endif",
          "480:    aesni_cbc_encrypt(in,out,len,",
          "481:      &key->ks,ctx->iv,0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "476:    key->md = key->head;",
          "477:    SHA1_Update(&key->md,key->aux.tls_aad,plen);",
          "479: #if 1",
          "481:    if (len>=(256+SHA_CBLOCK)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "501: #if defined(STITCHED_DECRYPT_CALL)",
          "502:    if (stitch) {",
          "503:     blocks = (len-(256+32+SHA_CBLOCK))/SHA_CBLOCK;",
          "504:     aes_off = len-AES_BLOCK_SIZE-blocks*SHA_CBLOCK;",
          "505:     sha_off = SHA_CBLOCK-plen;",
          "507:     aesni_cbc_encrypt(in,out,aes_off,",
          "508:      &key->ks,ctx->iv,0);",
          "510:     SHA1_Update(&key->md,out,sha_off);",
          "511:     aesni256_cbc_sha1_dec(in+aes_off,",
          "512:      out+aes_off,blocks,&key->ks,ctx->iv,",
          "513:      &key->md,out+sha_off);",
          "515:     sha_off += blocks*=SHA_CBLOCK;",
          "516:     out += sha_off;",
          "517:     len -= sha_off;",
          "518:     inp_len -= sha_off;",
          "521:     memcpy(ctx->iv,tail_iv,AES_BLOCK_SIZE);",
          "522:    }",
          "523: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "630: #endif",
          "631:    return ret;",
          "632:   } else {",
          "633:    SHA1_Update(&key->md,out,len);",
          "634:   }",
          "635:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "679: #if defined(STITCHED_DECRYPT_CALL)",
          "680:    if (len>=1024 && ctx->key_len==32) {",
          "681:     if (sha_off%=SHA_CBLOCK)",
          "682:      blocks = (len-3*SHA_CBLOCK)/SHA_CBLOCK;",
          "683:     else",
          "684:      blocks = (len-2*SHA_CBLOCK)/SHA_CBLOCK;",
          "685:     aes_off = len-blocks*SHA_CBLOCK;",
          "687:     aesni_cbc_encrypt(in,out,aes_off,",
          "688:      &key->ks,ctx->iv,0);",
          "689:     SHA1_Update(&key->md,out,sha_off);",
          "690:     aesni256_cbc_sha1_dec(in+aes_off,",
          "691:      out+aes_off,blocks,&key->ks,ctx->iv,",
          "692:      &key->md,out+sha_off);",
          "694:     sha_off += blocks*=SHA_CBLOCK;",
          "695:     out += sha_off;",
          "696:     len -= sha_off;",
          "698:     key->md.Nh += blocks>>29;",
          "699:     key->md.Nl += blocks<<=3;",
          "700:     if (key->md.Nl<(unsigned int)blocks) key->md.Nh++;",
          "701:    } else",
          "702: #endif",
          "704:    aesni_cbc_encrypt(in,out,len,",
          "705:      &key->ks,ctx->iv,0);",
          "",
          "---------------"
        ],
        "crypto/evp/e_aes_cbc_hmac_sha256.c||crypto/evp/e_aes_cbc_hmac_sha256.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha256.c -> crypto/evp/e_aes_cbc_hmac_sha256.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "400:    iv = AES_BLOCK_SIZE;",
          "402: #if defined(STITCHED_CALL)",
          "404:       plen>(sha_off+iv) &&",
          "405:       (blocks=(plen-(sha_off+iv))/SHA256_CBLOCK)) {",
          "406:    SHA256_Update(&key->md,in+iv,sha_off);",
          "",
          "[Removed Lines]",
          "403:   if (OPENSSL_ia32cap_P[1]&(1<<(60-32)) &&",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "be125aa5bae0b6baac526890c835e10378b6df74",
      "candidate_info": {
        "commit_hash": "be125aa5bae0b6baac526890c835e10378b6df74",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/be125aa5bae0b6baac526890c835e10378b6df74",
        "files": [
          "ssl/s3_cbc.c"
        ],
        "message": "Fix IV check and padding removal.\n\nFix the calculation that checks there is enough room in a record\nafter removing padding and optional explicit IV. (by Steve)\n\nFor AEAD remove the correct number of padding bytes (by Andy)\n(cherry picked from commit 32cc2479b473c49ce869e57fded7e9a77b695c0d)\n\nResolved conflicts:\n\n\tssl/s3_cbc.c",
        "before_after_code_files": [
          "ssl/s3_cbc.c||ssl/s3_cbc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ],
          "candidate": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:        unsigned mac_size)",
          "140:  {",
          "141:  unsigned padding_length, good, to_check, i;",
          "150:   return 0;",
          "152:  padding_length = rec->data[rec->length-1];",
          "",
          "[Removed Lines]",
          "142:  const char has_explicit_iv = s->version == DTLS1_VERSION;",
          "143:  const unsigned overhead = 1 /* padding length byte */ +",
          "144:       mac_size +",
          "145:       (has_explicit_iv ? block_size : 0);",
          "149:  if (overhead > rec->length)",
          "",
          "[Added Lines]",
          "142:  const unsigned overhead = 1 /* padding length byte */ + mac_size;",
          "144:  if (s->version == DTLS1_VERSION)",
          "145:   {",
          "149:   if (overhead + block_size > rec->length)",
          "150:    return 0;",
          "152:   rec->data += block_size;",
          "153:   rec->input += block_size;",
          "154:   rec->length -= block_size;",
          "155:   }",
          "156:  else if (overhead > rec->length)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "208:  rec->length -= padding_length;",
          "226:  return (int)((good & 1) | (~good & -1));",
          "227:  }",
          "",
          "[Removed Lines]",
          "219:  if (has_explicit_iv)",
          "220:   {",
          "221:   rec->data += block_size;",
          "222:   rec->input += block_size;",
          "223:   rec->length -= block_size;",
          "224:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "59b1129e0a50fdf7e4e58d7c355783a7bfc1f44c",
      "candidate_info": {
        "commit_hash": "59b1129e0a50fdf7e4e58d7c355783a7bfc1f44c",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/59b1129e0a50fdf7e4e58d7c355783a7bfc1f44c",
        "files": [
          "ssl/s3_cbc.c"
        ],
        "message": "Fix IV check and padding removal.\n\nFix the calculation that checks there is enough room in a record\nafter removing padding and optional explicit IV. (by Steve)\n\nFor AEAD remove the correct number of padding bytes (by Andy)\n(cherry picked from commit be125aa5bae0b6baac526890c835e10378b6df74)",
        "before_after_code_files": [
          "ssl/s3_cbc.c||ssl/s3_cbc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ],
          "candidate": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:        unsigned mac_size)",
          "140:  {",
          "141:  unsigned padding_length, good, to_check, i;",
          "150:   return 0;",
          "152:  padding_length = rec->data[rec->length-1];",
          "",
          "[Removed Lines]",
          "142:  const char has_explicit_iv = s->version == DTLS1_VERSION;",
          "143:  const unsigned overhead = 1 /* padding length byte */ +",
          "144:       mac_size +",
          "145:       (has_explicit_iv ? block_size : 0);",
          "149:  if (overhead > rec->length)",
          "",
          "[Added Lines]",
          "142:  const unsigned overhead = 1 /* padding length byte */ + mac_size;",
          "144:  if (s->version == DTLS1_VERSION)",
          "145:   {",
          "149:   if (overhead + block_size > rec->length)",
          "150:    return 0;",
          "152:   rec->data += block_size;",
          "153:   rec->input += block_size;",
          "154:   rec->length -= block_size;",
          "155:   }",
          "156:  else if (overhead > rec->length)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "208:  rec->length -= padding_length;",
          "226:  return (int)((good & 1) | (~good & -1));",
          "227:  }",
          "",
          "[Removed Lines]",
          "219:  if (has_explicit_iv)",
          "220:   {",
          "221:   rec->data += block_size;",
          "222:   rec->input += block_size;",
          "223:   rec->length -= block_size;",
          "224:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
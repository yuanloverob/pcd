{
  "cve_id": "CVE-2020-10931",
  "cve_desc": "Memcached 1.6.x before 1.6.2 allows remote attackers to cause a denial of service (daemon crash) via a crafted binary protocol header to try_read_command_binary in memcached.c.",
  "repo": "memcached/memcached",
  "patch_hash": "02c6a2b62ddcb6fa4569a591d3461a156a636305",
  "patch_info": {
    "commit_hash": "02c6a2b62ddcb6fa4569a591d3461a156a636305",
    "repo": "memcached/memcached",
    "commit_url": "https://github.com/memcached/memcached/commit/02c6a2b62ddcb6fa4569a591d3461a156a636305",
    "files": [
      "memcached.c"
    ],
    "message": "Fix security issue reported by someone.\n\nsomeone will get their name attributed for future issues if they bother\nfollowing procedure.",
    "before_after_code_files": [
      "memcached.c||memcached.c"
    ]
  },
  "patch_diff": {
    "memcached.c||memcached.c": [
      "File: memcached.c -> memcached.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6180:         c->rbytes -= sizeof(c->binary_header) + extlen + keylen;",
      "6181:         c->rcurr += sizeof(c->binary_header) + extlen + keylen;",
      "",
      "[Removed Lines]",
      "6178:         char extbuf[sizeof(c->binary_header) + BIN_MAX_EXTLEN];",
      "6179:         memcpy(extbuf + sizeof(c->binary_header), c->rcurr + sizeof(c->binary_header), extlen);",
      "",
      "[Added Lines]",
      "6178:         char extbuf[sizeof(c->binary_header) + BIN_MAX_EXTLEN+1];",
      "6179:         memcpy(extbuf + sizeof(c->binary_header), c->rcurr + sizeof(c->binary_header),",
      "6180:                 extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN : extlen);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8e59147cba140aa7d592b483806a2a8fadb562a2",
      "candidate_info": {
        "commit_hash": "8e59147cba140aa7d592b483806a2a8fadb562a2",
        "repo": "memcached/memcached",
        "commit_url": "https://github.com/memcached/memcached/commit/8e59147cba140aa7d592b483806a2a8fadb562a2",
        "files": [
          "memcached.c",
          "memcached.h"
        ],
        "message": "network: refactor binprot's bizarre rbuf usage\n\nsince keys were (maybe) expanding to 64k, binprot overloads the\nread-into-key \"conn_nread\" state to read... a specific number of bytes\ninto the read buffer.\n\nHowever keys were never expanded in size, so this ends up being a waste\nof code and attaches binprot to management of the read buffer directly.\n\nInstead, re-parse the binary header if we don't have enough bytes and\nlet try_read_network() handle it like it does for ascii.\n\nAs a side effect, this prevents multiple memmove's of potentially a\nlarge amount of data for pipelined binprot commands, and under\nNEED_ALIGN.",
        "before_after_code_files": [
          "memcached.c||memcached.c",
          "memcached.h||memcached.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "memcached.c||memcached.c"
          ],
          "candidate": [
            "memcached.c||memcached.c"
          ]
        }
      },
      "candidate_diff": {
        "memcached.c||memcached.c": [
          "File: memcached.c -> memcached.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "120: #endif",
          "121: static void conn_free(conn *c);",
          "124: struct stats stats;",
          "125: struct stats_state stats_state;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124: static void process_bin_flush(conn *c, char *extbuf);",
          "125: static void process_bin_append_prepend(conn *c);",
          "126: static void process_bin_update(conn *c, char *extbuf);",
          "127: static void process_bin_get_or_touch(conn *c, char *extbuf);",
          "128: static void process_bin_delete(conn *c);",
          "129: static void complete_incr_bin(conn *c, char *extbuf);",
          "130: static void process_bin_stat(conn *c);",
          "131: static void process_bin_sasl_auth(conn *c);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1198:     c->item = 0;",
          "1199: }",
          "",
          "[Removed Lines]",
          "1204: static void* binary_get_request(conn *c) {",
          "1205:     char *ret = c->rcurr;",
          "1206:     ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +",
          "1207:             c->binary_header.request.extlen);",
          "1209:     assert(ret >= c->rbuf);",
          "1210:     return ret;",
          "1211: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1331:     conn_set_state(c, conn_new_cmd);",
          "1332: }",
          "1335:     item *it;",
          "1336:     char *key;",
          "1337:     size_t nkey;",
          "",
          "[Removed Lines]",
          "1334: static void complete_incr_bin(conn *c) {",
          "",
          "[Added Lines]",
          "1332: static void complete_incr_bin(conn *c, char *extbuf) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1340:     uint64_t cas = 0;",
          "1342:     protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->resp->wbuf;",
          "1345:     assert(c != NULL);",
          "",
          "[Removed Lines]",
          "1343:     protocol_binary_request_incr* req = binary_get_request(c);",
          "",
          "[Added Lines]",
          "1341:     protocol_binary_request_incr* req = (void *)extbuf;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1526:     }",
          "1527: }",
          "1530:     item *it;",
          "1532:     protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->resp->wbuf;",
          "",
          "[Removed Lines]",
          "1529: static void process_bin_get_or_touch(conn *c) {",
          "",
          "[Added Lines]",
          "1527: static void process_bin_get_or_touch(conn *c, char *extbuf) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1547:     }",
          "1549:     if (should_touch) {",
          "1551:         time_t exptime = ntohl(t->message.body.expiration);",
          "1553:         it = item_touch(key, nkey, realtime(exptime), c);",
          "",
          "[Removed Lines]",
          "1550:         protocol_binary_request_touch *t = binary_get_request(c);",
          "",
          "[Added Lines]",
          "1548:         protocol_binary_request_touch *t = (void *)extbuf;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1853:     }",
          "1854: }",
          "1909: static void handle_binary_protocol_error(conn *c) {",
          "1910:     write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);",
          "",
          "[Removed Lines]",
          "1856: static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {",
          "1857:     assert(c);",
          "1858:     c->substate = next_substate;",
          "1859:     c->rlbytes = c->keylen + extra;",
          "1862:     ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;",
          "1863:     if (c->rlbytes > c->rsize - offset) {",
          "1864:         size_t nsize = c->rsize;",
          "1865:         size_t size = c->rlbytes + sizeof(protocol_binary_request_header);",
          "1867:         while (size > nsize) {",
          "1868:             nsize *= 2;",
          "1869:         }",
          "1871:         if (nsize != c->rsize) {",
          "1872:             if (settings.verbose > 1) {",
          "1873:                 fprintf(stderr, \"%d: Need to grow buffer from %lu to %lu\\n\",",
          "1874:                         c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);",
          "1875:             }",
          "1876:             char *newm = realloc(c->rbuf, nsize);",
          "1877:             if (newm == NULL) {",
          "1878:                 STATS_LOCK();",
          "1879:                 stats.malloc_fails++;",
          "1880:                 STATS_UNLOCK();",
          "1881:                 if (settings.verbose) {",
          "1882:                     fprintf(stderr, \"%d: Failed to grow buffer.. closing connection\\n\",",
          "1883:                             c->sfd);",
          "1884:                 }",
          "1885:                 conn_set_state(c, conn_closing);",
          "1886:                 return;",
          "1887:             }",
          "1889:             c->rbuf= newm;",
          "1891:             c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);",
          "1892:             c->rsize = nsize;",
          "1893:         }",
          "1894:         if (c->rbuf != c->rcurr) {",
          "1895:             memmove(c->rbuf, c->rcurr, c->rbytes);",
          "1896:             c->rcurr = c->rbuf;",
          "1897:             if (settings.verbose > 1) {",
          "1898:                 fprintf(stderr, \"%d: Repack input buffer\\n\", c->sfd);",
          "1899:             }",
          "1900:         }",
          "1901:     }",
          "1904:     c->ritem = c->rcurr + sizeof(protocol_binary_request_header);",
          "1905:     conn_set_state(c, conn_nread);",
          "1906: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2127:     return rv;",
          "2128: }",
          "2131:     int protocol_error = 0;",
          "2133:     uint8_t extlen = c->binary_header.request.extlen;",
          "",
          "[Removed Lines]",
          "2130: static void dispatch_bin_command(conn *c) {",
          "",
          "[Added Lines]",
          "2076: static void dispatch_bin_command(conn *c, char *extbuf) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2212:             break;",
          "2213:         case PROTOCOL_BINARY_CMD_FLUSH:",
          "2214:             if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {",
          "2216:             } else {",
          "2217:                 protocol_error = 1;",
          "2218:             }",
          "",
          "[Removed Lines]",
          "2215:                 bin_read_key(c, bin_read_flush_exptime, extlen);",
          "",
          "[Added Lines]",
          "2161:                 process_bin_flush(c, extbuf);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2231:         case PROTOCOL_BINARY_CMD_REPLACE:",
          "2232:             if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {",
          "2234:             } else {",
          "2235:                 protocol_error = 1;",
          "2236:             }",
          "",
          "[Removed Lines]",
          "2233:                 bin_read_key(c, bin_reading_set_header, 8);",
          "",
          "[Added Lines]",
          "2179:                 process_bin_update(c, extbuf);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2241:         case PROTOCOL_BINARY_CMD_GETK:",
          "2242:             if (extlen == 0 && bodylen == keylen && keylen > 0) {",
          "2244:             } else {",
          "2245:                 protocol_error = 1;",
          "2246:             }",
          "2247:             break;",
          "2248:         case PROTOCOL_BINARY_CMD_DELETE:",
          "2249:             if (keylen > 0 && extlen == 0 && bodylen == keylen) {",
          "2251:             } else {",
          "2252:                 protocol_error = 1;",
          "2253:             }",
          "",
          "[Removed Lines]",
          "2243:                 bin_read_key(c, bin_reading_get_key, 0);",
          "2250:                 bin_read_key(c, bin_reading_del_header, extlen);",
          "",
          "[Added Lines]",
          "2189:                 process_bin_get_or_touch(c, extbuf);",
          "2196:                 process_bin_delete(c);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2255:         case PROTOCOL_BINARY_CMD_INCREMENT:",
          "2256:         case PROTOCOL_BINARY_CMD_DECREMENT:",
          "2257:             if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {",
          "2259:             } else {",
          "2260:                 protocol_error = 1;",
          "2261:             }",
          "",
          "[Removed Lines]",
          "2258:                 bin_read_key(c, bin_reading_incr_header, 20);",
          "",
          "[Added Lines]",
          "2204:                 complete_incr_bin(c, extbuf);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2263:         case PROTOCOL_BINARY_CMD_APPEND:",
          "2264:         case PROTOCOL_BINARY_CMD_PREPEND:",
          "2265:             if (keylen > 0 && extlen == 0) {",
          "2267:             } else {",
          "2268:                 protocol_error = 1;",
          "2269:             }",
          "2270:             break;",
          "2271:         case PROTOCOL_BINARY_CMD_STAT:",
          "2272:             if (extlen == 0) {",
          "2274:             } else {",
          "2275:                 protocol_error = 1;",
          "2276:             }",
          "",
          "[Removed Lines]",
          "2266:                 bin_read_key(c, bin_reading_set_header, 0);",
          "2273:                 bin_read_key(c, bin_reading_stat, 0);",
          "",
          "[Added Lines]",
          "2212:                 process_bin_append_prepend(c);",
          "2219:                 process_bin_stat(c);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2294:         case PROTOCOL_BINARY_CMD_SASL_AUTH:",
          "2295:         case PROTOCOL_BINARY_CMD_SASL_STEP:",
          "2296:             if (extlen == 0 && keylen != 0) {",
          "2298:             } else {",
          "2299:                 protocol_error = 1;",
          "2300:             }",
          "",
          "[Removed Lines]",
          "2297:                 bin_read_key(c, bin_reading_sasl_auth, 0);",
          "",
          "[Added Lines]",
          "2243:                 process_bin_sasl_auth(c);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2305:         case PROTOCOL_BINARY_CMD_GATK:",
          "2306:         case PROTOCOL_BINARY_CMD_GATKQ:",
          "2307:             if (extlen == 4 && keylen != 0) {",
          "2309:             } else {",
          "2310:                 protocol_error = 1;",
          "2311:             }",
          "",
          "[Removed Lines]",
          "2308:                 bin_read_key(c, bin_reading_touch_key, 4);",
          "",
          "[Added Lines]",
          "2254:                 process_bin_get_or_touch(c, extbuf);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2319:         handle_binary_protocol_error(c);",
          "2320: }",
          "2323:     char *key;",
          "2324:     int nkey;",
          "2325:     int vlen;",
          "2326:     item *it;",
          "2329:     assert(c != NULL);",
          "",
          "[Removed Lines]",
          "2322: static void process_bin_update(conn *c) {",
          "2327:     protocol_binary_request_set* req = binary_get_request(c);",
          "",
          "[Added Lines]",
          "2268: static void process_bin_update(conn *c, char *extbuf) {",
          "2273:     protocol_binary_request_set* req = (void *)extbuf;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2491:     c->substate = bin_read_set_value;",
          "2492: }",
          "2495:     time_t exptime = 0;",
          "2497:     rel_time_t new_oldest = 0;",
          "2499:     if (!settings.flush_enabled) {",
          "",
          "[Removed Lines]",
          "2494: static void process_bin_flush(conn *c) {",
          "2496:     protocol_binary_request_flush* req = binary_get_request(c);",
          "",
          "[Added Lines]",
          "2440: static void process_bin_flush(conn *c, char *extbuf) {",
          "2442:     protocol_binary_request_flush* req = (void *)extbuf;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2530:     item *it;",
          "2531:     uint32_t hv;",
          "2535:     char* key = binary_get_key(c);",
          "2536:     size_t nkey = c->binary_header.request.keylen;",
          "",
          "[Removed Lines]",
          "2533:     protocol_binary_request_delete* req = binary_get_request(c);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2553:     it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);",
          "2554:     if (it) {",
          "2556:         if (cas == 0 || cas == ITEM_get_cas(it)) {",
          "2557:             MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);",
          "2558:             pthread_mutex_lock(&c->thread->stats.mutex);",
          "",
          "[Removed Lines]",
          "2555:         uint64_t cas = ntohll(req->message.header.request.cas);",
          "",
          "[Added Lines]",
          "2499:         uint64_t cas = c->binary_header.request.cas;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2579:     assert(c->cmd >= 0);",
          "2581:     switch(c->substate) {",
          "2590:     case bin_read_set_value:",
          "2591:         complete_update_bin(c);",
          "2592:         break;",
          "2612:     case bin_reading_sasl_auth_data:",
          "2613:         process_bin_complete_sasl_auth(c);",
          "2614:         if (c->item) {",
          "",
          "[Removed Lines]",
          "2582:     case bin_reading_set_header:",
          "2583:         if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||",
          "2584:                 c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {",
          "2585:             process_bin_append_prepend(c);",
          "2586:         } else {",
          "2587:             process_bin_update(c);",
          "2588:         }",
          "2589:         break;",
          "2593:     case bin_reading_get_key:",
          "2594:     case bin_reading_touch_key:",
          "2595:         process_bin_get_or_touch(c);",
          "2596:         break;",
          "2597:     case bin_reading_stat:",
          "2598:         process_bin_stat(c);",
          "2599:         break;",
          "2600:     case bin_reading_del_header:",
          "2601:         process_bin_delete(c);",
          "2602:         break;",
          "2603:     case bin_reading_incr_header:",
          "2604:         complete_incr_bin(c);",
          "2605:         break;",
          "2606:     case bin_read_flush_exptime:",
          "2607:         process_bin_flush(c);",
          "2608:         break;",
          "2609:     case bin_reading_sasl_auth:",
          "2610:         process_bin_sasl_auth(c);",
          "2611:         break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "5901:         return 0;",
          "5902:     } else {",
          "5913:         protocol_binary_request_header* req;",
          "5916:         if (settings.verbose > 1) {",
          "",
          "[Removed Lines]",
          "5903: #ifdef NEED_ALIGN",
          "5904:         if (((long)(c->rcurr)) % 8 != 0) {",
          "5906:             memmove(c->rbuf, c->rcurr, c->rbytes);",
          "5907:             c->rcurr = c->rbuf;",
          "5908:             if (settings.verbose > 1) {",
          "5909:                 fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);",
          "5910:             }",
          "5911:         }",
          "5912: #endif",
          "5914:         req = (protocol_binary_request_header*)c->rcurr;",
          "",
          "[Added Lines]",
          "5820:         memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));",
          "5822:         req = &c->binary_header;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "5940:             return -1;",
          "5941:         }",
          "5943:         if (!resp_start(c)) {",
          "5945:             STATS_LOCK();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5851:         uint8_t extlen = c->binary_header.request.extlen;",
          "5852:         uint16_t keylen = c->binary_header.request.keylen;",
          "5853:         if (c->rbytes < keylen + extlen + sizeof(c->binary_header)) {",
          "5856:             return 0;",
          "5857:         }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5956:         c->cas = 0;",
          "5958:         c->last_cmd_time = current_time;",
          "5963:     }",
          "5965:     return 1;",
          "",
          "[Removed Lines]",
          "5959:         dispatch_bin_command(c);",
          "5961:         c->rbytes -= sizeof(c->binary_header);",
          "5962:         c->rcurr += sizeof(c->binary_header);",
          "",
          "[Added Lines]",
          "5879:         char extbuf[sizeof(c->binary_header) + BIN_MAX_EXTLEN];",
          "5880:         memcpy(extbuf + sizeof(c->binary_header), c->rcurr + sizeof(c->binary_header), extlen);",
          "5881:         c->rbytes -= sizeof(c->binary_header) + extlen + keylen;",
          "5882:         c->rcurr += sizeof(c->binary_header) + extlen + keylen;",
          "5884:         dispatch_bin_command(c, extbuf);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "6903:                 break;",
          "6904:             }",
          "6908:                 if (c->rbytes > 0) {",
          "6909:                     int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;",
          "6913:                     c->ritem += tocopy;",
          "6914:                     c->rlbytes -= tocopy;",
          "6915:                     c->rcurr += tocopy;",
          "",
          "[Removed Lines]",
          "6906:             if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {",
          "6910:                     if (c->ritem != c->rcurr) {",
          "6911:                         memmove(c->ritem, c->rcurr, tocopy);",
          "6912:                     }",
          "",
          "[Added Lines]",
          "6828:             if ((((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {",
          "6832:                     memmove(c->ritem, c->rcurr, tocopy);",
          "",
          "---------------"
        ],
        "memcached.h||memcached.h": [
          "File: memcached.h -> memcached.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: #define MAX_SENDBUF_SIZE (256 * 1024 * 1024)",
          "76: #define HASHPOWER_DEFAULT 16",
          "",
          "[Removed Lines]",
          "72: #define MIN_BIN_PKT_LENGTH 16",
          "73: #define BIN_PKT_HDR_WORDS (MIN_BIN_PKT_LENGTH/sizeof(uint32_t))",
          "",
          "[Added Lines]",
          "72: #define BIN_MAX_EXTLEN 20 // length of the _incr command is currently the longest.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4723d424f32acc3ee544d3a7bd91b9f05fe4c608",
      "candidate_info": {
        "commit_hash": "4723d424f32acc3ee544d3a7bd91b9f05fe4c608",
        "repo": "memcached/memcached",
        "commit_url": "https://github.com/memcached/memcached/commit/4723d424f32acc3ee544d3a7bd91b9f05fe4c608",
        "files": [
          "Makefile.am",
          "authfile.c",
          "authfile.h",
          "doc/protocol.txt",
          "memcached.c",
          "memcached.h",
          "t/ascii-auth.t",
          "t/authfile",
          "t/lib/MemcachedTest.pm"
        ],
        "message": "-Y [filename] for ascii authentication mode\n\nLoads \"username:password\\n\" tokens (up to 8) out of a supplied authfile.\n\nIf enabled, disables binary protocol (though may be able to enable both\nif sasl is also used?).\n\nauthentication is done via the \"set\" command. A separate handler is\nused to avoid some hot path conditionals and narrow the code\nexecuted in an unauthenticated state.\n\nie:\n\nset foo 0 0 7\\r\\n\nfoo bar\\r\\n\n\nreturns \"STORED\" on success. Else returns CLIENT_ERROR with some\ninformation.\n\nAny key is accepted: if using a client that doesn't try to authenticate\nwhen connecting to a pool of servers, the authentication set can be\ntried with the same key as one that failed to coerce the client to\nrouting to the correct server. Else an \"auth\" or similar key would\nalways go to the same server.",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "authfile.c||authfile.c",
          "authfile.h||authfile.h",
          "memcached.c||memcached.c",
          "memcached.h||memcached.h",
          "t/ascii-auth.t||t/ascii-auth.t",
          "t/lib/MemcachedTest.pm||t/liMemcachedTest.pm"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "memcached.c||memcached.c"
          ],
          "candidate": [
            "memcached.c||memcached.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:                     logger.c logger.h \\",
          "24:                     crawler.c crawler.h \\",
          "25:                     itoa_ljust.c itoa_ljust.h \\",
          "28: if BUILD_CACHE",
          "29: memcached_SOURCES += cache.c",
          "",
          "[Removed Lines]",
          "26:                     slab_automove.c slab_automove.h",
          "",
          "[Added Lines]",
          "26:                     slab_automove.c slab_automove.h \\",
          "27:                     authfile.c authfile.h",
          "",
          "---------------"
        ],
        "authfile.c||authfile.c": [
          "File: authfile.c -> authfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include <stdio.h>",
          "3: #include <stdlib.h>",
          "4: #include <string.h>",
          "5: #include <sys/types.h>",
          "6: #include <sys/stat.h>",
          "7: #include <unistd.h>",
          "9: #include \"authfile.h\"",
          "13: #define MAX_ENTRY_LEN 256",
          "15: #define MAX_ENTRIES 8",
          "17: typedef struct auth_entry {",
          "18:     char *user;",
          "19:     size_t ulen;",
          "20:     char *pass;",
          "21:     size_t plen;",
          "22: } auth_t;",
          "24: auth_t main_auth_entries[MAX_ENTRIES];",
          "25: int entry_cnt = 0;",
          "26: char *main_auth_data = NULL;",
          "28: enum authfile_ret authfile_load(const char *file) {",
          "29:     struct stat sb;",
          "30:     char *auth_data = NULL;",
          "31:     auth_t auth_entries[MAX_ENTRIES];",
          "33:     if (stat(file, &sb) == -1) {",
          "34:         return AUTHFILE_MISSING;",
          "35:     }",
          "37:     auth_data = calloc(1, sb.st_size);",
          "39:     if (auth_data == NULL) {",
          "40:         return AUTHFILE_OOM;",
          "41:     }",
          "43:     FILE *pwfile = fopen(file, \"r\");",
          "44:     if (pwfile == NULL) {",
          "46:         free(auth_data);",
          "47:         return AUTHFILE_OPENFAIL;",
          "48:     }",
          "50:     char *auth_cur = auth_data;",
          "51:     auth_t *entry_cur = auth_entries;",
          "52:     int used = 0;",
          "54:     while ((fgets(auth_cur, MAX_ENTRY_LEN, pwfile)) != NULL) {",
          "55:         int x;",
          "56:         int found = 0;",
          "58:         for (x = 0; x < MAX_ENTRY_LEN; x++) {",
          "59:             if (!found && auth_cur[x] == ':') {",
          "60:                 entry_cur->user = auth_cur;",
          "61:                 entry_cur->ulen = x;",
          "62:                 entry_cur->pass = &auth_cur[x+1];",
          "63:                 found = 1;",
          "64:             } else if (found) {",
          "66:                 if (auth_cur[x] == '\\n' ||",
          "67:                     auth_cur[x] == '\\r' ||",
          "68:                     auth_cur[x] == '\\0') {",
          "69:                     entry_cur->plen = x - (entry_cur->ulen + 1);",
          "70:                     break;",
          "71:                 }",
          "72:             }",
          "73:         }",
          "76:         if (!found) {",
          "77:             (void)fclose(pwfile);",
          "78:             free(auth_data);",
          "79:             return AUTHFILE_MALFORMED;",
          "80:         }",
          "83:         if (++used == MAX_ENTRIES) {",
          "84:             break;",
          "85:         }",
          "87:         if (auth_cur[x] == '\\0')",
          "88:             break;",
          "90:         auth_cur += x;",
          "91:         entry_cur++;",
          "92:     }",
          "96:     if (main_auth_data != NULL) {",
          "97:         free(main_auth_data);",
          "98:     }",
          "100:     entry_cnt = used;",
          "101:     main_auth_data = auth_data;",
          "102:     memcpy(main_auth_entries, auth_entries, sizeof(auth_entries));",
          "104:     (void)fclose(pwfile);",
          "106:     return AUTHFILE_OK;",
          "107: }",
          "110: int authfile_check(const char *user, const char *pass) {",
          "111:     size_t ulen = strlen(user);",
          "112:     size_t plen = strlen(pass);",
          "114:     for (int x = 0; x < entry_cnt; x++) {",
          "115:         auth_t *e = &main_auth_entries[x];",
          "116:         if (ulen == e->ulen && plen == e->plen &&",
          "117:             memcmp(user, e->user, e->ulen) == 0 &&",
          "118:             memcmp(pass, e->pass, e->plen) == 0) {",
          "119:             return 1;",
          "120:         }",
          "121:     }",
          "123:     return 0;",
          "124: }",
          "",
          "---------------"
        ],
        "authfile.h||authfile.h": [
          "File: authfile.h -> authfile.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef AUTHFILE_H",
          "2: #define AUTHFILE_H",
          "4: enum authfile_ret {",
          "5:     AUTHFILE_OK = 0,",
          "6:     AUTHFILE_MISSING,",
          "7:     AUTHFILE_OOM,",
          "8:     AUTHFILE_OPENFAIL,",
          "9:     AUTHFILE_MALFORMED,",
          "10: };",
          "13: enum authfile_ret authfile_load(const char *file);",
          "14: int authfile_check(const char *user, const char *pass);",
          "",
          "---------------"
        ],
        "memcached.c||memcached.c": [
          "File: memcached.c -> memcached.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #ifdef EXTSTORE",
          "18: #include \"storage.h\"",
          "19: #endif",
          "20: #include <sys/stat.h>",
          "21: #include <sys/socket.h>",
          "22: #include <sys/un.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"authfile.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80: static void drive_machine(conn *c);",
          "81: static int new_socket(struct addrinfo *ai);",
          "83: static ssize_t tcp_read(conn *arg, void *buf, size_t count);",
          "84: static ssize_t tcp_sendmsg(conn *arg, struct msghdr *msg, int flags);",
          "85: static ssize_t tcp_write(conn *arg, void *buf, size_t count);",
          "",
          "[Removed Lines]",
          "82: static int try_read_command(conn *c);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92: };",
          "94: static enum try_read_result try_read_network(conn *c);",
          "95: static enum try_read_result try_read_udp(conn *c);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94: static int try_read_command_negotiate(conn *c);",
          "95: static int try_read_command_udp(conn *c);",
          "96: static int try_read_command_binary(conn *c);",
          "97: static int try_read_command_ascii(conn *c);",
          "98: static int try_read_command_asciiauth(conn *c);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "657:     c->msgcurr = 0;",
          "658:     c->msgused = 0;",
          "659:     c->sasl_started = false;",
          "662: #ifdef EXTSTORE",
          "663:     c->io_wraplist = NULL;",
          "",
          "[Removed Lines]",
          "660:     c->authenticated = false;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "689:         c->write = tcp_write;",
          "690:     }",
          "692:     event_set(&c->event, sfd, event_flags, event_handler, (void *)c);",
          "693:     event_base_set(base, &c->event);",
          "694:     c->ev_flags = event_flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:     if (IS_UDP(transport)) {",
          "700:         c->try_read_command = try_read_command_udp;",
          "701:     } else {",
          "702:         switch (c->protocol) {",
          "703:             case ascii_prot:",
          "704:                 if (settings.auth_file == NULL) {",
          "705:                     c->authenticated = true;",
          "706:                     c->try_read_command = try_read_command_ascii;",
          "707:                 } else {",
          "708:                     c->authenticated = false;",
          "709:                     c->try_read_command = try_read_command_asciiauth;",
          "710:                 }",
          "711:                 break;",
          "712:             case binary_prot:",
          "714:                 c->authenticated = false;",
          "715:                 c->try_read_command = try_read_command_binary;",
          "716:                 break;",
          "717:             case negotiating_prot:",
          "718:                 c->try_read_command = try_read_command_negotiate;",
          "719:                 break;",
          "720:         }",
          "721:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3327:     APPEND_STAT(\"binding_protocol\", \"%s\",",
          "3328:                 prot_text(settings.binding_protocol));",
          "3329:     APPEND_STAT(\"auth_enabled_sasl\", \"%s\", settings.sasl ? \"yes\" : \"no\");",
          "3330:     APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);",
          "3331:     APPEND_STAT(\"maxconns_fast\", \"%s\", settings.maxconns_fast ? \"yes\" : \"no\");",
          "3332:     APPEND_STAT(\"hashpower_init\", \"%d\", settings.hashpower_init);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3361:     APPEND_STAT(\"auth_enabled_ascii\", \"%s\", settings.auth_file ? settings.auth_file : \"no\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5042:     return;",
          "5043: }",
          "5049:     assert(c != NULL);",
          "5050:     assert(c->rcurr <= (c->rbuf + c->rsize));",
          "5051:     assert(c->rbytes > 0);",
          "5064:     }",
          "5072: #ifdef NEED_ALIGN",
          "5080:             }",
          "5081: #endif",
          "5094:                 }",
          "5096:             }",
          "5110:             }",
          "5137:             return 0;",
          "5139:         el = memchr(c->rcurr, '\\n', c->rbytes);",
          "5140:         if (!el) {",
          "5141:             if (c->rbytes > 1024) {",
          "5157:             }",
          "5159:             return 0;",
          "5160:         }",
          "5176:     }",
          "5178:     return 1;",
          "5179: }",
          "",
          "[Removed Lines]",
          "5048: static int try_read_command(conn *c) {",
          "5053:     if (c->protocol == negotiating_prot || c->transport == udp_transport)  {",
          "5054:         if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {",
          "5055:             c->protocol = binary_prot;",
          "5056:         } else {",
          "5057:             c->protocol = ascii_prot;",
          "5058:         }",
          "5060:         if (settings.verbose > 1) {",
          "5061:             fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,",
          "5062:                     prot_text(c->protocol));",
          "5063:         }",
          "5066:     if (c->protocol == binary_prot) {",
          "5068:         if (c->rbytes < sizeof(c->binary_header)) {",
          "5070:             return 0;",
          "5071:         } else {",
          "5073:             if (((long)(c->rcurr)) % 8 != 0) {",
          "5075:                 memmove(c->rbuf, c->rcurr, c->rbytes);",
          "5076:                 c->rcurr = c->rbuf;",
          "5077:                 if (settings.verbose > 1) {",
          "5078:                     fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);",
          "5079:                 }",
          "5082:             protocol_binary_request_header* req;",
          "5083:             req = (protocol_binary_request_header*)c->rcurr;",
          "5085:             if (settings.verbose > 1) {",
          "5087:                 int ii;",
          "5088:                 fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);",
          "5089:                 for (ii = 0; ii < sizeof(req->bytes); ++ii) {",
          "5090:                     if (ii % 4 == 0) {",
          "5091:                         fprintf(stderr, \"\\n<%d   \", c->sfd);",
          "5092:                     }",
          "5093:                     fprintf(stderr, \" 0x%02x\", req->bytes[ii]);",
          "5095:                 fprintf(stderr, \"\\n\");",
          "5098:             c->binary_header = *req;",
          "5099:             c->binary_header.request.keylen = ntohs(req->request.keylen);",
          "5100:             c->binary_header.request.bodylen = ntohl(req->request.bodylen);",
          "5101:             c->binary_header.request.cas = ntohll(req->request.cas);",
          "5103:             if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {",
          "5104:                 if (settings.verbose) {",
          "5105:                     fprintf(stderr, \"Invalid magic:  %x\\n\",",
          "5106:                             c->binary_header.request.magic);",
          "5107:                 }",
          "5108:                 conn_set_state(c, conn_closing);",
          "5109:                 return -1;",
          "5112:             c->msgcurr = 0;",
          "5113:             c->msgused = 0;",
          "5114:             c->iovused = 0;",
          "5115:             if (add_msghdr(c) != 0) {",
          "5116:                 out_of_memory(c,",
          "5117:                         \"SERVER_ERROR Out of memory allocating headers\");",
          "5118:                 return 0;",
          "5119:             }",
          "5121:             c->cmd = c->binary_header.request.opcode;",
          "5122:             c->keylen = c->binary_header.request.keylen;",
          "5123:             c->opaque = c->binary_header.request.opaque;",
          "5125:             c->cas = 0;",
          "5127:             c->last_cmd_time = current_time;",
          "5128:             dispatch_bin_command(c);",
          "5130:             c->rbytes -= sizeof(c->binary_header);",
          "5131:             c->rcurr += sizeof(c->binary_header);",
          "5132:         }",
          "5133:     } else {",
          "5134:         char *el, *cont;",
          "5136:         if (c->rbytes == 0)",
          "5146:                 char *ptr = c->rcurr;",
          "5148:                     ++ptr;",
          "5149:                 }",
          "5151:                 if (ptr - c->rcurr > 100 ||",
          "5152:                     (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {",
          "5154:                     conn_set_state(c, conn_closing);",
          "5155:                     return 1;",
          "5156:                 }",
          "5161:         cont = el + 1;",
          "5162:         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {",
          "5163:             el--;",
          "5164:         }",
          "5167:         assert(cont <= (c->rcurr + c->rbytes));",
          "5169:         c->last_cmd_time = current_time;",
          "5170:         process_command(c, c->rcurr);",
          "5172:         c->rbytes -= (cont - c->rcurr);",
          "5173:         c->rcurr = cont;",
          "5175:         assert(c->rcurr <= (c->rbuf + c->rsize));",
          "",
          "[Added Lines]",
          "5077: static int try_read_command_negotiate(conn *c) {",
          "5078:     assert(c->protocol == negotiating_prot);",
          "5083:     if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {",
          "5084:         c->protocol = binary_prot;",
          "5085:         c->try_read_command = try_read_command_binary;",
          "5086:     } else {",
          "5088:         c->protocol = ascii_prot;",
          "5089:         c->try_read_command = try_read_command_ascii;",
          "5090:     }",
          "5092:     if (settings.verbose > 1) {",
          "5093:         fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,",
          "5094:                 prot_text(c->protocol));",
          "5097:     return c->try_read_command(c);",
          "5098: }",
          "5100: static int try_read_command_udp(conn *c) {",
          "5101:     assert(c != NULL);",
          "5102:     assert(c->rcurr <= (c->rbuf + c->rsize));",
          "5103:     assert(c->rbytes > 0);",
          "5105:     if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {",
          "5106:         c->protocol = binary_prot;",
          "5107:         return try_read_command_binary(c);",
          "5108:     } else {",
          "5109:         c->protocol = ascii_prot;",
          "5110:         return try_read_command_ascii(c);",
          "5111:     }",
          "5112: }",
          "5114: static int try_read_command_binary(conn *c) {",
          "5116:     if (c->rbytes < sizeof(c->binary_header)) {",
          "5118:         return 0;",
          "5119:     } else {",
          "5121:         if (((long)(c->rcurr)) % 8 != 0) {",
          "5123:             memmove(c->rbuf, c->rcurr, c->rbytes);",
          "5124:             c->rcurr = c->rbuf;",
          "5125:             if (settings.verbose > 1) {",
          "5126:                 fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);",
          "5128:         }",
          "5130:         protocol_binary_request_header* req;",
          "5131:         req = (protocol_binary_request_header*)c->rcurr;",
          "5133:         if (settings.verbose > 1) {",
          "5135:             int ii;",
          "5136:             fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);",
          "5137:             for (ii = 0; ii < sizeof(req->bytes); ++ii) {",
          "5138:                 if (ii % 4 == 0) {",
          "5139:                     fprintf(stderr, \"\\n<%d   \", c->sfd);",
          "5141:                 fprintf(stderr, \" 0x%02x\", req->bytes[ii]);",
          "5143:             fprintf(stderr, \"\\n\");",
          "5144:         }",
          "5146:         c->binary_header = *req;",
          "5147:         c->binary_header.request.keylen = ntohs(req->request.keylen);",
          "5148:         c->binary_header.request.bodylen = ntohl(req->request.bodylen);",
          "5149:         c->binary_header.request.cas = ntohll(req->request.cas);",
          "5151:         if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {",
          "5152:             if (settings.verbose) {",
          "5153:                 fprintf(stderr, \"Invalid magic:  %x\\n\",",
          "5154:                         c->binary_header.request.magic);",
          "5156:             conn_set_state(c, conn_closing);",
          "5157:             return -1;",
          "5158:         }",
          "5160:         c->msgcurr = 0;",
          "5161:         c->msgused = 0;",
          "5162:         c->iovused = 0;",
          "5163:         if (add_msghdr(c) != 0) {",
          "5164:             out_of_memory(c,",
          "5165:                     \"SERVER_ERROR Out of memory allocating headers\");",
          "5166:             return 0;",
          "5167:         }",
          "5169:         c->cmd = c->binary_header.request.opcode;",
          "5170:         c->keylen = c->binary_header.request.keylen;",
          "5171:         c->opaque = c->binary_header.request.opaque;",
          "5173:         c->cas = 0;",
          "5175:         c->last_cmd_time = current_time;",
          "5176:         dispatch_bin_command(c);",
          "5178:         c->rbytes -= sizeof(c->binary_header);",
          "5179:         c->rcurr += sizeof(c->binary_header);",
          "5180:     }",
          "5182:     return 1;",
          "5183: }",
          "5185: static int try_read_command_asciiauth(conn *c) {",
          "5186:     token_t tokens[MAX_TOKENS];",
          "5187:     size_t ntokens;",
          "5188:     char *cont = NULL;",
          "5191:     if (!c->sasl_started) {",
          "5192:         char *el;",
          "5193:         uint32_t size = 0;",
          "5196:         if (c->rbytes < 2)",
          "5204:                 conn_set_state(c, conn_closing);",
          "5205:                 return 1;",
          "5217:         ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);",
          "5219:         c->rbytes -= (el - c->rcurr) + 1;",
          "5220:         c->rcurr += (el - c->rcurr) + 1;",
          "5223:         if (ntokens < 6",
          "5224:                 || strcmp(tokens[0].value, \"set\") != 0",
          "5225:                 || !safe_strtoul(tokens[4].value, &size)) {",
          "5226:             out_string(c, \"CLIENT_ERROR unauthenticated\");",
          "5227:             return 1;",
          "5228:         }",
          "5232:         c->rlbytes = size + 2;",
          "5234:         c->sasl_started = true; // reuse from binprot sasl, but not sasl :)",
          "5235:     }",
          "5237:     if (c->rbytes < c->rlbytes) {",
          "5239:         return 0;",
          "5240:     }",
          "5242:     cont = c->rcurr;",
          "5244:     c->rbytes -= c->rlbytes;",
          "5245:     c->rcurr += c->rlbytes;",
          "5246:     c->sasl_started = false;",
          "5251:     if (strncmp(cont + c->rlbytes - 2, \"\\r\\n\", 2) != 0) {",
          "5252:         out_string(c, \"CLIENT_ERROR bad command line termination\");",
          "5253:         return 1;",
          "5254:     }",
          "5257:     cont[c->rlbytes - 2] = '\\0';",
          "5258:     ntokens = tokenize_command(cont, tokens, MAX_TOKENS);",
          "5260:     if (ntokens < 3) {",
          "5261:         out_string(c, \"CLIENT_ERROR bad authentication token format\");",
          "5262:         return 1;",
          "5263:     }",
          "5265:     if (authfile_check(tokens[0].value, tokens[1].value) == 1) {",
          "5266:         out_string(c, \"STORED\");",
          "5267:         c->authenticated = true;",
          "5268:         c->try_read_command = try_read_command_ascii;",
          "5269:         pthread_mutex_lock(&c->thread->stats.mutex);",
          "5270:         c->thread->stats.auth_cmds++;",
          "5271:         pthread_mutex_unlock(&c->thread->stats.mutex);",
          "5272:     } else {",
          "5273:         out_string(c, \"CLIENT_ERROR authentication failure\");",
          "5274:         pthread_mutex_lock(&c->thread->stats.mutex);",
          "5275:         c->thread->stats.auth_cmds++;",
          "5276:         c->thread->stats.auth_errors++;",
          "5277:         pthread_mutex_unlock(&c->thread->stats.mutex);",
          "5283: static int try_read_command_ascii(conn *c) {",
          "5284:     char *el, *cont;",
          "5286:     if (c->rbytes == 0)",
          "5287:         return 0;",
          "5289:     el = memchr(c->rcurr, '\\n', c->rbytes);",
          "5290:     if (!el) {",
          "5291:         if (c->rbytes > 1024) {",
          "5296:             char *ptr = c->rcurr;",
          "5298:                 ++ptr;",
          "5299:             }",
          "5301:             if (ptr - c->rcurr > 100 ||",
          "5302:                 (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {",
          "5304:                 conn_set_state(c, conn_closing);",
          "5305:                 return 1;",
          "5306:             }",
          "5307:         }",
          "5309:         return 0;",
          "5310:     }",
          "5311:     cont = el + 1;",
          "5312:     if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {",
          "5313:         el--;",
          "5314:     }",
          "5317:     assert(cont <= (c->rcurr + c->rbytes));",
          "5319:     c->last_cmd_time = current_time;",
          "5320:     process_command(c, c->rcurr);",
          "5322:     c->rbytes -= (cont - c->rcurr);",
          "5323:     c->rcurr = cont;",
          "5325:     assert(c->rcurr <= (c->rbuf + c->rsize));",
          "5327:     return 1;",
          "5328: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5642:             break;",
          "5644:         case conn_parse_cmd :",
          "5647:                 conn_set_state(c, conn_waiting);",
          "5648:             }",
          "",
          "[Removed Lines]",
          "5645:             if (try_read_command(c) == 0) {",
          "",
          "[Added Lines]",
          "5794:             if (c->try_read_command(c) == 0) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6347:     assoc_start_expand(stats_state.curr_items);",
          "6349:     evtimer_set(&clockevent, clock_handler, 0);",
          "6350:     event_base_set(main_base, &clockevent);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6499:     if (settings.sig_hup) {",
          "6500:         settings.sig_hup = false;",
          "6502:         authfile_load(settings.auth_file);",
          "6503:     }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6414: #endif",
          "6415:     printf(\"-F, --disable-flush-all   disable flush_all command\\n\");",
          "6416:     printf(\"-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\\n\");",
          "6417: #ifdef TLS",
          "6418:     printf(\"-Z, --enable-ssl          enable TLS/SSL\\n\");",
          "6419: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6573:     printf(\"-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\\n\"",
          "6574:            \"                          user:pass\\\\nuser2:pass2\\\\n\\n\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6620:     exit(EXIT_SUCCESS);",
          "6621: }",
          "6623: #ifndef HAVE_SIGIGNORE",
          "6624: static int sigignore(int sig) {",
          "6625:     struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6781: static void sighup_handler(const int sig) {",
          "6782:     settings.sig_hup = true;",
          "6783: }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "6935:     signal(SIGINT, sig_handler);",
          "6936:     signal(SIGTERM, sig_handler);",
          "6939:     settings_init();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7099:     signal(SIGHUP, sighup_handler);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7030:         {\"enable-sasl\", no_argument, 0, 'S'},",
          "7031:         {\"disable-flush-all\", no_argument, 0, 'F'},",
          "7032:         {\"disable-dumping\", no_argument, 0, 'X'},",
          "7033:         {\"extended\", required_argument, 0, 'o'},",
          "7034:         {0, 0, 0, 0}",
          "7035:     };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7197:         {\"auth-file\", required_argument, 0, 'Y'},",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "7231:        case 'X' :",
          "7232:             settings.dump_enabled = false;",
          "7233:             break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7399:        case 'Y' :",
          "7401:             settings.auth_file = strdup(optarg);",
          "7402:             break;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "7853:         }",
          "7854:     }",
          "7856:     if (udp_specified && settings.udpport != 0 && !tcp_specified) {",
          "7857:         settings.port = settings.udpport;",
          "7858:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8025:     if (settings.auth_file) {",
          "8026:         if (!protocol_specified) {",
          "8027:             settings.binding_protocol = ascii_prot;",
          "8028:         } else {",
          "8029:             if (settings.binding_protocol != ascii_prot) {",
          "8030:                 fprintf(stderr, \"ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\\n\");",
          "8031:                 exit(EX_USAGE);",
          "8032:             }",
          "8033:         }",
          "8034:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "7981:     main_base = event_init();",
          "7982: #endif",
          "7985:     logger_init();",
          "7986:     stats_init();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8165:     if (settings.auth_file) {",
          "8166:         if (settings.udpport) {",
          "8167:             fprintf(stderr, \"Cannot use UDP with ascii authentication enabled (-U 0 to disable)\\n\");",
          "8168:             exit(EX_USAGE);",
          "8169:         }",
          "8171:         switch (authfile_load(settings.auth_file)) {",
          "8172:             case AUTHFILE_MISSING: // fall through.",
          "8173:             case AUTHFILE_OPENFAIL:",
          "8174:                 vperror(\"Could not open authfile [%s] for reading\", settings.auth_file);",
          "8175:                 exit(EXIT_FAILURE);",
          "8176:                 break;",
          "8177:             case AUTHFILE_OOM:",
          "8178:                 fprintf(stderr, \"Out of memory reading password file: %s\", settings.auth_file);",
          "8179:                 exit(EXIT_FAILURE);",
          "8180:                 break;",
          "8181:             case AUTHFILE_MALFORMED:",
          "8182:                 fprintf(stderr, \"Authfile [%s] has a malformed entry. Should be 'user:password'\", settings.auth_file);",
          "8183:                 exit(EXIT_FAILURE);",
          "8184:                 break;",
          "8185:             case AUTHFILE_OK:",
          "8186:                 break;",
          "8187:         }",
          "8188:     }",
          "",
          "---------------"
        ],
        "memcached.h||memcached.h": [
          "File: memcached.h -> memcached.h"
        ],
        "t/ascii-auth.t||t/ascii-auth.t": [
          "File: t/ascii-auth.t -> t/ascii-auth.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/perl",
          "3: use strict;",
          "4: use Test::More tests => 9;",
          "5: use FindBin qw($Bin);",
          "6: use lib \"$Bin/lib\";",
          "7: use MemcachedTest;",
          "9: # FIXME: Some tests are forcing UDP to be enabled via MemcachedTest.pm - need",
          "10: # to audit and fix.",
          "11: my $server = new_memcached(\"-Y $Bin/authfile -U 0\");",
          "12: my $sock = $server->sock;",
          "14: # Test unauthenticated modes",
          "15: print $sock \"set foo 0 0 2\\r\\nhi\\r\\n\";",
          "16: like(scalar <$sock>, qr/CLIENT_ERROR/, \"failed to do a write\");",
          "17: print $sock \"get foo\\r\\n\";",
          "18: like(scalar <$sock>, qr/CLIENT_ERROR/, \"failed to do a read\");",
          "20: # Fail to authenticate.",
          "21: print $sock \"set foo 0 0 7\\r\\nfoo bab\\r\\n\";",
          "22: like(scalar <$sock>, qr/CLIENT_ERROR/, \"failed to authenticate\");",
          "24: # Try for real.",
          "25: print $sock \"set foo 0 0 7\\r\\nfoo bar\\r\\n\";",
          "26: like(scalar <$sock>, qr/STORED/, \"authenticated?\");",
          "28: print $sock \"set toast 0 0 2\\r\\nhi\\r\\n\";",
          "29: like(scalar <$sock>, qr/STORED/, \"stored an item that didn't look like user/pass\");",
          "31: mem_get_is($sock, \"toast\", \"hi\");",
          "33: # Create a second socket, try to authenticate against the second token.",
          "35: my $sock2 = $server->new_sock;",
          "37: print $sock2 \"set foo 0 0 10\\r\\nbaaaz quux\\r\\n\";",
          "38: like(scalar <$sock2>, qr/STORED/, \"authenticated a second socket?\");",
          "40: print $sock2 \"set toast2 0 0 2\\r\\nho\\r\\n\";",
          "41: like(scalar <$sock2>, qr/STORED/, \"stored an item that didn't look like user/pass\");",
          "43: mem_get_is($sock2, \"toast2\", \"ho\");",
          "45: # TODO: tests for reloads.",
          "",
          "---------------"
        ],
        "t/lib/MemcachedTest.pm||t/liMemcachedTest.pm": [
          "File: t/lib/MemcachedTest.pm -> t/liMemcachedTest.pm",
          "--- Hunk 1 ---",
          "[Context before]",
          "262:         }",
          "263:         $udpport = free_port(\"udp\");",
          "264:         $args .= \" -p $port\";",
          "266:             $args .= \" -U $udpport\";",
          "267:         }",
          "268:         if ($ssl_enabled) {",
          "",
          "[Removed Lines]",
          "265:         if (supports_udp()) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-7946",
  "cve_desc": "The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.",
  "repo": "radare/radare2",
  "patch_hash": "d1e8ac62c6d978d4662f69116e30230d43033c92",
  "patch_info": {
    "commit_hash": "d1e8ac62c6d978d4662f69116e30230d43033c92",
    "repo": "radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92",
    "files": [
      "libr/bin/format/mach0/mach0.c"
    ],
    "message": "Fix null deref and uaf in mach0 parser",
    "before_after_code_files": [
      "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
    ]
  },
  "patch_diff": {
    "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
      "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1119:   case LC_LOAD_WEAK_DYLIB:",
      "1120:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);",
      "1121:    bin->nlibs++;",
      "1123:     bprintf (\"Cannot parse dylib\\n\");",
      "1124:     bin->nlibs--;",
      "1125:     return false;",
      "",
      "[Removed Lines]",
      "1122:    if (!parse_dylib(bin, off)){",
      "",
      "[Added Lines]",
      "1122:    if (!parse_dylib (bin, off)){",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1130:    {",
      "1131:    ut8 dyldi[sizeof (struct dyld_info_command)] = {0};",
      "1132:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);",
      "1157:    }",
      "1158:    }",
      "1159:    break;",
      "",
      "[Removed Lines]",
      "1133:    bin->dyld_info = malloc (sizeof(struct dyld_info_command));",
      "1135:    if (off + sizeof (struct dyld_info_command) > bin->size){",
      "1136:     bprintf (\"Cannot parse dyldinfo\\n\");",
      "1137:     free (bin->dyld_info);",
      "1138:     return false;",
      "1139:    }",
      "1140:    if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {",
      "1141:     free (bin->dyld_info);",
      "1142:     bin->dyld_info = NULL;",
      "1143:     bprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
      "1144:    } else {",
      "1145:     bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);",
      "1146:     bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);",
      "1147:     bin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);",
      "1148:     bin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);",
      "1149:     bin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);",
      "1150:     bin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);",
      "1151:     bin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);",
      "1152:     bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);",
      "1153:     bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);",
      "1154:     bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);",
      "1155:     bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);",
      "1156:     bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);",
      "",
      "[Added Lines]",
      "1133:    bin->dyld_info = calloc (1, sizeof (struct dyld_info_command));",
      "1134:    if (bin->dyld_info) {",
      "1135:     if (off + sizeof (struct dyld_info_command) > bin->size){",
      "1136:      bprintf (\"Cannot parse dyldinfo\\n\");",
      "1137:      R_FREE (bin->dyld_info);",
      "1138:      return false;",
      "1139:     }",
      "1140:     if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {",
      "1141:      free (bin->dyld_info);",
      "1142:      bin->dyld_info = NULL;",
      "1143:      bprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
      "1144:     } else {",
      "1145:      bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);",
      "1146:      bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);",
      "1147:      bin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);",
      "1148:      bin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);",
      "1149:      bin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);",
      "1150:      bin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);",
      "1151:      bin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);",
      "1152:      bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);",
      "1153:      bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);",
      "1154:      bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);",
      "1155:      bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);",
      "1156:      bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);",
      "1157:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1747:   if ((bind_size + lazy_size)<1) {",
      "1748:    return NULL;",
      "1749:   }",
      "1751:    return NULL;",
      "1752:   if (bin->dyld_info->lazy_bind_off > bin->size || \\",
      "1754:    return NULL;",
      "1756:    return NULL;",
      "1759:    return NULL;",
      "1761:   opcodes = calloc (1, bind_size + lazy_size + 1);",
      "1762:   if (!opcodes) {",
      "1763:    free (relocs);",
      "",
      "[Removed Lines]",
      "1750:   if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)",
      "1753:    bin->dyld_info->lazy_bind_off + lazy_size > bin->size)",
      "1755:   if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)",
      "1758:   if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))",
      "",
      "[Added Lines]",
      "1751:   if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {",
      "1753:   }",
      "1755:    bin->dyld_info->lazy_bind_off + lazy_size > bin->size) {",
      "1757:   }",
      "1758:   if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {",
      "1760:   }",
      "1762:   if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {",
      "1764:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1905:   free (opcodes);",
      "1906:  } else {",
      "1907:   int j;",
      "1909:    return NULL;",
      "1911:    return NULL;",
      "1912:   for (j = 0; j < bin->dysymtab.nundefsym; j++) {",
      "1914:     relocs[i].ord = j;",
      "1915:     relocs[i++].last = 0;",
      "1916:    }",
      "",
      "[Removed Lines]",
      "1908:   if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)",
      "1910:   if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))",
      "1913:    if (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {",
      "",
      "[Added Lines]",
      "1912:   if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {",
      "1914:   }",
      "1915:   if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {",
      "1917:   }",
      "1919:    if (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1962:  struct lib_t *libs;",
      "1963:  int i;",
      "1966:   return NULL;",
      "1968:   return NULL;",
      "1969:  for (i = 0; i < bin->nlibs; i++) {",
      "1970:   strncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);",
      "1971:   libs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';",
      "",
      "[Removed Lines]",
      "1965:  if (!bin->nlibs)",
      "1967:  if (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))",
      "",
      "[Added Lines]",
      "1970:  if (!bin->nlibs) {",
      "1972:  }",
      "1973:  if (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {",
      "1975:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1978: ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {",
      "1979:  int i;",
      "1982:   return 0;",
      "1986:    return bin->segs[i].vmaddr;",
      "1987:  return 0;",
      "1988: }",
      "",
      "[Removed Lines]",
      "1981:  if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)",
      "1984:  for (i = 0; i < bin->nsegs; ++i)",
      "1985:   if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)",
      "",
      "[Added Lines]",
      "1988:  if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {",
      "1990:  }",
      "1991:  for (i = 0; i < bin->nsegs; ++i) {",
      "1992:   if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {",
      "1994:   }",
      "1995:  }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2309:   ut8 b[128];",
      "2310:   ut64 entry = addr_to_offset(bin, bin->entry);",
      "2313:    return 0;",
      "2314:   i = r_buf_read_at (bin->b, entry, b, sizeof (b));",
      "2315:   if (i < 1) {",
      "2316:    return 0;",
      "",
      "[Removed Lines]",
      "2312:   if (entry > bin->size || entry + sizeof (b) > bin->size)",
      "",
      "[Added Lines]",
      "2321:   if (entry > bin->size || entry + sizeof (b) > bin->size) {",
      "2323:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4e2cd40ed6866c6ee690ce2a640bdf7796054491",
      "candidate_info": {
        "commit_hash": "4e2cd40ed6866c6ee690ce2a640bdf7796054491",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/4e2cd40ed6866c6ee690ce2a640bdf7796054491",
        "files": [
          "libr/bin/bin.c",
          "libr/bin/format/elf/elf.c",
          "libr/bin/format/elf/elf.h",
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h",
          "libr/bin/format/pe/pe.c",
          "libr/bin/format/pe/pe.h",
          "libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_pe.c",
          "libr/core/cconfig.c",
          "libr/include/r_bin.h"
        ],
        "message": "Implement bin.verbose for ELF, PE and MACH0",
        "before_after_code_files": [
          "libr/bin/bin.c||libr/bin/bin.c",
          "libr/bin/format/elf/elf.c||libr/bin/format/elf/elf.c",
          "libr/bin/format/elf/elf.h||libr/bin/format/elf/elf.h",
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
          "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c",
          "libr/bin/format/pe/pe.h||libr/bin/format/pe/pe.h",
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c",
          "libr/core/cconfig.c||libr/core/cconfig.c",
          "libr/include/r_bin.h||libr/include/r_bin.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ],
          "candidate": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/bin.c||libr/bin/bin.c": [
          "File: libr/bin/bin.c -> libr/bin/bin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:   r_list_foreach ((l), _it, _el) { \\",
          "25:    _el->paddr += (o)->loadaddr;\\",
          "26:   }\\",
          "28:  } while (0)",
          "30: #define ARCHS_KEY \"archs\"",
          "",
          "[Removed Lines]",
          "27: \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "299:  return count;",
          "300: }",
          "304:  RBinPlugin *plugin = r_bin_file_cur_plugin (arch);",
          "305:  RBinString *ptr;",
          "306:  RListIter *it;",
          "",
          "[Removed Lines]",
          "302: static void get_strings_range(RBinFile *arch, RList *list, int min, ut64 from,",
          "303:           ut64 to) {",
          "",
          "[Added Lines]",
          "301: static void get_strings_range(RBinFile *arch, RList *list, int min, ut64 from, ut64 to) {",
          "",
          "---------------"
        ],
        "libr/bin/format/elf/elf.c||libr/bin/format/elf/elf.c": [
          "File: libr/bin/format/elf/elf.c -> libr/bin/format/elf/elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #define R_ELF_FULL_RELRO 2",
          "23: #define R_ELF_PART_RELRO 1",
          "25: #define READ8(x, i) r_read_ble8(x + i); i += 1;",
          "26: #define READ16(x, i) r_read_ble16(x + i, bin->endian); i += 2;",
          "27: #define READ32(x, i) r_read_ble32(x + i, bin->endian); i += 4;",
          "28: #define READ64(x, i) r_read_ble64(x + i, bin->endian); i += 8;",
          "31: static inline int __strnlen(const char *str, int len) {",
          "32:  int l = 0;",
          "33:  while (IS_PRINTABLE (*str) && --len) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #define bprintf if(bin->verbose)eprintf",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:  ut8 ehdr[sizeof (Elf_(Ehdr))] = {0};",
          "51:  int i, len;",
          "52:  if (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {",
          "54:   return false;",
          "55:  }",
          "56:  sdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"",
          "",
          "[Removed Lines]",
          "53:   eprintf (\"Warning: read (magic)\\n\");",
          "",
          "[Added Lines]",
          "53:   bprintf (\"Warning: read (magic)\\n\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95:  len = r_buf_read_at (bin->b, 0, ehdr, sizeof (Elf_(Ehdr)));",
          "96:  if (len < 1) {",
          "98:   return false;",
          "99:  }",
          "100:  memcpy (&bin->ehdr.e_ident, ehdr, 16);",
          "",
          "[Removed Lines]",
          "97:   eprintf (\"Warning: read (ehdr)\\n\");",
          "",
          "[Added Lines]",
          "97:   bprintf (\"Warning: read (ehdr)\\n\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "160:   j = 0;",
          "161:   len = r_buf_read_at (bin->b, bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr)), phdr, sizeof (Elf_(Phdr)));",
          "162:   if (len < 1) {",
          "164:    R_FREE (bin->phdr);",
          "165:    return false;",
          "166:   }",
          "",
          "[Removed Lines]",
          "163:    eprintf (\"Warning: read (phdr)\\n\");",
          "",
          "[Added Lines]",
          "163:    bprintf (\"Warning: read (phdr)\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "243:   j = 0;",
          "244:   len = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));",
          "245:   if (len < 1) {",
          "247:    R_FREE (bin->shdr);",
          "248:    return false;",
          "249:   }",
          "",
          "[Removed Lines]",
          "246:    eprintf (\"Warning: read (shdr) at 0x%\"PFMT64x\"\\n\", (ut64) bin->ehdr.e_shoff);",
          "",
          "[Added Lines]",
          "246:    bprintf (\"Warning: read (shdr) at 0x%\"PFMT64x\"\\n\", (ut64) bin->ehdr.e_shoff);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "328:  }",
          "329:  if (r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,",
          "330:     bin->shstrtab_section->sh_size + 1) < 1) {",
          "332:     (ut64) bin->shstrtab_section->sh_offset);",
          "333:   R_FREE (bin->shstrtab);",
          "334:   return false;",
          "",
          "[Removed Lines]",
          "331:   eprintf (\"Warning: read (shstrtab) at 0x%\"PFMT64x\"\\n\",",
          "",
          "[Added Lines]",
          "331:   bprintf (\"Warning: read (shstrtab) at 0x%\"PFMT64x\"\\n\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "410:   j = 0;",
          "411:   r_buf_read_at (bin->b, offset + i * sizeof (Elf_(Dyn)), sdyn, sizeof (Elf_(Dyn)));",
          "412:   if (len < 1) {",
          "414:   }",
          "415: #if R_BIN_ELF64",
          "416:   dyn[i].d_tag = READ64 (sdyn, j)",
          "",
          "[Removed Lines]",
          "413:    eprintf(\"Warning: read (dyn)\\n\");",
          "",
          "[Added Lines]",
          "413:    bprintf(\"Warning: read (dyn)\\n\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "437:  }",
          "438:  if (!strtabaddr || strtabaddr > bin->size || strsize > ST32_MAX || !strsize || strsize > bin->size) {",
          "439:   if (!strtabaddr) {",
          "441:   }",
          "442:   goto beach;",
          "443:  }",
          "",
          "[Removed Lines]",
          "440:    eprintf (\"Warning: section.shstrtab not found or invalid\\n\");",
          "",
          "[Added Lines]",
          "440:    bprintf (\"Warning: section.shstrtab not found or invalid\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "597:        goto beach;",
          "598:       }",
          "599:       if (r_buf_read_at (bin->b, offset, svn, sizeof (svn)) < 0) {",
          "601:        goto beach;",
          "602:       }",
          "603:       k = 0;",
          "",
          "[Removed Lines]",
          "600:        eprintf (\"Warning: Cannot read Verneed for Versym\\n\");",
          "",
          "[Added Lines]",
          "600:        bprintf (\"Warning: Cannot read Verneed for Versym\\n\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "612:         goto beach;",
          "613:        }",
          "614:        if (r_buf_read_at (bin->b, a_off, svna, sizeof (svna)) < 0) {",
          "616:         goto beach;",
          "617:        }",
          "618:        k = 0;",
          "",
          "[Removed Lines]",
          "615:         eprintf (\"Warning: Cannot read Vernaux for Versym\\n\");",
          "",
          "[Added Lines]",
          "615:         bprintf (\"Warning: Cannot read Vernaux for Versym\\n\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "646:      }",
          "647:      do {",
          "648:       if (r_buf_read_at (bin->b, offset, svd, sizeof (svd)) < 0) {",
          "650:        goto beach;",
          "651:       }",
          "652:       k = 0;",
          "",
          "[Removed Lines]",
          "649:        eprintf (\"Warning: Cannot read Verdef for Versym\\n\");",
          "",
          "[Added Lines]",
          "649:        bprintf (\"Warning: Cannot read Verdef for Versym\\n\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "668:        goto beach;",
          "669:       }",
          "670:       if (r_buf_read_at (bin->b, off_vda, svda, sizeof (svda)) < 0) {",
          "672:        goto beach;",
          "673:       }",
          "674:       k = 0;",
          "",
          "[Removed Lines]",
          "671:        eprintf (\"Warning: Cannot read Verdaux for Versym\\n\");",
          "",
          "[Added Lines]",
          "671:        bprintf (\"Warning: Cannot read Verdaux for Versym\\n\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "712:   link_section_name = &bin->shstrtab[link_shdr->sh_name];",
          "713:  }",
          "714:  if (!defs) {",
          "716:   return NULL;",
          "717:  }",
          "718:  sdb = sdb_new0 ();",
          "",
          "[Removed Lines]",
          "715:   eprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");",
          "",
          "[Added Lines]",
          "715:   bprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "836:   link_section_name = &bin->shstrtab[link_shdr->sh_name];",
          "837:  }",
          "838:  if (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {",
          "840:   goto beach;",
          "841:  }",
          "842:  end = need + shdr->sh_size;",
          "",
          "[Removed Lines]",
          "839:   eprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");",
          "",
          "[Added Lines]",
          "839:   bprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "923:    sdb_ns_set (sdb_version, key, sdb_vernaux);",
          "924:   }",
          "925:   if ((int)entry->vn_next < 0) {",
          "927:    break;",
          "928:   }",
          "929:   i += entry->vn_next;",
          "",
          "[Removed Lines]",
          "926:    eprintf (\"Invalid vn_next\\n\");",
          "",
          "[Added Lines]",
          "926:    bprintf (\"Invalid vn_next\\n\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1009:   section_name = &bin->shstrtab[bin->shdr[i].sh_name];",
          "1010:   if (bin->shdr[i].sh_type == SHT_STRTAB && !strcmp (section_name, \".dynstr\")) {",
          "1011:    if (!(bin->dynstr = (char*) calloc (bin->shdr[i].sh_size + 1, sizeof (char)))) {",
          "1013:     return false;",
          "1014:    }",
          "1015:    if (bin->shdr[i].sh_offset > bin->size) {",
          "",
          "[Removed Lines]",
          "1012:     eprintf(\"Warning: Cannot allocate memory for dynamic strings\\n\");",
          "",
          "[Added Lines]",
          "1012:     bprintf(\"Warning: Cannot allocate memory for dynamic strings\\n\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1053:   return false;",
          "1054:  }",
          "1055:  if (!init_phdr (bin)) {",
          "1057:  }",
          "1058:  if (!init_shdr (bin)) {",
          "1060:  }",
          "1061:  if (!init_strtab (bin)) {",
          "1063:  }",
          "1064:  if (!init_dynstr (bin)) {",
          "1066:  }",
          "1067:  bin->baddr = Elf_(r_bin_elf_get_baddr) (bin);",
          "1068:  if (!init_dynamic_section (bin) && !Elf_(r_bin_elf_get_static)(bin))",
          "1071:  bin->imports_by_ord_size = 0;",
          "1072:  bin->imports_by_ord = NULL;",
          "",
          "[Removed Lines]",
          "1056:   eprintf (\"Warning: Cannot initialize program headers\\n\");",
          "1059:   eprintf (\"Warning: Cannot initialize section headers\\n\");",
          "1062:   eprintf (\"Warning: Cannot initialize strings table\\n\");",
          "1065:   eprintf (\"Warning: Cannot initialize dynamic strings\\n\");",
          "1069:   eprintf (\"Warning: Cannot initialize dynamic section\\n\");",
          "",
          "[Added Lines]",
          "1056:   bprintf (\"Warning: Cannot initialize program headers\\n\");",
          "1059:   bprintf (\"Warning: Cannot initialize section headers\\n\");",
          "1062:   bprintf (\"Warning: Cannot initialize strings table\\n\");",
          "1065:   bprintf (\"Warning: Cannot initialize dynamic strings\\n\");",
          "1069:   bprintf (\"Warning: Cannot initialize dynamic section\\n\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1234:      free (REL);",
          "1235:      return plt_addr;",
          "1236:     } else {",
          "1238:     }",
          "1240:     break;",
          "",
          "[Removed Lines]",
          "1237:      eprintf (\"Unknown sparc reloc type %d\\n\", reloc_type);",
          "",
          "[Added Lines]",
          "1237:      bprintf (\"Unknown sparc reloc type %d\\n\", reloc_type);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1261:      plt_sym_addr = plt_addr + k * 16 + 32;",
          "1262:      goto done;",
          "1263:     default:",
          "1265:      break;",
          "1266:     }",
          "1267:     break;",
          "",
          "[Removed Lines]",
          "1264:      eprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);",
          "",
          "[Added Lines]",
          "1264:      bprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1336:      break;",
          "1337:      }",
          "1338:     default:",
          "1340:      free (REL);",
          "1341:      return of;",
          "1342:      break;",
          "",
          "[Removed Lines]",
          "1339:      eprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);",
          "",
          "[Added Lines]",
          "1339:      bprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1367:     }",
          "1368:     break;",
          "1369:    default:",
          "1371:      reloc_type, bin->ehdr.e_machine);",
          "1372:     break;",
          "1373:    }",
          "",
          "[Removed Lines]",
          "1370:     eprintf (\"Unsupported relocs type %d for arch %d\\n\",",
          "",
          "[Added Lines]",
          "1370:     bprintf (\"Unsupported relocs type %d for arch %d\\n\",",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1466:   return 0LL;",
          "1467:  }",
          "1468:  if (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {",
          "1470:   return 0;",
          "1471:  }",
          "1472:  if (buf[0] == 0x68) { // push // x86 only",
          "",
          "[Removed Lines]",
          "1469:   eprintf (\"Warning: read (init_offset)\\n\");",
          "",
          "[Added Lines]",
          "1469:   bprintf (\"Warning: read (init_offset)\\n\");",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1486:  }",
          "1488:  if (r_buf_read_at (bin->b, entry+11, buf, sizeof (buf)) == -1) {",
          "1490:   return 0;",
          "1491:  }",
          "1492:  if (*buf == 0x68) { // push // x86/32 only",
          "",
          "[Removed Lines]",
          "1489:   eprintf (\"Warning: read (get_fini)\\n\");",
          "",
          "[Added Lines]",
          "1489:   bprintf (\"Warning: read (get_fini)\\n\");",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1549:   return 0;",
          "1550:  }",
          "1551:  if (r_buf_read_at (bin->b, entry, buf, sizeof (buf)) < 1) {",
          "1553:   return 0;",
          "1554:  }",
          "",
          "[Removed Lines]",
          "1552:   eprintf (\"Warning: read (main)\\n\");",
          "",
          "[Added Lines]",
          "1552:   bprintf (\"Warning: read (main)\\n\");",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1643:    ut8 n32s[sizeof (ut32)] = {0};",
          "1644:    maddr = entry + 0x24 + r_read_le32 (buf + 0x20);",
          "1645:    if (r_buf_read_at (bin->b, maddr, n32s, sizeof (ut32)) == -1) {",
          "1647:     return 0;",
          "1648:    }",
          "1649:    maddr = (ut64)r_read_le32 (&n32s[0]);",
          "",
          "[Removed Lines]",
          "1646:     eprintf (\"Warning: read (maddr) 2\\n\");",
          "",
          "[Added Lines]",
          "1646:     bprintf (\"Warning: read (maddr) 2\\n\");",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1725:     return NULL;",
          "1726:    }",
          "1727:    if (r_buf_read_at (bin->b, addr, (ut8*)str, sz) < 1) {",
          "1729:     return 0;",
          "1730:    }",
          "1731:    str[sz] = 0;",
          "",
          "[Removed Lines]",
          "1728:     eprintf (\"Warning: read (main)\\n\");",
          "",
          "[Added Lines]",
          "1728:     bprintf (\"Warning: read (main)\\n\");",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2013:    ut8 *buf = malloc (regsize);",
          "2014:    if (r_buf_read_at (bin->b, bin->phdr[i].p_offset + regdelta, buf, regsize) != regsize) {",
          "2015:     free (buf);",
          "2017:     return NULL;",
          "2018:    }",
          "2019:    if (len) {",
          "",
          "[Removed Lines]",
          "2016:     eprintf (\"Cannot read register state from CORE file\\n\");",
          "",
          "[Added Lines]",
          "2016:     bprintf (\"Cannot read register state from CORE file\\n\");",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2022:    return buf;",
          "2023:   }",
          "2024:  }",
          "2026:  return NULL;",
          "2027: }",
          "",
          "[Removed Lines]",
          "2025:  eprintf (\"Cannot find NOTE section\\n\");",
          "",
          "[Added Lines]",
          "2025:  bprintf (\"Cannot find NOTE section\\n\");",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2164:     break;",
          "2165:    }",
          "2166:    if (rel >= reloc_num) {",
          "2168:              \"please file a bug report.\");",
          "2169:     break;",
          "2170:    }",
          "",
          "[Removed Lines]",
          "2167:     eprintf (\"Internal error: ELF relocation buffer too small,\"",
          "",
          "[Added Lines]",
          "2167:     bprintf (\"Internal error: ELF relocation buffer too small,\"",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2175:    }",
          "2176:    res = read_reloc (bin, &ret[rel], rela, bin->g_sections[i].offset + j);",
          "2177:    if (j + res > bin->g_sections[i].size) {",
          "2179:    }",
          "2180:    if (bin->ehdr.e_type == ET_REL) {",
          "2181:     if (bin->g_sections[i].info < bin->ehdr.e_shnum && bin->shdr) {",
          "",
          "[Removed Lines]",
          "2178:     eprintf (\"Warning: malformed file, relocation entry #%u is partially beyond the end of section %u.\\n\", rel, i);",
          "",
          "[Added Lines]",
          "2178:     bprintf (\"Warning: malformed file, relocation entry #%u is partially beyond the end of section %u.\\n\", rel, i);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2671:    }",
          "2672:    strtab_section = &bin->shdr[bin->shdr[i].sh_link];",
          "2673:    if (strtab_section->sh_size > ST32_MAX || strtab_section->sh_size+8 > bin->size) {",
          "2675:     free (ret);",
          "2676:     free (strtab);",
          "2677:     return NULL;",
          "2678:    }",
          "2679:    if (!strtab) {",
          "2680:     if (!(strtab = (char *)calloc (1, 8 + strtab_section->sh_size))) {",
          "2682:      goto beach;",
          "2683:     }",
          "2684:     if (strtab_section->sh_offset > bin->size ||",
          "",
          "[Removed Lines]",
          "2674:     eprintf (\"size (syms strtab)\");",
          "2681:      eprintf (\"malloc (syms strtab)\");",
          "",
          "[Added Lines]",
          "2674:     bprintf (\"size (syms strtab)\");",
          "2681:      bprintf (\"malloc (syms strtab)\");",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2687:     }",
          "2688:     if (r_buf_read_at (bin->b, strtab_section->sh_offset,",
          "2689:        (ut8*)strtab, strtab_section->sh_size) == -1) {",
          "2691:      goto beach;",
          "2692:     }",
          "2693:    }",
          "2695:    newsize = 1 + bin->shdr[i].sh_size;",
          "2696:    if (newsize < 0 || newsize > bin->size) {",
          "2698:     goto beach;",
          "2699:    }",
          "2700:    nsym = (int)(bin->shdr[i].sh_size / sizeof (Elf_(Sym)));",
          "",
          "[Removed Lines]",
          "2690:      eprintf (\"Warning: read (syms strtab)\\n\");",
          "2697:     eprintf (\"invalid shdr %d size\\n\", i);",
          "",
          "[Added Lines]",
          "2690:      bprintf (\"Warning: read (syms strtab)\\n\");",
          "2697:     bprintf (\"invalid shdr %d size\\n\", i);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2702:     goto beach;",
          "2703:    }",
          "2704:    if (!(sym = (Elf_(Sym) *)calloc (nsym, sizeof (Elf_(Sym))))) {",
          "2706:     goto beach;",
          "2707:    }",
          "2708:    if (!UT32_MUL (&size, nsym, sizeof (Elf_(Sym)))) {",
          "",
          "[Removed Lines]",
          "2705:     eprintf (\"calloc (syms)\");",
          "",
          "[Added Lines]",
          "2705:     bprintf (\"calloc (syms)\");",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2721:     int k = 0;",
          "2722:     r = r_buf_read_at (bin->b, bin->shdr[i].sh_offset + j * sizeof (Elf_(Sym)), s, sizeof (Elf_(Sym)));",
          "2723:     if (r < 1) {",
          "2725:      goto beach;",
          "2726:     }",
          "2727: #if R_BIN_ELF64",
          "",
          "[Removed Lines]",
          "2724:      eprintf (\"Warning: read (sym)\\n\");",
          "",
          "[Added Lines]",
          "2724:      bprintf (\"Warning: read (sym)\\n\");",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2743:    free (ret);",
          "2744:    ret = calloc (nsym, sizeof (RBinElfSymbol));",
          "2745:    if (!ret) {",
          "2747:     goto beach;",
          "2748:    }",
          "2749:    for (k = 1, ret_ctr = 0; k < nsym; k++) {",
          "",
          "[Removed Lines]",
          "2746:     eprintf (\"Cannot allocate %d symbols\\n\", nsym);",
          "",
          "[Added Lines]",
          "2746:     bprintf (\"Cannot allocate %d symbols\\n\", nsym);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2770:     }",
          "2771:     ret[ret_ctr].size = tsize;",
          "2772:     if (sym[k].st_name + 2 > strtab_section->sh_size) {",
          "2774:      goto beach;",
          "2775:     }",
          "2776:     {",
          "",
          "[Removed Lines]",
          "2773:      eprintf (\"Warning: index out of strtab range\\n\");",
          "",
          "[Added Lines]",
          "2773:      bprintf (\"Warning: index out of strtab range\\n\");",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2908:  return NULL;",
          "2909: }",
          "2912:  ut8 *buf;",
          "2913:  int size;",
          "2914:  ELFOBJ *bin = R_NEW0 (ELFOBJ);",
          "",
          "[Removed Lines]",
          "2911: ELFOBJ* Elf_(r_bin_elf_new)(const char* file) {",
          "",
          "[Added Lines]",
          "2911: ELFOBJ* Elf_(r_bin_elf_new)(const char* file, bool verbose) {",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2921:   return Elf_(r_bin_elf_free) (bin);",
          "2922:  }",
          "2923:  bin->size = size;",
          "2924:  bin->b = r_buf_new ();",
          "2925:  if (!r_buf_set_bytes (bin->b, buf, bin->size)) {",
          "2926:   free (buf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2924:  bin->verbose = verbose;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2934:  return bin;",
          "2935: }",
          "2938:  ELFOBJ *bin = R_NEW0 (ELFOBJ);",
          "2939:  bin->kv = sdb_new0 ();",
          "2940:  bin->b = r_buf_new ();",
          "2941:  bin->size = (ut32)buf->length;",
          "2942:  if (!r_buf_set_bytes (bin->b, buf->buf, buf->length)) {",
          "2943:   return Elf_(r_bin_elf_free) (bin);",
          "2944:  }",
          "",
          "[Removed Lines]",
          "2937: ELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf) {",
          "",
          "[Added Lines]",
          "2938: ELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose) {",
          "2943:  bin->verbose = verbose;",
          "",
          "---------------"
        ],
        "libr/bin/format/elf/elf.h||libr/bin/format/elf/elf.h": [
          "File: libr/bin/format/elf/elf.h -> libr/bin/format/elf/elf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:  ut64 baddr;",
          "104:  ut64 boffset;",
          "105:  int endian;",
          "106:  const char* file;",
          "107:  RBuffer *b;",
          "108:  Sdb *kv;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:  bool verbose;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "144: struct r_bin_elf_field_t* Elf_(r_bin_elf_get_fields)(struct Elf_(r_bin_elf_obj_t) *bin);",
          "145: char *Elf_(r_bin_elf_get_rpath)(struct Elf_(r_bin_elf_obj_t) *bin);",
          "146: void* Elf_(r_bin_elf_free)(struct Elf_(r_bin_elf_obj_t)* bin);",
          "149: ut64 Elf_(r_bin_elf_resize_section)(struct Elf_(r_bin_elf_obj_t) *bin, const char *name, ut64 size);",
          "150: bool Elf_(r_bin_elf_section_perms)(struct Elf_(r_bin_elf_obj_t) *bin, const char *name, int perms);",
          "151: bool Elf_(r_bin_elf_entry_write)(struct Elf_(r_bin_elf_obj_t) *bin, ut64 addr);",
          "",
          "[Removed Lines]",
          "147: struct Elf_(r_bin_elf_obj_t)* Elf_(r_bin_elf_new)(const char* file);",
          "148: struct Elf_(r_bin_elf_obj_t)* Elf_(r_bin_elf_new_buf)(struct r_buf_t *buf);",
          "",
          "[Added Lines]",
          "148: struct Elf_(r_bin_elf_obj_t)* Elf_(r_bin_elf_new)(const char* file, bool verbose);",
          "149: struct Elf_(r_bin_elf_obj_t)* Elf_(r_bin_elf_new_buf)(struct r_buf_t *buf, bool verbose);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include <r_util.h>",
          "6: #include \"mach0.h\"",
          "8: typedef struct _ulebr {",
          "9:  ut8 *p;",
          "10: } ulebr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #define bprintf if(bin->verbose)eprintf",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20:  do {",
          "21:   if (p == end) {",
          "22:    eprintf (\"malformed uleb128\");",
          "23:   }",
          "24:   slice = *p & 0x7f;",
          "25:   if (bit > 63) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25:    break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "41:  do {",
          "42:   if (p == end) {",
          "43:    eprintf (\"malformed sleb128\");",
          "44:   }",
          "45:   byte = *p++;",
          "46:   result |= (((st64)(byte & 0x7f)) << bit);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:    break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "90:  int len;",
          "92:  if (r_buf_read_at (bin->b, 0, magicbytes, 4) < 1) {",
          "94:   return false;",
          "95:  }",
          "96:  if (r_read_le32(magicbytes) == 0xfeedface) {",
          "",
          "[Removed Lines]",
          "93:   eprintf (\"Error: read (magic)\\n\");",
          "",
          "[Added Lines]",
          "96:   bprintf (\"Error: read (magic)\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "110:  }",
          "111:  len = r_buf_read_at (bin->b, 0, machohdrbytes, sizeof (machohdrbytes));",
          "112:  if (len != sizeof (machohdrbytes)) {",
          "114:   return false;",
          "115:  }",
          "116:  bin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);",
          "",
          "[Removed Lines]",
          "113:   eprintf (\"Error: read (hdr)\\n\");",
          "",
          "[Added Lines]",
          "116:   bprintf (\"Error: read (hdr)\\n\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "170:  j = bin->nsegs - 1;",
          "171:  len = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));",
          "172:  if (len != sizeof (struct MACH0_(segment_command))) {",
          "174:   return false;",
          "175:  }",
          "176:  i = 0;",
          "",
          "[Removed Lines]",
          "173:   eprintf (\"Error: read (seg)\\n\");",
          "",
          "[Added Lines]",
          "176:   bprintf (\"Error: read (seg)\\n\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "219:   bin->nsects += bin->segs[j].nsects;",
          "220:   if (bin->nsects > 128) {",
          "221:    int new_nsects = bin->nsects & 0xf;",
          "223:      bin->nsects, new_nsects);",
          "224:    bin->nsects = new_nsects;",
          "225:   }",
          "226:   if ((int)bin->nsects < 1) {",
          "228:    bin->nsects = sect;",
          "229:    return false;",
          "230:   }",
          "",
          "[Removed Lines]",
          "222:    eprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",",
          "227:    eprintf (\"Warning: Invalid number of sections\\n\");",
          "",
          "[Added Lines]",
          "225:    bprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",",
          "230:    bprintf (\"Warning: Invalid number of sections\\n\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "259:    ut64 offset = off + sizeof (struct MACH0_(segment_command)) + j * sizeof (struct MACH0_(section));",
          "260:    len = r_buf_read_at (bin->b, offset, sec, sizeof (struct MACH0_(section)));",
          "261:    if (len != sizeof (struct MACH0_(section))) {",
          "263:     bin->nsects = sect;",
          "264:     return false;",
          "265:    }",
          "",
          "[Removed Lines]",
          "262:     eprintf (\"Error: read (sects)\\n\");",
          "",
          "[Added Lines]",
          "265:     bprintf (\"Error: read (sects)\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "314:  }",
          "315:  int len = r_buf_read_at (bin->b, off, symt, sizeof (struct symtab_command));",
          "316:  if (len != sizeof (struct symtab_command)) {",
          "318:   return false;",
          "319:  }",
          "320:  st.cmd = r_read_ble32 (&symt[0], bin->big_endian);",
          "",
          "[Removed Lines]",
          "317:   eprintf (\"Error: read (symtab)\\n\");",
          "",
          "[Added Lines]",
          "320:   bprintf (\"Error: read (symtab)\\n\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "332:    return false;",
          "333:   }",
          "334:   if (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist)))) {",
          "336:    return false;",
          "337:   }",
          "338:   if (!size_sym) {",
          "340:    return false;",
          "341:   }",
          "342:   if (st.symoff > bin->size || st.symoff + size_sym > bin->size) {",
          "344:    return false;",
          "345:   }",
          "346:   if (!(bin->symstr = calloc (1, st.strsize + 2))) {",
          "",
          "[Removed Lines]",
          "335:    eprintf(\"fail2\\n\");",
          "339:    eprintf(\"fail3\\n\");",
          "343:    eprintf(\"fail4\\n\");",
          "",
          "[Added Lines]",
          "338:    bprintf(\"fail2\\n\");",
          "342:    bprintf(\"fail3\\n\");",
          "346:    bprintf(\"fail4\\n\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "350:   bin->symstrlen = st.strsize;",
          "351:   len = r_buf_read_at (bin->b, st.stroff, (ut8*)bin->symstr, st.strsize);",
          "352:   if (len != st.strsize) {",
          "354:    R_FREE (bin->symstr);",
          "355:    return false;",
          "356:   }",
          "",
          "[Removed Lines]",
          "353:    eprintf (\"Error: read (symstr)\\n\");",
          "",
          "[Added Lines]",
          "356:    bprintf (\"Error: read (symstr)\\n\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "362:    len = r_buf_read_at (bin->b, st.symoff + (i * sizeof (struct MACH0_(nlist))),",
          "363:         nlst, sizeof (struct MACH0_(nlist)));",
          "364:    if (len != sizeof (struct MACH0_(nlist))) {",
          "366:     R_FREE (bin->symtab);",
          "367:     return false;",
          "368:    }",
          "",
          "[Removed Lines]",
          "365:     eprintf (\"Error: read (nlist)\\n\");",
          "",
          "[Added Lines]",
          "368:     bprintf (\"Error: read (nlist)\\n\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "396:  len = r_buf_read_at(bin->b, off, dysym, sizeof (struct dysymtab_command));",
          "397:  if (len != sizeof (struct dysymtab_command)) {",
          "399:   return false;",
          "400:  }",
          "",
          "[Removed Lines]",
          "398:   eprintf (\"Error: read (dysymtab)\\n\");",
          "",
          "[Added Lines]",
          "401:   bprintf (\"Error: read (dysymtab)\\n\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "443:     i * sizeof (struct dylib_table_of_contents),",
          "444:     dytoc, sizeof (struct dylib_table_of_contents));",
          "445:    if (len != sizeof (struct dylib_table_of_contents)) {",
          "447:     R_FREE (bin->toc);",
          "448:     return false;",
          "449:    }",
          "",
          "[Removed Lines]",
          "446:     eprintf (\"Error: read (toc)\\n\");",
          "",
          "[Added Lines]",
          "449:     bprintf (\"Error: read (toc)\\n\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "475:     i * sizeof (struct MACH0_(dylib_module)),",
          "476:     dymod, sizeof (struct MACH0_(dylib_module)));",
          "477:    if (len == -1) {",
          "479:     R_FREE (bin->modtab);",
          "480:     return false;",
          "481:    }",
          "",
          "[Removed Lines]",
          "478:     eprintf (\"Error: read (modtab)\\n\");",
          "",
          "[Added Lines]",
          "481:     bprintf (\"Error: read (modtab)\\n\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "523:   for (i = 0; i < bin->nindirectsyms; i++) {",
          "524:    len = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);",
          "525:    if (len == -1) {",
          "527:     R_FREE (bin->indirectsyms);",
          "528:     return false;",
          "529:    }",
          "",
          "[Removed Lines]",
          "526:     eprintf (\"Error: read (indirect syms)\\n\");",
          "",
          "[Added Lines]",
          "529:     bprintf (\"Error: read (indirect syms)\\n\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "548:  }",
          "549:  len = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));",
          "550:  if (len != sizeof (struct linkedit_data_command)) {",
          "552:   return false;",
          "553:  }",
          "554:  link.cmd = r_read_ble32 (&lit[0], bin->big_endian);",
          "",
          "[Removed Lines]",
          "551:   eprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");",
          "",
          "[Added Lines]",
          "554:   bprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "645:     return false;",
          "646:    if ((len = r_buf_fread_at (bin->b, ptr_thread,",
          "647:     (ut8*)&bin->thread_state.x86_32, \"16i\", 1)) == -1) {",
          "649:     return false;",
          "650:    }",
          "651:    pc = bin->thread_state.x86_32.eip;",
          "",
          "[Removed Lines]",
          "648:     eprintf (\"Error: read (thread state x86_32)\\n\");",
          "",
          "[Added Lines]",
          "651:     bprintf (\"Error: read (thread state x86_32)\\n\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "658:     return false;",
          "659:    if ((len = r_buf_fread_at (bin->b, ptr_thread,",
          "660:     (ut8*)&bin->thread_state.x86_64, \"32l\", 1)) == -1) {",
          "662:     return false;",
          "663:    }",
          "664:    pc = bin->thread_state.x86_64.rip;",
          "",
          "[Removed Lines]",
          "661:     eprintf (\"Error: read (thread state x86_64)\\n\");",
          "",
          "[Added Lines]",
          "664:     bprintf (\"Error: read (thread state x86_64)\\n\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "676:     return false;",
          "677:    if ((len = r_buf_fread_at (bin->b, ptr_thread,",
          "678:     (ut8*)&bin->thread_state.ppc_32, bin->big_endian?\"40I\":\"40i\", 1)) == -1) {",
          "680:     return false;",
          "681:    }",
          "682:    pc = bin->thread_state.ppc_32.srr0;",
          "",
          "[Removed Lines]",
          "679:     eprintf (\"Error: read (thread state ppc_32)\\n\");",
          "",
          "[Added Lines]",
          "682:     bprintf (\"Error: read (thread state ppc_32)\\n\");",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "688:     return false;",
          "689:    if ((len = r_buf_fread_at (bin->b, ptr_thread,",
          "690:     (ut8*)&bin->thread_state.ppc_64, bin->big_endian?\"34LI3LI\":\"34li3li\", 1)) == -1) {",
          "692:     return false;",
          "693:    }",
          "694:    pc = bin->thread_state.ppc_64.srr0;",
          "",
          "[Removed Lines]",
          "691:     eprintf (\"Error: read (thread state ppc_64)\\n\");",
          "",
          "[Added Lines]",
          "694:     bprintf (\"Error: read (thread state ppc_64)\\n\");",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "702:    return false;",
          "703:   if ((len = r_buf_fread_at (bin->b, ptr_thread,",
          "704:     (ut8*)&bin->thread_state.arm_32, bin->big_endian?\"17I\":\"17i\", 1)) == -1) {",
          "706:    return false;",
          "707:   }",
          "708:   pc = bin->thread_state.arm_32.r15;",
          "",
          "[Removed Lines]",
          "705:    eprintf (\"Error: read (thread state arm)\\n\");",
          "",
          "[Added Lines]",
          "708:    bprintf (\"Error: read (thread state arm)\\n\");",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "716:   }",
          "717:   if ((len = r_buf_fread_at(bin->b, ptr_thread,",
          "718:     (ut8*)&bin->thread_state.arm_64, bin->big_endian?\"34LI1I\":\"34Li1i\", 1)) == -1) {",
          "720:    return false;",
          "721:   }",
          "722:   pc = r_read_be64 (&bin->thread_state.arm_64.pc);",
          "",
          "[Removed Lines]",
          "719:    eprintf (\"Error: read (thread state arm)\\n\");",
          "",
          "[Added Lines]",
          "722:    bprintf (\"Error: read (thread state arm)\\n\");",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "725:   arw_sz = sizeof (struct arm_thread_state64);",
          "726:   break;",
          "727:  default:",
          "729:   return false;",
          "730:  }",
          "733:  if (arw_ptr && arw_sz > 0) {",
          "734:   int i;",
          "735:   ut8 *p = arw_ptr;",
          "737:   for (i = 0; i < arw_sz; i++) {",
          "739:   }",
          "741:  }",
          "743:  if (is_first_thread) {",
          "",
          "[Removed Lines]",
          "728:   eprintf (\"Error: read (unknown thread state structure)\\n\");",
          "736:   eprintf (\"arw \");",
          "738:    eprintf (\"%02x\", 0xff & p[i]);",
          "740:   eprintf (\"\\n\");",
          "",
          "[Added Lines]",
          "731:   bprintf (\"Error: read (unknown thread state structure)\\n\");",
          "739:   bprintf (\"arw \");",
          "741:    bprintf (\"%02x\", 0xff & p[i]);",
          "743:   bprintf (\"\\n\");",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "753:  return true;",
          "754: wrong_read:",
          "756:  return false;",
          "757: }",
          "",
          "[Removed Lines]",
          "755:  eprintf (\"Error: read (thread)\\n\");",
          "",
          "[Added Lines]",
          "758:  bprintf (\"Error: read (thread)\\n\");",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "763:  int len;",
          "765:  if (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {",
          "767:    \" LC_FUNCTION_STARTS command\\n\");",
          "768:  }",
          "769:  bin->func_start = NULL;",
          "770:  len = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));",
          "771:  if (len < 1) {",
          "773:    \" LC_FUNCTION_STARTS command\\n\");",
          "774:  }",
          "775:  fc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);",
          "",
          "[Removed Lines]",
          "766:   eprintf (\"Likely overflow while parsing\"",
          "772:   eprintf (\"Failed to get data while parsing\"",
          "",
          "[Added Lines]",
          "769:   bprintf (\"Likely overflow while parsing\"",
          "775:   bprintf (\"Failed to get data while parsing\"",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "780:  buf = calloc (1, fc.datasize + 1);",
          "781:  if (!buf) {",
          "783:   return false;",
          "784:  }",
          "785:  bin->func_size = fc.datasize;",
          "786:  if (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {",
          "787:   free (buf);",
          "789:    \"LC_FUNCTION_STARTS command\\n\");",
          "790:   return false;",
          "791:  }",
          "792:  len = r_buf_read_at (bin->b, fc.dataoff, buf, fc.datasize);",
          "793:  if (len != fc.datasize) {",
          "794:   free (buf);",
          "796:    \" LC_FUNCTION_STARTS\\n\");",
          "797:   return false;",
          "798:  }",
          "",
          "[Removed Lines]",
          "782:   eprintf (\"Failed to allocate buffer\\n\");",
          "788:   eprintf (\"Likely overflow while parsing \"",
          "795:   eprintf (\"Failed to get data while parsing\"",
          "",
          "[Added Lines]",
          "785:   bprintf (\"Failed to allocate buffer\\n\");",
          "791:   bprintf (\"Likely overflow while parsing \"",
          "798:   bprintf (\"Failed to get data while parsing\"",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "816:  }",
          "817:  len = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));",
          "818:  if (len < 1) {",
          "820:   return false;",
          "821:  }",
          "822:  dl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);",
          "",
          "[Removed Lines]",
          "819:   eprintf (\"Error: read (dylib)\\n\");",
          "",
          "[Added Lines]",
          "822:   bprintf (\"Error: read (dylib)\\n\");",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "833:  len = r_buf_read_at (bin->b, off+dl.dylib.name, (ut8*)bin->libs[lib], R_BIN_MACH0_STRING_LENGTH);",
          "834:  if (len < 1) {",
          "836:   return false;",
          "837:  }",
          "838:  return true;",
          "",
          "[Removed Lines]",
          "835:   eprintf (\"Error: read (dylib str)\");",
          "",
          "[Added Lines]",
          "838:   bprintf (\"Error: read (dylib str)\");",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "849:  bin->os = 0;",
          "850:  bin->has_crypto = 0;",
          "851:  if (bin->hdr.sizeofcmds > bin->size) {",
          "853:   bin->hdr.sizeofcmds = bin->size - 128;",
          "855:  }",
          "857:  for (i = 0, off = sizeof (struct MACH0_(mach_header)); \\",
          "858:    i < bin->hdr.ncmds; i++, off += lc.cmdsize) {",
          "859:   if (off > bin->size || off + sizeof (struct load_command) > bin->size){",
          "861:    return false;",
          "862:   }",
          "863:   len = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));",
          "864:   if (len < 1) {",
          "866:    return false;",
          "867:   }",
          "868:   lc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);",
          "869:   lc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);",
          "871:   if (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {",
          "873:    break;",
          "874:   }",
          "",
          "[Removed Lines]",
          "852:   eprintf (\"Warning: chopping hdr.sizeofcmds\\n\");",
          "860:    eprintf (\"mach0: out of bounds command\\n\");",
          "865:    eprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);",
          "872:    eprintf (\"Warning: mach0_header %d = cmdsize<1.\\n\", i);",
          "",
          "[Added Lines]",
          "855:   bprintf (\"Warning: chopping hdr.sizeofcmds\\n\");",
          "863:    bprintf (\"mach0: out of bounds command\\n\");",
          "868:    bprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);",
          "875:    bprintf (\"Warning: mach0_header %d = cmdsize<1.\\n\", i);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "885:    break;",
          "886:   case LC_RPATH:",
          "887:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"rpath\", 0);",
          "889:    break;",
          "890:   case LC_SEGMENT_64:",
          "891:   case LC_SEGMENT:",
          "892:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"segment\", 0);",
          "893:    bin->nsegs++;",
          "894:    if (!parse_segments (bin, off)) {",
          "896:     bin->nsegs--;",
          "897:     return false;",
          "898:    }",
          "",
          "[Removed Lines]",
          "895:     eprintf (\"error parsing segment\\n\");",
          "",
          "[Added Lines]",
          "898:     bprintf (\"error parsing segment\\n\");",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "900:   case LC_SYMTAB:",
          "901:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"symtab\", 0);",
          "902:    if (!parse_symtab (bin, off)) {",
          "904:     return false;",
          "905:    }",
          "906:    break;",
          "907:   case LC_DYSYMTAB:",
          "908:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dysymtab\", 0);",
          "909:    if (!parse_dysymtab(bin, off)) {",
          "911:     return false;",
          "912:    }",
          "913:    break;",
          "914:   case LC_DYLIB_CODE_SIGN_DRS:",
          "915:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylib_code_sign_drs\", 0);",
          "917:    break;",
          "918:   case LC_VERSION_MIN_MACOSX:",
          "919:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_macosx\", 0);",
          "920:    bin->os = 1;",
          "923:    break;",
          "924:   case LC_VERSION_MIN_IPHONEOS:",
          "925:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_iphoneos\", 0);",
          "926:    bin->os = 2;",
          "929:    break;",
          "930:   case LC_VERSION_MIN_TVOS:",
          "931:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_tvos\", 0);",
          "",
          "[Removed Lines]",
          "903:     eprintf (\"error parsing symtab\\n\");",
          "910:     eprintf (\"error parsing dysymtab\\n\");",
          "",
          "[Added Lines]",
          "906:     bprintf (\"error parsing symtab\\n\");",
          "913:     bprintf (\"error parsing dysymtab\\n\");",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "940:    {",
          "941:    struct uuid_command uc = {0};",
          "942:    if (off + sizeof (struct uuid_command) > bin->size) {",
          "944:     return false;",
          "945:    }",
          "946:    if (r_buf_fread_at (bin->b, off, (ut8*)&uc, \"24c\", 1) != -1) {",
          "",
          "[Removed Lines]",
          "943:     eprintf (\"UUID out of obunds\\n\");",
          "",
          "[Added Lines]",
          "946:     bprintf (\"UUID out of obunds\\n\");",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "961:    struct MACH0_(encryption_info_command) eic = {0};",
          "962:    ut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};",
          "963:    if (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {",
          "965:     return false;",
          "966:    }",
          "967:    if (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {",
          "",
          "[Removed Lines]",
          "964:     eprintf (\"encryption info out of bounds\\n\");",
          "",
          "[Added Lines]",
          "967:     bprintf (\"encryption info out of bounds\\n\");",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "984:     sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylinker\", 0);",
          "985:     free (bin->intrp);",
          "986:     bin->intrp = NULL;",
          "988:     struct dylinker_command dy = {0};",
          "989:     ut8 sdy[sizeof (struct dylinker_command)] = {0};",
          "990:     if (off + sizeof (struct dylinker_command) > bin->size){",
          "992:      return false;",
          "993:     }",
          "994:     if (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {",
          "996:     } else {",
          "997:      dy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);",
          "998:      dy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);",
          "",
          "[Removed Lines]",
          "991:      eprintf (\"Warning: Cannot parse dylinker command\\n\");",
          "995:      eprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
          "",
          "[Added Lines]",
          "994:      bprintf (\"Warning: Cannot parse dylinker command\\n\");",
          "998:      bprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1020:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"main\", 0);",
          "1022:    if (!is_first_thread) {",
          "1024:     return false;",
          "1025:    }",
          "1026:    if (off + 8 > bin->size || off + sizeof (ep) > bin->size) {",
          "1028:     return false;",
          "1029:    }",
          "1030:    r_buf_read_at (bin->b, off + 8, sep, 2 * sizeof (ut64));",
          "",
          "[Removed Lines]",
          "1023:     eprintf(\"Error: LC_MAIN with other threads\\n\");",
          "1027:     eprintf (\"invalid command size for main\\n\");",
          "",
          "[Added Lines]",
          "1026:     bprintf(\"Error: LC_MAIN with other threads\\n\");",
          "1030:     bprintf (\"invalid command size for main\\n\");",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1043:   case LC_UNIXTHREAD:",
          "1044:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"unixthread\", 0);",
          "1045:    if (!is_first_thread) {",
          "1047:     return false;",
          "1048:    }",
          "1049:   case LC_THREAD:",
          "1050:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"thread\", 0);",
          "1051:    if (!parse_thread (bin, &lc, off, is_first_thread)) {",
          "1053:     return false;",
          "1054:    }",
          "1055:    is_first_thread = false;",
          "",
          "[Removed Lines]",
          "1046:     eprintf(\"Error: LC_UNIXTHREAD with other threads\\n\");",
          "1052:     eprintf (\"Cannot parse thread\\n\");",
          "",
          "[Added Lines]",
          "1049:     bprintf(\"Error: LC_UNIXTHREAD with other threads\\n\");",
          "1055:     bprintf (\"Cannot parse thread\\n\");",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1059:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);",
          "1060:    bin->nlibs++;",
          "1061:    if (!parse_dylib(bin, off)){",
          "1063:     bin->nlibs--;",
          "1064:     return false;",
          "1065:    }",
          "",
          "[Removed Lines]",
          "1062:     eprintf (\"Cannot parse dylib\\n\");",
          "",
          "[Added Lines]",
          "1065:     bprintf (\"Cannot parse dylib\\n\");",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1072:    bin->dyld_info = malloc (sizeof(struct dyld_info_command));",
          "1074:    if (off + sizeof (struct dyld_info_command) > bin->size){",
          "1076:     free (bin->dyld_info);",
          "1077:     return false;",
          "1078:    }",
          "1079:    if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {",
          "1080:     free (bin->dyld_info);",
          "1081:     bin->dyld_info = NULL;",
          "1083:    } else {",
          "1084:     bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);",
          "1085:     bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);",
          "",
          "[Removed Lines]",
          "1075:     eprintf (\"Cannot parse dyldinfo\\n\");",
          "1082:     eprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
          "",
          "[Added Lines]",
          "1078:     bprintf (\"Cannot parse dyldinfo\\n\");",
          "1085:     bprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1115:   case LC_FUNCTION_STARTS:",
          "1116:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"function_starts\", 0);",
          "1117:    if (!parse_function_starts (bin, off)) {",
          "1119:    }",
          "1120:    break;",
          "1121:   case LC_REEXPORT_DYLIB:",
          "",
          "[Removed Lines]",
          "1118:     eprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");",
          "",
          "[Added Lines]",
          "1121:     bprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1137:  } endian = { 1 };",
          "1138:  little_ = endian.byte[0];",
          "1139:  if (!init_hdr(bin)) {",
          "1141:   return false;",
          "1142:  }",
          "1146:  bin->baddr = MACH0_(get_baddr)(bin);",
          "1147:  return true;",
          "1148: }",
          "1150: void* MACH0_(mach0_free)(struct MACH0_(obj_t)* bin) {",
          "1152:  free (bin->segs);",
          "1153:  free (bin->sects);",
          "1154:  free (bin->symtab);",
          "",
          "[Removed Lines]",
          "1140:   eprintf (\"Warning: File is not MACH0\\n\");",
          "1143:  if (!init_items(bin))",
          "1144:   eprintf (\"Warning: Cannot initialize items\\n\");",
          "1151:  if (!bin) return NULL;",
          "",
          "[Added Lines]",
          "1143:   bprintf (\"Warning: File is not MACH0\\n\");",
          "1146:  if (!init_items (bin)) {",
          "1147:   bprintf (\"Warning: Cannot initialize items\\n\");",
          "1148:  }",
          "1154:  if (!bin) {",
          "1155:   return NULL;",
          "1156:  }",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1166:  return NULL;",
          "1167: }",
          "1170:  ut8 *buf;",
          "1171:  struct MACH0_(obj_t) *bin;",
          "1174:   return NULL;",
          "1175:  memset (bin, 0, sizeof (struct MACH0_(obj_t)));",
          "1176:  bin->file = file;",
          "1177:  if (!(buf = (ut8*)r_file_slurp(file, &bin->size)))",
          "1178:   return MACH0_(mach0_free)(bin);",
          "",
          "[Removed Lines]",
          "1169: struct MACH0_(obj_t)* MACH0_(mach0_new)(const char* file) {",
          "1173:  if (!(bin = malloc (sizeof (struct MACH0_(obj_t)))))",
          "",
          "[Added Lines]",
          "1174: struct MACH0_(obj_t)* MACH0_(mach0_new)(const char* file, bool verbose) {",
          "1177:  if (!(bin = malloc (sizeof (struct MACH0_(obj_t))))) {",
          "1179:  }",
          "1181:  bin->verbose = verbose;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1182:   return MACH0_(mach0_free)(bin);",
          "1183:  }",
          "1184:  free (buf);",
          "1186:  bin->dyld_info = NULL;",
          "1189:   return MACH0_(mach0_free)(bin);",
          "1191:  bin->imports_by_ord_size = 0;",
          "1192:  bin->imports_by_ord = NULL;",
          "1194:  return bin;",
          "1195: }",
          "1198:  struct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));",
          "1200:  bin->kv = sdb_new (NULL, \"bin.mach0\", 0);",
          "1201:  bin->b = r_buf_new ();",
          "1202:  bin->size = buf->length;",
          "1203:  if (!r_buf_set_bytes (bin->b, buf->buf, bin->size)){",
          "1204:   return MACH0_(mach0_free) (bin);",
          "1205:  }",
          "1207:   return MACH0_(mach0_free)(bin);",
          "1208:  return bin;",
          "1209: }",
          "",
          "[Removed Lines]",
          "1188:  if (!init(bin))",
          "1197: struct MACH0_(obj_t)* MACH0_(new_buf)(RBuffer *buf) {",
          "1199:  if (!bin) return NULL;",
          "1206:  if (!init(bin))",
          "",
          "[Added Lines]",
          "1192:  if (!init(bin)) {",
          "1194:  }",
          "1200: struct MACH0_(obj_t)* MACH0_(new_buf)(RBuffer *buf, bool verbose) {",
          "1202:  if (!bin) {",
          "1203:   return NULL;",
          "1204:  }",
          "1208:  bin->verbose = verbose;",
          "1212:  if (!init (bin)) {",
          "1214:  }",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1303:   if ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {",
          "1304:    nsyms = (int)(bin->sects[i].size / bin->sects[i].reserved2);",
          "1305:    if (nsyms > bin->size) {",
          "1307:    }",
          "1308:    for (j = 0; j < nsyms; j++) {",
          "1309:     if (bin->sects) {",
          "",
          "[Removed Lines]",
          "1306:     eprintf (\"mach0: Invalid symbol table size\\n\");",
          "",
          "[Added Lines]",
          "1313:     bprintf (\"mach0: Invalid symbol table size\\n\");",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1427: #endif",
          "1428:   int maxsymbols = symbols_size / sizeof(struct symbol_t);",
          "1429:   if (to > 0x500000) {",
          "1431:    free (symbols);",
          "1432:    sdb_free (db);",
          "1433:    return NULL;",
          "",
          "[Removed Lines]",
          "1430:    eprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);",
          "",
          "[Added Lines]",
          "1437:    bprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1486:  to = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);",
          "1487:  for (i = bin->dysymtab.iundefsym; i < to; i++) {",
          "1488:   if (j > symbols_count) {",
          "1490:    break;",
          "1491:   }",
          "1492:   if (parse_import_stub(bin, &symbols[j], i))",
          "",
          "[Removed Lines]",
          "1489:    eprintf (\"mach0-get-symbols: error\\n\");",
          "",
          "[Added Lines]",
          "1496:    bprintf (\"mach0-get-symbols: error\\n\");",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1498:  for (i = 0; i < bin->nsymtab; i++) {",
          "1499:   struct MACH0_(nlist) *st = &bin->symtab[i];",
          "1500: #if 0",
          "1502:    st->n_strx, st->n_sect, st->n_type, st->n_value);",
          "1503: #endif",
          "1504:   stridx = st->n_strx;",
          "",
          "[Removed Lines]",
          "1501:   eprintf (\"stridx %d -> section %d type %d value = %d\\n\",",
          "",
          "[Added Lines]",
          "1508:   bprintf (\"stridx %d -> section %d type %d value = %d\\n\",",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1592:  for (i = j = 0; i < bin->dysymtab.nundefsym; i++) {",
          "1593:   idx = bin->dysymtab.iundefsym +i;",
          "1594:   if (idx < 0 || idx >= bin->nsymtab) {",
          "1596:    free (imports);",
          "1597:    return NULL;",
          "1598:   }",
          "",
          "[Removed Lines]",
          "1595:    eprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");",
          "",
          "[Added Lines]",
          "1602:    bprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1697:   len = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);",
          "1698:   i = r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);",
          "1699:   if (len < 1 || i < 1) {",
          "1701:    (ut64)(size_t)bin->dyld_info->bind_off);",
          "1702:    free (opcodes);",
          "1703:    relocs[i].last = 1;",
          "",
          "[Removed Lines]",
          "1700:    eprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\",",
          "",
          "[Added Lines]",
          "1707:    bprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\",",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1760:    case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:",
          "1761:     seg_idx = imm;",
          "1762:     if (seg_idx < 0 || seg_idx >= bin->nsegs) {",
          "1764:       \" has unexistent segment %d\\n\", seg_idx);",
          "1765:      addr = 0LL;",
          "1766:      return 0; // early exit to avoid future mayhem",
          "",
          "[Removed Lines]",
          "1763:      eprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"",
          "",
          "[Added Lines]",
          "1770:      bprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1789: } while (0)",
          "1790:    case BIND_OPCODE_DO_BIND:",
          "1791:     if (addr >= segmentAddress) {",
          "1793:      goto beach;",
          "1794:     }",
          "1795:     DO_BIND();",
          "",
          "[Removed Lines]",
          "1792:      eprintf (\"Error: Malformed DO bind opcode\\n\");",
          "",
          "[Added Lines]",
          "1799:      bprintf (\"Error: Malformed DO bind opcode\\n\");",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1797:     break;",
          "1798:    case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:",
          "1799:     if (addr >= segmentAddress) {",
          "1801:      goto beach;",
          "1802:     }",
          "1803:     DO_BIND();",
          "",
          "[Removed Lines]",
          "1800:      eprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");",
          "",
          "[Added Lines]",
          "1807:      bprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1805:     break;",
          "1806:    case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:",
          "1807:     if (addr >= segmentAddress) {",
          "1809:      goto beach;",
          "1810:     }",
          "1811:     DO_BIND();",
          "",
          "[Removed Lines]",
          "1808:      eprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");",
          "",
          "[Added Lines]",
          "1815:      bprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1816:     skip = ULEB();",
          "1817:     for (j = 0; j < count; j++) {",
          "1818:      if (addr >= segmentAddress) {",
          "1820:       goto beach;",
          "1821:      }",
          "1822:      DO_BIND();",
          "",
          "[Removed Lines]",
          "1819:       eprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");",
          "",
          "[Added Lines]",
          "1826:       bprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1827: #undef ULEB",
          "1828: #undef SLEB",
          "1829:    default:",
          "1831:     free (opcodes);",
          "1832:     relocs[i].last = 1;",
          "1833:     return relocs;",
          "",
          "[Removed Lines]",
          "1830:     eprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *ur.p);",
          "",
          "[Added Lines]",
          "1837:     bprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *ur.p);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
          "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:  const char *lang;",
          "134:  int uuidn;",
          "135:  int func_size;",
          "136: };",
          "140: void* MACH0_(mach0_free)(struct MACH0_(obj_t)* bin);",
          "141: struct section_t* MACH0_(get_sections)(struct MACH0_(obj_t)* bin);",
          "142: struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin);",
          "",
          "[Removed Lines]",
          "138: struct MACH0_(obj_t)* MACH0_(mach0_new)(const char* file);",
          "139: struct MACH0_(obj_t)* MACH0_(new_buf)(struct r_buf_t *buf);",
          "",
          "[Added Lines]",
          "136:  bool verbose;",
          "139: struct MACH0_(obj_t)* MACH0_(mach0_new)(const char* file, bool verbose);",
          "140: struct MACH0_(obj_t)* MACH0_(new_buf)(struct r_buf_t *buf, bool verbose);",
          "",
          "---------------"
        ],
        "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c": [
          "File: libr/bin/format/pe/pe.c -> libr/bin/format/pe/pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #define PE_IMAGE_FILE_MACHINE_RPI2 452",
          "14: struct SCV_NB10_HEADER;",
          "15: typedef struct {",
          "16:  ut8 signature[4];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #define bprintf if(bin->verbose)eprintf",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:  b[367] = 0;",
          "64:  if (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) < 0) {",
          "66:   free (entry);",
          "67:   return NULL;",
          "68:  }",
          "",
          "[Removed Lines]",
          "65:   eprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);",
          "",
          "[Added Lines]",
          "67:   bprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:   }",
          "167:   len = r_buf_read_at (bin->b, off + i * sizeof (PE_DWord), (ut8*)&import_table, sizeof (PE_DWord));",
          "168:   if (len != sizeof (PE_DWord)) {",
          "170:    goto error;",
          "171:   }",
          "172:   else if (import_table) {",
          "",
          "[Removed Lines]",
          "169:    eprintf(\"Warning: read (import table)\\n\");",
          "",
          "[Added Lines]",
          "171:    bprintf(\"Warning: read (import table)\\n\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "210:       snprintf (import_name, PE_NAME_LENGTH, \"%s_%s\", dll_name, symname);",
          "211:      }",
          "212:     } else {",
          "215:     }",
          "216:    } else {",
          "217:     import_ordinal++;",
          "218:     const ut64 off = bin_pe_rva_to_paddr(bin, import_table);",
          "219:     if (off > bin->size || (off + sizeof (PE_Word)) > bin->size) {",
          "221:      goto error;",
          "222:     }",
          "223:     len = r_buf_read_at (bin->b, off, (ut8*)&import_hint, sizeof (PE_Word));",
          "224:     if (len != sizeof (PE_Word)) {",
          "226:      goto error;",
          "227:     }",
          "228:     name[0] = '\\0';",
          "229:     len = r_buf_read_at (bin->b, off + sizeof(PE_Word), (ut8*)name, PE_NAME_LENGTH);",
          "230:     if (len < 1) {",
          "232:      goto error;",
          "233:     } else if (!*name) {",
          "234:      break;",
          "",
          "[Removed Lines]",
          "213:      eprintf (\"Cannot find %s\\n\", filename);",
          "220:      eprintf (\"Warning: off > bin->size\\n\");",
          "225:      eprintf (\"Warning: read import hint at 0x%08\"PFMT64x\"\\n\", off);",
          "231:      eprintf (\"Warning: read (import name)\\n\");",
          "",
          "[Added Lines]",
          "215:      bprintf (\"Cannot find %s\\n\", filename);",
          "222:      bprintf (\"Warning: off > bin->size\\n\");",
          "227:      bprintf (\"Warning: read import hint at 0x%08\"PFMT64x\"\\n\", off);",
          "233:      bprintf (\"Warning: read (import name)\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "268:   return false;",
          "269:  }",
          "270:  if (r_buf_read_at (bin->b, 0, (ut8*)bin->dos_header, sizeof(PE_(image_dos_header))) == -1) {",
          "272:   return false;",
          "273:  }",
          "274:  sdb_num_set (bin->kv, \"pe_dos_header.offset\", 0, 0);",
          "",
          "[Removed Lines]",
          "271:   eprintf(\"Warning: read (dos header)\\n\");",
          "",
          "[Added Lines]",
          "273:   bprintf(\"Warning: read (dos header)\\n\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "277:    \" e_ss e_sp e_csum e_ip e_cs e_lfarlc e_ovno e_res e_oemid\"",
          "278:    \" e_oeminfo e_res2 e_lfanew\", 0);",
          "279:  if (bin->dos_header->e_lfanew > (unsigned int)bin->size) {",
          "281:   return false;",
          "282:  }",
          "283:  if (!(bin->nt_headers = malloc (sizeof (PE_(image_nt_headers))))) {",
          "",
          "[Removed Lines]",
          "280:   eprintf(\"Invalid e_lfanew field\\n\");",
          "",
          "[Added Lines]",
          "282:   bprintf(\"Invalid e_lfanew field\\n\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "286:  }",
          "287:  bin->nt_header_offset = bin->dos_header->e_lfanew;",
          "288:  if (r_buf_read_at (bin->b, bin->dos_header->e_lfanew, (ut8*)bin->nt_headers, sizeof (PE_(image_nt_headers))) < -1) {",
          "290:   return false;",
          "291:  }",
          "292:  sdb_set (bin->kv, \"pe_magic.cparse\", \"enum pe_magic { IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b, IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b, IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107 };\", 0);",
          "",
          "[Removed Lines]",
          "289:   eprintf (\"Warning: read (dos header)\\n\");",
          "",
          "[Added Lines]",
          "291:   bprintf (\"Warning: read (dos header)\\n\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "475:  }",
          "476:  sections_size = sizeof (PE_(image_section_header)) * bin->num_sections;",
          "477:  if (sections_size > bin->size) {",
          "479:   goto out_error;",
          "480:  }",
          "481:  if (!(bin->section_header = malloc (sections_size))) {",
          "",
          "[Removed Lines]",
          "478:   eprintf (\"Invalid NumberOfSections value\\n\");",
          "",
          "[Added Lines]",
          "480:   bprintf (\"Invalid NumberOfSections value\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "485:  if (r_buf_read_at (bin->b, bin->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) +",
          "486:     bin->nt_headers->file_header.SizeOfOptionalHeader,",
          "487:     (ut8*)bin->section_header, sections_size) == -1) {",
          "489:   R_FREE (bin->section_header);",
          "490:   goto out_error;",
          "491:  }",
          "",
          "[Removed Lines]",
          "488:   eprintf (\"Warning: read (sections)\\n\");",
          "",
          "[Added Lines]",
          "490:   bprintf (\"Warning: read (sections)\\n\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "634:  bin->import_directory = NULL;",
          "635:  if (import_dir_paddr != 0) {",
          "636:   if (import_dir_size < 1 || import_dir_size > maxidsz) {",
          "638:    import_dir_size = maxidsz;",
          "639:   }",
          "640:   bin->import_directory_offset = import_dir_offset;",
          "",
          "[Removed Lines]",
          "637:    eprintf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);",
          "",
          "[Added Lines]",
          "639:    bprintf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "656:    new_import_dir = NULL;",
          "657:    curr_import_dir = import_dir + (indx - 1);",
          "658:    if (r_buf_read_at (bin->b, import_dir_offset + (indx - 1) * dir_size, (ut8*)(curr_import_dir), dir_size) < 1) {",
          "660:     free (import_dir);",
          "661:     import_dir = NULL;",
          "662:     break; //return false;",
          "",
          "[Removed Lines]",
          "659:     eprintf (\"Warning: read (import directory)\\n\");",
          "",
          "[Added Lines]",
          "661:     bprintf (\"Warning: read (import directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "679:     indx++;",
          "680:     off = indx * delay_import_size;",
          "681:     if (off >= bin->b->length) {",
          "683:      break;",
          "684:     }",
          "685:     delay_import_dir = (PE_(image_delay_import_directory) *)realloc (",
          "",
          "[Removed Lines]",
          "682:      eprintf (\"Warning: Cannot find end of import symbols\\n\");",
          "",
          "[Added Lines]",
          "684:      bprintf (\"Warning: Cannot find end of import symbols\\n\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "693:     curr_delay_import_dir = delay_import_dir + (indx - 1);",
          "694:     rr = r_buf_read_at (bin->b, delay_import_dir_offset + (indx - 1) * delay_import_size,",
          "696:     if (rr != dir_size) {",
          "698:      goto fail;",
          "699:     }",
          "700:    } while (curr_delay_import_dir->Name != 0);",
          "",
          "[Removed Lines]",
          "695:       (ut8*)(curr_delay_import_dir), dir_size);",
          "697:      eprintf(\"Warning: read (delay import directory)\\n\");",
          "",
          "[Added Lines]",
          "697:      (ut8*)(curr_delay_import_dir), dir_size);",
          "699:      bprintf (\"Warning: read (delay import directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "716:  PE_DWord export_dir_paddr = bin_pe_rva_to_paddr (bin, data_dir_export->VirtualAddress);",
          "717:  if (!export_dir_paddr) {",
          "720:   return false;",
          "721:  }",
          "724:  if (!(bin->export_directory = malloc (sizeof(PE_(image_export_directory))))) {",
          "725:   r_sys_perror (\"malloc (export directory)\");",
          "726:   return false;",
          "727:  }",
          "728:  if (r_buf_read_at (bin->b, export_dir_paddr, (ut8*)bin->export_directory, sizeof (PE_(image_export_directory))) == -1) {",
          "730:   free (bin->export_directory);",
          "731:   bin->export_directory = NULL;",
          "732:   return false;",
          "",
          "[Removed Lines]",
          "729:   eprintf (\"Warning: read (export directory)\\n\");",
          "",
          "[Added Lines]",
          "731:   bprintf (\"Warning: read (export directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "746:  }",
          "747:  if (r_buf_read_at (bin->b, resource_dir_paddr, (ut8*)bin->resource_directory,",
          "748:    sizeof (*bin->resource_directory)) != sizeof (*bin->resource_directory)) {",
          "750:   free (bin->resource_directory);",
          "751:   bin->resource_directory = NULL;",
          "752:   return false;",
          "",
          "[Removed Lines]",
          "749:   eprintf (\"Warning: read (resource directory)\\n\");",
          "",
          "[Added Lines]",
          "751:   bprintf (\"Warning: read (resource directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "764:  while (addressOfTLSCallback != 0) {",
          "765:   if (r_buf_read_at (bin->b, callbacks, (ut8*)&addressOfTLSCallback, sizeof(addressOfTLSCallback)) != sizeof (addressOfTLSCallback)) {",
          "767:    return;",
          "768:   }",
          "769:   if (!addressOfTLSCallback) {",
          "",
          "[Removed Lines]",
          "766:    eprintf(\"Warning: read (tls_callback)\\n\");",
          "",
          "[Added Lines]",
          "768:    bprintf(\"Warning: read (tls_callback)\\n\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "794:  image_tls_directory = R_NEW0 (PE_(image_tls_directory));",
          "795:  if (r_buf_read_at (bin->b, tls_paddr, (ut8*)image_tls_directory, sizeof (PE_(image_tls_directory))) != sizeof (PE_(image_tls_directory))) {",
          "797:   free(image_tls_directory);",
          "798:   return 0;",
          "799:  }",
          "",
          "[Removed Lines]",
          "796:   eprintf (\"Warning: read (image_tls_directory)\\n\");",
          "",
          "[Added Lines]",
          "798:   bprintf (\"Warning: read (image_tls_directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "887: static Var *Pe_r_bin_pe_parse_var(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord *curAddr) {",
          "888:  Var *var = calloc (1, sizeof(*var));",
          "889:  if (!var) {",
          "891:   return NULL;",
          "892:  }",
          "893:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&var->wLength, sizeof(var->wLength)) != sizeof(var->wLength)) {",
          "895:   free_Var(var);",
          "896:   return NULL;",
          "897:  }",
          "899:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&var->wValueLength, sizeof(var->wValueLength)) != sizeof(var->wValueLength)) {",
          "901:   free_Var(var);",
          "902:   return NULL;",
          "903:  }",
          "905:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&var->wType, sizeof(var->wType)) != sizeof(var->wType)) {",
          "907:   free_Var(var);",
          "908:   return NULL;",
          "909:  }",
          "911:  if (var->wType != 0 && var->wType != 1) {",
          "913:   free_Var(var);",
          "914:   return NULL;",
          "915:  }",
          "916:  var->szKey = (ut16 *) malloc (TRANSLATION_UTF_16_LEN); //L\"Translation\"",
          "917:  if (!var->szKey) {",
          "919:   free_Var(var);",
          "920:   return NULL;",
          "921:  }",
          "922:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {",
          "924:   free_Var(var);",
          "925:   return NULL;",
          "926:  }",
          "928:  if (memcmp(var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {",
          "930:   free_Var(var);",
          "931:   return NULL;",
          "932:  }",
          "933:  align32(*curAddr);",
          "934:  var->numOfValues = var->wValueLength / 4;",
          "935:  if (!var->numOfValues) {",
          "937:   free_Var(var);",
          "938:   return NULL;",
          "939:  }",
          "940:  var->Value = (ut32 *) malloc (var->wValueLength);",
          "941:  if (!var->Value) {",
          "943:   free_Var(var);",
          "944:   return NULL;",
          "945:  }",
          "946:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)var->Value, var->wValueLength) != var->wValueLength) {",
          "948:   free_Var(var);",
          "949:   return NULL;",
          "950:  }",
          "",
          "[Removed Lines]",
          "890:   eprintf (\"Warning: calloc (Var)\\n\");",
          "894:   eprintf (\"Warning: read (Var wLength)\\n\");",
          "900:   eprintf (\"Warning: read (Var wValueLength)\\n\");",
          "906:   eprintf (\"Warning: read (Var wType)\\n\");",
          "912:   eprintf (\"Warning: check (Var wType)\\n\");",
          "918:   eprintf (\"Warning: malloc (Var szKey)\\n\");",
          "923:   eprintf (\"Warning: read (Var szKey)\\n\");",
          "929:   eprintf (\"Warning: check (Var szKey)\\n\");",
          "936:   eprintf (\"Warning: check (Var numOfValues)\\n\");",
          "942:   eprintf (\"Warning: malloc (Var Value)\\n\");",
          "947:   eprintf (\"Warning: read (Var Value)\\n\");",
          "",
          "[Added Lines]",
          "892:   bprintf (\"Warning: calloc (Var)\\n\");",
          "896:   bprintf (\"Warning: read (Var wLength)\\n\");",
          "902:   bprintf (\"Warning: read (Var wValueLength)\\n\");",
          "908:   bprintf (\"Warning: read (Var wType)\\n\");",
          "914:   bprintf (\"Warning: check (Var wType)\\n\");",
          "920:   bprintf (\"Warning: malloc (Var szKey)\\n\");",
          "925:   bprintf (\"Warning: read (Var szKey)\\n\");",
          "931:   bprintf (\"Warning: check (Var szKey)\\n\");",
          "938:   bprintf (\"Warning: check (Var numOfValues)\\n\");",
          "944:   bprintf (\"Warning: malloc (Var Value)\\n\");",
          "949:   bprintf (\"Warning: read (Var Value)\\n\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "955: static VarFileInfo *Pe_r_bin_pe_parse_var_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord *curAddr) {",
          "956:  VarFileInfo *varFileInfo = calloc (1, sizeof(*varFileInfo));",
          "957:  if (!varFileInfo) {",
          "959:   return NULL;",
          "960:  }",
          "961:  PE_DWord startAddr = *curAddr;",
          "962:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&varFileInfo->wLength, sizeof(varFileInfo->wLength)) != sizeof(varFileInfo->wLength)) {",
          "964:   free_VarFileInfo(varFileInfo);",
          "965:   return NULL;",
          "966:  }",
          "969:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&varFileInfo->wValueLength, sizeof(varFileInfo->wValueLength)) != sizeof(varFileInfo->wValueLength)) {",
          "971:   free_VarFileInfo(varFileInfo);",
          "972:   return NULL;",
          "973:  }",
          "976:  if (varFileInfo->wValueLength != 0) {",
          "978:   free_VarFileInfo(varFileInfo);",
          "979:   return NULL;",
          "980:  }",
          "982:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&varFileInfo->wType, sizeof(varFileInfo->wType)) != sizeof(varFileInfo->wType)) {",
          "984:   free_VarFileInfo(varFileInfo);",
          "985:   return NULL;",
          "986:  }",
          "988:  if (varFileInfo->wType && varFileInfo->wType != 1) {",
          "990:   free_VarFileInfo(varFileInfo);",
          "991:   return NULL;",
          "992:  }",
          "994:  varFileInfo->szKey = (ut16 *) malloc (VARFILEINFO_UTF_16_LEN); //L\"VarFileInfo\"",
          "995:  if (!varFileInfo->szKey) {",
          "997:   free_VarFileInfo(varFileInfo);",
          "998:   return NULL;",
          "999:  }",
          "1001:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)varFileInfo->szKey, VARFILEINFO_UTF_16_LEN) != VARFILEINFO_UTF_16_LEN) {",
          "1003:   free_VarFileInfo(varFileInfo);",
          "1004:   return NULL;",
          "1005:  }",
          "1008:  if (memcmp(varFileInfo->szKey, VARFILEINFO_UTF_16, VARFILEINFO_UTF_16_LEN)) {",
          "1010:   free_VarFileInfo(varFileInfo);",
          "1011:   return NULL;",
          "1012:  }",
          "",
          "[Removed Lines]",
          "958:   eprintf (\"Warning: calloc (VarFileInfo)\\n\");",
          "963:   eprintf (\"Warning: read (VarFileInfo wLength)\\n\");",
          "970:   eprintf (\"Warning: read (VarFileInfo wValueLength)\\n\");",
          "977:   eprintf (\"Warning: check (VarFileInfo wValueLength)\\n\");",
          "983:   eprintf (\"Warning: read (VarFileInfo wType)\\n\");",
          "989:   eprintf (\"Warning: check (VarFileInfo wType)\\n\");",
          "996:   eprintf (\"Warning: malloc (VarFileInfo szKey)\\n\");",
          "1002:   eprintf (\"Warning: read (VarFileInfo szKey)\\n\");",
          "1009:   eprintf (\"Warning: check (VarFileInfo szKey)\\n\");",
          "",
          "[Added Lines]",
          "960:   bprintf (\"Warning: calloc (VarFileInfo)\\n\");",
          "965:   bprintf (\"Warning: read (VarFileInfo wLength)\\n\");",
          "972:   bprintf (\"Warning: read (VarFileInfo wValueLength)\\n\");",
          "979:   bprintf (\"Warning: check (VarFileInfo wValueLength)\\n\");",
          "985:   bprintf (\"Warning: read (VarFileInfo wType)\\n\");",
          "991:   bprintf (\"Warning: check (VarFileInfo wType)\\n\");",
          "998:   bprintf (\"Warning: malloc (VarFileInfo szKey)\\n\");",
          "1004:   bprintf (\"Warning: read (VarFileInfo szKey)\\n\");",
          "1011:   bprintf (\"Warning: check (VarFileInfo szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1014:  while (startAddr + varFileInfo->wLength > *curAddr) {",
          "1015:   Var **tmp = (Var **) realloc(varFileInfo->Children, (varFileInfo->numOfChildren + 1) * sizeof(*varFileInfo->Children));",
          "1016:   if (!tmp) {",
          "1018:    free_VarFileInfo(varFileInfo);",
          "1019:    return NULL;",
          "1020:   }",
          "1021:   varFileInfo->Children = tmp;",
          "1022:   if (!(varFileInfo->Children[varFileInfo->numOfChildren] = Pe_r_bin_pe_parse_var(bin, curAddr))) {",
          "1024:    free_VarFileInfo(varFileInfo);",
          "1025:    return NULL;",
          "1026:   }",
          "",
          "[Removed Lines]",
          "1017:    eprintf (\"Warning: realloc (VarFileInfo Children)\\n\");",
          "1023:    eprintf (\"Warning: bad parsing Var\\n\");",
          "",
          "[Added Lines]",
          "1019:    bprintf (\"Warning: realloc (VarFileInfo Children)\\n\");",
          "1025:    bprintf (\"Warning: bad parsing Var\\n\");",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1036:  int len_value = 0;",
          "1037:  int i = 0;",
          "1038:  if (!string) {",
          "1040:   return NULL;",
          "1041:  }",
          "1042:  if (begAddr > bin->size || begAddr + sizeof(string->wLength) > bin->size) {",
          "1043:   return NULL;",
          "1044:  }",
          "1045:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&string->wLength, sizeof(string->wLength)) != sizeof(string->wLength)) {",
          "1047:   goto out_error;",
          "1048:  }",
          "",
          "[Removed Lines]",
          "1039:   eprintf (\"Warning: calloc (String)\\n\");",
          "1046:   eprintf (\"Warning: read (String wLength)\\n\");",
          "",
          "[Added Lines]",
          "1041:   bprintf (\"Warning: calloc (String)\\n\");",
          "1048:   bprintf (\"Warning: read (String wLength)\\n\");",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1051:   goto out_error;",
          "1052:  }",
          "1053:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&string->wValueLength, sizeof(string->wValueLength)) != sizeof(string->wValueLength)) {",
          "1055:   goto out_error;",
          "1056:  }",
          "",
          "[Removed Lines]",
          "1054:   eprintf (\"Warning: read (String wValueLength)\\n\");",
          "",
          "[Added Lines]",
          "1056:   bprintf (\"Warning: read (String wValueLength)\\n\");",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1060:   goto out_error;",
          "1061:  }",
          "1062:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&string->wType, sizeof(string->wType)) != sizeof(string->wType)) {",
          "1064:   goto out_error;",
          "1065:  }",
          "1067:  if (string->wType != 0 && string->wType != 1) {",
          "1069:   goto out_error;",
          "1070:  }",
          "",
          "[Removed Lines]",
          "1063:   eprintf (\"Warning: read (String wType)\\n\");",
          "1068:   eprintf (\"Warning: check (String wType)\\n\");",
          "",
          "[Added Lines]",
          "1065:   bprintf (\"Warning: read (String wType)\\n\");",
          "1070:   bprintf (\"Warning: check (String wType)\\n\");",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1075:    goto out_error;",
          "1076:   }",
          "1077:   if (r_buf_read_at(bin->b, *curAddr, (ut8*)&utf16_char, sizeof (ut16)) != sizeof (ut16)) {",
          "1079:    goto out_error;",
          "1080:   }",
          "1081:   string->szKey = (ut16*)realloc (string->szKey, (i + 1) * sizeof (ut16));",
          "",
          "[Removed Lines]",
          "1078:    eprintf (\"Warning: check (String szKey)\\n\");",
          "",
          "[Added Lines]",
          "1080:    bprintf (\"Warning: check (String szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1094:  }",
          "1095:  string->Value = (ut16 *) calloc (len_value + 1, 1);",
          "1096:  if (!string->Value) {",
          "1098:   goto out_error;",
          "1099:  }",
          "1100:  if (*curAddr > bin->size || *curAddr + len_value > bin->size) {",
          "1101:   goto out_error;",
          "1102:  }",
          "1103:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)string->Value, len_value) != len_value) {",
          "1105:   goto out_error;",
          "1106:  }",
          "",
          "[Removed Lines]",
          "1097:   eprintf (\"Warning: malloc (String Value)\\n\");",
          "1104:   eprintf (\"Warning: read (String Value)\\n\");",
          "",
          "[Added Lines]",
          "1099:   bprintf (\"Warning: malloc (String Value)\\n\");",
          "1106:   bprintf (\"Warning: read (String Value)\\n\");",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1114: static StringTable *Pe_r_bin_pe_parse_string_table(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord *curAddr) {",
          "1115:  StringTable *stringTable = calloc (1, sizeof(*stringTable));",
          "1116:  if (!stringTable) {",
          "1118:   return NULL;",
          "1119:  }",
          "1121:  PE_DWord startAddr = *curAddr;",
          "1122:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&stringTable->wLength, sizeof(stringTable->wLength)) != sizeof(stringTable->wLength)) {",
          "1124:   free_StringTable(stringTable);",
          "1125:   return NULL;",
          "1126:  }",
          "1129:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&stringTable->wValueLength, sizeof(stringTable->wValueLength)) != sizeof(stringTable->wValueLength)) {",
          "1131:   free_StringTable(stringTable);",
          "1132:   return NULL;",
          "1133:  }",
          "1136:  if (stringTable->wValueLength) {",
          "1138:   free_StringTable(stringTable);",
          "1139:   return NULL;",
          "1140:  }",
          "1142:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&stringTable->wType, sizeof(stringTable->wType)) != sizeof(stringTable->wType)) {",
          "1144:   free_StringTable(stringTable);",
          "1145:   return NULL;",
          "1146:  }",
          "1148:  if (stringTable->wType && stringTable->wType != 1) {",
          "1150:   free_StringTable(stringTable);",
          "1151:   return NULL;",
          "1152:  }",
          "1153:  stringTable->szKey = (ut16 *) malloc (EIGHT_HEX_DIG_UTF_16_LEN); //EIGHT_HEX_DIG_UTF_16_LEN",
          "1154:  if (!stringTable->szKey) {",
          "1156:   free_StringTable(stringTable);",
          "1157:   return NULL;",
          "1158:  }",
          "1160:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN) != EIGHT_HEX_DIG_UTF_16_LEN) {",
          "1162:   free_StringTable(stringTable);",
          "1163:   return NULL;",
          "1164:  }",
          "",
          "[Removed Lines]",
          "1117:   eprintf (\"Warning: calloc (stringTable)\\n\");",
          "1123:   eprintf (\"Warning: read (StringTable wLength)\\n\");",
          "1130:   eprintf (\"Warning: read (StringTable wValueLength)\\n\");",
          "1137:   eprintf (\"Warning: check (StringTable wValueLength)\\n\");",
          "1143:   eprintf (\"Warning: read (StringTable wType)\\n\");",
          "1149:   eprintf (\"Warning: check (StringTable wType)\\n\");",
          "1155:   eprintf (\"Warning: malloc (stringTable szKey)\\n\");",
          "1161:   eprintf (\"Warning: read (StringTable szKey)\\n\");",
          "",
          "[Added Lines]",
          "1119:   bprintf (\"Warning: calloc (stringTable)\\n\");",
          "1125:   bprintf (\"Warning: read (StringTable wLength)\\n\");",
          "1132:   bprintf (\"Warning: read (StringTable wValueLength)\\n\");",
          "1139:   bprintf (\"Warning: check (StringTable wValueLength)\\n\");",
          "1145:   bprintf (\"Warning: read (StringTable wType)\\n\");",
          "1151:   bprintf (\"Warning: check (StringTable wType)\\n\");",
          "1157:   bprintf (\"Warning: malloc (stringTable szKey)\\n\");",
          "1163:   bprintf (\"Warning: read (StringTable szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1167:  while (startAddr + stringTable->wLength > *curAddr) {",
          "1168:   String **tmp = (String **) realloc(stringTable->Children, (stringTable->numOfChildren + 1) * sizeof(*stringTable->Children));",
          "1169:   if (!tmp) {",
          "1171:    free_StringTable(stringTable);",
          "1172:    return NULL;",
          "1173:   }",
          "1174:   stringTable->Children = tmp;",
          "1175:   if (!(stringTable->Children[stringTable->numOfChildren] = Pe_r_bin_pe_parse_string(bin, curAddr))) {",
          "1177:    free_StringTable(stringTable);",
          "1178:    return NULL;",
          "1179:   }",
          "",
          "[Removed Lines]",
          "1170:    eprintf (\"Warning: realloc (StringTable Children)\\n\");",
          "1176:    eprintf (\"Warning: bad parsing String\\n\");",
          "",
          "[Added Lines]",
          "1172:    bprintf (\"Warning: realloc (StringTable Children)\\n\");",
          "1178:    bprintf (\"Warning: bad parsing String\\n\");",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1182:  }",
          "1184:  if (!stringTable->numOfChildren) {",
          "1186:   free_StringTable(stringTable);",
          "1187:   return NULL;",
          "1188:  }",
          "",
          "[Removed Lines]",
          "1185:   eprintf (\"Warning: check (StringTable numOfChildren)\\n\");",
          "",
          "[Added Lines]",
          "1187:   bprintf (\"Warning: check (StringTable numOfChildren)\\n\");",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1193: static StringFileInfo *Pe_r_bin_pe_parse_string_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord *curAddr) {",
          "1194:  StringFileInfo *stringFileInfo = calloc (1, sizeof(*stringFileInfo));",
          "1195:  if (!stringFileInfo) {",
          "1197:   return NULL;",
          "1198:  }",
          "1200:  PE_DWord startAddr = *curAddr;",
          "1202:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&stringFileInfo->wLength, sizeof(stringFileInfo->wLength)) != sizeof(stringFileInfo->wLength)) {",
          "1204:   free_StringFileInfo(stringFileInfo);",
          "1205:   return NULL;",
          "1206:  }",
          "1209:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&stringFileInfo->wValueLength, sizeof(stringFileInfo->wValueLength)) != sizeof(stringFileInfo->wValueLength)) {",
          "1211:   free_StringFileInfo(stringFileInfo);",
          "1212:   return NULL;",
          "1213:  }",
          "1216:  if (stringFileInfo->wValueLength) {",
          "1218:   free_StringFileInfo(stringFileInfo);",
          "1219:   return NULL;",
          "1220:  }",
          "1222:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)&stringFileInfo->wType, sizeof(stringFileInfo->wType)) != sizeof(stringFileInfo->wType)) {",
          "1224:   free_StringFileInfo(stringFileInfo);",
          "1225:   return NULL;",
          "1226:  }",
          "1229:  if (stringFileInfo->wType && stringFileInfo->wType != 1) {",
          "1231:   free_StringFileInfo(stringFileInfo);",
          "1232:   return NULL;",
          "1233:  }",
          "1235:  stringFileInfo->szKey = (ut16 *) malloc (STRINGFILEINFO_UTF_16_LEN); //L\"StringFileInfo\"",
          "1236:  if (!stringFileInfo->szKey) {",
          "1238:   free_StringFileInfo(stringFileInfo);",
          "1239:   return NULL;",
          "1240:  }",
          "1242:  if (r_buf_read_at(bin->b, *curAddr, (ut8*)stringFileInfo->szKey, STRINGFILEINFO_UTF_16_LEN) != STRINGFILEINFO_UTF_16_LEN) {",
          "1244:   free_StringFileInfo(stringFileInfo);",
          "1245:   return NULL;",
          "1246:  }",
          "1249:  if (memcmp(stringFileInfo->szKey, STRINGFILEINFO_UTF_16, STRINGFILEINFO_UTF_16_LEN) != 0) {",
          "1251:   free_StringFileInfo(stringFileInfo);",
          "1252:   return NULL;",
          "1253:  }",
          "",
          "[Removed Lines]",
          "1196:   eprintf (\"Warning: calloc (StringFileInfo)\\n\");",
          "1203:   eprintf (\"Warning: read (StringFileInfo wLength)\\n\");",
          "1210:   eprintf (\"Warning: read (StringFileInfo wValueLength)\\n\");",
          "1217:   eprintf (\"Warning: check (StringFileInfo wValueLength)\\n\");",
          "1223:   eprintf (\"Warning: read (StringFileInfo wType)\\n\");",
          "1230:   eprintf (\"Warning: check (StringFileInfo wType)\\n\");",
          "1237:   eprintf (\"Warning: malloc (StringFileInfo szKey)\\n\");",
          "1243:   eprintf (\"Warning: read (StringFileInfo szKey)\\n\");",
          "1250:   eprintf (\"Warning: check (StringFileInfo szKey)\\n\");",
          "",
          "[Added Lines]",
          "1198:   bprintf (\"Warning: calloc (StringFileInfo)\\n\");",
          "1205:   bprintf (\"Warning: read (StringFileInfo wLength)\\n\");",
          "1212:   bprintf (\"Warning: read (StringFileInfo wValueLength)\\n\");",
          "1219:   bprintf (\"Warning: check (StringFileInfo wValueLength)\\n\");",
          "1225:   bprintf (\"Warning: read (StringFileInfo wType)\\n\");",
          "1232:   bprintf (\"Warning: check (StringFileInfo wType)\\n\");",
          "1239:   bprintf (\"Warning: malloc (StringFileInfo szKey)\\n\");",
          "1245:   bprintf (\"Warning: read (StringFileInfo szKey)\\n\");",
          "1252:   bprintf (\"Warning: check (StringFileInfo szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1257:  while (startAddr + stringFileInfo->wLength > *curAddr) {",
          "1258:   StringTable **tmp = (StringTable **) realloc(stringFileInfo->Children, (stringFileInfo->numOfChildren + 1) * sizeof(*stringFileInfo->Children));",
          "1259:   if (!tmp) {",
          "1261:    free_StringFileInfo(stringFileInfo);",
          "1262:    return NULL;",
          "1263:   }",
          "1264:   stringFileInfo->Children = tmp;",
          "1265:   if (!(stringFileInfo->Children[stringFileInfo->numOfChildren] = Pe_r_bin_pe_parse_string_table(bin, curAddr))) {",
          "1267:    free_StringFileInfo(stringFileInfo);",
          "1268:    return NULL;",
          "1269:   }",
          "",
          "[Removed Lines]",
          "1260:    eprintf (\"Warning: realloc (StringFileInfo Children)\\n\");",
          "1266:    eprintf (\"Warning: bad parsing StringTable\\n\");",
          "",
          "[Added Lines]",
          "1262:    bprintf (\"Warning: realloc (StringFileInfo Children)\\n\");",
          "1268:    bprintf (\"Warning: bad parsing StringTable\\n\");",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1272:  }",
          "1274:  if (!stringFileInfo->numOfChildren) {",
          "1276:   free_StringFileInfo(stringFileInfo);",
          "1277:   return NULL;",
          "1278:  }",
          "",
          "[Removed Lines]",
          "1275:   eprintf (\"Warning: check (StringFileInfo numOfChildren)\\n\");",
          "",
          "[Added Lines]",
          "1277:   bprintf (\"Warning: check (StringFileInfo numOfChildren)\\n\");",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1299:  sz = sizeof(ut16);",
          "1300:  EXIT_ON_OVERFLOW(sz);",
          "1301:  if (r_buf_read_at(bin->b, curAddr, (ut8*)&vs_VersionInfo->wLength, sz) != sz) {",
          "1303:   goto out_error;",
          "1304:  }",
          "1305:  curAddr += sz;",
          "1306:  EXIT_ON_OVERFLOW(sz);",
          "1307:  if (r_buf_read_at(bin->b, curAddr, (ut8*)&vs_VersionInfo->wValueLength, sz) != sz) {",
          "1309:   goto out_error;",
          "1310:  }",
          "1311:  curAddr += sz;",
          "1312:  EXIT_ON_OVERFLOW(sz);",
          "1313:  if (r_buf_read_at(bin->b, curAddr, (ut8*)&vs_VersionInfo->wType, sz) != sz) {",
          "1315:   goto out_error;",
          "1316:  }",
          "1317:  curAddr += sz;",
          "1318:  if (vs_VersionInfo->wType && vs_VersionInfo->wType != 1) {",
          "1320:   goto out_error;",
          "1321:  }",
          "1323:  vs_VersionInfo->szKey = (ut16 *) malloc (VS_VERSION_INFO_UTF_16_LEN); //L\"VS_VERSION_INFO\"",
          "1324:  if (!vs_VersionInfo->szKey) {",
          "1326:   goto out_error;",
          "1327:  }",
          "1328:  sz = VS_VERSION_INFO_UTF_16_LEN;",
          "1329:  EXIT_ON_OVERFLOW(sz);",
          "1330:  if (r_buf_read_at (bin->b, curAddr, (ut8*)vs_VersionInfo->szKey, sz) != sz) {",
          "1332:   goto out_error;",
          "1333:  }",
          "1334:  curAddr += sz;",
          "",
          "[Removed Lines]",
          "1302:   eprintf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");",
          "1308:   eprintf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");",
          "1314:   eprintf (\"Warning: read (VS_VERSIONINFO wType)\\n\");",
          "1319:   eprintf (\"Warning: check (VS_VERSIONINFO wType)\\n\");",
          "1325:   eprintf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");",
          "1331:   eprintf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");",
          "",
          "[Added Lines]",
          "1304:   bprintf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");",
          "1310:   bprintf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");",
          "1316:   bprintf (\"Warning: read (VS_VERSIONINFO wType)\\n\");",
          "1321:   bprintf (\"Warning: check (VS_VERSIONINFO wType)\\n\");",
          "1327:   bprintf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");",
          "1333:   bprintf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1338:  align32 (curAddr);",
          "1339:  if (vs_VersionInfo->wValueLength) {",
          "1340:   if (vs_VersionInfo->wValueLength != sizeof (*vs_VersionInfo->Value)) {",
          "1342:    goto out_error;",
          "1343:   }",
          "1345:   vs_VersionInfo->Value = (PE_VS_FIXEDFILEINFO *) malloc (sizeof(*vs_VersionInfo->Value));",
          "1346:   if (!vs_VersionInfo->Value) {",
          "1348:    goto out_error;",
          "1349:   }",
          "1350:   sz = sizeof(PE_VS_FIXEDFILEINFO);",
          "1351:   EXIT_ON_OVERFLOW(sz);",
          "1352:   if (r_buf_read_at (bin->b, curAddr, (ut8*)vs_VersionInfo->Value, sz) != sz) {",
          "1354:    goto out_error;",
          "1355:   }",
          "1357:   if (vs_VersionInfo->Value->dwSignature != 0xFEEF04BD) {",
          "1359:    goto out_error;",
          "1360:   }",
          "1361:   curAddr += sz;",
          "",
          "[Removed Lines]",
          "1341:    eprintf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");",
          "1347:    eprintf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");",
          "1353:    eprintf (\"Warning: read (VS_VERSIONINFO Value)\\n\");",
          "1358:    eprintf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);",
          "",
          "[Added Lines]",
          "1343:    bprintf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");",
          "1349:    bprintf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");",
          "1355:    bprintf (\"Warning: read (VS_VERSIONINFO Value)\\n\");",
          "1360:    bprintf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1368:    goto out_error;",
          "1369:   }",
          "1370:   if (r_buf_read_at(bin->b, curAddr + 3 * sizeof(ut16), (ut8*)&t, 1) != 1) {",
          "1372:    goto out_error;",
          "1373:   }",
          "1374:   if (!(t == 'S' || t == 'V')) {",
          "1376:    goto out_error;",
          "1377:   }",
          "1378:   if (t == 'S') {",
          "1379:    if (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info(bin, &curAddr))) {",
          "1381:     goto out_error;",
          "1382:    }",
          "1383:   }",
          "1384:   if (t == 'V') {",
          "1385:    if (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info(bin, &curAddr))) {",
          "1387:     goto out_error;",
          "1388:    }",
          "1389:   }",
          "",
          "[Removed Lines]",
          "1371:    eprintf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");",
          "1375:    eprintf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");",
          "1380:     eprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "1386:     eprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "",
          "[Added Lines]",
          "1373:    bprintf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");",
          "1377:    bprintf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");",
          "1382:     bprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "1388:     bprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1393:   if (startAddr + vs_VersionInfo->wLength > curAddr) {",
          "1394:    if (t == 'V') {",
          "1395:     if (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info(bin, &curAddr))) {",
          "1397:      goto out_error;",
          "1398:     }",
          "1399:    } else if (t == 'S') {",
          "1400:     if (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info(bin, &curAddr))) {",
          "1402:      goto out_error;",
          "1403:     }",
          "1404:    }",
          "1405:    if (startAddr + vs_VersionInfo->wLength > curAddr) {",
          "1407:     goto out_error;",
          "1408:    }",
          "1409:   }",
          "",
          "[Removed Lines]",
          "1396:      eprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "1401:      eprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "1406:     eprintf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");",
          "",
          "[Added Lines]",
          "1398:      bprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "1403:      bprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "1408:     bprintf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1585:    goto out_error;",
          "1586:   }",
          "1587:   if (r_buf_read_at (bin->b, off, (ut8*)&typeEntry, sizeof(Pe_image_resource_directory_entry)) < 1) {",
          "1589:    goto out_error;",
          "1590:   }",
          "1591:   if (!typeEntry.u1.s.NameIsString && typeEntry.u1.Id == PE_RESOURCE_ENTRY_VERSION) {",
          "",
          "[Removed Lines]",
          "1588:    eprintf (\"Warning: read (resource type directory entry)\\n\");",
          "",
          "[Added Lines]",
          "1590:    bprintf (\"Warning: read (resource type directory entry)\\n\");",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1595:     goto out_error;",
          "1596:    }",
          "1597:    if (r_buf_read_at (bin->b, off, (ut8*)&identDir, sizeof(Pe_image_resource_directory)) < 1) {",
          "1599:     goto out_error;",
          "1600:    }",
          "1601:    ut32 totalIdent = identDir.NumberOfNamedEntries + identDir.NumberOfIdEntries;",
          "",
          "[Removed Lines]",
          "1598:     eprintf (\"Warning: read (resource identifier directory)\\n\");",
          "",
          "[Added Lines]",
          "1600:     bprintf (\"Warning: read (resource identifier directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1608:      goto out_error;",
          "1609:     }",
          "1610:     if (r_buf_read_at (bin->b, off, (ut8*)&identEntry, sizeof(Pe_image_resource_directory_entry)) < 1) {",
          "1612:      goto out_error;",
          "1613:     }",
          "1614:     if (!identEntry.u2.s.DataIsDirectory) {",
          "",
          "[Removed Lines]",
          "1611:      eprintf (\"Warning: read (resource identifier entry)\\n\");",
          "",
          "[Added Lines]",
          "1613:      bprintf (\"Warning: read (resource identifier entry)\\n\");",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1620:      goto out_error;",
          "1621:     }",
          "1622:     if (r_buf_read_at (bin->b, off, (ut8*)&langDir, sizeof(Pe_image_resource_directory)) < 1) {",
          "1624:      goto out_error;",
          "1625:     }",
          "1626:     ut32 totalLang = langDir.NumberOfNamedEntries + langDir.NumberOfIdEntries;",
          "",
          "[Removed Lines]",
          "1623:      eprintf (\"Warning: read (resource language directory)\\n\");",
          "",
          "[Added Lines]",
          "1625:      bprintf (\"Warning: read (resource language directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1632:       goto out_error;",
          "1633:      }",
          "1634:      if (r_buf_read_at (bin->b, off, (ut8*)&langEntry, sizeof(Pe_image_resource_directory_entry)) < 1) {",
          "1636:       goto out_error;",
          "1637:      }",
          "1638:      if (langEntry.u2.s.DataIsDirectory) {",
          "",
          "[Removed Lines]",
          "1635:       eprintf (\"Warning: read (resource language entry)\\n\");",
          "",
          "[Added Lines]",
          "1637:       bprintf (\"Warning: read (resource language entry)\\n\");",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1644:       goto out_error;",
          "1645:      }",
          "1646:      if (r_buf_read_at (bin->b, off, (ut8*)&data, sizeof (data)) != sizeof (data)) {",
          "1648:       goto out_error;",
          "1649:      }",
          "1650:      PE_DWord data_paddr = bin_pe_rva_to_paddr(bin, data.OffsetToData);",
          "1651:      if (!data_paddr) {",
          "1653:       goto out_error;",
          "1654:      }",
          "1655:      PE_DWord cur_paddr = data_paddr;",
          "1656:      if ((cur_paddr & 0x3) != 0) {",
          "1659:       continue;",
          "1660:      }",
          "1661:      while(cur_paddr < data_paddr + data.Size && cur_paddr < bin->size) {",
          "",
          "[Removed Lines]",
          "1647:       eprintf (\"Warning: read (resource data entry)\\n\");",
          "1652:       eprintf (\"Warning: bad RVA in resource data entry\\n\");",
          "1658:       eprintf (\"Warning: not aligned version info address\\n\");",
          "",
          "[Added Lines]",
          "1649:       bprintf (\"Warning: read (resource data entry)\\n\");",
          "1654:       bprintf (\"Warning: bad RVA in resource data entry\\n\");",
          "1660:       bprintf (\"Warning: not aligned version info address\\n\");",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1692:  bin->data_directory = NULL;",
          "1694:  if (!bin_pe_init_hdr(bin)) {",
          "1696:   return false;",
          "1697:  }",
          "1698:  bin_pe_init_sections (bin);",
          "",
          "[Removed Lines]",
          "1695:   eprintf (\"Warning: File is not PE\\n\");",
          "",
          "[Added Lines]",
          "1697:   bprintf (\"Warning: File is not PE\\n\");",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1769:    struct r_bin_pe_section_t *sections =  PE_(r_bin_pe_get_sections) (bin);",
          "1770:   ut64 paddr = 0;",
          "1771:   if (!debug) {",
          "1773:      \"trying to fix it but i do not promise nothing\\n\");",
          "1774:   }",
          "1775:   for (i = 0; i < bin->num_sections; i++) {",
          "",
          "[Removed Lines]",
          "1772:    eprintf (\"Warning: Invalid entrypoint ... \"",
          "",
          "[Added Lines]",
          "1774:    bprintf (\"Warning: Invalid entrypoint ... \"",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1804:  }",
          "1805:  if (!entry->paddr) {",
          "1806:   if (!debug) {",
          "1808:   }",
          "1809:    struct r_bin_pe_section_t *sections =  PE_(r_bin_pe_get_sections) (bin);",
          "1810:   for (i = 0; i < bin->num_sections; i++) {",
          "",
          "[Removed Lines]",
          "1807:    eprintf (\"Warning: NULL entrypoint\\n\");",
          "",
          "[Added Lines]",
          "1809:    bprintf (\"Warning: NULL entrypoint\\n\");",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1863:    return NULL;",
          "1864:   }",
          "1865:   if (r_buf_read_at (bin->b, bin_pe_rva_to_paddr (bin, bin->export_directory->Name), (ut8*)dll_name, PE_NAME_LENGTH) < 1) {",
          "1867:    free (exports);",
          "1868:    return NULL;",
          "1869:   }",
          "",
          "[Removed Lines]",
          "1866:    eprintf (\"Warning: read (dll name)\\n\");",
          "",
          "[Added Lines]",
          "1868:    bprintf (\"Warning: read (dll name)\\n\");",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1898:      name_paddr = bin_pe_rva_to_paddr (bin, name_vaddr);",
          "1899:      if (r_buf_read_at (bin->b, name_paddr, (ut8*)function_name, PE_NAME_LENGTH) < 1) {",
          "1901:       free (exports);",
          "1902:       return NULL;",
          "1903:      }",
          "",
          "[Removed Lines]",
          "1900:       eprintf(\"Warning: read (function name)\\n\");",
          "",
          "[Added Lines]",
          "1902:       bprintf(\"Warning: read (function name)\\n\");",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1913:    if (function_rva >= export_dir_rva && function_rva < (export_dir_rva + export_dir_size)) {",
          "1915:     if (r_buf_read_at (bin->b, bin_pe_rva_to_paddr (bin, function_rva), (ut8*)forwarder_name, PE_NAME_LENGTH) < 1) {",
          "1917:      free (exports);",
          "1918:      return NULL;",
          "1919:     }",
          "",
          "[Removed Lines]",
          "1916:      eprintf (\"Warning: read (magic)\\n\");",
          "",
          "[Added Lines]",
          "1918:      bprintf (\"Warning: read (magic)\\n\");",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1975:  res->file_name = (ut8 *)strdup ((const char *)dbg_data + nb10sz);",
          "1976: }",
          "1979: #define SIZEOF_FILE_NAME 255",
          "1980:  int i = 0;",
          "1981:  if (!dbg_data) {",
          "",
          "[Removed Lines]",
          "1978: static int get_debug_info(PE_(image_debug_directory_entry) *dbg_dir_entry, ut8 *dbg_data, int dbg_data_len, SDebugInfo *res) {",
          "",
          "[Added Lines]",
          "1980: static int get_debug_info(struct PE_(r_bin_pe_obj_t) *bin, PE_(image_debug_directory_entry) *dbg_dir_entry, ut8 *dbg_data, int dbg_data_len, SDebugInfo *res) {",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1987:    SCV_RSDS_HEADER rsds_hdr;",
          "1988:    init_rsdr_hdr (&rsds_hdr);",
          "1989:    if (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {",
          "1991:     return 0;",
          "1992:    }",
          "1993:    snprintf (res->guidstr, GUIDSTR_LEN,",
          "",
          "[Removed Lines]",
          "1990:     eprintf (\"Warning: Cannot read PE debug info\\n\");",
          "",
          "[Added Lines]",
          "1992:     bprintf (\"Warning: Cannot read PE debug info\\n\");",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2019:    res->file_name[sizeof (res->file_name)-1] = 0;",
          "2020:    nb10_hdr.free ((struct SCV_NB10_HEADER *)&nb10_hdr);",
          "2021:   } else {",
          "2023:    return 0;",
          "2024:   }",
          "2025:   break;",
          "2026:  default:",
          "2028:   return 0;",
          "2029:  }",
          "",
          "[Removed Lines]",
          "2022:    eprintf (\"CodeView section not NB10 or RSDS\\n\");",
          "",
          "[Added Lines]",
          "2024:    bprintf (\"CodeView section not NB10 or RSDS\\n\");",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2066:   dbg_data = (ut8 *) calloc (1, dbg_data_len + 1);",
          "2067:   if (dbg_data) {",
          "2068:    r_buf_read_at (bin->b, dbg_data_poff, dbg_data, dbg_data_len);",
          "2070:    R_FREE (dbg_data);",
          "2071:   }",
          "2072:  }",
          "",
          "[Removed Lines]",
          "2069:    result = get_debug_info (img_dbg_dir_entry, dbg_data, dbg_data_len, res);",
          "",
          "[Added Lines]",
          "2071:    result = get_debug_info (bin, img_dbg_dir_entry, dbg_data, dbg_data_len, res);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2108:   }",
          "2109:   if (off + bin->import_directory_size > bin->size) {",
          "2112:    bin->import_directory_size = bin->size - bin->import_directory_offset;",
          "2113:   }",
          "2114:   last = (char *)curr_import_dir + bin->import_directory_size;",
          "",
          "[Removed Lines]",
          "2111:    eprintf (\"Warning: read (import directory too big)\\n\");",
          "",
          "[Added Lines]",
          "2113:    bprintf (\"Warning: read (import directory too big)\\n\");",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2125:    if (paddr + PE_NAME_LENGTH > bin->size) {",
          "2126:     rr = r_buf_read_at (bin->b, paddr, (ut8*)dll_name, bin->size - paddr);",
          "2127:     if (rr != bin->size - paddr) {",
          "2129:      return NULL;",
          "2130:     }",
          "2131:     dll_name[bin->size - paddr] = '\\0';",
          "",
          "[Removed Lines]",
          "2128:      eprintf (\"Warning: read (magic)\\n\");",
          "",
          "[Added Lines]",
          "2130:      bprintf (\"Warning: read (magic)\\n\");",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "2133:    else {",
          "2134:     rr = r_buf_read_at (bin->b, paddr, (ut8*)dll_name, PE_NAME_LENGTH);",
          "2135:     if (rr != PE_NAME_LENGTH) {",
          "2137:      return NULL;",
          "2138:     }",
          "2139:     dll_name[PE_NAME_LENGTH] = '\\0';",
          "",
          "[Removed Lines]",
          "2136:      eprintf (\"Warning: read (magic)\\n\");",
          "",
          "[Added Lines]",
          "2138:      bprintf (\"Warning: read (magic)\\n\");",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "2167:    }",
          "2168:    int rr = r_buf_read_at (bin->b, dll_name_offset, (ut8*)dll_name, PE_NAME_LENGTH);",
          "2169:    if (rr < 5) {",
          "2171:     return NULL;",
          "2172:    }",
          "",
          "[Removed Lines]",
          "2170:     eprintf (\"Warning: read (magic)\\n\");",
          "",
          "[Added Lines]",
          "2172:     bprintf (\"Warning: read (magic)\\n\");",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2177:     break;",
          "2178:    }",
          "2179:    if ((char *)(curr_delay_import_dir + 2) > (char *)(bin->b->buf + bin->size)) {",
          "2181:     return NULL;",
          "2182:    }",
          "2183:    curr_delay_import_dir++;",
          "",
          "[Removed Lines]",
          "2180:     eprintf (\"Warning: malformed pe\\n\");",
          "",
          "[Added Lines]",
          "2182:     bprintf (\"Warning: malformed pe\\n\");",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2214:  }",
          "2216:  if (bin->import_directory_offset + bin->import_directory_size > bin->size) {",
          "2218:   goto out_error;",
          "2219:  }",
          "2220:  lib_map = r_strht_new();",
          "",
          "[Removed Lines]",
          "2217:   eprintf (\"import directory offset bigger than file\\n\");",
          "",
          "[Added Lines]",
          "2219:   bprintf (\"import directory offset bigger than file\\n\");",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "2236:     goto next;",
          "2237:    }",
          "2238:    if (len < 2 || libs[index].name[0] == 0) { // minimum string length",
          "2240:     break;",
          "2241:    }",
          "2242:    libs[index].name[len-1] = '\\0';",
          "",
          "[Removed Lines]",
          "2239:     eprintf (\"Warning: read (libs - import dirs) %d\\n\", len);",
          "",
          "[Added Lines]",
          "2241:     bprintf (\"Warning: read (libs - import dirs) %d\\n\", len);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2270:    }",
          "2271:    len = r_buf_read_at (bin->b, name_off, (ut8*)libs[index].name, PE_STRING_LENGTH);",
          "2272:    if (len != PE_STRING_LENGTH) {",
          "2274:     break;",
          "2275:    }",
          "2276:    libs[index].name[len-1] = '\\0';",
          "",
          "[Removed Lines]",
          "2273:     eprintf (\"Warning: read (libs - delay import dirs)\\n\");",
          "",
          "[Added Lines]",
          "2275:     bprintf (\"Warning: read (libs - delay import dirs)\\n\");",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "2671:  return NULL;",
          "2672: }",
          "2675:  ut8 *buf;",
          "2676:  struct PE_(r_bin_pe_obj_t) *bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));",
          "2677:  if (!bin) {",
          "2678:   return NULL;",
          "2679:  }",
          "2680:  bin->file = file;",
          "2682:   return PE_(r_bin_pe_free)(bin);",
          "2683:  }",
          "2684:  bin->b = r_buf_new ();",
          "",
          "[Removed Lines]",
          "2674: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file) {",
          "2681:  if (!(buf = (ut8*)r_file_slurp(file, &bin->size))) {",
          "",
          "[Added Lines]",
          "2676: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file, bool verbose) {",
          "2683:  if (!(buf = (ut8*)r_file_slurp (file, &bin->size))) {",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "2686:   free (buf);",
          "2687:   return PE_(r_bin_pe_free)(bin);",
          "2688:  }",
          "2689:  free (buf);",
          "2690:  if (!bin_pe_init(bin)) {",
          "2691:   return PE_(r_bin_pe_free)(bin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2691:  bin->verbose = verbose;",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "2693:  return bin;",
          "2694: }",
          "2697:  struct PE_(r_bin_pe_obj_t) *bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));",
          "2698:  if (!bin) {",
          "2699:   return NULL;",
          "2700:  }",
          "2701:  bin->kv = sdb_new0 ();",
          "2702:  bin->b = r_buf_new ();",
          "2703:  bin->size = buf->length;",
          "2704:  if (!r_buf_set_bytes (bin->b, buf->buf, bin->size)){",
          "2705:   return PE_(r_bin_pe_free)(bin);",
          "2706:  }",
          "2708:   return PE_(r_bin_pe_free)(bin);",
          "2709:  return bin;",
          "2710: }",
          "",
          "[Removed Lines]",
          "2696: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(struct r_buf_t *buf) {",
          "2707:  if (!bin_pe_init(bin))",
          "",
          "[Added Lines]",
          "2699: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(RBuffer *buf, bool verbose) {",
          "2706:  bin->verbose = verbose;",
          "2711:  if (!bin_pe_init (bin)) {",
          "2713:  }",
          "",
          "---------------"
        ],
        "libr/bin/format/pe/pe.h||libr/bin/format/pe/pe.h": [
          "File: libr/bin/format/pe/pe.h -> libr/bin/format/pe/pe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:  int size;",
          "88:  int num_sections;",
          "89:  int endian;",
          "90:  RList *relocs;",
          "91:  const char* file;",
          "92:  struct r_buf_t* b;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90:  bool verbose;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125: int PE_(r_bin_pe_is_stripped_local_syms)(struct PE_(r_bin_pe_obj_t)* bin);",
          "126: int PE_(r_bin_pe_is_stripped_debug)(struct PE_(r_bin_pe_obj_t)* bin);",
          "127: void* PE_(r_bin_pe_free)(struct PE_(r_bin_pe_obj_t)* bin);",
          "130: int PE_(r_bin_pe_get_debug_data)(struct PE_(r_bin_pe_obj_t) *bin, struct SDebugInfo *res);",
          "131: int PE_(bin_pe_get_claimed_checksum)(struct PE_(r_bin_pe_obj_t) *bin);",
          "132: int PE_(bin_pe_get_actual_checksum)(struct PE_(r_bin_pe_obj_t) *bin);",
          "",
          "[Removed Lines]",
          "128: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file);",
          "129: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(struct r_buf_t *buf);",
          "",
          "[Added Lines]",
          "129: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file, bool verbose);",
          "130: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(struct r_buf_t *buf, bool verbose);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:  }",
          "50:  tbuf = r_buf_new ();",
          "51:  r_buf_set_bytes (tbuf, buf, sz);",
          "53:  if (res) {",
          "54:   sdb_ns_set (sdb, \"info\", res->kv);",
          "55:  }",
          "",
          "[Removed Lines]",
          "52:  res = Elf_(r_bin_elf_new_buf) (tbuf);",
          "",
          "[Added Lines]",
          "52:  res = Elf_(r_bin_elf_new_buf) (tbuf, arch->rbin->verbose);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:  if (!buf || !sz || sz == UT64_MAX) {",
          "40:   return NULL;",
          "41:  }",
          "43:  r_buf_set_bytes (tbuf, buf, sz);",
          "45:  if (res) {",
          "46:   sdb_ns_set (sdb, \"info\", res->kv);",
          "47:  }",
          "",
          "[Removed Lines]",
          "42:  tbuf = r_buf_new();",
          "44:  res = MACH0_(new_buf) (tbuf);",
          "",
          "[Added Lines]",
          "42:  tbuf = r_buf_new ();",
          "44:  res = MACH0_(new_buf) (tbuf, arch->rbin->verbose);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c": [
          "File: libr/bin/p/bin_pe.c -> libr/bin/p/bin_pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:  if (!buf || !sz || sz == UT64_MAX) {",
          "28:   return NULL;",
          "29:  }",
          "31:  r_buf_set_bytes (tbuf, buf, sz);",
          "33:  if (res) {",
          "34:   sdb_ns_set (sdb, \"info\", res->kv);",
          "35:  }",
          "",
          "[Removed Lines]",
          "30:  tbuf = r_buf_new();",
          "32:  res = PE_(r_bin_pe_new_buf) (tbuf);",
          "",
          "[Added Lines]",
          "30:  tbuf = r_buf_new ();",
          "32:  res = PE_(r_bin_pe_new_buf) (tbuf, arch->rbin->verbose);",
          "",
          "---------------"
        ],
        "libr/core/cconfig.c||libr/core/cconfig.c": [
          "File: libr/core/cconfig.c -> libr/core/cconfig.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1413:  return true;",
          "1414: }",
          "1416: static int cb_rawstr(void *user, void *data) {",
          "1417:  RCore *core = (RCore *) user;",
          "1418:  RConfigNode *node = (RConfigNode *) data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1416: static int cb_binverbose(void *user, void *data) {",
          "1417:  RCore *core = (RCore *) user;",
          "1418:  RConfigNode *node = (RConfigNode *) data;",
          "1419:  core->bin->verbose = node->i_value;",
          "1420:  return true;",
          "1421: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1876:  SETCB(\"bin.debase64\", \"false\", &cb_debase64, \"Try to debase64 all strings\");",
          "1877:  SETPREF(\"bin.classes\", \"true\", \"Load classes from rbin on startup\");",
          "1878:  SETPREF(\"bin.mergeflags\", \"true\", \"Merge symbols with the same name into the same flag\");",
          "1881:  SETPREF(\"prj.name\", \"\", \"Name of current project\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1886:  SETCB(\"bin.verbose\", \"true\", &cb_binverbose, \"Show RBin warnings when loading binaries\");",
          "",
          "---------------"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "243:  char *prefix; // bin.prefix",
          "244:  ut64 filter_rules;",
          "245:  bool demanglercmd;",
          "246: } RBin;",
          "248: typedef struct r_bin_xtr_metadata_t {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246:  bool verbose;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "409232f7e496778b9fa26dbfd454041bb3f4900b",
      "candidate_info": {
        "commit_hash": "409232f7e496778b9fa26dbfd454041bb3f4900b",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/409232f7e496778b9fa26dbfd454041bb3f4900b",
        "files": [
          "libr/bin/format/elf/elf_write.c",
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/p/bin_dex.c"
        ],
        "message": "Fix code style",
        "before_after_code_files": [
          "libr/bin/format/elf/elf_write.c||libr/bin/format/elf/elf_write.c",
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ],
          "candidate": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/elf/elf_write.c||libr/bin/format/elf/elf_write.c": [
          "File: libr/bin/format/elf/elf_write.c -> libr/bin/format/elf/elf_write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:     return 0;",
          "89:    }",
          "92:     perror(\"read (rel)\");",
          "94:    for (j = 0, relp = rel; j < shdrp->sh_size; j += sizeof(Elf_(Rela)), relp++) {",
          "",
          "[Removed Lines]",
          "91:    if (r_buf_read_at(bin->b, shdrp->sh_offset, (ut8*)rel, shdrp->sh_size) == -1)",
          "",
          "[Added Lines]",
          "91:    if (r_buf_read_at (bin->b, shdrp->sh_offset, (ut8*)rel, shdrp->sh_size) == -1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110:  for (i = 0, shdrp = shdr; i < ehdr->e_shnum; i++, shdrp++) {",
          "112:    shdrp->sh_size = rsz_size;",
          "113:    done = 1;",
          "114:   } else if (shdrp->sh_offset >= rsz_offset + rsz_osize) {",
          "",
          "[Removed Lines]",
          "111:   if (!done && !strncmp(name, &strtab[shdrp->sh_name], ELF_STRING_LENGTH)) {",
          "",
          "[Added Lines]",
          "111:   if (!done && !strncmp (name, &strtab[shdrp->sh_name], ELF_STRING_LENGTH)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "116:    if (shdrp->sh_addr) shdrp->sh_addr += delta;",
          "118:   }",
          "120:   if (r_buf_write_at (bin->b, off, (ut8*)shdrp, sizeof (Elf_(Shdr))) == -1)",
          "123:  }",
          "",
          "[Removed Lines]",
          "119:   off = ehdr->e_shoff + i * sizeof(Elf_(Shdr));",
          "121:    perror(\"write (shdr)\");",
          "122:   printf(\"-> elf section (%s)\\n\", &strtab[shdrp->sh_name]);",
          "",
          "[Added Lines]",
          "119:   off = ehdr->e_shoff + i * sizeof (Elf_(Shdr));",
          "121:    perror (\"write (shdr)\");",
          "122:   printf (\"-> elf section (%s)\\n\", &strtab[shdrp->sh_name]);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "135:    if (phdrp->p_vaddr) phdrp->p_vaddr += delta;",
          "136:    if (phdrp->p_paddr) phdrp->p_paddr += delta;",
          "137:   }",
          "139:   if (r_buf_write_at (bin->b, off, (ut8*)phdrp, sizeof (Elf_(Phdr))) == -1)",
          "142:  }",
          "",
          "[Removed Lines]",
          "138:   off = ehdr->e_phoff + i * sizeof(Elf_(Phdr));",
          "140:    perror(\"write (phdr)\");",
          "141:   printf(\"-> program header (0x%08\"PFMT64x\")\\n\", (ut64) phdrp->p_offset);",
          "",
          "[Added Lines]",
          "138:   off = ehdr->e_phoff + i * sizeof (Elf_(Phdr));",
          "140:    perror (\"write (phdr)\");",
          "141:   printf (\"-> program header (0x%08\"PFMT64x\")\\n\", (ut64) phdrp->p_offset);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "159:  r_buf_read_at (bin->b, 0, (ut8*)buf, bin->size);",
          "160:  r_buf_set_bytes (bin->b, (ut8*)buf, (int)(rsz_offset+rsz_size+rest_size));",
          "163:  r_buf_read_at (bin->b, rsz_offset + rsz_osize, (ut8*)buf, rest_size);",
          "165:  r_buf_write_at (bin->b, rsz_offset + rsz_size, (ut8*)buf, rest_size);",
          "168:  bin->size = bin->b->length;",
          "170:  return delta;",
          "",
          "[Removed Lines]",
          "162:  printf(\"COPY FROM 0x%08\"PFMT64x\"\\n\", (ut64)(rsz_offset+rsz_osize));",
          "164:  printf(\"COPY TO 0x%08\"PFMT64x\"\\n\", (ut64)(rsz_offset+rsz_size));",
          "166:  printf(\"Shifted %d bytes\\n\", (int)delta);",
          "167:  free(buf);",
          "",
          "[Added Lines]",
          "162:  printf (\"COPY FROM 0x%08\"PFMT64x\"\\n\", (ut64)(rsz_offset+rsz_osize));",
          "164:  printf (\"COPY TO 0x%08\"PFMT64x\"\\n\", (ut64)(rsz_offset+rsz_size));",
          "166:  printf (\"Shifted %d bytes\\n\", (int)delta);",
          "167:  free (buf);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "396:   return false;",
          "397:  }",
          "400:  if (len != sizeof (struct dysymtab_command)) {",
          "401:   bprintf (\"Error: read (dysymtab)\\n\");",
          "402:   return false;",
          "",
          "[Removed Lines]",
          "399:  len = r_buf_read_at(bin->b, off, dysym, sizeof (struct dysymtab_command));",
          "",
          "[Added Lines]",
          "399:  len = r_buf_read_at (bin->b, off, dysym, sizeof (struct dysymtab_command));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "426:  bin->ntoc = bin->dysymtab.ntoc;",
          "427:  if (bin->ntoc > 0) {",
          "429:    perror (\"calloc (toc)\");",
          "430:    return false;",
          "431:   }",
          "",
          "[Removed Lines]",
          "428:   if (!(bin->toc = calloc (bin->ntoc, sizeof(struct dylib_table_of_contents)))) {",
          "",
          "[Added Lines]",
          "428:   if (!(bin->toc = calloc (bin->ntoc, sizeof (struct dylib_table_of_contents)))) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "442:    return false;",
          "443:   }",
          "444:   for (i = 0; i < bin->ntoc; i++) {",
          "446:     i * sizeof (struct dylib_table_of_contents),",
          "447:     dytoc, sizeof (struct dylib_table_of_contents));",
          "448:    if (len != sizeof (struct dylib_table_of_contents)) {",
          "",
          "[Removed Lines]",
          "445:    len = r_buf_read_at(bin->b, bin->dysymtab.tocoff +",
          "",
          "[Added Lines]",
          "445:    len = r_buf_read_at (bin->b, bin->dysymtab.tocoff +",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "456:  }",
          "457:  bin->nmodtab = bin->dysymtab.nmodtab;",
          "458:  if (bin->nmodtab > 0) {",
          "460:    perror (\"calloc (modtab)\");",
          "461:    return false;",
          "462:   }",
          "",
          "[Removed Lines]",
          "459:   if (!(bin->modtab = calloc (bin->nmodtab, sizeof(struct MACH0_(dylib_module))))) {",
          "",
          "[Added Lines]",
          "459:   if (!(bin->modtab = calloc (bin->nmodtab, sizeof (struct MACH0_(dylib_module))))) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "474:    return false;",
          "475:   }",
          "476:   for (i = 0; i < bin->nmodtab; i++) {",
          "478:     i * sizeof (struct MACH0_(dylib_module)),",
          "479:     dymod, sizeof (struct MACH0_(dylib_module)));",
          "480:    if (len == -1) {",
          "",
          "[Removed Lines]",
          "477:    len = r_buf_read_at(bin->b, bin->dysymtab.modtaboff +",
          "",
          "[Added Lines]",
          "477:    len = r_buf_read_at (bin->b, bin->dysymtab.modtaboff +",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "505:  }",
          "506:  bin->nindirectsyms = bin->dysymtab.nindirectsyms;",
          "507:  if (bin->nindirectsyms > 0) {",
          "509:    perror (\"calloc (indirectsyms)\");",
          "510:    return false;",
          "511:   }",
          "",
          "[Removed Lines]",
          "508:   if (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof(ut32)))) {",
          "",
          "[Added Lines]",
          "508:   if (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof (ut32)))) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "588:    struct blob_t entitlements = {0};",
          "589:    entitlements.magic = r_read_ble32 (bin->b->buf + off, little_);",
          "590:    entitlements.length = r_read_ble32 (bin->b->buf + off + 4, little_);",
          "592:    if (len <= bin->size && len > 1) {",
          "593:     bin->signature = calloc (1, len + 1);",
          "594:     if (bin->signature) {",
          "",
          "[Removed Lines]",
          "591:    len = entitlements.length - sizeof(struct blob_t);",
          "",
          "[Added Lines]",
          "591:    len = entitlements.length - sizeof (struct blob_t);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "627:   goto wrong_read;",
          "628:  bin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);",
          "629:  bin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);",
          "631:  if (len == -1)",
          "632:   goto wrong_read;",
          "",
          "[Removed Lines]",
          "630:  flavor = r_read_ble32 (bin->b->buf + off + sizeof(struct thread_command), bin->big_endian);",
          "",
          "[Added Lines]",
          "630:  flavor = r_read_ble32 (bin->b->buf + off + sizeof (struct thread_command), bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "636:   return false;",
          "640:     bin->big_endian);",
          "641:  ptr_thread = off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (count);",
          "",
          "[Removed Lines]",
          "639:  count = r_read_ble32 (bin->b->buf + off + sizeof (struct thread_command) + sizeof(flavor),",
          "",
          "[Added Lines]",
          "639:  count = r_read_ble32 (bin->b->buf + off + sizeof (struct thread_command) + sizeof (flavor),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1489:   to = R_MIN (to , symbols_size / sizeof (struct symbol_t));",
          "1490:   to = R_MIN (to, bin->nsymtab);",
          "1491: #else",
          "1493:   to = symbols_count; //symbols_size/sizeof(struct symbol_t);",
          "1494: #endif",
          "1496:   if (to > 0x500000) {",
          "1497:    bprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);",
          "1498:    free (symbols);",
          "",
          "[Removed Lines]",
          "1492:   from = R_MIN (R_MAX (0, from), symbols_size/sizeof(struct symbol_t));",
          "1495:   int maxsymbols = symbols_size / sizeof(struct symbol_t);",
          "",
          "[Added Lines]",
          "1492:   from = R_MIN (R_MAX (0, from), symbols_size/sizeof (struct symbol_t));",
          "1495:   int maxsymbols = symbols_size / sizeof (struct symbol_t);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1656:  if (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {",
          "1657:   return NULL;",
          "1658:  }",
          "1660:   return NULL;",
          "1661:  }",
          "1662:  for (i = j = 0; i < bin->dysymtab.nundefsym; i++) {",
          "",
          "[Removed Lines]",
          "1659:  if (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct import_t)))) {",
          "",
          "[Added Lines]",
          "1659:  if (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1911:   if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {",
          "1912:    return NULL;",
          "1913:   }",
          "1915:    return NULL;",
          "1916:   }",
          "1917:   for (j = 0; j < bin->dysymtab.nundefsym; j++) {",
          "",
          "[Removed Lines]",
          "1914:   if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {",
          "",
          "[Added Lines]",
          "1914:   if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct reloc_t)))) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1967:  if (!bin->nlibs) {",
          "1968:   return NULL;",
          "1969:  }",
          "1971:   return NULL;",
          "1972:  }",
          "1973:  for (i = 0; i < bin->nlibs; i++) {",
          "",
          "[Removed Lines]",
          "1970:  if (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {",
          "",
          "[Added Lines]",
          "1970:  if (!(libs = calloc ((bin->nlibs + 1), sizeof (struct lib_t)))) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2353:  ut64 addr = 0x20 - 4;",
          "2354:  ut32 word = 0;",
          "2356: #define READWORD() \\",
          "2357:   addr += 4; \\",
          "2358:   if (!r_buf_read_at (buf, addr, (ut8*)wordbuf, 4)) { \\",
          "",
          "[Removed Lines]",
          "2355:  ut8 wordbuf[sizeof(word)];",
          "",
          "[Added Lines]",
          "2355:  ut8 wordbuf[sizeof (word)];",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2435: #endif",
          "2436:  }",
          "2437:  len = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));",
          "2439:   free (macho_hdr);",
          "2440:   return NULL;",
          "2441:  }",
          "",
          "[Removed Lines]",
          "2438:  if (len != sizeof(struct MACH0_(mach_header))) {",
          "",
          "[Added Lines]",
          "2438:  if (len != sizeof (struct MACH0_(mach_header))) {",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c": [
          "File: libr/bin/p/bin_dex.c -> libr/bin/p/bin_dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1767:  r_list_foreach (bin->methods_list, iter, m) {",
          "1768:   if (strlen (m->name) > 30 && m->bind &&",
          "1770:       !strcmp (m->name + strlen (m->name) - 31,",
          "1771:         \".onCreate(Landroid/os/Bundle;)V\")) {",
          "1772:    if (!already_entry (ret, m->paddr)) {",
          "",
          "[Removed Lines]",
          "1769:    (!strcmp(m->bind, \"LOCAL\") || !strcmp(m->bind, \"GLOBAL\")) &&",
          "",
          "[Added Lines]",
          "1769:    (!strcmp (m->bind, \"LOCAL\") || !strcmp (m->bind, \"GLOBAL\")) &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c32624b86bf936110de2350eafa234e148a968dc",
      "candidate_info": {
        "commit_hash": "c32624b86bf936110de2350eafa234e148a968dc",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/c32624b86bf936110de2350eafa234e148a968dc",
        "files": [
          "libr/bin/format/mach0/fatmach0.c",
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/objc/mach0_classes.c",
          "libr/bin/p/bin_xtr_fatmach0.c",
          "libr/util/buf.c"
        ],
        "message": "Bigendian fixes: Mainly for mach0 (WIP)",
        "before_after_code_files": [
          "libr/bin/format/mach0/fatmach0.c||libr/bin/format/mach0/fatmach0.c",
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c",
          "libr/bin/p/bin_xtr_fatmach0.c||libr/bin/p/bin_xtr_fatmach0.c",
          "libr/util/buf.c||libr/util/buf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ],
          "candidate": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/fatmach0.c||libr/bin/format/mach0/fatmach0.c": [
          "File: libr/bin/format/mach0/fatmach0.c -> libr/bin/format/mach0/fatmach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: static int r_bin_fatmach0_init(struct r_bin_fatmach0_obj_t* bin) {",
          "9:  ut32 size;",
          "12:   perror (\"read (fat_header)\");",
          "13:   return false;",
          "14:  }",
          "15:  bin->nfat_arch = bin->hdr.nfat_arch;",
          "18:   return false;",
          "19:  }",
          "21:   return false;",
          "22:  }",
          "23:  size = bin->nfat_arch * sizeof (struct fat_arch);",
          "",
          "[Removed Lines]",
          "10:  int len = r_buf_fread_at (bin->b, 0, (ut8*)&bin->hdr, \"2I\", 1);",
          "11:  if (len < 1) {",
          "16:  if (sizeof (struct fat_header) + bin->nfat_arch * \\",
          "17:    sizeof (struct fat_arch) > bin->size) {",
          "20:  if (bin->hdr.magic != FAT_MAGIC || bin->nfat_arch == 0 || bin->nfat_arch < 1) {",
          "",
          "[Added Lines]",
          "10:  ut32 i;",
          "11:  ut8 hdrbytes[sizeof (struct fat_header)] = {0};",
          "12:  int len = r_buf_read_at (bin->b, 0, &hdrbytes[0], sizeof (struct fat_header));",
          "13:  if (len != sizeof (struct fat_header)) {",
          "17:  bin->hdr.magic = r_read_be32 (&hdrbytes[0]);",
          "18:  bin->hdr.nfat_arch = r_read_be32 (&hdrbytes[4]);",
          "20:  if (sizeof(struct fat_header) + bin->nfat_arch *",
          "21:   sizeof(struct fat_arch) > bin->size) {",
          "24:  if (bin->hdr.magic != FAT_MAGIC || !bin->nfat_arch || bin->nfat_arch < 1) {",
          "25:   eprintf(\"Endian FAT_MAGIC failed (?)\\n\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:   perror (\"malloc (fat_arch)\");",
          "29:   return false;",
          "30:  }",
          "37:  return true;",
          "38: }",
          "",
          "[Removed Lines]",
          "31:  len = r_buf_fread_at (bin->b, R_BUF_CUR, (ut8*)bin->archs, \"5I\", bin->nfat_arch);",
          "32:  if (len < 1) {",
          "33:   perror (\"read (fat_arch)\");",
          "34:   R_FREE (bin->archs);",
          "35:   return false;",
          "36:  }",
          "",
          "[Added Lines]",
          "36:  for (i = 0; i < bin->nfat_arch; i++) {",
          "37:   ut8 archbytes[sizeof (struct fat_arch)] = {0};",
          "38:   len = r_buf_read_at (bin->b, 8 + i * sizeof (struct fat_arch), &archbytes[0], sizeof (struct fat_arch));",
          "39:   if (len != sizeof (struct fat_arch)) {",
          "40:    perror (\"read (fat_arch)\");",
          "41:    R_FREE (bin->archs);",
          "42:    return false;",
          "43:   }",
          "44:   bin->archs[i].cputype = r_read_be32 (&archbytes[0]);",
          "45:   bin->archs[i].cpusubtype = r_read_be32 (&archbytes[4]);",
          "46:   bin->archs[i].offset = r_read_be32 (&archbytes[8]);",
          "47:   bin->archs[i].size = r_read_be32 (&archbytes[12]);",
          "48:   bin->archs[i].align = r_read_be32 (&archbytes[16]);",
          "49:  }",
          "50:  eprintf(\"fatmach init worked\\n\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "55:   perror (\"malloc (ret)\");",
          "56:   return NULL;",
          "57:  }",
          "59:   eprintf (\"Skipping corrupted sub-bin %d arch %d\\n\", idx, bin->archs[idx].size);",
          "60:   free (ret);",
          "61:   return NULL;",
          "",
          "[Removed Lines]",
          "58:  if (bin->archs[idx].size == 0 || bin->archs[idx].size > bin->size) {",
          "",
          "[Added Lines]",
          "72:  if (!bin->archs[idx].size || bin->archs[idx].size > bin->size) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "65:   free (ret);",
          "66:   return NULL;",
          "67:  }",
          "69:   perror (\"read (buf)\");",
          "70:   free (buf);",
          "71:   free (ret);",
          "",
          "[Removed Lines]",
          "68:  if (r_buf_read_at (bin->b, bin->archs[idx].offset, buf, bin->archs[idx].size) == -1) {",
          "",
          "[Added Lines]",
          "82:  if (r_buf_read_at (bin->b, bin->archs[idx].offset, buf, bin->archs[idx].size) != bin->archs[idx].size) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "101: struct r_bin_fatmach0_obj_t* r_bin_fatmach0_new(const char* file) {",
          "102:  ut8 *buf;",
          "103:  struct r_bin_fatmach0_obj_t *bin = R_NEW0 (struct r_bin_fatmach0_obj_t);",
          "105:  bin->file = file;",
          "107:   return r_bin_fatmach0_free (bin);",
          "108:  bin->b = r_buf_new ();",
          "109:  if (!r_buf_set_bytes (bin->b, buf, bin->size)) {",
          "110:   free (buf);",
          "111:   return r_bin_fatmach0_free (bin);",
          "112:  }",
          "113:  free (buf);",
          "115:   return r_bin_fatmach0_free (bin);",
          "116:  return bin;",
          "117: }",
          "119: struct r_bin_fatmach0_obj_t* r_bin_fatmach0_from_bytes_new(const ut8* buf, ut64 size) {",
          "120:  struct r_bin_fatmach0_obj_t *bin = R_NEW0 (struct r_bin_fatmach0_obj_t);",
          "123:  bin->b = r_buf_new ();",
          "124:  bin->size = size;",
          "126:   return r_bin_fatmach0_free (bin);",
          "128:   return r_bin_fatmach0_free (bin);",
          "129:  return bin;",
          "130: }",
          "",
          "[Removed Lines]",
          "104:  if (!bin) return NULL;",
          "106:  if (!(buf = (ut8*)r_file_slurp (file, &bin->size)))",
          "114:  if (!r_bin_fatmach0_init (bin))",
          "121:  if (!bin) return NULL;",
          "122:  if (!buf) return r_bin_fatmach0_free (bin);",
          "125:  if (!r_buf_set_bytes (bin->b, buf, size))",
          "127:  if (!r_bin_fatmach0_init (bin))",
          "",
          "[Added Lines]",
          "118:  if (!bin) {",
          "119:   return NULL;",
          "120:  }",
          "122:  if (!(buf = (ut8*)r_file_slurp (file, &bin->size))) {",
          "124:  }",
          "131:  if (!r_bin_fatmach0_init (bin)) {",
          "133:  }",
          "139:  if (!bin) {",
          "140:   return NULL;",
          "141:  }",
          "142:  if (!buf) {",
          "143:   return r_bin_fatmach0_free (bin);",
          "144:  }",
          "147:  if (!r_buf_set_bytes (bin->b, buf, size)) {",
          "149:  }",
          "150:  if (!r_bin_fatmach0_init (bin)) {",
          "152:  }",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:  ut8 *p;",
          "10: } ulebr;",
          "14: static ut64 read_uleb128(ulebr *r, ut8 *end) {",
          "15:  ut64 result = 0;",
          "16:  int bit = 0;",
          "",
          "[Removed Lines]",
          "12: static bool little_;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83: }",
          "85: static int init_hdr(struct MACH0_(obj_t)* bin) {",
          "87:  int len;",
          "90:   eprintf (\"Error: read (magic)\\n\");",
          "91:   return false;",
          "92:  }",
          "94:   bin->big_endian = false;",
          "96:   bin->big_endian = true;",
          "98:   bin->big_endian = true;",
          "99:  } else {",
          "100:   return false; // object files are magic == 0, but body is different :?",
          "101:  }",
          "103: #if R_BIN_MACH064",
          "107: #endif",
          "110:  sdb_set (bin->kv, \"mach0_header.format\",",
          "111:   \"xxxxddx \"",
          "112:   \"magic cputype cpusubtype filetype ncmds sizeofcmds flags\", 0);",
          "",
          "[Removed Lines]",
          "86:  ut32 magic = 0;",
          "89:  if (r_buf_read_at (bin->b, 0, (ut8*)&magic, 4) < 1) {",
          "93:  if (magic == MACH0_(MH_MAGIC)) {",
          "95:  } else if (magic == MACH0_(MH_CIGAM)) {",
          "97:  } else if (magic == FAT_CIGAM) {",
          "102:  len = r_buf_fread_at (bin->b, 0, (ut8*)&bin->hdr,",
          "104:   bin->big_endian?\"8I\":\"8i\", 1",
          "105: #else",
          "106:   bin->big_endian?\"7I\":\"7i\", 1",
          "108:  );",
          "",
          "[Added Lines]",
          "84:  ut8 magicbytes[4]= {0};",
          "85:  ut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};",
          "88:  if (r_buf_read_at (bin->b, 0, magicbytes, 4) < 1) {",
          "92:  if (r_read_le32(magicbytes) == 0xfeedface) {",
          "93:   bin->big_endian = false;",
          "94:  } else if (r_read_be32(magicbytes) == 0xfeedface) {",
          "95:   bin->big_endian = true;",
          "96:  } else if (r_read_le32(magicbytes) == FAT_MAGIC) {",
          "98:  } else if (r_read_be32(magicbytes) == FAT_MAGIC) {",
          "100:  } else if (r_read_le32(magicbytes) == 0xfeedfacf) {",
          "101:   bin->big_endian = false;",
          "102:  } else if (r_read_be32(magicbytes) == 0xfeedfacf) {",
          "107:  len = r_buf_read_at (bin->b, 0, machohdrbytes, sizeof (machohdrbytes));",
          "108:  bin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);",
          "109:  bin->hdr.cputype = r_read_ble (&machohdrbytes[4], bin->big_endian, 32);",
          "110:  bin->hdr.cpusubtype = r_read_ble (&machohdrbytes[8], bin->big_endian, 32);",
          "111:  bin->hdr.filetype = r_read_ble (&machohdrbytes[12], bin->big_endian, 32);",
          "112:  bin->hdr.ncmds = r_read_ble (&machohdrbytes[16], bin->big_endian, 32);",
          "113:  bin->hdr.sizeofcmds = r_read_ble (&machohdrbytes[20], bin->big_endian, 32);",
          "114:  bin->hdr.flags = r_read_ble (&machohdrbytes[24], bin->big_endian, 32);",
          "116:  bin->hdr.reserved = r_read_ble (&machohdrbytes[28], bin->big_endian, 32);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "137: }",
          "139: static int parse_segments(struct MACH0_(obj_t)* bin, ut64 off) {",
          "141:  ut32 size_sects;",
          "143:  if (!UT32_MUL (&size_sects, bin->nsegs, sizeof (struct MACH0_(segment_command))))",
          "144:   return false;",
          "",
          "[Removed Lines]",
          "140:  int sect, len, seg = bin->nsegs - 1;",
          "",
          "[Added Lines]",
          "148:  int i, j, k, sect, len;",
          "150:  ut8 segcom[sizeof (struct MACH0_(segment_command))] = {0};",
          "151:  ut8 sec[sizeof (struct MACH0_(section))] = {0};",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:   perror (\"realloc (seg)\");",
          "151:   return false;",
          "152:  }",
          "153: #if R_BIN_MACH064",
          "155: #else",
          "157: #endif",
          "161:  sdb_num_set (bin->kv, \"mach0_segments.count\", 0, 0);",
          "162:  sdb_set (bin->kv, \"mach0_segment.format\",",
          "163:   \"xd[16]zxxxxoodx \"",
          "164:   \"cmd cmdsize segname vmaddr vmsize \"",
          "165:   \"fileoff filesize maxprot initprot nsects flags\", 0);",
          "172:   sect = bin->nsects;",
          "174:   if (bin->nsects > 128) {",
          "175:    int new_nsects = bin->nsects & 0xf;",
          "176:    eprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",",
          "",
          "[Removed Lines]",
          "154:  len = r_buf_fread_at (bin->b, off, (ut8*)&bin->segs[seg], bin->big_endian?\"2I16c4L4I\":\"2i16c4l4i\", 1);",
          "156:  len = r_buf_fread_at (bin->b, off, (ut8*)&bin->segs[seg], bin->big_endian?\"2I16c8I\":\"2i16c8i\", 1);",
          "158:  if (len < 1)",
          "159:   return false;",
          "160:  sdb_num_set (bin->kv, sdb_fmt (0, \"mach0_segment_%d.offset\", seg), off, 0);",
          "167:  if (len < 1) {",
          "168:   eprintf (\"Error: read (seg)\\n\");",
          "169:   return false;",
          "170:  }",
          "171:  if (bin->segs[seg].nsects > 0) {",
          "173:   bin->nsects += bin->segs[seg].nsects;",
          "",
          "[Added Lines]",
          "163:  j = bin->nsegs - 1;",
          "164:  len = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));",
          "165:  if (len < 1) {",
          "166:   eprintf (\"Error: read (seg)\\n\");",
          "167:   return false;",
          "168:  }",
          "169:  i = 0;",
          "170:  bin->segs[j].cmd = r_read_ble32 (&segcom[i], bin->big_endian);",
          "171:  i += sizeof (ut32);",
          "172:  bin->segs[j].cmdsize = r_read_ble32 (&segcom[i], bin->big_endian);",
          "173:  i += sizeof (ut32);",
          "174:  memcpy (&bin->segs[j].segname, &segcom[i], 16);",
          "175:  i += 16;",
          "177:  bin->segs[j].vmaddr = r_read_ble64 (&segcom[i], bin->big_endian);",
          "178:  i += sizeof (ut64);",
          "179:  bin->segs[j].vmsize = r_read_ble64 (&segcom[i], bin->big_endian);",
          "180:  i += sizeof (ut64);",
          "181:  bin->segs[j].fileoff = r_read_ble64 (&segcom[i], bin->big_endian);",
          "182:  i += sizeof (ut64);",
          "183:  bin->segs[j].filesize = r_read_ble64 (&segcom[i], bin->big_endian);",
          "184:  i += sizeof (ut64);",
          "186:  bin->segs[j].vmaddr = r_read_ble32 (&segcom[i], bin->big_endian);",
          "187:  i += sizeof (ut32);",
          "188:  bin->segs[j].vmsize = r_read_ble32 (&segcom[i], bin->big_endian);",
          "189:  i += sizeof (ut32);",
          "190:  bin->segs[j].fileoff = r_read_ble32 (&segcom[i], bin->big_endian);",
          "191:  i += sizeof (ut32);",
          "192:  bin->segs[j].filesize = r_read_ble32 (&segcom[i], bin->big_endian);",
          "193:  i += sizeof (ut32);",
          "195:  bin->segs[j].maxprot = r_read_ble32 (&segcom[i], bin->big_endian);",
          "196:  i += sizeof (ut32);",
          "197:  bin->segs[j].initprot = r_read_ble32 (&segcom[i], bin->big_endian);",
          "198:  i += sizeof (ut32);",
          "199:  bin->segs[j].nsects = r_read_ble32 (&segcom[i], bin->big_endian);",
          "200:  i += sizeof (ut32);",
          "201:  bin->segs[j].flags = r_read_ble32 (&segcom[i], bin->big_endian);",
          "203:  sdb_num_set (bin->kv, sdb_fmt (0, \"mach0_segment_%d.offset\", j), off, 0);",
          "210:  if (bin->segs[j].nsects > 0) {",
          "212:   bin->nsects += bin->segs[j].nsects;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "187:     return false;",
          "188:    }",
          "192:     bin->nsects = sect;",
          "193:     return false;",
          "194:    }",
          "",
          "[Removed Lines]",
          "190:    if (bin->segs[seg].cmdsize != sizeof (struct MACH0_(segment_command)) \\",
          "191:        + (sizeof (struct MACH0_(section))*bin->segs[seg].nsects)){",
          "",
          "[Added Lines]",
          "229:    if (bin->segs[j].cmdsize != sizeof (struct MACH0_(segment_command)) \\",
          "230:        + (sizeof (struct MACH0_(section))*bin->segs[j].nsects)){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "204:     bin->nsects = sect;",
          "205:     return false;",
          "206:    }",
          "209: #if R_BIN_MACH064",
          "211: #else",
          "213: #endif",
          "219:    }",
          "220:   } else {",
          "221:    eprintf (\"Warning: Invalid number of sections\\n\");",
          "",
          "[Removed Lines]",
          "207:    len = r_buf_fread_at (bin->b, off + sizeof (struct MACH0_(segment_command)),",
          "208:     (ut8*)&bin->sects[sect],",
          "210:     bin->big_endian?\"16c16c2L8I\":\"16c16c2l8i\",",
          "212:     bin->big_endian?\"16c16c9I\":\"16c16c9i\",",
          "214:     bin->nsects - sect);",
          "215:    if (len < 1) {",
          "216:     eprintf (\"Error: read (sects)\\n\");",
          "217:     bin->nsects = sect;",
          "218:     return false;",
          "",
          "[Added Lines]",
          "247:    k = sect;",
          "248:    {",
          "249:     len = r_buf_read_at (bin->b, off + sizeof (struct MACH0_(segment_command)),",
          "250:      sec, sizeof (struct MACH0_(section)));",
          "251:     if (len < 1) {",
          "252:      eprintf (\"Error: read (sects)\\n\");",
          "253:      bin->nsects = sect;",
          "254:      return false;",
          "255:     }",
          "257:     i = 0;",
          "258:     memcpy (&bin->sects[k].sectname, &sec[i], 16);",
          "259:     i += 16;",
          "260:     memcpy (&bin->sects[k].segname, &sec[i], 16);",
          "261:     i += 16;",
          "263:     bin->sects[k].addr = r_read_ble64 (&sec[i], bin->big_endian);",
          "264:     i += sizeof (ut64);",
          "265:     bin->sects[k].size = r_read_ble64 (&sec[i], bin->big_endian);",
          "266:     i += sizeof (ut64);",
          "268:     bin->sects[k].addr = r_read_ble32 (&sec[i], bin->big_endian);",
          "269:     i += sizeof (ut32);",
          "270:     bin->sects[k].size = r_read_ble32 (&sec[i], bin->big_endian);",
          "271:     i += sizeof (ut32);",
          "272: #endif",
          "273:     bin->sects[k].offset = r_read_ble32 (&sec[i], bin->big_endian);",
          "274:     i += sizeof (ut32);",
          "275:     bin->sects[k].align = r_read_ble32 (&sec[i], bin->big_endian);",
          "276:     i += sizeof (ut32);",
          "277:     bin->sects[k].reloff = r_read_ble32 (&sec[i], bin->big_endian);",
          "278:     i += sizeof (ut32);",
          "279:     bin->sects[k].nreloc = r_read_ble32 (&sec[i], bin->big_endian);",
          "280:     i += sizeof (ut32);",
          "281:     bin->sects[k].flags = r_read_ble32 (&sec[i], bin->big_endian);",
          "282:     i += sizeof (ut32);",
          "283:     bin->sects[k].reserved1 = r_read_ble32 (&sec[i], bin->big_endian);",
          "284:     i += sizeof (ut32);",
          "285:     bin->sects[k].reserved2 = r_read_ble32 (&sec[i], bin->big_endian);",
          "286:     i += sizeof (ut32);",
          "287: #if R_BIN_MACH064",
          "288:     bin->sects[k].reserved3 = r_read_ble32 (&sec[i], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "229: static int parse_symtab(struct MACH0_(obj_t)* bin, ut64 off) {",
          "230:  struct symtab_command st;",
          "231:  ut32 size_sym;",
          "234:   return false;",
          "237:  if (len < 1) {",
          "238:   eprintf (\"Error: read (symtab)\\n\");",
          "239:   return false;",
          "240:  }",
          "241:  bin->symtab = NULL;",
          "242:  bin->nsymtab = 0;",
          "243:  if (st.strsize > 0 && st.strsize < bin->size && st.nsyms > 0) {",
          "244:   bin->nsymtab = st.nsyms;",
          "248:    return false;",
          "250:    return false;",
          "252:    return false;",
          "253:   if (!(bin->symstr = calloc (1, st.strsize + 2))) {",
          "254:    perror (\"calloc (symstr)\");",
          "255:    return false;",
          "",
          "[Removed Lines]",
          "233:  if (off > bin->size || off + sizeof (struct symtab_command) > bin->size)",
          "235:  int len = r_buf_fread_at (bin->b, off, (ut8*)&st,",
          "236:   bin->big_endian?\"6I\":\"6i\", 1);",
          "245:   if (st.stroff > bin->size || st.stroff + st.strsize > bin->size)",
          "246:    return false;",
          "247:   if (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist))))",
          "249:   if (!size_sym)",
          "251:   if (st.symoff > bin->size || st.symoff + size_sym > bin->size)",
          "",
          "[Added Lines]",
          "303:  int i;",
          "304:  ut8 symt[sizeof (struct symtab_command)] = {0};",
          "305:  ut8 nlst[sizeof (struct MACH0_(nlist))] = {0};",
          "307:  if (off > (ut64)bin->size || off + sizeof (struct symtab_command) > (ut64)bin->size)",
          "309:  int len = r_buf_read_at (bin->b, off, symt, sizeof (struct symtab_command));",
          "314:  st.cmd = r_read_ble32 (&symt[0], bin->big_endian);",
          "315:  st.cmdsize = r_read_ble32 (&symt[4], bin->big_endian);",
          "316:  st.symoff = r_read_ble32 (&symt[8], bin->big_endian);",
          "317:  st.nsyms = r_read_ble32 (&symt[12], bin->big_endian);",
          "318:  st.stroff = r_read_ble32 (&symt[16], bin->big_endian);",
          "319:  st.strsize = r_read_ble32 (&symt[20], bin->big_endian);",
          "329:   if (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist)))) {",
          "330:    eprintf(\"fail2\\n\");",
          "332:   }",
          "333:   if (!size_sym) {",
          "334:    eprintf(\"fail3\\n\");",
          "336:   }",
          "337:   if (st.symoff > bin->size || st.symoff + size_sym > bin->size) {",
          "338:    eprintf(\"fail4\\n\");",
          "340:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "267:    perror (\"calloc (symtab)\");",
          "268:    return false;",
          "269:   }",
          "270: #if R_BIN_MACH064",
          "273: #else",
          "276: #endif",
          "281:   }",
          "282:  }",
          "283:  return true;",
          "284: }",
          "286: static int parse_dysymtab(struct MACH0_(obj_t)* bin, ut64 off) {",
          "288:  ut32 size_tab;",
          "290:  if (off > bin->size || off + sizeof (struct dysymtab_command) > bin->size)",
          "291:   return false;",
          "294:  if (len < 1) {",
          "295:   eprintf (\"Error: read (dysymtab)\\n\");",
          "296:   return false;",
          "297:  }",
          "298:  bin->ntoc = bin->dysymtab.ntoc;",
          "299:  if (bin->ntoc > 0) {",
          "300:   if (!(bin->toc = calloc (bin->ntoc, sizeof(struct dylib_table_of_contents)))) {",
          "",
          "[Removed Lines]",
          "271:   len = r_buf_fread_at (bin->b, st.symoff, (ut8*)bin->symtab,",
          "272:    bin->big_endian?\"I2cSL\":\"i2csl\", bin->nsymtab);",
          "274:   len = r_buf_fread_at (bin->b, st.symoff, (ut8*)bin->symtab,",
          "275:    bin->big_endian?\"I2cSI\":\"i2csi\", bin->nsymtab);",
          "277:   if (len < 1) {",
          "278:    eprintf (\"Error: read (nlist)\\n\");",
          "279:    R_FREE (bin->symtab);",
          "280:    return false;",
          "287:  int len;",
          "293:  len = r_buf_fread_at(bin->b, off, (ut8*)&bin->dysymtab, bin->big_endian?\"20I\":\"20i\", 1);",
          "",
          "[Added Lines]",
          "358:   for (i = 0; i < bin->nsymtab; i++) {",
          "359:    len = r_buf_read_at (bin->b, st.symoff + i * sizeof (struct MACH0_(nlist)),",
          "360:       nlst, sizeof (struct MACH0_(nlist)));",
          "361:    if (len < 1) {",
          "362:     eprintf (\"Error: read (nlist)\\n\");",
          "363:     R_FREE (bin->symtab);",
          "364:     return false;",
          "365:    }",
          "367:    bin->symtab[i].n_un.n_strx = r_read_ble32 (&nlst[0], bin->big_endian);",
          "368:    bin->symtab[i].n_type = r_read_ble8 (&nlst[4]);",
          "369:    bin->symtab[i].n_sect = r_read_ble8 (&nlst[5]);",
          "370:    bin->symtab[i].n_desc = r_read_ble16 (&nlst[6], bin->big_endian);",
          "372:    bin->symtab[i].n_value = r_read_ble64 (&nlst[8], bin->big_endian);",
          "374:    bin->symtab[i].n_value = r_read_ble32 (&nlst[8], bin->big_endian);",
          "382:  int len, i;",
          "384:  ut8 dysym[sizeof (struct dysymtab_command)] = {0};",
          "385:  ut8 dytoc[sizeof (struct dylib_table_of_contents)] = {0};",
          "386:  ut8 dymod[sizeof (struct MACH0_(dylib_module))] = {0};",
          "387:  ut8 idsyms[sizeof (ut32)] = {0};",
          "392:  len = r_buf_read_at(bin->b, off, dysym, sizeof (struct dysymtab_command));",
          "398:  bin->dysymtab.cmd = r_read_ble32 (&dysym[0], bin->big_endian);",
          "399:  bin->dysymtab.cmdsize = r_read_ble32 (&dysym[4], bin->big_endian);",
          "400:  bin->dysymtab.ilocalsym = r_read_ble32 (&dysym[8], bin->big_endian);",
          "401:  bin->dysymtab.nlocalsym = r_read_ble32 (&dysym[12], bin->big_endian);",
          "402:  bin->dysymtab.iextdefsym = r_read_ble32 (&dysym[16], bin->big_endian);",
          "403:  bin->dysymtab.nextdefsym = r_read_ble32 (&dysym[20], bin->big_endian);",
          "404:  bin->dysymtab.iundefsym = r_read_ble32 (&dysym[24], bin->big_endian);",
          "405:  bin->dysymtab.nundefsym = r_read_ble32 (&dysym[28], bin->big_endian);",
          "406:  bin->dysymtab.tocoff = r_read_ble32 (&dysym[32], bin->big_endian);",
          "407:  bin->dysymtab.ntoc = r_read_ble32 (&dysym[36], bin->big_endian);",
          "408:  bin->dysymtab.modtaboff = r_read_ble32 (&dysym[40], bin->big_endian);",
          "409:  bin->dysymtab.nmodtab = r_read_ble32 (&dysym[44], bin->big_endian);",
          "410:  bin->dysymtab.extrefsymoff = r_read_ble32 (&dysym[48], bin->big_endian);",
          "411:  bin->dysymtab.nextrefsyms = r_read_ble32 (&dysym[52], bin->big_endian);",
          "412:  bin->dysymtab.indirectsymoff = r_read_ble32 (&dysym[56], bin->big_endian);",
          "413:  bin->dysymtab.nindirectsyms = r_read_ble32 (&dysym[60], bin->big_endian);",
          "414:  bin->dysymtab.extreloff = r_read_ble32 (&dysym[64], bin->big_endian);",
          "415:  bin->dysymtab.nextrel = r_read_ble32 (&dysym[68], bin->big_endian);",
          "416:  bin->dysymtab.locreloff = r_read_ble32 (&dysym[72], bin->big_endian);",
          "417:  bin->dysymtab.nlocrel = r_read_ble32 (&dysym[76], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "313:    R_FREE (bin->toc);",
          "314:    return false;",
          "315:   }",
          "322:   }",
          "323:  }",
          "324:  bin->nmodtab = bin->dysymtab.nmodtab;",
          "",
          "[Removed Lines]",
          "316:   len = r_buf_fread_at(bin->b, bin->dysymtab.tocoff,",
          "317:    (ut8*)bin->toc, bin->big_endian?\"2I\":\"2i\", bin->ntoc);",
          "318:   if (len < 1) {",
          "319:    eprintf (\"Error: read (toc)\\n\");",
          "320:    R_FREE (bin->toc);",
          "321:    return false;",
          "",
          "[Added Lines]",
          "437:   for (i = 0; i < bin->ntoc; i++) {",
          "438:    len = r_buf_read_at(bin->b, bin->dysymtab.tocoff +",
          "439:     i * sizeof (struct dylib_table_of_contents),",
          "440:     dytoc, sizeof (struct dylib_table_of_contents));",
          "441:    if (len < 1) {",
          "442:     eprintf (\"Error: read (toc)\\n\");",
          "443:     R_FREE (bin->toc);",
          "444:     return false;",
          "445:    }",
          "446:    bin->toc[i].symbol_index = r_read_ble32 (&dytoc[0], bin->big_endian);",
          "447:    bin->toc[i].module_index = r_read_ble32 (&dytoc[4], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "340:    R_FREE (bin->modtab);",
          "341:    return false;",
          "342:   }",
          "343: #if R_BIN_MACH064",
          "346: #else",
          "349: #endif",
          "354:   }",
          "355:  }",
          "356:  bin->nindirectsyms = bin->dysymtab.nindirectsyms;",
          "",
          "[Removed Lines]",
          "344:   len = r_buf_fread_at (bin->b, bin->dysymtab.modtaboff,",
          "345:    (ut8*)bin->modtab, bin->big_endian?\"12IL\":\"12il\", bin->nmodtab);",
          "347:   len = r_buf_fread_at (bin->b, bin->dysymtab.modtaboff,",
          "348:    (ut8*)bin->modtab, bin->big_endian?\"13I\":\"13i\", bin->nmodtab);",
          "350:   if (len == -1) {",
          "351:    eprintf (\"Error: read (modtab)\\n\");",
          "352:    R_FREE (bin->modtab);",
          "353:    return false;",
          "",
          "[Added Lines]",
          "469:   for (i = 0; i < bin->nmodtab; i++) {",
          "470:    len = r_buf_read_at(bin->b, bin->dysymtab.modtaboff +",
          "471:     i * sizeof (struct MACH0_(dylib_module)),",
          "472:     dymod, sizeof (struct MACH0_(dylib_module)));",
          "473:    if (len == -1) {",
          "474:     eprintf (\"Error: read (modtab)\\n\");",
          "475:     R_FREE (bin->modtab);",
          "476:     return false;",
          "477:    }",
          "479:    bin->modtab[i].module_name = r_read_ble32 (&dymod[0], bin->big_endian);",
          "480:    bin->modtab[i].iextdefsym = r_read_ble32 (&dymod[4], bin->big_endian);",
          "481:    bin->modtab[i].nextdefsym = r_read_ble32 (&dymod[8], bin->big_endian);",
          "482:    bin->modtab[i].irefsym = r_read_ble32 (&dymod[12], bin->big_endian);",
          "483:    bin->modtab[i].nrefsym = r_read_ble32 (&dymod[16], bin->big_endian);",
          "484:    bin->modtab[i].ilocalsym = r_read_ble32 (&dymod[20], bin->big_endian);",
          "485:    bin->modtab[i].nlocalsym = r_read_ble32 (&dymod[24], bin->big_endian);",
          "486:    bin->modtab[i].iextrel = r_read_ble32 (&dymod[28], bin->big_endian);",
          "487:    bin->modtab[i].nextrel = r_read_ble32 (&dymod[32], bin->big_endian);",
          "488:    bin->modtab[i].iinit_iterm = r_read_ble32 (&dymod[36], bin->big_endian);",
          "489:    bin->modtab[i].ninit_nterm = r_read_ble32 (&dymod[40], bin->big_endian);",
          "491:    bin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[44], bin->big_endian);",
          "492:    bin->modtab[i].objc_module_info_addr = r_read_ble64 (&dymod[48], bin->big_endian);",
          "494:    bin->modtab[i].objc_module_info_addr = r_read_ble32 (&dymod[44], bin->big_endian);",
          "495:    bin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[48], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "373:    return false;",
          "374:   }",
          "382:   }",
          "383:  }",
          "",
          "[Removed Lines]",
          "376:   len = r_buf_fread_at (bin->b, bin->dysymtab.indirectsymoff,",
          "377:     (ut8*)bin->indirectsyms, bin->big_endian?\"I\":\"i\", bin->nindirectsyms);",
          "378:   if (len == -1) {",
          "379:    eprintf (\"Error: read (indirect syms)\\n\");",
          "380:    R_FREE (bin->indirectsyms);",
          "381:    return false;",
          "",
          "[Added Lines]",
          "519:   for (i = 0; i < bin->nindirectsyms; i++) {",
          "520:    len = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);",
          "521:    if (len == -1) {",
          "522:     eprintf (\"Error: read (indirect syms)\\n\");",
          "523:     R_FREE (bin->indirectsyms);",
          "524:     return false;",
          "525:    }",
          "526:    bin->indirectsyms[i] = r_read_ble32 (&idsyms[0], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "388: static bool parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {",
          "389:  int i, len;",
          "391:  bin->signature = NULL;",
          "392:  struct linkedit_data_command link = {};",
          "393:  if (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {",
          "394:   return false;",
          "395:  }",
          "398:   eprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");",
          "399:   return false;",
          "400:  }",
          "401:  data = link.dataoff;",
          "402:  if (data > bin->size || data + sizeof (struct super_blob_t) > bin->size) {",
          "403:   bin->signature = (ut8 *)strdup (\"Malformed entitlement\");",
          "404:   return true;",
          "405:  }",
          "411:    break;",
          "412:   }",
          "416:    if (begin > bin->size || begin + sizeof (struct blob_t) > bin->size) {",
          "417:     bin->signature = (ut8 *)strdup (\"Malformed entitlement\");",
          "418:     break;",
          "419:    }",
          "422:    if (len <= bin->size && len > 1) {",
          "423:     bin->signature = calloc (1, len + 1);",
          "424:     if (bin->signature) {",
          "426:      bin->signature[len] = '\\0';",
          "427:      return true;",
          "428:     }",
          "",
          "[Removed Lines]",
          "390:  ut32 count, data;",
          "396:  len = r_buf_fread_at (bin->b, off, (ut8*)&link, bin->big_endian ? \"4I\" : \"4i\", 1);",
          "397:  if (len < 1) {",
          "406:  struct super_blob_t *super = (struct super_blob_t *) (bin->b->buf + data);",
          "407:  count = r_read_ble32 (&super->count, little_);",
          "408:  for (i = 0; i < count; ++i) {",
          "409:   if ((ut8 *)(super->index + i + 1) > (ut8 *)(bin->b->buf + bin->size)) {",
          "410:    bin->signature = (ut8 *)strdup (\"Malformed entitlement\");",
          "414:   if (r_read_ble32 (&super->index[i].type, little_) == CSSLOT_ENTITLEMENTS) {",
          "415:    ut32 begin = r_read_ble32 (&super->index[i].offset, little_);",
          "420:    struct blob_t *entitlements = (struct blob_t *) ((ut8*)super + begin);",
          "421:    len = r_read_ble32 (&entitlements->length, little_) - sizeof(struct blob_t);",
          "425:      memcpy (bin->signature, entitlements + 1, len);",
          "",
          "[Added Lines]",
          "535:  ut32 data;",
          "538:  ut8 lit[sizeof (struct linkedit_data_command)] = {0};",
          "539:  struct blob_index_t idx = {};",
          "540:  struct super_blob_t super = {};",
          "545:  len = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));",
          "546:  if (len != sizeof (struct linkedit_data_command)) {",
          "550:  link.cmd = r_read_ble32 (&lit[0], bin->big_endian);",
          "551:  link.cmdsize = r_read_ble32 (&lit[4], bin->big_endian);",
          "552:  link.dataoff = r_read_ble32 (&lit[8], bin->big_endian);",
          "553:  link.datasize = r_read_ble32 (&lit[12], bin->big_endian);",
          "560:  super.blob.magic = r_read_ble32 (bin->b->buf + data, bin->big_endian);",
          "561:  super.blob.length = r_read_ble32 (bin->b->buf + data + 4, bin->big_endian);",
          "562:  super.count = r_read_ble32 (bin->b->buf + data + 8, bin->big_endian);",
          "563:  for (i = 0; i < super.count; ++i) {",
          "564:   if ((ut8 *)(bin->b->buf + data + i) > (ut8 *)(bin->b->buf + bin->size)) {",
          "567:   struct blob_index_t *bi = (struct blob_index_t *)(bin->b->buf + data + 12);",
          "568:   idx.type = r_read_ble32 (&bi[i].type, bin->big_endian);",
          "569:   idx.offset = r_read_ble32 (&bi[i].offset, bin->big_endian);",
          "570:   if (idx.type == CSSLOT_ENTITLEMENTS) {",
          "571:    ut32 begin = idx.offset;",
          "576:    len = r_read_ble32 (bin->b->buf + data + begin + 4, bin->big_endian) - sizeof (struct blob_t);",
          "580:      memcpy (bin->signature, bin->b->buf + data + begin, len);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "443:  ut32 flavor, count;",
          "444:  ut8 *arw_ptr = NULL;",
          "445:  int arw_sz, len = 0;",
          "447:  if (off > bin->size || off + sizeof (struct thread_command) > bin->size)",
          "448:   return false;",
          "452:  if (len < 1)",
          "453:   goto wrong_read;",
          "457:  if (len == -1)",
          "458:   goto wrong_read;",
          "",
          "[Removed Lines]",
          "450:  len = r_buf_fread_at (bin->b, off, (ut8*)&bin->thread,",
          "451:   bin->big_endian?\"2I\":\"2i\", 1);",
          "455:  len = r_buf_fread_at(bin->b, off + sizeof(struct thread_command),",
          "456:   (ut8*)&flavor, bin->big_endian?\"1I\":\"1i\", 1);",
          "",
          "[Added Lines]",
          "601:  ut8 thc[sizeof (struct thread_command)] = {0};",
          "606:  len = r_buf_read_at (bin->b, off, thc, 8);",
          "609:  bin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);",
          "610:  bin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);",
          "611:  flavor = r_read_ble32 (bin->b->buf + off + sizeof(struct thread_command), bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "462:   return false;",
          "470:  ptr_thread = off + sizeof(struct thread_command) + sizeof(flavor) + sizeof(count);",
          "472:  if (ptr_thread > bin->size)",
          "",
          "[Removed Lines]",
          "465:  len = r_buf_fread_at(bin->b, off + sizeof(struct thread_command) + sizeof(flavor),",
          "466:   (ut8*)&count, bin->big_endian?\"1I\":\"1i\", 1);",
          "467:  if (len == -1)",
          "468:   goto wrong_read;",
          "",
          "[Added Lines]",
          "620:  count = r_read_ble32 (bin->b->buf + off + sizeof(struct thread_command) + sizeof(flavor),",
          "621:     bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "593: static int parse_function_starts (struct MACH0_(obj_t)* bin, ut64 off) {",
          "594:  struct linkedit_data_command fc;",
          "595:  ut8 *buf;",
          "596:  int len;",
          "597:  if (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {",
          "598:   eprintf (\"Likely overflow while parsing\"",
          "599:    \" LC_FUNCTION_STARTS command\\n\");",
          "600:  }",
          "601:  bin->func_start = NULL;",
          "603:  if (len < 1) {",
          "604:   eprintf (\"Failed to get data while parsing\"",
          "605:    \" LC_FUNCTION_STARTS command\\n\");",
          "606:  }",
          "607:  buf = calloc (1, fc.datasize + 1);",
          "608:  if (!buf) {",
          "609:   eprintf (\"Failed to allocate buffer\\n\");",
          "",
          "[Removed Lines]",
          "602:  len = r_buf_fread_at (bin->b, off, (ut8*)&fc, bin->big_endian ? \"4I\" : \"4i\", 1);",
          "",
          "[Added Lines]",
          "747:  ut8 sfc[sizeof (struct linkedit_data_command)] = {0};",
          "756:  len = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));",
          "761:  fc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);",
          "762:  fc.cmdsize = r_read_ble32 (&sfc[4], bin->big_endian);",
          "763:  fc.dataoff = r_read_ble32 (&sfc[8], bin->big_endian);",
          "764:  fc.datasize = r_read_ble32 (&sfc[12], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "631: static int parse_dylib(struct MACH0_(obj_t)* bin, ut64 off) {",
          "632:  struct dylib_command dl;",
          "633:  int lib, len;",
          "635:  if (off > bin->size || off + sizeof (struct dylib_command) > bin->size)",
          "636:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "793:  ut8 sdl[sizeof (struct dylib_command)] = {0};",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "640:   perror (\"realloc (libs)\");",
          "641:   return false;",
          "642:  }",
          "644:  if (len < 1) {",
          "645:   eprintf (\"Error: read (dylib)\\n\");",
          "646:   return false;",
          "647:  }",
          "649:  if (off + dl.dylib.name.offset > bin->size ||\\",
          "650:    off + dl.dylib.name.offset + R_BIN_MACH0_STRING_LENGTH > bin->size)",
          "",
          "[Removed Lines]",
          "643:  len = r_buf_fread_at (bin->b, off, (ut8*)&dl, bin->big_endian?\"6I\":\"6i\", 1);",
          "",
          "[Added Lines]",
          "803:  len = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));",
          "808:  dl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);",
          "809:  dl.cmdsize = r_read_ble32 (&sdl[4], bin->big_endian);",
          "810:  dl.dylib.name.offset = r_read_ble32 (&sdl[8], bin->big_endian);",
          "811:  dl.dylib.timestamp = r_read_ble32 (&sdl[12], bin->big_endian);",
          "812:  dl.dylib.current_version = r_read_ble32 (&sdl[16], bin->big_endian);",
          "813:  dl.dylib.compatibility_version = r_read_ble32 (&sdl[20], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "661: static int init_items(struct MACH0_(obj_t)* bin) {",
          "662:  struct load_command lc = {0, 0};",
          "663:  bool is_first_thread = true;",
          "664:  ut64 off = 0LL;",
          "665:  int i, len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "829:  ut8 loadc[sizeof (struct load_command)] = {0};",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "679:    eprintf (\"mach0: out of bounds command\\n\");",
          "680:    return false;",
          "681:   }",
          "683:   if (len < 1) {",
          "684:    eprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);",
          "685:    return false;",
          "686:   }",
          "687:   if (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {",
          "688:    eprintf (\"Warning: mach0_header %d = cmdsize<1.\\n\", i);",
          "689:    break;",
          "",
          "[Removed Lines]",
          "682:   len = r_buf_fread_at (bin->b, off, (ut8*)&lc, bin->big_endian?\"2I\":\"2i\", 1);",
          "",
          "[Added Lines]",
          "849:   len = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));",
          "854:   lc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);",
          "855:   lc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "775:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"encryption_info\", 0);",
          "776:    {",
          "777:    struct MACH0_(encryption_info_command) eic = {0};",
          "778:    if (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {",
          "779:     eprintf (\"encryption info out of bounds\\n\");",
          "780:     return false;",
          "781:    }",
          "783:     bin->has_crypto = eic.cryptid;",
          "784:     sdb_set (bin->kv, \"crypto\", \"true\", 0);",
          "785:     sdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);",
          "",
          "[Removed Lines]",
          "782:    if (r_buf_fread_at (bin->b, off, (ut8*)&eic, bin->big_endian?\"5I\":\"5i\", 1) != -1) {",
          "",
          "[Added Lines]",
          "948:    ut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};",
          "953:    if (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {",
          "954:     eic.cmd = r_read_ble32 (&seic[0], bin->big_endian);",
          "955:     eic.cmdsize = r_read_ble32 (&seic[4], bin->big_endian);",
          "956:     eic.cryptoff = r_read_ble32 (&seic[8], bin->big_endian);",
          "957:     eic.cryptsize = r_read_ble32 (&seic[12], bin->big_endian);",
          "958:     eic.cryptid = r_read_ble32 (&seic[16], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "795:     bin->intrp = NULL;",
          "797:     struct dylinker_command dy = {0};",
          "798:     if (off + sizeof (struct dylinker_command) > bin->size){",
          "799:      eprintf (\"Warning: Cannot parse dylinker command\\n\");",
          "800:      return false;",
          "801:     }",
          "804:      eprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
          "805:     } else {",
          "806:      int len = dy.cmdsize;",
          "807:      char *buf = malloc (len+1);",
          "808:      if (buf) {",
          "809:       r_buf_read_at (bin->b, off + 0xc, (ut8*)buf, len);",
          "810:       buf[len] = 0;",
          "811:       free (bin->intrp);",
          "",
          "[Removed Lines]",
          "802:     if (r_buf_fread_at (bin->b, off, (ut8*)&dy,",
          "803:        bin->big_endian?\"3I\":\"3i\", 1) == -1) {",
          "",
          "[Added Lines]",
          "975:     ut8 sdy[sizeof (struct dylinker_command)] = {0};",
          "980:     if (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {",
          "983:      dy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);",
          "984:      dy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);",
          "985:      dy.name.offset = r_read_ble32 (&sdy[8], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "820:     ut64 eo;",
          "821:     ut64 ss;",
          "822:    } ep = {0};",
          "823:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"main\", 0);",
          "825:    if (!is_first_thread) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1005:    ut8 sep[2 * sizeof (ut64)] = {0};",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "830:     eprintf (\"invalid command size for main\\n\");",
          "831:     return false;",
          "832:    }",
          "835:    bin->entry = ep.eo;",
          "836:    bin->main_cmd = lc;",
          "",
          "[Removed Lines]",
          "833:    r_buf_fread_at (bin->b, off+8, (void*)&ep,",
          "834:     bin->big_endian?\"2L\": \"2l\", 1);",
          "",
          "[Added Lines]",
          "1016:    r_buf_read_at (bin->b, off+8, sep, 2 * sizeof (ut64));",
          "1017:    ep.eo = r_read_ble64 (&sep[0], bin->big_endian);",
          "1018:    ep.ss = r_read_ble64 (&sep[8], bin->big_endian);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "866:    break;",
          "867:   case LC_DYLD_INFO:",
          "868:   case LC_DYLD_INFO_ONLY:",
          "869:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);",
          "870:    bin->dyld_info = malloc (sizeof(struct dyld_info_command));",
          "871:    if (off + sizeof (struct dyld_info_command) > bin->size){",
          "872:     eprintf (\"Cannot parse dyldinfo\\n\");",
          "873:     free (bin->dyld_info);",
          "874:     return false;",
          "875:    }",
          "877:     free (bin->dyld_info);",
          "878:     bin->dyld_info = NULL;",
          "879:     eprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
          "880:    }",
          "881:    break;",
          "882:   case LC_CODE_SIGNATURE:",
          "",
          "[Removed Lines]",
          "876:    if (r_buf_fread_at (bin->b, off, (ut8*)bin->dyld_info, bin->big_endian?\"12I\":\"12i\", 1) == -1) {",
          "",
          "[Added Lines]",
          "1054:    {",
          "1055:    ut8 dyldi[sizeof (struct dyld_info_command)] = {0};",
          "1064:    if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {",
          "1068:    } else {",
          "1069:     bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);",
          "1070:     bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);",
          "1071:     bin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);",
          "1072:     bin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);",
          "1073:     bin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);",
          "1074:     bin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);",
          "1075:     bin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);",
          "1076:     bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);",
          "1077:     bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);",
          "1078:     bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);",
          "1079:     bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);",
          "1080:     bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);",
          "1081:    }",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "914: }",
          "916: static int init(struct MACH0_(obj_t)* bin) {",
          "922:  if (!init_hdr(bin)) {",
          "923:   eprintf (\"Warning: File is not MACH0\\n\");",
          "924:   return false;",
          "",
          "[Removed Lines]",
          "917:  union {",
          "918:   ut16 word;",
          "919:   ut8 byte[2];",
          "920:  } endian = { 1 };",
          "921:  little_ = endian.byte[0];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2003: }",
          "2005: struct MACH0_(mach_header) * MACH0_(get_hdr_from_bytes)(RBuffer *buf) {",
          "2007:  int len;",
          "2008:  struct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));",
          "2011:  if (!macho_hdr) {",
          "2012:   return NULL;",
          "2013:  }",
          "2015:   eprintf (\"Error: read (magic)\\n\");",
          "2016:   free (macho_hdr);",
          "2017:   return false;",
          "2018:  }",
          "2020:   big_endian = false;",
          "2022:   big_endian = true;",
          "2024:   big_endian = true;",
          "2026:   big_endian = false;",
          "2027:  } else {",
          "2029: #if 0",
          "",
          "[Removed Lines]",
          "2006:  ut32 magic = 0;",
          "2009:  bool big_endian = false;",
          "2014:  if (r_buf_read_at (buf, 0, (ut8*)&magic, 4) < 1) {",
          "2019:  if (magic == MACH0_(MH_MAGIC)) {",
          "2021:  } else if (magic == MACH0_(MH_CIGAM)) {",
          "2023:  } else if (magic == FAT_CIGAM) {",
          "2025:  } else if (magic == 0xfeedfacf) {",
          "",
          "[Added Lines]",
          "2203:  ut8 magicbytes[sizeof (ut32)] = {0};",
          "2204:  ut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};",
          "2207:  bool big_endian;",
          "2211:  if (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {",
          "2217:  if (r_read_le32(magicbytes) == 0xfeedface) {",
          "2219:  } else if (r_read_be32(magicbytes) == 0xfeedface) {",
          "2221:  } else if (r_read_le32(magicbytes) == FAT_MAGIC) {",
          "2222:   big_endian = false;",
          "2223:  } else if (r_read_be32(magicbytes) == FAT_MAGIC) {",
          "2225:  } else if (r_read_le32(magicbytes) == 0xfeedfacf) {",
          "2227:  } else if (r_read_be32(magicbytes) == 0xfeedfacf) {",
          "2228:   big_endian = true;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2031:   return NULL;",
          "2032: #endif",
          "2033:  }",
          "2041:  if (len != sizeof(struct MACH0_(mach_header))) {",
          "2042:   free (macho_hdr);",
          "2043:   return NULL;",
          "2044:  }",
          "2045:  return macho_hdr;",
          "2046: }",
          "",
          "[Removed Lines]",
          "2034:  len = r_buf_fread_at (buf, 0, (ut8*)macho_hdr,",
          "2035: #if R_BIN_MACH064",
          "2036:   big_endian?\"8I\":\"8i\", 1",
          "2037: #else",
          "2038:   big_endian?\"7I\":\"7i\", 1",
          "2039: #endif",
          "2040:  );",
          "",
          "[Added Lines]",
          "2236:  len = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));",
          "2241:  macho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);",
          "2242:  macho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);",
          "2243:  macho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);",
          "2244:  macho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);",
          "2245:  macho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);",
          "2246:  macho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);",
          "2247:  macho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);",
          "2248: #if R_BIN_MACH064",
          "2249:  macho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);",
          "2250: #endif",
          "",
          "---------------"
        ],
        "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c": [
          "File: libr/bin/format/objc/mach0_classes.c -> libr/bin/format/objc/mach0_classes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: static mach0_ut get_pointer(mach0_ut p, ut32 *offset, ut32 *left, RBinFile *arch);",
          "87: static void copy_sym_name_with_namespace(char *class_name, char *read_name, RBinSymbol *sym);",
          "89: static void get_ivar_list_t(mach0_ut p, RBinFile *arch, RBinClass *klass);",
          "91: static void get_objc_property_list(mach0_ut p, RBinFile *arch, RBinClass *klass);",
          "93: static void get_method_list_t(mach0_ut p, RBinFile *arch, char *class_name, RBinClass *klass, bool is_static);",
          "95: static void get_protocol_list_t(mach0_ut p, RBinFile *arch, RBinClass *klass);",
          "97: static void get_class_ro_t(mach0_ut p, RBinFile *arch, ut32 *is_meta_class, RBinClass *klass);",
          "99: static void get_class_t(mach0_ut p, RBinFile *arch, RBinClass *klass);",
          "101: static void __r_bin_class_free(RBinClass *p);",
          "103: static int is_thumb(RBinFile *arch) {",
          "104:  struct MACH0_(obj_t) *bin = (struct MACH0_(obj_t) *)arch->o->bin_obj;",
          "105:  if (bin->hdr.cputype == 12) {",
          "107:    return 1;",
          "108:  }",
          "109:  return 0;",
          "110: }",
          "",
          "[Removed Lines]",
          "106:   if (bin->hdr.cpusubtype == 9)",
          "",
          "[Added Lines]",
          "98:   if (bin->hdr.cpusubtype == 9) {",
          "100:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:  addr = p;",
          "131:  r_list_foreach (sctns, iter, s) {",
          "132:   if (addr >= s->vaddr && addr < s->vaddr + s->vsize) {",
          "135:    r = (s->paddr + (addr - s->vaddr));",
          "136: #if 0",
          "137:    r_list_free (sctns);",
          "",
          "[Removed Lines]",
          "133:    if (offset) *offset = addr - s->vaddr;",
          "134:    if (left) *left = s->vsize - (addr - s->vaddr);",
          "",
          "[Added Lines]",
          "126:    if (offset) {",
          "128:    }",
          "129:    if (left) {",
          "131:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "141:   }",
          "142:  }",
          "147: #if 0",
          "148:  r_list_free (sctns);",
          "",
          "[Removed Lines]",
          "144:  if (offset) *offset = 0;",
          "145:  if (left) *left = 0;",
          "",
          "[Added Lines]",
          "141:  if (offset) {",
          "143:  }",
          "144:  if (left) {",
          "146:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156: static void copy_sym_name_with_namespace(char *class_name, char *read_name, RBinSymbol *sym) {",
          "158:  sym->classname = strdup (class_name);",
          "159:  sym->name = strdup (read_name);",
          "160: }",
          "",
          "[Removed Lines]",
          "157:  if (!class_name) class_name = \"\";",
          "",
          "[Added Lines]",
          "158:  if (!class_name) {",
          "159:   class_name = \"\";",
          "160:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "167:  ut32 offset, left, j;",
          "168:  char *name;",
          "169:  int len;",
          "170:  mach0_ut ivar_offset_p, ivar_offset;",
          "171:  RBinField *field = NULL;",
          "173:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "174:   eprintf (\"uncorrect RBinFile pointer\\n\");",
          "175:   return;",
          "176:  }",
          "179:   return;",
          "181:  memset (&il, '\\0', sizeof (struct MACH0_(SIVarList)));",
          "187:  if (left < sizeof (struct MACH0_(SIVarList))) {",
          "189:  } else {",
          "192:  }",
          "196:  p += sizeof (struct MACH0_(SIVarList));",
          "197:  offset += sizeof (struct MACH0_(SIVarList));",
          "198:  for (j = 0; j < il.count; j++) {",
          "199:   r = get_pointer (p, &offset, &left, arch);",
          "201:   if (!(field = R_NEW0 (RBinField))) {",
          "204:    return;",
          "205:   }",
          "206:   memset (&i, '\\0', sizeof (struct MACH0_(SIVar)));",
          "212:   if (left < sizeof (struct MACH0_(SIVar))) {",
          "214:   } else {",
          "217:   }",
          "219:   ivar_offset_p = get_pointer (i.offset, NULL, &left, arch);",
          "224:   if (ivar_offset_p != 0 && left >= sizeof (mach0_ut)) {",
          "229:     eprintf (\"Error reading\\n\");",
          "230:     goto error;",
          "231:    }",
          "232:    field->vaddr = ivar_offset;",
          "233:   }",
          "",
          "[Removed Lines]",
          "178:  if (!(r = get_pointer (p, &offset, &left, arch)))",
          "183:  if (r + left < r || r + sizeof (struct MACH0_(SIVarList)) < r) return;",
          "184:  if (r > arch->size || r + left > arch->size) return;",
          "185:  if (r + sizeof (struct MACH0_(SIVarList)) > arch->size) return;",
          "188:   len = r_buf_read_at (arch->buf, r, (ut8 *)&il, left);",
          "190:   len = r_buf_read_at (arch->buf, r, (ut8 *)&il,",
          "191:     sizeof (struct MACH0_(SIVarList)));",
          "194:  if (len < 1) return;",
          "200:   if (r == 0) return;",
          "208:   if (r + left < r || r + sizeof (struct MACH0_(SIVar)) < r) goto error;",
          "209:   if (r > arch->size || r + left > arch->size) goto error;",
          "210:   if (r + sizeof (struct MACH0_(SIVar)) > arch->size) goto error;",
          "213:    len = r_buf_read_at (arch->buf, r, (ut8 *)&i, left);",
          "215:    len = r_buf_read_at (arch->buf, r, (ut8 *)&i,",
          "216:      sizeof (struct MACH0_(SIVar)));",
          "218:   if (len < 1) goto error;",
          "221:   if (ivar_offset_p > arch->size) goto error;",
          "222:   if (ivar_offset_p + sizeof (ivar_offset) > arch->size) goto error;",
          "225:    len = r_buf_read_at (arch->buf, ivar_offset_p,",
          "226:      (ut8 *)&ivar_offset,",
          "227:      sizeof (ivar_offset));",
          "228:    if (len < 1) {",
          "",
          "[Added Lines]",
          "173:  bool bigendian = arch->o->info->big_endian;",
          "176:  ut8 sivarlist[sizeof (struct MACH0_(SIVarList))] = {0};",
          "177:  ut8 sivar[sizeof (struct MACH0_(SIVar))] = {0};",
          "178:  ut8 offs[sizeof (mach0_ut)] = {0};",
          "185:  if (!(r = get_pointer (p, &offset, &left, arch))) {",
          "187:  }",
          "189:  if (r + left < r || r + sizeof (struct MACH0_(SIVarList)) < r) {",
          "190:   return;",
          "191:  }",
          "192:  if (r > arch->size || r + left > arch->size) {",
          "193:   return;",
          "194:  }",
          "195:  if (r + sizeof (struct MACH0_(SIVarList)) > arch->size) {",
          "196:   return;",
          "197:  }",
          "199:   if (r_buf_read_at (arch->buf, r, sivarlist, left) != left) {",
          "200:    return;",
          "201:   }",
          "203:   len = r_buf_read_at (arch->buf, r, sivarlist, sizeof (struct MACH0_(SIVarList)));",
          "204:   if (len != sizeof (struct MACH0_(SIVarList))) {",
          "205:    return;",
          "206:   }",
          "208:  il.entsize = r_read_ble (&sivarlist[0], bigendian, 32);",
          "209:  il.count = r_read_ble (&sivarlist[4], bigendian, 32);",
          "214:   if (!r) {",
          "215:    return;",
          "216:   }",
          "223:   if (r + left < r || r + sizeof (struct MACH0_(SIVar)) < r) {",
          "224:    goto error;",
          "225:   }",
          "226:   if (r > arch->size || r + left > arch->size) {",
          "227:    goto error;",
          "228:   }",
          "229:   if (r + sizeof (struct MACH0_(SIVar)) > arch->size) {",
          "230:    goto error;",
          "231:   }",
          "233:    if (r_buf_read_at (arch->buf, r, sivar, left) != left) {",
          "234:     goto error;",
          "235:    }",
          "237:    len = r_buf_read_at (arch->buf, r, sivar, sizeof (struct MACH0_(SIVar)));",
          "238:    if (len != sizeof (struct MACH0_(SIVar))) {",
          "239:     goto error;",
          "240:    }",
          "241:   }",
          "242:   switch (sizeof (mach0_ut)) {",
          "243:   case 4:",
          "244:    i.offset = r_read_ble (&sivar[0], bigendian, 32);",
          "245:    i.name = r_read_ble (&sivar[4], bigendian, 32);",
          "246:    i.type = r_read_ble (&sivar[8], bigendian, 32);",
          "247:    i.alignment = r_read_ble (&sivar[12], bigendian, 32);",
          "248:    i.size = r_read_ble (&sivar[16], bigendian, 32);",
          "249:    break;",
          "250:   case 8:",
          "251:    i.offset = r_read_ble (&sivar[0], bigendian, 64);",
          "252:    i.name = r_read_ble (&sivar[8], bigendian, 64);",
          "253:    i.type = r_read_ble (&sivar[16], bigendian, 64);",
          "254:    i.alignment = r_read_ble (&sivar[24], bigendian, 32);",
          "255:    i.size = r_read_ble (&sivar[28], bigendian, 32);",
          "256:    break;",
          "260:   if (ivar_offset_p > arch->size) {",
          "261:    goto error;",
          "262:   }",
          "263:   if (ivar_offset_p + sizeof (ivar_offset) > arch->size) {",
          "264:    goto error;",
          "265:   }",
          "267:    len = r_buf_read_at (arch->buf, ivar_offset_p, offs, sizeof (mach0_ut));",
          "268:    if (len != sizeof (mach0_ut)) {",
          "272:    ivar_offset = r_read_ble (offs, bigendian, 8 * sizeof (mach0_ut));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "291:  ut32 offset, left, j;",
          "292:  char *name;",
          "293:  int len;",
          "294:  RBinField *property = NULL;",
          "296:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "297:   eprintf (\"uncorrect RBinFile pointer\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "335:  bool bigendian = arch->o->info->big_endian;",
          "337:  ut8 sopl[sizeof (struct MACH0_(SObjcPropertyList))] = {0};",
          "338:  ut8 sop[sizeof (struct MACH0_(SObjcProperty))] = {0};",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "299:  }",
          "301:  r = get_pointer (p, &offset, &left, arch);",
          "304:  memset (&opl, '\\0', sizeof (struct MACH0_(SObjcPropertyList)));",
          "310:  if (left < sizeof (struct MACH0_(SObjcPropertyList))) {",
          "312:  } else {",
          "315:  }",
          "318:  p += sizeof (struct MACH0_(SObjcPropertyList));",
          "319:  offset += sizeof (struct MACH0_(SObjcPropertyList));",
          "320:  for (j = 0; j < opl.count; j++) {",
          "321:   r = get_pointer (p, &offset, &left, arch);",
          "323:    return;",
          "325:   if (!(property = R_NEW0 (RBinField))) {",
          "",
          "[Removed Lines]",
          "302:  if (r == 0) return;",
          "306:  if (r + left < r || r + sizeof (struct MACH0_(SObjcPropertyList)) < r) return;",
          "307:  if (r > arch->size || r + left > arch->size) return;",
          "308:  if (r + sizeof (struct MACH0_(SObjcPropertyList)) > arch->size) return;",
          "311:   len = r_buf_read_at (arch->buf, r, (ut8 *)&opl, left);",
          "313:   len = r_buf_read_at (arch->buf, r, (ut8 *)&opl,",
          "314:     sizeof (struct MACH0_(SObjcPropertyList)));",
          "316:  if (len < 1) return;",
          "322:   if (r == 0)",
          "",
          "[Added Lines]",
          "346:  if (!r) {",
          "347:   return;",
          "348:  }",
          "350:  if (r + left < r || r + sizeof (struct MACH0_(SObjcPropertyList)) < r) {",
          "351:   return;",
          "352:  }",
          "353:  if (r > arch->size || r + left > arch->size) {",
          "354:   return;",
          "355:  }",
          "356:  if (r + sizeof (struct MACH0_(SObjcPropertyList)) > arch->size) {",
          "357:   return;",
          "358:  }",
          "360:   if (r_buf_read_at (arch->buf, r, sopl, left) != left) {",
          "361:    return;",
          "362:   }",
          "364:   len = r_buf_read_at (arch->buf, r, sopl, sizeof (struct MACH0_(SObjcPropertyList)));",
          "365:   if (len != sizeof (struct MACH0_(SObjcPropertyList))) {",
          "366:    return;",
          "367:   }",
          "370:  opl.entsize = r_read_ble (&sopl[0], bigendian, 32);",
          "371:  opl.count = r_read_ble (&sopl[4], bigendian, 32);",
          "377:   if (!r) {",
          "379:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "331:   memset (&op, '\\0', sizeof (struct MACH0_(SObjcProperty)));",
          "337:   if (left < sizeof (struct MACH0_(SObjcProperty))) {",
          "339:   } else {",
          "342:   }",
          "345:   r = get_pointer (op.name, NULL, &left, arch);",
          "346:   if (r) {",
          "347:    struct MACH0_(obj_t) *bin = (struct MACH0_(obj_t) *)arch->o->bin_obj;",
          "351:    if (bin->has_crypto) {",
          "352:     name = strdup (\"some_encrypted_data\");",
          "353:     left = strlen (name) + 1;",
          "354:    } else {",
          "355:     name = calloc (1, left + 1);",
          "359:    }",
          "360:    property->name = r_str_newf (\"%s::%s%s\", klass->name,",
          "361:       \"(property)\", name);",
          "",
          "[Removed Lines]",
          "333:   if (r + left < r || r + sizeof (struct MACH0_(SObjcProperty)) < r) goto error;",
          "334:   if (r > arch->size || r + left > arch->size) goto error;",
          "335:   if (r + sizeof (struct MACH0_(SObjcProperty)) > arch->size) goto error;",
          "338:    len = r_buf_read_at (arch->buf, r, (ut8 *)&op, left);",
          "340:    len = r_buf_read_at (arch->buf, r, (ut8 *)&op,",
          "341:      sizeof (struct MACH0_(SObjcProperty)));",
          "343:   if (len < 1) goto error;",
          "348:    if (r > arch->size || r + left > arch->size) goto error;",
          "349:    if (r + left < r) goto error;",
          "356:     if (!name) goto error;",
          "357:     len = r_buf_read_at (arch->buf, r, (ut8 *)name, left);",
          "358:     if (len < 1) goto error;",
          "",
          "[Added Lines]",
          "389:   if (r + left < r || r + sizeof (struct MACH0_(SObjcProperty)) < r) {",
          "390:    goto error;",
          "391:   }",
          "392:   if (r > arch->size || r + left > arch->size) {",
          "393:    goto error;",
          "394:   }",
          "395:   if (r + sizeof (struct MACH0_(SObjcProperty)) > arch->size) {",
          "396:    goto error;",
          "397:   }",
          "400:    if (r_buf_read_at (arch->buf, r, sop, left) != left) {",
          "401:     goto error;",
          "402:    }",
          "404:    len = r_buf_read_at (arch->buf, r, sop, sizeof (struct MACH0_(SObjcProperty)));",
          "405:    if (len != sizeof (struct MACH0_(SObjcProperty))) {",
          "406:     goto error;",
          "407:    }",
          "409:   op.name = r_read_ble (&sop[0], bigendian, 8 * sizeof (mach0_ut));",
          "410:   op.attributes = r_read_ble (&sop[sizeof (mach0_ut)], bigendian, 8 * sizeof (mach0_ut));",
          "414:    if (r > arch->size || r + left > arch->size) {",
          "415:     goto error;",
          "416:    }",
          "417:    if (r + left < r) {",
          "418:     goto error;",
          "419:    }",
          "425:     if (!name) {",
          "426:      goto error;",
          "427:     }",
          "428:     if (r_buf_read_at (arch->buf, r, (ut8 *)name, left) != left) {",
          "429:      goto error;",
          "430:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "401:  ut32 offset, left, i;",
          "402:  char *name = NULL;",
          "403:  int len;",
          "405:  RBinSymbol *method = NULL;",
          "407:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "408:   eprintf (\"incorrect RBinFile pointer\\n\");",
          "409:   return;",
          "410:  }",
          "412:  r = get_pointer (p, &offset, &left, arch);",
          "414:   return;",
          "415:  }",
          "416:  memset (&ml, '\\0', sizeof (struct MACH0_(SMethodList)));",
          "422:  if (left < sizeof (struct MACH0_(SMethodList))) {",
          "424:  } else {",
          "427:  }",
          "430:  p += sizeof (struct MACH0_(SMethodList));",
          "431:  offset += sizeof (struct MACH0_(SMethodList));",
          "432:  for (i = 0; i < ml.count; i++) {",
          "433:   r = get_pointer (p, &offset, &left, arch);",
          "435:    return;",
          "436:   }",
          "",
          "[Removed Lines]",
          "413:  if (r == 0) {",
          "418:  if (r + left < r || r + sizeof (struct MACH0_(SMethodList)) < r) return;",
          "419:  if (r > arch->size || r + left > arch->size) return;",
          "420:  if (r + sizeof (struct MACH0_(SMethodList)) > arch->size) return;",
          "423:   len = r_buf_read_at (arch->buf, r, (ut8 *)&ml, left);",
          "425:   len = r_buf_read_at (arch->buf, r, (ut8 *)&ml,",
          "426:     sizeof (struct MACH0_(SMethodList)));",
          "428:  if (len < 1) return;",
          "434:   if (r == 0) {",
          "",
          "[Added Lines]",
          "476:  bool bigendian = arch->o->info->big_endian;",
          "477:  ut8 sml[sizeof (struct MACH0_(SMethodList))] = {0};",
          "478:  ut8 sm[sizeof (struct MACH0_(SMethod))] = {0};",
          "487:  if (!r) {",
          "492:  if (r + left < r || r + sizeof (struct MACH0_(SMethodList)) < r) {",
          "493:   return;",
          "494:  }",
          "495:  if (r > arch->size || r + left > arch->size) {",
          "496:   return;",
          "497:  }",
          "498:  if (r + sizeof (struct MACH0_(SMethodList)) > arch->size) {",
          "499:   return;",
          "500:  }",
          "502:   if (r_buf_read_at (arch->buf, r, sml, left) != left) {",
          "503:    return;",
          "504:   }",
          "506:   len = r_buf_read_at (arch->buf, r, sml, sizeof (struct MACH0_(SMethodList)));",
          "507:   if (len != sizeof (struct MACH0_(SMethodList))) {",
          "508:    return;",
          "509:   }",
          "511:  ml.entsize = r_read_ble (&sml[0], bigendian, 32);",
          "512:  ml.count = r_read_ble (&sml[4], bigendian, 32);",
          "518:   if (!r) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "441:    return;",
          "442:   }",
          "444:   memset (&m, '\\0', sizeof (struct MACH0_(SMethod)));",
          "455:   }",
          "458:    goto error;",
          "459:   }",
          "461:   r = get_pointer (m.name, NULL, &left, arch);",
          "463:    struct MACH0_(obj_t) *bin = (struct MACH0_(obj_t) *)arch->o->bin_obj;",
          "468:    if (bin->has_crypto) {",
          "469:     name = strdup (\"some_encrypted_data\");",
          "470:     left = strlen (name) + 1;",
          "",
          "[Removed Lines]",
          "446:   if (r + left < r || r + sizeof (struct MACH0_(SMethod)) < r) goto error;",
          "447:   if (r > arch->size || r + left > arch->size) goto error;",
          "448:   if (r + sizeof (struct MACH0_(SMethod)) > arch->size) goto error;",
          "450:   if (left < sizeof (struct MACH0_(SMethod))) {",
          "451:    len = r_buf_read_at (arch->buf, r, (ut8 *)&m, left);",
          "452:   } else {",
          "453:    len = r_buf_read_at (arch->buf, r, (ut8 *)&m,",
          "454:      sizeof (struct MACH0_(SMethod)));",
          "456:   if (len < 1) {",
          "457:    eprintf (\"READ ERROR\\n\");",
          "462:   if (r != 0) {",
          "465:    if (r + left < r) goto error;",
          "466:    if (r > arch->size || r + left > arch->size) goto error;",
          "",
          "[Added Lines]",
          "528:   if (r + left < r || r + sizeof (struct MACH0_(SMethod)) < r) {",
          "529:    goto error;",
          "531:   if (r > arch->size || r + left > arch->size) {",
          "534:   if (r + sizeof (struct MACH0_(SMethod)) > arch->size) {",
          "535:    goto error;",
          "536:   }",
          "537:   if (left < sizeof (struct MACH0_(SMethod))) {",
          "538:    if (r_buf_read_at (arch->buf, r, sm, left) != left) {",
          "539:     goto error;",
          "540:    }",
          "541:   } else {",
          "542:    len = r_buf_read_at (arch->buf, r, sm, sizeof (struct MACH0_(SMethod)));",
          "543:    if (len != sizeof (struct MACH0_(SMethod))) {",
          "544:     goto error;",
          "545:    }",
          "546:   }",
          "547:   m.name = r_read_ble (&sm[0], bigendian, 8 * sizeof (mach0_ut));",
          "548:   m.types = r_read_ble (&sm[sizeof (mach0_ut)], bigendian, 8 * sizeof (mach0_ut));",
          "549:   m.imp = r_read_ble (&sm[2 * sizeof (mach0_ut)], bigendian, 8 * sizeof (mach0_ut));",
          "552:   if (r) {",
          "554:    if (r + left < r) {",
          "555:     goto error;",
          "556:    }",
          "557:    if (r > arch->size || r + left > arch->size) {",
          "558:     goto error;",
          "559:    }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "497:     if (!name) {",
          "498:      goto error;",
          "499:     }",
          "503:      free (name);",
          "504:      goto error;",
          "505:     }",
          "506:    }",
          "507:    R_FREE (name);",
          "508:   }",
          "",
          "[Removed Lines]",
          "500:     len = r_buf_read_at (arch->buf, r, (ut8 *)name, left);",
          "501:     name[left] = 0;",
          "502:     if (len != left) {",
          "",
          "[Added Lines]",
          "592:     if (r_buf_read_at (arch->buf, r, (ut8 *)name, left) != left) {",
          "596:     name[left] = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "533:  struct MACH0_(SProtocolList) pl = { 0 };",
          "534:  struct MACH0_(SProtocol) pc;",
          "535:  char *class_name = NULL;",
          "537:  mach0_ut q, r;",
          "538:  int len;",
          "540:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "541:   eprintf (\"get_protocol_list_t: Invalid RBinFile pointer\\n\");",
          "542:   return;",
          "543:  }",
          "546:   return;",
          "552:  if (left < sizeof (struct MACH0_(SProtocolList))) {",
          "554:  } else {",
          "557:  }",
          "560:  p += sizeof (struct MACH0_(SProtocolList));",
          "561:  offset += sizeof (struct MACH0_(SProtocolList));",
          "562:  for (i = 0; i < pl.count; i++) {",
          "564:    return;",
          "565:   q = 0;",
          "570:   if (left < sizeof (ut32)) {",
          "572:   } else {",
          "574:   }",
          "577:   if (!(r = get_pointer (q, &offset, &left, arch))) {",
          "578:    return;",
          "579:   }",
          "580:   memset (&pc, '\\0', sizeof (struct MACH0_(SProtocol)));",
          "587:   if (left < sizeof (struct MACH0_(SProtocol))) {",
          "589:   } else {",
          "592:   }",
          "595:   r = get_pointer (pc.name, NULL, &left, arch);",
          "596:   if (r != 0) {",
          "597:    char *name = NULL;",
          "598:    struct MACH0_(obj_t) *bin = (struct MACH0_(obj_t) *)arch->o->bin_obj;",
          "603:    if (bin->has_crypto) {",
          "604:     name = strdup (\"some_encrypted_data\");",
          "605:     left = strlen (name) + 1;",
          "606:    } else {",
          "607:     name = malloc (left);",
          "610:    }",
          "613:    R_FREE (name);",
          "614:   }",
          "616:   if (pc.instanceMethods > 0) {",
          "619:   }",
          "620:   if (pc.classMethods > 0) {",
          "623:   }",
          "624:   R_FREE (class_name);",
          "625:   p += sizeof (ut32);",
          "",
          "[Removed Lines]",
          "536:  ut32 offset, left, i;",
          "545:  if (!(r = get_pointer (p, &offset, &left, arch)))",
          "548:  if (r + left < r || r + sizeof (struct MACH0_(SProtocolList)) < r) return;",
          "549:  if (r > arch->size || r + left > arch->size) return;",
          "550:  if (r + sizeof (struct MACH0_(SProtocolList)) > arch->size) return;",
          "553:   len = r_buf_read_at (arch->buf, r, (ut8 *)&pl, left);",
          "555:   len = r_buf_read_at (arch->buf, r, (ut8 *)&pl,",
          "556:     sizeof (struct MACH0_(SProtocolList)));",
          "558:  if (len < 1) return;",
          "563:   if (!(r = get_pointer (p, &offset, &left, arch)))",
          "566:   if (r + left < r || r + sizeof (mach0_ut) < r) return;",
          "567:   if (r > arch->size || r + left > arch->size) return;",
          "568:   if (r + sizeof (mach0_ut) > arch->size) return;",
          "571:    len = r_buf_read_at (arch->buf, r, (ut8 *)&q, left);",
          "573:    len = r_buf_read_at (arch->buf, r, (ut8 *)&q, sizeof (mach0_ut));",
          "575:   if (len < 1) return;",
          "582:   if (r + left < r || r + sizeof (struct MACH0_(SProtocol)) < r) return;",
          "583:   if (r > arch->size || r + left > arch->size) return;",
          "584:   if (r + sizeof (struct MACH0_(SProtocol)) > arch->size) return;",
          "588:    len = r_buf_read_at (arch->buf, r, (ut8 *)&pc, left);",
          "590:    len = r_buf_read_at (arch->buf, r, (ut8 *)&pc,",
          "591:      sizeof (struct MACH0_(SProtocol)));",
          "593:   if (len < 1) return;",
          "600:    if (r + left < r) return;",
          "601:    if (r > arch->size || r + left > arch->size) return;",
          "608:     len = r_buf_read_at (arch->buf, r, (ut8 *)name, left);",
          "609:     if (len < 1) return;",
          "611:    class_name = r_str_newf (\"%s::%s%s\", klass->name,",
          "612:       \"(protocol)\", name);",
          "617:    get_method_list_t (pc.instanceMethods, arch,",
          "618:      class_name, klass, false);",
          "621:    get_method_list_t (pc.classMethods, arch,",
          "622:      class_name, klass, true);",
          "",
          "[Added Lines]",
          "627:  ut32 offset, left, i, j;",
          "630:  bool bigendian = arch->o->info->big_endian;",
          "631:  ut8 spl[sizeof (struct MACH0_(SProtocolList))] = {0};",
          "632:  ut8 spc[sizeof (struct MACH0_(SProtocol))] = {0};",
          "633:  ut8 sptr[sizeof (mach0_ut)] = {0};",
          "640:  if (!(r = get_pointer (p, &offset, &left, arch))) {",
          "642:  }",
          "644:  if (r + left < r || r + sizeof (struct MACH0_(SProtocolList)) < r) {",
          "645:   return;",
          "646:  }",
          "647:  if (r > arch->size || r + left > arch->size) {",
          "648:   return;",
          "649:  }",
          "650:  if (r + sizeof (struct MACH0_(SProtocolList)) > arch->size) {",
          "651:   return;",
          "652:  }",
          "654:   if (r_buf_read_at (arch->buf, r, spl, left) != left) {",
          "655:    return;",
          "656:   }",
          "658:   len = r_buf_read_at (arch->buf, r, spl, sizeof (struct MACH0_(SProtocolList)));",
          "659:   if (len != sizeof (struct MACH0_(SProtocolList))) {",
          "660:    return;",
          "661:   }",
          "663:  pl.count = r_read_ble (&spl[0], bigendian, 8 * sizeof (mach0_ut));",
          "668:   if (!(r = get_pointer (p, &offset, &left, arch))) {",
          "670:   }",
          "672:   if (r + left < r || r + sizeof (mach0_ut) < r) {",
          "673:    return;",
          "674:   }",
          "675:   if (r > arch->size || r + left > arch->size) {",
          "676:    return;",
          "677:   }",
          "678:   if (r + sizeof (mach0_ut) > arch->size) {",
          "679:    return;",
          "680:   }",
          "682:    if (r_buf_read_at (arch->buf, r, sptr, left) != left) {",
          "683:     return;",
          "684:    }",
          "686:    len = r_buf_read_at (arch->buf, r, sptr, sizeof (mach0_ut));",
          "687:    if (len != sizeof (mach0_ut)) {",
          "688:     return;",
          "689:    }",
          "691:   q = r_read_ble (&sptr[0], bigendian, 8 * sizeof (mach0_ut));",
          "696:   if (r + left < r || r + sizeof (struct MACH0_(SProtocol)) < r) {",
          "697:    return;",
          "698:   }",
          "699:   if (r > arch->size || r + left > arch->size) {",
          "700:    return;",
          "701:   }",
          "702:   if (r + sizeof (struct MACH0_(SProtocol)) > arch->size) {",
          "703:    return;",
          "704:   }",
          "706:    if (r_buf_read_at (arch->buf, r, spc, left) != left) {",
          "707:     return;",
          "708:    }",
          "710:    len = r_buf_read_at (arch->buf, r, spc, sizeof (struct MACH0_(SProtocol)));",
          "711:    if (len != sizeof (struct MACH0_(SProtocol))) {",
          "712:     return;",
          "713:    }",
          "715:   j = 0;",
          "716:   pc.isa = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "717:   j += sizeof (mach0_ut);",
          "718:   pc.name = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "719:   j += sizeof (mach0_ut);",
          "720:   pc.protocols = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "721:   j += sizeof (mach0_ut);",
          "722:   pc.instanceMethods = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "723:   j += sizeof (mach0_ut);",
          "724:   pc.classMethods = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "725:   j += sizeof (mach0_ut);",
          "726:   pc.optionalInstanceMethods = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "727:   j += sizeof (mach0_ut);",
          "728:   pc.optionalClassMethods = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "729:   j += sizeof (mach0_ut);",
          "730:   pc.instanceProperties = r_read_ble (&spc[j], bigendian, 8 * sizeof (mach0_ut));",
          "736:    if (r + left < r) {",
          "737:     return;",
          "738:    }",
          "739:    if (r > arch->size || r + left > arch->size) {",
          "740:     return;",
          "741:    }",
          "747:     if (r_buf_read_at (arch->buf, r, (ut8 *)name, left) != left) {",
          "748:      return;",
          "749:     }",
          "751:    class_name = r_str_newf (\"%s::%s%s\", klass->name, \"(protocol)\", name);",
          "756:    get_method_list_t (pc.instanceMethods, arch, class_name, klass, false);",
          "759:    get_method_list_t (pc.classMethods, arch, class_name, klass, true);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "665: static void get_class_ro_t(mach0_ut p, RBinFile *arch, ut32 *is_meta_class, RBinClass *klass) {",
          "666:  struct MACH0_(obj_t) * bin;",
          "667:  struct MACH0_(SClassRoT) cro = { 0 };",
          "669:  ut64 r, s;",
          "670:  int len;",
          "672:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "673:   eprintf (\"Invalid RBinFile pointer\\n\");",
          "",
          "[Removed Lines]",
          "668:  ut32 offset, left;",
          "",
          "[Added Lines]",
          "805:  ut32 offset, left, i;",
          "808:  bool bigendian = arch->o->info->big_endian;",
          "809:  ut8 scro[sizeof (struct MACH0_(SClassRoT))] = {0};",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "680:   return;",
          "681:  }",
          "688:  if (left < sizeof (cro)) {",
          "689:   eprintf (\"Not enough data for SClassRoT\\n\");",
          "690:   return;",
          "691:  }",
          "693:  if (len < 1) {",
          "694:   return;",
          "695:  }",
          "697:  s = r;",
          "698:  if ((r = get_pointer (cro.name, NULL, &left, arch))) {",
          "702:   if (bin->has_crypto) {",
          "703:    klass->name = strdup (\"some_encrypted_data\");",
          "704:    left = strlen (klass->name) + 1;",
          "",
          "[Removed Lines]",
          "683:  if (r + left < r || r + sizeof (cro) < r) return;",
          "684:  if (r > arch->size || r + left > arch->size) return;",
          "685:  if (r + sizeof (cro) > arch->size) return;",
          "692:  len = r_buf_read_at (arch->buf, r, (ut8 *)&cro, sizeof (cro));",
          "699:   if (left < 1 || r + left < r) return;",
          "700:   if (r > arch->size || r + left > arch->size) return;",
          "",
          "[Added Lines]",
          "822:  if (r + left < r || r + sizeof (cro) < r) {",
          "823:   return;",
          "824:  }",
          "825:  if (r > arch->size || r + left > arch->size) {",
          "826:   return;",
          "827:  }",
          "828:  if (r + sizeof (cro) > arch->size) {",
          "829:   return;",
          "830:  }",
          "837:  len = r_buf_read_at (arch->buf, r, scro, sizeof (cro));",
          "842:  i = 0;",
          "843:  cro.flags = r_read_ble (&scro[i], bigendian, 8 * sizeof (ut32));",
          "844:  i += sizeof (ut32);",
          "845:  cro.instanceStart = r_read_ble (&scro[i], bigendian, 8 * sizeof (ut32));",
          "846:  i += sizeof (ut32);",
          "847:  cro.instanceSize = r_read_ble (&scro[i], bigendian, 8 * sizeof (ut32));",
          "848:  i += sizeof (ut32);",
          "849: #ifdef R_BIN_MACH064",
          "850:  cro.reserved = r_read_ble (&scro[i], bigendian, 8 * sizeof (ut32));",
          "851:  i += sizeof (ut32);",
          "852: #endif",
          "853:  cro.ivarLayout = r_read_ble (&scro[i], bigendian, 8 * sizeof (mach0_ut));",
          "854:  i += sizeof (mach0_ut);",
          "855:  cro.name = r_read_ble (&scro[i], bigendian, 8 * sizeof (mach0_ut));",
          "856:  i += sizeof (mach0_ut);",
          "857:  cro.baseMethods = r_read_ble (&scro[i], bigendian, 8 * sizeof (mach0_ut));",
          "858:  i += sizeof (mach0_ut);",
          "859:  cro.baseProtocols = r_read_ble (&scro[i], bigendian, 8 * sizeof (mach0_ut));",
          "860:  i += sizeof (mach0_ut);",
          "861:  cro.ivars = r_read_ble (&scro[i], bigendian, 8 * sizeof (mach0_ut));",
          "862:  i += sizeof (mach0_ut);",
          "863:  cro.weakIvarLayout = r_read_ble (&scro[i], bigendian, 8 * sizeof (mach0_ut));",
          "864:  i += sizeof (mach0_ut);",
          "865:  cro.baseProperties = r_read_ble (&scro[i], bigendian, 8 * sizeof (mach0_ut));",
          "869:   if (left < 1 || r + left < r) {",
          "870:    return;",
          "871:   }",
          "872:   if (r > arch->size || r + left > arch->size) {",
          "873:    return;",
          "874:   }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "706:    char *name = malloc (left + 1);",
          "707:    if (name) {",
          "708:     int rc = r_buf_read_at (arch->buf, r, (ut8 *)name, left);",
          "710:     name[rc] = 0;",
          "711:     klass->name = demangle_classname (name);",
          "712:     free (name);",
          "",
          "[Removed Lines]",
          "709:     if (rc < 1) rc = 0;",
          "",
          "[Added Lines]",
          "882:     if (rc != left) {",
          "883:      rc = 0;",
          "884:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "755:  ut32 offset = 0, left = 0;",
          "756:  ut32 is_meta_class = 0;",
          "757:  int len;",
          "759:  if (!(r = get_pointer (p, &offset, &left, arch))) {",
          "760:   return;",
          "761:  }",
          "766:  if (left < size) {",
          "767:   eprintf (\"Cannot parse obj class info out of bounds\\n\");",
          "768:   return;",
          "769:  }",
          "774:  klass->addr = c.isa;",
          "775:  get_class_ro_t (c.data & ~0x3, arch, &is_meta_class, klass);",
          "",
          "[Removed Lines]",
          "762:  if ((r + left) < r || (r + size) < r) return;",
          "763:  if (r > arch->size || r + left > arch->size) return;",
          "764:  if (r + size > arch->size) return;",
          "771:  len = r_buf_read_at (arch->buf, r, (ut8 *)&c, size);",
          "772:  if (len < 1) return;",
          "",
          "[Added Lines]",
          "933:  bool bigendian = arch->o->info->big_endian;",
          "934:  ut8 sc[sizeof (struct MACH0_(SClass))] = {0};",
          "935:  ut32 i;",
          "940:  if ((r + left) < r || (r + size) < r) {",
          "941:   return;",
          "942:  }",
          "943:  if (r > arch->size || r + left > arch->size) {",
          "944:   return;",
          "945:  }",
          "946:  if (r + size > arch->size) {",
          "947:   return;",
          "948:  }",
          "954:  len = r_buf_read_at (arch->buf, r, sc, size);",
          "955:  if (len != size) {",
          "956:   return;",
          "957:  }",
          "959:  i = 0;",
          "960:  c.isa = r_read_ble (&sc[i], bigendian, 8 * sizeof (mach0_ut));",
          "961:  i += sizeof (mach0_ut);",
          "962:  c.superclass = r_read_ble (&sc[i], bigendian, 8 * sizeof (mach0_ut));",
          "963:  i += sizeof (mach0_ut);",
          "964:  c.cache = r_read_ble (&sc[i], bigendian, 8 * sizeof (mach0_ut));",
          "965:  i += sizeof (mach0_ut);",
          "966:  c.vtable = r_read_ble (&sc[i], bigendian, 8 * sizeof (mach0_ut));",
          "967:  i += sizeof (mach0_ut);",
          "968:  c.data = r_read_ble (&sc[i], bigendian, 8 * sizeof (mach0_ut));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "858:  mach0_ut p = 0;",
          "859:  ut32 left = 0;",
          "860:  int len;",
          "862:  if (!arch || !arch->o || !arch->o->bin_obj)",
          "863:   return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1057:  bool bigendian = arch->o->info->big_endian;",
          "1058:  ut8 pp[sizeof (mach0_ut)] = {0};",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "929:   if (s->paddr + size < s->paddr) {",
          "930:    goto get_classes_error;",
          "931:   }",
          "940:    goto get_classes_error;",
          "941:   }",
          "942:   get_class_t (p, arch, klass);",
          "944:   if (!klass->name) {",
          "947:    if (!klass->name) {",
          "948:     goto get_classes_error;",
          "949:    }",
          "",
          "[Removed Lines]",
          "934: #ifdef R_BIN_MACH064",
          "935:   len = r_buf_fread_at (arch->buf, s->paddr + i, (ut8 *)&p, \"l\", 1);",
          "936: #else",
          "937:   len = r_buf_fread_at (arch->buf, s->paddr + i, (ut8 *)&p, \"i\", 1);",
          "938: #endif",
          "939:   if (len < 1) {",
          "945:    klass->name = r_str_newf (\"UnnamedClass%\" PFMT64d,",
          "946:       num_of_unnamed_class);",
          "",
          "[Added Lines]",
          "1128:   len = r_buf_read_at (arch->buf, s->paddr + i, pp, sizeof (mach0_ut));",
          "1129:   if (len != sizeof (mach0_ut)) {",
          "1132:   p = r_read_ble (&pp[0], bigendian, 8 * sizeof (mach0_ut));",
          "1135:    klass->name = r_str_newf (\"UnnamedClass%\" PFMT64d, num_of_unnamed_class);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_xtr_fatmach0.c||libr/bin/p/bin_xtr_fatmach0.c": [
          "File: libr/bin/p/bin_xtr_fatmach0.c -> libr/bin/p/bin_xtr_fatmach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:  RMmap *m = r_file_mmap (bin->file, false, 0);",
          "20:  if (!m || !m->buf) {",
          "21:   r_file_mmap_free (m);",
          "22:   return false;",
          "23:  }",
          "24:  h = m->buf;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22:   eprintf(\"check failed\\n\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:   }",
          "36:  }",
          "37:  r_file_mmap_free (m);",
          "38:  return ret;",
          "39: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39:  eprintf(\"check=%d\\n\", ret);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:    }",
          "64:   }",
          "65:  }",
          "66:  return ret;",
          "67: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  eprintf(\"checkbytes=%d\\n\", ret);",
          "",
          "---------------"
        ],
        "libr/util/buf.c||libr/util/buf.c": [
          "File: libr/util/buf.c -> libr/util/buf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "498:   }",
          "500:   for (k = 0; k < m; k++) {",
          "502:    ut8* src1 = &b->buf[len+(k*tsize)];",
          "504:    ut8* src2 = &b->buf[addr+len+(k*tsize)];",
          "505:    if (write) {",
          "506:     switch (tsize) {",
          "507:     case 1:",
          "509:      break;",
          "510:     case 2:",
          "512:      break;",
          "513:     case 4:",
          "515:      break;",
          "516:     case 8:",
          "518:      break;",
          "519:     }",
          "520:    } else {",
          "521:     switch (tsize) {",
          "522:     case 1:",
          "524:      break;",
          "525:     case 2:",
          "527:      break;",
          "528:     case 4:",
          "530:      break;",
          "531:     case 8:",
          "533:      break;",
          "534:     }",
          "535:    }",
          "",
          "[Removed Lines]",
          "501:    ut8* dest1 = &buf[addr+len+(k*tsize)];",
          "503:    ut8* dest2 = &buf[len+(k*tsize)];",
          "",
          "[Added Lines]",
          "503:    void* dest1 = &buf[addr+len+(k*tsize)];",
          "504:    void* dest2 = &buf[len+(k*tsize)];",
          "505:    ut8* dest1_8 = (ut8*)dest1;",
          "506:    ut16* dest1_16 = (ut16*)dest1;",
          "507:    ut32* dest1_32 = (ut32*)dest1;",
          "508:    ut64* dest1_64 = (ut64*)dest1;",
          "509:    ut8* dest2_8 = (ut8*)dest2;",
          "510:    ut16* dest2_16 = (ut16*)dest2;",
          "511:    ut32* dest2_32 = (ut32*)dest2;",
          "512:    ut64* dest2_64 = (ut64*)dest2;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7cc6c04d700c04b1bf35bbeed7d4606b6616a9b",
      "candidate_info": {
        "commit_hash": "b7cc6c04d700c04b1bf35bbeed7d4606b6616a9b",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/b7cc6c04d700c04b1bf35bbeed7d4606b6616a9b",
        "files": [
          "binr/rabin2/rabin2.c",
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h",
          "libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_mach064.c",
          "libr/core/bin.c",
          "libr/core/cmd_info.c",
          "libr/include/r_bin.h",
          "libr/include/r_core.h"
        ],
        "message": "LDID parse signature in mach0 binaries\n\n* added iC command to show signature info\n\nin the case of mach it shows entitlements\n\n* added rabin2 -OC to get signature info from binary\n\n* change swap to r_read_bleX new API\n\n* change eprintf to r_cons_printf\n\n* add const char in plg->signature",
        "before_after_code_files": [
          "binr/rabin2/rabin2.c||binr/rabin2/rabin2.c",
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_mach064.c||libr/bin/p/bin_mach064.c",
          "libr/core/bin.c||libr/core/bin.c",
          "libr/core/cmd_info.c||libr/core/cmd_info.c",
          "libr/include/r_bin.h||libr/include/r_bin.h",
          "libr/include/r_core.h||libr/include/r_core.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ],
          "candidate": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "binr/rabin2/rabin2.c||binr/rabin2/rabin2.c": [
          "File: binr/rabin2/rabin2.c -> binr/rabin2/rabin2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "352:   r_bin_wr_rpath_del (bin);",
          "353:   rc = r_bin_wr_output (bin, output);",
          "354:   break;",
          "355:  case 'r':",
          "356:   r_bin_wr_scn_resize (bin, ptr, r_num_math (NULL, ptr2));",
          "357:   rc = r_bin_wr_output (bin, output);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:  case 'C':",
          "356:   {",
          "357:   RBinFile *cur   = r_bin_cur (bin);",
          "358:   RBinPlugin *plg = r_bin_file_cur_plugin (cur);",
          "359:   if (!plg) break;",
          "360:   if (plg->signature) {",
          "361:    const char *sign = plg->signature (cur);",
          "362:    r_cons_printf (\"%s\\n\", sign);",
          "363:    r_cons_flush ();",
          "364:   }",
          "365:   }",
          "366:   break;",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "381:  return true;",
          "382: }",
          "384: static int parse_thread(struct MACH0_(obj_t)* bin, struct load_command *lc, ut64 off, bool is_first_thread) {",
          "385:  ut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;",
          "386:  ut32 flavor, count;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "384: static void parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {",
          "385:      int index, len;",
          "386:  ut32 count, data;",
          "387:  struct linkedit_data_command link = {};",
          "388:      if (off > bin->size || off + sizeof(struct linkedit_data_command) > bin->size)",
          "389:       return;",
          "390:  len = r_buf_fread_at (bin->b, off, (ut8*)&link, bin->big_endian ? \"4I\" : \"4i\", 1);",
          "391:  if (len < 1) {",
          "392:   eprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");",
          "393:   return;",
          "394:  }",
          "395:  data = link.dataoff;",
          "396:  if (data > bin->size || data + sizeof(struct super_blob_t) > bin->size)",
          "397:       return;",
          "398:  struct super_blob_t *super = (struct super_blob_t *) (bin->b->buf + data);",
          "399:  count = r_read_ble32 (&super->count, true);",
          "400:  for (index = 0; index < count; ++index) {",
          "401:   if ((ut8 *)(super->index +",
          "402:        index * sizeof (struct blob_index_t)) >",
          "403:       (ut8 *)(bin->b->buf + bin->size))",
          "404:    return;",
          "405:   if (r_read_ble32 (&super->index[index].type, true) == CSSLOT_ENTITLEMENTS) {",
          "406:    ut32 begin = r_read_ble32 (&super->index[index].offset, true);",
          "407:    if (begin > bin->size || begin + sizeof(struct blob_t) > bin->size)",
          "408:         return;",
          "409:    struct blob_t *entitlements = (struct blob_t *) ((ut8*)super + begin);",
          "410:    len = r_read_ble32 (&entitlements->length, true) - sizeof(struct blob_t);",
          "411:    if (len > bin->size || len < 1)",
          "412:         return;",
          "413:    bin->signature = calloc (1, len + 1);",
          "414:    if (!bin->signature)",
          "415:         return;",
          "416:    memcpy (bin->signature, entitlements + 1, len);",
          "417:    bin->signature[len] = '\\0';",
          "418:    return;",
          "419:   }",
          "420:  }",
          "421: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "537:  struct linkedit_data_command fc;",
          "538:  ut8 *buf;",
          "539:  int len;",
          "542:   eprintf (\"Likely overflow while parsing\"",
          "543:    \" LC_FUNCTION_STARTS command\\n\");",
          "544:  }",
          "",
          "[Removed Lines]",
          "540:  if (off > bin->size || off + sizeof (struct",
          "541:    linkedit_data_command) > bin->size) {",
          "",
          "[Added Lines]",
          "579:  if (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "723:     eprintf (\"encryption info out of bounds\\n\");",
          "724:     return false;",
          "725:    }",
          "728:     bin->has_crypto = eic.cryptid;",
          "729:     sdb_set (bin->kv, \"crypto\", \"true\", 0);",
          "730:     sdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);",
          "",
          "[Removed Lines]",
          "726:    if (r_buf_fread_at (bin->b, off, (ut8*)&eic,",
          "727:      bin->big_endian?\"5I\":\"5i\", 1) != -1) {",
          "",
          "[Added Lines]",
          "764:    if (r_buf_fread_at (bin->b, off, (ut8*)&eic, bin->big_endian?\"5I\":\"5i\", 1) != -1) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "735:    break;",
          "736:   case LC_LOAD_DYLINKER:",
          "737:    {",
          "739:     free (bin->intrp);",
          "740:     bin->intrp = NULL;",
          "",
          "[Removed Lines]",
          "738:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylinker\", 0);",
          "",
          "[Added Lines]",
          "775:     sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylinker\", 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "818:     free (bin->dyld_info);",
          "819:     return false;",
          "820:    }",
          "823:     free (bin->dyld_info);",
          "824:     bin->dyld_info = NULL;",
          "825:     eprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
          "826:    }",
          "827:    break;",
          "828:   case LC_CODE_SIGNATURE:",
          "829:    sdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"signature\", 0);",
          "833:    break;",
          "",
          "[Removed Lines]",
          "821:    if (r_buf_fread_at (bin->b, off, (ut8*)bin->dyld_info,",
          "822:      bin->big_endian?\"12I\":\"12i\", 1) == -1) {",
          "",
          "[Added Lines]",
          "858:    if (r_buf_fread_at (bin->b, off, (ut8*)bin->dyld_info, bin->big_endian?\"12I\":\"12i\", 1) == -1) {",
          "865:    parse_signature(bin, off);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "884:  free (bin->modtab);",
          "885:  free (bin->libs);",
          "886:  free (bin->func_start);",
          "887:  r_buf_free (bin->b);",
          "888:  free (bin);",
          "889:  return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "923:  free (bin->signature);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
          "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #define R_BIN_MACH0_STRING_LENGTH 256",
          "12: struct section_t {",
          "13:  ut64 offset;",
          "14:  ut64 addr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #define CSMAGIC_CODEDIRECTORY      0xfade0c02",
          "14: #define CSMAGIC_EMBEDDED_SIGNATURE 0xfade0cc0",
          "15: #define CSMAGIC_ENTITLEMENTS       0xfade7171",
          "17: #define CSSLOT_CODEDIRECTORY 0",
          "18: #define CSSLOT_REQUIREMENTS  2",
          "19: #define CSSLOT_ENTITLEMENTS  5",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:  int last;",
          "56: };",
          "58: struct MACH0_(obj_t) {",
          "59:  struct MACH0_(mach_header) hdr;",
          "60:  struct MACH0_(segment_command)* segs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: struct blob_index_t {",
          "69:     ut32 type;",
          "70:     ut32 offset;",
          "71: };",
          "73: struct blob_t {",
          "74:     ut32 magic;",
          "75:     ut32  length;",
          "76: };",
          "78: struct super_blob_t {",
          "79:     struct blob_t blob;",
          "80:     ut32 count;",
          "81:     struct blob_index_t index[];",
          "82: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:  struct MACH0_(dylib_module)* modtab;",
          "82:  int nmodtab;",
          "83:  struct thread_command thread;",
          "84:  union {",
          "85:   struct x86_thread_state32 x86_32;",
          "86:   struct x86_thread_state64 x86_64;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:  ut8* signature;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "128: char* MACH0_(get_filetype)(struct MACH0_(obj_t)* bin);",
          "129: ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin);",
          "144: #endif",
          "",
          "[Removed Lines]",
          "131: #if 0",
          "132: int r_bin_mach0_get_file_alignment(r_bin_mach0_obj*);",
          "133: int r_bin_mach0_get_image_size(r_bin_mach0_obj*);",
          "134: int r_bin_mach0_get_os(r_bin_mach0_obj*, char*);",
          "135: int r_bin_mach0_get_subsystem(r_bin_mach0_obj*, char*);",
          "136: int r_bin_mach0_get_section_alignment(r_bin_mach0_obj*);",
          "137: int r_bin_mach0_get_strings(r_bin_mach0_obj*, int, int, r_bin_mach0_string*);",
          "138: int r_bin_mach0_is_stripped_relocs(r_bin_mach0_obj*);",
          "139: int r_bin_mach0_is_stripped_line_nums(r_bin_mach0_obj*);",
          "140: int r_bin_mach0_is_stripped_local_syms(r_bin_mach0_obj*);",
          "141: int r_bin_mach0_is_stripped_debug(r_bin_mach0_obj*);",
          "142: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:  return NULL;",
          "21: }",
          "23: static void * load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){",
          "24:  struct MACH0_(obj_t) *res = NULL;",
          "25:  RBuffer *tbuf = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: static char *entitlements(RBinFile *arch) {",
          "24:  struct MACH0_(obj_t) *bin;",
          "25:  if (!arch || !arch->o)",
          "26:       return NULL;",
          "27:  bin = arch->o->bin_obj;",
          "28:  return (char *)bin->signature;",
          "29: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "587:  .baddr = &baddr,",
          "588:  .binsym = &binsym,",
          "589:  .entries = &entries,",
          "590:  .sections = &sections,",
          "591:  .symbols = &symbols,",
          "592:  .imports = &imports,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "599:  .signature = &entitlements,",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach064.c||libr/bin/p/bin_mach064.c": [
          "File: libr/bin/p/bin_mach064.c -> libr/bin/p/bin_mach064.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:  .binsym = binsym,",
          "200:  .entries = &entries,",
          "201:  .sections = &sections,",
          "202:  .symbols = &symbols,",
          "203:  .imports = &imports,",
          "204:  .info = &info,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:  .signature = &entitlements,",
          "",
          "---------------"
        ],
        "libr/core/bin.c||libr/core/bin.c": [
          "File: libr/core/bin.c -> libr/core/bin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2104:  return true;",
          "2105: }",
          "2107: R_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {",
          "2108:  int ret = true;",
          "2109:  const char *name = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2107: static int bin_signature(RCore *r, int mode) {",
          "2108:      RBinFile *cur = r_bin_cur (r->bin);",
          "2109:  RBinPlugin *plg = r_bin_file_cur_plugin (cur);",
          "2110:  if (!plg) return false;",
          "2111:  if (plg->signature) {",
          "2112:       const char *signature = plg->signature (cur);",
          "2113:   r_cons_printf (\"%s\\n\", signature);",
          "2114:   return true;",
          "2115:  }",
          "2116:  return false;",
          "2117: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2149:   ret &= bin_mem (core, mode);",
          "2150:  if ((action & R_CORE_BIN_ACC_VERSIONINFO))",
          "2151:   ret &= bin_versioninfo (core, mode);",
          "2152:  return ret;",
          "2153: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2164:  if ((action & R_CORE_BIN_ACC_SIGNATURE))",
          "2165:   ret &= bin_signature (core, mode);",
          "",
          "---------------"
        ],
        "libr/core/cmd_info.c||libr/core/cmd_info.c": [
          "File: libr/core/cmd_info.c -> libr/core/cmd_info.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "315:   case 'M': RBININFO (\"main\", R_CORE_BIN_ACC_MAIN, NULL); break;",
          "316:   case 'm': RBININFO (\"memory\", R_CORE_BIN_ACC_MEM, NULL); break;",
          "317:   case 'V': RBININFO (\"versioninfo\", R_CORE_BIN_ACC_VERSIONINFO, NULL); break;",
          "318:   case 'z':",
          "319:    if (input[1] == 'z') {",
          "320:     char *biname;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "318:   case 'C': RBININFO (\"signature\", R_CORE_BIN_ACC_SIGNATURE, NULL); break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "446:     \"ia\", \"\", \"Show all info (imports, exports, sections..)\",",
          "447:     \"ib\", \"\", \"Reload the current buffer for setting of the bin (use once only)\",",
          "448:     \"ic\", \"\", \"List classes, methods and fields\",",
          "449:     \"id\", \"\", \"Debug information (source lines)\",",
          "450:     \"iD\", \" lang sym\", \"demangle symbolname for given language\",",
          "451:     \"ie\", \"\", \"Entrypoint\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "450:     \"iC\", \"\", \"Show signature info (entitlements, ...)\",",
          "",
          "---------------"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "299:  RList* (*classes)(RBinFile *arch);",
          "300:  RList* (*mem)(RBinFile *arch);",
          "301:  RList* (*patch_relocs)(RBin *bin);",
          "302:  int (*demangle_type)(const char *str);",
          "303:  struct r_bin_dbginfo_t *dbginfo;",
          "304:  struct r_bin_write_t *write;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "302:  char* (*signature)(RBinFile *arch);",
          "",
          "---------------"
        ],
        "libr/include/r_core.h||libr/include/r_core.h": [
          "File: libr/include/r_core.h -> libr/include/r_core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "438: #define R_CORE_BIN_ACC_MEM 0x4000",
          "439: #define R_CORE_BIN_ACC_EXPORTS  0x8000",
          "440: #define R_CORE_BIN_ACC_VERSIONINFO 0x10000",
          "441: #define R_CORE_BIN_ACC_ALL 0x4FFF",
          "443: #define R_CORE_PRJ_FLAGS 0x0001",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "441: #define R_CORE_BIN_ACC_SIGNATURE 0x20000",
          "",
          "---------------"
        ]
      }
    }
  ]
}
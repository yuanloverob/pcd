{
  "cve_id": "CVE-2013-4483",
  "cve_desc": "The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
  "patch_info": {
    "commit_hash": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
    "files": [
      "ipc/msg.c",
      "ipc/sem.c",
      "ipc/util.c",
      "ipc/util.h"
    ],
    "message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "ipc/msg.c||ipc/msg.c",
      "ipc/sem.c||ipc/sem.c",
      "ipc/util.c||ipc/util.c",
      "ipc/util.h||ipc/util.h"
    ]
  },
  "patch_diff": {
    "ipc/msg.c||ipc/msg.c": [
      "File: ipc/msg.c -> ipc/msg.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "687:    goto out_unlock_free;",
      "688:   }",
      "689:   ss_add(msq, &s);",
      "691:   msg_unlock(msq);",
      "692:   schedule();",
      "",
      "[Removed Lines]",
      "690:   ipc_rcu_getref(msq);",
      "",
      "[Added Lines]",
      "691:   if (!ipc_rcu_getref(msq)) {",
      "692:    err = -EIDRM;",
      "693:    goto out_unlock_free;",
      "694:   }",
      "",
      "---------------"
    ],
    "ipc/sem.c||ipc/sem.c": [
      "File: ipc/sem.c -> ipc/sem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "138: #define sem_ids(ns) ((ns)->ids[IPC_SEM_IDS])",
      "141: #define sem_checkid(sma, semid) ipc_checkid(&sma->sem_perm, semid)",
      "143: static int newary(struct ipc_namespace *, struct ipc_params *);",
      "",
      "[Removed Lines]",
      "140: #define sem_unlock(sma)  ipc_unlock(&(sma)->sem_perm)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "189:     IPC_SEM_IDS, sysvipc_sem_proc_show);",
      "190: }",
      "197: {",
      "198:  struct kern_ipc_perm *ipcp;",
      "199:  struct sem_array *sma;",
      "",
      "[Removed Lines]",
      "196: static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)",
      "",
      "[Added Lines]",
      "208: static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,",
      "209:          int nsops)",
      "210: {",
      "211:  int locknum;",
      "212:  again:",
      "213:  if (nsops == 1 && !sma->complex_count) {",
      "214:   struct sem *sem = sma->sem_base + sops->sem_num;",
      "217:   spin_lock(&sem->lock);",
      "223:   if (unlikely(sma->complex_count)) {",
      "224:    spin_unlock(&sem->lock);",
      "225:    goto lock_array;",
      "226:   }",
      "233:   if (unlikely(spin_is_locked(&sma->sem_perm.lock))) {",
      "234:    spin_unlock(&sem->lock);",
      "235:    spin_unlock_wait(&sma->sem_perm.lock);",
      "236:    goto again;",
      "237:   }",
      "239:   locknum = sops->sem_num;",
      "240:  } else {",
      "241:   int i;",
      "248:  lock_array:",
      "249:   spin_lock(&sma->sem_perm.lock);",
      "250:   for (i = 0; i < sma->sem_nsems; i++) {",
      "251:    struct sem *sem = sma->sem_base + i;",
      "252:    spin_unlock_wait(&sem->lock);",
      "253:   }",
      "254:   locknum = -1;",
      "255:  }",
      "256:  return locknum;",
      "257: }",
      "259: static inline void sem_unlock(struct sem_array *sma, int locknum)",
      "260: {",
      "261:  if (locknum == -1) {",
      "262:   spin_unlock(&sma->sem_perm.lock);",
      "263:  } else {",
      "264:   struct sem *sem = sma->sem_base + locknum;",
      "265:   spin_unlock(&sem->lock);",
      "266:  }",
      "267:  rcu_read_unlock();",
      "268: }",
      "274: static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,",
      "275:    int id, struct sembuf *sops, int nsops, int *locknum)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "205:   goto err;",
      "206:  }",
      "",
      "[Removed Lines]",
      "208:  spin_lock(&ipcp->lock);",
      "",
      "[Added Lines]",
      "287:  sma = container_of(ipcp, struct sem_array, sem_perm);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "213:  if (!ipcp->deleted)",
      "214:   return container_of(ipcp, struct sem_array, sem_perm);",
      "217:  sma = ERR_PTR(-EINVAL);",
      "218: err:",
      "219:  rcu_read_unlock();",
      "",
      "[Removed Lines]",
      "216:  spin_unlock(&ipcp->lock);",
      "",
      "[Added Lines]",
      "296:  sem_unlock(sma, *locknum);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "230:  return container_of(ipcp, struct sem_array, sem_perm);",
      "231: }",
      "244: static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,",
      "245:        int id)",
      "246: {",
      "",
      "[Removed Lines]",
      "233: static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,",
      "234:       int id)",
      "235: {",
      "236:  struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);",
      "238:  if (IS_ERR(ipcp))",
      "239:   return ERR_CAST(ipcp);",
      "241:  return container_of(ipcp, struct sem_array, sem_perm);",
      "242: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "255: static inline void sem_lock_and_putref(struct sem_array *sma)",
      "256: {",
      "258:  ipc_rcu_putref(sma);",
      "259: }",
      "261: static inline void sem_getref_and_unlock(struct sem_array *sma)",
      "262: {",
      "265: }",
      "267: static inline void sem_putref(struct sem_array *sma)",
      "268: {",
      "272: }",
      "",
      "[Removed Lines]",
      "257:  ipc_lock_by_ptr(&sma->sem_perm);",
      "263:  ipc_rcu_getref(sma);",
      "264:  ipc_unlock(&(sma)->sem_perm);",
      "269:  ipc_lock_by_ptr(&sma->sem_perm);",
      "270:  ipc_rcu_putref(sma);",
      "271:  ipc_unlock(&(sma)->sem_perm);",
      "",
      "[Added Lines]",
      "326:  rcu_read_lock();",
      "327:  sem_lock(sma, NULL, -1);",
      "333:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
      "334:  sem_unlock(sma, -1);",
      "339:  sem_lock_and_putref(sma);",
      "340:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "277: static inline void sem_getref(struct sem_array *sma)",
      "278: {",
      "282: }",
      "284: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
      "",
      "[Removed Lines]",
      "279:  spin_lock(&(sma)->sem_perm.lock);",
      "280:  ipc_rcu_getref(sma);",
      "281:  ipc_unlock(&(sma)->sem_perm);",
      "",
      "[Added Lines]",
      "348:  sem_lock(sma, NULL, -1);",
      "349:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
      "350:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "372:  sma->sem_base = (struct sem *) &sma[1];",
      "375:   INIT_LIST_HEAD(&sma->sem_base[i].sem_pending);",
      "377:  sma->complex_count = 0;",
      "378:  INIT_LIST_HEAD(&sma->sem_pending);",
      "379:  INIT_LIST_HEAD(&sma->list_id);",
      "380:  sma->sem_nsems = nsems;",
      "381:  sma->sem_ctime = get_seconds();",
      "384:  return sma->sem_perm.id;",
      "385: }",
      "",
      "[Removed Lines]",
      "374:  for (i = 0; i < nsems; i++)",
      "382:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "443:  for (i = 0; i < nsems; i++) {",
      "445:   spin_lock_init(&sma->sem_base[i].lock);",
      "446:  }",
      "453:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "820:  sem_rmid(ns, sma);",
      "823:  wake_up_sem_queue_do(&tasks);",
      "824:  ns->used_sems -= sma->sem_nsems;",
      "",
      "[Removed Lines]",
      "821:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "892:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "947:  struct sem_array *sma;",
      "948:  struct sem* curr;",
      "949:  int err;",
      "951:  struct list_head tasks;",
      "952:  int val;",
      "953: #if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)",
      "",
      "[Removed Lines]",
      "950:  int nsems;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "958:  val = arg;",
      "959: #endif",
      "965:  INIT_LIST_HEAD(&tasks);",
      "972:  err = security_sem_semctl(sma, SETVAL);",
      "980:  curr = &sma->sem_base[semnum];",
      "986:  assert_spin_locked(&sma->sem_perm.lock);",
      "987:  list_for_each_entry(un, &sma->list_id, list_id)",
      "988:   un->semadj[semnum] = 0;",
      "",
      "[Removed Lines]",
      "961:  sma = sem_lock_check(ns, semid);",
      "962:  if (IS_ERR(sma))",
      "963:   return PTR_ERR(sma);",
      "966:  nsems = sma->sem_nsems;",
      "968:  err = -EACCES;",
      "969:  if (ipcperms(ns, &sma->sem_perm, S_IWUGO))",
      "970:   goto out_unlock;",
      "973:  if (err)",
      "974:   goto out_unlock;",
      "976:  err = -EINVAL;",
      "977:  if(semnum < 0 || semnum >= nsems)",
      "978:   goto out_unlock;",
      "982:  err = -ERANGE;",
      "983:  if (val > SEMVMX || val < 0)",
      "984:   goto out_unlock;",
      "",
      "[Added Lines]",
      "1031:  if (val > SEMVMX || val < 0)",
      "1032:   return -ERANGE;",
      "1036:  rcu_read_lock();",
      "1037:  sma = sem_obtain_object_check(ns, semid);",
      "1038:  if (IS_ERR(sma)) {",
      "1039:   rcu_read_unlock();",
      "1040:   return PTR_ERR(sma);",
      "1041:  }",
      "1043:  if (semnum < 0 || semnum >= sma->sem_nsems) {",
      "1044:   rcu_read_unlock();",
      "1045:   return -EINVAL;",
      "1046:  }",
      "1049:  if (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {",
      "1050:   rcu_read_unlock();",
      "1051:   return -EACCES;",
      "1052:  }",
      "1055:  if (err) {",
      "1056:   rcu_read_unlock();",
      "1057:   return -EACCES;",
      "1058:  }",
      "1060:  sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "992:  sma->sem_ctime = get_seconds();",
      "994:  do_smart_update(sma, NULL, 0, 0, &tasks);",
      "998:  wake_up_sem_queue_do(&tasks);",
      "1000: }",
      "1002: static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,",
      "",
      "[Removed Lines]",
      "995:  err = 0;",
      "996: out_unlock:",
      "997:  sem_unlock(sma);",
      "999:  return err;",
      "",
      "[Added Lines]",
      "1073:  sem_unlock(sma, -1);",
      "1075:  return 0;",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1052:    sem_lock_and_putref(sma);",
      "1053:    if (sma->sem_perm.deleted) {",
      "1055:     err = -EIDRM;",
      "1056:     goto out_free;",
      "1057:    }",
      "1061:   for (i = 0; i < sma->sem_nsems; i++)",
      "1062:    sem_io[i] = sma->sem_base[i].semval;",
      "1064:   err = 0;",
      "1065:   if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))",
      "1066:    err = -EFAULT;",
      "",
      "[Removed Lines]",
      "1054:     sem_unlock(sma);",
      "1058:   }",
      "1060:   spin_lock(&sma->sem_perm.lock);",
      "1063:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1130:     sem_unlock(sma, -1);",
      "1134:   } else",
      "1135:    sem_lock(sma, NULL, -1);",
      "1139:   sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "1071:   int i;",
      "1072:   struct sem_undo *un;",
      "1075:   rcu_read_unlock();",
      "1077:   if(nsems > SEMMSL_FAST) {",
      "",
      "[Removed Lines]",
      "1074:   ipc_rcu_getref(sma);",
      "",
      "[Added Lines]",
      "1150:   if (!ipc_rcu_getref(sma)) {",
      "1151:    rcu_read_unlock();",
      "1152:    return -EIDRM;",
      "1153:   }",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "1097:   }",
      "1098:   sem_lock_and_putref(sma);",
      "1099:   if (sma->sem_perm.deleted) {",
      "1101:    err = -EIDRM;",
      "1102:    goto out_free;",
      "1103:   }",
      "",
      "[Removed Lines]",
      "1100:    sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1179:    sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "1124:   goto out_wakeup;",
      "1125:  }",
      "1128:  curr = &sma->sem_base[semnum];",
      "1130:  switch (cmd) {",
      "",
      "[Removed Lines]",
      "1127:  spin_lock(&sma->sem_perm.lock);",
      "",
      "[Added Lines]",
      "1206:  sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "1143:  }",
      "1145: out_unlock:",
      "1147: out_wakeup:",
      "1148:  wake_up_sem_queue_do(&tasks);",
      "1149: out_free:",
      "",
      "[Removed Lines]",
      "1146:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1225:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "1212:  switch(cmd){",
      "1213:  case IPC_RMID:",
      "1215:   freeary(ns, ipcp);",
      "1216:   goto out_up;",
      "1217:  case IPC_SET:",
      "1219:   err = ipc_update_perm(&semid64.sem_perm, ipcp);",
      "1220:   if (err)",
      "1221:    goto out_unlock;",
      "",
      "[Removed Lines]",
      "1214:   ipc_lock_object(&sma->sem_perm);",
      "1218:   ipc_lock_object(&sma->sem_perm);",
      "",
      "[Added Lines]",
      "1293:   sem_lock(sma, NULL, -1);",
      "1297:   sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "1228:  }",
      "1230: out_unlock:",
      "1232: out_up:",
      "1233:  up_write(&sem_ids(ns).rw_mutex);",
      "1234:  return err;",
      "",
      "[Removed Lines]",
      "1231:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1310:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "1340:  struct sem_array *sma;",
      "1341:  struct sem_undo_list *ulp;",
      "1342:  struct sem_undo *un, *new;",
      "1346:  error = get_undo_list(&ulp);",
      "1347:  if (error)",
      "",
      "[Removed Lines]",
      "1343:  int nsems;",
      "1344:  int error;",
      "",
      "[Added Lines]",
      "1422:  int nsems, error;",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "1363:  }",
      "1365:  nsems = sma->sem_nsems;",
      "1367:  rcu_read_unlock();",
      "",
      "[Removed Lines]",
      "1366:  ipc_rcu_getref(sma);",
      "",
      "[Added Lines]",
      "1444:  if (!ipc_rcu_getref(sma)) {",
      "1445:   rcu_read_unlock();",
      "1446:   un = ERR_PTR(-EIDRM);",
      "1447:   goto out;",
      "1448:  }",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "1377:  sem_lock_and_putref(sma);",
      "1378:  if (sma->sem_perm.deleted) {",
      "1380:   kfree(new);",
      "1381:   un = ERR_PTR(-EIDRM);",
      "1382:   goto out;",
      "",
      "[Removed Lines]",
      "1379:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1461:   sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "1404: success:",
      "1405:  spin_unlock(&ulp->lock);",
      "1406:  rcu_read_lock();",
      "1408: out:",
      "1409:  return un;",
      "1410: }",
      "",
      "[Removed Lines]",
      "1407:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1489:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "1444:  struct sembuf fast_sops[SEMOPM_FAST];",
      "1445:  struct sembuf* sops = fast_sops, *sop;",
      "1446:  struct sem_undo *un;",
      "1448:  struct sem_queue queue;",
      "1449:  unsigned long jiffies_left = 0;",
      "1450:  struct ipc_namespace *ns;",
      "",
      "[Removed Lines]",
      "1447:  int undos = 0, alter = 0, max;",
      "",
      "[Added Lines]",
      "1529:  int undos = 0, alter = 0, max, locknum;",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "1488:    alter = 1;",
      "1489:  }",
      "1491:  if (undos) {",
      "1492:   un = find_alloc_undo(ns, semid);",
      "1493:   if (IS_ERR(un)) {",
      "1494:    error = PTR_ERR(un);",
      "1495:    goto out_free;",
      "1496:   }",
      "1498:   un = NULL;",
      "1503:  sma = sem_obtain_object_check(ns, semid);",
      "1504:  if (IS_ERR(sma)) {",
      "1507:   error = PTR_ERR(sma);",
      "1508:   goto out_free;",
      "1509:  }",
      "",
      "[Removed Lines]",
      "1497:  } else",
      "1500:  INIT_LIST_HEAD(&tasks);",
      "1502:  rcu_read_lock();",
      "1505:   if (un)",
      "1506:    rcu_read_unlock();",
      "",
      "[Added Lines]",
      "1573:  INIT_LIST_HEAD(&tasks);",
      "1582:  } else {",
      "1584:   rcu_read_lock();",
      "1585:  }",
      "1589:   rcu_read_unlock();",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "1536:  error = -EIDRM;",
      "1555:  error = try_atomic_semop (sma, sops, nsops, un, task_tgid_vnr(current));",
      "1556:  if (error <= 0) {",
      "",
      "[Removed Lines]",
      "1537:  ipc_lock_object(&sma->sem_perm);",
      "1538:  if (un) {",
      "1539:   if (un->semid == -1) {",
      "1540:    rcu_read_unlock();",
      "1541:    goto out_unlock_free;",
      "1542:   } else {",
      "1551:    rcu_read_unlock();",
      "1552:   }",
      "1553:  }",
      "",
      "[Added Lines]",
      "1620:  locknum = sem_lock(sma, sops, nsops);",
      "1621:  if (un && un->semid == -1)",
      "1622:   goto out_unlock_free;",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "1592: sleep_again:",
      "1593:  current->state = TASK_INTERRUPTIBLE;",
      "1596:  if (timeout)",
      "1597:   jiffies_left = schedule_timeout(jiffies_left);",
      "",
      "[Removed Lines]",
      "1594:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1663:  sem_unlock(sma, locknum);",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "1613:   goto out_free;",
      "1614:  }",
      "",
      "[Removed Lines]",
      "1616:  sma = sem_obtain_lock(ns, semid);",
      "",
      "[Added Lines]",
      "1685:  sma = sem_obtain_lock(ns, semid, sops, nsops, &locknum);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "1652:  unlink_queue(sma, &queue);",
      "1654: out_unlock_free:",
      "1656: out_wakeup:",
      "1657:  wake_up_sem_queue_do(&tasks);",
      "1658: out_free:",
      "",
      "[Removed Lines]",
      "1655:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1724:  sem_unlock(sma, locknum);",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "1716:   struct sem_array *sma;",
      "1717:   struct sem_undo *un;",
      "1718:   struct list_head tasks;",
      "1722:   rcu_read_lock();",
      "1723:   un = list_entry_rcu(ulp->list_proc.next,",
      "",
      "[Removed Lines]",
      "1719:   int semid;",
      "1720:   int i;",
      "",
      "[Added Lines]",
      "1788:   int semid, i;",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "1726:    semid = -1;",
      "1727:    else",
      "1728:    semid = un->semid;",
      "1732:    break;",
      "1738:    continue;",
      "1740:   un = __lookup_undo(ulp, semid);",
      "1741:   if (un == NULL) {",
      "1746:    continue;",
      "1747:   }",
      "",
      "[Removed Lines]",
      "1729:   rcu_read_unlock();",
      "1731:   if (semid == -1)",
      "1734:   sma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);",
      "1737:   if (IS_ERR(sma))",
      "1745:    sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1798:   if (semid == -1) {",
      "1799:    rcu_read_unlock();",
      "1801:   }",
      "1803:   sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);",
      "1805:   if (IS_ERR(sma)) {",
      "1806:    rcu_read_unlock();",
      "1808:   }",
      "1810:   sem_lock(sma, NULL, -1);",
      "1816:    sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1783:   INIT_LIST_HEAD(&tasks);",
      "1784:   do_smart_update(sma, NULL, 0, 1, &tasks);",
      "1786:   wake_up_sem_queue_do(&tasks);",
      "1788:   kfree_rcu(un, rcu);",
      "",
      "[Removed Lines]",
      "1785:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1856:   sem_unlock(sma, -1);",
      "",
      "---------------"
    ],
    "ipc/util.c||ipc/util.c": [
      "File: ipc/util.c -> ipc/util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "443: {",
      "445:  if(size > PAGE_SIZE)",
      "446:   out = vmalloc(size);",
      "447:  else",
      "",
      "[Removed Lines]",
      "442: void* ipc_alloc(int size)",
      "444:  void* out;",
      "",
      "[Added Lines]",
      "442: void *ipc_alloc(int size)",
      "444:  void *out;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "479: struct ipc_rcu_hdr",
      "480: {",
      "482:  int is_vmalloc;",
      "483:  void *data[0];",
      "484: };",
      "",
      "[Removed Lines]",
      "481:  int refcount;",
      "",
      "[Added Lines]",
      "481:  atomic_t refcount;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "524: {",
      "530:  if (rcu_use_vmalloc(size)) {",
      "531:   out = vmalloc(HDRLEN_VMALLOC + size);",
      "537:  } else {",
      "538:   out = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);",
      "544:  }",
      "546:  return out;",
      "547: }",
      "550: {",
      "552: }",
      "554: static void ipc_do_vfree(struct work_struct *work)",
      "",
      "[Removed Lines]",
      "523: void* ipc_rcu_alloc(int size)",
      "525:  void* out;",
      "532:   if (out) {",
      "533:    out += HDRLEN_VMALLOC;",
      "534:    container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;",
      "535:    container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;",
      "536:   }",
      "539:   if (out) {",
      "540:    out += HDRLEN_KMALLOC;",
      "541:    container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;",
      "542:    container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;",
      "543:   }",
      "549: void ipc_rcu_getref(void *ptr)",
      "551:  container_of(ptr, struct ipc_rcu_hdr, data)->refcount++;",
      "",
      "[Added Lines]",
      "521: void *ipc_rcu_alloc(int size)",
      "523:  void *out;",
      "531:   if (!out)",
      "532:    goto done;",
      "534:   out += HDRLEN_VMALLOC;",
      "535:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;",
      "538:   if (!out)",
      "539:    goto done;",
      "541:   out += HDRLEN_KMALLOC;",
      "542:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;",
      "546:  atomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);",
      "547: done:",
      "551: int ipc_rcu_getref(void *ptr)",
      "553:  return atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "579: void ipc_rcu_putref(void *ptr)",
      "580: {",
      "582:   return;",
      "584:  if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {",
      "",
      "[Removed Lines]",
      "581:  if (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)",
      "",
      "[Added Lines]",
      "583:  if (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))",
      "",
      "---------------"
    ],
    "ipc/util.h||ipc/util.h": [
      "File: ipc/util.h -> ipc/util.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "121: void* ipc_rcu_alloc(int size);",
      "123: void ipc_rcu_putref(void *ptr);",
      "125: struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);",
      "",
      "[Removed Lines]",
      "122: void ipc_rcu_getref(void *ptr);",
      "",
      "[Added Lines]",
      "122: int ipc_rcu_getref(void *ptr);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "53dad6d3a8e5ac1af8bacc6ac2134ae1a8b085f1",
      "candidate_info": {
        "commit_hash": "53dad6d3a8e5ac1af8bacc6ac2134ae1a8b085f1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/53dad6d3a8e5ac1af8bacc6ac2134ae1a8b085f1",
        "files": [
          "ipc/msg.c",
          "ipc/sem.c",
          "ipc/shm.c",
          "ipc/util.c",
          "ipc/util.h"
        ],
        "message": "ipc: fix race with LSMs\n\nCurrently, IPC mechanisms do security and auditing related checks under\nRCU.  However, since security modules can free the security structure,\nfor example, through selinux_[sem,msg_queue,shm]_free_security(), we can\nrace if the structure is freed before other tasks are done with it,\ncreating a use-after-free condition.  Manfred illustrates this nicely,\nfor instance with shared mem and selinux:\n\n -> do_shmat calls rcu_read_lock()\n -> do_shmat calls shm_object_check().\n     Checks that the object is still valid - but doesn't acquire any locks.\n     Then it returns.\n -> do_shmat calls security_shm_shmat (e.g. selinux_shm_shmat)\n -> selinux_shm_shmat calls ipc_has_perm()\n -> ipc_has_perm accesses ipc_perms->security\n\nshm_close()\n -> shm_close acquires rw_mutex & shm_lock\n -> shm_close calls shm_destroy\n -> shm_destroy calls security_shm_free (e.g. selinux_shm_free_security)\n -> selinux_shm_free_security calls ipc_free_security(&shp->shm_perm)\n -> ipc_free_security calls kfree(ipc_perms->security)\n\nThis patch delays the freeing of the security structures after all RCU\nreaders are done.  Furthermore it aligns the security life cycle with\nthat of the rest of IPC - freeing them based on the reference counter.\nFor situations where we need not free security, the current behavior is\nkept.  Linus states:\n\n \"... the old behavior was suspect for another reason too: having the\n  security blob go away from under a user sounds like it could cause\n  various other problems anyway, so I think the old code was at least\n  _prone_ to bugs even if it didn't have catastrophic behavior.\"\n\nI have tested this patch with IPC testcases from LTP on both my\nquad-core laptop and on a 64 core NUMA server.  In both cases selinux is\nenabled, and tests pass for both voluntary and forced preemption models.\nWhile the mentioned races are theoretical (at least no one as reported\nthem), I wanted to make sure that this new logic doesn't break anything\nwe weren't aware of.\n\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Davidlohr Bueso <davidlohr@hp.com>\nAcked-by: Manfred Spraul <manfred@colorfullife.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/msg.c||ipc/msg.c",
          "ipc/sem.c||ipc/sem.c",
          "ipc/shm.c||ipc/shm.c",
          "ipc/util.c||ipc/util.c",
          "ipc/util.h||ipc/util.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/msg.c||ipc/msg.c",
            "ipc/sem.c||ipc/sem.c",
            "ipc/util.c||ipc/util.c",
            "ipc/util.h||ipc/util.h"
          ],
          "candidate": [
            "ipc/msg.c||ipc/msg.c",
            "ipc/sem.c||ipc/sem.c",
            "ipc/util.c||ipc/util.c",
            "ipc/util.h||ipc/util.h"
          ]
        }
      },
      "candidate_diff": {
        "ipc/msg.c||ipc/msg.c": [
          "File: ipc/msg.c -> ipc/msg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:  ipc_rmid(&msg_ids(ns), &s->q_perm);",
          "166: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168: static void msg_rcu_free(struct rcu_head *head)",
          "169: {",
          "170:  struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);",
          "171:  struct msg_queue *msq = ipc_rcu_to_struct(p);",
          "173:  security_msg_queue_free(msq);",
          "174:  ipc_rcu_free(head);",
          "175: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "189:  msq->q_perm.security = NULL;",
          "190:  retval = security_msg_queue_alloc(msq);",
          "191:  if (retval) {",
          "193:   return retval;",
          "194:  }",
          "197:  id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);",
          "198:  if (id < 0) {",
          "201:   return id;",
          "202:  }",
          "",
          "[Removed Lines]",
          "192:   ipc_rcu_putref(msq);",
          "199:   security_msg_queue_free(msq);",
          "200:   ipc_rcu_putref(msq);",
          "",
          "[Added Lines]",
          "201:   ipc_rcu_putref(msq, ipc_rcu_free);",
          "208:   ipc_rcu_putref(msq, msg_rcu_free);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "276:   free_msg(msg);",
          "277:  }",
          "278:  atomic_sub(msq->q_cbytes, &ns->msg_bytes);",
          "281: }",
          "",
          "[Removed Lines]",
          "279:  security_msg_queue_free(msq);",
          "280:  ipc_rcu_putref(msq);",
          "",
          "[Added Lines]",
          "287:  ipc_rcu_putref(msq, msg_rcu_free);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "717:   rcu_read_lock();",
          "718:   ipc_lock_object(&msq->q_perm);",
          "721:   if (msq->q_perm.deleted) {",
          "722:    err = -EIDRM;",
          "723:    goto out_unlock0;",
          "",
          "[Removed Lines]",
          "720:   ipc_rcu_putref(msq);",
          "",
          "[Added Lines]",
          "727:   ipc_rcu_putref(msq, ipc_rcu_free);",
          "",
          "---------------"
        ],
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "243:  }",
          "244: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: static void sem_rcu_free(struct rcu_head *head)",
          "247: {",
          "248:  struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);",
          "249:  struct sem_array *sma = ipc_rcu_to_struct(p);",
          "251:  security_sem_free(sma);",
          "252:  ipc_rcu_free(head);",
          "253: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "374: static inline void sem_lock_and_putref(struct sem_array *sma)",
          "375: {",
          "376:  sem_lock(sma, NULL, -1);",
          "383: }",
          "385: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
          "",
          "[Removed Lines]",
          "377:  ipc_rcu_putref(sma);",
          "378: }",
          "380: static inline void sem_putref(struct sem_array *sma)",
          "381: {",
          "382:  ipc_rcu_putref(sma);",
          "",
          "[Added Lines]",
          "386:  ipc_rcu_putref(sma, ipc_rcu_free);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "458:  sma->sem_perm.security = NULL;",
          "459:  retval = security_sem_alloc(sma);",
          "460:  if (retval) {",
          "462:   return retval;",
          "463:  }",
          "465:  id = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);",
          "466:  if (id < 0) {",
          "469:   return id;",
          "470:  }",
          "471:  ns->used_sems += nsems;",
          "",
          "[Removed Lines]",
          "461:   ipc_rcu_putref(sma);",
          "467:   security_sem_free(sma);",
          "468:   ipc_rcu_putref(sma);",
          "",
          "[Added Lines]",
          "465:   ipc_rcu_putref(sma, ipc_rcu_free);",
          "471:   ipc_rcu_putref(sma, sem_rcu_free);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1048:  wake_up_sem_queue_do(&tasks);",
          "1049:  ns->used_sems -= sma->sem_nsems;",
          "1052: }",
          "1054: static unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in, int version)",
          "",
          "[Removed Lines]",
          "1050:  security_sem_free(sma);",
          "1051:  ipc_rcu_putref(sma);",
          "",
          "[Added Lines]",
          "1053:  ipc_rcu_putref(sma, sem_rcu_free);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1292:    rcu_read_unlock();",
          "1293:    sem_io = ipc_alloc(sizeof(ushort)*nsems);",
          "1294:    if(sem_io == NULL) {",
          "1296:     return -ENOMEM;",
          "1297:    }",
          "",
          "[Removed Lines]",
          "1295:     sem_putref(sma);",
          "",
          "[Added Lines]",
          "1297:     ipc_rcu_putref(sma, ipc_rcu_free);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1328:   if(nsems > SEMMSL_FAST) {",
          "1329:    sem_io = ipc_alloc(sizeof(ushort)*nsems);",
          "1330:    if(sem_io == NULL) {",
          "1332:     return -ENOMEM;",
          "1333:    }",
          "1334:   }",
          "1336:   if (copy_from_user (sem_io, p, nsems*sizeof(ushort))) {",
          "1338:    err = -EFAULT;",
          "1339:    goto out_free;",
          "1340:   }",
          "1342:   for (i = 0; i < nsems; i++) {",
          "1343:    if (sem_io[i] > SEMVMX) {",
          "1345:     err = -ERANGE;",
          "1346:     goto out_free;",
          "1347:    }",
          "",
          "[Removed Lines]",
          "1331:     sem_putref(sma);",
          "1337:    sem_putref(sma);",
          "1344:     sem_putref(sma);",
          "",
          "[Added Lines]",
          "1333:     ipc_rcu_putref(sma, ipc_rcu_free);",
          "1339:    ipc_rcu_putref(sma, ipc_rcu_free);",
          "1346:     ipc_rcu_putref(sma, ipc_rcu_free);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1630:  new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);",
          "1631:  if (!new) {",
          "1633:   return ERR_PTR(-ENOMEM);",
          "1634:  }",
          "",
          "[Removed Lines]",
          "1632:   sem_putref(sma);",
          "",
          "[Added Lines]",
          "1634:   ipc_rcu_putref(sma, ipc_rcu_free);",
          "",
          "---------------"
        ],
        "ipc/shm.c||ipc/shm.c": [
          "File: ipc/shm.c -> ipc/shm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "167:  ipc_lock_object(&ipcp->shm_perm);",
          "168: }",
          "170: static inline void shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *s)",
          "171: {",
          "172:  ipc_rmid(&shm_ids(ns), &s->shm_perm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170: static void shm_rcu_free(struct rcu_head *head)",
          "171: {",
          "172:  struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);",
          "173:  struct shmid_kernel *shp = ipc_rcu_to_struct(p);",
          "175:  security_shm_free(shp);",
          "176:  ipc_rcu_free(head);",
          "177: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "208:   user_shm_unlock(file_inode(shp->shm_file)->i_size,",
          "209:       shp->mlock_user);",
          "210:  fput (shp->shm_file);",
          "213: }",
          "",
          "[Removed Lines]",
          "211:  security_shm_free(shp);",
          "212:  ipc_rcu_putref(shp);",
          "",
          "[Added Lines]",
          "220:  ipc_rcu_putref(shp, shm_rcu_free);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "497:  shp->shm_perm.security = NULL;",
          "498:  error = security_shm_alloc(shp);",
          "499:  if (error) {",
          "501:   return error;",
          "502:  }",
          "",
          "[Removed Lines]",
          "500:   ipc_rcu_putref(shp);",
          "",
          "[Added Lines]",
          "508:   ipc_rcu_putref(shp, ipc_rcu_free);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "566:   user_shm_unlock(size, shp->mlock_user);",
          "567:  fput(file);",
          "568: no_file:",
          "571:  return error;",
          "572: }",
          "",
          "[Removed Lines]",
          "569:  security_shm_free(shp);",
          "570:  ipc_rcu_putref(shp);",
          "",
          "[Added Lines]",
          "577:  ipc_rcu_putref(shp, shm_rcu_free);",
          "",
          "---------------"
        ],
        "ipc/util.c||ipc/util.c": [
          "File: ipc/util.c -> ipc/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "474:   kfree(ptr);",
          "475: }",
          "",
          "[Removed Lines]",
          "477: struct ipc_rcu {",
          "478:  struct rcu_head rcu;",
          "479:  atomic_t refcount;",
          "480: } ____cacheline_aligned_in_smp;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "505:  return atomic_inc_not_zero(&p->refcount);",
          "506: }",
          "518: {",
          "519:  struct ipc_rcu *p = ((struct ipc_rcu *)ptr) - 1;",
          "521:  if (!atomic_dec_and_test(&p->refcount))",
          "522:   return;",
          "529: }",
          "",
          "[Removed Lines]",
          "512: static void ipc_schedule_free(struct rcu_head *head)",
          "513: {",
          "514:  vfree(container_of(head, struct ipc_rcu, rcu));",
          "515: }",
          "517: void ipc_rcu_putref(void *ptr)",
          "524:  if (is_vmalloc_addr(ptr)) {",
          "525:   call_rcu(&p->rcu, ipc_schedule_free);",
          "526:  } else {",
          "527:   kfree_rcu(p, rcu);",
          "528:  }",
          "",
          "[Added Lines]",
          "503: void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head))",
          "510:  call_rcu(&p->rcu, func);",
          "511: }",
          "513: void ipc_rcu_free(struct rcu_head *head)",
          "514: {",
          "515:  struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);",
          "517:  if (is_vmalloc_addr(p))",
          "518:   vfree(p);",
          "519:  else",
          "520:   kfree(p);",
          "",
          "---------------"
        ],
        "ipc/util.h||ipc/util.h": [
          "File: ipc/util.h -> ipc/util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: static inline void shm_exit_ns(struct ipc_namespace *ns) { }",
          "48: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: struct ipc_rcu {",
          "51:  struct rcu_head rcu;",
          "52:  atomic_t refcount;",
          "53: } ____cacheline_aligned_in_smp;",
          "55: #define ipc_rcu_to_struct(p)  ((void *)(p+1))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "121: void* ipc_rcu_alloc(int size);",
          "122: int ipc_rcu_getref(void *ptr);",
          "125: struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);",
          "126: struct kern_ipc_perm *ipc_obtain_object(struct ipc_ids *ids, int id);",
          "",
          "[Removed Lines]",
          "123: void ipc_rcu_putref(void *ptr);",
          "",
          "[Added Lines]",
          "130: void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head));",
          "131: void ipc_rcu_free(struct rcu_head *head);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c460b662d5cae467f1c341c59b02a5c5e68fed0b",
      "candidate_info": {
        "commit_hash": "c460b662d5cae467f1c341c59b02a5c5e68fed0b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c460b662d5cae467f1c341c59b02a5c5e68fed0b",
        "files": [
          "ipc/sem.c"
        ],
        "message": "ipc,sem: open code and rename sem_lock\n\nRename sem_lock() to sem_obtain_lock(), so we can introduce a sem_lock()\nlater that only locks the sem_array and does nothing else.\n\nOpen code the locking from ipc_lock() in sem_obtain_lock() so we can\nintroduce finer grained locking for the sem_array in the next patch.\n\n[akpm@linux-foundation.org: propagate the ipc_obtain_object() errno out of sem_obtain_lock()]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Emmanuel Benisty <benisty.e@gmail.com>\nCc: Jason Low <jason.low2@hp.com>\nCc: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "198: {",
          "205: }",
          "207: static inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int id)",
          "",
          "[Removed Lines]",
          "197: static inline struct sem_array *sem_lock(struct ipc_namespace *ns, int id)",
          "199:  struct kern_ipc_perm *ipcp = ipc_lock(&sem_ids(ns), id);",
          "201:  if (IS_ERR(ipcp))",
          "202:   return (struct sem_array *)ipcp;",
          "204:  return container_of(ipcp, struct sem_array, sem_perm);",
          "",
          "[Added Lines]",
          "197: static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)",
          "199:  struct kern_ipc_perm *ipcp;",
          "200:  struct sem_array *sma;",
          "202:  rcu_read_lock();",
          "203:  ipcp = ipc_obtain_object(&sem_ids(ns), id);",
          "204:  if (IS_ERR(ipcp)) {",
          "205:   sma = ERR_CAST(ipcp);",
          "206:   goto err;",
          "207:  }",
          "209:  spin_lock(&ipcp->lock);",
          "214:  if (!ipcp->deleted)",
          "215:   return container_of(ipcp, struct sem_array, sem_perm);",
          "217:  spin_unlock(&ipcp->lock);",
          "218:  sma = ERR_PTR(-EINVAL);",
          "219: err:",
          "220:  rcu_read_unlock();",
          "221:  return sma;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1593:   goto out_free;",
          "1594:  }",
          "",
          "[Removed Lines]",
          "1596:  sma = sem_lock(ns, semid);",
          "",
          "[Added Lines]",
          "1613:  sma = sem_obtain_lock(ns, semid);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "196aa0132fc7261f34b10ae1bfb44abc1bc69b3c",
      "candidate_info": {
        "commit_hash": "196aa0132fc7261f34b10ae1bfb44abc1bc69b3c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/196aa0132fc7261f34b10ae1bfb44abc1bc69b3c",
        "files": [
          "ipc/util.c"
        ],
        "message": "ipc/util.c, ipc_rcu_alloc: cacheline align allocation\n\nEnforce that ipc_rcu_alloc returns a cacheline aligned pointer on SMP.\n\nRationale:\n\nThe SysV sem code tries to move the main spinlock into a seperate\ncacheline (____cacheline_aligned_in_smp).  This works only if\nipc_rcu_alloc returns cacheline aligned pointers.  vmalloc and kmalloc\nreturn cacheline algined pointers, the implementation of ipc_rcu_alloc\nbreaks that.\n\n[akpm@linux-foundation.org: coding-style fixes]\nSigned-off-by: Manfred Spraul <manfred@colorfullife.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Davidlohr Bueso <davidlohr.bueso@hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/util.c||ipc/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/util.c||ipc/util.c"
          ],
          "candidate": [
            "ipc/util.c||ipc/util.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/util.c||ipc/util.c": [
          "File: ipc/util.c -> ipc/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "468: struct ipc_rcu {",
          "469:  struct rcu_head rcu;",
          "470:  atomic_t refcount;",
          "",
          "[Removed Lines]",
          "472:  void *data[0];",
          "473: };",
          "",
          "[Added Lines]",
          "471: } ____cacheline_aligned_in_smp;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "488:  if (unlikely(!out))",
          "489:   return NULL;",
          "490:  atomic_set(&out->refcount, 1);",
          "492: }",
          "494: int ipc_rcu_getref(void *ptr)",
          "495: {",
          "497: }",
          "",
          "[Removed Lines]",
          "491:  return out->data;",
          "496:  return atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu, data)->refcount);",
          "",
          "[Added Lines]",
          "489:  return out + 1;",
          "494:  struct ipc_rcu *p = ((struct ipc_rcu *)ptr) - 1;",
          "496:  return atomic_inc_not_zero(&p->refcount);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "508: void ipc_rcu_putref(void *ptr)",
          "509: {",
          "512:  if (!atomic_dec_and_test(&p->refcount))",
          "513:   return;",
          "",
          "[Removed Lines]",
          "510:  struct ipc_rcu *p = container_of(ptr, struct ipc_rcu, data);",
          "",
          "[Added Lines]",
          "510:  struct ipc_rcu *p = ((struct ipc_rcu *)ptr) - 1;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
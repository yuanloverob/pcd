{
  "cve_id": "CVE-2019-19965",
  "cve_desc": "In the Linux kernel through 5.4.6, there is a NULL pointer dereference in drivers/scsi/libsas/sas_discover.c because of mishandling of port disconnection during discovery, related to a PHY down race condition, aka CID-f70267f379b5.",
  "repo": "torvalds/linux",
  "patch_hash": "f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
  "patch_info": {
    "commit_hash": "f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
    "files": [
      "drivers/scsi/libsas/sas_discover.c"
    ],
    "message": "scsi: libsas: stop discovering if oob mode is disconnected\n\nThe discovering of sas port is driven by workqueue in libsas. When libsas\nis processing port events or phy events in workqueue, new events may rise\nup and change the state of some structures such as asd_sas_phy.  This may\ncause some problems such as follows:\n\n==>thread 1                       ==>thread 2\n\n                                  ==>phy up\n                                  ==>phy_up_v3_hw()\n                                    ==>oob_mode = SATA_OOB_MODE;\n                                  ==>phy down quickly\n                                  ==>hisi_sas_phy_down()\n                                    ==>sas_ha->notify_phy_event()\n                                    ==>sas_phy_disconnected()\n                                      ==>oob_mode = OOB_NOT_CONNECTED\n==>workqueue wakeup\n==>sas_form_port()\n  ==>sas_discover_domain()\n    ==>sas_get_port_device()\n      ==>oob_mode is OOB_NOT_CONNECTED and device\n         is wrongly taken as expander\n\nThis at last lead to the panic when libsas trying to issue a command to\ndiscover the device.\n\n[183047.614035] Unable to handle kernel NULL pointer dereference at\nvirtual address 0000000000000058\n[183047.622896] Mem abort info:\n[183047.625762]   ESR = 0x96000004\n[183047.628893]   Exception class = DABT (current EL), IL = 32 bits\n[183047.634888]   SET = 0, FnV = 0\n[183047.638015]   EA = 0, S1PTW = 0\n[183047.641232] Data abort info:\n[183047.644189]   ISV = 0, ISS = 0x00000004\n[183047.648100]   CM = 0, WnR = 0\n[183047.651145] user pgtable: 4k pages, 48-bit VAs, pgdp =\n00000000b7df67be\n[183047.657834] [0000000000000058] pgd=0000000000000000\n[183047.662789] Internal error: Oops: 96000004 [#1] SMP\n[183047.667740] Process kworker/u16:2 (pid: 31291, stack limit =\n0x00000000417c4974)\n[183047.675208] CPU: 0 PID: 3291 Comm: kworker/u16:2 Tainted: G\nW  OE 4.19.36-vhulk1907.1.0.h410.eulerosv2r8.aarch64 #1\n[183047.687015] Hardware name: N/A N/A/Kunpeng Desktop Board D920S10,\nBIOS 0.15 10/22/2019\n[183047.695007] Workqueue: 0000:74:02.0_disco_q sas_discover_domain\n[183047.700999] pstate: 20c00009 (nzCv daif +PAN +UAO)\n[183047.705864] pc : prep_ata_v3_hw+0xf8/0x230 [hisi_sas_v3_hw]\n[183047.711510] lr : prep_ata_v3_hw+0xb0/0x230 [hisi_sas_v3_hw]\n[183047.717153] sp : ffff00000f28ba60\n[183047.720541] x29: ffff00000f28ba60 x28: ffff8026852d7228\n[183047.725925] x27: ffff8027dba3e0a8 x26: ffff8027c05fc200\n[183047.731310] x25: 0000000000000000 x24: ffff8026bafa8dc0\n[183047.736695] x23: ffff8027c05fc218 x22: ffff8026852d7228\n[183047.742079] x21: ffff80007c2f2940 x20: ffff8027c05fc200\n[183047.747464] x19: 0000000000f80800 x18: 0000000000000010\n[183047.752848] x17: 0000000000000000 x16: 0000000000000000\n[183047.758232] x15: ffff000089a5a4ff x14: 0000000000000005\n[183047.763617] x13: ffff000009a5a50e x12: ffff8026bafa1e20\n[183047.769001] x11: ffff0000087453b8 x10: ffff00000f28b870\n[183047.774385] x9 : 0000000000000000 x8 : ffff80007e58f9b0\n[183047.779770] x7 : 0000000000000000 x6 : 000000000000003f\n[183047.785154] x5 : 0000000000000040 x4 : ffffffffffffffe0\n[183047.790538] x3 : 00000000000000f8 x2 : 0000000002000007\n[183047.795922] x1 : 0000000000000008 x0 : 0000000000000000\n[183047.801307] Call trace:\n[183047.803827]  prep_ata_v3_hw+0xf8/0x230 [hisi_sas_v3_hw]\n[183047.809127]  hisi_sas_task_prep+0x750/0x888 [hisi_sas_main]\n[183047.814773]  hisi_sas_task_exec.isra.7+0x88/0x1f0 [hisi_sas_main]\n[183047.820939]  hisi_sas_queue_command+0x28/0x38 [hisi_sas_main]\n[183047.826757]  smp_execute_task_sg+0xec/0x218\n[183047.831013]  smp_execute_task+0x74/0xa0\n[183047.834921]  sas_discover_expander.part.7+0x9c/0x5f8\n[183047.839959]  sas_discover_root_expander+0x90/0x160\n[183047.844822]  sas_discover_domain+0x1b8/0x1e8\n[183047.849164]  process_one_work+0x1b4/0x3f8\n[183047.853246]  worker_thread+0x54/0x470\n[183047.856981]  kthread+0x134/0x138\n[183047.860283]  ret_from_fork+0x10/0x18\n[183047.863931] Code: f9407a80 528000e2 39409281 72a04002 (b9405800)\n[183047.870097] kernel fault(0x1) notification starting on CPU 0\n[183047.875828] kernel fault(0x1) notification finished on CPU 0\n[183047.881559] Modules linked in: unibsp(OE) hns3(OE) hclge(OE)\nhnae3(OE) mem_drv(OE) hisi_sas_v3_hw(OE) hisi_sas_main(OE)\n[183047.892418] ---[ end trace 4cc26083fc11b783  ]---\n[183047.897107] Kernel panic - not syncing: Fatal exception\n[183047.902403] kernel fault(0x5) notification starting on CPU 0\n[183047.908134] kernel fault(0x5) notification finished on CPU 0\n[183047.913865] SMP: stopping secondary CPUs\n[183047.917861] Kernel Offset: disabled\n[183047.921422] CPU features: 0x2,a2a00a38\n[183047.925243] Memory Limit: none\n[183047.928372] kernel reboot(0x2) notification starting on CPU 0\n[183047.934190] kernel reboot(0x2) notification finished on CPU 0\n[183047.940008] ---[ end Kernel panic - not syncing: Fatal exception\n]---\n\nFixes: 2908d778ab3e (\"[SCSI] aic94xx: new driver\")\nLink: https://lore.kernel.org/r/20191206011118.46909-1-yanaijie@huawei.com\nReported-by: Gao Chuan <gaochuan4@huawei.com>\nReviewed-by: John Garry <john.garry@huawei.com>\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "before_after_code_files": [
      "drivers/scsi/libsas/sas_discover.c||drivers/scsi/libsas/sas_discover.c"
    ]
  },
  "patch_diff": {
    "drivers/scsi/libsas/sas_discover.c||drivers/scsi/libsas/sas_discover.c": [
      "File: drivers/scsi/libsas/sas_discover.c -> drivers/scsi/libsas/sas_discover.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "81:   else",
      "82:    dev->dev_type = SAS_SATA_DEV;",
      "83:   dev->tproto = SAS_PROTOCOL_SATA;",
      "85:   struct sas_identify_frame *id =",
      "86:    (struct sas_identify_frame *) dev->frame_rcvd;",
      "87:   dev->dev_type = id->dev_type;",
      "88:   dev->iproto = id->initiator_bits;",
      "89:   dev->tproto = id->target_bits;",
      "90:  }",
      "92:  sas_init_dev(dev);",
      "",
      "[Removed Lines]",
      "84:  } else {",
      "",
      "[Added Lines]",
      "84:  } else if (port->oob_mode == SAS_OOB_MODE) {",
      "90:  } else {",
      "95:   sas_put_device(dev);",
      "96:   pr_warn(\"Port %016llx is disconnected when discovering\\n\",",
      "97:    SAS_ADDR(port->attached_sas_addr));",
      "98:   return -ENODEV;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "894c9ef9780c5cf2f143415e867ee39a33ecb75d",
      "candidate_info": {
        "commit_hash": "894c9ef9780c5cf2f143415e867ee39a33ecb75d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/894c9ef9780c5cf2f143415e867ee39a33ecb75d",
        "files": [
          "include/linux/cpuhotplug.h",
          "kernel/padata.c"
        ],
        "message": "padata: validate cpumask without removed CPU during offline\n\nConfiguring an instance's parallel mask without any online CPUs...\n\n  echo 2 > /sys/kernel/pcrypt/pencrypt/parallel_cpumask\n  echo 0 > /sys/devices/system/cpu/cpu1/online\n\n...makes tcrypt mode=215 crash like this:\n\n  divide error: 0000 [#1] SMP PTI\n  CPU: 4 PID: 283 Comm: modprobe Not tainted 5.4.0-rc8-padata-doc-v2+ #2\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191013_105130-anatol 04/01/2014\n  RIP: 0010:padata_do_parallel+0x114/0x300\n  Call Trace:\n   pcrypt_aead_encrypt+0xc0/0xd0 [pcrypt]\n   crypto_aead_encrypt+0x1f/0x30\n   do_mult_aead_op+0x4e/0xdf [tcrypt]\n   test_mb_aead_speed.constprop.0.cold+0x226/0x564 [tcrypt]\n   do_test+0x28c2/0x4d49 [tcrypt]\n   tcrypt_mod_init+0x55/0x1000 [tcrypt]\n   ...\n\ncpumask_weight() in padata_cpu_hash() returns 0 because the mask has no\nCPUs.  The problem is __padata_remove_cpu() checks for valid masks too\nearly and so doesn't mark the instance PADATA_INVALID as expected, which\nwould have made padata_do_parallel() return error before doing the\ndivision.\n\nFix by introducing a second padata CPU hotplug state before\nCPUHP_BRINGUP_CPU so that __padata_remove_cpu() sees the online mask\nwithout @cpu.  No need for the second argument to padata_replace() since\n@cpu is now already missing from the online mask.\n\nFixes: 33e54450683c (\"padata: Handle empty padata cpumasks\")\nSigned-off-by: Daniel Jordan <daniel.m.jordan@oracle.com>\nCc: Eric Biggers <ebiggers@kernel.org>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nCc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: linux-crypto@vger.kernel.org\nCc: linux-kernel@vger.kernel.org\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
        "before_after_code_files": [
          "include/linux/cpuhotplug.h||include/linux/cpuhotplug.h",
          "kernel/padata.c||kernel/padata.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/linux/cpuhotplug.h||include/linux/cpuhotplug.h": [
          "File: include/linux/cpuhotplug.h -> include/linux/cpuhotplug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:  CPUHP_IOMMU_INTEL_DEAD,",
          "60:  CPUHP_LUSTRE_CFS_DEAD,",
          "61:  CPUHP_AP_ARM_CACHE_B15_RAC_DEAD,",
          "62:  CPUHP_WORKQUEUE_PREP,",
          "63:  CPUHP_POWER_NUMA_PREPARE,",
          "64:  CPUHP_HRTIMERS_PREPARE,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62:  CPUHP_PADATA_DEAD,",
          "",
          "---------------"
        ],
        "kernel/padata.c||kernel/padata.c": [
          "File: kernel/padata.c -> kernel/padata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "512:  return 0;",
          "513: }",
          "516: {",
          "517:  int notification_mask = 0;",
          "518:  struct padata_shell *ps;",
          "",
          "[Removed Lines]",
          "515: static int padata_replace(struct padata_instance *pinst, int cpu)",
          "",
          "[Added Lines]",
          "515: static int padata_replace(struct padata_instance *pinst)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "523:  cpumask_copy(pinst->omask, pinst->rcpumask.pcpu);",
          "524:  cpumask_and(pinst->rcpumask.pcpu, pinst->cpumask.pcpu,",
          "525:       cpu_online_mask);",
          "528:  if (!cpumask_equal(pinst->omask, pinst->rcpumask.pcpu))",
          "529:   notification_mask |= PADATA_CPU_PARALLEL;",
          "531:  cpumask_copy(pinst->omask, pinst->rcpumask.cbcpu);",
          "532:  cpumask_and(pinst->rcpumask.cbcpu, pinst->cpumask.cbcpu,",
          "533:       cpu_online_mask);",
          "536:  if (!cpumask_equal(pinst->omask, pinst->rcpumask.cbcpu))",
          "537:   notification_mask |= PADATA_CPU_SERIAL;",
          "",
          "[Removed Lines]",
          "526:  if (cpu >= 0)",
          "527:   cpumask_clear_cpu(cpu, pinst->rcpumask.pcpu);",
          "534:  if (cpu >= 0)",
          "535:   cpumask_clear_cpu(cpu, pinst->rcpumask.cbcpu);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "624:  cpumask_copy(pinst->cpumask.pcpu, pcpumask);",
          "625:  cpumask_copy(pinst->cpumask.cbcpu, cbcpumask);",
          "629:  if (valid)",
          "630:   __padata_start(pinst);",
          "",
          "[Removed Lines]",
          "627:  err = padata_setup_cpumasks(pinst) ?: padata_replace(pinst, -1);",
          "",
          "[Added Lines]",
          "623:  err = padata_setup_cpumasks(pinst) ?: padata_replace(pinst);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "715:  int err = 0;",
          "717:  if (cpumask_test_cpu(cpu, cpu_online_mask)) {",
          "720:   if (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&",
          "721:       padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))",
          "",
          "[Removed Lines]",
          "718:   err = padata_replace(pinst, -1);",
          "",
          "[Added Lines]",
          "714:   err = padata_replace(pinst);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "729: {",
          "730:  int err = 0;",
          "733:   if (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||",
          "734:       !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))",
          "735:    __padata_stop(pinst);",
          "738:  }",
          "740:  return err;",
          "",
          "[Removed Lines]",
          "732:  if (cpumask_test_cpu(cpu, cpu_online_mask)) {",
          "737:   err = padata_replace(pinst, cpu);",
          "",
          "[Added Lines]",
          "728:  if (!cpumask_test_cpu(cpu, cpu_online_mask)) {",
          "733:   err = padata_replace(pinst);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "761:  return ret;",
          "762: }",
          "765: {",
          "766:  struct padata_instance *pinst;",
          "767:  int ret;",
          "",
          "[Removed Lines]",
          "764: static int padata_cpu_prep_down(unsigned int cpu, struct hlist_node *node)",
          "",
          "[Added Lines]",
          "760: static int padata_cpu_dead(unsigned int cpu, struct hlist_node *node)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "782: static void __padata_free(struct padata_instance *pinst)",
          "783: {",
          "784: #ifdef CONFIG_HOTPLUG_CPU",
          "785:  cpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);",
          "786: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "781:  cpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD, &pinst->node);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "990: #ifdef CONFIG_HOTPLUG_CPU",
          "991:  cpuhp_state_add_instance_nocalls_cpuslocked(hp_online, &pinst->node);",
          "992: #endif",
          "994:  put_online_cpus();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "989:  cpuhp_state_add_instance_nocalls_cpuslocked(CPUHP_PADATA_DEAD,",
          "990:           &pinst->node);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1101:  int ret;",
          "1103:  ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"padata:online\",",
          "1106:  if (ret < 0)",
          "1107:   return ret;",
          "1108:  hp_online = ret;",
          "1109:  return 0;",
          "1110: }",
          "1111: module_init(padata_driver_init);",
          "1113: static __exit void padata_driver_exit(void)",
          "1114: {",
          "1115:  cpuhp_remove_multi_state(hp_online);",
          "1116: }",
          "1117: module_exit(padata_driver_exit);",
          "",
          "[Removed Lines]",
          "1104:           padata_cpu_online,",
          "1105:           padata_cpu_prep_down);",
          "",
          "[Added Lines]",
          "1103:           padata_cpu_online, NULL);",
          "1108:  ret = cpuhp_setup_state_multi(CPUHP_PADATA_DEAD, \"padata:dead\",",
          "1109:           NULL, padata_cpu_dead);",
          "1110:  if (ret < 0) {",
          "1111:   cpuhp_remove_multi_state(hp_online);",
          "1112:   return ret;",
          "1113:  }",
          "1120:  cpuhp_remove_multi_state(CPUHP_PADATA_DEAD);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8b1c78e06e6167f49beb27be073faa2c6c5c6eff",
      "candidate_info": {
        "commit_hash": "8b1c78e06e6167f49beb27be073faa2c6c5c6eff",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8b1c78e06e6167f49beb27be073faa2c6c5c6eff",
        "files": [
          "drivers/gpu/drm/i915/display/intel_display.c",
          "drivers/gpu/drm/i915/display/intel_overlay.c",
          "drivers/gpu/drm/i915/gem/i915_gem_domain.c"
        ],
        "message": "drm/i915: Avoid calling i915_gem_object_unbind holding object lock\n\nIn the extreme case, we may wish to wait on an rcu-barrier to reap stale\nvm to purge the last of the object bindings. However, we are not allowed\nto use rcu_barrier() beneath the dma_resv (i.e. object) lock and do not\ntake lightly the prospect of unlocking a mutex deep in the bowels of the\nroutine. i915_gem_object_unbind() itself does not need the object lock,\nand it turns out the callers do not need to the unbind as part of a\nlocked sequence around set-cache-level, so rearrange the code to avoid\ntaking the object lock in the callers.\n\n<4> [186.816311] ======================================================\n<4> [186.816313] WARNING: possible circular locking dependency detected\n<4> [186.816316] 5.4.0-rc8-CI-CI_DRM_7486+ #1 Tainted: G     U\n<4> [186.816318] ------------------------------------------------------\n<4> [186.816320] perf_pmu/1321 is trying to acquire lock:\n<4> [186.816322] ffff88849487c4d8 (&mm->mmap_sem#2){++++}, at: __might_fault+0x39/0x90\n<4> [186.816331]\nbut task is already holding lock:\n<4> [186.816333] ffffe8ffffa05008 (&cpuctx_mutex){+.+.}, at: perf_event_ctx_lock_nested+0xa9/0x1b0\n<4> [186.816339]\nwhich lock already depends on the new lock.\n\n<4> [186.816341]\nthe existing dependency chain (in reverse order) is:\n<4> [186.816343]\n-> #6 (&cpuctx_mutex){+.+.}:\n<4> [186.816349]        __mutex_lock+0x9a/0x9d0\n<4> [186.816352]        perf_event_init_cpu+0xa4/0x140\n<4> [186.816357]        perf_event_init+0x19d/0x1cd\n<4> [186.816362]        start_kernel+0x372/0x4f4\n<4> [186.816365]        secondary_startup_64+0xa4/0xb0\n<4> [186.816381]\n-> #5 (pmus_lock){+.+.}:\n<4> [186.816385]        __mutex_lock+0x9a/0x9d0\n<4> [186.816387]        perf_event_init_cpu+0x6b/0x140\n<4> [186.816404]        cpuhp_invoke_callback+0x9b/0x9d0\n<4> [186.816406]        _cpu_up+0xa2/0x140\n<4> [186.816409]        do_cpu_up+0x61/0xa0\n<4> [186.816411]        smp_init+0x57/0x96\n<4> [186.816413]        kernel_init_freeable+0xac/0x1c7\n<4> [186.816416]        kernel_init+0x5/0x100\n<4> [186.816419]        ret_from_fork+0x24/0x50\n<4> [186.816421]\n-> #4 (cpu_hotplug_lock.rw_sem){++++}:\n<4> [186.816424]        cpus_read_lock+0x34/0xd0\n<4> [186.816427]        rcu_barrier+0xaa/0x190\n<4> [186.816429]        kernel_init+0x21/0x100\n<4> [186.816431]        ret_from_fork+0x24/0x50\n<4> [186.816433]\n-> #3 (rcu_state.barrier_mutex){+.+.}:\n<4> [186.816436]        __mutex_lock+0x9a/0x9d0\n<4> [186.816438]        rcu_barrier+0x23/0x190\n<4> [186.816502]        i915_gem_object_unbind+0x3a6/0x400 [i915]\n<4> [186.816537]        i915_gem_object_set_cache_level+0x32/0x90 [i915]\n<4> [186.816571]        i915_gem_object_pin_to_display_plane+0x5d/0x160 [i915]\n<4> [186.816612]        intel_pin_and_fence_fb_obj+0x9e/0x200 [i915]\n<4> [186.816679]        intel_plane_pin_fb+0x3f/0xd0 [i915]\n<4> [186.816717]        intel_prepare_plane_fb+0x130/0x520 [i915]\n<4> [186.816722]        drm_atomic_helper_prepare_planes+0x85/0x110\n<4> [186.816761]        intel_atomic_commit+0xc6/0x350 [i915]\n<4> [186.816764]        drm_atomic_helper_update_plane+0xed/0x110\n<4> [186.816768]        setplane_internal+0x97/0x190\n<4> [186.816770]        drm_mode_setplane+0xcd/0x190\n<4> [186.816773]        drm_ioctl_kernel+0xa7/0xf0\n<4> [186.816775]        drm_ioctl+0x2e1/0x390\n<4> [186.816778]        do_vfs_ioctl+0xa0/0x6f0\n<4> [186.816780]        ksys_ioctl+0x35/0x60\n<4> [186.816782]        __x64_sys_ioctl+0x11/0x20\n<4> [186.816785]        do_syscall_64+0x4f/0x210\n<4> [186.816787]        entry_SYSCALL_64_after_hwframe+0x49/0xbe\n<4> [186.816789]\n-> #2 (reservation_ww_class_mutex){+.+.}:\n<4> [186.816793]        __ww_mutex_lock.constprop.15+0xc3/0x1090\n<4> [186.816795]        ww_mutex_lock+0x39/0x70\n<4> [186.816798]        dma_resv_lockdep+0x10e/0x1f7\n<4> [186.816800]        do_one_initcall+0x58/0x2ff\n<4> [186.816802]        kernel_init_freeable+0x137/0x1c7\n<4> [186.816804]        kernel_init+0x5/0x100\n<4> [186.816806]        ret_from_fork+0x24/0x50\n<4> [186.816808]\n-> #1 (reservation_ww_class_acquire){+.+.}:\n<4> [186.816811]        dma_resv_lockdep+0xec/0x1f7\n<4> [186.816813]        do_one_initcall+0x58/0x2ff\n<4> [186.816815]        kernel_init_freeable+0x137/0x1c7\n<4> [186.816817]        kernel_init+0x5/0x100\n<4> [186.816819]        ret_from_fork+0x24/0x50\n<4> [186.816820]\n-> #0 (&mm->mmap_sem#2){++++}:\n<4> [186.816824]        __lock_acquire+0x1328/0x15d0\n<4> [186.816826]        lock_acquire+0xa7/0x1c0\n<4> [186.816828]        __might_fault+0x63/0x90\n<4> [186.816831]        _copy_to_user+0x1e/0x80\n<4> [186.816834]        perf_read+0x200/0x2b0\n<4> [186.816836]        vfs_read+0x96/0x160\n<4> [186.816838]        ksys_read+0x9f/0xe0\n<4> [186.816839]        do_syscall_64+0x4f/0x210\n<4> [186.816841]        entry_SYSCALL_64_after_hwframe+0x49/0xbe\n<4> [186.816843]\nother info that might help us debug this:\n\n<4> [186.816846] Chain exists of:\n  &mm->mmap_sem#2 --> pmus_lock --> &cpuctx_mutex\n\n<4> [186.816849]  Possible unsafe locking scenario:\n\n<4> [186.816851]        CPU0                    CPU1\n<4> [186.816853]        ----                    ----\n<4> [186.816854]   lock(&cpuctx_mutex);\n<4> [186.816856]                                lock(pmus_lock);\n<4> [186.816858]                                lock(&cpuctx_mutex);\n<4> [186.816860]   lock(&mm->mmap_sem#2);\n<4> [186.816861]\n *** DEADLOCK ***\n\nCloses: https://gitlab.freedesktop.org/drm/intel/issues/728\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nReviewed-by: Andi Shyti <andi.shyti@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20191206105527.1130413-5-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/display/intel_display.c||drivers/gpu/drm/i915/display/intel_display.c",
          "drivers/gpu/drm/i915/display/intel_overlay.c||drivers/gpu/drm/i915/display/intel_overlay.c",
          "drivers/gpu/drm/i915/gem/i915_gem_domain.c||drivers/gpu/drm/i915/gem/i915_gem_domain.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/display/intel_display.c||drivers/gpu/drm/i915/display/intel_display.c": [
          "File: drivers/gpu/drm/i915/display/intel_display.c -> drivers/gpu/drm/i915/display/intel_display.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2167:  wakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);",
          "2170:  atomic_inc(&dev_priv->gpu_error.pending_fb_pin);",
          "2181:  if (HAS_GMCH(dev_priv))",
          "2182:   pinctl |= PIN_MAPPABLE;",
          "",
          "[Removed Lines]",
          "2168:  i915_gem_object_lock(obj);",
          "2172:  pinctl = 0;",
          "",
          "[Added Lines]",
          "2179:  pinctl = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2219:  i915_vma_get(vma);",
          "2220: err:",
          "2221:  atomic_dec(&dev_priv->gpu_error.pending_fb_pin);",
          "2224:  intel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);",
          "2225:  return vma;",
          "2226: }",
          "",
          "[Removed Lines]",
          "2223:  i915_gem_object_unlock(obj);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/display/intel_overlay.c||drivers/gpu/drm/i915/display/intel_overlay.c": [
          "File: drivers/gpu/drm/i915/display/intel_overlay.c -> drivers/gpu/drm/i915/display/intel_overlay.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "759:  atomic_inc(&dev_priv->gpu_error.pending_fb_pin);",
          "762:  vma = i915_gem_object_pin_to_display_plane(new_bo,",
          "763:          0, NULL, PIN_MAPPABLE);",
          "765:  if (IS_ERR(vma)) {",
          "766:   ret = PTR_ERR(vma);",
          "767:   goto out_pin_section;",
          "",
          "[Removed Lines]",
          "761:  i915_gem_object_lock(new_bo);",
          "764:  i915_gem_object_unlock(new_bo);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/gem/i915_gem_domain.c||drivers/gpu/drm/i915/gem/i915_gem_domain.c": [
          "File: drivers/gpu/drm/i915/gem/i915_gem_domain.c -> drivers/gpu/drm/i915/gem/i915_gem_domain.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187: {",
          "188:  int ret;",
          "192:  if (obj->cache_level == cache_level)",
          "193:   return 0;",
          "196:  if (ret)",
          "197:   return ret;",
          "205: }",
          "207: int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,",
          "",
          "[Removed Lines]",
          "190:  assert_object_held(obj);",
          "195:  ret = i915_gem_object_unbind(obj, I915_GEM_OBJECT_UNBIND_ACTIVE);",
          "201:  i915_gem_object_set_cache_coherency(obj, cache_level);",
          "204:  return 0;",
          "",
          "[Added Lines]",
          "193:  ret = i915_gem_object_lock_interruptible(obj);",
          "198:  if (obj->cache_level != cache_level) {",
          "199:   i915_gem_object_set_cache_coherency(obj, cache_level);",
          "200:   obj->cache_dirty = true;",
          "201:  }",
          "203:  i915_gem_object_unlock(obj);",
          "206:  return i915_gem_object_unbind(obj, I915_GEM_OBJECT_UNBIND_ACTIVE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "282:   goto out;",
          "283:  }",
          "300: out:",
          "301:  i915_gem_object_put(obj);",
          "",
          "[Removed Lines]",
          "285:  if (obj->cache_level == level)",
          "286:   goto out;",
          "288:  ret = i915_gem_object_wait(obj,",
          "289:        I915_WAIT_INTERRUPTIBLE,",
          "290:        MAX_SCHEDULE_TIMEOUT);",
          "291:  if (ret)",
          "292:   goto out;",
          "294:  ret = i915_gem_object_lock_interruptible(obj);",
          "295:  if (ret == 0) {",
          "296:   ret = i915_gem_object_set_cache_level(obj, level);",
          "297:   i915_gem_object_unlock(obj);",
          "298:  }",
          "",
          "[Added Lines]",
          "287:  ret = i915_gem_object_set_cache_level(obj, level);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "318:  struct i915_vma *vma;",
          "319:  int ret;",
          "324:  if (HAS_LMEM(i915) && !i915_gem_object_is_lmem(obj))",
          "325:   return ERR_PTR(-EINVAL);",
          "",
          "[Removed Lines]",
          "321:  assert_object_held(obj);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "363:  vma->display_alignment = max_t(u64, vma->display_alignment, alignment);",
          "373:  return vma;",
          "374: }",
          "",
          "[Removed Lines]",
          "365:  __i915_gem_object_flush_for_display(obj);",
          "371:  obj->read_domains |= I915_GEM_DOMAIN_GTT;",
          "",
          "[Added Lines]",
          "352:  i915_gem_object_flush_if_display(obj);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a470552ee8965da0fe6fd4df0aa39c4cda652c7c",
      "candidate_info": {
        "commit_hash": "a470552ee8965da0fe6fd4df0aa39c4cda652c7c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a470552ee8965da0fe6fd4df0aa39c4cda652c7c",
        "files": [
          "drivers/firmware/efi/rci2-table.c"
        ],
        "message": "efi: Don't attempt to map RCI2 config table if it doesn't exist\n\nCommit:\n\n  1c5fecb61255aa12 (\"efi: Export Runtime Configuration Interface table to sysfs\")\n\n... added support for a Dell specific UEFI configuration table, but\nfailed to take into account that mapping the table should not be\nattempted unless the table actually exists. If it doesn't exist,\nthe code usually fails silently unless pr_debug() prints are\nenabled. However, on 32-bit PAE x86, the splat below is produced due\nto the attempt to map the placeholder value EFI_INVALID_TABLE_ADDR\nwhich we use for non-existing UEFI configuration tables, and which\nequals ULONG_MAX.\n\n   memremap attempted on mixed range 0x00000000ffffffff size: 0x1e\n   WARNING: CPU: 1 PID: 1 at kernel/iomem.c:81 memremap+0x1a3/0x1c0\n   Modules linked in:\n   CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.4.2-smp-mine #1\n   Hardware name: Hewlett-Packard HP Z400 Workstation/0B4Ch, BIOS 786G3 v03.61 03/05/2018\n   EIP: memremap+0x1a3/0x1c0\n  ...\n   Call Trace:\n    ? map_properties+0x473/0x473\n    ? efi_rci2_sysfs_init+0x2c/0x154\n    ? map_properties+0x473/0x473\n    ? do_one_initcall+0x49/0x1d4\n    ? parse_args+0x1e8/0x2a0\n    ? do_early_param+0x7a/0x7a\n    ? kernel_init_freeable+0x139/0x1c2\n    ? rest_init+0x8e/0x8e\n    ? kernel_init+0xd/0xf2\n    ? ret_from_fork+0x2e/0x38\n\nFix this by checking whether the table exists before attempting to map it.\n\nReported-by: Richard Narron <comet.berkeley@gmail.com>\nTested-by: Richard Narron <comet.berkeley@gmail.com>\nSigned-off-by: Ard Biesheuvel <ardb@kernel.org>\nCc: linux-efi@vger.kernel.org\nFixes: 1c5fecb61255aa12 (\"efi: Export Runtime Configuration Interface table to sysfs\")\nLink: https://lkml.kernel.org/r/20191210090945.11501-2-ardb@kernel.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "drivers/firmware/efi/rci2-table.c||drivers/firmware/efi/rci2-table.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/firmware/efi/rci2-table.c||drivers/firmware/efi/rci2-table.c": [
          "File: drivers/firmware/efi/rci2-table.c -> drivers/firmware/efi/rci2-table.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:  struct kobject *tables_kobj;",
          "82:  int ret = -ENOMEM;",
          "84:  rci2_base = memremap(rci2_table_phys,",
          "85:         sizeof(struct rci2_table_global_hdr),",
          "86:         MEMREMAP_WB);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84:  if (rci2_table_phys == EFI_INVALID_TABLE_ADDR)",
          "85:   return 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
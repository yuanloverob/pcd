{
  "cve_id": "CVE-2019-19965",
  "cve_desc": "In the Linux kernel through 5.4.6, there is a NULL pointer dereference in drivers/scsi/libsas/sas_discover.c because of mishandling of port disconnection during discovery, related to a PHY down race condition, aka CID-f70267f379b5.",
  "repo": "torvalds/linux",
  "patch_hash": "f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
  "patch_info": {
    "commit_hash": "f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
    "files": [
      "drivers/scsi/libsas/sas_discover.c"
    ],
    "message": "scsi: libsas: stop discovering if oob mode is disconnected\n\nThe discovering of sas port is driven by workqueue in libsas. When libsas\nis processing port events or phy events in workqueue, new events may rise\nup and change the state of some structures such as asd_sas_phy.  This may\ncause some problems such as follows:\n\n==>thread 1                       ==>thread 2\n\n                                  ==>phy up\n                                  ==>phy_up_v3_hw()\n                                    ==>oob_mode = SATA_OOB_MODE;\n                                  ==>phy down quickly\n                                  ==>hisi_sas_phy_down()\n                                    ==>sas_ha->notify_phy_event()\n                                    ==>sas_phy_disconnected()\n                                      ==>oob_mode = OOB_NOT_CONNECTED\n==>workqueue wakeup\n==>sas_form_port()\n  ==>sas_discover_domain()\n    ==>sas_get_port_device()\n      ==>oob_mode is OOB_NOT_CONNECTED and device\n         is wrongly taken as expander\n\nThis at last lead to the panic when libsas trying to issue a command to\ndiscover the device.\n\n[183047.614035] Unable to handle kernel NULL pointer dereference at\nvirtual address 0000000000000058\n[183047.622896] Mem abort info:\n[183047.625762]   ESR = 0x96000004\n[183047.628893]   Exception class = DABT (current EL), IL = 32 bits\n[183047.634888]   SET = 0, FnV = 0\n[183047.638015]   EA = 0, S1PTW = 0\n[183047.641232] Data abort info:\n[183047.644189]   ISV = 0, ISS = 0x00000004\n[183047.648100]   CM = 0, WnR = 0\n[183047.651145] user pgtable: 4k pages, 48-bit VAs, pgdp =\n00000000b7df67be\n[183047.657834] [0000000000000058] pgd=0000000000000000\n[183047.662789] Internal error: Oops: 96000004 [#1] SMP\n[183047.667740] Process kworker/u16:2 (pid: 31291, stack limit =\n0x00000000417c4974)\n[183047.675208] CPU: 0 PID: 3291 Comm: kworker/u16:2 Tainted: G\nW  OE 4.19.36-vhulk1907.1.0.h410.eulerosv2r8.aarch64 #1\n[183047.687015] Hardware name: N/A N/A/Kunpeng Desktop Board D920S10,\nBIOS 0.15 10/22/2019\n[183047.695007] Workqueue: 0000:74:02.0_disco_q sas_discover_domain\n[183047.700999] pstate: 20c00009 (nzCv daif +PAN +UAO)\n[183047.705864] pc : prep_ata_v3_hw+0xf8/0x230 [hisi_sas_v3_hw]\n[183047.711510] lr : prep_ata_v3_hw+0xb0/0x230 [hisi_sas_v3_hw]\n[183047.717153] sp : ffff00000f28ba60\n[183047.720541] x29: ffff00000f28ba60 x28: ffff8026852d7228\n[183047.725925] x27: ffff8027dba3e0a8 x26: ffff8027c05fc200\n[183047.731310] x25: 0000000000000000 x24: ffff8026bafa8dc0\n[183047.736695] x23: ffff8027c05fc218 x22: ffff8026852d7228\n[183047.742079] x21: ffff80007c2f2940 x20: ffff8027c05fc200\n[183047.747464] x19: 0000000000f80800 x18: 0000000000000010\n[183047.752848] x17: 0000000000000000 x16: 0000000000000000\n[183047.758232] x15: ffff000089a5a4ff x14: 0000000000000005\n[183047.763617] x13: ffff000009a5a50e x12: ffff8026bafa1e20\n[183047.769001] x11: ffff0000087453b8 x10: ffff00000f28b870\n[183047.774385] x9 : 0000000000000000 x8 : ffff80007e58f9b0\n[183047.779770] x7 : 0000000000000000 x6 : 000000000000003f\n[183047.785154] x5 : 0000000000000040 x4 : ffffffffffffffe0\n[183047.790538] x3 : 00000000000000f8 x2 : 0000000002000007\n[183047.795922] x1 : 0000000000000008 x0 : 0000000000000000\n[183047.801307] Call trace:\n[183047.803827]  prep_ata_v3_hw+0xf8/0x230 [hisi_sas_v3_hw]\n[183047.809127]  hisi_sas_task_prep+0x750/0x888 [hisi_sas_main]\n[183047.814773]  hisi_sas_task_exec.isra.7+0x88/0x1f0 [hisi_sas_main]\n[183047.820939]  hisi_sas_queue_command+0x28/0x38 [hisi_sas_main]\n[183047.826757]  smp_execute_task_sg+0xec/0x218\n[183047.831013]  smp_execute_task+0x74/0xa0\n[183047.834921]  sas_discover_expander.part.7+0x9c/0x5f8\n[183047.839959]  sas_discover_root_expander+0x90/0x160\n[183047.844822]  sas_discover_domain+0x1b8/0x1e8\n[183047.849164]  process_one_work+0x1b4/0x3f8\n[183047.853246]  worker_thread+0x54/0x470\n[183047.856981]  kthread+0x134/0x138\n[183047.860283]  ret_from_fork+0x10/0x18\n[183047.863931] Code: f9407a80 528000e2 39409281 72a04002 (b9405800)\n[183047.870097] kernel fault(0x1) notification starting on CPU 0\n[183047.875828] kernel fault(0x1) notification finished on CPU 0\n[183047.881559] Modules linked in: unibsp(OE) hns3(OE) hclge(OE)\nhnae3(OE) mem_drv(OE) hisi_sas_v3_hw(OE) hisi_sas_main(OE)\n[183047.892418] ---[ end trace 4cc26083fc11b783  ]---\n[183047.897107] Kernel panic - not syncing: Fatal exception\n[183047.902403] kernel fault(0x5) notification starting on CPU 0\n[183047.908134] kernel fault(0x5) notification finished on CPU 0\n[183047.913865] SMP: stopping secondary CPUs\n[183047.917861] Kernel Offset: disabled\n[183047.921422] CPU features: 0x2,a2a00a38\n[183047.925243] Memory Limit: none\n[183047.928372] kernel reboot(0x2) notification starting on CPU 0\n[183047.934190] kernel reboot(0x2) notification finished on CPU 0\n[183047.940008] ---[ end Kernel panic - not syncing: Fatal exception\n]---\n\nFixes: 2908d778ab3e (\"[SCSI] aic94xx: new driver\")\nLink: https://lore.kernel.org/r/20191206011118.46909-1-yanaijie@huawei.com\nReported-by: Gao Chuan <gaochuan4@huawei.com>\nReviewed-by: John Garry <john.garry@huawei.com>\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "before_after_code_files": [
      "drivers/scsi/libsas/sas_discover.c||drivers/scsi/libsas/sas_discover.c"
    ]
  },
  "patch_diff": {
    "drivers/scsi/libsas/sas_discover.c||drivers/scsi/libsas/sas_discover.c": [
      "File: drivers/scsi/libsas/sas_discover.c -> drivers/scsi/libsas/sas_discover.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "81:   else",
      "82:    dev->dev_type = SAS_SATA_DEV;",
      "83:   dev->tproto = SAS_PROTOCOL_SATA;",
      "85:   struct sas_identify_frame *id =",
      "86:    (struct sas_identify_frame *) dev->frame_rcvd;",
      "87:   dev->dev_type = id->dev_type;",
      "88:   dev->iproto = id->initiator_bits;",
      "89:   dev->tproto = id->target_bits;",
      "90:  }",
      "92:  sas_init_dev(dev);",
      "",
      "[Removed Lines]",
      "84:  } else {",
      "",
      "[Added Lines]",
      "84:  } else if (port->oob_mode == SAS_OOB_MODE) {",
      "90:  } else {",
      "95:   sas_put_device(dev);",
      "96:   pr_warn(\"Port %016llx is disconnected when discovering\\n\",",
      "97:    SAS_ADDR(port->attached_sas_addr));",
      "98:   return -ENODEV;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6f7ac8285371fb0df58aba861eaab387f79ed04d",
      "candidate_info": {
        "commit_hash": "6f7ac8285371fb0df58aba861eaab387f79ed04d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6f7ac8285371fb0df58aba861eaab387f79ed04d",
        "files": [
          "drivers/gpu/drm/i915/gt/intel_lrc.c"
        ],
        "message": "drm/i915/gt: Save irqstate around virtual_context_destroy\n\nAs virtual_context_destroy() may be called from a request signal, it may\nbe called from inside an irq-off section, and so we need to do a full\nsave/restore of the irq state rather than blindly re-enable irqs upon\nunlocking.\n\n<4> [110.024262] WARNING: inconsistent lock state\n<4> [110.024277] 5.4.0-rc8-CI-CI_DRM_7489+ #1 Tainted: G     U\n<4> [110.024292] --------------------------------\n<4> [110.024305] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.\n<4> [110.024323] kworker/0:0/5 [HC0[0]:SC0[0]:HE1:SE1] takes:\n<4> [110.024338] ffff88826a0c7a18 (&(&rq->lock)->rlock){?.-.}, at: i915_request_retire+0x221/0x930 [i915]\n<4> [110.024592] {IN-HARDIRQ-W} state was registered at:\n<4> [110.024612]   lock_acquire+0xa7/0x1c0\n<4> [110.024627]   _raw_spin_lock_irqsave+0x33/0x50\n<4> [110.024788]   intel_engine_breadcrumbs_irq+0x38c/0x600 [i915]\n<4> [110.024808]   irq_work_run_list+0x49/0x70\n<4> [110.024824]   irq_work_run+0x26/0x50\n<4> [110.024839]   smp_irq_work_interrupt+0x44/0x1e0\n<4> [110.024855]   irq_work_interrupt+0xf/0x20\n<4> [110.024871]   __do_softirq+0xb7/0x47f\n<4> [110.024885]   irq_exit+0xba/0xc0\n<4> [110.024898]   do_IRQ+0x83/0x160\n<4> [110.024910]   ret_from_intr+0x0/0x1d\n<4> [110.024922] irq event stamp: 172864\n<4> [110.024938] hardirqs last  enabled at (172863): [<ffffffff819ea214>] _raw_spin_unlock_irq+0x24/0x50\n<4> [110.024963] hardirqs last disabled at (172864): [<ffffffff819e9fba>] _raw_spin_lock_irq+0xa/0x40\n<4> [110.024988] softirqs last  enabled at (172812): [<ffffffff81c00385>] __do_softirq+0x385/0x47f\n<4> [110.025012] softirqs last disabled at (172797): [<ffffffff810b829a>] irq_exit+0xba/0xc0\n<4> [110.025031]\nother info that might help us debug this:\n<4> [110.025049]  Possible unsafe locking scenario:\n\n<4> [110.025065]        CPU0\n<4> [110.025075]        ----\n<4> [110.025084]   lock(&(&rq->lock)->rlock);\n<4> [110.025099]   <Interrupt>\n<4> [110.025109]     lock(&(&rq->lock)->rlock);\n<4> [110.025124]\n *** DEADLOCK ***\n\n<4> [110.025144] 4 locks held by kworker/0:0/5:\n<4> [110.025156]  #0: ffff88827588f528 ((wq_completion)events){+.+.}, at: process_one_work+0x1de/0x620\n<4> [110.025187]  #1: ffffc9000006fe78 ((work_completion)(&engine->retire_work)){+.+.}, at: process_one_work+0x1de/0x620\n<4> [110.025219]  #2: ffff88825605e270 (&kernel#2){+.+.}, at: engine_retire+0x57/0xe0 [i915]\n<4> [110.025405]  #3: ffff88826a0c7a18 (&(&rq->lock)->rlock){?.-.}, at: i915_request_retire+0x221/0x930 [i915]\n<4> [110.025634]\nstack backtrace:\n<4> [110.025653] CPU: 0 PID: 5 Comm: kworker/0:0 Tainted: G     U            5.4.0-rc8-CI-CI_DRM_7489+ #1\n<4> [110.025675] Hardware name:  /NUC7i5BNB, BIOS BNKBL357.86A.0054.2017.1025.1822 10/25/2017\n<4> [110.025856] Workqueue: events engine_retire [i915]\n<4> [110.025872] Call Trace:\n<4> [110.025891]  dump_stack+0x71/0x9b\n<4> [110.025907]  mark_lock+0x49a/0x500\n<4> [110.025926]  ? print_shortest_lock_dependencies+0x200/0x200\n<4> [110.025946]  mark_held_locks+0x49/0x70\n<4> [110.025962]  ? _raw_spin_unlock_irq+0x24/0x50\n<4> [110.025978]  lockdep_hardirqs_on+0xa2/0x1c0\n<4> [110.025995]  _raw_spin_unlock_irq+0x24/0x50\n<4> [110.026171]  virtual_context_destroy+0xc5/0x2e0 [i915]\n<4> [110.026376]  __active_retire+0xb4/0x290 [i915]\n<4> [110.026396]  dma_fence_signal_locked+0x9e/0x1b0\n<4> [110.026613]  i915_request_retire+0x451/0x930 [i915]\n<4> [110.026766]  retire_requests+0x4d/0x60 [i915]\n<4> [110.026919]  engine_retire+0x63/0xe0 [i915]\n\nFixes: b1e3177bd1d8 (\"drm/i915: Coordinate i915_active with its own mutex\")\nFixes: 6d06779e8672 (\"drm/i915: Load balancing across a virtual engine\")\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nReviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20191205145934.663183-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/gt/intel_lrc.c||drivers/gpu/drm/i915/gt/intel_lrc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/gt/intel_lrc.c||drivers/gpu/drm/i915/gt/intel_lrc.c": [
          "File: drivers/gpu/drm/i915/gt/intel_lrc.c -> drivers/gpu/drm/i915/gt/intel_lrc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4200:  for (n = 0; n < ve->num_siblings; n++) {",
          "4201:   struct intel_engine_cs *sibling = ve->siblings[n];",
          "4202:   struct rb_node *node = &ve->nodes[sibling->id].rb;",
          "4204:   if (RB_EMPTY_NODE(node))",
          "4205:    continue;",
          "4210:   if (!RB_EMPTY_NODE(node))",
          "4211:    rb_erase_cached(node, &sibling->execlists.virtual);",
          "4214:  }",
          "4215:  GEM_BUG_ON(__tasklet_is_scheduled(&ve->base.execlists.tasklet));",
          "",
          "[Removed Lines]",
          "4207:   spin_lock_irq(&sibling->active.lock);",
          "4213:   spin_unlock_irq(&sibling->active.lock);",
          "",
          "[Added Lines]",
          "4203:   unsigned long flags;",
          "4208:   spin_lock_irqsave(&sibling->active.lock, flags);",
          "4214:   spin_unlock_irqrestore(&sibling->active.lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "38228e8848cd7dd86ccb90406af32de0cad24be3",
      "candidate_info": {
        "commit_hash": "38228e8848cd7dd86ccb90406af32de0cad24be3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/38228e8848cd7dd86ccb90406af32de0cad24be3",
        "files": [
          "kernel/padata.c"
        ],
        "message": "padata: always acquire cpu_hotplug_lock before pinst->lock\n\nlockdep complains when padata's paths to update cpumasks via CPU hotplug\nand sysfs are both taken:\n\n  # echo 0 > /sys/devices/system/cpu/cpu1/online\n  # echo ff > /sys/kernel/pcrypt/pencrypt/parallel_cpumask\n\n  ======================================================\n  WARNING: possible circular locking dependency detected\n  5.4.0-rc8-padata-cpuhp-v3+ #1 Not tainted\n  ------------------------------------------------------\n  bash/205 is trying to acquire lock:\n  ffffffff8286bcd0 (cpu_hotplug_lock.rw_sem){++++}, at: padata_set_cpumask+0x2b/0x120\n\n  but task is already holding lock:\n  ffff8880001abfa0 (&pinst->lock){+.+.}, at: padata_set_cpumask+0x26/0x120\n\n  which lock already depends on the new lock.\n\npadata doesn't take cpu_hotplug_lock and pinst->lock in a consistent\norder.  Which should be first?  CPU hotplug calls into padata with\ncpu_hotplug_lock already held, so it should have priority.\n\nFixes: 6751fb3c0e0c (\"padata: Use get_online_cpus/put_online_cpus\")\nSigned-off-by: Daniel Jordan <daniel.m.jordan@oracle.com>\nCc: Eric Biggers <ebiggers@kernel.org>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nCc: linux-crypto@vger.kernel.org\nCc: linux-kernel@vger.kernel.org\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
        "before_after_code_files": [
          "kernel/padata.c||kernel/padata.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/padata.c||kernel/padata.c": [
          "File: kernel/padata.c -> kernel/padata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "643:  struct cpumask *serial_mask, *parallel_mask;",
          "644:  int err = -EINVAL;",
          "647:  get_online_cpus();",
          "649:  switch (cpumask_type) {",
          "650:  case PADATA_CPU_PARALLEL:",
          "",
          "[Removed Lines]",
          "646:  mutex_lock(&pinst->lock);",
          "",
          "[Added Lines]",
          "647:  mutex_lock(&pinst->lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "662:  err =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);",
          "664: out:",
          "666:  mutex_unlock(&pinst->lock);",
          "668:  return err;",
          "669: }",
          "",
          "[Removed Lines]",
          "665:  put_online_cpus();",
          "",
          "[Added Lines]",
          "666:  put_online_cpus();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5480e299b5ae57956af01d4839c9fc88a465eeab",
      "candidate_info": {
        "commit_hash": "5480e299b5ae57956af01d4839c9fc88a465eeab",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5480e299b5ae57956af01d4839c9fc88a465eeab",
        "files": [
          "drivers/scsi/libiscsi.c"
        ],
        "message": "scsi: iscsi: Fix a potential deadlock in the timeout handler\n\nSome time ago the block layer was modified such that timeout handlers are\ncalled from thread context instead of interrupt context. Make it safe to\nrun the iSCSI timeout handler in thread context. This patch fixes the\nfollowing lockdep complaint:\n\n================================\nWARNING: inconsistent lock state\n5.5.1-dbg+ #11 Not tainted\n--------------------------------\ninconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage.\nkworker/7:1H/206 [HC0[0]:SC0[0]:HE1:SE1] takes:\nffff88802d9827e8 (&(&session->frwd_lock)->rlock){+.?.}, at: iscsi_eh_cmd_timed_out+0xa6/0x6d0 [libiscsi]\n{IN-SOFTIRQ-W} state was registered at:\n  lock_acquire+0x106/0x240\n  _raw_spin_lock+0x38/0x50\n  iscsi_check_transport_timeouts+0x3e/0x210 [libiscsi]\n  call_timer_fn+0x132/0x470\n  __run_timers.part.0+0x39f/0x5b0\n  run_timer_softirq+0x63/0xc0\n  __do_softirq+0x12d/0x5fd\n  irq_exit+0xb3/0x110\n  smp_apic_timer_interrupt+0x131/0x3d0\n  apic_timer_interrupt+0xf/0x20\n  default_idle+0x31/0x230\n  arch_cpu_idle+0x13/0x20\n  default_idle_call+0x53/0x60\n  do_idle+0x38a/0x3f0\n  cpu_startup_entry+0x24/0x30\n  start_secondary+0x222/0x290\n  secondary_startup_64+0xa4/0xb0\nirq event stamp: 1383705\nhardirqs last  enabled at (1383705): [<ffffffff81aace5c>] _raw_spin_unlock_irq+0x2c/0x50\nhardirqs last disabled at (1383704): [<ffffffff81aacb98>] _raw_spin_lock_irq+0x18/0x50\nsoftirqs last  enabled at (1383690): [<ffffffffa0e2efea>] iscsi_queuecommand+0x76a/0xa20 [libiscsi]\nsoftirqs last disabled at (1383682): [<ffffffffa0e2e998>] iscsi_queuecommand+0x118/0xa20 [libiscsi]\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(&(&session->frwd_lock)->rlock);\n  <Interrupt>\n    lock(&(&session->frwd_lock)->rlock);\n\n *** DEADLOCK ***\n\n2 locks held by kworker/7:1H/206:\n #0: ffff8880d57bf928 ((wq_completion)kblockd){+.+.}, at: process_one_work+0x472/0xab0\n #1: ffff88802b9c7de8 ((work_completion)(&q->timeout_work)){+.+.}, at: process_one_work+0x476/0xab0\n\nstack backtrace:\nCPU: 7 PID: 206 Comm: kworker/7:1H Not tainted 5.5.1-dbg+ #11\nHardware name: Bochs Bochs, BIOS Bochs 01/01/2011\nWorkqueue: kblockd blk_mq_timeout_work\nCall Trace:\n dump_stack+0xa5/0xe6\n print_usage_bug.cold+0x232/0x23b\n mark_lock+0x8dc/0xa70\n __lock_acquire+0xcea/0x2af0\n lock_acquire+0x106/0x240\n _raw_spin_lock+0x38/0x50\n iscsi_eh_cmd_timed_out+0xa6/0x6d0 [libiscsi]\n scsi_times_out+0xf4/0x440 [scsi_mod]\n scsi_timeout+0x1d/0x20 [scsi_mod]\n blk_mq_check_expired+0x365/0x3a0\n bt_iter+0xd6/0xf0\n blk_mq_queue_tag_busy_iter+0x3de/0x650\n blk_mq_timeout_work+0x1af/0x380\n process_one_work+0x56d/0xab0\n worker_thread+0x7a/0x5d0\n kthread+0x1bc/0x210\n ret_from_fork+0x24/0x30\n\nFixes: 287922eb0b18 (\"block: defer timeouts to a workqueue\")\nCc: Christoph Hellwig <hch@lst.de>\nCc: Keith Busch <keith.busch@intel.com>\nCc: Lee Duncan <lduncan@suse.com>\nCc: Chris Leech <cleech@redhat.com>\nCc: <stable@vger.kernel.org>\nLink: https://lore.kernel.org/r/20191209173457.187370-1-bvanassche@acm.org\nSigned-off-by: Bart Van Assche <bvanassche@acm.org>\nReviewed-by: Lee Duncan <lduncan@suse.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/libiscsi.c||drivers/scsi/libiscsi.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/libiscsi.c||drivers/scsi/libiscsi.c": [
          "File: drivers/scsi/libiscsi.c -> drivers/scsi/libiscsi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1946:  ISCSI_DBG_EH(session, \"scsi cmd %p timedout\\n\", sc);",
          "1949:  task = (struct iscsi_task *)sc->SCp.ptr;",
          "1950:  if (!task) {",
          "",
          "[Removed Lines]",
          "1948:  spin_lock(&session->frwd_lock);",
          "",
          "[Added Lines]",
          "1948:  spin_lock_bh(&session->frwd_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2072: done:",
          "2073:  if (task)",
          "2074:   task->last_timeout = jiffies;",
          "2076:  ISCSI_DBG_EH(session, \"return %s\\n\", rc == BLK_EH_RESET_TIMER ?",
          "2077:        \"timer reset\" : \"shutdown or nh\");",
          "2078:  return rc;",
          "",
          "[Removed Lines]",
          "2075:  spin_unlock(&session->frwd_lock);",
          "",
          "[Added Lines]",
          "2075:  spin_unlock_bh(&session->frwd_lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "00d4e14d2e4caf5f7254a505fee5eeca8cd37bd4",
      "candidate_info": {
        "commit_hash": "00d4e14d2e4caf5f7254a505fee5eeca8cd37bd4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/00d4e14d2e4caf5f7254a505fee5eeca8cd37bd4",
        "files": [
          "net/can/j1939/socket.c"
        ],
        "message": "can: j1939: j1939_sk_bind(): take priv after lock is held\n\nsyzbot reproduced following crash:\n\n===============================================================================\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] PREEMPT SMP KASAN\nCPU: 0 PID: 9844 Comm: syz-executor.0 Not tainted 5.4.0-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS\nGoogle 01/01/2011\nRIP: 0010:__lock_acquire+0x1254/0x4a00 kernel/locking/lockdep.c:3828\nCode: 00 0f 85 96 24 00 00 48 81 c4 f0 00 00 00 5b 41 5c 41 5d 41 5e 41\n5f 5d c3 48 b8 00 00 00 00 00 fc ff df 4c 89 f2 48 c1 ea 03 <80> 3c 02\n00 0f 85 0b 28 00 00 49 81 3e 20 19 78 8a 0f 84 5f ee ff\nRSP: 0018:ffff888099c3fb48 EFLAGS: 00010006\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000218 RSI: 0000000000000000 RDI: 0000000000000001\nRBP: ffff888099c3fc60 R08: 0000000000000001 R09: 0000000000000001\nR10: fffffbfff146e1d0 R11: ffff888098720400 R12: 00000000000010c0\nR13: 0000000000000000 R14: 00000000000010c0 R15: 0000000000000000\nFS:  00007f0559e98700(0000) GS:ffff8880ae800000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fe4d89e0000 CR3: 0000000099606000 CR4: 00000000001406f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485\n __raw_spin_lock_bh include/linux/spinlock_api_smp.h:135 [inline]\n _raw_spin_lock_bh+0x33/0x50 kernel/locking/spinlock.c:175\n spin_lock_bh include/linux/spinlock.h:343 [inline]\n j1939_jsk_del+0x32/0x210 net/can/j1939/socket.c:89\n j1939_sk_bind+0x2ea/0x8f0 net/can/j1939/socket.c:448\n __sys_bind+0x239/0x290 net/socket.c:1648\n __do_sys_bind net/socket.c:1659 [inline]\n __se_sys_bind net/socket.c:1657 [inline]\n __x64_sys_bind+0x73/0xb0 net/socket.c:1657\n do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x45a679\nCode: ad b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89\nf7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01\nf0 ff ff 0f 83 7b b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00\nRSP: 002b:00007f0559e97c78 EFLAGS: 00000246 ORIG_RAX: 0000000000000031\nRAX: ffffffffffffffda RBX: 0000000000000003 RCX: 000000000045a679\nRDX: 0000000000000018 RSI: 0000000020000240 RDI: 0000000000000003\nRBP: 000000000075bf20 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f0559e986d4\nR13: 00000000004c09e9 R14: 00000000004d37d0 R15: 00000000ffffffff\nModules linked in:\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 9844 at kernel/locking/mutex.c:1419\nmutex_trylock+0x279/0x2f0 kernel/locking/mutex.c:1427\n===============================================================================\n\nThis issues was caused by null pointer deference. Where j1939_sk_bind()\nwas using currently not existing priv.\n\nPossible scenario may look as following:\ncpu0                                    cpu1\nbind()\n                                        bind()\n j1939_sk_bind()\n                                         j1939_sk_bind()\n  priv = jsk->priv;\n                                         priv = jsk->priv;\n  lock_sock(sock->sk);\n  priv = j1939_netdev_start(ndev);\n  j1939_jsk_add(priv, jsk);\n    jsk->priv = priv;\n  relase_sock(sock->sk);\n                                         lock_sock(sock->sk);\n                                         j1939_jsk_del(priv, jsk);\n                                         ..... ooops ......\n\nWith this patch we move \"priv = jsk->priv;\" after the lock, to avoid\nassigning of wrong priv pointer.\n\nReported-by: syzbot+99e9e1b200a1e363237d@syzkaller.appspotmail.com\nFixes: 9d71dd0c7009 (\"can: add support of SAE J1939 protocol\")\nSigned-off-by: Oleksij Rempel <o.rempel@pengutronix.de>\nCc: linux-stable <stable@vger.kernel.org> # >= v5.4\nSigned-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",
        "before_after_code_files": [
          "net/can/j1939/socket.c||net/can/j1939/socket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/can/j1939/socket.c||net/can/j1939/socket.c": [
          "File: net/can/j1939/socket.c -> net/can/j1939/socket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "423: {",
          "424:  struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;",
          "425:  struct j1939_sock *jsk = j1939_sk(sock->sk);",
          "429:  int ret = 0;",
          "431:  ret = j1939_sk_sanity_check(addr, len);",
          "",
          "[Removed Lines]",
          "426:  struct j1939_priv *priv = jsk->priv;",
          "427:  struct sock *sk = sock->sk;",
          "428:  struct net *net = sock_net(sk);",
          "",
          "[Added Lines]",
          "426:  struct j1939_priv *priv;",
          "427:  struct sock *sk;",
          "428:  struct net *net;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "435:  lock_sock(sock->sk);",
          "438:  if (jsk->state & J1939_SOCK_BOUND) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "437:  priv = jsk->priv;",
          "438:  sk = sock->sk;",
          "439:  net = sock_net(sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "045d1fb79616f138a2e51f04537acd40b9a38ce0",
      "candidate_info": {
        "commit_hash": "045d1fb79616f138a2e51f04537acd40b9a38ce0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/045d1fb79616f138a2e51f04537acd40b9a38ce0",
        "files": [
          "drivers/gpu/drm/i915/gt/intel_breadcrumbs.c"
        ],
        "message": "drm/i915/gt: Acquire a GT wakeref for the breadcrumb interrupt\n\nTake a wakeref on the intel_gt specifically for the enabled breadcrumb\ninterrupt so that we can safely process the mmio. If the intel_gt is\nalready asleep by the time we try and setup the breadcrumb interrupt, by\na process of elimination we know the request must have been completed\nand we can skip its enablement!\n\n<4> [1518.350005] Unclaimed write to register 0x220a8\n<4> [1518.350323] WARNING: CPU: 2 PID: 3685 at drivers/gpu/drm/i915/intel_uncore.c:1163 __unclaimed_reg_debug+0x40/0x50 [i915]\n<4> [1518.350393] Modules linked in: vgem snd_hda_codec_hdmi x86_pkg_temp_thermal i915 coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_intel snd_intel_dspcfg snd_hda_codec snd_hwdep snd_hda_core btusb cdc_ether btrtl usbnet btbcm btintel r8152 snd_pcm mii bluetooth ecdh_generic ecc i2c_hid pinctrl_sunrisepoint pinctrl_intel intel_lpss_pci prime_numbers [last unloaded: vgem]\n<4> [1518.350646] CPU: 2 PID: 3685 Comm: gem_exec_parse_ Tainted: G     U            5.4.0-rc8-CI-CI_DRM_7490+ #1\n<4> [1518.350708] Hardware name: Google Caroline/Caroline, BIOS MrChromebox 08/27/2018\n<4> [1518.350946] RIP: 0010:__unclaimed_reg_debug+0x40/0x50 [i915]\n<4> [1518.350992] Code: 74 05 5b 5d 41 5c c3 45 84 e4 48 c7 c0 95 8d 47 a0 48 c7 c6 8b 8d 47 a0 48 0f 44 f0 89 ea 48 c7 c7 9e 8d 47 a0 e8 40 45 e3 e0 <0f> 0b 83 2d 27 4f 2a 00 01 5b 5d 41 5c c3 66 90 41 55 41 54 55 53\n<4> [1518.351100] RSP: 0018:ffffc900007f39c8 EFLAGS: 00010086\n<4> [1518.351140] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000006\n<4> [1518.351202] RDX: 0000000080000006 RSI: 0000000000000000 RDI: 00000000ffffffff\n<4> [1518.351249] RBP: 00000000000220a8 R08: 0000000000000000 R09: 0000000000000000\n<4> [1518.351296] R10: ffffc900007f3990 R11: ffffc900007f3868 R12: 0000000000000000\n<4> [1518.351342] R13: 00000000fefeffff R14: 0000000000000092 R15: ffff888155fea000\n<4> [1518.351391] FS:  00007fc255abfe40(0000) GS:ffff88817ab00000(0000) knlGS:0000000000000000\n<4> [1518.351445] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4> [1518.351485] CR2: 00007fc2554882d0 CR3: 0000000168ca2005 CR4: 00000000003606e0\n<4> [1518.351529] Call Trace:\n<4> [1518.351746]  fwtable_write32+0x114/0x1d0 [i915]\n<4> [1518.351795]  ? sync_file_alloc+0x80/0x80\n<4> [1518.352039]  gen8_logical_ring_enable_irq+0x30/0x50 [i915]\n<4> [1518.352295]  irq_enable.part.10+0x23/0x40 [i915]\n<4> [1518.352523]  i915_request_enable_breadcrumb+0xb5/0x330 [i915]\n<4> [1518.352575]  ? sync_file_alloc+0x80/0x80\n<4> [1518.352612]  __dma_fence_enable_signaling+0x60/0x160\n<4> [1518.352653]  ? sync_file_alloc+0x80/0x80\n<4> [1518.352685]  dma_fence_add_callback+0x44/0xd0\n<4> [1518.352726]  sync_file_poll+0x95/0xc0\n<4> [1518.352767]  do_sys_poll+0x24d/0x570\n\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nReviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20191205215842.862750-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/gt/intel_breadcrumbs.c||drivers/gpu/drm/i915/gt/intel_breadcrumbs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/gt/intel_breadcrumbs.c||drivers/gpu/drm/i915/gt/intel_breadcrumbs.c": [
          "File: drivers/gpu/drm/i915/gt/intel_breadcrumbs.c -> drivers/gpu/drm/i915/gt/intel_breadcrumbs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"i915_drv.h\"",
          "30: #include \"i915_trace.h\"",
          "32: static void irq_enable(struct intel_engine_cs *engine)",
          "33: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include \"intel_gt_pm.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: static void __intel_breadcrumbs_disarm_irq(struct intel_breadcrumbs *b)",
          "55: {",
          "56:  lockdep_assert_held(&b->irq_lock);",
          "58:  GEM_BUG_ON(!b->irq_enabled);",
          "59:  if (!--b->irq_enabled)",
          "64:  b->irq_armed = false;",
          "65: }",
          "67: void intel_engine_disarm_breadcrumbs(struct intel_engine_cs *engine)",
          "",
          "[Removed Lines]",
          "60:   irq_disable(container_of(b,",
          "61:       struct intel_engine_cs,",
          "62:       breadcrumbs));",
          "",
          "[Added Lines]",
          "57:  struct intel_engine_cs *engine =",
          "58:   container_of(b, struct intel_engine_cs, breadcrumbs);",
          "64:   irq_disable(engine);",
          "67:  intel_gt_pm_put_async(engine->gt);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:  intel_engine_breadcrumbs_irq(engine);",
          "208: }",
          "211: {",
          "212:  struct intel_engine_cs *engine =",
          "213:   container_of(b, struct intel_engine_cs, breadcrumbs);",
          "215:  lockdep_assert_held(&b->irq_lock);",
          "216:  if (b->irq_armed)",
          "",
          "[Removed Lines]",
          "210: static void __intel_breadcrumbs_arm_irq(struct intel_breadcrumbs *b)",
          "217:   return;",
          "",
          "[Added Lines]",
          "213: static bool __intel_breadcrumbs_arm_irq(struct intel_breadcrumbs *b)",
          "220:   return true;",
          "222:  if (!intel_gt_pm_get_if_awake(engine->gt))",
          "223:   return false;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "235:  if (!b->irq_enabled++)",
          "236:   irq_enable(engine);",
          "237: }",
          "239: void intel_engine_init_breadcrumbs(struct intel_engine_cs *engine)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "244:  return true;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "277:   spin_lock(&b->irq_lock);",
          "278:   GEM_BUG_ON(test_bit(I915_FENCE_FLAG_SIGNAL, &rq->fence.flags));",
          "",
          "[Removed Lines]",
          "280:   __intel_breadcrumbs_arm_irq(b);",
          "",
          "[Added Lines]",
          "288:   if (!__intel_breadcrumbs_arm_irq(b))",
          "289:    goto unlock;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "306:   GEM_BUG_ON(!check_signal_order(ce, rq));",
          "308:   set_bit(I915_FENCE_FLAG_SIGNAL, &rq->fence.flags);",
          "309:   spin_unlock(&b->irq_lock);",
          "310:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "318: unlock:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-4150",
  "cve_desc": "The virtio_net_load function in hw/net/virtio-net.c in QEMU 1.5.0 through 1.7.x before 1.7.2 allows remote attackers to cause a denial of service or possibly execute arbitrary code via vectors in which the value of curr_queues is greater than max_queues, which triggers an out-of-bounds write.",
  "repo": "qemu/qemu",
  "patch_hash": "eea750a5623ddac7a61982eec8f1c93481857578",
  "patch_info": {
    "commit_hash": "eea750a5623ddac7a61982eec8f1c93481857578",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/eea750a5623ddac7a61982eec8f1c93481857578",
    "files": [
      "hw/net/virtio-net.c"
    ],
    "message": "virtio-net: out-of-bounds buffer write on invalid state load\n\nCVE-2013-4150 QEMU 1.5.0 out-of-bounds buffer write in\nvirtio_net_load()@hw/net/virtio-net.c\n\nThis code is in hw/net/virtio-net.c:\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n        }\n\n        n->curr_queues = qemu_get_be16(f);\n        for (i = 1; i < n->curr_queues; i++) {\n            n->vqs[i].tx_waiting = qemu_get_be32(f);\n        }\n    }\n\nNumber of vqs is max_queues, so if we get invalid input here,\nfor example if max_queues = 2, curr_queues = 3, we get\nwrite beyond end of the buffer, with data that comes from\nwire.\n\nThis might be used to corrupt qemu memory in hard to predict ways.\nSince we have lots of function pointers around, RCE might be possible.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nAcked-by: Jason Wang <jasowang@redhat.com>\nReviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>",
    "before_after_code_files": [
      "hw/net/virtio-net.c||hw/net/virtio-net.c"
    ]
  },
  "patch_diff": {
    "hw/net/virtio-net.c||hw/net/virtio-net.c": [
      "File: hw/net/virtio-net.c -> hw/net/virtio-net.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1407:         }",
      "1409:         n->curr_queues = qemu_get_be16(f);",
      "1410:         for (i = 1; i < n->curr_queues; i++) {",
      "1411:             n->vqs[i].tx_waiting = qemu_get_be32(f);",
      "1412:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1410:         if (n->curr_queues > n->max_queues) {",
      "1411:             error_report(\"virtio-net: curr_queues %x > max_queues %x\",",
      "1412:                          n->curr_queues, n->max_queues);",
      "1413:             return -1;",
      "1414:         }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b24cfb0f1ef056263210cd6e80444a1113cea24a",
      "candidate_info": {
        "commit_hash": "b24cfb0f1ef056263210cd6e80444a1113cea24a",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/b24cfb0f1ef056263210cd6e80444a1113cea24a",
        "files": [
          "hw/net/virtio-net.c"
        ],
        "message": "virtio-net: out-of-bounds buffer write on invalid state load\n\nCVE-2013-4150 QEMU 1.5.0 out-of-bounds buffer write in\nvirtio_net_load()@hw/net/virtio-net.c\n\nThis code is in hw/net/virtio-net.c:\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n        }\n\n        n->curr_queues = qemu_get_be16(f);\n        for (i = 1; i < n->curr_queues; i++) {\n            n->vqs[i].tx_waiting = qemu_get_be32(f);\n        }\n    }\n\nNumber of vqs is max_queues, so if we get invalid input here,\nfor example if max_queues = 2, curr_queues = 3, we get\nwrite beyond end of the buffer, with data that comes from\nwire.\n\nThis might be used to corrupt qemu memory in hard to predict ways.\nSince we have lots of function pointers around, RCE might be possible.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nAcked-by: Jason Wang <jasowang@redhat.com>\nReviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n(cherry picked from commit eea750a5623ddac7a61982eec8f1c93481857578)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/net/virtio-net.c||hw/net/virtio-net.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/net/virtio-net.c||hw/net/virtio-net.c"
          ],
          "candidate": [
            "hw/net/virtio-net.c||hw/net/virtio-net.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/net/virtio-net.c||hw/net/virtio-net.c": [
          "File: hw/net/virtio-net.c -> hw/net/virtio-net.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1407:         }",
          "1409:         n->curr_queues = qemu_get_be16(f);",
          "1410:         for (i = 1; i < n->curr_queues; i++) {",
          "1411:             n->vqs[i].tx_waiting = qemu_get_be32(f);",
          "1412:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1410:         if (n->curr_queues > n->max_queues) {",
          "1411:             error_report(\"virtio-net: curr_queues %x > max_queues %x\",",
          "1412:                          n->curr_queues, n->max_queues);",
          "1413:             return -1;",
          "1414:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2b15f410bd2c333add4db2e7c96f457cdac3d149",
      "candidate_info": {
        "commit_hash": "2b15f410bd2c333add4db2e7c96f457cdac3d149",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/2b15f410bd2c333add4db2e7c96f457cdac3d149",
        "files": [
          "hw/net/virtio-net.c"
        ],
        "message": "virtio-net: out-of-bounds buffer write on invalid state load\n\nCVE-2013-4150 QEMU 1.5.0 out-of-bounds buffer write in\nvirtio_net_load()@hw/net/virtio-net.c\n\nThis code is in hw/net/virtio-net.c:\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n        }\n\n        n->curr_queues = qemu_get_be16(f);\n        for (i = 1; i < n->curr_queues; i++) {\n            n->vqs[i].tx_waiting = qemu_get_be32(f);\n        }\n    }\n\nNumber of vqs is max_queues, so if we get invalid input here,\nfor example if max_queues = 2, curr_queues = 3, we get\nwrite beyond end of the buffer, with data that comes from\nwire.\n\nThis might be used to corrupt qemu memory in hard to predict ways.\nSince we have lots of function pointers around, RCE might be possible.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nAcked-by: Jason Wang <jasowang@redhat.com>\nReviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n(cherry picked from commit eea750a5623ddac7a61982eec8f1c93481857578)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/net/virtio-net.c||hw/net/virtio-net.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/net/virtio-net.c||hw/net/virtio-net.c"
          ],
          "candidate": [
            "hw/net/virtio-net.c||hw/net/virtio-net.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/net/virtio-net.c||hw/net/virtio-net.c": [
          "File: hw/net/virtio-net.c -> hw/net/virtio-net.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1387:         }",
          "1389:         n->curr_queues = qemu_get_be16(f);",
          "1390:         for (i = 1; i < n->curr_queues; i++) {",
          "1391:             n->vqs[i].tx_waiting = qemu_get_be32(f);",
          "1392:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1390:         if (n->curr_queues > n->max_queues) {",
          "1391:             error_report(\"virtio-net: curr_queues %x > max_queues %x\",",
          "1392:                          n->curr_queues, n->max_queues);",
          "1393:             return -1;",
          "1394:         }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
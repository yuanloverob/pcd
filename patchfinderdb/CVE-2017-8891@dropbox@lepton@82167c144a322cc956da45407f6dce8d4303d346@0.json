{
  "cve_id": "CVE-2017-8891",
  "cve_desc": "Dropbox Lepton 1.2.1 allows DoS (SEGV and application crash) via a malformed lepton file because the code does not ensure setup of a correct number of threads.",
  "repo": "dropbox/lepton",
  "patch_hash": "82167c144a322cc956da45407f6dce8d4303d346",
  "patch_info": {
    "commit_hash": "82167c144a322cc956da45407f6dce8d4303d346",
    "repo": "dropbox/lepton",
    "commit_url": "https://github.com/dropbox/lepton/commit/82167c144a322cc956da45407f6dce8d4303d346",
    "files": [
      "src/lepton/bitops.cc",
      "src/lepton/bitops.hh",
      "src/lepton/lepton_codec.cc",
      "src/lepton/vp8_decoder.cc",
      "src/vp8/decoder/boolreader.hh"
    ],
    "message": "fix #87 : always check that threads_required set up the appropriate number of threads---fire off nop functions on unused threads for consistency",
    "before_after_code_files": [
      "src/lepton/bitops.cc||src/lepton/bitops.cc",
      "src/lepton/bitops.hh||src/lepton/bitops.hh",
      "src/lepton/lepton_codec.cc||src/lepton/lepton_codec.cc",
      "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc",
      "src/vp8/decoder/boolreader.hh||src/vp8/decoder/boolreader.hh"
    ]
  },
  "patch_diff": {
    "src/lepton/bitops.cc||src/lepton/bitops.cc": [
      "File: src/lepton/bitops.cc -> src/lepton/bitops.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "356:     this->size_callback = size_callback;",
      "357:     buffer_position = 0;",
      "358:     byte_position = 0;",
      "359:     num_bytes_attempted_to_write = 0;",
      "360:     set_bound(0);",
      "361: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "359:     byte_bound = 0x7FFFFFFF;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "384:     parent->Close();",
      "385: }",
      "389:     std::pair<unsigned int, Sirikata::JpegError> retval;",
      "390:     if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {",
      "",
      "[Removed Lines]",
      "387: unsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {",
      "",
      "[Added Lines]",
      "388: uint32_t bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {",
      "",
      "---------------"
    ],
    "src/lepton/bitops.hh||src/lepton/bitops.hh": [
      "File: src/lepton/bitops.hh -> src/lepton/bitops.hh",
      "--- Hunk 1 ---",
      "[Context before]",
      "467:     uint8_t buffer[buffer_size];",
      "468:     uint32_t buffer_position;",
      "469:     Sirikata::DecoderWriter *parent;",
      "473:     Sirikata::JpegError err;",
      "474:     std::function<void(Sirikata::DecoderWriter*, size_t)> size_callback;",
      "476: public:",
      "477:  bounded_iostream( Sirikata::DecoderWriter * parent,",
      "478:                       const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,",
      "",
      "[Removed Lines]",
      "470:     unsigned int byte_bound;",
      "471:     unsigned int byte_position;",
      "472:     unsigned int num_bytes_attempted_to_write;",
      "475:     unsigned int write_no_buffer( const void* from, size_t bytes_to_write );",
      "",
      "[Added Lines]",
      "470:     uint32_t byte_bound;",
      "471:     uint32_t byte_position;",
      "472:     uint32_t num_bytes_attempted_to_write;",
      "475:     uint32_t write_no_buffer( const void* from, size_t bytes_to_write );",
      "",
      "---------------"
    ],
    "src/lepton/lepton_codec.cc||src/lepton/lepton_codec.cc": [
      "File: src/lepton/lepton_codec.cc -> src/lepton/lepton_codec.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "277:     dev_assert(luma_splits_.size() == 2); // not ready to do multiple work items on a thread yet",
      "278:     int min_y = luma_splits_[0];",
      "279:     int max_y = luma_splits_[1];",
      "280:     while(true) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "278:     always_assert(luma_splits_.size() >= 2);",
      "",
      "---------------"
    ],
    "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc": [
      "File: src/lepton/vp8_decoder.cc -> src/lepton/vp8_decoder.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "417: void VP8ComponentDecoder::flush() {",
      "418:         mux_splicer.drain(mux_reader_);",
      "419: }",
      "420: CodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * const colldata)",
      "421: {",
      "422:     mux_splicer.init(spin_workers_);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "420: namespace{void nop(){}}",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "455:     if (do_threading_) {",
      "456:         for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
      "457:             unsigned int cur_spin_worker = thread_id;",
      "466:             spin_workers_[cur_spin_worker].activate_work();",
      "467:         }",
      "468:         flush();",
      "",
      "[Removed Lines]",
      "458:             spin_workers_[cur_spin_worker].work",
      "459:                 = std::bind(worker_thread,",
      "460:                             thread_state_[thread_id],",
      "461:                             thread_id,",
      "462:                             colldata,",
      "463:                             mux_splicer.thread_target,",
      "464:                             getWorker(cur_spin_worker),",
      "465:                             &send_to_actual_thread_state);",
      "",
      "[Added Lines]",
      "459:             if (!thread_state_[thread_id]) {",
      "460:                 spin_workers_[cur_spin_worker].work",
      "461:                     = &nop;",
      "462:             } else {",
      "463:                 spin_workers_[cur_spin_worker].work",
      "464:                     = std::bind(worker_thread,",
      "465:                                 thread_state_[thread_id],",
      "466:                                 thread_id,",
      "467:                                 colldata,",
      "468:                                 mux_splicer.thread_target,",
      "469:                                 getWorker(cur_spin_worker),",
      "470:                                 &send_to_actual_thread_state);",
      "471:             }",
      "",
      "---------------"
    ],
    "src/vp8/decoder/boolreader.hh||src/vp8/decoder/boolreader.hh": [
      "File: src/vp8/decoder/boolreader.hh -> src/vp8/decoder/boolreader.hh",
      "--- Hunk 1 ---",
      "[Context before]",
      "119:             return;",
      "120:         }",
      "121:         size_t del = rope[0].second-rope[0].first;",
      "123:         dest += del;",
      "124:         size -=del;",
      "125:         if (size) {",
      "",
      "[Removed Lines]",
      "122:         memcpy(dest, rope[0].first, del);",
      "",
      "[Added Lines]",
      "122:         if (del) {",
      "123:             memcpy(dest, rope[0].first, del);",
      "124:         }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6948758e94460ba9d4bcf38e1267348b72a913f8",
      "candidate_info": {
        "commit_hash": "6948758e94460ba9d4bcf38e1267348b72a913f8",
        "repo": "dropbox/lepton",
        "commit_url": "https://github.com/dropbox/lepton/commit/6948758e94460ba9d4bcf38e1267348b72a913f8",
        "files": [
          "src/vp8/decoder/boolreader.cc",
          "src/vp8/decoder/boolreader.hh",
          "src/vp8/decoder/vpx_bool_reader.hh"
        ],
        "message": "added a PacketReader interface to allow for streaming of data into the vpx_reader",
        "before_after_code_files": [
          "src/vp8/decoder/boolreader.cc||src/vp8/decoder/boolreader.cc",
          "src/vp8/decoder/boolreader.hh||src/vp8/decoder/boolreader.hh",
          "src/vp8/decoder/vpx_bool_reader.hh||src/vp8/decoder/vpx_bool_reader.hh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/vp8/decoder/boolreader.hh||src/vp8/decoder/boolreader.hh"
          ],
          "candidate": [
            "src/vp8/decoder/boolreader.hh||src/vp8/decoder/boolreader.hh"
          ]
        }
      },
      "candidate_diff": {
        "src/vp8/decoder/boolreader.cc||src/vp8/decoder/boolreader.cc": [
          "File: src/vp8/decoder/boolreader.cc -> src/vp8/decoder/boolreader.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: int r_bitcount = 0;",
          "26: int vpx_reader_init(vpx_reader *r,",
          "34:     r->value = 0;",
          "35:     r->count = -8;",
          "36:     r->range = 255;",
          "37:     vpx_reader_fill(r);",
          "38:     return vpx_read(r, 128, Billing::HEADER) != 0;  // marker bit",
          "40: }",
          "",
          "[Removed Lines]",
          "27:                     const uint8_t *buffer,",
          "28:                     size_t size) {",
          "29:   if (size && !buffer) {",
          "30:     return 1;",
          "31:   } else {",
          "32:     r->buffer_end = buffer + size;",
          "33:     r->buffer = buffer;",
          "39:   }",
          "46: const uint8_t *vpx_reader_find_end(vpx_reader *r) {",
          "48:   while (r->count > CHAR_BIT && r->count < BD_VALUE_SIZE) {",
          "49:     r->count -= CHAR_BIT;",
          "50:     r->buffer--;",
          "51:   }",
          "52:   return r->buffer;",
          "53: }",
          "",
          "[Added Lines]",
          "27:                     PacketReader *upstream_reader) {",
          "28:     r->buffer = BiRope();",
          "29:     r->reader = upstream_reader;",
          "",
          "---------------"
        ],
        "src/vp8/decoder/boolreader.hh||src/vp8/decoder/boolreader.hh": [
          "File: src/vp8/decoder/boolreader.hh -> src/vp8/decoder/boolreader.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: typedef size_t BD_VALUE;",
          "46: #define BD_VALUE_SIZE ((int)sizeof(BD_VALUE) * CHAR_BIT)",
          "",
          "[Removed Lines]",
          "40: #ifdef __cplusplus",
          "41: extern \"C\" {",
          "42: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51: #define LOTS_OF_BITS 0x40000000",
          "53: typedef struct {",
          "55:   BD_VALUE value;",
          "56:   unsigned int range;",
          "57:   int count;",
          "63: } vpx_reader;",
          "65: int vpx_reader_init(vpx_reader *r,",
          "69: static INLINE void vpx_reader_fill(vpx_reader *r) {",
          "73:     BD_VALUE value = r->value;",
          "74:     int count = r->count;",
          "77:     int shift = BD_VALUE_SIZE - CHAR_BIT - (count + CHAR_BIT);",
          "79:     if (bits_left > BD_VALUE_SIZE) {",
          "80:         const int bits = (shift & 0xfffffff8) + CHAR_BIT;",
          "81:         BD_VALUE nv;",
          "82:         BD_VALUE big_endian_values;",
          "84:         if (sizeof(BD_VALUE) == 8) {",
          "85:             big_endian_values = htobe64(big_endian_values);",
          "86:         } else {",
          "",
          "[Removed Lines]",
          "58:   const uint8_t *buffer_end;",
          "59:   const uint8_t *buffer;",
          "62:   uint8_t clear_buffer[sizeof(BD_VALUE) + 1];",
          "66:                     const uint8_t *buffer,",
          "67:                     size_t size);",
          "70:     const uint8_t *const buffer_end = r->buffer_end;",
          "71:     const uint8_t *buffer = r->buffer;",
          "72:     const uint8_t *buffer_start = buffer;",
          "75:     const size_t bytes_left = buffer_end - buffer;",
          "76:     const size_t bits_left = bytes_left * CHAR_BIT;",
          "83:         memcpy(&big_endian_values, buffer, sizeof(BD_VALUE));",
          "",
          "[Added Lines]",
          "48: typedef std::pair<const uint8_t*, const uint8_t*> ROBuffer;",
          "49: class PacketReader{",
          "50: protected:",
          "51:     bool isEof;",
          "52: public:",
          "54:     virtual ROBuffer getNext() = 0;",
          "55:     bool eof()const {",
          "56:         return isEof;",
          "57:     }",
          "58:     virtual void setFree(ROBuffer buffer) = 0;",
          "59:     virtual ~PacketReader(){}",
          "60: };",
          "61: class TestPacketReader :public PacketReader{",
          "62:     const uint8_t*cur;",
          "63:     const uint8_t*end;",
          "64: public:",
          "65:     TestPacketReader(const uint8_t *start, const uint8_t *ed) {",
          "66:         isEof = false;",
          "67:         cur = start;",
          "68:         end = ed;",
          "69:     }",
          "70:     ROBuffer getNext(){",
          "71:         if (cur == end) {",
          "72:             isEof = true;",
          "73:             return {NULL, NULL};",
          "74:         }",
          "75:         if (end - cur > 16) {",
          "76:             size_t val = rand()%16 + 1;",
          "77:             cur += val;",
          "78:             return {cur - val, cur};",
          "79:         }",
          "80:         const uint8_t *ret = cur;",
          "81:         cur = end;",
          "82:         return {ret, end};",
          "83:     }",
          "84:     bool eof()const {",
          "85:         return isEof;",
          "86:     }",
          "87:     void setFree(ROBuffer buffer){}",
          "88: };",
          "89: class BiRope {",
          "90: public:",
          "91:     ROBuffer rope[2];",
          "93:     uint8_t backing[sizeof(BD_VALUE)];",
          "94:     BiRope() {",
          "95:         for (size_t i= 0; i < sizeof(rope)/sizeof(rope[0]); ++i) {",
          "96:             rope[i] = {NULL, NULL};",
          "97:         }",
          "98:     }",
          "99:     void push(ROBuffer data) {",
          "100:         if(rope[0].first == NULL) {",
          "101:             rope[0] = data;",
          "102:         }else {",
          "103:             always_assert(rope[1].first == NULL);",
          "104:             rope[1] = data;",
          "105:         }",
          "106:     }",
          "107:     size_t size() const {",
          "108:         return (rope[0].second-rope[0].first) +",
          "109:             (rope[1].second - rope[1].first);",
          "110:     }",
          "111:     void memcpy_ro(uint8_t *dest, size_t size) const {",
          "112:         if ((ptrdiff_t)size < rope[0].second-rope[0].first) {",
          "113:             memcpy(dest, rope[0].first, size);",
          "114:             return;",
          "115:         }",
          "116:         size_t del = rope[0].second-rope[0].first;",
          "117:         memcpy(dest, rope[0].first, del);",
          "118:         dest += del;",
          "119:         size -=del;",
          "120:         if (size) {",
          "121:             always_assert(rope[1].second - rope[1].first >= (ptrdiff_t)size);",
          "122:             memcpy(dest, rope[1].first, size);",
          "123:         }",
          "124:     }",
          "125:     void operator += (size_t del) {",
          "126:         if ((ptrdiff_t)del < rope[0].second - rope[0].first) {",
          "127:             rope[0].first += del;",
          "128:             return;",
          "129:         }",
          "130:         del -= rope[0].second - rope[0].first;",
          "131:         rope[0] = rope[1];",
          "132:         rope[1] = {NULL, NULL};",
          "133:         always_assert((ptrdiff_t)del <= rope[0].second - rope[0].first);",
          "134:         rope[0].first += del;",
          "135:         if (rope[0].first == rope[0].second) {",
          "136:             rope[0] = {NULL, NULL};",
          "137:         }",
          "138:     }",
          "140:     void memcpy_pop(uint8_t *dest, size_t size) {",
          "141:         if (size < rope[0].second-rope[0].first) {",
          "142:             memcpy(dest, rope[0].first, size);",
          "143:             rope[0].first += size;",
          "144:             return;",
          "145:         } else {",
          "146:             size_t del = rope[0].second-rope[0].first;",
          "147:             memcpy(dest, rope[0].first, del);",
          "148:             dest += del;",
          "149:             size -= del;",
          "150:             rope[0] = rope[1];",
          "151:             rope[1] = {NULL, NULL};",
          "152:         }",
          "153:         if (size) {",
          "154:             always_assert(rope[0].second - rope[0].first < size);",
          "155:             memcpy(dest, rope[0].first, size);",
          "156:             rope[0].first += size;",
          "157:             if (rope[0].first == rope[0].second) {",
          "158:                 rope[0] = {NULL, NULL};",
          "159:             }",
          "160:         }",
          "162: };",
          "168:   BiRope buffer;",
          "169:   PacketReader *reader;",
          "175:                     PacketReader *reader);",
          "180:     size_t bytes_left = r->buffer.size();",
          "181:     size_t bits_left = bytes_left * CHAR_BIT;",
          "183:     if (bits_left <= BD_VALUE_SIZE && !r->reader->eof()) {",
          "185:         uint8_t local_buffer[sizeof(BD_VALUE)] = {0};",
          "186:         r->buffer.memcpy_ro(local_buffer, bytes_left);",
          "187:         r->buffer += bytes_left; // clear it out",
          "188:         while(true) {",
          "189:             auto next = r->reader->getNext();",
          "190:             if (next.second - next.first + bytes_left <= sizeof(BD_VALUE)) {",
          "191:                 memcpy(local_buffer + bytes_left, next.first, next.second - next.first);",
          "192:                 bytes_left += next.second - next.first;",
          "193:             } else {",
          "194:                 if (bytes_left) {",
          "195:                     memcpy(r->buffer.backing, local_buffer, bytes_left);",
          "196:                     r->buffer.push({r->buffer.backing, r->buffer.backing + bytes_left});",
          "197:                 }",
          "198:                 r->buffer.push(next);",
          "199:                 break;",
          "200:             }",
          "201:             if (r->reader->eof()) {",
          "202:                 always_assert(bytes_left <= sizeof(BD_VALUE)); // otherwise we'd have break'd",
          "203:                 memcpy(r->buffer.backing, local_buffer, bytes_left);",
          "204:                 r->buffer.push({r->buffer.backing, r->buffer.backing + bytes_left});",
          "205:                 break; // setup a simplistic rope that just points to the backing store",
          "206:             }",
          "207:         }",
          "208:         bytes_left = r->buffer.size();",
          "209:         bits_left = bytes_left * CHAR_BIT;",
          "210:     }",
          "215:         r->buffer.memcpy_ro((uint8_t*)&big_endian_values, sizeof(BD_VALUE));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88:         }",
          "89:         nv = big_endian_values >> (BD_VALUE_SIZE - bits);",
          "90:         count += bits;",
          "92:         value = r->value | (nv << (shift & 0x7));",
          "93:     } else {",
          "94:         const int bits_over = (int)(shift + CHAR_BIT - bits_left);",
          "",
          "[Removed Lines]",
          "91:         buffer += (bits >> 3);",
          "",
          "[Added Lines]",
          "223:         r->buffer += (bits >> 3);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "101:         if (bits_over < 0 || bits_left) {",
          "102:             while (shift >= loop_end) {",
          "103:                 count += CHAR_BIT;",
          "105:                 shift -= CHAR_BIT;",
          "106:             }",
          "107:         }",
          "",
          "[Removed Lines]",
          "104:                 value |= (BD_VALUE)*buffer++ << shift;",
          "",
          "[Added Lines]",
          "236:                 uint8_t cur_val = 0;",
          "237:                 r->buffer.memcpy_ro(&cur_val, 1);",
          "238:                 r->buffer += 1;",
          "239:                 value |= ((BD_VALUE)cur_val) << shift;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "113:     r->value = value;",
          "114:     r->count = count;",
          "115: }",
          "",
          "[Removed Lines]",
          "112:     r->buffer += buffer - buffer_start;",
          "117: const uint8_t *vpx_reader_find_end(vpx_reader *r);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "268:   return bit;",
          "269: }",
          "275: #endif  // VPX_DSP_BITREADER_H_",
          "",
          "[Removed Lines]",
          "271: #ifdef __cplusplus",
          "272: }  // extern \"C\"",
          "273: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vp8/decoder/vpx_bool_reader.hh||src/vp8/decoder/vpx_bool_reader.hh": [
          "File: src/vp8/decoder/vpx_bool_reader.hh -> src/vp8/decoder/vpx_bool_reader.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: public:",
          "12:     void init (const uint8_t *buffer, size_t size) {",
          "13:         vpx_reader_init(&bit_reader,",
          "16:     }",
          "17:     VPXBoolReader() {",
          "18: #ifdef DEBUG_ARICODER",
          "",
          "[Removed Lines]",
          "14:                         buffer,",
          "15:                         size);",
          "",
          "[Added Lines]",
          "14:                         new TestPacketReader(buffer,",
          "15:                                              buffer + size));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c4f0b33edc4bb865feb97129c42bc10fbd0c425a",
      "candidate_info": {
        "commit_hash": "c4f0b33edc4bb865feb97129c42bc10fbd0c425a",
        "repo": "dropbox/lepton",
        "commit_url": "https://github.com/dropbox/lepton/commit/c4f0b33edc4bb865feb97129c42bc10fbd0c425a",
        "files": [
          "src/lepton/base_coders.hh",
          "src/lepton/jpgcoder.cc",
          "src/lepton/lepton_codec.cc",
          "src/lepton/lepton_codec.hh",
          "src/lepton/recoder.cc",
          "src/lepton/simple_decoder.hh",
          "src/lepton/stream_interfaces.hh",
          "src/lepton/vp8_decoder.cc",
          "src/lepton/vp8_decoder.hh",
          "src/lepton/vp8_encoder.cc",
          "src/lepton/vp8_encoder.hh",
          "src/vp8/decoder/bool_decoder.hh",
          "src/vp8/decoder/decoder.cc",
          "src/vp8/decoder/decoder.hh",
          "src/vp8/encoder/bool_encoder.hh",
          "src/vp8/encoder/encoder.cc",
          "src/vp8/encoder/encoder.hh",
          "src/vp8/model/model.hh",
          "src/vp8/util/aligned_block.hh"
        ],
        "message": "Add BoolDecoder and BoolEncoder as template arguments rather than as toplevel defines. This required a significant amount of threading of the BoolDecoder through each of the state classes",
        "before_after_code_files": [
          "src/lepton/base_coders.hh||src/lepton/base_coders.hh",
          "src/lepton/jpgcoder.cc||src/lepton/jpgcoder.cc",
          "src/lepton/lepton_codec.cc||src/lepton/lepton_codec.cc",
          "src/lepton/lepton_codec.hh||src/lepton/lepton_codec.hh",
          "src/lepton/recoder.cc||src/lepton/recoder.cc",
          "src/lepton/simple_decoder.hh||src/lepton/simple_decoder.hh",
          "src/lepton/stream_interfaces.hh||src/lepton/stream_interfaces.hh",
          "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc",
          "src/lepton/vp8_decoder.hh||src/lepton/vp8_decoder.hh",
          "src/lepton/vp8_encoder.cc||src/lepton/vp8_encoder.cc",
          "src/lepton/vp8_encoder.hh||src/lepton/vp8_encoder.hh",
          "src/vp8/decoder/bool_decoder.hh||src/vp8/decoder/bool_decoder.hh",
          "src/vp8/decoder/decoder.cc||src/vp8/decoder/decoder.cc",
          "src/vp8/decoder/decoder.hh||src/vp8/decoder/decoder.hh",
          "src/vp8/encoder/bool_encoder.hh||src/vp8/encoder/bool_encoder.hh",
          "src/vp8/encoder/encoder.cc||src/vp8/encoder/encoder.cc",
          "src/vp8/encoder/encoder.hh||src/vp8/encoder/encoder.hh",
          "src/vp8/model/model.hh||src/vp8/model/model.hh",
          "src/vp8/util/aligned_block.hh||src/vp8/util/aligned_block.hh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lepton/lepton_codec.cc||src/lepton/lepton_codec.cc",
            "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc"
          ],
          "candidate": [
            "src/lepton/lepton_codec.cc||src/lepton/lepton_codec.cc",
            "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/lepton/base_coders.hh||src/lepton/base_coders.hh": [
          "File: src/lepton/base_coders.hh -> src/lepton/base_coders.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:     virtual void flush() = 0;",
          "48:     virtual void map_logical_thread_to_physical_thread(int thread_id, int target_thread_state) = 0;",
          "49:     virtual void clear_thread_state(int thread_id, int target_thread_state, BlockBasedImagePerChannel<true>& framebuffer) = 0;",
          "50: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50:     virtual void reset_all_comm_buffers() = 0;",
          "",
          "---------------"
        ],
        "src/lepton/jpgcoder.cc||src/lepton/jpgcoder.cc": [
          "File: src/lepton/jpgcoder.cc -> src/lepton/jpgcoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "83: #include \"../io/BufferedIO.hh\"",
          "84: #include \"../io/Zlib0.hh\"",
          "85: #include \"../io/Seccomp.hh\"",
          "88: #ifdef EMSCRIPTEN",
          "89: #include <emscripten.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86: #include \"../vp8/encoder/vpx_bool_writer.hh\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "438:     return retval;",
          "439: }",
          "443:     TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();",
          "444:     if (start_workers) {",
          "445:         retval->registerWorkers(get_worker_threads(",
          "",
          "[Removed Lines]",
          "441: VP8ComponentDecoder *makeBoth(bool threaded, bool start_workers) {",
          "442:     VP8ComponentDecoder *retval = new VP8ComponentDecoder(threaded);",
          "",
          "[Added Lines]",
          "441: template <class BoolEncoder>VP8ComponentDecoder<BoolEncoder> *makeBoth(bool threaded, bool start_workers) {",
          "442:     VP8ComponentDecoder<BoolEncoder> *retval = new VP8ComponentDecoder<BoolEncoder>(threaded);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "451:     return retval;",
          "452: }",
          "455:     TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT_BEGIN] = TimingHarness::get_time_us();",
          "457:     TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();",
          "458:     if (start_workers) {",
          "459:         retval->registerWorkers(get_worker_threads(NUM_THREADS - 1), NUM_THREADS - 1);",
          "",
          "[Removed Lines]",
          "454: BaseEncoder *makeEncoder(bool threaded, bool start_workers) {",
          "456:     VP8ComponentEncoder * retval = new VP8ComponentEncoder(threaded);",
          "",
          "[Added Lines]",
          "454: template <class BoolDecoder>BaseEncoder *makeEncoder(bool threaded, bool start_workers) {",
          "456:     VP8ComponentEncoder<BoolDecoder> * retval = new VP8ComponentEncoder<BoolDecoder>(threaded, IsDecoderAns<BoolDecoder>::IS_ANS);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "461:     return retval;",
          "462: }",
          "463: BaseDecoder *makeDecoder(bool threaded, bool start_workers) {",
          "465: }",
          "467:     global variables: info about files",
          "",
          "[Removed Lines]",
          "464:     return makeBoth(threaded, start_workers);",
          "",
          "[Added Lines]",
          "464:     return makeBoth<VPXBoolReader>(threaded, start_workers);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1190:         exit(1);",
          "1191:     }",
          "1192:     if (g_do_preload && g_skip_validation) {",
          "1194:         g_encoder.reset(d);",
          "1195:         g_decoder = d;",
          "1196:     }",
          "",
          "[Removed Lines]",
          "1193:         VP8ComponentDecoder *d = makeBoth(g_threaded, g_threaded && action != forkserve && action != socketserve);",
          "",
          "[Added Lines]",
          "1193:         VP8ComponentDecoder<VPXBoolReader> *d = makeBoth<VPXBoolReader>(g_threaded, g_threaded && action != forkserve && action != socketserve);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1609:         if (ofiletype == LEPTON) {",
          "1610:             if (!g_encoder) {",
          "1612:                 TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();",
          "1613:                 g_decoder = NULL;",
          "1614:             } else if (g_threaded && (action == socketserve || action == forkserve)) {",
          "",
          "[Removed Lines]",
          "1611:                 g_encoder.reset(makeEncoder(g_threaded, g_threaded));",
          "",
          "[Added Lines]",
          "1611:                 g_encoder.reset(makeEncoder<VPXBoolReader>(g_threaded, g_threaded));",
          "",
          "---------------"
        ],
        "src/lepton/lepton_codec.cc||src/lepton/lepton_codec.cc": [
          "File: src/lepton/lepton_codec.cc -> src/lepton/lepton_codec.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:                                           Middle& middle_model,",
          "10:                                           Right& right_model,",
          "11:                                           int curr_y,",
          "",
          "[Removed Lines]",
          "7: template<class Left, class Middle, class Right, bool force_memory_optimization>",
          "8: void LeptonCodec::ThreadState::decode_row(Left & left_model,",
          "",
          "[Added Lines]",
          "7: template<class BoolDecoder> template<class Left, class Middle, class Right, bool force_memory_optimization>",
          "8: void LeptonCodec<BoolDecoder>::ThreadState::decode_row(Left & left_model,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:                                           Sirikata::Array1d<uint32_t,",
          "94:                                                             (uint32_t)ColorChannel::",
          "95:                                                             NumBlockTypes> component_size_in_blocks,",
          "",
          "[Removed Lines]",
          "92: void LeptonCodec::ThreadState::decode_row_wrapper(BlockBasedImagePerChannel<true>& image_data,",
          "",
          "[Added Lines]",
          "92: template <class BoolDecoder>",
          "93: void LeptonCodec<BoolDecoder>::ThreadState::decode_row_wrapper(BlockBasedImagePerChannel<true>& image_data,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97:                                           int curr_y) {",
          "98:     return decode_rowt(image_data, component_size_in_blocks, component, curr_y);",
          "99: }",
          "101:                                           Sirikata::Array1d<uint32_t,",
          "102:                                                             (uint32_t)ColorChannel::",
          "103:                                                             NumBlockTypes> component_size_in_blocks,",
          "",
          "[Removed Lines]",
          "100: void LeptonCodec::ThreadState::decode_rowf(BlockBasedImagePerChannel<false>& image_data,",
          "",
          "[Added Lines]",
          "101: template <class BoolDecoder>",
          "102: void LeptonCodec<BoolDecoder>::ThreadState::decode_rowf(BlockBasedImagePerChannel<false>& image_data,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "105:                                           int curr_y) {",
          "106:     decode_row_internal(image_data, component_size_in_blocks,component,curr_y);",
          "107: }",
          "109:                                           Sirikata::Array1d<uint32_t,",
          "110:                                                             (uint32_t)ColorChannel::",
          "111:                                                             NumBlockTypes> component_size_in_blocks,",
          "",
          "[Removed Lines]",
          "108: void LeptonCodec::ThreadState::decode_rowt(BlockBasedImagePerChannel<true>& image_data,",
          "",
          "[Added Lines]",
          "110: template <class BoolDecoder>",
          "111: void LeptonCodec<BoolDecoder>::ThreadState::decode_rowt(BlockBasedImagePerChannel<true>& image_data,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "113:                                           int curr_y) {",
          "114:     decode_row_internal(image_data, component_size_in_blocks,component,curr_y);",
          "115: }",
          "118:                                           Sirikata::Array1d<uint32_t,",
          "119:                                                             (uint32_t)ColorChannel::",
          "120:                                                             NumBlockTypes> component_size_in_blocks,",
          "",
          "[Removed Lines]",
          "116: template<bool force_memory_optimization>",
          "117: void LeptonCodec::ThreadState::decode_row_internal(BlockBasedImagePerChannel<force_memory_optimization>& image_data,",
          "",
          "[Added Lines]",
          "119: template <class BoolDecoder> template<bool force_memory_optimization>",
          "120: void LeptonCodec<BoolDecoder>::ThreadState::decode_row_internal(BlockBasedImagePerChannel<force_memory_optimization>& image_data,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "260:         }",
          "261:     }",
          "262: }",
          "265:                                                               UncompressedComponents *const colldata) {",
          "266:     Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks;",
          "267:     BlockBasedImagePerChannel<false> image_data;",
          "",
          "[Removed Lines]",
          "264: CodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id,",
          "",
          "[Added Lines]",
          "266: template <class BoolDecoder>",
          "267: CodingReturnValue LeptonCodec<BoolDecoder>::ThreadState::vp8_decode_thread(unsigned int thread_id,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "279:     int min_y = luma_splits_[0];",
          "280:     int max_y = luma_splits_[1];",
          "281:     while(true) {",
          "283:         if (cur_row.done) {",
          "284:             break;",
          "285:         }",
          "",
          "[Removed Lines]",
          "282:         RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);",
          "",
          "[Added Lines]",
          "285:         LeptonCodec_RowSpec cur_row = LeptonCodec_row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "304:     }",
          "305:     return CODING_DONE;",
          "306: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312: template<class BoolDecoder> void LeptonCodec<BoolDecoder>::worker_thread(ThreadState *ts, int thread_id, UncompressedComponents * const colldata,",
          "313:                                         int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID],",
          "314:                                         GenericWorker *worker,",
          "315:                                         VP8ComponentDecoder_SendToActualThread *send_to_actual_thread_state) {",
          "316:     TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();",
          "317:     for (uint8_t i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {",
          "318:         if (thread_target[i] == int8_t(thread_id)) {",
          "319:             ts->bool_decoder_.init(new ActualThreadPacketReader(i,worker, send_to_actual_thread_state));",
          "320:         }",
          "321:     }",
          "322:     while (ts->vp8_decode_thread(thread_id, colldata) == CODING_PARTIAL) {",
          "323:     }",
          "324:     TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();",
          "325: }",
          "326: template class LeptonCodec<VPXBoolReader>;",
          "",
          "---------------"
        ],
        "src/lepton/lepton_codec.hh||src/lepton/lepton_codec.hh": [
          "File: src/lepton/lepton_codec.hh -> src/lepton/lepton_codec.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include \"model.hh\"",
          "5: #include \"bool_decoder.hh\"",
          "6: #include \"base_coders.hh\"",
          "7: class UncompressedComponents;",
          "10: protected:",
          "11:     struct ThreadState {",
          "12:         ProbabilityTablesBase model_;",
          "",
          "[Removed Lines]",
          "9: class LeptonCodec {",
          "",
          "[Added Lines]",
          "7: #include \"../../io/MuxReader.hh\"",
          "8: #include \"stream_interfaces.hh\"",
          "10:     struct LeptonCodec_RowSpec {",
          "11:         int min_row_luma_y;",
          "12:         int next_row_luma_y;",
          "13:         int luma_y;",
          "14:         int component;",
          "15:         int curr_y;",
          "16:         int mcu_row_index;",
          "17:         bool last_row_to_complete_mcu;",
          "18:         bool skip;",
          "19:         bool done;",
          "20:     };",
          "22: template<class BoolDecoder> struct IsDecoderAns {",
          "23: };",
          "24: template<> struct IsDecoderAns<ANSBoolReader> {",
          "25:     enum {",
          "26:         IS_ANS = true",
          "27:     };",
          "28: };",
          "30: template<> struct IsDecoderAns<VPXBoolReader> {",
          "31:     enum {",
          "32:         IS_ANS = false",
          "33:     };",
          "34: };",
          "38: class VP8ComponentDecoder_SendToActualThread;",
          "40: template<class BlockBasedImagePerChannels>",
          "41: static LeptonCodec_RowSpec LeptonCodec_row_spec_from_index(uint32_t decode_index,",
          "42:                                                const BlockBasedImagePerChannels& image_data,",
          "43:                                                int mcuv, // number of mcus",
          "44:                                                Sirikata::Array1d<uint32_t,",
          "45:                                                (size_t)ColorChannel",
          "46:                                                ::NumBlockTypes> max_coded_heights) {",
          "48:     uint32_t num_cmp = (uint32_t)ColorChannel::NumBlockTypes;",
          "49:     uint32_t heights[(uint32_t)ColorChannel::NumBlockTypes] = {0};",
          "50:     uint32_t component_multiple[(uint32_t)ColorChannel::NumBlockTypes] = {0};",
          "51:     uint32_t mcu_multiple = 0;",
          "52:     for (uint32_t i = 0; i < num_cmp; ++i) {",
          "53:         heights[i] = image_data[i] ? image_data[i]->original_height() : 0;",
          "54:         component_multiple[i] = heights[i] / mcuv;",
          "55:         mcu_multiple += component_multiple[i];",
          "56:     }",
          "57:     uint32_t mcu_row = decode_index / mcu_multiple;",
          "58:     LeptonCodec_RowSpec retval = {0, 0, 0, 0, 0, 0, false, false, false};",
          "59:     retval.skip = false;",
          "60:     retval.done = false;",
          "61:     retval.mcu_row_index = mcu_row;",
          "62:     uint32_t place_within_scan = decode_index - mcu_row * mcu_multiple;",
          "63:     retval.component = num_cmp;",
          "64:     retval.min_row_luma_y = (mcu_row) * component_multiple[0];",
          "65:     retval.next_row_luma_y =  retval.min_row_luma_y + component_multiple[0];",
          "66:     retval.luma_y = retval.min_row_luma_y;",
          "67:     for (uint32_t i = num_cmp - 1; true; --i) {",
          "68:         if (place_within_scan < component_multiple[i]) {",
          "69:             retval.component = i;",
          "70:             retval.curr_y = mcu_row * component_multiple[i] + place_within_scan;",
          "71:             retval.last_row_to_complete_mcu = (place_within_scan + 1 == component_multiple[i]",
          "72:                                                && i == 0);",
          "73:             if (retval.curr_y >= int( max_coded_heights[i] ) ) {",
          "74:                 retval.skip = true;",
          "75:                 retval.done = true; // assume true, but if we find something that needs coding, set false",
          "76:                 for (uint32_t j = 0; j < num_cmp - 1; ++j) {",
          "77:                     if (mcu_row * component_multiple[j] < max_coded_heights[j]) {",
          "78:                         retval.done = false; // we want to make sure to write out any partial rows,",
          "81:                     }",
          "82:                 }",
          "83:             }",
          "84:             if (i == 0) {",
          "85:                 retval.luma_y = retval.curr_y;",
          "86:             }",
          "87:             break;",
          "88:         } else {",
          "89:             place_within_scan -= component_multiple[i];",
          "90:         }",
          "91:         if (i == 0) {",
          "92:             dev_assert(false);",
          "93:             retval.skip = true;",
          "94:             retval.done = true;",
          "95:             break;",
          "96:         }",
          "97:     }",
          "98:     return retval;",
          "99: }",
          "101: template <class BoolDecoder> class LeptonCodec{",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:         return a;",
          "67:     }",
          "68: public:",
          "140: protected:",
          "141:     bool do_threading_;",
          "142:     GenericWorker* spin_workers_;",
          "",
          "[Removed Lines]",
          "69:     struct RowSpec {",
          "70:         int min_row_luma_y;",
          "71:         int next_row_luma_y;",
          "72:         int luma_y;",
          "73:         int component;",
          "74:         int curr_y;",
          "75:         int mcu_row_index;",
          "76:         bool last_row_to_complete_mcu;",
          "77:         bool skip;",
          "78:         bool done;",
          "79:     };",
          "80:     template<class BlockBasedImagePerChannels>",
          "81:     static RowSpec row_spec_from_index(uint32_t decode_index,",
          "82:                                        const BlockBasedImagePerChannels& image_data,",
          "83:            int mcuv, // number of mcus",
          "84:                                        Sirikata::Array1d<uint32_t,",
          "85:                                                          (size_t)ColorChannel",
          "86:                                                          ::NumBlockTypes> max_coded_heights) {",
          "88:         uint32_t num_cmp = (uint32_t)ColorChannel::NumBlockTypes;",
          "89:         uint32_t heights[(uint32_t)ColorChannel::NumBlockTypes] = {0};",
          "90:         uint32_t component_multiple[(uint32_t)ColorChannel::NumBlockTypes] = {0};",
          "91:         uint32_t mcu_multiple = 0;",
          "92:         for (uint32_t i = 0; i < num_cmp; ++i) {",
          "93:             heights[i] = image_data[i] ? image_data[i]->original_height() : 0;",
          "94:             component_multiple[i] = heights[i] / mcuv;",
          "95:             mcu_multiple += component_multiple[i];",
          "96:         }",
          "97:         uint32_t mcu_row = decode_index / mcu_multiple;",
          "98:         RowSpec retval = {0, 0, 0, 0, 0, 0, false, false, false};",
          "99:         retval.skip = false;",
          "100:         retval.done = false;",
          "101:         retval.mcu_row_index = mcu_row;",
          "102:         uint32_t place_within_scan = decode_index - mcu_row * mcu_multiple;",
          "103:         retval.component = num_cmp;",
          "104:         retval.min_row_luma_y = (mcu_row) * component_multiple[0];",
          "105:         retval.next_row_luma_y =  retval.min_row_luma_y + component_multiple[0];",
          "106:         retval.luma_y = retval.min_row_luma_y;",
          "107:         for (uint32_t i = num_cmp - 1; true; --i) {",
          "108:             if (place_within_scan < component_multiple[i]) {",
          "109:                 retval.component = i;",
          "110:                 retval.curr_y = mcu_row * component_multiple[i] + place_within_scan;",
          "111:                 retval.last_row_to_complete_mcu = (place_within_scan + 1 == component_multiple[i]",
          "112:                                                    && i == 0);",
          "113:                 if (retval.curr_y >= int( max_coded_heights[i] ) ) {",
          "114:                     retval.skip = true;",
          "115:                     retval.done = true; // assume true, but if we find something that needs coding, set false",
          "116:                     for (uint32_t j = 0; j < num_cmp - 1; ++j) {",
          "117:                         if (mcu_row * component_multiple[j] < max_coded_heights[j]) {",
          "118:                             retval.done = false; // we want to make sure to write out any partial rows,",
          "121:                         }",
          "122:                     }",
          "123:                 }",
          "124:                 if (i == 0) {",
          "125:                     retval.luma_y = retval.curr_y;",
          "126:                 }",
          "127:                 break;",
          "128:             } else {",
          "129:                 place_within_scan -= component_multiple[i];",
          "130:             }",
          "131:             if (i == 0) {",
          "132:                 dev_assert(false);",
          "133:                 retval.skip = true;",
          "134:                 retval.done = true;",
          "135:                 break;",
          "136:             }",
          "137:         }",
          "138:         return retval;",
          "139:     }",
          "",
          "[Added Lines]",
          "161:     static void worker_thread(ThreadState *, int thread_id, UncompressedComponents * const colldata,",
          "162:                               int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID],",
          "163:                               GenericWorker*worker,",
          "164:                               VP8ComponentDecoder_SendToActualThread*data_receiver);",
          "",
          "---------------"
        ],
        "src/lepton/recoder.cc||src/lepton/recoder.cc": [
          "File: src/lepton/recoder.cc -> src/lepton/recoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "483:                                                 retval.num_overhang_bits);",
          "484:     int decode_index = 0;",
          "485:     while (true) {",
          "487:                                                                         framebuffer,",
          "488:                                                                         mcuv,",
          "489:                                                                         max_coded_heights);",
          "",
          "[Removed Lines]",
          "486:         LeptonCodec::RowSpec cur_row = LeptonCodec::row_spec_from_index(decode_index++,",
          "",
          "[Added Lines]",
          "486:         LeptonCodec_RowSpec cur_row = LeptonCodec_row_spec_from_index(decode_index++,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "725:     if (luma_bounds.size() && luma_bounds[0].is_legacy_mode()) {",
          "726:         g_threaded = false;",
          "727:     }",
          "729:     for (unsigned int physical_thread_id = 1; physical_thread_id < (g_threaded ? NUM_THREADS : 1); ++physical_thread_id) {",
          "730:         int logical_thread_start, logical_thread_end;",
          "731:         std::tie(logical_thread_start, logical_thread_end)",
          "732:             = logical_thread_range_from_physical_thread_id(physical_thread_id, luma_bounds.size());",
          "733:         for (int log_thread = logical_thread_start; log_thread < logical_thread_end; ++log_thread) {",
          "735:         }",
          "736:     }",
          "",
          "[Removed Lines]",
          "728:     static_cast<VP8ComponentDecoder*>(g_decoder)->reset_all_comm_buffers();",
          "734:             static_cast<VP8ComponentDecoder*>(g_decoder)->map_logical_thread_to_physical_thread(log_thread, physical_thread_id);",
          "",
          "[Added Lines]",
          "728:     g_decoder->reset_all_comm_buffers();",
          "734:             g_decoder->map_logical_thread_to_physical_thread(log_thread, physical_thread_id);",
          "",
          "---------------"
        ],
        "src/lepton/simple_decoder.hh||src/lepton/simple_decoder.hh": [
          "File: src/lepton/simple_decoder.hh -> src/lepton/simple_decoder.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:     unsigned int getNumWorkers() const {",
          "23:         return 0;",
          "24:     }",
          "26:     GenericWorker *getWorker(unsigned int i) {",
          "27:         return NULL;",
          "28:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25:     void reset_all_comm_buffers(){}",
          "",
          "---------------"
        ],
        "src/lepton/stream_interfaces.hh||src/lepton/stream_interfaces.hh": [
          "File: src/lepton/stream_interfaces.hh -> src/lepton/stream_interfaces.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"jpgcoder.hh\"",
          "2: #include \"model.hh\"",
          "3: #include \"bool_decoder.hh\"",
          "4: #include \"base_coders.hh\"",
          "5: #include \"../../io/MuxReader.hh\"",
          "8: struct ResizableByteBufferListNode : public Sirikata::MuxReader::ResizableByteBuffer {",
          "9:     uint8_t stream_id;",
          "10:     ResizableByteBufferListNode *next;",
          "11:     ResizableByteBufferListNode(){",
          "12:         stream_id = 0;",
          "13:         next = NULL;",
          "14:     }",
          "15: };",
          "16: struct ResizableByteBufferList {",
          "17:     ResizableByteBufferListNode * head;",
          "18:     ResizableByteBufferListNode * tail;",
          "19:     ResizableByteBufferList() {",
          "20:         head = NULL;",
          "21:         tail = NULL;",
          "22:     }",
          "23:     void push(ResizableByteBufferListNode * item) {",
          "24:         always_assert(item);",
          "25:         if (!tail) {",
          "26:             always_assert(!head);",
          "27:             head = tail = item;",
          "28:         } else {",
          "29:             always_assert(!tail->next);",
          "30:             tail->next = item;",
          "31:             tail = item;",
          "32:         }",
          "33:     }",
          "34:     bool empty()const {",
          "35:         return head == NULL && tail == NULL;",
          "36:     }",
          "37:     bool size_gt_1()const {",
          "38:         return head != tail;",
          "39:     }",
          "40:     ResizableByteBufferListNode * front() {",
          "41:         return head;",
          "42:     }",
          "43:     const ResizableByteBufferListNode * front() const{",
          "44:         return head;",
          "45:     }",
          "46:     ResizableByteBufferListNode * pop() {",
          "47:         always_assert(!empty());",
          "48:         auto retval = head;",
          "49:         if (tail == head) {",
          "50:             always_assert(tail->next == NULL);",
          "51:             head = NULL;",
          "52:             tail = NULL;",
          "53:             return retval;",
          "54:         }",
          "55:         head = head->next;",
          "56:         return retval;",
          "57:     }",
          "58: };",
          "61: class VP8ComponentDecoder_SendToVirtualThread {",
          "62:     ResizableByteBufferList vbuffers[Sirikata::MuxReader::MAX_STREAM_ID];",
          "64:     GenericWorker *all_workers;",
          "65:     bool eof;",
          "66:     void set_eof();",
          "67: public:",
          "68:     int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID]; // 0 is the current thread",
          "69:     VP8ComponentDecoder_SendToVirtualThread();",
          "70:     void init(GenericWorker *generic_workers);",
          "72:     void bind_thread(uint8_t virtual_thread_id, int8_t physical_thread_id) {",
          "73:         thread_target[virtual_thread_id] = physical_thread_id;",
          "74:     }",
          "75:     void send(ResizableByteBufferListNode *data);",
          "76:     void drain(Sirikata::MuxReader&reader);",
          "78:     ResizableByteBufferListNode* read(Sirikata::MuxReader&reader, uint8_t stream_id);",
          "79:     void read_all(Sirikata::MuxReader&reader);",
          "80: };",
          "81: class VP8ComponentDecoder_SendToActualThread {",
          "82: public:",
          "83:     ResizableByteBufferList vbuffers[Sirikata::MuxReader::MAX_STREAM_ID];",
          "84: };",
          "86: class ActualThreadPacketReader : public PacketReader{",
          "87:     GenericWorker *worker;",
          "88:     VP8ComponentDecoder_SendToActualThread *base;",
          "89:     uint8_t stream_id;",
          "90:     ResizableByteBufferListNode* last;",
          "91: public:",
          "92:     ActualThreadPacketReader(uint8_t stream_id, GenericWorker*worker, VP8ComponentDecoder_SendToActualThread*base) {",
          "93:         this->worker = worker;",
          "94:         this->stream_id = stream_id;",
          "95:         this->base = base;",
          "96:     }",
          "98:     virtual ROBuffer getNext() {",
          "99:         if (!base->vbuffers[stream_id].empty()) {",
          "100:             auto retval = base->vbuffers[stream_id].front();",
          "101:             if (!retval->empty()) {",
          "102:                 base->vbuffers[stream_id].pop();",
          "103:             }",
          "104:             if (retval->empty()) {",
          "105:                 isEof = true;",
          "106:                 return {NULL, NULL};",
          "107:             }",
          "108:             return {retval->data(), retval->data() + retval->size()};",
          "109:         }",
          "110:         while(!isEof) {",
          "111:             auto dat = worker->batch_recv_data();",
          "112:             for (unsigned int i = 0; i < dat.count; ++i) {",
          "113:                 ResizableByteBufferListNode* lnode = (ResizableByteBufferListNode*) dat.data[i];",
          "114:                 if (dat.count == 1 && lnode->stream_id == stream_id && lnode && lnode->size()) {",
          "115:                     assert(stream_id == lnode->stream_id);",
          "116:                     last = lnode;",
          "117:                     return {lnode->data(), lnode->data() + lnode->size()};",
          "118:                 } else {",
          "119:                     base->vbuffers[lnode->stream_id].push(lnode);",
          "120:                 }",
          "121:             }",
          "122:             if (!base->vbuffers[stream_id].empty()) {",
          "123:                 return getNext(); // recursive call, 1 deep",
          "124:             }",
          "125:             if (dat.return_code < 0) {",
          "126:                 isEof = true; // hmm... should we bail here?",
          "127:                 always_assert(false);",
          "128:             }",
          "129:         }",
          "130:         return {NULL, NULL};",
          "131:     }",
          "132:     bool eof()const {",
          "133:         return isEof;",
          "134:     }",
          "135:     virtual void setFree(ROBuffer buffer) {// don't even bother",
          "136:         if (last && last->data() == buffer.first) {",
          "137:             delete last; // hax",
          "138:             last = NULL;",
          "139:         }",
          "140:     }",
          "141:     virtual ~ActualThreadPacketReader(){}",
          "142: };",
          "",
          "---------------"
        ],
        "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc": [
          "File: src/lepton/vp8_decoder.cc -> src/lepton/vp8_decoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include \"../io/Reader.hh\"",
          "15: #include \"../vp8/decoder/decoder.hh\"",
          "16: using namespace std;",
          "18:                                       const std::vector<ThreadHandoff>& thread_handoff)",
          "19: {",
          "20:     str_in = input;",
          "21:     mux_reader_.init(input);",
          "22:     thread_handoff_ = thread_handoff;",
          "23: }",
          "25:                                      BlockBasedImagePerChannel<true>& image_data, // FIXME: set image_data to true",
          "26:                                      Sirikata::Array1d<uint32_t,",
          "27:                                                        (uint32_t)ColorChannel::",
          "28:                                                        NumBlockTypes> component_size_in_blocks,",
          "29:                                      int component,",
          "30:                                      int curr_y) {",
          "32:                                                component_size_in_blocks,",
          "33:                                                component,",
          "34:                                                curr_y);",
          "35: }",
          "40:       mux_reader_(Sirikata::JpegAllocator<uint8_t>(),",
          "41:                   8,",
          "42:                   0) {",
          "43:     virtual_thread_id_ = -1;",
          "44: }",
          "48: }",
          "",
          "[Removed Lines]",
          "17: void VP8ComponentDecoder::initialize( Sirikata::DecoderReader *input,",
          "24: void VP8ComponentDecoder::decode_row(int target_thread_id,",
          "31:     thread_state_[target_thread_id]->decode_rowt(image_data,",
          "38: VP8ComponentDecoder::VP8ComponentDecoder(bool do_threading)",
          "39:     : VP8ComponentEncoder(do_threading),",
          "46: VP8ComponentDecoder::~VP8ComponentDecoder() {",
          "",
          "[Added Lines]",
          "17: template<class BoolEncoder>",
          "18: void VP8ComponentDecoder<BoolEncoder>::initialize( Sirikata::DecoderReader *input,",
          "25: template<class BoolEncoder>",
          "26: void VP8ComponentDecoder<BoolEncoder>::decode_row(int target_thread_id,",
          "33:     this->thread_state_[target_thread_id]->decode_rowt(image_data,",
          "40: template<class BoolDecoder>",
          "41: VP8ComponentDecoder<BoolDecoder>::VP8ComponentDecoder(bool do_threading)",
          "42:     : VP8ComponentEncoder<BoolDecoder>(do_threading, IsDecoderAns<BoolDecoder>::IS_ANS),",
          "48: template<class BoolEncoder>",
          "49: VP8ComponentDecoder<BoolEncoder>::~VP8ComponentDecoder() {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:                         BlockType::Cr",
          "69: #endif",
          "74:     initialize_thread_id(thread_id, target_thread_state, framebuffer);",
          "75:     initialize_bool_decoder(thread_id, target_thread_state);",
          "76: }",
          "148: class VirtualThreadPacketReader : public PacketReader{",
          "150:     uint8_t stream_id;",
          "151:     Sirikata::MuxReader*mux_reader_;",
          "152:     Sirikata::MuxReader::ResizableByteBuffer * last;",
          "153: public:",
          "155:         this->base = base;",
          "156:         this->stream_id = stream_id;",
          "157:         this->mux_reader_ = mr;",
          "",
          "[Removed Lines]",
          "71: void VP8ComponentDecoder::clear_thread_state(int thread_id, int target_thread_state, BlockBasedImagePerChannel<true>& framebuffer) {",
          "77: class ActualThreadPacketReader : public PacketReader{",
          "78:     GenericWorker *worker;",
          "79:     VP8ComponentDecoder::SendToActualThread *base;",
          "80:     uint8_t stream_id;",
          "81:     ResizableByteBufferListNode* last;",
          "82: public:",
          "83:     ActualThreadPacketReader(uint8_t stream_id, GenericWorker*worker, VP8ComponentDecoder::SendToActualThread*base) {",
          "84:         this->worker = worker;",
          "85:         this->stream_id = stream_id;",
          "86:         this->base = base;",
          "87:     }",
          "89:     virtual ROBuffer getNext() {",
          "90:         if (!base->vbuffers[stream_id].empty()) {",
          "91:             auto retval = base->vbuffers[stream_id].front();",
          "92:             if (!retval->empty()) {",
          "93:                 base->vbuffers[stream_id].pop();",
          "94:             }",
          "95:             if (retval->empty()) {",
          "96:                 isEof = true;",
          "97:                 return {NULL, NULL};",
          "98:             }",
          "99:             return {retval->data(), retval->data() + retval->size()};",
          "100:         }",
          "101:         while(!isEof) {",
          "102:             auto dat = worker->batch_recv_data();",
          "103:             for (unsigned int i = 0; i < dat.count; ++i) {",
          "104:                 ResizableByteBufferListNode* lnode = (ResizableByteBufferListNode*) dat.data[i];",
          "105:                 if (dat.count == 1 && lnode->stream_id == stream_id && lnode && lnode->size()) {",
          "106:                     assert(stream_id == lnode->stream_id);",
          "107:                     last = lnode;",
          "108:                     return {lnode->data(), lnode->data() + lnode->size()};",
          "109:                 } else {",
          "110:                     base->vbuffers[lnode->stream_id].push(lnode);",
          "111:                 }",
          "112:             }",
          "113:             if (!base->vbuffers[stream_id].empty()) {",
          "114:                 return getNext(); // recursive call, 1 deep",
          "115:             }",
          "116:             if (dat.return_code < 0) {",
          "117:                 isEof = true; // hmm... should we bail here?",
          "118:                 always_assert(false);",
          "119:             }",
          "120:         }",
          "121:         return {NULL, NULL};",
          "122:     }",
          "123:     bool eof()const {",
          "124:         return isEof;",
          "125:     }",
          "126:     virtual void setFree(ROBuffer buffer) {// don't even bother",
          "127:         if (last && last->data() == buffer.first) {",
          "128:             delete last; // hax",
          "129:             last = NULL;",
          "130:         }",
          "131:     }",
          "132:     virtual ~ActualThreadPacketReader(){}",
          "133: };",
          "134: void VP8ComponentDecoder::worker_thread(ThreadState *ts, int thread_id, UncompressedComponents * const colldata,",
          "135:                                         int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID],",
          "136:                                         GenericWorker *worker,",
          "137:                                         SendToActualThread *send_to_actual_thread_state) {",
          "138:     TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();",
          "139:     for (uint8_t i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {",
          "140:         if (thread_target[i] == int8_t(thread_id)) {",
          "141:             ts->bool_decoder_.init(new ActualThreadPacketReader(i,worker, send_to_actual_thread_state));",
          "142:         }",
          "143:     }",
          "144:     while (ts->vp8_decode_thread(thread_id, colldata) == CODING_PARTIAL) {",
          "145:     }",
          "146:     TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();",
          "147: }",
          "149:     VP8ComponentDecoder::SendToVirtualThread*base;",
          "154:     VirtualThreadPacketReader(uint8_t stream_id, Sirikata::MuxReader * mr, VP8ComponentDecoder::SendToVirtualThread*base) {",
          "",
          "[Added Lines]",
          "74: template <class BoolEncoder>",
          "75: void VP8ComponentDecoder<BoolEncoder>::clear_thread_state(int thread_id, int target_thread_state, BlockBasedImagePerChannel<true>& framebuffer) {",
          "83:     VP8ComponentDecoder_SendToVirtualThread*base;",
          "88:     VirtualThreadPacketReader(uint8_t stream_id, Sirikata::MuxReader * mr, VP8ComponentDecoder_SendToVirtualThread*base) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "179:     virtual ~VirtualThreadPacketReader(){}",
          "180: };",
          "183:     if (NUM_THREADS > 1 && g_threaded) {",
          "185:                                                                                             getWorker(target_thread_state),",
          "186:                                                                                             &send_to_actual_thread_state));",
          "187:     } else {",
          "189:     }",
          "190: }",
          "194:                                                BlockBasedImagePerChannel<force_memory_optimized>& framebuffer) {",
          "195:     if (target_thread_state) {",
          "197:     }",
          "198:     TimingHarness::timing[thread_id%NUM_THREADS][TimingHarness::TS_STREAM_MULTIPLEX_STARTED] = TimingHarness::get_time_us();",
          "203:     for (unsigned int i = 0; i < framebuffer.size(); ++i) {",
          "204:         if (framebuffer[i] != NULL)  {",
          "209:         }",
          "210:     }",
          "212:     int index = thread_id;",
          "213:     always_assert((size_t)index < streams_.size());",
          "217:     if ((size_t)index < thread_handoff_.size()) {",
          "220:     } else {",
          "226:     }",
          "229:     TimingHarness::timing[thread_id%NUM_THREADS][TimingHarness::TS_STREAM_MULTIPLEX_FINISHED] = TimingHarness::get_time_us();",
          "230: }",
          "232:     const UncompressedComponents * const colldata,",
          "233:     Sirikata::Array1d<BlockBasedImagePerChannel<true>,",
          "234:                       MAX_NUM_THREADS>& framebuffer) {",
          "236:     return initialize_decoder_state(colldata, framebuffer);",
          "237: }",
          "240:     using namespace Sirikata;",
          "241:     if (!eof) {",
          "242:         for (unsigned int thread_id = 0; thread_id < Sirikata::MuxReader::MAX_STREAM_ID; ++thread_id) {",
          "",
          "[Removed Lines]",
          "182: void VP8ComponentDecoder::initialize_bool_decoder(int thread_id, int target_thread_state) {",
          "184:         thread_state_[target_thread_state]->bool_decoder_.init(new ActualThreadPacketReader(thread_id,",
          "188:         thread_state_[target_thread_state]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));",
          "192:     template <bool force_memory_optimized>",
          "193: void VP8ComponentDecoder::initialize_thread_id(int thread_id, int target_thread_state,",
          "196:         always_assert(spin_workers_);",
          "200:         reset_thread_model_state(target_thread_state);",
          "202:     thread_state_[target_thread_state]->decode_index_ = 0;",
          "205:             thread_state_[target_thread_state]->is_top_row_.at(i) = true;",
          "206:             thread_state_[target_thread_state]->num_nonzeros_.at(i).resize(framebuffer[i]->block_width() << 1);",
          "207:             thread_state_[target_thread_state]->context_.at(i)",
          "208:                 = framebuffer[i]->begin(thread_state_[target_thread_state]->num_nonzeros_.at(i).begin());",
          "215:     thread_state_[target_thread_state]->is_valid_range_ = false;",
          "216:     thread_state_[target_thread_state]->luma_splits_.resize(2);",
          "218:         thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_[thread_id].luma_y_start;",
          "219:         thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_[thread_id].luma_y_end;",
          "224:         thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_.back().luma_y_end; // <- not a typo",
          "225:         thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_.back().luma_y_end; // both start and end at end",
          "231: std::vector<ThreadHandoff> VP8ComponentDecoder::initialize_baseline_decoder(",
          "235:     mux_splicer.init(spin_workers_);",
          "239: void VP8ComponentDecoder::SendToVirtualThread::set_eof() {",
          "",
          "[Added Lines]",
          "116: template <class BoolDecoder>",
          "117: void VP8ComponentDecoder<BoolDecoder>::registerWorkers(GenericWorker *workers, unsigned int num_workers) {",
          "118:         this->VP8ComponentEncoder<BoolDecoder>::registerWorkers(workers, num_workers);",
          "119: }",
          "121: template <class BoolDecoder>",
          "122: void VP8ComponentDecoder<BoolDecoder>::initialize_bool_decoder(int thread_id, int target_thread_state) {",
          "124:         this->thread_state_[target_thread_state]->bool_decoder_.init(new ActualThreadPacketReader(thread_id,",
          "128:         this->thread_state_[target_thread_state]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));",
          "132: template <class BoolDecoder> template <bool force_memory_optimized>",
          "133: void VP8ComponentDecoder<BoolDecoder>::initialize_thread_id(int thread_id, int target_thread_state,",
          "136:         always_assert(this->spin_workers_);",
          "140:         this->reset_thread_model_state(target_thread_state);",
          "142:     this->thread_state_[target_thread_state]->decode_index_ = 0;",
          "145:             this->thread_state_[target_thread_state]->is_top_row_.at(i) = true;",
          "146:             this->thread_state_[target_thread_state]->num_nonzeros_.at(i).resize(framebuffer[i]->block_width() << 1);",
          "147:             this->thread_state_[target_thread_state]->context_.at(i)",
          "148:                 = framebuffer[i]->begin(this->thread_state_[target_thread_state]->num_nonzeros_.at(i).begin());",
          "155:     this->thread_state_[target_thread_state]->is_valid_range_ = false;",
          "156:     this->thread_state_[target_thread_state]->luma_splits_.resize(2);",
          "158:         this->thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_[thread_id].luma_y_start;",
          "159:         this->thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_[thread_id].luma_y_end;",
          "164:         this->thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_.back().luma_y_end; // <- not a typo",
          "165:         this->thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_.back().luma_y_end; // both start and end at end",
          "172: template <class BoolDecoder>",
          "173: std::vector<ThreadHandoff> VP8ComponentDecoder<BoolDecoder>::initialize_baseline_decoder(",
          "177:     mux_splicer.init(this->spin_workers_);",
          "181: void VP8ComponentDecoder_SendToVirtualThread::set_eof() {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "252:     }",
          "253:     eof = true;",
          "254: }",
          "256:     eof = false;",
          "257:     for (int i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {",
          "258:         thread_target[i] = -1;",
          "",
          "[Removed Lines]",
          "255: VP8ComponentDecoder::SendToVirtualThread::SendToVirtualThread(){",
          "",
          "[Added Lines]",
          "197: VP8ComponentDecoder_SendToVirtualThread::VP8ComponentDecoder_SendToVirtualThread(){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "260:     this->all_workers = NULL;",
          "261: }",
          "264:     this->eof = false;",
          "265:     for (unsigned int thread_id = 0; thread_id < MAX_NUM_THREADS; ++thread_id) {",
          "266:         if (!vbuffers[thread_id].empty()) {",
          "",
          "[Removed Lines]",
          "263: void VP8ComponentDecoder::SendToVirtualThread::init(GenericWorker * all_workers) {",
          "",
          "[Added Lines]",
          "205: void VP8ComponentDecoder_SendToVirtualThread::init(GenericWorker * all_workers) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "269:     }",
          "270:     this->all_workers = all_workers;",
          "271: }",
          "273:     always_assert(data);",
          "274:     always_assert(data->stream_id < sizeof(vbuffers) / sizeof(vbuffers[0]) &&",
          "275:                   \"INVALID SEND STREAM ID\");",
          "",
          "[Removed Lines]",
          "272: void VP8ComponentDecoder::SendToVirtualThread::send(ResizableByteBufferListNode *data) {",
          "",
          "[Added Lines]",
          "214: void VP8ComponentDecoder_SendToVirtualThread::send(ResizableByteBufferListNode *data) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "294:         always_assert(false && \"Cannot send to thread that wasn't bound\");",
          "295:     }",
          "296: }",
          "298:     while (!reader.eof) {",
          "299:         ResizableByteBufferListNode *data = new ResizableByteBufferListNode;",
          "300:         auto ret = reader.nextDataPacket(*data);",
          "",
          "[Removed Lines]",
          "297: void VP8ComponentDecoder::SendToVirtualThread::drain(Sirikata::MuxReader&reader) {",
          "",
          "[Added Lines]",
          "239: void VP8ComponentDecoder_SendToVirtualThread::drain(Sirikata::MuxReader&reader) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "312:     fprintf(stderr, \"FINAL BUF %02x %02x %02x %02x\\n\", buf[0], buf[1], buf[2], buf[3]);",
          "314: }",
          "316:     using namespace Sirikata;",
          "317:     always_assert(stream_id < sizeof(vbuffers) / sizeof(vbuffers[0]) &&",
          "318:                   \"INVALID READ STREAM ID\");",
          "",
          "[Removed Lines]",
          "315: ResizableByteBufferListNode* VP8ComponentDecoder::SendToVirtualThread::read(Sirikata::MuxReader&reader, uint8_t stream_id) {",
          "",
          "[Added Lines]",
          "257: ResizableByteBufferListNode* VP8ComponentDecoder_SendToVirtualThread::read(Sirikata::MuxReader&reader, uint8_t stream_id) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "355:     }",
          "356:     return NULL;",
          "357: }",
          "359:     using namespace Sirikata;",
          "360:     while (!eof) {",
          "361:         ResizableByteBufferListNode *data = new ResizableByteBufferListNode;",
          "",
          "[Removed Lines]",
          "358: void VP8ComponentDecoder::SendToVirtualThread::read_all(Sirikata::MuxReader&reader) {",
          "",
          "[Added Lines]",
          "300: void VP8ComponentDecoder_SendToVirtualThread::read_all(Sirikata::MuxReader&reader) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "370:     }",
          "371: }",
          "375:                                                    Sirikata::Array1d<BlockBasedImagePerChannel<force_memory_optimized>,",
          "376:                                                                      MAX_NUM_THREADS>& framebuffer) {",
          "377:     if (colldata->get_num_components() > (int)BlockType::Y) {",
          "",
          "[Removed Lines]",
          "373: template <bool force_memory_optimized>",
          "374: std::vector<ThreadHandoff> VP8ComponentDecoder::initialize_decoder_state(const UncompressedComponents * const colldata,",
          "",
          "[Added Lines]",
          "315: template<class BoolDecoder> template <bool force_memory_optimized>",
          "316: std::vector<ThreadHandoff> VP8ComponentDecoder<BoolDecoder>::initialize_decoder_state(const UncompressedComponents * const colldata,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "425:     }",
          "426:     return thread_handoff_;",
          "427: }",
          "429:         mux_splicer.drain(mux_reader_);",
          "430: }",
          "431: namespace{void nop(){}}",
          "434:     for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "435:         while (!send_to_actual_thread_state.vbuffers[thread_id].empty()) {",
          "436:             send_to_actual_thread_state.vbuffers[thread_id].pop();",
          "",
          "[Removed Lines]",
          "428: void VP8ComponentDecoder::flush() {",
          "433: void VP8ComponentDecoder::reset_all_comm_buffers() {",
          "",
          "[Added Lines]",
          "370: template <class BoolDecoder>",
          "371: void VP8ComponentDecoder<BoolDecoder>::flush() {",
          "376: template <class BoolDecoder>",
          "377: void VP8ComponentDecoder<BoolDecoder>::reset_all_comm_buffers() {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "438:     }",
          "439: }",
          "442: {",
          "450:         BlockBasedImagePerChannel<false> framebuffer;",
          "451:         framebuffer.memset(0);",
          "",
          "[Removed Lines]",
          "441: CodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * const colldata)",
          "443:     mux_splicer.init(spin_workers_);",
          "448:     if ( thread_state_[0] == nullptr || thread_state_[0]->context_[0].isNil() ) {",
          "",
          "[Added Lines]",
          "385: template <class BoolDecoder>",
          "386: CodingReturnValue VP8ComponentDecoder<BoolDecoder>::decode_chunk(UncompressedComponents * const colldata)",
          "388:     mux_splicer.init(this->spin_workers_);",
          "393:     if ( this->thread_state_[0] == nullptr || this->thread_state_[0]->context_[0].isNil() ) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "465:         }",
          "466:         for (size_t i = 0;i < num_threads_needed; ++i) {",
          "467:             initialize_thread_id(i, i, framebuffer);",
          "469:                 break;",
          "470:             }",
          "471:         }",
          "",
          "[Removed Lines]",
          "468:             if (!do_threading_) {",
          "",
          "[Added Lines]",
          "413:             if (!this->do_threading_) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "473:             return CODING_ERROR;",
          "474:         }",
          "475:     }",
          "477:         reset_all_comm_buffers();",
          "478:         for (unsigned int physical_thread_id = 0; physical_thread_id < (g_threaded ? getNumWorkers() : 1); ++physical_thread_id) {",
          "479:             getWorker(physical_thread_id)->work = nop;",
          "",
          "[Removed Lines]",
          "476:     if (do_threading_) {",
          "",
          "[Added Lines]",
          "421:     if (this->do_threading_) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "482:         for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "483:             unsigned int cur_spin_worker = thread_id;",
          "486:                     = &nop;",
          "487:             } else {",
          "491:                                 thread_id,",
          "492:                                 colldata,",
          "493:                                 mux_splicer.thread_target,",
          "494:                                 getWorker(cur_spin_worker),",
          "495:                                 &send_to_actual_thread_state);",
          "496:             }",
          "498:         }",
          "499:         flush();",
          "500:         for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "501:             unsigned int cur_spin_worker = thread_id;",
          "502:             TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_STARTED] = TimingHarness::get_time_us();",
          "504:             TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_FINISHED] = TimingHarness::get_time_us();",
          "505:         }",
          "507:     } else {",
          "508:         if (virtual_thread_id_ != -1) {",
          "509:             TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();",
          "511:             if (ret == CODING_PARTIAL) {",
          "512:                 return ret;",
          "513:             }",
          "",
          "[Removed Lines]",
          "484:             if (!thread_state_[thread_id]) {",
          "485:                 spin_workers_[cur_spin_worker].work",
          "488:                 spin_workers_[cur_spin_worker].work",
          "489:                     = std::bind(worker_thread,",
          "490:                                 thread_state_[thread_id],",
          "497:             spin_workers_[cur_spin_worker].activate_work();",
          "503:             spin_workers_[cur_spin_worker].main_wait_for_done();",
          "510:             CodingReturnValue ret = thread_state_[0]->vp8_decode_thread(0, colldata);",
          "",
          "[Added Lines]",
          "429:             if (!this->thread_state_[thread_id]) {",
          "430:                 this->spin_workers_[cur_spin_worker].work",
          "433:                 this->spin_workers_[cur_spin_worker].work",
          "434:                     = std::bind(LeptonCodec<BoolDecoder>::worker_thread,",
          "435:                                 this->thread_state_[thread_id],",
          "442:             this->spin_workers_[cur_spin_worker].activate_work();",
          "448:             this->spin_workers_[cur_spin_worker].main_wait_for_done();",
          "455:             CodingReturnValue ret = this->thread_state_[0]->vp8_decode_thread(0, colldata);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "523:             }",
          "525:             initialize_thread_id(thread_id, 0, framebuffer);",
          "527:             TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();",
          "528:             CodingReturnValue ret;",
          "530:                 return ret;",
          "531:             }",
          "532:             TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();",
          "",
          "[Removed Lines]",
          "526:             thread_state_[0]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));",
          "529:             if ((ret = thread_state_[0]->vp8_decode_thread(0, colldata)) == CODING_PARTIAL) {",
          "",
          "[Added Lines]",
          "471:             this->thread_state_[0]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));",
          "474:             if ((ret = this->thread_state_[0]->vp8_decode_thread(0, colldata)) == CODING_PARTIAL) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "541:     write_byte_bill(Billing::DELIMITERS, true, mux_reader_.getOverhead());",
          "542:     return CODING_DONE;",
          "543: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "490: template class VP8ComponentDecoder<VPXBoolReader>;",
          "",
          "---------------"
        ],
        "src/lepton/vp8_decoder.hh||src/lepton/vp8_decoder.hh": [
          "File: src/lepton/vp8_decoder.hh -> src/lepton/vp8_decoder.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"vp8_encoder.hh\"",
          "90:     void flush();",
          "91:     void map_logical_thread_to_physical_thread(int logical_thread_id,",
          "92:                                                int physical_thread_id) {",
          "",
          "[Removed Lines]",
          "12: struct ResizableByteBufferListNode : public Sirikata::MuxReader::ResizableByteBuffer {",
          "13:     uint8_t stream_id;",
          "14:     ResizableByteBufferListNode *next;",
          "15:     ResizableByteBufferListNode(){",
          "16:         stream_id = 0;",
          "17:         next = NULL;",
          "18:     }",
          "19: };",
          "20: struct ResizableByteBufferList {",
          "21:     ResizableByteBufferListNode * head;",
          "22:     ResizableByteBufferListNode * tail;",
          "23:     ResizableByteBufferList() {",
          "24:         head = NULL;",
          "25:         tail = NULL;",
          "26:     }",
          "27:     void push(ResizableByteBufferListNode * item) {",
          "28:         always_assert(item);",
          "29:         if (!tail) {",
          "30:             always_assert(!head);",
          "31:             head = tail = item;",
          "32:         } else {",
          "33:             always_assert(!tail->next);",
          "34:             tail->next = item;",
          "35:             tail = item;",
          "36:         }",
          "37:     }",
          "38:     bool empty()const {",
          "39:         return head == NULL && tail == NULL;",
          "40:     }",
          "41:     bool size_gt_1()const {",
          "42:         return head != tail;",
          "43:     }",
          "44:     ResizableByteBufferListNode * front() {",
          "45:         return head;",
          "46:     }",
          "47:     const ResizableByteBufferListNode * front() const{",
          "48:         return head;",
          "49:     }",
          "50:     ResizableByteBufferListNode * pop() {",
          "51:         always_assert(!empty());",
          "52:         auto retval = head;",
          "53:         if (tail == head) {",
          "54:             always_assert(tail->next == NULL);",
          "55:             head = NULL;",
          "56:             tail = NULL;",
          "57:             return retval;",
          "58:         }",
          "59:         head = head->next;",
          "60:         return retval;",
          "61:     }",
          "62: };",
          "64: class VP8ComponentDecoder : public BaseDecoder, public VP8ComponentEncoder {",
          "65: public:",
          "66:     class SendToVirtualThread {",
          "67:         ResizableByteBufferList vbuffers[Sirikata::MuxReader::MAX_STREAM_ID];",
          "69:         GenericWorker *all_workers;",
          "70:         bool eof;",
          "71:         void set_eof();",
          "72:     public:",
          "73:         int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID]; // 0 is the current thread",
          "74:         SendToVirtualThread();",
          "75:         void init(GenericWorker *generic_workers);",
          "77:         void bind_thread(uint8_t virtual_thread_id, int8_t physical_thread_id) {",
          "78:             thread_target[virtual_thread_id] = physical_thread_id;",
          "79:         }",
          "80:         void send(ResizableByteBufferListNode *data);",
          "81:         void drain(Sirikata::MuxReader&reader);",
          "83:         ResizableByteBufferListNode* read(Sirikata::MuxReader&reader, uint8_t stream_id);",
          "84:         void read_all(Sirikata::MuxReader&reader);",
          "85:     };",
          "86:     class SendToActualThread {",
          "87:     public:",
          "88:         ResizableByteBufferList vbuffers[Sirikata::MuxReader::MAX_STREAM_ID];",
          "89:     };",
          "",
          "[Added Lines]",
          "14: template<class BoolDecoder> class VP8ComponentDecoder : public BaseDecoder, public VP8ComponentEncoder<BoolDecoder> {",
          "15: public:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94:     }",
          "95:     void reset_all_comm_buffers();",
          "96: private:",
          "98:     Sirikata::DecoderReader *str_in {};",
          "100:     Sirikata::MuxReader mux_reader_;",
          "102:     std::vector<ThreadHandoff> thread_handoff_;",
          "103:     Sirikata::Array1d<std::pair <Sirikata::MuxReader::ResizableByteBuffer::const_iterator,",
          "104:                                  Sirikata::MuxReader::ResizableByteBuffer::const_iterator>,",
          "",
          "[Removed Lines]",
          "97:     SendToActualThread send_to_actual_thread_state;",
          "101:     SendToVirtualThread mux_splicer;",
          "",
          "[Added Lines]",
          "23:     VP8ComponentDecoder_SendToActualThread send_to_actual_thread_state;",
          "27:     VP8ComponentDecoder_SendToVirtualThread mux_splicer;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:     VP8ComponentDecoder(const VP8ComponentDecoder&) = delete;",
          "108:     VP8ComponentDecoder& operator=(const VP8ComponentDecoder&) = delete;",
          "113:     template <bool force_memory_optimized>",
          "114:     void initialize_thread_id(int thread_id, int target_thread_state,",
          "115:                               BlockBasedImagePerChannel<force_memory_optimized>& framebuffer);",
          "",
          "[Removed Lines]",
          "109:     static void worker_thread(ThreadState *, int thread_id, UncompressedComponents * const colldata,",
          "110:                               int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID],",
          "111:                               GenericWorker*worker,",
          "112:                               SendToActualThread*data_receiver);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "130:     virtual std::vector<ThreadHandoff> initialize_baseline_decoder(const UncompressedComponents * const colldata,",
          "131:                                              Sirikata::Array1d<BlockBasedImagePerChannel<true>,",
          "132:                                                                MAX_NUM_THREADS>& framebuffer);",
          "136:     unsigned int getNumWorkers() const {",
          "138:     }",
          "139:     GenericWorker *getWorker(unsigned int i) {",
          "142:     }",
          "143:     size_t get_model_memory_usage() const {",
          "145:     }",
          "146:     size_t get_model_worker_memory_usage() const {",
          "148:     }",
          "149:     ~VP8ComponentDecoder();",
          "150:     void initialize(Sirikata::DecoderReader *input,",
          "",
          "[Removed Lines]",
          "133:     void registerWorkers(GenericWorker *workers, unsigned int num_workers) {",
          "134:         this->VP8ComponentEncoder::registerWorkers(workers, num_workers);",
          "135:     }",
          "137:         return num_registered_workers_;",
          "140:         always_assert(i < num_registered_workers_);",
          "141:         return &spin_workers_[i];",
          "144:         return model_memory_used();",
          "147:         return model_worker_memory_used();",
          "",
          "[Added Lines]",
          "55:     void registerWorkers(GenericWorker *workers, unsigned int num_workers);",
          "57:         return this->num_registered_workers_;",
          "60:         always_assert(i < this->num_registered_workers_);",
          "61:         return &this->spin_workers_[i];",
          "64:         return this->model_memory_used();",
          "67:         return this->model_worker_memory_used();",
          "",
          "---------------"
        ],
        "src/lepton/vp8_encoder.cc||src/lepton/vp8_encoder.cc": [
          "File: src/lepton/vp8_encoder.cc -> src/lepton/vp8_encoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include \"../vp8/model/model.hh\"",
          "21: #include \"../vp8/encoder/encoder.hh\"",
          "22: #include \"../io/MuxReader.hh\"",
          "23: extern unsigned char ujgversion;",
          "24: using namespace std;",
          "25: typedef Sirikata::MuxReader::ResizableByteBuffer ResizableByteBuffer;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include \"lepton_codec.hh\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66: #endif",
          "67: }",
          "71: }",
          "77: {",
          "79: }",
          "83:                                       Left & left_model,",
          "84:                                       Middle& middle_model,",
          "85:                                       Right& right_model,",
          "",
          "[Removed Lines]",
          "69: VP8ComponentEncoder::VP8ComponentEncoder(bool do_threading)",
          "70:     : LeptonCodec(do_threading){",
          "73: CodingReturnValue VP8ComponentEncoder::encode_chunk(const UncompressedComponents *input,",
          "74:                                                     IOUtil::FileWriter *output,",
          "75:                                                     const ThreadHandoff *selected_splits,",
          "76:                                                     unsigned int num_selected_splits)",
          "78:     return vp8_full_encoder(input, output, selected_splits, num_selected_splits);",
          "81: template<class Left, class Middle, class Right>",
          "82: void VP8ComponentEncoder::process_row(ProbabilityTablesBase &pt,",
          "",
          "[Added Lines]",
          "70: template <class ArithmeticCoder>",
          "71: VP8ComponentEncoder<ArithmeticCoder>::VP8ComponentEncoder(bool do_threading, bool use_ans_encoder)",
          "72:     : LeptonCodec<ArithmeticCoder>(do_threading){",
          "73:     this->mUseAnsEncoder = use_ans_encoder;",
          "75: template <class ArithmeticCoder>",
          "76: CodingReturnValue VP8ComponentEncoder<ArithmeticCoder>::encode_chunk(const UncompressedComponents *input,",
          "77:                                                                      IOUtil::FileWriter *output,",
          "78:                                                                      const ThreadHandoff *selected_splits,",
          "79:                                                                      unsigned int num_selected_splits)",
          "81:     return vp8_full_encoder(input, output, selected_splits, num_selected_splits, this->mUseAnsEncoder);",
          "83: template <class ArithmeticCoder>",
          "84: template<class Left, class Middle, class Right, class BoolEncoder>",
          "85: void VP8ComponentEncoder<ArithmeticCoder>::process_row(ProbabilityTablesBase &pt,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "233: tuple<ProbabilityTablesTuple(true, true, false)> midright(EACH_BLOCK_TYPE(true, true, false));",
          "234: tuple<ProbabilityTablesTuple(false, true, false)> width_one(EACH_BLOCK_TYPE(false, true, false));",
          "237:                                             const UncompressedComponents * const colldata,",
          "238:                                             int min_y,",
          "239:                                             int max_y,",
          "",
          "[Removed Lines]",
          "236: void VP8ComponentEncoder::process_row_range(unsigned int thread_id,",
          "",
          "[Added Lines]",
          "239: template <class ArithmeticCoder> template <class BoolEncoder>",
          "240: void VP8ComponentEncoder<ArithmeticCoder>::process_row_range(unsigned int thread_id,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "252:     uint8_t is_top_row[(uint32_t)ColorChannel::NumBlockTypes];",
          "253:     memset(is_top_row, true, sizeof(is_top_row));",
          "254:     ProbabilityTablesBase *model = nullptr;",
          "258:     } else {",
          "261:     }",
          "262:     KBlockBasedImagePerChannel<false> image_data;",
          "263:     for (int i = 0; i < colldata->get_num_components(); ++i) {",
          "",
          "[Removed Lines]",
          "255:     if (do_threading_) {",
          "256:         reset_thread_model_state(thread_id);",
          "257:         model = &thread_state_[thread_id]->model_;",
          "259:         reset_thread_model_state(0);",
          "260:         model = &thread_state_[0]->model_;",
          "",
          "[Added Lines]",
          "259:     if (this->do_threading_) {",
          "260:         LeptonCodec<ArithmeticCoder>::reset_thread_model_state(thread_id);",
          "261:         model = &this->thread_state_[thread_id]->model_;",
          "263:         LeptonCodec<ArithmeticCoder>::reset_thread_model_state(0);",
          "264:         model = &this->thread_state_[0]->model_;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "266:     uint32_t encode_index = 0;",
          "267:     Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> max_coded_heights = colldata->get_max_coded_heights();",
          "268:     while(true) {",
          "270:                                               image_data,",
          "271:                                               colldata->get_mcu_count_vertical(),",
          "272:                                               max_coded_heights);",
          "",
          "[Removed Lines]",
          "269:         RowSpec cur_row = row_spec_from_index(encode_index++,",
          "",
          "[Added Lines]",
          "273:         LeptonCodec_RowSpec cur_row = LeptonCodec_row_spec_from_index(encode_index++,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "426:             }",
          "427:         }",
          "428:     }",
          "430:                                        image_data,",
          "431:                                        colldata->get_mcu_count_vertical(),",
          "432:                                        max_coded_heights);",
          "",
          "[Removed Lines]",
          "429:     RowSpec test = row_spec_from_index(encode_index,",
          "",
          "[Added Lines]",
          "433:     LeptonCodec_RowSpec test = ::LeptonCodec_row_spec_from_index(encode_index,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "453: }",
          "454: int model_file_fd = load_model_file_fd_output();",
          "461: {",
          "463:     using namespace Sirikata;",
          "",
          "[Removed Lines]",
          "457: CodingReturnValue VP8ComponentEncoder::vp8_full_encoder( const UncompressedComponents * const colldata,",
          "458:                                                          IOUtil::FileWriter *str_out,",
          "459:                                                          const ThreadHandoff * selected_splits,",
          "460:                                                          unsigned int num_selected_splits)",
          "",
          "[Added Lines]",
          "460: template<class BoolDecoder>",
          "461: CodingReturnValue VP8ComponentEncoder<BoolDecoder>::vp8_full_encoder( const UncompressedComponents * const colldata,",
          "462:                                                                       IOUtil::FileWriter *str_out,",
          "463:                                                                       const ThreadHandoff * selected_splits,",
          "464:                                                                       unsigned int num_selected_splits,",
          "465:                                                                       bool use_ans_encoder)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "482: #endif",
          "484:     ResizableByteBuffer stream[MuxReader::MAX_STREAM_ID];",
          "492:         }",
          "507:         }",
          "525:         }",
          "526:     }",
          "527:     static_assert(MAX_NUM_THREADS * SIMD_WIDTH <= MuxReader::MAX_STREAM_ID,",
          "528:                   \"Need to have enough mux streams for all threads and simd width\");",
          "531:         for (unsigned int thread_id = 1; thread_id < NUM_THREADS; ++thread_id) {",
          "532:             TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_STARTED] = TimingHarness::get_time_us();",
          "534:             TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_FINISHED] = TimingHarness::get_time_us();",
          "535:         }",
          "536:     }",
          "",
          "[Removed Lines]",
          "485:     BoolEncoder bool_encoder[MAX_NUM_THREADS];",
          "486:     Array1d<std::vector<NeighborSummary>,",
          "487:             (uint32_t)ColorChannel::NumBlockTypes> num_nonzeros[MAX_NUM_THREADS];",
          "488:     for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "489:         bool_encoder[thread_id].init();",
          "490:         for (size_t i = 0; i < num_nonzeros[thread_id].size(); ++i) {",
          "491:             num_nonzeros[thread_id].at(i).resize(colldata->block_width(i) << 1);",
          "493:     }",
          "495:     if (do_threading_) {",
          "496:         for (unsigned int thread_id = 1; thread_id < NUM_THREADS; ++thread_id) {",
          "497:             spin_workers_[thread_id - 1].work",
          "498:                 = std::bind(&VP8ComponentEncoder::process_row_range, this,",
          "499:                             thread_id,",
          "500:                             colldata,",
          "501:                             selected_splits[thread_id].luma_y_start,",
          "502:                             selected_splits[thread_id].luma_y_end,",
          "503:                             &stream[thread_id],",
          "504:                             &bool_encoder[thread_id],",
          "505:                             &num_nonzeros[thread_id]);",
          "506:             spin_workers_[thread_id - 1].activate_work();",
          "508:     }",
          "509:     process_row_range(0,",
          "510:                       colldata,",
          "511:                       selected_splits[0].luma_y_start,",
          "512:                       selected_splits[0].luma_y_end,",
          "513:                       &stream[0],",
          "514:                       &bool_encoder[0],",
          "515:                       &num_nonzeros[0]);",
          "516:     if(!do_threading_) { // single threading",
          "517:         for (unsigned int thread_id = 1; thread_id < NUM_THREADS; ++thread_id) {",
          "518:             process_row_range(thread_id,",
          "519:                               colldata,",
          "520:                               selected_splits[thread_id].luma_y_start,",
          "521:                               selected_splits[thread_id].luma_y_end,",
          "522:                               &stream[thread_id],",
          "523:                               &bool_encoder[thread_id],",
          "524:                               &num_nonzeros[thread_id]);",
          "530:     if (do_threading_) {",
          "533:             spin_workers_[thread_id - 1].main_wait_for_done();",
          "",
          "[Added Lines]",
          "490:     if (use_ans_encoder) {",
          "491:         always_assert(false&& \"NOT IMPL\");",
          "492:     } else {",
          "494:         VPXBoolWriter bool_encoder[MAX_NUM_THREADS];",
          "495:         Array1d<std::vector<NeighborSummary>,",
          "496:                 (uint32_t)ColorChannel::NumBlockTypes> num_nonzeros[MAX_NUM_THREADS];",
          "497:         for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "498:             bool_encoder[thread_id].init();",
          "499:             for (size_t i = 0; i < num_nonzeros[thread_id].size(); ++i) {",
          "500:                 num_nonzeros[thread_id].at(i).resize(colldata->block_width(i) << 1);",
          "501:             }",
          "504:         if (this->do_threading_) {",
          "505:             for (unsigned int thread_id = 1; thread_id < NUM_THREADS; ++thread_id) {",
          "506:                 this->spin_workers_[thread_id - 1].work",
          "507:                     = std::bind(&VP8ComponentEncoder<BoolDecoder>::process_row_range<VPXBoolWriter>, this,",
          "508:                                 thread_id,",
          "509:                                 colldata,",
          "510:                                 selected_splits[thread_id].luma_y_start,",
          "511:                                 selected_splits[thread_id].luma_y_end,",
          "512:                                 &stream[thread_id],",
          "513:                                 &bool_encoder[thread_id],",
          "514:                                 &num_nonzeros[thread_id]);",
          "515:                 this->spin_workers_[thread_id - 1].activate_work();",
          "516:             }",
          "518:         process_row_range(0,",
          "519:                           colldata,",
          "520:                           selected_splits[0].luma_y_start,",
          "521:                           selected_splits[0].luma_y_end,",
          "522:                           &stream[0],",
          "523:                           &bool_encoder[0],",
          "524:                           &num_nonzeros[0]);",
          "525:         if(!this->do_threading_) { // single threading",
          "526:             for (unsigned int thread_id = 1; thread_id < NUM_THREADS; ++thread_id) {",
          "527:                 process_row_range(thread_id,",
          "528:                                   colldata,",
          "529:                                   selected_splits[thread_id].luma_y_start,",
          "530:                                   selected_splits[thread_id].luma_y_end,",
          "531:                                   &stream[thread_id],",
          "532:                                   &bool_encoder[thread_id],",
          "533:                                   &num_nonzeros[thread_id]);",
          "534:             }",
          "540:     if (this->do_threading_) {",
          "543:             this->spin_workers_[thread_id - 1].main_wait_for_done();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "581:         const char * msg = \"Writing new compression model...\\n\";",
          "582:         while (write(2, msg, strlen(msg)) < 0 && errno == EINTR){}",
          "586:     }",
          "587: #ifdef ANNOTATION_ENABLED",
          "588:     {",
          "",
          "[Removed Lines]",
          "584:         std::get<(int)BlockType::Y>(middle).optimize(thread_state_[0]->model_);",
          "585:         std::get<(int)BlockType::Y>(middle).serialize(thread_state_[0]->model_, model_file_fd );",
          "",
          "[Added Lines]",
          "594:         std::get<(int)BlockType::Y>(middle).optimize(this->thread_state_[0]->model_);",
          "595:         std::get<(int)BlockType::Y>(middle).serialize(this->thread_state_[0]->model_, model_file_fd );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "594:     TimingHarness::timing[0][TimingHarness::TS_STREAM_FLUSH_FINISHED] = TimingHarness::get_time_us();",
          "595:     return CODING_DONE;",
          "596: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "607: template class VP8ComponentEncoder<VPXBoolReader>;",
          "",
          "---------------"
        ],
        "src/lepton/vp8_encoder.hh||src/lepton/vp8_encoder.hh": [
          "File: src/lepton/vp8_encoder.hh -> src/lepton/vp8_encoder.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include \"lepton_codec.hh\"",
          "6: #include \"model.hh\"",
          "7: #include \"../io/MuxReader.hh\"",
          "11:     static void process_row(ProbabilityTablesBase&pt,",
          "12:                             Left & left_model,",
          "13:                          Middle& middle_model,",
          "",
          "[Removed Lines]",
          "8: class BoolEncoder;",
          "9: class VP8ComponentEncoder : protected LeptonCodec, public BaseEncoder {",
          "10:     template<class Left, class Middle, class Right>",
          "",
          "[Added Lines]",
          "8: #include \"lepton_codec.hh\"",
          "10: template<class BoolDecoder> class VP8ComponentEncoder : protected LeptonCodec<BoolDecoder>, public BaseEncoder {",
          "11:     template<class Left, class Middle, class Right, class BoolEncoder>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17:                          Sirikata::Array1d<ConstBlockContext,",
          "18:                                            (uint32_t)ColorChannel::NumBlockTypes> &context,",
          "19:                          BoolEncoder &bool_encoder);",
          "21:                            const UncompressedComponents * const colldata,",
          "22:                            int min_y,",
          "23:                            int max_y,",
          "",
          "[Removed Lines]",
          "20:     void process_row_range(unsigned int thread_id,",
          "",
          "[Added Lines]",
          "21:     template <class BoolEncoder> void process_row_range(unsigned int thread_id,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "25:                            BoolEncoder *bool_encoder,",
          "26:                            Sirikata::Array1d<std::vector<NeighborSummary>,",
          "27:                                              (uint32_t)ColorChannel::NumBlockTypes> *num_nonzeros);",
          "28: public:",
          "30:     void registerWorkers(GenericWorker * workers, unsigned int num_workers) {",
          "32:     }",
          "34:     CodingReturnValue vp8_full_encoder( const UncompressedComponents * const colldata,",
          "35:                                         IOUtil::FileWriter *,",
          "36:                                         const ThreadHandoff * selected_splits,",
          "39:     CodingReturnValue encode_chunk(const UncompressedComponents *input,",
          "40:                                    IOUtil::FileWriter *,",
          "41:                                    const ThreadHandoff * selected_splits,",
          "43:     size_t get_decode_model_memory_usage() const {",
          "45:     }",
          "46:     size_t get_decode_model_worker_memory_usage() const {",
          "48:     }",
          "50: };",
          "",
          "[Removed Lines]",
          "29:     VP8ComponentEncoder(bool do_threading);",
          "31:         this->LeptonCodec::registerWorkers(workers, num_workers);",
          "37:                                         unsigned int num_selected_splits);",
          "42:                                         unsigned int num_selected_splits);",
          "44:         return model_memory_used();",
          "47:         return model_worker_memory_used();",
          "",
          "[Added Lines]",
          "29:     bool mUseAnsEncoder;",
          "31:     VP8ComponentEncoder(bool do_threading, bool use_ans_encoder);",
          "33:         this->LeptonCodec<BoolDecoder>::registerWorkers(workers, num_workers);",
          "39:                                         unsigned int num_selected_splits,",
          "40:                                         bool use_ans_encoder);",
          "45:                                    unsigned int num_selected_splits);",
          "47:         return this->model_memory_used();",
          "50:         return this->model_worker_memory_used();",
          "",
          "---------------"
        ],
        "src/vp8/decoder/bool_decoder.hh||src/vp8/decoder/bool_decoder.hh": [
          "File: src/vp8/decoder/bool_decoder.hh -> src/vp8/decoder/bool_decoder.hh"
        ],
        "src/vp8/decoder/decoder.cc||src/vp8/decoder/decoder.cc": [
          "File: src/vp8/decoder/decoder.cc -> src/vp8/decoder/decoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #endif",
          "27: template<bool all_neighbors_present, BlockType color,",
          "29: void decode_one_edge(BlockContext mcontext,",
          "30:                  BoolDecoder& decoder,",
          "31:                  ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "28:          bool horizontal>",
          "",
          "[Added Lines]",
          "28:          bool horizontal, class BoolDecoder>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140:     }",
          "141: }",
          "144: void decode_edge(BlockContext mcontext,",
          "145:                  BoolDecoder& decoder,",
          "146:                  ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "143: template<bool all_neighbors_present, BlockType color>",
          "",
          "[Added Lines]",
          "143: template<bool all_neighbors_present, BlockType color, class BoolDecoder>",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "168: void parse_tokens(BlockContext context,",
          "169:                   BoolDecoder& decoder,",
          "170:                   ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "167: template<bool all_neighbors_present, BlockType color>",
          "",
          "[Added Lines]",
          "167: template<bool all_neighbors_present, BlockType color, class BoolDecoder>",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "317:                                             context.here().dc());",
          "318: }",
          "319: #ifdef ALLOW_FOUR_COLORS",
          "322: #endif",
          "",
          "[Removed Lines]",
          "320: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<false, BlockType::Ck>&, ProbabilityTablesBase&);",
          "321: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<true, BlockType::Ck>&, ProbabilityTablesBase&);",
          "324: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<false, BlockType::Y>&, ProbabilityTablesBase&);",
          "325: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<false, BlockType::Cb>&, ProbabilityTablesBase&);",
          "326: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<false, BlockType::Cr>&, ProbabilityTablesBase&);",
          "327: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<true, BlockType::Y>&, ProbabilityTablesBase&);",
          "328: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<true, BlockType::Cb>&, ProbabilityTablesBase&);",
          "329: template void parse_tokens(BlockContext, BoolDecoder&, ProbabilityTables<true, BlockType::Cr>&, ProbabilityTablesBase&);",
          "",
          "[Added Lines]",
          "320: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<false, BlockType::Ck>&, ProbabilityTablesBase&);",
          "321: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<true, BlockType::Ck>&, ProbabilityTablesBase&);",
          "324: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<false, BlockType::Y>&, ProbabilityTablesBase&);",
          "325: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<false, BlockType::Cb>&, ProbabilityTablesBase&);",
          "326: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<false, BlockType::Cr>&, ProbabilityTablesBase&);",
          "327: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<true, BlockType::Y>&, ProbabilityTablesBase&);",
          "328: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<true, BlockType::Cb>&, ProbabilityTablesBase&);",
          "329: template void parse_tokens(BlockContext, VPXBoolReader&, ProbabilityTables<true, BlockType::Cr>&, ProbabilityTablesBase&);",
          "",
          "---------------"
        ],
        "src/vp8/decoder/decoder.hh||src/vp8/decoder/decoder.hh": [
          "File: src/vp8/decoder/decoder.hh -> src/vp8/decoder/decoder.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #ifndef DECODER_HH",
          "3: #define DECODER_HH",
          "5: void parse_tokens(BlockContext context,",
          "6:                   BoolDecoder& data,",
          "7:                   ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "4: template<bool all_neighbors_present, BlockType color>",
          "",
          "[Added Lines]",
          "4: template<bool all_neighbors_present, BlockType color, class BoolDecoder>",
          "",
          "---------------"
        ],
        "src/vp8/encoder/bool_encoder.hh||src/vp8/encoder/bool_encoder.hh": [
          "File: src/vp8/encoder/bool_encoder.hh -> src/vp8/encoder/bool_encoder.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: };",
          "31: #ifdef JPEG_ENCODER",
          "33: #else",
          "35: #endif",
          "",
          "[Removed Lines]",
          "32: class BoolEncoder : public JpegBoolEncoder{};",
          "34: class BoolEncoder : public VPXBoolWriter{};",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vp8/encoder/encoder.cc||src/vp8/encoder/encoder.cc": [
          "File: src/vp8/encoder/encoder.cc -> src/vp8/encoder/encoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: };",
          "39: template<bool all_neighbors_present, BlockType color,",
          "41: void encode_one_edge(ConstBlockContext context,",
          "42:                  BoolEncoder& encoder,",
          "43:                  ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "40:          bool horizontal>",
          "",
          "[Added Lines]",
          "40:          bool horizontal,  class BoolEncoder>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:     }",
          "164: }",
          "167: void encode_edge(ConstBlockContext context,",
          "168:                  BoolEncoder& encoder,",
          "169:                  ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "166: template<bool all_neighbors_present, BlockType color>",
          "",
          "[Added Lines]",
          "166: template<bool all_neighbors_present, BlockType color, class BoolEncoder>",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "191: int avg_err = 0;",
          "192: int ori_err = 0;",
          "195: void serialize_tokens(ConstBlockContext context,",
          "196:                       BoolEncoder& encoder,",
          "197:                       ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "194: template <bool all_neighbors_present, BlockType color>",
          "",
          "[Added Lines]",
          "194: template <bool all_neighbors_present, BlockType color, class BoolEncoder>",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401:     }",
          "402: }",
          "403: #ifdef ALLOW_FOUR_COLORS",
          "406: #endif",
          "",
          "[Removed Lines]",
          "404: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<false, BlockType::Ck>&, ProbabilityTablesBase&);",
          "405: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<true, BlockType::Ck>&, ProbabilityTablesBase&);",
          "408: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<false, BlockType::Y>&, ProbabilityTablesBase&);",
          "409: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<false, BlockType::Cb>&, ProbabilityTablesBase&);",
          "410: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<false, BlockType::Cr>&, ProbabilityTablesBase&);",
          "411: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<true, BlockType::Y>&, ProbabilityTablesBase&);",
          "412: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<true, BlockType::Cb>&, ProbabilityTablesBase&);",
          "413: template void serialize_tokens(ConstBlockContext, BoolEncoder&, ProbabilityTables<true, BlockType::Cr>&, ProbabilityTablesBase&);",
          "",
          "[Added Lines]",
          "404: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<false, BlockType::Ck>&, ProbabilityTablesBase&);",
          "405: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<true, BlockType::Ck>&, ProbabilityTablesBase&);",
          "408: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<false, BlockType::Y>&, ProbabilityTablesBase&);",
          "409: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<false, BlockType::Cb>&, ProbabilityTablesBase&);",
          "410: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<false, BlockType::Cr>&, ProbabilityTablesBase&);",
          "411: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<true, BlockType::Y>&, ProbabilityTablesBase&);",
          "412: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<true, BlockType::Cb>&, ProbabilityTablesBase&);",
          "413: template void serialize_tokens(ConstBlockContext, VPXBoolWriter&, ProbabilityTables<true, BlockType::Cr>&, ProbabilityTablesBase&);",
          "",
          "---------------"
        ],
        "src/vp8/encoder/encoder.hh||src/vp8/encoder/encoder.hh": [
          "File: src/vp8/encoder/encoder.hh -> src/vp8/encoder/encoder.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #ifndef ENCODER_HH",
          "3: #define ENCODER_HH",
          "4: #include \"model.hh\"",
          "6: void serialize_tokens(ConstBlockContext context,",
          "7:                       BoolEncoder & encoder,",
          "8:                       ProbabilityTables<all_neighbors_present, color> & probability_tables,",
          "",
          "[Removed Lines]",
          "5: template<bool all_neighbors_present, BlockType color>",
          "",
          "[Added Lines]",
          "5: template<bool all_neighbors_present, BlockType color, class BoolEncoder>",
          "",
          "---------------"
        ],
        "src/vp8/model/model.hh||src/vp8/model/model.hh": [
          "File: src/vp8/model/model.hh -> src/vp8/model/model.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include \"../util/mm_mullo_epi32.hh\"",
          "19: #endif",
          "22: constexpr bool advanced_dc_prediction = true;",
          "23: enum TableParams : unsigned int {",
          "24:     MAX_EXPONENT = 11,",
          "",
          "[Removed Lines]",
          "21: class BoolEncoder;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vp8/util/aligned_block.hh||src/vp8/util/aligned_block.hh": [
          "File: src/vp8/util/aligned_block.hh -> src/vp8/util/aligned_block.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: static IdentityArray1d aligned_to_raster;",
          "86: #endif",
          "90: struct BlockColorContext;",
          "",
          "[Removed Lines]",
          "88: class BoolEncoder;",
          "89: class BoolDecoder;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3730da1c7cbfe441bcd1a2dc558291675196ea2a",
      "candidate_info": {
        "commit_hash": "3730da1c7cbfe441bcd1a2dc558291675196ea2a",
        "repo": "dropbox/lepton",
        "commit_url": "https://github.com/dropbox/lepton/commit/3730da1c7cbfe441bcd1a2dc558291675196ea2a",
        "files": [
          "src/lepton/jpgcoder.cc",
          "src/lepton/vp8_decoder.cc"
        ],
        "message": "simplified the decode_chunk progressive inner loop",
        "before_after_code_files": [
          "src/lepton/jpgcoder.cc||src/lepton/jpgcoder.cc",
          "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc"
          ],
          "candidate": [
            "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/lepton/jpgcoder.cc||src/lepton/jpgcoder.cc": [
          "File: src/lepton/jpgcoder.cc -> src/lepton/jpgcoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "572:     if (current_operation_first_byte.tv_sec == 0 &&",
          "573:         current_operation_first_byte.tv_usec == 0) {",
          "574:         gettimeofday(&current_operation_first_byte, NULL);",
          "578:     }",
          "580: #endif",
          "581: #endif",
          "582: }",
          "",
          "[Removed Lines]",
          "575:         fprintf(stderr,\"FIRST BYTE ACHIEVED %ld %ld\\n\",",
          "576:                 (long)current_operation_first_byte.tv_sec,",
          "577:                 (long)current_operation_first_byte.tv_usec );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3866:     read uncompressed JPEG file",
          "3869: void mem_nop (void *opaque, void *ptr){",
          "3871: }",
          "",
          "[Removed Lines]",
          "3868: namespace {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3875: void* mem_realloc_nop(void * ptr, size_t size, size_t *actualSize, unsigned int movable, void *opaque){",
          "3876:     return NULL;",
          "3877: }",
          "3879: bool read_ujpg( void )",
          "3880: {",
          "3881:     using namespace IOUtil;",
          "",
          "[Removed Lines]",
          "3878: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lepton/vp8_decoder.cc||src/lepton/vp8_decoder.cc": [
          "File: src/lepton/vp8_decoder.cc -> src/lepton/vp8_decoder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "405:         for (int i = 0; i + 1 < mark; ++i) {",
          "406:             thread_handoff_[i].luma_y_end = htole16(luma_splits_tmp[i]);",
          "407:             if (thread_handoff_[i].luma_y_end % sfv_lcm) {",
          "412:                 custom_exit(ExitCode::THREADING_PARTIAL_MCU);",
          "413:             }",
          "414:         }",
          "",
          "[Removed Lines]",
          "409:                 fprintf(stderr, \"File Split %d = %d (remainder %d)\\n\",",
          "410:                         i, thread_handoff_[i].luma_y_end, sfv_lcm);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "456:                 break;",
          "457:             }",
          "458:         }",
          "467:         if (num_threads_needed > NUM_THREADS || num_threads_needed == 0) {",
          "468:             return CODING_ERROR;",
          "469:         }",
          "493:     }",
          "494:     if (do_threading_) {",
          "495:         flush();",
          "496:         for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "497:             unsigned int cur_spin_worker = thread_id;",
          "",
          "[Removed Lines]",
          "460:         for (size_t i = 0;i < num_threads_needed; ++i) {",
          "461:             initialize_bool_decoder(i, i);",
          "462:             if (!do_threading_) {",
          "463:                 break;",
          "464:             }",
          "465:         }",
          "470:         if (do_threading_) {",
          "471:             for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "472:                 unsigned int cur_spin_worker = thread_id;",
          "473:                 spin_workers_[cur_spin_worker].work",
          "474:                     = std::bind(worker_thread,",
          "475:                                 thread_state_[thread_id],",
          "476:                                 thread_id,",
          "477:                                 colldata,",
          "478:                                 mux_splicer.thread_target,",
          "479:                                 getWorker(cur_spin_worker),",
          "480:                                 &send_to_actual_thread_state);",
          "481:                 spin_workers_[cur_spin_worker].activate_work();",
          "482:             }",
          "483:         }",
          "485:     }",
          "486:     if (virtual_thread_id_ != -1 && !do_threading_) {",
          "487:         TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();",
          "488:         CodingReturnValue ret = thread_state_[0]->vp8_decode_thread(0, colldata);",
          "489:         if (ret == CODING_PARTIAL) {",
          "490:             return ret;",
          "491:         }",
          "492:         TimingHarness::timing[0][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();",
          "",
          "[Added Lines]",
          "458:         for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {",
          "459:             unsigned int cur_spin_worker = thread_id;",
          "460:             spin_workers_[cur_spin_worker].work",
          "461:                 = std::bind(worker_thread,",
          "462:                             thread_state_[thread_id],",
          "463:                             thread_id,",
          "464:                             colldata,",
          "465:                             mux_splicer.thread_target,",
          "466:                             getWorker(cur_spin_worker),",
          "467:                             &send_to_actual_thread_state);",
          "468:             spin_workers_[cur_spin_worker].activate_work();",
          "469:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "501:         }",
          "503:     } else {",
          "505:         virtual_thread_id_ += 1; // first time's a charm",
          "506:         for (unsigned int thread_id = virtual_thread_id_; thread_id < NUM_THREADS; ++thread_id, ++virtual_thread_id_) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "479:         if (virtual_thread_id_ != -1) {",
          "480:             TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();",
          "481:             CodingReturnValue ret = thread_state_[0]->vp8_decode_thread(0, colldata);",
          "482:             if (ret == CODING_PARTIAL) {",
          "483:                 return ret;",
          "484:             }",
          "485:             TimingHarness::timing[0][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();",
          "486:         }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19924",
  "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
  "repo": "sqlite/sqlite",
  "patch_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
  "patch_info": {
    "commit_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/vdbeaux.c",
      "src/window.c"
    ],
    "message": "When an error occurs while rewriting the parser tree for window functions in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/vdbeaux.c||src/vdbeaux.c",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "376:   int addr;",
      "377:   CollSeq *p4;",
      "379:   if( isCommuted ){",
      "380:     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);",
      "381:   }else{",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:   if( pParse->nErr ) return 0;",
      "",
      "---------------"
    ],
    "src/vdbeaux.c||src/vdbeaux.c": [
      "File: src/vdbeaux.c -> src/vdbeaux.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1304: static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){",
      "1305:   assert( p->nOp>0 || p->aOp==0 );",
      "1307:   if( p->nOp ){",
      "1308:     assert( p->aOp );",
      "1309:     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
      "",
      "[Removed Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );",
      "",
      "[Added Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
      "1307:           || p->pParse->nErr>0 );",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "935:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
      "936:     if( pTab==0 ){",
      "938:     }",
      "940:     p->pSrc = 0;",
      "",
      "[Removed Lines]",
      "937:       return SQLITE_NOMEM;",
      "",
      "[Added Lines]",
      "937:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1039:     sqlite3DbFree(db, pTab);",
      "1040:   }",
      "1042:   return rc;",
      "1043: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1042:   if( rc && pParse->nErr==0 ){",
      "1043:     assert( pParse->db->mallocFailed );",
      "1044:     return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
      "1045:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
      "candidate_info": {
        "commit_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1cf197583de15d352dc169437f619d2e4631cf4b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/malloc.c",
          "src/sqliteInt.h",
          "src/tokenize.c"
        ],
        "message": "Give the sqlite3 object a pointer to the current Parse so that if an OOM occurs, it can automatically set the Parse.rc value to SQLITE_NOMEM.  This avoids a frequent extra test of db.mallocFailed in the innermost parser loop.\n\nFossilOrigin-Name: 5c6638040b3017c6be016441422d965a3ca00dd6ae1f78cadc0b54562978f64e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/malloc.c||src/malloc.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/tokenize.c||src/tokenize.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 440a7cda000164d3b46109caf2e1dde80681ba9b0d94ba9be6847d2b917445cf",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/malloc.c||src/malloc.c": [
          "File: src/malloc.c -> src/malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "661:       db->u1.isInterrupted = 1;",
          "662:     }",
          "663:     db->lookaside.bDisable++;",
          "664:   }",
          "665: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "664:     if( db->pParse ){",
          "665:       db->pParse->rc = SQLITE_NOMEM_BKPT;",
          "666:     }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/tokenize.c||src/tokenize.c": [
          "File: src/tokenize.c -> src/tokenize.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "563: #ifdef sqlite3Parser_ENGINEALWAYSONSTACK",
          "565: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:   VVA_ONLY( u8 startedWithOom = db->mallocFailed );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "594:   assert( pParse->pNewTrigger==0 );",
          "595:   assert( pParse->nVar==0 );",
          "596:   assert( pParse->pVList==0 );",
          "597:   while( 1 ){",
          "598:     n = sqlite3GetToken((u8*)zSql, &tokenType);",
          "599:     mxSqlLen -= n;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "598:   pParse->pParentParse = db->pParse;",
          "599:   db->pParse = pParse;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "650:     sqlite3Parser(pEngine, tokenType, pParse->sLastToken);",
          "651:     lastTokenParsed = tokenType;",
          "652:     zSql += n;",
          "654:   }",
          "655:   assert( nErr==0 );",
          "656: #ifdef YYTRACKMAXSTACKDEPTH",
          "",
          "[Removed Lines]",
          "653:     if( pParse->rc!=SQLITE_OK || db->mallocFailed ) break;",
          "",
          "[Added Lines]",
          "656:     assert( db->mallocFailed==0 || pParse->rc!=SQLITE_OK || startedWithOom );",
          "657:     if( pParse->rc!=SQLITE_OK ) break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "718:     pParse->pZombieTab = p->pNextZombie;",
          "719:     sqlite3DeleteTable(db, p);",
          "720:   }",
          "721:   assert( nErr==0 || pParse->rc!=SQLITE_OK );",
          "722:   return nErr;",
          "723: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "725:   db->pParse = pParse->pParentParse;",
          "726:   pParse->pParentParse = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c3bb59f76bd1cc196e6a5609017555b228eb64c",
      "candidate_info": {
        "commit_hash": "9c3bb59f76bd1cc196e6a5609017555b228eb64c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9c3bb59f76bd1cc196e6a5609017555b228eb64c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Fix the build for when -DSQLITE_SMALL_STACK is used.\n\nFossilOrigin-Name: b9eda2249ab5cf523093e4849c317d9a4b1743f7e15d96bdd6bb6cc423302914",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 89bf0399e87be76e7b264e0a35e8a6d3af0f9e71123a929c20754882b636ca70",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2984:     }else if( pRec->flags & (MEM_Int|MEM_IntReal) ){",
          "2986:       i64 i = pRec->u.i;",
          "2988:       testcase( pRec->flags & MEM_Int );",
          "2989:       testcase( pRec->flags & MEM_IntReal );",
          "2990:       if( i<0 ){",
          "2992:       }else{",
          "2994:       }",
          "2995:       nHdr++;",
          "3002:         if( (i&1)==i && file_format>=4 ){",
          "3004:         }else{",
          "3005:           nData++;",
          "3006:           pRec->uTemp = 1;",
          "3007:         }",
          "3009:         nData += 2;",
          "3010:         pRec->uTemp = 2;",
          "3012:         nData += 3;",
          "3013:         pRec->uTemp = 3;",
          "3015:         nData += 4;",
          "3016:         pRec->uTemp = 4;",
          "3018:         nData += 6;",
          "3019:         pRec->uTemp = 5;",
          "3020:       }else{",
          "",
          "[Removed Lines]",
          "2987:       u64 u;",
          "2991:         u = ~i;",
          "2993:         u = i;",
          "2996:       testcase( u==127 );               testcase( u==128 );",
          "2997:       testcase( u==32767 );             testcase( u==32768 );",
          "2998:       testcase( u==8388607 );           testcase( u==8388608 );",
          "2999:       testcase( u==2147483647 );        testcase( u==2147483648 );",
          "3000:       testcase( u==140737488355327LL ); testcase( u==140737488355328LL );",
          "3001:       if( u<=127 ){",
          "3003:           pRec->uTemp = 8+(u32)u;",
          "3008:       }else if( u<=32767 ){",
          "3011:       }else if( u<=8388607 ){",
          "3014:       }else if( u<=2147483647 ){",
          "3017:       }else if( u<=140737488355327LL ){",
          "",
          "[Added Lines]",
          "2987:       u64 uu;",
          "2991:         uu = ~i;",
          "2993:         uu = i;",
          "2996:       testcase( uu==127 );               testcase( uu==128 );",
          "2997:       testcase( uu==32767 );             testcase( uu==32768 );",
          "2998:       testcase( uu==8388607 );           testcase( uu==8388608 );",
          "2999:       testcase( uu==2147483647 );        testcase( uu==2147483648 );",
          "3000:       testcase( uu==140737488355327LL ); testcase( uu==140737488355328LL );",
          "3001:       if( uu<=127 ){",
          "3003:           pRec->uTemp = 8+(u32)uu;",
          "3008:       }else if( uu<=32767 ){",
          "3011:       }else if( uu<=8388607 ){",
          "3014:       }else if( uu<=2147483647 ){",
          "3017:       }else if( uu<=140737488355327LL ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b0ea9432a12c01597951967a18e530df1b4bffd1",
      "candidate_info": {
        "commit_hash": "b0ea9432a12c01597951967a18e530df1b4bffd1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b0ea9432a12c01597951967a18e530df1b4bffd1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/btreeInt.h"
        ],
        "message": "Defer computing the MemPage.nFree value of an in-memory btree page until it is actually needed, since for many pages it is never needed. This checkin works sufficiently to prove the concept, but still has issues with exception handling.\n\nFossilOrigin-Name: 1d43ee4000b71f5c6d49244dee96358c567f09ba3451b9d22895a796d3f61ad6",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/btreeInt.h||src/btreeInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: db74a56af73d92b7a9d43ceda7e4540915c580c68a0266b4ddefb9e0d5cbcbeb",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1506:   data[hdr+7] = 0;",
          "1508:  defragment_out:",
          "1509:   if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){",
          "1510:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1511:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1509:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1657:   testcase( gap+2+nByte==top );",
          "1658:   if( gap+2+nByte>top ){",
          "1659:     assert( pPage->nCell>0 || CORRUPT_DB );",
          "1660:     rc = defragmentPage(pPage, MIN(4, pPage->nFree - (2+nByte)));",
          "1661:     if( rc ) return rc;",
          "1662:     top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1661:     assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1845:   return SQLITE_OK;",
          "1846: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1854: static int btreeComputeFreeSpace(MemPage *pPage){",
          "1864:   assert( pPage->pBt!=0 );",
          "1865:   assert( pPage->pBt->db!=0 );",
          "1866:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "1867:   assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );",
          "1868:   assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );",
          "1869:   assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );",
          "1870:   assert( pPage->isInit==1 );",
          "1871:   assert( pPage->nFree<0 );",
          "1873:   usableSize = pPage->pBt->usableSize;",
          "1874:   hdr = pPage->hdrOffset;",
          "1875:   data = pPage->aData;",
          "1879:   top = get2byteNotZero(&data[hdr+5]);",
          "1880:   iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;",
          "1881:   iCellLast = usableSize - 4;",
          "1887:   pc = get2byte(&data[hdr+1]);",
          "1889:   if( pc>0 ){",
          "1890:     u32 next, size;",
          "1891:     if( pc<iCellFirst ){",
          "1895:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1896:     }",
          "1897:     while( 1 ){",
          "1898:       if( pc>iCellLast ){",
          "1900:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1901:       }",
          "1902:       next = get2byte(&data[pc]);",
          "1903:       size = get2byte(&data[pc+2]);",
          "1904:       nFree = nFree + size;",
          "1905:       if( next<=pc+size+3 ) break;",
          "1906:       pc = next;",
          "1907:     }",
          "1908:     if( next>0 ){",
          "1910:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1911:     }",
          "1912:     if( pc+size>(unsigned int)usableSize ){",
          "1914:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1915:     }",
          "1916:   }",
          "1925:   if( nFree>usableSize ){",
          "1926:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1927:   }",
          "1928:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "1929:   return SQLITE_OK;",
          "1930: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1890:   pPage->aDataEnd = &data[usableSize];",
          "1891:   pPage->aCellIdx = &data[cellOffset];",
          "1892:   pPage->aDataOfst = &data[pPage->childPtrSize];",
          "1899:   pPage->nCell = get2byte(&data[hdr+3]);",
          "",
          "[Removed Lines]",
          "1896:   top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1909:   assert( pPage->nCell>0 || top==usableSize || CORRUPT_DB );",
          "",
          "[Added Lines]",
          "1987:   assert( pPage->nCell>0",
          "1988:        || get2byteNotZero(&data[hdr+5])==usableSize",
          "1989:        || CORRUPT_DB );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1937:     }",
          "1938:     if( !pPage->leaf ) iCellLast++;",
          "1939:   }",
          "1987:   pPage->isInit = 1;",
          "1988:   return SQLITE_OK;",
          "1989: }",
          "",
          "[Removed Lines]",
          "1945:   pc = get2byte(&data[hdr+1]);",
          "1947:   if( pc>0 ){",
          "1948:     u32 next, size;",
          "1949:     if( pc<iCellFirst ){",
          "1953:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1954:     }",
          "1955:     while( 1 ){",
          "1956:       if( pc>iCellLast ){",
          "1958:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1959:       }",
          "1960:       next = get2byte(&data[pc]);",
          "1961:       size = get2byte(&data[pc+2]);",
          "1962:       nFree = nFree + size;",
          "1963:       if( next<=pc+size+3 ) break;",
          "1964:       pc = next;",
          "1965:     }",
          "1966:     if( next>0 ){",
          "1968:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1969:     }",
          "1970:     if( pc+size>(unsigned int)usableSize ){",
          "1972:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1973:     }",
          "1974:   }",
          "1983:   if( nFree>usableSize ){",
          "1984:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1985:   }",
          "1986:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2128:   if( pgno>btreePagecount(pBt) ){",
          "2129:     rc = SQLITE_CORRUPT_BKPT;",
          "2131:   }",
          "2132:   rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);",
          "2133:   if( rc ){",
          "2135:   }",
          "2137:   if( (*ppPage)->isInit==0 ){",
          "2138:     btreePageFromDbPage(pDbPage, pgno, pBt);",
          "2139:     rc = btreeInitPage(*ppPage);",
          "2140:     if( rc!=SQLITE_OK ){",
          "2143:     }",
          "2144:   }",
          "2145:   assert( (*ppPage)->pgno==pgno );",
          "",
          "[Removed Lines]",
          "2130:     goto getAndInitPage_error;",
          "2134:     goto getAndInitPage_error;",
          "2141:       releasePage(*ppPage);",
          "2142:       goto getAndInitPage_error;",
          "",
          "[Added Lines]",
          "2164:     goto getAndInitPage_error1;",
          "2168:     goto getAndInitPage_error1;",
          "2175:       goto getAndInitPage_error2;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2150:   if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){",
          "2151:     rc = SQLITE_CORRUPT_PGNO(pgno);",
          "2154:   }",
          "2155:   return SQLITE_OK;",
          "2158:   if( pCur ){",
          "2159:     pCur->iPage--;",
          "2160:     pCur->pPage = pCur->apPage[pCur->iPage];",
          "",
          "[Removed Lines]",
          "2152:     releasePage(*ppPage);",
          "2153:     goto getAndInitPage_error;",
          "2157: getAndInitPage_error:",
          "",
          "[Added Lines]",
          "2185:     goto getAndInitPage_error2;",
          "2189: getAndInitPage_error2:",
          "2190:   releasePage(*ppPage);",
          "2191: getAndInitPage_error1:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6566:   assert( CORRUPT_DB || sz==cellSize(pPage, idx) );",
          "6567:   assert( sqlite3PagerIswriteable(pPage->pDbPage) );",
          "6568:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "6569:   data = pPage->aData;",
          "6570:   ptr = &pPage->aCellIdx[2*idx];",
          "6571:   pc = get2byte(ptr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6603:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6638:   assert( sz==pPage->xCellSize(pPage, pCell) || (sz==8 && iChild>0) );",
          "6639:   if( pPage->nOverflow || sz+2>pPage->nFree ){",
          "6640:     if( pTemp ){",
          "6641:       memcpy(pTemp, pCell, sz);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6674:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7187:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "7188:   assert( sqlite3PagerIswriteable(pParent->pDbPage) );",
          "7189:   assert( pPage->nOverflow==1 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7228:   if( pPage->nFree<0 ){",
          "7229:     rc = btreeComputeFreeSpace(pPage);",
          "7230:     if( rc ) return rc;",
          "7231:   }",
          "7232:   if( pParent->nFree<0 ){",
          "7233:     rc = btreeComputeFreeSpace(pParent);",
          "7234:     if( rc ) return rc;",
          "7235:   }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7466:   if( !aOvflSpace ){",
          "7467:     return SQLITE_NOMEM_BKPT;",
          "7468:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7514:   if( pParent->nFree<0 ){",
          "7515:     rc = btreeComputeFreeSpace(pParent);",
          "7516:     if( rc ) return rc;",
          "7517:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7501:   pgno = get4byte(pRight);",
          "7502:   while( 1 ){",
          "7503:     rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);",
          "7504:     if( rc ){",
          "7505:       memset(apOld, 0, (i+1)*sizeof(MemPage*));",
          "7506:       goto balance_cleanup;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7553:     if( rc==0 && apOld[i]->nFree<0 ){",
          "7554:       rc = btreeComputeFreeSpace(apOld[i]);",
          "7555:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "7704:       b.apEnd[k] = pParent->aDataEnd;",
          "7705:       b.ixNx[k] = cntOld[i]+1;",
          "7706:     }",
          "7707:     szNew[i] = usableSpace - p->nFree;",
          "7708:     for(j=0; j<p->nOverflow; j++){",
          "7709:       szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7759:     assert( p->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "8247:     int iPage = pCur->iPage;",
          "8248:     MemPage *pPage = pCur->pPage;",
          "8250:     if( iPage==0 ){",
          "8251:       if( pPage->nOverflow ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8303:     if( pPage->nFree<0 ){",
          "8304:       rc = btreeComputeFreeSpace(pPage);",
          "8305:       if( rc ) break;",
          "8306:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "8621:   pPage = pCur->pPage;",
          "8622:   assert( pPage->intKey || pX->nKey>=0 );",
          "8623:   assert( pPage->leaf || !pPage->intKey );",
          "8625:   TRACE((\"INSERT: table=%d nkey=%lld ndata=%d page=%d %s\\n\",",
          "8626:           pCur->pgnoRoot, pX->nKey, pX->nData, pPage->pgno,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8681:   if( pPage->nFree<0 ){",
          "8682:     rc = btreeComputeFreeSpace(pPage);",
          "8683:     if( rc ) return rc;",
          "8684:   }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "8771:   iCellIdx = pCur->ix;",
          "8772:   pPage = pCur->pPage;",
          "8773:   pCell = findCell(pPage, iCellIdx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8835:   if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ) return SQLITE_CORRUPT;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "8841:     Pgno n;",
          "8842:     unsigned char *pTmp;",
          "8844:     if( iCellDepth<pCur->iPage-1 ){",
          "8845:       n = pCur->apPage[iCellDepth+1]->pgno;",
          "8846:     }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8906:     if( pLeaf->nFree<0 ){",
          "8907:       rc = btreeComputeFreeSpace(pLeaf);",
          "8908:       if( rc ) return rc;",
          "8909:     }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "9732:                    \"btreeInitPage() returns error code %d\", rc);",
          "9733:     goto end_of_check;",
          "9734:   }",
          "9735:   data = pPage->aData;",
          "9736:   hdr = pPage->hdrOffset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9801:   if( (rc = btreeComputeFreeSpace(pPage))!=0 ){",
          "9802:     assert( rc==SQLITE_CORRUPT );",
          "9803:     checkAppendMsg(pCheck, \"free space corruption\", rc);",
          "9804:     goto end_of_check;",
          "9805:   }",
          "",
          "---------------"
        ],
        "src/btreeInt.h||src/btreeInt.h": [
          "File: src/btreeInt.h -> src/btreeInt.h"
        ]
      }
    },
    {
      "candidate_hash": "41422656450bed94abee2edf1df83660325afc5c",
      "candidate_info": {
        "commit_hash": "41422656450bed94abee2edf1df83660325afc5c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/41422656450bed94abee2edf1df83660325afc5c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "test/fuzzdata8.db"
        ],
        "message": "Ensure that the BtShared.nPage value is reset correctly on a SAVEPOINT ROLLBACK.\n\nFossilOrigin-Name: e6d5fee8cdbdce8515957e8288e4d1e7b06f417fd3f9deeeb636fbf5b995af51",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7e4809eadfe99ebfd797a7c63501421021a720bbeed9fba81bebf630c58bb791",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4153:   return rc;",
          "4154: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4160: static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){",
          "4161:   int nPage = get4byte(&pPage1->aData[28]);",
          "4162:   testcase( nPage==0 );",
          "4163:   if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);",
          "4164:   testcase( pBt->nPage!=nPage );",
          "4165:   pBt->nPage = nPage;",
          "4166: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4200:     if( btreeGetPage(pBt, 1, &pPage1, 0)==SQLITE_OK ){",
          "4206:       releasePageOne(pPage1);",
          "4207:     }",
          "4208:     assert( countValidCursors(pBt, 1)==0 );",
          "",
          "[Removed Lines]",
          "4201:       int nPage = get4byte(28+(u8*)pPage1->aData);",
          "4202:       testcase( nPage==0 );",
          "4203:       if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);",
          "4204:       testcase( pBt->nPage!=nPage );",
          "4205:       pBt->nPage = nPage;",
          "",
          "[Added Lines]",
          "4213:       btreeSetNPage(pBt, pPage1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4282:         pBt->nPage = 0;",
          "4283:       }",
          "4284:       rc = newDatabase(pBt);",
          "",
          "[Removed Lines]",
          "4285:       pBt->nPage = get4byte(28 + pBt->pPage1->aData);",
          "",
          "[Added Lines]",
          "4293:       btreeSetNPage(pBt, pBt->pPage1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ed6c068f556dd45f705355c3454c1f8af1047d4",
      "candidate_info": {
        "commit_hash": "7ed6c068f556dd45f705355c3454c1f8af1047d4",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/7ed6c068f556dd45f705355c3454c1f8af1047d4",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/vdbeaux.c",
          "test/indexexpr2.test"
        ],
        "message": "Fix a problem in [b5ca442a] causing an assert() to fail in REINDEX commands.\n\nFossilOrigin-Name: a3e77c7776ab01dadb9d30d6067ac97e9d4b09ec54834558a5fa1ffed7b52c72",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/vdbeaux.c||src/vdbeaux.c",
          "test/indexexpr2.test||test/indexexpr2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/vdbeaux.c||src/vdbeaux.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/vdbeaux.c||src/vdbeaux.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b8071d10cba8f6c19fb8d5df3877f72567dc6d6a94744a39cbc1f58b2e2f343b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "648:       break;",
          "649:     }",
          "650:     if( opcode==OP_CreateBtree && pOp->p3==BTREE_INTKEY ) hasCreateTable = 1;",
          "652:     if( opcode==OP_InitCoroutine ) hasInitCoroutine = 1;",
          "653: #ifndef SQLITE_OMIT_FOREIGN_KEY",
          "654:     if( opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1 ){",
          "",
          "[Removed Lines]",
          "651:     if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;",
          "",
          "[Added Lines]",
          "651:     if( mayAbort ){",
          "656:       if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;",
          "657:       if( opcode==OP_Clear ) hasCreateIndex = 1;",
          "658:     }",
          "",
          "---------------"
        ],
        "test/indexexpr2.test||test/indexexpr2.test": [
          "File: test/indexexpr2.test -> test/indexexpr2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "291:   SELECT sql FROM sqlite_master WHERE tbl_name = 't0';",
          "292:   CREATE INDEX i0 ON t0(c0);",
          "293: } {{CREATE TABLE t0(c0)}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "294: do_execsql_test 7.3 {",
          "295:   REINDEX;",
          "296: } {}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
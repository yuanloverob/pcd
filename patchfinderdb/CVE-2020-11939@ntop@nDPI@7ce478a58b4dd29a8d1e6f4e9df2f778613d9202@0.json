{
  "cve_id": "CVE-2020-11939",
  "cve_desc": "In nDPI through 3.2 Stable, the SSH protocol dissector has multiple KEXINIT integer overflows that result in a controlled remote heap overflow in concat_hash_string in ssh.c. Due to the granular nature of the overflow primitive and the ability to control both the contents and layout of the nDPI library's heap memory through remote input, this vulnerability may be abused to achieve full Remote Code Execution against any network inspection stack that is linked against nDPI and uses it to perform network traffic analysis.",
  "repo": "ntop/nDPI",
  "patch_hash": "7ce478a58b4dd29a8d1e6f4e9df2f778613d9202",
  "patch_info": {
    "commit_hash": "7ce478a58b4dd29a8d1e6f4e9df2f778613d9202",
    "repo": "ntop/nDPI",
    "commit_url": "https://github.com/ntop/nDPI/commit/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202",
    "files": [
      "src/lib/protocols/ssh.c"
    ],
    "message": "ssh: fixing unsigned overflow leading to heap overflow\n\ncf GHSL-2020-051",
    "before_after_code_files": [
      "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
    ]
  },
  "patch_diff": {
    "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c": [
      "File: src/lib/protocols/ssh.c -> src/lib/protocols/ssh.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "96: static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,",
      "97:        char *buf, u_int8_t client_hash) {",
      "99:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
      "100:     goto invalid_payload;",
      "101:   u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "",
      "[Removed Lines]",
      "98:   u_int16_t offset = 22, buf_out_len = 0;",
      "",
      "[Added Lines]",
      "98:   u_int32_t offset = 22, buf_out_len = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "114:     goto invalid_payload;",
      "116:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "117:   offset += 4 + len;",
      "119:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "117:   if (len > UINT32_MAX - 4 - offset)",
      "118:     goto invalid_payload;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "122:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "124:   if(client_hash) {",
      "127:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
      "128:       goto invalid_payload;",
      "130:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
      "131:     buf_out_len += len;",
      "132:     buf[buf_out_len++] = ';';",
      "137:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
      "138:     goto invalid_payload;",
      "140:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "142:   if(!client_hash) {",
      "145:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
      "146:       goto invalid_payload;",
      "148:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
      "149:     buf_out_len += len;",
      "150:     buf[buf_out_len++] = ';';",
      "155:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
      "156:     goto invalid_payload;",
      "158:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "160:   if(client_hash) {",
      "163:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
      "164:       goto invalid_payload;",
      "166:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
      "167:     buf_out_len += len;",
      "168:     buf[buf_out_len++] = ';';",
      "173:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
      "174:     goto invalid_payload;",
      "176:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "178:   if(!client_hash) {",
      "181:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
      "182:       goto invalid_payload;",
      "184:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
      "185:     buf_out_len += len;",
      "186:     buf[buf_out_len++] = ';';",
      "192:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
      "193:     goto invalid_payload;",
      "194:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "196:   if(client_hash) {",
      "199:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
      "200:       goto invalid_payload;",
      "202:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
      "203:     buf_out_len += len;",
      "208:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
      "209:     goto invalid_payload;",
      "211:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
      "213:   if(!client_hash) {",
      "216:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
      "217:       goto invalid_payload;",
      "219:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
      "220:     buf_out_len += len;",
      "",
      "[Removed Lines]",
      "125:     offset += 4;",
      "133:     offset += len;",
      "134:   } else",
      "135:     offset += 4 + len;",
      "143:     offset += 4;",
      "151:     offset += len;",
      "152:   } else",
      "153:     offset += 4 + len;",
      "161:     offset += 4;",
      "169:     offset += len;",
      "170:   } else",
      "171:     offset += 4 + len;",
      "179:     offset += 4;",
      "187:     offset += len;",
      "188:   } else",
      "189:     offset += 4 + len;",
      "197:     offset += 4;",
      "204:     offset += len;",
      "205:   } else",
      "206:     offset += 4 + len;",
      "214:     offset += 4;",
      "221:     offset += len;",
      "222:   } else",
      "223:     offset += 4 + len;",
      "",
      "[Added Lines]",
      "126:   offset += 4;",
      "134:   }",
      "135:   if (len > UINT32_MAX - offset)",
      "136:     goto invalid_payload;",
      "137:   offset += len;",
      "144:   offset += 4;",
      "152:   }",
      "153:   if (len > UINT32_MAX - offset)",
      "154:     goto invalid_payload;",
      "155:   offset += len;",
      "162:   offset += 4;",
      "170:   }",
      "171:   if (len > UINT32_MAX - offset)",
      "172:     goto invalid_payload;",
      "173:   offset += len;",
      "180:   offset += 4;",
      "188:   }",
      "189:   if (len > UINT32_MAX - offset)",
      "190:     goto invalid_payload;",
      "191:   offset += len;",
      "198:   offset += 4;",
      "205:   }",
      "206:   if (len > UINT32_MAX - offset)",
      "207:     goto invalid_payload;",
      "208:   offset += len;",
      "215:   offset += 4;",
      "222:   }",
      "223:   if (len > UINT32_MAX - offset)",
      "224:     goto invalid_payload;",
      "225:   offset += len;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3bbb0cd3296023f6f922c71d21a1c374d2b0a435",
      "candidate_info": {
        "commit_hash": "3bbb0cd3296023f6f922c71d21a1c374d2b0a435",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/3bbb0cd3296023f6f922c71d21a1c374d2b0a435",
        "files": [
          "src/lib/protocols/ssh.c"
        ],
        "message": "ssh: adds systematic bounds checks in concat_hash_string\n\ncf GHSL-2020-052",
        "before_after_code_files": [
          "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/ntop/nDPI/pull/865"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ],
          "candidate": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c": [
          "File: src/lib/protocols/ssh.c -> src/lib/protocols/ssh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:   buf[buf_out_len++] = ';';",
          "111:   offset += len;",
          "114:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "115:   offset += 4 + len;",
          "118:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "114:     goto invalid_payload;",
          "119:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "120:     goto invalid_payload;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:   } else",
          "131:     offset += 4 + len;",
          "134:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "138:     goto invalid_payload;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "146:   } else",
          "147:     offset += 4 + len;",
          "150:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "155:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "156:     goto invalid_payload;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "162:   } else",
          "163:     offset += 4 + len;",
          "166:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "174:     goto invalid_payload;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "195:   } else",
          "196:     offset += 4 + len;",
          "199:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "208:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "209:     goto invalid_payload;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e7c0ac37d87958c80115e7553ea39b26668ce360",
      "candidate_info": {
        "commit_hash": "e7c0ac37d87958c80115e7553ea39b26668ce360",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/e7c0ac37d87958c80115e7553ea39b26668ce360",
        "files": [
          "example/ndpiReader.c",
          "example/reader_util.c",
          "example/reader_util.h",
          "src/include/ndpi_typedefs.h",
          "src/lib/protocols/ssh.c",
          "src/lib/protocols/tls.c",
          "src/lib/third_party/include/ndpi_md5.h",
          "src/lib/third_party/src/ndpi_md5.c"
        ],
        "message": "Implemented HASSH (https://github.com/salesforce/hassh)",
        "before_after_code_files": [
          "example/ndpiReader.c||example/ndpiReader.c",
          "example/reader_util.c||example/reader_util.c",
          "example/reader_util.h||example/reader_util.h",
          "src/include/ndpi_typedefs.h||src/include/ndpi_typedefs.h",
          "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c",
          "src/lib/protocols/tls.c||src/lib/protocols/tls.c",
          "src/lib/third_party/include/ndpi_md5.h||src/lib/third_party/include/ndpi_md5.h",
          "src/lib/third_party/src/ndpi_md5.c||src/lib/third_party/src/ndpi_md5.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ],
          "candidate": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ]
        }
      },
      "candidate_diff": {
        "example/ndpiReader.c||example/ndpiReader.c": [
          "File: example/ndpiReader.c -> example/ndpiReader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "973:     if(flow->ssh_tls.ssl_version != 0) fprintf(out, \"[%s]\", ndpi_ssl_version2str(flow->ssh_tls.ssl_version));",
          "974:     if(flow->ssh_tls.client_info[0] != '\\0') fprintf(out, \"[client: %s]\", flow->ssh_tls.client_info);",
          "975:     if(flow->ssh_tls.ja3_client[0] != '\\0') fprintf(out, \"[JA3C: %s%s]\", flow->ssh_tls.ja3_client,",
          "976:           print_cipher(flow->ssh_tls.client_unsafe_cipher));",
          "977:     if(flow->ssh_tls.server_info[0] != '\\0') fprintf(out, \"[server: %s]\", flow->ssh_tls.server_info);",
          "979:     if(flow->ssh_tls.ja3_server[0] != '\\0') fprintf(out, \"[JA3S: %s%s]\", flow->ssh_tls.ja3_server,",
          "980:           print_cipher(flow->ssh_tls.server_unsafe_cipher));",
          "981:     if(flow->ssh_tls.server_organization[0] != '\\0') fprintf(out, \"[organization: %s]\", flow->ssh_tls.server_organization);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "975:     if(flow->ssh_tls.client_hassh[0] != '\\0') fprintf(out, \"[HASSH-C: %s]\", flow->ssh_tls.client_hassh);",
          "980:     if(flow->ssh_tls.server_hassh[0] != '\\0') fprintf(out, \"[HASSH-S: %s]\", flow->ssh_tls.server_hassh);",
          "",
          "---------------"
        ],
        "example/reader_util.c||example/reader_util.c": [
          "File: example/reader_util.c -> example/reader_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "862:         flow->ndpi_flow->protos.ssh.client_signature);",
          "863:       snprintf(flow->ssh_tls.server_info, sizeof(flow->ssh_tls.server_info), \"%s\",",
          "864:         flow->ndpi_flow->protos.ssh.server_signature);",
          "865:     }",
          "867:     else if((flow->detected_protocol.app_protocol == NDPI_PROTOCOL_TLS)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "865:       snprintf(flow->ssh_tls.client_hassh, sizeof(flow->ssh_tls.client_hassh), \"%s\",",
          "866:         flow->ndpi_flow->protos.ssh.hassh_client);",
          "867:       snprintf(flow->ssh_tls.server_hassh, sizeof(flow->ssh_tls.server_hassh), \"%s\",",
          "868:         flow->ndpi_flow->protos.ssh.hassh_server);",
          "",
          "---------------"
        ],
        "example/reader_util.h||example/reader_util.h": [
          "File: example/reader_util.h -> example/reader_util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "153:   struct {",
          "154:     u_int16_t ssl_version;",
          "156:       ja3_client[33], ja3_server[33];",
          "157:     u_int16_t server_cipher;",
          "158:     ndpi_cipher_weakness client_unsafe_cipher, server_unsafe_cipher;",
          "",
          "[Removed Lines]",
          "155:     char client_info[64], server_info[64], server_organization[64],",
          "",
          "[Added Lines]",
          "155:     char client_info[64], server_info[64],",
          "156:       client_hassh[33], server_hassh[33],",
          "157:       server_organization[64],",
          "",
          "---------------"
        ],
        "src/include/ndpi_typedefs.h||src/include/ndpi_typedefs.h": [
          "File: src/include/ndpi_typedefs.h -> src/include/ndpi_typedefs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1172:     struct {",
          "1173:       char client_signature[48], server_signature[48];",
          "1174:     } ssh;",
          "1176:     struct {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1174:       char hassh_client[33], hassh_server[33];",
          "",
          "---------------"
        ],
        "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c": [
          "File: src/lib/protocols/ssh.c -> src/lib/protocols/ssh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #define NDPI_CURRENT_PROTO NDPI_PROTOCOL_SSH",
          "29: #include \"ndpi_api.h\"",
          "31: static void ndpi_int_ssh_add_connection(struct ndpi_detection_module_struct",
          "33:   ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_SSH, NDPI_PROTOCOL_UNKNOWN);",
          "34: }",
          "36: static void ndpi_ssh_zap_cr(char *str, int len) {",
          "37:   len--;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"ndpi_md5.h\"",
          "33:   HASSH - https://github.com/salesforce/hassh",
          "35:   https://github.com/salesforce/hassh/blob/master/python/hassh.py",
          "37:   [server]",
          "38:   skex = packet.ssh.kex_algorithms",
          "39:   seastc = packet.ssh.encryption_algorithms_server_to_client",
          "40:   smastc = packet.ssh.mac_algorithms_server_to_client",
          "41:   scastc = packet.ssh.compression_algorithms_server_to_client",
          "42:   hasshs_str = ';'.join([skex, seastc, smastc, scastc])",
          "44:   [client]",
          "45:   ckex = packet.ssh.kex_algorithms",
          "46:   ceacts = packet.ssh.encryption_algorithms_client_to_server",
          "47:   cmacts = packet.ssh.mac_algorithms_client_to_server",
          "48:   ccacts = packet.ssh.compression_algorithms_client_to_server",
          "49:   hassh_str = ';'.join([ckex, ceacts, cmacts, ccacts])",
          "63: static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,",
          "64:        char *buf, u_int8_t client_hash) {",
          "65:   u_int16_t offset = 22, buf_out_len = 0;",
          "66:   u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "68:   if(len < (packet->payload_packet_len-offset)) {",
          "70:     offset += 4;",
          "71:     strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);",
          "72:     buf[buf_out_len++] = ';';",
          "73:     offset += len;",
          "76:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "77:     offset += 4 + len;",
          "80:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "82:     if(client_hash) {",
          "83:       offset += 4;",
          "84:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "85:       buf_out_len += len;",
          "86:       buf[buf_out_len++] = ';';",
          "87:       offset += len;",
          "88:     } else",
          "89:       offset += 4 + len;",
          "92:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "93:     if(!client_hash) {",
          "94:       offset += 4;",
          "95:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "96:       buf_out_len += len;",
          "97:       buf[buf_out_len++] = ';';",
          "98:       offset += len;",
          "99:     } else",
          "100:       offset += 4 + len;",
          "103:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "104:     if(client_hash) {",
          "105:       offset += 4;",
          "106:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "107:       buf_out_len += len;",
          "108:       buf[buf_out_len++] = ';';",
          "109:       offset += len;",
          "110:     } else",
          "111:       offset += 4 + len;",
          "114:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "115:     if(!client_hash) {",
          "116:       offset += 4;",
          "117:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "118:       buf_out_len += len;",
          "119:       buf[buf_out_len++] = ';';",
          "120:       offset += len;",
          "121:     } else",
          "122:       offset += 4 + len;",
          "125:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "126:     if(client_hash) {",
          "127:       offset += 4;",
          "128:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "129:       buf_out_len += len;",
          "130:       offset += len;",
          "131:     } else",
          "132:       offset += 4 + len;",
          "135:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "136:     if(!client_hash) {",
          "137:       offset += 4;",
          "138:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "139:       buf_out_len += len;",
          "140:       offset += len;",
          "141:     } else",
          "142:       offset += 4 + len;",
          "147:   }",
          "149: #ifdef SSH_DEBUG",
          "150:   printf(\"\\n[SSH] %s\\n\", buf);",
          "151: #endif",
          "153:   return(buf_out_len);",
          "154: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:   }",
          "46: }",
          "54:  && memcmp(packet->payload, \"SSH-\", 4) == 0) {",
          "55:       if(!ndpi_struct->disable_metadata_export) {",
          "57:  strncpy(flow->protos.ssh.client_signature, (const char *)packet->payload, len);",
          "58:  flow->protos.ssh.client_signature[len] = '\\0';",
          "59:  ndpi_ssh_zap_cr(flow->protos.ssh.client_signature, len);",
          "60:       }",
          "62:       NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 0 passed\\n\");",
          "63:       flow->l4.tcp.ssh_stage = 1 + packet->packet_direction;",
          "64:       return;",
          "65:     }",
          "68:  && memcmp(packet->payload, \"SSH-\", 4) == 0) {",
          "69:       if(!ndpi_struct->disable_metadata_export) {",
          "70:  int len = ndpi_min(sizeof(flow->protos.ssh.server_signature)-1, packet->payload_packet_len);",
          "71:  strncpy(flow->protos.ssh.server_signature, (const char *)packet->payload, len);",
          "72:  flow->protos.ssh.server_signature[len] = '\\0';",
          "73:  ndpi_ssh_zap_cr(flow->protos.ssh.server_signature, len);",
          "74:       }",
          "79:       return;",
          "81:     }",
          "82:   }",
          "84:   NDPI_LOG_DBG(ndpi_struct, \"excluding ssh at stage %d\\n\", flow->l4.tcp.ssh_stage);",
          "85:   NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_SSH);",
          "86: }",
          "89: void init_ssh_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)",
          "90: {",
          "",
          "[Removed Lines]",
          "48: void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)",
          "49: {",
          "50:   struct ndpi_packet_struct *packet = &flow->packet;",
          "52:   if (flow->l4.tcp.ssh_stage == 0) {",
          "53:     if (packet->payload_packet_len > 7 && packet->payload_packet_len < 100",
          "56:  int len = ndpi_min(sizeof(flow->protos.ssh.client_signature)-1, packet->payload_packet_len);",
          "66:   } else if (flow->l4.tcp.ssh_stage == (2 - packet->packet_direction)) {",
          "67:     if (packet->payload_packet_len > 7 && packet->payload_packet_len < 500",
          "76:       NDPI_LOG_INFO(ndpi_struct, \"found ssh\\n\");",
          "78:       ndpi_int_ssh_add_connection(ndpi_struct, flow);",
          "",
          "[Added Lines]",
          "172: void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {",
          "173:   struct ndpi_packet_struct *packet = &flow->packet;",
          "175: #ifdef SSH_DEBUG",
          "176:   printf(\"\\n[SSH] [stage: %u]\\n\", flow->l4.tcp.ssh_stage);",
          "177: #endif",
          "179:   if(flow->l4.tcp.ssh_stage == 0) {",
          "180:     if(packet->payload_packet_len > 7 && packet->payload_packet_len < 100",
          "183:         int len = ndpi_min(sizeof(flow->protos.ssh.client_signature)-1, packet->payload_packet_len);",
          "189: #ifdef SSH_DEBUG",
          "190:  printf(\"\\n[SSH] [client_signature: %s]\\n\", flow->protos.ssh.client_signature);",
          "191: #endif",
          "196:       flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;",
          "199:   } else if(flow->l4.tcp.ssh_stage == (2 - packet->packet_direction)) {",
          "200:     if(packet->payload_packet_len > 7 && packet->payload_packet_len < 500",
          "209: #ifdef SSH_DEBUG",
          "210:  printf(\"\\n[SSH] [server_signature: %s]\\n\", flow->protos.ssh.server_signature);",
          "211: #endif",
          "213:  NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 1 passed\\n\");",
          "214:  flow->l4.tcp.ssh_stage++;;",
          "215:  flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;",
          "216:       } else {",
          "217:  NDPI_LOG_INFO(ndpi_struct, \"found ssh\\n\");",
          "218:  ndpi_int_ssh_add_connection(ndpi_struct, flow);",
          "221: #ifdef SSH_DEBUG",
          "222:       printf(\"\\n[SSH] [completed stage: %u]\\n\", flow->l4.tcp.ssh_stage);",
          "223: #endif",
          "226:     }",
          "227:   } else {",
          "228:     u_int8_t msgcode = *(packet->payload + 5);",
          "229:     ndpi_MD5_CTX ctx;",
          "231: #ifdef SSH_DEBUG",
          "232:     printf(\"\\n[SSH] [stage: %u][msg: %u]\\n\", flow->l4.tcp.ssh_stage, msgcode);",
          "233: #endif",
          "235:     if(msgcode == 20 /* key exchange init */) {",
          "236:       char *hassh_buf = calloc(packet->payload_packet_len, sizeof(char));",
          "237:       u_int i, len;",
          "239:       if(hassh_buf) {",
          "240:  if(flow->l4.tcp.ssh_stage == 3) {",
          "241:    u_char fingerprint_client[16];",
          "243:    len = concat_hash_string(packet, hassh_buf, 1 /* client */);",
          "245:    ndpi_MD5Init(&ctx);",
          "246:    ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);",
          "247:    ndpi_MD5Final(fingerprint_client, &ctx);",
          "249: #ifdef SSH_DEBUG",
          "250:    {",
          "251:      printf(\"\\n[SSH] [client][%s][\", hassh_buf);",
          "252:      for(i=0; i<16; i++) printf(\"%02X\", fingerprint_client[i]);",
          "253:      printf(\"]\\n\");",
          "254:    }",
          "255: #endif",
          "256:    for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_client[i*2], \"%02X\", fingerprint_client[i] & 0xFF);",
          "257:    flow->protos.ssh.hassh_client[32] = '\\0';",
          "258:  } else {",
          "259:    u_char fingerprint_server[16];",
          "261:    len = concat_hash_string(packet, hassh_buf, 0 /* server */);",
          "263:    ndpi_MD5Init(&ctx);",
          "264:    ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);",
          "265:    ndpi_MD5Final(fingerprint_server, &ctx);",
          "267: #ifdef SSH_DEBUG",
          "268:    {",
          "269:      printf(\"\\n[SSH] [server][%s][\", hassh_buf);",
          "270:      for(i=0; i<16; i++) printf(\"%02X\", fingerprint_server[i]);",
          "271:      printf(\"]\\n\");",
          "272:    }",
          "273: #endif",
          "275:    for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_server[i*2], \"%02X\", fingerprint_server[i] & 0xFF);",
          "276:    flow->protos.ssh.hassh_server[32] = '\\0';",
          "277:  }",
          "279:  free(hassh_buf);",
          "280:       }",
          "283:     if(flow->l4.tcp.ssh_stage++ == 4) {",
          "284:       NDPI_LOG_INFO(ndpi_struct, \"found ssh\\n\");",
          "285:       ndpi_int_ssh_add_connection(ndpi_struct, flow);",
          "286:     }",
          "288:     return;",
          "",
          "---------------"
        ],
        "src/lib/protocols/tls.c||src/lib/protocols/tls.c": [
          "File: src/lib/protocols/tls.c -> src/lib/protocols/tls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #define NDPI_CURRENT_PROTO NDPI_PROTOCOL_TLS",
          "28: #include \"ndpi_api.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"ndpi_md5.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "236: static u_int32_t ndpi_tls_refine_master_protocol(struct ndpi_detection_module_struct *ndpi_struct,",
          "237:        struct ndpi_flow_struct *flow, u_int32_t protocol) {",
          "238:   struct ndpi_packet_struct *packet = &flow->packet;",
          "",
          "[Removed Lines]",
          "40: typedef struct MD5Context {",
          "41:   uint32_t buf[4];",
          "42:   uint32_t bits[2];",
          "43:   unsigned char in[64];",
          "44: } MD5_CTX;",
          "48: static int is_big_endian(void) {",
          "49:   static const int n = 1;",
          "50:   return ((char *) &n)[0] == 0;",
          "51: }",
          "53: static void byteReverse(unsigned char *buf, unsigned longs) {",
          "55:   if (is_big_endian()) {",
          "56:     do {",
          "57:       uint32_t t;",
          "59:       t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "60:  ((unsigned) buf[1] << 8 | buf[0]);",
          "62:       buf += 4;",
          "63:     } while (--longs);",
          "64:   }",
          "65: }",
          "67: #define F1(x, y, z) (z ^ (x & (y ^ z)))",
          "68: #define F2(x, y, z) F1(z, x, y)",
          "69: #define F3(x, y, z) (x ^ y ^ z)",
          "70: #define F4(x, y, z) (y ^ (x | ~z))",
          "72: #define MD5STEP(f, w, x, y, z, data, s) \\",
          "73:   ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )",
          "77: static void MD5Init(MD5_CTX *ctx) {",
          "78:   ctx->buf[0] = 0x67452301;",
          "79:   ctx->buf[1] = 0xefcdab89;",
          "80:   ctx->buf[2] = 0x98badcfe;",
          "81:   ctx->buf[3] = 0x10325476;",
          "83:   ctx->bits[0] = 0;",
          "84:   ctx->bits[1] = 0;",
          "85: }",
          "87: static void MD5Transform(uint32_t buf[4], uint32_t const in[16]) {",
          "88:   uint32_t a, b, c, d;",
          "90:   a = buf[0];",
          "91:   b = buf[1];",
          "92:   c = buf[2];",
          "93:   d = buf[3];",
          "95:   MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);",
          "96:   MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);",
          "97:   MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);",
          "98:   MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);",
          "99:   MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);",
          "100:   MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);",
          "101:   MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);",
          "102:   MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);",
          "103:   MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);",
          "104:   MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);",
          "105:   MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);",
          "106:   MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);",
          "107:   MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);",
          "108:   MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);",
          "109:   MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);",
          "110:   MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);",
          "112:   MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);",
          "113:   MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);",
          "114:   MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);",
          "115:   MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);",
          "116:   MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);",
          "117:   MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);",
          "118:   MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);",
          "119:   MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);",
          "120:   MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);",
          "121:   MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);",
          "122:   MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);",
          "123:   MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);",
          "124:   MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);",
          "125:   MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);",
          "126:   MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);",
          "127:   MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);",
          "129:   MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);",
          "130:   MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);",
          "131:   MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);",
          "132:   MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);",
          "133:   MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);",
          "134:   MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);",
          "135:   MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);",
          "136:   MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);",
          "137:   MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);",
          "138:   MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);",
          "139:   MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);",
          "140:   MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);",
          "141:   MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);",
          "142:   MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);",
          "143:   MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);",
          "144:   MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);",
          "146:   MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);",
          "147:   MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);",
          "148:   MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);",
          "149:   MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);",
          "150:   MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);",
          "151:   MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);",
          "152:   MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);",
          "153:   MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);",
          "154:   MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);",
          "155:   MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);",
          "156:   MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);",
          "157:   MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);",
          "158:   MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);",
          "159:   MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);",
          "160:   MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);",
          "161:   MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);",
          "163:   buf[0] += a;",
          "164:   buf[1] += b;",
          "165:   buf[2] += c;",
          "166:   buf[3] += d;",
          "167: }",
          "169: static void MD5Update(MD5_CTX *ctx, unsigned char const *buf, unsigned len) {",
          "170:   uint32_t t;",
          "172:   t = ctx->bits[0];",
          "173:   if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t)",
          "174:     ctx->bits[1]++;",
          "175:   ctx->bits[1] += len >> 29;",
          "177:   t = (t >> 3) & 0x3f;",
          "179:   if (t) {",
          "180:     unsigned char *p = (unsigned char *) ctx->in + t;",
          "182:     t = 64 - t;",
          "183:     if (len < t) {",
          "184:       memcpy(p, buf, len);",
          "185:       return;",
          "186:     }",
          "187:     memcpy(p, buf, t);",
          "188:     byteReverse(ctx->in, 16);",
          "189:     MD5Transform(ctx->buf, (uint32_t *) ctx->in);",
          "190:     buf += t;",
          "191:     len -= t;",
          "192:   }",
          "194:   while (len >= 64) {",
          "195:     memcpy(ctx->in, buf, 64);",
          "196:     byteReverse(ctx->in, 16);",
          "197:     MD5Transform(ctx->buf, (uint32_t *) ctx->in);",
          "198:     buf += 64;",
          "199:     len -= 64;",
          "200:   }",
          "202:   memcpy(ctx->in, buf, len);",
          "203: }",
          "205: static void MD5Final(unsigned char digest[16], MD5_CTX *ctx) {",
          "206:   unsigned count;",
          "207:   unsigned char *p;",
          "208:   uint32_t *c = (uint32_t*)ctx->in;",
          "210:   count = (ctx->bits[0] >> 3) & 0x3F;",
          "212:   p = ctx->in + count;",
          "214:   count = 64 - 1 - count;",
          "215:   if (count < 8) {",
          "216:     memset(p, 0, count);",
          "217:     byteReverse(ctx->in, 16);",
          "218:     MD5Transform(ctx->buf, (uint32_t *) ctx->in);",
          "219:     memset(ctx->in, 0, 56);",
          "220:   } else {",
          "221:     memset(p, 0, count - 8);",
          "222:   }",
          "223:   byteReverse(ctx->in, 14);",
          "225:   c[14] = ctx->bits[0];",
          "226:   c[15] = ctx->bits[1];",
          "228:   MD5Transform(ctx->buf, (uint32_t *) ctx->in);",
          "229:   byteReverse((unsigned char *) ctx->buf, 4);",
          "230:   memcpy(digest, ctx->buf, 16);",
          "231:   memset((char *) ctx, 0, sizeof(*ctx));",
          "232: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "375:   u_int8_t invalid_ja3 = 0;",
          "376:   u_int16_t pkt_tls_version = (packet->payload[1] << 8) + packet->payload[2], ja3_str_len;",
          "377:   char ja3_str[JA3_STR_LEN];",
          "379:   u_char md5_hash[16];",
          "381:   if(packet->udp) {",
          "",
          "[Removed Lines]",
          "378:   MD5_CTX ctx;",
          "",
          "[Added Lines]",
          "183:   ndpi_MD5_CTX ctx;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "521:    printf(\"[JA3] Server: %s \\n\", ja3_str);",
          "522: #endif",
          "528:    for(i=0, j=0; i<16; i++)",
          "529:      j += snprintf(&flow->protos.stun_ssl.ssl.ja3_server[j],",
          "",
          "[Removed Lines]",
          "524:    MD5Init(&ctx);",
          "525:    MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));",
          "526:    MD5Final(md5_hash, &ctx);",
          "",
          "[Added Lines]",
          "329:    ndpi_MD5Init(&ctx);",
          "330:    ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));",
          "331:    ndpi_MD5Final(md5_hash, &ctx);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "834: #ifdef DEBUG_TLS",
          "835:       printf(\"[JA3] Client: %s \\n\", ja3_str);",
          "836: #endif",
          "842:       for(i=0, j=0; i<16; i++)",
          "843:         j += snprintf(&flow->protos.stun_ssl.ssl.ja3_client[j],",
          "846: #ifdef DEBUG_TLS",
          "847:       printf(\"[JA3] Client: %s \\n\", flow->protos.stun_ssl.ssl.ja3_client);",
          "",
          "[Removed Lines]",
          "838:       MD5Init(&ctx);",
          "839:       MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));",
          "840:       MD5Final(md5_hash, &ctx);",
          "844:         sizeof(flow->protos.stun_ssl.ssl.ja3_client)-j, \"%02x\", md5_hash[i]);",
          "",
          "[Added Lines]",
          "643:       ndpi_MD5Init(&ctx);",
          "644:       ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));",
          "645:       ndpi_MD5Final(md5_hash, &ctx);",
          "649:         sizeof(flow->protos.stun_ssl.ssl.ja3_client)-j, \"%02x\",",
          "650:         md5_hash[i]);",
          "",
          "---------------"
        ],
        "src/lib/third_party/include/ndpi_md5.h||src/lib/third_party/include/ndpi_md5.h": [
          "File: src/lib/third_party/include/ndpi_md5.h -> src/lib/third_party/include/ndpi_md5.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:   Contributed code pasted here to make nDPI self-contained with no",
          "3:   external dependencies",
          "8: typedef struct ndpi_MD5Context {",
          "9:   uint32_t buf[4];",
          "10:   uint32_t bits[2];",
          "11:   unsigned char in[64];",
          "12: } ndpi_MD5_CTX;",
          "16: extern void ndpi_MD5Init(ndpi_MD5_CTX *ctx);",
          "17: extern void ndpi_MD5Update(ndpi_MD5_CTX *ctx, unsigned char const *buf, unsigned len);",
          "18: extern void ndpi_MD5Final(unsigned char digest[16], ndpi_MD5_CTX *ctx);",
          "",
          "---------------"
        ],
        "src/lib/third_party/src/ndpi_md5.c||src/lib/third_party/src/ndpi_md5.c": [
          "File: src/lib/third_party/src/ndpi_md5.c -> src/lib/third_party/src/ndpi_md5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:   Contributed code pasted here to make nDPI self-contained with no",
          "3:   external dependencies",
          "6: #include \"ndpi_api.h\"",
          "7: #include \"ndpi_md5.h\"",
          "11: static int is_big_endian(void) {",
          "12:   static const int n = 1;",
          "13:   return ((char *) &n)[0] == 0;",
          "14: }",
          "16: static void byte_reverse(unsigned char *buf, unsigned longs) {",
          "18:   if (is_big_endian()) {",
          "19:     do {",
          "20:       u_int32_t t;",
          "22:       t = (u_int32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "23:  ((unsigned) buf[1] << 8 | buf[0]);",
          "25:       buf += 4;",
          "26:     } while (--longs);",
          "27:   }",
          "28: }",
          "30: #define F1(x, y, z) (z ^ (x & (y ^ z)))",
          "31: #define F2(x, y, z) F1(z, x, y)",
          "32: #define F3(x, y, z) (x ^ y ^ z)",
          "33: #define F4(x, y, z) (y ^ (x | ~z))",
          "35: #define MD5STEP(f, w, x, y, z, data, s) \\",
          "36:   ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )",
          "42: void ndpi_MD5Init(ndpi_MD5_CTX *ctx) {",
          "43:   ctx->buf[0] = 0x67452301;",
          "44:   ctx->buf[1] = 0xefcdab89;",
          "45:   ctx->buf[2] = 0x98badcfe;",
          "46:   ctx->buf[3] = 0x10325476;",
          "48:   ctx->bits[0] = 0;",
          "49:   ctx->bits[1] = 0;",
          "50: }",
          "54: static void MD5Transform(u_int32_t buf[4], u_int32_t const in[16]) {",
          "55:   u_int32_t a, b, c, d;",
          "57:   a = buf[0];",
          "58:   b = buf[1];",
          "59:   c = buf[2];",
          "60:   d = buf[3];",
          "62:   MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);",
          "63:   MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);",
          "64:   MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);",
          "65:   MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);",
          "66:   MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);",
          "67:   MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);",
          "68:   MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);",
          "69:   MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);",
          "70:   MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);",
          "71:   MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);",
          "72:   MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);",
          "73:   MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);",
          "74:   MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);",
          "75:   MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);",
          "76:   MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);",
          "77:   MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);",
          "79:   MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);",
          "80:   MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);",
          "81:   MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);",
          "82:   MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);",
          "83:   MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);",
          "84:   MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);",
          "85:   MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);",
          "86:   MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);",
          "87:   MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);",
          "88:   MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);",
          "89:   MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);",
          "90:   MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);",
          "91:   MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);",
          "92:   MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);",
          "93:   MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);",
          "94:   MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);",
          "96:   MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);",
          "97:   MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);",
          "98:   MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);",
          "99:   MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);",
          "100:   MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);",
          "101:   MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);",
          "102:   MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);",
          "103:   MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);",
          "104:   MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);",
          "105:   MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);",
          "106:   MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);",
          "107:   MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);",
          "108:   MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);",
          "109:   MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);",
          "110:   MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);",
          "111:   MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);",
          "113:   MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);",
          "114:   MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);",
          "115:   MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);",
          "116:   MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);",
          "117:   MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);",
          "118:   MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);",
          "119:   MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);",
          "120:   MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);",
          "121:   MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);",
          "122:   MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);",
          "123:   MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);",
          "124:   MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);",
          "125:   MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);",
          "126:   MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);",
          "127:   MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);",
          "128:   MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);",
          "130:   buf[0] += a;",
          "131:   buf[1] += b;",
          "132:   buf[2] += c;",
          "133:   buf[3] += d;",
          "134: }",
          "138: void ndpi_MD5Update(ndpi_MD5_CTX *ctx, unsigned char const *buf, unsigned len) {",
          "139:   u_int32_t t;",
          "141:   t = ctx->bits[0];",
          "142:   if ((ctx->bits[0] = t + ((u_int32_t) len << 3)) < t)",
          "143:     ctx->bits[1]++;",
          "144:   ctx->bits[1] += len >> 29;",
          "146:   t = (t >> 3) & 0x3f;",
          "148:   if (t) {",
          "149:     unsigned char *p = (unsigned char *) ctx->in + t;",
          "151:     t = 64 - t;",
          "152:     if (len < t) {",
          "153:       memcpy(p, buf, len);",
          "154:       return;",
          "155:     }",
          "156:     memcpy(p, buf, t);",
          "157:     byte_reverse(ctx->in, 16);",
          "158:     MD5Transform(ctx->buf, (u_int32_t *) ctx->in);",
          "159:     buf += t;",
          "160:     len -= t;",
          "161:   }",
          "163:   while (len >= 64) {",
          "164:     memcpy(ctx->in, buf, 64);",
          "165:     byte_reverse(ctx->in, 16);",
          "166:     MD5Transform(ctx->buf, (u_int32_t *) ctx->in);",
          "167:     buf += 64;",
          "168:     len -= 64;",
          "169:   }",
          "171:   memcpy(ctx->in, buf, len);",
          "172: }",
          "176: void ndpi_MD5Final(unsigned char digest[16], ndpi_MD5_CTX *ctx) {",
          "177:   unsigned count;",
          "178:   unsigned char *p;",
          "179:   u_int32_t *c = (u_int32_t*)ctx->in;",
          "181:   count = (ctx->bits[0] >> 3) & 0x3F;",
          "183:   p = ctx->in + count;",
          "185:   count = 64 - 1 - count;",
          "186:   if (count < 8) {",
          "187:     memset(p, 0, count);",
          "188:     byte_reverse(ctx->in, 16);",
          "189:     MD5Transform(ctx->buf, (u_int32_t *) ctx->in);",
          "190:     memset(ctx->in, 0, 56);",
          "191:   } else {",
          "192:     memset(p, 0, count - 8);",
          "193:   }",
          "194:   byte_reverse(ctx->in, 14);",
          "196:   c[14] = ctx->bits[0];",
          "197:   c[15] = ctx->bits[1];",
          "199:   MD5Transform(ctx->buf, (u_int32_t *) ctx->in);",
          "200:   byte_reverse((unsigned char *) ctx->buf, 4);",
          "201:   memcpy(digest, ctx->buf, 16);",
          "202:   memset((char *) ctx, 0, sizeof(*ctx));",
          "203: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c120cca66272646c4277d71fa769d020b1026b28",
      "candidate_info": {
        "commit_hash": "c120cca66272646c4277d71fa769d020b1026b28",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/c120cca66272646c4277d71fa769d020b1026b28",
        "files": [
          "src/lib/protocols/ssh.c"
        ],
        "message": "SSH boundary check rework",
        "before_after_code_files": [
          "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ],
          "candidate": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c": [
          "File: src/lib/protocols/ssh.c -> src/lib/protocols/ssh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "96: static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,",
          "97:         char *buf, u_int8_t client_hash) {",
          "102:     goto invalid_payload;",
          "104:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "98:   u_int32_t offset = 22, buf_out_len = 0;",
          "99:   int len;",
          "101:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "",
          "[Added Lines]",
          "98:   u_int32_t offset = 22, len, buf_out_len = 0, max_payload_len = packet->payload_packet_len-sizeof(u_int32_t);",
          "99:   const u_int32_t len_max = 65565;",
          "101:   if(offset >= max_payload_len)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:   buf[buf_out_len++] = ';';",
          "114:   offset += len;",
          "117:     goto invalid_payload;",
          "120:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "123:     goto invalid_payload;",
          "124:   offset += 4 + len;",
          "127:     goto invalid_payload;",
          "",
          "[Removed Lines]",
          "116:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "122:   if(len > UINT32_MAX - 8 - offset)",
          "126:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "",
          "[Added Lines]",
          "116:   if(offset >= max_payload_len)",
          "122:   if(len > len_max)",
          "126:   if(offset >= max_payload_len)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "139:     buf[buf_out_len++] = ';';",
          "140:   }",
          "143:     goto invalid_payload;",
          "144:   offset += len;",
          "147:     goto invalid_payload;",
          "",
          "[Removed Lines]",
          "142:   if(len > UINT32_MAX - 4 - offset)",
          "146:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "",
          "[Added Lines]",
          "142:   if(len > len_max)",
          "146:   if(offset >= max_payload_len)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "159:     buf[buf_out_len++] = ';';",
          "160:   }",
          "163:     goto invalid_payload;",
          "164:   offset += len;",
          "167:     goto invalid_payload;",
          "169:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "162:   if(len > UINT32_MAX - 4 - offset)",
          "166:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "",
          "[Added Lines]",
          "162:   if(len > len_max)",
          "166:   if(offset >= max_payload_len)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "177:     buf_out_len += len;",
          "178:     buf[buf_out_len++] = ';';",
          "179:   }",
          "181:     goto invalid_payload;",
          "182:   offset += len;",
          "185:     goto invalid_payload;",
          "187:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "180:   if(len > UINT32_MAX - 4 - offset)",
          "184:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "",
          "[Added Lines]",
          "181:   if(len > len_max)",
          "185:   if(offset >= max_payload_len)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "196:     buf[buf_out_len++] = ';';",
          "197:   }",
          "200:     goto invalid_payload;",
          "201:   offset += len;",
          "205:     goto invalid_payload;",
          "206:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "208:   offset += 4;",
          "",
          "[Removed Lines]",
          "199:   if(len > UINT32_MAX - 4 - offset)",
          "204:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "",
          "[Added Lines]",
          "200:   if(len > len_max)",
          "205:   if(offset >= max_payload_len)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "214:     buf_out_len += len;",
          "215:   }",
          "218:     goto invalid_payload;",
          "219:   offset += len;",
          "222:     goto invalid_payload;",
          "224:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "",
          "[Removed Lines]",
          "217:   if(len > UINT32_MAX - 4 - offset)",
          "221:   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)",
          "",
          "[Added Lines]",
          "219:   if(len > len_max)",
          "223:   if(offset >= max_payload_len)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "232:     buf_out_len += len;",
          "233:   }",
          "236:     goto invalid_payload;",
          "237:   offset += len;",
          "",
          "[Removed Lines]",
          "235:   if(len > UINT32_MAX - offset)",
          "",
          "[Added Lines]",
          "237:   if(len > len_max)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a70fd6ed3b33d9e2c89fe35c96102c156d39f1f9",
      "candidate_info": {
        "commit_hash": "a70fd6ed3b33d9e2c89fe35c96102c156d39f1f9",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/a70fd6ed3b33d9e2c89fe35c96102c156d39f1f9",
        "files": [
          "src/lib/protocols/ssh.c"
        ],
        "message": "Better fix for integer overflow in SSH\n\nCredits to GHSL",
        "before_after_code_files": [
          "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ],
          "candidate": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c": [
          "File: src/lib/protocols/ssh.c -> src/lib/protocols/ssh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:     goto invalid_payload;",
          "116:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "118:     goto invalid_payload;",
          "119:   offset += 4 + len;",
          "",
          "[Removed Lines]",
          "117:   if (len > UINT32_MAX - 4 - offset)",
          "",
          "[Added Lines]",
          "117:   if (len > UINT32_MAX - 8 - offset)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "132:     buf_out_len += len;",
          "133:     buf[buf_out_len++] = ';';",
          "134:   }",
          "136:     goto invalid_payload;",
          "137:   offset += len;",
          "",
          "[Removed Lines]",
          "135:   if (len > UINT32_MAX - offset)",
          "",
          "[Added Lines]",
          "135:   if (len > UINT32_MAX - 4 - offset)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:     buf_out_len += len;",
          "151:     buf[buf_out_len++] = ';';",
          "152:   }",
          "154:     goto invalid_payload;",
          "155:   offset += len;",
          "",
          "[Removed Lines]",
          "153:   if (len > UINT32_MAX - offset)",
          "",
          "[Added Lines]",
          "153:   if (len > UINT32_MAX - 4 - offset)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168:     buf_out_len += len;",
          "169:     buf[buf_out_len++] = ';';",
          "170:   }",
          "172:     goto invalid_payload;",
          "173:   offset += len;",
          "",
          "[Removed Lines]",
          "171:   if (len > UINT32_MAX - offset)",
          "",
          "[Added Lines]",
          "171:   if (len > UINT32_MAX - 4 - offset)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "186:     buf_out_len += len;",
          "187:     buf[buf_out_len++] = ';';",
          "188:   }",
          "190:     goto invalid_payload;",
          "191:   offset += len;",
          "",
          "[Removed Lines]",
          "189:   if (len > UINT32_MAX - offset)",
          "",
          "[Added Lines]",
          "189:   if (len > UINT32_MAX - 4 - offset)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "203:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "204:     buf_out_len += len;",
          "205:   }",
          "207:     goto invalid_payload;",
          "208:   offset += len;",
          "",
          "[Removed Lines]",
          "206:   if (len > UINT32_MAX - offset)",
          "",
          "[Added Lines]",
          "206:   if (len > UINT32_MAX - 4 - offset)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1231b8183978fd9f2a64ffd1d3f8069f7774f435",
      "candidate_info": {
        "commit_hash": "1231b8183978fd9f2a64ffd1d3f8069f7774f435",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/1231b8183978fd9f2a64ffd1d3f8069f7774f435",
        "files": [
          "src/lib/protocols/ssh.c"
        ],
        "message": "Add more length checks in HASSH\n\nThis to prevent possible crashes on invalid packets",
        "before_after_code_files": [
          "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ],
          "candidate": [
            "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/protocols/ssh.c||src/lib/protocols/ssh.c": [
          "File: src/lib/protocols/ssh.c -> src/lib/protocols/ssh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:        char *buf, u_int8_t client_hash) {",
          "65:   u_int16_t offset = 22, buf_out_len = 0;",
          "66:   u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "70:     offset += 4;",
          "72:     buf[buf_out_len++] = ';';",
          "73:     offset += len;",
          "77:     offset += 4 + len;",
          "149: #ifdef SSH_DEBUG",
          "150:   printf(\"\\n[SSH] %s\\n\", buf);",
          "151: #endif",
          "153:   return(buf_out_len);",
          "154: }",
          "",
          "[Removed Lines]",
          "68:   if(len < (packet->payload_packet_len-offset)) {",
          "71:     strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);",
          "76:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "80:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "82:     if(client_hash) {",
          "83:       offset += 4;",
          "84:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "85:       buf_out_len += len;",
          "86:       buf[buf_out_len++] = ';';",
          "87:       offset += len;",
          "88:     } else",
          "89:       offset += 4 + len;",
          "92:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "93:     if(!client_hash) {",
          "94:       offset += 4;",
          "95:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "96:       buf_out_len += len;",
          "97:       buf[buf_out_len++] = ';';",
          "98:       offset += len;",
          "99:     } else",
          "100:       offset += 4 + len;",
          "103:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "104:     if(client_hash) {",
          "105:       offset += 4;",
          "106:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "107:       buf_out_len += len;",
          "108:       buf[buf_out_len++] = ';';",
          "109:       offset += len;",
          "110:     } else",
          "111:       offset += 4 + len;",
          "114:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "115:     if(!client_hash) {",
          "116:       offset += 4;",
          "117:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "118:       buf_out_len += len;",
          "119:       buf[buf_out_len++] = ';';",
          "120:       offset += len;",
          "121:     } else",
          "122:       offset += 4 + len;",
          "125:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "126:     if(client_hash) {",
          "127:       offset += 4;",
          "128:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "129:       buf_out_len += len;",
          "130:       offset += len;",
          "131:     } else",
          "132:       offset += 4 + len;",
          "135:     len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "136:     if(!client_hash) {",
          "137:       offset += 4;",
          "138:       strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "139:       buf_out_len += len;",
          "140:       offset += len;",
          "141:     } else",
          "142:       offset += 4 + len;",
          "147:   }",
          "",
          "[Added Lines]",
          "67:   offset += 4;",
          "70:   if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
          "71:     goto invalid_payload;",
          "74:   strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);",
          "75:   buf[buf_out_len++] = ';';",
          "76:   offset += len;",
          "79:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "80:   offset += 4 + len;",
          "83:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "85:   if(client_hash) {",
          "88:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
          "89:       goto invalid_payload;",
          "91:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "92:     buf_out_len += len;",
          "95:   } else",
          "96:     offset += 4 + len;",
          "99:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "101:   if(!client_hash) {",
          "102:     offset += 4;",
          "104:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
          "105:       goto invalid_payload;",
          "107:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "108:     buf_out_len += len;",
          "109:     buf[buf_out_len++] = ';';",
          "110:     offset += len;",
          "111:   } else",
          "115:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "117:   if(client_hash) {",
          "118:     offset += 4;",
          "120:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
          "121:       goto invalid_payload;",
          "123:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "124:     buf_out_len += len;",
          "125:     buf[buf_out_len++] = ';';",
          "126:     offset += len;",
          "127:   } else",
          "128:     offset += 4 + len;",
          "131:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "133:   if(!client_hash) {",
          "134:     offset += 4;",
          "136:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
          "137:       goto invalid_payload;",
          "139:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "140:     buf_out_len += len;",
          "141:     buf[buf_out_len++] = ';';",
          "142:     offset += len;",
          "143:   } else",
          "144:     offset += 4 + len;",
          "147:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "149:   if(client_hash) {",
          "150:     offset += 4;",
          "152:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
          "153:       goto invalid_payload;",
          "155:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "156:     buf_out_len += len;",
          "157:     offset += len;",
          "158:   } else",
          "159:     offset += 4 + len;",
          "162:   len = ntohl(*(u_int32_t*)&packet->payload[offset]);",
          "164:   if(!client_hash) {",
          "165:     offset += 4;",
          "167:     if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))",
          "168:       goto invalid_payload;",
          "170:     strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);",
          "171:     buf_out_len += len;",
          "172:     offset += len;",
          "173:   } else",
          "174:     offset += 4 + len;",
          "186: invalid_payload:",
          "188: #ifdef SSH_DEBUG",
          "189:   printf(\"\\n[SSH] Invalid packet payload\\n\");",
          "190: #endif",
          "192:   return(0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
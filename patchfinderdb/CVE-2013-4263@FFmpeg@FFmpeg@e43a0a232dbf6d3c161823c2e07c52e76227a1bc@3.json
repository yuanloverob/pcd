{
  "cve_id": "CVE-2013-4263",
  "cve_desc": "libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted \"plane,\" which triggers an out-of-bounds heap write.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
  "patch_info": {
    "commit_hash": "e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
    "files": [
      "libavfilter/vf_boxblur.c",
      "libavfilter/vf_delogo.c",
      "libavfilter/vf_fieldmatch.c",
      "libavfilter/vf_fieldorder.c",
      "libavfilter/vf_gradfun.c",
      "libavfilter/vf_hflip.c",
      "libavfilter/vf_kerndeint.c",
      "libavfilter/vf_lut.c",
      "libavfilter/vf_pad.c",
      "libavfilter/vf_showinfo.c",
      "libavfilter/vf_vignette.c"
    ],
    "message": "avfilter: fix plane validity checks\n\nFixes out of array accesses\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c",
      "libavfilter/vf_delogo.c||libavfilter/vf_delogo.c",
      "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c",
      "libavfilter/vf_fieldorder.c||libavfilter/vf_fieldorder.c",
      "libavfilter/vf_gradfun.c||libavfilter/vf_gradfun.c",
      "libavfilter/vf_hflip.c||libavfilter/vf_hflip.c",
      "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c",
      "libavfilter/vf_lut.c||libavfilter/vf_lut.c",
      "libavfilter/vf_pad.c||libavfilter/vf_pad.c",
      "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c",
      "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c"
    ]
  },
  "patch_diff": {
    "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c": [
      "File: libavfilter/vf_boxblur.c -> libavfilter/vf_boxblur.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "313:     }",
      "314:     av_frame_copy_props(out, in);",
      "317:         hblur(out->data[plane], out->linesize[plane],",
      "318:               in ->data[plane], in ->linesize[plane],",
      "319:               w[plane], h[plane], s->radius[plane], s->power[plane],",
      "320:               s->temp);",
      "323:         vblur(out->data[plane], out->linesize[plane],",
      "324:               out->data[plane], out->linesize[plane],",
      "325:               w[plane], h[plane], s->radius[plane], s->power[plane],",
      "",
      "[Removed Lines]",
      "316:     for (plane = 0; in->data[plane] && plane < 4; plane++)",
      "322:     for (plane = 0; in->data[plane] && plane < 4; plane++)",
      "",
      "[Added Lines]",
      "316:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)",
      "322:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)",
      "",
      "---------------"
    ],
    "libavfilter/vf_delogo.c||libavfilter/vf_delogo.c": [
      "File: libavfilter/vf_delogo.c -> libavfilter/vf_delogo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "237:     if (!sar.num)",
      "238:         sar.num = sar.den = 1;",
      "241:         int hsub = plane == 1 || plane == 2 ? hsub0 : 0;",
      "242:         int vsub = plane == 1 || plane == 2 ? vsub0 : 0;",
      "",
      "[Removed Lines]",
      "240:     for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "240:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c": [
      "File: libavfilter/vf_fieldmatch.c -> libavfilter/vf_fieldmatch.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "608:                         const AVFrame *src, int field)",
      "609: {",
      "610:     int plane;",
      "612:         av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,",
      "613:                             src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,",
      "614:                             get_width(fm, src, plane), get_height(fm, src, plane) / 2);",
      "",
      "[Removed Lines]",
      "611:     for (plane = 0; plane < 4 && src->data[plane]; plane++)",
      "",
      "[Added Lines]",
      "611:     for (plane = 0; plane < 4 && src->data[plane] && src->linesize[plane]; plane++)",
      "",
      "---------------"
    ],
    "libavfilter/vf_fieldorder.c||libavfilter/vf_fieldorder.c": [
      "File: libavfilter/vf_fieldorder.c -> libavfilter/vf_fieldorder.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "106:             \"picture will move %s one line\\n\",",
      "107:             s->dst_tff ? \"up\" : \"down\");",
      "108:     h = frame->height;",
      "110:         line_step = frame->linesize[plane];",
      "111:         line_size = s->line_size[plane];",
      "112:         data = frame->data[plane];",
      "",
      "[Removed Lines]",
      "109:     for (plane = 0; plane < 4 && frame->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "109:     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_gradfun.c||libavfilter/vf_gradfun.c": [
      "File: libavfilter/vf_gradfun.c -> libavfilter/vf_gradfun.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "199:         av_frame_copy_props(out, in);",
      "200:     }",
      "203:         int w = inlink->w;",
      "204:         int h = inlink->h;",
      "205:         int r = s->radius;",
      "",
      "[Removed Lines]",
      "202:     for (p = 0; p < 4 && in->data[p]; p++) {",
      "",
      "[Added Lines]",
      "202:     for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_hflip.c||libavfilter/vf_hflip.c": [
      "File: libavfilter/vf_hflip.c -> libavfilter/vf_hflip.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "90:     if (av_pix_fmt_desc_get(inlink->format)->flags & AV_PIX_FMT_FLAG_PAL)",
      "91:         memcpy(out->data[1], in->data[1], AVPALETTE_SIZE);",
      "94:         const int width  = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->w, s->hsub) : inlink->w;",
      "95:         const int height = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->h, s->vsub) : inlink->h;",
      "96:         step = s->max_step[plane];",
      "",
      "[Removed Lines]",
      "93:     for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "93:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c": [
      "File: libavfilter/vf_kerndeint.c -> libavfilter/vf_kerndeint.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:     av_frame_copy_props(outpic, inpic);",
      "151:     outpic->interlaced_frame = 0;",
      "154:         h = plane == 0 ? inlink->h : FF_CEIL_RSHIFT(inlink->h, kerndeint->vsub);",
      "155:         bwidth = kerndeint->tmp_bwidth[plane];",
      "",
      "[Removed Lines]",
      "153:     for (plane = 0; inpic->data[plane] && plane < 4; plane++) {",
      "",
      "[Added Lines]",
      "153:     for (plane = 0; plane < 4 && inpic->data[plane] && inpic->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_lut.c||libavfilter/vf_lut.c": [
      "File: libavfilter/vf_lut.c -> libavfilter/vf_lut.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "304:         }",
      "305:     } else {",
      "308:             int vsub = plane == 1 || plane == 2 ? s->vsub : 0;",
      "309:             int hsub = plane == 1 || plane == 2 ? s->hsub : 0;",
      "310:             int h = FF_CEIL_RSHIFT(inlink->h, vsub);",
      "",
      "[Removed Lines]",
      "307:         for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "307:         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_pad.c||libavfilter/vf_pad.c": [
      "File: libavfilter/vf_pad.c -> libavfilter/vf_pad.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "214:     frame->width  = w;",
      "215:     frame->height = h;",
      "218:         int hsub = s->draw.hsub[plane];",
      "219:         int vsub = s->draw.vsub[plane];",
      "220:         frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +",
      "",
      "[Removed Lines]",
      "217:     for (plane = 0; plane < 4 && frame->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "217:     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "311:         int i;",
      "313:         out = in;",
      "315:             int hsub = s->draw.hsub[i];",
      "316:             int vsub = s->draw.vsub[i];",
      "317:             out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +",
      "",
      "[Removed Lines]",
      "314:         for (i = 0; i < 4 && out->data[i]; i++) {",
      "",
      "[Added Lines]",
      "314:         for (i = 0; i < 4 && out->data[i] && out->linesize[i]; i++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c": [
      "File: libavfilter/vf_showinfo.c -> libavfilter/vf_showinfo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38:     uint32_t plane_checksum[4] = {0}, checksum = 0;",
      "39:     int i, plane, vsub = desc->log2_chroma_h;",
      "42:         int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);",
      "43:         uint8_t *data = frame->data[plane];",
      "44:         int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;",
      "",
      "[Removed Lines]",
      "41:     for (plane = 0; plane < 4 && frame->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "41:     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "68:            av_get_picture_type_char(frame->pict_type),",
      "69:            checksum, plane_checksum[0]);",
      "72:         av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);",
      "73:     av_log(ctx, AV_LOG_INFO, \"]\\n\");",
      "",
      "[Removed Lines]",
      "71:     for (plane = 1; plane < 4 && frame->data[plane]; plane++)",
      "",
      "[Added Lines]",
      "71:     for (plane = 1; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)",
      "",
      "---------------"
    ],
    "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c": [
      "File: libavfilter/vf_vignette.c -> libavfilter/vf_vignette.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "239:     } else {",
      "240:         int plane;",
      "243:             uint8_t       *dst = out->data[plane];",
      "244:             const uint8_t *src = in ->data[plane];",
      "245:             const float *fmap = s->fmap;",
      "",
      "[Removed Lines]",
      "242:         for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "242:         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1e6408a18ef4ca794d39ce3839c60ab1cf7dc925",
      "candidate_info": {
        "commit_hash": "1e6408a18ef4ca794d39ce3839c60ab1cf7dc925",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/1e6408a18ef4ca794d39ce3839c60ab1cf7dc925",
        "files": [
          "libavfilter/vf_showinfo.c"
        ],
        "message": "lavfi/showinfo: only print checksum for the existing planes\n\nMake the output a bit nicer.",
        "before_after_code_files": [
          "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
          ],
          "candidate": [
            "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c": [
          "File: libavfilter/vf_showinfo.c -> libavfilter/vf_showinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:     av_log(ctx, AV_LOG_INFO,",
          "63:            \"n:%d pts:%s pts_time:%s pos:%\"PRId64\" \"",
          "64:            \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"",
          "66:            showinfo->frame,",
          "67:            av_ts2str(picref->pts), av_ts2timestr(picref->pts, &inlink->time_base), picref->pos,",
          "68:            av_pix_fmt_descriptors[picref->format].name,",
          "",
          "[Removed Lines]",
          "65:            \"checksum:%08X plane_checksum:[%08X %08X %08X %08X]\\n\",",
          "",
          "[Added Lines]",
          "65:            \"checksum:%08X plane_checksum:[%08X\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:            picref->video->key_frame,",
          "74:            av_get_picture_type_char(picref->video->pict_type),",
          "77:     showinfo->frame++;",
          "78:     avfilter_end_frame(inlink->dst->outputs[0]);",
          "",
          "[Removed Lines]",
          "75:            checksum, plane_checksum[0], plane_checksum[1], plane_checksum[2], plane_checksum[3]);",
          "",
          "[Added Lines]",
          "75:            checksum, plane_checksum[0]);",
          "77:     for (plane = 1; picref->data[plane] && plane < 4; plane++)",
          "78:         av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);",
          "79:     av_log(ctx, AV_LOG_INFO, \"]\\n\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a05d02079e0fde1ff9b6abfda79ff20b38f68439",
      "candidate_info": {
        "commit_hash": "a05d02079e0fde1ff9b6abfda79ff20b38f68439",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/a05d02079e0fde1ff9b6abfda79ff20b38f68439",
        "files": [
          "doc/filters.texi",
          "libavfilter/vf_showinfo.c"
        ],
        "message": "showinfo: replace \"CRC\" by \"checksum\"\n\nIndeed the Adler-32 checksum, which is computed by showinfo, is not\ncyclic, so using the term \"CRC\" is wrong/confusing.",
        "before_after_code_files": [
          "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
          ],
          "candidate": [
            "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c": [
          "File: libavfilter/vf_showinfo.c -> libavfilter/vf_showinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     AVFilterContext *ctx = inlink->dst;",
          "44:     ShowInfoContext *showinfo = ctx->priv;",
          "45:     AVFilterBufferRef *picref = inlink->cur_buf;",
          "47:     int i, plane, vsub = av_pix_fmt_descriptors[inlink->format].log2_chroma_h;",
          "49:     for (plane = 0; picref->data[plane] && plane < 4; plane++) {",
          "",
          "[Removed Lines]",
          "46:     uint32_t plane_crc[4] = {0}, crc = 0;",
          "",
          "[Added Lines]",
          "46:     uint32_t plane_checksum[4] = {0}, checksum = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:         int h = plane == 1 || plane == 2 ? inlink->h >> vsub : inlink->h;",
          "54:         for (i = 0; i < h; i++) {",
          "57:             data += picref->linesize[plane];",
          "58:         }",
          "59:     }",
          "",
          "[Removed Lines]",
          "55:             plane_crc[plane] = av_adler32_update(plane_crc[plane], data, linesize);",
          "56:             crc = av_adler32_update(crc, data, linesize);",
          "",
          "[Added Lines]",
          "55:             plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);",
          "56:             checksum = av_adler32_update(checksum, data, linesize);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:     av_log(ctx, AV_LOG_INFO,",
          "62:            \"n:%d pts:%\"PRId64\" pts_time:%f pos:%\"PRId64\" \"",
          "63:            \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"",
          "65:            showinfo->frame,",
          "66:            picref->pts, picref ->pts * av_q2d(inlink->time_base), picref->pos,",
          "67:            av_pix_fmt_descriptors[picref->format].name,",
          "",
          "[Removed Lines]",
          "64:            \"crc:%u plane_crc:[%u %u %u %u]\\n\",",
          "",
          "[Added Lines]",
          "64:            \"checksum:%u plane_checksum:[%u %u %u %u]\\n\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "72:            picref->video->key_frame,",
          "73:            av_get_picture_type_char(picref->video->pict_type),",
          "76:     showinfo->frame++;",
          "77:     avfilter_end_frame(inlink->dst->outputs[0]);",
          "",
          "[Removed Lines]",
          "74:            crc, plane_crc[0], plane_crc[1], plane_crc[2], plane_crc[3]);",
          "",
          "[Added Lines]",
          "74:            checksum, plane_checksum[0], plane_checksum[1], plane_checksum[2], plane_checksum[3]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "250b122e3ab12baeef4fb65c4d76df4fc506b899",
      "candidate_info": {
        "commit_hash": "250b122e3ab12baeef4fb65c4d76df4fc506b899",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/250b122e3ab12baeef4fb65c4d76df4fc506b899",
        "files": [
          "libavfilter/vf_boxblur.c"
        ],
        "message": "vf_boxblur: switch to filter_frame, boxblur did not support slices\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c"
          ],
          "candidate": [
            "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c": [
          "File: libavfilter/vf_boxblur.c -> libavfilter/vf_boxblur.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "302:                    h, radius, power, temp);",
          "303: }",
          "308: {",
          "309:     AVFilterContext *ctx = inlink->dst;",
          "310:     BoxBlurContext *boxblur = ctx->priv;",
          "311:     AVFilterLink *outlink = inlink->dst->outputs[0];",
          "314:     int plane;",
          "316:     int w[4] = { inlink->w, cw, cw, inlink->w };",
          "322:               w[plane], h[plane], boxblur->radius[plane], boxblur->power[plane],",
          "323:               boxblur->temp);",
          "328:               w[plane], h[plane], boxblur->radius[plane], boxblur->power[plane],",
          "329:               boxblur->temp);",
          "333: }",
          "335: static const AVFilterPad avfilter_vf_boxblur_inputs[] = {",
          "",
          "[Removed Lines]",
          "305: static int null_draw_slice(AVFilterLink *inlink, int y, int h, int slice_dir) { return 0; }",
          "307: static int end_frame(AVFilterLink *inlink)",
          "312:     AVFilterBufferRef *inpicref  = inlink ->cur_buf;",
          "313:     AVFilterBufferRef *outpicref = outlink->out_buf;",
          "315:     int cw = inlink->w >> boxblur->hsub, ch = inlink->h >> boxblur->vsub;",
          "317:     int h[4] = { inlink->h, ch, ch, inlink->h };",
          "319:     for (plane = 0; inpicref->data[plane] && plane < 4; plane++)",
          "320:         hblur(outpicref->data[plane], outpicref->linesize[plane],",
          "321:               inpicref ->data[plane], inpicref ->linesize[plane],",
          "325:     for (plane = 0; inpicref->data[plane] && plane < 4; plane++)",
          "326:         vblur(outpicref->data[plane], outpicref->linesize[plane],",
          "327:               outpicref->data[plane], outpicref->linesize[plane],",
          "331:     ff_draw_slice(outlink, 0, inlink->h, 1);",
          "332:     return ff_end_frame(outlink);",
          "",
          "[Added Lines]",
          "305: static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in)",
          "310:     AVFilterBufferRef *out;",
          "312:     int cw = inlink->w >> boxblur->hsub, ch = in->video->h >> boxblur->vsub;",
          "314:     int h[4] = { in->video->h, ch, ch, in->video->h };",
          "316:     out = ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);",
          "317:     if (!out) {",
          "318:         avfilter_unref_bufferp(&in);",
          "319:         return AVERROR(ENOMEM);",
          "320:     }",
          "321:     avfilter_copy_buffer_ref_props(out, in);",
          "323:     for (plane = 0; in->data[plane] && plane < 4; plane++)",
          "324:         hblur(out->data[plane], out->linesize[plane],",
          "325:               in ->data[plane], in ->linesize[plane],",
          "329:     for (plane = 0; in->data[plane] && plane < 4; plane++)",
          "330:         vblur(out->data[plane], out->linesize[plane],",
          "331:               out->data[plane], out->linesize[plane],",
          "335:     avfilter_unref_bufferp(&in);",
          "337:     return ff_filter_frame(outlink, out);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "337:         .name         = \"default\",",
          "338:         .type         = AVMEDIA_TYPE_VIDEO,",
          "339:         .config_props = config_input,",
          "342:         .min_perms    = AV_PERM_READ",
          "343:     },",
          "344:     { NULL }",
          "",
          "[Removed Lines]",
          "340:         .draw_slice   = null_draw_slice,",
          "341:         .end_frame    = end_frame,",
          "",
          "[Added Lines]",
          "345:         .filter_frame = filter_frame,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6b61920ab76dc6d85ef462909951923935dd643f",
      "candidate_info": {
        "commit_hash": "6b61920ab76dc6d85ef462909951923935dd643f",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/6b61920ab76dc6d85ef462909951923935dd643f",
        "files": [
          "Changelog",
          "configure",
          "doc/filters.texi",
          "libavfilter/Makefile",
          "libavfilter/allfilters.c",
          "libavfilter/avfilter.h",
          "libavfilter/vf_boxblur.c"
        ],
        "message": "lavfi: port boxblur filter from libmpcodecs\n\nWith the following additions:\n* support to gray format\n* support to yuva420p format\n* parametric luma/chroma/alpha radius\n* consistency check on the radius values, avoid crashes with invalid values",
        "before_after_code_files": [
          "libavfilter/allfilters.c||libavfilter/allfilters.c",
          "libavfilter/avfilter.h||libavfilter/avfilter.h",
          "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c"
          ],
          "candidate": [
            "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/allfilters.c||libavfilter/allfilters.c": [
          "File: libavfilter/allfilters.c -> libavfilter/allfilters.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:     REGISTER_FILTER (ANULLSINK,   anullsink,   asink);",
          "43:     REGISTER_FILTER (BLACKFRAME,  blackframe,  vf);",
          "44:     REGISTER_FILTER (COPY,        copy,        vf);",
          "45:     REGISTER_FILTER (CROP,        crop,        vf);",
          "46:     REGISTER_FILTER (CROPDETECT,  cropdetect,  vf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44:     REGISTER_FILTER (BOXBLUR,     boxblur,     vf);",
          "",
          "---------------"
        ],
        "libavfilter/avfilter.h||libavfilter/avfilter.h": [
          "File: libavfilter/avfilter.h -> libavfilter/avfilter.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"libavutil/rational.h\"",
          "31: #define LIBAVFILTER_VERSION_MAJOR  2",
          "35: #define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \\",
          "36:                                                LIBAVFILTER_VERSION_MINOR, \\",
          "",
          "[Removed Lines]",
          "32: #define LIBAVFILTER_VERSION_MINOR 24",
          "33: #define LIBAVFILTER_VERSION_MICRO  4",
          "",
          "[Added Lines]",
          "32: #define LIBAVFILTER_VERSION_MINOR 25",
          "33: #define LIBAVFILTER_VERSION_MICRO  0",
          "",
          "---------------"
        ],
        "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c": [
          "File: libavfilter/vf_boxblur.c -> libavfilter/vf_boxblur.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/avstring.h\"",
          "29: #include \"libavutil/eval.h\"",
          "30: #include \"libavutil/pixdesc.h\"",
          "31: #include \"avfilter.h\"",
          "33: static const char *var_names[] = {",
          "34:     \"w\",",
          "35:     \"h\",",
          "36:     \"cw\",",
          "37:     \"ch\",",
          "38:     \"hsub\",",
          "39:     \"vsub\",",
          "40:     NULL",
          "41: };",
          "43: enum var_name {",
          "44:     VAR_W,",
          "45:     VAR_H,",
          "46:     VAR_CW,",
          "47:     VAR_CH,",
          "48:     VAR_HSUB,",
          "49:     VAR_VSUB,",
          "50:     VARS_NB",
          "51: };",
          "53: typedef struct {",
          "54:     int radius;",
          "55:     int power;",
          "56: } FilterParam;",
          "58: typedef struct {",
          "59:     FilterParam luma_param;",
          "60:     FilterParam chroma_param;",
          "61:     FilterParam alpha_param;",
          "62:     char luma_radius_expr  [256];",
          "63:     char chroma_radius_expr[256];",
          "64:     char alpha_radius_expr [256];",
          "66:     int hsub, vsub;",
          "67:     int radius[4];",
          "68:     int power[4];",
          "69:     uint8_t *temp[2]; ///< temporary buffer used in blur_power()",
          "70: } BoxBlurContext;",
          "72: #define Y 0",
          "73: #define U 1",
          "74: #define V 2",
          "75: #define A 3",
          "77: static av_cold int init(AVFilterContext *ctx, const char *args, void *opaque)",
          "78: {",
          "79:     BoxBlurContext *boxblur = ctx->priv;",
          "80:     int e;",
          "82:     if (!args) {",
          "83:         av_log(ctx, AV_LOG_ERROR,",
          "84:                \"Filter expects 2 or 4 arguments, none provided\\n\");",
          "85:         return AVERROR(EINVAL);",
          "86:     }",
          "88:     e = sscanf(args, \"%255[^:]:%d:%255[^:]:%d:%255[^:]:%d\",",
          "89:                boxblur->luma_radius_expr,   &boxblur->luma_param  .power,",
          "90:                boxblur->chroma_radius_expr, &boxblur->chroma_param.power,",
          "91:                boxblur->alpha_radius_expr,  &boxblur->alpha_param .power);",
          "93:     if (e != 2 && e != 4 && e != 6) {",
          "94:         av_log(ctx, AV_LOG_ERROR,",
          "95:                \"Filter expects 2 or 4 or 6 params, provided %d\\n\", e);",
          "96:         return AVERROR(EINVAL);",
          "97:     }",
          "99:     if (e < 4) {",
          "100:         boxblur->chroma_param.power = boxblur->luma_param.power;",
          "101:         av_strlcpy(boxblur->chroma_radius_expr, boxblur->luma_radius_expr,",
          "102:                    sizeof(boxblur->chroma_radius_expr));",
          "103:     }",
          "104:     if (e < 6) {",
          "105:         boxblur->alpha_param.power = boxblur->luma_param.power;",
          "106:         av_strlcpy(boxblur->alpha_radius_expr, boxblur->luma_radius_expr,",
          "107:                    sizeof(boxblur->alpha_radius_expr));",
          "108:     }",
          "110:     return 0;",
          "111: }",
          "113: static av_cold void uninit(AVFilterContext *ctx)",
          "114: {",
          "115:     BoxBlurContext *boxblur = ctx->priv;",
          "117:     av_freep(&boxblur->temp[0]);",
          "118:     av_freep(&boxblur->temp[1]);",
          "119: }",
          "121: static int query_formats(AVFilterContext *ctx)",
          "122: {",
          "123:     enum PixelFormat pix_fmts[] = {",
          "124:         PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,",
          "125:         PIX_FMT_YUV411P,  PIX_FMT_YUV410P,  PIX_FMT_YUVA420P,",
          "126:         PIX_FMT_YUV440P,  PIX_FMT_GRAY8,",
          "127:         PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,",
          "128:         PIX_FMT_YUVJ440P,",
          "129:         PIX_FMT_NONE",
          "130:     };",
          "132:     avfilter_set_common_pixel_formats(ctx, avfilter_make_format_list(pix_fmts));",
          "133:     return 0;",
          "134: }",
          "136: static int config_input(AVFilterLink *inlink)",
          "137: {",
          "138:     AVFilterContext *ctx = inlink->dst;",
          "139:     BoxBlurContext *boxblur = ctx->priv;",
          "140:     const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];",
          "141:     int w = inlink->w, h = inlink->h;",
          "142:     int cw, ch;",
          "143:     double var_values[VARS_NB], res;",
          "144:     char *expr;",
          "145:     int ret;",
          "147:     if (!(boxblur->temp[0] = av_malloc(w)) ||",
          "148:         !(boxblur->temp[1] = av_malloc(w)))",
          "149:         return AVERROR(ENOMEM);",
          "151:     boxblur->hsub = desc->log2_chroma_w;",
          "152:     boxblur->vsub = desc->log2_chroma_h;",
          "154:     var_values[VAR_W]  = inlink->w;",
          "155:     var_values[VAR_H]  = inlink->h;",
          "156:     var_values[VAR_CW] = cw = w>>boxblur->hsub;",
          "157:     var_values[VAR_CH] = ch = h>>boxblur->vsub;",
          "158:     var_values[VAR_HSUB] = 1<<boxblur->hsub;",
          "159:     var_values[VAR_VSUB] = 1<<boxblur->vsub;",
          "161: #define EVAL_RADIUS_EXPR(comp)                                          \\",
          "162:     expr = boxblur->comp##_radius_expr;                                 \\",
          "163:     ret = av_expr_parse_and_eval(&res, expr, var_names, var_values,     \\",
          "164:                                  NULL, NULL, NULL, NULL, NULL, 0, ctx); \\",
          "165:     boxblur->comp##_param.radius = res;                                 \\",
          "166:     if (ret < 0) {                                                      \\",
          "167:         av_log(NULL, AV_LOG_ERROR,                                      \\",
          "168:                \"Error when evaluating \" #comp \" radius expression '%s'\\n\", expr); \\",
          "169:         return ret;                                                     \\",
          "170:     }",
          "171:     EVAL_RADIUS_EXPR(luma);",
          "172:     EVAL_RADIUS_EXPR(chroma);",
          "173:     EVAL_RADIUS_EXPR(alpha);",
          "175:     av_log(ctx, AV_LOG_INFO,",
          "176:            \"luma_radius:%d luma_power:%d \"",
          "177:            \"chroma_radius:%d chroma_power:%d \"",
          "178:            \"alpha_radius:%d alpha_power:%d \"",
          "179:            \"w:%d chroma_w:%d h:%d chroma_h:%d\\n\",",
          "180:            boxblur->luma_param  .radius, boxblur->luma_param  .power,",
          "181:            boxblur->chroma_param.radius, boxblur->chroma_param.power,",
          "182:            boxblur->alpha_param .radius, boxblur->alpha_param .power,",
          "183:            w, cw, h, ch);",
          "185: #define CHECK_RADIUS_VAL(w_, h_, comp)                                  \\",
          "186:     if (boxblur->comp##_param.radius < 0 ||                             \\",
          "187:         2*boxblur->comp##_param.radius > FFMIN(w_, h_)) {               \\",
          "188:         av_log(ctx, AV_LOG_ERROR,                                       \\",
          "189:                \"Invalid \" #comp \" radius value %d, must be >= 0 and <= %d\\n\", \\",
          "190:                boxblur->comp##_param.radius, FFMIN(w_, h_)/2);          \\",
          "191:         return AVERROR(EINVAL);                                         \\",
          "192:     }",
          "193:     CHECK_RADIUS_VAL(w,  h,  luma);",
          "194:     CHECK_RADIUS_VAL(cw, ch, chroma);",
          "195:     CHECK_RADIUS_VAL(w,  h,  alpha);",
          "197:     boxblur->radius[Y] = boxblur->luma_param.radius;",
          "198:     boxblur->radius[U] = boxblur->radius[V] = boxblur->chroma_param.radius;",
          "199:     boxblur->radius[A] = boxblur->alpha_param.radius;",
          "201:     boxblur->power[Y] = boxblur->luma_param.power;",
          "202:     boxblur->power[U] = boxblur->power[V] = boxblur->chroma_param.power;",
          "203:     boxblur->power[A] = boxblur->alpha_param.power;",
          "205:     return 0;",
          "206: }",
          "208: static inline void blur(uint8_t *dst, int dst_step, const uint8_t *src, int src_step,",
          "209:                         int w, int radius)",
          "210: {",
          "225:     int x, sum = 0;",
          "226:     const int length = radius*2 + 1;",
          "227:     const int inv = ((1<<16) + length/2)/length;",
          "229:     for (x = 0; x < radius; x++)",
          "230:         sum += src[x*src_step]<<1;",
          "231:     sum += src[radius*src_step];",
          "233:     for (x = 0; x <= radius; x++) {",
          "234:         sum += src[(radius+x)*src_step] - src[(radius-x)*src_step];",
          "235:         dst[x*dst_step] = (sum*inv + (1<<15))>>16;",
          "236:     }",
          "238:     for (; x < w-radius; x++) {",
          "239:         sum += src[(radius+x)*src_step] - src[(x-radius-1)*src_step];",
          "240:         dst[x*dst_step] = (sum*inv + (1<<15))>>16;",
          "241:     }",
          "243:     for (; x < w; x++) {",
          "244:         sum += src[(2*w-radius-x-1)*src_step] - src[(x-radius-1)*src_step];",
          "245:         dst[x*dst_step] = (sum*inv + (1<<15))>>16;",
          "246:     }",
          "247: }",
          "249: static inline void blur_power(uint8_t *dst, int dst_step, const uint8_t *src, int src_step,",
          "250:                               int w, int radius, int power, uint8_t *temp[2])",
          "251: {",
          "252:     uint8_t *a = temp[0], *b = temp[1];",
          "254:     if (radius && power) {",
          "255:         blur(a, 1, src, src_step, w, radius);",
          "256:         for (; power > 2; power--) {",
          "257:             uint8_t *c;",
          "258:             blur(b, 1, a, 1, w, radius);",
          "259:             c = a; a = b; b = c;",
          "260:         }",
          "261:         if (power > 1) {",
          "262:             blur(dst, dst_step, a, 1, w, radius);",
          "263:         } else {",
          "264:             int i;",
          "265:             for (i = 0; i < w; i++)",
          "266:                 dst[i*dst_step] = a[i];",
          "267:         }",
          "268:     } else {",
          "269:         int i;",
          "270:         for (i = 0; i < w; i++)",
          "271:             dst[i*dst_step] = src[i*src_step];",
          "272:     }",
          "273: }",
          "275: static void hblur(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize,",
          "276:                   int w, int h, int radius, int power, uint8_t *temp[2])",
          "277: {",
          "278:     int y;",
          "280:     if (radius == 0 && dst == src)",
          "281:         return;",
          "283:     for (y = 0; y < h; y++)",
          "284:         blur_power(dst + y*dst_linesize, 1, src + y*src_linesize, 1,",
          "285:                    w, radius, power, temp);",
          "286: }",
          "288: static void vblur(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize,",
          "289:                   int w, int h, int radius, int power, uint8_t *temp[2])",
          "290: {",
          "291:     int x;",
          "293:     if (radius == 0 && dst == src)",
          "294:         return;",
          "296:     for (x = 0; x < w; x++)",
          "297:         blur_power(dst + x, dst_linesize, src + x, src_linesize,",
          "298:                    h, radius, power, temp);",
          "299: }",
          "301: static void draw_slice(AVFilterLink *inlink, int y0, int h0, int slice_dir)",
          "302: {",
          "303:     AVFilterContext *ctx = inlink->dst;",
          "304:     BoxBlurContext *boxblur = ctx->priv;",
          "305:     AVFilterLink *outlink = inlink->dst->outputs[0];",
          "306:     AVFilterBufferRef *inpicref  = inlink ->cur_buf;",
          "307:     AVFilterBufferRef *outpicref = outlink->out_buf;",
          "308:     int plane;",
          "309:     int cw = inlink->w >> boxblur->hsub, ch = h0 >> boxblur->vsub;",
          "310:     int w[4] = { inlink->w, cw, cw, inlink->w };",
          "311:     int h[4] = { h0, ch, ch, h0 };",
          "312:     uint8_t *dst[4], *src[4];",
          "314:     for (plane = 0; inpicref->data[plane] && plane < 4; plane++) {",
          "315:         int y = plane == 1 || plane == 2 ? y0 >> boxblur->vsub : y0;",
          "316:         src[plane] = inpicref ->data[plane] + inpicref ->linesize[plane] * y;",
          "317:         dst[plane] = outpicref->data[plane] + outpicref->linesize[plane] * y;",
          "318:     }",
          "320:     for (plane = 0; inpicref->data[plane] && plane < 4; plane++)",
          "321:         hblur(outpicref->data[plane], outpicref->linesize[plane],",
          "322:               inpicref ->data[plane], inpicref ->linesize[plane],",
          "323:               w[plane], h[plane], boxblur->radius[plane], boxblur->power[plane],",
          "324:               boxblur->temp);",
          "326:     for (plane = 0; inpicref->data[plane] && plane < 4; plane++)",
          "327:         vblur(outpicref->data[plane], outpicref->linesize[plane],",
          "328:               outpicref->data[plane], outpicref->linesize[plane],",
          "329:               w[plane], h[plane], boxblur->radius[plane], boxblur->power[plane],",
          "330:               boxblur->temp);",
          "331: }",
          "333: AVFilter avfilter_vf_boxblur = {",
          "334:     .name          = \"boxblur\",",
          "335:     .description   = NULL_IF_CONFIG_SMALL(\"Blur the input.\"),",
          "336:     .priv_size     = sizeof(BoxBlurContext),",
          "337:     .init          = init,",
          "338:     .uninit        = uninit,",
          "339:     .query_formats = query_formats,",
          "341:     .inputs    = (AVFilterPad[]) {{ .name             = \"default\",",
          "342:                                     .type             = AVMEDIA_TYPE_VIDEO,",
          "343:                                     .config_props     = config_input,",
          "344:                                     .draw_slice       = draw_slice,",
          "345:                                     .min_perms        = AV_PERM_READ },",
          "346:                                   { .name = NULL}},",
          "347:     .outputs   = (AVFilterPad[]) {{ .name             = \"default\",",
          "348:                                     .type             = AVMEDIA_TYPE_VIDEO, },",
          "349:                                   { .name = NULL}},",
          "350: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dd2793c880ea72c9aacda8245596694d9b4f378c",
      "candidate_info": {
        "commit_hash": "dd2793c880ea72c9aacda8245596694d9b4f378c",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/dd2793c880ea72c9aacda8245596694d9b4f378c",
        "files": [
          "Changelog",
          "doc/filters.texi",
          "libavfilter/Makefile",
          "libavfilter/allfilters.c",
          "libavfilter/avfilter.h",
          "libavfilter/vf_lut.c"
        ],
        "message": "lavfi: add LUT (LookUp Table) generic filters",
        "before_after_code_files": [
          "libavfilter/allfilters.c||libavfilter/allfilters.c",
          "libavfilter/avfilter.h||libavfilter/avfilter.h",
          "libavfilter/vf_lut.c||libavfilter/vf_lut.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_lut.c||libavfilter/vf_lut.c"
          ],
          "candidate": [
            "libavfilter/vf_lut.c||libavfilter/vf_lut.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/allfilters.c||libavfilter/allfilters.c": [
          "File: libavfilter/allfilters.c -> libavfilter/allfilters.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:     REGISTER_FILTER (GRADFUN,     gradfun,     vf);",
          "55:     REGISTER_FILTER (HFLIP,       hflip,       vf);",
          "56:     REGISTER_FILTER (HQDN3D,      hqdn3d,      vf);",
          "57:     REGISTER_FILTER (MP,          mp,          vf);",
          "58:     REGISTER_FILTER (NOFORMAT,    noformat,    vf);",
          "59:     REGISTER_FILTER (NULL,        null,        vf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57:     REGISTER_FILTER (LUT,         lut,         vf);",
          "58:     REGISTER_FILTER (LUTRGB,      lutrgb,      vf);",
          "59:     REGISTER_FILTER (LUTYUV,      lutyuv,      vf);",
          "",
          "---------------"
        ],
        "libavfilter/avfilter.h||libavfilter/avfilter.h": [
          "File: libavfilter/avfilter.h -> libavfilter/avfilter.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include \"libavutil/samplefmt.h\"",
          "28: #define LIBAVFILTER_VERSION_MAJOR  2",
          "30: #define LIBAVFILTER_VERSION_MICRO  0",
          "32: #define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \\",
          "",
          "[Removed Lines]",
          "29: #define LIBAVFILTER_VERSION_MINOR 18",
          "",
          "[Added Lines]",
          "29: #define LIBAVFILTER_VERSION_MINOR 19",
          "",
          "---------------"
        ],
        "libavfilter/vf_lut.c||libavfilter/vf_lut.c": [
          "File: libavfilter/vf_lut.c -> libavfilter/vf_lut.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"libavutil/eval.h\"",
          "28: #include \"libavutil/opt.h\"",
          "29: #include \"libavutil/pixdesc.h\"",
          "30: #include \"avfilter.h\"",
          "32: static const char *var_names[] = {",
          "33:     \"E\",",
          "34:     \"PHI\",",
          "35:     \"PI\",",
          "36:     \"w\",        ///< width of the input video",
          "37:     \"h\",        ///< height of the input video",
          "38:     \"val\",      ///< input value for the pixel",
          "39:     \"maxval\",   ///< max value for the pixel",
          "40:     \"minval\",   ///< min value for the pixel",
          "41:     \"negval\",   ///< negated value",
          "42:     \"clipval\",",
          "43:     NULL",
          "44: };",
          "46: enum var_name {",
          "47:     VAR_E,",
          "48:     VAR_PHI,",
          "49:     VAR_PI,",
          "50:     VAR_W,",
          "51:     VAR_H,",
          "52:     VAR_VAL,",
          "53:     VAR_MAXVAL,",
          "54:     VAR_MINVAL,",
          "55:     VAR_NEGVAL,",
          "56:     VAR_CLIPVAL,",
          "57:     VAR_VARS_NB",
          "58: };",
          "60: typedef struct {",
          "61:     const AVClass *class;",
          "62:     uint8_t lut[4][256];  ///< lookup table for each component",
          "63:     char   *comp_expr_str[4];",
          "64:     AVExpr *comp_expr[4];",
          "65:     int hsub, vsub;",
          "66:     double var_values[VAR_VARS_NB];",
          "67:     int is_rgb, is_yuv;",
          "68:     int rgba_map[4];",
          "69:     int step;",
          "70: } LutContext;",
          "72: #define Y 0",
          "73: #define U 1",
          "74: #define V 2",
          "75: #define R 0",
          "76: #define G 1",
          "77: #define B 2",
          "78: #define A 3",
          "80: #define OFFSET(x) offsetof(LutContext, x)",
          "82: static const AVOption lut_options[] = {",
          "83:     {\"c0\", \"set component #0 expression\", OFFSET(comp_expr_str[0]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "84:     {\"c1\", \"set component #1 expression\", OFFSET(comp_expr_str[1]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "85:     {\"c2\", \"set component #2 expression\", OFFSET(comp_expr_str[2]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "86:     {\"c3\", \"set component #3 expression\", OFFSET(comp_expr_str[3]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "87:     {\"y\",  \"set Y expression\", OFFSET(comp_expr_str[Y]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "88:     {\"u\",  \"set U expression\", OFFSET(comp_expr_str[U]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "89:     {\"v\",  \"set V expression\", OFFSET(comp_expr_str[V]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "90:     {\"r\",  \"set R expression\", OFFSET(comp_expr_str[R]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "91:     {\"g\",  \"set G expression\", OFFSET(comp_expr_str[G]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "92:     {\"b\",  \"set B expression\", OFFSET(comp_expr_str[B]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "93:     {\"a\",  \"set A expression\", OFFSET(comp_expr_str[A]),  FF_OPT_TYPE_STRING, {.str=\"val\"}, CHAR_MIN, CHAR_MAX},",
          "94:     {NULL},",
          "95: };",
          "97: static const char *lut_get_name(void *ctx)",
          "98: {",
          "99:     return \"lut\";",
          "100: }",
          "102: static const AVClass lut_class = {",
          "103:     \"LutContext\",",
          "104:     lut_get_name,",
          "105:     lut_options",
          "106: };",
          "108: static int init(AVFilterContext *ctx, const char *args, void *opaque)",
          "109: {",
          "110:     LutContext *lut = ctx->priv;",
          "111:     int ret;",
          "113:     lut->class = &lut_class;",
          "114:     av_opt_set_defaults2(lut, 0, 0);",
          "116:     lut->var_values[VAR_PHI] = M_PHI;",
          "117:     lut->var_values[VAR_PI]  = M_PI;",
          "118:     lut->var_values[VAR_E ]  = M_E;",
          "120:     lut->is_rgb = !strcmp(ctx->filter->name, \"lutrgb\");",
          "121:     lut->is_yuv = !strcmp(ctx->filter->name, \"lutyuv\");",
          "122:     if (args && (ret = av_set_options_string(lut, args, \"=\", \":\")) < 0)",
          "123:         return ret;",
          "125:     return 0;",
          "126: }",
          "128: static av_cold void uninit(AVFilterContext *ctx)",
          "129: {",
          "130:     LutContext *lut = ctx->priv;",
          "131:     int i;",
          "133:     for (i = 0; i < 4; i++) {",
          "134:         av_expr_free(lut->comp_expr[i]);",
          "135:         lut->comp_expr[i] = NULL;",
          "136:         av_freep(&lut->comp_expr_str[i]);",
          "137:     }",
          "138: }",
          "140: #define YUV_FORMATS                                         \\",
          "141:     PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,    \\",
          "142:     PIX_FMT_YUV411P,  PIX_FMT_YUV410P,  PIX_FMT_YUV440P,    \\",
          "143:     PIX_FMT_YUVA420P,                                       \\",
          "144:     PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,   \\",
          "145:     PIX_FMT_YUVJ440P",
          "147: #define RGB_FORMATS                             \\",
          "148:     PIX_FMT_ARGB,         PIX_FMT_RGBA,         \\",
          "149:     PIX_FMT_ABGR,         PIX_FMT_BGRA,         \\",
          "150:     PIX_FMT_RGB24,        PIX_FMT_BGR24",
          "152: static enum PixelFormat yuv_pix_fmts[] = { YUV_FORMATS, PIX_FMT_NONE };",
          "153: static enum PixelFormat rgb_pix_fmts[] = { RGB_FORMATS, PIX_FMT_NONE };",
          "154: static enum PixelFormat all_pix_fmts[] = { RGB_FORMATS, YUV_FORMATS, PIX_FMT_NONE };",
          "156: static int query_formats(AVFilterContext *ctx)",
          "157: {",
          "158:     LutContext *lut = ctx->priv;",
          "160:     enum PixelFormat *pix_fmts = lut->is_rgb ? rgb_pix_fmts :",
          "161:                                  lut->is_yuv ? yuv_pix_fmts : all_pix_fmts;",
          "163:     avfilter_set_common_formats(ctx, avfilter_make_format_list(pix_fmts));",
          "164:     return 0;",
          "165: }",
          "167: static int pix_fmt_is_in(enum PixelFormat pix_fmt, enum PixelFormat *pix_fmts)",
          "168: {",
          "169:     enum PixelFormat *p;",
          "170:     for (p = pix_fmts; *p != PIX_FMT_NONE; p++) {",
          "171:         if (pix_fmt == *p)",
          "172:             return 1;",
          "173:     }",
          "174:     return 0;",
          "175: }",
          "180: static double clip(void *opaque, double val)",
          "181: {",
          "182:     LutContext *lut = opaque;",
          "183:     double minval = lut->var_values[VAR_MINVAL];",
          "184:     double maxval = lut->var_values[VAR_MAXVAL];",
          "186:     return av_clip(val, minval, maxval);",
          "187: }",
          "193: static double compute_gammaval(void *opaque, double gamma)",
          "194: {",
          "195:     LutContext *lut = opaque;",
          "196:     double val    = lut->var_values[VAR_CLIPVAL];",
          "197:     double minval = lut->var_values[VAR_MINVAL];",
          "198:     double maxval = lut->var_values[VAR_MAXVAL];",
          "200:     return pow((val-minval)/(maxval-minval), gamma) * (maxval-minval)+minval;",
          "201: }",
          "203: static double (* const funcs1[])(void *, double) = {",
          "204:     (void *)clip,",
          "205:     (void *)compute_gammaval,",
          "206:     NULL",
          "207: };",
          "209: static const char * const funcs1_names[] = {",
          "210:     \"clip\",",
          "211:     \"gammaval\",",
          "212:     NULL",
          "213: };",
          "215: static int config_props(AVFilterLink *inlink)",
          "216: {",
          "217:     AVFilterContext *ctx = inlink->dst;",
          "218:     LutContext *lut = ctx->priv;",
          "219:     const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];",
          "220:     int min[4], max[4];",
          "221:     int val, comp, ret;",
          "223:     lut->hsub = desc->log2_chroma_w;",
          "224:     lut->vsub = desc->log2_chroma_h;",
          "226:     lut->var_values[VAR_W] = inlink->w;",
          "227:     lut->var_values[VAR_H] = inlink->h;",
          "229:     switch (inlink->format) {",
          "230:     case PIX_FMT_YUV410P:",
          "231:     case PIX_FMT_YUV411P:",
          "232:     case PIX_FMT_YUV420P:",
          "233:     case PIX_FMT_YUV422P:",
          "234:     case PIX_FMT_YUV440P:",
          "235:     case PIX_FMT_YUV444P:",
          "236:     case PIX_FMT_YUVA420P:",
          "237:         min[Y] = min[U] = min[V] = 16;",
          "238:         max[Y] = 235;",
          "239:         max[U] = max[V] = 240;",
          "240:         break;",
          "241:     default:",
          "242:         min[0] = min[1] = min[2] = min[3] = 0;",
          "243:         max[0] = max[1] = max[2] = max[3] = 255;",
          "244:     }",
          "246:     lut->is_yuv = lut->is_rgb = 0;",
          "247:     if      (pix_fmt_is_in(inlink->format, yuv_pix_fmts)) lut->is_yuv = 1;",
          "248:     else if (pix_fmt_is_in(inlink->format, rgb_pix_fmts)) lut->is_rgb = 1;",
          "250:     if (lut->is_rgb) {",
          "251:         switch (inlink->format) {",
          "252:         case PIX_FMT_ARGB:  lut->rgba_map[A] = 0; lut->rgba_map[R] = 1; lut->rgba_map[G] = 2; lut->rgba_map[B] = 3; break;",
          "253:         case PIX_FMT_ABGR:  lut->rgba_map[A] = 0; lut->rgba_map[B] = 1; lut->rgba_map[G] = 2; lut->rgba_map[R] = 3; break;",
          "254:         case PIX_FMT_RGBA:",
          "255:         case PIX_FMT_RGB24: lut->rgba_map[R] = 0; lut->rgba_map[G] = 1; lut->rgba_map[B] = 2; lut->rgba_map[A] = 3; break;",
          "256:         case PIX_FMT_BGRA:",
          "257:         case PIX_FMT_BGR24: lut->rgba_map[B] = 0; lut->rgba_map[G] = 1; lut->rgba_map[R] = 2; lut->rgba_map[A] = 3; break;",
          "258:         }",
          "259:         lut->step = av_get_bits_per_pixel(desc) >> 3;",
          "260:     }",
          "262:     for (comp = 0; comp < desc->nb_components; comp++) {",
          "263:         double res;",
          "266:         ret = av_expr_parse(&lut->comp_expr[comp], lut->comp_expr_str[comp],",
          "267:                             var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx);",
          "268:         if (ret < 0) {",
          "269:             av_log(ctx, AV_LOG_ERROR,",
          "270:                    \"Error when parsing the expression '%s' for the component %d.\\n\",",
          "271:                    lut->comp_expr_str[comp], comp);",
          "272:             return AVERROR(EINVAL);",
          "273:         }",
          "276:         lut->var_values[VAR_MAXVAL] = max[comp];",
          "277:         lut->var_values[VAR_MINVAL] = min[comp];",
          "279:         for (val = 0; val < 256; val++) {",
          "280:             lut->var_values[VAR_VAL] = val;",
          "281:             lut->var_values[VAR_CLIPVAL] = av_clip(val, min[comp], max[comp]);",
          "282:             lut->var_values[VAR_NEGVAL] =",
          "283:                 av_clip(min[comp] + max[comp] - lut->var_values[VAR_VAL],",
          "284:                         min[comp], max[comp]);",
          "286:             res = av_expr_eval(lut->comp_expr[comp], lut->var_values, lut);",
          "287:             if (isnan(res)) {",
          "288:                 av_log(ctx, AV_LOG_ERROR,",
          "289:                        \"Error when evaluating the expression '%s' for the value %d for the component #%d.\\n\",",
          "290:                        lut->comp_expr_str[comp], val, comp);",
          "291:                 return AVERROR(EINVAL);",
          "292:             }",
          "293:             lut->lut[comp][val] = av_clip((int)res, min[comp], max[comp]);",
          "294:             av_log(ctx, AV_LOG_DEBUG, \"val[%d][%d] = %d\\n\", comp, val, lut->lut[comp][val]);",
          "295:         }",
          "296:     }",
          "298:     return 0;",
          "299: }",
          "301: static void draw_slice(AVFilterLink *inlink, int y, int h, int slice_dir)",
          "302: {",
          "303:     AVFilterContext *ctx = inlink->dst;",
          "304:     LutContext *lut = ctx->priv;",
          "305:     AVFilterLink *outlink = ctx->outputs[0];",
          "306:     AVFilterBufferRef *inpic  = inlink ->cur_buf;",
          "307:     AVFilterBufferRef *outpic = outlink->out_buf;",
          "308:     uint8_t *inrow, *outrow;",
          "309:     int i, j, k, plane;",
          "311:     if (lut->is_rgb) {",
          "313:         inrow  = inpic ->data[0] + y * inpic ->linesize[0];",
          "314:         outrow = outpic->data[0] + y * outpic->linesize[0];",
          "316:         for (i = 0; i < h; i ++) {",
          "317:             for (j = 0; j < inlink->w; j++) {",
          "318:                 for (k = 0; k < lut->step; k++)",
          "319:                     outrow[k] = lut->lut[lut->rgba_map[k]][inrow[k]];",
          "320:                 outrow += lut->step;",
          "321:                 inrow  += lut->step;",
          "322:             }",
          "323:         }",
          "324:     } else {",
          "326:         for (plane = 0; inpic->data[plane]; plane++) {",
          "327:             int vsub = plane == 1 || plane == 2 ? lut->vsub : 0;",
          "328:             int hsub = plane == 1 || plane == 2 ? lut->hsub : 0;",
          "330:             inrow  = inpic ->data[plane] + (y>>vsub) * inpic ->linesize[plane];",
          "331:             outrow = outpic->data[plane] + (y>>vsub) * outpic->linesize[plane];",
          "333:             for (i = 0; i < h>>vsub; i ++) {",
          "334:                 for (j = 0; j < inlink->w>>hsub; j++)",
          "335:                     outrow[j] = lut->lut[plane][inrow[j]];",
          "336:                 inrow  += inpic ->linesize[plane];",
          "337:                 outrow += outpic->linesize[plane];",
          "338:             }",
          "339:         }",
          "340:     }",
          "342:     avfilter_draw_slice(outlink, y, h, slice_dir);",
          "343: }",
          "345: #define DEFINE_LUT_FILTER(name_, description_, init_)                   \\",
          "346:     AVFilter avfilter_vf_##name_ = {                                    \\",
          "347:         .name          = NULL_IF_CONFIG_SMALL(#name_),                  \\",
          "348:         .description   = description_,                                  \\",
          "349:         .priv_size     = sizeof(LutContext),                            \\",
          "350:                                                                         \\",
          "351:         .init          = init_,                                         \\",
          "352:         .uninit        = uninit,                                        \\",
          "353:         .query_formats = query_formats,                                 \\",
          "354:                                                                         \\",
          "355:         .inputs    = (AVFilterPad[]) {{ .name            = \"default\",   \\",
          "356:                                         .type            = AVMEDIA_TYPE_VIDEO, \\",
          "357:                                         .draw_slice      = draw_slice,  \\",
          "358:                                         .config_props    = config_props, \\",
          "359:                                         .min_perms       = AV_PERM_READ, }, \\",
          "360:                                       { .name = NULL}},                 \\",
          "361:         .outputs   = (AVFilterPad[]) {{ .name            = \"default\",   \\",
          "362:                                         .type            = AVMEDIA_TYPE_VIDEO, }, \\",
          "363:                                       { .name = NULL}},                 \\",
          "364:     }",
          "366: DEFINE_LUT_FILTER(lut,    \"Compute and apply a lookup table to the RGB/YUV input video.\", init);",
          "367: DEFINE_LUT_FILTER(lutyuv, \"Compute and apply a lookup table to the YUV input video.\",     init);",
          "368: DEFINE_LUT_FILTER(lutrgb, \"Compute and apply a lookup table to the RGB input video.\",     init);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-6786",
  "cve_desc": "kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 30955111.",
  "repo": "torvalds/linux",
  "patch_hash": "f63a8daa5812afef4f06c962351687e1ff9ccb2b",
  "patch_info": {
    "commit_hash": "f63a8daa5812afef4f06c962351687e1ff9ccb2b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b",
    "files": [
      "kernel/events/core.c"
    ],
    "message": "perf: Fix event->ctx locking\n\nThere have been a few reported issues wrt. the lack of locking around\nchanging event->ctx. This patch tries to address those.\n\nIt avoids the whole rwsem thing; and while it appears to work, please\ngive it some thought in review.\n\nWhat I did fail at is sensible runtime checks on the use of\nevent->ctx, the RCU use makes it very hard.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http://lkml.kernel.org/r/20150123125834.209535886@infradead.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "before_after_code_files": [
      "kernel/events/core.c||kernel/events/core.c"
    ]
  },
  "patch_diff": {
    "kernel/events/core.c||kernel/events/core.c": [
      "File: kernel/events/core.c -> kernel/events/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "906:  }",
      "907: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "950: static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)",
      "951: {",
      "952:  struct perf_event_context *ctx;",
      "954: again:",
      "955:  rcu_read_lock();",
      "956:  ctx = ACCESS_ONCE(event->ctx);",
      "957:  if (!atomic_inc_not_zero(&ctx->refcount)) {",
      "958:   rcu_read_unlock();",
      "959:   goto again;",
      "960:  }",
      "961:  rcu_read_unlock();",
      "963:  mutex_lock(&ctx->mutex);",
      "964:  if (event->ctx != ctx) {",
      "965:   mutex_unlock(&ctx->mutex);",
      "966:   put_ctx(ctx);",
      "967:   goto again;",
      "968:  }",
      "970:  return ctx;",
      "971: }",
      "973: static void perf_event_ctx_unlock(struct perf_event *event,",
      "974:       struct perf_event_context *ctx)",
      "975: {",
      "976:  mutex_unlock(&ctx->mutex);",
      "977:  put_ctx(ctx);",
      "978: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1670: {",
      "1671:  struct perf_event_context *ctx = event->ctx;",
      "1672:  struct task_struct *task = ctx->task;",
      "",
      "[Removed Lines]",
      "1669: void perf_event_disable(struct perf_event *event)",
      "",
      "[Added Lines]",
      "1740: static void _perf_event_disable(struct perf_event *event)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1707:  }",
      "1708:  raw_spin_unlock_irq(&ctx->lock);",
      "1709: }",
      "1710: EXPORT_SYMBOL_GPL(perf_event_disable);",
      "1712: static void perf_set_shadow_time(struct perf_event *event,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1786: void perf_event_disable(struct perf_event *event)",
      "1787: {",
      "1788:  struct perf_event_context *ctx;",
      "1790:  ctx = perf_event_ctx_lock(event);",
      "1791:  _perf_event_disable(event);",
      "1792:  perf_event_ctx_unlock(event, ctx);",
      "1793: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2174: {",
      "2175:  struct perf_event_context *ctx = event->ctx;",
      "2176:  struct task_struct *task = ctx->task;",
      "",
      "[Removed Lines]",
      "2173: void perf_event_enable(struct perf_event *event)",
      "",
      "[Added Lines]",
      "2257: static void _perf_event_enable(struct perf_event *event)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2226: out:",
      "2227:  raw_spin_unlock_irq(&ctx->lock);",
      "2228: }",
      "2229: EXPORT_SYMBOL_GPL(perf_event_enable);",
      "2232: {",
      "",
      "[Removed Lines]",
      "2231: int perf_event_refresh(struct perf_event *event, int refresh)",
      "",
      "[Added Lines]",
      "2317: void perf_event_enable(struct perf_event *event)",
      "2318: {",
      "2319:  struct perf_event_context *ctx;",
      "2321:  ctx = perf_event_ctx_lock(event);",
      "2322:  _perf_event_enable(event);",
      "2323:  perf_event_ctx_unlock(event, ctx);",
      "2324: }",
      "2327: static int _perf_event_refresh(struct perf_event *event, int refresh)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2237:   return -EINVAL;",
      "2239:  atomic_add(refresh, &event->event_limit);",
      "2242:  return 0;",
      "2243: }",
      "2244: EXPORT_SYMBOL_GPL(perf_event_refresh);",
      "2246: static void ctx_sched_out(struct perf_event_context *ctx,",
      "",
      "[Removed Lines]",
      "2240:  perf_event_enable(event);",
      "",
      "[Added Lines]",
      "2336:  _perf_event_enable(event);",
      "2344: int perf_event_refresh(struct perf_event *event, int refresh)",
      "2345: {",
      "2346:  struct perf_event_context *ctx;",
      "2347:  int ret;",
      "2349:  ctx = perf_event_ctx_lock(event);",
      "2350:  ret = _perf_event_refresh(event, refresh);",
      "2351:  perf_event_ctx_unlock(event, ctx);",
      "2353:  return ret;",
      "2354: }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3433:  rcu_read_unlock();",
      "3435:  if (owner) {",
      "",
      "[Removed Lines]",
      "3436:   mutex_lock(&owner->perf_event_mutex);",
      "",
      "[Added Lines]",
      "3555:   mutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "3559:        u64 read_format, char __user *buf)",
      "3560: {",
      "3561:  struct perf_event *leader = event->group_leader, *sub;",
      "3563:  struct perf_event_context *ctx = leader->ctx;",
      "3565:  u64 count, enabled, running;",
      "3568:  count = perf_event_read_value(leader, &enabled, &running);",
      "3570:  values[n++] = 1 + leader->nr_siblings;",
      "",
      "[Removed Lines]",
      "3562:  int n = 0, size = 0, ret = -EFAULT;",
      "3564:  u64 values[5];",
      "3567:  mutex_lock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "3683:  int n = 0, size = 0, ret;",
      "3685:  u64 values[5];",
      "3687:  lockdep_assert_held(&ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3579:  size = n * sizeof(u64);",
      "3581:  if (copy_to_user(buf, values, size))",
      "3584:  ret = size;",
      "",
      "[Removed Lines]",
      "3582:   goto unlock;",
      "",
      "[Added Lines]",
      "3703:   return -EFAULT;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3593:   size = n * sizeof(u64);",
      "3595:   if (copy_to_user(buf + ret, values, size)) {",
      "3598:   }",
      "3600:   ret += size;",
      "3601:  }",
      "3605:  return ret;",
      "3606: }",
      "",
      "[Removed Lines]",
      "3596:    ret = -EFAULT;",
      "3597:    goto unlock;",
      "3602: unlock:",
      "3603:  mutex_unlock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "3717:    return -EFAULT;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "3672: perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)",
      "3673: {",
      "3674:  struct perf_event *event = file->private_data;",
      "3677: }",
      "3679: static unsigned int perf_poll(struct file *file, poll_table *wait)",
      "",
      "[Removed Lines]",
      "3676:  return perf_read_hw(event, buf, count);",
      "",
      "[Added Lines]",
      "3793:  struct perf_event_context *ctx;",
      "3794:  int ret;",
      "3796:  ctx = perf_event_ctx_lock(event);",
      "3797:  ret = perf_read_hw(event, buf, count);",
      "3798:  perf_event_ctx_unlock(event, ctx);",
      "3800:  return ret;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3699:  return events;",
      "3700: }",
      "3703: {",
      "3704:  (void)perf_event_read(event);",
      "3705:  local64_set(&event->count, 0);",
      "",
      "[Removed Lines]",
      "3702: static void perf_event_reset(struct perf_event *event)",
      "",
      "[Added Lines]",
      "3826: static void _perf_event_reset(struct perf_event *event)",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "3731:  struct perf_event_context *ctx = event->ctx;",
      "3732:  struct perf_event *sibling;",
      "3736:  event = event->group_leader;",
      "3738:  perf_event_for_each_child(event, func);",
      "3739:  list_for_each_entry(sibling, &event->sibling_list, group_entry)",
      "3740:   perf_event_for_each_child(sibling, func);",
      "3742: }",
      "3744: static int perf_event_period(struct perf_event *event, u64 __user *arg)",
      "",
      "[Removed Lines]",
      "3734:  WARN_ON_ONCE(ctx->parent_ctx);",
      "3735:  mutex_lock(&ctx->mutex);",
      "3741:  mutex_unlock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "3859:  lockdep_assert_held(&ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3808:      struct perf_event *output_event);",
      "3809: static int perf_event_set_filter(struct perf_event *event, void __user *arg);",
      "3812: {",
      "3814:  void (*func)(struct perf_event *);",
      "3815:  u32 flags = arg;",
      "3817:  switch (cmd) {",
      "3818:  case PERF_EVENT_IOC_ENABLE:",
      "3820:   break;",
      "3821:  case PERF_EVENT_IOC_DISABLE:",
      "3823:   break;",
      "3824:  case PERF_EVENT_IOC_RESET:",
      "3826:   break;",
      "3828:  case PERF_EVENT_IOC_REFRESH:",
      "3831:  case PERF_EVENT_IOC_PERIOD:",
      "3832:   return perf_event_period(event, (u64 __user *)arg);",
      "",
      "[Removed Lines]",
      "3811: static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
      "3813:  struct perf_event *event = file->private_data;",
      "3819:   func = perf_event_enable;",
      "3822:   func = perf_event_disable;",
      "3825:   func = perf_event_reset;",
      "3829:   return perf_event_refresh(event, arg);",
      "",
      "[Added Lines]",
      "3935: static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)",
      "3942:   func = _perf_event_enable;",
      "3945:   func = _perf_event_disable;",
      "3948:   func = _perf_event_reset;",
      "3952:   return _perf_event_refresh(event, arg);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "3873:  return 0;",
      "3874: }",
      "3876: #ifdef CONFIG_COMPAT",
      "3877: static long perf_compat_ioctl(struct file *file, unsigned int cmd,",
      "3878:     unsigned long arg)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3999: static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
      "4000: {",
      "4001:  struct perf_event *event = file->private_data;",
      "4002:  struct perf_event_context *ctx;",
      "4003:  long ret;",
      "4005:  ctx = perf_event_ctx_lock(event);",
      "4006:  ret = _perf_ioctl(event, cmd, arg);",
      "4007:  perf_event_ctx_unlock(event, ctx);",
      "4009:  return ret;",
      "4010: }",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "3896: int perf_event_task_enable(void)",
      "3897: {",
      "3898:  struct perf_event *event;",
      "3900:  mutex_lock(&current->perf_event_mutex);",
      "3903:  mutex_unlock(&current->perf_event_mutex);",
      "3905:  return 0;",
      "",
      "[Removed Lines]",
      "3901:  list_for_each_entry(event, &current->perf_event_list, owner_entry)",
      "3902:   perf_event_for_each_child(event, perf_event_enable);",
      "",
      "[Added Lines]",
      "4034:  struct perf_event_context *ctx;",
      "4038:  list_for_each_entry(event, &current->perf_event_list, owner_entry) {",
      "4039:   ctx = perf_event_ctx_lock(event);",
      "4040:   perf_event_for_each_child(event, _perf_event_enable);",
      "4041:   perf_event_ctx_unlock(event, ctx);",
      "4042:  }",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "3908: int perf_event_task_disable(void)",
      "3909: {",
      "3910:  struct perf_event *event;",
      "3912:  mutex_lock(&current->perf_event_mutex);",
      "3915:  mutex_unlock(&current->perf_event_mutex);",
      "3917:  return 0;",
      "",
      "[Removed Lines]",
      "3913:  list_for_each_entry(event, &current->perf_event_list, owner_entry)",
      "3914:   perf_event_for_each_child(event, perf_event_disable);",
      "",
      "[Added Lines]",
      "4050:  struct perf_event_context *ctx;",
      "4054:  list_for_each_entry(event, &current->perf_event_list, owner_entry) {",
      "4055:   ctx = perf_event_ctx_lock(event);",
      "4056:   perf_event_for_each_child(event, _perf_event_disable);",
      "4057:   perf_event_ctx_unlock(event, ctx);",
      "4058:  }",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "7269:  return ret;",
      "7270: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7416: static void mutex_lock_double(struct mutex *a, struct mutex *b)",
      "7417: {",
      "7418:  if (b < a)",
      "7419:   swap(a, b);",
      "7421:  mutex_lock(a);",
      "7422:  mutex_lock_nested(b, SINGLE_DEPTH_NESTING);",
      "7423: }",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "7284:  struct perf_event *group_leader = NULL, *output_event = NULL;",
      "7285:  struct perf_event *event, *sibling;",
      "7286:  struct perf_event_attr attr;",
      "7288:  struct file *event_file = NULL;",
      "7289:  struct fd group = {NULL, 0};",
      "7290:  struct task_struct *task = NULL;",
      "",
      "[Removed Lines]",
      "7287:  struct perf_event_context *ctx;",
      "",
      "[Added Lines]",
      "7440:  struct perf_event_context *ctx, *uninitialized_var(gctx);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "7482:  }",
      "7484:  if (move_group) {",
      "7488:   perf_remove_from_context(group_leader, false);",
      "",
      "[Removed Lines]",
      "7485:   struct perf_event_context *gctx = group_leader->ctx;",
      "7487:   mutex_lock(&gctx->mutex);",
      "",
      "[Added Lines]",
      "7638:   gctx = group_leader->ctx;",
      "7644:   mutex_lock_double(&gctx->mutex, &ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "7499:    perf_event__state_init(sibling);",
      "7500:    put_ctx(gctx);",
      "7501:   }",
      "7504:  }",
      "7506:  WARN_ON_ONCE(ctx->parent_ctx);",
      "7509:  if (move_group) {",
      "7510:   synchronize_rcu();",
      "7511:   perf_install_in_context(ctx, group_leader, group_leader->cpu);",
      "7512:   get_ctx(ctx);",
      "7513:   list_for_each_entry(sibling, &group_leader->sibling_list,",
      "",
      "[Removed Lines]",
      "7502:   mutex_unlock(&gctx->mutex);",
      "7503:   put_ctx(gctx);",
      "7507:  mutex_lock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "7660:  } else {",
      "7661:   mutex_lock(&ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "7520:  perf_install_in_context(ctx, event, event->cpu);",
      "7521:  perf_unpin_context(ctx);",
      "7522:  mutex_unlock(&ctx->mutex);",
      "7524:  put_online_cpus();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7685:  if (move_group) {",
      "7686:   mutex_unlock(&gctx->mutex);",
      "7687:   put_ctx(gctx);",
      "7688:  }",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "7626:  src_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;",
      "7627:  dst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;",
      "7630:  list_for_each_entry_safe(event, tmp, &src_ctx->event_list,",
      "7631:      event_entry) {",
      "7632:   perf_remove_from_context(event, false);",
      "",
      "[Removed Lines]",
      "7629:  mutex_lock(&src_ctx->mutex);",
      "",
      "[Added Lines]",
      "7800:  mutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "7634:   put_ctx(src_ctx);",
      "7635:   list_add(&event->migrate_entry, &events);",
      "7636:  }",
      "7639:  synchronize_rcu();",
      "7642:  list_for_each_entry_safe(event, tmp, &events, migrate_entry) {",
      "7643:   list_del(&event->migrate_entry);",
      "7644:   if (event->state >= PERF_EVENT_STATE_OFF)",
      "",
      "[Removed Lines]",
      "7637:  mutex_unlock(&src_ctx->mutex);",
      "7641:  mutex_lock(&dst_ctx->mutex);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "7648:   get_ctx(dst_ctx);",
      "7649:  }",
      "7650:  mutex_unlock(&dst_ctx->mutex);",
      "7651: }",
      "7652: EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7820:  mutex_unlock(&src_ctx->mutex);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "683ede43dd412c6cad0d23578a018409ac9c683e",
      "candidate_info": {
        "commit_hash": "683ede43dd412c6cad0d23578a018409ac9c683e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/683ede43dd412c6cad0d23578a018409ac9c683e",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf: Rework free paths\n\nPrimarily make perf_event_release_kernel() into put_event(), this will\nallow kernel space to create per-task inherited events, and is safer\nin general.\n\nAlso, document the free_event() assumptions.\n\nSigned-off-by: Peter Zijlstra <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nCc: Stephane Eranian <eranian@google.com>\nLink: http://lkml.kernel.org/n/tip-rk9pvr6e1d0559lxstltbztc@git.kernel.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3252:  call_rcu(&event->rcu_head, free_event_rcu);",
          "3253: }",
          "3255: {",
          "3256:  irq_work_sync(&event->pending);",
          "",
          "[Removed Lines]",
          "3254: static void free_event(struct perf_event *event)",
          "",
          "[Added Lines]",
          "3255: static void _free_event(struct perf_event *event)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3279:  if (is_cgroup_event(event))",
          "3280:   perf_detach_cgroup(event);",
          "3283:  __free_event(event);",
          "3284: }",
          "3287: {",
          "3310: }",
          "3316: static void put_event(struct perf_event *event)",
          "3317: {",
          "3318:  struct task_struct *owner;",
          "3320:  if (!atomic_long_dec_and_test(&event->refcount))",
          "",
          "[Removed Lines]",
          "3286: int perf_event_release_kernel(struct perf_event *event)",
          "3288:  struct perf_event_context *ctx = event->ctx;",
          "3290:  WARN_ON_ONCE(ctx->parent_ctx);",
          "3303:  mutex_lock_nested(&ctx->mutex, SINGLE_DEPTH_NESTING);",
          "3304:  perf_remove_from_context(event, true);",
          "3305:  mutex_unlock(&ctx->mutex);",
          "3307:  free_event(event);",
          "3309:  return 0;",
          "3311: EXPORT_SYMBOL_GPL(perf_event_release_kernel);",
          "",
          "[Added Lines]",
          "3290: static void free_event(struct perf_event *event)",
          "3292:  if (WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1,",
          "3293:     \"unexpected event refcount: %ld; ptr=%p\\n\",",
          "3294:     atomic_long_read(&event->refcount), event)) {",
          "3296:   return;",
          "3297:  }",
          "3299:  _free_event(event);",
          "3307:  struct perf_event_context *ctx = event->ctx;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3353:   put_task_struct(owner);",
          "3354:  }",
          "3357: }",
          "3359: static int perf_release(struct inode *inode, struct file *file)",
          "3360: {",
          "3361:  put_event(file->private_data);",
          "",
          "[Removed Lines]",
          "3356:  perf_event_release_kernel(event);",
          "",
          "[Added Lines]",
          "3346:  WARN_ON_ONCE(ctx->parent_ctx);",
          "3359:  mutex_lock_nested(&ctx->mutex, SINGLE_DEPTH_NESTING);",
          "3360:  perf_remove_from_context(event, true);",
          "3361:  mutex_unlock(&ctx->mutex);",
          "3363:  _free_event(event);",
          "3366: int perf_event_release_kernel(struct perf_event *event)",
          "3367: {",
          "3368:  put_event(event);",
          "3369:  return 0;",
          "3370: }",
          "3371: EXPORT_SYMBOL_GPL(perf_event_release_kernel);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3577af70a2ce4853d58e57d832e687d739281479",
      "candidate_info": {
        "commit_hash": "3577af70a2ce4853d58e57d832e687d739281479",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3577af70a2ce4853d58e57d832e687d739281479",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf: Fix a race condition in perf_remove_from_context()\n\nWe saw a kernel soft lockup in perf_remove_from_context(),\nit looks like the `perf` process, when exiting, could not go\nout of the retry loop. Meanwhile, the target process was forking\na child. So either the target process should execute the smp\nfunction call to deactive the event (if it was running) or it should\ndo a context switch which deactives the event.\n\nIt seems we optimize out a context switch in perf_event_context_sched_out(),\nand what's more important, we still test an obsolete task pointer when\nretrying, so no one actually would deactive that event in this situation.\nFix it directly by reloading the task pointer in perf_remove_from_context().\n\nThis should cure the above soft lockup.\n\nSigned-off-by: Cong Wang <cwang@twopensource.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: Peter Zijlstra <peterz@infradead.org>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: <stable@vger.kernel.org>\nLink: http://lkml.kernel.org/r/1409696840-843-1-git-send-email-xiyou.wangcong@gmail.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1525:  if (ctx->is_active) {",
          "1526:   raw_spin_unlock_irq(&ctx->lock);",
          "1527:   goto retry;",
          "1528:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1531:   task = ctx->task;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1968:  if (ctx->is_active) {",
          "1969:   raw_spin_unlock_irq(&ctx->lock);",
          "1970:   goto retry;",
          "1971:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1979:   task = ctx->task;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "179033b3e064d2cd3f5f9945e76b0a0f0fbf4883",
      "candidate_info": {
        "commit_hash": "179033b3e064d2cd3f5f9945e76b0a0f0fbf4883",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/179033b3e064d2cd3f5f9945e76b0a0f0fbf4883",
        "files": [
          "include/linux/perf_event.h",
          "kernel/events/core.c"
        ],
        "message": "perf: Add PERF_EVENT_STATE_EXIT state for events with exited task\n\nAdding new perf event state to indicate that the monitored task has\nexited.  In this case the event stays alive until the owner task exits\nor close the event fd while providing the last data through the read\nsyscall and ring buffer.\n\nInstead it needs to propagate the error info (monitored task has died)\nvia poll and read  syscalls by  returning POLLHUP and 0 respectively.\n\nSigned-off-by: Jiri Olsa <jolsa@kernel.org>\nAcked-by: Peter Zijlstra <peterz@infradead.org>\nLink: http://lkml.kernel.org/r/20140811120102.GY9918@twins.programming.kicks-ass.net\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Corey Ashford <cjashfor@linux.vnet.ibm.com>\nCc: David Ahern <dsahern@gmail.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Ingo Molnar <mingo@kernel.org>\nCc: Jean Pihet <jean.pihet@linaro.org>\nCc: Namhyung Kim <namhyung@kernel.org>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Peter Zijlstra <a.p.zijlstra@chello.nl>\nLink: http://lkml.kernel.org/n/tip-t5y3w8jjx6tfo5w8y6oajsjq@git.kernel.org\nSigned-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>",
        "before_after_code_files": [
          "include/linux/perf_event.h||include/linux/perf_event.h",
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/perf_event.h||include/linux/perf_event.h": [
          "File: include/linux/perf_event.h -> include/linux/perf_event.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "271: enum perf_event_active_state {",
          "272:  PERF_EVENT_STATE_ERROR  = -2,",
          "273:  PERF_EVENT_STATE_OFF  = -1,",
          "274:  PERF_EVENT_STATE_INACTIVE =  0,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:  PERF_EVENT_STATE_EXIT  = -3,",
          "",
          "---------------"
        ],
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3604:   return 0;",
          "3606:  if (count < event->read_size)",
          "",
          "[Removed Lines]",
          "3603:  if (event->state == PERF_EVENT_STATE_ERROR)",
          "",
          "[Added Lines]",
          "3603:  if ((event->state == PERF_EVENT_STATE_ERROR) ||",
          "3604:      (event->state == PERF_EVENT_STATE_EXIT))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3630:  unsigned int events = POLLHUP;",
          "3632:  poll_wait(file, &event->waitq, wait);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3635:  if (event->state == PERF_EVENT_STATE_EXIT)",
          "3636:   return events;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7588:  if (child_event->parent) {",
          "7589:   sync_child_event(child_event, child);",
          "7590:   free_event(child_event);",
          "7591:  }",
          "7592: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7596:  } else {",
          "7597:   child_event->state = PERF_EVENT_STATE_EXIT;",
          "7598:   perf_event_wakeup(child_event);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dc633982ff3f4fd74cdc11b5a6ae53d39a0b2451",
      "candidate_info": {
        "commit_hash": "dc633982ff3f4fd74cdc11b5a6ae53d39a0b2451",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/dc633982ff3f4fd74cdc11b5a6ae53d39a0b2451",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf: Do not POLLHUP event if it has children\n\nCurrently we return POLLHUP in event polling if the monitored\nprocess is done, but we didn't consider possible children,\nthat might be still running and producing data.\n\nBefore returning POLLHUP making sure that:\n\n   1) the monitored task has exited and that\n   2) we don't have any children to monitor\n\nAlso adding parent wakeup when the child event is gone.\n\nSuggested-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Jiri Olsa <jolsa@kernel.org>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nLink: http://lkml.kernel.org/r/1410520708-19275-1-git-send-email-jolsa@kernel.org\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3587:  return n * sizeof(u64);",
          "3588: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3590: static bool is_event_hup(struct perf_event *event)",
          "3591: {",
          "3592:  bool no_children;",
          "3594:  if (event->state != PERF_EVENT_STATE_EXIT)",
          "3595:   return false;",
          "3597:  mutex_lock(&event->child_mutex);",
          "3598:  no_children = list_empty(&event->child_list);",
          "3599:  mutex_unlock(&event->child_mutex);",
          "3600:  return no_children;",
          "3601: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3633:  poll_wait(file, &event->waitq, wait);",
          "3636:   return events;",
          "",
          "[Removed Lines]",
          "3635:  if (event->state == PERF_EVENT_STATE_EXIT)",
          "",
          "[Added Lines]",
          "3648:  if (is_event_hup(event))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7579:  list_del_init(&child_event->child_list);",
          "7580:  mutex_unlock(&parent_event->child_mutex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7599:  perf_event_wakeup(parent_event);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a83fe28e2e45392464858a96745db26ac73670c8",
      "candidate_info": {
        "commit_hash": "a83fe28e2e45392464858a96745db26ac73670c8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a83fe28e2e45392464858a96745db26ac73670c8",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf: Fix put_event() ctx lock\n\nSo what I suspect; but I'm in zombie mode today it seems; is that while\nI initially thought that it was impossible for ctx to change when\nrefcount dropped to 0, I now suspect its possible.\n\nNote that until perf_remove_from_context() the event is still active and\nvisible on the lists. So a concurrent sys_perf_event_open() from another\ntask into this task can race.\n\nReported-by: Vince Weaver <vincent.weaver@maine.edu>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Stephane Eranian <eranian@gmail.com>\nCc: mark.rutland@arm.com\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http://lkml.kernel.org/r/20150129134434.GB26304@twins.programming.kicks-ass.net\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "951: {",
          "952:  struct perf_event_context *ctx;",
          "",
          "[Removed Lines]",
          "950: static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)",
          "",
          "[Added Lines]",
          "950: static struct perf_event_context *",
          "951: perf_event_ctx_lock_nested(struct perf_event *event, int nesting)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "960:  }",
          "961:  rcu_read_unlock();",
          "964:  if (event->ctx != ctx) {",
          "965:   mutex_unlock(&ctx->mutex);",
          "966:   put_ctx(ctx);",
          "",
          "[Removed Lines]",
          "963:  mutex_lock(&ctx->mutex);",
          "",
          "[Added Lines]",
          "964:  mutex_lock_nested(&ctx->mutex, nesting);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "970:  return ctx;",
          "971: }",
          "973: static void perf_event_ctx_unlock(struct perf_event *event,",
          "974:       struct perf_event_context *ctx)",
          "975: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "974: static inline struct perf_event_context *",
          "975: perf_event_ctx_lock(struct perf_event *event)",
          "976: {",
          "977:  return perf_event_ctx_lock_nested(event, 0);",
          "978: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3573: static void put_event(struct perf_event *event)",
          "3574: {",
          "3577:  if (!atomic_long_dec_and_test(&event->refcount))",
          "3578:   return;",
          "",
          "[Removed Lines]",
          "3575:  struct perf_event_context *ctx = event->ctx;",
          "",
          "[Added Lines]",
          "3582:  struct perf_event_context *ctx;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3580:  if (!is_kernel_event(event))",
          "3581:   perf_remove_from_owner(event);",
          "",
          "[Removed Lines]",
          "3583:  WARN_ON_ONCE(ctx->parent_ctx);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3597:  perf_remove_from_context(event, true);",
          "3598:  mutex_unlock(&ctx->mutex);",
          "",
          "[Removed Lines]",
          "3596:  mutex_lock_nested(&ctx->mutex, SINGLE_DEPTH_NESTING);",
          "",
          "[Added Lines]",
          "3602:  ctx = perf_event_ctx_lock_nested(event, SINGLE_DEPTH_NESTING);",
          "3603:  WARN_ON_ONCE(ctx->parent_ctx);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-11096",
  "cve_desc": "In FreeRDP before version 2.1.2, there is a global OOB read in update_read_cache_bitmap_v3_order. As a workaround, one can disable bitmap cache with -bitmap-cache (default). This is fixed in version 2.1.2.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "b8beb55913471952f92770c90c372139d78c16c0",
  "patch_info": {
    "commit_hash": "b8beb55913471952f92770c90c372139d78c16c0",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/b8beb55913471952f92770c90c372139d78c16c0",
    "files": [
      "libfreerdp/core/orders.c"
    ],
    "message": "Fixed OOB read in update_read_cache_bitmap_v3_order\n\nCVE-2020-11096 thanks @antonio-morales for finding this.",
    "before_after_code_files": [
      "libfreerdp/core/orders.c||libfreerdp/core/orders.c"
    ]
  },
  "patch_diff": {
    "libfreerdp/core/orders.c||libfreerdp/core/orders.c": [
      "File: libfreerdp/core/orders.c -> libfreerdp/core/orders.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "113:  }",
      "114: }",
      "131: static BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,",
      "132:                                   BOOL condition)",
      "",
      "[Removed Lines]",
      "116: static const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };",
      "118: static const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,",
      "119:                               0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };",
      "121: static const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };",
      "123: static const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,",
      "124:                                0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };",
      "126: static const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };",
      "128: static const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,",
      "129:                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };",
      "",
      "[Added Lines]",
      "116: static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid)",
      "117: {",
      "118:  if (pValid)",
      "120:  switch (bpp)",
      "121:  {",
      "122:   case 3:",
      "123:    return 8;",
      "124:   case 4:",
      "125:    return 16;",
      "126:   case 5:",
      "127:    return 24;",
      "128:   case 6:",
      "129:    return 32;",
      "130:   default:",
      "131:    WLog_WARN(TAG, \"Invalid bpp %\" PRIu32, bpp);",
      "132:    if (pValid)",
      "134:    return 0;",
      "135:  }",
      "136: }",
      "138: static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid)",
      "139: {",
      "140:  if (pValid)",
      "142:  switch (bmf)",
      "143:  {",
      "144:   case 1:",
      "145:    return 1;",
      "146:   case 3:",
      "147:    return 8;",
      "148:   case 4:",
      "149:    return 16;",
      "150:   case 5:",
      "151:    return 24;",
      "152:   case 6:",
      "153:    return 32;",
      "154:   default:",
      "155:    WLog_WARN(TAG, \"Invalid bmf %\" PRIu32, bmf);",
      "156:    if (pValid)",
      "158:    return 0;",
      "159:  }",
      "160: }",
      "161: static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid)",
      "162: {",
      "163:  if (pValid)",
      "165:  switch (bpp)",
      "166:  {",
      "167:   case 1:",
      "168:    return 1;",
      "169:   case 8:",
      "170:    return 3;",
      "171:   case 16:",
      "172:    return 4;",
      "173:   case 24:",
      "174:    return 5;",
      "175:   case 32:",
      "176:    return 6;",
      "177:   default:",
      "178:    WLog_WARN(TAG, \"Invalid color depth %\" PRIu32, bpp);",
      "179:    if (pValid)",
      "181:    return 0;",
      "182:  }",
      "183: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "815:  if (brush->style & CACHED_BRUSH)",
      "816:  {",
      "817:   brush->index = brush->hatch;",
      "820:   if (brush->bpp == 0)",
      "821:    brush->bpp = 1;",
      "822:  }",
      "",
      "[Removed Lines]",
      "818:   brush->bpp = BMF_BPP[brush->style & 0x07];",
      "",
      "[Added Lines]",
      "871:   BOOL rc;",
      "873:   brush->bpp = get_bmf_bpp(brush->style, &rc);",
      "874:   if (!rc)",
      "875:    return FALSE;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "859:  if (brush->style & CACHED_BRUSH)",
      "860:  {",
      "861:   brush->hatch = brush->index;",
      "864:   if (brush->bpp == 0)",
      "865:    brush->bpp = 1;",
      "866:  }",
      "",
      "[Removed Lines]",
      "862:   brush->bpp = BMF_BPP[brush->style & 0x07];",
      "",
      "[Added Lines]",
      "917:   BOOL rc;",
      "919:   brush->bpp = get_bmf_bpp(brush->style, &rc);",
      "920:   if (!rc)",
      "921:    return FALSE;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2016: static CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,",
      "2017:                                                                 BOOL compressed, UINT16 flags)",
      "2018: {",
      "2019:  BYTE bitsPerPixelId;",
      "2020:  CACHE_BITMAP_V2_ORDER* cache_bitmap_v2;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2077:  BOOL rc;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2030:  cache_bitmap_v2->cacheId = flags & 0x0003;",
      "2031:  cache_bitmap_v2->flags = (flags & 0xFF80) >> 7;",
      "2032:  bitsPerPixelId = (flags & 0x0078) >> 3;",
      "2035:  if (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)",
      "2036:  {",
      "",
      "[Removed Lines]",
      "2033:  cache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];",
      "",
      "[Added Lines]",
      "2092:  cache_bitmap_v2->bitmapBpp = get_cbr2_bpp(bitsPerPixelId, &rc);",
      "2093:  if (!rc)",
      "2094:   goto fail;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2109: BOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,",
      "2110:                                         BOOL compressed, UINT16* flags)",
      "2111: {",
      "2112:  BYTE bitsPerPixelId;",
      "2114:  if (!Stream_EnsureRemainingCapacity(",
      "2115:          s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))",
      "2116:   return FALSE;",
      "2120:           ((cache_bitmap_v2->flags << 7) & 0xFF80);",
      "",
      "[Removed Lines]",
      "2118:  bitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];",
      "",
      "[Added Lines]",
      "2173:  BOOL rc;",
      "2180:  bitsPerPixelId = get_bpp_bmf(cache_bitmap_v2->bitmapBpp, &rc);",
      "2181:  if (!rc)",
      "2182:   return FALSE;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2177: static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,",
      "2178:                                                                 UINT16 flags)",
      "2179: {",
      "2180:  BYTE bitsPerPixelId;",
      "2181:  BITMAP_DATA_EX* bitmapData;",
      "2182:  UINT32 new_len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2244:  BOOL rc;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2194:  cache_bitmap_v3->cacheId = flags & 0x00000003;",
      "2195:  cache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;",
      "2196:  bitsPerPixelId = (flags & 0x00000078) >> 3;",
      "2199:  if (Stream_GetRemainingLength(s) < 21)",
      "2200:   goto fail;",
      "",
      "[Removed Lines]",
      "2197:  cache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];",
      "",
      "[Added Lines]",
      "2262:  cache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);",
      "2263:  if (!rc)",
      "2264:   goto fail;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2242: BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,",
      "2243:                                         UINT16* flags)",
      "2244: {",
      "2245:  BYTE bitsPerPixelId;",
      "2246:  BITMAP_DATA_EX* bitmapData;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2312:  BOOL rc;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2250:   return FALSE;",
      "2252:  bitmapData = &cache_bitmap_v3->bitmapData;",
      "2255:           ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);",
      "",
      "[Removed Lines]",
      "2253:  bitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];",
      "",
      "[Added Lines]",
      "2321:  bitsPerPixelId = get_bpp_bmf(cache_bitmap_v3->bpp, &rc);",
      "2322:  if (!rc)",
      "2323:   return FALSE;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "2574: static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)",
      "2575: {",
      "2576:  int i;",
      "2577:  BYTE iBitmapFormat;",
      "2578:  BOOL compressed = FALSE;",
      "2579:  CACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2647:  BOOL rc;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "2591:   goto fail;",
      "",
      "[Removed Lines]",
      "2590:  if (iBitmapFormat >= ARRAYSIZE(BMF_BPP))",
      "2593:  cache_brush->bpp = BMF_BPP[iBitmapFormat];",
      "",
      "[Added Lines]",
      "2661:  cache_brush->bpp = get_bmf_bpp(iBitmapFormat, &rc);",
      "2662:  if (!rc)",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "2661: {",
      "2662:  int i;",
      "2663:  BYTE iBitmapFormat;",
      "2664:  BOOL compressed = FALSE;",
      "2666:  if (!Stream_EnsureRemainingCapacity(s,",
      "2667:                                      update_approximate_cache_brush_order(cache_brush, flags)))",
      "2668:   return FALSE;",
      "",
      "[Removed Lines]",
      "2670:  iBitmapFormat = BPP_BMF[cache_brush->bpp];",
      "",
      "[Added Lines]",
      "2735:  BOOL rc;",
      "2742:  iBitmapFormat = get_bpp_bmf(cache_brush->bpp, &rc);",
      "2743:  if (!rc)",
      "2744:   return FALSE;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0a98c450c58ec150e44781c89aa6f8e7e0f571f5",
      "candidate_info": {
        "commit_hash": "0a98c450c58ec150e44781c89aa6f8e7e0f571f5",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/0a98c450c58ec150e44781c89aa6f8e7e0f571f5",
        "files": [
          "libfreerdp/codec/include/bitmap.c"
        ],
        "message": "Fixed out of bound read in RLEDECOMPRESS\n\nCVE-2020-4033 thanks to @antonio-morales for finding this.",
        "before_after_code_files": [
          "libfreerdp/codec/include/bitmap.c||libfreerdp/codec/include/bitmap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/include/bitmap.c||libfreerdp/codec/include/bitmap.c": [
          "File: libfreerdp/codec/include/bitmap.c -> libfreerdp/codec/include/bitmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202:     if (code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN)",
          "203:     {",
          "204:      SRCREADPIXEL(fgPel, pbSrc);",
          "205:      SRCNEXTPIXEL(pbSrc);",
          "206:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "204:      if (pbSrc >= pbEnd)",
          "205:       return FALSE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231:    case MEGA_MEGA_DITHERED_RUN:",
          "232:     runLength = ExtractRunLength(code, pbSrc, &advance);",
          "233:     pbSrc = pbSrc + advance;",
          "234:     SRCREADPIXEL(pixelA, pbSrc);",
          "235:     SRCNEXTPIXEL(pbSrc);",
          "236:     SRCREADPIXEL(pixelB, pbSrc);",
          "237:     SRCNEXTPIXEL(pbSrc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "236:     if (pbSrc >= pbEnd)",
          "237:      return FALSE;",
          "240:     if (pbSrc >= pbEnd)",
          "241:      return FALSE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "252:    case MEGA_MEGA_COLOR_RUN:",
          "253:     runLength = ExtractRunLength(code, pbSrc, &advance);",
          "254:     pbSrc = pbSrc + advance;",
          "255:     SRCREADPIXEL(pixelA, pbSrc);",
          "256:     SRCNEXTPIXEL(pbSrc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "261:     if (pbSrc >= pbEnd)",
          "262:      return FALSE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "272:     runLength = ExtractRunLength(code, pbSrc, &advance);",
          "273:     pbSrc = pbSrc + advance;",
          "275:     if (code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE)",
          "276:     {",
          "277:      SRCREADPIXEL(fgPel, pbSrc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283:     if (pbSrc >= pbEnd)",
          "284:      return FALSE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "338:      return FALSE;",
          "340:     UNROLL(runLength, {",
          "341:      SRCREADPIXEL(temp, pbSrc);",
          "342:      SRCNEXTPIXEL(pbSrc);",
          "343:      DESTWRITEPIXEL(pbDest, temp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:      if (pbSrc >= pbEnd)",
          "352:       return FALSE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ac7bb5d6a743b19e8686410d5ec6dcf74869ebe",
      "candidate_info": {
        "commit_hash": "3ac7bb5d6a743b19e8686410d5ec6dcf74869ebe",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/3ac7bb5d6a743b19e8686410d5ec6dcf74869ebe",
        "files": [
          "libfreerdp/utils/pcap.c"
        ],
        "message": "Fixed pcap cleanup",
        "before_after_code_files": [
          "libfreerdp/utils/pcap.c||libfreerdp/utils/pcap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/utils/pcap.c||libfreerdp/utils/pcap.c": [
          "File: libfreerdp/utils/pcap.c -> libfreerdp/utils/pcap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170: {",
          "171:  rdpPcap* pcap;",
          "181:  pcap = (rdpPcap*)calloc(1, sizeof(rdpPcap));",
          "182:  if (!pcap)",
          "185:  pcap->name = name;",
          "186:  pcap->write = write;",
          "187:  pcap->record_count = 0;",
          "190:  if (write)",
          "191:  {",
          "",
          "[Removed Lines]",
          "173:  FILE* pcap_fp = fopen(name, write ? \"w+b\" : \"rb\");",
          "175:  if (pcap_fp == NULL)",
          "176:  {",
          "177:   WLog_ERR(TAG, \"opening pcap dump\");",
          "178:   return NULL;",
          "179:  }",
          "183:   goto fail_close;",
          "188:  pcap->fp = pcap_fp;",
          "",
          "[Added Lines]",
          "175:   goto fail;",
          "180:  pcap->fp = fopen(name, write ? \"w+b\" : \"rb\");",
          "182:  if (pcap->fp == NULL)",
          "183:   goto fail;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "211:  return pcap;",
          "213: fail:",
          "217:  return NULL;",
          "218: }",
          "",
          "[Removed Lines]",
          "214:  free(pcap);",
          "215: fail_close:",
          "216:  fclose(pcap_fp);",
          "",
          "[Added Lines]",
          "209:  pcap_close(pcap);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232: void pcap_close(rdpPcap* pcap)",
          "233: {",
          "234:  pcap_flush(pcap);",
          "236:  if (pcap->fp != NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227:  if (!pcap)",
          "228:   return;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1c6a6923f87dcfb295c508963f21bebbbc4292ae",
      "candidate_info": {
        "commit_hash": "1c6a6923f87dcfb295c508963f21bebbbc4292ae",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/1c6a6923f87dcfb295c508963f21bebbbc4292ae",
        "files": [
          "channels/rdpdr/client/rdpdr_main.c"
        ],
        "message": "Fixed broken const variable.",
        "before_after_code_files": [
          "channels/rdpdr/client/rdpdr_main.c||channels/rdpdr/client/rdpdr_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/rdpdr/client/rdpdr_main.c||channels/rdpdr/client/rdpdr_main.c": [
          "File: channels/rdpdr/client/rdpdr_main.c -> channels/rdpdr/client/rdpdr_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "598:  size_t x;",
          "599:  char buffer[MAX_PATH];",
          "600:  uid_t uid = getuid();",
          "603:  if (getlogin_r(uname, sizeof(uname)) != 0)",
          "604:   return FALSE;",
          "",
          "[Removed Lines]",
          "601:  const char uname[MAX_PATH] = { 0 };",
          "",
          "[Added Lines]",
          "601:  char uname[MAX_PATH] = { 0 };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
      "candidate_info": {
        "commit_hash": "c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
        "files": [
          "libfreerdp/cache/glyph.c"
        ],
        "message": "Fixed Out-of-bound read in glyph_cache_put\n\nCVE-2020-11098 thanks to @antonio-morales for finding this.",
        "before_after_code_files": [
          "libfreerdp/cache/glyph.c||libfreerdp/cache/glyph.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/cache/glyph.c||libfreerdp/cache/glyph.c": [
          "File: libfreerdp/cache/glyph.c -> libfreerdp/cache/glyph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "579:   return FALSE;",
          "580:  }",
          "583:  {",
          "584:   WLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);",
          "585:   return FALSE;",
          "",
          "[Removed Lines]",
          "582:  if (index > glyphCache->glyphCache[id].number)",
          "",
          "[Added Lines]",
          "582:  if (index >= glyphCache->glyphCache[id].number)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58a3122250d54de3a944c487776bcd4d1da4721e",
      "candidate_info": {
        "commit_hash": "58a3122250d54de3a944c487776bcd4d1da4721e",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/58a3122250d54de3a944c487776bcd4d1da4721e",
        "files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c"
        ],
        "message": "Fixed OOB read in ntlm_av_pair_get\n\nCVE-2020-11097 thanks to @antonio-morales for finding this.",
        "before_after_code_files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c||winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c||winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c": [
          "File: winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c -> winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include \"../../log.h\"",
          "40: #define TAG WINPR_TAG(\"sspi.NTLM\")",
          "49: static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPairList, size_t* pcbAvPairList);",
          "51: static INLINE void ntlm_av_pair_set_id(NTLM_AV_PAIR* pAvPair, UINT16 id)",
          "",
          "[Removed Lines]",
          "42: static const char* const AV_PAIR_STRINGS[] = {",
          "43:  \"MsvAvEOL\",           \"MsvAvNbComputerName\", \"MsvAvNbDomainName\", \"MsvAvDnsComputerName\",",
          "44:  \"MsvAvDnsDomainName\", \"MsvAvDnsTreeName\",    \"MsvAvFlags\",        \"MsvAvTimestamp\",",
          "45:  \"MsvAvRestrictions\",  \"MsvAvTargetName\",     \"MsvChannelBindings\"",
          "46: };",
          "48: static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair);",
          "",
          "[Added Lines]",
          "42: static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset);",
          "44: static BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair, size_t size)",
          "45: {",
          "46:  size_t offset;",
          "47:  if (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR) + size)",
          "48:   return FALSE;",
          "49:  if (!ntlm_av_pair_get_next_offset(pAvPair, cbAvPair, &offset))",
          "50:   return FALSE;",
          "51:  return cbAvPair >= offset;",
          "52: }",
          "54: static const char* get_av_pair_string(UINT16 pair)",
          "55: {",
          "56:  switch (pair)",
          "57:  {",
          "58:   case MsvAvEOL:",
          "59:    return \"MsvAvEOL\";",
          "60:   case MsvAvNbComputerName:",
          "61:    return \"MsvAvNbComputerName\";",
          "62:   case MsvAvNbDomainName:",
          "63:    return \"MsvAvNbDomainName\";",
          "64:   case MsvAvDnsComputerName:",
          "65:    return \"MsvAvDnsComputerName\";",
          "66:   case MsvAvDnsDomainName:",
          "67:    return \"MsvAvDnsDomainName\";",
          "68:   case MsvAvDnsTreeName:",
          "69:    return \"MsvAvDnsTreeName\";",
          "70:   case MsvAvFlags:",
          "71:    return \"MsvAvFlags\";",
          "72:   case MsvAvTimestamp:",
          "73:    return \"MsvAvTimestamp\";",
          "74:   case MsvAvSingleHost:",
          "75:    return \"MsvAvSingleHost\";",
          "76:   case MsvAvTargetName:",
          "77:    return \"MsvAvTargetName\";",
          "78:   case MsvChannelBindings:",
          "79:    return \"MsvChannelBindings\";",
          "80:   default:",
          "81:    return \"UNKNOWN\";",
          "82:  }",
          "83: }",
          "85: static BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:  return TRUE;",
          "71: }",
          "74: {",
          "75:  UINT16 AvId;",
          "77:  Data_Read_UINT16(&pAvPair->AvId, AvId);",
          "80: }",
          "82: ULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)",
          "",
          "[Removed Lines]",
          "73: static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)",
          "79:  return AvId;",
          "",
          "[Added Lines]",
          "110: static INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair)",
          "113:  if (!pAvPair || !pair)",
          "114:   return FALSE;",
          "116:  if (size < sizeof(NTLM_AV_PAIR))",
          "117:   return FALSE;",
          "122:  return TRUE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "91:  return ((PBYTE)pAvPair - (PBYTE)pAvPairList) + sizeof(NTLM_AV_PAIR);",
          "92: }",
          "95: {",
          "96:  UINT16 AvLen;",
          "98:  Data_Read_UINT16(&pAvPair->AvLen, AvLen);",
          "101: }",
          "103: void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)",
          "104: {",
          "105:  size_t cbAvPair = cbAvPairList;",
          "106:  NTLM_AV_PAIR* pAvPair = pAvPairList;",
          "",
          "[Removed Lines]",
          "94: static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)",
          "100:  return AvLen;",
          "",
          "[Added Lines]",
          "137: static INLINE BOOL ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pAvLen)",
          "140:  if (!pAvPair)",
          "141:   return FALSE;",
          "143:  if (size < sizeof(NTLM_AV_PAIR))",
          "144:   return FALSE;",
          "149:  return TRUE;",
          "154:  UINT16 pair;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:  WLog_INFO(TAG, \"AV_PAIRs =\");",
          "114:  {",
          "121:   pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);",
          "122:  }",
          "",
          "[Removed Lines]",
          "113:  while (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)",
          "115:   WLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\",",
          "116:             AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),",
          "117:             ntlm_av_pair_get_len(pAvPair));",
          "118:   winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),",
          "119:                 ntlm_av_pair_get_len(pAvPair));",
          "",
          "[Added Lines]",
          "163:  while (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair) && (pair != MsvAvEOL))",
          "165:   size_t cbLen = 0;",
          "166:   ntlm_av_pair_get_len(pAvPair, cbAvPair, &cbLen);",
          "168:   WLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\", get_av_pair_string(pair), pair);",
          "169:   winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair), cbLen);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:  return (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);",
          "134: }",
          "137: {",
          "139: }",
          "142: {",
          "146: }",
          "148: static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)",
          "",
          "[Removed Lines]",
          "136: static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)",
          "138:  return ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);",
          "141: static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)",
          "143:  if (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))",
          "144:   return FALSE;",
          "145:  return cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);",
          "",
          "[Added Lines]",
          "186: static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)",
          "188:  size_t avLen;",
          "189:  if (!pOffset)",
          "190:   return FALSE;",
          "192:  if (!ntlm_av_pair_get_len(pAvPair, size, &avLen))",
          "193:   return FALSE;",
          "195:  return TRUE;",
          "198: static BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair)",
          "200:  return ntlm_av_pair_check_data(pAvPair, cbAvPair, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "154:  if (!ntlm_av_pair_check(pAvPair, *pcbAvPair))",
          "155:   return NULL;",
          "159:  return (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);",
          "160: }",
          "",
          "[Removed Lines]",
          "157:  offset = ntlm_av_pair_get_next_offset(pAvPair);",
          "",
          "[Added Lines]",
          "212:  if (!ntlm_av_pair_get_next_offset(pAvPair, *pcbAvPair, &offset))",
          "213:   return NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "162: NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,",
          "163:                                size_t* pcbAvPairListRemaining)",
          "164: {",
          "165:  size_t cbAvPair = cbAvPairList;",
          "166:  NTLM_AV_PAIR* pAvPair = pAvPairList;",
          "168:  if (!ntlm_av_pair_check(pAvPair, cbAvPair))",
          "169:   pAvPair = NULL;",
          "172:  {",
          "175:   if (id == AvId)",
          "176:    break;",
          "177:   if (id == MsvAvEOL)",
          "",
          "[Removed Lines]",
          "171:  while (pAvPair)",
          "173:   UINT16 id = ntlm_av_pair_get_id(pAvPair);",
          "",
          "[Added Lines]",
          "222:  UINT16 id;",
          "229:  while (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "218: static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,",
          "219:                                   NTLM_AV_PAIR* pAvPair, size_t cbAvPair)",
          "220: {",
          "221:  if (!ntlm_av_pair_check(pAvPair, cbAvPair))",
          "222:   return FALSE;",
          "226: }",
          "228: static int ntlm_get_target_computer_name(PUNICODE_STRING pName, COMPUTER_NAME_FORMAT type)",
          "",
          "[Removed Lines]",
          "224:  return ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),",
          "225:                          ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));",
          "",
          "[Added Lines]",
          "277:  UINT16 pair;",
          "278:  size_t avLen;",
          "283:  if (!ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair))",
          "284:   return FALSE;",
          "286:  if (!ntlm_av_pair_get_len(pAvPair, cbAvPair, &avLen))",
          "287:   return FALSE;",
          "289:  return ntlm_av_pair_add(pAvPairList, cbAvPairList, pair,",
          "290:                          ntlm_av_pair_get_value_pointer(pAvPair), avLen);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "501:  if (AvNbDomainName)",
          "502:  {",
          "505:  }",
          "507:  if (AvNbComputerName)",
          "508:  {",
          "511:  }",
          "513:  if (AvDnsDomainName)",
          "514:  {",
          "517:  }",
          "519:  if (AvDnsComputerName)",
          "520:  {",
          "523:  }",
          "525:  if (AvDnsTreeName)",
          "526:  {",
          "529:  }",
          "",
          "[Removed Lines]",
          "504:   AvPairsValueLength += ntlm_av_pair_get_len(AvNbDomainName);",
          "510:   AvPairsValueLength += ntlm_av_pair_get_len(AvNbComputerName);",
          "516:   AvPairsValueLength += ntlm_av_pair_get_len(AvDnsDomainName);",
          "522:   AvPairsValueLength += ntlm_av_pair_get_len(AvDnsComputerName);",
          "528:   AvPairsValueLength += ntlm_av_pair_get_len(AvDnsTreeName);",
          "",
          "[Added Lines]",
          "568:   size_t avLen;",
          "569:   if (!ntlm_av_pair_get_len(AvNbDomainName, cbAvNbDomainName, &avLen))",
          "570:    goto fail;",
          "572:   AvPairsValueLength += avLen;",
          "577:   size_t avLen;",
          "578:   if (!ntlm_av_pair_get_len(AvNbComputerName, cbAvNbComputerName, &avLen))",
          "579:    goto fail;",
          "581:   AvPairsValueLength += avLen;",
          "586:   size_t avLen;",
          "587:   if (!ntlm_av_pair_get_len(AvDnsDomainName, cbAvDnsDomainName, &avLen))",
          "588:    goto fail;",
          "590:   AvPairsValueLength += avLen;",
          "595:   size_t avLen;",
          "596:   if (!ntlm_av_pair_get_len(AvDnsComputerName, cbAvDnsComputerName, &avLen))",
          "597:    goto fail;",
          "599:   AvPairsValueLength += avLen;",
          "604:   size_t avLen;",
          "605:   if (!ntlm_av_pair_get_len(AvDnsTreeName, cbAvDnsTreeName, &avLen))",
          "606:    goto fail;",
          "608:   AvPairsValueLength += avLen;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
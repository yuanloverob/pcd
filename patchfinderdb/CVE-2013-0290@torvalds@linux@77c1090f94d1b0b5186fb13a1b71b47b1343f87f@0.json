{
  "cve_id": "CVE-2013-0290",
  "cve_desc": "The __skb_recv_datagram function in net/core/datagram.c in the Linux kernel before 3.8 does not properly handle the MSG_PEEK flag with zero-length data, which allows local users to cause a denial of service (infinite loop and system hang) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "77c1090f94d1b0b5186fb13a1b71b47b1343f87f",
  "patch_info": {
    "commit_hash": "77c1090f94d1b0b5186fb13a1b71b47b1343f87f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/77c1090f94d1b0b5186fb13a1b71b47b1343f87f",
    "files": [
      "net/core/datagram.c"
    ],
    "message": "net: fix infinite loop in __skb_recv_datagram()\n\nTommi was fuzzing with trinity and reported the following problem :\n\ncommit 3f518bf745 (datagram: Add offset argument to __skb_recv_datagram)\nmissed that a raw socket receive queue can contain skbs with no payload.\n\nWe can loop in __skb_recv_datagram() with MSG_PEEK mode, because\nwait_for_packet() is not prepared to skip these skbs.\n\n[   83.541011] INFO: rcu_sched detected stalls on CPUs/tasks: {}\n(detected by 0, t=26002 jiffies, g=27673, c=27672, q=75)\n[   83.541011] INFO: Stall ended before state dump start\n[  108.067010] BUG: soft lockup - CPU#0 stuck for 22s! [trinity-child31:2847]\n...\n[  108.067010] Call Trace:\n[  108.067010]  [<ffffffff818cc103>] __skb_recv_datagram+0x1a3/0x3b0\n[  108.067010]  [<ffffffff818cc33d>] skb_recv_datagram+0x2d/0x30\n[  108.067010]  [<ffffffff819ed43d>] rawv6_recvmsg+0xad/0x240\n[  108.067010]  [<ffffffff818c4b04>] sock_common_recvmsg+0x34/0x50\n[  108.067010]  [<ffffffff818bc8ec>] sock_recvmsg+0xbc/0xf0\n[  108.067010]  [<ffffffff818bf31e>] sys_recvfrom+0xde/0x150\n[  108.067010]  [<ffffffff81ca4329>] system_call_fastpath+0x16/0x1b\n\nReported-by: Tommi Rantala <tt.rantala@gmail.com>\nTested-by: Tommi Rantala <tt.rantala@gmail.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Pavel Emelyanov <xemul@parallels.com>\nAcked-by: Pavel Emelyanov <xemul@parallels.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/core/datagram.c||net/core/datagram.c"
    ]
  },
  "patch_diff": {
    "net/core/datagram.c||net/core/datagram.c": [
      "File: net/core/datagram.c -> net/core/datagram.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "187:   skb_queue_walk(queue, skb) {",
      "189:    if (flags & MSG_PEEK) {",
      "192:      continue;",
      "193:     }",
      "",
      "[Removed Lines]",
      "190:     if (*off >= skb->len) {",
      "",
      "[Added Lines]",
      "190:     if (*off >= skb->len && skb->len) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "633dc92a28fc3fea6f08ef34de0b353ff5f9bf08",
      "candidate_info": {
        "commit_hash": "633dc92a28fc3fea6f08ef34de0b353ff5f9bf08",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/633dc92a28fc3fea6f08ef34de0b353ff5f9bf08",
        "files": [
          "arch/arm/mm/dma-mapping.c"
        ],
        "message": "ARM: DMA mapping: fix bad atomic test\n\nRealview fails to boot with this warning:\nBUG: spinlock lockup suspected on CPU#0, init/1\n lock: 0xcf8bde10, .magic: dead4ead, .owner: init/1, .owner_cpu: 0\nBacktrace:\n[<c00185d8>] (dump_backtrace+0x0/0x10c) from [<c03294e8>] (dump_stack+0x18/0x1c) r6:cf8bde10 r5:cf83d1c0 r4:cf8bde10 r3:cf83d1c0\n[<c03294d0>] (dump_stack+0x0/0x1c) from [<c018926c>] (spin_dump+0x84/0x98)\n[<c01891e8>] (spin_dump+0x0/0x98) from [<c0189460>] (do_raw_spin_lock+0x100/0x198)\n[<c0189360>] (do_raw_spin_lock+0x0/0x198) from [<c032cbac>] (_raw_spin_lock+0x3c/0x44)\n[<c032cb70>] (_raw_spin_lock+0x0/0x44) from [<c01c9224>] (pl011_console_write+0xe8/0x11c)\n[<c01c913c>] (pl011_console_write+0x0/0x11c) from [<c002aea8>] (call_console_drivers.clone.7+0xdc/0x104)\n[<c002adcc>] (call_console_drivers.clone.7+0x0/0x104) from [<c002b320>] (console_unlock+0x2e8/0x454)\n[<c002b038>] (console_unlock+0x0/0x454) from [<c002b8b4>] (vprintk_emit+0x2d8/0x594)\n[<c002b5dc>] (vprintk_emit+0x0/0x594) from [<c0329718>] (printk+0x3c/0x44)\n[<c03296dc>] (printk+0x0/0x44) from [<c002929c>] (warn_slowpath_common+0x28/0x6c)\n[<c0029274>] (warn_slowpath_common+0x0/0x6c) from [<c0029304>] (warn_slowpath_null+0x24/0x2c)\n[<c00292e0>] (warn_slowpath_null+0x0/0x2c) from [<c0070ab0>] (lockdep_trace_alloc+0xd8/0xf0)\n[<c00709d8>] (lockdep_trace_alloc+0x0/0xf0) from [<c00c0850>] (kmem_cache_alloc+0x24/0x11c)\n[<c00c082c>] (kmem_cache_alloc+0x0/0x11c) from [<c00bb044>] (__get_vm_area_node.clone.24+0x7c/0x16c)\n[<c00bafc8>] (__get_vm_area_node.clone.24+0x0/0x16c) from [<c00bb7b8>] (get_vm_area_caller+0x48/0x54)\n[<c00bb770>] (get_vm_area_caller+0x0/0x54) from [<c0020064>] (__alloc_remap_buffer.clone.15+0x38/0xb8)\n[<c002002c>] (__alloc_remap_buffer.clone.15+0x0/0xb8) from [<c0020244>] (__dma_alloc+0x160/0x2c8)\n[<c00200e4>] (__dma_alloc+0x0/0x2c8) from [<c00204d8>] (arm_dma_alloc+0x88/0xa0)[<c0020450>] (arm_dma_alloc+0x0/0xa0) from [<c00beb00>] (dma_pool_alloc+0xcc/0x1a8)\n[<c00bea34>] (dma_pool_alloc+0x0/0x1a8) from [<c01a9d14>] (pl08x_fill_llis_for_desc+0x28/0x568)\n[<c01a9cec>] (pl08x_fill_llis_for_desc+0x0/0x568) from [<c01aab8c>] (pl08x_prep_slave_sg+0x258/0x3b0)\n[<c01aa934>] (pl08x_prep_slave_sg+0x0/0x3b0) from [<c01c9f74>] (pl011_dma_tx_refill+0x140/0x288)\n[<c01c9e34>] (pl011_dma_tx_refill+0x0/0x288) from [<c01ca748>] (pl011_start_tx+0xe4/0x120)\n[<c01ca664>] (pl011_start_tx+0x0/0x120) from [<c01c54a4>] (__uart_start+0x48/0x4c)\n[<c01c545c>] (__uart_start+0x0/0x4c) from [<c01c632c>] (uart_start+0x2c/0x3c)\n[<c01c6300>] (uart_start+0x0/0x3c) from [<c01c795c>] (uart_write+0xcc/0xf4)\n[<c01c7890>] (uart_write+0x0/0xf4) from [<c01b0384>] (n_tty_write+0x1c0/0x3e4)\n[<c01b01c4>] (n_tty_write+0x0/0x3e4) from [<c01acfe8>] (tty_write+0x144/0x240)\n[<c01acea4>] (tty_write+0x0/0x240) from [<c01ad17c>] (redirected_tty_write+0x98/0xac)\n[<c01ad0e4>] (redirected_tty_write+0x0/0xac) from [<c00c371c>] (vfs_write+0xbc/0x150)\n[<c00c3660>] (vfs_write+0x0/0x150) from [<c00c39c0>] (sys_write+0x4c/0x78)\n[<c00c3974>] (sys_write+0x0/0x78) from [<c0014460>] (ret_fast_syscall+0x0/0x3c)\n\nThis happens because the DMA allocation code is not respecting atomic\nallocations correctly.\n\nGFP flags should not be tested for GFP_ATOMIC to determine if an\natomic allocation is being requested.  GFP_ATOMIC is not a flag but\na value.  The GFP bitmask flags are all prefixed with __GFP_.\n\nThe rest of the kernel tests for __GFP_WAIT not being set to indicate\nan atomic allocation.  We need to do the same.\n\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>",
        "before_after_code_files": [
          "arch/arm/mm/dma-mapping.c||arch/arm/mm/dma-mapping.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm/mm/dma-mapping.c||arch/arm/mm/dma-mapping.c": [
          "File: arch/arm/mm/dma-mapping.c -> arch/arm/mm/dma-mapping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "641:  if (is_coherent || nommu())",
          "642:   addr = __alloc_simple_buffer(dev, size, gfp, &page);",
          "644:   addr = __alloc_from_pool(size, &page);",
          "645:  else if (!IS_ENABLED(CONFIG_CMA))",
          "646:   addr = __alloc_remap_buffer(dev, size, gfp, prot, &page, caller);",
          "",
          "[Removed Lines]",
          "643:  else if (gfp & GFP_ATOMIC)",
          "",
          "[Added Lines]",
          "643:  else if (!(gfp & __GFP_WAIT))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39cc86130bc045d87f525ce7742da308ff757cec",
      "candidate_info": {
        "commit_hash": "39cc86130bc045d87f525ce7742da308ff757cec",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/39cc86130bc045d87f525ce7742da308ff757cec",
        "files": [
          "net/core/datagram.c"
        ],
        "message": "unix/dgram: fix peeking with an offset larger than data in queue\n\nCurrently, peeking on a unix datagram socket with an offset larger than len of\nthe data in the sk receive queue returns immediately with bogus data. That's\nbecause *off is not reset between each skb_queue_walk().\n\nThis patch fixes this so that the behavior is the same as peeking with no\noffset on an empty queue: the caller blocks.\n\nSigned-off-by: Benjamin Poirier <bpoirier@suse.de>\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/core/datagram.c||net/core/datagram.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/datagram.c||net/core/datagram.c"
          ],
          "candidate": [
            "net/core/datagram.c||net/core/datagram.c"
          ]
        }
      },
      "candidate_diff": {
        "net/core/datagram.c||net/core/datagram.c": [
          "File: net/core/datagram.c -> net/core/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:  return autoremove_wake_function(wait, mode, sync, key);",
          "79: }",
          "84: {",
          "85:  int error;",
          "86:  DEFINE_WAIT_FUNC(wait, receiver_wake_function);",
          "",
          "[Removed Lines]",
          "83: static int wait_for_packet(struct sock *sk, int *err, long *timeo_p)",
          "",
          "[Added Lines]",
          "83: static int wait_for_more_packets(struct sock *sk, int *err, long *timeo_p,",
          "84:      const struct sk_buff *skb)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92:  if (error)",
          "93:   goto out_err;",
          "96:   goto out;",
          "",
          "[Removed Lines]",
          "95:  if (!skb_queue_empty(&sk->sk_receive_queue))",
          "",
          "[Added Lines]",
          "96:  if (sk->sk_receive_queue.prev != skb)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "161: struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,",
          "162:         int *peeked, int *off, int *err)",
          "163: {",
          "165:  long timeo;",
          "",
          "[Removed Lines]",
          "164:  struct sk_buff *skb;",
          "",
          "[Added Lines]",
          "165:  struct sk_buff *skb, *last;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "183:   unsigned long cpu_flags;",
          "184:   struct sk_buff_head *queue = &sk->sk_receive_queue;",
          "186:   spin_lock_irqsave(&queue->lock, cpu_flags);",
          "187:   skb_queue_walk(queue, skb) {",
          "189:    if (flags & MSG_PEEK) {",
          "191:         skb->peeked)) {",
          "193:      continue;",
          "194:     }",
          "195:     skb->peeked = 1;",
          "",
          "[Removed Lines]",
          "190:     if (*off >= skb->len && (skb->len || *off ||",
          "",
          "[Added Lines]",
          "186:   int _off = *off;",
          "188:   last = (struct sk_buff *)queue;",
          "191:    last = skb;",
          "194:     if (_off >= skb->len && (skb->len || _off ||",
          "196:      _off -= skb->len;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "207:   if (!timeo)",
          "208:    goto no_packet;",
          "212:  return NULL;",
          "",
          "[Removed Lines]",
          "210:  } while (!wait_for_packet(sk, err, &timeo));",
          "",
          "[Added Lines]",
          "215:  } while (!wait_for_more_packets(sk, err, &timeo, last));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3f518bf745cbd6007d8069100fb9cb09e960c872",
      "candidate_info": {
        "commit_hash": "3f518bf745cbd6007d8069100fb9cb09e960c872",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3f518bf745cbd6007d8069100fb9cb09e960c872",
        "files": [
          "include/linux/skbuff.h",
          "net/core/datagram.c",
          "net/ipv4/udp.c",
          "net/ipv6/udp.c"
        ],
        "message": "datagram: Add offset argument to __skb_recv_datagram\n\nThis one is only considered for MSG_PEEK flag and the value pointed by\nit specifies where to start peeking bytes from. If the offset happens to\npoint into the middle of the returned skb, the offset within this skb is\nput back to this very argument.\n\nSigned-off-by: Pavel Emelyanov <xemul@parallels.com>\nAcked-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/skbuff.h||include/linux/skbuff.h",
          "net/core/datagram.c||net/core/datagram.c",
          "net/ipv4/udp.c||net/ipv4/udp.c",
          "net/ipv6/udp.c||net/ipv6/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/datagram.c||net/core/datagram.c"
          ],
          "candidate": [
            "net/core/datagram.c||net/core/datagram.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/skbuff.h||include/linux/skbuff.h": [
          "File: include/linux/skbuff.h -> include/linux/skbuff.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2046:  for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)",
          "2048: extern struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,",
          "2050: extern struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,",
          "2051:       int noblock, int *err);",
          "2052: extern unsigned int    datagram_poll(struct file *file, struct socket *sock,",
          "",
          "[Removed Lines]",
          "2049:         int *peeked, int *err);",
          "",
          "[Added Lines]",
          "2049:         int *peeked, int *off, int *err);",
          "",
          "---------------"
        ],
        "net/core/datagram.c||net/core/datagram.c": [
          "File: net/core/datagram.c -> net/core/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "160: struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,",
          "162: {",
          "163:  struct sk_buff *skb;",
          "164:  long timeo;",
          "",
          "[Removed Lines]",
          "161:         int *peeked, int *err)",
          "",
          "[Added Lines]",
          "163:         int *peeked, int *off, int *err)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "183:   struct sk_buff_head *queue = &sk->sk_receive_queue;",
          "185:   spin_lock_irqsave(&queue->lock, cpu_flags);",
          "189:    if (flags & MSG_PEEK) {",
          "190:     skb->peeked = 1;",
          "191:     atomic_inc(&skb->users);",
          "192:    } else",
          "193:     __skb_unlink(skb, queue);",
          "198:    return skb;",
          "201:   error = -EAGAIN;",
          "",
          "[Removed Lines]",
          "186:   skb = skb_peek(queue);",
          "187:   if (skb) {",
          "194:   }",
          "195:   spin_unlock_irqrestore(&queue->lock, cpu_flags);",
          "197:   if (skb)",
          "",
          "[Added Lines]",
          "188:   skb_queue_walk(queue, skb) {",
          "191:     if (*off >= skb->len) {",
          "193:      continue;",
          "194:     }",
          "200:    spin_unlock_irqrestore(&queue->lock, cpu_flags);",
          "202:   }",
          "203:   spin_unlock_irqrestore(&queue->lock, cpu_flags);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "215: struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,",
          "216:       int noblock, int *err)",
          "217: {",
          "220:  return __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),",
          "222: }",
          "223: EXPORT_SYMBOL(skb_recv_datagram);",
          "",
          "[Removed Lines]",
          "218:  int peeked;",
          "221:        &peeked, err);",
          "",
          "[Added Lines]",
          "223:  int peeked, off = 0;",
          "226:        &peeked, &off, err);",
          "",
          "---------------"
        ],
        "net/ipv4/udp.c||net/ipv4/udp.c": [
          "File: net/ipv4/udp.c -> net/ipv4/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1167:  struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;",
          "1168:  struct sk_buff *skb;",
          "1169:  unsigned int ulen, copied;",
          "1171:  int err;",
          "1172:  int is_udplite = IS_UDPLITE(sk);",
          "1173:  bool slow;",
          "",
          "[Removed Lines]",
          "1170:  int peeked;",
          "",
          "[Added Lines]",
          "1170:  int peeked, off = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1184: try_again:",
          "1185:  skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),",
          "1187:  if (!skb)",
          "1188:   goto out;",
          "",
          "[Removed Lines]",
          "1186:       &peeked, &err);",
          "",
          "[Added Lines]",
          "1186:       &peeked, &off, &err);",
          "",
          "---------------"
        ],
        "net/ipv6/udp.c||net/ipv6/udp.c": [
          "File: net/ipv6/udp.c -> net/ipv6/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "342:  struct inet_sock *inet = inet_sk(sk);",
          "343:  struct sk_buff *skb;",
          "344:  unsigned int ulen, copied;",
          "346:  int err;",
          "347:  int is_udplite = IS_UDPLITE(sk);",
          "348:  int is_udp4;",
          "",
          "[Removed Lines]",
          "345:  int peeked;",
          "",
          "[Added Lines]",
          "345:  int peeked, off = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "360: try_again:",
          "361:  skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),",
          "363:  if (!skb)",
          "364:   goto out;",
          "",
          "[Removed Lines]",
          "362:       &peeked, &err);",
          "",
          "[Added Lines]",
          "362:       &peeked, &off, &err);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "add05ad4e9f5c4efee9b98535db5efa32b0d0492",
      "candidate_info": {
        "commit_hash": "add05ad4e9f5c4efee9b98535db5efa32b0d0492",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/add05ad4e9f5c4efee9b98535db5efa32b0d0492",
        "files": [
          "net/core/datagram.c"
        ],
        "message": "unix/dgram: peek beyond 0-sized skbs\n\n\"77c1090 net: fix infinite loop in __skb_recv_datagram()\" (v3.8) introduced a\nregression:\nAfter that commit, recv can no longer peek beyond a 0-sized skb in the queue.\n__skb_recv_datagram() instead stops at the first skb with len == 0 and results\nin the system call failing with -EFAULT via skb_copy_datagram_iovec().\n\nWhen peeking at an offset with 0-sized skb(s), each one of those is received\nonly once, in sequence. The offset starts moving forward again after receiving\ndatagrams with len > 0.\n\nSigned-off-by: Benjamin Poirier <bpoirier@suse.de>\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/core/datagram.c||net/core/datagram.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/datagram.c||net/core/datagram.c"
          ],
          "candidate": [
            "net/core/datagram.c||net/core/datagram.c"
          ]
        }
      },
      "candidate_diff": {
        "net/core/datagram.c||net/core/datagram.c": [
          "File: net/core/datagram.c -> net/core/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:   skb_queue_walk(queue, skb) {",
          "189:    if (flags & MSG_PEEK) {",
          "192:      continue;",
          "193:     }",
          "",
          "[Removed Lines]",
          "190:     if (*off >= skb->len && skb->len) {",
          "",
          "[Added Lines]",
          "190:     if (*off >= skb->len && (skb->len || *off ||",
          "191:         skb->peeked)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
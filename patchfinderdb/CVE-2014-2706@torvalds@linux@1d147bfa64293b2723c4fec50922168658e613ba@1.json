{
  "cve_id": "CVE-2014-2706",
  "cve_desc": "Race condition in the mac80211 subsystem in the Linux kernel before 3.13.7 allows remote attackers to cause a denial of service (system crash) via network traffic that improperly interacts with the WLAN_STA_PS_STA state (aka power-save mode), related to sta_info.c and tx.c.",
  "repo": "torvalds/linux",
  "patch_hash": "1d147bfa64293b2723c4fec50922168658e613ba",
  "patch_info": {
    "commit_hash": "1d147bfa64293b2723c4fec50922168658e613ba",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba",
    "files": [
      "net/mac80211/sta_info.c",
      "net/mac80211/sta_info.h",
      "net/mac80211/tx.c"
    ],
    "message": "mac80211: fix AP powersave TX vs. wakeup race\n\nThere is a race between the TX path and the STA wakeup: while\na station is sleeping, mac80211 buffers frames until it wakes\nup, then the frames are transmitted. However, the RX and TX\npath are concurrent, so the packet indicating wakeup can be\nprocessed while a packet is being transmitted.\n\nThis can lead to a situation where the buffered frames list\nis emptied on the one side, while a frame is being added on\nthe other side, as the station is still seen as sleeping in\nthe TX path.\n\nAs a result, the newly added frame will not be send anytime\nsoon. It might be sent much later (and out of order) when the\nstation goes to sleep and wakes up the next time.\n\nAdditionally, it can lead to the crash below.\n\nFix all this by synchronising both paths with a new lock.\nBoth path are not fastpath since they handle PS situations.\n\nIn a later patch we'll remove the extra skb queue locks to\nreduce locking overhead.\n\nBUG: unable to handle kernel\nNULL pointer dereference at 000000b0\nIP: [<ff6f1791>] ieee80211_report_used_skb+0x11/0x3e0 [mac80211]\n*pde = 00000000\nOops: 0000 [#1] SMP DEBUG_PAGEALLOC\nEIP: 0060:[<ff6f1791>] EFLAGS: 00210282 CPU: 1\nEIP is at ieee80211_report_used_skb+0x11/0x3e0 [mac80211]\nEAX: e5900da0 EBX: 00000000 ECX: 00000001 EDX: 00000000\nESI: e41d00c0 EDI: e5900da0 EBP: ebe458e4 ESP: ebe458b0\n DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068\nCR0: 8005003b CR2: 000000b0 CR3: 25a78000 CR4: 000407d0\nDR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\nDR6: ffff0ff0 DR7: 00000400\nProcess iperf (pid: 3934, ti=ebe44000 task=e757c0b0 task.ti=ebe44000)\niwlwifi 0000:02:00.0: I iwl_pcie_enqueue_hcmd Sending command LQ_CMD (#4e), seq: 0x0903, 92 bytes at 3[3]:9\nStack:\n e403b32c ebe458c4 00200002 00200286 e403b338 ebe458cc c10960bb e5900da0\n ff76a6ec ebe458d8 00000000 e41d00c0 e5900da0 ebe458f0 ff6f1b75 e403b210\n ebe4598c ff723dc1 00000000 ff76a6ec e597c978 e403b758 00000002 00000002\nCall Trace:\n [<ff6f1b75>] ieee80211_free_txskb+0x15/0x20 [mac80211]\n [<ff723dc1>] invoke_tx_handlers+0x1661/0x1780 [mac80211]\n [<ff7248a5>] ieee80211_tx+0x75/0x100 [mac80211]\n [<ff7249bf>] ieee80211_xmit+0x8f/0xc0 [mac80211]\n [<ff72550e>] ieee80211_subif_start_xmit+0x4fe/0xe20 [mac80211]\n [<c149ef70>] dev_hard_start_xmit+0x450/0x950\n [<c14b9aa9>] sch_direct_xmit+0xa9/0x250\n [<c14b9c9b>] __qdisc_run+0x4b/0x150\n [<c149f732>] dev_queue_xmit+0x2c2/0xca0\n\nCc: stable@vger.kernel.org\nReported-by: Yaara Rozenblum <yaara.rozenblum@intel.com>\nSigned-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>\nReviewed-by: Stanislaw Gruszka <sgruszka@redhat.com>\n[reword commit log, use a separate lock]\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
    "before_after_code_files": [
      "net/mac80211/sta_info.c||net/mac80211/sta_info.c",
      "net/mac80211/sta_info.h||net/mac80211/sta_info.h",
      "net/mac80211/tx.c||net/mac80211/tx.c"
    ]
  },
  "patch_diff": {
    "net/mac80211/sta_info.c||net/mac80211/sta_info.c": [
      "File: net/mac80211/sta_info.c -> net/mac80211/sta_info.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:  rcu_read_unlock();",
      "332:  spin_lock_init(&sta->lock);",
      "333:  INIT_WORK(&sta->drv_unblock_wk, sta_unblock);",
      "334:  INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);",
      "335:  mutex_init(&sta->ampdu_mlme.mtx);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:  spin_lock_init(&sta->ps_lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1110:  skb_queue_head_init(&pending);",
      "1113:  for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {",
      "1114:   int count = skb_queue_len(&pending), tmp;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1114:  spin_lock(&sta->ps_lock);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1128:  }",
      "1130:  ieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);",
      "1133:  if (!ieee80211_smps_is_restrictive(sta->known_smps_mode,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1134:  spin_unlock(&sta->ps_lock);",
      "",
      "---------------"
    ],
    "net/mac80211/sta_info.h||net/mac80211/sta_info.h": [
      "File: net/mac80211/sta_info.h -> net/mac80211/sta_info.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "357:  unsigned long _flags;",
      "363:  struct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];",
      "364:  struct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];",
      "365:  unsigned long driver_buffered_tids;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "361:  spinlock_t ps_lock;",
      "",
      "---------------"
    ],
    "net/mac80211/tx.c||net/mac80211/tx.c": [
      "File: net/mac80211/tx.c -> net/mac80211/tx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "478:          sta->sta.addr, sta->sta.aid, ac);",
      "479:   if (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)",
      "480:    purge_old_ps_buffers(tx->local);",
      "481:   if (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {",
      "482:    struct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);",
      "483:    ps_dbg(tx->sdata,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "483:   spin_lock(&sta->ps_lock);",
      "489:   if (!test_sta_flag(sta, WLAN_STA_PS_STA) &&",
      "490:       !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {",
      "491:    spin_unlock(&sta->ps_lock);",
      "492:    return TX_CONTINUE;",
      "493:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "492:   info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;",
      "493:   info->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;",
      "494:   skb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);",
      "496:   if (!timer_pending(&local->sta_cleanup))",
      "497:    mod_timer(&local->sta_cleanup,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "509:   spin_unlock(&sta->ps_lock);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5ac2e35030113ed881ce9ad413d80f13ffe5b5a0",
      "candidate_info": {
        "commit_hash": "5ac2e35030113ed881ce9ad413d80f13ffe5b5a0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5ac2e35030113ed881ce9ad413d80f13ffe5b5a0",
        "files": [
          "net/mac80211/rx.c",
          "net/mac80211/sta_info.c",
          "net/mac80211/sta_info.h",
          "net/mac80211/tx.c"
        ],
        "message": "mac80211: fix station/driver powersave race\n\nIt is currently possible to have a race due to the station PS\nunblock work like this:\n * station goes to sleep with frames buffered in the driver\n * driver blocks wakeup\n * station wakes up again\n * driver flushes/returns frames, and unblocks, which schedules\n   the unblock work\n * unblock work starts to run, and checks that the station is\n   awake (i.e. that the WLAN_STA_PS_STA flag isn't set)\n * we process a received frame with PM=1, setting the flag again\n * ieee80211_sta_ps_deliver_wakeup() runs, delivering all frames\n   to the driver, and then clearing the WLAN_STA_PS_DRIVER and\n   WLAN_STA_PS_STA flags\n\nIn this scenario, mac80211 will think that the station is awake,\nwhile it really is asleep, and any TX'ed frames should be filtered\nby the device (it will know that the station is sleeping) but then\npassed to mac80211 again, which will not buffer it either as it\nthinks the station is awake, and eventually the packets will be\ndropped.\n\nFix this by moving the clearing of the flags to exactly where we\nlearn about the situation. This creates a problem of reordering,\nso introduce another flag indicating that delivery is being done,\nthis new flag also queues frames and is cleared only while the\nspinlock is held (which the queuing code also holds) so that any\nconcurrent delivery/TX is handled correctly.\n\nReported-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
        "before_after_code_files": [
          "net/mac80211/rx.c||net/mac80211/rx.c",
          "net/mac80211/sta_info.c||net/mac80211/sta_info.c",
          "net/mac80211/sta_info.h||net/mac80211/sta_info.h",
          "net/mac80211/tx.c||net/mac80211/tx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/mac80211/sta_info.c||net/mac80211/sta_info.c",
            "net/mac80211/sta_info.h||net/mac80211/sta_info.h",
            "net/mac80211/tx.c||net/mac80211/tx.c"
          ],
          "candidate": [
            "net/mac80211/sta_info.c||net/mac80211/sta_info.c",
            "net/mac80211/sta_info.h||net/mac80211/sta_info.h",
            "net/mac80211/tx.c||net/mac80211/tx.c"
          ]
        }
      },
      "candidate_diff": {
        "net/mac80211/rx.c||net/mac80211/rx.c": [
          "File: net/mac80211/rx.c -> net/mac80211/rx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1107:   return;",
          "1108:  }",
          "1110:  ieee80211_sta_ps_deliver_wakeup(sta);",
          "1111: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1110:  set_sta_flag(sta, WLAN_STA_PS_DELIVER);",
          "1111:  clear_sta_flag(sta, WLAN_STA_PS_STA);",
          "",
          "---------------"
        ],
        "net/mac80211/sta_info.c||net/mac80211/sta_info.c": [
          "File: net/mac80211/sta_info.c -> net/mac80211/sta_info.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:  struct ps_data *ps;",
          "102:  if (test_sta_flag(sta, WLAN_STA_PS_STA) ||",
          "104:   if (sta->sdata->vif.type == NL80211_IFTYPE_AP ||",
          "105:       sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)",
          "106:    ps = &sdata->bss->ps;",
          "",
          "[Removed Lines]",
          "103:      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {",
          "",
          "[Added Lines]",
          "103:      test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||",
          "104:      test_sta_flag(sta, WLAN_STA_PS_DELIVER)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112:   clear_sta_flag(sta, WLAN_STA_PS_STA);",
          "113:   clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "115:   atomic_dec(&ps->num_sta_ps);",
          "116:   sta_info_recalc_tim(sta);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "115:   clear_sta_flag(sta, WLAN_STA_PS_DELIVER);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:  if (ieee80211_vif_is_mesh(&sdata->vif))",
          "126:   mesh_sta_cleanup(sta);",
          "",
          "[Removed Lines]",
          "128:  cancel_work_sync(&sta->drv_unblock_wk);",
          "",
          "[Added Lines]",
          "130:  cancel_work_sync(&sta->drv_deliver_wk);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "253:  rcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)], sta);",
          "254: }",
          "257: {",
          "258:  struct sta_info *sta;",
          "262:  if (sta->dead)",
          "263:   return;",
          "267:   ieee80211_sta_ps_deliver_wakeup(sta);",
          "273:   ieee80211_sta_ps_deliver_poll_response(sta);",
          "279:   ieee80211_sta_ps_deliver_uapsd(sta);",
          "283: }",
          "285: static int sta_prepare_rate_control(struct ieee80211_local *local,",
          "",
          "[Removed Lines]",
          "256: static void sta_unblock(struct work_struct *wk)",
          "260:  sta = container_of(wk, struct sta_info, drv_unblock_wk);",
          "265:  if (!test_sta_flag(sta, WLAN_STA_PS_STA)) {",
          "266:   local_bh_disable();",
          "268:   local_bh_enable();",
          "269:  } else if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL)) {",
          "270:   clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "272:   local_bh_disable();",
          "274:   local_bh_enable();",
          "275:  } else if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD)) {",
          "276:   clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "278:   local_bh_disable();",
          "280:   local_bh_enable();",
          "281:  } else",
          "282:   clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "",
          "[Added Lines]",
          "258: static void sta_deliver_ps_frames(struct work_struct *wk)",
          "262:  sta = container_of(wk, struct sta_info, drv_deliver_wk);",
          "267:  local_bh_disable();",
          "268:  if (!test_sta_flag(sta, WLAN_STA_PS_STA))",
          "270:  else if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL))",
          "272:  else if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD))",
          "274:  local_bh_enable();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "342:  spin_lock_init(&sta->lock);",
          "343:  spin_lock_init(&sta->ps_lock);",
          "345:  INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);",
          "346:  mutex_init(&sta->ampdu_mlme.mtx);",
          "347: #ifdef CONFIG_MAC80211_MESH",
          "",
          "[Removed Lines]",
          "344:  INIT_WORK(&sta->drv_unblock_wk, sta_unblock);",
          "",
          "[Added Lines]",
          "336:  INIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1141:  }",
          "1143:  ieee80211_add_pending_skbs(local, &pending);",
          "1146:  spin_unlock(&sta->ps_lock);",
          "1148:  atomic_dec(&ps->num_sta_ps);",
          "",
          "[Removed Lines]",
          "1144:  clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "1145:  clear_sta_flag(sta, WLAN_STA_PS_STA);",
          "",
          "[Added Lines]",
          "1138:  clear_sta_flag(sta, WLAN_STA_PS_DELIVER);",
          "1143:  clear_sta_flag(sta, WLAN_STA_PSPOLL);",
          "1144:  clear_sta_flag(sta, WLAN_STA_UAPSD);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1544:  trace_api_sta_block_awake(sta->local, pubsta, block);",
          "1547:   set_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "1550: }",
          "1551: EXPORT_SYMBOL(ieee80211_sta_block_awake);",
          "",
          "[Removed Lines]",
          "1546:  if (block)",
          "1548:  else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))",
          "1549:   ieee80211_queue_work(hw, &sta->drv_unblock_wk);",
          "",
          "[Added Lines]",
          "1545:  if (block) {",
          "1547:   return;",
          "1548:  }",
          "1550:  if (!test_sta_flag(sta, WLAN_STA_PS_DRIVER))",
          "1551:   return;",
          "1553:  if (!test_sta_flag(sta, WLAN_STA_PS_STA)) {",
          "1554:   set_sta_flag(sta, WLAN_STA_PS_DELIVER);",
          "1555:   clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "1556:   ieee80211_queue_work(hw, &sta->drv_deliver_wk);",
          "1557:  } else if (test_sta_flag(sta, WLAN_STA_PSPOLL) ||",
          "1558:      test_sta_flag(sta, WLAN_STA_UAPSD)) {",
          "1560:   clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "1561:   ieee80211_queue_work(hw, &sta->drv_deliver_wk);",
          "1562:  } else {",
          "1563:   clear_sta_flag(sta, WLAN_STA_PS_DRIVER);",
          "1564:  }",
          "",
          "---------------"
        ],
        "net/mac80211/sta_info.h||net/mac80211/sta_info.h": [
          "File: net/mac80211/sta_info.h -> net/mac80211/sta_info.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:  WLAN_STA_TOFFSET_KNOWN,",
          "83:  WLAN_STA_MPSP_OWNER,",
          "84:  WLAN_STA_MPSP_RECIPIENT,",
          "85: };",
          "87: #define ADDBA_RESP_INTERVAL HZ",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:  WLAN_STA_PS_DELIVER,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "345:  void *rate_ctrl_priv;",
          "346:  spinlock_t lock;",
          "350:  u16 listen_interval;",
          "",
          "[Removed Lines]",
          "348:  struct work_struct drv_unblock_wk;",
          "",
          "[Added Lines]",
          "351:  struct work_struct drv_deliver_wk;",
          "",
          "---------------"
        ],
        "net/mac80211/tx.c||net/mac80211/tx.c": [
          "File: net/mac80211/tx.c -> net/mac80211/tx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "469:   return TX_CONTINUE;",
          "471:  if (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||",
          "473:        !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {",
          "474:   int ac = skb_get_queue_mapping(tx->skb);",
          "",
          "[Removed Lines]",
          "472:         test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&",
          "",
          "[Added Lines]",
          "472:         test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||",
          "473:         test_sta_flag(sta, WLAN_STA_PS_DELIVER)) &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "488:   if (!test_sta_flag(sta, WLAN_STA_PS_STA) &&",
          "490:    spin_unlock(&sta->ps_lock);",
          "491:    return TX_CONTINUE;",
          "492:   }",
          "",
          "[Removed Lines]",
          "489:       !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {",
          "",
          "[Added Lines]",
          "490:       !test_sta_flag(sta, WLAN_STA_PS_DRIVER) &&",
          "491:       !test_sta_flag(sta, WLAN_STA_PS_DELIVER)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
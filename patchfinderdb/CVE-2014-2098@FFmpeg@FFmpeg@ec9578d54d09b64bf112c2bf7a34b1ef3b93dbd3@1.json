{
  "cve_id": "CVE-2014-2098",
  "cve_desc": "libavcodec/wmalosslessdec.c in FFmpeg before 2.1.4 uses an incorrect data-structure size for certain coefficients, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted WMA data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3",
  "patch_info": {
    "commit_hash": "ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3",
    "files": [
      "libavcodec/wmalosslessdec.c"
    ],
    "message": "avcodec/wmalosslessdec: fix mclms_coeffs* array size\n\nFixes corruption of context\nFixes: 8835659dde6a4f7dcdf341de6a45c6c8-signal_sigsegv_1dce67b_4564_cov_2504444599_classical_22_16_1_14000_v3c_0_extend_0_29.wma\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c": [
      "File: libavcodec/wmalosslessdec.c -> libavcodec/wmalosslessdec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "128:     int8_t  mclms_order;",
      "129:     int8_t  mclms_scaling;",
      "132:     int16_t mclms_prevvalues[WMALL_MAX_CHANNELS * 2 * 32];",
      "133:     int16_t mclms_updates[WMALL_MAX_CHANNELS * 2 * 32];",
      "134:     int     mclms_recent;",
      "",
      "[Removed Lines]",
      "130:     int16_t mclms_coeffs[128];",
      "131:     int16_t mclms_coeffs_cur[4];",
      "",
      "[Added Lines]",
      "130:     int16_t mclms_coeffs[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS * 32];",
      "131:     int16_t mclms_coeffs_cur[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b0b02a210109473cbc8d3bb8d7a6bcf4eb6ebb68",
      "candidate_info": {
        "commit_hash": "b0b02a210109473cbc8d3bb8d7a6bcf4eb6ebb68",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b0b02a210109473cbc8d3bb8d7a6bcf4eb6ebb68",
        "files": [
          "libavcodec/wmalosslessdec.c"
        ],
        "message": "avcodec/wmalosslessdec: fix mclms_coeffs* array size\n\nFixes corruption of context\nFixes: 8835659dde6a4f7dcdf341de6a45c6c8-signal_sigsegv_1dce67b_4564_cov_2504444599_classical_22_16_1_14000_v3c_0_extend_0_29.wma\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ],
          "candidate": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c": [
          "File: libavcodec/wmalosslessdec.c -> libavcodec/wmalosslessdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:     int8_t  mclms_order;",
          "129:     int8_t  mclms_scaling;",
          "132:     int16_t mclms_prevvalues[WMALL_MAX_CHANNELS * 2 * 32];",
          "133:     int16_t mclms_updates[WMALL_MAX_CHANNELS * 2 * 32];",
          "134:     int     mclms_recent;",
          "",
          "[Removed Lines]",
          "130:     int16_t mclms_coeffs[128];",
          "131:     int16_t mclms_coeffs_cur[4];",
          "",
          "[Added Lines]",
          "130:     int16_t mclms_coeffs[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS * 32];",
          "131:     int16_t mclms_coeffs_cur[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c23597ec7eaea16a638729c60866befcd48eda3e",
      "candidate_info": {
        "commit_hash": "c23597ec7eaea16a638729c60866befcd48eda3e",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c23597ec7eaea16a638729c60866befcd48eda3e",
        "files": [
          "libavcodec/wmalosslessdec.c"
        ],
        "message": "avcodec/wmalosslessdec: fix mclms_coeffs* array size\n\nFixes corruption of context\nFixes: 8835659dde6a4f7dcdf341de6a45c6c8-signal_sigsegv_1dce67b_4564_cov_2504444599_classical_22_16_1_14000_v3c_0_extend_0_29.wma\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ],
          "candidate": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c": [
          "File: libavcodec/wmalosslessdec.c -> libavcodec/wmalosslessdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:     int8_t  mclms_order;",
          "127:     int8_t  mclms_scaling;",
          "130:     int16_t mclms_prevvalues[WMALL_MAX_CHANNELS * 2 * 32];",
          "131:     int16_t mclms_updates[WMALL_MAX_CHANNELS * 2 * 32];",
          "132:     int     mclms_recent;",
          "",
          "[Removed Lines]",
          "128:     int16_t mclms_coeffs[128];",
          "129:     int16_t mclms_coeffs_cur[4];",
          "",
          "[Added Lines]",
          "128:     int16_t mclms_coeffs[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS * 32];",
          "129:     int16_t mclms_coeffs_cur[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b9bf17c55ac2b3b06e44a221994563fa894c1347",
      "candidate_info": {
        "commit_hash": "b9bf17c55ac2b3b06e44a221994563fa894c1347",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b9bf17c55ac2b3b06e44a221994563fa894c1347",
        "files": [
          "libavcodec/wmalosslessdec.c"
        ],
        "message": "avcodec/wmalosslessdec: fix mclms_coeffs* array size\n\nFixes corruption of context\nFixes: 8835659dde6a4f7dcdf341de6a45c6c8-signal_sigsegv_1dce67b_4564_cov_2504444599_classical_22_16_1_14000_v3c_0_extend_0_29.wma\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ],
          "candidate": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c": [
          "File: libavcodec/wmalosslessdec.c -> libavcodec/wmalosslessdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:     int8_t  mclms_order;",
          "127:     int8_t  mclms_scaling;",
          "130:     int16_t mclms_prevvalues[WMALL_MAX_CHANNELS * 2 * 32];",
          "131:     int16_t mclms_updates[WMALL_MAX_CHANNELS * 2 * 32];",
          "132:     int     mclms_recent;",
          "",
          "[Removed Lines]",
          "128:     int16_t mclms_coeffs[128];",
          "129:     int16_t mclms_coeffs_cur[4];",
          "",
          "[Added Lines]",
          "128:     int16_t mclms_coeffs[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS * 32];",
          "129:     int16_t mclms_coeffs_cur[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "123b1fac5c0a18061d7fa9a7869e537e81d16506",
      "candidate_info": {
        "commit_hash": "123b1fac5c0a18061d7fa9a7869e537e81d16506",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/123b1fac5c0a18061d7fa9a7869e537e81d16506",
        "files": [
          "libavcodec/Makefile",
          "libavcodec/allcodecs.c",
          "libavcodec/wmalosslessdec.c"
        ],
        "message": "wmall: Working bitstream parser (cherry picked from commit 929822111bc10fdf19ca66b7ed09e0ebf802878b)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/allcodecs.c||libavcodec/allcodecs.c",
          "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ],
          "candidate": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/allcodecs.c||libavcodec/allcodecs.c": [
          "File: libavcodec/allcodecs.c -> libavcodec/allcodecs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "296:     REGISTER_DECODER (VMDAUDIO, vmdaudio);",
          "297:     REGISTER_ENCDEC  (VORBIS, vorbis);",
          "298:     REGISTER_DECODER (WAVPACK, wavpack);",
          "299:     REGISTER_DECODER (WMAPRO, wmapro);",
          "300:     REGISTER_ENCDEC  (WMAV1, wmav1);",
          "301:     REGISTER_ENCDEC  (WMAV2, wmav2);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "299:     REGISTER_DECODER (WMALOSSLESS, wmalossless);",
          "",
          "---------------"
        ],
        "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c": [
          "File: libavcodec/wmalosslessdec.c -> libavcodec/wmalosslessdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: #include \"avcodec.h\"",
          "91: #include \"internal.h\"",
          "92: #include \"get_bits.h\"",
          "93: #include \"put_bits.h\"",
          "94: #include \"dsputil.h\"",
          "95: #include \"wma.h\"",
          "98: #define WMALL_MAX_CHANNELS    8                             ///< max number of handled channels",
          "99: #define MAX_SUBFRAMES  32                                    ///< max number of subframes per channel",
          "100: #define MAX_BANDS      29                                    ///< max number of scale factor bands",
          "101: #define MAX_FRAMESIZE  32768                                 ///< maximum compressed frame size",
          "103: #define WMALL_BLOCK_MIN_BITS  6                                           ///< log2 of min block size",
          "104: #define WMALL_BLOCK_MAX_BITS 12                                           ///< log2 of max block size",
          "105: #define WMALL_BLOCK_MAX_SIZE (1 << WMALL_BLOCK_MAX_BITS)                 ///< maximum block size",
          "106: #define WMALL_BLOCK_SIZES    (WMALL_BLOCK_MAX_BITS - WMALL_BLOCK_MIN_BITS + 1) ///< possible block sizes",
          "109: #define VLCBITS            9",
          "110: #define SCALEVLCBITS       8",
          "111: #define VEC4MAXDEPTH    ((HUFF_VEC4_MAXBITS+VLCBITS-1)/VLCBITS)",
          "112: #define VEC2MAXDEPTH    ((HUFF_VEC2_MAXBITS+VLCBITS-1)/VLCBITS)",
          "113: #define VEC1MAXDEPTH    ((HUFF_VEC1_MAXBITS+VLCBITS-1)/VLCBITS)",
          "114: #define SCALEMAXDEPTH   ((HUFF_SCALE_MAXBITS+SCALEVLCBITS-1)/SCALEVLCBITS)",
          "115: #define SCALERLMAXDEPTH ((HUFF_SCALE_RL_MAXBITS+VLCBITS-1)/VLCBITS)",
          "117: static float            sin64[33];        ///< sinus table for decorrelation",
          "122: typedef struct {",
          "123:     int16_t  prev_block_len;                          ///< length of the previous block",
          "124:     uint8_t  transmit_coefs;",
          "125:     uint8_t  num_subframes;",
          "126:     uint16_t subframe_len[MAX_SUBFRAMES];             ///< subframe length in samples",
          "127:     uint16_t subframe_offset[MAX_SUBFRAMES];          ///< subframe positions in the current frame",
          "128:     uint8_t  cur_subframe;                            ///< current subframe number",
          "129:     uint16_t decoded_samples;                         ///< number of already processed samples",
          "130:     uint8_t  grouped;                                 ///< channel is part of a group",
          "131:     int      quant_step;                              ///< quantization step for the current subframe",
          "132:     int8_t   reuse_sf;                                ///< share scale factors between subframes",
          "133:     int8_t   scale_factor_step;                       ///< scaling step for the current subframe",
          "134:     int      max_scale_factor;                        ///< maximum scale factor for the current subframe",
          "135:     int      saved_scale_factors[2][MAX_BANDS];       ///< resampled and (previously) transmitted scale factor values",
          "136:     int8_t   scale_factor_idx;                        ///< index for the transmitted scale factor values (used for resampling)",
          "137:     int*     scale_factors;                           ///< pointer to the scale factor values used for decoding",
          "138:     uint8_t  table_idx;                               ///< index in sf_offsets for the scale factor reference block",
          "139:     float*   coeffs;                                  ///< pointer to the subframe decode buffer",
          "140:     uint16_t num_vec_coeffs;                          ///< number of vector coded coefficients",
          "141:     DECLARE_ALIGNED(16, float, out)[WMALL_BLOCK_MAX_SIZE + WMALL_BLOCK_MAX_SIZE / 2]; ///< output buffer",
          "142: } WmallChannelCtx;",
          "147: typedef struct {",
          "148:     uint8_t num_channels;                                     ///< number of channels in the group",
          "149:     int8_t  transform;                                        ///< transform on / off",
          "150:     int8_t  transform_band[MAX_BANDS];                        ///< controls if the transform is enabled for a certain band",
          "151:     float   decorrelation_matrix[WMALL_MAX_CHANNELS*WMALL_MAX_CHANNELS];",
          "152:     float*  channel_data[WMALL_MAX_CHANNELS];                ///< transformation coefficients",
          "153: } WmallChannelGrp;",
          "158: typedef struct WmallDecodeCtx {",
          "160:     AVCodecContext*  avctx;                         ///< codec context for av_log",
          "161:     DSPContext       dsp;                           ///< accelerated DSP functions",
          "162:     uint8_t          frame_data[MAX_FRAMESIZE +",
          "163:                       FF_INPUT_BUFFER_PADDING_SIZE];///< compressed frame data",
          "164:     PutBitContext    pb;                            ///< context for filling the frame_data buffer",
          "165:     FFTContext       mdct_ctx[WMALL_BLOCK_SIZES];  ///< MDCT context per block size",
          "166:     DECLARE_ALIGNED(16, float, tmp)[WMALL_BLOCK_MAX_SIZE]; ///< IMDCT output buffer",
          "167:     float*           windows[WMALL_BLOCK_SIZES];   ///< windows for the different block sizes",
          "170:     uint32_t         decode_flags;                  ///< used compression features",
          "171:     uint8_t          len_prefix;                    ///< frame is prefixed with its length",
          "172:     uint8_t          dynamic_range_compression;     ///< frame contains DRC data",
          "173:     uint8_t          bits_per_sample;               ///< integer audio sample size for the unscaled IMDCT output (used to scale to [-1.0, 1.0])",
          "174:     uint16_t         samples_per_frame;             ///< number of samples to output",
          "175:     uint16_t         log2_frame_size;",
          "176:     int8_t           num_channels;                  ///< number of channels in the stream (same as AVCodecContext.num_channels)",
          "177:     int8_t           lfe_channel;                   ///< lfe channel index",
          "178:     uint8_t          max_num_subframes;",
          "179:     uint8_t          subframe_len_bits;             ///< number of bits used for the subframe length",
          "180:     uint8_t          max_subframe_len_bit;          ///< flag indicating that the subframe is of maximum size when the first subframe length bit is 1",
          "181:     uint16_t         min_samples_per_subframe;",
          "182:     int8_t           num_sfb[WMALL_BLOCK_SIZES];   ///< scale factor bands per block size",
          "183:     int16_t          sfb_offsets[WMALL_BLOCK_SIZES][MAX_BANDS];                    ///< scale factor band offsets (multiples of 4)",
          "184:     int8_t           sf_offsets[WMALL_BLOCK_SIZES][WMALL_BLOCK_SIZES][MAX_BANDS]; ///< scale factor resample matrix",
          "185:     int16_t          subwoofer_cutoffs[WMALL_BLOCK_SIZES]; ///< subwoofer cutoff values",
          "188:     GetBitContext    pgb;                           ///< bitstream reader context for the packet",
          "189:     int              next_packet_start;             ///< start offset of the next wma packet in the demuxer packet",
          "190:     uint8_t          packet_offset;                 ///< frame offset in the packet",
          "191:     uint8_t          packet_sequence_number;        ///< current packet number",
          "192:     int              num_saved_bits;                ///< saved number of bits",
          "193:     int              frame_offset;                  ///< frame offset in the bit reservoir",
          "194:     int              subframe_offset;               ///< subframe offset in the bit reservoir",
          "195:     uint8_t          packet_loss;                   ///< set in case of bitstream error",
          "196:     uint8_t          packet_done;                   ///< set when a packet is fully decoded",
          "199:     uint32_t         frame_num;                     ///< current frame number (not used for decoding)",
          "200:     GetBitContext    gb;                            ///< bitstream reader context",
          "201:     int              buf_bit_size;                  ///< buffer size in bits",
          "202:     float*           samples;                       ///< current samplebuffer pointer",
          "203:     float*           samples_end;                   ///< maximum samplebuffer pointer",
          "204:     uint8_t          drc_gain;                      ///< gain for the DRC tool",
          "205:     int8_t           skip_frame;                    ///< skip output step",
          "206:     int8_t           parsed_all_subframes;          ///< all subframes decoded?",
          "209:     int16_t          subframe_len;                  ///< current subframe length",
          "210:     int8_t           channels_for_cur_subframe;     ///< number of channels that contain the subframe",
          "211:     int8_t           channel_indexes_for_cur_subframe[WMALL_MAX_CHANNELS];",
          "212:     int8_t           num_bands;                     ///< number of scale factor bands",
          "213:     int8_t           transmit_num_vec_coeffs;       ///< number of vector coded coefficients is part of the bitstream",
          "214:     int16_t*         cur_sfb_offsets;               ///< sfb offsets for the current block",
          "215:     uint8_t          table_idx;                     ///< index for the num_sfb, sfb_offsets, sf_offsets and subwoofer_cutoffs tables",
          "216:     int8_t           esc_len;                       ///< length of escaped coefficients",
          "218:     uint8_t          num_chgroups;                  ///< number of channel groups",
          "219:     WmallChannelGrp chgroup[WMALL_MAX_CHANNELS];  ///< channel group information",
          "221:     WmallChannelCtx channel[WMALL_MAX_CHANNELS];  ///< per channel data",
          "225:     uint8_t do_arith_coding;",
          "226:     uint8_t do_ac_filter;",
          "227:     uint8_t do_inter_ch_decorr;",
          "228:     uint8_t do_mclms;",
          "229:     uint8_t do_lpc;",
          "231:     int8_t acfilter_order;",
          "232:     int8_t acfilter_scaling;",
          "233:     int acfilter_coeffs[16];",
          "235:     int8_t mclms_order;",
          "236:     int8_t mclms_scaling;",
          "237:     int16_t mclms_coeffs[128];",
          "238:     int16_t mclms_coeffs_cur[4];",
          "240:     int movave_scaling;",
          "241:     int quant_stepsize;",
          "243:     struct {",
          "244:         int order;",
          "245:         int scaling;",
          "246:         int coefsend;",
          "247:         int bitsend;",
          "248:         int16_t coefs[256];",
          "249:     } cdlms[2][9];",
          "252:     int cdlms_ttl[2];",
          "254:     int bV3RTM;",
          "256:     int is_channel_coded[2];",
          "258:     int transient[2];",
          "259:     int transient_pos[2];",
          "260:     int seekable_tile;",
          "262:     int ave_sum[2];",
          "264:     int channel_residues[2][2048];",
          "267:     int lpc_coefs[2][40];",
          "268:     int lpc_order;",
          "269:     int lpc_scaling;",
          "270:     int lpc_intbits;",
          "272:     int channel_coeffs[2][2048];",
          "274: } WmallDecodeCtx;",
          "277: #undef dprintf",
          "278: #define dprintf(pctx, ...) av_log(pctx, AV_LOG_DEBUG, __VA_ARGS__)",
          "285: static void av_cold dump_context(WmallDecodeCtx *s)",
          "286: {",
          "287: #define PRINT(a, b)     av_log(s->avctx, AV_LOG_DEBUG, \" %s = %d\\n\", a, b);",
          "288: #define PRINT_HEX(a, b) av_log(s->avctx, AV_LOG_DEBUG, \" %s = %x\\n\", a, b);",
          "290:     PRINT(\"ed sample bit depth\", s->bits_per_sample);",
          "291:     PRINT_HEX(\"ed decode flags\", s->decode_flags);",
          "292:     PRINT(\"samples per frame\",   s->samples_per_frame);",
          "293:     PRINT(\"log2 frame size\",     s->log2_frame_size);",
          "294:     PRINT(\"max num subframes\",   s->max_num_subframes);",
          "295:     PRINT(\"len prefix\",          s->len_prefix);",
          "296:     PRINT(\"num channels\",        s->num_channels);",
          "297: }",
          "304: static av_cold int decode_end(AVCodecContext *avctx)",
          "305: {",
          "306:     WmallDecodeCtx *s = avctx->priv_data;",
          "307:     int i;",
          "309:     for (i = 0; i < WMALL_BLOCK_SIZES; i++)",
          "310:         ff_mdct_end(&s->mdct_ctx[i]);",
          "312:     return 0;",
          "313: }",
          "320: static av_cold int decode_init(AVCodecContext *avctx)",
          "321: {",
          "322:     WmallDecodeCtx *s = avctx->priv_data;",
          "323:     uint8_t *edata_ptr = avctx->extradata;",
          "324:     unsigned int channel_mask;",
          "325:     int i;",
          "326:     int log2_max_num_subframes;",
          "327:     int num_possible_block_sizes;",
          "329:     s->avctx = avctx;",
          "330:     dsputil_init(&s->dsp, avctx);",
          "331:     init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);",
          "333:     avctx->sample_fmt = AV_SAMPLE_FMT_FLT;",
          "335:     if (avctx->extradata_size >= 18) {",
          "336:         s->decode_flags    = AV_RL16(edata_ptr+14);",
          "337:         channel_mask       = AV_RL32(edata_ptr+2);",
          "338:         s->bits_per_sample = AV_RL16(edata_ptr);",
          "340:         for (i = 0; i < avctx->extradata_size; i++)",
          "341:             dprintf(avctx, \"[%x] \", avctx->extradata[i]);",
          "342:         dprintf(avctx, \"\\n\");",
          "344:     } else {",
          "345:         av_log_ask_for_sample(avctx, \"Unknown extradata size\\n\");",
          "346:         return AVERROR_INVALIDDATA;",
          "347:     }",
          "350:     s->log2_frame_size = av_log2(avctx->block_align) + 4;",
          "354:     s->packet_loss = 1;",
          "355:     s->len_prefix  = (s->decode_flags & 0x40);",
          "358:     s->samples_per_frame = 1 << ff_wma_get_frame_len_bits(avctx->sample_rate,",
          "359:                                                           3, s->decode_flags);",
          "362:     for (i = 0; i < avctx->channels; i++)",
          "363:         s->channel[i].prev_block_len = s->samples_per_frame;",
          "366:     log2_max_num_subframes       = ((s->decode_flags & 0x38) >> 3);",
          "367:     s->max_num_subframes         = 1 << log2_max_num_subframes;",
          "368:     s->max_subframe_len_bit = 0;",
          "369:     s->subframe_len_bits = av_log2(log2_max_num_subframes) + 1;",
          "371:     num_possible_block_sizes     = log2_max_num_subframes + 1;",
          "372:     s->min_samples_per_subframe  = s->samples_per_frame / s->max_num_subframes;",
          "373:     s->dynamic_range_compression = (s->decode_flags & 0x80);",
          "375:     s->bV3RTM = s->decode_flags & 0x100;",
          "377:     if (s->max_num_subframes > MAX_SUBFRAMES) {",
          "378:         av_log(avctx, AV_LOG_ERROR, \"invalid number of subframes %i\\n\",",
          "379:                s->max_num_subframes);",
          "380:         return AVERROR_INVALIDDATA;",
          "381:     }",
          "383:     s->num_channels = avctx->channels;",
          "386:     s->lfe_channel = -1;",
          "388:     if (channel_mask & 8) {",
          "389:         unsigned int mask;",
          "390:         for (mask = 1; mask < 16; mask <<= 1) {",
          "391:             if (channel_mask & mask)",
          "392:                 ++s->lfe_channel;",
          "393:         }",
          "394:     }",
          "396:     if (s->num_channels < 0) {",
          "397:         av_log(avctx, AV_LOG_ERROR, \"invalid number of channels %d\\n\", s->num_channels);",
          "398:         return AVERROR_INVALIDDATA;",
          "399:     } else if (s->num_channels > WMALL_MAX_CHANNELS) {",
          "400:         av_log_ask_for_sample(avctx, \"unsupported number of channels\\n\");",
          "401:         return AVERROR_PATCHWELCOME;",
          "402:     }",
          "404:     avctx->channel_layout = channel_mask;",
          "405:     return 0;",
          "406: }",
          "414: static int decode_subframe_length(WmallDecodeCtx *s, int offset)",
          "415: {",
          "416:     int frame_len_ratio;",
          "417:     int subframe_len, len;",
          "420:     if (offset == s->samples_per_frame - s->min_samples_per_subframe)",
          "421:         return s->min_samples_per_subframe;",
          "423:     len = av_log2(s->max_num_subframes - 1) + 1;",
          "424:     frame_len_ratio = get_bits(&s->gb, len);",
          "426:     subframe_len = s->min_samples_per_subframe * (frame_len_ratio + 1);",
          "429:     if (subframe_len < s->min_samples_per_subframe ||",
          "430:         subframe_len > s->samples_per_frame) {",
          "431:         av_log(s->avctx, AV_LOG_ERROR, \"broken frame: subframe_len %i\\n\",",
          "432:                subframe_len);",
          "433:         return AVERROR_INVALIDDATA;",
          "434:     }",
          "435:     return subframe_len;",
          "436: }",
          "458: static int decode_tilehdr(WmallDecodeCtx *s)",
          "459: {",
          "465:     int c;",
          "474:     for (c = 0; c < s->num_channels; c++)",
          "475:         s->channel[c].num_subframes = 0;",
          "477:     memset(num_samples, 0, sizeof(num_samples));",
          "479:     if (s->max_num_subframes == 1 || get_bits1(&s->gb))",
          "480:         fixed_channel_layout = 1;",
          "483:     do {",
          "484:         int subframe_len;",
          "487:         for (c = 0; c < s->num_channels; c++) {",
          "488:             if (num_samples[c] == min_channel_len) {",
          "489:                 if (fixed_channel_layout || channels_for_cur_subframe == 1 ||",
          "490:                     (min_channel_len == s->samples_per_frame - s->min_samples_per_subframe)) {",
          "491:                     contains_subframe[c] = 1;",
          "492:                 }",
          "493:                 else {",
          "494:                     contains_subframe[c] = get_bits1(&s->gb);",
          "495:                 }",
          "496:             } else",
          "497:                 contains_subframe[c] = 0;",
          "498:         }",
          "501:         if ((subframe_len = decode_subframe_length(s, min_channel_len)) <= 0)",
          "502:             return AVERROR_INVALIDDATA;",
          "504:         min_channel_len += subframe_len;",
          "505:         for (c = 0; c < s->num_channels; c++) {",
          "506:             WmallChannelCtx* chan = &s->channel[c];",
          "508:             if (contains_subframe[c]) {",
          "509:                 if (chan->num_subframes >= MAX_SUBFRAMES) {",
          "510:                     av_log(s->avctx, AV_LOG_ERROR,",
          "511:                            \"broken frame: num subframes > 31\\n\");",
          "512:                     return AVERROR_INVALIDDATA;",
          "513:                 }",
          "514:                 chan->subframe_len[chan->num_subframes] = subframe_len;",
          "515:                 num_samples[c] += subframe_len;",
          "516:                 ++chan->num_subframes;",
          "517:                 if (num_samples[c] > s->samples_per_frame) {",
          "518:                     av_log(s->avctx, AV_LOG_ERROR, \"broken frame: \"",
          "519:                            \"channel len(%d) > samples_per_frame(%d)\\n\",",
          "520:                            num_samples[c], s->samples_per_frame);",
          "521:                     return AVERROR_INVALIDDATA;",
          "522:                 }",
          "523:             } else if (num_samples[c] <= min_channel_len) {",
          "524:                 if (num_samples[c] < min_channel_len) {",
          "525:                     channels_for_cur_subframe = 0;",
          "526:                     min_channel_len = num_samples[c];",
          "527:                 }",
          "528:                 ++channels_for_cur_subframe;",
          "529:             }",
          "530:         }",
          "531:     } while (min_channel_len < s->samples_per_frame);",
          "533:     for (c = 0; c < s->num_channels; c++) {",
          "534:         int i;",
          "535:         int offset = 0;",
          "536:         for (i = 0; i < s->channel[c].num_subframes; i++) {",
          "537:             s->channel[c].subframe_offset[i] = offset;",
          "538:             offset += s->channel[c].subframe_len[i];",
          "539:         }",
          "540:     }",
          "542:     return 0;",
          "543: }",
          "546: static int my_log2(unsigned int i)",
          "547: {",
          "548:     unsigned int iLog2 = 0;",
          "549:     while ((i >> iLog2) > 1)",
          "550:         iLog2++;",
          "551:     return iLog2;",
          "552: }",
          "558: static void decode_ac_filter(WmallDecodeCtx *s)",
          "559: {",
          "560:     int i;",
          "561:     s->acfilter_order = get_bits(&s->gb, 4) + 1;",
          "562:     s->acfilter_scaling = get_bits(&s->gb, 4);",
          "564:     for(i = 0; i < s->acfilter_order; i++) {",
          "565:         s->acfilter_coeffs[i] = get_bits(&s->gb, s->acfilter_scaling) + 1;",
          "566:     }",
          "567: }",
          "573: static void decode_mclms(WmallDecodeCtx *s)",
          "574: {",
          "575:     s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;",
          "576:     s->mclms_scaling = get_bits(&s->gb, 4);",
          "577:     if(get_bits1(&s->gb)) {",
          "579:         int i;",
          "580:         int send_coef_bits;",
          "581:         int cbits = av_log2(s->mclms_scaling + 1);",
          "582:         assert(cbits == my_log2(s->mclms_scaling + 1));",
          "583:         if(1 << cbits < s->mclms_scaling + 1)",
          "584:             cbits++;",
          "586:         send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;",
          "588:         for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {",
          "589:             s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);",
          "590:         }",
          "592:         for(i = 0; i < s->num_channels; i++) {",
          "593:             int c;",
          "594:             for(c = 0; c < i; c++) {",
          "595:                 s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);",
          "596:             }",
          "597:         }",
          "598:     }",
          "599: }",
          "605: static void decode_cdlms(WmallDecodeCtx *s)",
          "606: {",
          "607:     int c, i;",
          "608:     int cdlms_send_coef = get_bits1(&s->gb);",
          "610:     for(c = 0; c < s->num_channels; c++) {",
          "611:         s->cdlms_ttl[c] = get_bits(&s->gb, 3) + 1;",
          "612:         for(i = 0; i < s->cdlms_ttl[c]; i++) {",
          "613:             s->cdlms[c][i].order = (get_bits(&s->gb, 7) + 1) * 8;",
          "614:         }",
          "616:         for(i = 0; i < s->cdlms_ttl[c]; i++) {",
          "617:             s->cdlms[c][i].scaling = get_bits(&s->gb, 4);",
          "618:         }",
          "620:         if(cdlms_send_coef) {",
          "621:             for(i = 0; i < s->cdlms_ttl[c]; i++) {",
          "622:                 int cbits, shift_l, shift_r, j;",
          "623:                 cbits = av_log2(s->cdlms[c][i].order);",
          "624:                 if(1 << cbits < s->cdlms[c][i].order)",
          "625:                     cbits++;",
          "626:                 s->cdlms[c][i].coefsend = get_bits(&s->gb, cbits) + 1;",
          "628:                 cbits = av_log2(s->cdlms[c][i].scaling + 1);",
          "629:                 if(1 << cbits < s->cdlms[c][i].scaling + 1)",
          "630:                     cbits++;",
          "632:                 s->cdlms[c][i].bitsend = get_bits(&s->gb, cbits) + 2;",
          "633:                 shift_l = 32 - s->cdlms[c][i].bitsend;",
          "634:                 shift_r = 32 - 2 - s->cdlms[c][i].scaling;",
          "635:                 for(j = 0; j < s->cdlms[c][i].coefsend; j++) {",
          "636:                     s->cdlms[c][i].coefs[j] =",
          "637:                         (get_bits(&s->gb, s->cdlms[c][i].bitsend) << shift_l) >> shift_r;",
          "638:                 }",
          "639:             }",
          "640:         }",
          "641:     }",
          "642: }",
          "647: static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)",
          "648: {",
          "649:     int i = 0;",
          "650:     unsigned int ave_mean;",
          "651:     s->transient[ch] = get_bits1(&s->gb);",
          "652:     if(s->transient[ch])",
          "653:         s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));",
          "655:     if(s->seekable_tile) {",
          "656:         ave_mean = get_bits(&s->gb, s->bits_per_sample);",
          "657:         s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);",
          "659:     }",
          "661:     if(s->seekable_tile) {",
          "662:         if(s->do_inter_ch_decorr)",
          "663:             s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);",
          "664:         else",
          "665:             s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);",
          "666:         i++;",
          "667:     }",
          "668:     for(; i < tile_size; i++) {",
          "669:         int quo = 0, rem, rem_bits, residue;",
          "670:         while(get_bits1(&s->gb))",
          "671:             quo++;",
          "672:         if(quo >= 32)",
          "673:             quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);",
          "675:                ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);",
          "676:         rem_bits = av_ceil_log2(ave_mean);",
          "677:         rem = rem_bits ? get_bits(&s->gb, rem_bits) : 0;",
          "678:         residue = (quo << rem_bits) + rem;",
          "680:         s->ave_sum[ch] = residue + s->ave_sum[ch] - (s->ave_sum[ch] >> s->movave_scaling);",
          "682:         if(residue & 1)",
          "683:             residue = -(residue >> 1) - 1;",
          "684:         else",
          "685:             residue = residue >> 1;",
          "686:         s->channel_residues[ch][i] = residue;",
          "689:     }",
          "691:     return 0;",
          "693: }",
          "699: static void",
          "700: decode_lpc(WmallDecodeCtx *s)",
          "701: {",
          "702:     int ch, i, cbits;",
          "703:     s->lpc_order = get_bits(&s->gb, 5) + 1;",
          "704:     s->lpc_scaling = get_bits(&s->gb, 4);",
          "705:     s->lpc_intbits = get_bits(&s->gb, 3) + 1;",
          "706:     cbits = s->lpc_scaling + s->lpc_intbits;",
          "707:     for(ch = 0; ch < s->num_channels; ch++) {",
          "708:         for(i = 0; i < s->lpc_order; i++) {",
          "709:             s->lpc_coefs[ch][i] = get_sbits(&s->gb, cbits);",
          "710:         }",
          "711:     }",
          "712: }",
          "721: static int decode_subframe(WmallDecodeCtx *s)",
          "722: {",
          "723:     int offset = s->samples_per_frame;",
          "724:     int subframe_len = s->samples_per_frame;",
          "725:     int i;",
          "726:     int total_samples   = s->samples_per_frame * s->num_channels;",
          "727:     int rawpcm_tile;",
          "728:     int padding_zeroes;",
          "730:     s->subframe_offset = get_bits_count(&s->gb);",
          "733:         == the next block of the channel with the smallest number of",
          "734:         decoded samples",
          "736:     for (i = 0; i < s->num_channels; i++) {",
          "737:         s->channel[i].grouped = 0;",
          "738:         if (offset > s->channel[i].decoded_samples) {",
          "739:             offset = s->channel[i].decoded_samples;",
          "740:             subframe_len =",
          "741:                 s->channel[i].subframe_len[s->channel[i].cur_subframe];",
          "742:         }",
          "743:     }",
          "746:     s->channels_for_cur_subframe = 0;",
          "747:     for (i = 0; i < s->num_channels; i++) {",
          "748:         const int cur_subframe = s->channel[i].cur_subframe;",
          "750:         total_samples -= s->channel[i].decoded_samples;",
          "753:         if (offset == s->channel[i].decoded_samples &&",
          "754:             subframe_len == s->channel[i].subframe_len[cur_subframe]) {",
          "755:             total_samples -= s->channel[i].subframe_len[cur_subframe];",
          "756:             s->channel[i].decoded_samples +=",
          "757:                 s->channel[i].subframe_len[cur_subframe];",
          "758:             s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;",
          "759:             ++s->channels_for_cur_subframe;",
          "760:         }",
          "761:     }",
          "765:     if (!total_samples)",
          "766:         s->parsed_all_subframes = 1;",
          "769:     s->seekable_tile = get_bits1(&s->gb);",
          "770:     if(s->seekable_tile) {",
          "771:         s->do_arith_coding    = get_bits1(&s->gb);",
          "772:         if(s->do_arith_coding) {",
          "773:             dprintf(s->avctx, \"do_arith_coding == 1\");",
          "774:             abort();",
          "775:         }",
          "776:         s->do_ac_filter       = get_bits1(&s->gb);",
          "777:         s->do_inter_ch_decorr = get_bits1(&s->gb);",
          "778:         s->do_mclms           = get_bits1(&s->gb);",
          "780:         if(s->do_ac_filter)",
          "781:             decode_ac_filter(s);",
          "783:         if(s->do_mclms)",
          "784:             decode_mclms(s);",
          "786:         decode_cdlms(s);",
          "787:         s->movave_scaling = get_bits(&s->gb, 3);",
          "788:         s->quant_stepsize = get_bits(&s->gb, 8) + 1;",
          "789:     }",
          "791:     rawpcm_tile = get_bits1(&s->gb);",
          "793:     for(i = 0; i < s->num_channels; i++) {",
          "794:         s->is_channel_coded[i] = 1;",
          "795:     }",
          "797:     if(!rawpcm_tile) {",
          "799:         for(i = 0; i < s->num_channels; i++) {",
          "800:             s->is_channel_coded[i] = get_bits1(&s->gb);",
          "801:         }",
          "803:         if(s->bV3RTM) {",
          "805:             s->do_lpc = get_bits1(&s->gb);",
          "806:             if(s->do_lpc) {",
          "807:                 decode_lpc(s);",
          "808:             }",
          "809:         } else {",
          "810:             s->do_lpc = 0;",
          "811:         }",
          "812:     }",
          "815:     if(get_bits1(&s->gb)) {",
          "816:         padding_zeroes = get_bits(&s->gb, 5);",
          "817:     } else {",
          "818:         padding_zeroes = 0;",
          "819:     }",
          "821:     if(rawpcm_tile) {",
          "823:         int bits = s->bits_per_sample - padding_zeroes;",
          "824:         int j;",
          "825:         dprintf(s->avctx, \"RAWPCM %d bits per sample. total %d bits, remain=%d\\n\", bits,",
          "826:                 bits * s->num_channels * subframe_len, get_bits_count(&s->gb));",
          "827:         for(i = 0; i < s->num_channels; i++) {",
          "828:             for(j = 0; j < subframe_len; j++) {",
          "829:                 s->channel_coeffs[i][j] = get_sbits(&s->gb, bits);",
          "831:             }",
          "832:         }",
          "833:     } else {",
          "834:         for(i = 0; i < s->num_channels; i++)",
          "835:             if(s->is_channel_coded[i])",
          "836:                 decode_channel_residues(s, i, subframe_len);",
          "837:     }",
          "841:     for (i = 0; i < s->channels_for_cur_subframe; i++) {",
          "842:         int c = s->channel_indexes_for_cur_subframe[i];",
          "843:         if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {",
          "844:             av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");",
          "845:             return AVERROR_INVALIDDATA;",
          "846:         }",
          "847:         ++s->channel[c].cur_subframe;",
          "848:     }",
          "849:     return 0;",
          "850: }",
          "858: static int decode_frame(WmallDecodeCtx *s)",
          "859: {",
          "860:     GetBitContext* gb = &s->gb;",
          "861:     int more_frames = 0;",
          "862:     int len = 0;",
          "863:     int i;",
          "866:     if (s->num_channels * s->samples_per_frame > s->samples_end - s->samples) {",
          "868:         av_log(s->avctx, AV_LOG_ERROR,",
          "869:                \"not enough space for the output samples\\n\");",
          "870:         s->packet_loss = 1;",
          "871:         return 0;",
          "872:     }",
          "875:     if (s->len_prefix)",
          "876:         len = get_bits(gb, s->log2_frame_size);",
          "879:     if (decode_tilehdr(s)) {",
          "880:         s->packet_loss = 1;",
          "881:         return 0;",
          "882:     }",
          "885:     if (s->dynamic_range_compression) {",
          "886:         s->drc_gain = get_bits(gb, 8);",
          "887:     }",
          "891:     if (get_bits1(gb)) {",
          "892:         int skip;",
          "895:         if (get_bits1(gb)) {",
          "896:             skip = get_bits(gb, av_log2(s->samples_per_frame * 2));",
          "897:             dprintf(s->avctx, \"start skip: %i\\n\", skip);",
          "898:         }",
          "901:         if (get_bits1(gb)) {",
          "902:             skip = get_bits(gb, av_log2(s->samples_per_frame * 2));",
          "903:             dprintf(s->avctx, \"end skip: %i\\n\", skip);",
          "904:         }",
          "906:     }",
          "909:     s->parsed_all_subframes = 0;",
          "910:     for (i = 0; i < s->num_channels; i++) {",
          "911:         s->channel[i].decoded_samples = 0;",
          "912:         s->channel[i].cur_subframe    = 0;",
          "913:         s->channel[i].reuse_sf        = 0;",
          "914:     }",
          "917:     while (!s->parsed_all_subframes) {",
          "918:         if (decode_subframe(s) < 0) {",
          "919:             s->packet_loss = 1;",
          "920:             return 0;",
          "921:         }",
          "922:     }",
          "924:     dprintf(s->avctx, \"Frame done\\n\");",
          "926:     if (s->skip_frame) {",
          "927:         s->skip_frame = 0;",
          "928:     } else",
          "929:         s->samples += s->num_channels * s->samples_per_frame;",
          "931:     if (s->len_prefix) {",
          "932:         if (len != (get_bits_count(gb) - s->frame_offset) + 2) {",
          "934:             av_log(s->avctx, AV_LOG_ERROR,",
          "935:                    \"frame[%i] would have to skip %i bits\\n\", s->frame_num,",
          "936:                    len - (get_bits_count(gb) - s->frame_offset) - 1);",
          "937:             s->packet_loss = 1;",
          "938:             return 0;",
          "939:         }",
          "942:         skip_bits_long(gb, len - (get_bits_count(gb) - s->frame_offset) - 1);",
          "943:     } else {",
          "945:         while (get_bits_count(gb) < s->num_saved_bits && get_bits1(gb) == 0) {",
          "946:             dprintf(s->avctx, \"skip1\\n\");",
          "947:         }",
          "949:     }",
          "952:     more_frames = get_bits1(gb);",
          "953:     ++s->frame_num;",
          "954:     return more_frames;",
          "955: }",
          "963: static int remaining_bits(WmallDecodeCtx *s, GetBitContext *gb)",
          "964: {",
          "965:     return s->buf_bit_size - get_bits_count(gb);",
          "966: }",
          "975: static void save_bits(WmallDecodeCtx *s, GetBitContext* gb, int len,",
          "976:                       int append)",
          "977: {",
          "978:     int buflen;",
          "981:         is resetted and additional bits from the previous frame are copyed",
          "984:     if (!append) {",
          "985:         s->frame_offset = get_bits_count(gb) & 7;",
          "986:         s->num_saved_bits = s->frame_offset;",
          "987:         init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);",
          "988:     }",
          "990:     buflen = (s->num_saved_bits + len + 8) >> 3;",
          "992:     if (len <= 0 || buflen > MAX_FRAMESIZE) {",
          "993:         av_log_ask_for_sample(s->avctx, \"input buffer too small\\n\");",
          "994:         s->packet_loss = 1;",
          "995:         return;",
          "996:     }",
          "998:     s->num_saved_bits += len;",
          "999:     if (!append) {",
          "1000:         avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),",
          "1001:                      s->num_saved_bits);",
          "1002:     } else {",
          "1003:         int align = 8 - (get_bits_count(gb) & 7);",
          "1004:         align = FFMIN(align, len);",
          "1005:         put_bits(&s->pb, align, get_bits(gb, align));",
          "1006:         len -= align;",
          "1007:         avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);",
          "1008:     }",
          "1009:     skip_bits_long(gb, len);",
          "1011:     {",
          "1012:         PutBitContext tmp = s->pb;",
          "1013:         flush_put_bits(&tmp);",
          "1014:     }",
          "1016:     init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);",
          "1017:     skip_bits(&s->gb, s->frame_offset);",
          "1018: }",
          "1028: static int decode_packet(AVCodecContext *avctx,",
          "1029:                          void *data, int *data_size, AVPacket* avpkt)",
          "1030: {",
          "1031:     WmallDecodeCtx *s = avctx->priv_data;",
          "1032:     GetBitContext* gb  = &s->pgb;",
          "1033:     const uint8_t* buf = avpkt->data;",
          "1034:     int buf_size       = avpkt->size;",
          "1035:     int num_bits_prev_frame;",
          "1036:     int packet_sequence_number;",
          "1038:     s->samples       = data;",
          "1039:     s->samples_end   = (float*)((int8_t*)data + *data_size);",
          "1042:     if (s->packet_done || s->packet_loss) {",
          "1043:         s->packet_done = 0;",
          "1046:         if (buf_size < avctx->block_align)",
          "1047:             return 0;",
          "1049:         s->next_packet_start = buf_size - avctx->block_align;",
          "1050:         buf_size = avctx->block_align;",
          "1051:         s->buf_bit_size = buf_size << 3;",
          "1054:         init_get_bits(gb, buf, s->buf_bit_size);",
          "1055:         packet_sequence_number = get_bits(gb, 4);",
          "1056:         int seekable_frame_in_packet = get_bits1(gb);",
          "1057:         int spliced_packet = get_bits1(gb);",
          "1060:         num_bits_prev_frame = get_bits(gb, s->log2_frame_size);",
          "1063:         if (!s->packet_loss &&",
          "1064:             ((s->packet_sequence_number + 1) & 0xF) != packet_sequence_number) {",
          "1065:             s->packet_loss = 1;",
          "1066:             av_log(avctx, AV_LOG_ERROR, \"Packet loss detected! seq %x vs %x\\n\",",
          "1067:                    s->packet_sequence_number, packet_sequence_number);",
          "1068:         }",
          "1069:         s->packet_sequence_number = packet_sequence_number;",
          "1071:         if (num_bits_prev_frame > 0) {",
          "1072:             int remaining_packet_bits = s->buf_bit_size - get_bits_count(gb);",
          "1073:             if (num_bits_prev_frame >= remaining_packet_bits) {",
          "1074:                 num_bits_prev_frame = remaining_packet_bits;",
          "1075:                 s->packet_done = 1;",
          "1076:             }",
          "1080:             save_bits(s, gb, num_bits_prev_frame, 1);",
          "1083:             if (!s->packet_loss)",
          "1084:                 decode_frame(s);",
          "1085:         } else if (s->num_saved_bits - s->frame_offset) {",
          "1086:             dprintf(avctx, \"ignoring %x previously saved bits\\n\",",
          "1087:                     s->num_saved_bits - s->frame_offset);",
          "1088:         }",
          "1090:         if (s->packet_loss) {",
          "1092:                 does not start to decode incomplete frames in the",
          "1094:             s->num_saved_bits = 0;",
          "1095:             s->packet_loss = 0;",
          "1096:         }",
          "1098:     } else {",
          "1099:         int frame_size;",
          "1101:         s->buf_bit_size = (avpkt->size - s->next_packet_start) << 3;",
          "1102:         init_get_bits(gb, avpkt->data, s->buf_bit_size);",
          "1103:         skip_bits(gb, s->packet_offset);",
          "1105:         if (s->len_prefix && remaining_bits(s, gb) > s->log2_frame_size &&",
          "1106:             (frame_size = show_bits(gb, s->log2_frame_size)) &&",
          "1107:             frame_size <= remaining_bits(s, gb)) {",
          "1108:             save_bits(s, gb, frame_size, 0);",
          "1109:             s->packet_done = !decode_frame(s);",
          "1110:         } else if (!s->len_prefix",
          "1111:                    && s->num_saved_bits > get_bits_count(&s->gb)) {",
          "1113:                 the compressed length of the individual frames",
          "1114:                 however, we know what part of a new packet belongs to the",
          "1115:                 previous frame",
          "1116:                 therefore we save the incoming packet first, then we append",
          "1117:                 the \"previous frame\" data from the next packet so that",
          "1119:             s->packet_done = !decode_frame(s);",
          "1120:         } else {",
          "1121:             s->packet_done = 1;",
          "1122:         }",
          "1123:     }",
          "1125:     if (s->packet_done && !s->packet_loss &&",
          "1126:         remaining_bits(s, gb) > 0) {",
          "1129:         save_bits(s, gb, remaining_bits(s, gb), 0);",
          "1130:     }",
          "1133:     s->packet_offset = get_bits_count(gb) & 7;",
          "1135:     return (s->packet_loss) ? AVERROR_INVALIDDATA : get_bits_count(gb) >> 3;",
          "1136: }",
          "1142: static void flush(AVCodecContext *avctx)",
          "1143: {",
          "1144:     WmallDecodeCtx *s = avctx->priv_data;",
          "1145:     int i;",
          "1148:     for (i = 0; i < s->num_channels; i++)",
          "1149:         memset(s->channel[i].out, 0, s->samples_per_frame *",
          "1150:                sizeof(*s->channel[i].out));",
          "1151:     s->packet_loss = 1;",
          "1152: }",
          "1158: AVCodec ff_wmalossless_decoder = {",
          "1159:     \"wmalossless\",",
          "1160:     AVMEDIA_TYPE_AUDIO,",
          "1161:     CODEC_ID_WMALOSSLESS,",
          "1162:     sizeof(WmallDecodeCtx),",
          "1163:     decode_init,",
          "1164:     NULL,",
          "1165:     decode_end,",
          "1166:     decode_packet,",
          "1167:     .capabilities = CODEC_CAP_SUBFRAMES | CODEC_CAP_EXPERIMENTAL,",
          "1168:     .flush= flush,",
          "1169:     .long_name = NULL_IF_CONFIG_SMALL(\"Windows Media Audio 9 Lossless\"),",
          "1170: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "36d8914f1b94e4731d2fc67162902839c106e72e",
      "candidate_info": {
        "commit_hash": "36d8914f1b94e4731d2fc67162902839c106e72e",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/36d8914f1b94e4731d2fc67162902839c106e72e",
        "files": [
          "libavcodec/wmalosslessdec.c"
        ],
        "message": "wmalosslessdec: fix mclms_coeffs* array size\n\nFixes corruption of context\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nCC:libav-stable@libav.org\nBug-Id: CVE-2014-2098\nSigned-off-by: Anton Khirnov <anton@khirnov.net>\n(cherry picked from commit 849b9d34c7ef70b370c53e7af3940f51cbc07d0f)\nSigned-off-by: Anton Khirnov <anton@khirnov.net>",
        "before_after_code_files": [
          "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ],
          "candidate": [
            "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/wmalosslessdec.c||libavcodec/wmalosslessdec.c": [
          "File: libavcodec/wmalosslessdec.c -> libavcodec/wmalosslessdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:     int8_t  mclms_order;",
          "129:     int8_t  mclms_scaling;",
          "132:     int16_t mclms_prevvalues[WMALL_MAX_CHANNELS * 2 * 32];",
          "133:     int16_t mclms_updates[WMALL_MAX_CHANNELS * 2 * 32];",
          "134:     int     mclms_recent;",
          "",
          "[Removed Lines]",
          "130:     int16_t mclms_coeffs[128];",
          "131:     int16_t mclms_coeffs_cur[4];",
          "",
          "[Added Lines]",
          "130:     int16_t mclms_coeffs[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS * 32];",
          "131:     int16_t mclms_coeffs_cur[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS];",
          "",
          "---------------"
        ]
      }
    }
  ]
}
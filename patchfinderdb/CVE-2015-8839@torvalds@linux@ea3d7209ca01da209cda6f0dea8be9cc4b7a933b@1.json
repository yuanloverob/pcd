{
  "cve_id": "CVE-2015-8839",
  "cve_desc": "Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.",
  "repo": "torvalds/linux",
  "patch_hash": "ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
  "patch_info": {
    "commit_hash": "ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
    "files": [
      "fs/ext4/ext4.h",
      "fs/ext4/extents.c",
      "fs/ext4/file.c",
      "fs/ext4/inode.c",
      "fs/ext4/super.c",
      "fs/ext4/truncate.h"
    ],
    "message": "ext4: fix races between page faults and hole punching\n\nCurrently, page faults and hole punching are completely unsynchronized.\nThis can result in page fault faulting in a page into a range that we\nare punching after truncate_pagecache_range() has been called and thus\nwe can end up with a page mapped to disk blocks that will be shortly\nfreed. Filesystem corruption will shortly follow. Note that the same\nrace is avoided for truncate by checking page fault offset against\ni_size but there isn't similar mechanism available for punching holes.\n\nFix the problem by creating new rw semaphore i_mmap_sem in inode and\ngrab it for writing over truncate, hole punching, and other functions\nremoving blocks from extent tree and for read over page faults. We\ncannot easily use i_data_sem for this since that ranks below transaction\nstart and we need something ranking above it so that it can be held over\nthe whole truncate / hole punching operation. Also remove various\nworkarounds we had in the code to reduce race window when page fault\ncould have created pages with stale mapping information.\n\nSigned-off-by: Jan Kara <jack@suse.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/ext4.h||fs/ext4/ext4.h",
      "fs/ext4/extents.c||fs/ext4/extents.c",
      "fs/ext4/file.c||fs/ext4/file.c",
      "fs/ext4/inode.c||fs/ext4/inode.c",
      "fs/ext4/super.c||fs/ext4/super.c",
      "fs/ext4/truncate.h||fs/ext4/truncate.h"
    ]
  },
  "patch_diff": {
    "fs/ext4/ext4.h||fs/ext4/ext4.h": [
      "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "912:  struct rw_semaphore i_data_sem;",
      "913:  struct inode vfs_inode;",
      "914:  struct jbd2_inode *jinode;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "921:  struct rw_semaphore i_mmap_sem;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2484: extern int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,",
      "2485:         loff_t lstart, loff_t lend);",
      "2486: extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);",
      "2487: extern qsize_t *ext4_get_reserved_space(struct inode *inode);",
      "2488: extern void ext4_da_update_reserve_space(struct inode *inode,",
      "2489:      int used, int quota_claim);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2496: extern int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf);",
      "",
      "---------------"
    ],
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4770:  int partial_begin, partial_end;",
      "4771:  loff_t start, end;",
      "4772:  ext4_lblk_t lblk;",
      "4774:  unsigned int blkbits = inode->i_blkbits;",
      "4776:  trace_ext4_zero_range(inode, offset, len, mode);",
      "",
      "[Removed Lines]",
      "4773:  struct address_space *mapping = inode->i_mapping;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4785:    return ret;",
      "4786:  }",
      "",
      "[Removed Lines]",
      "4792:  if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {",
      "4793:   ret = filemap_write_and_wait_range(mapping, offset,",
      "4794:          offset + len - 1);",
      "4795:   if (ret)",
      "4796:    return ret;",
      "4797:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4856:   flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |",
      "4857:      EXT4_EX_NOCACHE);",
      "4864:   ext4_inode_block_unlocked_dio(inode);",
      "4865:   inode_dio_wait(inode);",
      "4867:   ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,",
      "4868:           flags, mode);",
      "4869:   if (ret)",
      "4870:    goto out_dio;",
      "4871:  }",
      "",
      "[Removed Lines]",
      "4860:   truncate_pagecache_range(inode, start, end - 1);",
      "4861:   inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
      "",
      "[Added Lines]",
      "4855:   down_write(&EXT4_I(inode)->i_mmap_sem);",
      "4857:   truncate_pagecache_range(inode, start, end - 1);",
      "4858:   inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
      "4862:   up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "5524:   goto out_mutex;",
      "5525:  }",
      "5530:  ext4_inode_block_unlocked_dio(inode);",
      "5531:  inode_dio_wait(inode);",
      "5533:  credits = ext4_writepage_trans_blocks(inode);",
      "5534:  handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);",
      "5535:  if (IS_ERR(handle)) {",
      "5536:   ret = PTR_ERR(handle);",
      "5538:  }",
      "5540:  down_write(&EXT4_I(inode)->i_data_sem);",
      "",
      "[Removed Lines]",
      "5527:  truncate_pagecache(inode, ioffset);",
      "5537:   goto out_dio;",
      "",
      "[Added Lines]",
      "5529:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "5530:  truncate_pagecache(inode, ioffset);",
      "5536:   goto out_mmap;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "5574: out_stop:",
      "5575:  ext4_journal_stop(handle);",
      "5577:  ext4_inode_resume_unlocked_dio(inode);",
      "5578: out_mutex:",
      "5579:  mutex_unlock(&inode->i_mutex);",
      "",
      "[Removed Lines]",
      "5576: out_dio:",
      "",
      "[Added Lines]",
      "5575: out_mmap:",
      "5576:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "5660:   goto out_mutex;",
      "5661:  }",
      "5666:  ext4_inode_block_unlocked_dio(inode);",
      "5667:  inode_dio_wait(inode);",
      "5669:  credits = ext4_writepage_trans_blocks(inode);",
      "5670:  handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);",
      "5671:  if (IS_ERR(handle)) {",
      "5672:   ret = PTR_ERR(handle);",
      "5674:  }",
      "",
      "[Removed Lines]",
      "5663:  truncate_pagecache(inode, ioffset);",
      "5673:   goto out_dio;",
      "",
      "[Added Lines]",
      "5671:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "5672:  truncate_pagecache(inode, ioffset);",
      "5678:   goto out_mmap;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "5742: out_stop:",
      "5743:  ext4_journal_stop(handle);",
      "5745:  ext4_inode_resume_unlocked_dio(inode);",
      "5746: out_mutex:",
      "5747:  mutex_unlock(&inode->i_mutex);",
      "",
      "[Removed Lines]",
      "5744: out_dio:",
      "",
      "[Added Lines]",
      "5749: out_mmap:",
      "5750:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------"
    ],
    "fs/ext4/file.c||fs/ext4/file.c": [
      "File: fs/ext4/file.c -> fs/ext4/file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "209: {",
      "210:  int result;",
      "211:  handle_t *handle = NULL;",
      "213:  bool write = vmf->flags & FAULT_FLAG_WRITE;",
      "215:  if (write) {",
      "216:   sb_start_pagefault(sb);",
      "217:   file_update_time(vma->vm_file);",
      "218:   handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,",
      "219:       EXT4_DATA_TRANS_BLOCKS(sb));",
      "222:  if (IS_ERR(handle))",
      "223:   result = VM_FAULT_SIGBUS;",
      "",
      "[Removed Lines]",
      "212:  struct super_block *sb = file_inode(vma->vm_file)->i_sb;",
      "220:  }",
      "",
      "[Added Lines]",
      "212:  struct inode *inode = file_inode(vma->vm_file);",
      "213:  struct super_block *sb = inode->i_sb;",
      "219:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "222:  } else",
      "223:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "228:  if (write) {",
      "229:   if (!IS_ERR(handle))",
      "230:    ext4_journal_stop(handle);",
      "231:   sb_end_pagefault(sb);",
      "234:  return result;",
      "235: }",
      "",
      "[Removed Lines]",
      "232:  }",
      "",
      "[Added Lines]",
      "234:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "236:  } else",
      "237:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "246:  if (write) {",
      "247:   sb_start_pagefault(sb);",
      "248:   file_update_time(vma->vm_file);",
      "249:   handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,",
      "250:     ext4_chunk_trans_blocks(inode,",
      "251:        PMD_SIZE / PAGE_SIZE));",
      "254:  if (IS_ERR(handle))",
      "255:   result = VM_FAULT_SIGBUS;",
      "",
      "[Removed Lines]",
      "252:  }",
      "",
      "[Added Lines]",
      "254:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "258:  } else",
      "259:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "260:  if (write) {",
      "261:   if (!IS_ERR(handle))",
      "262:    ext4_journal_stop(handle);",
      "263:   sb_end_pagefault(sb);",
      "266:  return result;",
      "267: }",
      "269: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
      "270: {",
      "273: }",
      "275: static const struct vm_operations_struct ext4_dax_vm_ops = {",
      "276:  .fault  = ext4_dax_fault,",
      "277:  .pmd_fault = ext4_dax_pmd_fault,",
      "278:  .page_mkwrite = ext4_dax_mkwrite,",
      "280: };",
      "281: #else",
      "282: #define ext4_dax_vm_ops ext4_file_vm_ops",
      "283: #endif",
      "285: static const struct vm_operations_struct ext4_file_vm_ops = {",
      "287:  .map_pages = filemap_map_pages,",
      "288:  .page_mkwrite   = ext4_page_mkwrite,",
      "289: };",
      "",
      "[Removed Lines]",
      "264:  }",
      "271:  return dax_mkwrite(vma, vmf, ext4_get_block_dax,",
      "272:     ext4_end_io_unwritten);",
      "279:  .pfn_mkwrite = dax_pfn_mkwrite,",
      "286:  .fault  = filemap_fault,",
      "",
      "[Added Lines]",
      "270:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "272:  } else",
      "273:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "280:  int err;",
      "281:  struct inode *inode = file_inode(vma->vm_file);",
      "283:  sb_start_pagefault(inode->i_sb);",
      "284:  file_update_time(vma->vm_file);",
      "285:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "286:  err = __dax_mkwrite(vma, vmf, ext4_get_block_dax,",
      "287:        ext4_end_io_unwritten);",
      "288:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "289:  sb_end_pagefault(inode->i_sb);",
      "291:  return err;",
      "292: }",
      "303: static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,",
      "304:     struct vm_fault *vmf)",
      "305: {",
      "306:  struct inode *inode = file_inode(vma->vm_file);",
      "307:  struct super_block *sb = inode->i_sb;",
      "308:  int ret = VM_FAULT_NOPAGE;",
      "309:  loff_t size;",
      "311:  sb_start_pagefault(sb);",
      "312:  file_update_time(vma->vm_file);",
      "313:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "314:  size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;",
      "315:  if (vmf->pgoff >= size)",
      "316:   ret = VM_FAULT_SIGBUS;",
      "317:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "318:  sb_end_pagefault(sb);",
      "320:  return ret;",
      "327:  .pfn_mkwrite = ext4_dax_pfn_mkwrite,",
      "334:  .fault  = ext4_filemap_fault,",
      "",
      "---------------"
    ],
    "fs/ext4/inode.c||fs/ext4/inode.c": [
      "File: fs/ext4/inode.c -> fs/ext4/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3624:  }",
      "3626:  first_block_offset = round_up(offset, sb->s_blocksize);",
      "3627:  last_block_offset = round_down((offset + length), sb->s_blocksize) - 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3627:  ext4_inode_block_unlocked_dio(inode);",
      "3628:  inode_dio_wait(inode);",
      "3634:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3631:   truncate_pagecache_range(inode, first_block_offset,",
      "3632:       last_block_offset);",
      "3638:  if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
      "3639:   credits = ext4_writepage_trans_blocks(inode);",
      "3640:  else",
      "",
      "[Removed Lines]",
      "3635:  ext4_inode_block_unlocked_dio(inode);",
      "3636:  inode_dio_wait(inode);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3680:  if (IS_SYNC(inode))",
      "3681:   ext4_handle_sync(handle);",
      "3688:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
      "3689:  ext4_mark_inode_dirty(handle, inode);",
      "3690: out_stop:",
      "3691:  ext4_journal_stop(handle);",
      "3692: out_dio:",
      "3693:  ext4_inode_resume_unlocked_dio(inode);",
      "3694: out_mutex:",
      "3695:  mutex_unlock(&inode->i_mutex);",
      "",
      "[Removed Lines]",
      "3684:  if (last_block_offset > first_block_offset)",
      "3685:   truncate_pagecache_range(inode, first_block_offset,",
      "3686:       last_block_offset);",
      "",
      "[Added Lines]",
      "3693:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4823:    } else",
      "4824:     ext4_wait_for_tail_page_commit(inode);",
      "4825:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4827:   down_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4830:   truncate_pagecache(inode, inode->i_size);",
      "4831:   if (shrink)",
      "4832:    ext4_truncate(inode);",
      "4833:  }",
      "4835:  if (!rc) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4835:   up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "5279:  sb_start_pagefault(inode->i_sb);",
      "5280:  file_update_time(vma->vm_file);",
      "5282:  if (test_opt(inode->i_sb, DELALLOC) &&",
      "5283:      !ext4_should_journal_data(inode) &&",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5285:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "5347: out_ret:",
      "5348:  ret = block_page_mkwrite_return(ret);",
      "5349: out:",
      "5350:  sb_end_pagefault(inode->i_sb);",
      "5351:  return ret;",
      "5352: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5355:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "5360: int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
      "5361: {",
      "5362:  struct inode *inode = file_inode(vma->vm_file);",
      "5363:  int err;",
      "5365:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "5366:  err = filemap_fault(vma, vmf);",
      "5367:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "5369:  return err;",
      "5370: }",
      "",
      "---------------"
    ],
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "958:  INIT_LIST_HEAD(&ei->i_orphan);",
      "959:  init_rwsem(&ei->xattr_sem);",
      "960:  init_rwsem(&ei->i_data_sem);",
      "961:  inode_init_once(&ei->vfs_inode);",
      "962: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "961:  init_rwsem(&ei->i_mmap_sem);",
      "",
      "---------------"
    ],
    "fs/ext4/truncate.h||fs/ext4/truncate.h": [
      "File: fs/ext4/truncate.h -> fs/ext4/truncate.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "11: static inline void ext4_truncate_failed_write(struct inode *inode)",
      "12: {",
      "13:  truncate_inode_pages(inode->i_mapping, inode->i_size);",
      "14:  ext4_truncate(inode);",
      "15: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "16:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e676a4c191653787c3fe851fe3b9f1f33d49dac2",
      "candidate_info": {
        "commit_hash": "e676a4c191653787c3fe851fe3b9f1f33d49dac2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e676a4c191653787c3fe851fe3b9f1f33d49dac2",
        "files": [
          "fs/ext4/file.c"
        ],
        "message": "ext4: use ext4_get_block_write() for DAX\n\nDAX relies on the get_block function either zeroing newly allocated\nblocks before they're findable by subsequent calls to get_block, or\nmarking newly allocated blocks as unwritten.  ext4_get_block() cannot\ncreate unwritten extents, but ext4_get_block_write() can.\n\nSigned-off-by: Matthew Wilcox <willy@linux.intel.com>\nReported-by: Andy Rudoff <andy.rudoff@intel.com>\nCc: Theodore Ts'o <tytso@mit.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ext4/file.c||fs/ext4/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/file.c||fs/ext4/file.c"
          ],
          "candidate": [
            "fs/ext4/file.c||fs/ext4/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "208: static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "209: {",
          "212: }",
          "214: static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,",
          "",
          "[Removed Lines]",
          "210:  return dax_fault(vma, vmf, ext4_get_block, ext4_end_io_unwritten);",
          "",
          "[Added Lines]",
          "210:  return dax_fault(vma, vmf, ext4_get_block_write, ext4_end_io_unwritten);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "221: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "222: {",
          "224: }",
          "226: static const struct vm_operations_struct ext4_dax_vm_ops = {",
          "",
          "[Removed Lines]",
          "223:  return dax_mkwrite(vma, vmf, ext4_get_block, ext4_end_io_unwritten);",
          "",
          "[Added Lines]",
          "222:  return dax_mkwrite(vma, vmf, ext4_get_block_write,",
          "223:     ext4_end_io_unwritten);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "923ae0ff9250430133b3310fe62c47538cf1cbc1",
      "candidate_info": {
        "commit_hash": "923ae0ff9250430133b3310fe62c47538cf1cbc1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/923ae0ff9250430133b3310fe62c47538cf1cbc1",
        "files": [
          "Documentation/filesystems/dax.txt",
          "Documentation/filesystems/ext4.txt",
          "fs/ext4/ext4.h",
          "fs/ext4/file.c",
          "fs/ext4/indirect.c",
          "fs/ext4/inode.c",
          "fs/ext4/namei.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: add DAX functionality\n\nThis is a port of the DAX functionality found in the current version of\next2.\n\n[matthew.r.wilcox@intel.com: heavily tweaked]\n[akpm@linux-foundation.org: remap_pages went away]\nSigned-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>\nReviewed-by: Andreas Dilger <andreas.dilger@intel.com>\nSigned-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>\nCc: Boaz Harrosh <boaz@plexistor.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Dave Chinner <david@fromorbit.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>\nCc: Randy Dunlap <rdunlap@infradead.org>\nCc: Theodore Ts'o <tytso@mit.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/ext4/indirect.c||fs/ext4/indirect.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/namei.c||fs/ext4/namei.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "965: #define EXT4_MOUNT_ERRORS_MASK  0x00070",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "968: #ifdef CONFIG_FS_DAX",
          "970: #else",
          "971: #define EXT4_MOUNT_DAX   0",
          "972: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2579: extern const struct inode_operations ext4_file_inode_operations;",
          "2580: extern const struct file_operations ext4_file_operations;",
          "2581: extern loff_t ext4_llseek(struct file *file, loff_t offset, int origin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2586: extern const struct file_operations ext4_dax_file_operations;",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:  struct inode *inode = file_inode(iocb->ki_filp);",
          "96:  struct mutex *aio_mutex = NULL;",
          "97:  struct blk_plug plug;",
          "99:  int overwrite = 0;",
          "100:  size_t length = iov_iter_count(from);",
          "101:  ssize_t ret;",
          "",
          "[Removed Lines]",
          "98:  int o_direct = file->f_flags & O_DIRECT;",
          "",
          "[Added Lines]",
          "98:  int o_direct = io_is_direct(file);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191:  return ret;",
          "192: }",
          "194: static const struct vm_operations_struct ext4_file_vm_ops = {",
          "195:  .fault  = filemap_fault,",
          "196:  .map_pages = filemap_map_pages,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194: #ifdef CONFIG_FS_DAX",
          "195: static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "196: {",
          "197:  return dax_fault(vma, vmf, ext4_get_block);",
          "199: }",
          "201: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "202: {",
          "203:  return dax_mkwrite(vma, vmf, ext4_get_block);",
          "204: }",
          "206: static const struct vm_operations_struct ext4_dax_vm_ops = {",
          "207:  .fault  = ext4_dax_fault,",
          "208:  .page_mkwrite = ext4_dax_mkwrite,",
          "209: };",
          "210: #else",
          "211: #define ext4_dax_vm_ops ext4_file_vm_ops",
          "212: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200: static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)",
          "201: {",
          "202:  file_accessed(file);",
          "204:  return 0;",
          "205: }",
          "",
          "[Removed Lines]",
          "203:  vma->vm_ops = &ext4_file_vm_ops;",
          "",
          "[Added Lines]",
          "223:  if (IS_DAX(file_inode(file))) {",
          "224:   vma->vm_ops = &ext4_dax_vm_ops;",
          "225:   vma->vm_flags |= VM_MIXEDMAP;",
          "226:  } else {",
          "227:   vma->vm_ops = &ext4_file_vm_ops;",
          "228:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "599:  .fallocate = ext4_fallocate,",
          "600: };",
          "602: const struct inode_operations ext4_file_inode_operations = {",
          "603:  .setattr = ext4_setattr,",
          "604:  .getattr = ext4_getattr,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627: #ifdef CONFIG_FS_DAX",
          "628: const struct file_operations ext4_dax_file_operations = {",
          "629:  .llseek  = ext4_llseek,",
          "630:  .read  = new_sync_read,",
          "631:  .write  = new_sync_write,",
          "632:  .read_iter = generic_file_read_iter,",
          "633:  .write_iter = ext4_file_write_iter,",
          "634:  .unlocked_ioctl = ext4_ioctl,",
          "635: #ifdef CONFIG_COMPAT",
          "636:  .compat_ioctl = ext4_compat_ioctl,",
          "637: #endif",
          "638:  .mmap  = ext4_file_mmap,",
          "639:  .open  = ext4_file_open,",
          "640:  .release = ext4_release_file,",
          "641:  .fsync  = ext4_sync_file,",
          "643:  .fallocate = ext4_fallocate,",
          "644: };",
          "645: #endif",
          "",
          "---------------"
        ],
        "fs/ext4/indirect.c||fs/ext4/indirect.c": [
          "File: fs/ext4/indirect.c -> fs/ext4/indirect.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "689:    inode_dio_done(inode);",
          "690:    goto locked;",
          "691:   }",
          "695:   inode_dio_done(inode);",
          "696:  } else {",
          "697: locked:",
          "701:   if (unlikely((rw & WRITE) && ret < 0)) {",
          "702:    loff_t isize = i_size_read(inode);",
          "",
          "[Removed Lines]",
          "692:   ret = __blockdev_direct_IO(rw, iocb, inode,",
          "693:      inode->i_sb->s_bdev, iter, offset,",
          "694:      ext4_get_block, NULL, NULL, 0);",
          "698:   ret = blockdev_direct_IO(rw, iocb, inode, iter,",
          "699:      offset, ext4_get_block);",
          "",
          "[Added Lines]",
          "692:   if (IS_DAX(inode))",
          "693:    ret = dax_do_io(rw, iocb, inode, iter, offset,",
          "694:      ext4_get_block, NULL, 0);",
          "695:   else",
          "696:    ret = __blockdev_direct_IO(rw, iocb, inode,",
          "697:      inode->i_sb->s_bdev, iter, offset,",
          "698:      ext4_get_block, NULL, NULL, 0);",
          "702:   if (IS_DAX(inode))",
          "703:    ret = dax_do_io(rw, iocb, inode, iter, offset,",
          "704:      ext4_get_block, NULL, DIO_LOCKING);",
          "705:   else",
          "706:    ret = blockdev_direct_IO(rw, iocb, inode, iter,",
          "707:      offset, ext4_get_block);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "657:  return retval;",
          "658: }",
          "661: #define DIO_MAX_BLOCKS 4096",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "660: static void ext4_end_io_unwritten(struct buffer_head *bh, int uptodate)",
          "661: {",
          "662:  struct inode *inode = bh->b_assoc_map->host;",
          "664:  loff_t offset = (loff_t)(uintptr_t)bh->b_private << inode->i_blkbits;",
          "665:  int err;",
          "666:  if (!uptodate)",
          "667:   return;",
          "668:  WARN_ON(!buffer_unwritten(bh));",
          "669:  err = ext4_convert_unwritten_extents(NULL, inode, offset, bh->b_size);",
          "670: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "695:   map_bh(bh, inode->i_sb, map.m_pblk);",
          "696:   bh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;",
          "697:   if (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)",
          "698:    set_buffer_defer_completion(bh);",
          "699:   bh->b_size = inode->i_sb->s_blocksize * map.m_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "709:   if (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {",
          "710:    bh->b_assoc_map = inode->i_mapping;",
          "711:    bh->b_private = (void *)(unsigned long)iblock;",
          "712:    bh->b_end_io = ext4_end_io_unwritten;",
          "713:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3010:   get_block_func = ext4_get_block_write;",
          "3011:   dio_flags = DIO_LOCKING;",
          "3012:  }",
          "",
          "[Removed Lines]",
          "3013:  ret = __blockdev_direct_IO(rw, iocb, inode,",
          "3014:        inode->i_sb->s_bdev, iter,",
          "3015:        offset,",
          "3016:        get_block_func,",
          "3017:        ext4_end_io_dio,",
          "3018:        NULL,",
          "3019:        dio_flags);",
          "",
          "[Added Lines]",
          "3030:  if (IS_DAX(inode))",
          "3031:   ret = dax_do_io(rw, iocb, inode, iter, offset, get_block_func,",
          "3032:     ext4_end_io_dio, dio_flags);",
          "3033:  else",
          "3034:   ret = __blockdev_direct_IO(rw, iocb, inode,",
          "3035:         inode->i_sb->s_bdev, iter, offset,",
          "3036:         get_block_func,",
          "3037:         ext4_end_io_dio, NULL, dio_flags);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3180:   inode->i_mapping->a_ops = &ext4_aops;",
          "3181: }",
          "3191:   struct address_space *mapping, loff_t from, loff_t length)",
          "3192: {",
          "3193:  ext4_fsblk_t index = from >> PAGE_CACHE_SHIFT;",
          "3194:  unsigned offset = from & (PAGE_CACHE_SIZE-1);",
          "3196:  ext4_lblk_t iblock;",
          "3197:  struct inode *inode = mapping->host;",
          "3198:  struct buffer_head *bh;",
          "",
          "[Removed Lines]",
          "3190: static int ext4_block_zero_page_range(handle_t *handle,",
          "3195:  unsigned blocksize, max, pos;",
          "",
          "[Added Lines]",
          "3201: static int __ext4_block_zero_page_range(handle_t *handle,",
          "3206:  unsigned blocksize, pos;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3205:   return -ENOMEM;",
          "3207:  blocksize = inode->i_sb->s_blocksize;",
          "3217:  iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);",
          "",
          "[Removed Lines]",
          "3208:  max = blocksize - (offset & (blocksize - 1));",
          "3214:  if (length > max || length < 0)",
          "3215:   length = max;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3277:  return err;",
          "3278: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3290: static int ext4_block_zero_page_range(handle_t *handle,",
          "3291:   struct address_space *mapping, loff_t from, loff_t length)",
          "3292: {",
          "3293:  struct inode *inode = mapping->host;",
          "3294:  unsigned offset = from & (PAGE_CACHE_SIZE-1);",
          "3295:  unsigned blocksize = inode->i_sb->s_blocksize;",
          "3296:  unsigned max = blocksize - (offset & (blocksize - 1));",
          "3302:  if (length > max || length < 0)",
          "3303:   length = max;",
          "3305:  if (IS_DAX(inode))",
          "3306:   return dax_zero_page_range(inode, from, length, ext4_get_block);",
          "3307:  return __ext4_block_zero_page_range(handle, mapping, from, length);",
          "3308: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3798:   new_fl |= S_NOATIME;",
          "3799:  if (flags & EXT4_DIRSYNC_FL)",
          "3800:   new_fl |= S_DIRSYNC;",
          "3801:  inode_set_flags(inode, new_fl,",
          "3803: }",
          "",
          "[Removed Lines]",
          "3802:    S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);",
          "",
          "[Added Lines]",
          "3831:  if (test_opt(inode->i_sb, DAX))",
          "3832:   new_fl |= S_DAX;",
          "3834:    S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4053:  if (S_ISREG(inode->i_mode)) {",
          "4054:   inode->i_op = &ext4_file_inode_operations;",
          "4056:   ext4_set_aops(inode);",
          "4057:  } else if (S_ISDIR(inode->i_mode)) {",
          "4058:   inode->i_op = &ext4_dir_inode_operations;",
          "",
          "[Removed Lines]",
          "4055:   inode->i_fop = &ext4_file_operations;",
          "",
          "[Added Lines]",
          "4087:   if (test_opt(inode->i_sb, DAX))",
          "4088:    inode->i_fop = &ext4_dax_file_operations;",
          "4089:   else",
          "4090:    inode->i_fop = &ext4_file_operations;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4538:  }",
          "",
          "[Removed Lines]",
          "4537:    truncate_pagecache(inode, inode->i_size);",
          "",
          "[Added Lines]",
          "4572:   truncate_pagecache(inode, inode->i_size);",
          "",
          "---------------"
        ],
        "fs/ext4/namei.c||fs/ext4/namei.c": [
          "File: fs/ext4/namei.c -> fs/ext4/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2235:  err = PTR_ERR(inode);",
          "2236:  if (!IS_ERR(inode)) {",
          "2237:   inode->i_op = &ext4_file_inode_operations;",
          "2239:   ext4_set_aops(inode);",
          "2240:   err = ext4_add_nondir(handle, dentry, inode);",
          "2241:   if (!err && IS_DIRSYNC(dir))",
          "",
          "[Removed Lines]",
          "2238:   inode->i_fop = &ext4_file_operations;",
          "",
          "[Added Lines]",
          "2238:   if (test_opt(inode->i_sb, DAX))",
          "2239:    inode->i_fop = &ext4_dax_file_operations;",
          "2240:   else",
          "2241:    inode->i_fop = &ext4_file_operations;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2299:  err = PTR_ERR(inode);",
          "2300:  if (!IS_ERR(inode)) {",
          "2301:   inode->i_op = &ext4_file_inode_operations;",
          "2303:   ext4_set_aops(inode);",
          "2304:   d_tmpfile(dentry, inode);",
          "2305:   err = ext4_orphan_add(handle, inode);",
          "",
          "[Removed Lines]",
          "2302:   inode->i_fop = &ext4_file_operations;",
          "",
          "[Added Lines]",
          "2305:   if (test_opt(inode->i_sb, DAX))",
          "2306:    inode->i_fop = &ext4_dax_file_operations;",
          "2307:   else",
          "2308:    inode->i_fop = &ext4_file_operations;",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1124:  Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,",
          "1125:  Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,",
          "1126:  Opt_noquota, Opt_barrier, Opt_nobarrier, Opt_err,",
          "1128:  Opt_stripe, Opt_delalloc, Opt_nodelalloc, Opt_mblk_io_submit,",
          "1129:  Opt_nomblk_io_submit, Opt_block_validity, Opt_noblock_validity,",
          "1130:  Opt_inode_readahead_blks, Opt_journal_ioprio,",
          "",
          "[Removed Lines]",
          "1127:  Opt_usrquota, Opt_grpquota, Opt_i_version,",
          "",
          "[Added Lines]",
          "1127:  Opt_usrquota, Opt_grpquota, Opt_i_version, Opt_dax,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1187:  {Opt_barrier, \"barrier\"},",
          "1188:  {Opt_nobarrier, \"nobarrier\"},",
          "1189:  {Opt_i_version, \"i_version\"},",
          "1190:  {Opt_stripe, \"stripe=%u\"},",
          "1191:  {Opt_delalloc, \"delalloc\"},",
          "1192:  {Opt_nodelalloc, \"nodelalloc\"},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1190:  {Opt_dax, \"dax\"},",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1371:  {Opt_min_batch_time, 0, MOPT_GTE0},",
          "1372:  {Opt_inode_readahead_blks, 0, MOPT_GTE0},",
          "1373:  {Opt_init_itable, 0, MOPT_GTE0},",
          "1374:  {Opt_stripe, 0, MOPT_GTE0},",
          "1375:  {Opt_resuid, 0, MOPT_GTE0},",
          "1376:  {Opt_resgid, 0, MOPT_GTE0},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1375:  {Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1606:    return -1;",
          "1607:   }",
          "1608:   sbi->s_jquota_fmt = m->mount_opt;",
          "1609: #endif",
          "1610:  } else {",
          "1611:   if (!args->from)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1611: #endif",
          "1612: #ifndef CONFIG_FS_DAX",
          "1613:  } else if (token == Opt_dax) {",
          "1614:   ext4_msg(sb, KERN_INFO, \"dax option not supported\");",
          "1615:   return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3589:      \"both data=journal and dioread_nolock\");",
          "3590:    goto failed_mount;",
          "3591:   }",
          "3592:   if (test_opt(sb, DELALLOC))",
          "3593:    clear_opt(sb, DELALLOC);",
          "3594:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3599:   if (test_opt(sb, DAX)) {",
          "3600:    ext4_msg(sb, KERN_ERR, \"can't mount with \"",
          "3601:      \"both data=journal and dax\");",
          "3602:    goto failed_mount;",
          "3603:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3652:   goto failed_mount;",
          "3653:  }",
          "3655:  if (sb->s_blocksize != blocksize) {",
          "3657:   if (!sb_set_blocksize(sb, blocksize)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3667:  if (sbi->s_mount_opt & EXT4_MOUNT_DAX) {",
          "3668:   if (blocksize != PAGE_SIZE) {",
          "3669:    ext4_msg(sb, KERN_ERR,",
          "3670:      \"error: unsupported blocksize for dax\");",
          "3671:    goto failed_mount;",
          "3672:   }",
          "3673:   if (!sb->s_bdev->bd_disk->fops->direct_access) {",
          "3674:    ext4_msg(sb, KERN_ERR,",
          "3675:      \"error: device does not support dax\");",
          "3676:    goto failed_mount;",
          "3677:   }",
          "3678:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4869:    err = -EINVAL;",
          "4870:    goto restore_opts;",
          "4871:   }",
          "4872:  }",
          "4874:  if (sbi->s_mount_flags & EXT4_MF_FS_ABORTED)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4897:   if (test_opt(sb, DAX)) {",
          "4898:    ext4_msg(sb, KERN_ERR, \"can't mount with \"",
          "4899:      \"both data=journal and dax\");",
          "4900:    err = -EINVAL;",
          "4901:    goto restore_opts;",
          "4902:   }",
          "4903:  }",
          "4905:  if ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT4_MOUNT_DAX) {",
          "4906:   ext4_msg(sb, KERN_WARNING, \"warning: refusing change of \"",
          "4907:    \"dax flag with busy inodes while remounting\");",
          "4908:   sbi->s_mount_opt ^= EXT4_MOUNT_DAX;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "11bd1a9ecdd687b8a4b9b360b7e4b74a1a5e2bd5",
      "candidate_info": {
        "commit_hash": "11bd1a9ecdd687b8a4b9b360b7e4b74a1a5e2bd5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/11bd1a9ecdd687b8a4b9b360b7e4b74a1a5e2bd5",
        "files": [
          "fs/ext4/file.c"
        ],
        "message": "ext4: huge page fault support\n\nUse DAX to provide support for huge pages.\n\nSigned-off-by: Matthew Wilcox <willy@linux.intel.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: \"Kirill A. Shutemov\" <kirill.shutemov@linux.intel.com>\nCc: Theodore Ts'o <tytso@mit.edu>\nCc: Jan Kara <jack@suse.cz>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ext4/file.c||fs/ext4/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/file.c||fs/ext4/file.c"
          ],
          "candidate": [
            "fs/ext4/file.c||fs/ext4/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "212: }",
          "214: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "215: {",
          "216:  return dax_mkwrite(vma, vmf, ext4_get_block, ext4_end_io_unwritten);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "214: static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,",
          "215:       pmd_t *pmd, unsigned int flags)",
          "216: {",
          "217:  return dax_pmd_fault(vma, addr, pmd, flags, ext4_get_block_write,",
          "218:     ext4_end_io_unwritten);",
          "219: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "219: static const struct vm_operations_struct ext4_dax_vm_ops = {",
          "220:  .fault  = ext4_dax_fault,",
          "221:  .page_mkwrite = ext4_dax_mkwrite,",
          "222:  .pfn_mkwrite = dax_pfn_mkwrite,",
          "223: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "228:  .pmd_fault = ext4_dax_pmd_fault,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "245:  file_accessed(file);",
          "246:  if (IS_DAX(file_inode(file))) {",
          "247:   vma->vm_ops = &ext4_dax_vm_ops;",
          "249:  } else {",
          "250:   vma->vm_ops = &ext4_file_vm_ops;",
          "251:  }",
          "",
          "[Removed Lines]",
          "248:   vma->vm_flags |= VM_MIXEDMAP;",
          "",
          "[Added Lines]",
          "256:   vma->vm_flags |= VM_MIXEDMAP | VM_HUGEPAGE;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
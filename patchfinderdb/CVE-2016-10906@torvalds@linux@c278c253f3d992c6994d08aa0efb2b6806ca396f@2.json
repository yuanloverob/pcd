{
  "cve_id": "CVE-2016-10906",
  "cve_desc": "An issue was discovered in drivers/net/ethernet/arc/emac_main.c in the Linux kernel before 4.5. A use-after-free is caused by a race condition between the functions arc_emac_tx and arc_emac_tx_clean.",
  "repo": "torvalds/linux",
  "patch_hash": "c278c253f3d992c6994d08aa0efb2b6806ca396f",
  "patch_info": {
    "commit_hash": "c278c253f3d992c6994d08aa0efb2b6806ca396f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c278c253f3d992c6994d08aa0efb2b6806ca396f",
    "files": [
      "drivers/net/ethernet/arc/emac_main.c"
    ],
    "message": "net: arc_emac: fix koops caused by sk_buff free\n\nThere is a race between arc_emac_tx() and arc_emac_tx_clean().\nsk_buff got freed by arc_emac_tx_clean() while arc_emac_tx()\nsubmitting sk_buff.\n\nIn order to free sk_buff arc_emac_tx_clean() checks:\n    if ((info & FOR_EMAC) || !txbd->data)\n        break;\n    ...\n    dev_kfree_skb_irq(skb);\n\nIf condition false, arc_emac_tx_clean() free sk_buff.\n\nIn order to submit txbd, arc_emac_tx() do:\n    priv->tx_buff[*txbd_curr].skb = skb;\n    ...\n    priv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n    ...\n    ...  <== arc_emac_tx_clean() check condition here\n    ...  <== (info & FOR_EMAC) is false\n    ...  <== !txbd->data is false\n    ...\n    *info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n\nIn order to reproduce the situation,\nrun device:\n    # iperf -s\nrun on host:\n    # iperf -t 600 -c <device-ip-addr>\n\n[   28.396284] ------------[ cut here ]------------\n[   28.400912] kernel BUG at .../net/core/skbuff.c:1355!\n[   28.414019] Internal error: Oops - BUG: 0 [#1] SMP ARM\n[   28.419150] Modules linked in:\n[   28.422219] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G    B           4.4.0+ #120\n[   28.429516] Hardware name: Rockchip (Device Tree)\n[   28.434216] task: c0665070 ti: c0660000 task.ti: c0660000\n[   28.439622] PC is at skb_put+0x10/0x54\n[   28.443381] LR is at arc_emac_poll+0x260/0x474\n[   28.447821] pc : [<c03af580>]    lr : [<c028fec4>]    psr: a0070113\n[   28.447821] sp : c0661e58  ip : eea68502  fp : ef377000\n[   28.459280] r10: 0000012c  r9 : f08b2000  r8 : eeb57100\n[   28.464498] r7 : 00000000  r6 : ef376594  r5 : 00000077  r4 : ef376000\n[   28.471015] r3 : 0030488b  r2 : ef13e880  r1 : 000005ee  r0 : eeb57100\n[   28.477534] Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n[   28.484658] Control: 10c5387d  Table: 8eaf004a  DAC: 00000051\n[   28.490396] Process swapper/0 (pid: 0, stack limit = 0xc0660210)\n[   28.496393] Stack: (0xc0661e58 to 0xc0662000)\n[   28.500745] 1e40:                                                       00000002 00000000\n[   28.508913] 1e60: 00000000 ef376520 00000028 f08b23b8 00000000 ef376520 ef7b6900 c028fc64\n[   28.517082] 1e80: 2f158000 c0661ea8 c0661eb0 0000012c c065e900 c03bdeac ffff95e9 c0662100\n[   28.525250] 1ea0: c0663924 00000028 c0661ea8 c0661ea8 c0661eb0 c0661eb0 0000001e c0660000\n[   28.533417] 1ec0: 40000003 00000008 c0695a00 0000000a c066208c 00000100 c0661ee0 c0027410\n[   28.541584] 1ee0: ef0fb700 2f158000 00200000 ffff95e8 00000004 c0662100 c0662080 00000003\n[   28.549751] 1f00: 00000000 00000000 00000000 c065b45c 0000001e ef005000 c0647a30 00000000\n[   28.557919] 1f20: 00000000 c0027798 00000000 c005cf40 f0802100 c0662ffc c0661f60 f0803100\n[   28.566088] 1f40: c0661fb8 c00093bc c000ffb4 60070013 ffffffff c0661f94 c0661fb8 c00137d4\n[   28.574267] 1f60: 00000001 00000000 00000000 c001ffa0 00000000 c0660000 00000000 c065a364\n[   28.582441] 1f80: c0661fb8 c0647a30 00000000 00000000 00000000 c0661fb0 c000ffb0 c000ffb4\n[   28.590608] 1fa0: 60070013 ffffffff 00000051 00000000 00000000 c005496c c0662400 c061bc40\n[   28.598776] 1fc0: ffffffff ffffffff 00000000 c061b680 00000000 c0647a30 00000000 c0695294\n[   28.606943] 1fe0: c0662488 c0647a2c c066619c 6000406a 413fc090 6000807c 00000000 00000000\n[   28.615127] [<c03af580>] (skb_put) from [<ef376520>] (0xef376520)\n[   28.621218] Code: e5902054 e590c090 e3520000 0a000000 (e7f001f2)\n[   28.627307] ---[ end trace 4824734e2243fdb6 ]---\n\n[   34.377068] Internal error: Oops: 17 [#1] SMP ARM\n[   34.382854] Modules linked in:\n[   34.385947] CPU: 0 PID: 3 Comm: ksoftirqd/0 Not tainted 4.4.0+ #120\n[   34.392219] Hardware name: Rockchip (Device Tree)\n[   34.396937] task: ef02d040 ti: ef05c000 task.ti: ef05c000\n[   34.402376] PC is at __dev_kfree_skb_irq+0x4/0x80\n[   34.407121] LR is at arc_emac_poll+0x130/0x474\n[   34.411583] pc : [<c03bb640>]    lr : [<c028fd94>]    psr: 60030013\n[   34.411583] sp : ef05de68  ip : 0008e83c  fp : ef377000\n[   34.423062] r10: c001bec4  r9 : 00000000  r8 : f08b24c8\n[   34.428296] r7 : f08b2400  r6 : 00000075  r5 : 00000019  r4 : ef376000\n[   34.434827] r3 : 00060000  r2 : 00000042  r1 : 00000001  r0 : 00000000\n[   34.441365] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n[   34.448507] Control: 10c5387d  Table: 8f25c04a  DAC: 00000051\n[   34.454262] Process ksoftirqd/0 (pid: 3, stack limit = 0xef05c210)\n[   34.460449] Stack: (0xef05de68 to 0xef05e000)\n[   34.464827] de60:                   ef376000 c028fd94 00000000 c0669480 c0669480 ef376520\n[   34.473022] de80: 00000028 00000001 00002ae4 ef376520 ef7b6900 c028fc64 2f158000 ef05dec0\n[   34.481215] dea0: ef05dec8 0000012c c065e900 c03bdeac ffff983f c0662100 c0663924 00000028\n[   34.489409] dec0: ef05dec0 ef05dec0 ef05dec8 ef05dec8 ef7b6000 ef05c000 40000003 00000008\n[   34.497600] dee0: c0695a00 0000000a c066208c 00000100 ef05def8 c0027410 ef7b6000 40000000\n[   34.505795] df00: 04208040 ffff983e 00000004 c0662100 c0662080 00000003 ef05c000 ef027340\n[   34.513985] df20: ef05c000 c0666c2c 00000000 00000001 00000002 00000000 00000000 c0027568\n[   34.522176] df40: ef027340 c003ef48 ef027300 00000000 ef027340 c003edd4 00000000 00000000\n[   34.530367] df60: 00000000 c003c37c ffffff7f 00000001 00000000 ef027340 00000000 00030003\n[   34.538559] df80: ef05df80 ef05df80 00000000 00000000 ef05df90 ef05df90 ef05dfac ef027300\n[   34.546750] dfa0: c003c2a4 00000000 00000000 c000f578 00000000 00000000 00000000 00000000\n[   34.554939] dfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n[   34.563129] dfe0: 00000000 00000000 00000000 00000000 00000013 00000000 ffffffff dfff7fff\n[   34.571360] [<c03bb640>] (__dev_kfree_skb_irq) from [<c028fd94>] (arc_emac_poll+0x130/0x474)\n[   34.579840] [<c028fd94>] (arc_emac_poll) from [<c03bdeac>] (net_rx_action+0xdc/0x28c)\n[   34.587712] [<c03bdeac>] (net_rx_action) from [<c0027410>] (__do_softirq+0xcc/0x1f8)\n[   34.595482] [<c0027410>] (__do_softirq) from [<c0027568>] (run_ksoftirqd+0x2c/0x50)\n[   34.603168] [<c0027568>] (run_ksoftirqd) from [<c003ef48>] (smpboot_thread_fn+0x174/0x18c)\n[   34.611466] [<c003ef48>] (smpboot_thread_fn) from [<c003c37c>] (kthread+0xd8/0xec)\n[   34.619075] [<c003c37c>] (kthread) from [<c000f578>] (ret_from_fork+0x14/0x3c)\n[   34.626317] Code: e8bd8010 e3a00000 e12fff1e e92d4010 (e59030a4)\n[   34.632572] ---[ end trace cca5a3d86a82249a ]---\n\nSigned-off-by: Alexander Kochetkov <al.kochet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "drivers/net/ethernet/arc/emac_main.c||drivers/net/ethernet/arc/emac_main.c"
    ]
  },
  "patch_diff": {
    "drivers/net/ethernet/arc/emac_main.c||drivers/net/ethernet/arc/emac_main.c": [
      "File: drivers/net/ethernet/arc/emac_main.c -> drivers/net/ethernet/arc/emac_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "163:   struct sk_buff *skb = tx_buff->skb;",
      "164:   unsigned int info = le32_to_cpu(txbd->info);",
      "167:    break;",
      "169:   if (unlikely(info & (DROP | DEFR | LTCL | UFLO))) {",
      "",
      "[Removed Lines]",
      "166:   if ((info & FOR_EMAC) || !txbd->data)",
      "",
      "[Added Lines]",
      "166:   if ((info & FOR_EMAC) || !txbd->data || !skb)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "192:   txbd->data = 0;",
      "193:   txbd->info = 0;",
      "196:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "194:   tx_buff->skb = NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "610:  dma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);",
      "611:  dma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);",
      "614:  priv->txbd[*txbd_curr].data = cpu_to_le32(addr);",
      "",
      "[Removed Lines]",
      "613:  priv->tx_buff[*txbd_curr].skb = skb;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "624:  wmb();",
      "626:  priv->tx_buff[*txbd_curr].skb = skb;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c73bbaa4ec3eb225ffe468f80d45724d0496bf03",
      "candidate_info": {
        "commit_hash": "c73bbaa4ec3eb225ffe468f80d45724d0496bf03",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c73bbaa4ec3eb225ffe468f80d45724d0496bf03",
        "files": [
          "drivers/media/rc/rc-main.c",
          "include/media/rc-core.h"
        ],
        "message": "[media] rc-core: don't lock device at rc_register_device()\n\nThe mutex lock at rc_register_device() was added by commit 08aeb7c9a42a\n(\"[media] rc: add locking to fix register/show race\").\n\nIt is meant to avoid race issues when trying to open a sysfs file while\nthe RC register didn't complete.\n\nAdding a lock there causes troubles, as detected by the Kernel lock\ndebug instrumentation at the Kernel:\n\n    ======================================================\n    [ INFO: possible circular locking dependency detected ]\n    4.5.0-rc3+ #46 Not tainted\n    -------------------------------------------------------\n    systemd-udevd/2681 is trying to acquire lock:\n     (s_active#171){++++.+}, at: [<ffffffff8171a115>] kernfs_remove_by_name_ns+0x45/0xa0\n\n    but task is already holding lock:\n     (&dev->lock){+.+.+.}, at: [<ffffffffa0724def>] rc_register_device+0xb2f/0x1450 [rc_core]\n\n    which lock already depends on the new lock.\n\n    the existing dependency chain (in reverse order) is:\n\n    -> #1 (&dev->lock){+.+.+.}:\n           [<ffffffff8124817d>] lock_acquire+0x13d/0x320\n           [<ffffffff822de966>] mutex_lock_nested+0xb6/0x860\n           [<ffffffffa0721f2b>] show_protocols+0x3b/0x3f0 [rc_core]\n           [<ffffffff81cdaba5>] dev_attr_show+0x45/0xc0\n           [<ffffffff8171f1b3>] sysfs_kf_seq_show+0x203/0x3c0\n           [<ffffffff8171a6a1>] kernfs_seq_show+0x121/0x1b0\n           [<ffffffff81617c71>] seq_read+0x2f1/0x1160\n           [<ffffffff8171c911>] kernfs_fop_read+0x321/0x460\n           [<ffffffff815abc20>] __vfs_read+0xe0/0x3d0\n           [<ffffffff815ae90e>] vfs_read+0xde/0x2d0\n           [<ffffffff815b1d01>] SyS_read+0x111/0x230\n           [<ffffffff822e8636>] entry_SYSCALL_64_fastpath+0x16/0x76\n\n    -> #0 (s_active#171){++++.+}:\n           [<ffffffff81244f24>] __lock_acquire+0x4304/0x5990\n           [<ffffffff8124817d>] lock_acquire+0x13d/0x320\n           [<ffffffff81717d3a>] __kernfs_remove+0x58a/0x810\n           [<ffffffff8171a115>] kernfs_remove_by_name_ns+0x45/0xa0\n           [<ffffffff81721592>] remove_files.isra.0+0x72/0x190\n           [<ffffffff8172174b>] sysfs_remove_group+0x9b/0x150\n           [<ffffffff81721854>] sysfs_remove_groups+0x54/0xa0\n           [<ffffffff81cd97d0>] device_remove_attrs+0xb0/0x140\n           [<ffffffff81cdb27c>] device_del+0x38c/0x6b0\n           [<ffffffffa0724b8b>] rc_register_device+0x8cb/0x1450 [rc_core]\n           [<ffffffffa1326a7b>] dvb_usb_remote_init+0x66b/0x14d0 [dvb_usb]\n           [<ffffffffa1321c81>] dvb_usb_device_init+0xf21/0x1860 [dvb_usb]\n           [<ffffffffa13517dc>] dib0700_probe+0x14c/0x410 [dvb_usb_dib0700]\n           [<ffffffff81dbb1dd>] usb_probe_interface+0x45d/0x940\n           [<ffffffff81ce7e7a>] driver_probe_device+0x21a/0xc30\n           [<ffffffff81ce89b1>] __driver_attach+0x121/0x160\n           [<ffffffff81ce21bf>] bus_for_each_dev+0x11f/0x1a0\n           [<ffffffff81ce6cdd>] driver_attach+0x3d/0x50\n           [<ffffffff81ce5df9>] bus_add_driver+0x4c9/0x770\n           [<ffffffff81cea39c>] driver_register+0x18c/0x3b0\n           [<ffffffff81db6e98>] usb_register_driver+0x1f8/0x440\n           [<ffffffffa074001e>] dib0700_driver_init+0x1e/0x1000 [dvb_usb_dib0700]\n           [<ffffffff810021b1>] do_one_initcall+0x141/0x300\n           [<ffffffff8144d8eb>] do_init_module+0x1d0/0x5ad\n           [<ffffffff812f27b6>] load_module+0x6666/0x9ba0\n           [<ffffffff812f5fe8>] SyS_finit_module+0x108/0x130\n           [<ffffffff822e8636>] entry_SYSCALL_64_fastpath+0x16/0x76\n\n    other info that might help us debug this:\n\n     Possible unsafe locking scenario:\n\n           CPU0                    CPU1\n           ----                    ----\n      lock(&dev->lock);\n                                   lock(s_active#171);\n                                   lock(&dev->lock);\n      lock(s_active#171);\n\n     *** DEADLOCK ***\n\n    3 locks held by systemd-udevd/2681:\n     #0:  (&dev->mutex){......}, at: [<ffffffff81ce8933>] __driver_attach+0xa3/0x160\n     #1:  (&dev->mutex){......}, at: [<ffffffff81ce8941>] __driver_attach+0xb1/0x160\n     #2:  (&dev->lock){+.+.+.}, at: [<ffffffffa0724def>] rc_register_device+0xb2f/0x1450 [rc_core]\n\nIn this specific case, some error happened during device init,\ncausing IR to be disabled.\n\nLet's fix it by adding a var that will tell when the device is\ninitialized. Any calls before that will return a -EINVAL.\n\nThat should prevent the race issues.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>",
        "before_after_code_files": [
          "drivers/media/rc/rc-main.c||drivers/media/rc/rc-main.c",
          "include/media/rc-core.h||include/media/rc-core.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/media/rc/rc-main.c||drivers/media/rc/rc-main.c": [
          "File: drivers/media/rc/rc-main.c -> drivers/media/rc/rc-main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "723:   return -EINVAL;",
          "725:  mutex_lock(&rdev->lock);",
          "726:  if (!rdev->users++ && rdev->open != NULL)",
          "727:   rval = rdev->open(rdev);",
          "729:  if (rval)",
          "730:   rdev->users--;",
          "732:  mutex_unlock(&rdev->lock);",
          "734:  return rval;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "726:  if (!rdev->initialized) {",
          "727:   rval = -EINVAL;",
          "728:   goto unlock;",
          "729:  }",
          "737: unlock:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "874:   return -EINVAL;",
          "876:  mutex_lock(&dev->lock);",
          "878:  if (fattr->type == RC_FILTER_NORMAL) {",
          "879:   enabled = dev->enabled_protocols;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "883:  if (!dev->initialized) {",
          "884:   mutex_unlock(&dev->lock);",
          "885:   return -EINVAL;",
          "886:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1074:  }",
          "1076:  mutex_lock(&dev->lock);",
          "1078:  old_protocols = *current_protocols;",
          "1079:  new_protocols = old_protocols;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1087:  if (!dev->initialized) {",
          "1088:   rc = -EINVAL;",
          "1089:   goto out;",
          "1090:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1154:  if (!dev)",
          "1155:   return -EINVAL;",
          "1157:  if (fattr->type == RC_FILTER_NORMAL)",
          "1158:   filter = &dev->scancode_filter;",
          "1159:  else",
          "1160:   filter = &dev->scancode_wakeup_filter;",
          "1163:  if (fattr->mask)",
          "1164:   val = filter->mask;",
          "1165:  else",
          "",
          "[Removed Lines]",
          "1162:  mutex_lock(&dev->lock);",
          "",
          "[Added Lines]",
          "1171:  mutex_lock(&dev->lock);",
          "1172:  if (!dev->initialized) {",
          "1173:   mutex_unlock(&dev->lock);",
          "1174:   return -EINVAL;",
          "1175:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1222:   return -EINVAL;",
          "1224:  mutex_lock(&dev->lock);",
          "1226:  new_filter = *filter;",
          "1227:  if (fattr->mask)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1244:  if (!dev->initialized) {",
          "1245:   ret = -EINVAL;",
          "1246:   goto unlock;",
          "1247:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1419:   dev->sysfs_groups[attr++] = &rc_dev_wakeup_protocol_attr_grp;",
          "1420:  dev->sysfs_groups[attr++] = NULL;",
          "1430:  rc = device_add(&dev->dev);",
          "1431:  if (rc)",
          "1432:   goto out_unlock;",
          "",
          "[Removed Lines]",
          "1428:  mutex_lock(&dev->lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1440:  dev->input_dev->phys = dev->input_phys;",
          "1441:  dev->input_dev->name = dev->input_name;",
          "1446:  rc = input_register_device(dev->input_dev);",
          "1450:  if (rc)",
          "1451:   goto out_table;",
          "",
          "[Removed Lines]",
          "1444:  mutex_unlock(&dev->lock);",
          "1448:  mutex_lock(&dev->lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1475:    request_module_nowait(\"ir-lirc-codec\");",
          "1476:    raw_init = true;",
          "1477:   }",
          "1480:   rc = ir_raw_event_register(dev);",
          "1482:   if (rc < 0)",
          "1483:    goto out_input;",
          "1484:  }",
          "",
          "[Removed Lines]",
          "1479:   mutex_unlock(&dev->lock);",
          "1481:   mutex_lock(&dev->lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1491:   dev->enabled_protocols = rc_type;",
          "1492:  }",
          "1494:  mutex_unlock(&dev->lock);",
          "1496:  IR_dprintk(1, \"Registered rc%u (driver: %s, remote: %s, mode %s)\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1500:  mutex_lock(&dev->lock);",
          "1501:  dev->initialized = true;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1512: out_dev:",
          "1513:  device_del(&dev->dev);",
          "1514: out_unlock:",
          "1516:  ida_simple_remove(&rc_ida, minor);",
          "1517:  return rc;",
          "1518: }",
          "",
          "[Removed Lines]",
          "1515:  mutex_unlock(&dev->lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/media/rc-core.h||include/media/rc-core.h": [
          "File: include/media/rc-core.h -> include/media/rc-core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "122: struct rc_dev {",
          "123:  struct device   dev;",
          "124:  const struct attribute_group *sysfs_groups[5];",
          "125:  const char   *input_name;",
          "126:  const char   *input_phys;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125:  bool    initialized;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5ff8eaac1636bf6deae86491f4818c4c69d1a9ac",
      "candidate_info": {
        "commit_hash": "5ff8eaac1636bf6deae86491f4818c4c69d1a9ac",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5ff8eaac1636bf6deae86491f4818c4c69d1a9ac",
        "files": [
          "fs/fs-writeback.c"
        ],
        "message": "writeback: keep superblock pinned during cgroup writeback association switches\n\nIf cgroup writeback is in use, an inode is associated with a cgroup\nfor writeback.  If the inode's main dirtier changes to another cgroup,\nthe association gets updated asynchronously.  Nothing was pinning the\nsuperblock while such switches are in progress and superblock could go\naway while async switching is pending or in progress leading to\ncrashes like the following.\n\n kernel BUG at fs/jbd2/transaction.c:319!\n invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC\n CPU: 1 PID: 29158 Comm: kworker/1:10 Not tainted 4.5.0-rc3 #51\n Hardware name: Google Google, BIOS Google 01/01/2011\n Workqueue: events inode_switch_wbs_work_fn\n task: ffff880213dbbd40 ti: ffff880209264000 task.ti: ffff880209264000\n RIP: 0010:[<ffffffff803e6922>]  [<ffffffff803e6922>] start_this_handle+0x382/0x3e0\n RSP: 0018:ffff880209267c30  EFLAGS: 00010202\n ...\n Call Trace:\n  [<ffffffff803e6be4>] jbd2__journal_start+0xf4/0x190\n  [<ffffffff803cfc7e>] __ext4_journal_start_sb+0x4e/0x70\n  [<ffffffff803b31ec>] ext4_evict_inode+0x12c/0x3d0\n  [<ffffffff8035338b>] evict+0xbb/0x190\n  [<ffffffff80354190>] iput+0x130/0x190\n  [<ffffffff80360223>] inode_switch_wbs_work_fn+0x343/0x4c0\n  [<ffffffff80279819>] process_one_work+0x129/0x300\n  [<ffffffff80279b16>] worker_thread+0x126/0x480\n  [<ffffffff8027ed14>] kthread+0xc4/0xe0\n  [<ffffffff809771df>] ret_from_fork+0x3f/0x70\n\nFix it by bumping s_active while cgroup association switching is in\nflight.\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-and-tested-by: Tahsin Erdogan <tahsin@google.com>\nLink: http://lkml.kernel.org/g/CAAeU0aNCq7LGODvVGRU-oU_o-6enii5ey0p1c26D1ZzYwkDc5A@mail.gmail.com\nFixes: d10c80955265 (\"writeback: implement foreign cgroup inode bdi_writeback switching\")\nCc: stable@vger.kernel.org #v4.5+\nSigned-off-by: Jens Axboe <axboe@fb.com>",
        "before_after_code_files": [
          "fs/fs-writeback.c||fs/fs-writeback.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/fs-writeback.c||fs/fs-writeback.c": [
          "File: fs/fs-writeback.c -> fs/fs-writeback.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "317:  struct inode_switch_wbs_context *isw =",
          "318:   container_of(work, struct inode_switch_wbs_context, work);",
          "319:  struct inode *inode = isw->inode;",
          "320:  struct address_space *mapping = inode->i_mapping;",
          "321:  struct bdi_writeback *old_wb = inode->i_wb;",
          "322:  struct bdi_writeback *new_wb = isw->new_wb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "320:  struct super_block *sb = inode->i_sb;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "423:  wb_put(new_wb);",
          "425:  iput(inode);",
          "426:  kfree(isw);",
          "427: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "427:  deactivate_super(sb);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "471:  spin_lock(&inode->i_lock);",
          "472:  if (inode->i_state & (I_WB_SWITCH | I_FREEING) ||",
          "477:  inode->i_state |= I_WB_SWITCH;",
          "478:  spin_unlock(&inode->i_lock);",
          "",
          "[Removed Lines]",
          "473:      inode_to_wb(inode) == isw->new_wb) {",
          "474:   spin_unlock(&inode->i_lock);",
          "475:   goto out_free;",
          "476:  }",
          "",
          "[Added Lines]",
          "476:      inode_to_wb(inode) == isw->new_wb)",
          "477:   goto out_unlock;",
          "479:  if (!atomic_inc_not_zero(&inode->i_sb->s_active))",
          "480:   goto out_unlock;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "489:  call_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);",
          "490:  return;",
          "492: out_free:",
          "493:  if (isw->new_wb)",
          "494:   wb_put(isw->new_wb);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "497: out_unlock:",
          "498:  spin_unlock(&inode->i_lock);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
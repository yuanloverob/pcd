{
  "cve_id": "CVE-2015-8324",
  "cve_desc": "The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function.",
  "repo": "torvalds/linux",
  "patch_hash": "744692dc059845b2a3022119871846e74d4f6e11",
  "patch_info": {
    "commit_hash": "744692dc059845b2a3022119871846e74d4f6e11",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
    "files": [
      "fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c",
      "fs/ext4/inode.c",
      "fs/ext4/super.c"
    ],
    "message": "ext4: use ext4_get_block_write in buffer write\n\nAllocate uninitialized extent before ext4 buffer write and\nconvert the extent to initialized after io completes.\nThe purpose is to make sure an extent can only be marked\ninitialized after it has been written with new data so\nwe can safely drop the i_mutex lock in ext4 DIO read without\nexposing stale data. This helps to improve multi-thread DIO\nread performance on high-speed disks.\n\nSkip the nobh and data=journal mount cases to make things simple for now.\n\nSigned-off-by: Jiaying Zhang <jiayingz@google.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/ext4.h||fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c||fs/ext4/extents.c",
      "fs/ext4/inode.c||fs/ext4/inode.c",
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/ext4.h||fs/ext4/ext4.h": [
      "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "361:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "363: #define EXT4_GET_BLOCKS_IO_CONVERT_EXT  (EXT4_GET_BLOCKS_CONVERT|\\",
      "",
      "[Removed Lines]",
      "364:       EXT4_GET_BLOCKS_IO_CREATE_EXT)",
      "",
      "[Added Lines]",
      "364:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "704:  struct list_head i_completed_io_list;",
      "706:  ext4_io_end_t *cur_aio_dio;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "705:  spinlock_t i_completed_io_lock;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1781:         __u64 len, __u64 *moved_len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1787: enum ext4_state_bits {",
      "1789:    = BH_JBDPrivateStart,",
      "1790: };",
      "1792: BUFFER_FNS(Uninit, uninit)",
      "1793: TAS_BUFFER_FNS(Uninit, uninit)",
      "",
      "---------------"
    ],
    "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
      "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "304:  return 0;",
      "305: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "316: static inline int ext4_should_dioread_nolock(struct inode *inode)",
      "317: {",
      "318:  if (!test_opt(inode->i_sb, DIOREAD_NOLOCK))",
      "319:   return 0;",
      "320:  if (test_opt(inode->i_sb, NOBH))",
      "321:   return 0;",
      "322:  if (!S_ISREG(inode->i_mode))",
      "323:   return 0;",
      "324:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
      "325:   return 0;",
      "326:  if (ext4_should_journal_data(inode))",
      "327:   return 0;",
      "328:  return 1;",
      "329: }",
      "",
      "---------------"
    ],
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1619:  BUG_ON(path[depth].p_hdr == NULL);",
      "1623:   && ext4_can_extents_be_merged(inode, ex, newext)) {",
      "1624:   ext_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",",
      "1625:     ext4_ext_is_uninitialized(newext),",
      "",
      "[Removed Lines]",
      "1622:  if (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1622:  if (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1741: merge:",
      "1744:   ext4_ext_try_to_merge(inode, path, nearex);",
      "",
      "[Removed Lines]",
      "1743:  if (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1743:  if (!(flag & EXT4_GET_BLOCKS_PRE_IO))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3065:  ext4_ext_show_leaf(inode, path);",
      "3069:   ret = ext4_split_unwritten_extents(handle,",
      "3070:       inode, path, iblock,",
      "3071:       max_blocks, flags);",
      "",
      "[Removed Lines]",
      "3068:  if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3068:  if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3078:    io->flag = EXT4_IO_UNWRITTEN;",
      "3079:   else",
      "3080:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
      "3081:   goto out;",
      "3082:  }",
      "3085:   ret = ext4_convert_unwritten_extents_endio(handle, inode,",
      "3086:        path);",
      "3087:   if (ret >= 0)",
      "",
      "[Removed Lines]",
      "3084:  if (flags == EXT4_GET_BLOCKS_CONVERT) {",
      "",
      "[Added Lines]",
      "3081:   if (ext4_should_dioread_nolock(inode))",
      "3082:    set_buffer_uninit(bh_result);",
      "3086:  if ((flags & EXT4_GET_BLOCKS_CONVERT)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3351:  if (flags & EXT4_GET_BLOCKS_UNINIT_EXT){",
      "3352:   ext4_ext_mark_uninitialized(&newex);",
      "3363:    if (io)",
      "3364:     io->flag = EXT4_IO_UNWRITTEN;",
      "3365:    else",
      "3366:     ext4_set_inode_state(inode,",
      "3367:            EXT4_STATE_DIO_UNWRITTEN);",
      "3368:   }",
      "3369:  }",
      "3371:  if (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {",
      "",
      "[Removed Lines]",
      "3362:   if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3362:   if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "3369:   if (ext4_should_dioread_nolock(inode))",
      "3370:    set_buffer_uninit(bh_result);",
      "",
      "---------------"
    ],
    "fs/ext4/inode.c||fs/ext4/inode.c": [
      "File: fs/ext4/inode.c -> fs/ext4/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #include <linux/uio.h>",
      "39: #include <linux/bio.h>",
      "40: #include <linux/workqueue.h>",
      "42: #include \"ext4_jbd2.h\"",
      "43: #include \"xattr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "41: #include <linux/kernel.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1534:  ext4_truncate(inode);",
      "1535: }",
      "1537: static int ext4_write_begin(struct file *file, struct address_space *mapping,",
      "1538:        loff_t pos, unsigned len, unsigned flags,",
      "1539:        struct page **pagep, void **fsdata)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1538: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "1539:      struct buffer_head *bh_result, int create);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1575:  }",
      "1581:  if (!ret && ext4_should_journal_data(inode)) {",
      "1582:   ret = walk_page_buffers(handle, page_buffers(page),",
      "",
      "[Removed Lines]",
      "1578:  ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,",
      "1579:     ext4_get_block);",
      "",
      "[Added Lines]",
      "1581:  if (ext4_should_dioread_nolock(inode))",
      "1582:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1583:     fsdata, ext4_get_block_write);",
      "1584:  else",
      "1585:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1586:     fsdata, ext4_get_block);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2092:     } else if (buffer_mapped(bh))",
      "2093:      BUG_ON(bh->b_blocknr != pblock);",
      "2095:     cur_logical++;",
      "2096:     pblock++;",
      "2097:    } while ((bh = bh->b_this_page) != head);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2102:     if (buffer_uninit(exbh))",
      "2103:      set_buffer_uninit(bh);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2222:  new.b_state = 0;",
      "2223:  get_blocks_flags = EXT4_GET_BLOCKS_CREATE;",
      "2224:  if (mpd->b_state & (1 << BH_Delay))",
      "2225:   get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2233:  if (ext4_should_dioread_nolock(mpd->inode))",
      "2234:   get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2636:  return ret;",
      "2637: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2650: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode);",
      "2651: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2683:  int ret = 0;",
      "2684:  loff_t size;",
      "2685:  unsigned int len;",
      "2687:  struct inode *inode = page->mapping->host;",
      "2689:  trace_ext4_writepage(inode, page);",
      "",
      "[Removed Lines]",
      "2686:  struct buffer_head *page_bufs;",
      "",
      "[Added Lines]",
      "2700:  struct buffer_head *page_bufs = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2760:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
      "2761:   ret = nobh_writepage(page, noalloc_get_block_write, wbc);",
      "2763:   ret = block_write_full_page(page, noalloc_get_block_write,",
      "2764:          wbc);",
      "",
      "[Removed Lines]",
      "2762:  else",
      "",
      "[Added Lines]",
      "2776:  else if (page_bufs && buffer_uninit(page_bufs)) {",
      "2777:   ext4_set_bh_endio(page_bufs, inode);",
      "2778:   ret = block_write_full_page_endio(page, noalloc_get_block_write,",
      "2779:          wbc, ext4_end_io_buffer_write);",
      "2780:  } else",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3347:  return mpage_readpages(mapping, pages, nr_pages, ext4_get_block);",
      "3348: }",
      "3350: static void ext4_invalidatepage(struct page *page, unsigned long offset)",
      "3351: {",
      "3352:  journal_t *journal = EXT4_JOURNAL(page->mapping->host);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3368: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3369: {",
      "3370:  BUG_ON(!io);",
      "3371:  if (io->page)",
      "3372:   put_page(io->page);",
      "3373:  iput(io->inode);",
      "3374:  kfree(io);",
      "3375: }",
      "3377: static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)",
      "3378: {",
      "3379:  struct buffer_head *head, *bh;",
      "3380:  unsigned int curr_off = 0;",
      "3382:  if (!page_has_buffers(page))",
      "3383:   return;",
      "3384:  head = bh = page_buffers(page);",
      "3385:  do {",
      "3386:   if (offset <= curr_off && test_clear_buffer_uninit(bh)",
      "3387:      && bh->b_private) {",
      "3388:    ext4_free_io_end(bh->b_private);",
      "3389:    bh->b_private = NULL;",
      "3390:    bh->b_end_io = NULL;",
      "3391:   }",
      "3392:   curr_off = curr_off + bh->b_size;",
      "3393:   bh = bh->b_this_page;",
      "3394:  } while (bh != head);",
      "3395: }",
      "3404:  if (ext4_should_dioread_nolock(page->mapping->host))",
      "3405:   ext4_invalidatepage_free_endio(page, offset);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3471: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "3472:      struct buffer_head *bh_result, int create)",
      "3473: {",
      "3475:  int ret = 0;",
      "3476:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
      "3477:  int dio_credits;",
      "3479:  ext4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",",
      "3480:      inode->i_ino, create);",
      "",
      "[Removed Lines]",
      "3474:  handle_t *handle = NULL;",
      "",
      "[Added Lines]",
      "3526:  handle_t *handle = ext4_journal_current_handle();",
      "3530:  int started = 0;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "3486:  create = EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "3495:  }",
      "3496:  ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,",
      "3497:          create);",
      "3498:  if (ret > 0) {",
      "3499:   bh_result->b_size = (ret << inode->i_blkbits);",
      "3500:   ret = 0;",
      "3501:  }",
      "3503: out:",
      "3504:  return ret;",
      "3505: }",
      "3514: static void dump_completed_IO(struct inode * inode)",
      "3515: {",
      "3516: #ifdef EXT4_DEBUG",
      "3517:  struct list_head *cur, *before, *after;",
      "3518:  ext4_io_end_t *io, *io0, *io1;",
      "3520:  if (list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3521:   ext4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);",
      "",
      "[Removed Lines]",
      "3488:  if (max_blocks > DIO_MAX_BLOCKS)",
      "3489:   max_blocks = DIO_MAX_BLOCKS;",
      "3490:  dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3491:  handle = ext4_journal_start(inode, dio_credits);",
      "3492:  if (IS_ERR(handle)) {",
      "3493:   ret = PTR_ERR(handle);",
      "3494:   goto out;",
      "3502:  ext4_journal_stop(handle);",
      "3507: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3508: {",
      "3509:  BUG_ON(!io);",
      "3510:  iput(io->inode);",
      "3511:  kfree(io);",
      "3512: }",
      "",
      "[Added Lines]",
      "3541:  if (!handle) {",
      "3542:   if (max_blocks > DIO_MAX_BLOCKS)",
      "3543:    max_blocks = DIO_MAX_BLOCKS;",
      "3544:   dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3545:   handle = ext4_journal_start(inode, dio_credits);",
      "3546:   if (IS_ERR(handle)) {",
      "3547:    ret = PTR_ERR(handle);",
      "3548:    goto out;",
      "3549:   }",
      "3550:   started = 1;",
      "3559:  if (started)",
      "3560:   ext4_journal_stop(handle);",
      "3570:  unsigned long flags;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3523:  }",
      "3525:  ext4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);",
      "3526:  list_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){",
      "3527:   cur = &io->list;",
      "3528:   before = cur->prev;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3578:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "3533:   ext4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",",
      "3534:        io, inode->i_ino, io0, io1);",
      "3535:  }",
      "3536: #endif",
      "3537: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3589:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3556:  if (io->flag != EXT4_IO_UNWRITTEN)",
      "3557:   return ret;",
      "3562:  if (ret < 0) {",
      "3563:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
      "3564:    \"extents to written extents, error is %d\"",
      "",
      "[Removed Lines]",
      "3559:  if (offset + size <= i_size_read(inode))",
      "3560:   ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "[Added Lines]",
      "3613:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "3578: static void ext4_end_io_work(struct work_struct *work)",
      "3579: {",
      "3584:  mutex_lock(&inode->i_mutex);",
      "3585:  ret = ext4_end_io_nolock(io);",
      "3590:  }",
      "3591:  mutex_unlock(&inode->i_mutex);",
      "3592: }",
      "",
      "[Removed Lines]",
      "3580:  ext4_io_end_t *io  = container_of(work, ext4_io_end_t, work);",
      "3581:  struct inode *inode = io->inode;",
      "3582:  int ret = 0;",
      "3586:  if (ret >= 0) {",
      "3587:   if (!list_empty(&io->list))",
      "3588:    list_del_init(&io->list);",
      "3589:   ext4_free_io_end(io);",
      "",
      "[Added Lines]",
      "3632:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
      "3633:  struct inode  *inode = io->inode;",
      "3634:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3635:  unsigned long  flags;",
      "3636:  int   ret;",
      "3640:  if (ret < 0) {",
      "3641:   mutex_unlock(&inode->i_mutex);",
      "3642:   return;",
      "3645:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3646:  if (!list_empty(&io->list))",
      "3647:   list_del_init(&io->list);",
      "3648:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3650:  ext4_free_io_end(io);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "3607: int flush_completed_IO(struct inode *inode)",
      "3608: {",
      "3609:  ext4_io_end_t *io;",
      "3610:  int ret = 0;",
      "3611:  int ret2 = 0;",
      "3614:   return ret;",
      "3616:  dump_completed_IO(inode);",
      "3619:     ext4_io_end_t, list);",
      "",
      "[Removed Lines]",
      "3613:  if (list_empty(&EXT4_I(inode)->i_completed_io_list))",
      "3617:  while (!list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3618:   io = list_entry(EXT4_I(inode)->i_completed_io_list.next,",
      "",
      "[Added Lines]",
      "3669:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3670:  unsigned long flags;",
      "3674:  if (list_empty(&ei->i_completed_io_list))",
      "3678:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3679:  while (!list_empty(&ei->i_completed_io_list)){",
      "3680:   io = list_entry(ei->i_completed_io_list.next,",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "3634:   ret = ext4_end_io_nolock(io);",
      "3635:   if (ret < 0)",
      "3636:    ret2 = ret;",
      "3637:   else",
      "3638:    list_del_init(&io->list);",
      "3639:  }",
      "3640:  return (ret2 < 0) ? ret2 : 0;",
      "3641: }",
      "3644: {",
      "3645:  ext4_io_end_t *io = NULL;",
      "3649:  if (io) {",
      "3650:   igrab(inode);",
      "",
      "[Removed Lines]",
      "3643: static ext4_io_end_t *ext4_init_io_end (struct inode *inode)",
      "3647:  io = kmalloc(sizeof(*io), GFP_NOFS);",
      "",
      "[Added Lines]",
      "3696:   spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3698:   spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3704:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3708: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)",
      "3712:  io = kmalloc(sizeof(*io), flags);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "3652:   io->flag = 0;",
      "3653:   io->offset = 0;",
      "3654:   io->size = 0;",
      "3656:   INIT_WORK(&io->work, ext4_end_io_work);",
      "3657:   INIT_LIST_HEAD(&io->list);",
      "3658:  }",
      "",
      "[Removed Lines]",
      "3655:   io->error = 0;",
      "",
      "[Added Lines]",
      "3720:   io->page = NULL;",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "3665: {",
      "3666:         ext4_io_end_t *io_end = iocb->private;",
      "3667:  struct workqueue_struct *wq;",
      "3670:  if (!io_end || !size)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3733:  unsigned long flags;",
      "3734:  struct ext4_inode_info *ei;",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "3685:  io_end->offset = offset;",
      "3686:  io_end->size = size;",
      "3687:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
      "3690:  queue_work(wq, &io_end->work);",
      "3695:  iocb->private = NULL;",
      "3696: }",
      "",
      "[Removed Lines]",
      "3693:  list_add_tail(&io_end->list,",
      "3694:    &EXT4_I(io_end->inode)->i_completed_io_list);",
      "",
      "[Added Lines]",
      "3754:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3761:  ei = EXT4_I(io_end->inode);",
      "3762:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3763:  list_add_tail(&io_end->list, &ei->i_completed_io_list);",
      "3764:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3768: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)",
      "3769: {",
      "3770:  ext4_io_end_t *io_end = bh->b_private;",
      "3771:  struct workqueue_struct *wq;",
      "3772:  struct inode *inode;",
      "3773:  unsigned long flags;",
      "3775:  if (!test_clear_buffer_uninit(bh) || !io_end)",
      "3776:   goto out;",
      "3778:  if (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {",
      "3779:   printk(\"sb umounted, discard end_io request for inode %lu\\n\",",
      "3780:    io_end->inode->i_ino);",
      "3781:   ext4_free_io_end(io_end);",
      "3782:   goto out;",
      "3783:  }",
      "3785:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3786:  inode = io_end->inode;",
      "3789:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3790:  list_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);",
      "3791:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3793:  wq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;",
      "3795:  queue_work(wq, &io_end->work);",
      "3796: out:",
      "3797:  bh->b_private = NULL;",
      "3798:  bh->b_end_io = NULL;",
      "3799:  clear_buffer_uninit(bh);",
      "3800:  end_buffer_async_write(bh, uptodate);",
      "3801: }",
      "3803: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)",
      "3804: {",
      "3805:  ext4_io_end_t *io_end;",
      "3806:  struct page *page = bh->b_page;",
      "3807:  loff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;",
      "3808:  size_t size = bh->b_size;",
      "3810: retry:",
      "3811:  io_end = ext4_init_io_end(inode, GFP_ATOMIC);",
      "3812:  if (!io_end) {",
      "3813:   if (printk_ratelimit())",
      "3814:    printk(KERN_WARNING \"%s: allocation fail\\n\", __func__);",
      "3815:   schedule();",
      "3816:   goto retry;",
      "3817:  }",
      "3818:  io_end->offset = offset;",
      "3819:  io_end->size = size;",
      "3825:  io_end->page = page;",
      "3826:  get_page(io_end->page);",
      "3828:  bh->b_private = io_end;",
      "3829:  bh->b_end_io = ext4_end_io_buffer_write;",
      "3830:  return 0;",
      "3831: }",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "3748:   iocb->private = NULL;",
      "3749:   EXT4_I(inode)->cur_aio_dio = NULL;",
      "3750:   if (!is_sync_kiocb(iocb)) {",
      "3752:    if (!iocb->private)",
      "3753:     return -ENOMEM;",
      "",
      "[Removed Lines]",
      "3751:    iocb->private = ext4_init_io_end(inode);",
      "",
      "[Added Lines]",
      "3886:    iocb->private = ext4_init_io_end(inode, GFP_NOFS);",
      "",
      "---------------"
    ],
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "709:  ei->i_reserved_quota = 0;",
      "710: #endif",
      "711:  INIT_LIST_HEAD(&ei->i_completed_io_list);",
      "712:  ei->cur_aio_dio = NULL;",
      "713:  ei->i_sync_tid = 0;",
      "714:  ei->i_datasync_tid = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "712:  spin_lock_init(&ei->i_completed_io_lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "926:  if (test_opt(sb, NOLOAD))",
      "927:   seq_puts(seq, \",norecovery\");",
      "929:  ext4_show_quota_options(seq, sb);",
      "931:  return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "930:  if (test_opt(sb, DIOREAD_NOLOCK))",
      "931:   seq_puts(seq, \",dioread_nolock\");",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1109:  Opt_stripe, Opt_delalloc, Opt_nodelalloc,",
      "1110:  Opt_block_validity, Opt_noblock_validity,",
      "1111:  Opt_inode_readahead_blks, Opt_journal_ioprio,",
      "1112:  Opt_discard, Opt_nodiscard,",
      "1113: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1116:  Opt_dioread_nolock, Opt_dioread_lock,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1176:  {Opt_auto_da_alloc, \"auto_da_alloc=%u\"},",
      "1177:  {Opt_auto_da_alloc, \"auto_da_alloc\"},",
      "1178:  {Opt_noauto_da_alloc, \"noauto_da_alloc\"},",
      "1179:  {Opt_discard, \"discard\"},",
      "1180:  {Opt_nodiscard, \"nodiscard\"},",
      "1181:  {Opt_err, NULL},",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1184:  {Opt_dioread_nolock, \"dioread_nolock\"},",
      "1185:  {Opt_dioread_lock, \"dioread_lock\"},",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1640:   case Opt_nodiscard:",
      "1641:    clear_opt(sbi->s_mount_opt, DISCARD);",
      "1642:    break;",
      "1643:   default:",
      "1644:    ext4_msg(sb, KERN_ERR,",
      "1645:           \"Unrecognized mount option \\\"%s\\\" \"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1650:   case Opt_dioread_nolock:",
      "1651:    set_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1652:    break;",
      "1653:   case Opt_dioread_lock:",
      "1654:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1655:    break;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2795:        EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {",
      "2796:   ext4_msg(sb, KERN_ERR, \"required journal recovery \"",
      "2797:          \"suppressed and not mounted read-only\");",
      "2799:  } else {",
      "2800:   clear_opt(sbi->s_mount_opt, DATA_FLAGS);",
      "2801:   set_opt(sbi->s_mount_opt, WRITEBACK_DATA);",
      "",
      "[Removed Lines]",
      "2798:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2811:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2808:      !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,",
      "2809:            JBD2_FEATURE_INCOMPAT_64BIT)) {",
      "2810:   ext4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");",
      "2812:  }",
      "2814:  if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {",
      "",
      "[Removed Lines]",
      "2811:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2824:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2847:       (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {",
      "2848:    ext4_msg(sb, KERN_ERR, \"Journal does not support \"",
      "2849:           \"requested data journaling mode\");",
      "2851:   }",
      "2852:  default:",
      "2853:   break;",
      "",
      "[Removed Lines]",
      "2850:    goto failed_mount4;",
      "",
      "[Added Lines]",
      "2863:    goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2855:  set_task_ioprio(sbi->s_journal->j_task, journal_ioprio);",
      "2857: no_journal:",
      "2859:  if (test_opt(sb, NOBH)) {",
      "2860:   if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {",
      "2861:    ext4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"",
      "2862:     \"its supported only with writeback mode\");",
      "2863:    clear_opt(sbi->s_mount_opt, NOBH);",
      "2864:   }",
      "2865:  }",
      "2866:  EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");",
      "2867:  if (!EXT4_SB(sb)->dio_unwritten_wq) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2877:   if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2878:    ext4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"",
      "2879:     \"not supported with nobh mode\");",
      "2880:    goto failed_mount_wq;",
      "2881:   }",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2926:     \"requested data journaling mode\");",
      "2927:   clear_opt(sbi->s_mount_opt, DELALLOC);",
      "2928:  }",
      "2930:  err = ext4_setup_system_zone(sb);",
      "2931:  if (err) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2946:  if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2947:   if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {",
      "2948:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2949:     \"option - requested data journaling mode\");",
      "2950:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2951:   }",
      "2952:   if (sb->s_blocksize < PAGE_SIZE) {",
      "2953:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2954:     \"option - block size is too small\");",
      "2955:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2956:   }",
      "2957:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5b3ff237bef43b9e7fb7d1eb858e29b73fd664f9",
      "candidate_info": {
        "commit_hash": "5b3ff237bef43b9e7fb7d1eb858e29b73fd664f9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5b3ff237bef43b9e7fb7d1eb858e29b73fd664f9",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/inode.c"
        ],
        "message": "ext4: move aio completion after unwritten extent conversion\n\nThis patch is to be applied upon Christoph's \"direct-io: move aio_complete\ninto ->end_io\" patch. It adds iocb and result fields to struct ext4_io_end_t,\nso that we can call aio_complete from  ext4_end_io_nolock() after the extent\nconversion has finished.\n\nI have verified with Christoph's aio-dio test that used to fail after a few\nruns on an original kernel but now succeeds on the patched kernel.\n\nSee http://thread.gmane.org/gmane.comp.file-systems.ext4/19659 for details.\n\nSigned-off-by: Jiaying Zhang <jiayingz@google.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3668:   return ret;",
          "3669:  }",
          "3672:  io->flag = 0;",
          "3673:  return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3671:  if (io->iocb)",
          "3672:   aio_complete(io->iocb, io->result, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3767:   io->offset = 0;",
          "3768:   io->size = 0;",
          "3769:   io->page = NULL;",
          "3770:   INIT_WORK(&io->work, ext4_end_io_work);",
          "3771:   INIT_LIST_HEAD(&io->list);",
          "3772:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3772:   io->iocb = NULL;",
          "3773:   io->result = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3796:  if (io_end->flag != EXT4_IO_UNWRITTEN){",
          "3797:   ext4_free_io_end(io_end);",
          "3798:   iocb->private = NULL;",
          "3800:  }",
          "3802:  io_end->offset = offset;",
          "3803:  io_end->size = size;",
          "3805:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
          "",
          "[Removed Lines]",
          "3799:   goto out;",
          "3804:  io_end->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3803: out:",
          "3804:   if (is_async)",
          "3805:    aio_complete(iocb, ret, 0);",
          "3806:   return;",
          "3811:  if (is_async) {",
          "3812:   io_end->iocb = iocb;",
          "3813:   io_end->result = ret;",
          "3814:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3813:  list_add_tail(&io_end->list, &ei->i_completed_io_list);",
          "3814:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
          "3815:  iocb->private = NULL;",
          "3819: }",
          "3821: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)",
          "",
          "[Removed Lines]",
          "3816: out:",
          "3817:  if (is_async)",
          "3818:   aio_complete(iocb, ret, 0);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a42afc5f56f319107e987aa6adf2f65d93d527c7",
      "candidate_info": {
        "commit_hash": "a42afc5f56f319107e987aa6adf2f65d93d527c7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a42afc5f56f319107e987aa6adf2f65d93d527c7",
        "files": [
          "fs/ext4/inode.c"
        ],
        "message": "ext4: simplify ext4_writepage()\n\nThe actual code in ext4_writepage() is unnecessarily convoluted.\nSimplify it so it is easier to understand, but otherwise logically\nequivalent.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2704: static int ext4_writepage(struct page *page,",
          "2705:      struct writeback_control *wbc)",
          "2706: {",
          "2708:  loff_t size;",
          "2709:  unsigned int len;",
          "2710:  struct buffer_head *page_bufs = NULL;",
          "",
          "[Removed Lines]",
          "2707:  int ret = 0;",
          "",
          "[Added Lines]",
          "2707:  int ret = 0, commit_write = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2717:  else",
          "2718:   len = PAGE_CACHE_SIZE;",
          "2732:    redirty_page_for_writepage(wbc, page);",
          "2733:    unlock_page(page);",
          "2734:    return 0;",
          "2735:   }",
          "2772:   block_commit_write(page, 0, len);",
          "2775:  if (PageChecked(page) && ext4_should_journal_data(inode)) {",
          "",
          "[Removed Lines]",
          "2720:  if (page_has_buffers(page)) {",
          "2721:   page_bufs = page_buffers(page);",
          "2722:   if (walk_page_buffers(NULL, page_bufs, 0, len, NULL,",
          "2723:      ext4_bh_delay_or_unwritten)) {",
          "2736:  } else {",
          "2750:   ret = block_prepare_write(page, 0, len,",
          "2751:        noalloc_get_block_write);",
          "2752:   if (!ret) {",
          "2753:    page_bufs = page_buffers(page);",
          "2755:    if (walk_page_buffers(NULL, page_bufs, 0, len, NULL,",
          "2756:       ext4_bh_delay_or_unwritten)) {",
          "2757:     redirty_page_for_writepage(wbc, page);",
          "2758:     unlock_page(page);",
          "2759:     return 0;",
          "2760:    }",
          "2761:   } else {",
          "2767:    redirty_page_for_writepage(wbc, page);",
          "2768:    unlock_page(page);",
          "2769:    return 0;",
          "2770:   }",
          "2773:  }",
          "",
          "[Added Lines]",
          "2725:  if (!page_buffers(page)) {",
          "2726:   if (block_prepare_write(page, 0, len,",
          "2727:      noalloc_get_block_write)) {",
          "2728:   redirty_page:",
          "2733:   commit_write = 1;",
          "2734:  }",
          "2735:  page_bufs = page_buffers(page);",
          "2736:  if (walk_page_buffers(NULL, page_bufs, 0, len, NULL,",
          "2737:          ext4_bh_delay_or_unwritten)) {",
          "2746:   goto redirty_page;",
          "2747:  }",
          "2748:  if (commit_write)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2781:   return __ext4_journalled_writepage(page, len);",
          "2782:  }",
          "2785:   ext4_set_bh_endio(page_bufs, inode);",
          "2786:   ret = block_write_full_page_endio(page, noalloc_get_block_write,",
          "2787:          wbc, ext4_end_io_buffer_write);",
          "",
          "[Removed Lines]",
          "2784:  if (page_bufs && buffer_uninit(page_bufs)) {",
          "",
          "[Added Lines]",
          "2761:  if (buffer_uninit(page_bufs)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e1db88d536adcbbfe562b2d4b7d6425784fff12",
      "candidate_info": {
        "commit_hash": "6e1db88d536adcbbfe562b2d4b7d6425784fff12",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6e1db88d536adcbbfe562b2d4b7d6425784fff12",
        "files": [
          "fs/buffer.c",
          "fs/ext2/dir.c",
          "fs/ext3/inode.c",
          "fs/ext4/inode.c",
          "fs/minix/inode.c",
          "fs/nilfs2/dir.c",
          "fs/reiserfs/inode.c",
          "fs/sysv/itree.c",
          "fs/ufs/inode.c",
          "include/linux/buffer_head.h"
        ],
        "message": "introduce __block_write_begin\n\nSplit up the block_write_begin implementation - __block_write_begin is a new\ntrivial wrapper for block_prepare_write that always takes an already\nallocated page and can be either called from block_write_begin or filesystem\ncode that already has a page allocated.  Remove the handling of already\nallocated pages from block_write_begin after switching all callers that\ndo it to __block_write_begin.\n\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/buffer.c||fs/buffer.c",
          "fs/ext2/dir.c||fs/ext2/dir.c",
          "fs/ext3/inode.c||fs/ext3/inode.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/minix/inode.c||fs/minix/inode.c",
          "fs/nilfs2/dir.c||fs/nilfs2/dir.c",
          "fs/reiserfs/inode.c||fs/reiserfs/inode.c",
          "fs/sysv/itree.c||fs/sysv/itree.c",
          "fs/ufs/inode.c||fs/ufs/inode.c",
          "include/linux/buffer_head.h||include/linux/buffer_head.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/buffer.c||fs/buffer.c": [
          "File: fs/buffer.c -> fs/buffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1833: }",
          "1834: EXPORT_SYMBOL(page_zero_new_buffers);",
          "1838: {",
          "1839:  unsigned block_start, block_end;",
          "1840:  sector_t block;",
          "1841:  int err = 0;",
          "",
          "[Removed Lines]",
          "1836: static int __block_prepare_write(struct inode *inode, struct page *page,",
          "1837:   unsigned from, unsigned to, get_block_t *get_block)",
          "",
          "[Added Lines]",
          "1836: int block_prepare_write(struct page *page, unsigned from, unsigned to,",
          "1837:   get_block_t *get_block)",
          "1839:  struct inode *inode = page->mapping->host;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1908:   if (!buffer_uptodate(*wait_bh))",
          "1909:    err = -EIO;",
          "1910:  }",
          "1912:   page_zero_new_buffers(page, from, to);",
          "1913:  return err;",
          "1914: }",
          "1916: static int __block_commit_write(struct inode *inode, struct page *page,",
          "1917:   unsigned from, unsigned to)",
          "",
          "[Removed Lines]",
          "1911:  if (unlikely(err))",
          "",
          "[Added Lines]",
          "1912:  if (unlikely(err)) {",
          "1914:   ClearPageUptodate(page);",
          "1915:  }",
          "1918: EXPORT_SYMBOL(block_prepare_write);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1948:  return 0;",
          "1949: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1955: int __block_write_begin(struct page *page, loff_t pos, unsigned len,",
          "1956:   get_block_t *get_block)",
          "1957: {",
          "1958:  unsigned start = pos & (PAGE_CACHE_SIZE - 1);",
          "1960:  return block_prepare_write(page, start, start + len, get_block);",
          "1961: }",
          "1962: EXPORT_SYMBOL(__block_write_begin);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1958:    struct page **pagep, void **fsdata,",
          "1959:    get_block_t *get_block)",
          "1960: {",
          "1963:  struct page *page;",
          "1985:  if (unlikely(status)) {",
          "1993:  }",
          "1996:  return status;",
          "1997: }",
          "1998: EXPORT_SYMBOL(block_write_begin_newtrunc);",
          "",
          "[Removed Lines]",
          "1961:  struct inode *inode = mapping->host;",
          "1962:  int status = 0;",
          "1964:  pgoff_t index;",
          "1965:  unsigned start, end;",
          "1966:  int ownpage = 0;",
          "1968:  index = pos >> PAGE_CACHE_SHIFT;",
          "1969:  start = pos & (PAGE_CACHE_SIZE - 1);",
          "1970:  end = start + len;",
          "1972:  page = *pagep;",
          "1973:  if (page == NULL) {",
          "1974:   ownpage = 1;",
          "1975:   page = grab_cache_page_write_begin(mapping, index, flags);",
          "1976:   if (!page) {",
          "1977:    status = -ENOMEM;",
          "1978:    goto out;",
          "1979:   }",
          "1981:  } else",
          "1982:   BUG_ON(!PageLocked(page));",
          "1984:  status = __block_prepare_write(inode, page, start, end, get_block);",
          "1986:   ClearPageUptodate(page);",
          "1988:   if (ownpage) {",
          "1989:    unlock_page(page);",
          "1990:    page_cache_release(page);",
          "1992:   }",
          "1995: out:",
          "",
          "[Added Lines]",
          "1974:  pgoff_t index = pos >> PAGE_CACHE_SHIFT;",
          "1976:  int status;",
          "1978:  page = grab_cache_page_write_begin(mapping, index, flags);",
          "1979:  if (!page)",
          "1980:   return -ENOMEM;",
          "1982:  status = __block_write_begin(page, pos, len, get_block);",
          "1984:   unlock_page(page);",
          "1985:   page_cache_release(page);",
          "1986:   page = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2379: }",
          "2380: EXPORT_SYMBOL(cont_write_begin);",
          "2393: int block_commit_write(struct page *page, unsigned from, unsigned to)",
          "2394: {",
          "2395:  struct inode *inode = page->mapping->host;",
          "",
          "[Removed Lines]",
          "2382: int block_prepare_write(struct page *page, unsigned from, unsigned to,",
          "2383:    get_block_t *get_block)",
          "2384: {",
          "2385:  struct inode *inode = page->mapping->host;",
          "2386:  int err = __block_prepare_write(inode, page, from, to, get_block);",
          "2387:  if (err)",
          "2388:   ClearPageUptodate(page);",
          "2389:  return err;",
          "2390: }",
          "2391: EXPORT_SYMBOL(block_prepare_write);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext2/dir.c||fs/ext2/dir.c": [
          "File: fs/ext2/dir.c -> fs/ext2/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "451: static int ext2_prepare_chunk(struct page *page, loff_t pos, unsigned len)",
          "452: {",
          "455: }",
          "",
          "[Removed Lines]",
          "453:  return block_write_begin_newtrunc(NULL, page->mapping, pos, len, 0,",
          "454:        &page, NULL, ext2_get_block);",
          "",
          "[Added Lines]",
          "453:  return __block_write_begin(page, pos, len, ext2_get_block);",
          "",
          "---------------"
        ],
        "fs/ext3/inode.c||fs/ext3/inode.c": [
          "File: fs/ext3/inode.c -> fs/ext3/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1196:   ret = PTR_ERR(handle);",
          "1197:   goto out;",
          "1198:  }",
          "1201:  if (ret)",
          "1202:   goto write_begin_failed;",
          "",
          "[Removed Lines]",
          "1199:  ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,",
          "1200:        ext3_get_block);",
          "",
          "[Added Lines]",
          "1199:  ret = __block_write_begin(page, pos, len, ext3_get_block);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1580:  if (ext4_should_dioread_nolock(inode))",
          "1583:  else",
          "1587:  if (!ret && ext4_should_journal_data(inode)) {",
          "1588:   ret = walk_page_buffers(handle, page_buffers(page),",
          "",
          "[Removed Lines]",
          "1581:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
          "1582:     fsdata, ext4_get_block_write);",
          "1584:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
          "1585:     fsdata, ext4_get_block);",
          "",
          "[Added Lines]",
          "1581:   ret = __block_write_begin(page, pos, len, ext4_get_block_write);",
          "1583:   ret = __block_write_begin(page, pos, len, ext4_get_block);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3185:  }",
          "3190:  if (ret < 0) {",
          "3191:   unlock_page(page);",
          "3192:   ext4_journal_stop(handle);",
          "",
          "[Removed Lines]",
          "3188:  ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,",
          "3189:     ext4_da_get_block_prep);",
          "",
          "[Added Lines]",
          "3186:  ret = __block_write_begin(page, pos, len, ext4_da_get_block_prep);",
          "",
          "---------------"
        ],
        "fs/minix/inode.c||fs/minix/inode.c": [
          "File: fs/minix/inode.c -> fs/minix/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "360: int minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)",
          "361: {",
          "364: }",
          "366: static int minix_write_begin(struct file *file, struct address_space *mapping,",
          "",
          "[Removed Lines]",
          "362:  return block_write_begin_newtrunc(NULL, page->mapping, pos, len, 0,",
          "363:        &page, NULL, minix_get_block);",
          "",
          "[Added Lines]",
          "362:  return __block_write_begin(page, pos, len, minix_get_block);",
          "",
          "---------------"
        ],
        "fs/nilfs2/dir.c||fs/nilfs2/dir.c": [
          "File: fs/nilfs2/dir.c -> fs/nilfs2/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "83: static int nilfs_prepare_chunk(struct page *page, unsigned from, unsigned to)",
          "84: {",
          "85:  loff_t pos = page_offset(page) + from;",
          "88: }",
          "90: static void nilfs_commit_chunk(struct page *page,",
          "",
          "[Removed Lines]",
          "86:  return block_write_begin_newtrunc(NULL, page->mapping, pos, to - from,",
          "87:        0, &page, NULL, nilfs_get_block);",
          "",
          "[Added Lines]",
          "86:  return __block_write_begin(page, pos, to - from, nilfs_get_block);",
          "",
          "---------------"
        ],
        "fs/reiserfs/inode.c||fs/reiserfs/inode.c": [
          "File: fs/reiserfs/inode.c -> fs/reiserfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2585:   old_ref = th->t_refcount;",
          "2586:   th->t_refcount++;",
          "2587:  }",
          "2590:  if (ret && reiserfs_transaction_running(inode->i_sb)) {",
          "2591:   struct reiserfs_transaction_handle *th = current->journal_info;",
          "",
          "[Removed Lines]",
          "2588:  ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,",
          "2589:     reiserfs_get_block);",
          "",
          "[Added Lines]",
          "2588:  ret = __block_write_begin(page, pos, len, reiserfs_get_block);",
          "",
          "---------------"
        ],
        "fs/sysv/itree.c||fs/sysv/itree.c": [
          "File: fs/sysv/itree.c -> fs/sysv/itree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "462: int sysv_prepare_chunk(struct page *page, loff_t pos, unsigned len)",
          "463: {",
          "466: }",
          "468: static int sysv_write_begin(struct file *file, struct address_space *mapping,",
          "",
          "[Removed Lines]",
          "464:  return block_write_begin_newtrunc(NULL, page->mapping, pos, len, 0,",
          "465:        &page, NULL, get_block);",
          "",
          "[Added Lines]",
          "464:  return __block_write_begin(page, pos, len, get_block);",
          "",
          "---------------"
        ],
        "fs/ufs/inode.c||fs/ufs/inode.c": [
          "File: fs/ufs/inode.c -> fs/ufs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "561: int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)",
          "562: {",
          "565: }",
          "567: static int ufs_write_begin(struct file *file, struct address_space *mapping,",
          "",
          "[Removed Lines]",
          "563:  return block_write_begin_newtrunc(NULL, page->mapping, pos, len, 0,",
          "564:        &page, NULL, ufs_getfrag_block);",
          "",
          "[Added Lines]",
          "563:  return __block_write_begin(page, pos, len, ufs_getfrag_block);",
          "",
          "---------------"
        ],
        "include/linux/buffer_head.h||include/linux/buffer_head.h": [
          "File: include/linux/buffer_head.h -> include/linux/buffer_head.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "209: int block_write_begin(struct file *, struct address_space *,",
          "210:     loff_t, unsigned, unsigned,",
          "211:     struct page **, void **, get_block_t*);",
          "212: int block_write_end(struct file *, struct address_space *,",
          "213:     loff_t, unsigned, unsigned,",
          "214:     struct page *, void *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "212: int __block_write_begin(struct page *page, loff_t pos, unsigned len,",
          "213:   get_block_t *get_block);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "43ce1d23b43330634507a049b55c36e91d27282e",
      "candidate_info": {
        "commit_hash": "43ce1d23b43330634507a049b55c36e91d27282e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/43ce1d23b43330634507a049b55c36e91d27282e",
        "files": [
          "fs/ext4/inode.c",
          "include/trace/events/ext4.h"
        ],
        "message": "ext4: Fix mmap/truncate race when blocksize < pagesize && !nodellaoc\n\nThis patch fixes the mmap/truncate race that was fixed for delayed\nallocation by merging ext4_{journalled,normal,da}_writepage() into\next4_writepage().\n\nSigned-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>\nAcked-by: Jan Kara <jack@suse.cz>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "include/trace/events/ext4.h||include/trace/events/ext4.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #define MPAGE_DA_EXTENT_TAIL 0x01",
          "50: static inline int ext4_begin_ordered_truncate(struct inode *inode,",
          "51:            loff_t new_size)",
          "52: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: static int __ext4_journalled_writepage(struct page *page,",
          "51:            struct writeback_control *wbc,",
          "52:            unsigned int len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2519: }",
          "2529:         struct writeback_control *wbc)",
          "2530: {",
          "2531:  int ret = 0;",
          "",
          "[Removed Lines]",
          "2528: static int ext4_da_writepage(struct page *page,",
          "",
          "[Added Lines]",
          "2566: static int ext4_writepage(struct page *page,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2534:  struct buffer_head *page_bufs;",
          "2535:  struct inode *inode = page->mapping->host;",
          "2538:  size = i_size_read(inode);",
          "2539:  if (page->index == size >> PAGE_CACHE_SHIFT)",
          "2540:   len = size & ~PAGE_CACHE_MASK;",
          "",
          "[Removed Lines]",
          "2537:  trace_ext4_da_writepage(inode, page);",
          "",
          "[Added Lines]",
          "2575:  trace_ext4_writepage(inode, page);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2596:   block_commit_write(page, 0, len);",
          "2597:  }",
          "2599:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
          "2600:   ret = nobh_writepage(page, noalloc_get_block_write, wbc);",
          "2601:  else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2637:  if (PageChecked(page) && ext4_should_journal_data(inode)) {",
          "2642:   ClearPageChecked(page);",
          "2643:   return __ext4_journalled_writepage(page, wbc, len);",
          "2644:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3135:  return 0;",
          "3136: }",
          "3239: static int __ext4_journalled_writepage(struct page *page,",
          "3241: {",
          "3244:  struct address_space *mapping = page->mapping;",
          "3245:  struct inode *inode = mapping->host;",
          "3246:  struct buffer_head *page_bufs;",
          "",
          "[Removed Lines]",
          "3191: static int __ext4_normal_writepage(struct page *page,",
          "3192:        struct writeback_control *wbc)",
          "3193: {",
          "3194:  struct inode *inode = page->mapping->host;",
          "3196:  if (test_opt(inode->i_sb, NOBH))",
          "3197:   return nobh_writepage(page, noalloc_get_block_write, wbc);",
          "3198:  else",
          "3199:   return block_write_full_page(page, noalloc_get_block_write,",
          "3200:           wbc);",
          "3201: }",
          "3203: static int ext4_normal_writepage(struct page *page,",
          "3204:      struct writeback_control *wbc)",
          "3205: {",
          "3206:  struct inode *inode = page->mapping->host;",
          "3207:  loff_t size = i_size_read(inode);",
          "3208:  loff_t len;",
          "3210:  trace_ext4_normal_writepage(inode, page);",
          "3211:  J_ASSERT(PageLocked(page));",
          "3212:  if (page->index == size >> PAGE_CACHE_SHIFT)",
          "3213:   len = size & ~PAGE_CACHE_MASK;",
          "3214:  else",
          "3215:   len = PAGE_CACHE_SIZE;",
          "3217:  if (page_has_buffers(page)) {",
          "3227:   BUG_ON(walk_page_buffers(NULL, page_buffers(page), 0, len, NULL,",
          "3228:      ext4_bh_delay_or_unwritten));",
          "3229:  }",
          "3231:  if (!ext4_journal_current_handle())",
          "3232:   return __ext4_normal_writepage(page, wbc);",
          "3234:  redirty_page_for_writepage(wbc, page);",
          "3235:  unlock_page(page);",
          "3236:  return 0;",
          "3237: }",
          "3240:            struct writeback_control *wbc)",
          "3242:  loff_t size;",
          "3243:  unsigned int len;",
          "",
          "[Added Lines]",
          "3186:            struct writeback_control *wbc,",
          "3187:            unsigned int len)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3248:  int ret = 0;",
          "3249:  int err;",
          "3260:  page_bufs = page_buffers(page);",
          "3261:  walk_page_buffers(handle, page_bufs, 0, len, NULL, bget_one);",
          "",
          "[Removed Lines]",
          "3251:  size = i_size_read(inode);",
          "3252:  if (page->index == size >> PAGE_CACHE_SHIFT)",
          "3253:   len = size & ~PAGE_CACHE_MASK;",
          "3254:  else",
          "3255:   len = PAGE_CACHE_SIZE;",
          "3256:  ret = block_prepare_write(page, 0, len, noalloc_get_block_write);",
          "3257:  if (ret != 0)",
          "3258:   goto out_unlock;",
          "",
          "[Added Lines]",
          "3197:  BUG_ON(!page_bufs);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3283:  walk_page_buffers(handle, page_bufs, 0, len, NULL, bput_one);",
          "3284:  EXT4_I(inode)->i_state |= EXT4_STATE_JDATA;",
          "3289: out:",
          "3290:  return ret;",
          "3291: }",
          "3346: static int ext4_readpage(struct file *file, struct page *page)",
          "3347: {",
          "3348:  return mpage_readpage(page, ext4_get_block);",
          "",
          "[Removed Lines]",
          "3285:  goto out;",
          "3287: out_unlock:",
          "3288:  unlock_page(page);",
          "3293: static int ext4_journalled_writepage(struct page *page,",
          "3294:          struct writeback_control *wbc)",
          "3295: {",
          "3296:  struct inode *inode = page->mapping->host;",
          "3297:  loff_t size = i_size_read(inode);",
          "3298:  loff_t len;",
          "3300:  trace_ext4_journalled_writepage(inode, page);",
          "3301:  J_ASSERT(PageLocked(page));",
          "3302:  if (page->index == size >> PAGE_CACHE_SHIFT)",
          "3303:   len = size & ~PAGE_CACHE_MASK;",
          "3304:  else",
          "3305:   len = PAGE_CACHE_SIZE;",
          "3307:  if (page_has_buffers(page)) {",
          "3317:   BUG_ON(walk_page_buffers(NULL, page_buffers(page), 0, len, NULL,",
          "3318:      ext4_bh_delay_or_unwritten));",
          "3319:  }",
          "3321:  if (ext4_journal_current_handle())",
          "3322:   goto no_write;",
          "3324:  if (PageChecked(page)) {",
          "3329:   ClearPageChecked(page);",
          "3330:   return __ext4_journalled_writepage(page, wbc);",
          "3331:  } else {",
          "3337:   return block_write_full_page(page, noalloc_get_block_write,",
          "3338:           wbc);",
          "3339:  }",
          "3340: no_write:",
          "3341:  redirty_page_for_writepage(wbc, page);",
          "3342:  unlock_page(page);",
          "3343:  return 0;",
          "3344: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3489: static const struct address_space_operations ext4_ordered_aops = {",
          "3490:  .readpage  = ext4_readpage,",
          "3491:  .readpages  = ext4_readpages,",
          "3493:  .sync_page  = block_sync_page,",
          "3494:  .write_begin  = ext4_write_begin,",
          "3495:  .write_end  = ext4_ordered_write_end,",
          "",
          "[Removed Lines]",
          "3492:  .writepage  = ext4_normal_writepage,",
          "",
          "[Added Lines]",
          "3372:  .writepage  = ext4_writepage,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3504: static const struct address_space_operations ext4_writeback_aops = {",
          "3505:  .readpage  = ext4_readpage,",
          "3506:  .readpages  = ext4_readpages,",
          "3508:  .sync_page  = block_sync_page,",
          "3509:  .write_begin  = ext4_write_begin,",
          "3510:  .write_end  = ext4_writeback_write_end,",
          "",
          "[Removed Lines]",
          "3507:  .writepage  = ext4_normal_writepage,",
          "",
          "[Added Lines]",
          "3387:  .writepage  = ext4_writepage,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3519: static const struct address_space_operations ext4_journalled_aops = {",
          "3520:  .readpage  = ext4_readpage,",
          "3521:  .readpages  = ext4_readpages,",
          "3523:  .sync_page  = block_sync_page,",
          "3524:  .write_begin  = ext4_write_begin,",
          "3525:  .write_end  = ext4_journalled_write_end,",
          "",
          "[Removed Lines]",
          "3522:  .writepage  = ext4_journalled_writepage,",
          "",
          "[Added Lines]",
          "3402:  .writepage  = ext4_writepage,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3533: static const struct address_space_operations ext4_da_aops = {",
          "3534:  .readpage  = ext4_readpage,",
          "3535:  .readpages  = ext4_readpages,",
          "3537:  .writepages  = ext4_da_writepages,",
          "3538:  .sync_page  = block_sync_page,",
          "3539:  .write_begin  = ext4_da_write_begin,",
          "",
          "[Removed Lines]",
          "3536:  .writepage  = ext4_da_writepage,",
          "",
          "[Added Lines]",
          "3416:  .writepage  = ext4_writepage,",
          "",
          "---------------"
        ],
        "include/trace/events/ext4.h||include/trace/events/ext4.h": [
          "File: include/trace/events/ext4.h -> include/trace/events/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:     __entry->copied)",
          "191: );",
          "194:  TP_PROTO(struct inode *inode, struct page *page),",
          "196:  TP_ARGS(inode, page),",
          "",
          "[Removed Lines]",
          "193: TRACE_EVENT(ext4_da_writepage,",
          "",
          "[Added Lines]",
          "193: TRACE_EVENT(ext4_writepage,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "342:     __entry->copied)",
          "343: );",
          "388: TRACE_EVENT(ext4_discard_blocks,",
          "389:  TP_PROTO(struct super_block *sb, unsigned long long blk,",
          "390:    unsigned long long count),",
          "",
          "[Removed Lines]",
          "345: TRACE_EVENT(ext4_normal_writepage,",
          "346:  TP_PROTO(struct inode *inode, struct page *page),",
          "348:  TP_ARGS(inode, page),",
          "350:  TP_STRUCT__entry(",
          "351:   __field( dev_t, dev   )",
          "352:   __field( ino_t, ino   )",
          "353:   __field( pgoff_t, index   )",
          "354:  ),",
          "356:  TP_fast_assign(",
          "357:   __entry->dev = inode->i_sb->s_dev;",
          "358:   __entry->ino = inode->i_ino;",
          "359:   __entry->index = page->index;",
          "360:  ),",
          "362:  TP_printk(\"dev %s ino %lu page_index %lu\",",
          "363:     jbd2_dev_to_name(__entry->dev), __entry->ino, __entry->index)",
          "364: );",
          "366: TRACE_EVENT(ext4_journalled_writepage,",
          "367:  TP_PROTO(struct inode *inode, struct page *page),",
          "369:  TP_ARGS(inode, page),",
          "371:  TP_STRUCT__entry(",
          "372:   __field( dev_t, dev   )",
          "373:   __field( ino_t, ino   )",
          "374:   __field( pgoff_t, index   )",
          "376:  ),",
          "378:  TP_fast_assign(",
          "379:   __entry->dev = inode->i_sb->s_dev;",
          "380:   __entry->ino = inode->i_ino;",
          "381:   __entry->index = page->index;",
          "382:  ),",
          "384:  TP_printk(\"dev %s ino %lu page_index %lu\",",
          "385:     jbd2_dev_to_name(__entry->dev), __entry->ino, __entry->index)",
          "386: );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b767e78a179e5ab30fdbff1686d074ac270471eb",
      "candidate_info": {
        "commit_hash": "b767e78a179e5ab30fdbff1686d074ac270471eb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b767e78a179e5ab30fdbff1686d074ac270471eb",
        "files": [
          "fs/ext4/inode.c"
        ],
        "message": "ext4: Don't look at buffer_heads outside i_size.\n\nBuffer heads outside i_size will be unmapped. So when we\nare doing \"walk_page_buffers\" limit ourself to i_size.\n\nSigned-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>\nReviewed-by: Josef Bacik <jbacik@redhat.com>\nAcked-by: Jan Kara <jack@suse.cz>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\n----",
        "before_after_code_files": [
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2582:        noalloc_get_block_write);",
          "2583:   if (!ret) {",
          "2584:    page_bufs = page_buffers(page);",
          "",
          "[Removed Lines]",
          "2581:   ret = block_prepare_write(page, 0, PAGE_CACHE_SIZE,",
          "",
          "[Added Lines]",
          "2581:   ret = block_prepare_write(page, 0, len,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2600:    return 0;",
          "2601:   }",
          "2604:  }",
          "2606:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
          "",
          "[Removed Lines]",
          "2603:   block_commit_write(page, 0, PAGE_CACHE_SIZE);",
          "",
          "[Added Lines]",
          "2603:   block_commit_write(page, 0, len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3246: static int __ext4_journalled_writepage(struct page *page,",
          "3247:            struct writeback_control *wbc)",
          "3248: {",
          "3249:  struct address_space *mapping = page->mapping;",
          "3250:  struct inode *inode = mapping->host;",
          "3251:  struct buffer_head *page_bufs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3249:  loff_t size;",
          "3250:  unsigned int len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3253:  int ret = 0;",
          "3254:  int err;",
          "3258:  if (ret != 0)",
          "3259:   goto out_unlock;",
          "3261:  page_bufs = page_buffers(page);",
          "3266:  unlock_page(page);",
          "",
          "[Removed Lines]",
          "3256:  ret = block_prepare_write(page, 0, PAGE_CACHE_SIZE,",
          "3257:       noalloc_get_block_write);",
          "3262:  walk_page_buffers(handle, page_bufs, 0, PAGE_CACHE_SIZE, NULL,",
          "3263:         bget_one);",
          "",
          "[Added Lines]",
          "3258:  size = i_size_read(inode);",
          "3259:  if (page->index == size >> PAGE_CACHE_SHIFT)",
          "3260:   len = size & ~PAGE_CACHE_MASK;",
          "3261:  else",
          "3262:   len = PAGE_CACHE_SIZE;",
          "3263:  ret = block_prepare_write(page, 0, len, noalloc_get_block_write);",
          "3268:  walk_page_buffers(handle, page_bufs, 0, len, NULL, bget_one);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3271:   goto out;",
          "3272:  }",
          "3279:  if (ret == 0)",
          "3280:   ret = err;",
          "3281:  err = ext4_journal_stop(handle);",
          "3282:  if (!ret)",
          "3283:   ret = err;",
          "3287:  EXT4_I(inode)->i_state |= EXT4_STATE_JDATA;",
          "3288:  goto out;",
          "",
          "[Removed Lines]",
          "3274:  ret = walk_page_buffers(handle, page_bufs, 0,",
          "3275:    PAGE_CACHE_SIZE, NULL, do_journal_get_write_access);",
          "3277:  err = walk_page_buffers(handle, page_bufs, 0,",
          "3278:     PAGE_CACHE_SIZE, NULL, write_end_fn);",
          "3285:  walk_page_buffers(handle, page_bufs, 0,",
          "3286:     PAGE_CACHE_SIZE, NULL, bput_one);",
          "",
          "[Added Lines]",
          "3279:  ret = walk_page_buffers(handle, page_bufs, 0, len, NULL,",
          "3280:     do_journal_get_write_access);",
          "3282:  err = walk_page_buffers(handle, page_bufs, 0, len, NULL,",
          "3283:     write_end_fn);",
          "3290:  walk_page_buffers(handle, page_bufs, 0, len, NULL, bput_one);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
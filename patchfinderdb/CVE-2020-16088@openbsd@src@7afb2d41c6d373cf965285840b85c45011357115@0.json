{
  "cve_id": "CVE-2020-16088",
  "cve_desc": "iked in OpenIKED, as used in OpenBSD through 6.7, allows authentication bypass because ca.c has the wrong logic for checking whether a public key matches.",
  "repo": "openbsd/src",
  "patch_hash": "7afb2d41c6d373cf965285840b85c45011357115",
  "patch_info": {
    "commit_hash": "7afb2d41c6d373cf965285840b85c45011357115",
    "repo": "openbsd/src",
    "commit_url": "https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115",
    "files": [
      "sbin/iked/ca.c"
    ],
    "message": "Fix return value check for openssl API used during pubkey validation.\n\nFound thanks to bug report by Michael Scheibel <m.Scheibel (at) tuvit (dot) de>\nok patrick@, markus@, tb@",
    "before_after_code_files": [
      "sbin/iked/ca.c||sbin/iked/ca.c"
    ]
  },
  "patch_diff": {
    "sbin/iked/ca.c||sbin/iked/ca.c": [
      "File: sbin/iked/ca.c -> sbin/iked/ca.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1420:  if (localkey == NULL)",
      "1421:   goto sslerr;",
      "1424:   log_debug(\"%s: public key does not match %s\", __func__, file);",
      "1425:   goto done;",
      "1426:  }",
      "",
      "[Removed Lines]",
      "1423:  if (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {",
      "",
      "[Added Lines]",
      "1423:  if (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "adb747051e789ed1c1996b5c86eb2c191a6005ac",
      "candidate_info": {
        "commit_hash": "adb747051e789ed1c1996b5c86eb2c191a6005ac",
        "repo": "openbsd/src",
        "commit_url": "https://github.com/openbsd/src/commit/adb747051e789ed1c1996b5c86eb2c191a6005ac",
        "files": [
          "sbin/iked/ca.c",
          "sbin/iked/iked.h",
          "sbin/iked/ikev2.c"
        ],
        "message": "Make CERT and CERTREQ payloads optional for public key authentication.\n\nWhen using certificate authentication the CERT payload is mandatory and as the\nname suggests is used to send a certificate containing a public key used for\nthe authentication signature.\nFor pubkey authentication the key is preshared and stored locally, but only\nthe 'ca' process can read the local keys.  The 'ikev2' process had to get the\nkey from the received CERT payload to verify the authentication signature.\nThe peer ID + raw key was then forwarded to the 'ca' process which\ncompared the key against the contents of /etc/iked/pubkey and returned either\nCERTVALID or CERTINVALID.\n\nWith this change a message containing only the ID may be sent from 'ikev2' to\nthe 'ca' process if CERT was not included.  In this case the CA process will\ntry to find a local key matching the ID and return it to the 'ikev2' process.\nThe auth verification happens after the 'ca' process has verified or found a\nkey and returned it to the 'ikev2' process, eliminating the need for\nthe CERT payload.\n\nMaking CERTREQ optional is easier because we already have a fallback case if\nthe CERTREQ can not be fulfilled.  If no CERTREQ was received we now use this\nsame fallback.\n\nThis should fix public key authentication interoperability with *swan and\nother IKEv2 implementations.\n\nok and tested by kn@\nok patrick@",
        "before_after_code_files": [
          "sbin/iked/ca.c||sbin/iked/ca.c",
          "sbin/iked/iked.h||sbin/iked/iked.h",
          "sbin/iked/ikev2.c||sbin/iked/ikev2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sbin/iked/ca.c||sbin/iked/ca.c"
          ],
          "candidate": [
            "sbin/iked/ca.c||sbin/iked/ca.c"
          ]
        }
      },
      "candidate_diff": {
        "sbin/iked/ca.c||sbin/iked/ca.c": [
          "File: sbin/iked/ca.c -> sbin/iked/ca.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: int  ca_subjectpubkey_digest(X509 *, uint8_t *, unsigned int *);",
          "63: int  ca_x509_subject_cmp(X509 *, struct iked_static_id *);",
          "64: int  ca_validate_pubkey(struct iked *, struct iked_static_id *,",
          "66: int  ca_validate_cert(struct iked *, struct iked_static_id *,",
          "67:      void *, size_t);",
          "68: int  ca_privkey_to_method(struct iked_id *);",
          "",
          "[Removed Lines]",
          "65:      void *, size_t);",
          "",
          "[Added Lines]",
          "65:      void *, size_t, struct iked_id *);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "289:  iov[iovcnt].iov_base = &type;",
          "290:  iov[iovcnt].iov_len = sizeof(type);",
          "291:  iovcnt++;",
          "296:  if (proc_composev(&env->sc_ps, procid, IMSG_CERT, iov, iovcnt) == -1)",
          "297:   return (-1);",
          "",
          "[Removed Lines]",
          "292:  iov[iovcnt].iov_base = data;",
          "293:  iov[iovcnt].iov_len = len;",
          "294:  iovcnt++;",
          "",
          "[Added Lines]",
          "292:  if (data != NULL) {",
          "293:   iov[iovcnt].iov_base = data;",
          "294:   iov[iovcnt].iov_len = len;",
          "295:   iovcnt++;",
          "296:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "333:  iov[iovcnt].iov_base = &more;",
          "334:  iov[iovcnt].iov_len = sizeof(more);",
          "335:  iovcnt++;",
          "340:  if (proc_composev(&env->sc_ps, procid, IMSG_CERTREQ, iov, iovcnt) == -1)",
          "341:   goto done;",
          "",
          "[Removed Lines]",
          "336:  iov[iovcnt].iov_base = data;",
          "337:  iov[iovcnt].iov_len = len;",
          "338:  iovcnt++;",
          "",
          "[Added Lines]",
          "338:  if (data != NULL) {",
          "339:   iov[iovcnt].iov_base = data;",
          "340:   iov[iovcnt].iov_len = len;",
          "341:   iovcnt++;",
          "342:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "418:  size_t    len;",
          "419:  struct iked_static_id  id;",
          "420:  unsigned int   i;",
          "424:  ptr = (uint8_t *)imsg->data;",
          "425:  len = IMSG_DATA_SIZE(imsg);",
          "426:  i = sizeof(id) + sizeof(sh) + sizeof(type);",
          "428:   return (-1);",
          "430:  memcpy(&id, ptr, sizeof(id));",
          "",
          "[Removed Lines]",
          "421:  struct iovec   iov[2];",
          "422:  int    iovcnt = 2, cmd, ret = 0;",
          "427:  if (len <= i)",
          "",
          "[Added Lines]",
          "425:  struct iovec   iov[3];",
          "426:  int    iovcnt = 3, cmd, ret = 0;",
          "427:  struct iked_id   key;",
          "432:  if (len < i)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "436:  ptr += i;",
          "437:  len -= i;",
          "439:  switch (type) {",
          "440:  case IKEV2_CERT_X509_CERT:",
          "441:   ret = ca_validate_cert(env, &id, ptr, len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "444:  bzero(&key, sizeof(key));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "447:   break;",
          "448:  case IKEV2_CERT_RSA_KEY:",
          "449:  case IKEV2_CERT_ECDSA:",
          "451:   break;",
          "452:  default:",
          "453:   log_debug(\"%s: unsupported cert type %d\", __func__, type);",
          "",
          "[Removed Lines]",
          "450:   ret = ca_validate_pubkey(env, &id, ptr, len);",
          "",
          "[Added Lines]",
          "457:   ret = ca_validate_pubkey(env, &id, ptr, len, NULL);",
          "458:   break;",
          "459:  case IKEV2_CERT_NONE:",
          "461:   ret = ca_validate_pubkey(env, &id, NULL, 0, &key);",
          "462:   if (ret == 0) {",
          "463:    ptr = ibuf_data(key.id_buf);",
          "464:    len = ibuf_length(key.id_buf);",
          "465:    type = key.id_type;",
          "466:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "464:  iov[0].iov_len = sizeof(sh);",
          "465:  iov[1].iov_base = &type;",
          "466:  iov[1].iov_len = sizeof(type);",
          "468:  if (proc_composev(&env->sc_ps, PROC_IKEV2, cmd, iov, iovcnt) == -1)",
          "469:   return (-1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "483:  iov[2].iov_base = ptr;",
          "484:  iov[2].iov_len = len;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "541:     break;",
          "542:    }",
          "543:   }",
          "545:  fallback:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:  case IKEV2_CERT_NONE:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1312: int",
          "1313: ca_validate_pubkey(struct iked *env, struct iked_static_id *id,",
          "1315: {",
          "1316:  BIO  *rawcert = NULL;",
          "1317:  RSA  *peerrsa = NULL, *localrsa = NULL;",
          "",
          "[Removed Lines]",
          "1314:     void *data, size_t len)",
          "",
          "[Added Lines]",
          "1333:     void *data, size_t len, struct iked_id *out)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1323:  char   file[PATH_MAX];",
          "1324:  struct iked_id  idp;",
          "1329:  switch (id->id_type) {",
          "1330:  case IKEV2_ID_IPV4:",
          "1331:  case IKEV2_ID_FQDN:",
          "",
          "[Removed Lines]",
          "1326:  if (len == 0 && data == NULL)",
          "1327:   return (-1);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1348:  if (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)",
          "1349:   goto done;",
          "1353:   peerkey = (EVP_PKEY *)data;",
          "1355:   if ((rawcert = BIO_new_mem_buf(data, len)) == NULL)",
          "1356:    goto done;",
          "",
          "[Removed Lines]",
          "1351:  if (len == 0) {",
          "1354:  } else {",
          "",
          "[Added Lines]",
          "1367:  if (len == 0 && data) {",
          "1370:  }",
          "1371:  if (len > 0) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1403:  if (localkey == NULL)",
          "1404:   goto sslerr;",
          "1407:   log_debug(\"%s: public key does not match %s\", __func__, file);",
          "1408:   goto done;",
          "1409:  }",
          "1411:  log_debug(\"%s: valid public key in file %s\", __func__, file);",
          "1413:  ret = 0;",
          "1414:  sslerr:",
          "1415:  if (ret != 0)",
          "",
          "[Removed Lines]",
          "1406:  if (!EVP_PKEY_cmp(peerkey, localkey)) {",
          "",
          "[Added Lines]",
          "1423:  if (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {",
          "1430:  if (out && ca_pubkey_serialize(localkey, out))",
          "1431:   goto done;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1468:    errstr = \"no public key in cert\";",
          "1469:    goto done;",
          "1470:   }",
          "1472:   EVP_PKEY_free(pkey);",
          "1473:   if (ret == 0) {",
          "1474:    errstr = \"in public key file, ok\";",
          "",
          "[Removed Lines]",
          "1471:   ret = ca_validate_pubkey(env, id, pkey, 0);",
          "",
          "[Added Lines]",
          "1491:   ret = ca_validate_pubkey(env, id, pkey, 0, NULL);",
          "",
          "---------------"
        ],
        "sbin/iked/iked.h||sbin/iked/iked.h": [
          "File: sbin/iked/iked.h -> sbin/iked/iked.h"
        ],
        "sbin/iked/ikev2.c||sbin/iked/ikev2.c": [
          "File: sbin/iked/ikev2.c -> sbin/iked/ikev2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: int  ikev2_ike_auth_recv(struct iked *, struct iked_sa *,",
          "71:      struct iked_message *);",
          "72: int  ikev2_ike_auth(struct iked *, struct iked_sa *);",
          "74: void  ikev2_init_recv(struct iked *, struct iked_message *,",
          "75:      struct ike_header *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: int  ikev2_auth_verify(struct iked *, struct iked_sa *);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "291:   break;",
          "292:  case IMSG_CERTVALID:",
          "295:   if ((sa = ikev2_getimsgdata(env, imsg,",
          "296:       &sh, &type, &ptr, &len)) == NULL ||",
          "297:       sa->sa_state < IKEV2_STATE_EAP)",
          "298:    break;",
          "307:    break;",
          "308:   }",
          "309:   if (ikev2_ike_auth(env, sa) != 0)",
          "310:    log_debug(\"%s: failed to send ike auth\", __func__);",
          "311:   break;",
          "312:  case IMSG_CERT:",
          "313:   if ((sa = ikev2_getimsgdata(env, imsg,",
          "314:       &sh, &type, &ptr, &len)) == NULL) {",
          "",
          "[Removed Lines]",
          "293:  case IMSG_CERTINVALID:",
          "300:   if (imsg->hdr.type == IMSG_CERTVALID) {",
          "301:    log_debug(\"%s: peer certificate is valid\", __func__);",
          "302:    sa_stateflags(sa, IKED_REQ_CERTVALID);",
          "303:   } else {",
          "304:    log_warnx(\"%s: peer certificate is invalid\",",
          "305:        SPI_SA(sa, __func__));",
          "306:    ikev2_send_auth_failed(env, sa);",
          "",
          "[Added Lines]",
          "300:   if (sh.sh_initiator)",
          "301:    id = &sa->sa_rcert;",
          "302:   else",
          "303:    id = &sa->sa_icert;",
          "305:   id->id_type = type;",
          "306:   id->id_offset = 0;",
          "307:   ibuf_release(id->id_buf);",
          "308:   id->id_buf = NULL;",
          "310:   if (len > 0 && (id->id_buf = ibuf_new(ptr, len)) == NULL) {",
          "311:    log_debug(\"%s: failed to get cert payload\",",
          "312:        __func__);",
          "316:   if (sa->sa_peerauth.id_type && ikev2_auth_verify(env, sa))",
          "317:    break;",
          "319:   log_debug(\"%s: peer certificate is valid\", __func__);",
          "320:   sa_stateflags(sa, IKED_REQ_CERTVALID);",
          "325:  case IMSG_CERTINVALID:",
          "327:   if ((sa = ikev2_getimsgdata(env, imsg,",
          "328:       &sh, &type, &ptr, &len)) == NULL ||",
          "329:       sa->sa_state < IKEV2_STATE_EAP)",
          "330:    break;",
          "331:   log_warnx(\"%s: peer certificate is invalid\",",
          "332:    SPI_SA(sa, __func__));",
          "333:   ikev2_send_auth_failed(env, sa);",
          "334:   break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "707:  return (-1);",
          "708: }",
          "710: int",
          "711: ikev2_ike_auth_recv(struct iked *env, struct iked_sa *sa,",
          "712:     struct iked_message *msg)",
          "713: {",
          "714:  struct iked_id  *id, *certid;",
          "715:  struct ibuf  *authmsg;",
          "717:  struct iked_policy *policy = sa->sa_policy;",
          "721:  if (msg->msg_auth.id_type != IKEV2_AUTH_NONE &&",
          "",
          "[Removed Lines]",
          "716:  struct iked_auth  ikeauth;",
          "718:  int    ret = -1;",
          "",
          "[Added Lines]",
          "733: int",
          "734: ikev2_auth_verify(struct iked *env, struct iked_sa *sa)",
          "735: {",
          "736:  struct iked_auth  ikeauth;",
          "737:  struct ibuf  *authmsg;",
          "738:  int    ret;",
          "740:  memcpy(&ikeauth, &sa->sa_policy->pol_auth,",
          "741:      sizeof(ikeauth));",
          "743:  if (sa->sa_policy->pol_auth.auth_eap &&",
          "744:      sa->sa_eapmsk != NULL) {",
          "749:   ikeauth.auth_method = IKEV2_AUTH_SHARED_KEY_MIC;",
          "752:   memcpy(ikeauth.auth_data,",
          "753:       ibuf_data(sa->sa_eapmsk),",
          "754:       ibuf_size(sa->sa_eapmsk));",
          "755:   ikeauth.auth_length = ibuf_size(sa->sa_eapmsk);",
          "756:  }",
          "758:  if (ikev2_ike_auth_compatible(sa,",
          "759:      ikeauth.auth_method, sa->sa_peerauth.id_type) < 0) {",
          "760:   log_warnx(\"%s: unexpected auth method %s, was \"",
          "761:       \"expecting %s\", SPI_SA(sa, __func__),",
          "762:       print_map(sa->sa_peerauth.id_type,",
          "763:       ikev2_auth_map),",
          "764:       print_map(ikeauth.auth_method,",
          "765:       ikev2_auth_map));",
          "766:   return (-1);",
          "767:  }",
          "768:  ikeauth.auth_method = sa->sa_peerauth.id_type;",
          "770:  if ((authmsg = ikev2_msg_auth(env, sa,",
          "771:      sa->sa_hdr.sh_initiator)) == NULL) {",
          "772:   log_debug(\"%s: failed to get auth data\",",
          "773:       __func__);",
          "774:   return (-1);",
          "775:  }",
          "777:  ret = ikev2_msg_authverify(env, sa, &ikeauth,",
          "778:      ibuf_data(sa->sa_peerauth.id_buf),",
          "779:      ibuf_length(sa->sa_peerauth.id_buf),",
          "780:      authmsg);",
          "781:  ibuf_release(authmsg);",
          "782:  if (ret != 0) {",
          "783:   log_info(\"%s: ikev2_msg_authverify failed\",",
          "784:       SPI_SA(sa, __func__));",
          "785:   ikev2_send_auth_failed(env, sa);",
          "786:   return (-1);",
          "787:  }",
          "788:  if (sa->sa_eapmsk != NULL) {",
          "789:   if ((authmsg = ikev2_msg_auth(env, sa,",
          "790:       !sa->sa_hdr.sh_initiator)) == NULL) {",
          "791:    log_debug(\"%s: failed to get auth data\",",
          "792:        __func__);",
          "793:    return (-1);",
          "794:   }",
          "797:   ret = ikev2_msg_authsign(env, sa, &ikeauth, authmsg);",
          "798:   ibuf_release(authmsg);",
          "799:   if (ret != 0) {",
          "800:    ikev2_send_auth_failed(env, sa);",
          "801:    return (-1);",
          "802:   }",
          "805:   sa_stateflags(sa, IKED_REQ_AUTHVALID);",
          "806:   sa_stateflags(sa, IKED_REQ_EAPVALID);",
          "807:   sa_state(env, sa, IKEV2_STATE_EAP_SUCCESS);",
          "808:  }",
          "810:  return (0);",
          "811: }",
          "820:  uint8_t   *cert = NULL;",
          "821:  size_t    certlen = 0;",
          "822:  int    certtype = IKEV2_CERT_NONE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "784:   }",
          "785:  }",
          "867:  if (!TAILQ_EMPTY(&msg->msg_proposals)) {",
          "868:   if (proposals_negotiate(&sa->sa_proposals,",
          "869:       &sa->sa_policy->pol_proposals, &msg->msg_proposals,",
          "",
          "[Removed Lines]",
          "787:  if (msg->msg_cert.id_type) {",
          "788:   memcpy(certid, &msg->msg_cert, sizeof(*certid));",
          "789:   bzero(&msg->msg_cert, sizeof(msg->msg_cert));",
          "791:   ca_setcert(env, &sa->sa_hdr,",
          "792:       id, certid->id_type,",
          "793:       ibuf_data(certid->id_buf),",
          "794:       ibuf_length(certid->id_buf), PROC_CERT);",
          "795:  }",
          "797:  if (msg->msg_auth.id_type) {",
          "798:   memcpy(&ikeauth, &policy->pol_auth, sizeof(ikeauth));",
          "800:   if (policy->pol_auth.auth_eap && sa->sa_eapmsk != NULL) {",
          "805:    ikeauth.auth_method = IKEV2_AUTH_SHARED_KEY_MIC;",
          "808:    memcpy(ikeauth.auth_data, ibuf_data(sa->sa_eapmsk),",
          "809:        ibuf_size(sa->sa_eapmsk));",
          "810:    ikeauth.auth_length = ibuf_size(sa->sa_eapmsk);",
          "811:   }",
          "813:   if (ikev2_ike_auth_compatible(sa,",
          "814:       ikeauth.auth_method, msg->msg_auth.id_type) < 0) {",
          "815:    log_warnx(\"%s: unexpected auth method %s, was \"",
          "816:        \"expecting %s\", SPI_SA(sa, __func__),",
          "817:        print_map(msg->msg_auth.id_type, ikev2_auth_map),",
          "818:        print_map(ikeauth.auth_method, ikev2_auth_map));",
          "819:    return (-1);",
          "820:   }",
          "821:   ikeauth.auth_method = msg->msg_auth.id_type;",
          "823:   if ((authmsg = ikev2_msg_auth(env, sa,",
          "824:       sa->sa_hdr.sh_initiator)) == NULL) {",
          "825:    log_debug(\"%s: failed to get auth data\", __func__);",
          "826:    return (-1);",
          "827:   }",
          "829:   ret = ikev2_msg_authverify(env, sa, &ikeauth,",
          "830:       ibuf_data(msg->msg_auth.id_buf),",
          "831:       ibuf_length(msg->msg_auth.id_buf),",
          "832:       authmsg);",
          "833:   ibuf_release(authmsg);",
          "835:   if (ret != 0) {",
          "836:    log_info(\"%s: ikev2_msg_authverify failed\",",
          "837:        SPI_SA(sa, __func__));",
          "838:    ikev2_send_auth_failed(env, sa);",
          "839:    return (-1);",
          "840:   }",
          "842:   if (sa->sa_eapmsk != NULL) {",
          "843:    if ((authmsg = ikev2_msg_auth(env, sa,",
          "844:        !sa->sa_hdr.sh_initiator)) == NULL) {",
          "845:     log_debug(\"%s: failed to get auth data\",",
          "846:         __func__);",
          "847:     return (-1);",
          "848:    }",
          "851:    ret = ikev2_msg_authsign(env, sa, &ikeauth, authmsg);",
          "852:    ibuf_release(authmsg);",
          "854:    if (ret != 0) {",
          "856:     return (-1);",
          "857:    }",
          "860:    sa_stateflags(sa, IKED_REQ_AUTHVALID);",
          "861:    sa_stateflags(sa, IKED_REQ_EAPVALID);",
          "863:    sa_state(env, sa, IKEV2_STATE_EAP_SUCCESS);",
          "864:   }",
          "865:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "875:    sa_stateflags(sa, IKED_REQ_SA);",
          "876:  }",
          "878:  return ikev2_ike_auth(env, sa);",
          "879: }",
          "881: int",
          "882: ikev2_ike_auth(struct iked *env, struct iked_sa *sa)",
          "883: {",
          "888:  if (sa->sa_state == IKEV2_STATE_EAP_SUCCESS)",
          "889:   sa_state(env, sa, IKEV2_STATE_EAP_VALID);",
          "",
          "[Removed Lines]",
          "884:  struct iked_policy *pol = sa->sa_policy;",
          "885:  uint8_t    certreqtype;",
          "",
          "[Added Lines]",
          "902:  if (msg->msg_auth.id_type) {",
          "903:   memcpy(&sa->sa_peerauth, &msg->msg_auth, sizeof(sa->sa_peerauth));",
          "904:   bzero(&msg->msg_auth, sizeof(msg->msg_auth));",
          "905:  }",
          "908:  if ((sa->sa_policy->pol_auth.auth_eap &&",
          "909:      sa->sa_eapmsk != NULL) ||",
          "910:      sa->sa_policy->pol_auth.auth_method == IKEV2_AUTH_SHARED_KEY_MIC)",
          "911:   ikev2_auth_verify(env, sa);",
          "913:  else if (sa->sa_peerauth.id_type) {",
          "914:   if (msg->msg_cert.id_type) {",
          "915:    certtype = msg->msg_cert.id_type;",
          "916:    cert = ibuf_data(msg->msg_cert.id_buf);",
          "917:    certlen = ibuf_length(msg->msg_cert.id_buf);",
          "918:    bzero(&msg->msg_cert, sizeof(msg->msg_cert));",
          "919:   }",
          "920:   if (ca_setcert(env, &sa->sa_hdr, id, certtype, cert, certlen, PROC_CERT) == -1)",
          "921:    return (-1);",
          "922:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "893:  if (sa->sa_hdr.sh_initiator) {",
          "894:   if (sa_stateok(sa, IKEV2_STATE_AUTH_SUCCESS))",
          "895:    return (ikev2_init_done(env, sa));",
          "896:   else",
          "897:    return (ikev2_init_ike_auth(env, sa));",
          "898:  }",
          "921:  return (ikev2_resp_ike_auth(env, sa));",
          "922: }",
          "",
          "[Removed Lines]",
          "906:  if (sa->sa_statevalid & IKED_REQ_CERT) {",
          "907:   if ((sa->sa_stateflags & IKED_REQ_CERTREQ) == 0) {",
          "908:    log_debug(\"%s: no CERTREQ, using default\", __func__);",
          "909:    if (pol->pol_certreqtype)",
          "910:     certreqtype = pol->pol_certreqtype;",
          "911:    else",
          "912:     certreqtype = env->sc_certreqtype;",
          "913:    return (ca_setreq(env, sa,",
          "914:        &pol->pol_localid, certreqtype, 0,",
          "915:        ibuf_data(env->sc_certreq),",
          "916:        ibuf_size(env->sc_certreq), PROC_CERT));",
          "917:   } else if ((sa->sa_stateflags & IKED_REQ_CERT) == 0)",
          "919:  }",
          "",
          "[Added Lines]",
          "940:   else if (sa_stateok(sa, IKEV2_STATE_AUTH_REQUEST))",
          "941:    return (0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3012: {",
          "3013:  struct iked_certreq *cr;",
          "3014:  struct iked_sa  *sa;",
          "3017:  if ((sa = msg->msg_sa) == NULL)",
          "3018:   return (-1);",
          "",
          "[Removed Lines]",
          "3015:  uint8_t more;",
          "",
          "[Added Lines]",
          "3039:  uint8_t    crtype;",
          "3040:  uint8_t more;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3021:  if (sa->sa_policy->pol_auth.auth_method == IKEV2_AUTH_SHARED_KEY_MIC)",
          "3022:   return (0);",
          "3032:   else",
          "3043:  }",
          "3045:  return (0);",
          "",
          "[Removed Lines]",
          "3024:  while ((cr = SLIST_FIRST(&msg->msg_certreqs))) {",
          "3025:   if (sa->sa_hdr.sh_initiator)",
          "3026:    sa->sa_stateinit |= IKED_REQ_CERT;",
          "3027:   else",
          "3028:    sa->sa_statevalid |= IKED_REQ_CERT;",
          "3030:   if (SLIST_NEXT(cr, cr_entry) != NULL)",
          "3031:    more = 1;",
          "3033:    more = 0;",
          "3035:   ca_setreq(env, sa, &sa->sa_policy->pol_localid, cr->cr_type,",
          "3036:       more, ibuf_data(cr->cr_data),",
          "3037:       ibuf_length(cr->cr_data),",
          "3038:       PROC_CERT);",
          "3040:   ibuf_release(cr->cr_data);",
          "3041:   SLIST_REMOVE_HEAD(&msg->msg_certreqs, cr_entry);",
          "3042:   free(cr);",
          "",
          "[Added Lines]",
          "3049:  if (sa->sa_hdr.sh_initiator)",
          "3050:   sa->sa_stateinit |= IKED_REQ_CERT;",
          "3051:  else",
          "3052:   sa->sa_statevalid |= IKED_REQ_CERT;",
          "3060:  if (SLIST_EMPTY(&msg->msg_certreqs)) {",
          "3061:   if (sa->sa_policy->pol_certreqtype)",
          "3062:    crtype = sa->sa_policy->pol_certreqtype;",
          "3064:    crtype = env->sc_certreqtype;",
          "3065:   ca_setreq(env, sa, &sa->sa_policy->pol_localid,",
          "3066:       crtype, 0, ibuf_data(env->sc_certreq),",
          "3067:       ibuf_size(env->sc_certreq), PROC_CERT);",
          "3068:  } else {",
          "3069:   while ((cr = SLIST_FIRST(&msg->msg_certreqs))) {",
          "3071:    if (SLIST_NEXT(cr, cr_entry) != NULL)",
          "3072:     more = 1;",
          "3073:    else",
          "3074:     more = 0;",
          "3076:    ca_setreq(env, sa, &sa->sa_policy->pol_localid,",
          "3077:        cr->cr_type, more, ibuf_data(cr->cr_data),",
          "3078:        ibuf_length(cr->cr_data),",
          "3079:        PROC_CERT);",
          "3081:    ibuf_release(cr->cr_data);",
          "3082:    SLIST_REMOVE_HEAD(&msg->msg_certreqs, cr_entry);",
          "3083:    free(cr);",
          "3084:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
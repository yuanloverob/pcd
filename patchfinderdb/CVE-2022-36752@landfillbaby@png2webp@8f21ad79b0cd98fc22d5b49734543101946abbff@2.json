{
  "cve_id": "CVE-2022-36752",
  "cve_desc": "png2webp v1.0.4 was discovered to contain an out-of-bounds write via the function w2p. This vulnerability is exploitable via a crafted png file.",
  "repo": "landfillbaby/png2webp",
  "patch_hash": "8f21ad79b0cd98fc22d5b49734543101946abbff",
  "patch_info": {
    "commit_hash": "8f21ad79b0cd98fc22d5b49734543101946abbff",
    "repo": "landfillbaby/png2webp",
    "commit_url": "https://github.com/landfillbaby/png2webp/commit/8f21ad79b0cd98fc22d5b49734543101946abbff",
    "files": [
      "png2webp.c"
    ],
    "message": "v1.0.5: fix buffer overrun when reading bad WebPs",
    "before_after_code_files": [
      "png2webp.c||png2webp.c"
    ]
  },
  "patch_diff": {
    "png2webp.c||png2webp.c": [
      "File: png2webp.c -> png2webp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: #include <errno.h>",
      "5: #include <inttypes.h>",
      "6: #include <limits.h>",
      "",
      "[Removed Lines]",
      "3: #define VERSION \"v1.0.4\"",
      "",
      "[Added Lines]",
      "3: #define VERSION \"v1.0.5\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "319:   }",
      "320:   size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;",
      "322:   x = malloc(l);",
      "323:   if(!x) {",
      "324:     PF(\"ERROR reading %s: %s\", IP, *k);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "322:   if(l <= 12",
      "323: #ifdef SSIZE_MAX",
      "324:     || l - 12 > SSIZE_MAX",
      "325: #endif",
      "326:   ) {",
      "327:     PF(\"ERROR reading %s: %s\", IP, k[2]);",
      "328:     goto w2p_close;",
      "329:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "088b2415b2a639f4b19a846b8567764e4ef0c8af",
      "candidate_info": {
        "commit_hash": "088b2415b2a639f4b19a846b8567764e4ef0c8af",
        "repo": "landfillbaby/png2webp",
        "commit_url": "https://github.com/landfillbaby/png2webp/commit/088b2415b2a639f4b19a846b8567764e4ef0c8af",
        "files": [
          "png2webp.c"
        ],
        "message": "v1.1.1: fix output on -t without -v, PNG_NORETURN",
        "before_after_code_files": [
          "png2webp.c||png2webp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "png2webp.c||png2webp.c"
          ],
          "candidate": [
            "png2webp.c||png2webp.c"
          ]
        }
      },
      "candidate_diff": {
        "png2webp.c||png2webp.c": [
          "File: png2webp.c -> png2webp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <errno.h>",
          "5: #include <inttypes.h>",
          "6: #include <limits.h>",
          "",
          "[Removed Lines]",
          "3: #define VERSION \"v1.1.0\"",
          "",
          "[Added Lines]",
          "3: #define VERSION \"v1.1.1\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:   (void)p;",
          "131: #endif",
          "132: }",
          "134:   P(\"ERROR reading: %s\", s);",
          "135:   png_longjmp(p, 1);",
          "136: }",
          "138:   P(\"ERROR writing: %s\", s);",
          "139:   png_longjmp(p, 1);",
          "140: }",
          "",
          "[Removed Lines]",
          "133: static void pngrerr(png_struct *p, const char *s) {",
          "137: static void pngwerr(png_struct *p, const char *s) {",
          "",
          "[Added Lines]",
          "133: static PNG_NORETURN void pngrerr(png_struct *p, const char *s) {",
          "137: static PNG_NORETURN void pngwerr(png_struct *p, const char *s) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "274:     .stats = verbose ? &s : 0, .progress_hook = doprogress ? progress : 0};",
          "275:   trns = (trns || (colortype & PNG_COLOR_MASK_ALPHA)) &&",
          "276:     WebPPictureHasTransparency(&o);",
          "280:     fclose(fp);",
          "281:   p2w_rm:",
          "282:     if(op) remove(op);",
          "283:     goto p2w_free;",
          "284:   }",
          "285:   if(fclose(fp)) {",
          "287:     goto p2w_rm;",
          "288:   }",
          "289:   free(b);",
          "290: #define F s.lossless_features",
          "291: #define C s.palette_size",
          "294: Header size: %u, image data size: %u\\nUses alpha: %s\\n\\",
          "295: Precision bits: histogram=%u transform=%u cache=%u\\n\\",
          "296: Lossless features:%s%s%s%s\\nColors: %s%u\",",
          "304:   return 0;",
          "305: }",
          "306: static bool w2p(char *ip, char *op) {",
          "",
          "[Removed Lines]",
          "277:   if(!WebPEncode(&c, &o)) {",
          "278: #define PN(x, ...) P(doprogress ? \"\\n\" x \"\\n\" : x, __VA_ARGS__)",
          "279:     PN(\"ERROR writing: %s\", k[o.error_code - 1]);",
          "286:     PN(\"ERROR writing: %s\", strerror(errno));",
          "292:   if(verbose)",
          "293:     PN(\"Output info:\\nSize: %u bytes (%.15g bpp)\\n\\",
          "297:       s.lossless_size,",
          "298:       (unsigned)s.lossless_size * 8. / (uint32_t)(o.width * o.height),",
          "299:       s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",",
          "300:       s.histogram_bits, s.transform_bits, s.cache_bits,",
          "301:       F ? F & 1 ? \" prediction\" : \"\" : \" none\",",
          "302:       F && F & 2 ? \" cross-color\" : \"\", F && F & 4 ? \" subtract-green\" : \"\",",
          "303:       F && F & 8 ? \" palette\" : \"\", C ? \"\" : \">\", C ? C : 256);",
          "",
          "[Added Lines]",
          "277:   int r = WebPEncode(&c, &o);",
          "278:   if(doprogress) putc('\\n', stderr);",
          "279:   if(!r) {",
          "280:     P(\"ERROR writing: %s\", k[o.error_code - 1]);",
          "287:     P(\"ERROR writing: %s\", strerror(errno));",
          "293:   PV(\"Output info:\\nSize: %u bytes (%.15g bpp)\\n\\",
          "297:     s.lossless_size,",
          "298:     (unsigned)s.lossless_size * 8. / (uint32_t)(o.width * o.height),",
          "299:     s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",",
          "300:     s.histogram_bits, s.transform_bits, s.cache_bits,",
          "301:     F ? F & 1 ? \" prediction\" : \"\" : \" none\", F && F & 2 ? \" cross-color\" : \"\",",
          "302:     F && F & 4 ? \" subtract-green\" : \"\", F && F & 8 ? \" palette\" : \"\",",
          "303:     C ? \"\" : \">\", C ? C : 256);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d26351f53860e62ab2ebd02bcbe34f66a2eafcb3",
      "candidate_info": {
        "commit_hash": "d26351f53860e62ab2ebd02bcbe34f66a2eafcb3",
        "repo": "landfillbaby/png2webp",
        "commit_url": "https://github.com/landfillbaby/png2webp/commit/d26351f53860e62ab2ebd02bcbe34f66a2eafcb3",
        "files": [
          "Makefile",
          "README.md",
          "configure",
          "png2webp.c",
          "png2webp.sh",
          "webptopng.sh"
        ],
        "message": "v1.1.7: better configure",
        "before_after_code_files": [
          "png2webp.c||png2webp.c",
          "png2webp.sh||png2webp.sh",
          "webptopng.sh||webptopng.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "png2webp.c||png2webp.c"
          ],
          "candidate": [
            "png2webp.c||png2webp.c"
          ]
        }
      },
      "candidate_diff": {
        "png2webp.c||png2webp.c": [
          "File: png2webp.c -> png2webp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #define _FILE_OFFSET_BITS 64",
          "5: #include <inttypes.h>",
          "6: #include <limits.h>",
          "",
          "[Removed Lines]",
          "3: #define VERSION \"v1.1.6\"",
          "",
          "[Added Lines]",
          "3: #ifdef P2WCONF",
          "4: #include \"p2wconf.h\"",
          "5: #endif",
          "6: #ifndef VERSION",
          "7: #define VERSION \"v1.1.7\"",
          "8: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22: #else",
          "23: #include <unistd.h>",
          "24: #endif",
          "28: #if !defined NOFOPENX && __STDC_VERSION__ < 201112L",
          "29: #define NOFOPENX",
          "30: #endif",
          "",
          "[Removed Lines]",
          "25: #ifdef P2WCONF",
          "26: #include \"p2wconf.h\"",
          "27: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "png2webp.sh||png2webp.sh": [
          "File: png2webp.sh -> png2webp.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: ret=$?",
          "4: if [ $ret -ne 0 ]",
          "5: then",
          "8: fi",
          "9: exit $ret",
          "",
          "[Removed Lines]",
          "6:   echo -n 'Press enter to continue'",
          "7:   read -r duh",
          "",
          "[Added Lines]",
          "6:  echo Press enter to continue",
          "7:  read -r x",
          "",
          "---------------"
        ],
        "webptopng.sh||webptopng.sh": [
          "File: webptopng.sh -> webptopng.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: ret=$?",
          "4: if [ $ret -ne 0 ]",
          "5: then",
          "8: fi",
          "9: exit $ret",
          "",
          "[Removed Lines]",
          "6:   echo -n 'Press enter to continue'",
          "7:   read -r duh",
          "",
          "[Added Lines]",
          "6:  echo Press enter to continue",
          "7:  read -r x",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6ca7950f71cd7edd336e2e65f25084d8695a0d62",
      "candidate_info": {
        "commit_hash": "6ca7950f71cd7edd336e2e65f25084d8695a0d62",
        "repo": "landfillbaby/png2webp",
        "commit_url": "https://github.com/landfillbaby/png2webp/commit/6ca7950f71cd7edd336e2e65f25084d8695a0d62",
        "files": [
          ".gitignore",
          "Makefile",
          "Makefile.static",
          "README.md",
          "TODO.txt",
          "compile_msvc.bat",
          "configure",
          "png2webp.bat",
          "png2webp.c",
          "png2webp.sh",
          "webp2png.sh",
          "webptopng.bat",
          "webptopng.sh"
        ],
        "message": "v1.0: major rewrite\n\nthe cli changed again. no guesswork just default to batch mode\nnow deletes output files on error\ndrop netpbm support\nwindows release builds are now through msys2 clang64",
        "before_after_code_files": [
          "Makefile.static||Makefile.static",
          "compile_msvc.bat||compile_msvc.bat",
          "png2webp.bat||png2webp.bat",
          "png2webp.c||png2webp.c",
          "png2webp.sh||png2webp.sh",
          "webp2png.sh||webp2png.sh",
          "webp2png.bat||webptopng.bat",
          "webptopng.sh||webptopng.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "png2webp.c||png2webp.c"
          ],
          "candidate": [
            "png2webp.c||png2webp.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.static||Makefile.static": [
          "File: Makefile.static -> Makefile.static",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "compile_msvc.bat||compile_msvc.bat": [
          "File: compile_msvc.bat -> compile_msvc.bat",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "png2webp.bat||png2webp.bat": [
          "File: png2webp.bat -> png2webp.bat",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: @ECHO OFF",
          "3: IF %ERRORLEVEL% NEQ 0 PAUSE",
          "4: EXIT /B %ERRORLEVEL%",
          "",
          "[Removed Lines]",
          "2: \"%~dpn0.exe\" -bv -- %*",
          "",
          "[Added Lines]",
          "2: \"%~dpn0.exe\" -v -- %*",
          "",
          "---------------"
        ],
        "png2webp.c||png2webp.c": [
          "File: png2webp.c -> png2webp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: #include <errno.h>",
          "52: #include <stdbool.h>",
          "53: #include <stdio.h>",
          "54: #include <stdlib.h>",
          "55: #include <string.h>",
          "56: #ifdef _WIN32",
          "57: #include <fcntl.h>",
          "58: #include <io.h>",
          "60: #else",
          "61: #include <unistd.h>",
          "62: #define setmode(x, y) 0",
          "89: #endif",
          "108:   return -1;",
          "127: }",
          "149: #else",
          "162: #endif",
          "163: #endif",
          "166: #endif",
          "174: #endif",
          "185: #endif",
          "187:     }",
          "193: #endif",
          "226: #else",
          "232: #endif",
          "241: #ifdef LOSSYISERROR",
          "245: #else",
          "250: #endif",
          "257: #ifdef LOSSYISERROR",
          "259: #endif",
          "279: #else",
          "282: #else",
          "297: #endif",
          "298: #endif",
          "322:     }",
          "327: #else",
          "330: #endif",
          "345:       }",
          "352: #endif",
          "357: #else",
          "359: #endif",
          "364: #endif",
          "365:     }",
          "372: #else",
          "382: #endif",
          "405: #endif",
          "438:     }",
          "",
          "[Removed Lines]",
          "4: #define VERSION \"v0.9\"",
          "5: #ifdef FROMWEBP",
          "7: Ideally should palette if <=256 colors (in order of appearance),",
          "8: or at least try to palette when input WebP was,",
          "9: but that's not part of either libpng encoding or libwebp decoding.",
          "10: Maybe do this:",
          "11: #include <webp/encode.h> // for WebPPicture",
          "12: WEBP_EXTERN int WebPGetColorPalette( // declared in libwebp utils/utils.h",
          "14: #include <webp/decode.h>",
          "15: #define INEXT \"webp\"",
          "16: #define INEXTCHK INEXT",
          "17: #ifdef PAM",
          "18: #define OUTEXT \"pam\"",
          "19: #else",
          "20: #include <png.h>",
          "21: #define OUTEXT \"png\"",
          "22: #endif",
          "23: #define OUTEXTCHK \".\" OUTEXT",
          "24: #define EXTRALETTERS",
          "25: #define EXTRAHELP",
          "26: #else // FROMWEBP",
          "27: #include <webp/encode.h>",
          "28: #ifdef PAM",
          "29: #include <pam.h>",
          "30: #define INEXT \"pam\"",
          "31: #define X(x) ((argv[0][len - 2] | 32) == x)",
          "32: #define ISINEXT \\",
          "33:  if(len > 3) { \\",
          "34:   uint32_t ext, extmask, extmatch; \\",
          "35:   memcpy(&ext, *argv + len - 4, 4); \\",
          "36:   memcpy(&extmask, (char[4]){\"\\0 \\xff \"}, 4); \\",
          "37:   memcpy(&extmatch, (char[4]){\".p\\xffm\"}, 4); \\",
          "38:   if((ext | extmask) == extmatch && (X('b') || X('g') || \\",
          "39:    X('p') || X('n') || X('a'))) len -= 4; \\",
          "40:  }",
          "41: #else",
          "42: #include <png.h>",
          "43: #define INEXT \"png\"",
          "44: #define INEXTCHK \".png\"",
          "45: #endif",
          "46: #define OUTEXT \"webp\"",
          "47: #define OUTEXTCHK \"webp\"",
          "48: #define EXTRALETTERS \"e\"",
          "49: #define EXTRAHELP \"-e: Keep RGB data on pixels where alpha is 0.\\n\"",
          "50: #endif // FROMWEBP",
          "59: #define O(x) _##x",
          "63: #define O(x) x",
          "64: #endif",
          "65: #ifndef ISINEXT",
          "66: #define ISINEXT \\",
          "67:  if(len >= sizeof INEXT) { \\",
          "68:   uint32_t ext, extmask, extmatch; \\",
          "69:   memcpy(&ext, *argv + len - 4, 4); \\",
          "70:   memcpy(&extmask, (char[4]){(sizeof INEXT > 4) * 32, 32, 32, \\",
          "71:    32}, 4); \\",
          "72:   memcpy(&extmatch, (char[4]){INEXTCHK}, 4); \\",
          "73:   if((sizeof INEXT < 5 || argv[0][len - 5] == '.') && \\",
          "74:    (ext | extmask) == extmatch) len -= sizeof INEXT; \\",
          "75:  }",
          "76: #endif",
          "77: #define P(x) fputs(x \"\\n\", stderr)",
          "78: #define PF(x, ...) fprintf(stderr, x \"\\n\", __VA_ARGS__)",
          "80: #define PFV(...) if(verbose) PF(__VA_ARGS__)",
          "81: #define E(f, ...) \\",
          "82:  if(!(f)) { \\",
          "83:   PF(\"ERROR \" __VA_ARGS__); \\",
          "84:   return 1; \\",
          "85:  }",
          "86: #if __STDC_VERSION__ < 201112L || defined NOFOPENX",
          "87: #include <fcntl.h>",
          "88: #include <sys/stat.h>",
          "90: #define HELP \\",
          "91:   P(INEXT \"2\" OUTEXT \" \" VERSION \"\\n\\nUsage:\\n\" INEXT \"2\" OUTEXT \\",
          "92:     \" [-b\" EXTRALETTERS \"fv-] infile.\" INEXT \" ...\\n\" INEXT \"2\" OUTEXT \\",
          "93:     \" [-p\" EXTRALETTERS \"fv-] [{infile.\" INEXT \"|-} [outfile.\" OUTEXT \\",
          "94:     \"|-]]\\n\\n-b: Work with many input files (Batch mode).\\n\" \\",
          "95:     \"    Constructs output filenames by removing the .\" INEXT \\",
          "96:     \" extension if possible,\\n    and appending \\\".\" OUTEXT \"\\\".\\n\" \\",
          "97:     \"-p: Work with a single file, allowing Piping from stdin or to stdout,\\n\" \\",
          "98:     \"    or using a different output filename to the input.\\n    infile.\" \\",
          "99:     INEXT \" and outfile.\" OUTEXT \\",
          "100:     \" default to stdin and stdout respectively,\\n\" \\",
          "101:     \"    or explicitly as \\\"-\\\".\\n\" \\",
          "102:     \"    Will show this message if stdin/stdout is used and is a terminal.\\n\" \\",
          "103:     EXTRAHELP \\",
          "104:     \"-f: Force overwrite of output files (has no effect on stdout).\\n\" \\",
          "105:     \"-v: Be verbose.\\n--: Explicitly stop parsing options.\\n\\n\" \\",
          "106:     \"Without -b or -p, and with 1 or 2 filenames, there is some ambiguity.\\n\" \\",
          "107:     \"In this case it will tell you what its guess is.\"); \\",
          "109: #define OPENR(x) \\",
          "110:  PFV(\"%scoding %s ...\", \"De\", x ? \"stdin\" : *argv); \\",
          "111:  if(x) fp = stdin; \\",
          "112:  else E(fp = fopen(*argv, \"rb\"), \"opening \\\"%s\\\" for %s: %s\", *argv, \\",
          "113:   \"reading\", strerror(errno))",
          "114: #define PIPEARG(x) (*argv[x] == '-' && !argv[x][1])",
          "115: #define PIPECHK(x, y) \\",
          "116:   if(use##y) { \\",
          "117:  if(!(x && skipstdoutchk) && O(isatty)(x)) { HELP } \\",
          "118:  E(O(setmode)(x, _O_BINARY) != -1, \"setting %s to binary mode\", #y) \\",
          "119:   }",
          "120: #define URGC (unsigned)argc",
          "121: #define EC(x) E(!fclose(fp), \"closing %s: %s\", x, strerror(errno))",
          "122: #ifndef FROMWEBP",
          "123: static FILE* fp;",
          "124: static int w(const uint8_t* d, size_t s, const WebPPicture* x) {",
          "125:  (void)x;",
          "126:  return s ? (int)fwrite(d, s, 1, fp) : 1;",
          "128: #endif",
          "129: int main(int argc, char** argv) {",
          "130: #ifdef FROMWEBP",
          "131:   FILE* fp;",
          "132: #else // FROMWEBP",
          "133: #ifdef PAM",
          "134:   pm_init(\"ERROR\", 0); // TODO: maybe *argv or (INEXT \"2\" OUTEXT) ?",
          "135: #elif !defined USEADVANCEDPNG",
          "136:   uint32_t endian;",
          "137:   memcpy(&endian, (char[4]){\"\\xAA\\xBB\\xCC\\xDD\"}, 4);",
          "138:   E(endian == 0xAABBCCDD || endian == 0xDDCCBBAA,",
          "139:  \"32-bit mixed-endianness (%X) not supported\", endian)",
          "140: #endif",
          "141:   bool exact = 0;",
          "142: #endif // FROMWEBP",
          "143:   bool usepipe = 0, usestdin = 0, usestdout = 0, force = 0, verbose = 0,",
          "144:  chosen = 0, skipstdoutchk = 0;",
          "145:   char* outname = 0;",
          "146: #ifdef USEGETOPT",
          "147:   int c;",
          "148:   while((c = getopt(argc, argv, \":bp\" EXTRALETTERS \"fv\")) != -1) switch(c)",
          "150:   while(--argc && **++argv == '-' && argv[0][1])",
          "151:     while(*++*argv) switch(**argv)",
          "152: #endif",
          "153:     {",
          "154: #ifdef __has_c_attribute",
          "155: #if __has_c_attribute(fallthrough)",
          "156: #define FALLTHRU [[fallthrough]]",
          "157: #endif",
          "158: #endif",
          "159: #if !defined FALLTHRU && defined __has_attribute",
          "160: #if __has_attribute(fallthrough)",
          "161: #define FALLTHRU __attribute__((fallthrough))",
          "164: #ifndef FALLTHRU",
          "165: #define FALLTHRU 0",
          "167:       case 'p': usepipe = 1; FALLTHRU;",
          "168:       case 'b':",
          "169:  if(chosen) { HELP }",
          "170:  chosen = 1;",
          "171:  break;",
          "172: #ifndef FROMWEBP",
          "173:  case 'e': exact = 1; break;",
          "175:  case 'f': force = 1; break;",
          "176:  case 'v': verbose = 1; break;",
          "177: #ifndef USEGETOPT",
          "178:  case '-':",
          "179:    if(!argv[0][1]) {",
          "180:   argc--;",
          "181:   argv++;",
          "182:   goto endflagloop;",
          "183:    }",
          "184:    FALLTHRU;",
          "186:  default: HELP",
          "188: #ifdef USEGETOPT",
          "189:   argc -= optind;",
          "190:   argv += optind;",
          "191: #else",
          "192: endflagloop:",
          "194:   if(chosen && (usepipe ? URGC > 2 : !argc)) { HELP }",
          "195:   if(usepipe) {",
          "196:  usestdin = !argc || PIPEARG(0);",
          "197:  usestdout = URGC < 2 || PIPEARG(1);",
          "198:   } else if(!chosen && URGC < 3) {",
          "199:     usestdin = !argc || PIPEARG(0);",
          "200:     usestdout = argc == 2 ? PIPEARG(1) : usestdin;",
          "201:     if(!(usepipe = usestdin || usestdout)) {",
          "202:       PF(\"Warning: %u file%s given and neither -b or -p specified.\", URGC,",
          "203:  argc == 1 ? \"\" : \"s\");",
          "204:       if(argc == 1) {",
          "205:  if(!O(isatty)(1)) usepipe = usestdout = skipstdoutchk = 1;",
          "206:       } else {",
          "207:  size_t len = strlen(argv[1]);",
          "208:  if(len >= sizeof OUTEXT) {",
          "209:    uint32_t ext, extmask, extmatch;",
          "210:    memcpy(&ext, argv[1] + len - 4, 4);",
          "211:    memcpy(&extmask, (char[4]){(sizeof OUTEXT > 4) * 32, 32, 32, 32}, 4);",
          "212:    memcpy(&extmatch, (char[4]){OUTEXTCHK}, 4);",
          "213:    usepipe = (sizeof OUTEXT < 5 || argv[1][len - 5] == '.') &&",
          "214:   (ext | extmask) == extmatch;",
          "215:       } }",
          "216:       PF(\"Guessed -%c.\", usepipe ? 'p' : 'b');",
          "217:   } }",
          "218:   PIPECHK(0, stdin)",
          "219:   PIPECHK(1, stdout)",
          "220:   OPENR(usestdin)",
          "221:   for(;;) {",
          "222: #ifdef FROMWEBP",
          "223:     WebPDecoderConfig c = { // TODO: memset? WebPInitDecoderConfig?",
          "224: #ifdef NOTHREADS",
          "225:  0",
          "227:  .options.use_threads = 1",
          "228: #endif",
          "229:     };",
          "230: #ifndef IDEC_BUFSIZE",
          "231: #define IDEC_BUFSIZE 65536",
          "233:     uint8_t i[IDEC_BUFSIZE];",
          "234:     size_t l = fread(i, 1, IDEC_BUFSIZE, fp);",
          "235:     char* k[] = {\"out of RAM\", \"invalid params\", \"bitstream broke\",",
          "236:  \"unsupported feature\", \"suspended\", \"cancelled\", \"not enough data\"};",
          "237: #define F c.input",
          "238: #define A F.has_alpha",
          "239:     VP8StatusCode r = WebPGetFeatures(i, l, &F);",
          "240:     E(!r, \"reading WebP header: %u (%s)\", r, r < 8 ? k[r - 1] : \"???\")",
          "242: #define FORMATSTR",
          "243: #define GETFORMAT",
          "244: #define ANIMARGS \"%sion)\", k[3], \"animat\"",
          "246:     char* formats[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};",
          "247: #define FORMATSTR \"\\nFormat: %s (%d)\"",
          "248: #define GETFORMAT , (unsigned)V < 3 ? formats[V] : \"???\", V",
          "249: #define ANIMARGS \"animation)\", k[3]",
          "251: #define V F.format",
          "252: #define W (unsigned)F.width",
          "253: #define H (unsigned)F.height",
          "254:     PFV(\"Input WebP info:\\nDimensions: %u x %u\\nUses alpha: %s\" FORMATSTR,",
          "255:  W, H, A ? \"yes\" : \"no\" GETFORMAT);",
          "256:     E(!F.has_animation, \"reading WebP header: 4 (%s: \" ANIMARGS)",
          "258:     E(V == 2, \"reading WebP header: 4 (%s: %sion)\", k[3], \"lossy compress\")",
          "260:     if(A) c.output.colorspace = MODE_RGBA;",
          "261:     WebPIDecoder* d = WebPIDecode(i, l, &c);",
          "262:     E(d, \"initializing WebP decoder: 1 (%s)\", *k)",
          "263:     for(size_t x = l; (r = WebPIAppend(d, i, x)); l += x) {",
          "264:  E(r == 5 && !feof(fp), \"reading WebP data: %d (%s)\", r == 5 ? 7 : r,",
          "265:   r == 5 ? k[6] : r < 8 ? k[r - 1] : \"???\")",
          "266:  x = fread(i, 1, IDEC_BUFSIZE, fp);",
          "267:     }",
          "268:     WebPIDelete(d);",
          "269:     PFV(\"Size: %zu bytes (%.15g bpp)\", l, (double)l * 8 / (uint32_t)(W * H));",
          "270: #else // FROMWEBP",
          "271: #ifdef PAM",
          "272:     struct pam i;",
          "273:     pnm_readpaminit(fp, &i, PAM_STRUCT_SIZE(tuple_type));",
          "274:     E(i.depth < 5, \"too many channels: %u (max. 4)\", i.depth)",
          "275:     E((unsigned)i.width < 16384 && (unsigned)i.height < 16384,",
          "276:  \"image too big (%ux%u, max. 16383x16383 px)\", i.width, i.height)",
          "277:     if(255 % i.maxval) PF(\"Warning: scaling from maxval %lu to 255\", i.maxval);",
          "278:     tuple* r = pnm_allocpamrow(&i);",
          "280: #ifdef USEADVANCEDPNG",
          "281: #error // TODO",
          "283:     png_image i = {.version = PNG_IMAGE_VERSION}; // TODO: memset?",
          "284: #define EP(f, s, d) \\",
          "285:  E(f, \"reading PNG %s: %s\", s, i.message) \\",
          "286:  if(i.warning_or_error) { \\",
          "287:   PF(\"PNG %s warning: %s\", s, i.message); \\",
          "288:   if(d) i.warning_or_error = 0; \\",
          "289:  }",
          "290:     EP(png_image_begin_read_from_stdio(&i, fp), \"info\", 1)",
          "291:     E(i.width < 16384 && i.height < 16384,",
          "292:  \"image too big (%ux%u, max. 16383x16383 px)\", i.width, i.height)",
          "293:     if(i.format & PNG_FORMAT_FLAG_LINEAR)",
          "294:  P(\"Warning: input PNG is 16bpc, will be downsampled to 8bpc\");",
          "295:     bool A = !!(i.format & PNG_FORMAT_FLAG_ALPHA);",
          "296:     i.format = (*(uint8_t*)&(uint16_t){1}) ? PNG_FORMAT_BGRA : PNG_FORMAT_ARGB;",
          "299: #define W ((uint16_t)i.width)",
          "300: #define H ((uint16_t)i.height)",
          "301:     WebPPicture o = {1, .width = W, H, .writer = w};",
          "303:     WebPAuxStats s;",
          "304:     if(verbose) o.stats = &s;",
          "306:     char* es[VP8_ENC_ERROR_LAST - 1] = {\"out of RAM\",",
          "307:  \"out of RAM flushing bitstream\", \"something was null\", \"broken config\",",
          "309:  \"partition >16MiB\", \"couldn't write\", \"output >4GiB\", \"cancelled\"};",
          "310:     E(WebPPictureAlloc(&o), \"%sing WebP: %s (%u)\", \"allocat\",",
          "311:  es[o.error_code - 1], o.error_code)",
          "312: #ifdef PAM",
          "313:     for(unsigned y = 0; y < H; y++) {",
          "314:  pnm_readpamrow(&i, r);",
          "315:  pnm_scaletuplerow(&i, r, r, 255);",
          "316: #define A (~i.depth & 1)",
          "317: #define D (i.depth > 2)",
          "318:  for(unsigned x = 0; x < W; x++) o.argb[y * W + x] = (uint32_t)(",
          "319:   (((A ? r[x][i.depth - 1] : 255) & 255) << 24) |",
          "320:   ((*r[x] & 255) << 16) | ((r[x][D] & 255) << 8) |",
          "321:   (r[x][D * 2] & 255));",
          "323:     pnm_freepamrow(r);",
          "324: #else",
          "325: #ifdef USEADVANCEDPNG",
          "326: #error // TODO",
          "328:     EP(png_image_finish_read(&i, 0, o.argb, 0, 0), \"data\", 0)",
          "329: #endif",
          "331: #endif // FROMWEBP",
          "332:     EC(usestdin ? \"stdin\" : *argv)",
          "333:     if(usestdout) {",
          "334:  PFV(\"%scoding %s ...\", \"En\", \"stdout\");",
          "335:  fp = stdout;",
          "336:     } else {",
          "337:       if(usepipe) outname = argv[1];",
          "338:       else {",
          "339:  size_t len = strlen(*argv);",
          "340:  ISINEXT",
          "341:  outname = malloc(len + sizeof \".\" OUTEXT);",
          "342:  E(outname, \"adding .\" OUTEXT \" extension to %s: out of RAM\", *argv)",
          "343:  memcpy(outname, *argv, len);",
          "344:  memcpy(outname + len, \".\" OUTEXT, sizeof \".\" OUTEXT);",
          "346:       PFV(\"%scoding %s ...\", \"En\", outname);",
          "347: #define EO(x) E(x, \"opening \\\"%s\\\" for %s: %s\", outname, \\",
          "348:  force ? \"writing\" : \"creation\", strerror(errno))",
          "349: #if __STDC_VERSION__ < 201112L || defined NOFOPENX",
          "350: #ifndef O_BINARY",
          "351: #define O_BINARY 0",
          "353:       int fd = O(open)(outname, O(O_WRONLY) | O(O_CREAT) | O(O_BINARY) |",
          "354:  O(O_TRUNC) | (!force * O(O_EXCL)),",
          "355: #ifdef _WIN32",
          "356:  _S_IREAD | _S_IWRITE",
          "358:  0666",
          "360:  );",
          "361:       EO(fd != -1 && (fp = O(fdopen)(fd, \"wb\")))",
          "362: #else",
          "363:       EO(fp = fopen(outname, force ? \"wb\" : \"wbx\"))",
          "366: #ifdef FROMWEBP",
          "367: #define D c.output.u.RGBA",
          "368: #ifdef PAM",
          "369:     fprintf(fp, \"P7\\nWIDTH %u\\nHEIGHT %u\\nDEPTH %c\\nMAXVAL 255\\n\"",
          "370:  \"TUPLTYPE RGB%s\\nENDHDR\\n\", W, H, A ? '4' : '3', A ? \"_ALPHA\" : \"\");",
          "371:     fwrite(D.rgba, D.size, 1, fp);",
          "374:     png_structp png_ptr =",
          "375:  png_create_write_struct(PNG_LIBPNG_VER_STRING, 0, 0, 0);",
          "376:     E(png_ptr, \"writing PNG: %s\", *k)",
          "377:     png_infop info_ptr = png_create_info_struct(png_ptr);",
          "378:     E(info_ptr, \"writing PNG: %s\", *k)",
          "379: #ifdef PNG_SETJMP_SUPPORTED",
          "381:     if(setjmp(png_jmpbuf(png_ptr))) return 1;",
          "383:     png_init_io(png_ptr, fp);",
          "384:     png_set_filter(png_ptr, 0, PNG_ALL_FILTERS);",
          "385:     png_set_compression_level(png_ptr, 9);",
          "387:     png_set_IHDR(png_ptr, info_ptr, W, H, 8,",
          "388:  A ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,",
          "389:  PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);",
          "390:     png_write_info(png_ptr, info_ptr);",
          "391:     png_bytep px = D.rgba;",
          "392:     for(unsigned y = 0; y < H; y++) {",
          "393:  png_write_row(png_ptr, px);",
          "394:  px += D.stride;",
          "395:     }",
          "396:     png_write_end(png_ptr, info_ptr);",
          "397:     png_destroy_write_struct(&png_ptr, &info_ptr);",
          "398: #endif",
          "399:     WebPFreeDecBuffer(&c.output);",
          "400: #else // FROMWEBP",
          "401: #ifdef NOTHREADS",
          "402: #define THREADLEVEL",
          "403: #else",
          "404: #define THREADLEVEL .thread_level = 1,",
          "406:     E(WebPEncode(",
          "407:  &(WebPConfig){ // TODO: memset? WebpConfigInit?",
          "408:   1, 100, 6, // lossless, max",
          "409:   WEBP_HINT_GRAPH, /* see VP8LEncodeImage source",
          "411:   THREADLEVEL // doesn't seem to affect output",
          "412:   .near_lossless = 100, // don't modify visible pixels",
          "413:   .exact = exact, // see EXTRAHELP",
          "414:   .pass = 1, .segments = 1 // unused, for WebPValidateConfig",
          "415:  }, &o),",
          "416:  \"%sing WebP: %s (%u)\", \"encod\", es[o.error_code - 1], o.error_code)",
          "417: #define F s.lossless_features",
          "418: #define C s.palette_size",
          "419:     PFV(\"Output WebP info:\\nDimensions: %u x %u\\nSize: %u bytes (%.15g bpp)\\n\"",
          "420:  \"Header size: %u, image data size: %u\\nUses alpha: %s\\n\"",
          "421:  \"Precision bits: histogram=%u transform=%u cache=%u\\n\"",
          "422:  \"Lossless features:%s%s%s%s\\nColors: %s%u\",",
          "423:  o.width, o.height, s.coded_size,",
          "424:  (unsigned)s.coded_size * 8. / (uint32_t)(o.width * o.height),",
          "425:  s.lossless_hdr_size, s.lossless_data_size,",
          "426:  A && WebPPictureHasTransparency(&o) ? \"yes\" : \"no\",",
          "427:  s.histogram_bits, s.transform_bits, s.cache_bits,",
          "428:  F ? F & 1 ? \" prediction\" : \"\" : \" none\",",
          "429:  F && F & 2 ? \" cross-color\" : \"\", F && F & 4 ? \" subtract-green\" : \"\",",
          "430:  F && F & 8 ? \" palette\" : \"\", C ? \"\" : \">\", C ? C : 256);",
          "431:     WebPPictureFree(&o);",
          "432: #endif // FROMWEBP",
          "433:     EC(usestdout ? \"stdout\" : outname)",
          "434:     if(usepipe || !--argc) return 0;",
          "435:     if(outname) {",
          "436:  free(outname);",
          "437:  outname = 0;",
          "439:     argv++;",
          "440:     OPENR(0)",
          "441: } }",
          "",
          "[Added Lines]",
          "3: #define VERSION \"v1.0\"",
          "4: #include <assert.h>",
          "6: #include <limits.h>",
          "7: #include <setjmp.h>",
          "9: #include <stdint.h>",
          "13: #if __STDC_VERSION__ < 201112L && !defined NOFOPENX",
          "14: #define NOFOPENX",
          "15: #endif",
          "16: #ifdef NOFOPENX",
          "17: #include <fcntl.h>",
          "18: #include <sys/stat.h>",
          "19: #ifndef O_BINARY",
          "20: #define O_BINARY 0",
          "21: #endif",
          "22: #endif",
          "24: #define _CRT_NONSTDC_NO_WARNINGS",
          "27: #define RB \"rb\"",
          "28: #define WB \"wb\"",
          "29: #define XB \"wbx\"",
          "33: #define RB \"r\"",
          "34: #define WB \"w\"",
          "35: #define XB \"wx\"",
          "37: #include \"png.h\"",
          "38: #include \"webp/decode.h\"",
          "39: #include \"webp/encode.h\"",
          "40: static int help(void) {",
          "41:   fputs(\"PNG2WebP \" VERSION \"\\n\\",
          "42: \\n\\",
          "43: Usage:\\n\\",
          "44: png2webp [-refv-] INFILE ...\\n\\",
          "45: png2webp -p[refv-] [{INFILE|-} [OUTFILE|-]]\\n\\",
          "46: \\n\\",
          "47: -p: Work with a single file, allowing Piping from stdin or to stdout,\\n\\",
          "48:     or using a different output filename to the input.\\n\\",
          "49:     `INFILE` and `OUTFILE` default to stdin and stdout respectively,\\n\\",
          "50:     or explicitly as \\\"-\\\".\\n\\",
          "51:     Will show this message if stdin/stdout is used and is a terminal.\\n\\",
          "52: -r: Convert from WebP to PNG instead.\\n\\",
          "53: -e: Keep RGB data on pixels where alpha is 0. Always enabled for `-r`.\\n\\",
          "54: -f: Force overwrite of output files (has no effect on stdout).\\n\\",
          "55: -v: Be verbose.\\n\\",
          "56: --: Explicitly stop parsing options.\\n\",",
          "57:     stderr);",
          "60: static bool exact = 0, force = 0, verbose = 0;",
          "61: #define PF(x, ...) fprintf(stderr, x \"\\n\", __VA_ARGS__)",
          "62: #define PFV(...) \\",
          "63:   if(verbose) PF(__VA_ARGS__)",
          "64: #define IP (ip ? ip : \"<stdin>\")",
          "65: #define OP (op ? op : \"<stdout>\")",
          "66: static FILE *openr(char *ip) {",
          "67:   PFV(\"Decoding %s ...\", IP);",
          "68:   if(!ip) return stdin; // TODO: char **ip; *ip = \"<stdin>\" ?",
          "69:   FILE *fp;",
          "70: #ifdef NOFOPENX",
          "71:   int fd = open(ip, O_RDONLY | O_BINARY);",
          "72:   if(fd == -1) {",
          "73:     PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));",
          "74:     return 0;",
          "75:   }",
          "76:   if(!(fp = fdopen(fd, RB))) {",
          "77:     PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));",
          "78:     close(fd);",
          "79:     return 0;",
          "80:   }",
          "82:   if(!(fp = fopen(ip, RB))) {",
          "83:     PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));",
          "84:     return 0;",
          "85:   }",
          "87:   return fp;",
          "88: }",
          "89: static FILE *openw(char *op) {",
          "90:   PFV(\"Encoding %s ...\", OP);",
          "91:   if(!op) return stdout; // TODO: char **op; *op = \"<stdout>\" ?",
          "92:   FILE *fp;",
          "93: #define EO(x) \\",
          "94:   if(!(x)) { \\",
          "95:     PF(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\", \\",
          "96:       strerror(errno)); \\",
          "97:     return 0; \\",
          "98:   }",
          "99: #ifdef NOFOPENX",
          "100:   int fd = open(op, O_WRONLY | O_CREAT | O_TRUNC | (!force * O_EXCL) | O_BINARY,",
          "101: #ifdef _WIN32",
          "102:     S_IREAD | S_IWRITE",
          "103: #else",
          "104:     S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH",
          "106:   );",
          "107:   EO(fd != -1) // TODO: gotos?",
          "108:   if(!(fp = fdopen(fd, WB))) {",
          "109:     PF(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\",",
          "110:       strerror(errno));",
          "111:     close(fd);",
          "112:     remove(op);",
          "113:     return 0;",
          "114:   }",
          "115: #else",
          "116:   EO(fp = fopen(op, force ? WB : XB))",
          "118:   return fp;",
          "119: }",
          "120: static size_t pnglen;",
          "121: static void pngread(png_struct *p, uint8_t *d, size_t s) {",
          "122:   if(!fread(d, s, 1, png_get_io_ptr(p))) png_error(p, \"I/O error\");",
          "123:   pnglen += s;",
          "124: }",
          "125: static void pngwrite(png_struct *p, uint8_t *d, size_t s) {",
          "126:   if(!fwrite(d, s, 1, png_get_io_ptr(p))) png_error(p, \"I/O error\");",
          "127:   pnglen += s;",
          "128: }",
          "130: static void pngflush(png_struct *p) { (void)p; }",
          "131: equivalent to the default but may generate smaller static code:",
          "132: static void pngflush(png_struct *p) { fflush(png_get_io_ptr(p)); }",
          "134: static int webpwrite(const uint8_t *d, size_t s, const WebPPicture *p) {",
          "135:   return (int)fwrite(d, s, 1, p->custom_ptr);",
          "136: }",
          "137: #define E(x, ...) \\",
          "138:   if(!(x)) { \\",
          "139:     PF(\"ERROR \" __VA_ARGS__); \\",
          "140:     return 1; \\",
          "141:   }",
          "142: static bool p2w(char *ip, char *op) {",
          "143:   FILE *fp = openr(ip);",
          "144:   if(!fp) return 1;",
          "145:   uint32_t *b = 0;",
          "146:   png_info *n = 0;",
          "147:   char *k[VP8_ENC_ERROR_LAST - 1 /* 3 */] = {\"Out of memory\",",
          "148:     \"???\", // oom flushing bitstream, unused in libwebp",
          "149:     \"???\", // null param",
          "150:     \"Broken config, file a bug report\",",
          "151:     \"???\", // image too big (already checked)",
          "152:     \"???\", \"???\", // lossy",
          "153:     \"I/O error\",",
          "154:     \"???\", // lossy",
          "155:     \"???\"}; // cancelled",
          "156:   png_struct *p = png_create_read_struct(PNG_LIBPNG_VER_STRING, 0, 0, 0);",
          "158:   if(!p) {",
          "159:     PF(\"ERROR reading %s: %s\", IP, *k);",
          "160:     goto p2w_close;",
          "161:   }",
          "162:   n = png_create_info_struct(p);",
          "163:   if(!n) {",
          "164:     PF(\"ERROR reading %s: %s\", IP, *k);",
          "165:     goto p2w_close;",
          "166:   }",
          "167:   if(setjmp(png_jmpbuf(p))) {",
          "168:   p2w_close:",
          "169:     fclose(fp);",
          "170:     png_destroy_read_struct(&p, &n, 0);",
          "171:   p2w_free:",
          "172:     free(b);",
          "173:     return 1;",
          "174:   }",
          "175:   pnglen = 0;",
          "176:   png_set_read_fn(p, fp, pngread);",
          "177:   png_read_info(p, n);",
          "178:   uint32_t width, height;",
          "179:   int bitdepth, colortype;",
          "180:   png_get_IHDR(p, n, &width, &height, &bitdepth, &colortype, 0, 0, 0);",
          "181:   if(width > 16383 || height > 16383) {",
          "182:     PF(\"ERROR reading %s: Image too big (%u x %u, max. 16383 x 16383 px)\", IP,",
          "183:       width, height);",
          "184:     goto p2w_close;",
          "185:   }",
          "186:   if(bitdepth > 8)",
          "187:     PF(\"Warning: %s is 16-bit, will be downsampled to 8-bit\", IP);",
          "188:   bool trns = png_get_valid(p, n, PNG_INFO_tRNS);",
          "189: #ifdef FIXEDGAMMA",
          "190: #define GAMMA ((uint32_t)gamma) / 1e5",
          "191:   int32_t gamma = 45455;",
          "192:   if(png_get_valid(p, n, PNG_INFO_sRGB) || png_get_gAMA_fixed(p, n, &gamma))",
          "193:     png_set_gamma_fixed(p, 22e4, gamma);",
          "194: #else",
          "195: #define GAMMA gamma",
          "196:   double gamma = 1 / 2.2;",
          "197:   if(png_get_valid(p, n, PNG_INFO_sRGB) || png_get_gAMA(p, n, &gamma))",
          "198:     png_set_gamma(p, 2.2, gamma);",
          "200: #define S(x) png_set_##x(p)",
          "201:   S(scale_16);",
          "202:   S(expand);",
          "203:   S(gray_to_rgb);",
          "204:   S(packing);",
          "205:   if(*(uint8_t *)&(uint16_t){1}) {",
          "206:     S(bgr);",
          "207:     png_set_add_alpha(p, 255, PNG_FILLER_AFTER);",
          "208:   } else {",
          "210:     S(swap_alpha);",
          "211:     png_set_add_alpha(p, 255, PNG_FILLER_BEFORE);",
          "212:   }",
          "213:   int passes = S(interlace_handling);",
          "214:   png_read_update_info(p, n);",
          "215: #ifndef NDEBUG",
          "216:   size_t rowbytes = png_get_rowbytes(p, n);",
          "217:   if(rowbytes != (size_t)4 * width) {",
          "218:     PF(\"ERROR reading %s: rowbytes is %zu, should be %zu\", IP, rowbytes,",
          "219:       (size_t)4 * width);",
          "220:     goto p2w_close;",
          "221:   }",
          "223:   b = malloc(width * height * 4);",
          "224:   if(!b) {",
          "225:     PF(\"ERROR reading %s: %s\", IP, *k);",
          "226:     goto p2w_close;",
          "227:   }",
          "228:   for(int x = passes; x; x--) {",
          "229:     uint8_t *w = (uint8_t *)b;",
          "230:     for(unsigned y = height; y; y--) {",
          "231:       png_read_row(p, w, 0);",
          "232:       w += width * 4;",
          "234:   }",
          "235:   png_read_end(p, 0);",
          "236:   png_destroy_read_struct(&p, &n, 0);",
          "237:   fclose(fp);",
          "238:   char *colors[7] = {",
          "239:     \"greyscale\", \"???\", \"RGB\", \"paletted\", \"greyscale + alpha\", \"???\", \"RGBA\"};",
          "240:   PFV(\"Info: %s:\\nDimensions: %u x %u\\nSize: %zu bytes (%.15g bpp)\\n\"",
          "241:       \"Format: %u-bit %s (%u)%s%s\\nGamma: %.5g\",",
          "242:     IP, width, height, pnglen, (double)pnglen * 8 / (width * height), bitdepth,",
          "243:     (unsigned)colortype < 7 ? colors[colortype] : \"???\", colortype,",
          "244:     trns ? \", with transparency\" : \"\", passes > 1 ? \", interlaced\" : \"\", GAMMA);",
          "245:   trns = trns || (colortype & PNG_COLOR_MASK_ALPHA);",
          "246:   if(!(fp = openw(op))) goto p2w_free;",
          "247:   WebPAuxStats s;",
          "248:   WebPPicture o = {1, .width = (int)width, (int)height, .argb = b,",
          "249:     .argb_stride = (int)width, .writer = webpwrite, .custom_ptr = fp,",
          "250:     .stats = verbose ? &s : 0}; // TODO: memset? WebPPictureInit?",
          "252:   if(!WebPEncode(",
          "253:        &(WebPConfig){",
          "255:   1, 100, 6, // lossless, max",
          "256:   WEBP_HINT_GRAPH, // 16-bit is only for alpha on lossy",
          "257: #ifndef NOTHREADS",
          "258:   .thread_level = 1, // doesn't seem to affect output",
          "260:   .near_lossless = 100, // don't modify visible pixels",
          "261:   .exact = exact, // see `-e`",
          "262:   .pass = 1, .segments = 1 // unused, for WebPValidateConfig",
          "263:        },",
          "264:        &o)) {",
          "265:     PF(\"ERROR writing %s: %s\", OP, k[o.error_code - 1]);",
          "266:     fclose(fp);",
          "267:   p2w_rm:",
          "268:     if(op) remove(op);",
          "269:     goto p2w_free;",
          "270:   }",
          "271:   if(fclose(fp)) {",
          "272:     PF(\"ERROR closing %s: %s\", OP, strerror(errno));",
          "273:     goto p2w_rm;",
          "274:   }",
          "275:   trns = trns && WebPPictureHasTransparency(&o);",
          "276:   free(b);",
          "277: #define F s.lossless_features",
          "278: #define C s.palette_size",
          "279:   PFV(\"Info: %s:\\nDimensions: %u x %u\\nSize: %u bytes (%.15g bpp)\\n\"",
          "280:       \"Header size: %u, image data size: %u\\nUses alpha: %s\\n\"",
          "281:       \"Precision bits: histogram=%u transform=%u cache=%u\\n\"",
          "282:       \"Lossless features:%s%s%s%s\\nColors: %s%u\",",
          "283:     OP, o.width, o.height, s.lossless_size,",
          "284:     (unsigned)s.lossless_size * 8. / (unsigned)(o.width * o.height),",
          "285:     s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",",
          "286:     s.histogram_bits, s.transform_bits, s.cache_bits,",
          "287:     F ? F & 1 ? \" prediction\" : \"\" : \" none\", F && F & 2 ? \" cross-color\" : \"\",",
          "288:     F && F & 4 ? \" subtract-green\" : \"\", F && F & 8 ? \" palette\" : \"\",",
          "289:     C ? \"\" : \">\", C ? C : 256);",
          "290:   return 0;",
          "291: }",
          "293: Ideally should palette if <=256 colors (in order of appearance),",
          "294: or at least try to palette when input WebP was,",
          "295: but that's not part of either libpng encoding or libwebp decoding.",
          "296: Maybe do this:",
          "297: WEBP_EXTERN int WebPGetColorPalette( // declared in libwebp utils/utils.h",
          "298: const struct WebPPicture *const, uint32_t *const);",
          "300: static bool w2p(char *ip, char *op) {",
          "301:   FILE *fp = openr(ip);",
          "302:   if(!fp) return 1;",
          "303:   bool openwdone = 0;",
          "304:   uint8_t *x = 0, *b = 0;",
          "305:   png_struct *p = 0;",
          "306:   png_info *n = 0;",
          "307:   uint8_t i[12]; // TODO: 16 when LOSSYISERROR and check for VP8[LX]?",
          "308:   char *k[] = {\"Out of memory\", \"Broken config, file a bug report\",",
          "309:     \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};",
          "312:   if(!fread(i, 12, 1, fp)) {",
          "313:     PF(\"ERROR reading %s: %s\", IP, k[6]);",
          "314:     goto w2p_close;",
          "315:   }",
          "316:   if(memcmp(i, (char[4]){\"RIFF\"}, 4) || memcmp(i + 8, (char[4]){\"WEBP\"}, 4)) {",
          "317:     PF(\"ERROR reading %s: %s\", IP, k[2]);",
          "318:     goto w2p_close;",
          "319:   }",
          "320:   size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;",
          "322:   x = malloc(l);",
          "323:   if(!x) {",
          "324:     PF(\"ERROR reading %s: %s\", IP, *k);",
          "325:     goto w2p_close;",
          "326:   }",
          "327:   memcpy(x, i, 12); // should optimize out",
          "328:   if(!fread(x + 12, l - 12, 1, fp)) {",
          "329:     PF(\"ERROR reading %s: %s\", IP, k[6]);",
          "330:     goto w2p_close;",
          "331:   }",
          "332:   fclose(fp);",
          "333: #if defined LOSSYISERROR || defined NOTHREADS",
          "334:   WebPBitstreamFeatures I;",
          "336:   WebPDecoderConfig c = {.options.use_threads = 1};",
          "338: #define I c.input",
          "340:   VP8StatusCode r = WebPGetFeatures(x, l, &I);",
          "341:   if(r) {",
          "342:     PF(\"ERROR reading %s: %s\", IP, k[r - 1]);",
          "343:     goto w2p_free;",
          "344:   }",
          "345: #define V I.format",
          "346: #define W ((unsigned)I.width)",
          "347: #define H ((unsigned)I.height)",
          "348: #define A I.has_alpha",
          "350: #define FMTSTR",
          "351: #define FMTARG",
          "352: #define ANMSTR \"%s\"",
          "353: #define ANMARG , \"animat\"",
          "355:   char *formats[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};",
          "356: #define FMTSTR \"\\nFormat: %s (%d)\"",
          "357: #define FMTARG , (unsigned)V < 3 ? formats[V] : \"???\", V",
          "358: #define ANMSTR \"animat\"",
          "359: #define ANMARG",
          "361:   PFV(\"Info: %s:\\nDimensions: %u x %u\\nSize: %zu bytes (%.15g bpp)\\n\"",
          "362:       \"Uses alpha: %s\" FMTSTR,",
          "363:     IP, W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);",
          "364:   if(I.has_animation) {",
          "365:     PF(\"ERROR reading %s: Unsupported feature: \" ANMSTR \"ion\", IP ANMARG);",
          "366:     goto w2p_free;",
          "367:   }",
          "369:   if(V != 2) {",
          "370:     PF(\"ERROR reading %s: Unsupported feature: %sion\", IP, \"lossy compress\");",
          "371:     goto w2p_free;",
          "372:   }",
          "374: #define B ((unsigned)(3 + A))",
          "375:   b = malloc(W * H * B);",
          "376:   if(!b) {",
          "377:     PF(\"ERROR reading %s: %s\", IP, *k);",
          "378:     goto w2p_free;",
          "379:   }",
          "380: #if defined LOSSYISERROR || defined NOTHREADS",
          "381:   if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(",
          "382:        x, l, b, W * H * B, (int)(W * B))) {",
          "383:     PF(\"ERROR reading %s: %s\", IP, k[2]);",
          "384:     goto w2p_free;",
          "385:   }",
          "387:   c.output.colorspace = A ? MODE_RGBA : MODE_RGB;",
          "388:   c.output.is_external_memory = 1;",
          "389: #define D c.output.u.RGBA",
          "390:   D.rgba = b;",
          "391:   D.stride = (int)(W * B);",
          "392:   D.size = W * H * B;",
          "393:   r = WebPDecode(x, l, &c);",
          "394:   if(r) {",
          "395:     PF(\"ERROR reading %s: %s\", IP, k[r - 1]);",
          "396:     goto w2p_free;",
          "397:   }",
          "398: #endif",
          "399:   free(x);",
          "400:   x = 0;",
          "401:   if(!(fp = openw(op))) goto w2p_free;",
          "402:   openwdone = !!op;",
          "403:   p = png_create_write_struct(PNG_LIBPNG_VER_STRING, 0, 0, 0);",
          "404:   if(!p) {",
          "405:     PF(\"ERROR writing %s: %s\", OP, *k);",
          "406:     goto w2p_close;",
          "407:   }",
          "408:   n = png_create_info_struct(p);",
          "409:   if(!n) {",
          "410:     PF(\"ERROR writing %s: %s\", OP, *k);",
          "411:     goto w2p_close;",
          "412:   }",
          "413:   if(setjmp(png_jmpbuf(p))) {",
          "414:   w2p_close:",
          "415:     fclose(fp);",
          "416:   w2p_free:",
          "417:     if(openwdone) remove(op);",
          "418:     free(x);",
          "419:     free(b);",
          "420:     png_destroy_write_struct(&p, &n);",
          "421:     return 1;",
          "422:   }",
          "423:   pnglen = 0;",
          "424:   png_set_write_fn(p, fp, pngwrite, 0); // TODO: pngflush?",
          "425:   png_set_filter(p, 0, PNG_ALL_FILTERS);",
          "426:   png_set_compression_level(p, 9);",
          "428:   png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);",
          "429:   png_write_info(p, n);",
          "430:   uint8_t *w = b;",
          "431:   for(unsigned y = H; y; y--) {",
          "432:     png_write_row(p, w);",
          "433:     w += W * B;",
          "434:   }",
          "435:   png_write_end(p, n);",
          "436:   png_destroy_write_struct(&p, &n);",
          "437:   p = 0;",
          "438:   n = 0;",
          "439:   free(b);",
          "440:   b = 0;",
          "441:   if(fclose(fp)) {",
          "442:     PF(\"ERROR closing %s: %s\", OP, strerror(errno));",
          "443:     goto w2p_free;",
          "444:   }",
          "445:   PFV(\"Info: %s:\\nDimensions: %u x %u\\nSize: %zu bytes (%.15g bpp)\\n\"",
          "446:       \"Format: %u-bit %s (%u)%s%s\\nGamma: %.5g\",",
          "447:     OP, W, H, pnglen, (double)pnglen * 8 / (uint32_t)(W * H), 8,",
          "448:     A ? \"RGBA\" : \"RGB\", A ? 6 : 2, \"\", \"\", 1 / 2.2);",
          "449:   return 0;",
          "450: }",
          "451: int main(int argc, char **argv) {",
          "452:   static_assert(CHAR_BIT == 8, \"char isn't 8-bit\");",
          "453:   { // should be optimized out",
          "454:     uint32_t endian;",
          "455:     memcpy(&endian, (char[4]){\"\\xAA\\xBB\\xCC\\xDD\"}, 4);",
          "456:     E(endian == 0xAABBCCDD || endian == 0xDDCCBBAA,",
          "457:       \"32-bit mixed-endianness (%X) not supported\", endian)",
          "458:   }",
          "459:   bool pipe = 0, usestdin = 0, usestdout = 0, reverse = 0;",
          "460: #ifdef USEGETOPT",
          "461:   for(int c; (c = getopt(argc, argv, \":prefv\")) != -1;)",
          "462:     switch(c)",
          "464:   while(--argc && **++argv == '-' && argv[0][1])",
          "465:     while(*++*argv)",
          "466:       switch(**argv)",
          "468:     {",
          "469:       case 'p': pipe = 1; break;",
          "470:       case 'r': reverse = 1; break;",
          "471:       case 'e': exact = 1; break;",
          "472:       case 'f': force = 1; break;",
          "473:       case 'v': verbose = 1; break;",
          "474: #ifndef USEGETOPT",
          "475:       case '-':",
          "476:  if(argv[0][1]) return help();",
          "477:  argc--;",
          "478:  argv++;",
          "479:  goto endflagloop;",
          "481:       default: return help();",
          "483: #ifdef USEGETOPT",
          "484:   argc -= optind;",
          "485:   argv += optind;",
          "487: endflagloop:",
          "489: #define URGC (unsigned)argc",
          "490: #define PIPEARG(x) (*argv[x] == '-' && !argv[x][1])",
          "491:   if(pipe) {",
          "492:     if(URGC > 2 || ((usestdin = (!argc || PIPEARG(0))) && isatty(0)) ||",
          "493:       ((usestdout = (URGC < 2 || PIPEARG(1))) && isatty(1)))",
          "494:       return help();",
          "495:     if(usestdin) setmode(0, O_BINARY);",
          "496:     if(usestdout) setmode(1, O_BINARY);",
          "497:     return (reverse ? w2p : p2w)(usestdin ? 0 : *argv, usestdout ? 0 : argv[1]);",
          "498:   }",
          "499:   if(!argc) return help();",
          "500:   bool ret = 0;",
          "501:   if(reverse)",
          "502:     for(; argc; argc--, argv++) {",
          "503:       size_t len = strlen(*argv);",
          "504:       if(len > 4) {",
          "505:  uint32_t ext, extmatch;",
          "506:  memcpy(&ext, *argv + len - 4, 4);",
          "507:  memcpy(&extmatch, (char[4]){\"webp\"}, 4);",
          "508:  if(argv[0][len - 5] == '.' && (ext | 0x20202020) == extmatch) len -= 5;",
          "510:       {",
          "511: #if defined __STDC_NO_VLA__ && !defined NOVLA",
          "512: #define NOVLA",
          "514: #ifdef NOVLA",
          "515:  char *op = malloc(len + 5);",
          "516:  E(op, \"adding .%s extension to %s: Out of memory\", \"png\", *argv)",
          "518: #pragma GCC diagnostic push",
          "519: #pragma GCC diagnostic ignored \"-Wvla\"",
          "520:  char op[len + 5];",
          "521: #pragma GCC diagnostic pop",
          "523:  memcpy(op, *argv, len); // the only real memcpy",
          "524:  memcpy(op + len, \".png\", 5);",
          "525:  ret = w2p(*argv, op) || ret;",
          "526: #ifdef NOVLA",
          "527:  free(op);",
          "529:       }",
          "531:   else",
          "532:     for(; argc; argc--, argv++) {",
          "533:       size_t len = strlen(*argv);",
          "534:       if(len > 3) {",
          "535:  uint32_t ext, extmask, extmatch;",
          "536:  memcpy(&ext, *argv + len - 4, 4);",
          "537:  memcpy(&extmask, (char[4]){\"\\0   \"}, 4);",
          "538:  memcpy(&extmatch, (char[4]){\".png\"}, 4);",
          "539:  if((ext | extmask) == extmatch) len -= 4;",
          "540:       }",
          "541:       {",
          "542: #ifdef NOVLA",
          "543:  char *op = malloc(len + 6);",
          "544:  E(op, \"adding .%s extension to %s: Out of memory\", \"webp\", *argv)",
          "546: #pragma GCC diagnostic push",
          "547: #pragma GCC diagnostic ignored \"-Wvla\"",
          "548:  char op[len + 6];",
          "549: #pragma GCC diagnostic pop",
          "551:  memcpy(op, *argv, len); // the only real memcpy",
          "552:  memcpy(op + len, \".webp\", 6);",
          "553:  ret = p2w(*argv, op) || ret;",
          "554: #ifdef NOVLA",
          "555:  free(op);",
          "557:       }",
          "559:   return ret;",
          "560: }",
          "",
          "---------------"
        ],
        "png2webp.sh||png2webp.sh": [
          "File: png2webp.sh -> png2webp.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: ret=$?",
          "4: if [ $ret -ne 0 ]",
          "5: then",
          "",
          "[Removed Lines]",
          "1: #!/bin/sh",
          "2: \"${0%.sh}\" -bv -- \"$@\"",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env sh",
          "2: \"${0%.sh}\" -v -- \"$@\"",
          "",
          "---------------"
        ],
        "webp2png.sh||webp2png.sh": [
          "File: webp2png.sh -> webp2png.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "webp2png.bat||webptopng.bat": [
          "File: webp2png.bat -> webptopng.bat",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: @ECHO OFF",
          "3: IF %ERRORLEVEL% NEQ 0 PAUSE",
          "4: EXIT /B %ERRORLEVEL%",
          "",
          "[Removed Lines]",
          "2: \"%~dpn0.exe\" -bv -- %*",
          "",
          "[Added Lines]",
          "2: \"%~dp0png2webp.exe\" -rv -- %*",
          "",
          "---------------"
        ],
        "webptopng.sh||webptopng.sh": [
          "File: webptopng.sh -> webptopng.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env sh",
          "2: \"${0%webptopng.sh}png2webp\" -rv -- \"$@\"",
          "3: ret=$?",
          "4: if [ $ret -ne 0 ]",
          "5: then",
          "6:   echo -n 'Press enter to continue'",
          "7:   read -r duh",
          "8: fi",
          "9: exit $ret",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d7cb94df96f7558e86366214d4d6530ebccaef4c",
      "candidate_info": {
        "commit_hash": "d7cb94df96f7558e86366214d4d6530ebccaef4c",
        "repo": "landfillbaby/png2webp",
        "commit_url": "https://github.com/landfillbaby/png2webp/commit/d7cb94df96f7558e86366214d4d6530ebccaef4c",
        "files": [
          "README.md",
          "png2webp.c"
        ],
        "message": "v1.1.0: revamp output\n\nalways outputs \"INFILE -> OUTFILE ...\"\nprogress bar on by default for tty, `-t` forces\ndon't mention filename again in errors",
        "before_after_code_files": [
          "png2webp.c||png2webp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "png2webp.c||png2webp.c"
          ],
          "candidate": [
            "png2webp.c||png2webp.c"
          ]
        }
      },
      "candidate_diff": {
        "png2webp.c||png2webp.c": [
          "File: png2webp.c -> png2webp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <errno.h>",
          "5: #include <inttypes.h>",
          "6: #include <limits.h>",
          "",
          "[Removed Lines]",
          "3: #define VERSION \"v1.0.8\"",
          "",
          "[Added Lines]",
          "3: #define VERSION \"v1.1.0\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: -e: Keep RGB data on pixels where alpha is 0. Always enabled for `-r`.\\n\\",
          "53: -f: Force overwrite of output files (has no effect on stdout).\\n\\",
          "54: -v: Be verbose.\\n\\",
          "55: --: Explicitly stop parsing options.\\n\",",
          "56:     stderr);",
          "57:   return -1;",
          "58: }",
          "60: #define P(x, ...) fprintf(stderr, x \"\\n\", __VA_ARGS__)",
          "61: #define PV(...) \\",
          "62:   if(verbose) P(__VA_ARGS__)",
          "63: #define IP (ip ? ip : \"<stdin>\")",
          "64: #define OP (op ? op : \"<stdout>\")",
          "65: static FILE *openr(char *ip) {",
          "67:   if(!ip) return stdin;",
          "68:   FILE *fp;",
          "69: #ifdef NOFOPENX",
          "70:   int fd = open(ip, O_RDONLY | O_BINARY);",
          "71:   if(fd == -1) {",
          "73:     return 0;",
          "74:   }",
          "75:   if(!(fp = fdopen(fd, \"rb\"))) {",
          "77:     close(fd);",
          "78:     return 0;",
          "79:   }",
          "80: #else",
          "81:   if(!(fp = fopen(ip, \"rb\"))) {",
          "83:     return 0;",
          "84:   }",
          "85: #endif",
          "86:   return fp;",
          "87: }",
          "88: static FILE *openw(char *op) {",
          "90:   if(!op) return stdout;",
          "91:   FILE *fp;",
          "92: #define EO(x) \\",
          "93:   if(!(x)) { \\",
          "96:     return 0; \\",
          "97:   }",
          "98: #ifdef NOFOPENX",
          "",
          "[Removed Lines]",
          "59: static bool exact = 0, force = 0, verbose = 0;",
          "66:   PV(\"Decoding %s ...\", IP);",
          "72:     P(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));",
          "76:     P(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));",
          "82:     P(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));",
          "89:   PV(\"Encoding %s ...\", OP);",
          "94:     P(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\", \\",
          "95:       strerror(errno)); \\",
          "",
          "[Added Lines]",
          "55: -t: Print a progress bar even when stderr isn't a terminal (not for `-r`).\\n\\",
          "60: static bool exact, force, verbose, doprogress;",
          "72:     P(\"ERROR reading: %s\", strerror(errno));",
          "76:     P(\"ERROR reading: %s\", strerror(errno));",
          "82:     P(\"ERROR reading: %s\", strerror(errno));",
          "89:   if(verbose) fputs(\"Encoding ...\\n\", stderr);",
          "94:     P(\"ERROR writing: %s\", strerror(errno)); \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:   );",
          "106:   EO(fd != -1)",
          "107:   if(!(fp = fdopen(fd, \"wb\"))) {",
          "110:     close(fd);",
          "111:     remove(op);",
          "112:     return 0;",
          "",
          "[Removed Lines]",
          "108:     P(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\",",
          "109:       strerror(errno));",
          "",
          "[Added Lines]",
          "107:     P(\"ERROR writing: %s\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "133: #endif",
          "134: }",
          "135: static void pngrerr(png_struct *p, const char *s) {",
          "137:   png_longjmp(p, 1);",
          "138: }",
          "139: static void pngwerr(png_struct *p, const char *s) {",
          "141:   png_longjmp(p, 1);",
          "142: }",
          "143: static void pngwarn(png_struct *p, const char *s) {",
          "145: }",
          "146: static int webpwrite(const uint8_t *d, size_t s, const WebPPicture *p) {",
          "147:   return (int)fwrite(d, s, 1, p->custom_ptr);",
          "",
          "[Removed Lines]",
          "136:   P(\"ERROR reading %s: %s\", (char *)png_get_error_ptr(p), s);",
          "140:   P(\"ERROR writing %s: %s\", (char *)png_get_error_ptr(p), s);",
          "144:   P(\"Warning: %s: %s\", (char *)png_get_error_ptr(p), s);",
          "",
          "[Added Lines]",
          "134:   P(\"ERROR reading: %s\", s);",
          "138:   P(\"ERROR writing: %s\", s);",
          "142:   (void)p;",
          "143:   P(\"Warning: %s\", s);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "159:     return 1; \\",
          "160:   }",
          "161: static bool p2w(char *ip, char *op) {",
          "162:   FILE *fp = openr(ip);",
          "163:   if(!fp) return 1;",
          "164:   uint32_t *b = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:   P(\"%s -> %s ...\", IP, OP);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "173:     \"???\", // lossy",
          "174:     \"???\"}; // canceled",
          "175:   png_struct *p =",
          "177:   if(!p) {",
          "179:     goto p2w_close;",
          "180:   }",
          "181:   n = png_create_info_struct(p);",
          "182:   if(!n) {",
          "184:     goto p2w_close;",
          "185:   }",
          "186:   if(setjmp(png_jmpbuf(p))) {",
          "",
          "[Removed Lines]",
          "176:     png_create_read_struct(PNG_LIBPNG_VER_STRING, ip, pngrerr, pngwarn);",
          "178:     P(\"ERROR reading %s: %s\", IP, *k);",
          "183:     P(\"ERROR reading %s: %s\", IP, *k);",
          "",
          "[Added Lines]",
          "176:     png_create_read_struct(PNG_LIBPNG_VER_STRING, 0, pngrerr, pngwarn);",
          "178:     P(\"ERROR reading: %s\", *k);",
          "183:     P(\"ERROR reading: %s\", *k);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "198:   int bitdepth, colortype;",
          "199:   png_get_IHDR(p, n, &width, &height, &bitdepth, &colortype, 0, 0, 0);",
          "200:   if(width > 16383 || height > 16383) {",
          "202:       \", max. 16383 x 16383 px)\",",
          "204:     goto p2w_close;",
          "205:   }",
          "208:   bool trns = png_get_valid(p, n, PNG_INFO_tRNS);",
          "209:   int32_t gamma = 45455;",
          "210:   if(png_get_valid(p, n, PNG_INFO_sRGB) || png_get_gAMA_fixed(p, n, &gamma)) {",
          "211:     if(gamma != 45455)",
          "213:     png_set_gamma_fixed(p, 22e4, gamma);",
          "214:   }",
          "215: #define S(x) png_set_##x(p)",
          "",
          "[Removed Lines]",
          "201:     P(\"ERROR reading %s: Image too big (%\" PRIu32 \" x %\" PRIu32",
          "203:       IP, width, height);",
          "206:   if((unsigned)bitdepth > 8)",
          "207:     P(\"Warning: %s is 16-bit, will be downsampled to 8-bit\", IP);",
          "212:       P(\"Warning: %s has nonstandard gamma of %.5g\", IP, (uint32_t)gamma / 1e5);",
          "",
          "[Added Lines]",
          "201:     P(\"ERROR reading: Image too big (%\" PRIu32 \" x %\" PRIu32",
          "203:       width, height);",
          "206:   if((unsigned)bitdepth > 8) P(\"Warning: %s\", \"will be downsampled to 8-bit\");",
          "211:       P(\"Warning: nonstandard gamma: %.5g\", (uint32_t)gamma / 1e5);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "230: #ifndef NDEBUG",
          "231:   size_t rowbytes = png_get_rowbytes(p, n);",
          "232:   if(rowbytes != (size_t)4 * width) {",
          "234:       (size_t)4 * width);",
          "235:     goto p2w_close;",
          "236:   }",
          "237: #endif",
          "238:   b = malloc(width * height * 4);",
          "239:   if(!b) {",
          "241:     goto p2w_close;",
          "242:   }",
          "243:   for(unsigned x = (unsigned)passes; x; x--) {",
          "",
          "[Removed Lines]",
          "233:     P(\"ERROR reading %s: rowbytes is %zu, should be %zu\", IP, rowbytes,",
          "240:     P(\"ERROR reading %s: %s\", IP, *k);",
          "",
          "[Added Lines]",
          "232:     P(\"ERROR reading: rowbytes is %zu, should be %zu\", rowbytes,",
          "239:     P(\"ERROR reading: %s\", *k);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "252:   fclose(fp);",
          "253:   char *f[] = {",
          "254:     \"grayscale\", \"???\", \"RGB\", \"paletted\", \"grayscale + alpha\", \"???\", \"RGBA\"};",
          "256:      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\",",
          "258:     f[(unsigned)colortype], trns ? \", with transparency\" : \"\",",
          "259:     (unsigned)passes > 1 ? \", interlaced\" : \"\");",
          "260:   WebPConfig c;",
          "261:   if(!WebPConfigPreset(&c, WEBP_PRESET_ICON, 100)) {",
          "263:     goto p2w_free;",
          "264:   }",
          "265:   if(!(fp = openw(op))) goto p2w_free;",
          "",
          "[Removed Lines]",
          "255:   PV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32",
          "257:     IP, width, height, pnglen, (double)pnglen * 8 / (width * height), bitdepth,",
          "262:     P(\"ERROR writing %s: %s\", OP, k[3]);",
          "",
          "[Added Lines]",
          "254:   PV(\"Input info:\\nDimensions: %\" PRIu32 \" x %\" PRIu32",
          "256:     width, height, pnglen, (double)pnglen * 8 / (width * height), bitdepth,",
          "261:     P(\"ERROR writing: %s\", k[3]);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "272:   WebPAuxStats s;",
          "273:   WebPPicture o = {1, .width = (int)width, (int)height, .argb = b,",
          "274:     .argb_stride = (int)width, .writer = webpwrite, .custom_ptr = fp,",
          "276:   trns = (trns || (colortype & PNG_COLOR_MASK_ALPHA)) &&",
          "277:     WebPPictureHasTransparency(&o);",
          "278:   if(!WebPEncode(&c, &o)) {",
          "281:     fclose(fp);",
          "282:   p2w_rm:",
          "283:     if(op) remove(op);",
          "284:     goto p2w_free;",
          "285:   }",
          "286:   if(fclose(fp)) {",
          "288:     goto p2w_rm;",
          "289:   }",
          "290:   free(b);",
          "291: #define F s.lossless_features",
          "292: #define C s.palette_size",
          "294: Header size: %u, image data size: %u\\nUses alpha: %s\\n\\",
          "295: Precision bits: histogram=%u transform=%u cache=%u\\n\\",
          "296: Lossless features:%s%s%s%s\\nColors: %s%u\",",
          "304:   return 0;",
          "305: }",
          "306: static bool w2p(char *ip, char *op) {",
          "307:   FILE *fp = openr(ip);",
          "308:   if(!fp) return 1;",
          "309:   bool openwdone = 0;",
          "",
          "[Removed Lines]",
          "275:     .stats = verbose ? &s : 0, .progress_hook = verbose ? progress : 0};",
          "279: #define PN(x, ...) P(verbose ? \"\\n\" x \"\\n\" : x, __VA_ARGS__)",
          "280:     PN(\"ERROR writing %s: %s\", OP, k[o.error_code - 1]);",
          "287:     PN(\"ERROR closing %s: %s\", OP, strerror(errno));",
          "293:   PV(\"\\nInfo: %s:\\nSize: %u bytes (%.15g bpp)\\n\\",
          "297:     OP, s.lossless_size,",
          "298:     (unsigned)s.lossless_size * 8. / (uint32_t)(o.width * o.height),",
          "299:     s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",",
          "300:     s.histogram_bits, s.transform_bits, s.cache_bits,",
          "301:     F ? F & 1 ? \" prediction\" : \"\" : \" none\", F && F & 2 ? \" cross-color\" : \"\",",
          "302:     F && F & 4 ? \" subtract-green\" : \"\", F && F & 8 ? \" palette\" : \"\",",
          "303:     C ? \"\" : \">\", C ? C : 256);",
          "",
          "[Added Lines]",
          "274:     .stats = verbose ? &s : 0, .progress_hook = doprogress ? progress : 0};",
          "278: #define PN(x, ...) P(doprogress ? \"\\n\" x \"\\n\" : x, __VA_ARGS__)",
          "279:     PN(\"ERROR writing: %s\", k[o.error_code - 1]);",
          "286:     PN(\"ERROR writing: %s\", strerror(errno));",
          "292:   if(verbose)",
          "293:     PN(\"Output info:\\nSize: %u bytes (%.15g bpp)\\n\\",
          "297:       s.lossless_size,",
          "298:       (unsigned)s.lossless_size * 8. / (uint32_t)(o.width * o.height),",
          "299:       s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",",
          "300:       s.histogram_bits, s.transform_bits, s.cache_bits,",
          "301:       F ? F & 1 ? \" prediction\" : \"\" : \" none\",",
          "302:       F && F & 2 ? \" cross-color\" : \"\", F && F & 4 ? \" subtract-green\" : \"\",",
          "303:       F && F & 8 ? \" palette\" : \"\", C ? \"\" : \">\", C ? C : 256);",
          "307:   P(\"%s -> %s ...\", IP, OP);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "315:     \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};",
          "317:   if(!fread(i, 12, 1, fp)) {",
          "319:     goto w2p_close;",
          "320:   }",
          "321:   if(memcmp(i, (char[4]){\"RIFF\"}, 4) || memcmp(i + 8, (char[4]){\"WEBP\"}, 4)) {",
          "323:     goto w2p_close;",
          "324:   }",
          "325:   uint32_t l = // RIFF header size",
          "326:     ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;",
          "327:   if(l < 28 || l > 0xfffffffe) {",
          "329:     goto w2p_close;",
          "330:   }",
          "331:   x = malloc(l);",
          "332:   if(!x) {",
          "334:     goto w2p_close;",
          "335:   }",
          "336:   memcpy(x, i, 12); // should optimize out",
          "",
          "[Removed Lines]",
          "318:     P(\"ERROR reading %s: %s\", IP, k[6]);",
          "322:     P(\"ERROR reading %s: %s\", IP, k[2]);",
          "328:     P(\"ERROR reading %s: %s\", IP, k[2]);",
          "333:     P(\"ERROR reading %s: %s\", IP, *k);",
          "",
          "[Added Lines]",
          "319:     P(\"ERROR reading: %s\", k[6]);",
          "323:     P(\"ERROR reading: %s\", k[2]);",
          "329:     P(\"ERROR reading: %s\", k[2]);",
          "334:     P(\"ERROR reading: %s\", *k);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "339: #if defined __ANDROID__ // TODO? && __ANDROID_API__ < 34",
          "340:   if(m > 0x7fffffff) { // https://issuetracker.google.com/240139009",
          "341:     if(!fread(z, 0x7fffffff, 1, fp)) {",
          "343:       goto w2p_close;",
          "344:     }",
          "345:     z += 0x7fffffff;",
          "",
          "[Removed Lines]",
          "342:       P(\"ERROR reading %s: %s\", IP, k[6]);",
          "",
          "[Added Lines]",
          "343:       P(\"ERROR reading: %s\", k[6]);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "347:   }",
          "348: #endif",
          "349:   if(!fread(z, m, 1, fp)) {",
          "351:     goto w2p_close;",
          "352:   }",
          "353:   fclose(fp);",
          "",
          "[Removed Lines]",
          "350:     P(\"ERROR reading %s: %s\", IP, k[6]);",
          "",
          "[Added Lines]",
          "351:     P(\"ERROR reading: %s\", k[6]);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "359: #endif",
          "360:   VP8StatusCode r = WebPGetFeatures(x, l, &I);",
          "361:   if(r) {",
          "363:     goto w2p_free;",
          "364:   }",
          "365: #define V I.format",
          "",
          "[Removed Lines]",
          "362:     P(\"ERROR reading %s: %s\", IP, k[r - 1]);",
          "",
          "[Added Lines]",
          "363:     P(\"ERROR reading: %s\", k[r - 1]);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "369: #ifdef LOSSYISERROR",
          "370: #define FMTSTR",
          "371: #define FMTARG",
          "374: #else",
          "375:   char *f[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};",
          "376: #define FMTSTR \"\\nFormat: %s\"",
          "377: #define FMTARG , f[V]",
          "380: #endif",
          "382:      \" bytes (%.15g bpp)\\nUses alpha: %s\" FMTSTR,",
          "384:   if(I.has_animation) {",
          "386:     goto w2p_free;",
          "387:   }",
          "388: #ifdef LOSSYISERROR",
          "389:   if(V != 2) {",
          "391:     goto w2p_free;",
          "392:   }",
          "393: #endif",
          "394: #define B ((unsigned)(3 + A))",
          "395:   b = malloc(W * H * B);",
          "396:   if(!b) {",
          "398:     goto w2p_free;",
          "399:   }",
          "400: #if defined LOSSYISERROR || defined NOTHREADS",
          "401:   if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(",
          "402:        x, l, b, W * H * B, (int)(W * B))) {",
          "404:     goto w2p_free;",
          "405:   }",
          "406: #else",
          "",
          "[Removed Lines]",
          "372: #define ANMSTR \"%s\"",
          "373: #define ANMARG , \"animat\"",
          "378: #define ANMSTR \"animat\"",
          "379: #define ANMARG",
          "381:   PV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32 \"\\nSize: %\" PRIu32",
          "383:     IP, W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);",
          "385:     P(\"ERROR reading %s: Unsupported feature: \" ANMSTR \"ion\", IP ANMARG);",
          "390:     P(\"ERROR reading %s: Unsupported feature: %sion\", IP, \"lossy compress\");",
          "397:     P(\"ERROR reading %s: %s\", IP, *k);",
          "403:     P(\"ERROR reading %s: %s\", IP, k[2]);",
          "",
          "[Added Lines]",
          "378:   PV(\"Input info:\\nDimensions: %\" PRIu32 \" x %\" PRIu32 \"\\nSize: %\" PRIu32",
          "380:     W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);",
          "382:     P(\"ERROR reading: %s\", \"Unsupported feature: animation\");",
          "387:     P(\"ERROR reading: %s\", \"Unsupported feature: lossy compression\");",
          "394:     P(\"ERROR reading: %s\", *k);",
          "400:     P(\"ERROR reading: %s\", k[2]);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "412:   D.size = W * H * B;",
          "413:   r = WebPDecode(x, l, &c);",
          "414:   if(r) {",
          "416:     goto w2p_free;",
          "417:   }",
          "418: #endif",
          "",
          "[Removed Lines]",
          "415:     P(\"ERROR reading %s: %s\", IP, k[r - 1]);",
          "",
          "[Added Lines]",
          "412:     P(\"ERROR reading: %s\", k[r - 1]);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "420:   x = 0;",
          "421:   if(!(fp = openw(op))) goto w2p_free;",
          "422:   openwdone = !!op;",
          "424:   if(!p) {",
          "426:     goto w2p_close;",
          "427:   }",
          "428:   n = png_create_info_struct(p);",
          "429:   if(!n) {",
          "431:     goto w2p_close;",
          "432:   }",
          "433:   if(setjmp(png_jmpbuf(p))) {",
          "",
          "[Removed Lines]",
          "423:   p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);",
          "425:     P(\"ERROR writing %s: %s\", OP, *k);",
          "430:     P(\"ERROR writing %s: %s\", OP, *k);",
          "",
          "[Added Lines]",
          "420:   p = png_create_write_struct(PNG_LIBPNG_VER_STRING, 0, pngwerr, pngwarn);",
          "422:     P(\"ERROR writing: %s\", *k);",
          "427:     P(\"ERROR writing: %s\", *k);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "459:   free(b);",
          "460:   b = 0;",
          "461:   if(fclose(fp)) {",
          "463:     goto w2p_free;",
          "464:   }",
          "466:     (double)pnglen * 8 / (W * H), A ? \"RGBA\" : \"RGB\");",
          "467:   return 0;",
          "468: }",
          "",
          "[Removed Lines]",
          "462:     P(\"ERROR closing %s: %s\", OP, strerror(errno));",
          "465:   PV(\"Info: %s:\\nSize: %zu bytes (%.15g bpp)\\nFormat: 8-bit %s\", OP, pnglen,",
          "",
          "[Added Lines]",
          "459:     P(\"ERROR writing: %s\", strerror(errno));",
          "462:   PV(\"Output info:\\nSize: %zu bytes (%.15g bpp)\\nFormat: 8-bit %s\", pnglen,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "471:     uint32_t endian;",
          "472:     memcpy(&endian, (char[4]){\"\\xAA\\xBB\\xCC\\xDD\"}, 4);",
          "473:     if(endian == 0xAABBCCDD)",
          "475:     else",
          "476:       E(endian == 0xDDCCBBAA, \"32-bit mixed-endianness (%X) not supported\",",
          "477:  endian)",
          "478:   }",
          "479:   bool pipe = 0, usestdin = 0, usestdout = 0, reverse = 0;",
          "480: #ifdef USEGETOPT",
          "482:     switch(c)",
          "483: #else",
          "484:   while(--argc && **++argv == '-' && argv[0][1])",
          "",
          "[Removed Lines]",
          "474:       fputs(\"Warning: big-endian support is untested\\n\", stderr); // see TODO",
          "481:   for(int c; (c = getopt(argc, argv, \":prefv\")) != -1;)",
          "",
          "[Added Lines]",
          "471:       P(\"Warning: %s\", \"big-endian support is untested\"); // TODO",
          "478:   for(int c; (c = getopt(argc, argv, \":prefvt\")) != -1;)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "491:       case 'e': exact = 1; break;",
          "492:       case 'f': force = 1; break;",
          "493:       case 'v': verbose = 1; break;",
          "494: #ifndef USEGETOPT",
          "495:       case '-':",
          "496:  if(argv[0][1]) return help();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "491:       case 't': doprogress = 1; break;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "514:       return help();",
          "515:     if(usestdin) setmode(0, O_BINARY);",
          "516:     if(usestdout) setmode(1, O_BINARY);",
          "517:     return (reverse ? w2p : p2w)(usestdin ? 0 : *argv, usestdout ? 0 : argv[1]);",
          "518:   }",
          "519:   if(!argc) return help();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "515:     if(!reverse && !doprogress) doprogress = isatty(2);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "548: #endif",
          "549:       }",
          "550:     }",
          "552:     for(; argc; argc--, argv++) {",
          "553:       size_t len = strlen(*argv);",
          "554:       if(len > 3) {",
          "",
          "[Removed Lines]",
          "551:   else",
          "",
          "[Added Lines]",
          "550:   else {",
          "551:     if(!doprogress) doprogress = isatty(2);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "576: #endif",
          "577:       }",
          "578:     }",
          "579:   return ret;",
          "580: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "579:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cd9dd8cbf0e9b1cf003f61b3c14dcb0963079016",
      "candidate_info": {
        "commit_hash": "cd9dd8cbf0e9b1cf003f61b3c14dcb0963079016",
        "repo": "landfillbaby/png2webp",
        "commit_url": "https://github.com/landfillbaby/png2webp/commit/cd9dd8cbf0e9b1cf003f61b3c14dcb0963079016",
        "files": [
          "exestamp.c",
          "png2webp.c"
        ],
        "message": "android issue only < 34, formatting, if(b) free(b)",
        "before_after_code_files": [
          "exestamp.c||exestamp.c",
          "png2webp.c||png2webp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "png2webp.c||png2webp.c"
          ],
          "candidate": [
            "png2webp.c||png2webp.c"
          ]
        }
      },
      "candidate_diff": {
        "exestamp.c||exestamp.c": [
          "File: exestamp.c -> exestamp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:   char *n;",
          "26:   uint32_t t;",
          "27:   if(argc != 3 || isspace(*argv[2]) ||",
          "29:     fputs(\"Usage: exestamp EXE STAMP\\nEXE: Windows PE32(+) file\\nSTAMP: \\",
          "30: Decimal, octal (leading 0), or hexadecimal (leading 0x) Unix timestamp\\n\",",
          "32:     return -1;",
          "33:   }",
          "34:   FILE *f = fopen(argv[1], \"rb+\");",
          "",
          "[Removed Lines]",
          "28:     ((void)(t = (uint32_t)strtoll(argv[2], &n, 0)), *n) || errno) {",
          "31:       stderr);",
          "",
          "[Added Lines]",
          "28:       ((void)(t = (uint32_t)strtoll(argv[2], &n, 0)), *n) || errno) {",
          "31:  stderr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40: #define B (uint32_t)(*b | (b[1] << 8) | (b[2] << 16) | (b[3] << 24))",
          "41: #define R(x) !fread(b, x, 1, f)",
          "42:   if(R(2) || memcmp(b, (char[2]){\"MZ\"}, 2) || F(f, 60, SEEK_SET) || R(4) ||",
          "45:     fputs(\"ERROR: Invalid Windows PE32(+) file\\n\", stderr);",
          "46:     fclose(f);",
          "47:     return 1;",
          "",
          "[Removed Lines]",
          "43:     F(f, B, SEEK_SET) || R(4) || memcmp(b, \"PE\\0\", 4) || F(f, 4, SEEK_CUR) ||",
          "44:     R(4)) {",
          "",
          "[Added Lines]",
          "43:       F(f, B, SEEK_SET) || R(4) || memcmp(b, \"PE\\0\", 4) || F(f, 4, SEEK_CUR) ||",
          "44:       R(4)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "49:   printf(\"Original timestamp: %\" PRIu32 \"\\n\", B);",
          "50: #define T(x) ((t >> x) & 255)",
          "51:   if(F(f, -4, SEEK_CUR) ||",
          "53:     perror(\"ERROR writing new timestamp\");",
          "54:     fclose(f);",
          "55:     return 1;",
          "",
          "[Removed Lines]",
          "52:     !fwrite((uint8_t[]){T(0), T(8), T(16), T(24)}, 4, 1, f)) {",
          "",
          "[Added Lines]",
          "52:       !fwrite((uint8_t[]){T(0), T(8), T(16), T(24)}, 4, 1, f)) {",
          "",
          "---------------"
        ],
        "png2webp.c||png2webp.c": [
          "File: png2webp.c -> png2webp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: -v: Be verbose.\\n\\",
          "62: -t: Print a progress bar even when stderr isn't a terminal (not for `-r`).\\n\\",
          "63: --: Explicitly stop parsing options.\\n\",",
          "65:   return -1;",
          "66: }",
          "67: static bool exact, force, verbose, doprogress;",
          "",
          "[Removed Lines]",
          "64:     stderr);",
          "",
          "[Added Lines]",
          "64:       stderr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98: #ifdef NOFOPENX",
          "99:   int fd = open(op, O_WRONLY | O_CREAT | (force ? O_TRUNC : O_EXCL) | O_BINARY,",
          "100: #ifdef _WIN32",
          "102: #else",
          "104: #endif",
          "105:   );",
          "106:   if(fd == -1) {",
          "",
          "[Removed Lines]",
          "101:     S_IREAD | S_IWRITE",
          "103:     S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH",
          "",
          "[Added Lines]",
          "101:       S_IREAD | S_IWRITE",
          "103:       S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:   uint32_t *b = 0;",
          "167:   png_info *n = 0;",
          "168:   char *k[] = {\"Out of memory\",",
          "177:   png_struct *p =",
          "179:   if(!p) {",
          "180:     P(\"ERROR reading: %s\", *k);",
          "181:     goto p2w_close;",
          "",
          "[Removed Lines]",
          "169:     \"???\", // oom flushing bitstream, unused in libwebp",
          "170:     \"???\", // null param",
          "171:     \"Broken config, file a bug report\",",
          "172:     \"???\", // image too big (checked on PNG input)",
          "173:     \"???\", \"???\", // lossy",
          "174:     \"I/O error\",",
          "175:     \"???\", // lossy",
          "176:     \"???\"}; // canceled",
          "178:     png_create_read_struct(PNG_LIBPNG_VER_STRING, 0, pngrerr, pngwarn);",
          "",
          "[Added Lines]",
          "169:       \"???\", // oom flushing bitstream, unused in libwebp",
          "170:       \"???\", // null param",
          "171:       \"Broken config, file a bug report\",",
          "172:       \"???\", // image too big (checked on PNG input)",
          "173:       \"???\", \"???\", // lossy",
          "174:       \"I/O error\",",
          "175:       \"???\", // lossy",
          "176:       \"???\"}; // canceled",
          "178:       png_create_read_struct(PNG_LIBPNG_VER_STRING, 0, pngrerr, pngwarn);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "190:     fclose(fp);",
          "191:     png_destroy_read_struct(&p, &n, 0);",
          "192:   p2w_free:",
          "194:     return 1;",
          "195:   }",
          "196:   pnglen = 0;",
          "",
          "[Removed Lines]",
          "193:     free(b);",
          "",
          "[Added Lines]",
          "193:     if(b) free(b);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "202:   if(width > 16383 || height > 16383) {",
          "203:     P(\"ERROR reading: Image too big (%\" PRIu32 \" x %\" PRIu32",
          "204:       \", max. 16383 x 16383 px)\",",
          "206:     goto p2w_close;",
          "207:   }",
          "208:   if((unsigned)bitdepth > 8) P(\"Warning: %s\", \"Downsampling to 8-bit\");",
          "",
          "[Removed Lines]",
          "205:       width, height);",
          "",
          "[Added Lines]",
          "205:  width, height);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "232:   size_t rowbytes = png_get_rowbytes(p, n);",
          "233:   if(rowbytes != (size_t)4 * width) {",
          "234:     P(\"ERROR reading: rowbytes is %zu, should be %zu\", rowbytes,",
          "236:     goto p2w_close;",
          "237:   }",
          "238: #endif",
          "",
          "[Removed Lines]",
          "235:       (size_t)4 * width);",
          "",
          "[Added Lines]",
          "235:  (size_t)4 * width);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "251:   png_read_end(p, 0);",
          "252:   png_destroy_read_struct(&p, &n, 0);",
          "253:   fclose(fp);",
          "256:   PV(\"Input info:\\nDimensions: %\" PRIu32 \" x %\" PRIu32",
          "257:      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\",",
          "261:   WebPConfig c;",
          "262:   if(!WebPConfigPreset(&c, WEBP_PRESET_ICON, 100)) {",
          "263:     P(\"ERROR writing: %s\", k[3]);",
          "",
          "[Removed Lines]",
          "254:   char *f[] = {",
          "255:     \"grayscale\", \"???\", \"RGB\", \"paletted\", \"grayscale + alpha\", \"???\", \"RGBA\"};",
          "258:     width, height, pnglen, (double)pnglen * 8 / (width * height), bitdepth,",
          "259:     f[(unsigned)colortype], trns ? \", with transparency\" : \"\",",
          "260:     (unsigned)passes > 1 ? \", interlaced\" : \"\");",
          "",
          "[Added Lines]",
          "254:   char *f[] = {\"grayscale\", \"???\", \"RGB\", \"paletted\", \"grayscale + alpha\",",
          "255:       \"???\", \"RGBA\"};",
          "258:       width, height, pnglen, (double)pnglen * 8 / (width * height), bitdepth,",
          "259:       f[(unsigned)colortype], trns ? \", with transparency\" : \"\",",
          "260:       (unsigned)passes > 1 ? \", interlaced\" : \"\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "272:   c.exact = exact;",
          "273:   WebPAuxStats s;",
          "274:   WebPPicture o = {1, .width = (int)width, (int)height, .argb = b,",
          "277:   if(doprogress) fprintf(stderr, \"[%-64.*s] %u%%\", 0, \"\", 0);",
          "278:   trns = (trns || (colortype & PNG_COLOR_MASK_ALPHA)) &&",
          "280:   int r = WebPEncode(&c, &o);",
          "281:   if(doprogress) fputc('\\n', stderr);",
          "282:   if(!r) {",
          "",
          "[Removed Lines]",
          "275:     .argb_stride = (int)width, .writer = webpwrite, .custom_ptr = fp,",
          "276:     .stats = verbose ? &s : 0, .progress_hook = doprogress ? progress : 0};",
          "279:     WebPPictureHasTransparency(&o);",
          "",
          "[Added Lines]",
          "275:       .argb_stride = (int)width, .writer = webpwrite, .custom_ptr = fp,",
          "276:       .stats = verbose ? &s : 0, .progress_hook = doprogress ? progress : 0};",
          "279:       WebPPictureHasTransparency(&o);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "297: Header size: %u, image data size: %u\\nUses alpha: %s\\n\\",
          "298: Precision bits: histogram=%u transform=%u cache=%u\\n\\",
          "299: Lossless features:%s%s%s%s\\nColors: %s%u\",",
          "307:   return 0;",
          "308: }",
          "309: static bool w2p(char *ip, char *op) {",
          "",
          "[Removed Lines]",
          "300:     s.lossless_size,",
          "301:     (unsigned)s.lossless_size * 8. / (uint32_t)(o.width * o.height),",
          "302:     s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",",
          "303:     s.histogram_bits, s.transform_bits, s.cache_bits,",
          "304:     F ? F & 1 ? \" prediction\" : \"\" : \" none\", F && F & 2 ? \" cross-color\" : \"\",",
          "305:     F && F & 4 ? \" subtract-green\" : \"\", F && F & 8 ? \" palette\" : \"\",",
          "306:     C ? \"\" : \">\", C ? C : 256);",
          "",
          "[Added Lines]",
          "300:       s.lossless_size,",
          "301:       (unsigned)s.lossless_size * 8. / (uint32_t)(o.width * o.height),",
          "302:       s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",",
          "303:       s.histogram_bits, s.transform_bits, s.cache_bits,",
          "304:       F ? F & 1 ? \" prediction\" : \"\" : \" none\",",
          "305:       F && F & 2 ? \" cross-color\" : \"\", F && F & 4 ? \" subtract-green\" : \"\",",
          "306:       F && F & 8 ? \" palette\" : \"\", C ? \"\" : \">\", C ? C : 256);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "316:   png_info *n = 0;",
          "317:   uint8_t i[12];",
          "318:   char *k[] = {\"Out of memory\", \"Broken config, file a bug report\",",
          "321:   if(!fread(i, 12, 1, fp)) {",
          "322:     P(\"ERROR reading: %s\", k[6]);",
          "",
          "[Removed Lines]",
          "319:     \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};",
          "",
          "[Added Lines]",
          "319:       \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "327:     goto w2p_close;",
          "328:   }",
          "329:   uint32_t l = // RIFF header size",
          "331:   if(l < 28 || l > 0xfffffffe) {",
          "332:     P(\"ERROR reading: %s\", k[2]);",
          "333:     goto w2p_close;",
          "",
          "[Removed Lines]",
          "330:     ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;",
          "",
          "[Added Lines]",
          "330:       ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "340:   memcpy(x, i, 12); // should optimize out",
          "341:   uint8_t *z = x + 12;",
          "342:   uint32_t m = l - 12;",
          "344:   if(m > 0x7fffffff) { // https://issuetracker.google.com/240139009",
          "345:     if(!fread(z, 0x7fffffff, 1, fp)) {",
          "346:       P(\"ERROR reading: %s\", k[6]);",
          "",
          "[Removed Lines]",
          "343: #if defined __ANDROID__ // TODO? && __ANDROID_API__ < 34",
          "",
          "[Added Lines]",
          "343: #if defined __ANDROID__ && __ANDROID_API__ < 34",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "380: #endif",
          "381:   PV(\"Input info:\\nDimensions: %\" PRIu32 \" x %\" PRIu32 \"\\nSize: %\" PRIu32",
          "382:      \" bytes (%.15g bpp)\\nUses alpha: %s\" FMTSTR,",
          "384:   if(I.has_animation) {",
          "385:     P(\"ERROR reading: %s\", \"Unsupported feature: animation\");",
          "386:     goto w2p_free;",
          "",
          "[Removed Lines]",
          "383:     W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);",
          "",
          "[Added Lines]",
          "383:       W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "399:   }",
          "400: #if defined LOSSYISERROR || defined NOTHREADS",
          "401:   if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(",
          "403:     P(\"ERROR reading: %s\", k[2]);",
          "404:     goto w2p_free;",
          "405:   }",
          "",
          "[Removed Lines]",
          "402:        x, l, b, W * H * B, (int)(W * B))) {",
          "",
          "[Added Lines]",
          "402:   x, l, b, W * H * B, (int)(W * B))) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "436:   w2p_free:",
          "437:     if(openwdone) remove(op);",
          "438:     free(x);",
          "440:     png_destroy_write_struct(&p, &n);",
          "441:     return 1;",
          "442:   }",
          "",
          "[Removed Lines]",
          "439:     free(b);",
          "",
          "[Added Lines]",
          "439:     if(b) free(b);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "463:     goto w2p_free;",
          "464:   }",
          "465:   PV(\"Output info:\\nSize: %zu bytes (%.15g bpp)\\nFormat: 8-bit %s\", pnglen,",
          "467:   return 0;",
          "468: }",
          "469: int main(int argc, char **argv) {",
          "",
          "[Removed Lines]",
          "466:     (double)pnglen * 8 / (W * H), A ? \"RGBA\" : \"RGB\");",
          "",
          "[Added Lines]",
          "466:       (double)pnglen * 8 / (W * H), A ? \"RGBA\" : \"RGB\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "512: #define PIPEARG(x) (*argv[x] == '-' && !argv[x][1])",
          "513:   if(pipe) {",
          "514:     if(URGC > 2 || ((usestdin = (!argc || PIPEARG(0))) && isatty(0)) ||",
          "516:       return help();",
          "517: #ifdef _WIN32",
          "518:     if(usestdin) setmode(0, O_BINARY);",
          "",
          "[Removed Lines]",
          "515:       ((usestdout = (URGC < 2 || PIPEARG(1))) && isatty(1)))",
          "",
          "[Added Lines]",
          "515:  ((usestdout = (URGC < 2 || PIPEARG(1))) && isatty(1)))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "532:  memcpy(&extmatch, (char[4]){\"webp\"}, 4);",
          "533:  if(argv[0][len - 5] == '.' && (ext | 0x20202020) == extmatch) len -= 5;",
          "534:       }",
          "536: #if defined __STDC_NO_VLA__ && !defined NOVLA",
          "537: #define NOVLA",
          "538: #endif",
          "539: #ifdef NOVLA",
          "545: #elif defined __GNUC__",
          "546: #pragma GCC diagnostic push",
          "547: #pragma GCC diagnostic ignored \"-Wvla\"",
          "549: #pragma GCC diagnostic pop",
          "550: #else",
          "552: #endif",
          "556: #ifdef NOVLA",
          "558: #endif",
          "560:     }",
          "561:   else {",
          "562:     if(!doprogress) doprogress = isatty(2);",
          "",
          "[Removed Lines]",
          "535:       {",
          "540:  char *op = malloc(len + 5);",
          "541:  if(!op) {",
          "542:    P(\"ERROR adding .%s extension to %s: Out of memory\", \"png\", *argv);",
          "543:    return 1;",
          "544:  }",
          "548:  char op[len + 5];",
          "551:  char op[len + 5];",
          "553:  memcpy(op, *argv, len); // the only real memcpy",
          "554:  memcpy(op + len, \".png\", 5);",
          "555:  ret = w2p(*argv, op) || ret;",
          "557:  free(op);",
          "559:       }",
          "",
          "[Added Lines]",
          "539:       char *op = malloc(len + 5);",
          "540:       if(!op) {",
          "541:  P(\"ERROR adding .%s extension to %s: Out of memory\", \"png\", *argv);",
          "542:  return 1;",
          "543:       }",
          "547:       char op[len + 5];",
          "550:       char op[len + 5];",
          "552:       memcpy(op, *argv, len); // the only real memcpy",
          "553:       memcpy(op + len, \".png\", 5);",
          "554:       ret = w2p(*argv, op) || ret;",
          "556:       free(op);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "569:  memcpy(&extmatch, (char[4]){\".png\"}, 4);",
          "570:  if((ext | extmask) == extmatch) len -= 4;",
          "571:       }",
          "573: #ifdef NOVLA",
          "579: #elif defined __GNUC__",
          "580: #pragma GCC diagnostic push",
          "581: #pragma GCC diagnostic ignored \"-Wvla\"",
          "583: #pragma GCC diagnostic pop",
          "584: #else",
          "586: #endif",
          "590: #ifdef NOVLA",
          "592: #endif",
          "594:     }",
          "595:   }",
          "596:   return ret;",
          "",
          "[Removed Lines]",
          "572:       {",
          "574:  char *op = malloc(len + 6);",
          "575:  if(!op) {",
          "576:    P(\"ERROR adding .%s extension to %s: Out of memory\", \"webp\", *argv);",
          "577:    return 1;",
          "578:  }",
          "582:  char op[len + 6];",
          "585:  char op[len + 6];",
          "587:  memcpy(op, *argv, len); // the only real memcpy",
          "588:  memcpy(op + len, \".webp\", 6);",
          "589:  ret = p2w(*argv, op) || ret;",
          "591:  free(op);",
          "593:       }",
          "",
          "[Added Lines]",
          "571:       char *op = malloc(len + 6);",
          "572:       if(!op) {",
          "573:  P(\"ERROR adding .%s extension to %s: Out of memory\", \"webp\", *argv);",
          "574:  return 1;",
          "575:       }",
          "579:       char op[len + 6];",
          "582:       char op[len + 6];",
          "584:       memcpy(op, *argv, len); // the only real memcpy",
          "585:       memcpy(op + len, \".webp\", 6);",
          "586:       ret = p2w(*argv, op) || ret;",
          "588:       free(op);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
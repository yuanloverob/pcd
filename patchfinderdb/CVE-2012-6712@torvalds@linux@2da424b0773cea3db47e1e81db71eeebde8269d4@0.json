{
  "cve_id": "CVE-2012-6712",
  "cve_desc": "In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption.",
  "repo": "torvalds/linux",
  "patch_hash": "2da424b0773cea3db47e1e81db71eeebde8269d4",
  "patch_info": {
    "commit_hash": "2da424b0773cea3db47e1e81db71eeebde8269d4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4",
    "files": [
      "drivers/net/wireless/iwlwifi/iwl-agn-sta.c"
    ],
    "message": "iwlwifi: Sanity check for sta_id\n\nOn my testing, I saw some strange behavior\n\n[  421.739708] iwlwifi 0000:01:00.0: ACTIVATE a non DRIVER active station id 148 addr 00:00:00:00:00:00\n[  421.739719] iwlwifi 0000:01:00.0: iwl_sta_ucode_activate Added STA id 148 addr 00:00:00:00:00:00 to uCode\n\nnot sure how it happen, but adding the sanity check to prevent memory\ncorruption\n\nSigned-off-by: Wey-Yi Guy <wey-yi.w.guy@intel.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
    "before_after_code_files": [
      "drivers/net/wireless/iwlwifi/iwl-agn-sta.c||drivers/net/wireless/iwlwifi/iwl-agn-sta.c"
    ]
  },
  "patch_diff": {
    "drivers/net/wireless/iwlwifi/iwl-agn-sta.c||drivers/net/wireless/iwlwifi/iwl-agn-sta.c": [
      "File: drivers/net/wireless/iwlwifi/iwl-agn-sta.c -> drivers/net/wireless/iwlwifi/iwl-agn-sta.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "35: #include \"iwl-trans.h\"",
      "39: {",
      "41:  if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))",
      "42:   IWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"",
      "43:    \"addr %pM\\n\",",
      "",
      "[Removed Lines]",
      "38: static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)",
      "",
      "[Added Lines]",
      "38: static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)",
      "40:  if (sta_id >= IWLAGN_STATION_COUNT) {",
      "41:   IWL_ERR(priv, \"invalid sta_id %u\", sta_id);",
      "42:   return -EINVAL;",
      "43:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "53:   IWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",",
      "54:     sta_id, priv->stations[sta_id].sta.sta.addr);",
      "55:  }",
      "56: }",
      "58: static int iwl_process_add_sta_resp(struct iwl_priv *priv,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "59:  return 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "77:  switch (pkt->u.add_sta.status) {",
      "78:  case ADD_STA_SUCCESS_MSK:",
      "79:   IWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");",
      "82:   break;",
      "83:  case ADD_STA_NO_ROOM_IN_TABLE:",
      "84:   IWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",",
      "",
      "[Removed Lines]",
      "80:   iwl_sta_ucode_activate(priv, sta_id);",
      "81:   ret = 0;",
      "",
      "[Added Lines]",
      "84:   ret = iwl_sta_ucode_activate(priv, sta_id);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c745f55baf63d08d6e9bb20682102fb8bae8f67a",
      "candidate_info": {
        "commit_hash": "c745f55baf63d08d6e9bb20682102fb8bae8f67a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c745f55baf63d08d6e9bb20682102fb8bae8f67a",
        "files": [
          "drivers/net/wireless/iwlwifi/Makefile",
          "drivers/net/wireless/iwlwifi/iwl-1000.c",
          "drivers/net/wireless/iwlwifi/iwl-2000.c",
          "drivers/net/wireless/iwlwifi/iwl-5000.c",
          "drivers/net/wireless/iwlwifi/iwl-6000.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-lib.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-rs.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-rxon.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-sta.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-tx.c",
          "drivers/net/wireless/iwlwifi/iwl-agn.c",
          "drivers/net/wireless/iwlwifi/iwl-agn.h",
          "drivers/net/wireless/iwlwifi/iwl-core.c",
          "drivers/net/wireless/iwlwifi/iwl-rx.c",
          "drivers/net/wireless/iwlwifi/iwl-scan.c",
          "drivers/net/wireless/iwlwifi/iwl-sta.c",
          "drivers/net/wireless/iwlwifi/iwl-sta.h"
        ],
        "message": "iwlagn: merge station management functions\n\nAfter driver split, no need to separate station management functions\nin two files, merge it\n\nSigned-off-by: Wey-Yi Guy <wey-yi.w.guy@intel.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
        "before_after_code_files": [
          "drivers/net/wireless/iwlwifi/iwl-1000.c||drivers/net/wireless/iwlwifi/iwl-1000.c",
          "drivers/net/wireless/iwlwifi/iwl-2000.c||drivers/net/wireless/iwlwifi/iwl-2000.c",
          "drivers/net/wireless/iwlwifi/iwl-5000.c||drivers/net/wireless/iwlwifi/iwl-5000.c",
          "drivers/net/wireless/iwlwifi/iwl-6000.c||drivers/net/wireless/iwlwifi/iwl-6000.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-lib.c||drivers/net/wireless/iwlwifi/iwl-agn-lib.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-rs.c||drivers/net/wireless/iwlwifi/iwl-agn-rs.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-rxon.c||drivers/net/wireless/iwlwifi/iwl-agn-rxon.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-sta.c||drivers/net/wireless/iwlwifi/iwl-agn-sta.c",
          "drivers/net/wireless/iwlwifi/iwl-agn-tx.c||drivers/net/wireless/iwlwifi/iwl-agn-tx.c",
          "drivers/net/wireless/iwlwifi/iwl-agn.c||drivers/net/wireless/iwlwifi/iwl-agn.c",
          "drivers/net/wireless/iwlwifi/iwl-agn.h||drivers/net/wireless/iwlwifi/iwl-agn.h",
          "drivers/net/wireless/iwlwifi/iwl-core.c||drivers/net/wireless/iwlwifi/iwl-core.c",
          "drivers/net/wireless/iwlwifi/iwl-rx.c||drivers/net/wireless/iwlwifi/iwl-rx.c",
          "drivers/net/wireless/iwlwifi/iwl-scan.c||drivers/net/wireless/iwlwifi/iwl-scan.c",
          "drivers/net/wireless/iwlwifi/iwl-sta.c||drivers/net/wireless/iwlwifi/iwl-sta.c",
          "drivers/net/wireless/iwlwifi/iwl-sta.h||drivers/net/wireless/iwlwifi/iwl-sta.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/net/wireless/iwlwifi/iwl-agn-sta.c||drivers/net/wireless/iwlwifi/iwl-agn-sta.c"
          ],
          "candidate": [
            "drivers/net/wireless/iwlwifi/iwl-agn-sta.c||drivers/net/wireless/iwlwifi/iwl-agn-sta.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/iwlwifi/iwl-1000.c||drivers/net/wireless/iwlwifi/iwl-1000.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-1000.c -> drivers/net/wireless/iwlwifi/iwl-1000.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include \"iwl-dev.h\"",
          "40: #include \"iwl-core.h\"",
          "41: #include \"iwl-io.h\"",
          "43: #include \"iwl-agn.h\"",
          "44: #include \"iwl-helpers.h\"",
          "45: #include \"iwl-agn-hw.h\"",
          "",
          "[Removed Lines]",
          "42: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-2000.c||drivers/net/wireless/iwlwifi/iwl-2000.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-2000.c -> drivers/net/wireless/iwlwifi/iwl-2000.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include \"iwl-dev.h\"",
          "40: #include \"iwl-core.h\"",
          "41: #include \"iwl-io.h\"",
          "43: #include \"iwl-agn.h\"",
          "44: #include \"iwl-helpers.h\"",
          "45: #include \"iwl-agn-hw.h\"",
          "",
          "[Removed Lines]",
          "42: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-5000.c||drivers/net/wireless/iwlwifi/iwl-5000.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-5000.c -> drivers/net/wireless/iwlwifi/iwl-5000.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #include \"iwl-dev.h\"",
          "41: #include \"iwl-core.h\"",
          "42: #include \"iwl-io.h\"",
          "44: #include \"iwl-helpers.h\"",
          "45: #include \"iwl-agn.h\"",
          "46: #include \"iwl-agn-hw.h\"",
          "",
          "[Removed Lines]",
          "43: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-6000.c||drivers/net/wireless/iwlwifi/iwl-6000.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-6000.c -> drivers/net/wireless/iwlwifi/iwl-6000.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include \"iwl-dev.h\"",
          "40: #include \"iwl-core.h\"",
          "41: #include \"iwl-io.h\"",
          "43: #include \"iwl-agn.h\"",
          "44: #include \"iwl-helpers.h\"",
          "45: #include \"iwl-agn-hw.h\"",
          "",
          "[Removed Lines]",
          "42: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-agn-lib.c||drivers/net/wireless/iwlwifi/iwl-agn-lib.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-agn-lib.c -> drivers/net/wireless/iwlwifi/iwl-agn-lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #include \"iwl-helpers.h\"",
          "39: #include \"iwl-agn-hw.h\"",
          "40: #include \"iwl-agn.h\"",
          "42: #include \"iwl-trans.h\"",
          "43: #include \"iwl-shared.h\"",
          "",
          "[Removed Lines]",
          "41: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-agn-rs.c||drivers/net/wireless/iwlwifi/iwl-agn-rs.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-agn-rs.c -> drivers/net/wireless/iwlwifi/iwl-agn-rs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #include <linux/workqueue.h>",
          "38: #include \"iwl-dev.h\"",
          "40: #include \"iwl-core.h\"",
          "41: #include \"iwl-agn.h\"",
          "",
          "[Removed Lines]",
          "39: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-agn-rxon.c||drivers/net/wireless/iwlwifi/iwl-agn-rxon.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-agn-rxon.c -> drivers/net/wireless/iwlwifi/iwl-agn-rxon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"iwl-dev.h\"",
          "28: #include \"iwl-agn.h\"",
          "30: #include \"iwl-core.h\"",
          "31: #include \"iwl-agn-calib.h\"",
          "32: #include \"iwl-helpers.h\"",
          "",
          "[Removed Lines]",
          "29: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-agn-sta.c||drivers/net/wireless/iwlwifi/iwl-agn-sta.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-agn-sta.c -> drivers/net/wireless/iwlwifi/iwl-agn-sta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"iwl-dev.h\"",
          "33: #include \"iwl-core.h\"",
          "35: #include \"iwl-agn.h\"",
          "36: #include \"iwl-trans.h\"",
          "38: void iwl_sta_fill_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "39:        u8 sta_id, struct iwl_link_quality_cmd *link_cmd)",
          "40: {",
          "",
          "[Removed Lines]",
          "34: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "38: static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)",
          "39: {",
          "41:  if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))",
          "42:   IWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"",
          "43:    \"addr %pM\\n\",",
          "44:    sta_id, priv->stations[sta_id].sta.sta.addr);",
          "46:  if (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {",
          "47:   IWL_DEBUG_ASSOC(priv,",
          "48:     \"STA id %u addr %pM already present in uCode \"",
          "49:     \"(according to driver)\\n\",",
          "50:     sta_id, priv->stations[sta_id].sta.sta.addr);",
          "51:  } else {",
          "52:   priv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;",
          "53:   IWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",",
          "54:     sta_id, priv->stations[sta_id].sta.sta.addr);",
          "55:  }",
          "56: }",
          "58: static int iwl_process_add_sta_resp(struct iwl_priv *priv,",
          "59:         struct iwl_addsta_cmd *addsta,",
          "60:         struct iwl_rx_packet *pkt)",
          "61: {",
          "62:  u8 sta_id = addsta->sta.sta_id;",
          "63:  unsigned long flags;",
          "64:  int ret = -EIO;",
          "66:  if (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {",
          "67:   IWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",",
          "68:    pkt->hdr.flags);",
          "69:   return ret;",
          "70:  }",
          "72:  IWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",",
          "73:          sta_id);",
          "75:  spin_lock_irqsave(&priv->shrd->sta_lock, flags);",
          "77:  switch (pkt->u.add_sta.status) {",
          "78:  case ADD_STA_SUCCESS_MSK:",
          "79:   IWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");",
          "80:   iwl_sta_ucode_activate(priv, sta_id);",
          "81:   ret = 0;",
          "82:   break;",
          "83:  case ADD_STA_NO_ROOM_IN_TABLE:",
          "84:   IWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",",
          "85:    sta_id);",
          "86:   break;",
          "87:  case ADD_STA_NO_BLOCK_ACK_RESOURCE:",
          "88:   IWL_ERR(priv, \"Adding station %d failed, no block ack \"",
          "89:    \"resource.\\n\", sta_id);",
          "90:   break;",
          "91:  case ADD_STA_MODIFY_NON_EXIST_STA:",
          "92:   IWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",",
          "93:    sta_id);",
          "94:   break;",
          "95:  default:",
          "96:   IWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",",
          "97:     pkt->u.add_sta.status);",
          "98:   break;",
          "99:  }",
          "101:  IWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",",
          "102:          priv->stations[sta_id].sta.mode ==",
          "103:          STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",",
          "104:          sta_id, priv->stations[sta_id].sta.sta.addr);",
          "114:  IWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",",
          "115:          priv->stations[sta_id].sta.mode ==",
          "116:          STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",",
          "117:          addsta->sta.addr);",
          "118:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "120:  return ret;",
          "121: }",
          "123: int iwl_add_sta_callback(struct iwl_priv *priv, struct iwl_rx_mem_buffer *rxb,",
          "124:           struct iwl_device_cmd *cmd)",
          "125: {",
          "126:  struct iwl_rx_packet *pkt = rxb_addr(rxb);",
          "127:  struct iwl_addsta_cmd *addsta =",
          "128:   (struct iwl_addsta_cmd *) cmd->payload;",
          "130:  return iwl_process_add_sta_resp(priv, addsta, pkt);",
          "131: }",
          "133: static u16 iwlagn_build_addsta_hcmd(const struct iwl_addsta_cmd *cmd, u8 *data)",
          "134: {",
          "135:  u16 size = (u16)sizeof(struct iwl_addsta_cmd);",
          "136:  struct iwl_addsta_cmd *addsta = (struct iwl_addsta_cmd *)data;",
          "137:  memcpy(addsta, cmd, size);",
          "139:  addsta->rate_n_flags = cpu_to_le16(0);",
          "140:  return size;",
          "141: }",
          "143: int iwl_send_add_sta(struct iwl_priv *priv,",
          "144:        struct iwl_addsta_cmd *sta, u8 flags)",
          "145: {",
          "146:  int ret = 0;",
          "147:  u8 data[sizeof(*sta)];",
          "148:  struct iwl_host_cmd cmd = {",
          "149:   .id = REPLY_ADD_STA,",
          "150:   .flags = flags,",
          "151:   .data = { data, },",
          "152:  };",
          "153:  u8 sta_id __maybe_unused = sta->sta.sta_id;",
          "155:  IWL_DEBUG_INFO(priv, \"Adding sta %u (%pM) %ssynchronously\\n\",",
          "156:          sta_id, sta->sta.addr, flags & CMD_ASYNC ?  \"a\" : \"\");",
          "158:  if (!(flags & CMD_ASYNC)) {",
          "159:   cmd.flags |= CMD_WANT_SKB;",
          "160:   might_sleep();",
          "161:  }",
          "163:  cmd.len[0] = iwlagn_build_addsta_hcmd(sta, data);",
          "164:  ret = iwl_trans_send_cmd(trans(priv), &cmd);",
          "166:  if (ret || (flags & CMD_ASYNC))",
          "167:   return ret;",
          "171:  iwl_free_pages(priv->shrd, cmd.reply_page);",
          "173:  if (cmd.handler_status)",
          "174:   IWL_ERR(priv, \"%s - error in the CMD response %d\", __func__,",
          "175:    cmd.handler_status);",
          "177:  return cmd.handler_status;",
          "178: }",
          "180: static void iwl_set_ht_add_station(struct iwl_priv *priv, u8 index,",
          "181:        struct ieee80211_sta *sta,",
          "182:        struct iwl_rxon_context *ctx)",
          "183: {",
          "184:  struct ieee80211_sta_ht_cap *sta_ht_inf = &sta->ht_cap;",
          "185:  __le32 sta_flags;",
          "186:  u8 mimo_ps_mode;",
          "188:  if (!sta || !sta_ht_inf->ht_supported)",
          "189:   goto done;",
          "191:  mimo_ps_mode = (sta_ht_inf->cap & IEEE80211_HT_CAP_SM_PS) >> 2;",
          "192:  IWL_DEBUG_ASSOC(priv, \"spatial multiplexing power save mode: %s\\n\",",
          "193:    (mimo_ps_mode == WLAN_HT_CAP_SM_PS_STATIC) ?",
          "194:    \"static\" :",
          "195:    (mimo_ps_mode == WLAN_HT_CAP_SM_PS_DYNAMIC) ?",
          "196:    \"dynamic\" : \"disabled\");",
          "198:  sta_flags = priv->stations[index].sta.station_flags;",
          "200:  sta_flags &= ~(STA_FLG_RTS_MIMO_PROT_MSK | STA_FLG_MIMO_DIS_MSK);",
          "202:  switch (mimo_ps_mode) {",
          "203:  case WLAN_HT_CAP_SM_PS_STATIC:",
          "204:   sta_flags |= STA_FLG_MIMO_DIS_MSK;",
          "205:   break;",
          "206:  case WLAN_HT_CAP_SM_PS_DYNAMIC:",
          "207:   sta_flags |= STA_FLG_RTS_MIMO_PROT_MSK;",
          "208:   break;",
          "209:  case WLAN_HT_CAP_SM_PS_DISABLED:",
          "210:   break;",
          "211:  default:",
          "212:   IWL_WARN(priv, \"Invalid MIMO PS mode %d\\n\", mimo_ps_mode);",
          "213:   break;",
          "214:  }",
          "216:  sta_flags |= cpu_to_le32(",
          "217:        (u32)sta_ht_inf->ampdu_factor << STA_FLG_MAX_AGG_SIZE_POS);",
          "219:  sta_flags |= cpu_to_le32(",
          "220:        (u32)sta_ht_inf->ampdu_density << STA_FLG_AGG_MPDU_DENSITY_POS);",
          "222:  if (iwl_is_ht40_tx_allowed(priv, ctx, &sta->ht_cap))",
          "223:   sta_flags |= STA_FLG_HT40_EN_MSK;",
          "224:  else",
          "225:   sta_flags &= ~STA_FLG_HT40_EN_MSK;",
          "227:  priv->stations[index].sta.station_flags = sta_flags;",
          "228:  done:",
          "229:  return;",
          "230: }",
          "237: u8 iwl_prep_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "238:       const u8 *addr, bool is_ap, struct ieee80211_sta *sta)",
          "239: {",
          "240:  struct iwl_station_entry *station;",
          "241:  int i;",
          "242:  u8 sta_id = IWL_INVALID_STATION;",
          "244:  if (is_ap)",
          "245:   sta_id = ctx->ap_sta_id;",
          "246:  else if (is_broadcast_ether_addr(addr))",
          "247:   sta_id = ctx->bcast_sta_id;",
          "248:  else",
          "249:   for (i = IWL_STA_ID; i < IWLAGN_STATION_COUNT; i++) {",
          "250:    if (!compare_ether_addr(priv->stations[i].sta.sta.addr,",
          "251:       addr)) {",
          "252:     sta_id = i;",
          "253:     break;",
          "254:    }",
          "256:    if (!priv->stations[i].used &&",
          "257:        sta_id == IWL_INVALID_STATION)",
          "258:     sta_id = i;",
          "259:   }",
          "265:  if (unlikely(sta_id == IWL_INVALID_STATION))",
          "266:   return sta_id;",
          "273:  if (priv->stations[sta_id].used & IWL_STA_UCODE_INPROGRESS) {",
          "274:   IWL_DEBUG_INFO(priv, \"STA %d already in process of being \"",
          "275:           \"added.\\n\", sta_id);",
          "276:   return sta_id;",
          "277:  }",
          "279:  if ((priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE) &&",
          "280:      (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) &&",
          "281:      !compare_ether_addr(priv->stations[sta_id].sta.sta.addr, addr)) {",
          "282:   IWL_DEBUG_ASSOC(priv, \"STA %d (%pM) already added, not \"",
          "283:     \"adding again.\\n\", sta_id, addr);",
          "284:   return sta_id;",
          "285:  }",
          "287:  station = &priv->stations[sta_id];",
          "288:  station->used = IWL_STA_DRIVER_ACTIVE;",
          "289:  IWL_DEBUG_ASSOC(priv, \"Add STA to driver ID %d: %pM\\n\",",
          "290:    sta_id, addr);",
          "291:  priv->num_stations++;",
          "294:  memset(&station->sta, 0, sizeof(struct iwl_addsta_cmd));",
          "295:  memcpy(station->sta.sta.addr, addr, ETH_ALEN);",
          "296:  station->sta.mode = 0;",
          "297:  station->sta.sta.sta_id = sta_id;",
          "298:  station->sta.station_flags = ctx->station_flags;",
          "299:  station->ctxid = ctx->ctxid;",
          "301:  if (sta) {",
          "302:   struct iwl_station_priv *sta_priv;",
          "304:   sta_priv = (void *)sta->drv_priv;",
          "305:   sta_priv->ctx = ctx;",
          "306:  }",
          "313:  iwl_set_ht_add_station(priv, sta_id, sta, ctx);",
          "315:  return sta_id;",
          "317: }",
          "319: #define STA_WAIT_TIMEOUT (HZ/2)",
          "324: int iwl_add_station_common(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "325:       const u8 *addr, bool is_ap,",
          "326:       struct ieee80211_sta *sta, u8 *sta_id_r)",
          "327: {",
          "328:  unsigned long flags_spin;",
          "329:  int ret = 0;",
          "330:  u8 sta_id;",
          "331:  struct iwl_addsta_cmd sta_cmd;",
          "334:  spin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);",
          "335:  sta_id = iwl_prep_station(priv, ctx, addr, is_ap, sta);",
          "336:  if (sta_id == IWL_INVALID_STATION) {",
          "337:   IWL_ERR(priv, \"Unable to prepare station %pM for addition\\n\",",
          "338:    addr);",
          "339:   spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "340:   return -EINVAL;",
          "341:  }",
          "348:  if (priv->stations[sta_id].used & IWL_STA_UCODE_INPROGRESS) {",
          "349:   IWL_DEBUG_INFO(priv, \"STA %d already in process of being \"",
          "350:           \"added.\\n\", sta_id);",
          "351:   spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "352:   return -EEXIST;",
          "353:  }",
          "355:  if ((priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE) &&",
          "356:      (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE)) {",
          "357:   IWL_DEBUG_ASSOC(priv, \"STA %d (%pM) already added, not \"",
          "358:     \"adding again.\\n\", sta_id, addr);",
          "359:   spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "360:   return -EEXIST;",
          "361:  }",
          "363:  priv->stations[sta_id].used |= IWL_STA_UCODE_INPROGRESS;",
          "364:  memcpy(&sta_cmd, &priv->stations[sta_id].sta,",
          "365:         sizeof(struct iwl_addsta_cmd));",
          "366:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "369:  ret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);",
          "370:  if (ret) {",
          "371:   spin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);",
          "372:   IWL_ERR(priv, \"Adding station %pM failed.\\n\",",
          "373:    priv->stations[sta_id].sta.sta.addr);",
          "374:   priv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;",
          "375:   priv->stations[sta_id].used &= ~IWL_STA_UCODE_INPROGRESS;",
          "376:   spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "377:  }",
          "379:  return ret;",
          "380: }",
          "387: static void iwl_sta_ucode_deactivate(struct iwl_priv *priv, u8 sta_id)",
          "388: {",
          "390:  if ((priv->stations[sta_id].used &",
          "391:       (IWL_STA_UCODE_ACTIVE | IWL_STA_DRIVER_ACTIVE)) !=",
          "392:        IWL_STA_UCODE_ACTIVE)",
          "393:   IWL_ERR(priv, \"removed non active STA %u\\n\", sta_id);",
          "395:  priv->stations[sta_id].used &= ~IWL_STA_UCODE_ACTIVE;",
          "397:  memset(&priv->stations[sta_id], 0, sizeof(struct iwl_station_entry));",
          "398:  IWL_DEBUG_ASSOC(priv, \"Removed STA %u\\n\", sta_id);",
          "399: }",
          "401: static int iwl_send_remove_station(struct iwl_priv *priv,",
          "402:        const u8 *addr, int sta_id,",
          "403:        bool temporary)",
          "404: {",
          "405:  struct iwl_rx_packet *pkt;",
          "406:  int ret;",
          "408:  unsigned long flags_spin;",
          "409:  struct iwl_rem_sta_cmd rm_sta_cmd;",
          "411:  struct iwl_host_cmd cmd = {",
          "412:   .id = REPLY_REMOVE_STA,",
          "413:   .len = { sizeof(struct iwl_rem_sta_cmd), },",
          "414:   .flags = CMD_SYNC,",
          "415:   .data = { &rm_sta_cmd, },",
          "416:  };",
          "418:  memset(&rm_sta_cmd, 0, sizeof(rm_sta_cmd));",
          "419:  rm_sta_cmd.num_sta = 1;",
          "420:  memcpy(&rm_sta_cmd.addr, addr, ETH_ALEN);",
          "422:  cmd.flags |= CMD_WANT_SKB;",
          "424:  ret = iwl_trans_send_cmd(trans(priv), &cmd);",
          "426:  if (ret)",
          "427:   return ret;",
          "429:  pkt = (struct iwl_rx_packet *)cmd.reply_page;",
          "430:  if (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {",
          "431:   IWL_ERR(priv, \"Bad return from REPLY_REMOVE_STA (0x%08X)\\n\",",
          "432:      pkt->hdr.flags);",
          "433:   ret = -EIO;",
          "434:  }",
          "436:  if (!ret) {",
          "437:   switch (pkt->u.rem_sta.status) {",
          "438:   case REM_STA_SUCCESS_MSK:",
          "439:    if (!temporary) {",
          "440:     spin_lock_irqsave(&priv->shrd->sta_lock,",
          "441:      flags_spin);",
          "442:     iwl_sta_ucode_deactivate(priv, sta_id);",
          "443:     spin_unlock_irqrestore(&priv->shrd->sta_lock,",
          "444:      flags_spin);",
          "445:    }",
          "446:    IWL_DEBUG_ASSOC(priv, \"REPLY_REMOVE_STA PASSED\\n\");",
          "447:    break;",
          "448:   default:",
          "449:    ret = -EIO;",
          "450:    IWL_ERR(priv, \"REPLY_REMOVE_STA failed\\n\");",
          "451:    break;",
          "452:   }",
          "453:  }",
          "454:  iwl_free_pages(priv->shrd, cmd.reply_page);",
          "456:  return ret;",
          "457: }",
          "462: int iwl_remove_station(struct iwl_priv *priv, const u8 sta_id,",
          "463:          const u8 *addr)",
          "464: {",
          "465:  unsigned long flags;",
          "467:  if (!iwl_is_ready(priv->shrd)) {",
          "468:   IWL_DEBUG_INFO(priv,",
          "469:    \"Unable to remove station %pM, device not ready.\\n\",",
          "470:    addr);",
          "476:   return 0;",
          "477:  }",
          "479:  IWL_DEBUG_ASSOC(priv, \"Removing STA from driver:%d  %pM\\n\",",
          "480:    sta_id, addr);",
          "482:  if (WARN_ON(sta_id == IWL_INVALID_STATION))",
          "483:   return -EINVAL;",
          "485:  spin_lock_irqsave(&priv->shrd->sta_lock, flags);",
          "487:  if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE)) {",
          "488:   IWL_DEBUG_INFO(priv, \"Removing %pM but non DRIVER active\\n\",",
          "489:     addr);",
          "490:   goto out_err;",
          "491:  }",
          "493:  if (!(priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE)) {",
          "494:   IWL_DEBUG_INFO(priv, \"Removing %pM but non UCODE active\\n\",",
          "495:     addr);",
          "496:   goto out_err;",
          "497:  }",
          "499:  if (priv->stations[sta_id].used & IWL_STA_LOCAL) {",
          "500:   kfree(priv->stations[sta_id].lq);",
          "501:   priv->stations[sta_id].lq = NULL;",
          "502:  }",
          "504:  priv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;",
          "506:  priv->num_stations--;",
          "508:  if (WARN_ON(priv->num_stations < 0))",
          "509:   priv->num_stations = 0;",
          "511:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "513:  return iwl_send_remove_station(priv, addr, sta_id, false);",
          "514: out_err:",
          "515:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "516:  return -EINVAL;",
          "517: }",
          "527: void iwl_clear_ucode_stations(struct iwl_priv *priv,",
          "528:          struct iwl_rxon_context *ctx)",
          "529: {",
          "530:  int i;",
          "531:  unsigned long flags_spin;",
          "532:  bool cleared = false;",
          "534:  IWL_DEBUG_INFO(priv, \"Clearing ucode stations in driver\\n\");",
          "536:  spin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);",
          "537:  for (i = 0; i < IWLAGN_STATION_COUNT; i++) {",
          "538:   if (ctx && ctx->ctxid != priv->stations[i].ctxid)",
          "539:    continue;",
          "541:   if (priv->stations[i].used & IWL_STA_UCODE_ACTIVE) {",
          "542:    IWL_DEBUG_INFO(priv,",
          "543:     \"Clearing ucode active for station %d\\n\", i);",
          "544:    priv->stations[i].used &= ~IWL_STA_UCODE_ACTIVE;",
          "545:    cleared = true;",
          "546:   }",
          "547:  }",
          "548:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "550:  if (!cleared)",
          "551:   IWL_DEBUG_INFO(priv,",
          "552:           \"No active stations found to be cleared\\n\");",
          "553: }",
          "563: void iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx)",
          "564: {",
          "565:  struct iwl_addsta_cmd sta_cmd;",
          "566:  struct iwl_link_quality_cmd lq;",
          "567:  unsigned long flags_spin;",
          "568:  int i;",
          "569:  bool found = false;",
          "570:  int ret;",
          "571:  bool send_lq;",
          "573:  if (!iwl_is_ready(priv->shrd)) {",
          "574:   IWL_DEBUG_INFO(priv,",
          "575:           \"Not ready yet, not restoring any stations.\\n\");",
          "576:   return;",
          "577:  }",
          "579:  IWL_DEBUG_ASSOC(priv, \"Restoring all known stations ... start.\\n\");",
          "580:  spin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);",
          "581:  for (i = 0; i < IWLAGN_STATION_COUNT; i++) {",
          "582:   if (ctx->ctxid != priv->stations[i].ctxid)",
          "583:    continue;",
          "584:   if ((priv->stations[i].used & IWL_STA_DRIVER_ACTIVE) &&",
          "585:        !(priv->stations[i].used & IWL_STA_UCODE_ACTIVE)) {",
          "586:    IWL_DEBUG_ASSOC(priv, \"Restoring sta %pM\\n\",",
          "587:      priv->stations[i].sta.sta.addr);",
          "588:    priv->stations[i].sta.mode = 0;",
          "589:    priv->stations[i].used |= IWL_STA_UCODE_INPROGRESS;",
          "590:    found = true;",
          "591:   }",
          "592:  }",
          "594:  for (i = 0; i < IWLAGN_STATION_COUNT; i++) {",
          "595:   if ((priv->stations[i].used & IWL_STA_UCODE_INPROGRESS)) {",
          "596:    memcpy(&sta_cmd, &priv->stations[i].sta,",
          "597:           sizeof(struct iwl_addsta_cmd));",
          "598:    send_lq = false;",
          "599:    if (priv->stations[i].lq) {",
          "600:     if (priv->shrd->wowlan)",
          "601:      iwl_sta_fill_lq(priv, ctx, i, &lq);",
          "602:     else",
          "603:      memcpy(&lq, priv->stations[i].lq,",
          "604:             sizeof(struct iwl_link_quality_cmd));",
          "605:     send_lq = true;",
          "606:    }",
          "607:    spin_unlock_irqrestore(&priv->shrd->sta_lock,",
          "608:             flags_spin);",
          "609:    ret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);",
          "610:    if (ret) {",
          "611:     spin_lock_irqsave(&priv->shrd->sta_lock,",
          "612:         flags_spin);",
          "613:     IWL_ERR(priv, \"Adding station %pM failed.\\n\",",
          "614:      priv->stations[i].sta.sta.addr);",
          "615:     priv->stations[i].used &=",
          "616:       ~IWL_STA_DRIVER_ACTIVE;",
          "617:     priv->stations[i].used &=",
          "618:       ~IWL_STA_UCODE_INPROGRESS;",
          "619:     spin_unlock_irqrestore(&priv->shrd->sta_lock,",
          "620:              flags_spin);",
          "621:    }",
          "626:    if (send_lq)",
          "627:     iwl_send_lq_cmd(priv, ctx, &lq,",
          "628:       CMD_SYNC, true);",
          "629:    spin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);",
          "630:    priv->stations[i].used &= ~IWL_STA_UCODE_INPROGRESS;",
          "631:   }",
          "632:  }",
          "634:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "635:  if (!found)",
          "636:   IWL_DEBUG_INFO(priv, \"Restoring all known stations .... \"",
          "637:    \"no stations to be restored.\\n\");",
          "638:  else",
          "639:   IWL_DEBUG_INFO(priv, \"Restoring all known stations .... \"",
          "640:    \"complete.\\n\");",
          "641: }",
          "643: void iwl_reprogram_ap_sta(struct iwl_priv *priv, struct iwl_rxon_context *ctx)",
          "644: {",
          "645:  unsigned long flags;",
          "646:  int sta_id = ctx->ap_sta_id;",
          "647:  int ret;",
          "648:  struct iwl_addsta_cmd sta_cmd;",
          "649:  struct iwl_link_quality_cmd lq;",
          "650:  bool active;",
          "652:  spin_lock_irqsave(&priv->shrd->sta_lock, flags);",
          "653:  if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE)) {",
          "654:   spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "655:   return;",
          "656:  }",
          "658:  memcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));",
          "659:  sta_cmd.mode = 0;",
          "660:  memcpy(&lq, priv->stations[sta_id].lq, sizeof(lq));",
          "662:  active = priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE;",
          "663:  priv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;",
          "664:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "666:  if (active) {",
          "667:   ret = iwl_send_remove_station(",
          "668:    priv, priv->stations[sta_id].sta.sta.addr,",
          "669:    sta_id, true);",
          "670:   if (ret)",
          "671:    IWL_ERR(priv, \"failed to remove STA %pM (%d)\\n\",",
          "672:     priv->stations[sta_id].sta.sta.addr, ret);",
          "673:  }",
          "674:  spin_lock_irqsave(&priv->shrd->sta_lock, flags);",
          "675:  priv->stations[sta_id].used |= IWL_STA_DRIVER_ACTIVE;",
          "676:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "678:  ret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);",
          "679:  if (ret)",
          "680:   IWL_ERR(priv, \"failed to re-add STA %pM (%d)\\n\",",
          "681:    priv->stations[sta_id].sta.sta.addr, ret);",
          "682:  iwl_send_lq_cmd(priv, ctx, &lq, CMD_SYNC, true);",
          "683: }",
          "685: int iwl_get_free_ucode_key_offset(struct iwl_priv *priv)",
          "686: {",
          "687:  int i;",
          "689:  for (i = 0; i < priv->sta_key_max_num; i++)",
          "690:   if (!test_and_set_bit(i, &priv->ucode_key_table))",
          "691:    return i;",
          "693:  return WEP_INVALID_OFFSET;",
          "694: }",
          "696: void iwl_dealloc_bcast_stations(struct iwl_priv *priv)",
          "697: {",
          "698:  unsigned long flags;",
          "699:  int i;",
          "701:  spin_lock_irqsave(&priv->shrd->sta_lock, flags);",
          "702:  for (i = 0; i < IWLAGN_STATION_COUNT; i++) {",
          "703:   if (!(priv->stations[i].used & IWL_STA_BCAST))",
          "704:    continue;",
          "706:   priv->stations[i].used &= ~IWL_STA_UCODE_ACTIVE;",
          "707:   priv->num_stations--;",
          "708:   if (WARN_ON(priv->num_stations < 0))",
          "709:    priv->num_stations = 0;",
          "710:   kfree(priv->stations[i].lq);",
          "711:   priv->stations[i].lq = NULL;",
          "712:  }",
          "713:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "714: }",
          "716: #ifdef CONFIG_IWLWIFI_DEBUG",
          "717: static void iwl_dump_lq_cmd(struct iwl_priv *priv,",
          "718:       struct iwl_link_quality_cmd *lq)",
          "719: {",
          "720:  int i;",
          "721:  IWL_DEBUG_RATE(priv, \"lq station id 0x%x\\n\", lq->sta_id);",
          "722:  IWL_DEBUG_RATE(priv, \"lq ant 0x%X 0x%X\\n\",",
          "723:          lq->general_params.single_stream_ant_msk,",
          "724:          lq->general_params.dual_stream_ant_msk);",
          "726:  for (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)",
          "727:   IWL_DEBUG_RATE(priv, \"lq index %d 0x%X\\n\",",
          "728:           i, lq->rs_table[i].rate_n_flags);",
          "729: }",
          "730: #else",
          "731: static inline void iwl_dump_lq_cmd(struct iwl_priv *priv,",
          "732:        struct iwl_link_quality_cmd *lq)",
          "733: {",
          "734: }",
          "735: #endif",
          "748: static bool is_lq_table_valid(struct iwl_priv *priv,",
          "749:          struct iwl_rxon_context *ctx,",
          "750:          struct iwl_link_quality_cmd *lq)",
          "751: {",
          "752:  int i;",
          "754:  if (ctx->ht.enabled)",
          "755:   return true;",
          "757:  IWL_DEBUG_INFO(priv, \"Channel %u is not an HT channel\\n\",",
          "758:          ctx->active.channel);",
          "759:  for (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {",
          "760:   if (le32_to_cpu(lq->rs_table[i].rate_n_flags) &",
          "761:       RATE_MCS_HT_MSK) {",
          "762:    IWL_DEBUG_INFO(priv,",
          "763:            \"index %d of LQ expects HT channel\\n\",",
          "764:            i);",
          "765:    return false;",
          "766:   }",
          "767:  }",
          "768:  return true;",
          "769: }",
          "781: int iwl_send_lq_cmd(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "782:       struct iwl_link_quality_cmd *lq, u8 flags, bool init)",
          "783: {",
          "784:  int ret = 0;",
          "785:  unsigned long flags_spin;",
          "787:  struct iwl_host_cmd cmd = {",
          "788:   .id = REPLY_TX_LINK_QUALITY_CMD,",
          "789:   .len = { sizeof(struct iwl_link_quality_cmd), },",
          "790:   .flags = flags,",
          "791:   .data = { lq, },",
          "792:  };",
          "794:  if (WARN_ON(lq->sta_id == IWL_INVALID_STATION))",
          "795:   return -EINVAL;",
          "798:  spin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);",
          "799:  if (!(priv->stations[lq->sta_id].used & IWL_STA_DRIVER_ACTIVE)) {",
          "800:   spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "801:   return -EINVAL;",
          "802:  }",
          "803:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "805:  iwl_dump_lq_cmd(priv, lq);",
          "806:  if (WARN_ON(init && (cmd.flags & CMD_ASYNC)))",
          "807:   return -EINVAL;",
          "809:  if (is_lq_table_valid(priv, ctx, lq))",
          "810:   ret = iwl_trans_send_cmd(trans(priv), &cmd);",
          "811:  else",
          "812:   ret = -EINVAL;",
          "814:  if (cmd.flags & CMD_ASYNC)",
          "815:   return ret;",
          "817:  if (init) {",
          "818:   IWL_DEBUG_INFO(priv, \"init LQ command complete, \"",
          "819:           \"clearing sta addition status for sta %d\\n\",",
          "820:           lq->sta_id);",
          "821:   spin_lock_irqsave(&priv->shrd->sta_lock, flags_spin);",
          "822:   priv->stations[lq->sta_id].used &= ~IWL_STA_UCODE_INPROGRESS;",
          "823:   spin_unlock_irqrestore(&priv->shrd->sta_lock, flags_spin);",
          "824:  }",
          "825:  return ret;",
          "826: }",
          "828: int iwlagn_mac_sta_remove(struct ieee80211_hw *hw,",
          "829:          struct ieee80211_vif *vif,",
          "830:          struct ieee80211_sta *sta)",
          "831: {",
          "832:  struct iwl_priv *priv = hw->priv;",
          "833:  struct iwl_station_priv *sta_priv = (void *)sta->drv_priv;",
          "834:  int ret;",
          "836:  IWL_DEBUG_MAC80211(priv, \"enter: received request to remove \"",
          "837:       \"station %pM\\n\", sta->addr);",
          "838:  mutex_lock(&priv->shrd->mutex);",
          "839:  IWL_DEBUG_INFO(priv, \"proceeding to remove station %pM\\n\",",
          "840:    sta->addr);",
          "841:  ret = iwl_remove_station(priv, sta_priv->sta_id, sta->addr);",
          "842:  if (ret)",
          "843:   IWL_ERR(priv, \"Error removing station %pM\\n\",",
          "844:    sta->addr);",
          "845:  mutex_unlock(&priv->shrd->mutex);",
          "846:  IWL_DEBUG_MAC80211(priv, \"leave\\n\");",
          "848:  return ret;",
          "849: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:    hw_params(priv).valid_tx_ant;",
          "78:  }",
          "81:  link_cmd->agg_params.agg_time_limit =",
          "82:   cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);",
          "",
          "[Removed Lines]",
          "80:  link_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;",
          "",
          "[Added Lines]",
          "893:  link_cmd->agg_params.agg_dis_start_th =",
          "894:   LINK_QUAL_AGG_DISABLE_START_DEF;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85: }",
          "87: static struct iwl_link_quality_cmd *",
          "89: {",
          "90:  struct iwl_link_quality_cmd *link_cmd;",
          "",
          "[Removed Lines]",
          "88: iwl_sta_alloc_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx, u8 sta_id)",
          "",
          "[Added Lines]",
          "902: iwl_sta_alloc_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "903:    u8 sta_id)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "109:         const u8 *addr, u8 *sta_id_r)",
          "110: {",
          "111:  int ret;",
          "",
          "[Removed Lines]",
          "108: int iwlagn_add_bssid_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "",
          "[Added Lines]",
          "923: int iwlagn_add_bssid_station(struct iwl_priv *priv,",
          "924:         struct iwl_rxon_context *ctx,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:  link_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);",
          "134:  if (!link_cmd) {",
          "136:    addr);",
          "137:   return -ENOMEM;",
          "138:  }",
          "",
          "[Removed Lines]",
          "135:   IWL_ERR(priv, \"Unable to initialize rate scaling for station %pM.\\n\",",
          "",
          "[Added Lines]",
          "951:   IWL_ERR(priv,",
          "952:    \"Unable to initialize rate scaling for station %pM.\\n\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "225:  memset(&ctx->wep_keys[keyconf->keyidx], 0, sizeof(ctx->wep_keys[0]));",
          "226:  if (iwl_is_rfkill(priv->shrd)) {",
          "229:   return 0;",
          "230:  }",
          "",
          "[Removed Lines]",
          "227:   IWL_DEBUG_WEP(priv, \"Not sending REPLY_WEPKEY command due to RFKILL.\\n\");",
          "",
          "[Added Lines]",
          "1044:   IWL_DEBUG_WEP(priv,",
          "1045:    \"Not sending REPLY_WEPKEY command due to RFKILL.\\n\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "246:  if (keyconf->keylen != WEP_KEY_LEN_128 &&",
          "247:      keyconf->keylen != WEP_KEY_LEN_64) {",
          "249:   return -EINVAL;",
          "250:  }",
          "",
          "[Removed Lines]",
          "248:   IWL_DEBUG_WEP(priv, \"Bad WEP key length %d\\n\", keyconf->keylen);",
          "",
          "[Added Lines]",
          "1066:   IWL_DEBUG_WEP(priv,",
          "1067:          \"Bad WEP key length %d\\n\", keyconf->keylen);",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-agn-tx.c||drivers/net/wireless/iwlwifi/iwl-agn-tx.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-agn-tx.c -> drivers/net/wireless/iwlwifi/iwl-agn-tx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #include \"iwl-dev.h\"",
          "37: #include \"iwl-core.h\"",
          "39: #include \"iwl-io.h\"",
          "40: #include \"iwl-helpers.h\"",
          "41: #include \"iwl-agn-hw.h\"",
          "",
          "[Removed Lines]",
          "38: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-agn.c||drivers/net/wireless/iwlwifi/iwl-agn.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-agn.c -> drivers/net/wireless/iwlwifi/iwl-agn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #include \"iwl-core.h\"",
          "49: #include \"iwl-io.h\"",
          "50: #include \"iwl-helpers.h\"",
          "52: #include \"iwl-agn-calib.h\"",
          "53: #include \"iwl-agn.h\"",
          "54: #include \"iwl-shared.h\"",
          "",
          "[Removed Lines]",
          "51: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-agn.h||drivers/net/wireless/iwlwifi/iwl-agn.h": [
          "File: drivers/net/wireless/iwlwifi/iwl-agn.h -> drivers/net/wireless/iwlwifi/iwl-agn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "152: void iwlagn_post_scan(struct iwl_priv *priv);",
          "153: void iwlagn_disable_roc(struct iwl_priv *priv);",
          "160: void iwlagn_send_advance_bt_config(struct iwl_priv *priv);",
          "161: int iwlagn_bt_coex_profile_notif(struct iwl_priv *priv,",
          "",
          "[Removed Lines]",
          "156: int iwlagn_manage_ibss_station(struct iwl_priv *priv,",
          "157:           struct ieee80211_vif *vif, bool add);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "175: static inline const char *iwl_get_agg_tx_fail_reason(u16 status) { return \"\"; }",
          "176: #endif",
          "179: int iwlagn_alloc_bcast_station(struct iwl_priv *priv,",
          "180:           struct iwl_rxon_context *ctx);",
          "181: int iwlagn_add_bssid_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176: int iwlagn_manage_ibss_station(struct iwl_priv *priv,",
          "177:           struct ieee80211_vif *vif, bool add);",
          "180: #define IWL_STA_UCODE_INPROGRESS  BIT(2) /* ucode entry is in process of",
          "182: #define IWL_STA_LOCAL BIT(3) /* station state not directed by mac80211;",
          "187: void iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx);",
          "188: void iwl_clear_ucode_stations(struct iwl_priv *priv,",
          "189:          struct iwl_rxon_context *ctx);",
          "190: void iwl_dealloc_bcast_stations(struct iwl_priv *priv);",
          "191: int iwl_get_free_ucode_key_offset(struct iwl_priv *priv);",
          "192: int iwl_send_add_sta(struct iwl_priv *priv,",
          "193:        struct iwl_addsta_cmd *sta, u8 flags);",
          "194: int iwl_add_station_common(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "195:       const u8 *addr, bool is_ap,",
          "196:       struct ieee80211_sta *sta, u8 *sta_id_r);",
          "197: int iwl_remove_station(struct iwl_priv *priv, const u8 sta_id,",
          "198:          const u8 *addr);",
          "199: int iwlagn_mac_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,",
          "200:          struct ieee80211_sta *sta);",
          "202: u8 iwl_prep_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "203:       const u8 *addr, bool is_ap, struct ieee80211_sta *sta);",
          "205: void iwl_sta_fill_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "206:        u8 sta_id, struct iwl_link_quality_cmd *link_cmd);",
          "207: int iwl_send_lq_cmd(struct iwl_priv *priv, struct iwl_rxon_context *ctx,",
          "208:       struct iwl_link_quality_cmd *lq, u8 flags, bool init);",
          "209: void iwl_reprogram_ap_sta(struct iwl_priv *priv, struct iwl_rxon_context *ctx);",
          "210: int iwl_add_sta_callback(struct iwl_priv *priv, struct iwl_rx_mem_buffer *rxb,",
          "211:           struct iwl_device_cmd *cmd);",
          "223: static inline void iwl_clear_driver_stations(struct iwl_priv *priv)",
          "224: {",
          "225:  unsigned long flags;",
          "226:  struct iwl_rxon_context *ctx;",
          "228:  spin_lock_irqsave(&priv->shrd->sta_lock, flags);",
          "229:  memset(priv->stations, 0, sizeof(priv->stations));",
          "230:  priv->num_stations = 0;",
          "232:  priv->ucode_key_table = 0;",
          "234:  for_each_context(priv, ctx) {",
          "242:   memset(ctx->wep_keys, 0, sizeof(ctx->wep_keys));",
          "243:   ctx->key_mapping_keys = 0;",
          "244:  }",
          "246:  spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);",
          "247: }",
          "249: static inline int iwl_sta_id(struct ieee80211_sta *sta)",
          "250: {",
          "251:  if (WARN_ON(!sta))",
          "252:   return IWL_INVALID_STATION;",
          "254:  return ((struct iwl_station_priv *)sta->drv_priv)->sta_id;",
          "255: }",
          "268: static inline int iwl_sta_id_or_broadcast(struct iwl_priv *priv,",
          "269:        struct iwl_rxon_context *context,",
          "270:        struct ieee80211_sta *sta)",
          "271: {",
          "272:  int sta_id;",
          "274:  if (!sta)",
          "275:   return context->bcast_sta_id;",
          "277:  sta_id = iwl_sta_id(sta);",
          "283:  WARN_ON(sta_id == IWL_INVALID_STATION);",
          "285:  return sta_id;",
          "286: }",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-core.c||drivers/net/wireless/iwlwifi/iwl-core.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-core.c -> drivers/net/wireless/iwlwifi/iwl-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include \"iwl-core.h\"",
          "40: #include \"iwl-io.h\"",
          "41: #include \"iwl-power.h\"",
          "43: #include \"iwl-agn.h\"",
          "44: #include \"iwl-helpers.h\"",
          "45: #include \"iwl-shared.h\"",
          "",
          "[Removed Lines]",
          "42: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-rx.c||drivers/net/wireless/iwlwifi/iwl-rx.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-rx.c -> drivers/net/wireless/iwlwifi/iwl-rx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #include \"iwl-eeprom.h\"",
          "36: #include \"iwl-dev.h\"",
          "37: #include \"iwl-core.h\"",
          "39: #include \"iwl-io.h\"",
          "40: #include \"iwl-helpers.h\"",
          "41: #include \"iwl-agn-calib.h\"",
          "",
          "[Removed Lines]",
          "38: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-scan.c||drivers/net/wireless/iwlwifi/iwl-scan.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-scan.c -> drivers/net/wireless/iwlwifi/iwl-scan.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include \"iwl-eeprom.h\"",
          "34: #include \"iwl-dev.h\"",
          "35: #include \"iwl-core.h\"",
          "37: #include \"iwl-io.h\"",
          "38: #include \"iwl-helpers.h\"",
          "39: #include \"iwl-agn.h\"",
          "",
          "[Removed Lines]",
          "36: #include \"iwl-sta.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-sta.c||drivers/net/wireless/iwlwifi/iwl-sta.c": [
          "File: drivers/net/wireless/iwlwifi/iwl-sta.c -> drivers/net/wireless/iwlwifi/iwl-sta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/iwlwifi/iwl-sta.h||drivers/net/wireless/iwlwifi/iwl-sta.h": [
          "File: drivers/net/wireless/iwlwifi/iwl-sta.h -> drivers/net/wireless/iwlwifi/iwl-sta.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
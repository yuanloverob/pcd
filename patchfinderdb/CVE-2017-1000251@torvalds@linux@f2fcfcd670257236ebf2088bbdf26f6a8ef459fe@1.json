{
  "cve_id": "CVE-2017-1000251",
  "cve_desc": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.",
  "repo": "torvalds/linux",
  "patch_hash": "f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
  "patch_info": {
    "commit_hash": "f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
    "files": [
      "include/net/bluetooth/l2cap.h",
      "net/bluetooth/l2cap.c"
    ],
    "message": "Bluetooth: Add configuration support for ERTM and Streaming mode\n\nAdd support to config_req and config_rsp to configure ERTM and Streaming\nmode. If the remote device specifies ERTM or Streaming mode, then the\nsame mode is proposed. Otherwise ERTM or Basic mode is used. And in case\nof a state 2 device, the remote device should propose the same mode. If\nnot, then the channel gets disconnected.\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
    "before_after_code_files": [
      "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
      "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
    ]
  },
  "patch_diff": {
    "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
      "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #define L2CAP_DEFAULT_MTU  672",
      "30: #define L2CAP_DEFAULT_FLUSH_TO  0xffff",
      "32: #define L2CAP_DEFAULT_MAX_RECEIVE 1",
      "",
      "[Removed Lines]",
      "31: #define L2CAP_DEFAULT_RX_WINDOW  1",
      "",
      "[Added Lines]",
      "30: #define L2CAP_DEFAULT_MIN_MTU  48",
      "32: #define L2CAP_DEFAULT_TX_WINDOW  1",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "272:  __u16  omtu;",
      "273:  __u16  flush_to;",
      "274:  __u8  mode;",
      "275:  __u8  fcs;",
      "276:  __u8  sec_level;",
      "277:  __u8  role_switch;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "276:  __u8  num_conf_req;",
      "277:  __u8  num_conf_rsp;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "280:  __u8  conf_req[64];",
      "281:  __u8  conf_len;",
      "282:  __u8  conf_state;",
      "285:  __u8  ident;",
      "287:  __le16  sport;",
      "289:  struct l2cap_conn *conn;",
      "",
      "[Removed Lines]",
      "283:  __u8  conf_retry;",
      "",
      "[Added Lines]",
      "290:  __u8  remote_tx_win;",
      "291:  __u8  remote_max_tx;",
      "292:  __u16  retrans_timeout;",
      "293:  __u16  monitor_timeout;",
      "294:  __u16  max_pdu_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "291:  struct sock  *prev_c;",
      "292: };",
      "301: void l2cap_load(void);",
      "",
      "[Removed Lines]",
      "294: #define L2CAP_CONF_REQ_SENT 0x01",
      "295: #define L2CAP_CONF_INPUT_DONE 0x02",
      "296: #define L2CAP_CONF_OUTPUT_DONE 0x04",
      "297: #define L2CAP_CONF_CONNECT_PEND 0x80",
      "299: #define L2CAP_CONF_MAX_RETRIES 2",
      "",
      "[Added Lines]",
      "303: #define L2CAP_CONF_REQ_SENT       0x01",
      "304: #define L2CAP_CONF_INPUT_DONE     0x02",
      "305: #define L2CAP_CONF_OUTPUT_DONE    0x04",
      "306: #define L2CAP_CONF_MTU_DONE       0x08",
      "307: #define L2CAP_CONF_MODE_DONE      0x10",
      "308: #define L2CAP_CONF_CONNECT_PEND   0x20",
      "309: #define L2CAP_CONF_STATE2_DEVICE  0x80",
      "311: #define L2CAP_CONF_MAX_CONF_REQ 2",
      "312: #define L2CAP_CONF_MAX_CONF_RSP 2",
      "",
      "---------------"
    ],
    "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
      "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "966:  case L2CAP_MODE_BASIC:",
      "967:   break;",
      "968:  case L2CAP_MODE_ERTM:",
      "969:   if (enable_ertm)",
      "970:    break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "969:  case L2CAP_MODE_STREAMING:",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1029:  case L2CAP_MODE_BASIC:",
      "1030:   break;",
      "1031:  case L2CAP_MODE_ERTM:",
      "1032:   if (enable_ertm)",
      "1033:    break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1033:  case L2CAP_MODE_STREAMING:",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1740: }",
      "1742: static int l2cap_build_conf_req(struct sock *sk, void *data)",
      "1743: {",
      "1744:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
      "1745:  struct l2cap_conf_req *req = data;",
      "1747:  void *ptr = req->data;",
      "1749:  BT_DBG(\"sk %p\", sk);",
      "1751:  switch (pi->mode) {",
      "1752:  case L2CAP_MODE_BASIC:",
      "1753:   if (pi->imtu != L2CAP_DEFAULT_MTU)",
      "",
      "[Removed Lines]",
      "1746:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };",
      "",
      "[Added Lines]",
      "1744: static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)",
      "1745: {",
      "1746:  u32 local_feat_mask = l2cap_feat_mask;",
      "1747:  if (enable_ertm)",
      "1748:   local_feat_mask |= L2CAP_FEAT_ERTM;",
      "1750:  switch (mode) {",
      "1751:  case L2CAP_MODE_ERTM:",
      "1752:   return L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;",
      "1753:  case L2CAP_MODE_STREAMING:",
      "1754:   return L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;",
      "1755:  default:",
      "1756:   return 0x00;",
      "1757:  }",
      "1758: }",
      "1760: static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)",
      "1761: {",
      "1762:  switch (mode) {",
      "1763:  case L2CAP_MODE_STREAMING:",
      "1764:  case L2CAP_MODE_ERTM:",
      "1765:   if (l2cap_mode_supported(mode, remote_feat_mask))",
      "1766:    return mode;",
      "1768:  default:",
      "1769:   return L2CAP_MODE_BASIC;",
      "1770:  }",
      "1771: }",
      "1777:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_ERTM };",
      "1782:  if (pi->num_conf_req || pi->num_conf_rsp)",
      "1783:   goto done;",
      "1785:  switch (pi->mode) {",
      "1786:  case L2CAP_MODE_STREAMING:",
      "1787:  case L2CAP_MODE_ERTM:",
      "1788:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
      "1789:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) {",
      "1790:    struct l2cap_disconn_req req;",
      "1791:    req.dcid = cpu_to_le16(pi->dcid);",
      "1792:    req.scid = cpu_to_le16(pi->scid);",
      "1793:    l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn),",
      "1794:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "1795:   }",
      "1796:   break;",
      "1797:  default:",
      "1798:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
      "1799:   break;",
      "1800:  }",
      "1802: done:",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1757:  case L2CAP_MODE_ERTM:",
      "1758:   rfc.mode            = L2CAP_MODE_ERTM;",
      "1760:   rfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;",
      "1763:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
      "1765:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "",
      "[Removed Lines]",
      "1759:   rfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;",
      "1761:   rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);",
      "1762:   rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);",
      "",
      "[Added Lines]",
      "1811:   rfc.txwin_size      = L2CAP_DEFAULT_TX_WINDOW;",
      "1813:   rfc.retrans_timeout = 0;",
      "1814:   rfc.monitor_timeout = 0;",
      "1815:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
      "1817:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1818:      sizeof(rfc), (unsigned long) &rfc);",
      "1819:   break;",
      "1821:  case L2CAP_MODE_STREAMING:",
      "1822:   rfc.mode            = L2CAP_MODE_STREAMING;",
      "1823:   rfc.txwin_size      = 0;",
      "1824:   rfc.max_transmit    = 0;",
      "1825:   rfc.retrans_timeout = 0;",
      "1826:   rfc.monitor_timeout = 0;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1825:   }",
      "1826:  }",
      "1828:  if (result == L2CAP_CONF_SUCCESS) {",
      "1842:    result = L2CAP_CONF_UNACCEPT;",
      "1844:    memset(&rfc, 0, sizeof(rfc));",
      "1848:      sizeof(rfc), (unsigned long) &rfc);",
      "1852:  rsp->scid   = cpu_to_le16(pi->dcid);",
      "1853:  rsp->result = cpu_to_le16(result);",
      "1854:  rsp->flags  = cpu_to_le16(0x0000);",
      "",
      "[Removed Lines]",
      "1832:   if (rfc.mode == L2CAP_MODE_BASIC) {",
      "1833:    if (mtu < pi->omtu)",
      "1834:     result = L2CAP_CONF_UNACCEPT;",
      "1835:    else {",
      "1836:     pi->omtu = mtu;",
      "1837:     pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;",
      "1838:    }",
      "1840:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1841:   } else {",
      "1845:    rfc.mode = L2CAP_MODE_BASIC;",
      "1847:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1849:   }",
      "1850:  }",
      "",
      "[Added Lines]",
      "1892:  if (pi->num_conf_rsp || pi->num_conf_req)",
      "1893:   goto done;",
      "1895:  switch (pi->mode) {",
      "1896:  case L2CAP_MODE_STREAMING:",
      "1897:  case L2CAP_MODE_ERTM:",
      "1898:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
      "1899:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
      "1900:    return -ECONNREFUSED;",
      "1901:   break;",
      "1902:  default:",
      "1903:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
      "1904:   break;",
      "1905:  }",
      "1907: done:",
      "1908:  if (pi->mode != rfc.mode) {",
      "1909:   result = L2CAP_CONF_UNACCEPT;",
      "1910:   rfc.mode = pi->mode;",
      "1912:   if (pi->num_conf_rsp == 1)",
      "1913:    return -ECONNREFUSED;",
      "1915:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1916:      sizeof(rfc), (unsigned long) &rfc);",
      "1917:  }",
      "1924:   if (mtu < L2CAP_DEFAULT_MIN_MTU)",
      "1925:    result = L2CAP_CONF_UNACCEPT;",
      "1926:   else {",
      "1927:    pi->omtu = mtu;",
      "1928:    pi->conf_state |= L2CAP_CONF_MTU_DONE;",
      "1929:   }",
      "1930:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1932:   switch (rfc.mode) {",
      "1933:   case L2CAP_MODE_BASIC:",
      "1934:    pi->fcs = L2CAP_FCS_NONE;",
      "1935:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1936:    break;",
      "1938:   case L2CAP_MODE_ERTM:",
      "1939:    pi->remote_tx_win = rfc.txwin_size;",
      "1940:    pi->remote_max_tx = rfc.max_transmit;",
      "1941:    pi->max_pdu_size = rfc.max_pdu_size;",
      "1943:    rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;",
      "1944:    rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;",
      "1946:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1947:    break;",
      "1949:   case L2CAP_MODE_STREAMING:",
      "1950:    pi->remote_tx_win = rfc.txwin_size;",
      "1951:    pi->max_pdu_size = rfc.max_pdu_size;",
      "1953:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1954:    break;",
      "1956:   default:",
      "1960:    rfc.mode = pi->mode;",
      "1961:   }",
      "1963:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1966:   if (result == L2CAP_CONF_SUCCESS)",
      "1967:    pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;",
      "1968:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1856:  return ptr - data;",
      "1857: }",
      "1859: static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)",
      "1860: {",
      "1861:  struct l2cap_conf_rsp *rsp = data;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1976: static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)",
      "1977: {",
      "1978:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
      "1979:  struct l2cap_conf_req *req = data;",
      "1980:  void *ptr = req->data;",
      "1981:  int type, olen;",
      "1982:  unsigned long val;",
      "1983:  struct l2cap_conf_rfc rfc;",
      "1985:  BT_DBG(\"sk %p, rsp %p, len %d, req %p\", sk, rsp, len, data);",
      "1987:  while (len >= L2CAP_CONF_OPT_SIZE) {",
      "1988:   len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);",
      "1990:   switch (type) {",
      "1991:   case L2CAP_CONF_MTU:",
      "1992:    if (val < L2CAP_DEFAULT_MIN_MTU) {",
      "1994:     pi->omtu = L2CAP_DEFAULT_MIN_MTU;",
      "1995:    } else",
      "1996:     pi->omtu = val;",
      "1997:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1998:    break;",
      "2000:   case L2CAP_CONF_FLUSH_TO:",
      "2001:    pi->flush_to = val;",
      "2002:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,",
      "2003:        2, pi->flush_to);",
      "2004:    break;",
      "2006:   case L2CAP_CONF_RFC:",
      "2007:    if (olen == sizeof(rfc))",
      "2008:     memcpy(&rfc, (void *)val, olen);",
      "2010:    if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&",
      "2011:        rfc.mode != pi->mode)",
      "2012:     return -ECONNREFUSED;",
      "2014:    pi->mode = rfc.mode;",
      "2015:    pi->fcs = 0;",
      "2017:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "2018:      sizeof(rfc), (unsigned long) &rfc);",
      "2019:    break;",
      "2020:   }",
      "2021:  }",
      "2023:  if (*result == L2CAP_CONF_SUCCESS) {",
      "2024:   switch (rfc.mode) {",
      "2025:   case L2CAP_MODE_ERTM:",
      "2026:    pi->remote_tx_win   = rfc.txwin_size;",
      "2027:    pi->retrans_timeout = rfc.retrans_timeout;",
      "2028:    pi->monitor_timeout = rfc.monitor_timeout;",
      "2029:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
      "2030:    break;",
      "2031:   case L2CAP_MODE_STREAMING:",
      "2032:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
      "2033:    break;",
      "2034:   }",
      "2035:  }",
      "2037:  req->dcid   = cpu_to_le16(pi->dcid);",
      "2038:  req->flags  = cpu_to_le16(0x0000);",
      "2040:  return ptr - data;",
      "2041: }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2043:   l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2044:      l2cap_build_conf_req(sk, req), req);",
      "2045:   break;",
      "2047:  case L2CAP_CR_PEND:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2229:   l2cap_pi(sk)->num_conf_req++;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2102:  len = l2cap_parse_conf_req(sk, rsp);",
      "2104:   goto unlock;",
      "2106:  l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);",
      "2109:  l2cap_pi(sk)->conf_len = 0;",
      "",
      "[Removed Lines]",
      "2103:  if (len < 0)",
      "",
      "[Added Lines]",
      "2288:  if (len < 0) {",
      "2289:   struct l2cap_disconn_req req;",
      "2290:   req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
      "2291:   req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
      "2292:   l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2293:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "2295:  }",
      "2298:  l2cap_pi(sk)->num_conf_rsp++;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2121:   u8 buf[64];",
      "2122:   l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2123:      l2cap_build_conf_req(sk, buf), buf);",
      "2124:  }",
      "2126: unlock:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2316:   l2cap_pi(sk)->num_conf_req++;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2150:   break;",
      "2152:  case L2CAP_CONF_UNACCEPT:",
      "2163:   }",
      "2165:  default:",
      "",
      "[Removed Lines]",
      "2153:   if (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {",
      "2154:    char req[128];",
      "2160:    l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2161:       l2cap_build_conf_req(sk, req), req);",
      "2162:    goto done;",
      "",
      "[Added Lines]",
      "2346:   if (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {",
      "2347:    int len = cmd->len - sizeof(*rsp);",
      "2348:    char req[64];",
      "2351:    result = L2CAP_CONF_SUCCESS;",
      "2352:    len = l2cap_parse_conf_rsp(sk, rsp->data,",
      "2353:        len, req, &result);",
      "2354:    if (len < 0) {",
      "2355:     struct l2cap_disconn_req req;",
      "2356:     req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
      "2357:     req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
      "2358:     l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2359:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "2360:     goto done;",
      "2361:    }",
      "2363:    l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2364:       L2CAP_CONF_REQ, len, req);",
      "2365:    l2cap_pi(sk)->num_conf_req++;",
      "2366:    if (result != L2CAP_CONF_SUCCESS)",
      "2367:     goto done;",
      "2368:    break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bd3c9e255e76ae232d417e3914ca5d80ca3e9485",
      "candidate_info": {
        "commit_hash": "bd3c9e255e76ae232d417e3914ca5d80ca3e9485",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bd3c9e255e76ae232d417e3914ca5d80ca3e9485",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Add SOCK_STREAM support to L2CAP\n\nif enable_ertm is true and we have SOCK_STREAM the default mode will be\nERTM, otherwise Basic Mode.\n\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\nReviewed-by: Jo\u00e3o Paulo Rechi Vita <jprvita@profusion.mobi>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "225:  l2cap_pi(sk)->conn = conn;",
          "229:   l2cap_pi(sk)->scid = l2cap_alloc_cid(l);",
          "230:  } else if (sk->sk_type == SOCK_DGRAM) {",
          "",
          "[Removed Lines]",
          "227:  if (sk->sk_type == SOCK_SEQPACKET) {",
          "",
          "[Added Lines]",
          "227:  if (sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "452:  for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {",
          "453:   bh_lock_sock(sk);",
          "456:    bh_unlock_sock(sk);",
          "457:    continue;",
          "458:   }",
          "",
          "[Removed Lines]",
          "455:   if (sk->sk_type != SOCK_SEQPACKET) {",
          "",
          "[Added Lines]",
          "455:   if (sk->sk_type != SOCK_SEQPACKET &&",
          "456:     sk->sk_type != SOCK_STREAM) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "512:  for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {",
          "513:   bh_lock_sock(sk);",
          "516:    l2cap_sock_clear_timer(sk);",
          "517:    sk->sk_state = BT_CONNECTED;",
          "518:    sk->sk_state_change(sk);",
          "",
          "[Removed Lines]",
          "515:   if (sk->sk_type != SOCK_SEQPACKET) {",
          "",
          "[Added Lines]",
          "516:   if (sk->sk_type != SOCK_SEQPACKET &&",
          "517:     sk->sk_type != SOCK_STREAM) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "722:  case BT_CONNECTED:",
          "723:  case BT_CONFIG:",
          "725:    struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "727:    sk->sk_state = BT_DISCONN;",
          "",
          "[Removed Lines]",
          "724:   if (sk->sk_type == SOCK_SEQPACKET) {",
          "",
          "[Added Lines]",
          "726:   if (sk->sk_type == SOCK_SEQPACKET ||",
          "727:     sk->sk_type == SOCK_STREAM) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "732:   break;",
          "734:  case BT_CONNECT2:",
          "736:    struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "737:    struct l2cap_conn_rsp rsp;",
          "738:    __u16 result;",
          "",
          "[Removed Lines]",
          "735:   if (sk->sk_type == SOCK_SEQPACKET) {",
          "",
          "[Added Lines]",
          "738:   if (sk->sk_type == SOCK_SEQPACKET ||",
          "739:     sk->sk_type == SOCK_STREAM) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "795:  } else {",
          "796:   pi->imtu = L2CAP_DEFAULT_MTU;",
          "797:   pi->omtu = 0;",
          "799:   pi->max_tx = max_transmit;",
          "800:   pi->fcs  = L2CAP_FCS_CRC16;",
          "801:   pi->tx_win = tx_window;",
          "",
          "[Removed Lines]",
          "798:   pi->mode = L2CAP_MODE_BASIC;",
          "",
          "[Added Lines]",
          "802:   if (enable_ertm && sk->sk_type == SOCK_STREAM)",
          "803:    pi->mode = L2CAP_MODE_ERTM;",
          "804:   else",
          "805:    pi->mode = L2CAP_MODE_BASIC;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "853:  sock->state = SS_UNCONNECTED;",
          "856:    sock->type != SOCK_DGRAM && sock->type != SOCK_RAW)",
          "857:   return -ESOCKTNOSUPPORT;",
          "",
          "[Removed Lines]",
          "855:  if (sock->type != SOCK_SEQPACKET &&",
          "",
          "[Added Lines]",
          "862:  if (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1000:  l2cap_sock_set_timer(sk, sk->sk_sndtimeo);",
          "1002:  if (hcon->state == BT_CONNECTED) {",
          "1004:    l2cap_sock_clear_timer(sk);",
          "1005:    sk->sk_state = BT_CONNECTED;",
          "1006:   } else",
          "",
          "[Removed Lines]",
          "1003:   if (sk->sk_type != SOCK_SEQPACKET) {",
          "",
          "[Added Lines]",
          "1010:   if (sk->sk_type != SOCK_SEQPACKET &&",
          "1011:     sk->sk_type != SOCK_STREAM) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1035:  lock_sock(sk);",
          "1038:   err = -EINVAL;",
          "1039:   goto done;",
          "1040:  }",
          "",
          "[Removed Lines]",
          "1037:  if (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {",
          "",
          "[Added Lines]",
          "1045:  if ((sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)",
          "1046:    && !la.l2_psm) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1099:  lock_sock(sk);",
          "1102:   err = -EBADFD;",
          "1103:   goto done;",
          "1104:  }",
          "",
          "[Removed Lines]",
          "1101:  if (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {",
          "",
          "[Added Lines]",
          "1110:  if ((sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM)",
          "1111:    || sk->sk_state != BT_BOUND) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1858:  switch (optname) {",
          "1859:  case BT_SECURITY:",
          "1861:    err = -EINVAL;",
          "1862:    break;",
          "1863:   }",
          "",
          "[Removed Lines]",
          "1860:   if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {",
          "",
          "[Added Lines]",
          "1870:   if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM",
          "1871:     && sk->sk_type != SOCK_RAW) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2008:  switch (optname) {",
          "2009:  case BT_SECURITY:",
          "2011:    err = -EINVAL;",
          "2012:    break;",
          "2013:   }",
          "",
          "[Removed Lines]",
          "2010:   if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {",
          "",
          "[Added Lines]",
          "2021:   if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM",
          "2022:     && sk->sk_type != SOCK_RAW) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2314: {",
          "2315:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "2316:  struct l2cap_conf_req *req = data;",
          "2318:  void *ptr = req->data;",
          "2320:  BT_DBG(\"sk %p\", sk);",
          "",
          "[Removed Lines]",
          "2317:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };",
          "",
          "[Added Lines]",
          "2329:  struct l2cap_conf_rfc rfc = { .mode = pi->mode };",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3998: static inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)",
          "3999: {",
          "4001:   return;",
          "4003:  if (encrypt == 0x00) {",
          "",
          "[Removed Lines]",
          "4000:  if (sk->sk_type != SOCK_SEQPACKET)",
          "",
          "[Added Lines]",
          "4012:  if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1c2acffb76d4bc5fd27c4ea55cc27ad8ead10f9a",
      "candidate_info": {
        "commit_hash": "1c2acffb76d4bc5fd27c4ea55cc27ad8ead10f9a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1c2acffb76d4bc5fd27c4ea55cc27ad8ead10f9a",
        "files": [
          "include/net/bluetooth/bluetooth.h",
          "include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Add initial support for ERTM packets transfers\n\nThis patch adds support for ERTM transfers, without retransmission, with\ntxWindow up to 63 and with acknowledgement of packets received. Now the\npackets are queued before call l2cap_do_send(), so packets couldn't be\nsent at the time we call l2cap_sock_sendmsg(). They will be sent in\nan asynchronous way on later calls of l2cap_ertm_send(). Besides if an\nerror occurs on calling l2cap_do_send() we disconnect the channel.\n\nInitially based on a patch from Nathan Holstein <nathan@lampreynetworks.com>\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "include/net/bluetooth/bluetooth.h||include/net/bluetooth/bluetooth.h",
          "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/bluetooth.h||include/net/bluetooth/bluetooth.h": [
          "File: include/net/bluetooth/bluetooth.h -> include/net/bluetooth/bluetooth.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "138: struct bt_skb_cb {",
          "139:  __u8 pkt_type;",
          "140:  __u8 incoming;",
          "141: };",
          "144: static inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)",
          "145: {",
          "",
          "[Removed Lines]",
          "142: #define bt_cb(skb) ((struct bt_skb_cb *)(skb->cb))",
          "",
          "[Added Lines]",
          "141:  __u8 tx_seq;",
          "143: #define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))",
          "",
          "---------------"
        ],
        "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
          "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #define L2CAP_DEFAULT_MTU  672",
          "30: #define L2CAP_DEFAULT_MIN_MTU  48",
          "31: #define L2CAP_DEFAULT_FLUSH_TO  0xffff",
          "33: #define L2CAP_DEFAULT_MAX_RECEIVE 1",
          "",
          "[Removed Lines]",
          "32: #define L2CAP_DEFAULT_TX_WINDOW  1",
          "",
          "[Added Lines]",
          "32: #define L2CAP_DEFAULT_TX_WINDOW  63",
          "33: #define L2CAP_DEFAULT_NUM_TO_ACK        (L2CAP_DEFAULT_TX_WINDOW/5)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94: #define L2CAP_FCS_NONE  0x00",
          "95: #define L2CAP_FCS_CRC16  0x01",
          "98: struct l2cap_hdr {",
          "99:  __le16     len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99: #define L2CAP_CTRL_SAR               0xC000",
          "100: #define L2CAP_CTRL_REQSEQ            0x3F00",
          "101: #define L2CAP_CTRL_TXSEQ             0x007E",
          "102: #define L2CAP_CTRL_RETRANS           0x0080",
          "103: #define L2CAP_CTRL_FINAL             0x0080",
          "104: #define L2CAP_CTRL_POLL              0x0010",
          "105: #define L2CAP_CTRL_SUPERVISE         0x000C",
          "108: #define L2CAP_CTRL_TXSEQ_SHIFT      1",
          "109: #define L2CAP_CTRL_REQSEQ_SHIFT     8",
          "112: #define L2CAP_SUPER_RCV_READY           0x0000",
          "113: #define L2CAP_SUPER_REJECT              0x0004",
          "114: #define L2CAP_SUPER_RCV_NOT_READY       0x0008",
          "115: #define L2CAP_SUPER_SELECT_REJECT       0x000C",
          "118: #define L2CAP_SDU_UNSEGMENTED       0x0000",
          "119: #define L2CAP_SDU_START             0x4000",
          "120: #define L2CAP_SDU_END               0x8000",
          "121: #define L2CAP_SDU_CONTINUE          0xC000",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "264: #define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)",
          "266: struct l2cap_pinfo {",
          "267:  struct bt_sock bt;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291: #define TX_QUEUE(sk) (&l2cap_pi(sk)->tx_queue)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "285:  __u8  conf_len;",
          "286:  __u8  conf_state;",
          "288:  __u8  ident;",
          "290:  __u8  remote_tx_win;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315:  __u8  next_tx_seq;",
          "316:  __u8  expected_ack_seq;",
          "317:  __u8  req_seq;",
          "318:  __u8  expected_tx_seq;",
          "319:  __u8  unacked_frames;",
          "320:  __u8  num_to_ack;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "296:  __le16  sport;",
          "298:  struct l2cap_conn *conn;",
          "299:  struct sock  *next_c;",
          "300:  struct sock  *prev_c;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "332:  struct sk_buff_head tx_queue;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "311: #define L2CAP_CONF_MAX_CONF_REQ 2",
          "312: #define L2CAP_CONF_MAX_CONF_RSP 2",
          "315: void l2cap_load(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "349: static inline int l2cap_tx_window_full(struct sock *sk)",
          "350: {",
          "351:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "352:  int sub;",
          "354:  sub = (pi->next_tx_seq - pi->expected_ack_seq) % 64;",
          "356:  if (sub < 0)",
          "357:   sub += 64;",
          "359:  return (sub == pi->remote_tx_win);",
          "360: }",
          "362: #define __get_txseq(ctrl) ((ctrl) & L2CAP_CTRL_TXSEQ) >> 1",
          "363: #define __get_reqseq(ctrl) ((ctrl) & L2CAP_CTRL_REQSEQ) >> 8",
          "364: #define __is_iframe(ctrl) !((ctrl) & L2CAP_CTRL_FRAME_TYPE)",
          "365: #define __is_sframe(ctrl) (ctrl) & L2CAP_CTRL_FRAME_TYPE",
          "",
          "---------------"
        ],
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "333:  return hci_send_acl(conn->hcon, skb, 0);",
          "334: }",
          "336: static void l2cap_do_start(struct sock *sk)",
          "337: {",
          "338:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "336: static inline int l2cap_send_sframe(struct l2cap_pinfo *pi, u16 control)",
          "337: {",
          "338:  struct sk_buff *skb;",
          "339:  struct l2cap_hdr *lh;",
          "340:  struct l2cap_conn *conn = pi->conn;",
          "341:  int count;",
          "343:  BT_DBG(\"pi %p, control 0x%2.2x\", pi, control);",
          "345:  count = min_t(unsigned int, conn->mtu, L2CAP_HDR_SIZE + 2);",
          "346:  control |= L2CAP_CTRL_FRAME_TYPE;",
          "348:  skb = bt_skb_alloc(count, GFP_ATOMIC);",
          "349:  if (!skb)",
          "350:   return -ENOMEM;",
          "352:  lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);",
          "353:  lh->len = cpu_to_le16(2);",
          "354:  lh->cid = cpu_to_le16(pi->dcid);",
          "355:  put_unaligned_le16(control, skb_put(skb, 2));",
          "357:  return hci_send_acl(pi->conn->hcon, skb, 0);",
          "358: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1154:  return 0;",
          "1155: }",
          "1158: {",
          "1187:  if (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count)) {",
          "1190:  }",
          "1192:  sent += count;",
          "",
          "[Removed Lines]",
          "1157: static inline int l2cap_do_send(struct sock *sk, struct msghdr *msg, int len)",
          "1159:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "1160:  struct sk_buff *skb, **frag;",
          "1161:  int err, hlen, count, sent = 0;",
          "1162:  struct l2cap_hdr *lh;",
          "1164:  BT_DBG(\"sk %p len %d\", sk, len);",
          "1167:  if (sk->sk_type == SOCK_DGRAM)",
          "1168:   hlen = L2CAP_HDR_SIZE + 2;",
          "1169:  else",
          "1170:   hlen = L2CAP_HDR_SIZE;",
          "1172:  count = min_t(unsigned int, (conn->mtu - hlen), len);",
          "1174:  skb = bt_skb_send_alloc(sk, hlen + count,",
          "1175:    msg->msg_flags & MSG_DONTWAIT, &err);",
          "1176:  if (!skb)",
          "1177:   return err;",
          "1180:  lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);",
          "1181:  lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "1182:  lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));",
          "1184:  if (sk->sk_type == SOCK_DGRAM)",
          "1185:   put_unaligned(l2cap_pi(sk)->psm, (__le16 *) skb_put(skb, 2));",
          "1188:   err = -EFAULT;",
          "1189:   goto fail;",
          "",
          "[Added Lines]",
          "1181: static void l2cap_drop_acked_frames(struct sock *sk)",
          "1183:  struct sk_buff *skb;",
          "1185:  while ((skb = skb_peek(TX_QUEUE(sk)))) {",
          "1186:   if (bt_cb(skb)->tx_seq == l2cap_pi(sk)->expected_ack_seq)",
          "1187:    break;",
          "1189:   skb = skb_dequeue(TX_QUEUE(sk));",
          "1190:   kfree_skb(skb);",
          "1192:   l2cap_pi(sk)->unacked_frames--;",
          "1193:  }",
          "1195:  return;",
          "1196: }",
          "1198: static inline int l2cap_do_send(struct sock *sk, struct sk_buff *skb)",
          "1199: {",
          "1200:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "1201:  int err;",
          "1203:  BT_DBG(\"sk %p, skb %p len %d\", sk, skb, skb->len);",
          "1205:  err = hci_send_acl(pi->conn->hcon, skb, 0);",
          "1206:  if (err < 0)",
          "1207:   kfree_skb(skb);",
          "1209:  return err;",
          "1210: }",
          "1212: static int l2cap_ertm_send(struct sock *sk)",
          "1213: {",
          "1214:  struct sk_buff *skb, *tx_skb;",
          "1215:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "1216:  u16 control;",
          "1217:  int err;",
          "1219:  while ((skb = sk->sk_send_head) && (!l2cap_tx_window_full(sk))) {",
          "1220:   tx_skb = skb_clone(skb, GFP_ATOMIC);",
          "1222:   control = get_unaligned_le16(tx_skb->data + L2CAP_HDR_SIZE);",
          "1223:   control |= (pi->req_seq << L2CAP_CTRL_REQSEQ_SHIFT)",
          "1224:     | (pi->next_tx_seq << L2CAP_CTRL_TXSEQ_SHIFT);",
          "1225:   put_unaligned_le16(control, tx_skb->data + L2CAP_HDR_SIZE);",
          "1227:   err = l2cap_do_send(sk, tx_skb);",
          "1228:   if (err < 0) {",
          "1229:    l2cap_send_disconn_req(pi->conn, sk);",
          "1230:    return err;",
          "1231:   }",
          "1233:   bt_cb(skb)->tx_seq = pi->next_tx_seq;",
          "1234:   pi->next_tx_seq = (pi->next_tx_seq + 1) % 64;",
          "1236:   pi->unacked_frames++;",
          "1238:   if (skb_queue_is_last(TX_QUEUE(sk), skb))",
          "1239:    sk->sk_send_head = NULL;",
          "1240:   else",
          "1241:    sk->sk_send_head = skb_queue_next(TX_QUEUE(sk), skb);",
          "1242:  }",
          "1244:  return 0;",
          "1245: }",
          "1247: static inline int l2cap_skbuff_fromiovec(struct sock *sk, struct msghdr *msg, int len, int count, struct sk_buff *skb)",
          "1248: {",
          "1249:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "1250:  struct sk_buff **frag;",
          "1251:  int err, sent = 0;",
          "1254:   return -EFAULT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1201:   if (!*frag)",
          "1209:   sent += count;",
          "1210:   len  -= count;",
          "1212:   frag = &(*frag)->next;",
          "1213:  }",
          "1218:  return sent;",
          "1223: }",
          "1225: static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)",
          "1226: {",
          "1227:  struct sock *sk = sock->sk;",
          "1230:  BT_DBG(\"sock %p, sk %p\", sock, sk);",
          "",
          "[Removed Lines]",
          "1202:    goto fail;",
          "1204:   if (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count)) {",
          "1205:    err = -EFAULT;",
          "1206:    goto fail;",
          "1207:   }",
          "1214:  err = hci_send_acl(conn->hcon, skb, 0);",
          "1215:  if (err < 0)",
          "1216:   goto fail;",
          "1220: fail:",
          "1221:  kfree_skb(skb);",
          "1222:  return err;",
          "1228:  int err = 0;",
          "",
          "[Added Lines]",
          "1267:    return -EFAULT;",
          "1268:   if (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count))",
          "1269:    return -EFAULT;",
          "1278: }",
          "1280: static struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len)",
          "1281: {",
          "1282:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "1283:  struct sk_buff *skb;",
          "1284:  int err, count, hlen = L2CAP_HDR_SIZE + 2;",
          "1285:  struct l2cap_hdr *lh;",
          "1287:  BT_DBG(\"sk %p len %d\", sk, (int)len);",
          "1289:  count = min_t(unsigned int, (conn->mtu - hlen), len);",
          "1290:  skb = bt_skb_send_alloc(sk, count + hlen,",
          "1291:    msg->msg_flags & MSG_DONTWAIT, &err);",
          "1292:  if (!skb)",
          "1293:   return ERR_PTR(-ENOMEM);",
          "1296:  lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);",
          "1297:  lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "1298:  lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));",
          "1299:  put_unaligned_le16(l2cap_pi(sk)->psm, skb_put(skb, 2));",
          "1301:  err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);",
          "1302:  if (unlikely(err < 0)) {",
          "1303:   kfree_skb(skb);",
          "1304:   return ERR_PTR(err);",
          "1305:  }",
          "1306:  return skb;",
          "1307: }",
          "1309: static struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len)",
          "1310: {",
          "1311:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "1312:  struct sk_buff *skb;",
          "1313:  int err, count, hlen = L2CAP_HDR_SIZE;",
          "1314:  struct l2cap_hdr *lh;",
          "1316:  BT_DBG(\"sk %p len %d\", sk, (int)len);",
          "1318:  count = min_t(unsigned int, (conn->mtu - hlen), len);",
          "1319:  skb = bt_skb_send_alloc(sk, count + hlen,",
          "1320:    msg->msg_flags & MSG_DONTWAIT, &err);",
          "1321:  if (!skb)",
          "1322:   return ERR_PTR(-ENOMEM);",
          "1325:  lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);",
          "1326:  lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "1327:  lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));",
          "1329:  err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);",
          "1330:  if (unlikely(err < 0)) {",
          "1331:   kfree_skb(skb);",
          "1332:   return ERR_PTR(err);",
          "1333:  }",
          "1334:  return skb;",
          "1335: }",
          "1337: static struct sk_buff *l2cap_create_ertm_pdu(struct sock *sk, struct msghdr *msg, size_t len, u16 control)",
          "1338: {",
          "1339:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "1340:  struct sk_buff *skb;",
          "1341:  int err, count, hlen = L2CAP_HDR_SIZE + 2;",
          "1342:  struct l2cap_hdr *lh;",
          "1344:  BT_DBG(\"sk %p len %d\", sk, (int)len);",
          "1346:  count = min_t(unsigned int, (conn->mtu - hlen), len);",
          "1347:  skb = bt_skb_send_alloc(sk, count + hlen,",
          "1348:    msg->msg_flags & MSG_DONTWAIT, &err);",
          "1349:  if (!skb)",
          "1350:   return ERR_PTR(-ENOMEM);",
          "1353:  lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);",
          "1354:  lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "1355:  lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));",
          "1356:  put_unaligned_le16(control, skb_put(skb, 2));",
          "1358:  err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);",
          "1359:  if (unlikely(err < 0)) {",
          "1360:   kfree_skb(skb);",
          "1361:   return ERR_PTR(err);",
          "1362:  }",
          "1363:  return skb;",
          "1369:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "1370:  struct sk_buff *skb;",
          "1371:  u16 control;",
          "1372:  int err;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1237:   return -EOPNOTSUPP;",
          "1241:   return -EINVAL;",
          "1243:  lock_sock(sk);",
          "1248:   err = -ENOTCONN;",
          "1250:  release_sock(sk);",
          "1251:  return err;",
          "1252: }",
          "",
          "[Removed Lines]",
          "1240:  if (sk->sk_type != SOCK_RAW && len > l2cap_pi(sk)->omtu)",
          "1245:  if (sk->sk_state == BT_CONNECTED)",
          "1246:   err = l2cap_do_send(sk, msg, len);",
          "1247:  else",
          "",
          "[Added Lines]",
          "1384:  if (sk->sk_type == SOCK_SEQPACKET && pi->mode == L2CAP_MODE_BASIC",
          "1385:    && len > pi->omtu)",
          "1390:  if (sk->sk_state != BT_CONNECTED) {",
          "1392:   goto done;",
          "1393:  }",
          "1396:  if (sk->sk_type == SOCK_DGRAM) {",
          "1397:   skb = l2cap_create_connless_pdu(sk, msg, len);",
          "1398:   err = l2cap_do_send(sk, skb);",
          "1399:   goto done;",
          "1400:  }",
          "1402:  switch (pi->mode) {",
          "1403:  case L2CAP_MODE_BASIC:",
          "1405:   skb = l2cap_create_basic_pdu(sk, msg, len);",
          "1406:   if (IS_ERR(skb)) {",
          "1407:    err = PTR_ERR(skb);",
          "1408:    goto done;",
          "1409:   }",
          "1411:   err = l2cap_do_send(sk, skb);",
          "1412:   if (!err)",
          "1413:    err = len;",
          "1414:   break;",
          "1416:  case L2CAP_MODE_ERTM:",
          "1418:   if (len <= pi->omtu) {",
          "1419:    control = L2CAP_SDU_UNSEGMENTED;",
          "1420:    skb = l2cap_create_ertm_pdu(sk, msg, len, control);",
          "1421:    if (IS_ERR(skb)) {",
          "1422:     err = PTR_ERR(skb);",
          "1423:     goto done;",
          "1424:    }",
          "1425:   } else {",
          "1427:    err = -EINVAL;",
          "1428:    goto done;",
          "1429:   }",
          "1430:   __skb_queue_tail(TX_QUEUE(sk), skb);",
          "1431:   if (sk->sk_send_head == NULL)",
          "1432:    sk->sk_send_head = skb;",
          "1434:   err = l2cap_ertm_send(sk);",
          "1435:   if (!err)",
          "1436:    err = len;",
          "1437:   break;",
          "1439:  default:",
          "1440:   BT_DBG(\"bad state %1.1x\", pi->mode);",
          "1441:   err = -EINVAL;",
          "1442:  }",
          "1444: done:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2302:  if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {",
          "2303:   sk->sk_state = BT_CONNECTED;",
          "2304:   l2cap_chan_ready(sk);",
          "2305:   goto unlock;",
          "2306:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2499:   l2cap_pi(sk)->next_tx_seq = 0;",
          "2500:   l2cap_pi(sk)->expected_ack_seq = 0;",
          "2501:   l2cap_pi(sk)->unacked_frames = 0;",
          "2502:   __skb_queue_head_init(TX_QUEUE(sk));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2376:  if (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {",
          "2377:   sk->sk_state = BT_CONNECTED;",
          "2378:   l2cap_chan_ready(sk);",
          "2379:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2577:   l2cap_pi(sk)->expected_tx_seq = 0;",
          "2578:   l2cap_pi(sk)->num_to_ack = 0;",
          "2579:   __skb_queue_head_init(TX_QUEUE(sk));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2406:  sk->sk_shutdown = SHUTDOWN_MASK;",
          "2408:  l2cap_chan_del(sk, ECONNRESET);",
          "2409:  bh_unlock_sock(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2610:  skb_queue_purge(TX_QUEUE(sk));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2427:  if (!sk)",
          "2428:   return 0;",
          "2430:  l2cap_chan_del(sk, 0);",
          "2431:  bh_unlock_sock(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2634:  skb_queue_purge(TX_QUEUE(sk));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2602:  kfree_skb(skb);",
          "2603: }",
          "2605: static inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)",
          "2606: {",
          "2607:  struct sock *sk;",
          "2609:  sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);",
          "2610:  if (!sk) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2811: static inline int l2cap_data_channel_iframe(struct sock *sk, u16 rx_control, struct sk_buff *skb)",
          "2812: {",
          "2813:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "2814:  u8 tx_seq = __get_txseq(rx_control);",
          "2815:  u16 tx_control = 0;",
          "2816:  int err = 0;",
          "2818:  BT_DBG(\"sk %p rx_control 0x%4.4x len %d\", sk, rx_control, skb->len);",
          "2820:  if (tx_seq != pi->expected_tx_seq)",
          "2821:   return -EINVAL;",
          "2823:  pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;",
          "2824:  err = sock_queue_rcv_skb(sk, skb);",
          "2825:  if (err)",
          "2826:   return err;",
          "2828:  pi->num_to_ack = (pi->num_to_ack + 1) % L2CAP_DEFAULT_NUM_TO_ACK;",
          "2829:  if (pi->num_to_ack == L2CAP_DEFAULT_NUM_TO_ACK - 1) {",
          "2830:   tx_control |= L2CAP_CTRL_FRAME_TYPE;",
          "2831:   tx_control |= L2CAP_SUPER_RCV_READY;",
          "2832:   tx_control |= pi->expected_tx_seq << L2CAP_CTRL_REQSEQ_SHIFT;",
          "2833:   err = l2cap_send_sframe(pi, tx_control);",
          "2834:  }",
          "2835:  return err;",
          "2836: }",
          "2838: static inline int l2cap_data_channel_sframe(struct sock *sk, u16 rx_control, struct sk_buff *skb)",
          "2839: {",
          "2840:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "2842:  BT_DBG(\"sk %p rx_control 0x%4.4x len %d\", sk, rx_control, skb->len);",
          "2844:  switch (rx_control & L2CAP_CTRL_SUPERVISE) {",
          "2845:  case L2CAP_SUPER_RCV_READY:",
          "2846:   pi->expected_ack_seq = __get_reqseq(rx_control);",
          "2847:   l2cap_drop_acked_frames(sk);",
          "2848:   l2cap_ertm_send(sk);",
          "2849:   break;",
          "2851:  case L2CAP_SUPER_RCV_NOT_READY:",
          "2852:  case L2CAP_SUPER_REJECT:",
          "2853:  case L2CAP_SUPER_SELECT_REJECT:",
          "2854:   break;",
          "2855:  }",
          "2857:  return 0;",
          "2858: }",
          "2863:  u16 control;",
          "2864:  int err;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2617:  if (sk->sk_state != BT_CONNECTED)",
          "2618:   goto drop;",
          "2631: drop:",
          "2632:  kfree_skb(skb);",
          "",
          "[Removed Lines]",
          "2620:  if (l2cap_pi(sk)->imtu < skb->len)",
          "2621:   goto drop;",
          "2628:  if (!sock_queue_rcv_skb(sk, skb))",
          "2629:   goto done;",
          "",
          "[Added Lines]",
          "2877:  switch (l2cap_pi(sk)->mode) {",
          "2878:  case L2CAP_MODE_BASIC:",
          "2884:   if (l2cap_pi(sk)->imtu < skb->len)",
          "2885:    goto drop;",
          "2887:   if (!sock_queue_rcv_skb(sk, skb))",
          "2888:    goto done;",
          "2889:   break;",
          "2891:  case L2CAP_MODE_ERTM:",
          "2892:   control = get_unaligned_le16(skb->data);",
          "2893:   skb_pull(skb, 2);",
          "2895:   if (l2cap_pi(sk)->imtu < skb->len)",
          "2896:    goto drop;",
          "2898:   if (__is_iframe(control))",
          "2899:    err = l2cap_data_channel_iframe(sk, control, skb);",
          "2900:   else",
          "2901:    err = l2cap_data_channel_sframe(sk, control, skb);",
          "2903:   if (!err)",
          "2904:    goto done;",
          "2905:   break;",
          "2907:  default:",
          "2908:   BT_DBG(\"sk %p: bad mode 0x%2.2x\", sk, l2cap_pi(sk)->mode);",
          "2909:   break;",
          "2910:  }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2676:  cid = __le16_to_cpu(lh->cid);",
          "2677:  len = __le16_to_cpu(lh->len);",
          "2679:  BT_DBG(\"len %d, cid 0x%4.4x\", len, cid);",
          "2681:  switch (cid) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2960:  if (len != skb->len) {",
          "2961:   kfree_skb(skb);",
          "2962:   return;",
          "2963:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "22121fc9152ca8f25a2d790860832ccb6a414c4d",
      "candidate_info": {
        "commit_hash": "22121fc9152ca8f25a2d790860832ccb6a414c4d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/22121fc9152ca8f25a2d790860832ccb6a414c4d",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Create separate l2cap_send_disconn_req() function\n\nThe code for sending a disconnect request was repeated several times\nwithin L2CAP source code. So move this into its own function.\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "366:  }",
          "367: }",
          "370: static void l2cap_conn_start(struct l2cap_conn *conn)",
          "371: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "369: static void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk)",
          "370: {",
          "371:  struct l2cap_disconn_req req;",
          "373:  req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "374:  req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
          "375:  l2cap_send_cmd(conn, l2cap_get_ident(conn),",
          "376:    L2CAP_DISCONN_REQ, sizeof(req), &req);",
          "377: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "650:  case BT_CONFIG:",
          "651:   if (sk->sk_type == SOCK_SEQPACKET) {",
          "652:    struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "655:    sk->sk_state = BT_DISCONN;",
          "656:    l2cap_sock_set_timer(sk, sk->sk_sndtimeo);",
          "662:   } else",
          "663:    l2cap_chan_del(sk, reason);",
          "664:   break;",
          "",
          "[Removed Lines]",
          "653:    struct l2cap_disconn_req req;",
          "658:    req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "659:    req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
          "660:    l2cap_send_cmd(conn, l2cap_get_ident(conn),",
          "661:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
          "",
          "[Added Lines]",
          "666:    l2cap_send_disconn_req(conn, sk);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1786:  case L2CAP_MODE_STREAMING:",
          "1787:  case L2CAP_MODE_ERTM:",
          "1788:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
          "1796:   break;",
          "1797:  default:",
          "1798:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
          "",
          "[Removed Lines]",
          "1789:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) {",
          "1790:    struct l2cap_disconn_req req;",
          "1791:    req.dcid = cpu_to_le16(pi->dcid);",
          "1792:    req.scid = cpu_to_le16(pi->scid);",
          "1793:    l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn),",
          "1794:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
          "1795:   }",
          "",
          "[Added Lines]",
          "1794:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
          "1795:    l2cap_send_disconn_req(pi->conn, sk);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2287:  len = l2cap_parse_conf_req(sk, rsp);",
          "2288:  if (len < 0) {",
          "2294:   goto unlock;",
          "2295:  }",
          "",
          "[Removed Lines]",
          "2289:   struct l2cap_disconn_req req;",
          "2290:   req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "2291:   req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
          "2292:   l2cap_send_cmd(conn, l2cap_get_ident(conn),",
          "2293:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
          "",
          "[Added Lines]",
          "2289:   l2cap_send_disconn_req(conn, sk);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2352:    len = l2cap_parse_conf_rsp(sk, rsp->data,",
          "2353:        len, req, &result);",
          "2354:    if (len < 0) {",
          "2360:     goto done;",
          "2361:    }",
          "",
          "[Removed Lines]",
          "2355:     struct l2cap_disconn_req req;",
          "2356:     req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "2357:     req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
          "2358:     l2cap_send_cmd(conn, l2cap_get_ident(conn),",
          "2359:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
          "",
          "[Added Lines]",
          "2351:     l2cap_send_disconn_req(conn, sk);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2372:   sk->sk_state = BT_DISCONN;",
          "2373:   sk->sk_err = ECONNRESET;",
          "2374:   l2cap_sock_set_timer(sk, HZ * 5);",
          "2382:   goto done;",
          "2383:  }",
          "",
          "[Removed Lines]",
          "2375:   {",
          "2376:    struct l2cap_disconn_req req;",
          "2377:    req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "2378:    req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
          "2379:    l2cap_send_cmd(conn, l2cap_get_ident(conn),",
          "2380:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
          "2381:   }",
          "",
          "[Added Lines]",
          "2367:   l2cap_send_disconn_req(conn, sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6840ed0770d79b9bb0800e5e026a067040ef18f5",
      "candidate_info": {
        "commit_hash": "6840ed0770d79b9bb0800e5e026a067040ef18f5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6840ed0770d79b9bb0800e5e026a067040ef18f5",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Enable Streaming Mode for L2CAP\n\nStreaming Mode is helpful for the Bluetooth streaming based profiles, such\nas A2DP. It doesn't have any error control or flow control.\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1245:  return err;",
          "1246: }",
          "1248: static int l2cap_ertm_send(struct sock *sk)",
          "1249: {",
          "1250:  struct sk_buff *skb, *tx_skb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1248: static int l2cap_streaming_send(struct sock *sk)",
          "1249: {",
          "1250:  struct sk_buff *skb, *tx_skb;",
          "1251:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "1252:  u16 control;",
          "1253:  int err;",
          "1255:  while ((skb = sk->sk_send_head)) {",
          "1256:   tx_skb = skb_clone(skb, GFP_ATOMIC);",
          "1258:   control = get_unaligned_le16(tx_skb->data + L2CAP_HDR_SIZE);",
          "1259:   control |= pi->next_tx_seq << L2CAP_CTRL_TXSEQ_SHIFT;",
          "1260:   put_unaligned_le16(control, tx_skb->data + L2CAP_HDR_SIZE);",
          "1262:   err = l2cap_do_send(sk, tx_skb);",
          "1263:   if (err < 0) {",
          "1264:    l2cap_send_disconn_req(pi->conn, sk);",
          "1265:    return err;",
          "1266:   }",
          "1268:   pi->next_tx_seq = (pi->next_tx_seq + 1) % 64;",
          "1270:   if (skb_queue_is_last(TX_QUEUE(sk), skb))",
          "1271:    sk->sk_send_head = NULL;",
          "1272:   else",
          "1273:    sk->sk_send_head = skb_queue_next(TX_QUEUE(sk), skb);",
          "1275:   skb = skb_dequeue(TX_QUEUE(sk));",
          "1276:   kfree_skb(skb);",
          "1277:  }",
          "1278:  return 0;",
          "1279: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1383:  return skb;",
          "1384: }",
          "1387: {",
          "1388:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "1389:  struct sk_buff *skb;",
          "",
          "[Removed Lines]",
          "1386: static struct sk_buff *l2cap_create_ertm_pdu(struct sock *sk, struct msghdr *msg, size_t len, u16 control, u16 sdulen)",
          "",
          "[Added Lines]",
          "1419: static struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk, struct msghdr *msg, size_t len, u16 control, u16 sdulen)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1430:  __skb_queue_head_init(&sar_queue);",
          "1431:  control = L2CAP_SDU_START;",
          "1433:  if (IS_ERR(skb))",
          "1434:   return PTR_ERR(skb);",
          "",
          "[Removed Lines]",
          "1432:  skb = l2cap_create_ertm_pdu(sk, msg, pi->max_pdu_size, control, len);",
          "",
          "[Added Lines]",
          "1465:  skb = l2cap_create_iframe_pdu(sk, msg, pi->max_pdu_size, control, len);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1449:    buflen = len;",
          "1450:   }",
          "1453:   if (IS_ERR(skb)) {",
          "1454:    skb_queue_purge(&sar_queue);",
          "1455:    return PTR_ERR(skb);",
          "",
          "[Removed Lines]",
          "1452:   skb = l2cap_create_ertm_pdu(sk, msg, buflen, control, 0);",
          "",
          "[Added Lines]",
          "1485:   skb = l2cap_create_iframe_pdu(sk, msg, buflen, control, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1518:   break;",
          "1520:  case L2CAP_MODE_ERTM:",
          "1522:   if (len <= pi->max_pdu_size) {",
          "1523:    control = L2CAP_SDU_UNSEGMENTED;",
          "1525:    if (IS_ERR(skb)) {",
          "1526:     err = PTR_ERR(skb);",
          "1527:     goto done;",
          "",
          "[Removed Lines]",
          "1524:    skb = l2cap_create_ertm_pdu(sk, msg, len, control, 0);",
          "",
          "[Added Lines]",
          "1554:  case L2CAP_MODE_STREAMING:",
          "1558:    skb = l2cap_create_iframe_pdu(sk, msg, len, control, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1536:     goto done;",
          "1537:   }",
          "1540:   if (!err)",
          "1541:    err = len;",
          "1542:   break;",
          "",
          "[Removed Lines]",
          "1539:   err = l2cap_ertm_send(sk);",
          "",
          "[Added Lines]",
          "1573:   if (pi->mode == L2CAP_MODE_STREAMING)",
          "1574:    err = l2cap_streaming_send(sk);",
          "1575:   else",
          "1576:    err = l2cap_ertm_send(sk);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2050: {",
          "2051:  u32 local_feat_mask = l2cap_feat_mask;",
          "2052:  if (enable_ertm)",
          "2055:  switch (mode) {",
          "2056:  case L2CAP_MODE_ERTM:",
          "",
          "[Removed Lines]",
          "2053:   local_feat_mask |= L2CAP_FEAT_ERTM;",
          "",
          "[Added Lines]",
          "2091:   local_feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2771:   rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);",
          "2772:   rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);",
          "2773:   if (enable_ertm)",
          "2775:   put_unaligned(cpu_to_le32(feat_mask), (__le32 *) rsp->data);",
          "2776:   l2cap_send_cmd(conn, cmd->ident,",
          "2777:      L2CAP_INFO_RSP, sizeof(buf), buf);",
          "",
          "[Removed Lines]",
          "2774:    feat_mask |= L2CAP_FEAT_ERTM;",
          "",
          "[Added Lines]",
          "2812:    feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3096: static inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)",
          "3097: {",
          "3098:  struct sock *sk;",
          "3099:  u16 control, len;",
          "3100:  int err;",
          "3102:  sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3137:  struct l2cap_pinfo *pi;",
          "3139:  u8 tx_seq;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3105:   goto drop;",
          "3106:  }",
          "3108:  BT_DBG(\"sk %p, len %d\", sk, skb->len);",
          "3110:  if (sk->sk_state != BT_CONNECTED)",
          "3111:   goto drop;",
          "3114:  case L2CAP_MODE_BASIC:",
          "3121:    goto drop;",
          "3123:   if (!sock_queue_rcv_skb(sk, skb))",
          "",
          "[Removed Lines]",
          "3113:  switch (l2cap_pi(sk)->mode) {",
          "3120:   if (l2cap_pi(sk)->imtu < skb->len)",
          "",
          "[Added Lines]",
          "3148:  pi = l2cap_pi(sk);",
          "3155:  switch (pi->mode) {",
          "3162:   if (pi->imtu < skb->len)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3149:    goto done;",
          "3150:   break;",
          "3152:  default:",
          "3153:   BT_DBG(\"sk %p: bad mode 0x%2.2x\", sk, l2cap_pi(sk)->mode);",
          "3154:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3194:  case L2CAP_MODE_STREAMING:",
          "3195:   control = get_unaligned_le16(skb->data);",
          "3196:   skb_pull(skb, 2);",
          "3197:   len = skb->len;",
          "3199:   if (__is_sar_start(control))",
          "3200:    len -= 2;",
          "3202:   if (len > L2CAP_DEFAULT_MAX_PDU_SIZE || __is_sframe(control))",
          "3203:    goto drop;",
          "3205:   tx_seq = __get_txseq(control);",
          "3207:   if (pi->expected_tx_seq == tx_seq)",
          "3208:    pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;",
          "3209:   else",
          "3210:    pi->expected_tx_seq = tx_seq + 1;",
          "3212:   err = l2cap_sar_reassembly_sdu(sk, skb, control);",
          "3214:   goto done;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e7c29cb16c833441fd2160642bb13025f4e7ac70",
      "candidate_info": {
        "commit_hash": "e7c29cb16c833441fd2160642bb13025f4e7ac70",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e7c29cb16c833441fd2160642bb13025f4e7ac70",
        "files": [
          "include/net/bluetooth/hci_core.h",
          "net/bluetooth/af_bluetooth.c",
          "net/bluetooth/hci_conn.c",
          "net/bluetooth/l2cap.c"
        ],
        "message": "[Bluetooth] Reject L2CAP connections on an insecure ACL link\n\nThe Security Mode 4 of the Bluetooth 2.1 specification has strict\nauthentication and encryption requirements. It is the initiators job\nto create a secure ACL link. However in case of malicious devices, the\nacceptor has to make sure that the ACL is encrypted before allowing\nany kind of L2CAP connection. The only exception here is the PSM 1 for\nthe service discovery protocol, because that is allowed to run on an\ninsecure ACL link.\n\nPreviously it was enough to reject a L2CAP connection during the\nconnection setup phase, but with Bluetooth 2.1 it is forbidden to\ndo any L2CAP protocol exchange on an insecure link (except SDP).\n\nThe new hci_conn_check_link_mode() function can be used to check the\nintegrity of an ACL link. This functions also takes care of the cases\nwhere Security Mode 4 is disabled or one of the devices is based on\nan older specification.\n\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "include/net/bluetooth/hci_core.h||include/net/bluetooth/hci_core.h",
          "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c",
          "net/bluetooth/hci_conn.c||net/bluetooth/hci_conn.c",
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/hci_core.h||include/net/bluetooth/hci_core.h": [
          "File: include/net/bluetooth/hci_core.h -> include/net/bluetooth/hci_core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "326: void hci_conn_check_pending(struct hci_dev *hdev);",
          "328: struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type);",
          "329: int hci_conn_auth(struct hci_conn *conn);",
          "330: int hci_conn_encrypt(struct hci_conn *conn);",
          "331: int hci_conn_change_link_key(struct hci_conn *conn);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329: int hci_conn_check_link_mode(struct hci_conn *conn);",
          "",
          "---------------"
        ],
        "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c": [
          "File: net/bluetooth/af_bluetooth.c -> net/bluetooth/af_bluetooth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: #define BT_DBG(D...)",
          "50: #endif",
          "55: #define BT_MAX_PROTO 8",
          "",
          "[Removed Lines]",
          "52: #define VERSION \"2.12\"",
          "",
          "[Added Lines]",
          "52: #define VERSION \"2.13\"",
          "",
          "---------------"
        ],
        "net/bluetooth/hci_conn.c||net/bluetooth/hci_conn.c": [
          "File: net/bluetooth/hci_conn.c -> net/bluetooth/hci_conn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "376: }",
          "377: EXPORT_SYMBOL(hci_connect);",
          "380: int hci_conn_auth(struct hci_conn *conn)",
          "381: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "380: int hci_conn_check_link_mode(struct hci_conn *conn)",
          "381: {",
          "382:  BT_DBG(\"conn %p\", conn);",
          "384:  if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0 &&",
          "385:      !(conn->link_mode & HCI_LM_ENCRYPT))",
          "386:   return 0;",
          "388:  return 1;",
          "389: }",
          "390: EXPORT_SYMBOL(hci_conn_check_link_mode);",
          "",
          "---------------"
        ],
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1568:  struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;",
          "1569:  struct l2cap_conn_rsp rsp;",
          "1570:  struct sock *sk, *parent;",
          "1573:  u16 dcid = 0, scid = __le16_to_cpu(req->scid);",
          "1576:  BT_DBG(\"psm 0x%2.2x scid 0x%4.4x\", psm, scid);",
          "",
          "[Removed Lines]",
          "1571:  int result, status = 0;",
          "1574:  __le16 psm  = req->psm;",
          "",
          "[Added Lines]",
          "1571:  int result, status = L2CAP_CS_NO_INFO;",
          "1574:  __le16 psm = req->psm;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1582:   goto sendresp;",
          "1583:  }",
          "1585:  result = L2CAP_CR_NO_MEM;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1586:  if (psm != cpu_to_le16(0x0001) &&",
          "1587:     !hci_conn_check_link_mode(conn->hcon)) {",
          "1588:   result = L2CAP_CR_SEC_BLOCK;",
          "1589:   goto response;",
          "1590:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2239:    rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "2240:    rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);",
          "2241:    rsp.result = cpu_to_le16(result);",
          "2243:    l2cap_send_cmd(conn, l2cap_pi(sk)->ident,",
          "2244:      L2CAP_CONN_RSP, sizeof(rsp), &rsp);",
          "2245:   }",
          "",
          "[Removed Lines]",
          "2242:    rsp.status = cpu_to_le16(0);",
          "",
          "[Added Lines]",
          "2249:    rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2311:    rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "2312:    rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);",
          "2313:    rsp.result = cpu_to_le16(result);",
          "2315:    l2cap_send_cmd(conn, l2cap_pi(sk)->ident,",
          "2316:      L2CAP_CONN_RSP, sizeof(rsp), &rsp);",
          "2317:   }",
          "",
          "[Removed Lines]",
          "2314:    rsp.status = cpu_to_le16(0);",
          "",
          "[Added Lines]",
          "2321:    rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
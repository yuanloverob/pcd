{
  "cve_id": "CVE-2021-32672",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. When using the Redis Lua Debugger, users can send malformed requests that cause the debugger\u2019s protocol parser to read data beyond the actual buffer. This issue affects all versions of Redis with Lua debugging support (3.2 or newer). The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14.",
  "repo": "redis/redis",
  "patch_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
  "patch_info": {
    "commit_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
    "files": [
      "src/scripting.c",
      "tests/unit/scripting.tcl"
    ],
    "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
    "before_after_code_files": [
      "src/scripting.c||src/scripting.c",
      "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
    ]
  },
  "patch_diff": {
    "src/scripting.c||src/scripting.c": [
      "File: src/scripting.c -> src/scripting.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2030:     sds *argv = NULL;",
      "2031:     int argc = 0;",
      "2032:     if (sdslen(ldb.cbuf) == 0) return NULL;",
      "",
      "[Removed Lines]",
      "2029: sds *ldbReplParseCommand(int *argcp) {",
      "",
      "[Added Lines]",
      "2029: sds *ldbReplParseCommand(int *argcp, char** err) {",
      "2030:     static char* protocol_error = \"protocol error\";",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2044:     p = strchr(p,'*'); if (!p) goto protoerr;",
      "2049:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
      "",
      "[Removed Lines]",
      "2046:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
      "",
      "[Added Lines]",
      "2047:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2052:     argv = zmalloc(sizeof(sds)*(*argcp));",
      "2053:     argc = 0;",
      "2054:     while(argc < *argcp) {",
      "2055:         if (*p != '$') goto protoerr;",
      "2060:         if (slen <= 0 || slen > 1024) goto protoerr;",
      "2061:         argv[argc++] = sdsnewlen(p,slen);",
      "2063:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
      "",
      "[Removed Lines]",
      "2057:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
      "",
      "[Added Lines]",
      "2057:         if (*p == '\\0') goto keep_reading;",
      "2061:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
      "2065:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2067:     return argv;",
      "2069: protoerr:",
      "2070:     sdsfreesplitres(argv,argc);",
      "2071:     sdsfree(copy);",
      "2072:     return NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2076: keep_reading:",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2555: int ldbRepl(lua_State *lua) {",
      "2556:     sds *argv;",
      "2557:     int argc;",
      "2561:     while(1) {",
      "2563:             char buf[1024];",
      "2564:             int nread = connRead(ldb.conn,buf,sizeof(buf));",
      "2565:             if (nread <= 0) {",
      "",
      "[Removed Lines]",
      "2562:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
      "",
      "[Added Lines]",
      "2565:     char* err = NULL;",
      "2570:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
      "2572:             if (err) {",
      "2573:                 lua_pushstring(lua, err);",
      "2574:                 lua_error(lua);",
      "2575:             }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2570:                 return C_ERR;",
      "2571:             }",
      "2572:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
      "2573:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2588:             if (sdslen(ldb.cbuf) > 1<<20) {",
      "2589:                 sdsfree(ldb.cbuf);",
      "2590:                 ldb.cbuf = sdsempty();",
      "2591:                 lua_pushstring(lua, \"max client buffer reached\");",
      "2592:                 lua_error(lua);",
      "2593:             }",
      "",
      "---------------"
    ],
    "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
      "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "820:     r eval {return 'hello'} 0",
      "821:     r eval {return 'hello'} 0",
      "822: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "824: start_server {tags {\"scripting needs:debug external:skip\"}} {",
      "825:     test {Test scripting debug protocol parsing} {",
      "826:         r script debug sync",
      "827:         r eval {return 'hello'} 0",
      "828:         catch {r 'hello\\0world'} e",
      "829:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "830:         catch {r 'hello\\0'} e",
      "831:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "832:         catch {r '\\0hello'} e",
      "833:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "834:         catch {r '\\0hello\\0'} e",
      "835:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "836:     }",
      "837: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
      "candidate_info": {
        "commit_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "files": [
          "src/rio.c"
        ],
        "message": "more strict check in rioConnRead (#7564)\n\n(cherry picked from commit da840e9851bab8d1674e245a812b2105be111208)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "[Added Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "03cb27e8ecd456a008192fcb7cb274dab7872335",
      "candidate_info": {
        "commit_hash": "03cb27e8ecd456a008192fcb7cb274dab7872335",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/03cb27e8ecd456a008192fcb7cb274dab7872335",
        "files": [
          "src/config.h"
        ],
        "message": "Fix the wrong detection of sync_file_range system call (#9371)\n\nIf we want to check `defined(SYNC_FILE_RANGE_WAIT_BEFORE)`, we should include fcntl.h.\notherwise, SYNC_FILE_RANGE_WAIT_BEFORE is not defined, and there is alway not `sync_file_range` system call.\nIntroduced by #8532\n\n(cherry picked from commit 8edc3cd62c0d0508b68c887610ca53b632b8165b)",
        "before_after_code_files": [
          "src/config.h||src/config.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/config.h||src/config.h": [
          "File: src/config.h -> src/config.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #ifdef __linux__",
          "38: #include <features.h>",
          "39: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: #include <fcntl.h>",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "aabe95125d2cc5d315da575e64bebc8680607fc1",
      "candidate_info": {
        "commit_hash": "aabe95125d2cc5d315da575e64bebc8680607fc1",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/aabe95125d2cc5d315da575e64bebc8680607fc1",
        "files": [
          "src/ae_kqueue.c"
        ],
        "message": "Fix the timing of read and write events under kqueue (#9416)\n\nNormally we execute the read event first and then the write event.\nWhen the barrier is set, we will do it reverse.\nHowever, under `kqueue`, if an `fd` has both read and write events,\nreading the event using `kevent` will generate two events, which will\nresult in uncontrolled read and write timing.\n\nThis also means that the guarantees of AOF `appendfsync` = `always` are\nnot met on MacOS without this fix.\n\nThe main change to this pr is to cache the events already obtained when reading\nthem, so that if the same `fd` occurs again, only the mask in the cache is updated,\nrather than a new event is generated.\n\nThis was exposed by the following test failure on MacOS:\n```\n*** [err]: AOF fsync always barrier issue in tests/integration/aof.tcl\nExpected 544 != 544 (context: type eval line 26 cmd {assert {$size1 != $size2}} proc ::test)\n```\n\n(cherry picked from commit 306a5ccd2d053ff653988b61a779e3cbce408874)",
        "before_after_code_files": [
          "src/ae_kqueue.c||src/ae_kqueue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/ae_kqueue.c||src/ae_kqueue.c": [
          "File: src/ae_kqueue.c -> src/ae_kqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: typedef struct aeApiState {",
          "37:     int kqfd;",
          "38:     struct kevent *events;",
          "39: } aeApiState;",
          "41: static int aeApiCreate(aeEventLoop *eventLoop) {",
          "42:     aeApiState *state = zmalloc(sizeof(aeApiState));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43:     char *eventsMask;",
          "46: #define EVENT_MASK_MALLOC_SIZE(sz) (((sz) + 3) / 4)",
          "47: #define EVENT_MASK_OFFSET(fd) ((fd) % 4 * 2)",
          "48: #define EVENT_MASK_ENCODE(fd, mask) (((mask) & 0x3) << EVENT_MASK_OFFSET(fd))",
          "50: static inline int getEventMask(const char *eventsMask, int fd) {",
          "51:     return (eventsMask[fd/4] >> EVENT_MASK_OFFSET(fd)) & 0x3;",
          "52: }",
          "54: static inline void addEventMask(char *eventsMask, int fd, int mask) {",
          "55:     eventsMask[fd/4] |= EVENT_MASK_ENCODE(fd, mask);",
          "56: }",
          "58: static inline void resetEventMask(char *eventsMask, int fd) {",
          "59:     eventsMask[fd/4] &= ~EVENT_MASK_ENCODE(fd, 0x3);",
          "60: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:         zfree(state);",
          "54:         return -1;",
          "55:     }",
          "56:     eventLoop->apidata = state;",
          "57:     return 0;",
          "58: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77:     state->eventsMask = zmalloc(EVENT_MASK_MALLOC_SIZE(eventLoop->setsize));",
          "78:     memset(state->eventsMask, 0, EVENT_MASK_MALLOC_SIZE(eventLoop->setsize));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:     aeApiState *state = eventLoop->apidata;",
          "63:     state->events = zrealloc(state->events, sizeof(struct kevent)*setsize);",
          "64:     return 0;",
          "65: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:     state->eventsMask = zrealloc(state->eventsMask, EVENT_MASK_MALLOC_SIZE(setsize));",
          "88:     memset(state->eventsMask, 0, EVENT_MASK_MALLOC_SIZE(setsize));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:     close(state->kqfd);",
          "71:     zfree(state->events);",
          "72:     zfree(state);",
          "73: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97:     zfree(state->eventsMask);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "119:     if (retval > 0) {",
          "120:         int j;",
          "125:             struct kevent *e = state->events+j;",
          "131:         }",
          "132:     }",
          "133:     return numevents;",
          "",
          "[Removed Lines]",
          "122:         numevents = retval;",
          "123:         for(j = 0; j < numevents; j++) {",
          "124:             int mask = 0;",
          "127:             if (e->filter == EVFILT_READ) mask |= AE_READABLE;",
          "128:             if (e->filter == EVFILT_WRITE) mask |= AE_WRITABLE;",
          "129:             eventLoop->fired[j].fd = e->ident;",
          "130:             eventLoop->fired[j].mask = mask;",
          "",
          "[Added Lines]",
          "155:         for (j = 0; j < retval; j++) {",
          "157:             int fd = e->ident;",
          "158:             int mask = 0;",
          "160:             if (e->filter == EVFILT_READ) mask = AE_READABLE;",
          "161:             else if (e->filter == EVFILT_WRITE) mask = AE_WRITABLE;",
          "162:             addEventMask(state->eventsMask, fd, mask);",
          "163:         }",
          "167:         numevents = 0;",
          "168:         for (j = 0; j < retval; j++) {",
          "169:             struct kevent *e = state->events+j;",
          "170:             int fd = e->ident;",
          "171:             int mask = getEventMask(state->eventsMask, fd);",
          "173:             if (mask) {",
          "174:                 eventLoop->fired[numevents].fd = fd;",
          "175:                 eventLoop->fired[numevents].mask = mask;",
          "176:                 resetEventMask(state->eventsMask, fd);",
          "177:                 numevents++;",
          "178:             }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12a6b438a34b064389f347a09970237fc5f616d1",
      "candidate_info": {
        "commit_hash": "12a6b438a34b064389f347a09970237fc5f616d1",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/12a6b438a34b064389f347a09970237fc5f616d1",
        "files": [
          "src/rio.c"
        ],
        "message": "Fix harmless bug in rioConnRead (#7557)\n\nthis code is in use only if the master is disk-based, and the replica is\ndiskless. In this case we use a buffered reader, but we must avoid reading\npast the rdb file, into the command stream. which Luckly rdb.c doesn't\nreally attempt to do (it knows how much it should read).\n\nWhen rioConnRead detects that the extra buffering attempt reaches beyond\nthe read limit it should read less, but if the caller actually requested\nmore, then it should return with an error rather than a short read. the\nbug would have resulted in short read.\n\nin order to fix it, the code must consider the real requested size, and\nnot the extra buffering size.\n\n(cherry picked from commit 40d7fca3685d8439bae8480ddbd59775a2390411)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:     while (len > sdslen(r->io.conn.buf) - r->io.conn.pos) {",
          "192:         size_t buffered = sdslen(r->io.conn.buf) - r->io.conn.pos;",
          "197:         if (toread > sdsavail(r->io.conn.buf)) toread = sdsavail(r->io.conn.buf);",
          "198:         if (r->io.conn.read_limit != 0 &&",
          "199:             r->io.conn.read_so_far + buffered + toread > r->io.conn.read_limit)",
          "200:         {",
          "202:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "203:             else {",
          "204:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "193:         size_t toread = len - buffered;",
          "196:         if (toread < PROTO_IOBUF_LEN) toread = PROTO_IOBUF_LEN;",
          "201:             if (r->io.conn.read_limit >= r->io.conn.read_so_far - buffered)",
          "",
          "[Added Lines]",
          "193:         size_t needs = len - buffered;",
          "196:         size_t toread = needs < PROTO_IOBUF_LEN ? PROTO_IOBUF_LEN: needs;",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
      "candidate_info": {
        "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "files": [
          "src/scripting.c"
        ],
        "message": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\u00a0 \u00a0to explode the LUA stack (notice that currently there is no such\n\u00a0 \u00a0command in Redis that returns such a nested reply, but modules might\n\u00a0 \u00a0do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n\u00a0 \u00a0explode the LUA stack (all the arguments will be pushed to the LUA\n\u00a0 \u00a0stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [
            "src/scripting.c||src/scripting.c"
          ],
          "candidate": [
            "src/scripting.c||src/scripting.c"
          ]
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130: char *redisProtocolToLuaType(lua_State *lua, char* reply) {",
          "131:     char *p = reply;",
          "133:     switch(*p) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:     if (!lua_checkstack(lua, 5)) {",
          "138:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "139:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:             if (atype == '%') {",
          "221:                 p = redisProtocolToLuaType(lua,p);",
          "222:             } else {",
          "223:                 lua_pushboolean(lua,1);",
          "224:             }",
          "225:             lua_settable(lua,-3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:                 if (!lua_checkstack(lua, 1)) {",
          "236:                     serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "237:                 }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "341: void luaReplyToRedisReply(client *c, lua_State *lua) {",
          "342:     int t = lua_type(lua,-1);",
          "344:     switch(t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "358:     if (!lua_checkstack(lua, 4)) {",
          "363:         addReplyErrorFormat(c, \"reached lua stack limit\");",
          "364:         lua_pop(lua,1); // pop the element from the stack",
          "365:         return;",
          "366:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2506: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
          "2507:     int j, saved_rc = server.lua_replicate_commands;",
          "2509:     lua_getglobal(lua,\"redis\");",
          "2510:     lua_pushstring(lua,\"call\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2539:     if (!lua_checkstack(lua, argc + 1)) {",
          "2546:         ldbLogRedisReply(\"max lua stack reached\");",
          "2547:         return;",
          "2548:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
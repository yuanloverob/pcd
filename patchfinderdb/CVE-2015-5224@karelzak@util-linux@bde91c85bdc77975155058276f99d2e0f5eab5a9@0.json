{
  "cve_id": "CVE-2015-5224",
  "cve_desc": "The mkostemp function in login-utils in util-linux when used incorrectly allows remote attackers to cause file name collision and possibly other attacks.",
  "repo": "karelzak/util-linux",
  "patch_hash": "bde91c85bdc77975155058276f99d2e0f5eab5a9",
  "patch_info": {
    "commit_hash": "bde91c85bdc77975155058276f99d2e0f5eab5a9",
    "repo": "karelzak/util-linux",
    "commit_url": "https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9",
    "files": [
      "include/fileutils.h",
      "lib/fileutils.c",
      "login-utils/chfn.c",
      "login-utils/chsh.c",
      "login-utils/setpwnam.c",
      "login-utils/setpwnam.h",
      "login-utils/vipw.c"
    ],
    "message": "chsh, chfn, vipw: fix filenames collision\n\nThe utils when compiled WITHOUT libuser then mkostemp()ing\n\"/etc/%s.XXXXXX\" where the filename prefix is argv[0] basename.\n\nAn attacker could repeatedly execute the util with modified argv[0]\nand after many many attempts mkostemp() may generate suffix which\nmakes sense. The result maybe temporary file with name like rc.status\nld.so.preload or krb5.keytab, etc.\n\nNote that distros usually use libuser based ch{sh,fn} or stuff from\nshadow-utils.\n\nIt's probably very minor security bug.\n\nAddresses: CVE-2015-5224\nSigned-off-by: Karel Zak <kzak@redhat.com>",
    "before_after_code_files": [
      "include/fileutils.h||include/fileutils.h",
      "lib/fileutils.c||lib/fileutils.c",
      "login-utils/chfn.c||login-utils/chfn.c",
      "login-utils/chsh.c||login-utils/chsh.c",
      "login-utils/setpwnam.c||login-utils/setpwnam.c",
      "login-utils/setpwnam.h||login-utils/setpwnam.h",
      "login-utils/vipw.c||login-utils/vipw.c"
    ]
  },
  "patch_diff": {
    "include/fileutils.h||include/fileutils.h": [
      "File: include/fileutils.h -> include/fileutils.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: #include \"c.h\"",
      "13: {",
      "14:  int fd;",
      "15:  FILE *ret;",
      "18:  if (fd == -1)",
      "19:   return NULL;",
      "",
      "[Removed Lines]",
      "10: extern int xmkstemp(char **tmpname, char *dir);",
      "12: static inline FILE *xfmkstemp(char **tmpname, char *dir)",
      "17:  fd = xmkstemp(tmpname, dir);",
      "",
      "[Added Lines]",
      "10: extern int xmkstemp(char **tmpname, const char *dir, const char *prefix);",
      "12: static inline FILE *xfmkstemp(char **tmpname, const char *dir, const char *prefix)",
      "17:  fd = xmkstemp(tmpname, dir, prefix);",
      "",
      "---------------"
    ],
    "lib/fileutils.c||lib/fileutils.c": [
      "File: lib/fileutils.c -> lib/fileutils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "19: {",
      "20:  char *localtmp;",
      "22:  mode_t old_mode;",
      "23:  int fd, rc;",
      "39:  if (rc < 0)",
      "40:   return -1;",
      "",
      "[Removed Lines]",
      "18: int xmkstemp(char **tmpname, char *dir)",
      "21:  char *tmpenv;",
      "27:  if (dir != NULL)",
      "28:   tmpenv = dir;",
      "29:  else",
      "30:   tmpenv = getenv(\"TMPDIR\");",
      "32:  if (tmpenv)",
      "33:   rc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,",
      "34:      program_invocation_short_name);",
      "35:  else",
      "36:   rc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,",
      "37:      program_invocation_short_name);",
      "",
      "[Added Lines]",
      "18: int xmkstemp(char **tmpname, const char *dir, const char *prefix)",
      "21:  const char *tmpenv;",
      "27:  tmpenv = dir ? dir : getenv(\"TMPDIR\");",
      "28:  if (!tmpenv)",
      "29:   tmpenv = _PATH_TMP;",
      "31:  rc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv, prefix);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "107: {",
      "108:  FILE *f;",
      "109:  char *tmpname;",
      "111:  unlink(tmpname);",
      "112:  free(tmpname);",
      "113:  fclose(f);",
      "",
      "[Removed Lines]",
      "110:  f = xfmkstemp(&tmpname, NULL);",
      "",
      "[Added Lines]",
      "103:  f = xfmkstemp(&tmpname, NULL, \"test\");",
      "",
      "---------------"
    ],
    "login-utils/chfn.c||login-utils/chfn.c": [
      "File: login-utils/chfn.c -> login-utils/chfn.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "375:  ctl->pw->pw_gecos = gecos;",
      "377:   warn(\"setpwnam failed\");",
      "378: #endif",
      "379:   printf(_",
      "",
      "[Removed Lines]",
      "376:  if (setpwnam(ctl->pw) < 0) {",
      "",
      "[Added Lines]",
      "376:  if (setpwnam(ctl->pw, \".chfn\") < 0) {",
      "",
      "---------------"
    ],
    "login-utils/chsh.c||login-utils/chsh.c": [
      "File: login-utils/chsh.c -> login-utils/chsh.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "323:   errx(EXIT_FAILURE, _(\"Shell *NOT* changed.  Try again later.\"));",
      "324: #else",
      "325:  pw->pw_shell = info.shell;",
      "327:   err(EXIT_FAILURE, _(\"setpwnam failed\\n\"",
      "328:    \"Shell *NOT* changed.  Try again later.\"));",
      "329: #endif",
      "",
      "[Removed Lines]",
      "326:  if (setpwnam(pw) < 0)",
      "",
      "[Added Lines]",
      "326:  if (setpwnam(pw, \".chsh\") < 0)",
      "",
      "---------------"
    ],
    "login-utils/setpwnam.c||login-utils/setpwnam.c": [
      "File: login-utils/setpwnam.c -> login-utils/setpwnam.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "75: {",
      "76:  FILE *fp = NULL, *pwf = NULL;",
      "77:  int save_errno;",
      "",
      "[Removed Lines]",
      "74: int setpwnam(struct passwd *pwd)",
      "",
      "[Added Lines]",
      "74: int setpwnam(struct passwd *pwd, const char *prefix)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "81:  int contlen, rc;",
      "82:  char *linebuf = NULL;",
      "83:  char *tmpname = NULL;",
      "86:  pw_init();",
      "89:   return -1;",
      "",
      "[Removed Lines]",
      "84:  char *atomic_dir = \"/etc\";",
      "88:  if ((fp = xfmkstemp(&tmpname, atomic_dir)) == NULL)",
      "",
      "[Added Lines]",
      "87:  if ((fp = xfmkstemp(&tmpname, \"/etc\", prefix)) == NULL)",
      "",
      "---------------"
    ],
    "login-utils/setpwnam.h||login-utils/setpwnam.h": [
      "File: login-utils/setpwnam.h -> login-utils/setpwnam.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: #include \"pathnames.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "14: #ifndef UTIL_LINUX_SETPWNAM_H",
      "15: #define UTIL_LINUX_SETPWNAM_H",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "26: # define SGROUP_FILE \"/tmp/gshadow\"",
      "27: #endif",
      "",
      "[Removed Lines]",
      "29: extern int setpwnam (struct passwd *pwd);",
      "",
      "[Added Lines]",
      "31: extern int setpwnam (struct passwd *pwd, const char *prefix);",
      "",
      "---------------"
    ],
    "login-utils/vipw.c||login-utils/vipw.c": [
      "File: login-utils/vipw.c -> login-utils/vipw.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "135: {",
      "136:  FILE *fd;",
      "137:  char *tmpname = NULL;",
      "141:   ulckpwdf();",
      "142:   err(EXIT_FAILURE, _(\"can't open temporary file\"));",
      "143:  }",
      "",
      "[Removed Lines]",
      "138:  char *dir = \"/etc\";",
      "140:  if ((fd = xfmkstemp(&tmpname, dir)) == NULL) {",
      "",
      "[Added Lines]",
      "139:  if ((fd = xfmkstemp(&tmpname, \"/etc\", \".vipw\")) == NULL) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5fe1c32f61d2ba0d1ec91767bf11a978a934f6a3",
      "candidate_info": {
        "commit_hash": "5fe1c32f61d2ba0d1ec91767bf11a978a934f6a3",
        "repo": "karelzak/util-linux",
        "commit_url": "https://github.com/karelzak/util-linux/commit/5fe1c32f61d2ba0d1ec91767bf11a978a934f6a3",
        "files": [
          "login-utils/chfn.c"
        ],
        "message": "chfn: move new and old finger structs to chfn control struct\n\nThis change is a little bit messy, and requires a comment the struct\nfinfo should not have 'struct passwd *pw' as it's member.  The earlier\nstruct design would have been burden to maintain, and confusing to use.\n\nSigned-off-by: Sami Kerola <kerolasa@iki.fi>",
        "before_after_code_files": [
          "login-utils/chfn.c||login-utils/chfn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "login-utils/chfn.c||login-utils/chfn.c"
          ],
          "candidate": [
            "login-utils/chfn.c||login-utils/chfn.c"
          ]
        }
      },
      "candidate_diff": {
        "login-utils/chfn.c||login-utils/chfn.c": [
          "File: login-utils/chfn.c -> login-utils/chfn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: #endif",
          "57: struct finfo {",
          "60:  char *full_name;",
          "61:  char *office;",
          "62:  char *office_phone;",
          "",
          "[Removed Lines]",
          "58:  struct passwd *pw;",
          "59:  char *username;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65: };",
          "67: struct chfn_control {",
          "68:  unsigned int",
          "70: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:  struct passwd *pw;",
          "67:  char *username;",
          "72:  struct finfo oldf, newf;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126: {",
          "127:  int index, c, status = 0;",
          "128:  static const struct option long_options[] = {",
          "",
          "[Removed Lines]",
          "124: static void parse_argv(struct chfn_control *ctl, int argc, char *argv[],",
          "125:          struct finfo *pinfo)",
          "",
          "[Added Lines]",
          "129: static void parse_argv(struct chfn_control *ctl, int argc, char **argv)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "139:     &index)) != -1) {",
          "140:   switch (c) {",
          "141:   case 'f':",
          "143:    status += check_gecos_string(_(\"Name\"), optarg);",
          "144:    break;",
          "145:   case 'o':",
          "147:    status += check_gecos_string(_(\"Office\"), optarg);",
          "148:    break;",
          "149:   case 'p':",
          "151:    status += check_gecos_string(_(\"Office Phone\"), optarg);",
          "152:    break;",
          "153:   case 'h':",
          "155:    status += check_gecos_string(_(\"Home Phone\"), optarg);",
          "156:    break;",
          "157:   case 'v':",
          "",
          "[Removed Lines]",
          "142:    pinfo->full_name = optarg;",
          "146:    pinfo->office = optarg;",
          "150:    pinfo->office_phone = optarg;",
          "154:    pinfo->home_phone = optarg;",
          "",
          "[Added Lines]",
          "146:    ctl->newf.full_name = optarg;",
          "150:    ctl->newf.office = optarg;",
          "154:    ctl->newf.office_phone = optarg;",
          "158:    ctl->newf.home_phone = optarg;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "170:  if (optind < argc) {",
          "171:   if (optind + 1 < argc)",
          "172:    usage(stderr);",
          "174:  }",
          "175:  return;",
          "176: }",
          "",
          "[Removed Lines]",
          "173:   pinfo->username = argv[optind];",
          "",
          "[Added Lines]",
          "177:   ctl->username = argv[optind];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "183: {",
          "184:  char *gecos;",
          "187:   return;",
          "200: }",
          "",
          "[Removed Lines]",
          "182: static void parse_passwd(struct passwd *pw, struct finfo *pinfo)",
          "186:  if (!pw)",
          "188:  pinfo->pw = pw;",
          "189:  pinfo->username = pw->pw_name;",
          "191:  gecos = xstrdup(pw->pw_gecos);",
          "193:  pinfo->full_name = strsep(&gecos, \",\");",
          "194:  pinfo->office = strsep(&gecos, \",\");",
          "195:  pinfo->office_phone = strsep(&gecos, \",\");",
          "196:  pinfo->home_phone = strsep(&gecos, \",\");",
          "199:  pinfo->other = strsep(&gecos, \",\");",
          "",
          "[Added Lines]",
          "186: static void parse_passwd(struct chfn_control *ctl)",
          "190:  if (!ctl->pw)",
          "193:  gecos = xstrdup(ctl->pw->pw_gecos);",
          "195:  ctl->oldf.full_name = strsep(&gecos, \",\");",
          "196:  ctl->oldf.office = strsep(&gecos, \",\");",
          "197:  ctl->oldf.office_phone = strsep(&gecos, \",\");",
          "198:  ctl->oldf.home_phone = strsep(&gecos, \",\");",
          "201:  ctl->oldf.other = strsep(&gecos, \",\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "238: {",
          "243:  printf(\"\\n\");",
          "244: }",
          "",
          "[Removed Lines]",
          "237: static void ask_info(struct finfo *oldfp, struct finfo *newfp)",
          "239:  newfp->full_name = prompt(_(\"Name\"), oldfp->full_name);",
          "240:  newfp->office = prompt(_(\"Office\"), oldfp->office);",
          "241:  newfp->office_phone = prompt(_(\"Office Phone\"), oldfp->office_phone);",
          "242:  newfp->home_phone = prompt(_(\"Home Phone\"), oldfp->home_phone);",
          "",
          "[Added Lines]",
          "239: static void ask_info(struct chfn_control *ctl)",
          "241:  ctl->newf.full_name = prompt(_(\"Name\"), ctl->oldf.full_name);",
          "242:  ctl->newf.office = prompt(_(\"Office\"), ctl->oldf.office);",
          "243:  ctl->newf.office_phone = prompt(_(\"Office Phone\"), ctl->oldf.office_phone);",
          "244:  ctl->newf.home_phone = prompt(_(\"Home Phone\"), ctl->oldf.home_phone);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "251: {",
          "252:  int changed = false;",
          "256:   changed = true;",
          "260:   changed = true;",
          "264:   changed = true;",
          "268:   changed = true;",
          "271:  return changed;",
          "272: }",
          "",
          "[Removed Lines]",
          "250: static int set_changed_data(struct finfo *oldfp, struct finfo *newfp)",
          "254:  if (newfp->full_name) {",
          "255:   oldfp->full_name = newfp->full_name;",
          "257:  }",
          "258:  if (newfp->office) {",
          "259:   oldfp->office = newfp->office;",
          "261:  }",
          "262:  if (newfp->office_phone) {",
          "263:   oldfp->office_phone = newfp->office_phone;",
          "265:  }",
          "266:  if (newfp->home_phone) {",
          "267:   oldfp->home_phone = newfp->home_phone;",
          "269:  }",
          "",
          "[Added Lines]",
          "252: static int set_changed_data(struct chfn_control *ctl)",
          "256:  if (ctl->newf.full_name)",
          "258:  else",
          "259:   ctl->newf.full_name = ctl->oldf.full_name;",
          "260:  if (ctl->newf.office)",
          "262:  else",
          "263:   ctl->newf.office = ctl->oldf.office;",
          "264:  if (ctl->newf.office_phone)",
          "266:  else",
          "267:   ctl->newf.office_phone = ctl->oldf.office_phone;",
          "268:  if (ctl->newf.home_phone)",
          "270:  else",
          "271:   ctl->newf.home_phone = ctl->oldf.home_phone;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "280: {",
          "281:  char *gecos;",
          "282:  int len;",
          "302:   while (len > 0 && gecos[len - 1] == ',')",
          "303:    len--;",
          "304:   gecos[len] = 0;",
          "305:  }",
          "307: #ifdef HAVE_LIBUSER",
          "309:    LU_GECOS, gecos) < 0) {",
          "314:   warn(\"setpwnam failed\");",
          "315: #endif",
          "316:   printf(_",
          "",
          "[Removed Lines]",
          "279: static int save_new_data(struct finfo *pinfo)",
          "285:  if (!pinfo->full_name)",
          "286:   pinfo->full_name = \"\";",
          "287:  if (!pinfo->office)",
          "288:   pinfo->office = \"\";",
          "289:  if (!pinfo->office_phone)",
          "290:   pinfo->office_phone = \"\";",
          "291:  if (!pinfo->home_phone)",
          "292:   pinfo->home_phone = \"\";",
          "293:  if (!pinfo->other)",
          "294:   pinfo->other = \"\";",
          "297:  len = xasprintf(&gecos, \"%s,%s,%s,%s,%s\", pinfo->full_name, pinfo->office,",
          "298:     pinfo->office_phone, pinfo->home_phone, pinfo->other);",
          "301:  if (!pinfo->other[0]) {",
          "308:  if (set_value_libuser(\"chfn\", pinfo->pw->pw_name, pinfo->pw->pw_uid,",
          "312:  pinfo->pw->pw_gecos = gecos;",
          "313:  if (setpwnam(pinfo->pw) < 0) {",
          "",
          "[Added Lines]",
          "280: static int save_new_data(struct chfn_control *ctl)",
          "286:  if (!ctl->newf.full_name)",
          "287:   ctl->newf.full_name = \"\";",
          "288:  if (!ctl->newf.office)",
          "289:   ctl->newf.office = \"\";",
          "290:  if (!ctl->newf.office_phone)",
          "291:   ctl->newf.office_phone = \"\";",
          "292:  if (!ctl->newf.home_phone)",
          "293:   ctl->newf.home_phone = \"\";",
          "294:  if (!ctl->newf.other)",
          "295:   ctl->newf.other = \"\";",
          "298:  len = xasprintf(&gecos, \"%s,%s,%s,%s,%s\", ctl->newf.full_name, ctl->newf.office,",
          "299:     ctl->newf.office_phone, ctl->newf.home_phone, ctl->newf.other);",
          "302:  if (!ctl->newf.other[0]) {",
          "309:  if (set_value_libuser(\"chfn\", ctl->username, ctl->pw->pw_uid,",
          "313:  ctl->pw->pw_gecos = gecos;",
          "314:  if (setpwnam(ctl->pw) < 0) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "325: int main(int argc, char **argv)",
          "326: {",
          "327:  uid_t uid;",
          "329:  struct chfn_control ctl = {",
          "330:   .interactive = 1",
          "331:  };",
          "",
          "[Removed Lines]",
          "328:  struct finfo oldf, newf;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "335:  bindtextdomain(PACKAGE, LOCALEDIR);",
          "336:  textdomain(PACKAGE);",
          "337:  atexit(close_stdout);",
          "350:  uid = getuid();",
          "358:    errx(EXIT_FAILURE, _(\"you (user %d) don't exist.\"),",
          "359:         uid);",
          "360:  } else {",
          "363:    errx(EXIT_FAILURE, _(\"user \\\"%s\\\" does not exist.\"),",
          "365:  }",
          "367: #ifndef HAVE_LIBUSER",
          "369:   errx(EXIT_FAILURE, _(\"can only change local entries\"));",
          "370: #endif",
          "372: #ifdef HAVE_LIBSELINUX",
          "373:  if (is_selinux_enabled() > 0) {",
          "374:   if (uid == 0) {",
          "376:     security_context_t user_context;",
          "377:     if (getprevcon(&user_context) < 0)",
          "378:      user_context = NULL;",
          "",
          "[Removed Lines]",
          "351:  memset(&oldf, 0, sizeof(oldf));",
          "352:  memset(&newf, 0, sizeof(newf));",
          "354:  parse_argv(&ctl, argc, argv, &newf);",
          "355:  if (!newf.username) {",
          "356:   parse_passwd(getpwuid(uid), &oldf);",
          "357:   if (!oldf.username)",
          "361:   parse_passwd(getpwnam(newf.username), &oldf);",
          "362:   if (!oldf.username)",
          "364:         newf.username);",
          "368:  if (!(is_local(oldf.username)))",
          "375:    if (checkAccess(oldf.username, PASSWD__CHFN) != 0) {",
          "",
          "[Added Lines]",
          "340:  parse_argv(&ctl, argc, argv);",
          "341:  if (!ctl.username) {",
          "342:   ctl.pw = getpwuid(uid);",
          "343:   if (!ctl.pw)",
          "346:   ctl.username = ctl.pw->pw_name;",
          "348:   ctl.pw = getpwnam(ctl.username);",
          "349:   if (!ctl.pw)",
          "351:         ctl.username);",
          "353:  parse_passwd(&ctl);",
          "355:  if (!(is_local(ctl.username)))",
          "362:    if (checkAccess(ctl.username, PASSWD__CHFN) != 0) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "380:          _(\"%s is not authorized to change \"",
          "381:            \"the finger info of %s\"),",
          "382:          user_context ? : _(\"Unknown user context\"),",
          "384:    }",
          "385:   }",
          "386:   if (setupDefaultContext(_PATH_PASSWD))",
          "",
          "[Removed Lines]",
          "383:          oldf.username);",
          "",
          "[Added Lines]",
          "370:          ctl.username);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "392: #ifdef HAVE_LIBUSER",
          "395: #else",
          "397: #endif",
          "398:   errno = EACCES;",
          "399:   err(EXIT_FAILURE, _(\"running UID doesn't match UID of user we're \"",
          "400:         \"altering, change denied\"));",
          "401:  }",
          "405: #if !defined(HAVE_LIBUSER) && defined(CHFN_CHSH_PASSWORD)",
          "407:   return EXIT_FAILURE;",
          "408:  }",
          "409: #endif",
          "411:  if (ctl.interactive)",
          "415:   printf(_(\"Finger information not changed.\\n\"));",
          "416:   return EXIT_SUCCESS;",
          "417:  }",
          "420: }",
          "",
          "[Removed Lines]",
          "394:  if (geteuid() != getuid() && uid != oldf.pw->pw_uid) {",
          "396:  if (uid != 0 && uid != oldf.pw->pw_uid) {",
          "403:  printf(_(\"Changing finger information for %s.\\n\"), oldf.username);",
          "406:  if(!auth_pam(\"chfn\", uid, oldf.username)) {",
          "412:   ask_info(&oldf, &newf);",
          "414:  if (!set_changed_data(&oldf, &newf)) {",
          "419:  return save_new_data(&oldf) == 0 ? EXIT_SUCCESS : EXIT_FAILURE;",
          "",
          "[Added Lines]",
          "381:  if (geteuid() != getuid() && uid != ctl.pw->pw_uid) {",
          "383:  if (uid != 0 && uid != ctl.oldf.pw->pw_uid) {",
          "390:  printf(_(\"Changing finger information for %s.\\n\"), ctl.username);",
          "393:  if (!auth_pam(\"chfn\", uid, ctl.username)) {",
          "399:   ask_info(&ctl);",
          "401:  if (!set_changed_data(&ctl)) {",
          "406:  return save_new_data(&ctl) == 0 ? EXIT_SUCCESS : EXIT_FAILURE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5eef61296f9457fb9ad8a655d9415e8b10468999",
      "candidate_info": {
        "commit_hash": "5eef61296f9457fb9ad8a655d9415e8b10468999",
        "repo": "karelzak/util-linux",
        "commit_url": "https://github.com/karelzak/util-linux/commit/5eef61296f9457fb9ad8a655d9415e8b10468999",
        "files": [
          "login-utils/chsh.c"
        ],
        "message": "chsh: remove function prototypes\n\nSigned-off-by: Sami Kerola <kerolasa@iki.fi>",
        "before_after_code_files": [
          "login-utils/chsh.c||login-utils/chsh.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "login-utils/chsh.c||login-utils/chsh.c"
          ],
          "candidate": [
            "login-utils/chsh.c||login-utils/chsh.c"
          ]
        }
      },
      "candidate_diff": {
        "login-utils/chsh.c||login-utils/chsh.c": [
          "File: login-utils/chsh.c -> login-utils/chsh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  char *shell;",
          "62: };",
          "69: static void __attribute__((__noreturn__)) usage (FILE *fp)",
          "70: {",
          "",
          "[Removed Lines]",
          "64: static void parse_argv(int argc, char **argv, struct sinfo *pinfo);",
          "65: static char *prompt(char *question, char *def_val);",
          "66: static int check_shell(char *shell);",
          "67: static int get_shell_list(char *shell);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:  exit(fp == stderr ? EXIT_FAILURE : EXIT_SUCCESS);",
          "81: }",
          "84: {",
          "111:  }",
          "131:    }",
          "174:  }",
          "195: }",
          "",
          "[Removed Lines]",
          "83: int main(int argc, char **argv)",
          "85:  char *shell, *oldshell;",
          "86:  uid_t uid;",
          "87:  struct sinfo info;",
          "88:  struct passwd *pw;",
          "90:  sanitize_env();",
          "91:  setlocale(LC_ALL, \"\");",
          "92:  bindtextdomain(PACKAGE, LOCALEDIR);",
          "93:  textdomain(PACKAGE);",
          "94:  atexit(close_stdout);",
          "96:  uid = getuid();",
          "97:  memset(&info, 0, sizeof(info));",
          "99:  parse_argv(argc, argv, &info);",
          "100:  pw = NULL;",
          "101:  if (!info.username) {",
          "102:   pw = getpwuid(uid);",
          "103:   if (!pw)",
          "104:    errx(EXIT_FAILURE, _(\"you (user %d) don't exist.\"),",
          "105:         uid);",
          "106:  } else {",
          "107:   pw = getpwnam(info.username);",
          "108:   if (!pw)",
          "109:    errx(EXIT_FAILURE, _(\"user \\\"%s\\\" does not exist.\"),",
          "110:         info.username);",
          "113: #ifndef HAVE_LIBUSER",
          "114:  if (!(is_local(pw->pw_name)))",
          "115:   errx(EXIT_FAILURE, _(\"can only change local entries\"));",
          "116: #endif",
          "118: #ifdef HAVE_LIBSELINUX",
          "119:  if (is_selinux_enabled() > 0) {",
          "120:   if (uid == 0) {",
          "121:    if (checkAccess(pw->pw_name, PASSWD__CHSH) != 0) {",
          "122:     security_context_t user_context;",
          "123:     if (getprevcon(&user_context) < 0)",
          "124:      user_context =",
          "125:          (security_context_t) NULL;",
          "127:     errx(EXIT_FAILURE,",
          "128:          _(\"%s is not authorized to change the shell of %s\"),",
          "129:          user_context ? : _(\"Unknown user context\"),",
          "130:          pw->pw_name);",
          "132:   }",
          "133:   if (setupDefaultContext(_PATH_PASSWD) != 0)",
          "134:    errx(EXIT_FAILURE,",
          "135:         _(\"can't set default context for %s\"), _PATH_PASSWD);",
          "136:  }",
          "137: #endif",
          "139:  oldshell = pw->pw_shell;",
          "140:  if (oldshell == NULL || *oldshell == '\\0')",
          "144: #ifdef HAVE_LIBUSER",
          "146:  if (geteuid() != getuid() && uid != pw->pw_uid) {",
          "147: #else",
          "148:  if (uid != 0 && uid != pw->pw_uid) {",
          "149: #endif",
          "150:   errno = EACCES;",
          "151:   err(EXIT_FAILURE,",
          "152:       _(\"running UID doesn't match UID of user we're \"",
          "153:         \"altering, shell change denied\"));",
          "154:  }",
          "155:  if (uid != 0 && !get_shell_list(oldshell)) {",
          "156:   errno = EACCES;",
          "157:   err(EXIT_FAILURE, _(\"your shell is not in %s, \"",
          "158:         \"shell change denied\"), _PATH_SHELLS);",
          "159:  }",
          "161:  shell = info.shell;",
          "163:  printf(_(\"Changing shell for %s.\\n\"), pw->pw_name);",
          "165: #if !defined(HAVE_LIBUSER) && defined(CHFN_CHSH_PASSWORD)",
          "166:  if(!auth_pam(\"chsh\", uid, pw->pw_name)) {",
          "167:   return EXIT_FAILURE;",
          "168:  }",
          "169: #endif",
          "170:  if (!shell) {",
          "171:   shell = prompt(_(\"New shell\"), oldshell);",
          "172:   if (!shell)",
          "173:    return EXIT_SUCCESS;",
          "176:  if (check_shell(shell) < 0)",
          "177:   return EXIT_FAILURE;",
          "179:  if (strcmp(oldshell, shell) == 0)",
          "180:   errx(EXIT_SUCCESS, _(\"Shell not changed.\"));",
          "182: #ifdef HAVE_LIBUSER",
          "183:  if (set_value_libuser(\"chsh\", pw->pw_name, uid,",
          "184:      LU_LOGINSHELL, shell) < 0)",
          "185:   errx(EXIT_FAILURE, _(\"Shell *NOT* changed.  Try again later.\"));",
          "186: #else",
          "187:  pw->pw_shell = shell;",
          "188:  if (setpwnam(pw) < 0)",
          "189:   err(EXIT_FAILURE, _(\"setpwnam failed\\n\"",
          "190:    \"Shell *NOT* changed.  Try again later.\"));",
          "191: #endif",
          "193:  printf(_(\"Shell changed.\\n\"));",
          "194:  return EXIT_SUCCESS;",
          "",
          "[Added Lines]",
          "84: static int get_shell_list(char *shell_name)",
          "86:  FILE *fp;",
          "87:  int found;",
          "88:  int len;",
          "89:  char buf[PATH_MAX];",
          "91:  found = false;",
          "92:  fp = fopen(_PATH_SHELLS, \"r\");",
          "93:  if (!fp) {",
          "94:   if (!shell_name)",
          "95:    warnx(_(\"No known shells.\"));",
          "96:   return true;",
          "98:  while (fgets(buf, sizeof(buf), fp) != NULL) {",
          "100:   if (*buf == '#')",
          "101:    continue;",
          "102:   len = strlen(buf);",
          "104:   if (buf[len - 1] == '\\n')",
          "105:    buf[len - 1] = 0;",
          "107:   else",
          "108:    continue;",
          "110:   if (shell_name) {",
          "111:    if (!strcmp(shell_name, buf)) {",
          "112:     found = true;",
          "113:     break;",
          "115:   } else",
          "116:    printf(\"%s\\n\", buf);",
          "118:  fclose(fp);",
          "119:  return found;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "331:  return 0;",
          "332: }",
          "340: {",
          "352:  }",
          "369:    }",
          "372:  }",
          "375: }",
          "",
          "[Removed Lines]",
          "339: static int get_shell_list(char *shell_name)",
          "341:  FILE *fp;",
          "342:  int found;",
          "343:  int len;",
          "344:  char buf[PATH_MAX];",
          "346:  found = false;",
          "347:  fp = fopen(_PATH_SHELLS, \"r\");",
          "348:  if (!fp) {",
          "349:   if (!shell_name)",
          "350:    warnx(_(\"No known shells.\"));",
          "351:   return true;",
          "353:  while (fgets(buf, sizeof(buf), fp) != NULL) {",
          "355:   if (*buf == '#')",
          "356:    continue;",
          "357:   len = strlen(buf);",
          "359:   if (buf[len - 1] == '\\n')",
          "360:    buf[len - 1] = 0;",
          "362:   else",
          "363:    continue;",
          "365:   if (shell_name) {",
          "366:    if (!strcmp(shell_name, buf)) {",
          "367:     found = true;",
          "368:     break;",
          "370:   } else",
          "371:    printf(\"%s\\n\", buf);",
          "373:  fclose(fp);",
          "374:  return found;",
          "",
          "[Added Lines]",
          "259: int main(int argc, char **argv)",
          "261:  char *shell, *oldshell;",
          "262:  uid_t uid;",
          "263:  struct sinfo info;",
          "264:  struct passwd *pw;",
          "266:  sanitize_env();",
          "267:  setlocale(LC_ALL, \"\");",
          "268:  bindtextdomain(PACKAGE, LOCALEDIR);",
          "269:  textdomain(PACKAGE);",
          "270:  atexit(close_stdout);",
          "272:  uid = getuid();",
          "273:  memset(&info, 0, sizeof(info));",
          "275:  parse_argv(argc, argv, &info);",
          "276:  pw = NULL;",
          "277:  if (!info.username) {",
          "278:   pw = getpwuid(uid);",
          "279:   if (!pw)",
          "280:    errx(EXIT_FAILURE, _(\"you (user %d) don't exist.\"),",
          "281:         uid);",
          "282:  } else {",
          "283:   pw = getpwnam(info.username);",
          "284:   if (!pw)",
          "285:    errx(EXIT_FAILURE, _(\"user \\\"%s\\\" does not exist.\"),",
          "286:         info.username);",
          "289: #ifndef HAVE_LIBUSER",
          "290:  if (!(is_local(pw->pw_name)))",
          "291:   errx(EXIT_FAILURE, _(\"can only change local entries\"));",
          "292: #endif",
          "294: #ifdef HAVE_LIBSELINUX",
          "295:  if (is_selinux_enabled() > 0) {",
          "296:   if (uid == 0) {",
          "297:    if (checkAccess(pw->pw_name, PASSWD__CHSH) != 0) {",
          "298:     security_context_t user_context;",
          "299:     if (getprevcon(&user_context) < 0)",
          "300:      user_context =",
          "301:          (security_context_t) NULL;",
          "303:     errx(EXIT_FAILURE,",
          "304:          _(\"%s is not authorized to change the shell of %s\"),",
          "305:          user_context ? : _(\"Unknown user context\"),",
          "306:          pw->pw_name);",
          "308:   }",
          "309:   if (setupDefaultContext(_PATH_PASSWD) != 0)",
          "310:    errx(EXIT_FAILURE,",
          "311:         _(\"can't set default context for %s\"), _PATH_PASSWD);",
          "313: #endif",
          "315:  oldshell = pw->pw_shell;",
          "316:  if (oldshell == NULL || *oldshell == '\\0')",
          "320: #ifdef HAVE_LIBUSER",
          "322:  if (geteuid() != getuid() && uid != pw->pw_uid) {",
          "323: #else",
          "324:  if (uid != 0 && uid != pw->pw_uid) {",
          "325: #endif",
          "326:   errno = EACCES;",
          "327:   err(EXIT_FAILURE,",
          "328:       _(\"running UID doesn't match UID of user we're \"",
          "329:         \"altering, shell change denied\"));",
          "330:  }",
          "331:  if (uid != 0 && !get_shell_list(oldshell)) {",
          "332:   errno = EACCES;",
          "333:   err(EXIT_FAILURE, _(\"your shell is not in %s, \"",
          "334:         \"shell change denied\"), _PATH_SHELLS);",
          "335:  }",
          "337:  shell = info.shell;",
          "339:  printf(_(\"Changing shell for %s.\\n\"), pw->pw_name);",
          "341: #if !defined(HAVE_LIBUSER) && defined(CHFN_CHSH_PASSWORD)",
          "342:  if(!auth_pam(\"chsh\", uid, pw->pw_name)) {",
          "343:   return EXIT_FAILURE;",
          "344:  }",
          "345: #endif",
          "346:  if (!shell) {",
          "347:   shell = prompt(_(\"New shell\"), oldshell);",
          "348:   if (!shell)",
          "349:    return EXIT_SUCCESS;",
          "350:  }",
          "352:  if (check_shell(shell) < 0)",
          "353:   return EXIT_FAILURE;",
          "355:  if (strcmp(oldshell, shell) == 0)",
          "356:   errx(EXIT_SUCCESS, _(\"Shell not changed.\"));",
          "358: #ifdef HAVE_LIBUSER",
          "359:  if (set_value_libuser(\"chsh\", pw->pw_name, uid,",
          "360:      LU_LOGINSHELL, shell) < 0)",
          "361:   errx(EXIT_FAILURE, _(\"Shell *NOT* changed.  Try again later.\"));",
          "362: #else",
          "363:  pw->pw_shell = shell;",
          "364:  if (setpwnam(pw) < 0)",
          "365:   err(EXIT_FAILURE, _(\"setpwnam failed\\n\"",
          "366:    \"Shell *NOT* changed.  Try again later.\"));",
          "367: #endif",
          "369:  printf(_(\"Shell changed.\\n\"));",
          "370:  return EXIT_SUCCESS;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
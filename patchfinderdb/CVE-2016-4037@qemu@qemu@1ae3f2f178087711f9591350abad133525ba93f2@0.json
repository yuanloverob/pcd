{
  "cve_id": "CVE-2016-4037",
  "cve_desc": "The ehci_advance_state function in hw/usb/hcd-ehci.c in QEMU allows local guest OS administrators to cause a denial of service (infinite loop and CPU consumption) via a circular split isochronous transfer descriptor (siTD) list, a related issue to CVE-2015-8558.",
  "repo": "qemu/qemu",
  "patch_hash": "1ae3f2f178087711f9591350abad133525ba93f2",
  "patch_info": {
    "commit_hash": "1ae3f2f178087711f9591350abad133525ba93f2",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/1ae3f2f178087711f9591350abad133525ba93f2",
    "files": [
      "hw/usb/hcd-ehci.c"
    ],
    "message": "ehci: apply limit to iTD/sidt descriptors\n\nCommit \"156a2e4 ehci: make idt processing more robust\" tries to avoid a\nDoS by the guest (create a circular iTD queue and let qemu ehci\nemulation run in circles forever).  Unfortunately this has two problems:\nFirst it misses the case of siTDs, and second it reportedly breaks\nFreeBSD.\n\nSo lets go for a different approach: just count the number of iTDs and\nsiTDs we have seen per frame and apply a limit.  That should really\ncatch all cases now.\n\nReported-by: \u675c\u5c11\u535a <dushaobo@360.cn>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>",
    "before_after_code_files": [
      "hw/usb/hcd-ehci.c||hw/usb/hcd-ehci.c"
    ]
  },
  "patch_diff": {
    "hw/usb/hcd-ehci.c||hw/usb/hcd-ehci.c": [
      "File: hw/usb/hcd-ehci.c -> hw/usb/hcd-ehci.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2011: static void ehci_advance_state(EHCIState *ehci, int async)",
      "2012: {",
      "2013:     EHCIQueue *q = NULL;",
      "2014:     int again;",
      "2016:     do {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2014:     int itd_count = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2036:         case EST_FETCHITD:",
      "2037:             again = ehci_state_fetchitd(ehci, async);",
      "2038:             break;",
      "2040:         case EST_FETCHSITD:",
      "2041:             again = ehci_state_fetchsitd(ehci, async);",
      "2042:             break;",
      "2044:         case EST_ADVANCEQUEUE:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2039:             itd_count++;",
      "2044:             itd_count++;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2087:             break;",
      "2088:         }",
      "2091:             fprintf(stderr, \"processing error - resetting ehci HC\\n\");",
      "2092:             ehci_reset(ehci);",
      "2093:             again = 0;",
      "",
      "[Removed Lines]",
      "2090:         if (again < 0) {",
      "",
      "[Added Lines]",
      "2093:         if (again < 0 || itd_count > 16) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "706bab670bab12dddca0318b402461013e412270",
      "candidate_info": {
        "commit_hash": "706bab670bab12dddca0318b402461013e412270",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/706bab670bab12dddca0318b402461013e412270",
        "files": [
          "hw/usb/hcd-ehci.c"
        ],
        "message": "ehci: apply limit to iTD/sidt descriptors\n\nCommit \"156a2e4 ehci: make idt processing more robust\" tries to avoid a\nDoS by the guest (create a circular iTD queue and let qemu ehci\nemulation run in circles forever).  Unfortunately this has two problems:\nFirst it misses the case of siTDs, and second it reportedly breaks\nFreeBSD.\n\nSo lets go for a different approach: just count the number of iTDs and\nsiTDs we have seen per frame and apply a limit.  That should really\ncatch all cases now.\n\nReported-by: \u675c\u5c11\u535a <dushaobo@360.cn>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n(cherry picked from commit 1ae3f2f178087711f9591350abad133525ba93f2)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/usb/hcd-ehci.c||hw/usb/hcd-ehci.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/usb/hcd-ehci.c||hw/usb/hcd-ehci.c"
          ],
          "candidate": [
            "hw/usb/hcd-ehci.c||hw/usb/hcd-ehci.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/usb/hcd-ehci.c||hw/usb/hcd-ehci.c": [
          "File: hw/usb/hcd-ehci.c -> hw/usb/hcd-ehci.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2004: static void ehci_advance_state(EHCIState *ehci, int async)",
          "2005: {",
          "2006:     EHCIQueue *q = NULL;",
          "2007:     int again;",
          "2009:     do {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2007:     int itd_count = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2029:         case EST_FETCHITD:",
          "2030:             again = ehci_state_fetchitd(ehci, async);",
          "2031:             break;",
          "2033:         case EST_FETCHSITD:",
          "2034:             again = ehci_state_fetchsitd(ehci, async);",
          "2035:             break;",
          "2037:         case EST_ADVANCEQUEUE:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2032:             itd_count++;",
          "2037:             itd_count++;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2080:             break;",
          "2081:         }",
          "2084:             fprintf(stderr, \"processing error - resetting ehci HC\\n\");",
          "2085:             ehci_reset(ehci);",
          "2086:             again = 0;",
          "",
          "[Removed Lines]",
          "2083:         if (again < 0) {",
          "",
          "[Added Lines]",
          "2086:         if (again < 0 || itd_count > 16) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
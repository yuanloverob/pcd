{
  "cve_id": "CVE-2016-4414",
  "cve_desc": "The onReadyRead function in core/coreauthhandler.cpp in Quassel before 0.12.4 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via invalid handshake data.",
  "repo": "quassel/quassel",
  "patch_hash": "e67887343c433cc35bc26ad6a9392588f427e746",
  "patch_info": {
    "commit_hash": "e67887343c433cc35bc26ad6a9392588f427e746",
    "repo": "quassel/quassel",
    "commit_url": "https://github.com/quassel/quassel/commit/e67887343c433cc35bc26ad6a9392588f427e746",
    "files": [
      "src/common/peerfactory.cpp",
      "src/core/coreauthhandler.cpp"
    ],
    "message": "Handle invalid handshake data properly in the core\n\nClients sending invalid handshake data could make the core crash\ndue to an unchecked pointer. This commit fixes this issue by having\nthe core close the socket if a peer could not be created.\n\nThanks to Bas Pape (Tucos) for finding this one!",
    "before_after_code_files": [
      "src/common/peerfactory.cpp||src/common/peerfactory.cpp",
      "src/core/coreauthhandler.cpp||src/core/coreauthhandler.cpp"
    ]
  },
  "patch_diff": {
    "src/common/peerfactory.cpp||src/common/peerfactory.cpp": [
      "File: src/common/peerfactory.cpp -> src/common/peerfactory.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "56:         }",
      "57:     }",
      "60: }",
      "",
      "[Removed Lines]",
      "59:     return 0;",
      "",
      "[Added Lines]",
      "59:     return nullptr;",
      "",
      "---------------"
    ],
    "src/core/coreauthhandler.cpp||src/core/coreauthhandler.cpp": [
      "File: src/core/coreauthhandler.cpp -> src/core/coreauthhandler.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "81:     }",
      "85:         quint32 data;",
      "86:         socket()->read((char*)&data, 4);",
      "87:         data = qFromBigEndian<quint32>(data);",
      "",
      "[Removed Lines]",
      "84:     while (socket()->bytesAvailable() >= 4) {",
      "",
      "[Added Lines]",
      "84:     while (socket()->bytesAvailable() >= 4 && _supportedProtos.size() < 16) { // sanity check",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "98:                 level = Compressor::NoCompression;",
      "100:             RemotePeer *peer = PeerFactory::createPeer(_supportedProtos, this, socket(), level, this);",
      "101:             if (peer->protocol() == Protocol::LegacyProtocol) {",
      "102:                 _legacy = true;",
      "103:                 connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "101:             if (!peer) {",
      "102:                 qWarning() << \"Received invalid handshake data from client\" << socket()->peerAddress().toString();",
      "103:                 close();",
      "104:                 return;",
      "105:             }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "adbd7f6efa14b107ed722daa0b7963dd1238a681",
      "candidate_info": {
        "commit_hash": "adbd7f6efa14b107ed722daa0b7963dd1238a681",
        "repo": "quassel/quassel",
        "commit_url": "https://github.com/quassel/quassel/commit/adbd7f6efa14b107ed722daa0b7963dd1238a681",
        "files": [
          "src/common/peerfactory.cpp",
          "src/core/coreauthhandler.cpp"
        ],
        "message": "Handle invalid handshake data properly in the core\n\nClients sending invalid handshake data could make the core crash\ndue to an unchecked pointer. This commit fixes this issue by having\nthe core close the socket if a peer could not be created.\n\nThanks to Bas Pape (Tucos) for finding this one!",
        "before_after_code_files": [
          "src/common/peerfactory.cpp||src/common/peerfactory.cpp",
          "src/core/coreauthhandler.cpp||src/core/coreauthhandler.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/common/peerfactory.cpp||src/common/peerfactory.cpp",
            "src/core/coreauthhandler.cpp||src/core/coreauthhandler.cpp"
          ],
          "candidate": [
            "src/common/peerfactory.cpp||src/common/peerfactory.cpp",
            "src/core/coreauthhandler.cpp||src/core/coreauthhandler.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/common/peerfactory.cpp||src/common/peerfactory.cpp": [
          "File: src/common/peerfactory.cpp -> src/common/peerfactory.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:         }",
          "57:     }",
          "60: }",
          "",
          "[Removed Lines]",
          "59:     return 0;",
          "",
          "[Added Lines]",
          "59:     return nullptr;",
          "",
          "---------------"
        ],
        "src/core/coreauthhandler.cpp||src/core/coreauthhandler.cpp": [
          "File: src/core/coreauthhandler.cpp -> src/core/coreauthhandler.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:     }",
          "85:         quint32 data;",
          "86:         socket()->read((char*)&data, 4);",
          "87:         data = qFromBigEndian<quint32>(data);",
          "",
          "[Removed Lines]",
          "84:     while (socket()->bytesAvailable() >= 4) {",
          "",
          "[Added Lines]",
          "84:     while (socket()->bytesAvailable() >= 4 && _supportedProtos.size() < 16) { // sanity check",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98:                 level = Compressor::NoCompression;",
          "100:             RemotePeer *peer = PeerFactory::createPeer(_supportedProtos, this, socket(), level, this);",
          "101:             if (peer->protocol() == Protocol::LegacyProtocol) {",
          "102:                 _legacy = true;",
          "103:                 connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "101:             if (!peer) {",
          "102:                 qWarning() << \"Received invalid handshake data from client\" << socket()->peerAddress().toString();",
          "103:                 close();",
          "104:                 return;",
          "105:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
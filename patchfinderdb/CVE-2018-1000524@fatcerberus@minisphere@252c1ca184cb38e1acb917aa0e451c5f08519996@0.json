{
  "cve_id": "CVE-2018-1000524",
  "cve_desc": "miniSphere version 5.2.9 and earlier contains a Integer Overflow vulnerability in layer_resize() function in map_engine.c that can result in remote denial of service. This attack appear to be exploitable via the victim must load a specially-crafted map which calls SetLayerSize in its entry script. This vulnerability appears to have been fixed in 5.0.3, 5.1.5, 5.2.10 and later.",
  "repo": "fatcerberus/minisphere",
  "patch_hash": "252c1ca184cb38e1acb917aa0e451c5f08519996",
  "patch_info": {
    "commit_hash": "252c1ca184cb38e1acb917aa0e451c5f08519996",
    "repo": "fatcerberus/minisphere",
    "commit_url": "https://github.com/fatcerberus/minisphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996",
    "files": [
      "src/minisphere/map_engine.c"
    ],
    "message": "Fix integer overflow in layer_resize in map_engine.c (#268)\n\n* Fix integer overflow in layer_resize in map_engine.c\n\nThere's a buffer overflow bug in the function layer_resize. It allocates\na buffer `tilemap` with size `x_size * y_size * sizeof(struct map_tile)`.\nBut it didn't check for integer overflow, so if x_size and y_size are\nvery large, it's possible that the buffer size is smaller than needed,\ncausing a buffer overflow later.\n\nPoC: `SetLayerSize(0, 0x7FFFFFFF, 0x7FFFFFFF);`\n\n* move malloc to a separate line",
    "before_after_code_files": [
      "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
    ]
  },
  "patch_diff": {
    "src/minisphere/map_engine.c||src/minisphere/map_engine.c": [
      "File: src/minisphere/map_engine.c -> src/minisphere/map_engine.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1036:  struct map_tile*    tilemap;",
      "1037:  struct map_trigger* trigger;",
      "1038:  struct map_zone*    zone;",
      "1040:  int x, y, i;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1039:  size_t              tilemap_size;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1048:   return false;",
      "1049:  for (x = 0; x < x_size; ++x) {",
      "1050:   for (y = 0; y < y_size; ++y) {",
      "",
      "[Removed Lines]",
      "1047:  if (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))",
      "",
      "[Added Lines]",
      "1048:  tilemap_size = x_size * y_size * sizeof(struct map_tile);",
      "1049:  if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size",
      "1050:   || !(tilemap = malloc(tilemap_size)))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "22282e6887b88b59d6f2dcd672939edbd637f99d",
      "candidate_info": {
        "commit_hash": "22282e6887b88b59d6f2dcd672939edbd637f99d",
        "repo": "fatcerberus/minisphere",
        "commit_url": "https://github.com/fatcerberus/minisphere/commit/22282e6887b88b59d6f2dcd672939edbd637f99d",
        "files": [
          "src/minisphere/map_engine.c"
        ],
        "message": "Remove redundant `int` casts in map engine\n\nThere were a few unnecessary `int` casts when using vector.c functions;\nas indexing for vector_t was changed from `size_t` to `int ` quite a\nwhile back, the casts are just noise now and can disappear.",
        "before_after_code_files": [
          "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
          ],
          "candidate": [
            "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
          ]
        }
      },
      "candidate_diff": {
        "src/minisphere/map_engine.c||src/minisphere/map_engine.c": [
          "File: src/minisphere/map_engine.c -> src/minisphere/map_engine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1048:  tilemap_size = x_size * y_size * sizeof(struct map_tile);",
          "1051:   return false;",
          "1052:  for (x = 0; x < x_size; ++x) {",
          "1053:   for (y = 0; y < y_size; ++y) {",
          "",
          "[Removed Lines]",
          "1049:  if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size",
          "1050:   || !(tilemap = malloc(tilemap_size)))",
          "",
          "[Added Lines]",
          "1049:  if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size)",
          "1050:   return false;  // overflow detected",
          "1051:  if (!(tilemap = malloc(tilemap_size)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1086:   zone = vector_get(s_map->zones, i);",
          "1088:    vector_remove(s_map->zones, i);",
          "1089:   else {",
          "1090:    if (zone->bounds.x2 > s_map->width)",
          "1091:     zone->bounds.x2 = s_map->width;",
          "",
          "[Removed Lines]",
          "1085:  for (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {",
          "1087:   if (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)",
          "",
          "[Added Lines]",
          "1086:  for (i = vector_len(s_map->zones) - 1; i >= 0; --i) {",
          "1088:   if (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height) {",
          "1090:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1093:     zone->bounds.y2 = s_map->height;",
          "1094:   }",
          "1095:  }",
          "1097:   trigger = vector_get(s_map->triggers, i);",
          "1098:   if (trigger->x >= s_map->width || trigger->y >= s_map->height)",
          "1099:    vector_remove(s_map->triggers, i);",
          "",
          "[Removed Lines]",
          "1096:  for (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {",
          "",
          "[Added Lines]",
          "1098:  for (i = vector_len(s_map->triggers) - 1; i >= 0; --i) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2248:    continue;",
          "2249:   if (is_point_in_rect(x, y, zone->bounds) && which-- == 0) {",
          "2250:    found_item = zone;",
          "2252:    break;",
          "2253:   }",
          "2254:  }",
          "",
          "[Removed Lines]",
          "2251:    if (out_index) *out_index = (int)iter.index;",
          "",
          "[Added Lines]",
          "2253:    if (out_index)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "037d38bf592ff962292b991a45d4a68aa471f204",
      "candidate_info": {
        "commit_hash": "037d38bf592ff962292b991a45d4a68aa471f204",
        "repo": "fatcerberus/minisphere",
        "commit_url": "https://github.com/fatcerberus/minisphere/commit/037d38bf592ff962292b991a45d4a68aa471f204",
        "files": [
          "src/minisphere/map_engine.c"
        ],
        "message": "Fix integer overflow in layer_resize in map_engine.c (#268)\n\n* Fix integer overflow in layer_resize in map_engine.c\n\nThere's a buffer overflow bug in the function layer_resize. It allocates\na buffer `tilemap` with size `x_size * y_size * sizeof(struct map_tile)`.\nBut it didn't check for integer overflow, so if x_size and y_size are\nvery large, it's possible that the buffer size is smaller than needed,\ncausing a buffer overflow later.\n\nPoC: `SetLayerSize(0, 0x7FFFFFFF, 0x7FFFFFFF);`\n\n* move malloc to a separate line",
        "before_after_code_files": [
          "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
          ],
          "candidate": [
            "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
          ]
        }
      },
      "candidate_diff": {
        "src/minisphere/map_engine.c||src/minisphere/map_engine.c": [
          "File: src/minisphere/map_engine.c -> src/minisphere/map_engine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1037:  struct map_tile*    tilemap;",
          "1038:  struct map_trigger* trigger;",
          "1039:  struct map_zone*    zone;",
          "1041:  int x, y, i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1040:  size_t              tilemap_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1049:   return false;",
          "1050:  for (x = 0; x < x_size; ++x) {",
          "1051:   for (y = 0; y < y_size; ++y) {",
          "",
          "[Removed Lines]",
          "1048:  if (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))",
          "",
          "[Added Lines]",
          "1049:  tilemap_size = x_size * y_size * sizeof(struct map_tile);",
          "1050:  if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size",
          "1051:   || !(tilemap = malloc(tilemap_size)))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "41e4dbb1ed2abbcd29c76cfa02ad484aec7ed96d",
      "candidate_info": {
        "commit_hash": "41e4dbb1ed2abbcd29c76cfa02ad484aec7ed96d",
        "repo": "fatcerberus/minisphere",
        "commit_url": "https://github.com/fatcerberus/minisphere/commit/41e4dbb1ed2abbcd29c76cfa02ad484aec7ed96d",
        "files": [
          "src/minisphere/map_engine.c"
        ],
        "message": "Fix integer overflow in layer_resize in map_engine.c (#268)\n\n* Fix integer overflow in layer_resize in map_engine.c\n\nThere's a buffer overflow bug in the function layer_resize. It allocates\na buffer `tilemap` with size `x_size * y_size * sizeof(struct map_tile)`.\nBut it didn't check for integer overflow, so if x_size and y_size are\nvery large, it's possible that the buffer size is smaller than needed,\ncausing a buffer overflow later.\n\nPoC: `SetLayerSize(0, 0x7FFFFFFF, 0x7FFFFFFF);`\n\n* move malloc to a separate line",
        "before_after_code_files": [
          "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
          ],
          "candidate": [
            "src/minisphere/map_engine.c||src/minisphere/map_engine.c"
          ]
        }
      },
      "candidate_diff": {
        "src/minisphere/map_engine.c||src/minisphere/map_engine.c": [
          "File: src/minisphere/map_engine.c -> src/minisphere/map_engine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1039:  struct map_tile*    tilemap;",
          "1040:  struct map_trigger* trigger;",
          "1041:  struct map_zone*    zone;",
          "1043:  int x, y, i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1042:  size_t              tilemap_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1051:   return false;",
          "1052:  for (x = 0; x < x_size; ++x) {",
          "1053:   for (y = 0; y < y_size; ++y) {",
          "",
          "[Removed Lines]",
          "1050:  if (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))",
          "",
          "[Added Lines]",
          "1051:  tilemap_size = x_size * y_size * sizeof(struct map_tile);",
          "1052:  if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size",
          "1053:   || !(tilemap = malloc(tilemap_size)))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-5546",
  "cve_desc": "The freelist-randomization feature in mm/slab.c in the Linux kernel 4.8.x and 4.9.x before 4.9.5 allows local users to cause a denial of service (duplicate freelist entries and system crash) or possibly have unspecified other impact in opportunistic circumstances by leveraging the selection of a large value for a random number.",
  "repo": "torvalds/linux",
  "patch_hash": "c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
  "patch_info": {
    "commit_hash": "c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
    "files": [
      "mm/slab.c"
    ],
    "message": "mm/slab.c: fix SLAB freelist randomization duplicate entries\n\nThis patch fixes a bug in the freelist randomization code.  When a high\nrandom number is used, the freelist will contain duplicate entries.  It\nwill result in different allocations sharing the same chunk.\n\nIt will result in odd behaviours and crashes.  It should be uncommon but\nit depends on the machines.  We saw it happening more often on some\nmachines (every few hours of running tests).\n\nFixes: c7ce4f60ac19 (\"mm: SLAB freelist randomization\")\nLink: http://lkml.kernel.org/r/20170103181908.143178-1-thgarnie@google.com\nSigned-off-by: John Sperbeck <jsperbeck@google.com>\nSigned-off-by: Thomas Garnier <thgarnie@google.com>\nCc: Christoph Lameter <cl@linux.com>\nCc: Pekka Enberg <penberg@kernel.org>\nCc: David Rientjes <rientjes@google.com>\nCc: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/slab.c||mm/slab.c"
    ]
  },
  "patch_diff": {
    "mm/slab.c||mm/slab.c": [
      "File: mm/slab.c -> mm/slab.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2457:   unsigned int pos;",
      "2458:   unsigned int *list;",
      "2459:   unsigned int count;",
      "2461:  };",
      "2462:  struct rnd_state rnd_state;",
      "2463: };",
      "",
      "[Removed Lines]",
      "2460:   unsigned int rand;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2483:  } else {",
      "2484:   state->list = cachep->random_seq;",
      "2485:   state->count = count;",
      "2488:   ret = true;",
      "2489:  }",
      "2490:  return ret;",
      "",
      "[Removed Lines]",
      "2486:   state->pos = 0;",
      "2487:   state->rand = rand;",
      "",
      "[Added Lines]",
      "2485:   state->pos = rand % count;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2494: static freelist_idx_t next_random_slot(union freelist_init_state *state)",
      "2495: {",
      "2497: }",
      "",
      "[Removed Lines]",
      "2496:  return (state->list[state->pos++] + state->rand) % state->count;",
      "",
      "[Added Lines]",
      "2494:  if (state->pos >= state->count)",
      "2495:   state->pos = 0;",
      "2496:  return state->list[state->pos++];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c7ce4f60ac199fb3521c5fcd64da21cee801ec2b",
      "candidate_info": {
        "commit_hash": "c7ce4f60ac199fb3521c5fcd64da21cee801ec2b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c7ce4f60ac199fb3521c5fcd64da21cee801ec2b",
        "files": [
          "include/linux/slab_def.h",
          "init/Kconfig",
          "mm/slab.c"
        ],
        "message": "mm: SLAB freelist randomization\n\nProvides an optional config (CONFIG_SLAB_FREELIST_RANDOM) to randomize\nthe SLAB freelist.  The list is randomized during initialization of a\nnew set of pages.  The order on different freelist sizes is pre-computed\nat boot for performance.  Each kmem_cache has its own randomized\nfreelist.  Before pre-computed lists are available freelists are\ngenerated dynamically.  This security feature reduces the predictability\nof the kernel SLAB allocator against heap overflows rendering attacks\nmuch less stable.\n\nFor example this attack against SLUB (also applicable against SLAB)\nwould be affected:\n\n  https://jon.oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/\n\nAlso, since v4.6 the freelist was moved at the end of the SLAB.  It\nmeans a controllable heap is opened to new attacks not yet publicly\ndiscussed.  A kernel heap overflow can be transformed to multiple\nuse-after-free.  This feature makes this type of attack harder too.\n\nTo generate entropy, we use get_random_bytes_arch because 0 bits of\nentropy is available in the boot stage.  In the worse case this function\nwill fallback to the get_random_bytes sub API.  We also generate a shift\nrandom number to shift pre-computed freelist for each new set of pages.\n\nThe config option name is not specific to the SLAB as this approach will\nbe extended to other allocators like SLUB.\n\nPerformance results highlighted no major changes:\n\nHackbench (running 90 10 times):\n\n  Before average: 0.0698\n  After average: 0.0663 (-5.01%)\n\nslab_test 1 run on boot.  Difference only seen on the 2048 size test\nbeing the worse case scenario covered by freelist randomization.  New\nslab pages are constantly being created on the 10000 allocations.\nVariance should be mainly due to getting new pages every few\nallocations.\n\nBefore:\n\n  Single thread testing\n  =====================\n  1. Kmalloc: Repeatedly allocate then free test\n  10000 times kmalloc(8) -> 99 cycles kfree -> 112 cycles\n  10000 times kmalloc(16) -> 109 cycles kfree -> 140 cycles\n  10000 times kmalloc(32) -> 129 cycles kfree -> 137 cycles\n  10000 times kmalloc(64) -> 141 cycles kfree -> 141 cycles\n  10000 times kmalloc(128) -> 152 cycles kfree -> 148 cycles\n  10000 times kmalloc(256) -> 195 cycles kfree -> 167 cycles\n  10000 times kmalloc(512) -> 257 cycles kfree -> 199 cycles\n  10000 times kmalloc(1024) -> 393 cycles kfree -> 251 cycles\n  10000 times kmalloc(2048) -> 649 cycles kfree -> 228 cycles\n  10000 times kmalloc(4096) -> 806 cycles kfree -> 370 cycles\n  10000 times kmalloc(8192) -> 814 cycles kfree -> 411 cycles\n  10000 times kmalloc(16384) -> 892 cycles kfree -> 455 cycles\n  2. Kmalloc: alloc/free test\n  10000 times kmalloc(8)/kfree -> 121 cycles\n  10000 times kmalloc(16)/kfree -> 121 cycles\n  10000 times kmalloc(32)/kfree -> 121 cycles\n  10000 times kmalloc(64)/kfree -> 121 cycles\n  10000 times kmalloc(128)/kfree -> 121 cycles\n  10000 times kmalloc(256)/kfree -> 119 cycles\n  10000 times kmalloc(512)/kfree -> 119 cycles\n  10000 times kmalloc(1024)/kfree -> 119 cycles\n  10000 times kmalloc(2048)/kfree -> 119 cycles\n  10000 times kmalloc(4096)/kfree -> 121 cycles\n  10000 times kmalloc(8192)/kfree -> 119 cycles\n  10000 times kmalloc(16384)/kfree -> 119 cycles\n\nAfter:\n\n  Single thread testing\n  =====================\n  1. Kmalloc: Repeatedly allocate then free test\n  10000 times kmalloc(8) -> 130 cycles kfree -> 86 cycles\n  10000 times kmalloc(16) -> 118 cycles kfree -> 86 cycles\n  10000 times kmalloc(32) -> 121 cycles kfree -> 85 cycles\n  10000 times kmalloc(64) -> 176 cycles kfree -> 102 cycles\n  10000 times kmalloc(128) -> 178 cycles kfree -> 100 cycles\n  10000 times kmalloc(256) -> 205 cycles kfree -> 109 cycles\n  10000 times kmalloc(512) -> 262 cycles kfree -> 136 cycles\n  10000 times kmalloc(1024) -> 342 cycles kfree -> 157 cycles\n  10000 times kmalloc(2048) -> 701 cycles kfree -> 238 cycles\n  10000 times kmalloc(4096) -> 803 cycles kfree -> 364 cycles\n  10000 times kmalloc(8192) -> 835 cycles kfree -> 404 cycles\n  10000 times kmalloc(16384) -> 896 cycles kfree -> 441 cycles\n  2. Kmalloc: alloc/free test\n  10000 times kmalloc(8)/kfree -> 121 cycles\n  10000 times kmalloc(16)/kfree -> 121 cycles\n  10000 times kmalloc(32)/kfree -> 123 cycles\n  10000 times kmalloc(64)/kfree -> 142 cycles\n  10000 times kmalloc(128)/kfree -> 121 cycles\n  10000 times kmalloc(256)/kfree -> 119 cycles\n  10000 times kmalloc(512)/kfree -> 119 cycles\n  10000 times kmalloc(1024)/kfree -> 119 cycles\n  10000 times kmalloc(2048)/kfree -> 119 cycles\n  10000 times kmalloc(4096)/kfree -> 119 cycles\n  10000 times kmalloc(8192)/kfree -> 119 cycles\n  10000 times kmalloc(16384)/kfree -> 119 cycles\n\n[akpm@linux-foundation.org: propagate gfp_t into cache_random_seq_create()]\nSigned-off-by: Thomas Garnier <thgarnie@google.com>\nAcked-by: Christoph Lameter <cl@linux.com>\nCc: Pekka Enberg <penberg@kernel.org>\nCc: David Rientjes <rientjes@google.com>\nCc: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nCc: Kees Cook <keescook@chromium.org>\nCc: Greg Thelen <gthelen@google.com>\nCc: Laura Abbott <labbott@fedoraproject.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/slab_def.h||include/linux/slab_def.h",
          "mm/slab.c||mm/slab.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/slab.c||mm/slab.c"
          ],
          "candidate": [
            "mm/slab.c||mm/slab.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/slab_def.h||include/linux/slab_def.h": [
          "File: include/linux/slab_def.h -> include/linux/slab_def.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:  struct kasan_cache kasan_info;",
          "81: #endif",
          "83:  struct kmem_cache_node *node[MAX_NUMNODES];",
          "84: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83: #ifdef CONFIG_SLAB_FREELIST_RANDOM",
          "84:  void *random_seq;",
          "85: #endif",
          "",
          "---------------"
        ],
        "mm/slab.c||mm/slab.c": [
          "File: mm/slab.c -> mm/slab.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1243:  }",
          "1244: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1246: #ifdef CONFIG_SLAB_FREELIST_RANDOM",
          "1247: static void freelist_randomize(struct rnd_state *state, freelist_idx_t *list,",
          "1248:    size_t count)",
          "1249: {",
          "1250:  size_t i;",
          "1251:  unsigned int rand;",
          "1253:  for (i = 0; i < count; i++)",
          "1254:   list[i] = i;",
          "1257:  for (i = count - 1; i > 0; i--) {",
          "1258:   rand = prandom_u32_state(state);",
          "1259:   rand %= (i + 1);",
          "1260:   swap(list[i], list[rand]);",
          "1261:  }",
          "1262: }",
          "1265: static int cache_random_seq_create(struct kmem_cache *cachep, gfp_t gfp)",
          "1266: {",
          "1267:  unsigned int seed, count = cachep->num;",
          "1268:  struct rnd_state state;",
          "1270:  if (count < 2)",
          "1271:   return 0;",
          "1274:  cachep->random_seq = kcalloc(count, sizeof(freelist_idx_t), gfp);",
          "1275:  if (!cachep->random_seq)",
          "1276:   return -ENOMEM;",
          "1279:  get_random_bytes_arch(&seed, sizeof(seed));",
          "1280:  prandom_seed_state(&state, seed);",
          "1282:  freelist_randomize(&state, cachep->random_seq, count);",
          "1283:  return 0;",
          "1284: }",
          "1287: static void cache_random_seq_destroy(struct kmem_cache *cachep)",
          "1288: {",
          "1289:  kfree(cachep->random_seq);",
          "1290:  cachep->random_seq = NULL;",
          "1291: }",
          "1292: #else",
          "1293: static inline int cache_random_seq_create(struct kmem_cache *cachep, gfp_t gfp)",
          "1294: {",
          "1295:  return 0;",
          "1296: }",
          "1297: static inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2374:  int i;",
          "2375:  struct kmem_cache_node *n;",
          "2377:  free_percpu(cachep->cpu_cache);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2432:  cache_random_seq_destroy(cachep);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2480: #endif",
          "2481: }",
          "2483: static void cache_init_objs(struct kmem_cache *cachep,",
          "2484:        struct page *page)",
          "2485: {",
          "2486:  int i;",
          "2487:  void *objp;",
          "2489:  cache_init_objs_debug(cachep, page);",
          "2492:   page->freelist = index_to_obj(cachep, page, cachep->num - 1) +",
          "2493:       obj_offset(cachep);",
          "2494:  }",
          "",
          "[Removed Lines]",
          "2491:  if (OBJFREELIST_SLAB(cachep)) {",
          "",
          "[Added Lines]",
          "2540: #ifdef CONFIG_SLAB_FREELIST_RANDOM",
          "2542: union freelist_init_state {",
          "2543:  struct {",
          "2544:   unsigned int pos;",
          "2545:   freelist_idx_t *list;",
          "2546:   unsigned int count;",
          "2547:   unsigned int rand;",
          "2548:  };",
          "2549:  struct rnd_state rnd_state;",
          "2550: };",
          "2556: static bool freelist_state_initialize(union freelist_init_state *state,",
          "2557:     struct kmem_cache *cachep,",
          "2558:     unsigned int count)",
          "2559: {",
          "2560:  bool ret;",
          "2561:  unsigned int rand;",
          "2564:  get_random_bytes_arch(&rand, sizeof(rand));",
          "2567:  if (!cachep->random_seq) {",
          "2568:   prandom_seed_state(&state->rnd_state, rand);",
          "2569:   ret = false;",
          "2570:  } else {",
          "2571:   state->list = cachep->random_seq;",
          "2572:   state->count = count;",
          "2573:   state->pos = 0;",
          "2574:   state->rand = rand;",
          "2575:   ret = true;",
          "2576:  }",
          "2577:  return ret;",
          "2578: }",
          "2581: static freelist_idx_t next_random_slot(union freelist_init_state *state)",
          "2582: {",
          "2583:  return (state->list[state->pos++] + state->rand) % state->count;",
          "2584: }",
          "2590: static bool shuffle_freelist(struct kmem_cache *cachep, struct page *page)",
          "2591: {",
          "2592:  unsigned int objfreelist = 0, i, count = cachep->num;",
          "2593:  union freelist_init_state state;",
          "2594:  bool precomputed;",
          "2596:  if (count < 2)",
          "2597:   return false;",
          "2599:  precomputed = freelist_state_initialize(&state, cachep, count);",
          "2602:  if (OBJFREELIST_SLAB(cachep)) {",
          "2603:   if (!precomputed)",
          "2604:    objfreelist = count - 1;",
          "2605:   else",
          "2606:    objfreelist = next_random_slot(&state);",
          "2607:   page->freelist = index_to_obj(cachep, page, objfreelist) +",
          "2608:       obj_offset(cachep);",
          "2609:   count--;",
          "2610:  }",
          "2616:  if (!precomputed) {",
          "2617:   freelist_randomize(&state.rnd_state, page->freelist, count);",
          "2618:  } else {",
          "2619:   for (i = 0; i < count; i++)",
          "2620:    set_free_obj(page, i, next_random_slot(&state));",
          "2621:  }",
          "2623:  if (OBJFREELIST_SLAB(cachep))",
          "2624:   set_free_obj(page, cachep->num - 1, objfreelist);",
          "2626:  return true;",
          "2627: }",
          "2628: #else",
          "2629: static inline bool shuffle_freelist(struct kmem_cache *cachep,",
          "2630:     struct page *page)",
          "2631: {",
          "2632:  return false;",
          "2633: }",
          "2641:  bool shuffled;",
          "2646:  shuffled = shuffle_freelist(cachep, page);",
          "2648:  if (!shuffled && OBJFREELIST_SLAB(cachep)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2502:    kasan_poison_object_data(cachep, objp);",
          "2503:   }",
          "2506:  }",
          "2507: }",
          "",
          "[Removed Lines]",
          "2505:   set_free_obj(page, i, i);",
          "",
          "[Added Lines]",
          "2662:   if (!shuffled)",
          "2663:    set_free_obj(page, i, i);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3841:  int shared = 0;",
          "3842:  int batchcount = 0;",
          "3844:  if (!is_root_cache(cachep)) {",
          "3845:   struct kmem_cache *root = memcg_root_cache(cachep);",
          "3846:   limit = root->limit;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4002:  err = cache_random_seq_create(cachep, gfp);",
          "4003:  if (err)",
          "4004:   goto end;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3894:  batchcount = (limit + 1) / 2;",
          "3895: skip_setup:",
          "3896:  err = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);",
          "3897:  if (err)",
          "3898:   pr_err(\"enable_cpucache failed for %s, error %d\\n\",",
          "3899:          cachep->name, -err);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4059: end:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-4129",
  "cve_desc": "The bridge multicast implementation in the Linux kernel through 3.10.3 does not check whether a certain timer is armed before modifying the timeout value of that timer, which allows local users to cause a denial of service (BUG and system crash) via vectors involving the shutdown of a KVM virtual machine, related to net/bridge/br_mdb.c and net/bridge/br_multicast.c.",
  "repo": "torvalds/linux",
  "patch_hash": "c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1",
  "patch_info": {
    "commit_hash": "c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1",
    "files": [
      "net/bridge/br_mdb.c",
      "net/bridge/br_multicast.c"
    ],
    "message": "bridge: fix some kernel warning in multicast timer\n\nSeveral people reported the warning: \"kernel BUG at kernel/timer.c:729!\"\nand the stack trace is:\n\n\t#7 [ffff880214d25c10] mod_timer+501 at ffffffff8106d905\n\t#8 [ffff880214d25c50] br_multicast_del_pg.isra.20+261 at ffffffffa0731d25 [bridge]\n\t#9 [ffff880214d25c80] br_multicast_disable_port+88 at ffffffffa0732948 [bridge]\n\t#10 [ffff880214d25cb0] br_stp_disable_port+154 at ffffffffa072bcca [bridge]\n\t#11 [ffff880214d25ce8] br_device_event+520 at ffffffffa072a4e8 [bridge]\n\t#12 [ffff880214d25d18] notifier_call_chain+76 at ffffffff8164aafc\n\t#13 [ffff880214d25d50] raw_notifier_call_chain+22 at ffffffff810858f6\n\t#14 [ffff880214d25d60] call_netdevice_notifiers+45 at ffffffff81536aad\n\t#15 [ffff880214d25d80] dev_close_many+183 at ffffffff81536d17\n\t#16 [ffff880214d25dc0] rollback_registered_many+168 at ffffffff81537f68\n\t#17 [ffff880214d25de8] rollback_registered+49 at ffffffff81538101\n\t#18 [ffff880214d25e10] unregister_netdevice_queue+72 at ffffffff815390d8\n\t#19 [ffff880214d25e30] __tun_detach+272 at ffffffffa074c2f0 [tun]\n\t#20 [ffff880214d25e88] tun_chr_close+45 at ffffffffa074c4bd [tun]\n\t#21 [ffff880214d25ea8] __fput+225 at ffffffff8119b1f1\n\t#22 [ffff880214d25ef0] ____fput+14 at ffffffff8119b3fe\n\t#23 [ffff880214d25f00] task_work_run+159 at ffffffff8107cf7f\n\t#24 [ffff880214d25f30] do_notify_resume+97 at ffffffff810139e1\n\t#25 [ffff880214d25f50] int_signal+18 at ffffffff8164f292\n\nthis is due to I forgot to check if mp->timer is armed in\nbr_multicast_del_pg(). This bug is introduced by\ncommit 9f00b2e7cf241fa389733d41b6 (bridge: only expire the mdb entry\nwhen query is received).\n\nSame for __br_mdb_del().\n\nTested-by: poma <pomidorabelisima@gmail.com>\nReported-by: LiYonghua <809674045@qq.com>\nReported-by: Robert Hancock <hancockrwd@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nCc: Stephen Hemminger <stephen@networkplumber.org>\nCc: \"David S. Miller\" <davem@davemloft.net>\nSigned-off-by: Cong Wang <amwang@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/bridge/br_mdb.c||net/bridge/br_mdb.c",
      "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
    ]
  },
  "patch_diff": {
    "net/bridge/br_mdb.c||net/bridge/br_mdb.c": [
      "File: net/bridge/br_mdb.c -> net/bridge/br_mdb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "447:   call_rcu_bh(&p->rcu, br_multicast_free_pg);",
      "448:   err = 0;",
      "451:       netif_running(br->dev))",
      "452:    mod_timer(&mp->timer, jiffies);",
      "453:   break;",
      "",
      "[Removed Lines]",
      "450:   if (!mp->ports && !mp->mglist &&",
      "",
      "[Added Lines]",
      "450:   if (!mp->ports && !mp->mglist && mp->timer_armed &&",
      "",
      "---------------"
    ],
    "net/bridge/br_multicast.c||net/bridge/br_multicast.c": [
      "File: net/bridge/br_multicast.c -> net/bridge/br_multicast.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "270:   del_timer(&p->timer);",
      "271:   call_rcu_bh(&p->rcu, br_multicast_free_pg);",
      "274:       netif_running(br->dev))",
      "275:    mod_timer(&mp->timer, jiffies);",
      "",
      "[Removed Lines]",
      "273:   if (!mp->ports && !mp->mglist &&",
      "",
      "[Added Lines]",
      "273:   if (!mp->ports && !mp->mglist && mp->timer_armed &&",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7cc47d139f9a815a91bd9e7377063238c69a0423",
      "candidate_info": {
        "commit_hash": "7cc47d139f9a815a91bd9e7377063238c69a0423",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7cc47d139f9a815a91bd9e7377063238c69a0423",
        "files": [
          "drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c"
        ],
        "message": "cxgb3: Missing rtnl lock in error recovery\n\nWhen exercising error injection on IBM pseries machine, I hit the\nfollowing warning:\n\n[  251.450043] RTAS: event: 89, Type: Platform Error, Severity: 2\n[  253.549822] cxgb3 0006:01:00.0: enabling device (0140 -> 0142)\n[  253.713560] cxgb3 0006:01:00.0: adapter recovering, PEX ERR 0x100\n[  254.895437] RTNL: assertion failed at net/core/dev.c (2031)\n[  254.895467] CPU: 6 PID: 5449 Comm: eehd Tainted: G        W    3.10.0-rc7-00157-gea461ab #19\n[  254.895474] Call Trace:\n[  254.895483] [c000000fac56f7d0] [c000000000014dcc] .show_stack+0x7c/0x1f0 (unreliable)\n[  254.895493] [c000000fac56f8a0] [c0000000007ba318] .dump_stack+0x28/0x3c\n[  254.895500] [c000000fac56f910] [c0000000006c0384] .netif_set_real_num_tx_queues+0x224/0x230\n[  254.895515] [c000000fac56f9b0] [d00000000ef35510] .cxgb_open+0x80/0x3f0 [cxgb3]\n[  254.895525] [c000000fac56fa50] [d00000000ef35914] .t3_resume_ports+0x94/0x100 [cxgb3]\n[  254.895533] [c000000fac56fae0] [c00000000005fc8c] .eeh_report_resume+0x8c/0xd0\n[  254.895539] [c000000fac56fb60] [c00000000005e9fc] .eeh_pe_dev_traverse+0x9c/0x190\n[  254.895545] [c000000fac56fc10] [c000000000060000] .eeh_handle_event+0x110/0x330\n[  254.895551] [c000000fac56fca0] [c000000000060350] .eeh_event_handler+0x130/0x1a0\n[  254.895558] [c000000fac56fd30] [c0000000000ad758] .kthread+0xe8/0xf0\n[  254.895566] [c000000fac56fe30] [c00000000000a05c] .ret_from_kernel_thread+0x5c/0x80\n\nIt appears that t3_resume_ports() is called with the rtnl_lock held from\nthe fatal error task but not from the PCI error callbacks. This fixes it.\n\nSigned-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c||drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c||drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c": [
          "File: drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c -> drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3037:  CH_ALERT(adapter, \"adapter recovering, PEX ERR 0x%x\\n\",",
          "3038:    t3_read_reg(adapter, A_PCIE_PEX_ERR));",
          "3040:  t3_resume_ports(adapter);",
          "3041: }",
          "3043: static const struct pci_error_handlers t3_err_handler = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3040:  rtnl_lock();",
          "3042:  rtnl_unlock();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cfd567543590f71ca0af397437e2554f9756d750",
      "candidate_info": {
        "commit_hash": "cfd567543590f71ca0af397437e2554f9756d750",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cfd567543590f71ca0af397437e2554f9756d750",
        "files": [
          "include/uapi/linux/if_bridge.h",
          "net/bridge/br_mdb.c",
          "net/bridge/br_multicast.c",
          "net/bridge/br_private.h"
        ],
        "message": "bridge: add support of adding and deleting mdb entries\n\nThis patch implents adding/deleting mdb entries via netlink.\nCurrently all entries are temp, we probably need a flag to distinguish\npermanent entries too.\n\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nCc: Stephen Hemminger <shemminger@vyatta.com>\nCc: \"David S. Miller\" <davem@davemloft.net>\nCc: Thomas Graf <tgraf@suug.ch>\nSigned-off-by: Cong Wang <amwang@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/uapi/linux/if_bridge.h||include/uapi/linux/if_bridge.h",
          "net/bridge/br_mdb.c||net/bridge/br_mdb.c",
          "net/bridge/br_multicast.c||net/bridge/br_multicast.c",
          "net/bridge/br_private.h||net/bridge/br_private.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bridge/br_mdb.c||net/bridge/br_mdb.c",
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ],
          "candidate": [
            "net/bridge/br_mdb.c||net/bridge/br_mdb.c",
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ]
        }
      },
      "candidate_diff": {
        "include/uapi/linux/if_bridge.h||include/uapi/linux/if_bridge.h": [
          "File: include/uapi/linux/if_bridge.h -> include/uapi/linux/if_bridge.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "157: #define MDBA_ROUTER_MAX (__MDBA_ROUTER_MAX - 1)",
          "159: struct br_port_msg {",
          "160:  __u32 ifindex;",
          "161: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "160:  __u8  family;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171:  } addr;",
          "172: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "175: enum {",
          "176:  MDBA_SET_ENTRY_UNSPEC,",
          "177:  MDBA_SET_ENTRY,",
          "178:  __MDBA_SET_ENTRY_MAX,",
          "179: };",
          "180: #define MDBA_SET_ENTRY_MAX (__MDBA_SET_ENTRY_MAX - 1)",
          "",
          "---------------"
        ],
        "net/bridge/br_mdb.c||net/bridge/br_mdb.c": [
          "File: net/bridge/br_mdb.c -> net/bridge/br_mdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <linux/netdevice.h>",
          "5: #include <linux/rculist.h>",
          "6: #include <linux/skbuff.h>",
          "7: #include <net/ip.h>",
          "8: #include <net/netlink.h>",
          "9: #if IS_ENABLED(CONFIG_IPV6)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include <linux/if_ether.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "235:  __br_mdb_notify(dev, &entry, type);",
          "236: }",
          "238: void br_mdb_init(void)",
          "239: {",
          "240:  rtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, br_mdb_dump, NULL);",
          "241: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "239: static bool is_valid_mdb_entry(struct br_mdb_entry *entry)",
          "240: {",
          "241:  if (entry->ifindex == 0)",
          "242:   return false;",
          "244:  if (entry->addr.proto == htons(ETH_P_IP)) {",
          "245:   if (!ipv4_is_multicast(entry->addr.u.ip4))",
          "246:    return false;",
          "247:   if (ipv4_is_local_multicast(entry->addr.u.ip4))",
          "248:    return false;",
          "249: #if IS_ENABLED(CONFIG_IPV6)",
          "250:  } else if (entry->addr.proto == htons(ETH_P_IPV6)) {",
          "251:   if (!ipv6_is_transient_multicast(&entry->addr.u.ip6))",
          "252:    return false;",
          "253: #endif",
          "254:  } else",
          "255:   return false;",
          "257:  return true;",
          "258: }",
          "260: static int br_mdb_parse(struct sk_buff *skb, struct nlmsghdr *nlh,",
          "261:    struct net_device **pdev, struct br_mdb_entry **pentry)",
          "262: {",
          "263:  struct net *net = sock_net(skb->sk);",
          "264:  struct br_mdb_entry *entry;",
          "265:  struct br_port_msg *bpm;",
          "266:  struct nlattr *tb[MDBA_SET_ENTRY_MAX+1];",
          "267:  struct net_device *dev;",
          "268:  int err;",
          "270:  if (!capable(CAP_NET_ADMIN))",
          "271:   return -EPERM;",
          "273:  err = nlmsg_parse(nlh, sizeof(*bpm), tb, MDBA_SET_ENTRY, NULL);",
          "274:  if (err < 0)",
          "275:   return err;",
          "277:  bpm = nlmsg_data(nlh);",
          "278:  if (bpm->ifindex == 0) {",
          "279:   pr_info(\"PF_BRIDGE: br_mdb_parse() with invalid ifindex\\n\");",
          "280:   return -EINVAL;",
          "281:  }",
          "283:  dev = __dev_get_by_index(net, bpm->ifindex);",
          "284:  if (dev == NULL) {",
          "285:   pr_info(\"PF_BRIDGE: br_mdb_parse() with unknown ifindex\\n\");",
          "286:   return -ENODEV;",
          "287:  }",
          "289:  if (!(dev->priv_flags & IFF_EBRIDGE)) {",
          "290:   pr_info(\"PF_BRIDGE: br_mdb_parse() with non-bridge\\n\");",
          "291:   return -EOPNOTSUPP;",
          "292:  }",
          "296:  if (!tb[MDBA_SET_ENTRY] ||",
          "297:      nla_len(tb[MDBA_SET_ENTRY]) != sizeof(struct br_mdb_entry)) {",
          "298:   pr_info(\"PF_BRIDGE: br_mdb_parse() with invalid attr\\n\");",
          "299:   return -EINVAL;",
          "300:  }",
          "302:  entry = nla_data(tb[MDBA_SET_ENTRY]);",
          "303:  if (!is_valid_mdb_entry(entry)) {",
          "304:   pr_info(\"PF_BRIDGE: br_mdb_parse() with invalid entry\\n\");",
          "305:   return -EINVAL;",
          "306:  }",
          "309:  return 0;",
          "310: }",
          "312: static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,",
          "313:        struct br_ip *group)",
          "314: {",
          "315:  struct net_bridge_mdb_entry *mp;",
          "316:  struct net_bridge_port_group *p;",
          "317:  struct net_bridge_port_group __rcu **pp;",
          "318:  struct net_bridge_mdb_htable *mdb;",
          "319:  int err;",
          "321:  mdb = mlock_dereference(br->mdb, br);",
          "322:  mp = br_mdb_ip_get(mdb, group);",
          "323:  if (!mp) {",
          "324:   mp = br_multicast_new_group(br, port, group);",
          "325:   err = PTR_ERR(mp);",
          "326:   if (IS_ERR(mp))",
          "327:    return err;",
          "328:  }",
          "330:  for (pp = &mp->ports;",
          "331:       (p = mlock_dereference(*pp, br)) != NULL;",
          "332:       pp = &p->next) {",
          "333:   if (p->port == port)",
          "334:    return -EEXIST;",
          "335:   if ((unsigned long)p->port < (unsigned long)port)",
          "336:    break;",
          "337:  }",
          "339:  p = br_multicast_new_port_group(port, group, *pp);",
          "340:  if (unlikely(!p))",
          "341:   return -ENOMEM;",
          "342:  rcu_assign_pointer(*pp, p);",
          "344:  br_mdb_notify(br->dev, port, group, RTM_NEWMDB);",
          "345:  return 0;",
          "346: }",
          "348: static int __br_mdb_add(struct net *net, struct net_bridge *br,",
          "349:    struct br_mdb_entry *entry)",
          "350: {",
          "351:  struct br_ip ip;",
          "352:  struct net_device *dev;",
          "353:  struct net_bridge_port *p;",
          "354:  int ret;",
          "356:  if (!netif_running(br->dev) || br->multicast_disabled)",
          "357:   return -EINVAL;",
          "359:  dev = __dev_get_by_index(net, entry->ifindex);",
          "360:  if (!dev)",
          "361:   return -ENODEV;",
          "363:  p = br_port_get_rtnl(dev);",
          "364:  if (!p || p->br != br || p->state == BR_STATE_DISABLED)",
          "365:   return -EINVAL;",
          "367:  ip.proto = entry->addr.proto;",
          "368:  if (ip.proto == htons(ETH_P_IP))",
          "369:   ip.u.ip4 = entry->addr.u.ip4;",
          "370: #if IS_ENABLED(CONFIG_IPV6)",
          "371:  else",
          "372:   ip.u.ip6 = entry->addr.u.ip6;",
          "373: #endif",
          "375:  spin_lock_bh(&br->multicast_lock);",
          "376:  ret = br_mdb_add_group(br, p, &ip);",
          "377:  spin_unlock_bh(&br->multicast_lock);",
          "378:  return ret;",
          "379: }",
          "381: static int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)",
          "382: {",
          "383:  struct net *net = sock_net(skb->sk);",
          "384:  struct br_mdb_entry *entry;",
          "385:  struct net_device *dev;",
          "386:  struct net_bridge *br;",
          "387:  int err;",
          "389:  err = br_mdb_parse(skb, nlh, &dev, &entry);",
          "390:  if (err < 0)",
          "391:   return err;",
          "393:  br = netdev_priv(dev);",
          "395:  err = __br_mdb_add(net, br, entry);",
          "396:  if (!err)",
          "397:   __br_mdb_notify(dev, entry, RTM_NEWMDB);",
          "398:  return err;",
          "399: }",
          "401: static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)",
          "402: {",
          "403:  struct net_bridge_mdb_htable *mdb;",
          "404:  struct net_bridge_mdb_entry *mp;",
          "405:  struct net_bridge_port_group *p;",
          "406:  struct net_bridge_port_group __rcu **pp;",
          "407:  struct br_ip ip;",
          "408:  int err = -EINVAL;",
          "410:  if (!netif_running(br->dev) || br->multicast_disabled)",
          "411:   return -EINVAL;",
          "413:  if (timer_pending(&br->multicast_querier_timer))",
          "414:   return -EBUSY;",
          "416:  ip.proto = entry->addr.proto;",
          "417:  if (ip.proto == htons(ETH_P_IP))",
          "418:   ip.u.ip4 = entry->addr.u.ip4;",
          "419: #if IS_ENABLED(CONFIG_IPV6)",
          "420:  else",
          "421:   ip.u.ip6 = entry->addr.u.ip6;",
          "422: #endif",
          "424:  spin_lock_bh(&br->multicast_lock);",
          "425:  mdb = mlock_dereference(br->mdb, br);",
          "427:  mp = br_mdb_ip_get(mdb, &ip);",
          "428:  if (!mp)",
          "429:   goto unlock;",
          "431:  for (pp = &mp->ports;",
          "432:       (p = mlock_dereference(*pp, br)) != NULL;",
          "433:       pp = &p->next) {",
          "434:   if (!p->port || p->port->dev->ifindex != entry->ifindex)",
          "435:    continue;",
          "437:   if (p->port->state == BR_STATE_DISABLED)",
          "438:    goto unlock;",
          "440:   rcu_assign_pointer(*pp, p->next);",
          "441:   hlist_del_init(&p->mglist);",
          "442:   del_timer(&p->timer);",
          "443:   call_rcu_bh(&p->rcu, br_multicast_free_pg);",
          "444:   err = 0;",
          "446:   if (!mp->ports && !mp->mglist &&",
          "447:       netif_running(br->dev))",
          "448:    mod_timer(&mp->timer, jiffies);",
          "449:   break;",
          "450:  }",
          "452: unlock:",
          "453:  spin_unlock_bh(&br->multicast_lock);",
          "454:  return err;",
          "455: }",
          "457: static int br_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)",
          "458: {",
          "459:  struct net_device *dev;",
          "460:  struct br_mdb_entry *entry;",
          "461:  struct net_bridge *br;",
          "462:  int err;",
          "464:  err = br_mdb_parse(skb, nlh, &dev, &entry);",
          "465:  if (err < 0)",
          "466:   return err;",
          "468:  br = netdev_priv(dev);",
          "470:  err = __br_mdb_del(br, entry);",
          "471:  if (!err)",
          "472:   __br_mdb_notify(dev, entry, RTM_DELMDB);",
          "473:  return err;",
          "474: }",
          "479:  rtnl_register(PF_BRIDGE, RTM_NEWMDB, br_mdb_add, NULL, NULL);",
          "480:  rtnl_register(PF_BRIDGE, RTM_DELMDB, br_mdb_del, NULL, NULL);",
          "",
          "---------------"
        ],
        "net/bridge/br_multicast.c||net/bridge/br_multicast.c": [
          "File: net/bridge/br_multicast.c -> net/bridge/br_multicast.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #if IS_ENABLED(CONFIG_IPV6)",
          "28: #include <net/ipv6.h>",
          "29: #include <net/mld.h>",
          "31: #include <net/ip6_checksum.h>",
          "32: #endif",
          "34: #include \"br_private.h\"",
          "39: static void br_multicast_start_querier(struct net_bridge *br);",
          "40: unsigned int br_mdb_rehash_seq;",
          "51: static inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)",
          "52: {",
          "53:  if (a->proto != b->proto)",
          "",
          "[Removed Lines]",
          "30: #include <net/addrconf.h>",
          "36: #define mlock_dereference(X, br) \\",
          "37:  rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))",
          "42: #if IS_ENABLED(CONFIG_IPV6)",
          "43: static inline int ipv6_is_transient_multicast(const struct in6_addr *addr)",
          "44: {",
          "45:  if (ipv6_addr_is_multicast(addr) && IPV6_ADDR_MC_FLAG_TRANSIENT(addr))",
          "46:   return 1;",
          "47:  return 0;",
          "48: }",
          "49: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104:  return NULL;",
          "105: }",
          "109: {",
          "110:  if (!mdb)",
          "111:   return NULL;",
          "",
          "[Removed Lines]",
          "107: static struct net_bridge_mdb_entry *br_mdb_ip_get(",
          "108:  struct net_bridge_mdb_htable *mdb, struct br_ip *dst)",
          "",
          "[Added Lines]",
          "94: struct net_bridge_mdb_entry *br_mdb_ip_get(struct net_bridge_mdb_htable *mdb,",
          "95:         struct br_ip *dst)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "208:  return maxlen > elasticity ? -EINVAL : 0;",
          "209: }",
          "212: {",
          "213:  struct net_bridge_port_group *p =",
          "214:   container_of(head, struct net_bridge_port_group, rcu);",
          "",
          "[Removed Lines]",
          "211: static void br_multicast_free_pg(struct rcu_head *head)",
          "",
          "[Added Lines]",
          "198: void br_multicast_free_pg(struct rcu_head *head)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "584:  return mp;",
          "585: }",
          "590: {",
          "591:  struct net_bridge_mdb_htable *mdb;",
          "592:  struct net_bridge_mdb_entry *mp;",
          "",
          "[Removed Lines]",
          "587: static struct net_bridge_mdb_entry *br_multicast_new_group(",
          "588:  struct net_bridge *br, struct net_bridge_port *port,",
          "589:  struct br_ip *group)",
          "",
          "[Added Lines]",
          "574: struct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,",
          "575:  struct net_bridge_port *port, struct br_ip *group)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "633:  return mp;",
          "634: }",
          "636: static int br_multicast_add_group(struct net_bridge *br,",
          "637:       struct net_bridge_port *port,",
          "638:       struct br_ip *group)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "622: struct net_bridge_port_group *br_multicast_new_port_group(",
          "623:    struct net_bridge_port *port,",
          "624:    struct br_ip *group,",
          "625:    struct net_bridge_port_group *next)",
          "626: {",
          "627:  struct net_bridge_port_group *p;",
          "629:  p = kzalloc(sizeof(*p), GFP_ATOMIC);",
          "630:  if (unlikely(!p))",
          "631:   return NULL;",
          "633:  p->addr = *group;",
          "634:  p->port = port;",
          "635:  p->next = next;",
          "636:  hlist_add_head(&p->mglist, &port->mglist);",
          "637:  setup_timer(&p->timer, br_multicast_port_group_expired,",
          "638:       (unsigned long)p);",
          "639:  return p;",
          "640: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "668:    break;",
          "669:  }",
          "673:  if (unlikely(!p))",
          "674:   goto err;",
          "683:  rcu_assign_pointer(*pp, p);",
          "684:  br_mdb_notify(br->dev, port, group, RTM_NEWMDB);",
          "",
          "[Removed Lines]",
          "671:  p = kzalloc(sizeof(*p), GFP_ATOMIC);",
          "672:  err = -ENOMEM;",
          "676:  p->addr = *group;",
          "677:  p->port = port;",
          "678:  p->next = *pp;",
          "679:  hlist_add_head(&p->mglist, &port->mglist);",
          "680:  setup_timer(&p->timer, br_multicast_port_group_expired,",
          "681:       (unsigned long)p);",
          "",
          "[Added Lines]",
          "677:  p = br_multicast_new_port_group(port, group, *pp);",
          "",
          "---------------"
        ],
        "net/bridge/br_private.h||net/bridge/br_private.h": [
          "File: net/bridge/br_private.h -> net/bridge/br_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "434: extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);",
          "435: extern int br_multicast_set_querier(struct net_bridge *br, unsigned long val);",
          "436: extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);",
          "437: extern void br_mdb_init(void);",
          "438: extern void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,",
          "439:      struct br_ip *group, int type);",
          "441: static inline bool br_multicast_is_router(struct net_bridge *br)",
          "442: {",
          "443:  return br->multicast_router == 2 ||",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "437: extern struct net_bridge_mdb_entry *br_mdb_ip_get(",
          "438:     struct net_bridge_mdb_htable *mdb,",
          "439:     struct br_ip *dst);",
          "440: extern struct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,",
          "441:     struct net_bridge_port *port, struct br_ip *group);",
          "442: extern void br_multicast_free_pg(struct rcu_head *head);",
          "443: extern struct net_bridge_port_group *br_multicast_new_port_group(",
          "444:     struct net_bridge_port *port,",
          "445:     struct br_ip *group,",
          "446:     struct net_bridge_port_group *next);",
          "451: #define mlock_dereference(X, br) \\",
          "452:  rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))",
          "454: #if IS_ENABLED(CONFIG_IPV6)",
          "455: #include <net/addrconf.h>",
          "456: static inline int ipv6_is_transient_multicast(const struct in6_addr *addr)",
          "457: {",
          "458:  if (ipv6_addr_is_multicast(addr) && IPV6_ADDR_MC_FLAG_TRANSIENT(addr))",
          "459:   return 1;",
          "460:  return 0;",
          "461: }",
          "462: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "454594f3b93a49ef568cd190c5af31376b105a7b",
      "candidate_info": {
        "commit_hash": "454594f3b93a49ef568cd190c5af31376b105a7b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/454594f3b93a49ef568cd190c5af31376b105a7b",
        "files": [
          "net/bridge/br_mdb.c",
          "net/bridge/br_multicast.c",
          "net/bridge/br_private.h"
        ],
        "message": "Revert \"bridge: only expire the mdb entry when query is received\"\n\nWhile this commit was a good attempt to fix issues occuring when no\nmulticast querier is present, this commit still has two more issues:\n\n1) There are cases where mdb entries do not expire even if there is a\nquerier present. The bridge will unnecessarily continue flooding\nmulticast packets on the according ports.\n\n2) Never removing an mdb entry could be exploited for a Denial of\nService by an attacker on the local link, slowly, but steadily eating up\nall memory.\n\nActually, this commit became obsolete with\n\"bridge: disable snooping if there is no querier\" (b00589af3b)\nwhich included fixes for a few more cases.\n\nTherefore reverting the following commits (the commit stated in the\ncommit message plus three of its follow up fixes):\n\n====================\nRevert \"bridge: update mdb expiration timer upon reports.\"\nThis reverts commit f144febd93d5ee534fdf23505ab091b2b9088edc.\nRevert \"bridge: do not call setup_timer() multiple times\"\nThis reverts commit 1faabf2aab1fdaa1ace4e8c829d1b9cf7bfec2f1.\nRevert \"bridge: fix some kernel warning in multicast timer\"\nThis reverts commit c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1.\nRevert \"bridge: only expire the mdb entry when query is received\"\nThis reverts commit 9f00b2e7cf241fa389733d41b615efdaa2cb0f5b.\n====================\n\nCC: Cong Wang <amwang@redhat.com>\nSigned-off-by: Linus L\u00fcssing <linus.luessing@web.de>\nReviewed-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/bridge/br_mdb.c||net/bridge/br_mdb.c",
          "net/bridge/br_multicast.c||net/bridge/br_multicast.c",
          "net/bridge/br_private.h||net/bridge/br_private.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bridge/br_mdb.c||net/bridge/br_mdb.c",
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ],
          "candidate": [
            "net/bridge/br_mdb.c||net/bridge/br_mdb.c",
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bridge/br_mdb.c||net/bridge/br_mdb.c": [
          "File: net/bridge/br_mdb.c -> net/bridge/br_mdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "453:   call_rcu_bh(&p->rcu, br_multicast_free_pg);",
          "454:   err = 0;",
          "457:       netif_running(br->dev))",
          "458:    mod_timer(&mp->timer, jiffies);",
          "459:   break;",
          "",
          "[Removed Lines]",
          "456:   if (!mp->ports && !mp->mglist && mp->timer_armed &&",
          "",
          "[Added Lines]",
          "456:   if (!mp->ports && !mp->mglist &&",
          "",
          "---------------"
        ],
        "net/bridge/br_multicast.c||net/bridge/br_multicast.c": [
          "File: net/bridge/br_multicast.c -> net/bridge/br_multicast.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:   del_timer(&p->timer);",
          "273:   call_rcu_bh(&p->rcu, br_multicast_free_pg);",
          "276:       netif_running(br->dev))",
          "277:    mod_timer(&mp->timer, jiffies);",
          "",
          "[Removed Lines]",
          "275:   if (!mp->ports && !mp->mglist && mp->timer_armed &&",
          "",
          "[Added Lines]",
          "275:   if (!mp->ports && !mp->mglist &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "611:   break;",
          "613:  default:",
          "617:   goto out;",
          "618:  }",
          "",
          "[Removed Lines]",
          "615:   mod_timer(&mp->timer,",
          "616:      jiffies + br->multicast_membership_interval);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "663:  struct net_bridge_mdb_entry *mp;",
          "664:  struct net_bridge_port_group *p;",
          "665:  struct net_bridge_port_group __rcu **pp;",
          "666:  int err;",
          "668:  spin_lock(&br->multicast_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "662:  unsigned long now = jiffies;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "678:  if (!port) {",
          "679:   mp->mglist = true;",
          "680:   goto out;",
          "681:  }",
          "683:  for (pp = &mp->ports;",
          "684:       (p = mlock_dereference(*pp, br)) != NULL;",
          "685:       pp = &p->next) {",
          "692:   if ((unsigned long)p->port < (unsigned long)port)",
          "693:    break;",
          "694:  }",
          "",
          "[Removed Lines]",
          "686:   if (p->port == port) {",
          "688:    mod_timer(&p->timer,",
          "689:       jiffies + br->multicast_membership_interval);",
          "690:    goto out;",
          "691:   }",
          "",
          "[Added Lines]",
          "677:   mod_timer(&mp->timer, now + br->multicast_membership_interval);",
          "684:   if (p->port == port)",
          "685:    goto found;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "699:  rcu_assign_pointer(*pp, p);",
          "700:  br_mdb_notify(br->dev, port, group, RTM_NEWMDB);",
          "702: out:",
          "703:  err = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "696: found:",
          "697:  mod_timer(&p->timer, now + br->multicast_membership_interval);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1198:  if (!mp)",
          "1199:   goto out;",
          "1204:  max_delay *= br->multicast_last_member_count;",
          "1206:  if (mp->mglist &&",
          "",
          "[Removed Lines]",
          "1201:  mod_timer(&mp->timer, now + br->multicast_membership_interval);",
          "1202:  mp->timer_armed = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1277:  if (!mp)",
          "1278:   goto out;",
          "1283:  max_delay *= br->multicast_last_member_count;",
          "1284:  if (mp->mglist &&",
          "1285:      (timer_pending(&mp->timer) ?",
          "",
          "[Removed Lines]",
          "1280:  mod_timer(&mp->timer, now + br->multicast_membership_interval);",
          "1281:  mp->timer_armed = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1365:    call_rcu_bh(&p->rcu, br_multicast_free_pg);",
          "1366:    br_mdb_notify(br->dev, port, group, RTM_DELMDB);",
          "1369:        netif_running(br->dev))",
          "1370:     mod_timer(&mp->timer, jiffies);",
          "1371:   }",
          "",
          "[Removed Lines]",
          "1368:    if (!mp->ports && !mp->mglist && mp->timer_armed &&",
          "",
          "[Added Lines]",
          "1358:    if (!mp->ports && !mp->mglist &&",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1377:        br->multicast_last_member_interval;",
          "1379:  if (!port) {",
          "1381:       (timer_pending(&mp->timer) ?",
          "1382:        time_after(mp->timer.expires, time) :",
          "1383:        try_to_del_timer_sync(&mp->timer) >= 0)) {",
          "1384:    mod_timer(&mp->timer, time);",
          "1385:   }",
          "1386:  }",
          "1387: out:",
          "1388:  spin_unlock(&br->multicast_lock);",
          "",
          "[Removed Lines]",
          "1380:   if (mp->mglist && mp->timer_armed &&",
          "",
          "[Added Lines]",
          "1370:   if (mp->mglist &&",
          "1377:   goto out;",
          "1378:  }",
          "1380:  for (p = mlock_dereference(mp->ports, br);",
          "1381:       p != NULL;",
          "1382:       p = mlock_dereference(p->next, br)) {",
          "1383:   if (p->port != port)",
          "1384:    continue;",
          "1386:   if (!hlist_unhashed(&p->mglist) &&",
          "1387:       (timer_pending(&p->timer) ?",
          "1388:        time_after(p->timer.expires, time) :",
          "1389:        try_to_del_timer_sync(&p->timer) >= 0)) {",
          "1390:    mod_timer(&p->timer, time);",
          "1391:   }",
          "1393:   break;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1805:   hlist_for_each_entry_safe(mp, n, &mdb->mhash[i],",
          "1806:        hlist[ver]) {",
          "1807:    del_timer(&mp->timer);",
          "1809:    call_rcu_bh(&mp->rcu, br_multicast_free_group);",
          "1810:   }",
          "1811:  }",
          "",
          "[Removed Lines]",
          "1808:    mp->timer_armed = false;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "net/bridge/br_private.h||net/bridge/br_private.h": [
          "File: net/bridge/br_private.h -> net/bridge/br_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:  struct timer_list  timer;",
          "127:  struct br_ip   addr;",
          "128:  bool    mglist;",
          "130: };",
          "132: struct net_bridge_mdb_htable",
          "",
          "[Removed Lines]",
          "129:  bool    timer_armed;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-1000016",
  "cve_desc": "FFMPEG version 4.1 contains a CWE-129: Improper Validation of Array Index vulnerability in libavcodec/cbs_av1.c that can result in Denial of service. This attack appears to be exploitable via specially crafted AV1 file has to be provided as input. This vulnerability appears to have been fixed in after commit b97a4b658814b2de8b9f2a3bce491c002d34de31.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "b97a4b658814b2de8b9f2a3bce491c002d34de31",
  "patch_info": {
    "commit_hash": "b97a4b658814b2de8b9f2a3bce491c002d34de31",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b97a4b658814b2de8b9f2a3bce491c002d34de31",
    "files": [
      "libavcodec/cbs_av1.c"
    ],
    "message": "cbs_av1: Fix reading of overlong uvlc codes\n\nThe specification allows 2^32-1 to be encoded as any number of zeroes\ngreater than 31, followed by a one.  This previously failed because the\ntrace code would overflow the array containing the string representation\nof the bits if there were more than 63 zeroes.  Fix that by splitting the\ntrace output into batches, and at the same time move it out of the default\npath.\n\n(While this seems likely to be a specification error, libaom does support\nit so we probably should as well.)\n\nFrom a test case by keval shah <skeval65@gmail.com>.\n\nReviewed-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c"
    ]
  },
  "patch_diff": {
    "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c": [
      "File: libavcodec/cbs_av1.c -> libavcodec/cbs_av1.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "29:                              const char *name, uint32_t *write_to,",
      "30:                              uint32_t range_min, uint32_t range_max)",
      "31: {",
      "36:     if (ctx->trace_enable)",
      "37:         position = get_bits_count(gbc);",
      "40:     while (1) {",
      "42:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"",
      "43:                    \"%s: bitstream ended.\\n\", name);",
      "44:             return AVERROR_INVALIDDATA;",
      "45:         }",
      "49:             break;",
      "54:     }",
      "56:     if (zeroes >= 32) {",
      "57:         value = MAX_UINT_BITS(32);",
      "58:     } else {",
      "65:     }",
      "67:     if (ctx->trace_enable) {",
      "68:         bits[i] = 0;",
      "71:     }",
      "73:     if (value < range_min || value > range_max) {",
      "",
      "[Removed Lines]",
      "32:     uint32_t value;",
      "33:     int position, zeroes, i, j;",
      "34:     char bits[65];",
      "39:     zeroes = i = 0;",
      "41:         if (get_bits_left(gbc) < zeroes + 1) {",
      "47:         if (get_bits1(gbc)) {",
      "48:             bits[i++] = '1';",
      "50:         } else {",
      "51:             bits[i++] = '0';",
      "52:             ++zeroes;",
      "53:         }",
      "59:         value = get_bits_long(gbc, zeroes);",
      "61:         for (j = 0; j < zeroes; j++)",
      "62:             bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';",
      "64:         value += (1 << zeroes) - 1;",
      "69:         ff_cbs_trace_syntax_element(ctx, position, name, NULL,",
      "70:                                     bits, value);",
      "",
      "[Added Lines]",
      "32:     uint32_t zeroes, bits_value, value;",
      "33:     int position;",
      "38:     zeroes = 0;",
      "40:         if (get_bits_left(gbc) < 1) {",
      "46:         if (get_bits1(gbc))",
      "48:         ++zeroes;",
      "54:         if (get_bits_left(gbc) < zeroes) {",
      "55:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"",
      "56:                    \"%s: bitstream ended.\\n\", name);",
      "57:             return AVERROR_INVALIDDATA;",
      "58:         }",
      "60:         bits_value = get_bits_long(gbc, zeroes);",
      "61:         value = bits_value + (UINT32_C(1) << zeroes) - 1;",
      "65:         char bits[65];",
      "66:         int i, j, k;",
      "68:         if (zeroes >= 32) {",
      "69:             while (zeroes > 32) {",
      "70:                 k = FFMIN(zeroes - 32, 32);",
      "71:                 for (i = 0; i < k; i++)",
      "72:                     bits[i] = '0';",
      "73:                 bits[i] = 0;",
      "74:                 ff_cbs_trace_syntax_element(ctx, position, name,",
      "75:                                             NULL, bits, 0);",
      "76:                 zeroes -= k;",
      "77:                 position += k;",
      "78:             }",
      "79:         }",
      "81:         for (i = 0; i < zeroes; i++)",
      "82:             bits[i] = '0';",
      "83:         bits[i++] = '1';",
      "85:         if (zeroes < 32) {",
      "86:             for (j = 0; j < zeroes; j++)",
      "87:                 bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';",
      "88:         }",
      "91:         ff_cbs_trace_syntax_element(ctx, position, name,",
      "92:                                     NULL, bits, value);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b420f23566825192c3fc1f46fce24d19ffc1d72e",
      "candidate_info": {
        "commit_hash": "b420f23566825192c3fc1f46fce24d19ffc1d72e",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b420f23566825192c3fc1f46fce24d19ffc1d72e",
        "files": [
          "libavcodec/cbs_av1.c"
        ],
        "message": "cbs_av1: Fix reading of overlong uvlc codes\n\nThe specification allows 2^32-1 to be encoded as any number of zeroes\ngreater than 31, followed by a one.  This previously failed because the\ntrace code would overflow the array containing the string representation\nof the bits if there were more than 63 zeroes.  Fix that by splitting the\ntrace output into batches, and at the same time move it out of the default\npath.\n\n(While this seems likely to be a specification error, libaom does support\nit so we probably should as well.)\n\nFrom a test case by keval shah <skeval65@gmail.com>.\n\nReviewed-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit b97a4b658814b2de8b9f2a3bce491c002d34de31)",
        "before_after_code_files": [
          "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c"
          ],
          "candidate": [
            "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c": [
          "File: libavcodec/cbs_av1.c -> libavcodec/cbs_av1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:                              const char *name, uint32_t *write_to,",
          "30:                              uint32_t range_min, uint32_t range_max)",
          "31: {",
          "36:     if (ctx->trace_enable)",
          "37:         position = get_bits_count(gbc);",
          "40:     while (1) {",
          "42:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"",
          "43:                    \"%s: bitstream ended.\\n\", name);",
          "44:             return AVERROR_INVALIDDATA;",
          "45:         }",
          "49:             break;",
          "54:     }",
          "56:     if (zeroes >= 32) {",
          "57:         value = MAX_UINT_BITS(32);",
          "58:     } else {",
          "65:     }",
          "67:     if (ctx->trace_enable) {",
          "68:         bits[i] = 0;",
          "71:     }",
          "73:     if (value < range_min || value > range_max) {",
          "",
          "[Removed Lines]",
          "32:     uint32_t value;",
          "33:     int position, zeroes, i, j;",
          "34:     char bits[65];",
          "39:     zeroes = i = 0;",
          "41:         if (get_bits_left(gbc) < zeroes + 1) {",
          "47:         if (get_bits1(gbc)) {",
          "48:             bits[i++] = '1';",
          "50:         } else {",
          "51:             bits[i++] = '0';",
          "52:             ++zeroes;",
          "53:         }",
          "59:         value = get_bits_long(gbc, zeroes);",
          "61:         for (j = 0; j < zeroes; j++)",
          "62:             bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';",
          "64:         value += (1 << zeroes) - 1;",
          "69:         ff_cbs_trace_syntax_element(ctx, position, name, NULL,",
          "70:                                     bits, value);",
          "",
          "[Added Lines]",
          "32:     uint32_t zeroes, bits_value, value;",
          "33:     int position;",
          "38:     zeroes = 0;",
          "40:         if (get_bits_left(gbc) < 1) {",
          "46:         if (get_bits1(gbc))",
          "48:         ++zeroes;",
          "54:         if (get_bits_left(gbc) < zeroes) {",
          "55:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"",
          "56:                    \"%s: bitstream ended.\\n\", name);",
          "57:             return AVERROR_INVALIDDATA;",
          "58:         }",
          "60:         bits_value = get_bits_long(gbc, zeroes);",
          "61:         value = bits_value + (UINT32_C(1) << zeroes) - 1;",
          "65:         char bits[65];",
          "66:         int i, j, k;",
          "68:         if (zeroes >= 32) {",
          "69:             while (zeroes > 32) {",
          "70:                 k = FFMIN(zeroes - 32, 32);",
          "71:                 for (i = 0; i < k; i++)",
          "72:                     bits[i] = '0';",
          "73:                 bits[i] = 0;",
          "74:                 ff_cbs_trace_syntax_element(ctx, position, name,",
          "75:                                             NULL, bits, 0);",
          "76:                 zeroes -= k;",
          "77:                 position += k;",
          "78:             }",
          "79:         }",
          "81:         for (i = 0; i < zeroes; i++)",
          "82:             bits[i] = '0';",
          "83:         bits[i++] = '1';",
          "85:         if (zeroes < 32) {",
          "86:             for (j = 0; j < zeroes; j++)",
          "87:                 bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';",
          "88:         }",
          "91:         ff_cbs_trace_syntax_element(ctx, position, name,",
          "92:                                     NULL, bits, value);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c8c81ac5026c20ce60860dc9aa905e5e1634bed1",
      "candidate_info": {
        "commit_hash": "c8c81ac5026c20ce60860dc9aa905e5e1634bed1",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c8c81ac5026c20ce60860dc9aa905e5e1634bed1",
        "files": [
          "configure",
          "libavcodec/Makefile",
          "libavcodec/av1.h",
          "libavcodec/cbs.c",
          "libavcodec/cbs_av1.c",
          "libavcodec/cbs_av1.h",
          "libavcodec/cbs_av1_syntax_template.c",
          "libavcodec/cbs_internal.h"
        ],
        "message": "lavc: Add coded bitstream read/write support for AV1",
        "before_after_code_files": [
          "libavcodec/av1.h||libavcodec/av1.h",
          "libavcodec/cbs.c||libavcodec/cbs.c",
          "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c",
          "libavcodec/cbs_av1.h||libavcodec/cbs_av1.h",
          "libavcodec/cbs_av1_syntax_template.c||libavcodec/cbs_av1_syntax_template.c",
          "libavcodec/cbs_internal.h||libavcodec/cbs_internal.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c"
          ],
          "candidate": [
            "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/av1.h||libavcodec/av1.h": [
          "File: libavcodec/av1.h -> libavcodec/av1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:     AV1_OBU_PADDING                = 15,",
          "40: } AV1_OBU_Type;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: enum {",
          "44:     AV1_METADATA_TYPE_HDR_CLL     = 1,",
          "45:     AV1_METADATA_TYPE_HDR_MDCV    = 2,",
          "46:     AV1_METADATA_TYPE_SCALABILITY = 3,",
          "47:     AV1_METADATA_TYPE_ITUT_T35    = 4,",
          "48:     AV1_METADATA_TYPE_TIMECODE    = 5,",
          "49: };",
          "52: enum {",
          "53:     AV1_FRAME_KEY        = 0,",
          "54:     AV1_FRAME_INTER      = 1,",
          "55:     AV1_FRAME_INTRA_ONLY = 2,",
          "56:     AV1_FRAME_SWITCH     = 3,",
          "57: };",
          "60: enum {",
          "61:     AV1_REF_FRAME_INTRA   = 0,",
          "62:     AV1_REF_FRAME_LAST    = 1,",
          "63:     AV1_REF_FRAME_LAST2   = 2,",
          "64:     AV1_REF_FRAME_LAST3   = 3,",
          "65:     AV1_REF_FRAME_GOLDEN  = 4,",
          "66:     AV1_REF_FRAME_BWDREF  = 5,",
          "67:     AV1_REF_FRAME_ALTREF2 = 6,",
          "68:     AV1_REF_FRAME_ALTREF  = 7,",
          "69: };",
          "72: enum {",
          "73:     AV1_MAX_OPERATING_POINTS = 32,",
          "75:     AV1_MAX_SB_SIZE    = 128,",
          "76:     AV1_MI_SIZE        = 4,",
          "78:     AV1_MAX_TILE_WIDTH = 4096,",
          "79:     AV1_MAX_TILE_AREA  = 4096 * 2304,",
          "80:     AV1_MAX_TILE_ROWS  = 64,",
          "81:     AV1_MAX_TILE_COLS  = 64,",
          "83:     AV1_NUM_REF_FRAMES       = 8,",
          "84:     AV1_REFS_PER_FRAME       = 7,",
          "85:     AV1_TOTAL_REFS_PER_FRAME = 8,",
          "86:     AV1_PRIMARY_REF_NONE     = 7,",
          "88:     AV1_MAX_SEGMENTS = 8,",
          "89:     AV1_SEG_LVL_MAX  = 8,",
          "91:     AV1_SEG_LVL_ALT_Q      = 0,",
          "92:     AV1_SEG_LVL_ALT_LF_Y_V = 1,",
          "93:     AV1_SEG_LVL_REF_FRAME  = 5,",
          "94:     AV1_SEG_LVL_SKIP       = 6,",
          "95:     AV1_SEG_LVL_GLOBAL_MV  = 7,",
          "97:     AV1_SELECT_SCREEN_CONTENT_TOOLS = 2,",
          "98:     AV1_SELECT_INTEGER_MV           = 2,",
          "100:     AV1_SUPERRES_NUM       = 8,",
          "101:     AV1_SUPERRES_DENOM_MIN = 9,",
          "103:     AV1_INTERPOLATION_FILTER_SWITCHABLE = 4,",
          "105:     AV1_GM_ABS_ALPHA_BITS       = 12,",
          "106:     AV1_GM_ALPHA_PREC_BITS      = 15,",
          "107:     AV1_GM_ABS_TRANS_ONLY_BITS  = 9,",
          "108:     AV1_GM_TRANS_ONLY_PREC_BITS = 3,",
          "109:     AV1_GM_ABS_TRANS_BITS       = 12,",
          "110:     AV1_GM_TRANS_PREC_BITS      = 6,",
          "111:     AV1_WARPEDMODEL_PREC_BITS   = 16,",
          "113:     AV1_WARP_MODEL_IDENTITY    = 0,",
          "114:     AV1_WARP_MODEL_TRANSLATION = 1,",
          "115:     AV1_WARP_MODEL_ROTZOOM     = 2,",
          "116:     AV1_WARP_MODEL_AFFINE      = 3,",
          "117: };",
          "124: enum {",
          "125:     AV1_CSP_UNKNOWN   = 0,",
          "126:     AV1_CSP_VERTICAL  = 1, // -> AVCHROMA_LOC_LEFT.",
          "127:     AV1_CSP_COLOCATED = 2, // -> AVCHROMA_LOC_TOPLEFT.",
          "128: };",
          "",
          "---------------"
        ],
        "libavcodec/cbs.c||libavcodec/cbs.c": [
          "File: libavcodec/cbs.c -> libavcodec/cbs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: static const CodedBitstreamType *cbs_type_table[] = {",
          "32: #if CONFIG_CBS_H264",
          "33:     &ff_cbs_type_h264,",
          "34: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #if CONFIG_CBS_AV1",
          "33:     &ff_cbs_type_av1,",
          "34: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47: };",
          "49: const enum AVCodecID ff_cbs_all_codec_ids[] = {",
          "50: #if CONFIG_CBS_H264",
          "51:     AV_CODEC_ID_H264,",
          "52: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53: #if CONFIG_CBS_AV1",
          "54:     AV_CODEC_ID_AV1,",
          "55: #endif",
          "",
          "---------------"
        ],
        "libavcodec/cbs_av1.c||libavcodec/cbs_av1.c": [
          "File: libavcodec/cbs_av1.c -> libavcodec/cbs_av1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include \"libavutil/avassert.h\"",
          "20: #include \"libavutil/pixfmt.h\"",
          "22: #include \"cbs.h\"",
          "23: #include \"cbs_internal.h\"",
          "24: #include \"cbs_av1.h\"",
          "25: #include \"internal.h\"",
          "28: static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,",
          "29:                              const char *name, uint32_t *write_to,",
          "30:                              uint32_t range_min, uint32_t range_max)",
          "31: {",
          "32:     uint32_t value;",
          "33:     int position, zeroes, i, j;",
          "34:     char bits[65];",
          "36:     if (ctx->trace_enable)",
          "37:         position = get_bits_count(gbc);",
          "39:     zeroes = i = 0;",
          "40:     while (1) {",
          "41:         if (get_bits_left(gbc) < zeroes + 1) {",
          "42:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"",
          "43:                    \"%s: bitstream ended.\\n\", name);",
          "44:             return AVERROR_INVALIDDATA;",
          "45:         }",
          "47:         if (get_bits1(gbc)) {",
          "48:             bits[i++] = '1';",
          "49:             break;",
          "50:         } else {",
          "51:             bits[i++] = '0';",
          "52:             ++zeroes;",
          "53:         }",
          "54:     }",
          "56:     if (zeroes >= 32) {",
          "57:         value = MAX_UINT_BITS(32);",
          "58:     } else {",
          "59:         value = get_bits_long(gbc, zeroes);",
          "61:         for (j = 0; j < zeroes; j++)",
          "62:             bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';",
          "64:         value += (1 << zeroes) - 1;",
          "65:     }",
          "67:     if (ctx->trace_enable) {",
          "68:         bits[i] = 0;",
          "69:         ff_cbs_trace_syntax_element(ctx, position, name, NULL,",
          "70:                                     bits, value);",
          "71:     }",
          "73:     if (value < range_min || value > range_max) {",
          "74:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"",
          "75:                \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",",
          "76:                name, value, range_min, range_max);",
          "77:         return AVERROR_INVALIDDATA;",
          "78:     }",
          "81:     return 0;",
          "82: }",
          "84: static int cbs_av1_write_uvlc(CodedBitstreamContext *ctx, PutBitContext *pbc,",
          "85:                               const char *name, uint32_t value,",
          "86:                               uint32_t range_min, uint32_t range_max)",
          "87: {",
          "88:     uint32_t v;",
          "89:     int position, zeroes;",
          "91:     if (value < range_min || value > range_max) {",
          "92:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"",
          "93:                \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",",
          "94:                name, value, range_min, range_max);",
          "95:         return AVERROR_INVALIDDATA;",
          "96:     }",
          "98:     if (ctx->trace_enable)",
          "99:         position = put_bits_count(pbc);",
          "101:     if (value == 0) {",
          "102:         zeroes = 0;",
          "103:         put_bits(pbc, 1, 1);",
          "104:     } else {",
          "105:         zeroes = av_log2(value + 1);",
          "106:         v = value - (1 << zeroes) + 1;",
          "107:         put_bits(pbc, zeroes + 1, 1);",
          "108:         put_bits(pbc, zeroes, v);",
          "109:     }",
          "111:     if (ctx->trace_enable) {",
          "112:         char bits[65];",
          "113:         int i, j;",
          "114:         i = 0;",
          "115:         for (j = 0; j < zeroes; j++)",
          "116:             bits[i++] = '0';",
          "117:         bits[i++] = '1';",
          "118:         for (j = 0; j < zeroes; j++)",
          "119:             bits[i++] = (v >> (zeroes - j - 1) & 1) ? '1' : '0';",
          "120:         bits[i++] = 0;",
          "121:         ff_cbs_trace_syntax_element(ctx, position, name, NULL,",
          "122:                                     bits, value);",
          "123:     }",
          "125:     return 0;",
          "126: }",
          "128: static int cbs_av1_read_leb128(CodedBitstreamContext *ctx, GetBitContext *gbc,",
          "129:                                const char *name, uint64_t *write_to)",
          "130: {",
          "131:     uint64_t value;",
          "132:     int position, err, i;",
          "134:     if (ctx->trace_enable)",
          "135:         position = get_bits_count(gbc);",
          "137:     value = 0;",
          "138:     for (i = 0; i < 8; i++) {",
          "139:         int subscript[2] = { 1, i };",
          "140:         uint32_t byte;",
          "141:         err = ff_cbs_read_unsigned(ctx, gbc, 8, \"leb128_byte[i]\", subscript,",
          "142:                                    &byte, 0x00, 0xff);",
          "143:         if (err < 0)",
          "144:             return err;",
          "146:         value |= (uint64_t)(byte & 0x7f) << (i * 7);",
          "147:         if (!(byte & 0x80))",
          "148:             break;",
          "149:     }",
          "151:     if (ctx->trace_enable)",
          "152:         ff_cbs_trace_syntax_element(ctx, position, name, NULL, \"\", value);",
          "155:     return 0;",
          "156: }",
          "158: static int cbs_av1_write_leb128(CodedBitstreamContext *ctx, PutBitContext *pbc,",
          "159:                                 const char *name, uint64_t value)",
          "160: {",
          "161:     int position, err, len, i;",
          "162:     uint8_t byte;",
          "164:     len = (av_log2(value) + 7) / 7;",
          "166:     if (ctx->trace_enable)",
          "167:         position = put_bits_count(pbc);",
          "169:     for (i = 0; i < len; i++) {",
          "170:         int subscript[2] = { 1, i };",
          "172:         byte = value >> (7 * i) & 0x7f;",
          "173:         if (i < len - 1)",
          "174:             byte |= 0x80;",
          "176:         err = ff_cbs_write_unsigned(ctx, pbc, 8, \"leb128_byte[i]\", subscript,",
          "177:                                     byte, 0x00, 0xff);",
          "178:         if (err < 0)",
          "179:             return err;",
          "180:     }",
          "182:     if (ctx->trace_enable)",
          "183:         ff_cbs_trace_syntax_element(ctx, position, name, NULL, \"\", value);",
          "185:     return 0;",
          "186: }",
          "188: static int cbs_av1_read_su(CodedBitstreamContext *ctx, GetBitContext *gbc,",
          "189:                            int width, const char *name,",
          "190:                            const int *subscripts, int32_t *write_to)",
          "191: {",
          "192:     uint32_t magnitude;",
          "193:     int position, sign;",
          "194:     int32_t value;",
          "196:     if (ctx->trace_enable)",
          "197:         position = get_bits_count(gbc);",
          "199:     if (get_bits_left(gbc) < width + 1) {",
          "200:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid signed value at \"",
          "201:                \"%s: bitstream ended.\\n\", name);",
          "202:         return AVERROR_INVALIDDATA;",
          "203:     }",
          "205:     magnitude = get_bits(gbc, width);",
          "206:     sign      = get_bits1(gbc);",
          "207:     value     = sign ? -(int32_t)magnitude : magnitude;",
          "209:     if (ctx->trace_enable) {",
          "210:         char bits[33];",
          "211:         int i;",
          "212:         for (i = 0; i < width; i++)",
          "213:             bits[i] = magnitude >> (width - i - 1) & 1 ? '1' : '0';",
          "214:         bits[i] = sign ? '1' : '0';",
          "215:         bits[i + 1] = 0;",
          "217:         ff_cbs_trace_syntax_element(ctx, position,",
          "218:                                     name, subscripts, bits, value);",
          "219:     }",
          "222:     return 0;",
          "223: }",
          "225: static int cbs_av1_write_su(CodedBitstreamContext *ctx, PutBitContext *pbc,",
          "226:                             int width, const char *name,",
          "227:                             const int *subscripts, int32_t value)",
          "228: {",
          "229:     uint32_t magnitude;",
          "230:     int sign;",
          "232:     if (put_bits_left(pbc) < width + 1)",
          "233:         return AVERROR(ENOSPC);",
          "235:     sign      = value < 0;",
          "236:     magnitude = sign ? -value : value;",
          "238:     if (ctx->trace_enable) {",
          "239:         char bits[33];",
          "240:         int i;",
          "241:         for (i = 0; i < width; i++)",
          "242:             bits[i] = magnitude >> (width - i - 1) & 1 ? '1' : '0';",
          "243:         bits[i] = sign ? '1' : '0';",
          "244:         bits[i + 1] = 0;",
          "246:         ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),",
          "247:                                     name, subscripts, bits, value);",
          "248:     }",
          "250:     put_bits(pbc, width, magnitude);",
          "251:     put_bits(pbc, 1, sign);",
          "253:     return 0;",
          "254: }",
          "256: static int cbs_av1_read_ns(CodedBitstreamContext *ctx, GetBitContext *gbc,",
          "257:                            uint32_t n, const char *name,",
          "258:                            const int *subscripts, uint32_t *write_to)",
          "259: {",
          "260:     uint32_t w, m, v, extra_bit, value;",
          "261:     int position;",
          "263:     av_assert0(n > 0);",
          "265:     if (ctx->trace_enable)",
          "266:         position = get_bits_count(gbc);",
          "268:     w = av_log2(n) + 1;",
          "269:     m = (1 << w) - n;",
          "271:     if (get_bits_left(gbc) < w) {",
          "272:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid non-symmetric value at \"",
          "273:                \"%s: bitstream ended.\\n\", name);",
          "274:         return AVERROR_INVALIDDATA;",
          "275:     }",
          "277:     if (w - 1 > 0)",
          "278:         v = get_bits(gbc, w - 1);",
          "279:     else",
          "280:         v = 0;",
          "282:     if (v < m) {",
          "283:         value = v;",
          "284:     } else {",
          "285:         extra_bit = get_bits1(gbc);",
          "286:         value = (v << 1) - m + extra_bit;",
          "287:     }",
          "289:     if (ctx->trace_enable) {",
          "290:         char bits[33];",
          "291:         int i;",
          "292:         for (i = 0; i < w - 1; i++)",
          "293:             bits[i] = (v >> i & 1) ? '1' : '0';",
          "294:         if (v >= m)",
          "295:             bits[i++] = extra_bit ? '1' : '0';",
          "296:         bits[i] = 0;",
          "298:         ff_cbs_trace_syntax_element(ctx, position,",
          "299:                                     name, subscripts, bits, value);",
          "300:     }",
          "303:     return 0;",
          "304: }",
          "306: static int cbs_av1_write_ns(CodedBitstreamContext *ctx, PutBitContext *pbc,",
          "307:                             uint32_t n, const char *name,",
          "308:                             const int *subscripts, uint32_t value)",
          "309: {",
          "310:     uint32_t w, m, v, extra_bit;",
          "311:     int position;",
          "313:     if (value > n) {",
          "314:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"",
          "315:                \"%\"PRIu32\", but must be in [0,%\"PRIu32\"].\\n\",",
          "316:                name, value, n);",
          "317:         return AVERROR_INVALIDDATA;",
          "318:     }",
          "320:     if (ctx->trace_enable)",
          "321:         position = put_bits_count(pbc);",
          "323:     w = av_log2(n) + 1;",
          "324:     m = (1 << w) - n;",
          "326:     if (put_bits_left(pbc) < w)",
          "327:         return AVERROR(ENOSPC);",
          "329:     if (value < m) {",
          "330:         v = value;",
          "331:         put_bits(pbc, w - 1, v);",
          "332:     } else {",
          "333:         v = m + ((value - m) >> 1);",
          "334:         extra_bit = (value - m) & 1;",
          "335:         put_bits(pbc, w - 1, v);",
          "336:         put_bits(pbc, 1, extra_bit);",
          "337:     }",
          "339:     if (ctx->trace_enable) {",
          "340:         char bits[33];",
          "341:         int i;",
          "342:         for (i = 0; i < w - 1; i++)",
          "343:             bits[i] = (v >> i & 1) ? '1' : '0';",
          "344:         if (value >= m)",
          "345:             bits[i++] = extra_bit ? '1' : '0';",
          "346:         bits[i] = 0;",
          "348:         ff_cbs_trace_syntax_element(ctx, position,",
          "349:                                     name, subscripts, bits, value);",
          "350:     }",
          "352:     return 0;",
          "353: }",
          "355: static int cbs_av1_read_increment(CodedBitstreamContext *ctx, GetBitContext *gbc,",
          "356:                                   uint32_t range_min, uint32_t range_max,",
          "357:                                   const char *name, uint32_t *write_to)",
          "358: {",
          "359:     uint32_t value;",
          "360:     int position, i;",
          "361:     char bits[33];",
          "363:     av_assert0(range_min <= range_max && range_max - range_min < sizeof(bits) - 1);",
          "364:     if (ctx->trace_enable)",
          "365:         position = get_bits_count(gbc);",
          "367:     for (i = 0, value = range_min; value < range_max;) {",
          "368:         if (get_bits_left(gbc) < 1) {",
          "369:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid increment value at \"",
          "370:                    \"%s: bitstream ended.\\n\", name);",
          "371:             return AVERROR_INVALIDDATA;",
          "372:         }",
          "373:         if (get_bits1(gbc)) {",
          "374:             bits[i++] = '1';",
          "375:             ++value;",
          "376:         } else {",
          "377:             bits[i++] = '0';",
          "378:             break;",
          "379:         }",
          "380:     }",
          "382:     if (ctx->trace_enable) {",
          "383:         bits[i] = 0;",
          "384:         ff_cbs_trace_syntax_element(ctx, position,",
          "385:                                     name, NULL, bits, value);",
          "386:     }",
          "389:     return 0;",
          "390: }",
          "392: static int cbs_av1_write_increment(CodedBitstreamContext *ctx, PutBitContext *pbc,",
          "393:                                    uint32_t range_min, uint32_t range_max,",
          "394:                                    const char *name, uint32_t value)",
          "395: {",
          "396:     int len;",
          "398:     av_assert0(range_min <= range_max && range_max - range_min < 32);",
          "399:     if (value < range_min || value > range_max) {",
          "400:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"",
          "401:                \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",",
          "402:                name, value, range_min, range_max);",
          "403:         return AVERROR_INVALIDDATA;",
          "404:     }",
          "406:     if (value == range_max)",
          "407:         len = range_max - range_min;",
          "408:     else",
          "409:         len = value - range_min + 1;",
          "410:     if (put_bits_left(pbc) < len)",
          "411:         return AVERROR(ENOSPC);",
          "413:     if (ctx->trace_enable) {",
          "414:         char bits[33];",
          "415:         int i;",
          "416:         for (i = 0; i < len; i++) {",
          "417:             if (range_min + i == value)",
          "418:                 bits[i] = '0';",
          "419:             else",
          "420:                 bits[i] = '1';",
          "421:         }",
          "422:         bits[i] = 0;",
          "423:         ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),",
          "424:                                     name, NULL, bits, value);",
          "425:     }",
          "427:     if (len > 0)",
          "428:         put_bits(pbc, len, (1 << len) - 1 - (value != range_max));",
          "430:     return 0;",
          "431: }",
          "433: static int cbs_av1_read_subexp(CodedBitstreamContext *ctx, GetBitContext *gbc,",
          "434:                                uint32_t range_max, const char *name,",
          "435:                                const int *subscripts, uint32_t *write_to)",
          "436: {",
          "437:     uint32_t value;",
          "438:     int position, err;",
          "439:     uint32_t max_len, len, range_offset, range_bits;",
          "441:     if (ctx->trace_enable)",
          "442:         position = get_bits_count(gbc);",
          "444:     av_assert0(range_max > 0);",
          "445:     max_len = av_log2(range_max - 1) - 3;",
          "447:     err = cbs_av1_read_increment(ctx, gbc, 0, max_len,",
          "448:                                  \"subexp_more_bits\", &len);",
          "449:     if (err < 0)",
          "450:         return err;",
          "452:     if (len) {",
          "453:         range_bits   = 2 + len;",
          "454:         range_offset = 1 << range_bits;",
          "455:     } else {",
          "456:         range_bits   = 3;",
          "457:         range_offset = 0;",
          "458:     }",
          "460:     if (len < max_len) {",
          "461:         err = ff_cbs_read_unsigned(ctx, gbc, range_bits,",
          "462:                                    \"subexp_bits\", NULL, &value,",
          "463:                                    0, MAX_UINT_BITS(range_bits));",
          "464:         if (err < 0)",
          "465:             return err;",
          "467:     } else {",
          "468:         err = cbs_av1_read_ns(ctx, gbc, range_max - range_offset,",
          "469:                               \"subexp_final_bits\", NULL, &value);",
          "470:         if (err < 0)",
          "471:             return err;",
          "472:     }",
          "473:     value += range_offset;",
          "475:     if (ctx->trace_enable)",
          "476:         ff_cbs_trace_syntax_element(ctx, position,",
          "477:                                     name, subscripts, \"\", value);",
          "480:     return err;",
          "481: }",
          "483: static int cbs_av1_write_subexp(CodedBitstreamContext *ctx, PutBitContext *pbc,",
          "484:                                 uint32_t range_max, const char *name,",
          "485:                                 const int *subscripts, uint32_t value)",
          "486: {",
          "487:     int position, err;",
          "488:     uint32_t max_len, len, range_offset, range_bits;",
          "490:     if (value > range_max) {",
          "491:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"",
          "492:                \"%\"PRIu32\", but must be in [0,%\"PRIu32\"].\\n\",",
          "493:                name, value, range_max);",
          "494:         return AVERROR_INVALIDDATA;",
          "495:     }",
          "497:     if (ctx->trace_enable)",
          "498:         position = put_bits_count(pbc);",
          "500:     av_assert0(range_max > 0);",
          "501:     max_len = av_log2(range_max - 1) - 3;",
          "503:     if (value < 8) {",
          "504:         range_bits   = 3;",
          "505:         range_offset = 0;",
          "506:         len = 0;",
          "507:     } else {",
          "508:         range_bits = av_log2(value);",
          "509:         len = range_bits - 2;",
          "510:         if (len > max_len) {",
          "512:             av_assert0(len == max_len + 1);",
          "513:             --range_bits;",
          "514:             len = max_len;",
          "515:         }",
          "516:         range_offset = 1 << range_bits;",
          "517:     }",
          "519:     err = cbs_av1_write_increment(ctx, pbc, 0, max_len,",
          "520:                                   \"subexp_more_bits\", len);",
          "521:     if (err < 0)",
          "522:         return err;",
          "524:     if (len < max_len) {",
          "525:         err = ff_cbs_write_unsigned(ctx, pbc, range_bits,",
          "526:                                     \"subexp_bits\", NULL,",
          "527:                                     value - range_offset,",
          "528:                                     0, MAX_UINT_BITS(range_bits));",
          "529:         if (err < 0)",
          "530:             return err;",
          "532:     } else {",
          "533:         err = cbs_av1_write_ns(ctx, pbc, range_max - range_offset,",
          "534:                                \"subexp_final_bits\", NULL,",
          "535:                                value - range_offset);",
          "536:         if (err < 0)",
          "537:             return err;",
          "538:     }",
          "540:     if (ctx->trace_enable)",
          "541:         ff_cbs_trace_syntax_element(ctx, position,",
          "542:                                     name, subscripts, \"\", value);",
          "544:     return err;",
          "545: }",
          "548: static int cbs_av1_tile_log2(int blksize, int target)",
          "549: {",
          "550:     int k;",
          "551:     for (k = 0; (blksize << k) < target; k++);",
          "552:     return k;",
          "553: }",
          "555: static int cbs_av1_get_relative_dist(const AV1RawSequenceHeader *seq,",
          "556:                                      unsigned int a, unsigned int b)",
          "557: {",
          "558:     unsigned int diff, m;",
          "559:     if (!seq->enable_order_hint)",
          "560:         return 0;",
          "561:     diff = a - b;",
          "562:     m = 1 << seq->order_hint_bits_minus_1;",
          "563:     diff = (diff & (m - 1)) - (diff & m);",
          "564:     return diff;",
          "565: }",
          "568: #define HEADER(name) do { \\",
          "569:         ff_cbs_trace_header(ctx, name); \\",
          "570:     } while (0)",
          "572: #define CHECK(call) do { \\",
          "573:         err = (call); \\",
          "574:         if (err < 0) \\",
          "575:             return err; \\",
          "576:     } while (0)",
          "578: #define FUNC_NAME(rw, codec, name) cbs_ ## codec ## _ ## rw ## _ ## name",
          "579: #define FUNC_AV1(rw, name) FUNC_NAME(rw, av1, name)",
          "580: #define FUNC(name) FUNC_AV1(READWRITE, name)",
          "582: #define SUBSCRIPTS(subs, ...) (subs > 0 ? ((int[subs + 1]){ subs, __VA_ARGS__ }) : NULL)",
          "584: #define fb(width, name) \\",
          "585:         xf(width, name, current->name, 0, MAX_UINT_BITS(width), 0)",
          "586: #define fc(width, name, range_min, range_max) \\",
          "587:         xf(width, name, current->name, range_min, range_max, 0)",
          "588: #define flag(name) fb(1, name)",
          "589: #define su(width, name) \\",
          "590:         xsu(width, name, current->name, 0)",
          "592: #define fbs(width, name, subs, ...) \\",
          "593:         xf(width, name, current->name, 0, MAX_UINT_BITS(width), subs, __VA_ARGS__)",
          "594: #define fcs(width, name, range_min, range_max, subs, ...) \\",
          "595:         xf(width, name, current->name, range_min, range_max, subs, __VA_ARGS__)",
          "596: #define flags(name, subs, ...) \\",
          "597:         xf(1, name, current->name, 0, 1, subs, __VA_ARGS__)",
          "598: #define sus(width, name, subs, ...) \\",
          "599:         xsu(width, name, current->name, subs, __VA_ARGS__)",
          "601: #define fixed(width, name, value) do { \\",
          "602:         av_unused uint32_t fixed_value = value; \\",
          "603:         xf(width, name, fixed_value, value, value, 0); \\",
          "604:     } while (0)",
          "607: #define READ",
          "608: #define READWRITE read",
          "609: #define RWContext GetBitContext",
          "611: #define xf(width, name, var, range_min, range_max, subs, ...) do { \\",
          "612:         uint32_t value = range_min; \\",
          "613:         CHECK(ff_cbs_read_unsigned(ctx, rw, width, #name, \\",
          "614:                                    SUBSCRIPTS(subs, __VA_ARGS__), \\",
          "615:                                    &value, range_min, range_max)); \\",
          "616:         var = value; \\",
          "617:     } while (0)",
          "619: #define xsu(width, name, var, subs, ...) do { \\",
          "620:         int32_t value = 0; \\",
          "621:         CHECK(cbs_av1_read_su(ctx, rw, width, #name, \\",
          "622:                               SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\",
          "623:         var = value; \\",
          "624:     } while (0)",
          "626: #define uvlc(name, range_min, range_max) do { \\",
          "627:         uint32_t value = range_min; \\",
          "628:         CHECK(cbs_av1_read_uvlc(ctx, rw, #name, \\",
          "629:                                 &value, range_min, range_max)); \\",
          "630:         current->name = value; \\",
          "631:     } while (0)",
          "633: #define ns(max_value, name, subs, ...) do { \\",
          "634:         uint32_t value = 0; \\",
          "635:         CHECK(cbs_av1_read_ns(ctx, rw, max_value, #name, \\",
          "636:                               SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\",
          "637:         current->name = value; \\",
          "638:     } while (0)",
          "640: #define increment(name, min, max) do { \\",
          "641:         uint32_t value = 0; \\",
          "642:         CHECK(cbs_av1_read_increment(ctx, rw, min, max, #name, &value)); \\",
          "643:         current->name = value; \\",
          "644:     } while (0)",
          "646: #define subexp(name, max, subs, ...) do { \\",
          "647:         uint32_t value = 0; \\",
          "648:         CHECK(cbs_av1_read_subexp(ctx, rw, max, #name, \\",
          "649:                                   SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\",
          "650:         current->name = value; \\",
          "651:     } while (0)",
          "653: #define delta_q(name) do { \\",
          "654:         uint8_t delta_coded; \\",
          "655:         int8_t delta_q; \\",
          "656:         xf(1, name.delta_coded, delta_coded, 0, 1, 0); \\",
          "657:         if (delta_coded) \\",
          "658:             xsu(1 + 6, name.delta_q, delta_q, 0); \\",
          "659:         else \\",
          "660:             delta_q = 0; \\",
          "661:         current->name = delta_q; \\",
          "662:     } while (0)",
          "664: #define leb128(name) do { \\",
          "665:         uint64_t value = 0; \\",
          "666:         CHECK(cbs_av1_read_leb128(ctx, rw, #name, &value)); \\",
          "667:         current->name = value; \\",
          "668:     } while (0)",
          "670: #define infer(name, value) do { \\",
          "671:         current->name = value; \\",
          "672:     } while (0)",
          "674: #define byte_alignment(rw) (get_bits_count(rw) % 8)",
          "676: #include \"cbs_av1_syntax_template.c\"",
          "678: #undef READ",
          "679: #undef READWRITE",
          "680: #undef RWContext",
          "681: #undef xf",
          "682: #undef xsu",
          "683: #undef uvlc",
          "684: #undef leb128",
          "685: #undef ns",
          "686: #undef increment",
          "687: #undef subexp",
          "688: #undef delta_q",
          "689: #undef leb128",
          "690: #undef infer",
          "691: #undef byte_alignment",
          "694: #define WRITE",
          "695: #define READWRITE write",
          "696: #define RWContext PutBitContext",
          "698: #define xf(width, name, var, range_min, range_max, subs, ...) do { \\",
          "699:         CHECK(ff_cbs_write_unsigned(ctx, rw, width, #name, \\",
          "700:                                     SUBSCRIPTS(subs, __VA_ARGS__), \\",
          "701:                                     var, range_min, range_max)); \\",
          "702:     } while (0)",
          "704: #define xsu(width, name, var, subs, ...) do { \\",
          "705:         CHECK(cbs_av1_write_su(ctx, rw, width, #name, \\",
          "706:                                SUBSCRIPTS(subs, __VA_ARGS__), var)); \\",
          "707:     } while (0)",
          "709: #define uvlc(name, range_min, range_max) do { \\",
          "710:         CHECK(cbs_av1_write_uvlc(ctx, rw, #name, current->name, \\",
          "711:                                  range_min, range_max)); \\",
          "712:     } while (0)",
          "714: #define ns(max_value, name, subs, ...) do { \\",
          "715:         CHECK(cbs_av1_write_ns(ctx, rw, max_value, #name, \\",
          "716:                                SUBSCRIPTS(subs, __VA_ARGS__), \\",
          "717:                                current->name)); \\",
          "718:     } while (0)",
          "720: #define increment(name, min, max) do { \\",
          "721:         CHECK(cbs_av1_write_increment(ctx, rw, min, max, #name, \\",
          "722:                                       current->name)); \\",
          "723:     } while (0)",
          "725: #define subexp(name, max, subs, ...) do { \\",
          "726:         CHECK(cbs_av1_write_subexp(ctx, rw, max, #name, \\",
          "727:                                    SUBSCRIPTS(subs, __VA_ARGS__), \\",
          "728:                                    current->name)); \\",
          "729:     } while (0)",
          "731: #define delta_q(name) do { \\",
          "732:         xf(1, name.delta_coded, current->name != 0, 0, 1, 0); \\",
          "733:         if (current->name) \\",
          "734:             xsu(1 + 6, name.delta_q, current->name, 0); \\",
          "735:     } while (0)",
          "737: #define leb128(name) do { \\",
          "738:         CHECK(cbs_av1_write_leb128(ctx, rw, #name, current->name)); \\",
          "739:     } while (0)",
          "741: #define infer(name, value) do { \\",
          "742:         if (current->name != (value)) { \\",
          "743:             av_log(ctx->log_ctx, AV_LOG_WARNING, \"Warning: \" \\",
          "744:                    \"%s does not match inferred value: \" \\",
          "745:                    \"%\"PRId64\", but should be %\"PRId64\".\\n\", \\",
          "746:                    #name, (int64_t)current->name, (int64_t)(value)); \\",
          "747:         } \\",
          "748:     } while (0)",
          "750: #define byte_alignment(rw) (put_bits_count(rw) % 8)",
          "752: #include \"cbs_av1_syntax_template.c\"",
          "754: #undef READ",
          "755: #undef READWRITE",
          "756: #undef RWContext",
          "757: #undef xf",
          "758: #undef xsu",
          "759: #undef uvlc",
          "760: #undef leb128",
          "761: #undef ns",
          "762: #undef increment",
          "763: #undef subexp",
          "764: #undef delta_q",
          "765: #undef infer",
          "766: #undef byte_alignment",
          "769: static int cbs_av1_split_fragment(CodedBitstreamContext *ctx,",
          "770:                                   CodedBitstreamFragment *frag,",
          "771:                                   int header)",
          "772: {",
          "773:     GetBitContext gbc;",
          "774:     uint8_t *data;",
          "775:     size_t size;",
          "776:     uint64_t obu_length;",
          "777:     int pos, err, trace;",
          "780:     trace = ctx->trace_enable;",
          "781:     ctx->trace_enable = 0;",
          "783:     data = frag->data;",
          "784:     size = frag->data_size;",
          "786:     if (INT_MAX / 8 < size) {",
          "787:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid fragment: \"",
          "788:                \"too large (%zu bytes).\\n\", size);",
          "789:         err = AVERROR_INVALIDDATA;",
          "790:         goto fail;",
          "791:     }",
          "793:     while (size > 0) {",
          "794:         AV1RawOBUHeader header;",
          "795:         uint64_t obu_size;",
          "797:         init_get_bits(&gbc, data, 8 * size);",
          "799:         err = cbs_av1_read_obu_header(ctx, &gbc, &header);",
          "800:         if (err < 0)",
          "801:             goto fail;",
          "803:         if (!header.obu_has_size_field) {",
          "804:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU for raw \"",
          "805:                    \"stream: size field must be present.\\n\");",
          "806:             err = AVERROR_INVALIDDATA;",
          "807:             goto fail;",
          "808:         }",
          "810:         if (get_bits_left(&gbc) < 8) {",
          "811:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU: fragment \"",
          "812:                    \"too short (%zu bytes).\\n\", size);",
          "813:             err = AVERROR_INVALIDDATA;",
          "814:             goto fail;",
          "815:         }",
          "817:         err = cbs_av1_read_leb128(ctx, &gbc, \"obu_size\", &obu_size);",
          "818:         if (err < 0)",
          "819:             goto fail;",
          "821:         pos = get_bits_count(&gbc);",
          "822:         av_assert0(pos % 8 == 0 && pos / 8 <= size);",
          "824:         obu_length = pos / 8 + obu_size;",
          "826:         if (size < obu_length) {",
          "827:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU length: \"",
          "828:                    \"%\"PRIu64\", but only %zu bytes remaining in fragment.\\n\",",
          "829:                    obu_length, size);",
          "830:             err = AVERROR_INVALIDDATA;",
          "831:             goto fail;",
          "832:         }",
          "834:         err = ff_cbs_insert_unit_data(ctx, frag, -1, header.obu_type,",
          "835:                                       data, obu_length, frag->data_ref);",
          "836:         if (err < 0)",
          "837:             goto fail;",
          "839:         data += obu_length;",
          "840:         size -= obu_length;",
          "841:     }",
          "843:     err = 0;",
          "844: fail:",
          "845:     ctx->trace_enable = trace;",
          "846:     return err;",
          "847: }",
          "849: static void cbs_av1_free_tile_data(AV1RawTileData *td)",
          "850: {",
          "851:     av_buffer_unref(&td->data_ref);",
          "852: }",
          "854: static void cbs_av1_free_metadata(AV1RawMetadata *md)",
          "855: {",
          "856:     switch (md->metadata_type) {",
          "857:     case AV1_METADATA_TYPE_ITUT_T35:",
          "858:         av_buffer_unref(&md->metadata.itut_t35.payload_ref);",
          "859:         break;",
          "860:     }",
          "861: }",
          "863: static void cbs_av1_free_obu(void *unit, uint8_t *content)",
          "864: {",
          "865:     AV1RawOBU *obu = (AV1RawOBU*)content;",
          "867:     switch (obu->header.obu_type) {",
          "868:     case AV1_OBU_TILE_GROUP:",
          "869:         cbs_av1_free_tile_data(&obu->obu.tile_group.tile_data);",
          "870:         break;",
          "871:     case AV1_OBU_FRAME:",
          "872:         cbs_av1_free_tile_data(&obu->obu.frame.tile_group.tile_data);",
          "873:         break;",
          "874:     case AV1_OBU_TILE_LIST:",
          "875:         cbs_av1_free_tile_data(&obu->obu.tile_list.tile_data);",
          "876:         break;",
          "877:     case AV1_OBU_METADATA:",
          "878:         cbs_av1_free_metadata(&obu->obu.metadata);",
          "879:         break;",
          "880:     }",
          "882:     av_freep(&obu);",
          "883: }",
          "885: static int cbs_av1_ref_tile_data(CodedBitstreamContext *ctx,",
          "886:                                  CodedBitstreamUnit *unit,",
          "887:                                  GetBitContext *gbc,",
          "888:                                  AV1RawTileData *td)",
          "889: {",
          "890:     int pos;",
          "892:     pos = get_bits_count(gbc);",
          "893:     if (pos >= 8 * unit->data_size) {",
          "894:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"Bitstream ended before \"",
          "895:                \"any data in tile group (%d bits read).\\n\", pos);",
          "896:         return AVERROR_INVALIDDATA;",
          "897:     }",
          "899:     av_assert0(pos % 8 == 0);",
          "901:     td->data_ref = av_buffer_ref(unit->data_ref);",
          "902:     if (!td->data_ref)",
          "903:         return AVERROR(ENOMEM);",
          "905:     td->data      = unit->data      + pos / 8;",
          "906:     td->data_size = unit->data_size - pos / 8;",
          "908:     return 0;",
          "909: }",
          "911: static int cbs_av1_read_unit(CodedBitstreamContext *ctx,",
          "912:                              CodedBitstreamUnit *unit)",
          "913: {",
          "914:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "915:     AV1RawOBU *obu;",
          "916:     GetBitContext gbc;",
          "917:     int err, start_pos, end_pos;",
          "919:     err = ff_cbs_alloc_unit_content(ctx, unit, sizeof(*obu),",
          "920:                                     &cbs_av1_free_obu);",
          "921:     if (err < 0)",
          "922:         return err;",
          "923:     obu = unit->content;",
          "925:     err = init_get_bits(&gbc, unit->data, 8 * unit->data_size);",
          "926:     if (err < 0)",
          "927:         return err;",
          "929:     err = cbs_av1_read_obu_header(ctx, &gbc, &obu->header);",
          "930:     if (err < 0)",
          "931:         return err;",
          "932:     av_assert0(obu->header.obu_type == unit->type);",
          "934:     if (obu->header.obu_has_size_field) {",
          "935:         uint64_t obu_size;",
          "936:         err = cbs_av1_read_leb128(ctx, &gbc, \"obu_size\", &obu_size);",
          "937:         if (err < 0)",
          "938:             return err;",
          "939:         obu->obu_size = obu_size;",
          "940:     } else {",
          "941:         if (unit->data_size < 1 + obu->header.obu_extension_flag) {",
          "942:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU length: \"",
          "943:                    \"unit too short (%zu).\\n\", unit->data_size);",
          "944:             return AVERROR_INVALIDDATA;",
          "945:         }",
          "946:         obu->obu_size = unit->data_size - 1 - obu->header.obu_extension_flag;",
          "947:     }",
          "949:     start_pos = get_bits_count(&gbc);",
          "951:     if (obu->header.obu_extension_flag) {",
          "952:         priv->temporal_id = obu->header.temporal_id;",
          "953:         priv->spatial_id  = obu->header.temporal_id;",
          "955:         if (obu->header.obu_type != AV1_OBU_SEQUENCE_HEADER &&",
          "956:             obu->header.obu_type != AV1_OBU_TEMPORAL_DELIMITER &&",
          "957:             priv->operating_point_idc) {",
          "958:             int in_temporal_layer =",
          "959:                 (priv->operating_point_idc >>  priv->temporal_id    ) & 1;",
          "960:             int in_spatial_layer  =",
          "961:                 (priv->operating_point_idc >> (priv->spatial_id + 8)) & 1;",
          "962:             if (!in_temporal_layer || !in_spatial_layer) {",
          "964:             }",
          "965:         }",
          "966:     } else {",
          "967:         priv->temporal_id = 0;",
          "968:         priv->spatial_id  = 0;",
          "969:     }",
          "971:     switch (obu->header.obu_type) {",
          "972:     case AV1_OBU_SEQUENCE_HEADER:",
          "973:         {",
          "974:             err = cbs_av1_read_sequence_header_obu(ctx, &gbc,",
          "975:                                                    &obu->obu.sequence_header);",
          "976:             if (err < 0)",
          "977:                 return err;",
          "979:             av_buffer_unref(&priv->sequence_header_ref);",
          "980:             priv->sequence_header = NULL;",
          "982:             priv->sequence_header_ref = av_buffer_ref(unit->content_ref);",
          "983:             if (!priv->sequence_header_ref)",
          "984:                 return AVERROR(ENOMEM);",
          "985:             priv->sequence_header = &obu->obu.sequence_header;",
          "986:         }",
          "987:         break;",
          "988:     case AV1_OBU_TEMPORAL_DELIMITER:",
          "989:         {",
          "990:             err = cbs_av1_read_temporal_delimiter_obu(ctx, &gbc);",
          "991:             if (err < 0)",
          "992:                 return err;",
          "993:         }",
          "994:         break;",
          "995:     case AV1_OBU_FRAME_HEADER:",
          "996:     case AV1_OBU_REDUNDANT_FRAME_HEADER:",
          "997:         {",
          "998:             err = cbs_av1_read_frame_header_obu(ctx, &gbc,",
          "999:                                                 &obu->obu.frame_header);",
          "1000:             if (err < 0)",
          "1001:                 return err;",
          "1002:         }",
          "1003:         break;",
          "1004:     case AV1_OBU_TILE_GROUP:",
          "1005:         {",
          "1006:             err = cbs_av1_read_tile_group_obu(ctx, &gbc,",
          "1007:                                               &obu->obu.tile_group);",
          "1008:             if (err < 0)",
          "1009:                 return err;",
          "1011:             err = cbs_av1_ref_tile_data(ctx, unit, &gbc,",
          "1012:                                         &obu->obu.tile_group.tile_data);",
          "1013:             if (err < 0)",
          "1014:                 return err;",
          "1015:         }",
          "1016:         break;",
          "1017:     case AV1_OBU_FRAME:",
          "1018:         {",
          "1019:             err = cbs_av1_read_frame_obu(ctx, &gbc, &obu->obu.frame);",
          "1020:             if (err < 0)",
          "1021:                 return err;",
          "1023:             err = cbs_av1_ref_tile_data(ctx, unit, &gbc,",
          "1024:                                         &obu->obu.frame.tile_group.tile_data);",
          "1025:             if (err < 0)",
          "1026:                 return err;",
          "1027:         }",
          "1028:         break;",
          "1029:     case AV1_OBU_TILE_LIST:",
          "1030:         {",
          "1031:             err = cbs_av1_read_tile_list_obu(ctx, &gbc,",
          "1032:                                              &obu->obu.tile_list);",
          "1033:             if (err < 0)",
          "1034:                 return err;",
          "1036:             err = cbs_av1_ref_tile_data(ctx, unit, &gbc,",
          "1037:                                         &obu->obu.tile_list.tile_data);",
          "1038:             if (err < 0)",
          "1039:                 return err;",
          "1040:         }",
          "1041:         break;",
          "1042:     case AV1_OBU_METADATA:",
          "1043:         {",
          "1044:             err = cbs_av1_read_metadata_obu(ctx, &gbc, &obu->obu.metadata);",
          "1045:             if (err < 0)",
          "1046:                 return err;",
          "1047:         }",
          "1048:         break;",
          "1049:     case AV1_OBU_PADDING:",
          "1050:     default:",
          "1051:         return AVERROR(ENOSYS);",
          "1052:     }",
          "1054:     end_pos = get_bits_count(&gbc);",
          "1055:     av_assert0(end_pos <= unit->data_size * 8);",
          "1057:     if (obu->obu_size > 0 &&",
          "1058:         obu->header.obu_type != AV1_OBU_TILE_GROUP &&",
          "1059:         obu->header.obu_type != AV1_OBU_FRAME) {",
          "1060:         err = cbs_av1_read_trailing_bits(ctx, &gbc,",
          "1061:                                          obu->obu_size * 8 + start_pos - end_pos);",
          "1062:         if (err < 0)",
          "1063:             return err;",
          "1064:     }",
          "1066:     return 0;",
          "1067: }",
          "1069: static int cbs_av1_write_obu(CodedBitstreamContext *ctx,",
          "1070:                              CodedBitstreamUnit *unit,",
          "1071:                              PutBitContext *pbc)",
          "1072: {",
          "1073:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "1074:     AV1RawOBU *obu = unit->content;",
          "1075:     PutBitContext pbc_tmp;",
          "1076:     AV1RawTileData *td;",
          "1077:     size_t header_size;",
          "1078:     int err, start_pos, end_pos, data_pos;",
          "1083:     obu->header.obu_has_size_field = 1;",
          "1085:     err = cbs_av1_write_obu_header(ctx, pbc, &obu->header);",
          "1086:     if (err < 0)",
          "1087:         return err;",
          "1089:     if (obu->header.obu_has_size_field) {",
          "1090:         pbc_tmp = *pbc;",
          "1092:         put_bits32(pbc, 0);",
          "1093:         put_bits32(pbc, 0);",
          "1094:     }",
          "1096:     td = NULL;",
          "1097:     start_pos = put_bits_count(pbc);",
          "1099:     switch (obu->header.obu_type) {",
          "1100:     case AV1_OBU_SEQUENCE_HEADER:",
          "1101:         {",
          "1102:             err = cbs_av1_write_sequence_header_obu(ctx, pbc,",
          "1103:                                                     &obu->obu.sequence_header);",
          "1104:             if (err < 0)",
          "1105:                 return err;",
          "1107:             av_buffer_unref(&priv->sequence_header_ref);",
          "1108:             priv->sequence_header = NULL;",
          "1110:             priv->sequence_header_ref = av_buffer_ref(unit->content_ref);",
          "1111:             if (!priv->sequence_header_ref)",
          "1112:                 return AVERROR(ENOMEM);",
          "1113:             priv->sequence_header = &obu->obu.sequence_header;",
          "1114:         }",
          "1115:         break;",
          "1116:     case AV1_OBU_TEMPORAL_DELIMITER:",
          "1117:         {",
          "1118:             err = cbs_av1_write_temporal_delimiter_obu(ctx, pbc);",
          "1119:             if (err < 0)",
          "1120:                 return err;",
          "1121:         }",
          "1122:         break;",
          "1123:     case AV1_OBU_FRAME_HEADER:",
          "1124:     case AV1_OBU_REDUNDANT_FRAME_HEADER:",
          "1125:         {",
          "1126:             err = cbs_av1_write_frame_header_obu(ctx, pbc,",
          "1127:                                                  &obu->obu.frame_header);",
          "1128:             if (err < 0)",
          "1129:                 return err;",
          "1130:         }",
          "1131:         break;",
          "1132:     case AV1_OBU_TILE_GROUP:",
          "1133:         {",
          "1134:             err = cbs_av1_write_tile_group_obu(ctx, pbc,",
          "1135:                                                &obu->obu.tile_group);",
          "1136:             if (err < 0)",
          "1137:                 return err;",
          "1139:             td = &obu->obu.tile_group.tile_data;",
          "1140:         }",
          "1141:         break;",
          "1142:     case AV1_OBU_FRAME:",
          "1143:         {",
          "1144:             err = cbs_av1_write_frame_obu(ctx, pbc, &obu->obu.frame);",
          "1145:             if (err < 0)",
          "1146:                 return err;",
          "1148:             td = &obu->obu.frame.tile_group.tile_data;",
          "1149:         }",
          "1150:         break;",
          "1151:     case AV1_OBU_TILE_LIST:",
          "1152:         {",
          "1153:             err = cbs_av1_write_tile_list_obu(ctx, pbc, &obu->obu.tile_list);",
          "1154:             if (err < 0)",
          "1155:                 return err;",
          "1157:             td = &obu->obu.tile_list.tile_data;",
          "1158:         }",
          "1159:         break;",
          "1160:     case AV1_OBU_METADATA:",
          "1161:         {",
          "1162:             err = cbs_av1_write_metadata_obu(ctx, pbc, &obu->obu.metadata);",
          "1163:             if (err < 0)",
          "1164:                 return err;",
          "1165:         }",
          "1166:         break;",
          "1167:     case AV1_OBU_PADDING:",
          "1168:     default:",
          "1169:         return AVERROR(ENOSYS);",
          "1170:     }",
          "1172:     end_pos = put_bits_count(pbc);",
          "1173:     header_size = (end_pos - start_pos + 7) / 8;",
          "1174:     if (td) {",
          "1175:         obu->obu_size = header_size + td->data_size;",
          "1176:     } else if (header_size > 0) {",
          "1178:         err = cbs_av1_write_trailing_bits(ctx, pbc, 8 - end_pos % 8);",
          "1179:         if (err < 0)",
          "1180:             return err;",
          "1181:         end_pos = put_bits_count(pbc);",
          "1182:         obu->obu_size = (end_pos - start_pos + 7) / 8;",
          "1183:     } else {",
          "1185:         obu->obu_size = 0;",
          "1186:     }",
          "1188:     end_pos = put_bits_count(pbc);",
          "1190:     av_assert0(end_pos % 8 == 0);",
          "1191:     flush_put_bits(pbc);",
          "1192:     start_pos /= 8;",
          "1193:     end_pos   /= 8;",
          "1196:     err = cbs_av1_write_leb128(ctx, pbc, \"obu_size\", obu->obu_size);",
          "1197:     if (err < 0)",
          "1198:         return err;",
          "1200:     data_pos = put_bits_count(pbc) / 8;",
          "1201:     flush_put_bits(pbc);",
          "1202:     av_assert0(data_pos <= start_pos);",
          "1204:     if (8 * obu->obu_size > put_bits_left(pbc))",
          "1205:         return AVERROR(ENOSPC);",
          "1207:     if (obu->obu_size > 0) {",
          "1208:         memmove(priv->write_buffer + data_pos,",
          "1209:                 priv->write_buffer + start_pos, header_size);",
          "1210:         skip_put_bytes(pbc, header_size);",
          "1212:         if (td) {",
          "1213:             memcpy(priv->write_buffer + data_pos + header_size,",
          "1214:                    td->data, td->data_size);",
          "1215:             skip_put_bytes(pbc, td->data_size);",
          "1216:         }",
          "1217:     }",
          "1219:     return 0;",
          "1220: }",
          "1222: static int cbs_av1_write_unit(CodedBitstreamContext *ctx,",
          "1223:                               CodedBitstreamUnit *unit)",
          "1224: {",
          "1225:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "1226:     PutBitContext pbc;",
          "1227:     int err;",
          "1229:     if (!priv->write_buffer) {",
          "1231:         priv->write_buffer_size = 1024 * 1024;",
          "1233:     reallocate_and_try_again:",
          "1234:         err = av_reallocp(&priv->write_buffer, priv->write_buffer_size);",
          "1235:         if (err < 0) {",
          "1236:             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Unable to allocate a \"",
          "1237:                    \"sufficiently large write buffer (last attempt \"",
          "1238:                    \"%zu bytes).\\n\", priv->write_buffer_size);",
          "1239:             return err;",
          "1240:         }",
          "1241:     }",
          "1243:     init_put_bits(&pbc, priv->write_buffer, priv->write_buffer_size);",
          "1245:     err = cbs_av1_write_obu(ctx, unit, &pbc);",
          "1246:     if (err == AVERROR(ENOSPC)) {",
          "1248:         priv->write_buffer_size *= 2;",
          "1249:         goto reallocate_and_try_again;",
          "1250:     }",
          "1251:     if (err < 0)",
          "1252:         return err;",
          "1255:     av_assert0(put_bits_count(&pbc) <= 8 * priv->write_buffer_size);",
          "1258:     av_assert0(put_bits_count(&pbc) % 8 == 0);",
          "1260:     unit->data_size = put_bits_count(&pbc) / 8;",
          "1261:     flush_put_bits(&pbc);",
          "1263:     err = ff_cbs_alloc_unit_data(ctx, unit, unit->data_size);",
          "1264:     if (err < 0)",
          "1265:         return err;",
          "1267:     memcpy(unit->data, priv->write_buffer, unit->data_size);",
          "1269:     return 0;",
          "1270: }",
          "1272: static int cbs_av1_assemble_fragment(CodedBitstreamContext *ctx,",
          "1273:                                      CodedBitstreamFragment *frag)",
          "1274: {",
          "1275:     size_t size, pos;",
          "1276:     int i;",
          "1278:     size = 0;",
          "1279:     for (i = 0; i < frag->nb_units; i++)",
          "1280:         size += frag->units[i].data_size;",
          "1282:     frag->data_ref = av_buffer_alloc(size + AV_INPUT_BUFFER_PADDING_SIZE);",
          "1283:     if (!frag->data_ref)",
          "1284:         return AVERROR(ENOMEM);",
          "1285:     frag->data = frag->data_ref->data;",
          "1286:     memset(frag->data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "1288:     pos = 0;",
          "1289:     for (i = 0; i < frag->nb_units; i++) {",
          "1290:         memcpy(frag->data + pos, frag->units[i].data,",
          "1291:                frag->units[i].data_size);",
          "1292:         pos += frag->units[i].data_size;",
          "1293:     }",
          "1294:     av_assert0(pos == size);",
          "1295:     frag->data_size = size;",
          "1297:     return 0;",
          "1298: }",
          "1300: static void cbs_av1_close(CodedBitstreamContext *ctx)",
          "1301: {",
          "1302:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "1304:     av_buffer_unref(&priv->sequence_header_ref);",
          "1306:     av_freep(&priv->write_buffer);",
          "1307: }",
          "1309: const CodedBitstreamType ff_cbs_type_av1 = {",
          "1310:     .codec_id          = AV_CODEC_ID_AV1,",
          "1312:     .priv_data_size    = sizeof(CodedBitstreamAV1Context),",
          "1314:     .split_fragment    = &cbs_av1_split_fragment,",
          "1315:     .read_unit         = &cbs_av1_read_unit,",
          "1316:     .write_unit        = &cbs_av1_write_unit,",
          "1317:     .assemble_fragment = &cbs_av1_assemble_fragment,",
          "1319:     .close             = &cbs_av1_close,",
          "1320: };",
          "",
          "---------------"
        ],
        "libavcodec/cbs_av1.h||libavcodec/cbs_av1.h": [
          "File: libavcodec/cbs_av1.h -> libavcodec/cbs_av1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #ifndef AVCODEC_CBS_AV1_H",
          "20: #define AVCODEC_CBS_AV1_H",
          "22: #include <stddef.h>",
          "23: #include <stdint.h>",
          "25: #include \"av1.h\"",
          "26: #include \"cbs.h\"",
          "29: typedef struct AV1RawOBUHeader {",
          "30:     uint8_t obu_forbidden_bit;",
          "31:     uint8_t obu_type;",
          "32:     uint8_t obu_extension_flag;",
          "33:     uint8_t obu_has_size_field;",
          "34:     uint8_t obu_reserved_1bit;",
          "36:     uint8_t temporal_id;",
          "37:     uint8_t spatial_id;",
          "38:     uint8_t extension_header_reserved_3bits;",
          "39: } AV1RawOBUHeader;",
          "41: typedef struct AV1RawColorConfig {",
          "42:     uint8_t high_bitdepth;",
          "43:     uint8_t twelve_bit;",
          "44:     uint8_t mono_chrome;",
          "46:     uint8_t color_description_present_flag;",
          "47:     uint8_t color_primaries;",
          "48:     uint8_t transfer_characteristics;",
          "49:     uint8_t matrix_coefficients;",
          "51:     uint8_t color_range;",
          "52:     uint8_t subsampling_x;",
          "53:     uint8_t subsampling_y;",
          "54:     uint8_t chroma_sample_position;",
          "55:     uint8_t separate_uv_delta_q;",
          "56: } AV1RawColorConfig;",
          "58: typedef struct AV1RawTimingInfo {",
          "59:     uint32_t num_units_in_display_tick;",
          "60:     uint32_t time_scale;",
          "62:     uint8_t equal_picture_interval;",
          "63:     uint32_t num_ticks_per_picture_minus_1;",
          "64: } AV1RawTimingInfo;",
          "66: typedef struct AV1RawDecoderModelInfo {",
          "67:     uint8_t  buffer_delay_length_minus_1;",
          "68:     uint32_t num_units_in_decoding_tick;",
          "69:     uint8_t  buffer_removal_time_length_minus_1;",
          "70:     uint8_t  frame_presentation_time_length_minus_1;",
          "71: } AV1RawDecoderModelInfo;",
          "73: typedef struct AV1RawSequenceHeader {",
          "74:     uint8_t seq_profile;",
          "75:     uint8_t still_picture;",
          "76:     uint8_t reduced_still_picture_header;",
          "78:     uint8_t timing_info_present_flag;",
          "79:     uint8_t decoder_model_info_present_flag;",
          "80:     uint8_t initial_display_delay_present_flag;",
          "81:     uint8_t operating_points_cnt_minus_1;",
          "83:     AV1RawTimingInfo       timing_info;",
          "84:     AV1RawDecoderModelInfo decoder_model_info;",
          "86:     uint16_t operating_point_idc[AV1_MAX_OPERATING_POINTS];",
          "87:     uint8_t  seq_level_idx[AV1_MAX_OPERATING_POINTS];",
          "88:     uint8_t  seq_tier[AV1_MAX_OPERATING_POINTS];",
          "89:     uint8_t  decoder_model_present_for_this_op[AV1_MAX_OPERATING_POINTS];",
          "90:     uint8_t  decoder_buffer_delay[AV1_MAX_OPERATING_POINTS];",
          "91:     uint8_t  encoder_buffer_delay[AV1_MAX_OPERATING_POINTS];",
          "92:     uint8_t  low_delay_mode_flag[AV1_MAX_OPERATING_POINTS];",
          "93:     uint8_t  initial_display_delay_present_for_this_op[AV1_MAX_OPERATING_POINTS];",
          "94:     uint8_t  initial_display_delay_minus_1[AV1_MAX_OPERATING_POINTS];",
          "96:     uint8_t  frame_width_bits_minus_1;",
          "97:     uint8_t  frame_height_bits_minus_1;",
          "98:     uint16_t max_frame_width_minus_1;",
          "99:     uint16_t max_frame_height_minus_1;",
          "101:     uint8_t frame_id_numbers_present_flag;",
          "102:     uint8_t delta_frame_id_length_minus_2;",
          "103:     uint8_t additional_frame_id_length_minus_1;",
          "105:     uint8_t use_128x128_superblock;",
          "106:     uint8_t enable_filter_intra;",
          "107:     uint8_t enable_intra_edge_filter;",
          "108:     uint8_t enable_intraintra_compound;",
          "109:     uint8_t enable_masked_compound;",
          "110:     uint8_t enable_warped_motion;",
          "111:     uint8_t enable_dual_filter;",
          "113:     uint8_t enable_order_hint;",
          "114:     uint8_t enable_jnt_comp;",
          "115:     uint8_t enable_ref_frame_mvs;",
          "117:     uint8_t seq_choose_screen_content_tools;",
          "118:     uint8_t seq_force_screen_content_tools;",
          "119:     uint8_t seq_choose_integer_mv;",
          "120:     uint8_t seq_force_integer_mv;",
          "122:     uint8_t order_hint_bits_minus_1;",
          "124:     uint8_t enable_superres;",
          "125:     uint8_t enable_cdef;",
          "126:     uint8_t enable_restoration;",
          "128:     AV1RawColorConfig color_config;",
          "130:     uint8_t film_grain_params_present;",
          "131: } AV1RawSequenceHeader;",
          "133: typedef struct AV1RawFrameHeader {",
          "134:     uint8_t  show_existing_frame;",
          "135:     uint8_t  frame_to_show_map_idx;",
          "136:     uint32_t frame_presentation_time;",
          "137:     uint32_t display_frame_id;",
          "139:     uint8_t frame_type;",
          "140:     uint8_t show_frame;",
          "141:     uint8_t showable_frame;",
          "143:     uint8_t error_resilient_mode;",
          "144:     uint8_t disable_cdf_update;",
          "145:     uint8_t allow_screen_content_tools;",
          "146:     uint8_t force_integer_mv;",
          "148:     uint32_t current_frame_id;",
          "149:     uint8_t  frame_size_override_flag;",
          "150:     uint8_t  order_hint;",
          "152:     uint8_t  buffer_removal_time_present_flag;",
          "153:     uint32_t buffer_removal_time[AV1_MAX_OPERATING_POINTS];",
          "155:     uint8_t  primary_ref_frame;",
          "156:     uint16_t frame_width_minus_1;",
          "157:     uint16_t frame_height_minus_1;",
          "158:     uint8_t  use_superres;",
          "159:     uint8_t  coded_denom;",
          "160:     uint8_t  render_and_frame_size_different;",
          "161:     uint8_t  render_width_minus_1;",
          "162:     uint8_t  render_height_minus_1;",
          "164:     uint8_t found_ref;",
          "166:     uint8_t refresh_frame_flags;",
          "167:     uint8_t allow_intrabc;",
          "168:     uint8_t ref_order_hint[AV1_NUM_REF_FRAMES];",
          "169:     uint8_t frame_refs_short_signaling;",
          "170:     uint8_t last_frame_idx;",
          "171:     uint8_t golden_frame_idx;",
          "172:     int8_t  ref_frame_idx[AV1_REFS_PER_FRAME];",
          "173:     uint8_t delta_frame_id_minus1;",
          "175:     uint8_t allow_high_precision_mv;",
          "176:     uint8_t is_filter_switchable;",
          "177:     uint8_t interpolation_filter;",
          "178:     uint8_t is_motion_mode_switchable;",
          "179:     uint8_t use_ref_frame_mvs;",
          "181:     uint8_t disable_frame_end_update_cdf;",
          "183:     uint8_t uniform_tile_spacing_flag;",
          "184:     uint8_t tile_cols_log2;",
          "185:     uint8_t tile_rows_log2;",
          "186:     uint8_t width_in_sbs_minus_1[AV1_MAX_TILE_COLS];",
          "187:     uint8_t height_in_sbs_minus_1[AV1_MAX_TILE_ROWS];",
          "188:     uint16_t context_update_tile_id;",
          "189:     uint8_t tile_size_bytes_minus1;",
          "193:     uint16_t tile_cols;",
          "194:     uint16_t tile_rows;",
          "196:     uint8_t base_q_idx;",
          "197:     int8_t  delta_q_y_dc;",
          "198:     uint8_t diff_uv_delta;",
          "199:     int8_t  delta_q_u_dc;",
          "200:     int8_t  delta_q_u_ac;",
          "201:     int8_t  delta_q_v_dc;",
          "202:     int8_t  delta_q_v_ac;",
          "203:     uint8_t using_qmatrix;",
          "204:     uint8_t qm_y;",
          "205:     uint8_t qm_u;",
          "206:     uint8_t qm_v;",
          "208:     uint8_t segmentation_enabled;",
          "209:     uint8_t segmentation_update_map;",
          "210:     uint8_t segmentation_temporal_update;",
          "211:     uint8_t segmentation_update_data;",
          "212:     uint8_t feature_enabled[AV1_MAX_SEGMENTS][AV1_SEG_LVL_MAX];",
          "213:     uint8_t feature_value[AV1_MAX_SEGMENTS][AV1_SEG_LVL_MAX];",
          "215:     uint8_t delta_q_present;",
          "216:     uint8_t delta_q_res;",
          "217:     uint8_t delta_lf_present;",
          "218:     uint8_t delta_lf_res;",
          "219:     uint8_t delta_lf_multi;",
          "221:     uint8_t loop_filter_level[4];",
          "222:     uint8_t loop_filter_sharpness;",
          "223:     uint8_t loop_filter_delta_enabled;",
          "224:     uint8_t loop_filter_delta_update;",
          "225:     uint8_t update_ref_delta[AV1_TOTAL_REFS_PER_FRAME];",
          "226:     int8_t  loop_filter_ref_deltas[AV1_TOTAL_REFS_PER_FRAME];",
          "227:     uint8_t update_mode_delta[2];",
          "228:     int8_t  loop_filter_mode_deltas[2];",
          "230:     uint8_t cdef_damping_minus_3;",
          "231:     uint8_t cdef_bits;",
          "232:     uint8_t cdef_y_pri_strength[8];",
          "233:     uint8_t cdef_y_sec_strength[8];",
          "234:     uint8_t cdef_uv_pri_strength[8];",
          "235:     uint8_t cdef_uv_sec_strength[8];",
          "237:     uint8_t lr_type[3];",
          "238:     uint8_t lr_unit_shift;",
          "239:     uint8_t lr_uv_shift;",
          "241:     uint8_t tx_mode;",
          "242:     uint8_t reference_select;",
          "243:     uint8_t skip_mode_present;",
          "245:     uint8_t allow_warped_motion;",
          "246:     uint8_t reduced_tx_set;",
          "248:     uint8_t is_global[AV1_TOTAL_REFS_PER_FRAME];",
          "249:     uint8_t is_rot_zoom[AV1_TOTAL_REFS_PER_FRAME];",
          "250:     uint8_t is_translation[AV1_TOTAL_REFS_PER_FRAME];",
          "252:     uint32_t gm_params[AV1_TOTAL_REFS_PER_FRAME][6];",
          "254:     uint8_t  apply_grain;",
          "255:     uint16_t grain_seed;",
          "256:     uint8_t  update_grain;",
          "257:     uint8_t  film_grain_params_ref_idx;",
          "258:     uint8_t  num_y_points;",
          "259:     uint8_t  point_y_value[16];",
          "260:     uint8_t  point_y_scaling[16];",
          "261:     uint8_t  chroma_scaling_from_luma;",
          "262:     uint8_t  num_cb_points;",
          "263:     uint8_t  point_cb_value[16];",
          "264:     uint8_t  point_cb_scaling[16];",
          "265:     uint8_t  num_cr_points;",
          "266:     uint8_t  point_cr_value[16];",
          "267:     uint8_t  point_cr_scaling[16];",
          "268:     uint8_t  grain_scaling_minus_8;",
          "269:     uint8_t  ar_coeff_lag;",
          "270:     uint8_t  ar_coeffs_y_plus_128[24];",
          "271:     uint8_t  ar_coeffs_cb_plus_128[24];",
          "272:     uint8_t  ar_coeffs_cr_plus_128[24];",
          "273:     uint8_t  ar_coeff_shift_minus_6;",
          "274:     uint8_t  grain_scale_shift;",
          "275:     uint8_t  cb_mult;",
          "276:     uint8_t  cb_luma_mult;",
          "277:     uint16_t cb_offset;",
          "278:     uint8_t  cr_mult;",
          "279:     uint8_t  cr_luma_mult;",
          "280:     uint16_t cr_offset;",
          "281:     uint8_t  overlap_flag;",
          "282:     uint8_t  clip_to_restricted_range;",
          "283: } AV1RawFrameHeader;",
          "285: typedef struct AV1RawTileData {",
          "286:     uint8_t     *data;",
          "287:     size_t       data_size;",
          "288:     AVBufferRef *data_ref;",
          "289: } AV1RawTileData;",
          "291: typedef struct AV1RawTileGroup {",
          "292:     uint8_t  tile_start_and_end_present_flag;",
          "293:     uint16_t tg_start;",
          "294:     uint16_t tg_end;",
          "296:     AV1RawTileData tile_data;",
          "297: } AV1RawTileGroup;",
          "299: typedef struct AV1RawFrame {",
          "300:     AV1RawFrameHeader header;",
          "301:     AV1RawTileGroup   tile_group;",
          "302: } AV1RawFrame;",
          "304: typedef struct AV1RawTileList {",
          "305:     uint8_t output_frame_width_in_tiles_minus_1;",
          "306:     uint8_t output_frame_height_in_tiles_minus_1;",
          "307:     uint16_t tile_count_minus_1;",
          "309:     AV1RawTileData tile_data;",
          "310: } AV1RawTileList;",
          "312: typedef struct AV1RawMetadataHDRCLL {",
          "313:     uint16_t max_cll;",
          "314:     uint16_t max_fall;",
          "315: } AV1RawMetadataHDRCLL;",
          "317: typedef struct AV1RawMetadataHDRMDCV {",
          "318:     uint16_t primary_chromaticity_x[3];",
          "319:     uint16_t primary_chromaticity_y[3];",
          "320:     uint16_t white_point_chromaticity_x;",
          "321:     uint16_t white_point_chromaticity_y;",
          "322:     uint32_t luminance_max;",
          "323:     uint32_t luminance_min;",
          "324: } AV1RawMetadataHDRMDCV;",
          "326: typedef struct AV1RawMetadataScalability {",
          "327:     uint8_t scalability_mode_idc;",
          "329: } AV1RawMetadataScalability;",
          "331: typedef struct AV1RawMetadataITUTT35 {",
          "332:     uint8_t itu_t_t35_country_code;",
          "333:     uint8_t itu_t_t35_country_code_extension_byte;",
          "335:     uint8_t     *payload;",
          "336:     size_t       payload_size;",
          "337:     AVBufferRef *payload_ref;",
          "338: } AV1RawMetadataITUTT35;",
          "340: typedef struct AV1RawMetadataTimecode {",
          "341:     uint8_t  counting_type;",
          "342:     uint8_t  full_timestamp_flag;",
          "343:     uint8_t  discontinuity_flag;",
          "344:     uint8_t  cnt_dropped_flag;",
          "345:     uint16_t n_frames;",
          "346:     uint8_t  seconds_value;",
          "347:     uint8_t  minutes_value;",
          "348:     uint8_t  hours_value;",
          "349:     uint8_t  seconds_flag;",
          "350:     uint8_t  minutes_flag;",
          "351:     uint8_t  hours_flag;",
          "352:     uint8_t  time_offset_length;",
          "353:     uint32_t time_offset_value;",
          "354: } AV1RawMetadataTimecode;",
          "356: typedef struct AV1RawMetadata {",
          "357:     uint64_t metadata_type;",
          "358:     union {",
          "359:         AV1RawMetadataHDRCLL      hdr_cll;",
          "360:         AV1RawMetadataHDRMDCV     hdr_mdcv;",
          "361:         AV1RawMetadataScalability scalability;",
          "362:         AV1RawMetadataITUTT35     itut_t35;",
          "363:         AV1RawMetadataTimecode    timecode;",
          "364:     } metadata;",
          "365: } AV1RawMetadata;",
          "368: typedef struct AV1RawOBU {",
          "369:     AV1RawOBUHeader header;",
          "371:     size_t obu_size;",
          "373:     union {",
          "374:         AV1RawSequenceHeader sequence_header;",
          "375:         AV1RawFrameHeader    frame_header;",
          "376:         AV1RawFrame          frame;",
          "377:         AV1RawTileGroup      tile_group;",
          "378:         AV1RawTileList       tile_list;",
          "379:         AV1RawMetadata       metadata;",
          "380:     } obu;",
          "381: } AV1RawOBU;",
          "383: typedef struct AV1ReferenceFrameState {",
          "384:     int valid;          // RefValid",
          "385:     int frame_id;       // RefFrameId",
          "386:     int upscaled_width; // RefUpscaledWidth",
          "387:     int frame_width;    // RefFrameWidth",
          "388:     int frame_height;   // RefFrameHeight",
          "389:     int render_width;   // RefRenderWidth",
          "390:     int render_height;  // RefRenderHeight",
          "391:     int frame_type;     // RefFrameType",
          "392:     int subsampling_x;  // RefSubsamplingX",
          "393:     int subsampling_y;  // RefSubsamplingY",
          "394:     int bit_depth;      // RefBitDepth",
          "395:     int order_hint;     // RefOrderHint",
          "396: } AV1ReferenceFrameState;",
          "398: typedef struct CodedBitstreamAV1Context {",
          "399:     AV1RawSequenceHeader *sequence_header;",
          "400:     AVBufferRef          *sequence_header_ref;",
          "402:     int seen_frame_header;",
          "404:     int temporal_id;",
          "405:     int spatial_id;",
          "406:     int operating_point_idc;",
          "408:     int bit_depth;",
          "409:     int frame_width;",
          "410:     int frame_height;",
          "411:     int upscaled_width;",
          "412:     int render_width;",
          "413:     int render_height;",
          "415:     int num_planes;",
          "416:     int coded_lossless;",
          "417:     int all_lossless;",
          "418:     int tile_cols;",
          "419:     int tile_rows;",
          "421:     AV1ReferenceFrameState ref[AV1_NUM_REF_FRAMES];",
          "424:     uint8_t *write_buffer;",
          "425:     size_t   write_buffer_size;",
          "426: } CodedBitstreamAV1Context;",
          "",
          "---------------"
        ],
        "libavcodec/cbs_av1_syntax_template.c||libavcodec/cbs_av1_syntax_template.c": [
          "File: libavcodec/cbs_av1_syntax_template.c -> libavcodec/cbs_av1_syntax_template.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: static int FUNC(obu_header)(CodedBitstreamContext *ctx, RWContext *rw,",
          "20:                             AV1RawOBUHeader *current)",
          "21: {",
          "22:     int err;",
          "23:     av_unused int zero = 0;",
          "25:     HEADER(\"OBU header\");",
          "27:     fc(1, obu_forbidden_bit, 0, 0);",
          "29:     fc(4, obu_type, 0, AV1_OBU_PADDING);",
          "30:     flag(obu_extension_flag);",
          "31:     flag(obu_has_size_field);",
          "33:     fc(1, obu_reserved_1bit, 0, 0);",
          "35:     if (current->obu_extension_flag) {",
          "36:         fb(3, temporal_id);",
          "37:         fb(2, spatial_id);",
          "38:         fc(3, extension_header_reserved_3bits, 0, 0);",
          "39:     }",
          "41:     return 0;",
          "42: }",
          "44: static int FUNC(trailing_bits)(CodedBitstreamContext *ctx, RWContext *rw, int nb_bits)",
          "45: {",
          "46:     int err;",
          "48:     av_assert0(nb_bits > 0);",
          "50:     fixed(1, trailing_one_bit, 1);",
          "51:     --nb_bits;",
          "53:     while (nb_bits > 0) {",
          "54:         fixed(1, trailing_zero_bit, 0);",
          "55:         --nb_bits;",
          "56:     }",
          "58:     return 0;",
          "59: }",
          "61: static int FUNC(byte_alignment)(CodedBitstreamContext *ctx, RWContext *rw)",
          "62: {",
          "63:     int err;",
          "65:     while (byte_alignment(rw) != 0)",
          "66:         fixed(1, zero_bit, 0);",
          "68:     return 0;",
          "69: }",
          "71: static int FUNC(color_config)(CodedBitstreamContext *ctx, RWContext *rw,",
          "72:                               AV1RawColorConfig *current, int seq_profile)",
          "73: {",
          "74:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "75:     int err;",
          "77:     flag(high_bitdepth);",
          "79:     if (seq_profile == FF_PROFILE_AV1_PROFESSIONAL &&",
          "80:         current->high_bitdepth) {",
          "81:         flag(twelve_bit);",
          "82:         priv->bit_depth = current->twelve_bit ? 12 : 10;",
          "83:     } else {",
          "84:         priv->bit_depth = current->high_bitdepth ? 10 : 8;",
          "85:     }",
          "87:     if (seq_profile == FF_PROFILE_AV1_HIGH)",
          "88:         infer(mono_chrome, 0);",
          "89:     else",
          "90:         flag(mono_chrome);",
          "91:     priv->num_planes = current->mono_chrome ? 1 : 3;",
          "93:     flag(color_description_present_flag);",
          "94:     if (current->color_description_present_flag) {",
          "95:         fb(8, color_primaries);",
          "96:         fb(8, transfer_characteristics);",
          "97:         fb(8, matrix_coefficients);",
          "98:     } else {",
          "99:         infer(color_primaries,          AVCOL_PRI_UNSPECIFIED);",
          "100:         infer(transfer_characteristics, AVCOL_TRC_UNSPECIFIED);",
          "101:         infer(matrix_coefficients,      AVCOL_SPC_UNSPECIFIED);",
          "102:     }",
          "104:     if (current->mono_chrome) {",
          "105:         flag(color_range);",
          "107:         infer(subsampling_x, 1);",
          "108:         infer(subsampling_y, 1);",
          "109:         infer(chroma_sample_position, AV1_CSP_UNKNOWN);",
          "110:         infer(separate_uv_delta_q, 0);",
          "112:     } else if (current->color_primaries          == AVCOL_PRI_BT709 &&",
          "113:                current->transfer_characteristics == AVCOL_TRC_IEC61966_2_1 &&",
          "114:                current->matrix_coefficients      == AVCOL_SPC_RGB) {",
          "115:         infer(color_range,   1);",
          "116:         infer(subsampling_x, 0);",
          "117:         infer(subsampling_y, 0);",
          "118:         flag(separate_uv_delta_q);",
          "120:     } else {",
          "121:         flag(color_range);",
          "123:         if (seq_profile == FF_PROFILE_AV1_MAIN) {",
          "124:             infer(subsampling_x, 1);",
          "125:             infer(subsampling_y, 1);",
          "126:         } else if (seq_profile == FF_PROFILE_AV1_HIGH) {",
          "127:             infer(subsampling_x, 0);",
          "128:             infer(subsampling_y, 0);",
          "129:         } else {",
          "130:             if (priv->bit_depth == 12) {",
          "131:                 fb(1, subsampling_x);",
          "132:                 if (current->subsampling_x)",
          "133:                     fb(1, subsampling_y);",
          "134:                 else",
          "135:                     infer(subsampling_y, 0);",
          "136:             } else {",
          "137:                 infer(subsampling_x, 1);",
          "138:                 infer(subsampling_y, 0);",
          "139:             }",
          "140:         }",
          "141:         if (current->subsampling_x && current->subsampling_y) {",
          "142:             fc(2, chroma_sample_position, AV1_CSP_UNKNOWN,",
          "143:                                           AV1_CSP_COLOCATED);",
          "144:         }",
          "146:         flag(separate_uv_delta_q);",
          "147:     }",
          "149:     return 0;",
          "150: }",
          "152: static int FUNC(timing_info)(CodedBitstreamContext *ctx, RWContext *rw,",
          "153:                              AV1RawTimingInfo *current)",
          "154: {",
          "155:     int err;",
          "157:     fc(32, num_units_in_display_tick, 1, MAX_UINT_BITS(32));",
          "158:     fc(32, time_scale,                1, MAX_UINT_BITS(32));",
          "160:     flag(equal_picture_interval);",
          "161:     if (current->equal_picture_interval)",
          "162:         uvlc(num_ticks_per_picture_minus_1, 0, MAX_UINT_BITS(32) - 1);",
          "164:     return 0;",
          "165: }",
          "167: static int FUNC(decoder_model_info)(CodedBitstreamContext *ctx, RWContext *rw,",
          "168:                                     AV1RawDecoderModelInfo *current)",
          "169: {",
          "170:     int err;",
          "172:     fb(5, buffer_delay_length_minus_1);",
          "173:     fb(32, num_units_in_decoding_tick);",
          "174:     fb(5,  buffer_removal_time_length_minus_1);",
          "175:     fb(5,  frame_presentation_time_length_minus_1);",
          "177:     return 0;",
          "178: }",
          "180: static int FUNC(sequence_header_obu)(CodedBitstreamContext *ctx, RWContext *rw,",
          "181:                                      AV1RawSequenceHeader *current)",
          "182: {",
          "183:     int i, err;",
          "185:     HEADER(\"Sequence Header\");",
          "187:     fc(3, seq_profile, FF_PROFILE_AV1_MAIN,",
          "188:                        FF_PROFILE_AV1_PROFESSIONAL);",
          "189:     flag(still_picture);",
          "190:     flag(reduced_still_picture_header);",
          "192:     if (current->reduced_still_picture_header) {",
          "193:         infer(timing_info_present_flag,           0);",
          "194:         infer(decoder_model_info_present_flag,    0);",
          "195:         infer(initial_display_delay_present_flag, 0);",
          "196:         infer(operating_points_cnt_minus_1,       0);",
          "197:         infer(operating_point_idc[0],             0);",
          "199:         fb(5, seq_level_idx[0]);",
          "201:         infer(seq_tier[0], 0);",
          "202:         infer(decoder_model_present_for_this_op[0],         0);",
          "203:         infer(initial_display_delay_present_for_this_op[0], 0);",
          "205:     } else {",
          "206:         flag(timing_info_present_flag);",
          "207:         if (current->timing_info_present_flag) {",
          "208:             CHECK(FUNC(timing_info)(ctx, rw, &current->timing_info));",
          "210:             flag(decoder_model_info_present_flag);",
          "211:             if (current->decoder_model_info_present_flag) {",
          "212:                 CHECK(FUNC(decoder_model_info)",
          "213:                           (ctx, rw, &current->decoder_model_info));",
          "214:             }",
          "215:         } else {",
          "216:             infer(decoder_model_info_present_flag, 0);",
          "217:         }",
          "219:         flag(initial_display_delay_present_flag);",
          "221:         fb(5, operating_points_cnt_minus_1);",
          "222:         for (i = 0; i <= current->operating_points_cnt_minus_1; i++) {",
          "223:             fbs(12, operating_point_idc[i], 1, i);",
          "224:             fbs(5,  seq_level_idx[i], 1, i);",
          "226:             if (current->seq_level_idx[i] > 7)",
          "227:                 flags(seq_tier[i], 1, i);",
          "228:             else",
          "229:                 infer(seq_tier[i], 0);",
          "231:             if (current->decoder_model_info_present_flag) {",
          "232:                 flags(decoder_model_present_for_this_op[i], 1, i);",
          "233:                 if (current->decoder_model_present_for_this_op[i]) {",
          "234:                     int n = current->decoder_model_info.buffer_delay_length_minus_1 + 1;",
          "235:                     fbs(n, decoder_buffer_delay[i], 1, i);",
          "236:                     fbs(n, encoder_buffer_delay[i], 1, i);",
          "237:                     flags(low_delay_mode_flag[i], 1, i);",
          "238:                 }",
          "239:             } else {",
          "240:                 infer(decoder_model_present_for_this_op[i], 0);",
          "241:             }",
          "243:             if (current->initial_display_delay_present_flag) {",
          "244:                 flags(initial_display_delay_present_for_this_op[i], 1, i);",
          "245:                 if (current->initial_display_delay_present_for_this_op[i])",
          "246:                     fbs(4, initial_display_delay_minus_1[i], 1, i);",
          "247:             }",
          "248:         }",
          "249:     }",
          "251:     fb(4, frame_width_bits_minus_1);",
          "252:     fb(4, frame_height_bits_minus_1);",
          "254:     fb(current->frame_width_bits_minus_1  + 1, max_frame_width_minus_1);",
          "255:     fb(current->frame_height_bits_minus_1 + 1, max_frame_height_minus_1);",
          "257:     if (current->reduced_still_picture_header)",
          "258:         infer(frame_id_numbers_present_flag, 0);",
          "259:     else",
          "260:         flag(frame_id_numbers_present_flag);",
          "261:     if (current->frame_id_numbers_present_flag) {",
          "262:         fb(4, delta_frame_id_length_minus_2);",
          "263:         fb(3, additional_frame_id_length_minus_1);",
          "264:     }",
          "266:     flag(use_128x128_superblock);",
          "267:     flag(enable_filter_intra);",
          "268:     flag(enable_intra_edge_filter);",
          "270:     if (current->reduced_still_picture_header) {",
          "271:         infer(enable_intraintra_compound, 0);",
          "272:         infer(enable_masked_compound,     0);",
          "273:         infer(enable_warped_motion,       0);",
          "274:         infer(enable_dual_filter,         0);",
          "275:         infer(enable_order_hint,          0);",
          "276:         infer(enable_jnt_comp,            0);",
          "277:         infer(enable_ref_frame_mvs,       0);",
          "279:         infer(seq_force_screen_content_tools,",
          "280:               AV1_SELECT_SCREEN_CONTENT_TOOLS);",
          "281:         infer(seq_force_integer_mv,",
          "282:               AV1_SELECT_INTEGER_MV);",
          "283:     } else {",
          "284:         flag(enable_intraintra_compound);",
          "285:         flag(enable_masked_compound);",
          "286:         flag(enable_warped_motion);",
          "287:         flag(enable_dual_filter);",
          "289:         flag(enable_order_hint);",
          "290:         if (current->enable_order_hint) {",
          "291:             flag(enable_jnt_comp);",
          "292:             flag(enable_ref_frame_mvs);",
          "293:         } else {",
          "294:             infer(enable_jnt_comp,      0);",
          "295:             infer(enable_ref_frame_mvs, 0);",
          "296:         }",
          "298:         flag(seq_choose_screen_content_tools);",
          "299:         if (current->seq_choose_screen_content_tools)",
          "300:             infer(seq_force_screen_content_tools,",
          "301:                   AV1_SELECT_SCREEN_CONTENT_TOOLS);",
          "302:         else",
          "303:             fb(1, seq_force_screen_content_tools);",
          "304:         if (current->seq_force_screen_content_tools > 0) {",
          "305:             flag(seq_choose_integer_mv);",
          "306:             if (current->seq_choose_integer_mv)",
          "307:                 infer(seq_force_integer_mv,",
          "308:                       AV1_SELECT_INTEGER_MV);",
          "309:             else",
          "310:                 fb(1, seq_force_integer_mv);",
          "311:         } else {",
          "312:             infer(seq_force_integer_mv, AV1_SELECT_INTEGER_MV);",
          "313:         }",
          "315:         if (current->enable_order_hint)",
          "316:             fb(3, order_hint_bits_minus_1);",
          "317:     }",
          "319:     flag(enable_superres);",
          "320:     flag(enable_cdef);",
          "321:     flag(enable_restoration);",
          "323:     CHECK(FUNC(color_config)(ctx, rw, &current->color_config,",
          "324:                              current->seq_profile));",
          "326:     flag(film_grain_params_present);",
          "328:     return 0;",
          "329: }",
          "331: static int FUNC(temporal_delimiter_obu)(CodedBitstreamContext *ctx, RWContext *rw)",
          "332: {",
          "333:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "335:     HEADER(\"Temporal Delimiter\");",
          "337:     priv->seen_frame_header = 0;",
          "339:     return 0;",
          "340: }",
          "342: static int FUNC(superres_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "343:                                  AV1RawFrameHeader *current)",
          "344: {",
          "345:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "346:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "347:     int denom, err;",
          "349:     if (seq->enable_superres)",
          "350:         flag(use_superres);",
          "351:     else",
          "352:         infer(use_superres, 0);",
          "354:     if (current->use_superres) {",
          "355:         fb(3, coded_denom);",
          "356:         denom = current->coded_denom + AV1_SUPERRES_DENOM_MIN;",
          "357:     } else {",
          "358:         denom = AV1_SUPERRES_NUM;",
          "359:     }",
          "361:     priv->upscaled_width = priv->frame_width;",
          "362:     priv->frame_width = (priv->upscaled_width * AV1_SUPERRES_NUM +",
          "363:                          denom / 2) / denom;",
          "365:     return 0;",
          "366: }",
          "368: static int FUNC(frame_size)(CodedBitstreamContext *ctx, RWContext *rw,",
          "369:                             AV1RawFrameHeader *current)",
          "370: {",
          "371:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "372:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "373:     int err;",
          "375:     if (current->frame_size_override_flag) {",
          "376:         fb(seq->frame_width_bits_minus_1 + 1,  frame_width_minus_1);",
          "377:         fb(seq->frame_height_bits_minus_1 + 1, frame_height_minus_1);",
          "379:         priv->frame_width  = current->frame_width_minus_1  + 1;",
          "380:         priv->frame_height = current->frame_height_minus_1 + 1;",
          "381:     } else {",
          "382:         priv->frame_width  = seq->max_frame_width_minus_1  + 1;",
          "383:         priv->frame_height = seq->max_frame_height_minus_1 + 1;",
          "384:     }",
          "386:     CHECK(FUNC(superres_params)(ctx, rw, current));",
          "388:     return 0;",
          "389: }",
          "391: static int FUNC(render_size)(CodedBitstreamContext *ctx, RWContext *rw,",
          "392:                              AV1RawFrameHeader *current)",
          "393: {",
          "394:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "395:     int err;",
          "397:     flag(render_and_frame_size_different);",
          "399:     if (current->render_and_frame_size_different) {",
          "400:         fb(16, render_width_minus_1);",
          "401:         fb(16, render_height_minus_1);",
          "403:         priv->render_width  = current->render_width_minus_1  + 1;",
          "404:         priv->render_height = current->render_height_minus_1 + 1;",
          "405:     } else {",
          "406:         priv->render_width  = priv->upscaled_width;",
          "407:         priv->render_height = priv->frame_height;",
          "408:     }",
          "410:     return 0;",
          "411: }",
          "413: static int FUNC(frame_size_with_refs)(CodedBitstreamContext *ctx, RWContext *rw,",
          "414:                                       AV1RawFrameHeader *current)",
          "415: {",
          "416:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "417:     int i, err;",
          "419:     for (i = 0; i < AV1_REFS_PER_FRAME; i++) {",
          "420:         flag(found_ref);",
          "421:         if (current->found_ref) {",
          "422:             AV1ReferenceFrameState *ref =",
          "423:                 &priv->ref[current->ref_frame_idx[i]];",
          "425:             if (!ref->valid) {",
          "426:                 av_log(ctx->log_ctx, AV_LOG_ERROR,",
          "427:                        \"Missing reference frame needed for frame size \"",
          "428:                        \"(ref = %d, ref_frame_idx = %d).\\n\",",
          "429:                        i, current->ref_frame_idx[i]);",
          "430:                 return AVERROR_INVALIDDATA;",
          "431:             }",
          "433:             priv->upscaled_width = ref->upscaled_width;",
          "434:             priv->frame_width    = ref->frame_width;",
          "435:             priv->frame_height   = ref->frame_height;",
          "436:             priv->render_width   = ref->render_width;",
          "437:             priv->render_height  = ref->render_height;",
          "438:             break;",
          "439:         }",
          "440:     }",
          "442:     if (current->found_ref == 0) {",
          "443:         CHECK(FUNC(frame_size)(ctx, rw, current));",
          "444:         CHECK(FUNC(render_size)(ctx, rw, current));",
          "445:     } else {",
          "446:         CHECK(FUNC(superres_params)(ctx, rw, current));",
          "447:     }",
          "449:     return 0;",
          "450: }",
          "452: static int FUNC(interpolation_filter)(CodedBitstreamContext *ctx, RWContext *rw,",
          "453:                                       AV1RawFrameHeader *current)",
          "454: {",
          "455:     int err;",
          "457:     flag(is_filter_switchable);",
          "458:     if (current->is_filter_switchable)",
          "459:         infer(interpolation_filter,",
          "460:               AV1_INTERPOLATION_FILTER_SWITCHABLE);",
          "461:     else",
          "462:         fb(2, interpolation_filter);",
          "464:     return 0;",
          "465: }",
          "467: static int FUNC(tile_info)(CodedBitstreamContext *ctx, RWContext *rw,",
          "468:                            AV1RawFrameHeader *current)",
          "469: {",
          "470:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "471:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "472:     int mi_cols, mi_rows, sb_cols, sb_rows, sb_shift, sb_size;",
          "473:     int max_tile_width_sb, max_tile_height_sb, max_tile_area_sb;",
          "474:     int min_log2_tile_cols, max_log2_tile_cols, max_log2_tile_rows;",
          "475:     int min_log2_tiles, min_log2_tile_rows;",
          "476:     int i, err;",
          "478:     mi_cols = 2 * ((priv->frame_width  + 7) >> 3);",
          "479:     mi_rows = 2 * ((priv->frame_height + 7) >> 3);",
          "481:     sb_cols = seq->use_128x128_superblock ? ((mi_cols + 31) >> 5)",
          "482:                                           : ((mi_cols + 15) >> 4);",
          "483:     sb_rows = seq->use_128x128_superblock ? ((mi_rows + 31) >> 5)",
          "484:                                           : ((mi_rows + 15) >> 4);",
          "486:     sb_shift = seq->use_128x128_superblock ? 5 : 4;",
          "487:     sb_size  = sb_shift + 2;",
          "489:     max_tile_width_sb = AV1_MAX_TILE_WIDTH >> sb_size;",
          "490:     max_tile_area_sb  = AV1_MAX_TILE_AREA  >> (2 * sb_size);",
          "492:     min_log2_tile_cols = cbs_av1_tile_log2(max_tile_width_sb, sb_cols);",
          "493:     max_log2_tile_cols = cbs_av1_tile_log2(1, FFMIN(sb_cols, AV1_MAX_TILE_COLS));",
          "494:     max_log2_tile_rows = cbs_av1_tile_log2(1, FFMIN(sb_rows, AV1_MAX_TILE_ROWS));",
          "495:     min_log2_tiles = FFMAX(min_log2_tile_cols,",
          "496:                            cbs_av1_tile_log2(max_tile_area_sb, sb_rows * sb_cols));",
          "498:     flag(uniform_tile_spacing_flag);",
          "500:     if (current->uniform_tile_spacing_flag) {",
          "501:         int tile_width_sb, tile_height_sb;",
          "503:         increment(tile_cols_log2, min_log2_tile_cols, max_log2_tile_cols);",
          "505:         tile_width_sb = (sb_cols + (1 << current->tile_cols_log2) - 1) >>",
          "506:             current->tile_cols_log2;",
          "507:         current->tile_cols = (sb_cols + tile_width_sb - 1) / tile_width_sb;",
          "509:         min_log2_tile_rows = FFMAX(min_log2_tiles - current->tile_cols_log2, 0);",
          "511:         increment(tile_rows_log2, min_log2_tile_rows, max_log2_tile_rows);",
          "513:         tile_height_sb = (sb_rows + (1 << current->tile_rows_log2) - 1) >>",
          "514:             current->tile_rows_log2;",
          "515:         current->tile_rows = (sb_rows + tile_height_sb - 1) / tile_height_sb;",
          "517:     } else {",
          "518:         int widest_tile_sb, start_sb, size_sb, max_width, max_height;",
          "520:         widest_tile_sb = 0;",
          "522:         start_sb = 0;",
          "523:         for (i = 0; start_sb < sb_cols && i < AV1_MAX_TILE_COLS; i++) {",
          "524:             max_width = FFMIN(sb_cols - start_sb, max_tile_width_sb);",
          "525:             ns(max_width, width_in_sbs_minus_1[i], 1, i);",
          "526:             size_sb = current->width_in_sbs_minus_1[i] + 1;",
          "527:             widest_tile_sb = FFMAX(size_sb, widest_tile_sb);",
          "528:             start_sb += size_sb;",
          "529:         }",
          "530:         current->tile_cols_log2 = cbs_av1_tile_log2(1, i);",
          "531:         current->tile_cols = i;",
          "533:         if (min_log2_tiles > 0)",
          "534:             max_tile_area_sb = (sb_rows * sb_cols) >> (min_log2_tiles + 1);",
          "535:         else",
          "536:             max_tile_area_sb = sb_rows * sb_cols;",
          "537:         max_tile_height_sb = FFMAX(max_tile_area_sb / widest_tile_sb, 1);",
          "539:         start_sb = 0;",
          "540:         for (i = 0; start_sb < sb_rows && i < AV1_MAX_TILE_ROWS; i++) {",
          "541:             max_height = FFMIN(sb_rows - start_sb, max_tile_height_sb);",
          "542:             ns(max_height, height_in_sbs_minus_1[i], 1, i);",
          "543:             size_sb = current->height_in_sbs_minus_1[i] + 1;",
          "544:             start_sb += size_sb;",
          "545:         }",
          "546:         current->tile_rows_log2 = cbs_av1_tile_log2(1, i);",
          "547:         current->tile_rows = i;",
          "548:     }",
          "550:     if (current->tile_cols_log2 > 0 ||",
          "551:         current->tile_rows_log2 > 0) {",
          "552:         fb(current->tile_cols_log2 + current->tile_rows_log2,",
          "553:            context_update_tile_id);",
          "554:         fb(2, tile_size_bytes_minus1);",
          "555:     } else {",
          "556:         infer(context_update_tile_id, 0);",
          "557:     }",
          "559:     priv->tile_cols = current->tile_cols;",
          "560:     priv->tile_rows = current->tile_rows;",
          "562:     return 0;",
          "563: }",
          "565: static int FUNC(quantization_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "566:                                      AV1RawFrameHeader *current)",
          "567: {",
          "568:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "569:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "570:     int err;",
          "572:     fb(8, base_q_idx);",
          "574:     delta_q(delta_q_y_dc);",
          "576:     if (priv->num_planes > 1) {",
          "577:         if (seq->color_config.separate_uv_delta_q)",
          "578:             flag(diff_uv_delta);",
          "579:         else",
          "580:             infer(diff_uv_delta, 0);",
          "582:         delta_q(delta_q_u_dc);",
          "583:         delta_q(delta_q_u_ac);",
          "585:         if (current->diff_uv_delta) {",
          "586:             delta_q(delta_q_v_dc);",
          "587:             delta_q(delta_q_v_ac);",
          "588:         } else {",
          "589:             infer(delta_q_v_dc, current->delta_q_u_dc);",
          "590:             infer(delta_q_v_ac, current->delta_q_u_ac);",
          "591:         }",
          "592:     } else {",
          "593:         infer(delta_q_u_dc, 0);",
          "594:         infer(delta_q_u_ac, 0);",
          "595:         infer(delta_q_v_dc, 0);",
          "596:         infer(delta_q_v_ac, 0);",
          "597:     }",
          "599:     flag(using_qmatrix);",
          "600:     if (current->using_qmatrix) {",
          "601:         fb(4, qm_y);",
          "602:         fb(4, qm_u);",
          "603:         if (seq->color_config.separate_uv_delta_q)",
          "604:             fb(4, qm_v);",
          "605:         else",
          "606:             infer(qm_v, current->qm_u);",
          "607:     }",
          "609:     return 0;",
          "610: }",
          "612: static int FUNC(segmentation_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "613:                                      AV1RawFrameHeader *current)",
          "614: {",
          "615:     static const uint8_t bits[AV1_SEG_LVL_MAX] = { 8, 6, 6, 6, 6, 3, 0, 0 };",
          "616:     static const uint8_t sign[AV1_SEG_LVL_MAX] = { 1, 1, 1, 1, 1, 0, 0, 0 };",
          "617:     int i, j, err;",
          "619:     flag(segmentation_enabled);",
          "621:     if (current->segmentation_enabled) {",
          "622:         if (current->primary_ref_frame == AV1_PRIMARY_REF_NONE) {",
          "623:             infer(segmentation_update_map,      1);",
          "624:             infer(segmentation_temporal_update, 0);",
          "625:             infer(segmentation_update_data,     1);",
          "626:         } else {",
          "627:             flag(segmentation_update_map);",
          "628:             if (current->segmentation_update_map)",
          "629:                 flag(segmentation_temporal_update);",
          "630:             else",
          "631:                 infer(segmentation_temporal_update, 0);",
          "632:             flag(segmentation_update_data);",
          "633:         }",
          "635:         if (current->segmentation_update_data) {",
          "636:             for (i = 0; i < AV1_MAX_SEGMENTS; i++) {",
          "637:                 for (j = 0; j < AV1_SEG_LVL_MAX; j++) {",
          "638:                     flags(feature_enabled[i][j], 2, i, j);",
          "640:                     if (current->feature_enabled[i][j] && bits[j] > 0) {",
          "641:                         if (sign[j])",
          "642:                             sus(1 + bits[j], feature_value[i][j], 2, i, j);",
          "643:                         else",
          "644:                             fbs(bits[j], feature_value[i][j], 2, i, j);",
          "645:                     } else {",
          "646:                         infer(feature_value[i][j], 0);",
          "647:                     }",
          "648:                 }",
          "649:             }",
          "650:         }",
          "651:     } else {",
          "652:         for (i = 0; i < AV1_MAX_SEGMENTS; i++) {",
          "653:             for (j = 0; j < AV1_SEG_LVL_MAX; j++) {",
          "654:                 infer(feature_enabled[i][j], 0);",
          "655:                 infer(feature_value[i][j],   0);",
          "656:             }",
          "657:         }",
          "658:     }",
          "660:     return 0;",
          "661: }",
          "663: static int FUNC(delta_q_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "664:                                 AV1RawFrameHeader *current)",
          "665: {",
          "666:     int err;",
          "668:     if (current->base_q_idx > 0)",
          "669:         flag(delta_q_present);",
          "670:     else",
          "671:         infer(delta_q_present, 0);",
          "673:     if (current->delta_q_present)",
          "674:         fb(2, delta_q_res);",
          "676:     return 0;",
          "677: }",
          "679: static int FUNC(delta_lf_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "680:                                  AV1RawFrameHeader *current)",
          "681: {",
          "682:     int err;",
          "684:     if (current->delta_q_present) {",
          "685:         if (!current->allow_intrabc)",
          "686:             flag(delta_lf_present);",
          "687:         else",
          "688:             infer(delta_lf_present, 0);",
          "689:         if (current->delta_lf_present) {",
          "690:             fb(2, delta_lf_res);",
          "691:             flag(delta_lf_multi);",
          "692:         } else {",
          "693:             infer(delta_lf_res,   0);",
          "694:             infer(delta_lf_multi, 0);",
          "695:         }",
          "696:     } else {",
          "697:         infer(delta_lf_present, 0);",
          "698:         infer(delta_lf_res,     0);",
          "699:         infer(delta_lf_multi,   0);",
          "700:     }",
          "702:     return 0;",
          "703: }",
          "705: static int FUNC(loop_filter_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "706:                                     AV1RawFrameHeader *current)",
          "707: {",
          "708:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "709:     int i, err;",
          "711:     if (priv->coded_lossless || current->allow_intrabc) {",
          "712:         infer(loop_filter_level[0], 0);",
          "713:         infer(loop_filter_level[1], 0);",
          "714:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_INTRA],    1);",
          "715:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_LAST],     0);",
          "716:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_LAST2],    0);",
          "717:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_LAST3],    0);",
          "718:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_BWDREF],   0);",
          "719:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_GOLDEN],  -1);",
          "720:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_ALTREF],  -1);",
          "721:         infer(loop_filter_ref_deltas[AV1_REF_FRAME_ALTREF2], -1);",
          "722:         for (i = 0; i < 2; i++)",
          "723:             infer(loop_filter_mode_deltas[i], 0);",
          "724:         return 0;",
          "725:     }",
          "727:     fb(6, loop_filter_level[0]);",
          "728:     fb(6, loop_filter_level[1]);",
          "730:     if (priv->num_planes > 1) {",
          "731:         if (current->loop_filter_level[0] ||",
          "732:             current->loop_filter_level[1]) {",
          "733:             fb(6, loop_filter_level[2]);",
          "734:             fb(6, loop_filter_level[3]);",
          "735:         }",
          "736:     }",
          "738:     fb(3, loop_filter_sharpness);",
          "740:     flag(loop_filter_delta_enabled);",
          "741:     if (current->loop_filter_delta_enabled) {",
          "742:         flag(loop_filter_delta_update);",
          "743:         if (current->loop_filter_delta_update) {",
          "744:             for (i = 0; i < AV1_TOTAL_REFS_PER_FRAME; i++) {",
          "745:                 flags(update_ref_delta[i], 1, i);",
          "746:                 if (current->update_ref_delta[i])",
          "747:                     sus(1 + 6, loop_filter_ref_deltas[i], 1, i);",
          "748:             }",
          "749:             for (i = 0; i < 2; i++) {",
          "750:                 flags(update_mode_delta[i], 1, i);",
          "751:                 if (current->update_mode_delta[i])",
          "752:                     sus(1 + 6, loop_filter_mode_deltas[i], 1, i);",
          "753:             }",
          "754:         }",
          "755:     }",
          "757:     return 0;",
          "758: }",
          "760: static int FUNC(cdef_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "761:                              AV1RawFrameHeader *current)",
          "762: {",
          "763:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "764:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "765:     int i, err;",
          "767:     if (priv->coded_lossless || current->allow_intrabc ||",
          "768:         !seq->enable_cdef) {",
          "769:         infer(cdef_damping_minus_3, 0);",
          "770:         infer(cdef_bits, 0);",
          "771:         infer(cdef_y_pri_strength[0],  0);",
          "772:         infer(cdef_y_sec_strength[0],  0);",
          "773:         infer(cdef_uv_pri_strength[0], 0);",
          "774:         infer(cdef_uv_sec_strength[0], 0);",
          "776:         return 0;",
          "777:     }",
          "779:     fb(2, cdef_damping_minus_3);",
          "780:     fb(2, cdef_bits);",
          "782:     for (i = 0; i < (1 << current->cdef_bits); i++) {",
          "783:         fbs(4, cdef_y_pri_strength[i], 1, i);",
          "784:         fbs(2, cdef_y_sec_strength[i], 1, i);",
          "786:         if (priv->num_planes > 1) {",
          "787:             fbs(4, cdef_uv_pri_strength[i], 1, i);",
          "788:             fbs(2, cdef_uv_sec_strength[i], 1, i);",
          "789:         }",
          "790:     }",
          "792:     return 0;",
          "793: }",
          "795: static int FUNC(lr_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "796:                            AV1RawFrameHeader *current)",
          "797: {",
          "798:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "799:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "800:     int uses_lr,  uses_chroma_lr;",
          "801:     int i, err;",
          "803:     if (priv->all_lossless || current->allow_intrabc ||",
          "804:         !seq->enable_restoration) {",
          "805:         return 0;",
          "806:     }",
          "808:     uses_lr = uses_chroma_lr = 0;",
          "809:     for (i = 0; i < priv->num_planes; i++) {",
          "810:         fbs(2, lr_type[i], 1, i);",
          "812:         if (current->lr_type[i] != 0) {",
          "813:             uses_lr = 1;",
          "814:             if (i > 0)",
          "815:                 uses_chroma_lr = 1;",
          "816:         }",
          "817:     }",
          "819:     if (uses_lr) {",
          "820:         if (seq->use_128x128_superblock)",
          "821:             increment(lr_unit_shift, 1, 2);",
          "822:         else",
          "823:             increment(lr_unit_shift, 0, 2);",
          "825:         if(seq->color_config.subsampling_x &&",
          "826:            seq->color_config.subsampling_y && uses_chroma_lr) {",
          "827:             fb(1, lr_uv_shift);",
          "828:         } else {",
          "829:             infer(lr_uv_shift, 0);",
          "830:         }",
          "831:     }",
          "833:     return 0;",
          "834: }",
          "836: static int FUNC(read_tx_mode)(CodedBitstreamContext *ctx, RWContext *rw,",
          "837:                               AV1RawFrameHeader *current)",
          "838: {",
          "839:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "840:     int err;",
          "842:     if (priv->coded_lossless)",
          "843:         infer(tx_mode, 0);",
          "844:     else",
          "845:         increment(tx_mode, 1, 2);",
          "847:     return 0;",
          "848: }",
          "850: static int FUNC(frame_reference_mode)(CodedBitstreamContext *ctx, RWContext *rw,",
          "851:                                       AV1RawFrameHeader *current)",
          "852: {",
          "853:     int err;",
          "855:     if (current->frame_type == AV1_FRAME_INTRA_ONLY ||",
          "856:         current->frame_type == AV1_FRAME_KEY)",
          "857:         infer(reference_select, 0);",
          "858:     else",
          "859:         flag(reference_select);",
          "861:     return 0;",
          "862: }",
          "864: static int FUNC(skip_mode_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "865:                                   AV1RawFrameHeader *current)",
          "866: {",
          "867:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "868:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "869:     int skip_mode_allowed;",
          "870:     int err;",
          "872:     if (current->frame_type == AV1_FRAME_KEY ||",
          "873:         current->frame_type == AV1_FRAME_INTRA_ONLY ||",
          "874:         !current->reference_select || !seq->enable_order_hint) {",
          "875:         skip_mode_allowed = 0;",
          "876:     } else {",
          "877:         int forward_idx,  backward_idx;",
          "878:         int forward_hint, backward_hint;",
          "879:         int ref_hint, dist, i;",
          "881:         forward_idx  = -1;",
          "882:         backward_idx = -1;",
          "883:         for (i = 0; i < AV1_REFS_PER_FRAME; i++) {",
          "884:             ref_hint = priv->ref[i].order_hint;",
          "885:             dist = cbs_av1_get_relative_dist(seq, ref_hint,",
          "886:                                              current->order_hint);",
          "887:             if (dist < 0) {",
          "888:                 if (forward_idx < 0 ||",
          "889:                     cbs_av1_get_relative_dist(seq, ref_hint,",
          "890:                                               forward_hint) > 0) {",
          "891:                     forward_idx  = i;",
          "892:                     forward_hint = ref_hint;",
          "893:                 }",
          "894:             } else if (dist > 0) {",
          "895:                 if (backward_idx < 0 ||",
          "896:                     cbs_av1_get_relative_dist(seq, ref_hint,",
          "897:                                               backward_hint) < 0) {",
          "898:                     backward_idx  = i;",
          "899:                     backward_hint = ref_hint;",
          "900:                 }",
          "901:             }",
          "902:         }",
          "904:         if (forward_idx < 0) {",
          "905:             skip_mode_allowed = 0;",
          "906:         } else if (backward_idx >= 0) {",
          "907:             skip_mode_allowed = 1;",
          "909:         } else {",
          "910:             int second_forward_idx;",
          "911:             int second_forward_hint;",
          "913:             second_forward_idx = -1;",
          "914:             for (i = 0; i < AV1_REFS_PER_FRAME; i++) {",
          "915:                 ref_hint = priv->ref[i].order_hint;",
          "916:                 if (cbs_av1_get_relative_dist(seq, ref_hint,",
          "917:                                               forward_hint) < 0) {",
          "918:                     if (second_forward_idx < 0 ||",
          "919:                         cbs_av1_get_relative_dist(seq, ref_hint,",
          "920:                                                   second_forward_hint) > 0) {",
          "921:                         second_forward_idx  = i;",
          "922:                         second_forward_hint = ref_hint;",
          "923:                     }",
          "924:                 }",
          "925:             }",
          "927:             if (second_forward_idx < 0) {",
          "928:                 skip_mode_allowed = 0;",
          "929:             } else {",
          "930:                 skip_mode_allowed = 1;",
          "932:             }",
          "933:         }",
          "934:     }",
          "936:     if (skip_mode_allowed)",
          "937:         flag(skip_mode_present);",
          "938:     else",
          "939:         infer(skip_mode_present, 0);",
          "941:     return 0;",
          "942: }",
          "944: static int FUNC(global_motion_param)(CodedBitstreamContext *ctx, RWContext *rw,",
          "945:                                      AV1RawFrameHeader *current,",
          "946:                                      int type, int ref, int idx)",
          "947: {",
          "948:     uint32_t abs_bits, prec_bits, num_syms;",
          "949:     int err;",
          "951:     if (idx < 2) {",
          "952:         if (type == AV1_WARP_MODEL_TRANSLATION) {",
          "953:             abs_bits  = AV1_GM_ABS_TRANS_ONLY_BITS  - !current->allow_high_precision_mv;",
          "954:             prec_bits = AV1_GM_TRANS_ONLY_PREC_BITS - !current->allow_high_precision_mv;",
          "955:         } else {",
          "956:             abs_bits  = AV1_GM_ABS_TRANS_BITS;",
          "957:             prec_bits = AV1_GM_TRANS_PREC_BITS;",
          "958:         }",
          "959:     } else {",
          "960:         abs_bits  = AV1_GM_ABS_ALPHA_BITS;",
          "961:         prec_bits = AV1_GM_ALPHA_PREC_BITS;",
          "962:     }",
          "964:     num_syms = 2 * (1 << abs_bits) + 1;",
          "965:     subexp(gm_params[ref][idx], num_syms, 2, ref, idx);",
          "968:     (void)prec_bits;",
          "970:     return 0;",
          "971: }",
          "973: static int FUNC(global_motion_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "974:                                       AV1RawFrameHeader *current)",
          "975: {",
          "976:     int ref, type;",
          "977:     int err;",
          "979:     if (current->frame_type == AV1_FRAME_KEY ||",
          "980:         current->frame_type == AV1_FRAME_INTRA_ONLY)",
          "981:         return 0;",
          "983:     for (ref = AV1_REF_FRAME_LAST; ref <= AV1_REF_FRAME_ALTREF; ref++) {",
          "984:         flags(is_global[ref], 1, ref);",
          "985:         if (current->is_global[ref]) {",
          "986:             flags(is_rot_zoom[ref], 1, ref);",
          "987:             if (current->is_rot_zoom[ref]) {",
          "988:                 type = AV1_WARP_MODEL_ROTZOOM;",
          "989:             } else {",
          "990:                 flags(is_translation[ref], 1, ref);",
          "991:                 type = current->is_translation[ref] ? AV1_WARP_MODEL_TRANSLATION",
          "992:                                                     : AV1_WARP_MODEL_AFFINE;",
          "993:             }",
          "994:         } else {",
          "995:             type = AV1_WARP_MODEL_IDENTITY;",
          "996:         }",
          "998:         if (type >= AV1_WARP_MODEL_ROTZOOM) {",
          "999:             CHECK(FUNC(global_motion_param)(ctx, rw, current, type, ref, 2));",
          "1000:             CHECK(FUNC(global_motion_param)(ctx, rw, current, type, ref, 3));",
          "1001:             if (type == AV1_WARP_MODEL_AFFINE) {",
          "1002:                 CHECK(FUNC(global_motion_param)(ctx, rw, current, type, ref, 4));",
          "1003:                 CHECK(FUNC(global_motion_param)(ctx, rw, current, type, ref, 5));",
          "1004:             } else {",
          "1007:             }",
          "1008:         }",
          "1009:         if (type >= AV1_WARP_MODEL_TRANSLATION) {",
          "1010:             CHECK(FUNC(global_motion_param)(ctx, rw, current, type, ref, 0));",
          "1011:             CHECK(FUNC(global_motion_param)(ctx, rw, current, type, ref, 1));",
          "1012:         }",
          "1013:     }",
          "1015:     return 0;",
          "1016: }",
          "1018: static int FUNC(film_grain_params)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1019:                                    AV1RawFrameHeader *current)",
          "1020: {",
          "1021:     CodedBitstreamAV1Context  *priv = ctx->priv_data;",
          "1022:     const AV1RawSequenceHeader *seq = priv->sequence_header;",
          "1023:     int num_pos_luma, num_pos_chroma;",
          "1024:     int i, err;",
          "1026:     if (!seq->film_grain_params_present ||",
          "1027:         (!current->show_frame && !current->showable_frame))",
          "1028:         return 0;",
          "1030:     flag(apply_grain);",
          "1032:     if (!current->apply_grain)",
          "1033:         return 0;",
          "1035:     fb(16, grain_seed);",
          "1037:     if (current->frame_type == AV1_FRAME_INTER)",
          "1038:         flag(update_grain);",
          "1039:     else",
          "1040:         infer(update_grain, 1);",
          "1042:     if (!current->update_grain) {",
          "1043:         fb(3, film_grain_params_ref_idx);",
          "1044:         return 0;",
          "1045:     }",
          "1047:     fb(4, num_y_points);",
          "1048:     for (i = 0; i < current->num_y_points; i++) {",
          "1049:         fbs(8, point_y_value[i],   1, i);",
          "1050:         fbs(8, point_y_scaling[i], 1, i);",
          "1051:     }",
          "1053:     if (seq->color_config.mono_chrome)",
          "1054:         infer(chroma_scaling_from_luma, 0);",
          "1055:     else",
          "1056:         flag(chroma_scaling_from_luma);",
          "1058:     if (seq->color_config.mono_chrome ||",
          "1059:         current->chroma_scaling_from_luma ||",
          "1060:         (seq->color_config.subsampling_x == 1 &&",
          "1061:          seq->color_config.subsampling_y == 1 &&",
          "1062:          current->num_y_points == 0)) {",
          "1063:         infer(num_cb_points, 0);",
          "1064:         infer(num_cr_points, 0);",
          "1065:     } else {",
          "1066:         fb(4, num_cb_points);",
          "1067:         for (i = 0; i < current->num_cb_points; i++) {",
          "1068:             fbs(8, point_cb_value[i],   1, i);",
          "1069:             fbs(8, point_cb_scaling[i], 1, i);",
          "1070:         }",
          "1071:         fb(4, num_cr_points);",
          "1072:         for (i = 0; i < current->num_cr_points; i++) {",
          "1073:             fbs(8, point_cr_value[i],   1, i);",
          "1074:             fbs(8, point_cr_scaling[i], 1, i);",
          "1075:         }",
          "1076:     }",
          "1078:     fb(2, grain_scaling_minus_8);",
          "1079:     fb(2, ar_coeff_lag);",
          "1080:     num_pos_luma = 2 * current->ar_coeff_lag * (current->ar_coeff_lag + 1);",
          "1081:     if (current->num_y_points) {",
          "1082:         num_pos_chroma = num_pos_luma + 1;",
          "1083:         for (i = 0; i < num_pos_luma; i++)",
          "1084:             fbs(8, ar_coeffs_y_plus_128[i], 1, i);",
          "1085:     } else {",
          "1086:         num_pos_chroma = num_pos_luma;",
          "1087:     }",
          "1088:     if (current->chroma_scaling_from_luma || current->num_cb_points) {",
          "1089:         for (i = 0; i < num_pos_chroma; i++)",
          "1090:             fbs(8, ar_coeffs_cb_plus_128[i], 1, i);",
          "1091:     }",
          "1092:     if (current->chroma_scaling_from_luma || current->num_cr_points) {",
          "1093:         for (i = 0; i < num_pos_chroma; i++)",
          "1094:             fbs(8, ar_coeffs_cr_plus_128[i], 1, i);",
          "1095:     }",
          "1096:     fb(2, ar_coeff_shift_minus_6);",
          "1097:     fb(2, grain_scale_shift);",
          "1098:     if (current->num_cb_points) {",
          "1099:         fb(8, cb_mult);",
          "1100:         fb(8, cb_luma_mult);",
          "1101:         fb(9, cb_offset);",
          "1102:     }",
          "1103:     if (current->num_cr_points) {",
          "1104:         fb(8, cr_mult);",
          "1105:         fb(8, cr_luma_mult);",
          "1106:         fb(9, cr_offset);",
          "1107:     }",
          "1109:     flag(overlap_flag);",
          "1110:     flag(clip_to_restricted_range);",
          "1112:     return 0;",
          "1113: }",
          "1115: static int FUNC(uncompressed_header)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1116:                                      AV1RawFrameHeader *current)",
          "1117: {",
          "1118:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "1119:     const AV1RawSequenceHeader *seq;",
          "1120:     int id_len, diff_len, all_frames, frame_is_intra, order_hint_bits;",
          "1121:     int i, err;",
          "1123:     if (!priv->sequence_header) {",
          "1124:         av_log(ctx->log_ctx, AV_LOG_ERROR, \"No sequence header available: \"",
          "1125:                \"unable to decode frame header.\\n\");",
          "1126:         return AVERROR_INVALIDDATA;",
          "1127:     }",
          "1128:     seq = priv->sequence_header;",
          "1130:     id_len = seq->additional_frame_id_length_minus_1 +",
          "1131:              seq->delta_frame_id_length_minus_2 + 3;",
          "1132:     all_frames = (1 << AV1_NUM_REF_FRAMES) - 1;",
          "1134:     if (seq->reduced_still_picture_header) {",
          "1135:         infer(show_existing_frame, 0);",
          "1136:         infer(frame_type,     AV1_FRAME_KEY);",
          "1137:         infer(show_frame,     1);",
          "1138:         infer(showable_frame, 0);",
          "1139:         frame_is_intra = 1;",
          "1141:     } else {",
          "1142:         flag(show_existing_frame);",
          "1144:         if (current->show_existing_frame) {",
          "1145:             AV1ReferenceFrameState *frame;",
          "1147:             fb(3, frame_to_show_map_idx);",
          "1148:             frame = &priv->ref[current->frame_to_show_map_idx];",
          "1150:             if (seq->decoder_model_info_present_flag &&",
          "1151:                 !seq->timing_info.equal_picture_interval) {",
          "1152:                 fb(seq->decoder_model_info.frame_presentation_time_length_minus_1 + 1,",
          "1153:                    frame_presentation_time);",
          "1154:             }",
          "1156:             if (seq->frame_id_numbers_present_flag)",
          "1157:                 fb(id_len, display_frame_id);",
          "1159:             if (frame->frame_type == AV1_FRAME_KEY)",
          "1160:                 infer(refresh_frame_flags, all_frames);",
          "1161:             else",
          "1162:                 infer(refresh_frame_flags, 0);",
          "1164:             return 0;",
          "1165:         }",
          "1167:         fb(2, frame_type);",
          "1168:         frame_is_intra = (current->frame_type == AV1_FRAME_INTRA_ONLY ||",
          "1169:                           current->frame_type == AV1_FRAME_KEY);",
          "1171:         flag(show_frame);",
          "1172:         if (current->show_frame &&",
          "1173:             seq->decoder_model_info_present_flag &&",
          "1174:             !seq->timing_info.equal_picture_interval) {",
          "1175:             fb(seq->decoder_model_info.frame_presentation_time_length_minus_1 + 1,",
          "1176:                frame_presentation_time);",
          "1177:         }",
          "1178:         if (current->show_frame)",
          "1179:             infer(showable_frame, current->frame_type != AV1_FRAME_KEY);",
          "1180:         else",
          "1181:             flag(showable_frame);",
          "1183:         if (current->frame_type == AV1_FRAME_SWITCH ||",
          "1184:             (current->frame_type == AV1_FRAME_KEY && current->show_frame))",
          "1185:             infer(error_resilient_mode, 1);",
          "1186:         else",
          "1187:             flag(error_resilient_mode);",
          "1188:     }",
          "1190:     if (current->frame_type == AV1_FRAME_KEY && current->show_frame) {",
          "1191:         for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {",
          "1192:             priv->ref[i].valid = 0;",
          "1193:             priv->ref[i].order_hint = 0;",
          "1194:         }",
          "1195:     }",
          "1197:     flag(disable_cdf_update);",
          "1199:     if (seq->seq_force_screen_content_tools ==",
          "1200:         AV1_SELECT_SCREEN_CONTENT_TOOLS) {",
          "1201:         flag(allow_screen_content_tools);",
          "1202:     } else {",
          "1203:         infer(allow_screen_content_tools,",
          "1204:               seq->seq_force_screen_content_tools);",
          "1205:     }",
          "1206:     if (current->allow_screen_content_tools) {",
          "1207:         if (seq->seq_force_integer_mv == AV1_SELECT_INTEGER_MV)",
          "1208:             flag(force_integer_mv);",
          "1209:         else",
          "1210:             infer(force_integer_mv, seq->seq_force_integer_mv);",
          "1211:     } else {",
          "1212:         infer(force_integer_mv, 0);",
          "1213:     }",
          "1215:     if (seq->frame_id_numbers_present_flag) {",
          "1216:         fb(id_len, current_frame_id);",
          "1218:         diff_len = seq->delta_frame_id_length_minus_2 + 2;",
          "1219:         for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {",
          "1220:             if (current->current_frame_id > (1 << diff_len)) {",
          "1221:                 if (priv->ref[i].frame_id > current->current_frame_id ||",
          "1222:                     priv->ref[i].frame_id < (current->current_frame_id -",
          "1223:                                              (1 << diff_len)))",
          "1224:                     priv->ref[i].valid = 0;",
          "1225:             } else {",
          "1226:                 if (priv->ref[i].frame_id > current->current_frame_id &&",
          "1227:                     priv->ref[i].frame_id < ((1 << id_len) +",
          "1228:                                              current->current_frame_id -",
          "1229:                                              (1 << diff_len)))",
          "1230:                     priv->ref[i].valid = 0;",
          "1231:             }",
          "1232:         }",
          "1233:     } else {",
          "1234:         infer(current_frame_id, 0);",
          "1235:     }",
          "1237:     if (current->frame_type == AV1_FRAME_SWITCH)",
          "1238:         infer(frame_size_override_flag, 1);",
          "1239:     else if(seq->reduced_still_picture_header)",
          "1240:         infer(frame_size_override_flag, 0);",
          "1241:     else",
          "1242:         flag(frame_size_override_flag);",
          "1244:     order_hint_bits =",
          "1245:         seq->enable_order_hint ? seq->order_hint_bits_minus_1 + 1 : 0;",
          "1246:     if (order_hint_bits > 0)",
          "1247:         fb(order_hint_bits, order_hint);",
          "1248:     else",
          "1249:         infer(order_hint, 0);",
          "1251:     if (frame_is_intra || current->error_resilient_mode)",
          "1252:         infer(primary_ref_frame, AV1_PRIMARY_REF_NONE);",
          "1253:     else",
          "1254:         fb(3, primary_ref_frame);",
          "1256:     if (seq->decoder_model_info_present_flag) {",
          "1257:         flag(buffer_removal_time_present_flag);",
          "1258:         if (current->buffer_removal_time_present_flag) {",
          "1259:             for (i = 0; i <= seq->operating_points_cnt_minus_1; i++) {",
          "1260:                 if (seq->decoder_model_present_for_this_op[i]) {",
          "1261:                     int op_pt_idc = seq->operating_point_idc[i];",
          "1262:                     int in_temporal_layer = (op_pt_idc >>  priv->temporal_id    ) & 1;",
          "1263:                     int in_spatial_layer  = (op_pt_idc >> (priv->spatial_id + 8)) & 1;",
          "1264:                     if (seq->operating_point_idc[i] == 0 ||",
          "1265:                         in_temporal_layer || in_spatial_layer) {",
          "1266:                         fbs(seq->decoder_model_info.buffer_removal_time_length_minus_1 + 1,",
          "1267:                             buffer_removal_time[i], 1, i);",
          "1268:                     }",
          "1269:                 }",
          "1270:             }",
          "1271:         }",
          "1272:     }",
          "1274:     if (current->frame_type == AV1_FRAME_SWITCH ||",
          "1275:         (current->frame_type == AV1_FRAME_KEY && current->show_frame))",
          "1276:         infer(refresh_frame_flags, all_frames);",
          "1277:     else",
          "1278:         fb(8, refresh_frame_flags);",
          "1280:     if (!frame_is_intra || current->refresh_frame_flags != all_frames) {",
          "1281:         if (current->error_resilient_mode && seq->enable_order_hint) {",
          "1282:             for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {",
          "1283:                 fbs(order_hint_bits, ref_order_hint[i], 1, i);",
          "1284:                 if (current->ref_order_hint[i] != priv->ref[i].order_hint)",
          "1285:                     priv->ref[i].valid = 0;",
          "1286:             }",
          "1287:         }",
          "1288:     }",
          "1290:     if (current->frame_type == AV1_FRAME_KEY ||",
          "1291:         current->frame_type == AV1_FRAME_INTRA_ONLY) {",
          "1292:         CHECK(FUNC(frame_size)(ctx, rw, current));",
          "1293:         CHECK(FUNC(render_size)(ctx, rw, current));",
          "1295:         if (current->allow_screen_content_tools &&",
          "1296:             priv->upscaled_width == priv->frame_width)",
          "1297:             flag(allow_intrabc);",
          "1298:         else",
          "1299:             infer(allow_intrabc, 0);",
          "1301:     } else {",
          "1302:         if (!seq->enable_order_hint) {",
          "1303:             infer(frame_refs_short_signaling, 0);",
          "1304:         } else {",
          "1305:             flag(frame_refs_short_signaling);",
          "1306:             if (current->frame_refs_short_signaling) {",
          "1307:                 fb(3, last_frame_idx);",
          "1308:                 fb(3, golden_frame_idx);",
          "1310:                 for (i = 0; i < AV1_REFS_PER_FRAME; i++) {",
          "1311:                     if (i == 0)",
          "1312:                         infer(ref_frame_idx[i], current->last_frame_idx);",
          "1313:                     else if (i == AV1_REF_FRAME_GOLDEN -",
          "1314:                                   AV1_REF_FRAME_LAST)",
          "1315:                         infer(ref_frame_idx[i], current->golden_frame_idx);",
          "1316:                     else",
          "1317:                         infer(ref_frame_idx[i], -1);",
          "1318:                 }",
          "1319:             }",
          "1320:         }",
          "1322:         for (i = 0; i < AV1_REFS_PER_FRAME; i++) {",
          "1323:             if (!current->frame_refs_short_signaling)",
          "1324:                 fbs(3, ref_frame_idx[i], 1, i);",
          "1325:             if (seq->frame_id_numbers_present_flag) {",
          "1326:                 fb(seq->delta_frame_id_length_minus_2 + 2,",
          "1327:                    delta_frame_id_minus1);",
          "1328:             }",
          "1329:         }",
          "1331:         if (current->frame_size_override_flag &&",
          "1332:             !current->error_resilient_mode) {",
          "1333:             CHECK(FUNC(frame_size_with_refs)(ctx, rw, current));",
          "1334:         } else {",
          "1335:             CHECK(FUNC(frame_size)(ctx, rw, current));",
          "1336:             CHECK(FUNC(render_size)(ctx, rw, current));",
          "1337:         }",
          "1339:         if (current->force_integer_mv)",
          "1340:             infer(allow_high_precision_mv, 0);",
          "1341:         else",
          "1342:             flag(allow_high_precision_mv);",
          "1344:         CHECK(FUNC(interpolation_filter)(ctx, rw, current));",
          "1346:         flag(is_motion_mode_switchable);",
          "1348:         if (current->error_resilient_mode ||",
          "1349:             !seq->enable_ref_frame_mvs)",
          "1350:             infer(use_ref_frame_mvs, 0);",
          "1351:         else",
          "1352:             flag(use_ref_frame_mvs);",
          "1354:         infer(allow_intrabc, 0);",
          "1355:     }",
          "1357:     if (!frame_is_intra) {",
          "1359:     }",
          "1361:     if (seq->reduced_still_picture_header || current->disable_cdf_update)",
          "1362:         infer(disable_frame_end_update_cdf, 1);",
          "1363:     else",
          "1364:         flag(disable_frame_end_update_cdf);",
          "1366:     if (current->primary_ref_frame == AV1_PRIMARY_REF_NONE) {",
          "1369:     } else {",
          "1372:     }",
          "1374:     if (current->use_ref_frame_mvs) {",
          "1376:     }",
          "1378:     CHECK(FUNC(tile_info)(ctx, rw, current));",
          "1380:     CHECK(FUNC(quantization_params)(ctx, rw, current));",
          "1382:     CHECK(FUNC(segmentation_params)(ctx, rw, current));",
          "1384:     CHECK(FUNC(delta_q_params)(ctx, rw, current));",
          "1386:     CHECK(FUNC(delta_lf_params)(ctx, rw, current));",
          "1390:     priv->coded_lossless = 1;",
          "1391:     for (i = 0; i < AV1_MAX_SEGMENTS; i++) {",
          "1392:         int qindex;",
          "1393:         if (current->feature_enabled[i][AV1_SEG_LVL_ALT_Q]) {",
          "1394:             qindex = (current->base_q_idx +",
          "1395:                       current->feature_value[i][AV1_SEG_LVL_ALT_Q]);",
          "1396:         } else {",
          "1397:             qindex = current->base_q_idx;",
          "1398:         }",
          "1399:         qindex = av_clip_uintp2(qindex, 8);",
          "1401:         if (qindex                || current->delta_q_y_dc ||",
          "1402:             current->delta_q_u_ac || current->delta_q_u_dc ||",
          "1403:             current->delta_q_v_ac || current->delta_q_v_dc) {",
          "1404:             priv->coded_lossless = 0;",
          "1405:         }",
          "1406:     }",
          "1407:     priv->all_lossless = priv->coded_lossless &&",
          "1408:         priv->frame_width == priv->upscaled_width;",
          "1410:     CHECK(FUNC(loop_filter_params)(ctx, rw, current));",
          "1412:     CHECK(FUNC(cdef_params)(ctx, rw, current));",
          "1414:     CHECK(FUNC(lr_params)(ctx, rw, current));",
          "1416:     CHECK(FUNC(read_tx_mode)(ctx, rw, current));",
          "1418:     CHECK(FUNC(frame_reference_mode)(ctx, rw, current));",
          "1420:     CHECK(FUNC(skip_mode_params)(ctx, rw, current));",
          "1422:     if (frame_is_intra || current->error_resilient_mode ||",
          "1423:         !seq->enable_warped_motion)",
          "1424:         infer(allow_warped_motion, 0);",
          "1425:     else",
          "1426:         flag(allow_warped_motion);",
          "1428:     flag(reduced_tx_set);",
          "1430:     CHECK(FUNC(global_motion_params)(ctx, rw, current));",
          "1432:     CHECK(FUNC(film_grain_params)(ctx, rw, current));",
          "1434:     for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {",
          "1435:         if (current->refresh_frame_flags & (1 << i)) {",
          "1436:             priv->ref[i] = (AV1ReferenceFrameState) {",
          "1437:                 .valid          = 1,",
          "1438:                 .frame_id       = current->current_frame_id,",
          "1439:                 .upscaled_width = priv->upscaled_width,",
          "1440:                 .frame_width    = priv->frame_width,",
          "1441:                 .frame_height   = priv->frame_height,",
          "1442:                 .render_width   = priv->render_width,",
          "1443:                 .render_height  = priv->render_height,",
          "1444:                 .frame_type     = current->frame_type,",
          "1445:                 .subsampling_x  = seq->color_config.subsampling_x,",
          "1446:                 .subsampling_y  = seq->color_config.subsampling_y,",
          "1447:                 .bit_depth      = priv->bit_depth,",
          "1448:                 .order_hint     = current->order_hint,",
          "1449:             };",
          "1450:         }",
          "1451:     }",
          "1453:     av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Frame %d:  size %dx%d  \"",
          "1454:            \"upscaled %d  render %dx%d  subsample %dx%d  \"",
          "1455:            \"bitdepth %d  tiles %dx%d.\\n\", current->order_hint,",
          "1456:            priv->frame_width, priv->frame_height, priv->upscaled_width,",
          "1457:            priv->render_width, priv->render_height,",
          "1458:            seq->color_config.subsampling_x + 1,",
          "1459:            seq->color_config.subsampling_y + 1, priv->bit_depth,",
          "1460:            priv->tile_rows, priv->tile_cols);",
          "1462:     return 0;",
          "1463: }",
          "1465: static int FUNC(frame_header_obu)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1466:                                   AV1RawFrameHeader *current)",
          "1467: {",
          "1468:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "1469:     int err;",
          "1471:     HEADER(\"Frame Header\");",
          "1473:     if (priv->seen_frame_header) {",
          "1475:     } else {",
          "1476:         priv->seen_frame_header = 1;",
          "1478:         CHECK(FUNC(uncompressed_header)(ctx, rw, current));",
          "1480:         if (current->show_existing_frame) {",
          "1481:             priv->seen_frame_header = 0;",
          "1482:         } else {",
          "1483:             priv->seen_frame_header = 1;",
          "1484:         }",
          "1485:     }",
          "1487:     return 0;",
          "1488: }",
          "1490: static int FUNC(tile_group_obu)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1491:                                 AV1RawTileGroup *current)",
          "1492: {",
          "1493:     CodedBitstreamAV1Context *priv = ctx->priv_data;",
          "1494:     int num_tiles, tile_bits;",
          "1495:     int err;",
          "1497:     HEADER(\"Tile Group\");",
          "1499:     num_tiles = priv->tile_cols * priv->tile_rows;",
          "1500:     if (num_tiles > 1)",
          "1501:         flag(tile_start_and_end_present_flag);",
          "1502:     else",
          "1503:         infer(tile_start_and_end_present_flag, 0);",
          "1505:     if (num_tiles == 1 || !current->tile_start_and_end_present_flag) {",
          "1506:         infer(tg_start, 0);",
          "1507:         infer(tg_end, num_tiles - 1);",
          "1508:     } else {",
          "1509:         tile_bits = cbs_av1_tile_log2(1, priv->tile_cols) +",
          "1510:                     cbs_av1_tile_log2(1, priv->tile_rows);",
          "1511:         fb(tile_bits, tg_start);",
          "1512:         fb(tile_bits, tg_end);",
          "1513:     }",
          "1515:     CHECK(FUNC(byte_alignment)(ctx, rw));",
          "1518:     if (current->tg_end == num_tiles - 1)",
          "1519:         priv->seen_frame_header = 0;",
          "1523:     return 0;",
          "1524: }",
          "1526: static int FUNC(frame_obu)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1527:                            AV1RawFrame *current)",
          "1528: {",
          "1529:     int err;",
          "1531:     CHECK(FUNC(frame_header_obu)(ctx, rw, &current->header));",
          "1533:     CHECK(FUNC(byte_alignment)(ctx, rw));",
          "1535:     CHECK(FUNC(tile_group_obu)(ctx, rw, &current->tile_group));",
          "1537:     return 0;",
          "1538: }",
          "1540: static int FUNC(tile_list_obu)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1541:                                AV1RawTileList *current)",
          "1542: {",
          "1543:     int err;",
          "1545:     fb(8, output_frame_width_in_tiles_minus_1);",
          "1546:     fb(8, output_frame_height_in_tiles_minus_1);",
          "1548:     fb(16, tile_count_minus_1);",
          "1552:     return 0;",
          "1553: }",
          "1555: static int FUNC(metadata_hdr_cll)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1556:                                   AV1RawMetadataHDRCLL *current)",
          "1557: {",
          "1558:     int err;",
          "1560:     fb(16, max_cll);",
          "1561:     fb(16, max_fall);",
          "1563:     return 0;",
          "1564: }",
          "1566: static int FUNC(metadata_hdr_mdcv)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1567:                                    AV1RawMetadataHDRMDCV *current)",
          "1568: {",
          "1569:     int err, i;",
          "1571:     for (i = 0; i < 3; i++) {",
          "1572:         fcs(16, primary_chromaticity_x[i], 0, 50000, 1, i);",
          "1573:         fcs(16, primary_chromaticity_y[i], 0, 50000, 1, i);",
          "1574:     }",
          "1576:     fc(16, white_point_chromaticity_x, 0, 50000);",
          "1577:     fc(16, white_point_chromaticity_y, 0, 50000);",
          "1579:     fc(32, luminance_max, 1, MAX_UINT_BITS(32));",
          "1580:     fc(32, luminance_min, 0, current->luminance_max >> 6);",
          "1582:     return 0;",
          "1583: }",
          "1585: static int FUNC(metadata_scalability)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1586:                                       AV1RawMetadataScalability *current)",
          "1587: {",
          "1590:     return AVERROR_PATCHWELCOME;",
          "1591: }",
          "1593: static int FUNC(metadata_itut_t35)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1594:                                    AV1RawMetadataITUTT35 *current)",
          "1595: {",
          "1596:     int err;",
          "1597:     size_t i;",
          "1599:     fb(8, itu_t_t35_country_code);",
          "1600:     if (current->itu_t_t35_country_code == 0xff)",
          "1601:         fb(8, itu_t_t35_country_code_extension_byte);",
          "1603: #ifdef READ",
          "1606:     {",
          "1607:         GetBitContext tmp = *rw;",
          "1608:         current->payload_size = 0;",
          "1609:         for (i = 0; get_bits_left(rw) >= 8; i++) {",
          "1610:             if (get_bits(rw, 8))",
          "1611:                 current->payload_size = i;",
          "1612:         }",
          "1614:     }",
          "1616:     current->payload_ref = av_buffer_alloc(current->payload_size);",
          "1617:     if (!current->payload_ref)",
          "1618:         return AVERROR(ENOMEM);",
          "1619:     current->payload = current->payload_ref->data;",
          "1620: #endif",
          "1622:     for (i = 0; i < current->payload_size; i++)",
          "1623:         xf(8, itu_t_t35_payload_bytes[i], current->payload[i],",
          "1624:            0x00, 0xff, 1, i);",
          "1626:     return 0;",
          "1627: }",
          "1629: static int FUNC(metadata_timecode)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1630:                                    AV1RawMetadataTimecode *current)",
          "1631: {",
          "1632:     int err;",
          "1634:     fb(5, counting_type);",
          "1635:     flag(full_timestamp_flag);",
          "1636:     flag(discontinuity_flag);",
          "1637:     flag(cnt_dropped_flag);",
          "1638:     fb(9, n_frames);",
          "1640:     if (current->full_timestamp_flag) {",
          "1641:         fb(6, seconds_value);",
          "1642:         fb(6, minutes_value);",
          "1643:         fb(5, hours_value);",
          "1644:     } else {",
          "1645:         flag(seconds_flag);",
          "1646:         if (current->seconds_flag) {",
          "1647:             fb(6, seconds_value);",
          "1648:             flag(minutes_flag);",
          "1649:             if (current->minutes_flag) {",
          "1650:                 fb(6, minutes_value);",
          "1651:                 flag(hours_flag);",
          "1652:                 if (current->hours_flag)",
          "1653:                     fb(5, hours_value);",
          "1654:             }",
          "1655:         }",
          "1656:     }",
          "1658:     fb(5, time_offset_length);",
          "1659:     if (current->time_offset_length > 0)",
          "1660:         fb(current->time_offset_length, time_offset_value);",
          "1662:     return 0;",
          "1663: }",
          "1665: static int FUNC(metadata_obu)(CodedBitstreamContext *ctx, RWContext *rw,",
          "1666:                               AV1RawMetadata *current)",
          "1667: {",
          "1668:     int err;",
          "1670:     leb128(metadata_type);",
          "1672:     switch (current->metadata_type) {",
          "1673:     case AV1_METADATA_TYPE_HDR_CLL:",
          "1674:         CHECK(FUNC(metadata_hdr_cll)(ctx, rw, &current->metadata.hdr_cll));",
          "1675:         break;",
          "1676:     case AV1_METADATA_TYPE_HDR_MDCV:",
          "1677:         CHECK(FUNC(metadata_hdr_mdcv)(ctx, rw, &current->metadata.hdr_mdcv));",
          "1678:         break;",
          "1679:     case AV1_METADATA_TYPE_SCALABILITY:",
          "1680:         CHECK(FUNC(metadata_scalability)(ctx, rw, &current->metadata.scalability));",
          "1681:         break;",
          "1682:     case AV1_METADATA_TYPE_ITUT_T35:",
          "1683:         CHECK(FUNC(metadata_itut_t35)(ctx, rw, &current->metadata.itut_t35));",
          "1684:         break;",
          "1685:     case AV1_METADATA_TYPE_TIMECODE:",
          "1686:         CHECK(FUNC(metadata_timecode)(ctx, rw, &current->metadata.timecode));",
          "1687:         break;",
          "1688:     default:",
          "1690:         return AVERROR_PATCHWELCOME;",
          "1691:     }",
          "1693:     return 0;",
          "1694: }",
          "",
          "---------------"
        ],
        "libavcodec/cbs_internal.h||libavcodec/cbs_internal.h": [
          "File: libavcodec/cbs_internal.h -> libavcodec/cbs_internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: #define MAX_UINT_BITS(length) ((UINT64_C(1) << (length)) - 1)",
          "89: extern const CodedBitstreamType ff_cbs_type_h264;",
          "90: extern const CodedBitstreamType ff_cbs_type_h265;",
          "91: extern const CodedBitstreamType ff_cbs_type_jpeg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89: extern const CodedBitstreamType ff_cbs_type_av1;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
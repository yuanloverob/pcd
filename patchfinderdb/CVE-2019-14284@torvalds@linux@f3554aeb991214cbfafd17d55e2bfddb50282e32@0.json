{
  "cve_id": "CVE-2019-14284",
  "cve_desc": "In the Linux kernel before 5.2.3, drivers/block/floppy.c allows a denial of service by setup_format_params division-by-zero. Two consecutive ioctls can trigger the bug: the first one should set the drive geometry with .sect and .rate values that make F_SECT_PER_TRACK be zero. Next, the floppy format operation should be called. It can be triggered by an unprivileged local user even when a floppy disk has not been inserted. NOTE: QEMU creates the floppy device by default.",
  "repo": "torvalds/linux",
  "patch_hash": "f3554aeb991214cbfafd17d55e2bfddb50282e32",
  "patch_info": {
    "commit_hash": "f3554aeb991214cbfafd17d55e2bfddb50282e32",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f3554aeb991214cbfafd17d55e2bfddb50282e32",
    "files": [
      "drivers/block/floppy.c"
    ],
    "message": "floppy: fix div-by-zero in setup_format_params\n\nThis fixes a divide by zero error in the setup_format_params function of\nthe floppy driver.\n\nTwo consecutive ioctls can trigger the bug: The first one should set the\ndrive geometry with such .sect and .rate values for the F_SECT_PER_TRACK\nto become zero.  Next, the floppy format operation should be called.\n\nA floppy disk is not required to be inserted.  An unprivileged user\ncould trigger the bug if the device is accessible.\n\nThe patch checks F_SECT_PER_TRACK for a non-zero value in the\nset_geometry function.  The proper check should involve a reasonable\nupper limit for the .sect and .rate fields, but it could change the\nUAPI.\n\nThe patch also checks F_SECT_PER_TRACK in the setup_format_params, and\ncancels the formatting operation in case of zero.\n\nThe bug was found by syzkaller.\n\nSigned-off-by: Denis Efremov <efremov@ispras.ru>\nTested-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "drivers/block/floppy.c||drivers/block/floppy.c"
    ]
  },
  "patch_diff": {
    "drivers/block/floppy.c||drivers/block/floppy.c": [
      "File: drivers/block/floppy.c -> drivers/block/floppy.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2120:  raw_cmd->kernel_data = floppy_track_buffer;",
      "2121:  raw_cmd->length = 4 * F_SECT_PER_TRACK;",
      "2124:  head_shift = (F_SECT_PER_TRACK + 5) / 6;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2123:  if (!F_SECT_PER_TRACK)",
      "2124:   return;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3233:  if (g->sect <= 0 ||",
      "3234:      g->head <= 0 ||",
      "3235:      g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||",
      "3237:      (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3239:      (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "76dabe79605bebce6f34ca65c0e42e411e4ccb7b",
      "candidate_info": {
        "commit_hash": "76dabe79605bebce6f34ca65c0e42e411e4ccb7b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/76dabe79605bebce6f34ca65c0e42e411e4ccb7b",
        "files": [
          "drivers/block/floppy.c"
        ],
        "message": "floppy: cleanup: expand the R/W / format command macros\n\nVarious macros were used to access raw_cmd for R/W or format commands\nwithout making it obvious that raw_cmd->cmd[] was used. Let's expand\nthe macros to make this more obvious.\n\nLink: https://lore.kernel.org/r/20200224212352.8640-10-w@1wt.eu\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Denis Efremov <efremov@linux.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/block/floppy.c||drivers/block/floppy.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/block/floppy.c||drivers/block/floppy.c"
          ],
          "candidate": [
            "drivers/block/floppy.c||drivers/block/floppy.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/block/floppy.c||drivers/block/floppy.c": [
          "File: drivers/block/floppy.c -> drivers/block/floppy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "309: #define PH_HEAD(floppy, head) (((((floppy)->stretch & 2) >> 1) ^ head) << 2)",
          "310: #define STRETCH(floppy) ((floppy)->stretch & FD_STRETCH)",
          "322: #define NR_RW 9",
          "329: #define NR_F 6",
          "",
          "[Removed Lines]",
          "313: #define COMMAND  (raw_cmd->cmd[0])",
          "314: #define DR_SELECT (raw_cmd->cmd[1])",
          "315: #define TRACK  (raw_cmd->cmd[2])",
          "316: #define HEAD  (raw_cmd->cmd[3])",
          "317: #define SECTOR  (raw_cmd->cmd[4])",
          "318: #define SIZECODE (raw_cmd->cmd[5])",
          "319: #define SECT_PER_TRACK (raw_cmd->cmd[6])",
          "320: #define GAP  (raw_cmd->cmd[7])",
          "321: #define SIZECODE2 (raw_cmd->cmd[8])",
          "325: #define F_SIZECODE (raw_cmd->cmd[2])",
          "326: #define F_SECT_PER_TRACK (raw_cmd->cmd[3])",
          "327: #define F_GAP  (raw_cmd->cmd[4])",
          "328: #define F_FILL  (raw_cmd->cmd[5])",
          "",
          "[Added Lines]",
          "313: #define COMMAND   0",
          "314: #define DR_SELECT  1",
          "315: #define TRACK   2",
          "316: #define HEAD   3",
          "317: #define SECTOR   4",
          "318: #define SIZECODE  5",
          "319: #define SECT_PER_TRACK  6",
          "320: #define GAP   7",
          "321: #define SIZECODE2  8",
          "325: #define F_SIZECODE  2",
          "326: #define F_SECT_PER_TRACK 3",
          "327: #define F_GAP   4",
          "328: #define F_FILL   5",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2124:      FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);",
          "2125:  raw_cmd->rate = _floppy->rate & 0x43;",
          "2126:  raw_cmd->cmd_count = NR_F;",
          "2134:  raw_cmd->kernel_data = floppy_track_buffer;",
          "2138:   return;",
          "2144:  track_shift = 2 * head_shift + 3;",
          "2147:  n = (track_shift * format_req.track + head_shift * format_req.head)",
          "2151:  il = 1;",
          "",
          "[Removed Lines]",
          "2127:  COMMAND = FM_MODE(_floppy, FD_FORMAT);",
          "2128:  DR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);",
          "2129:  F_SIZECODE = FD_SIZECODE(_floppy);",
          "2130:  F_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;",
          "2131:  F_GAP = _floppy->fmt_gap;",
          "2132:  F_FILL = FD_FILL_BYTE;",
          "2135:  raw_cmd->length = 4 * F_SECT_PER_TRACK;",
          "2137:  if (!F_SECT_PER_TRACK)",
          "2141:  head_shift = (F_SECT_PER_TRACK + 5) / 6;",
          "2148:      % F_SECT_PER_TRACK;",
          "",
          "[Added Lines]",
          "2127:  raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_FORMAT);",
          "2128:  raw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);",
          "2129:  raw_cmd->cmd[F_SIZECODE] = FD_SIZECODE(_floppy);",
          "2130:  raw_cmd->cmd[F_SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[F_SIZECODE];",
          "2131:  raw_cmd->cmd[F_GAP] = _floppy->fmt_gap;",
          "2132:  raw_cmd->cmd[F_FILL] = FD_FILL_BYTE;",
          "2135:  raw_cmd->length = 4 * raw_cmd->cmd[F_SECT_PER_TRACK];",
          "2137:  if (!raw_cmd->cmd[F_SECT_PER_TRACK])",
          "2141:  head_shift = (raw_cmd->cmd[F_SECT_PER_TRACK] + 5) / 6;",
          "2148:      % raw_cmd->cmd[F_SECT_PER_TRACK];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2153:   il++;",
          "2157:   here[count].track = format_req.track;",
          "2158:   here[count].head = format_req.head;",
          "2159:   here[count].sect = 0;",
          "2161:  }",
          "2164:   here[n].sect = count;",
          "2167:    ++n;",
          "2170:     while (here[n].sect)",
          "2171:      ++n;",
          "2172:    }",
          "2173:   }",
          "2174:  }",
          "2175:  if (_floppy->stretch & FD_SECTBASEMASK) {",
          "2177:    here[count].sect += FD_SECTBASE(_floppy) - 1;",
          "2178:  }",
          "2179: }",
          "",
          "[Removed Lines]",
          "2156:  for (count = 0; count < F_SECT_PER_TRACK; ++count) {",
          "2160:   here[count].size = F_SIZECODE;",
          "2163:  for (count = 1; count <= F_SECT_PER_TRACK; ++count) {",
          "2165:   n = (n + il) % F_SECT_PER_TRACK;",
          "2168:    if (n >= F_SECT_PER_TRACK) {",
          "2169:     n -= F_SECT_PER_TRACK;",
          "2176:   for (count = 0; count < F_SECT_PER_TRACK; count++)",
          "",
          "[Added Lines]",
          "2156:  for (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {",
          "2160:   here[count].size = raw_cmd->cmd[F_SIZECODE];",
          "2163:  for (count = 1; count <= raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {",
          "2165:   n = (n + il) % raw_cmd->cmd[F_SECT_PER_TRACK];",
          "2168:    if (n >= raw_cmd->cmd[F_SECT_PER_TRACK]) {",
          "2169:     n -= raw_cmd->cmd[F_SECT_PER_TRACK];",
          "2176:   for (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; count++)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2303:   drive_state[current_drive].first_read_date = jiffies;",
          "2305:  nr_sectors = 0;",
          "2308:  if (ST1 & ST1_EOC)",
          "2309:   eoc = 1;",
          "2310:  else",
          "2311:   eoc = 0;",
          "2314:   heads = 2;",
          "2315:  else",
          "2316:   heads = 1;",
          "2322:  if (nr_sectors / ssize >",
          "2323:      DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {",
          "2324:   DPRINT(\"long rw: %x instead of %lx\\n\",",
          "2325:          nr_sectors, current_count_sectors);",
          "2329:   pr_info(\"heads=%d eoc=%d\\n\", heads, eoc);",
          "2330:   pr_info(\"spt=%d st=%d ss=%d\\n\",",
          "2332:   pr_info(\"in_sector_offset=%d\\n\", in_sector_offset);",
          "2333:  }",
          "",
          "[Removed Lines]",
          "2306:  ssize = DIV_ROUND_UP(1 << SIZECODE, 4);",
          "2313:  if (COMMAND & 0x80)",
          "2318:  nr_sectors = (((R_TRACK - TRACK) * heads +",
          "2319:          R_HEAD - HEAD) * SECT_PER_TRACK +",
          "2320:         R_SECTOR - SECTOR + eoc) << SIZECODE >> 2;",
          "2326:   pr_info(\"rs=%d s=%d\\n\", R_SECTOR, SECTOR);",
          "2327:   pr_info(\"rh=%d h=%d\\n\", R_HEAD, HEAD);",
          "2328:   pr_info(\"rt=%d t=%d\\n\", R_TRACK, TRACK);",
          "2331:    SECT_PER_TRACK, fsector_t, ssize);",
          "",
          "[Added Lines]",
          "2306:  ssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);",
          "2313:  if (raw_cmd->cmd[COMMAND] & 0x80)",
          "2318:  nr_sectors = (((R_TRACK - raw_cmd->cmd[TRACK]) * heads +",
          "2319:          R_HEAD - raw_cmd->cmd[HEAD]) * raw_cmd->cmd[SECT_PER_TRACK] +",
          "2320:         R_SECTOR - raw_cmd->cmd[SECTOR] + eoc) << raw_cmd->cmd[SIZECODE] >> 2;",
          "2326:   pr_info(\"rs=%d s=%d\\n\", R_SECTOR, raw_cmd->cmd[SECTOR]);",
          "2327:   pr_info(\"rh=%d h=%d\\n\", R_HEAD, raw_cmd->cmd[HEAD]);",
          "2328:   pr_info(\"rt=%d t=%d\\n\", R_TRACK, raw_cmd->cmd[TRACK]);",
          "2331:    raw_cmd->cmd[SECT_PER_TRACK], fsector_t, ssize);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2366:   probing = 0;",
          "2367:  }",
          "2370:      raw_cmd->kernel_data == bio_data(current_req->bio)) {",
          "2372:   cont->done(1);",
          "2374:   buffer_track = raw_cmd->track;",
          "2375:   buffer_drive = current_drive;",
          "2376:   INFBOUND(buffer_max, nr_sectors + fsector_t);",
          "",
          "[Removed Lines]",
          "2369:  if (CT(COMMAND) != FD_READ ||",
          "2373:  } else if (CT(COMMAND) == FD_READ) {",
          "",
          "[Added Lines]",
          "2369:  if (CT(raw_cmd->cmd[COMMAND]) != FD_READ ||",
          "2373:  } else if (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2429:        min(max_sector, max_sector_2),",
          "2430:        blk_rq_sectors(current_req));",
          "2433:      buffer_max > fsector_t + blk_rq_sectors(current_req))",
          "2434:   current_count_sectors = min_t(int, buffer_max - fsector_t,",
          "2435:            blk_rq_sectors(current_req));",
          "2437:  remaining = current_count_sectors << 9;",
          "2439:   DPRINT(\"in copy buffer\\n\");",
          "2440:   pr_info(\"current_count_sectors=%ld\\n\", current_count_sectors);",
          "2441:   pr_info(\"remaining=%d\\n\", remaining >> 9);",
          "",
          "[Removed Lines]",
          "2432:  if (current_count_sectors <= 0 && CT(COMMAND) == FD_WRITE &&",
          "2438:  if (remaining > blk_rq_bytes(current_req) && CT(COMMAND) == FD_WRITE) {",
          "",
          "[Added Lines]",
          "2432:  if (current_count_sectors <= 0 && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&",
          "2438:  if (remaining > blk_rq_bytes(current_req) && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2470:     fsector_t, buffer_min);",
          "2471:    pr_info(\"current_count_sectors=%ld\\n\",",
          "2472:     current_count_sectors);",
          "2474:     pr_info(\"read\\n\");",
          "2476:     pr_info(\"write\\n\");",
          "2477:    break;",
          "2478:   }",
          "2479:   if (((unsigned long)buffer) % 512)",
          "2480:    DPRINT(\"%p buffer not aligned\\n\", buffer);",
          "2483:    memcpy(buffer, dma_buffer, size);",
          "2484:   else",
          "2485:    memcpy(dma_buffer, buffer, size);",
          "",
          "[Removed Lines]",
          "2473:    if (CT(COMMAND) == FD_READ)",
          "2475:    if (CT(COMMAND) == FD_WRITE)",
          "2482:   if (CT(COMMAND) == FD_READ)",
          "",
          "[Added Lines]",
          "2473:    if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)",
          "2475:    if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)",
          "2482:   if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2506:  int hard_sectors;",
          "2507:  int end_sector;",
          "2515:    pr_info(\"too many sectors %d > %d\\n\",",
          "2517:    return;",
          "2518:   }",
          "2522:  }",
          "2523: }",
          "",
          "[Removed Lines]",
          "2509:  if (CT(COMMAND) == FD_WRITE) {",
          "2512:   hard_sectors = raw_cmd->length >> (7 + SIZECODE);",
          "2513:   end_sector = SECTOR + hard_sectors - 1;",
          "2514:   if (end_sector > SECT_PER_TRACK) {",
          "2516:     end_sector, SECT_PER_TRACK);",
          "2519:   SECT_PER_TRACK = end_sector;",
          "",
          "[Added Lines]",
          "2509:  if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {",
          "2512:   hard_sectors = raw_cmd->length >> (7 + raw_cmd->cmd[SIZECODE]);",
          "2513:   end_sector = raw_cmd->cmd[SECTOR] + hard_sectors - 1;",
          "2514:   if (end_sector > raw_cmd->cmd[SECT_PER_TRACK]) {",
          "2516:     end_sector, raw_cmd->cmd[SECT_PER_TRACK]);",
          "2519:   raw_cmd->cmd[SECT_PER_TRACK] = end_sector;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2550:  raw_cmd->cmd_count = NR_RW;",
          "2551:  if (rq_data_dir(current_req) == READ) {",
          "2552:   raw_cmd->flags |= FD_RAW_READ;",
          "2554:  } else if (rq_data_dir(current_req) == WRITE) {",
          "2555:   raw_cmd->flags |= FD_RAW_WRITE;",
          "2557:  } else {",
          "2558:   DPRINT(\"%s: unknown command\\n\", __func__);",
          "2559:   return 0;",
          "",
          "[Removed Lines]",
          "2553:   COMMAND = FM_MODE(_floppy, FD_READ);",
          "2556:   COMMAND = FM_MODE(_floppy, FD_WRITE);",
          "",
          "[Added Lines]",
          "2553:   raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);",
          "2556:   raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_WRITE);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2562:  max_sector = _floppy->sect * _floppy->head;",
          "2565:  fsector_t = (int)blk_rq_pos(current_req) % max_sector;",
          "2567:   if (blk_rq_cur_sectors(current_req) & 1) {",
          "2568:    current_count_sectors = 1;",
          "2569:    return 1;",
          "2570:   } else",
          "2571:    return 0;",
          "2572:  }",
          "2575:  if (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||",
          "2576:       test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags)) &&",
          "",
          "[Removed Lines]",
          "2564:  TRACK = (int)blk_rq_pos(current_req) / max_sector;",
          "2566:  if (_floppy->track && TRACK >= _floppy->track) {",
          "2573:  HEAD = fsector_t / _floppy->sect;",
          "",
          "[Added Lines]",
          "2564:  raw_cmd->cmd[TRACK] = (int)blk_rq_pos(current_req) / max_sector;",
          "2566:  if (_floppy->track && raw_cmd->cmd[TRACK] >= _floppy->track) {",
          "2573:  raw_cmd->cmd[HEAD] = fsector_t / _floppy->sect;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2578:   max_sector = _floppy->sect;",
          "2582:   max_sector = 2 * _floppy->sect / 3;",
          "2583:   if (fsector_t >= max_sector) {",
          "2584:    current_count_sectors =",
          "",
          "[Removed Lines]",
          "2581:  if ((_floppy->rate & FD_2M) && (!TRACK) && (!HEAD)) {",
          "",
          "[Added Lines]",
          "2581:  if ((_floppy->rate & FD_2M) && (!raw_cmd->cmd[TRACK]) && (!raw_cmd->cmd[HEAD])) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2586:       blk_rq_sectors(current_req));",
          "2587:    return 1;",
          "2588:   }",
          "2590:  } else",
          "2592:  raw_cmd->rate = _floppy->rate & 0x43;",
          "2594:   raw_cmd->rate = 1;",
          "2598:  else",
          "2606:      FD_SECTBASE(_floppy);",
          "",
          "[Removed Lines]",
          "2589:   SIZECODE = 2;",
          "2591:   SIZECODE = FD_SIZECODE(_floppy);",
          "2593:  if ((_floppy->rate & FD_2M) && (TRACK || HEAD) && raw_cmd->rate == 2)",
          "2596:  if (SIZECODE)",
          "2597:   SIZECODE2 = 0xff;",
          "2599:   SIZECODE2 = 0x80;",
          "2600:  raw_cmd->track = TRACK << STRETCH(_floppy);",
          "2601:  DR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, HEAD);",
          "2602:  GAP = _floppy->gap;",
          "2603:  ssize = DIV_ROUND_UP(1 << SIZECODE, 4);",
          "2604:  SECT_PER_TRACK = _floppy->sect << 2 >> SIZECODE;",
          "2605:  SECTOR = ((fsector_t % _floppy->sect) << 2 >> SIZECODE) +",
          "",
          "[Added Lines]",
          "2589:   raw_cmd->cmd[SIZECODE] = 2;",
          "2591:   raw_cmd->cmd[SIZECODE] = FD_SIZECODE(_floppy);",
          "2593:  if ((_floppy->rate & FD_2M) &&",
          "2594:      (raw_cmd->cmd[TRACK] || raw_cmd->cmd[HEAD]) && raw_cmd->rate == 2)",
          "2597:  if (raw_cmd->cmd[SIZECODE])",
          "2598:   raw_cmd->cmd[SIZECODE2] = 0xff;",
          "2600:   raw_cmd->cmd[SIZECODE2] = 0x80;",
          "2601:  raw_cmd->track = raw_cmd->cmd[TRACK] << STRETCH(_floppy);",
          "2602:  raw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, raw_cmd->cmd[HEAD]);",
          "2603:  raw_cmd->cmd[GAP] = _floppy->gap;",
          "2604:  ssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);",
          "2605:  raw_cmd->cmd[SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[SIZECODE];",
          "2606:  raw_cmd->cmd[SECTOR] = ((fsector_t % _floppy->sect) << 2 >> raw_cmd->cmd[SIZECODE]) +",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2611:  tracksize = _floppy->sect - _floppy->sect % ssize;",
          "2612:  if (tracksize < _floppy->sect) {",
          "2614:   if (tracksize <= fsector_t % _floppy->sect)",
          "2618:   while (tracksize <= fsector_t % _floppy->sect) {",
          "2619:    while (tracksize + ssize > _floppy->sect) {",
          "2621:     ssize >>= 1;",
          "2622:    }",
          "2625:    tracksize += ssize;",
          "2626:   }",
          "2629:   max_sector = _floppy->sect;",
          "2632:   max_sector = _floppy->sect;",
          "2633:  }",
          "",
          "[Removed Lines]",
          "2613:   SECT_PER_TRACK++;",
          "2615:    SECTOR--;",
          "2620:     SIZECODE--;",
          "2623:    SECTOR++;",
          "2624:    SECT_PER_TRACK++;",
          "2627:   max_sector = HEAD * _floppy->sect + tracksize;",
          "2628:  } else if (!TRACK && !HEAD && !(_floppy->rate & FD_2M) && probing) {",
          "2630:  } else if (!HEAD && CT(COMMAND) == FD_WRITE) {",
          "",
          "[Added Lines]",
          "2614:   raw_cmd->cmd[SECT_PER_TRACK]++;",
          "2616:    raw_cmd->cmd[SECTOR]--;",
          "2621:     raw_cmd->cmd[SIZECODE]--;",
          "2624:    raw_cmd->cmd[SECTOR]++;",
          "2625:    raw_cmd->cmd[SECT_PER_TRACK]++;",
          "2628:   max_sector = raw_cmd->cmd[HEAD] * _floppy->sect + tracksize;",
          "2629:  } else if (!raw_cmd->cmd[TRACK] && !raw_cmd->cmd[HEAD] && !(_floppy->rate & FD_2M) && probing) {",
          "2631:  } else if (!raw_cmd->cmd[HEAD] && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2639:      (current_drive == buffer_drive) &&",
          "2640:      (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {",
          "2643:    copy_buffer(1, max_sector, buffer_max);",
          "2644:    return 1;",
          "2645:   }",
          "2646:  } else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {",
          "2648:    unsigned int sectors;",
          "2650:    sectors = fsector_t + blk_rq_sectors(current_req);",
          "",
          "[Removed Lines]",
          "2642:   if (CT(COMMAND) == FD_READ) {",
          "2647:   if (CT(COMMAND) == FD_WRITE) {",
          "",
          "[Added Lines]",
          "2643:   if (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {",
          "2648:   if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2655:   }",
          "2656:   raw_cmd->flags &= ~FD_RAW_WRITE;",
          "2657:   raw_cmd->flags |= FD_RAW_READ;",
          "2659:  } else if ((unsigned long)bio_data(current_req->bio) < MAX_DMA_ADDRESS) {",
          "2660:   unsigned long dma_limit;",
          "2661:   int direct, indirect;",
          "",
          "[Removed Lines]",
          "2658:   COMMAND = FM_MODE(_floppy, FD_READ);",
          "",
          "[Added Lines]",
          "2659:   raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2706:   }",
          "2707:  }",
          "",
          "[Removed Lines]",
          "2709:  if (CT(COMMAND) == FD_READ)",
          "",
          "[Added Lines]",
          "2710:  if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2715:      fsector_t > buffer_max ||",
          "2716:      fsector_t < buffer_min ||",
          "2718:        (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&",
          "2719:       max_sector > 2 * max_buffer_sectors + buffer_min &&",
          "2720:       max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {",
          "",
          "[Removed Lines]",
          "2717:      ((CT(COMMAND) == FD_READ ||",
          "",
          "[Added Lines]",
          "2718:      ((CT(raw_cmd->cmd[COMMAND]) == FD_READ ||",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2726:  raw_cmd->kernel_data = floppy_track_buffer +",
          "2727:   ((aligned_sector_t - buffer_min) << 9);",
          "",
          "[Removed Lines]",
          "2729:  if (CT(COMMAND) == FD_WRITE) {",
          "",
          "[Added Lines]",
          "2730:  if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2748:  raw_cmd->length <<= 9;",
          "2749:  if ((raw_cmd->length < current_count_sectors << 9) ||",
          "2750:      (raw_cmd->kernel_data != bio_data(current_req->bio) &&",
          "2752:       (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||",
          "2753:        aligned_sector_t < buffer_min)) ||",
          "2755:      raw_cmd->length <= 0 || current_count_sectors <= 0) {",
          "2756:   DPRINT(\"fractionary current count b=%lx s=%lx\\n\",",
          "2757:          raw_cmd->length, current_count_sectors);",
          "",
          "[Removed Lines]",
          "2751:       CT(COMMAND) == FD_WRITE &&",
          "2754:      raw_cmd->length % (128 << SIZECODE) ||",
          "",
          "[Added Lines]",
          "2752:       CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&",
          "2755:      raw_cmd->length % (128 << raw_cmd->cmd[SIZECODE]) ||",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2762:     current_count_sectors);",
          "2763:   pr_info(\"st=%d ast=%d mse=%d msi=%d\\n\",",
          "2764:    fsector_t, aligned_sector_t, max_sector, max_size);",
          "2766:   pr_info(\"command=%x SECTOR=%d HEAD=%d, TRACK=%d\\n\",",
          "2768:   pr_info(\"buffer drive=%d\\n\", buffer_drive);",
          "2769:   pr_info(\"buffer track=%d\\n\", buffer_track);",
          "2770:   pr_info(\"buffer_min=%d\\n\", buffer_min);",
          "",
          "[Removed Lines]",
          "2765:   pr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, SIZECODE);",
          "2767:    COMMAND, SECTOR, HEAD, TRACK);",
          "",
          "[Added Lines]",
          "2766:   pr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, raw_cmd->cmd[SIZECODE]);",
          "2768:    raw_cmd->cmd[COMMAND], raw_cmd->cmd[SECTOR],",
          "2769:    raw_cmd->cmd[HEAD], raw_cmd->cmd[TRACK]);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2783:     fsector_t, buffer_min, raw_cmd->length >> 9);",
          "2784:    pr_info(\"current_count_sectors=%ld\\n\",",
          "2785:     current_count_sectors);",
          "2787:     pr_info(\"read\\n\");",
          "2789:     pr_info(\"write\\n\");",
          "2790:    return 0;",
          "2791:   }",
          "",
          "[Removed Lines]",
          "2786:    if (CT(COMMAND) == FD_READ)",
          "2788:    if (CT(COMMAND) == FD_WRITE)",
          "",
          "[Added Lines]",
          "2788:    if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)",
          "2790:    if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-9914",
  "cve_desc": "Race condition in the ip4_datagram_release_cb function in net/ipv4/datagram.c in the Linux kernel before 3.15.2 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect expectations about locking during multithreaded access to internal data structures for IPv4 UDP sockets.",
  "repo": "torvalds/linux",
  "patch_hash": "9709674e68646cee5a24e3000b3558d25412203a",
  "patch_info": {
    "commit_hash": "9709674e68646cee5a24e3000b3558d25412203a",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/9709674e68646cee5a24e3000b3558d25412203a",
    "files": [
      "net/ipv4/datagram.c"
    ],
    "message": "ipv4: fix a race in ip4_datagram_release_cb()\n\nAlexey gave a AddressSanitizer[1] report that finally gave a good hint\nat where was the origin of various problems already reported by Dormando\nin the past [2]\n\nProblem comes from the fact that UDP can have a lockless TX path, and\nconcurrent threads can manipulate sk_dst_cache, while another thread,\nis holding socket lock and calls __sk_dst_set() in\nip4_datagram_release_cb() (this was added in linux-3.8)\n\nIt seems that all we need to do is to use sk_dst_check() and\nsk_dst_set() so that all the writers hold same spinlock\n(sk->sk_dst_lock) to prevent corruptions.\n\nTCP stack do not need this protection, as all sk_dst_cache writers hold\nthe socket lock.\n\n[1]\nhttps://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel\n\nAddressSanitizer: heap-use-after-free in ipv4_dst_check\nRead of size 2 by thread T15453:\n [<ffffffff817daa3a>] ipv4_dst_check+0x1a/0x90 ./net/ipv4/route.c:1116\n [<ffffffff8175b789>] __sk_dst_check+0x89/0xe0 ./net/core/sock.c:531\n [<ffffffff81830a36>] ip4_datagram_release_cb+0x46/0x390 ??:0\n [<ffffffff8175eaea>] release_sock+0x17a/0x230 ./net/core/sock.c:2413\n [<ffffffff81830882>] ip4_datagram_connect+0x462/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nFreed by thread T15455:\n [<ffffffff8178d9b8>] dst_destroy+0xa8/0x160 ./net/core/dst.c:251\n [<ffffffff8178de25>] dst_release+0x45/0x80 ./net/core/dst.c:280\n [<ffffffff818304c1>] ip4_datagram_connect+0xa1/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nAllocated by thread T15453:\n [<ffffffff8178d291>] dst_alloc+0x81/0x2b0 ./net/core/dst.c:171\n [<ffffffff817db3b7>] rt_dst_alloc+0x47/0x50 ./net/ipv4/route.c:1406\n [<     inlined    >] __ip_route_output_key+0x3e8/0xf70\n__mkroute_output ./net/ipv4/route.c:1939\n [<ffffffff817dde08>] __ip_route_output_key+0x3e8/0xf70 ./net/ipv4/route.c:2161\n [<ffffffff817deb34>] ip_route_output_flow+0x14/0x30 ./net/ipv4/route.c:2249\n [<ffffffff81830737>] ip4_datagram_connect+0x317/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\n[2]\n<4>[196727.311203] general protection fault: 0000 [#1] SMP\n<4>[196727.311224] Modules linked in: xt_TEE xt_dscp xt_DSCP macvlan bridge coretemp crc32_pclmul ghash_clmulni_intel gpio_ich microcode ipmi_watchdog ipmi_devintf sb_edac edac_core lpc_ich mfd_core tpm_tis tpm tpm_bios ipmi_si ipmi_msghandler isci igb libsas i2c_algo_bit ixgbe ptp pps_core mdio\n<4>[196727.311333] CPU: 17 PID: 0 Comm: swapper/17 Not tainted 3.10.26 #1\n<4>[196727.311344] Hardware name: Supermicro X9DRi-LN4+/X9DR3-LN4+/X9DRi-LN4+/X9DR3-LN4+, BIOS 3.0 07/05/2013\n<4>[196727.311364] task: ffff885e6f069700 ti: ffff885e6f072000 task.ti: ffff885e6f072000\n<4>[196727.311377] RIP: 0010:[<ffffffff815f8c7f>]  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.311399] RSP: 0018:ffff885effd23a70  EFLAGS: 00010282\n<4>[196727.311409] RAX: dead000000200200 RBX: ffff8854c398ecc0 RCX: 0000000000000040\n<4>[196727.311423] RDX: dead000000100100 RSI: dead000000100100 RDI: dead000000200200\n<4>[196727.311437] RBP: ffff885effd23a80 R08: ffffffff815fd9e0 R09: ffff885d5a590800\n<4>[196727.311451] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n<4>[196727.311464] R13: ffffffff81c8c280 R14: 0000000000000000 R15: ffff880e85ee16ce\n<4>[196727.311510] FS:  0000000000000000(0000) GS:ffff885effd20000(0000) knlGS:0000000000000000\n<4>[196727.311554] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4>[196727.311581] CR2: 00007a46751eb000 CR3: 0000005e65688000 CR4: 00000000000407e0\n<4>[196727.311625] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n<4>[196727.311669] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n<4>[196727.311713] Stack:\n<4>[196727.311733]  ffff8854c398ecc0 ffff8854c398ecc0 ffff885effd23ab0 ffffffff815b7f42\n<4>[196727.311784]  ffff88be6595bc00 ffff8854c398ecc0 0000000000000000 ffff8854c398ecc0\n<4>[196727.311834]  ffff885effd23ad0 ffffffff815b86c6 ffff885d5a590800 ffff8816827821c0\n<4>[196727.311885] Call Trace:\n<4>[196727.311907]  <IRQ>\n<4>[196727.311912]  [<ffffffff815b7f42>] dst_destroy+0x32/0xe0\n<4>[196727.311959]  [<ffffffff815b86c6>] dst_release+0x56/0x80\n<4>[196727.311986]  [<ffffffff81620bd5>] tcp_v4_do_rcv+0x2a5/0x4a0\n<4>[196727.312013]  [<ffffffff81622b5a>] tcp_v4_rcv+0x7da/0x820\n<4>[196727.312041]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312070]  [<ffffffff815de02d>] ? nf_hook_slow+0x7d/0x150\n<4>[196727.312097]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312125]  [<ffffffff815fda92>] ip_local_deliver_finish+0xb2/0x230\n<4>[196727.312154]  [<ffffffff815fdd9a>] ip_local_deliver+0x4a/0x90\n<4>[196727.312183]  [<ffffffff815fd799>] ip_rcv_finish+0x119/0x360\n<4>[196727.312212]  [<ffffffff815fe00b>] ip_rcv+0x22b/0x340\n<4>[196727.312242]  [<ffffffffa0339680>] ? macvlan_broadcast+0x160/0x160 [macvlan]\n<4>[196727.312275]  [<ffffffff815b0c62>] __netif_receive_skb_core+0x512/0x640\n<4>[196727.312308]  [<ffffffff811427fb>] ? kmem_cache_alloc+0x13b/0x150\n<4>[196727.312338]  [<ffffffff815b0db1>] __netif_receive_skb+0x21/0x70\n<4>[196727.312368]  [<ffffffff815b0fa1>] netif_receive_skb+0x31/0xa0\n<4>[196727.312397]  [<ffffffff815b1ae8>] napi_gro_receive+0xe8/0x140\n<4>[196727.312433]  [<ffffffffa00274f1>] ixgbe_poll+0x551/0x11f0 [ixgbe]\n<4>[196727.312463]  [<ffffffff815fe00b>] ? ip_rcv+0x22b/0x340\n<4>[196727.312491]  [<ffffffff815b1691>] net_rx_action+0x111/0x210\n<4>[196727.312521]  [<ffffffff815b0db1>] ? __netif_receive_skb+0x21/0x70\n<4>[196727.312552]  [<ffffffff810519d0>] __do_softirq+0xd0/0x270\n<4>[196727.312583]  [<ffffffff816cef3c>] call_softirq+0x1c/0x30\n<4>[196727.312613]  [<ffffffff81004205>] do_softirq+0x55/0x90\n<4>[196727.312640]  [<ffffffff81051c85>] irq_exit+0x55/0x60\n<4>[196727.312668]  [<ffffffff816cf5c3>] do_IRQ+0x63/0xe0\n<4>[196727.312696]  [<ffffffff816c5aaa>] common_interrupt+0x6a/0x6a\n<4>[196727.312722]  <EOI>\n<1>[196727.313071] RIP  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.313100]  RSP <ffff885effd23a70>\n<4>[196727.313377] ---[ end trace 64b3f14fae0f2e29 ]---\n<0>[196727.380908] Kernel panic - not syncing: Fatal exception in interrupt\n\nReported-by: Alexey Preobrazhensky <preobr@google.com>\nReported-by: dormando <dormando@rydia.ne>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nFixes: 8141ed9fcedb2 (\"ipv4: Add a socket release callback for datagram sockets\")\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv4/datagram.c||net/ipv4/datagram.c"
    ]
  },
  "patch_diff": {
    "net/ipv4/datagram.c||net/ipv4/datagram.c": [
      "File: net/ipv4/datagram.c -> net/ipv4/datagram.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "86: }",
      "87: EXPORT_SYMBOL(ip4_datagram_connect);",
      "89: void ip4_datagram_release_cb(struct sock *sk)",
      "90: {",
      "91:  const struct inet_sock *inet = inet_sk(sk);",
      "92:  const struct ip_options_rcu *inet_opt;",
      "93:  __be32 daddr = inet->inet_daddr;",
      "94:  struct flowi4 fl4;",
      "95:  struct rtable *rt;",
      "100:  rcu_read_lock();",
      "101:  inet_opt = rcu_dereference(inet->inet_opt);",
      "102:  if (inet_opt && inet_opt->opt.srr)",
      "103:   daddr = inet_opt->opt.faddr;",
      "",
      "[Removed Lines]",
      "97:  if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))",
      "98:   return;",
      "",
      "[Added Lines]",
      "98:  struct dst_entry *dst;",
      "104:  dst = __sk_dst_get(sk);",
      "105:  if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {",
      "106:   rcu_read_unlock();",
      "107:   return;",
      "108:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:        inet->inet_saddr, inet->inet_dport,",
      "106:        inet->inet_sport, sk->sk_protocol,",
      "107:        RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);",
      "110:  rcu_read_unlock();",
      "111: }",
      "112: EXPORT_SYMBOL_GPL(ip4_datagram_release_cb);",
      "",
      "[Removed Lines]",
      "108:  if (!IS_ERR(rt))",
      "109:   __sk_dst_set(sk, &rt->dst);",
      "",
      "[Added Lines]",
      "117:  dst = !IS_ERR(rt) ? &rt->dst : NULL;",
      "118:  sk_dst_set(sk, dst);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "60e1751cb52cc6d1ae04b6bd3c2b96e770b5823f",
      "candidate_info": {
        "commit_hash": "60e1751cb52cc6d1ae04b6bd3c2b96e770b5823f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/60e1751cb52cc6d1ae04b6bd3c2b96e770b5823f",
        "files": [
          "drivers/infiniband/core/user_mad.c"
        ],
        "message": "IB/umad: Fix use-after-free on close\n\nAvoid that closing /dev/infiniband/umad<n> or /dev/infiniband/issm<n>\ntriggers a use-after-free.  __fput() invokes f_op->release() before it\ninvokes cdev_put().  Make sure that the ib_umad_device structure is\nfreed by the cdev_put() call instead of f_op->release().  This avoids\nthat changing the port mode from IB into Ethernet and back to IB\nfollowed by restarting opensmd triggers the following kernel oops:\n\n    general protection fault: 0000 [#1] PREEMPT SMP\n    RIP: 0010:[<ffffffff810cc65c>]  [<ffffffff810cc65c>] module_put+0x2c/0x170\n    Call Trace:\n     [<ffffffff81190f20>] cdev_put+0x20/0x30\n     [<ffffffff8118e2ce>] __fput+0x1ae/0x1f0\n     [<ffffffff8118e35e>] ____fput+0xe/0x10\n     [<ffffffff810723bc>] task_work_run+0xac/0xe0\n     [<ffffffff81002a9f>] do_notify_resume+0x9f/0xc0\n     [<ffffffff814b8398>] int_signal+0x12/0x17\n\nReference: https://bugzilla.kernel.org/show_bug.cgi?id=75051\nSigned-off-by: Bart Van Assche <bvanassche@acm.org>\nReviewed-by: Yann Droneaud <ydroneaud@opteya.com>\nCc: <stable@vger.kernel.org> # 3.x: 8ec0a0e6b58: IB/umad: Fix error handling\nSigned-off-by: Roland Dreier <roland@purestorage.com>",
        "before_after_code_files": [
          "drivers/infiniband/core/user_mad.c||drivers/infiniband/core/user_mad.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/infiniband/core/user_mad.c||drivers/infiniband/core/user_mad.c": [
          "File: drivers/infiniband/core/user_mad.c -> drivers/infiniband/core/user_mad.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: struct ib_umad_device {",
          "100:  int                  start_port, end_port;",
          "102:  struct ib_umad_port  port[0];",
          "103: };",
          "",
          "[Removed Lines]",
          "101:  struct kref          ref;",
          "",
          "[Added Lines]",
          "101:  struct kobject       kobj;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134: static void ib_umad_add_one(struct ib_device *device);",
          "135: static void ib_umad_remove_one(struct ib_device *device);",
          "138: {",
          "139:  struct ib_umad_device *dev =",
          "142:  kfree(dev);",
          "143: }",
          "145: static int hdr_size(struct ib_umad_file *file)",
          "146: {",
          "147:  return file->use_pkey_index ? sizeof (struct ib_user_mad_hdr) :",
          "",
          "[Removed Lines]",
          "137: static void ib_umad_release_dev(struct kref *ref)",
          "140:   container_of(ref, struct ib_umad_device, ref);",
          "",
          "[Added Lines]",
          "137: static void ib_umad_release_dev(struct kobject *kobj)",
          "140:   container_of(kobj, struct ib_umad_device, kobj);",
          "145: static struct kobj_type ib_umad_dev_ktype = {",
          "146:  .release = ib_umad_release_dev,",
          "147: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "812:   goto out;",
          "813:  }",
          "817: out:",
          "818:  mutex_unlock(&port->file_mutex);",
          "",
          "[Removed Lines]",
          "815:  kref_get(&port->umad_dev->ref);",
          "",
          "[Added Lines]",
          "819:  kobject_get(&port->umad_dev->kobj);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "851:  mutex_unlock(&file->port->file_mutex);",
          "853:  kfree(file);",
          "856:  return 0;",
          "857: }",
          "",
          "[Removed Lines]",
          "854:  kref_put(&dev->ref, ib_umad_release_dev);",
          "",
          "[Added Lines]",
          "858:  kobject_put(&dev->kobj);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "902:  if (ret)",
          "903:   goto err_clr_sm_cap;",
          "907:  return 0;",
          "",
          "[Removed Lines]",
          "905:  kref_get(&port->umad_dev->ref);",
          "",
          "[Added Lines]",
          "909:  kobject_get(&port->umad_dev->kobj);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "933:  up(&port->sm_sem);",
          "937:  return ret;",
          "938: }",
          "",
          "[Removed Lines]",
          "935:  kref_put(&port->umad_dev->ref, ib_umad_release_dev);",
          "",
          "[Added Lines]",
          "939:  kobject_put(&port->umad_dev->kobj);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1000: }",
          "1002: static int ib_umad_init_port(struct ib_device *device, int port_num,",
          "1003:         struct ib_umad_port *port)",
          "1004: {",
          "1005:  int devnum;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1007:         struct ib_umad_device *umad_dev,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1033:  cdev_init(&port->cdev, &umad_fops);",
          "1034:  port->cdev.owner = THIS_MODULE;",
          "1035:  kobject_set_name(&port->cdev.kobj, \"umad%d\", port->dev_num);",
          "1036:  if (cdev_add(&port->cdev, base, 1))",
          "1037:   goto err_cdev;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1040:  port->cdev.kobj.parent = &umad_dev->kobj;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1050:  base += IB_UMAD_MAX_PORTS;",
          "1051:  cdev_init(&port->sm_cdev, &umad_sm_fops);",
          "1052:  port->sm_cdev.owner = THIS_MODULE;",
          "1053:  kobject_set_name(&port->sm_cdev.kobj, \"issm%d\", port->dev_num);",
          "1054:  if (cdev_add(&port->sm_cdev, base, 1))",
          "1055:   goto err_sm_cdev;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1059:  port->sm_cdev.kobj.parent = &umad_dev->kobj;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1143:  if (!umad_dev)",
          "1144:   return;",
          "1148:  umad_dev->start_port = s;",
          "1149:  umad_dev->end_port   = e;",
          "",
          "[Removed Lines]",
          "1146:  kref_init(&umad_dev->ref);",
          "",
          "[Added Lines]",
          "1153:  kobject_init(&umad_dev->kobj, &ib_umad_dev_ktype);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1151:  for (i = s; i <= e; ++i) {",
          "1152:   umad_dev->port[i - s].umad_dev = umad_dev;",
          "1155:    goto err;",
          "1156:  }",
          "",
          "[Removed Lines]",
          "1154:   if (ib_umad_init_port(device, i, &umad_dev->port[i - s]))",
          "",
          "[Added Lines]",
          "1161:   if (ib_umad_init_port(device, i, umad_dev,",
          "1162:           &umad_dev->port[i - s]))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1163:  while (--i >= s)",
          "1164:   ib_umad_kill_port(&umad_dev->port[i - s]);",
          "1167: }",
          "1169: static void ib_umad_remove_one(struct ib_device *device)",
          "",
          "[Removed Lines]",
          "1166:  kref_put(&umad_dev->ref, ib_umad_release_dev);",
          "",
          "[Added Lines]",
          "1174:  kobject_put(&umad_dev->kobj);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1177:  for (i = 0; i <= umad_dev->end_port - umad_dev->start_port; ++i)",
          "1178:   ib_umad_kill_port(&umad_dev->port[i]);",
          "1181: }",
          "1183: static char *umad_devnode(struct device *dev, umode_t *mode)",
          "",
          "[Removed Lines]",
          "1180:  kref_put(&umad_dev->ref, ib_umad_release_dev);",
          "",
          "[Added Lines]",
          "1188:  kobject_put(&umad_dev->kobj);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61391d562229ed94899ed4b4973dc2f0c015292a",
      "candidate_info": {
        "commit_hash": "61391d562229ed94899ed4b4973dc2f0c015292a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/61391d562229ed94899ed4b4973dc2f0c015292a",
        "files": [
          "fs/btrfs/extent_io.c"
        ],
        "message": "Btrfs: fix hang on error (such as ENOSPC) when writing extent pages\n\nWhen running low on available disk space and having several processes\ndoing buffered file IO, I got the following trace in dmesg:\n\n[ 4202.720152] INFO: task kworker/u8:1:5450 blocked for more than 120 seconds.\n[ 4202.720401]       Not tainted 3.13.0-fdm-btrfs-next-26+ #1\n[ 4202.720596] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n[ 4202.720874] kworker/u8:1    D 0000000000000001     0  5450      2 0x00000000\n[ 4202.720904] Workqueue: btrfs-flush_delalloc normal_work_helper [btrfs]\n[ 4202.720908]  ffff8801f62ddc38 0000000000000082 ffff880203ac2490 00000000001d3f40\n[ 4202.720913]  ffff8801f62ddfd8 00000000001d3f40 ffff8800c4f0c920 ffff880203ac2490\n[ 4202.720918]  00000000001d4a40 ffff88020fe85a40 ffff88020fe85ab8 0000000000000001\n[ 4202.720922] Call Trace:\n[ 4202.720931]  [<ffffffff816a3cb9>] schedule+0x29/0x70\n[ 4202.720950]  [<ffffffffa01ec48d>] btrfs_start_ordered_extent+0x6d/0x110 [btrfs]\n[ 4202.720956]  [<ffffffff8108e620>] ? bit_waitqueue+0xc0/0xc0\n[ 4202.720972]  [<ffffffffa01ec559>] btrfs_run_ordered_extent_work+0x29/0x40 [btrfs]\n[ 4202.720988]  [<ffffffffa0201987>] normal_work_helper+0x137/0x2c0 [btrfs]\n[ 4202.720994]  [<ffffffff810680e5>] process_one_work+0x1f5/0x530\n(...)\n[ 4202.721027] 2 locks held by kworker/u8:1/5450:\n[ 4202.721028]  #0:  (%s-%s){++++..}, at: [<ffffffff81068083>] process_one_work+0x193/0x530\n[ 4202.721037]  #1:  ((&work->normal_work)){+.+...}, at: [<ffffffff81068083>] process_one_work+0x193/0x530\n[ 4202.721054] INFO: task btrfs:7891 blocked for more than 120 seconds.\n[ 4202.721258]       Not tainted 3.13.0-fdm-btrfs-next-26+ #1\n[ 4202.721444] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n[ 4202.721699] btrfs           D 0000000000000001     0  7891   7890 0x00000001\n[ 4202.721704]  ffff88018c2119e8 0000000000000086 ffff8800a33d2490 00000000001d3f40\n[ 4202.721710]  ffff88018c211fd8 00000000001d3f40 ffff8802144b0000 ffff8800a33d2490\n[ 4202.721714]  ffff8800d8576640 ffff88020fe85bc0 ffff88020fe85bc8 7fffffffffffffff\n[ 4202.721718] Call Trace:\n[ 4202.721723]  [<ffffffff816a3cb9>] schedule+0x29/0x70\n[ 4202.721727]  [<ffffffff816a2ebc>] schedule_timeout+0x1dc/0x270\n[ 4202.721732]  [<ffffffff8109bd79>] ? mark_held_locks+0xb9/0x140\n[ 4202.721736]  [<ffffffff816a90c0>] ? _raw_spin_unlock_irq+0x30/0x40\n[ 4202.721740]  [<ffffffff8109bf0d>] ? trace_hardirqs_on_caller+0x10d/0x1d0\n[ 4202.721744]  [<ffffffff816a488f>] wait_for_completion+0xdf/0x120\n[ 4202.721749]  [<ffffffff8107fa90>] ? try_to_wake_up+0x310/0x310\n[ 4202.721765]  [<ffffffffa01ebee4>] btrfs_wait_ordered_extents+0x1f4/0x280 [btrfs]\n[ 4202.721781]  [<ffffffffa020526e>] btrfs_mksubvol.isra.62+0x30e/0x5a0 [btrfs]\n[ 4202.721786]  [<ffffffff8108e620>] ? bit_waitqueue+0xc0/0xc0\n[ 4202.721799]  [<ffffffffa02056a9>] btrfs_ioctl_snap_create_transid+0x1a9/0x1b0 [btrfs]\n[ 4202.721813]  [<ffffffffa020583a>] btrfs_ioctl_snap_create_v2+0x10a/0x170 [btrfs]\n(...)\n\nIt turns out that extent_io.c:__extent_writepage(), which ends up being called\nthrough filemap_fdatawrite_range() in btrfs_start_ordered_extent(), was getting\n-ENOSPC when calling the fill_delalloc callback. In this situation, it returned\nwithout the writepage_end_io_hook callback (inode.c:btrfs_writepage_end_io_hook)\never being called for the respective page, which prevents the ordered extent's\nbytes_left count from ever reaching 0, and therefore a finish_ordered_fn work\nis never queued into the endio_write_workers queue. This makes the task that\ncalled btrfs_start_ordered_extent() hang forever on the wait queue of the ordered\nextent.\n\nThis is fairly easy to reproduce using a small filesystem and fsstress on\na quad core vm:\n\n    mkfs.btrfs -f -b `expr 2100 \\* 1024 \\* 1024` /dev/sdd\n    mount /dev/sdd /mnt\n\n    fsstress -p 6 -d /mnt -n 100000 -x \\\n        \"btrfs subvolume snapshot -r /mnt /mnt/mysnap\" \\\n\t    -f allocsp=0 \\\n\t    -f bulkstat=0 \\\n\t    -f bulkstat1=0 \\\n\t    -f chown=0 \\\n\t    -f creat=1 \\\n\t    -f dread=0 \\\n\t    -f dwrite=0 \\\n\t    -f fallocate=1 \\\n\t    -f fdatasync=0 \\\n\t    -f fiemap=0 \\\n\t    -f freesp=0 \\\n\t    -f fsync=0 \\\n\t    -f getattr=0 \\\n\t    -f getdents=0 \\\n\t    -f link=0 \\\n\t    -f mkdir=0 \\\n\t    -f mknod=0 \\\n\t    -f punch=1 \\\n\t    -f read=0 \\\n\t    -f readlink=0 \\\n\t    -f rename=0 \\\n\t    -f resvsp=0 \\\n\t    -f rmdir=0 \\\n\t    -f setxattr=0 \\\n\t    -f stat=0 \\\n\t    -f symlink=0 \\\n\t    -f sync=0 \\\n\t    -f truncate=1 \\\n\t    -f unlink=0 \\\n\t    -f unresvsp=0 \\\n\t    -f write=4\n\nSo just ensure that if an error happens while writing the extent page\nwe call the writepage_end_io_hook callback. Also make it return the\nerror code and ensure the caller (extent_write_cache_pages) processes\nall pages in the page vector even if an error happens only for some\nof them, so that ordered extents end up released.\n\nSigned-off-by: Filipe David Borba Manana <fdmanana@gmail.com>\nSigned-off-by: Chris Mason <clm@fb.com>",
        "before_after_code_files": [
          "fs/btrfs/extent_io.c||fs/btrfs/extent_io.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/extent_io.c||fs/btrfs/extent_io.c": [
          "File: fs/btrfs/extent_io.c -> fs/btrfs/extent_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3278:          end - cur + 1, 1);",
          "3279:   if (IS_ERR_OR_NULL(em)) {",
          "3280:    SetPageError(page);",
          "3281:    break;",
          "3282:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3281:    ret = PTR_ERR_OR_ZERO(em);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3364:   set_page_writeback(page);",
          "3365:   end_page_writeback(page);",
          "3366:  }",
          "3367:  unlock_page(page);",
          "3369: done_unlocked:",
          "3372:  free_extent_state(cached_state);",
          "3374: }",
          "3376: static int eb_wait(void *word)",
          "",
          "[Removed Lines]",
          "3373:  return 0;",
          "",
          "[Added Lines]",
          "3368:  if (PageError(page)) {",
          "3369:   ret = ret < 0 ? ret : -EIO;",
          "3370:   end_extent_writepage(page, ret, start, page_end);",
          "3371:  }",
          "3378:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3690:  struct inode *inode = mapping->host;",
          "3691:  int ret = 0;",
          "3692:  int done = 0;",
          "3693:  int nr_to_write_done = 0;",
          "3694:  struct pagevec pvec;",
          "3695:  int nr_pages;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3698:  int err = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3776:     unlock_page(page);",
          "3777:     ret = 0;",
          "3778:    }",
          "",
          "[Removed Lines]",
          "3779:    if (ret)",
          "3780:     done = 1;",
          "",
          "[Added Lines]",
          "3785:    if (!err && ret < 0)",
          "3786:     err = ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3789:   pagevec_release(&pvec);",
          "3790:   cond_resched();",
          "3791:  }",
          "",
          "[Removed Lines]",
          "3792:  if (!scanned && !done) {",
          "",
          "[Added Lines]",
          "3798:  if (!scanned && !done && !err) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3799:   goto retry;",
          "3800:  }",
          "3801:  btrfs_add_delayed_iput(inode);",
          "3803: }",
          "3805: static void flush_epd_write_bio(struct extent_page_data *epd)",
          "",
          "[Removed Lines]",
          "3802:  return ret;",
          "",
          "[Added Lines]",
          "3808:  return err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0430e49b6e7c6b5e076be8fefdee089958c9adad",
      "candidate_info": {
        "commit_hash": "0430e49b6e7c6b5e076be8fefdee089958c9adad",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0430e49b6e7c6b5e076be8fefdee089958c9adad",
        "files": [
          "security/integrity/ima/ima_crypto.c"
        ],
        "message": "ima: introduce ima_kernel_read()\n\nCommit 8aac62706 \"move exit_task_namespaces() outside of exit_notify\"\nintroduced the kernel opps since the kernel v3.10, which happens when\nApparmor and IMA-appraisal are enabled at the same time.\n\n----------------------------------------------------------------------\n[  106.750167] BUG: unable to handle kernel NULL pointer dereference at\n0000000000000018\n[  106.750221] IP: [<ffffffff811ec7da>] our_mnt+0x1a/0x30\n[  106.750241] PGD 0\n[  106.750254] Oops: 0000 [#1] SMP\n[  106.750272] Modules linked in: cuse parport_pc ppdev bnep rfcomm\nbluetooth rpcsec_gss_krb5 nfsd auth_rpcgss nfs_acl nfs lockd sunrpc\nfscache dm_crypt intel_rapl x86_pkg_temp_thermal intel_powerclamp\nkvm_intel snd_hda_codec_hdmi kvm crct10dif_pclmul crc32_pclmul\nghash_clmulni_intel aesni_intel aes_x86_64 glue_helper lrw gf128mul\nablk_helper cryptd snd_hda_codec_realtek dcdbas snd_hda_intel\nsnd_hda_codec snd_hwdep snd_pcm snd_page_alloc snd_seq_midi\nsnd_seq_midi_event snd_rawmidi psmouse snd_seq microcode serio_raw\nsnd_timer snd_seq_device snd soundcore video lpc_ich coretemp mac_hid lp\nparport mei_me mei nbd hid_generic e1000e usbhid ahci ptp hid libahci\npps_core\n[  106.750658] CPU: 6 PID: 1394 Comm: mysqld Not tainted 3.13.0-rc7-kds+ #15\n[  106.750673] Hardware name: Dell Inc. OptiPlex 9010/0M9KCM, BIOS A08\n09/19/2012\n[  106.750689] task: ffff8800de804920 ti: ffff880400fca000 task.ti:\nffff880400fca000\n[  106.750704] RIP: 0010:[<ffffffff811ec7da>]  [<ffffffff811ec7da>]\nour_mnt+0x1a/0x30\n[  106.750725] RSP: 0018:ffff880400fcba60  EFLAGS: 00010286\n[  106.750738] RAX: 0000000000000000 RBX: 0000000000000100 RCX:\nffff8800d51523e7\n[  106.750764] RDX: ffffffffffffffea RSI: ffff880400fcba34 RDI:\nffff880402d20020\n[  106.750791] RBP: ffff880400fcbae0 R08: 0000000000000000 R09:\n0000000000000001\n[  106.750817] R10: 0000000000000000 R11: 0000000000000001 R12:\nffff8800d5152300\n[  106.750844] R13: ffff8803eb8df510 R14: ffff880400fcbb28 R15:\nffff8800d51523e7\n[  106.750871] FS:  0000000000000000(0000) GS:ffff88040d200000(0000)\nknlGS:0000000000000000\n[  106.750910] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  106.750935] CR2: 0000000000000018 CR3: 0000000001c0e000 CR4:\n00000000001407e0\n[  106.750962] Stack:\n[  106.750981]  ffffffff813434eb ffff880400fcbb20 ffff880400fcbb18\n0000000000000000\n[  106.751037]  ffff8800de804920 ffffffff8101b9b9 0001800000000000\n0000000000000100\n[  106.751093]  0000010000000000 0000000000000002 000000000000000e\nffff8803eb8df500\n[  106.751149] Call Trace:\n[  106.751172]  [<ffffffff813434eb>] ? aa_path_name+0x2ab/0x430\n[  106.751199]  [<ffffffff8101b9b9>] ? sched_clock+0x9/0x10\n[  106.751225]  [<ffffffff8134a68d>] aa_path_perm+0x7d/0x170\n[  106.751250]  [<ffffffff8101b945>] ? native_sched_clock+0x15/0x80\n[  106.751276]  [<ffffffff8134aa73>] aa_file_perm+0x33/0x40\n[  106.751301]  [<ffffffff81348c5e>] common_file_perm+0x8e/0xb0\n[  106.751327]  [<ffffffff81348d78>] apparmor_file_permission+0x18/0x20\n[  106.751355]  [<ffffffff8130c853>] security_file_permission+0x23/0xa0\n[  106.751382]  [<ffffffff811c77a2>] rw_verify_area+0x52/0xe0\n[  106.751407]  [<ffffffff811c789d>] vfs_read+0x6d/0x170\n[  106.751432]  [<ffffffff811cda31>] kernel_read+0x41/0x60\n[  106.751457]  [<ffffffff8134fd45>] ima_calc_file_hash+0x225/0x280\n[  106.751483]  [<ffffffff8134fb52>] ? ima_calc_file_hash+0x32/0x280\n[  106.751509]  [<ffffffff8135022d>] ima_collect_measurement+0x9d/0x160\n[  106.751536]  [<ffffffff810b552d>] ? trace_hardirqs_on+0xd/0x10\n[  106.751562]  [<ffffffff8134f07c>] ? ima_file_free+0x6c/0xd0\n[  106.751587]  [<ffffffff81352824>] ima_update_xattr+0x34/0x60\n[  106.751612]  [<ffffffff8134f0d0>] ima_file_free+0xc0/0xd0\n[  106.751637]  [<ffffffff811c9635>] __fput+0xd5/0x300\n[  106.751662]  [<ffffffff811c98ae>] ____fput+0xe/0x10\n[  106.751687]  [<ffffffff81086774>] task_work_run+0xc4/0xe0\n[  106.751712]  [<ffffffff81066fad>] do_exit+0x2bd/0xa90\n[  106.751738]  [<ffffffff8173c958>] ? retint_swapgs+0x13/0x1b\n[  106.751763]  [<ffffffff8106780c>] do_group_exit+0x4c/0xc0\n[  106.751788]  [<ffffffff81067894>] SyS_exit_group+0x14/0x20\n[  106.751814]  [<ffffffff8174522d>] system_call_fastpath+0x1a/0x1f\n[  106.751839] Code: c3 0f 1f 44 00 00 55 48 89 e5 e8 22 fe ff ff 5d c3\n0f 1f 44 00 00 55 65 48 8b 04 25 c0 c9 00 00 48 8b 80 28 06 00 00 48 89\ne5 5d <48> 8b 40 18 48 39 87 c0 00 00 00 0f 94 c0 c3 0f 1f 80 00 00 00\n[  106.752185] RIP  [<ffffffff811ec7da>] our_mnt+0x1a/0x30\n[  106.752214]  RSP <ffff880400fcba60>\n[  106.752236] CR2: 0000000000000018\n[  106.752258] ---[ end trace 3c520748b4732721 ]---\n----------------------------------------------------------------------\n\nThe reason for the oops is that IMA-appraisal uses \"kernel_read()\" when\nfile is closed. kernel_read() honors LSM security hook which calls\nApparmor handler, which uses current->nsproxy->mnt_ns. The 'guilty'\ncommit changed the order of cleanup code so that nsproxy->mnt_ns was\nnot already available for Apparmor.\n\nDiscussion about the issue with Al Viro and Eric W. Biederman suggested\nthat kernel_read() is too high-level for IMA. Another issue, except\nsecurity checking, that was identified is mandatory locking. kernel_read\nhonors it as well and it might prevent IMA from calculating necessary hash.\nIt was suggested to use simplified version of the function without security\nand locking checks.\n\nThis patch introduces special version ima_kernel_read(), which skips security\nand mandatory locking checking. It prevents the kernel oops to happen.\n\nSigned-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>\nSuggested-by: Eric W. Biederman <ebiederm@xmission.com>\nSigned-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nCc: <stable@vger.kernel.org>",
        "before_after_code_files": [
          "security/integrity/ima/ima_crypto.c||security/integrity/ima/ima_crypto.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "security/integrity/ima/ima_crypto.c||security/integrity/ima/ima_crypto.c": [
          "File: security/integrity/ima/ima_crypto.c -> security/integrity/ima/ima_crypto.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: static struct crypto_shash *ima_shash_tfm;",
          "30: int ima_init_crypto(void)",
          "31: {",
          "32:  long rc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: static int ima_kernel_read(struct file *file, loff_t offset,",
          "39:       char *addr, unsigned long count)",
          "40: {",
          "41:  mm_segment_t old_fs;",
          "42:  char __user *buf = addr;",
          "43:  ssize_t ret;",
          "45:  if (!(file->f_mode & FMODE_READ))",
          "46:   return -EBADF;",
          "47:  if (!file->f_op->read && !file->f_op->aio_read)",
          "48:   return -EINVAL;",
          "50:  old_fs = get_fs();",
          "51:  set_fs(get_ds());",
          "52:  if (file->f_op->read)",
          "53:   ret = file->f_op->read(file, buf, count, &offset);",
          "54:  else",
          "55:   ret = do_sync_read(file, buf, count, &offset);",
          "56:  set_fs(old_fs);",
          "57:  return ret;",
          "58: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104:  while (offset < i_size) {",
          "105:   int rbuf_len;",
          "108:   if (rbuf_len < 0) {",
          "109:    rc = rbuf_len;",
          "110:    break;",
          "",
          "[Removed Lines]",
          "107:   rbuf_len = kernel_read(file, offset, rbuf, PAGE_SIZE);",
          "",
          "[Added Lines]",
          "137:   rbuf_len = ima_kernel_read(file, offset, rbuf, PAGE_SIZE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dbe33fc9ad0cd965afe71cd6fca9539afd704e38",
      "candidate_info": {
        "commit_hash": "dbe33fc9ad0cd965afe71cd6fca9539afd704e38",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/dbe33fc9ad0cd965afe71cd6fca9539afd704e38",
        "files": [
          "drivers/s390/cio/cio.c"
        ],
        "message": "s390/cio: silence lockdep warning\n\nOn systems where a ccw based console device is used a lockdep false alarm\ncould be triggered when a device driver calls printk while holding a\nsubchannels lock (e.g. in it's irq handler). Since this is valid behavior\nfix this by introducing a separate lock class for the console subchannels\nlock.\n\nThe lockdep warning was revealed by \"printk: enable interrupts before calling\nconsole_trylock_for_printk()\" which changed console_unlock() to be called with\nlockdep enabled.\n\n[ INFO: possible recursive locking detected ]\n3.15.0-rc5-next-20140520 #1 Not tainted\n---------------------------------------------\nccwgroup/2239 is trying to acquire lock:\n(&(sch->lock)->rlock){-.-...}, at: [<0000000000642a52>] raw3215_write+0x52/0x200\n\nbut task is already holding lock:\n(&(sch->lock)->rlock){-.-...}, at: [<00000000005fd160>] do_cio_interrupt+0x60/0x108\n\nother info that might help us debug this:\nPossible unsafe locking scenario:\n\nCPU0\n----\nlock(&(sch->lock)->rlock);\nlock(&(sch->lock)->rlock);\n\n*** DEADLOCK ***\n\nMay be due to missing lock nesting notation\n\n8 locks held by ccwgroup/2239:\n\nstack backtrace:\nCPU: 3 PID: 2239 Comm: ccwgroup Not tainted 3.15.0-rc5-next-20140520 #1\n0000000036fab518 0000000036fab528 0000000000000002 0000000000000000\n0000000036fab5b8 0000000036fab530 0000000036fab530 00000000001116e8\n0000000000000000 0000000000986ec4 00000000009701b6 000000000000000b\n0000000036fab578 0000000036fab518 0000000000000000 0000000000000000\n0000000000000000 00000000001116e8 0000000036fab518 0000000036fab578\nCall Trace:\n([<0000000000111626>] show_trace+0x14e/0x158)\n[<000000000011169a>] show_stack+0x6a/0xe8\n[<00000000007c6e72>] dump_stack+0x82/0xb0\n[<00000000001a95f2>] validate_chain.isra.37+0xa4a/0xbb0\n[<00000000001acaca>] __lock_acquire+0x4da/0xcd0\n[<00000000001ada1a>] lock_acquire+0xba/0x218\n[<00000000007cd634>] _raw_spin_lock_irqsave+0x6c/0xb8\n[<0000000000642a52>] raw3215_write+0x52/0x200\n[<0000000000643d16>] con3215_write+0x76/0xf8\n[<00000000001bd87a>] call_console_drivers.constprop.25+0xfa/0x210\n[<00000000001be0b0>] console_unlock+0x3e0/0x4e8\n[<00000000001be450>] vprintk_emit+0x298/0x6e0\n[<00000000005aa210>] dev_vprintk_emit+0xe0/0x1a8\n[<00000000005aa320>] dev_printk_emit+0x48/0x50\n[<00000000005aa390>] __dev_printk+0x68/0xb0\n[<00000000005aa7c2>] _dev_info+0x62/0x70\n[<0000000000657bf0>] qeth_l2_send_setmac_cb+0xd0/0x190\n[<0000000000651a1e>] qeth_send_control_data_cb+0x3a6/0x6a8\n[<0000000000655546>] qeth_irq+0x1a6/0xac0\n[<000000000060a0ac>] ccw_device_call_handler+0xa4/0xc0\n[<0000000000608b62>] ccw_device_irq+0x5a/0x190\n[<00000000005fd1ca>] do_cio_interrupt+0xca/0x108\n[<00000000001c0a2e>] handle_irq_event_percpu+0x5e/0x378\n[<00000000001c46fc>] handle_percpu_irq+0x6c/0x98\n[<00000000001c0066>] generic_handle_irq+0x46/0x68\n[<000000000010b5b6>] do_IRQ+0x5e/0x88\n[<00000000007cf304>] io_call+0x6/0x20\n[<000000000064c63a>] qeth_send_control_data+0x322/0x570\n([<000000000064c50e>] qeth_send_control_data+0x1f6/0x570)\n[<0000000000651db2>] qeth_send_ipa_cmd+0x92/0x120\n[<000000000065b310>] __qeth_l2_set_online+0x170/0xaa8\n[<000000000060ebb6>] ccwgroup_set_online+0x56/0x90\n[<000000000060ef96>] ccwgroup_online_store+0xd6/0xe0\n[<000000000033d11a>] kernfs_fop_write+0x10a/0x188\n[<00000000002bbd00>] vfs_write+0x98/0x1c0\n[<00000000002bc8a0>] SyS_write+0x60/0xd0\n[<00000000007cee3a>] sysc_nr_ok+0x22/0x28\n[<000003fffd0c3f28>] 0x3fffd0c3f28\n\nReported-by: Heiko Carstens <heiko.carstens@de.ibm.com>\nSigned-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>",
        "before_after_code_files": [
          "drivers/s390/cio/cio.c||drivers/s390/cio/cio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/s390/cio/cio.c||drivers/s390/cio/cio.c": [
          "File: drivers/s390/cio/cio.c -> drivers/s390/cio/cio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "603: #ifdef CONFIG_CCW_CONSOLE",
          "604: static struct subchannel *console_sch;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "605: static struct lock_class_key console_sch_key;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "686:  if (IS_ERR(sch))",
          "687:   return sch;",
          "689:  isc_register(CONSOLE_ISC);",
          "690:  sch->config.isc = CONSOLE_ISC;",
          "691:  sch->config.intparm = (u32)(addr_t)sch;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "690:  lockdep_set_class(sch->lock, &console_sch_key);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
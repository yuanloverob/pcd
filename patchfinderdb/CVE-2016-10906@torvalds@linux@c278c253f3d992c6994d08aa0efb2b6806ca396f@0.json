{
  "cve_id": "CVE-2016-10906",
  "cve_desc": "An issue was discovered in drivers/net/ethernet/arc/emac_main.c in the Linux kernel before 4.5. A use-after-free is caused by a race condition between the functions arc_emac_tx and arc_emac_tx_clean.",
  "repo": "torvalds/linux",
  "patch_hash": "c278c253f3d992c6994d08aa0efb2b6806ca396f",
  "patch_info": {
    "commit_hash": "c278c253f3d992c6994d08aa0efb2b6806ca396f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c278c253f3d992c6994d08aa0efb2b6806ca396f",
    "files": [
      "drivers/net/ethernet/arc/emac_main.c"
    ],
    "message": "net: arc_emac: fix koops caused by sk_buff free\n\nThere is a race between arc_emac_tx() and arc_emac_tx_clean().\nsk_buff got freed by arc_emac_tx_clean() while arc_emac_tx()\nsubmitting sk_buff.\n\nIn order to free sk_buff arc_emac_tx_clean() checks:\n    if ((info & FOR_EMAC) || !txbd->data)\n        break;\n    ...\n    dev_kfree_skb_irq(skb);\n\nIf condition false, arc_emac_tx_clean() free sk_buff.\n\nIn order to submit txbd, arc_emac_tx() do:\n    priv->tx_buff[*txbd_curr].skb = skb;\n    ...\n    priv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n    ...\n    ...  <== arc_emac_tx_clean() check condition here\n    ...  <== (info & FOR_EMAC) is false\n    ...  <== !txbd->data is false\n    ...\n    *info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n\nIn order to reproduce the situation,\nrun device:\n    # iperf -s\nrun on host:\n    # iperf -t 600 -c <device-ip-addr>\n\n[   28.396284] ------------[ cut here ]------------\n[   28.400912] kernel BUG at .../net/core/skbuff.c:1355!\n[   28.414019] Internal error: Oops - BUG: 0 [#1] SMP ARM\n[   28.419150] Modules linked in:\n[   28.422219] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G    B           4.4.0+ #120\n[   28.429516] Hardware name: Rockchip (Device Tree)\n[   28.434216] task: c0665070 ti: c0660000 task.ti: c0660000\n[   28.439622] PC is at skb_put+0x10/0x54\n[   28.443381] LR is at arc_emac_poll+0x260/0x474\n[   28.447821] pc : [<c03af580>]    lr : [<c028fec4>]    psr: a0070113\n[   28.447821] sp : c0661e58  ip : eea68502  fp : ef377000\n[   28.459280] r10: 0000012c  r9 : f08b2000  r8 : eeb57100\n[   28.464498] r7 : 00000000  r6 : ef376594  r5 : 00000077  r4 : ef376000\n[   28.471015] r3 : 0030488b  r2 : ef13e880  r1 : 000005ee  r0 : eeb57100\n[   28.477534] Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n[   28.484658] Control: 10c5387d  Table: 8eaf004a  DAC: 00000051\n[   28.490396] Process swapper/0 (pid: 0, stack limit = 0xc0660210)\n[   28.496393] Stack: (0xc0661e58 to 0xc0662000)\n[   28.500745] 1e40:                                                       00000002 00000000\n[   28.508913] 1e60: 00000000 ef376520 00000028 f08b23b8 00000000 ef376520 ef7b6900 c028fc64\n[   28.517082] 1e80: 2f158000 c0661ea8 c0661eb0 0000012c c065e900 c03bdeac ffff95e9 c0662100\n[   28.525250] 1ea0: c0663924 00000028 c0661ea8 c0661ea8 c0661eb0 c0661eb0 0000001e c0660000\n[   28.533417] 1ec0: 40000003 00000008 c0695a00 0000000a c066208c 00000100 c0661ee0 c0027410\n[   28.541584] 1ee0: ef0fb700 2f158000 00200000 ffff95e8 00000004 c0662100 c0662080 00000003\n[   28.549751] 1f00: 00000000 00000000 00000000 c065b45c 0000001e ef005000 c0647a30 00000000\n[   28.557919] 1f20: 00000000 c0027798 00000000 c005cf40 f0802100 c0662ffc c0661f60 f0803100\n[   28.566088] 1f40: c0661fb8 c00093bc c000ffb4 60070013 ffffffff c0661f94 c0661fb8 c00137d4\n[   28.574267] 1f60: 00000001 00000000 00000000 c001ffa0 00000000 c0660000 00000000 c065a364\n[   28.582441] 1f80: c0661fb8 c0647a30 00000000 00000000 00000000 c0661fb0 c000ffb0 c000ffb4\n[   28.590608] 1fa0: 60070013 ffffffff 00000051 00000000 00000000 c005496c c0662400 c061bc40\n[   28.598776] 1fc0: ffffffff ffffffff 00000000 c061b680 00000000 c0647a30 00000000 c0695294\n[   28.606943] 1fe0: c0662488 c0647a2c c066619c 6000406a 413fc090 6000807c 00000000 00000000\n[   28.615127] [<c03af580>] (skb_put) from [<ef376520>] (0xef376520)\n[   28.621218] Code: e5902054 e590c090 e3520000 0a000000 (e7f001f2)\n[   28.627307] ---[ end trace 4824734e2243fdb6 ]---\n\n[   34.377068] Internal error: Oops: 17 [#1] SMP ARM\n[   34.382854] Modules linked in:\n[   34.385947] CPU: 0 PID: 3 Comm: ksoftirqd/0 Not tainted 4.4.0+ #120\n[   34.392219] Hardware name: Rockchip (Device Tree)\n[   34.396937] task: ef02d040 ti: ef05c000 task.ti: ef05c000\n[   34.402376] PC is at __dev_kfree_skb_irq+0x4/0x80\n[   34.407121] LR is at arc_emac_poll+0x130/0x474\n[   34.411583] pc : [<c03bb640>]    lr : [<c028fd94>]    psr: 60030013\n[   34.411583] sp : ef05de68  ip : 0008e83c  fp : ef377000\n[   34.423062] r10: c001bec4  r9 : 00000000  r8 : f08b24c8\n[   34.428296] r7 : f08b2400  r6 : 00000075  r5 : 00000019  r4 : ef376000\n[   34.434827] r3 : 00060000  r2 : 00000042  r1 : 00000001  r0 : 00000000\n[   34.441365] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n[   34.448507] Control: 10c5387d  Table: 8f25c04a  DAC: 00000051\n[   34.454262] Process ksoftirqd/0 (pid: 3, stack limit = 0xef05c210)\n[   34.460449] Stack: (0xef05de68 to 0xef05e000)\n[   34.464827] de60:                   ef376000 c028fd94 00000000 c0669480 c0669480 ef376520\n[   34.473022] de80: 00000028 00000001 00002ae4 ef376520 ef7b6900 c028fc64 2f158000 ef05dec0\n[   34.481215] dea0: ef05dec8 0000012c c065e900 c03bdeac ffff983f c0662100 c0663924 00000028\n[   34.489409] dec0: ef05dec0 ef05dec0 ef05dec8 ef05dec8 ef7b6000 ef05c000 40000003 00000008\n[   34.497600] dee0: c0695a00 0000000a c066208c 00000100 ef05def8 c0027410 ef7b6000 40000000\n[   34.505795] df00: 04208040 ffff983e 00000004 c0662100 c0662080 00000003 ef05c000 ef027340\n[   34.513985] df20: ef05c000 c0666c2c 00000000 00000001 00000002 00000000 00000000 c0027568\n[   34.522176] df40: ef027340 c003ef48 ef027300 00000000 ef027340 c003edd4 00000000 00000000\n[   34.530367] df60: 00000000 c003c37c ffffff7f 00000001 00000000 ef027340 00000000 00030003\n[   34.538559] df80: ef05df80 ef05df80 00000000 00000000 ef05df90 ef05df90 ef05dfac ef027300\n[   34.546750] dfa0: c003c2a4 00000000 00000000 c000f578 00000000 00000000 00000000 00000000\n[   34.554939] dfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n[   34.563129] dfe0: 00000000 00000000 00000000 00000000 00000013 00000000 ffffffff dfff7fff\n[   34.571360] [<c03bb640>] (__dev_kfree_skb_irq) from [<c028fd94>] (arc_emac_poll+0x130/0x474)\n[   34.579840] [<c028fd94>] (arc_emac_poll) from [<c03bdeac>] (net_rx_action+0xdc/0x28c)\n[   34.587712] [<c03bdeac>] (net_rx_action) from [<c0027410>] (__do_softirq+0xcc/0x1f8)\n[   34.595482] [<c0027410>] (__do_softirq) from [<c0027568>] (run_ksoftirqd+0x2c/0x50)\n[   34.603168] [<c0027568>] (run_ksoftirqd) from [<c003ef48>] (smpboot_thread_fn+0x174/0x18c)\n[   34.611466] [<c003ef48>] (smpboot_thread_fn) from [<c003c37c>] (kthread+0xd8/0xec)\n[   34.619075] [<c003c37c>] (kthread) from [<c000f578>] (ret_from_fork+0x14/0x3c)\n[   34.626317] Code: e8bd8010 e3a00000 e12fff1e e92d4010 (e59030a4)\n[   34.632572] ---[ end trace cca5a3d86a82249a ]---\n\nSigned-off-by: Alexander Kochetkov <al.kochet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "drivers/net/ethernet/arc/emac_main.c||drivers/net/ethernet/arc/emac_main.c"
    ]
  },
  "patch_diff": {
    "drivers/net/ethernet/arc/emac_main.c||drivers/net/ethernet/arc/emac_main.c": [
      "File: drivers/net/ethernet/arc/emac_main.c -> drivers/net/ethernet/arc/emac_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "163:   struct sk_buff *skb = tx_buff->skb;",
      "164:   unsigned int info = le32_to_cpu(txbd->info);",
      "167:    break;",
      "169:   if (unlikely(info & (DROP | DEFR | LTCL | UFLO))) {",
      "",
      "[Removed Lines]",
      "166:   if ((info & FOR_EMAC) || !txbd->data)",
      "",
      "[Added Lines]",
      "166:   if ((info & FOR_EMAC) || !txbd->data || !skb)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "192:   txbd->data = 0;",
      "193:   txbd->info = 0;",
      "196:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "194:   tx_buff->skb = NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "610:  dma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);",
      "611:  dma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);",
      "614:  priv->txbd[*txbd_curr].data = cpu_to_le32(addr);",
      "",
      "[Removed Lines]",
      "613:  priv->tx_buff[*txbd_curr].skb = skb;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "624:  wmb();",
      "626:  priv->tx_buff[*txbd_curr].skb = skb;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "90a88d6ef88edcfc4f644dddc7eef4ea41bccf8b",
      "candidate_info": {
        "commit_hash": "90a88d6ef88edcfc4f644dddc7eef4ea41bccf8b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/90a88d6ef88edcfc4f644dddc7eef4ea41bccf8b",
        "files": [
          "drivers/scsi/scsi_sysfs.c"
        ],
        "message": "scsi: fix soft lockup in scsi_remove_target() on module removal\n\nThis softlockup is currently happening:\n\n[  444.088002] NMI watchdog: BUG: soft lockup - CPU#1 stuck for 22s! [kworker/1:1:29]\n[  444.088002] Modules linked in: lpfc(-) qla2x00tgt(O) qla2xxx_scst(O) scst_vdisk(O) scsi_transport_fc libcrc32c scst(O) dlm configfs nfsd lockd grace nfs_acl auth_rpcgss sunrpc ed\nd snd_pcm_oss snd_mixer_oss snd_seq snd_seq_device dm_mod iTCO_wdt snd_hda_codec_realtek snd_hda_codec_generic gpio_ich iTCO_vendor_support ppdev snd_hda_intel snd_hda_codec snd_hda\n_core snd_hwdep tg3 snd_pcm snd_timer libphy lpc_ich parport_pc ptp acpi_cpufreq snd pps_core fjes parport i2c_i801 ehci_pci tpm_tis tpm sr_mod cdrom soundcore floppy hwmon sg 8250_\nfintek pcspkr i915 drm_kms_helper uhci_hcd ehci_hcd drm fb_sys_fops sysimgblt sysfillrect syscopyarea i2c_algo_bit usbcore button video usb_common fan ata_generic ata_piix libata th\nermal\n[  444.088002] CPU: 1 PID: 29 Comm: kworker/1:1 Tainted: G           O    4.4.0-rc5-2.g1e923a3-default #1\n[  444.088002] Hardware name: FUJITSU SIEMENS ESPRIMO E           /D2164-A1, BIOS 5.00 R1.10.2164.A1               05/08/2006\n[  444.088002] Workqueue: fc_wq_4 fc_rport_final_delete [scsi_transport_fc]\n[  444.088002] task: f6266ec0 ti: f6268000 task.ti: f6268000\n[  444.088002] EIP: 0060:[<c07e7044>] EFLAGS: 00000286 CPU: 1\n[  444.088002] EIP is at _raw_spin_unlock_irqrestore+0x14/0x20\n[  444.088002] EAX: 00000286 EBX: f20d3800 ECX: 00000002 EDX: 00000286\n[  444.088002] ESI: f50ba800 EDI: f2146848 EBP: f6269ec8 ESP: f6269ec8\n[  444.088002]  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068\n[  444.088002] CR0: 8005003b CR2: 08f96600 CR3: 363ae000 CR4: 000006d0\n[  444.088002] Stack:\n[  444.088002]  f6269eec c066b0f7 00000286 f2146848 f50ba808 f50ba800 f50ba800 f2146a90\n[  444.088002]  f2146848 f6269f08 f8f0a4ed f3141000 f2146800 f2146a90 f619fa00 00000040\n[  444.088002]  f6269f40 c026cb25 00000001 166c6392 00000061 f6757140 f6136340 00000004\n[  444.088002] Call Trace:\n[  444.088002]  [<c066b0f7>] scsi_remove_target+0x167/0x1c0\n[  444.088002]  [<f8f0a4ed>] fc_rport_final_delete+0x9d/0x1e0 [scsi_transport_fc]\n[  444.088002]  [<c026cb25>] process_one_work+0x155/0x3e0\n[  444.088002]  [<c026cde7>] worker_thread+0x37/0x490\n[  444.088002]  [<c027214b>] kthread+0x9b/0xb0\n[  444.088002]  [<c07e72c1>] ret_from_kernel_thread+0x21/0x40\n\nWhat appears to be happening is that something has pinned the target\nso it can't go into STARGET_DEL via final release and the loop in\nscsi_remove_target spins endlessly until that happens.\n\nThe fix for this soft lockup is to not keep looping over a device that\nwe've called remove on but which hasn't gone into DEL state.  This\npatch will retain a simplistic memory of the last target and not keep\nlooping over it.\n\nReported-by: Sebastian Herbszt <herbszt@gmx.de>\nTested-by: Sebastian Herbszt <herbszt@gmx.de>\nFixes: 40998193560dab6c3ce8d25f4fa58a23e252ef38\nCc: stable@vger.kernel.org\nSigned-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>",
        "before_after_code_files": [
          "drivers/scsi/scsi_sysfs.c||drivers/scsi/scsi_sysfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/scsi_sysfs.c||drivers/scsi/scsi_sysfs.c": [
          "File: drivers/scsi/scsi_sysfs.c -> drivers/scsi/scsi_sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1272: void scsi_remove_target(struct device *dev)",
          "1273: {",
          "1274:  struct Scsi_Host *shost = dev_to_shost(dev->parent);",
          "1276:  unsigned long flags;",
          "1278: restart:",
          "1279:  spin_lock_irqsave(shost->host_lock, flags);",
          "1280:  list_for_each_entry(starget, &shost->__targets, siblings) {",
          "1282:    continue;",
          "1283:   if (starget->dev.parent == dev || &starget->dev == dev) {",
          "1284:    kref_get(&starget->reap_ref);",
          "1285:    spin_unlock_irqrestore(shost->host_lock, flags);",
          "1286:    __scsi_remove_target(starget);",
          "1287:    scsi_target_reap(starget);",
          "",
          "[Removed Lines]",
          "1275:  struct scsi_target *starget;",
          "1281:   if (starget->state == STARGET_DEL)",
          "",
          "[Added Lines]",
          "1275:  struct scsi_target *starget, *last_target = NULL;",
          "1281:   if (starget->state == STARGET_DEL ||",
          "1282:       starget == last_target)",
          "1286:    last_target = starget;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7716682cc58e305e22207d5bb315f26af6b1e243",
      "candidate_info": {
        "commit_hash": "7716682cc58e305e22207d5bb315f26af6b1e243",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7716682cc58e305e22207d5bb315f26af6b1e243",
        "files": [
          "include/net/inet_connection_sock.h",
          "net/dccp/ipv4.c",
          "net/dccp/ipv6.c",
          "net/ipv4/inet_connection_sock.c",
          "net/ipv4/tcp_ipv4.c",
          "net/ipv6/tcp_ipv6.c"
        ],
        "message": "tcp/dccp: fix another race at listener dismantle\n\nIlya reported following lockdep splat:\n\nkernel: =========================\nkernel: [ BUG: held lock freed! ]\nkernel: 4.5.0-rc1-ceph-00026-g5e0a311 #1 Not tainted\nkernel: -------------------------\nkernel: swapper/5/0 is freeing memory\nffff880035c9d200-ffff880035c9dbff, with a lock still held there!\nkernel: (&(&queue->rskq_lock)->rlock){+.-...}, at:\n[<ffffffff816f6a88>] inet_csk_reqsk_queue_add+0x28/0xa0\nkernel: 4 locks held by swapper/5/0:\nkernel: #0:  (rcu_read_lock){......}, at: [<ffffffff8169ef6b>]\nnetif_receive_skb_internal+0x4b/0x1f0\nkernel: #1:  (rcu_read_lock){......}, at: [<ffffffff816e977f>]\nip_local_deliver_finish+0x3f/0x380\nkernel: #2:  (slock-AF_INET){+.-...}, at: [<ffffffff81685ffb>]\nsk_clone_lock+0x19b/0x440\nkernel: #3:  (&(&queue->rskq_lock)->rlock){+.-...}, at:\n[<ffffffff816f6a88>] inet_csk_reqsk_queue_add+0x28/0xa0\n\nTo properly fix this issue, inet_csk_reqsk_queue_add() needs\nto return to its callers if the child as been queued\ninto accept queue.\n\nWe also need to make sure listener is still there before\ncalling sk->sk_data_ready(), by holding a reference on it,\nsince the reference carried by the child can disappear as\nsoon as the child is put on accept queue.\n\nReported-by: Ilya Dryomov <idryomov@gmail.com>\nFixes: ebb516af60e1 (\"tcp/dccp: fix race at listener dismantle phase\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/inet_connection_sock.h||include/net/inet_connection_sock.h",
          "net/dccp/ipv4.c||net/dccp/ipv4.c",
          "net/dccp/ipv6.c||net/dccp/ipv6.c",
          "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
          "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c",
          "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/net/inet_connection_sock.h||include/net/inet_connection_sock.h": [
          "File: include/net/inet_connection_sock.h -> include/net/inet_connection_sock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "270:          struct sock *newsk,",
          "271:          const struct request_sock *req);",
          "275: void inet_csk_reqsk_queue_hash_add(struct sock *sk, struct request_sock *req,",
          "276:        unsigned long timeout);",
          "277: struct sock *inet_csk_complete_hashdance(struct sock *sk, struct sock *child,",
          "",
          "[Removed Lines]",
          "273: void inet_csk_reqsk_queue_add(struct sock *sk, struct request_sock *req,",
          "274:          struct sock *child);",
          "",
          "[Added Lines]",
          "273: struct sock *inet_csk_reqsk_queue_add(struct sock *sk,",
          "274:           struct request_sock *req,",
          "275:           struct sock *child);",
          "",
          "---------------"
        ],
        "net/dccp/ipv4.c||net/dccp/ipv4.c": [
          "File: net/dccp/ipv4.c -> net/dccp/ipv4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "825:  if (sk->sk_state == DCCP_NEW_SYN_RECV) {",
          "826:   struct request_sock *req = inet_reqsk(sk);",
          "829:   sk = req->rsk_listener;",
          "833:    inet_csk_reqsk_queue_drop_and_put(sk, req);",
          "834:    goto lookup;",
          "835:   }",
          "836:   if (!nsk) {",
          "837:    reqsk_put(req);",
          "839:   }",
          "840:   if (nsk == sk) {",
          "842:    reqsk_put(req);",
          "843:   } else if (dccp_child_process(sk, nsk, skb)) {",
          "844:    dccp_v4_ctl_send_reset(sk, skb);",
          "846:   } else {",
          "847:    return 0;",
          "848:   }",
          "849:  }",
          "",
          "[Removed Lines]",
          "827:   struct sock *nsk = NULL;",
          "830:   if (likely(sk->sk_state == DCCP_LISTEN)) {",
          "831:    nsk = dccp_check_req(sk, skb, req);",
          "832:   } else {",
          "838:    goto discard_it;",
          "841:    sock_hold(sk);",
          "845:    goto discard_it;",
          "",
          "[Added Lines]",
          "827:   struct sock *nsk;",
          "830:   if (unlikely(sk->sk_state != DCCP_LISTEN)) {",
          "834:   sock_hold(sk);",
          "835:   nsk = dccp_check_req(sk, skb, req);",
          "838:    goto discard_and_relse;",
          "844:    goto discard_and_relse;",
          "846:    sock_put(sk);",
          "",
          "---------------"
        ],
        "net/dccp/ipv6.c||net/dccp/ipv6.c": [
          "File: net/dccp/ipv6.c -> net/dccp/ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "692:  if (sk->sk_state == DCCP_NEW_SYN_RECV) {",
          "693:   struct request_sock *req = inet_reqsk(sk);",
          "696:   sk = req->rsk_listener;",
          "700:    inet_csk_reqsk_queue_drop_and_put(sk, req);",
          "701:    goto lookup;",
          "702:   }",
          "703:   if (!nsk) {",
          "704:    reqsk_put(req);",
          "706:   }",
          "707:   if (nsk == sk) {",
          "709:    reqsk_put(req);",
          "710:   } else if (dccp_child_process(sk, nsk, skb)) {",
          "711:    dccp_v6_ctl_send_reset(sk, skb);",
          "713:   } else {",
          "714:    return 0;",
          "715:   }",
          "716:  }",
          "",
          "[Removed Lines]",
          "694:   struct sock *nsk = NULL;",
          "697:   if (likely(sk->sk_state == DCCP_LISTEN)) {",
          "698:    nsk = dccp_check_req(sk, skb, req);",
          "699:   } else {",
          "705:    goto discard_it;",
          "708:    sock_hold(sk);",
          "712:    goto discard_it;",
          "",
          "[Added Lines]",
          "694:   struct sock *nsk;",
          "697:   if (unlikely(sk->sk_state != DCCP_LISTEN)) {",
          "701:   sock_hold(sk);",
          "702:   nsk = dccp_check_req(sk, skb, req);",
          "705:    goto discard_and_relse;",
          "711:    goto discard_and_relse;",
          "713:    sock_put(sk);",
          "",
          "---------------"
        ],
        "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c": [
          "File: net/ipv4/inet_connection_sock.c -> net/ipv4/inet_connection_sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "789:  reqsk_put(req);",
          "790: }",
          "794: {",
          "795:  struct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;",
          "797:  spin_lock(&queue->rskq_lock);",
          "798:  if (unlikely(sk->sk_state != TCP_LISTEN)) {",
          "799:   inet_child_forget(sk, req, child);",
          "800:  } else {",
          "801:   req->sk = child;",
          "802:   req->dl_next = NULL;",
          "",
          "[Removed Lines]",
          "792: void inet_csk_reqsk_queue_add(struct sock *sk, struct request_sock *req,",
          "793:          struct sock *child)",
          "",
          "[Added Lines]",
          "792: struct sock *inet_csk_reqsk_queue_add(struct sock *sk,",
          "793:           struct request_sock *req,",
          "794:           struct sock *child)",
          "801:   child = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "808:   sk_acceptq_added(sk);",
          "809:  }",
          "810:  spin_unlock(&queue->rskq_lock);",
          "811: }",
          "812: EXPORT_SYMBOL(inet_csk_reqsk_queue_add);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "813:  return child;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "817:  if (own_req) {",
          "818:   inet_csk_reqsk_queue_drop(sk, req);",
          "819:   reqsk_queue_removed(&inet_csk(sk)->icsk_accept_queue, req);",
          "825:  }",
          "827:  bh_unlock_sock(child);",
          "",
          "[Removed Lines]",
          "820:   inet_csk_reqsk_queue_add(sk, req, child);",
          "824:   return child;",
          "",
          "[Added Lines]",
          "823:   if (inet_csk_reqsk_queue_add(sk, req, child))",
          "824:    return child;",
          "",
          "---------------"
        ],
        "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c": [
          "File: net/ipv4/tcp_ipv4.c -> net/ipv4/tcp_ipv4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1598:  if (sk->sk_state == TCP_NEW_SYN_RECV) {",
          "1599:   struct request_sock *req = inet_reqsk(sk);",
          "1602:   sk = req->rsk_listener;",
          "1603:   if (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {",
          "1604:    reqsk_put(req);",
          "1605:    goto discard_it;",
          "1606:   }",
          "1610:    inet_csk_reqsk_queue_drop_and_put(sk, req);",
          "1611:    goto lookup;",
          "1612:   }",
          "1613:   if (!nsk) {",
          "1614:    reqsk_put(req);",
          "1616:   }",
          "1617:   if (nsk == sk) {",
          "1619:    reqsk_put(req);",
          "1620:   } else if (tcp_child_process(sk, nsk, skb)) {",
          "1621:    tcp_v4_send_reset(nsk, skb);",
          "1623:   } else {",
          "1624:    return 0;",
          "1625:   }",
          "1626:  }",
          "",
          "[Removed Lines]",
          "1600:   struct sock *nsk = NULL;",
          "1607:   if (likely(sk->sk_state == TCP_LISTEN)) {",
          "1608:    nsk = tcp_check_req(sk, skb, req, false);",
          "1609:   } else {",
          "1615:    goto discard_it;",
          "1618:    sock_hold(sk);",
          "1622:    goto discard_it;",
          "",
          "[Added Lines]",
          "1600:   struct sock *nsk;",
          "1607:   if (unlikely(sk->sk_state != TCP_LISTEN)) {",
          "1611:   sock_hold(sk);",
          "1612:   nsk = tcp_check_req(sk, skb, req, false);",
          "1615:    goto discard_and_relse;",
          "1621:    goto discard_and_relse;",
          "1623:    sock_put(sk);",
          "",
          "---------------"
        ],
        "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c": [
          "File: net/ipv6/tcp_ipv6.c -> net/ipv6/tcp_ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1388:  if (sk->sk_state == TCP_NEW_SYN_RECV) {",
          "1389:   struct request_sock *req = inet_reqsk(sk);",
          "1392:   sk = req->rsk_listener;",
          "1393:   tcp_v6_fill_cb(skb, hdr, th);",
          "",
          "[Removed Lines]",
          "1390:   struct sock *nsk = NULL;",
          "",
          "[Added Lines]",
          "1390:   struct sock *nsk;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1395:    reqsk_put(req);",
          "1396:    goto discard_it;",
          "1397:   }",
          "1401:    inet_csk_reqsk_queue_drop_and_put(sk, req);",
          "1402:    goto lookup;",
          "1403:   }",
          "1404:   if (!nsk) {",
          "1405:    reqsk_put(req);",
          "1407:   }",
          "1408:   if (nsk == sk) {",
          "1410:    reqsk_put(req);",
          "1411:    tcp_v6_restore_cb(skb);",
          "1412:   } else if (tcp_child_process(sk, nsk, skb)) {",
          "1413:    tcp_v6_send_reset(nsk, skb);",
          "1415:   } else {",
          "1416:    return 0;",
          "1417:   }",
          "1418:  }",
          "",
          "[Removed Lines]",
          "1398:   if (likely(sk->sk_state == TCP_LISTEN)) {",
          "1399:    nsk = tcp_check_req(sk, skb, req, false);",
          "1400:   } else {",
          "1406:    goto discard_it;",
          "1409:    sock_hold(sk);",
          "1414:    goto discard_it;",
          "",
          "[Added Lines]",
          "1398:   if (unlikely(sk->sk_state != TCP_LISTEN)) {",
          "1402:   sock_hold(sk);",
          "1403:   nsk = tcp_check_req(sk, skb, req, false);",
          "1406:    goto discard_and_relse;",
          "1413:    goto discard_and_relse;",
          "1415:    sock_put(sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bc7f2ce0a7b54ba7703f81995fe434f0926424d2",
      "candidate_info": {
        "commit_hash": "bc7f2ce0a7b54ba7703f81995fe434f0926424d2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bc7f2ce0a7b54ba7703f81995fe434f0926424d2",
        "files": [
          "drivers/iommu/arm-smmu-v3.c",
          "drivers/iommu/arm-smmu.c"
        ],
        "message": "iommu/arm-smmu: Don't fail device attach if already attached to a domain\n\nThe ARM SMMU attach_dev implementations returns -EEXIST if the device\nbeing attached is already attached to a domain. This doesn't play nicely\nwith the default domain, resulting in splats such as:\n\n  WARNING: at drivers/iommu/iommu.c:1257\n  Modules linked in:\n\n  CPU: 3 PID: 1939 Comm: virtio-net-tx Tainted: G S              4.5.0-rc4+ #1\n  Hardware name: FVP Base (DT)\n  task: ffffffc87a9d0000 ti: ffffffc07a278000 task.ti: ffffffc07a278000\n  PC is at __iommu_detach_group+0x68/0xe8\n  LR is at __iommu_detach_group+0x48/0xe8\n\nThis patch fixes the problem by forcefully detaching the device from\nits old domain, if present, when attaching to a new one. The unused\n->detach_dev callback is also removed the iommu_ops structures.\n\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
        "before_after_code_files": [
          "drivers/iommu/arm-smmu-v3.c||drivers/iommu/arm-smmu-v3.c",
          "drivers/iommu/arm-smmu.c||drivers/iommu/arm-smmu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/iommu/arm-smmu-v3.c||drivers/iommu/arm-smmu-v3.c": [
          "File: drivers/iommu/arm-smmu-v3.c -> drivers/iommu/arm-smmu-v3.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1638:  return 0;",
          "1639: }",
          "1641: static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)",
          "1642: {",
          "1643:  int ret = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1641: static void arm_smmu_detach_dev(struct device *dev)",
          "1642: {",
          "1643:  struct arm_smmu_group *smmu_group = arm_smmu_group_get(dev);",
          "1645:  smmu_group->ste.bypass = true;",
          "1646:  if (IS_ERR_VALUE(arm_smmu_install_ste_for_group(smmu_group)))",
          "1647:   dev_warn(dev, \"failed to install bypass STE\\n\");",
          "1649:  smmu_group->domain = NULL;",
          "1650: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1652:  if (smmu_group->domain && smmu_group->domain != smmu_domain)",
          "1655:  smmu = smmu_group->smmu;",
          "1656:  mutex_lock(&smmu_domain->init_mutex);",
          "",
          "[Removed Lines]",
          "1653:   return -EEXIST;",
          "",
          "[Added Lines]",
          "1664:   arm_smmu_detach_dev(dev);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1687:  return ret;",
          "1688: }",
          "1709: static int arm_smmu_map(struct iommu_domain *domain, unsigned long iova,",
          "1710:    phys_addr_t paddr, size_t size, int prot)",
          "1711: {",
          "",
          "[Removed Lines]",
          "1690: static void arm_smmu_detach_dev(struct iommu_domain *domain, struct device *dev)",
          "1691: {",
          "1692:  struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);",
          "1693:  struct arm_smmu_group *smmu_group = arm_smmu_group_get(dev);",
          "1695:  BUG_ON(!smmu_domain);",
          "1696:  BUG_ON(!smmu_group);",
          "1698:  mutex_lock(&smmu_domain->init_mutex);",
          "1699:  BUG_ON(smmu_group->domain != smmu_domain);",
          "1701:  smmu_group->ste.bypass = true;",
          "1702:  if (IS_ERR_VALUE(arm_smmu_install_ste_for_group(smmu_group)))",
          "1703:   dev_warn(dev, \"failed to install bypass STE\\n\");",
          "1705:  smmu_group->domain = NULL;",
          "1706:  mutex_unlock(&smmu_domain->init_mutex);",
          "1707: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1943:  .domain_alloc  = arm_smmu_domain_alloc,",
          "1944:  .domain_free  = arm_smmu_domain_free,",
          "1945:  .attach_dev  = arm_smmu_attach_dev,",
          "1947:  .map   = arm_smmu_map,",
          "1948:  .unmap   = arm_smmu_unmap,",
          "1949:  .iova_to_phys  = arm_smmu_iova_to_phys,",
          "",
          "[Removed Lines]",
          "1946:  .detach_dev  = arm_smmu_detach_dev,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/iommu/arm-smmu.c||drivers/iommu/arm-smmu.c": [
          "File: drivers/iommu/arm-smmu.c -> drivers/iommu/arm-smmu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1131:  arm_smmu_master_free_smrs(smmu, cfg);",
          "1132: }",
          "1134: static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)",
          "1135: {",
          "1136:  int ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1134: static void arm_smmu_detach_dev(struct device *dev,",
          "1135:     struct arm_smmu_master_cfg *cfg)",
          "1136: {",
          "1137:  struct iommu_domain *domain = dev->archdata.iommu;",
          "1138:  struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);",
          "1140:  dev->archdata.iommu = NULL;",
          "1141:  arm_smmu_domain_remove_master(smmu_domain, cfg);",
          "1142: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1144:   return -ENXIO;",
          "1145:  }",
          "1153:  ret = arm_smmu_init_domain_context(domain, smmu);",
          "1154:  if (IS_ERR_VALUE(ret))",
          "",
          "[Removed Lines]",
          "1147:  if (dev->archdata.iommu) {",
          "1148:   dev_err(dev, \"already attached to IOMMU domain\\n\");",
          "1149:   return -EEXIST;",
          "1150:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1170:  if (!cfg)",
          "1171:   return -ENODEV;",
          "1173:  ret = arm_smmu_domain_add_master(smmu_domain, cfg);",
          "1174:  if (!ret)",
          "1175:   dev->archdata.iommu = domain;",
          "1176:  return ret;",
          "1177: }",
          "1192: static int arm_smmu_map(struct iommu_domain *domain, unsigned long iova,",
          "1193:    phys_addr_t paddr, size_t size, int prot)",
          "1194: {",
          "",
          "[Removed Lines]",
          "1179: static void arm_smmu_detach_dev(struct iommu_domain *domain, struct device *dev)",
          "1180: {",
          "1181:  struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);",
          "1182:  struct arm_smmu_master_cfg *cfg;",
          "1184:  cfg = find_smmu_master_cfg(dev);",
          "1185:  if (!cfg)",
          "1186:   return;",
          "1188:  dev->archdata.iommu = NULL;",
          "1189:  arm_smmu_domain_remove_master(smmu_domain, cfg);",
          "1190: }",
          "",
          "[Added Lines]",
          "1179:  if (dev->archdata.iommu)",
          "1180:   arm_smmu_detach_dev(dev, cfg);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1464:  .domain_alloc  = arm_smmu_domain_alloc,",
          "1465:  .domain_free  = arm_smmu_domain_free,",
          "1466:  .attach_dev  = arm_smmu_attach_dev,",
          "1468:  .map   = arm_smmu_map,",
          "1469:  .unmap   = arm_smmu_unmap,",
          "1470:  .map_sg   = default_iommu_map_sg,",
          "",
          "[Removed Lines]",
          "1467:  .detach_dev  = arm_smmu_detach_dev,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f4eafd8bcd5229e998aa252627703b8462c3b90f",
      "candidate_info": {
        "commit_hash": "f4eafd8bcd5229e998aa252627703b8462c3b90f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f4eafd8bcd5229e998aa252627703b8462c3b90f",
        "files": [
          "arch/x86/mm/fault.c"
        ],
        "message": "x86/mm: Fix vmalloc_fault() to handle large pages properly\n\nA kernel page fault oops with the callstack below was observed\nwhen a read syscall was made to a pmem device after a huge amount\n(>512GB) of vmalloc ranges was allocated by ioremap() on a x86_64\nsystem:\n\n     BUG: unable to handle kernel paging request at ffff880840000ff8\n     IP: vmalloc_fault+0x1be/0x300\n     PGD c7f03a067 PUD 0\n     Oops: 0000 [#1] SM\n     Call Trace:\n        __do_page_fault+0x285/0x3e0\n        do_page_fault+0x2f/0x80\n        ? put_prev_entity+0x35/0x7a0\n        page_fault+0x28/0x30\n        ? memcpy_erms+0x6/0x10\n        ? schedule+0x35/0x80\n        ? pmem_rw_bytes+0x6a/0x190 [nd_pmem]\n        ? schedule_timeout+0x183/0x240\n        btt_log_read+0x63/0x140 [nd_btt]\n         :\n        ? __symbol_put+0x60/0x60\n        ? kernel_read+0x50/0x80\n        SyS_finit_module+0xb9/0xf0\n        entry_SYSCALL_64_fastpath+0x1a/0xa4\n\nSince v4.1, ioremap() supports large page (pud/pmd) mappings in\nx86_64 and PAE.  vmalloc_fault() however assumes that the vmalloc\nrange is limited to pte mappings.\n\nvmalloc faults do not normally happen in ioremap'd ranges since\nioremap() sets up the kernel page tables, which are shared by\nuser processes.  pgd_ctor() sets the kernel's PGD entries to\nuser's during fork().  When allocation of the vmalloc ranges\ncrosses a 512GB boundary, ioremap() allocates a new pud table\nand updates the kernel PGD entry to point it.  If user process's\nPGD entry does not have this update yet, a read/write syscall\nto the range will cause a vmalloc fault, which hits the Oops\nabove as it does not handle a large page properly.\n\nFollowing changes are made to vmalloc_fault().\n\n64-bit:\n\n - No change for the PGD sync operation as it handles large\n   pages already.\n - Add pud_huge() and pmd_huge() to the validation code to\n   handle large pages.\n - Change pud_page_vaddr() to pud_pfn() since an ioremap range\n   is not directly mapped (while the if-statement still works\n   with a bogus addr).\n - Change pmd_page() to pmd_pfn() since an ioremap range is not\n   backed by struct page (while the if-statement still works\n   with a bogus addr).\n\n32-bit:\n - No change for the sync operation since the index3 PGD entry\n   covers the entire vmalloc range, which is always valid.\n   (A separate change to sync PGD entry is necessary if this\n    memory layout is changed regardless of the page size.)\n - Add pmd_huge() to the validation code to handle large pages.\n   This is for completeness since vmalloc_fault() won't happen\n   in ioremap'd ranges as its PGD entry is always valid.\n\nReported-by: Henning Schild <henning.schild@siemens.com>\nSigned-off-by: Toshi Kani <toshi.kani@hpe.com>\nAcked-by: Borislav Petkov <bp@alien8.de>\nCc: <stable@vger.kernel.org> # 4.1+\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Brian Gerst <brgerst@gmail.com>\nCc: Denys Vlasenko <dvlasenk@redhat.com>\nCc: H. Peter Anvin <hpa@zytor.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Luis R. Rodriguez <mcgrof@suse.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Toshi Kani <toshi.kani@hp.com>\nCc: linux-mm@kvack.org\nCc: linux-nvdimm@lists.01.org\nLink: http://lkml.kernel.org/r/1455758214-24623-1-git-send-email-toshi.kani@hpe.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "arch/x86/mm/fault.c||arch/x86/mm/fault.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/mm/fault.c||arch/x86/mm/fault.c": [
          "File: arch/x86/mm/fault.c -> arch/x86/mm/fault.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "287:  if (!pmd_k)",
          "288:   return -1;",
          "290:  pte_k = pte_offset_kernel(pmd_k, address);",
          "291:  if (!pte_present(*pte_k))",
          "292:   return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:  if (pmd_huge(*pmd_k))",
          "291:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "403:  if (pud_none(*pud_ref))",
          "404:   return -1;",
          "407:   BUG();",
          "409:  pmd = pmd_offset(pud, address);",
          "410:  pmd_ref = pmd_offset(pud_ref, address);",
          "411:  if (pmd_none(*pmd_ref))",
          "412:   return -1;",
          "415:   BUG();",
          "417:  pte_ref = pte_offset_kernel(pmd_ref, address);",
          "418:  if (!pte_present(*pte_ref))",
          "419:   return -1;",
          "",
          "[Removed Lines]",
          "406:  if (pud_none(*pud) || pud_page_vaddr(*pud) != pud_page_vaddr(*pud_ref))",
          "414:  if (pmd_none(*pmd) || pmd_page(*pmd) != pmd_page(*pmd_ref))",
          "",
          "[Added Lines]",
          "407:  if (pud_none(*pud) || pud_pfn(*pud) != pud_pfn(*pud_ref))",
          "410:  if (pud_huge(*pud))",
          "411:   return 0;",
          "418:  if (pmd_none(*pmd) || pmd_pfn(*pmd) != pmd_pfn(*pmd_ref))",
          "421:  if (pmd_huge(*pmd))",
          "422:   return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ea49c9acf2db7082f0406bb3a570cc6bad37082b",
      "candidate_info": {
        "commit_hash": "ea49c9acf2db7082f0406bb3a570cc6bad37082b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ea49c9acf2db7082f0406bb3a570cc6bad37082b",
        "files": [
          "drivers/gpu/drm/i915/intel_display.c"
        ],
        "message": "drm/i915: Lock mode_config.mutex in intel_display_resume.\n\nUnfortunately i915 is still not fully atomic, and expects mode_config.mutex\nto be held during modeset until we finally fix it.\n\nThis fixes the following WARN when resuming:\n\n[  425.208983] ------------[ cut here ]------------\n[  425.208990] WARNING: CPU: 0 PID: 6828 at drivers/gpu/drm/drm_edid.c:3555 drm_select_eld+0xa5/0xd0()\n[  425.209015] Modules linked in: pl2303 usbserial snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic intel_powerclamp coretemp i915 crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm i2c_hid i2c_designware_platform i2c_designware_core r8169 mii sdhci_acpi sdhci mmc_core\n[  425.209018] CPU: 0 PID: 6828 Comm: kworker/u4:5 Tainted: G     U  W       4.5.0-rc4-gfxbench+ #1\n[  425.209020] Hardware name: \\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff \\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff\\xffffffff/DN2820FYK, BIOS FYBYT10H.86A.0038.2014.0717.1455 07/17/2014\n[  425.209027] Workqueue: events_unbound async_run_entry_fn\n[  425.209032]  0000000000000000 ffff880072433958 ffffffff813f6b05 0000000000000000\n[  425.209036]  ffffffff81aaef2d ffff880072433990 ffffffff81078291 ffff880036b933d8\n[  425.209039]  ffff88006d528000 ffff88006d52b3d8 ffff88006d52b3d8 ffff88007315b6f8\n[  425.209040] Call Trace:\n[  425.209045]  [<ffffffff813f6b05>] dump_stack+0x67/0x92\n[  425.209049]  [<ffffffff81078291>] warn_slowpath_common+0x81/0xc0\n[  425.209052]  [<ffffffff81078385>] warn_slowpath_null+0x15/0x20\n[  425.209054]  [<ffffffff8151e195>] drm_select_eld+0xa5/0xd0\n[  425.209101]  [<ffffffffa01f34f4>] intel_audio_codec_enable+0x44/0x160 [i915]\n[  425.209135]  [<ffffffffa023eac7>] intel_enable_hdmi_audio+0x87/0x90 [i915]\n[  425.209169]  [<ffffffffa023eb5a>] g4x_enable_hdmi+0x8a/0xa0 [i915]\n[  425.209202]  [<ffffffffa023f41b>] vlv_hdmi_pre_enable+0x1cb/0x240 [i915]\n[  425.209236]  [<ffffffffa020edcf>] valleyview_crtc_enable+0x10f/0x290 [i915]\n[  425.209270]  [<ffffffffa020ba49>] intel_atomic_commit+0x769/0x17a0 [i915]\n[  425.209274]  [<ffffffff81526ad5>] ? drm_atomic_check_only+0x145/0x660\n[  425.209276]  [<ffffffff81527022>] drm_atomic_commit+0x32/0x50\n[  425.209310]  [<ffffffffa0215fa0>] intel_display_resume+0xa0/0x130 [i915]\n[  425.209338]  [<ffffffffa018c1bb>] i915_drm_resume+0xcb/0x160 [i915]\n[  425.209366]  [<ffffffffa018c272>] i915_pm_resume+0x22/0x30 [i915]\n[  425.209370]  [<ffffffff8143d91e>] pci_pm_resume+0x6e/0xe0\n[  425.209373]  [<ffffffff8143d8b0>] ? pci_pm_resume_noirq+0xa0/0xa0\n[  425.209375]  [<ffffffff815409ae>] dpm_run_callback+0x6e/0x280\n[  425.209378]  [<ffffffff815410b2>] device_resume+0x92/0x250\n[  425.209380]  [<ffffffff81541288>] async_resume+0x18/0x40\n[  425.209382]  [<ffffffff8109c7a5>] async_run_entry_fn+0x45/0x140\n[  425.209386]  [<ffffffff81093293>] process_one_work+0x1e3/0x620\n[  425.209388]  [<ffffffff810931f7>] ? process_one_work+0x147/0x620\n[  425.209391]  [<ffffffff81093719>] worker_thread+0x49/0x490\n[  425.209393]  [<ffffffff810936d0>] ? process_one_work+0x620/0x620\n[  425.209396]  [<ffffffff81099e0a>] kthread+0xea/0x100\n[  425.209400]  [<ffffffff81099d20>] ? kthread_create_on_node+0x1f0/0x1f0\n[  425.209404]  [<ffffffff817ba03f>] ret_from_fork+0x3f/0x70\n[  425.209407]  [<ffffffff81099d20>] ? kthread_create_on_node+0x1f0/0x1f0\n[  425.209409] ---[ end trace d1b247107f34a8b2 ]---\n\nFixes: e2c8b8701e2d (\"drm/i915: Use atomic helpers for suspend, v2.\")\nSigned-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>\nLink: http://patchwork.freedesktop.org/patch/msgid/1455632862-18557-1-git-send-email-maarten.lankhorst@linux.intel.com\nReviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/intel_display.c||drivers/gpu/drm/i915/intel_display.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/intel_display.c||drivers/gpu/drm/i915/intel_display.c": [
          "File: drivers/gpu/drm/i915/intel_display.c -> drivers/gpu/drm/i915/intel_display.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15884:  dev_priv->modeset_restore_state = NULL;",
          "15886:  drm_modeset_acquire_init(&ctx, 0);",
          "15888: retry:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15892:  mutex_lock(&dev->mode_config.mutex);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "15922:  drm_modeset_drop_locks(&ctx);",
          "15923:  drm_modeset_acquire_fini(&ctx);",
          "15925:  if (ret) {",
          "15926:   DRM_ERROR(\"Restoring old state failed with %i\\n\", ret);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15931:  mutex_unlock(&dev->mode_config.mutex);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
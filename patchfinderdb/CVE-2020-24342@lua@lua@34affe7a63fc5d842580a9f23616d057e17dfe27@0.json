{
  "cve_id": "CVE-2020-24342",
  "cve_desc": "Lua through 5.4.0 allows a stack redzone cross in luaO_pushvfstring because a protection mechanism wrongly calls luaD_callnoyield twice in a row.",
  "repo": "lua/lua",
  "patch_hash": "34affe7a63fc5d842580a9f23616d057e17dfe27",
  "patch_info": {
    "commit_hash": "34affe7a63fc5d842580a9f23616d057e17dfe27",
    "repo": "lua/lua",
    "commit_url": "https://github.com/lua/lua/commit/34affe7a63fc5d842580a9f23616d057e17dfe27",
    "files": [
      "ldo.c"
    ],
    "message": "Fixed bug: 'luaD_callnoyield' called twice in a row\n\nIn luaD_callnoyield, when there is a possible stack overflow, it\nzeros the number of CallInfos to force a check when calling the\nfunction. However, if the \"function\" is not a function, the code will\nraise an error before checking the stack. Then, the error handling calls\nluaD_callnoyield again and nCcalls is decremented again, crossing the\nstack redzone without raising an error. (This loop can only happens\nonce, because the error handler must be a function.  But once is enough\nto cross the redzone.)",
    "before_after_code_files": [
      "ldo.c||ldo.c"
    ]
  },
  "patch_diff": {
    "ldo.c||ldo.c": [
      "File: ldo.c -> ldo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "522: void luaD_callnoyield (lua_State *L, StkId func, int nResults) {",
      "523:   incXCcalls(L);",
      "526:   luaD_call(L, func, nResults);",
      "527:   decXCcalls(L);",
      "528: }",
      "",
      "[Removed Lines]",
      "525:     luaE_freeCI(L);",
      "",
      "[Added Lines]",
      "524:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5d8ce05b3f6fad79e37ed21c1076e47a322472c6",
      "candidate_info": {
        "commit_hash": "5d8ce05b3f6fad79e37ed21c1076e47a322472c6",
        "repo": "lua/lua",
        "commit_url": "https://github.com/lua/lua/commit/5d8ce05b3f6fad79e37ed21c1076e47a322472c6",
        "files": [
          "ldo.c",
          "ldo.h",
          "lparser.c",
          "lstate.c",
          "lstate.h",
          "ltests.h",
          "luaconf.h",
          "lvm.c",
          "testes/all.lua",
          "testes/cstack.lua",
          "testes/errors.lua"
        ],
        "message": "Back to a stackless implementation\n\nA \"with stack\" implementation gains too little in performance to be\nworth all the noise from C-stack overflows.\n\nThis commit is almost a sketch, to test performance. There are several\npending stuff:\n\n- review control of C-stack overflow and error messages;\n- what to do with setcstacklimit;\n- review comments;\n- review unroll of Lua calls.",
        "before_after_code_files": [
          "ldo.c||ldo.c",
          "ldo.h||ldo.h",
          "lparser.c||lparser.c",
          "lstate.c||lstate.c",
          "lstate.h||lstate.h",
          "ltests.h||ltests.h",
          "luaconf.h||luaconf.h",
          "lvm.c||lvm.c",
          "testes/all.lua||testes/all.lua",
          "testes/cstack.lua||testes/cstack.lua",
          "testes/errors.lua||testes/errors.lua"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ldo.c||ldo.c"
          ],
          "candidate": [
            "ldo.c||ldo.c"
          ]
        }
      },
      "candidate_diff": {
        "ldo.c||ldo.c": [
          "File: ldo.c -> ldo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {",
          "144:   struct lua_longjmp lj;",
          "145:   lj.status = LUA_OK;",
          "",
          "[Removed Lines]",
          "142:   global_State *g = G(L);",
          "143:   l_uint32 oldnCcalls = g->Cstacklimit - (L->nCcalls + L->nci);",
          "",
          "[Added Lines]",
          "142:   l_uint32 oldnCcalls = L->nCcalls;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "149:     (*f)(L, ud);",
          "150:   );",
          "153:   return lj.status;",
          "154: }",
          "",
          "[Removed Lines]",
          "152:   L->nCcalls = g->Cstacklimit - oldnCcalls - L->nci;",
          "",
          "[Added Lines]",
          "151:   L->nCcalls = oldnCcalls;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "458:   lua_CFunction f;",
          "459:  retry:",
          "460:   switch (ttypetag(s2v(func))) {",
          "",
          "[Removed Lines]",
          "457: void luaD_call (lua_State *L, StkId func, int nresults) {",
          "",
          "[Added Lines]",
          "456: int luaD_precall (lua_State *L, StkId func, int nresults) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "482:       lua_lock(L);",
          "483:       api_checknelems(L, n);",
          "484:       luaD_poscall(L, ci, n);",
          "486:     }",
          "488:       CallInfo *ci;",
          "",
          "[Removed Lines]",
          "485:       break;",
          "",
          "[Added Lines]",
          "484:       return 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "501:       for (; narg < nfixparams; narg++)",
          "503:       lua_assert(ci->top <= L->stack_last);",
          "506:     }",
          "",
          "[Removed Lines]",
          "505:       break;",
          "",
          "[Added Lines]",
          "503:       return 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "513: }",
          "519: void luaD_callnoyield (lua_State *L, StkId func, int nResults) {",
          "525:   luaD_call(L, func, nResults);",
          "527: }",
          "",
          "[Removed Lines]",
          "520:   incXCcalls(L);",
          "524:   }",
          "526:   decXCcalls(L);",
          "",
          "[Added Lines]",
          "514: static void stackerror (lua_State *L) {",
          "515:   if (getCcalls(L) == LUAI_MAXCCALLS)",
          "516:     luaG_runerror(L, \"C stack overflow\");",
          "517:   else if (getCcalls(L) >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))",
          "519: }",
          "522: void luaD_call (lua_State *L, StkId func, int nResults) {",
          "523:   L->nCcalls++;",
          "524:   if (getCcalls(L) >= LUAI_MAXCCALLS)",
          "525:     stackerror(L);",
          "528:   L->nCcalls--;",
          "529: }",
          "537:   incnny(L);",
          "539:   decnny(L);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "639:   CallInfo *ci = L->ci;",
          "642:   }",
          "644:     lua_assert(L->status == LUA_YIELD);",
          "",
          "[Removed Lines]",
          "641:     luaD_call(L, firstArg - 1, LUA_MULTRET);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "670:   }",
          "672:     return resume_error(L, \"cannot resume dead coroutine\", nargs);",
          "678:     return resume_error(L, \"C stack overflow\", nargs);",
          "679:   luai_userstateresume(L, nargs);",
          "680:   api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);",
          "",
          "[Removed Lines]",
          "673:   if (from == NULL)",
          "674:     L->nCcalls = CSTACKTHREAD;",
          "676:     L->nCcalls = getCcalls(from) - L->nci - CSTACKCF;",
          "677:   if (L->nCcalls <= CSTACKERR)",
          "",
          "[Added Lines]",
          "687:   L->nCcalls = (from) ? getCcalls(from) + 1 : 1;",
          "688:   if (getCcalls(L) >= LUAI_MAXCCALLS)",
          "",
          "---------------"
        ],
        "ldo.h||ldo.h": [
          "File: ldo.h -> ldo.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:                                         int fTransfer, int nTransfer);",
          "60: LUAI_FUNC void luaD_hookcall (lua_State *L, CallInfo *ci);",
          "61: LUAI_FUNC void luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func, int n);",
          "62: LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults);",
          "63: LUAI_FUNC void luaD_callnoyield (lua_State *L, StkId func, int nResults);",
          "64: LUAI_FUNC void luaD_tryfuncTM (lua_State *L, StkId func);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nResults);",
          "",
          "---------------"
        ],
        "lparser.c||lparser.c": [
          "File: lparser.c -> lparser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "489: }",
          "",
          "[Removed Lines]",
          "495: #define enterlevel(ls) luaE_enterCcall((ls)->L)",
          "497: #define leavelevel(ls) luaE_exitCcall((ls)->L)",
          "",
          "[Added Lines]",
          "492: static void enterlevel (LexState *ls) {",
          "493:   lua_State *L = ls->L;",
          "494:   L->nCcalls++;",
          "495:   checklimit(ls->fs, getCcalls(L), LUAI_MAXCCALLS, \"C levels\");",
          "496: }",
          "499: #define leavelevel(ls) ((ls)->L->nCcalls--)",
          "",
          "---------------"
        ],
        "lstate.c||lstate.c": [
          "File: lstate.c -> lstate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "119: }",
          "156: CallInfo *luaE_extendCI (lua_State *L) {",
          "157:   CallInfo *ci;",
          "158:   lua_assert(L->ci->next == NULL);",
          "160:   ci = luaM_new(L, CallInfo);",
          "161:   lua_assert(L->ci->next == NULL);",
          "162:   L->ci->next = ci;",
          "",
          "[Removed Lines]",
          "135: void luaE_enterCcall (lua_State *L) {",
          "136:   int ncalls = getCcalls(L);",
          "137:   L->nCcalls--;",
          "144:       else if (ncalls >= CSTACKMARK) {",
          "147:         luaG_runerror(L, \"C stack overflow\");",
          "148:       }",
          "151:     }",
          "152:   }",
          "153: }",
          "159:   luaE_enterCcall(L);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "335:   setthvalue2s(L, L->top, L1);",
          "336:   api_incr_top(L);",
          "337:   preinit_thread(L1, g);",
          "339:   L1->hookmask = L->hookmask;",
          "340:   L1->basehookcount = L->basehookcount;",
          "341:   L1->hook = L->hook;",
          "",
          "[Removed Lines]",
          "338:   L1->nCcalls = getCcalls(L);",
          "",
          "[Added Lines]",
          "299:   L1->nCcalls = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "396:   preinit_thread(L, g);",
          "398:   L->next = NULL;",
          "401:   g->frealloc = f;",
          "402:   g->ud = ud;",
          "",
          "[Removed Lines]",
          "399:   g->Cstacklimit = L->nCcalls = LUAI_MAXCSTACK + CSTACKERR;",
          "",
          "[Added Lines]",
          "360:   g->Cstacklimit = L->nCcalls = 0;",
          "",
          "---------------"
        ],
        "lstate.h||lstate.h": [
          "File: lstate.h -> lstate.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "145: #define decnny(L) ((L)->nCcalls -= 0x10000)",
          "",
          "[Removed Lines]",
          "148: #define incXCcalls(L) ((L)->nCcalls += 0x10000 - CSTACKCF)",
          "151: #define decXCcalls(L) ((L)->nCcalls -= 0x10000 - CSTACKCF)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "389: LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);",
          "390: LUAI_FUNC void luaE_freeCI (lua_State *L);",
          "391: LUAI_FUNC void luaE_shrinkCI (lua_State *L);",
          "393: LUAI_FUNC void luaE_warning (lua_State *L, const char *msg, int tocont);",
          "394: LUAI_FUNC void luaE_warnerror (lua_State *L, const char *where);",
          "",
          "[Removed Lines]",
          "392: LUAI_FUNC void luaE_enterCcall (lua_State *L);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ltests.h||ltests.h": [
          "File: ltests.h -> ltests.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #define LUAI_ASSERT",
          "32: #define UNUSED(x)       (x=0, (void)(x))",
          "",
          "[Removed Lines]",
          "28: #undef LUAI_MAXCSTACK",
          "29: #define LUAI_MAXCSTACK  400",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "luaconf.h||luaconf.h": [
          "File: luaconf.h -> luaconf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "40: @@ LUAI_MAXCSTACK defines the maximum depth for nested calls and",
          "",
          "[Added Lines]",
          "40: @@ LUAI_MAXCCALLS defines the maximum depth for nested calls and",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51: #endif",
          "",
          "[Removed Lines]",
          "49: #if !defined(LUAI_MAXCSTACK)",
          "50: #define LUAI_MAXCSTACK  2000",
          "",
          "[Added Lines]",
          "49: #if !defined(LUAI_MAXCCALLS)",
          "50: #define LUAI_MAXCCALLS  200",
          "",
          "---------------"
        ],
        "lvm.c||lvm.c": [
          "File: lvm.c -> lvm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1126: void luaV_execute (lua_State *L, CallInfo *ci) {",
          "1127:   LClosure *cl;",
          "1128:   TValue *k;",
          "1129:   StkId base;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1127:   const CallInfo *origci = ci;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1615:         vmbreak;",
          "1616:       }",
          "1617:       vmcase(OP_TAILCALL) {",
          "",
          "[Removed Lines]",
          "1614:         ProtectNT(luaD_call(L, ra, nresults));",
          "",
          "[Added Lines]",
          "1616:         if (luaD_precall(L, ra, nresults))",
          "1619:           ci = L->ci;",
          "1620:           goto tailcall;",
          "1621:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1637:           checkstackGCp(L, 1, ra);",
          "1638:         }",
          "1641:           updatetrap(ci);",
          "1643:           ci->func -= delta;",
          "1644:           luaD_poscall(L, ci, cast_int(L->top - ra));",
          "1646:         }",
          "1647:         ci->func -= delta;",
          "",
          "[Removed Lines]",
          "1645:           return;",
          "",
          "[Added Lines]",
          "1652:           goto ret;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1665:           ci->func -= ci->u.l.nextraargs + nparams1;",
          "1667:         luaD_poscall(L, ci, n);",
          "1669:       }",
          "1670:       vmcase(OP_RETURN0) {",
          "1671:         if (L->hookmask) {",
          "",
          "[Removed Lines]",
          "1668:         return;",
          "",
          "[Added Lines]",
          "1675:         goto ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1679:           while (nres-- > 0)",
          "1681:         }",
          "1683:       }",
          "1684:       vmcase(OP_RETURN1) {",
          "1685:         if (L->hookmask) {",
          "",
          "[Removed Lines]",
          "1682:         return;",
          "",
          "[Added Lines]",
          "1689:         goto ret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1698:               setnilvalue(s2v(L->top++));",
          "1699:           }",
          "1700:         }",
          "1702:       }",
          "1703:       vmcase(OP_FORLOOP) {",
          "",
          "[Removed Lines]",
          "1701:         return;",
          "",
          "[Added Lines]",
          "1708:        ret:",
          "1709:         if (ci == origci)",
          "1710:           return;",
          "1711:         else {",
          "1712:           ci = ci->previous;",
          "1713:           goto tailcall;",
          "1714:         }",
          "",
          "---------------"
        ],
        "testes/all.lua||testes/all.lua": [
          "File: testes/all.lua -> testes/all.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "127:   end",
          "129:   Cstacklevel = function ()",
          "132:   end",
          "133: end",
          "",
          "[Removed Lines]",
          "130:     local _, _, ncalls, nci = T.stacklevel()",
          "131:     return ncalls  + nci   -- number of free slots in the C stack",
          "",
          "[Added Lines]",
          "130:     local _, _, ncalls = T.stacklevel()",
          "131:     return ncalls    -- number of C calls",
          "",
          "---------------"
        ],
        "testes/cstack.lua||testes/cstack.lua": [
          "File: testes/cstack.lua -> testes/cstack.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: -- $Id: testes/cstack.lua $",
          "2: -- See Copyright Notice in file all.lua",
          "4: local debug = require \"debug\"",
          "6: print\"testing C-stack overflow detection\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: do return end",
          "",
          "---------------"
        ],
        "testes/errors.lua||testes/errors.lua": [
          "File: testes/errors.lua -> testes/errors.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "530:   if (finalresult) then",
          "531:     assert(res() == finalresult)",
          "532:   end",
          "537: end",
          "539: testrep(\"local a; a\", \",a\", \"= 1\", \",1\")    -- multiple assignment",
          "",
          "[Removed Lines]",
          "533:   s = init .. string.rep(rep, 10000)",
          "534:   local res, msg = load(s)   -- 10000 levels not ok",
          "535:   assert(not res and (string.find(msg, \"too many registers\") or",
          "536:                       string.find(msg, \"stack overflow\")))",
          "",
          "[Added Lines]",
          "533:   s = init .. string.rep(rep, 500)",
          "534:   local res, msg = load(s)   -- 500 levels not ok",
          "535:   assert(not res and string.find(msg, \"too many\"))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "287b302acb8d925178e9edb800f0a8d18c7d35f6",
      "candidate_info": {
        "commit_hash": "287b302acb8d925178e9edb800f0a8d18c7d35f6",
        "repo": "lua/lua",
        "commit_url": "https://github.com/lua/lua/commit/287b302acb8d925178e9edb800f0a8d18c7d35f6",
        "files": [
          "all",
          "ldblib.c",
          "ldo.c",
          "llimits.h",
          "lparser.c",
          "lstate.c",
          "lstate.h",
          "luaconf.h",
          "lvm.c",
          "manual/manual.of",
          "testes/cstack.lua",
          "testes/errors.lua"
        ],
        "message": "Revision of stackless implementation\n\n- more organized handling of 'nCcalls'\n- comments\n- deprecation of 'setcstacklimit'",
        "before_after_code_files": [
          "ldblib.c||ldblib.c",
          "ldo.c||ldo.c",
          "llimits.h||llimits.h",
          "lparser.c||lparser.c",
          "lstate.c||lstate.c",
          "lstate.h||lstate.h",
          "luaconf.h||luaconf.h",
          "lvm.c||lvm.c",
          "manual/manual.of||manual/manual.of",
          "testes/cstack.lua||testes/cstack.lua",
          "testes/errors.lua||testes/errors.lua"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ldo.c||ldo.c"
          ],
          "candidate": [
            "ldo.c||ldo.c"
          ]
        }
      },
      "candidate_diff": {
        "ldblib.c||ldblib.c": [
          "File: ldblib.c -> ldblib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "440: static int db_setcstacklimit (lua_State *L) {",
          "441:   int limit = (int)luaL_checkinteger(L, 1);",
          "442:   int res = lua_setcstacklimit(L, limit);",
          "447:   return 1;",
          "448: }",
          "",
          "[Removed Lines]",
          "443:   if (res == 0)",
          "444:     lua_pushboolean(L, 0);",
          "445:   else",
          "446:     lua_pushinteger(L, res);",
          "",
          "[Added Lines]",
          "443:   lua_pushinteger(L, res);",
          "",
          "---------------"
        ],
        "ldo.c||ldo.c": [
          "File: ldo.c -> ldo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "511: }",
          "524:   if (getCcalls(L) >= LUAI_MAXCCALLS)",
          "529: }",
          "536: void luaD_callnoyield (lua_State *L, StkId func, int nResults) {",
          "540: }",
          "",
          "[Removed Lines]",
          "514: static void stackerror (lua_State *L) {",
          "515:   if (getCcalls(L) == LUAI_MAXCCALLS)",
          "516:     luaG_runerror(L, \"C stack overflow\");",
          "517:   else if (getCcalls(L) >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))",
          "519: }",
          "522: void luaD_call (lua_State *L, StkId func, int nResults) {",
          "523:   L->nCcalls++;",
          "525:     stackerror(L);",
          "528:   L->nCcalls--;",
          "537:   incnny(L);",
          "538:   luaD_call(L, func, nResults);",
          "539:   decnny(L);",
          "",
          "[Added Lines]",
          "520: static void docall (lua_State *L, StkId func, int nResults, int inc) {",
          "521:   L->nCcalls += inc;",
          "523:     luaE_checkcstack(L);",
          "526:   L->nCcalls -= inc;",
          "533: void luaD_call (lua_State *L, StkId func, int nResults) {",
          "534:   return docall(L, func, nResults, 1);",
          "535: }",
          "542:   return docall(L, func, nResults, nyci);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "652:   CallInfo *ci = L->ci;",
          "658:     lua_assert(L->status == LUA_YIELD);",
          "",
          "[Removed Lines]",
          "656:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "684:   }",
          "686:     return resume_error(L, \"cannot resume dead coroutine\", nargs);",
          "690:   luai_userstateresume(L, nargs);",
          "691:   api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);",
          "692:   status = luaD_rawrunprotected(L, resume, &nargs);",
          "",
          "[Removed Lines]",
          "687:   L->nCcalls = (from) ? getCcalls(from) + 1 : 1;",
          "688:   if (getCcalls(L) >= LUAI_MAXCCALLS)",
          "689:     return resume_error(L, \"C stack overflow\", nargs);",
          "",
          "[Added Lines]",
          "689:   L->nCcalls = (from) ? getCcalls(from) : 0;",
          "",
          "---------------"
        ],
        "llimits.h||llimits.h": [
          "File: llimits.h -> llimits.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "234: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243: #if !defined(LUAI_MAXCCALLS)",
          "244: #define LUAI_MAXCCALLS  200",
          "245: #endif",
          "",
          "---------------"
        ],
        "lparser.c||lparser.c": [
          "File: lparser.c -> lparser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "489: }",
          "499: #define leavelevel(ls) ((ls)->L->nCcalls--)",
          "",
          "[Removed Lines]",
          "492: static void enterlevel (LexState *ls) {",
          "493:   lua_State *L = ls->L;",
          "494:   L->nCcalls++;",
          "495:   checklimit(ls->fs, getCcalls(L), LUAI_MAXCCALLS, \"C levels\");",
          "496: }",
          "",
          "[Added Lines]",
          "492: #define enterlevel(ls) luaE_incCstack(ls->L)",
          "",
          "---------------"
        ],
        "lstate.c||lstate.c": [
          "File: lstate.c -> lstate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: LUA_API int lua_setcstacklimit (lua_State *L, unsigned int limit) {",
          "119: }",
          "",
          "[Removed Lines]",
          "100:   global_State *g = G(L);",
          "101:   int ccalls;",
          "103:   ccalls = getCcalls(L);",
          "104:   if (limit >= 40000)",
          "106:   limit += CSTACKERR;",
          "107:   if (L != g-> mainthread)",
          "109:   else if (ccalls <= CSTACKERR)",
          "111:   else {",
          "112:     int diff = limit - g->Cstacklimit;",
          "113:     if (ccalls + diff <= CSTACKERR)",
          "118:   }",
          "",
          "[Added Lines]",
          "100:   UNUSED(L); UNUSED(limit);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172: }",
          "175: static void stack_init (lua_State *L1, lua_State *L) {",
          "176:   int i; CallInfo *ci;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165: void luaE_checkcstack (lua_State *L) {",
          "166:   if (getCcalls(L) == LUAI_MAXCCALLS)",
          "167:     luaG_runerror(L, \"C stack overflow\");",
          "168:   else if (getCcalls(L) >= (LUAI_MAXCCALLS / 10 * 11))",
          "170: }",
          "173: LUAI_FUNC void luaE_incCstack (lua_State *L) {",
          "174:   L->nCcalls++;",
          "175:   if (getCcalls(L) >= LUAI_MAXCCALLS)",
          "176:     luaE_checkcstack(L);",
          "177: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "357:   preinit_thread(L, g);",
          "359:   L->next = NULL;",
          "362:   g->frealloc = f;",
          "363:   g->ud = ud;",
          "",
          "[Removed Lines]",
          "360:   g->Cstacklimit = L->nCcalls = 0;",
          "",
          "[Added Lines]",
          "365:   L->nCcalls = 0;",
          "",
          "---------------"
        ],
        "lstate.h||lstate.h": [
          "File: lstate.h -> lstate.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "112: #define CSTACKCF 10",
          "125: #define CSTACKERR (8 * CSTACKCF)",
          "126: #define CSTACKMARK (CSTACKERR - (CSTACKCF + 2))",
          "127: #define CSTACKERRMARK (CSTACKCF + 2)",
          "131: #define CSTACKTHREAD (2 * CSTACKERR)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145: #define decnny(L) ((L)->nCcalls -= 0x10000)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112: #define nyci (0x10000 | 1)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "383: LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);",
          "384: LUAI_FUNC void luaE_freeCI (lua_State *L);",
          "385: LUAI_FUNC void luaE_shrinkCI (lua_State *L);",
          "386: LUAI_FUNC void luaE_warning (lua_State *L, const char *msg, int tocont);",
          "387: LUAI_FUNC void luaE_warnerror (lua_State *L, const char *where);",
          "392: #endif",
          "",
          "[Removed Lines]",
          "390: #define luaE_exitCcall(L) ((L)->nCcalls++)",
          "",
          "[Added Lines]",
          "350: LUAI_FUNC void luaE_checkcstack (lua_State *L);",
          "351: LUAI_FUNC void luaE_incCstack (lua_State *L);",
          "",
          "---------------"
        ],
        "luaconf.h||luaconf.h": [
          "File: luaconf.h -> luaconf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: @@ LUA_USE_C89 controls the use of non-ISO-C89 features.",
          "",
          "[Removed Lines]",
          "40: @@ LUAI_MAXCCALLS defines the maximum depth for nested calls and",
          "49: #if !defined(LUAI_MAXCCALLS)",
          "50: #define LUAI_MAXCCALLS  200",
          "51: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lvm.c||lvm.c": [
          "File: lvm.c -> lvm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1126: void luaV_execute (lua_State *L, CallInfo *ci) {",
          "1128:   LClosure *cl;",
          "1129:   TValue *k;",
          "1130:   StkId base;",
          "",
          "[Removed Lines]",
          "1127:   const CallInfo *origci = ci;",
          "",
          "[Added Lines]",
          "1127:   CallInfo * const origci = ci;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1648:           updatetrap(ci);",
          "1650:           ci->func -= delta;",
          "1652:           goto ret;",
          "1653:         }",
          "1654:         ci->func -= delta;",
          "",
          "[Removed Lines]",
          "1651:           luaD_poscall(L, ci, cast_int(L->top - ra));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "manual/manual.of||manual/manual.of": [
          "File: manual/manual.of -> manual/manual.of",
          "--- Hunk 1 ---",
          "[Context before]",
          "2436: you are responsible for ensuring consistency.",
          "2437: In particular,",
          "2438: @emph{you are responsible for controlling stack overflow}.",
          "2442: Whenever Lua calls C,",
          "2443: it ensures that the stack has space for",
          "",
          "[Removed Lines]",
          "2439: You can use the function @Lid{lua_checkstack}",
          "2440: to ensure that the stack has enough space for pushing new elements.",
          "",
          "[Added Lines]",
          "2439: When you call any API function,",
          "2440: you must ensure the stack has enough room to accommodate the results.",
          "2442: There is one exception to the above rule:",
          "2443: When you call a Lua function",
          "2444: without a fixed number of results @seeF{lua_call},",
          "2445: Lua ensures that the stack has enough space for all results.",
          "2446: However, it does not ensure any extra space.",
          "2447: So, before pushing anything on the stack after such a call",
          "2448: you should use @Lid{lua_checkstack}.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2446: @id{LUA_MINSTACK} is defined as 20,",
          "2447: so that usually you do not have to worry about stack space",
          "2448: unless your code has loops pushing elements onto the stack.",
          "2457: }",
          "",
          "[Removed Lines]",
          "2450: When you call a Lua function",
          "2451: without a fixed number of results @seeF{lua_call},",
          "2452: Lua ensures that the stack has enough space for all results,",
          "2453: but it does not ensure any extra space.",
          "2454: So, before pushing anything on the stack after such a call",
          "2455: you should use @Lid{lua_checkstack}.",
          "",
          "[Added Lines]",
          "2457: Whenever necessary,",
          "2458: you can use the function @Lid{lua_checkstack}",
          "2459: to ensure that the stack has enough space for pushing new elements.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2695: and this API function yields",
          "2696: (directly or indirectly by calling another function that yields),",
          "2697: Lua cannot return to @id{foo} any more,",
          "2700: To avoid this kind of problem,",
          "2701: Lua raises an error whenever it tries to yield across an API call,",
          "",
          "[Removed Lines]",
          "2698: because the @id{longjmp} removes its frame from the C stack.",
          "",
          "[Added Lines]",
          "2702: because the @id{longjmp} removes its frame from the @N{C stack}.",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2719: it eventually will finish running the callee function.",
          "2720: However,",
          "2721: the callee function cannot return to the original function,",
          "2723: Instead, Lua calls a @def{continuation function},",
          "2724: which was given as an argument to the callee function.",
          "2725: As the name implies,",
          "",
          "[Removed Lines]",
          "2722: because its frame in the C stack was destroyed by the yield.",
          "",
          "[Added Lines]",
          "2726: because its frame in the @N{C stack} was destroyed by the yield.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2842: Converts the @x{acceptable index} @id{idx}",
          "2843: into an equivalent @x{absolute index}",
          "2846: }",
          "",
          "[Removed Lines]",
          "2844: (that is, one that does not depend on the stack top).",
          "",
          "[Added Lines]",
          "2848: (that is, one that does not depend on the stack size).",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4340: Note that, both in case of errors and of a regular return,",
          "4341: by the time the @idx{__close} metamethod runs,",
          "4342: the @N{C stack} was already unwound,",
          "4344: will be out of scope.",
          "4346: }",
          "",
          "[Removed Lines]",
          "4343: so that any automatic C variable declared in the calling function",
          "",
          "[Added Lines]",
          "4347: so that any automatic @N{C variable} declared in the calling function",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4956: }",
          "4972: @APIEntry{void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);|",
          "4973: @apii{0,0,-}",
          "",
          "[Removed Lines]",
          "4958: @APIEntry{int (lua_setcstacklimit) (lua_State *L, unsigned int limit);|",
          "4959: @apii{0,0,-}",
          "4961: Sets a new limit for the C stack.",
          "4962: This limit controls how deeply nested calls can go in Lua,",
          "4963: with the intent of avoiding a stack overflow.",
          "4964: Returns the old limit in case of success,",
          "4965: or zero in case of error.",
          "4966: For more details about this function,",
          "4967: see @Lid{debug.setcstacklimit},",
          "4968: its equivalent in the standard library.",
          "4970: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "8757: }",
          "8787: @LibEntry{debug.sethook ([thread,] hook, mask [, count])|",
          "8789: Sets the given function as the debug hook.",
          "",
          "[Removed Lines]",
          "8759: @LibEntry{debug.setcstacklimit (limit)|",
          "8761: Sets a new limit for the C stack.",
          "8762: This limit controls how deeply nested calls can go in Lua,",
          "8763: with the intent of avoiding a stack overflow.",
          "8764: A limit too small restricts recursive calls pointlessly;",
          "8765: a limit too large exposes the interpreter to stack-overflow crashes.",
          "8766: Unfortunately, there is no way to know a priori",
          "8767: the maximum safe limit for a platform.",
          "8769: Each call made from Lua code counts one unit.",
          "8770: Other operations (e.g., calls made from C to Lua or resuming a coroutine)",
          "8771: may have a higher cost.",
          "8773: This function has the following restrictions:",
          "8774: @description{",
          "8775: @item{It can only be called from the main coroutine (thread);}",
          "8776: @item{It cannot be called while handling a stack-overflow error;}",
          "8777: @item{@id{limit} must be less than 40000;}",
          "8778: @item{@id{limit} cannot be less than the amount of C stack in use.}",
          "8779: }",
          "8780: If a call does not respect some restriction,",
          "8781: it returns a false value.",
          "8782: Otherwise,",
          "8783: the call returns the old limit.",
          "8785: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "testes/cstack.lua||testes/cstack.lua": [
          "File: testes/cstack.lua -> testes/cstack.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: -- $Id: testes/cstack.lua $",
          "2: -- See Copyright Notice in file all.lua",
          "8: print\"testing C-stack overflow detection\"",
          "11: -- Segmentation faults in these tests probably result from a C-stack",
          "18: -- Alternatively, you can ensure a larger stack for the program.",
          "37: local function checkerror (msg, f, ...)",
          "38:   local s, err = pcall(f, ...)",
          "39:   assert(not s and string.find(err, msg))",
          "40: end",
          "64: do  print(\"testing stack overflow in message handling\")",
          "66:   local function loop (x, y, z)",
          "68:     return 1 + loop(x, y, z)",
          "69:   end",
          "70:   local res, msg = xpcall(loop, loop)",
          "71:   assert(msg == \"error in error handling\")",
          "73: end",
          "",
          "[Removed Lines]",
          "4: do return end",
          "6: local debug = require \"debug\"",
          "9: print\"If this test crashes, see its file ('cstack.lua')\"",
          "12: -- overflow. To avoid these errors, you can use the function",
          "13: -- 'debug.setcstacklimit' to set a smaller limit for the use of",
          "14: -- C stack by Lua. After finding a reliable limit, you might want",
          "15: -- to recompile Lua with this limit as the value for",
          "16: -- the constant 'LUAI_MAXCCALLS', which defines the default limit.",
          "17: -- (The default limit is printed by this test.)",
          "20: -- For Linux, a limit up to 30_000 seems Ok. Windows cannot go much",
          "21: -- higher than 2_000.",
          "24: -- get and print original limit",
          "25: local origlimit <const> = debug.setcstacklimit(400)",
          "26: print(\"default stack limit: \" .. origlimit)",
          "29: -- Do the tests using the original limit. Or else you may want to change",
          "30: -- 'currentlimit' to lower values to avoid a seg. fault or to higher",
          "31: -- values to check whether they are reliable.",
          "32: local currentlimit <const> =  origlimit",
          "33: debug.setcstacklimit(currentlimit)",
          "34: print(\"current stack limit: \" .. currentlimit)",
          "42: -- auxiliary function to keep 'count' on the screen even if the program",
          "43: -- crashes.",
          "44: local count",
          "45: local back = string.rep(\"\\b\", 8)",
          "46: local function progress ()",
          "47:   count = count + 1",
          "48:   local n = string.format(\"%-8d\", count)",
          "49:   io.stderr:write(back, n)   -- erase previous value and write new one",
          "50: end",
          "53: do    print(\"testing simple recursion:\")",
          "54:   count = 0",
          "55:   local function foo ()",
          "56:     progress()",
          "57:     foo()   -- do recursive calls until a stack error (or crash)",
          "58:   end",
          "59:   checkerror(\"stack overflow\", foo)",
          "60:   print(\"\\tfinal count: \", count)",
          "61: end",
          "65:   count = 0",
          "67:     progress()",
          "72:   print(\"\\tfinal count: \", count)",
          "",
          "[Added Lines]",
          "8: -- overflow. To avoid these errors, you should set a smaller limit for",
          "9: -- the use of C stack by Lua, by changing the constant 'LUAI_MAXCCALLS'.",
          "19:   local count = 0",
          "21:     count = count + 1",
          "26:   print(\"final count: \", count)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82:   end",
          "83:   local m = f(80)",
          "84:   assert(#m == 80)",
          "86: end",
          "89: do  print(\"testing stack-overflow in recursive 'gsub'\")",
          "91:   local function foo ()",
          "93:     string.gsub(\"a\", \".\", foo)",
          "94:   end",
          "95:   checkerror(\"stack overflow\", foo)",
          "98:   print(\"testing stack-overflow in recursive 'gsub' with metatables\")",
          "100:   local t = setmetatable({}, {__index = foo})",
          "101:   foo = function ()",
          "102:     count = count + 1",
          "104:     string.gsub(\"a\", \".\", t)",
          "105:   end",
          "106:   checkerror(\"stack overflow\", foo)",
          "108: end",
          "110: do   -- bug in 5.4.0",
          "111:   print(\"testing limits in coroutines inside deep calls\")",
          "113:   local lim = 1000",
          "114:   local function stack (n)",
          "116:     if n > 0 then return stack(n - 1) + 1",
          "117:     else coroutine.wrap(function ()",
          "118:            stack(lim)",
          "119:          end)()",
          "120:     end",
          "121:   end",
          "124: end",
          "147:   end",
          "175: end",
          "178: print'OK'",
          "",
          "[Removed Lines]",
          "85:   checkerror(\"too complex\", f, 200000)",
          "90:   count = 0",
          "92:     progress()",
          "96:   print(\"\\tfinal count: \", count)",
          "99:   count = 0",
          "103:     progress(count)",
          "107:   print(\"\\tfinal count: \", count)",
          "112:   count = 0",
          "115:     progress()",
          "123:   print(xpcall(stack, function () return \"ok\" end, lim))",
          "127: do  print(\"testing changes in C-stack limit\")",
          "129:   -- Just an alternative limit, different from the current one",
          "130:   -- (smaller to avoid stack overflows)",
          "131:   local alterlimit <const> = currentlimit * 8 // 10",
          "133:   assert(not debug.setcstacklimit(0))        -- limit too small",
          "134:   assert(not debug.setcstacklimit(50000))    -- limit too large",
          "135:   local co = coroutine.wrap (function ()",
          "136:                return debug.setcstacklimit(alterlimit)",
          "137:              end)",
          "138:   assert(not co())         -- cannot change C stack inside coroutine",
          "140:   local n",
          "141:   local function foo () n = n + 1; foo () end",
          "143:   local function check ()",
          "144:     n = 0",
          "145:     pcall(foo)",
          "146:     return n",
          "149:   -- set limit to 'alterlimit'",
          "150:   assert(debug.setcstacklimit(alterlimit) == currentlimit)",
          "151:   local limalter <const> = check()",
          "152:   -- set a very low limit (given that there are already several active",
          "153:   -- calls to arrive here)",
          "154:   local lowlimit <const> = 38",
          "155:   assert(debug.setcstacklimit(lowlimit) == alterlimit)",
          "156:   -- usable limit is much lower, due to active calls",
          "157:   local actuallow = check()",
          "158:   assert(actuallow < lowlimit - 30)",
          "159:   -- now, add 'lowlimit' extra slots, which should all be available",
          "160:   assert(debug.setcstacklimit(lowlimit + lowlimit) == lowlimit)",
          "161:   local lim2 <const> = check()",
          "162:   assert(lim2 == actuallow + lowlimit)",
          "165:   -- 'setcstacklimit' works inside protected calls. (The new stack",
          "166:   -- limit is kept when 'pcall' returns.)",
          "167:   assert(pcall(function ()",
          "168:     assert(debug.setcstacklimit(alterlimit) == lowlimit * 2)",
          "169:     assert(check() <= limalter)",
          "170:   end))",
          "172:   assert(check() == limalter)",
          "173:   -- restore original limit",
          "174:   assert(debug.setcstacklimit(origlimit) == alterlimit)",
          "",
          "[Added Lines]",
          "39:   checkerror(\"too complex\", f, 2000)",
          "44:   local count = 0",
          "46:     count = count + 1",
          "50:   print(\"final count: \", count)",
          "53:   local count = 0",
          "60:   print(\"final count: \", count)",
          "66:   local count = 0",
          "71:            count = count + 1",
          "77:   local st, msg = xpcall(stack, function () return \"ok\" end, lim)",
          "78:   assert(not st and msg == \"ok\")",
          "79:   print(\"final count: \", count)",
          "83: do",
          "84:   print(\"nesting of resuming yielded coroutines\")",
          "85:   local count = 0",
          "87:   local function body ()",
          "88:     coroutine.yield()",
          "89:     local f = coroutine.wrap(body)",
          "90:     f();  -- start new coroutine (will stop in previous yield)",
          "91:     count = count + 1",
          "92:     f()   -- call it recursively",
          "95:   local f = coroutine.wrap(body)",
          "96:   f()",
          "97:   assert(not pcall(f))",
          "98:   print(\"final count: \", count)",
          "",
          "---------------"
        ],
        "testes/errors.lua||testes/errors.lua": [
          "File: testes/errors.lua -> testes/errors.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "532:   end",
          "533:   s = init .. string.rep(rep, 500)",
          "534:   local res, msg = load(s)   -- 500 levels not ok",
          "536: end",
          "538: testrep(\"local a; a\", \",a\", \"= 1\", \",1\")    -- multiple assignment",
          "",
          "[Removed Lines]",
          "535:   assert(not res and string.find(msg, \"too many\"))",
          "",
          "[Added Lines]",
          "535:   assert(not res and (string.find(msg, \"too many\") or",
          "536:                       string.find(msg, \"overflow\")))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94cbe4651156a84dd9114d7daaa61acd050adbe0",
      "candidate_info": {
        "commit_hash": "94cbe4651156a84dd9114d7daaa61acd050adbe0",
        "repo": "lua/lua",
        "commit_url": "https://github.com/lua/lua/commit/94cbe4651156a84dd9114d7daaa61acd050adbe0",
        "files": [
          "lcode.c",
          "ldo.c",
          "lparser.h",
          "manual/manual.of"
        ],
        "message": "Details\n\n- small corrections in the manual\n- ldo.c: 'docall' -> 'ccall' ('docall' already used in 'lua.c')\n- comments",
        "before_after_code_files": [
          "lcode.c||lcode.c",
          "ldo.c||ldo.c",
          "lparser.h||lparser.h",
          "manual/manual.of||manual/manual.of"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ldo.c||ldo.c"
          ],
          "candidate": [
            "ldo.c||ldo.c"
          ]
        }
      },
      "candidate_diff": {
        "lcode.c||lcode.c": [
          "File: lcode.c -> lcode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "947:       return e->u.info;",
          "948:     }",
          "949:   }",
          "951:   return e->u.info;",
          "952: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951:        to hold the jump values, because it is a local variable.",
          "",
          "---------------"
        ],
        "ldo.c||ldo.c": [
          "File: ldo.c -> ldo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "542:   CallInfo *ci;",
          "543:   L->nCcalls += inc;",
          "544:   if (unlikely(getCcalls(L) >= LUAI_MAXCCALLS))",
          "",
          "[Removed Lines]",
          "541: static void docall (lua_State *L, StkId func, int nResults, int inc) {",
          "",
          "[Added Lines]",
          "541: static void ccall (lua_State *L, StkId func, int nResults, int inc) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "557: void luaD_call (lua_State *L, StkId func, int nResults) {",
          "559: }",
          "",
          "[Removed Lines]",
          "558:   return docall(L, func, nResults, 1);",
          "",
          "[Added Lines]",
          "558:   ccall(L, func, nResults, 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "565: void luaD_callnoyield (lua_State *L, StkId func, int nResults) {",
          "567: }",
          "",
          "[Removed Lines]",
          "566:   return docall(L, func, nResults, nyci);",
          "",
          "[Added Lines]",
          "566:   ccall(L, func, nResults, nyci);",
          "",
          "---------------"
        ],
        "lparser.h||lparser.h": [
          "File: lparser.h -> lparser.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: typedef enum {",
          "",
          "[Removed Lines]",
          "26:   VVOID,  /* when 'expdesc' describes the last expression a list,",
          "",
          "[Added Lines]",
          "26:   VVOID,  /* when 'expdesc' describes the last expression of a list,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:   VLOCAL,  /* local variable; var.sidx = stack index (local register);",
          "42:   VINDEXED,  /* indexed variable;",
          "43:                 ind.t = table register;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41:   VCONST,  /* compile-time <const> variable;",
          "",
          "---------------"
        ],
        "manual/manual.of||manual/manual.of": [
          "File: manual/manual.of -> manual/manual.of",
          "--- Hunk 1 ---",
          "[Context before]",
          "2516: and then invalidate pointers to internal strings.",
          "2517: To allow a safe use of these pointers,",
          "2518: The API guarantees that any pointer to a string in a stack index",
          "2520: When the index is a pseudo-index (referring to an upvalue),",
          "2521: the pointer is valid while the corresponding call is active and",
          "2522: the corresponding upvalue is not modified.",
          "",
          "[Removed Lines]",
          "2519: is valid while the value at that index is neither modified nor popped.",
          "",
          "[Added Lines]",
          "2519: is valid while the string value at that index is not removed from the stack.",
          "2520: (It can be moved to another index, though.)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3744: }",
          "3746: @APIEntry{void lua_pop (lua_State *L, int n);|",
          "3749: Pops @id{n} elements from the stack.",
          "3751: }",
          "3753: @APIEntry{void lua_pushboolean (lua_State *L, int b);|",
          "",
          "[Removed Lines]",
          "3747: @apii{n,0,-}",
          "",
          "[Added Lines]",
          "3748: @apii{n,0,e}",
          "3752: This function can run arbitrary code when removing an index",
          "3753: marked as to-be-closed from the stack.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4227: }",
          "4229: @APIEntry{void lua_settop (lua_State *L, int index);|",
          "4232: Accepts any index, @N{or 0},",
          "4233: and sets the stack top to this index.",
          "",
          "[Removed Lines]",
          "4230: @apii{?,?,-}",
          "",
          "[Added Lines]",
          "4234: @apii{?,?,e}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4235: then the new elements are filled with @nil.",
          "4236: If @id{index} @N{is 0}, then all stack elements are removed.",
          "4238: }",
          "4240: @APIEntry{void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);|",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4242: This function can run arbitrary code when removing an index",
          "4243: marked as to-be-closed from the stack.",
          "",
          "---------------"
        ]
      }
    }
  ]
}
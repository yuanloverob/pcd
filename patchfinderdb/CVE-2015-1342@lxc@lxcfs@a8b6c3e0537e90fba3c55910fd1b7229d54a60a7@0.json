{
  "cve_id": "CVE-2015-1342",
  "cve_desc": "LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",
  "repo": "lxc/lxcfs",
  "patch_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
  "patch_info": {
    "commit_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "repo": "lxc/lxcfs",
    "commit_url": "https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "files": [
      "Makefile.am",
      "lxcfs.c",
      "tests/test_confinement.sh",
      "tests/test_syscalls.c"
    ],
    "message": "Fix checking of parent directories\n\nTaken from the justification in the launchpad bug:\n\nTo a task in freezer cgroup /a/b/c/d, it should appear that there are no\ncgroups other than its descendents. Since this is a filesystem, we must have\nthe parent directories, but each parent cgroup should only contain the child\nwhich the task can see.\n\nSo, when this task looks at /a/b, it should see only directory 'c' and no\nfiles. Attempt to create /a/b/x should result in -EPERM, whether /a/b/x already\nexists or not. Attempts to query /a/b/x should result in -ENOENT whether /a/b/x\nexists or not. Opening /a/b/tasks should result in -ENOENT.\n\nThe caller_may_see_dir checks specifically whether a task may see a cgroup\ndirectory - i.e. /a/b/x if opening /a/b/x/tasks, and /a/b/c/d if doing\nopendir('/a/b/c/d').\n\ncaller_is_in_ancestor() will return true if the caller in /a/b/c/d looks at\n/a/b/c/d/e. If the caller is in a child cgroup of the queried one - i.e. if the\ntask in /a/b/c/d queries /a/b, then *nextcg will container the next (the only)\ndirectory which he can see in the path - 'c'.\n\nBeyond this, regular DAC permissions should apply, with the\nroot-in-user-namespace privilege over its mapped uids being respected. The\nfc_may_access check does this check for both directories and files.\n\nThis is CVE-2015-1342 (LP: #1508481)\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
    "before_after_code_files": [
      "Makefile.am||Makefile.am",
      "lxcfs.c||lxcfs.c",
      "tests/test_confinement.sh||tests/test_confinement.sh",
      "tests/test_syscalls.c||tests/test_syscalls.c"
    ]
  },
  "patch_diff": {
    "Makefile.am||Makefile.am": [
      "File: Makefile.am -> Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: TEST_READ: tests/test-read.c",
      "31:  $(CC) -o tests/test-read tests/test-read.c",
      "33: TEST_CPUSET: tests/cpusetrange.c cpuset.c",
      "34:  $(CC) -o tests/cpusetrange tests/cpusetrange.c cpuset.c",
      "38: distclean:",
      "39:  rm -rf .deps/ \\",
      "",
      "[Removed Lines]",
      "36: tests: TEST_READ TEST_CPUSET",
      "",
      "[Added Lines]",
      "34: TEST_SYSCALLS: tests/test_syscalls.c",
      "35:  $(CC) -o tests/test_syscalls tests/test_syscalls.c",
      "37: tests: TEST_READ TEST_CPUSET TEST_SYSCALLS",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "60:   lxcfs.o \\",
      "61:   m4/ \\",
      "62:   missing \\",
      "",
      "[Removed Lines]",
      "63:   stamp-h1",
      "",
      "[Added Lines]",
      "64:   stamp-h1 \\",
      "65:   tests/test_syscalls",
      "",
      "---------------"
    ],
    "lxcfs.c||lxcfs.c": [
      "File: lxcfs.c -> lxcfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "379: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
      "380: {",
      "383:  bool answer = false;",
      "392:   return false;",
      "420:   }",
      "421:   answer = true;",
      "422:   goto out;",
      "423:  }",
      "425: out:",
      "428:  return answer;",
      "429: }",
      "",
      "[Removed Lines]",
      "381:  char fnam[PROCLEN];",
      "382:  FILE *f;",
      "384:  char *line = NULL;",
      "385:  size_t len = 0;",
      "386:  int ret;",
      "388:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
      "389:  if (ret < 0 || ret >= PROCLEN)",
      "390:   return false;",
      "391:  if (!(f = fopen(fnam, \"r\")))",
      "394:  while (getline(&line, &len, f) != -1) {",
      "395:   char *c1, *c2, *linecmp;",
      "396:   if (!line[0])",
      "397:    continue;",
      "398:   c1 = strchr(line, ':');",
      "399:   if (!c1)",
      "400:    goto out;",
      "401:   c1++;",
      "402:   c2 = strchr(c1, ':');",
      "403:   if (!c2)",
      "404:    goto out;",
      "406:   if (strcmp(c1, contrl) != 0)",
      "407:    continue;",
      "408:   c2++;",
      "409:   stripnewline(c2);",
      "410:   prune_init_slice(c2);",
      "415:   linecmp = *cg == '/' ? c2 : c2+1;",
      "416:   if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "417:    if (nextcg)",
      "419:    goto out;",
      "426:  fclose(f);",
      "427:  free(line);",
      "",
      "[Added Lines]",
      "388:  char *c2 = get_pid_cgroup(pid, contrl);",
      "389:  char *linecmp;",
      "391:  if (!c2)",
      "393:  prune_init_slice(c2);",
      "399:  linecmp = *cg == '/' ? c2 : c2+1;",
      "400:  if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "401:   if (nextcg) {",
      "404:   goto out;",
      "405:  }",
      "406:  answer = true;",
      "408: out:",
      "409:  free(c2);",
      "410:  return answer;",
      "411: }",
      "416: static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)",
      "417: {",
      "418:  bool answer = false;",
      "419:  char *c2, *task_cg;",
      "420:  size_t target_len, task_len;",
      "422:  if (strcmp(cg, \"/\") == 0)",
      "423:   return true;",
      "425:  c2 = get_pid_cgroup(pid, contrl);",
      "427:  if (!c2)",
      "428:   return false;",
      "430:  task_cg = c2 + 1;",
      "431:  target_len = strlen(cg);",
      "432:  task_len = strlen(task_cg);",
      "433:  if (strcmp(cg, task_cg) == 0) {",
      "437:  if (target_len < task_len) {",
      "439:   if (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')",
      "440:    answer = true;",
      "441:   goto out;",
      "442:  }",
      "443:  if (target_len > task_len) {",
      "445:   if (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')",
      "446:    answer = true;",
      "447:   goto out;",
      "448:  }",
      "451:  free(c2);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "554:  if (is_child_cgroup(controller, path1, path2)) {",
      "555:   if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {",
      "557:    sb->st_mode = S_IFDIR | 00555;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "579:   if (!caller_may_see_dir(fc->pid, controller, cgroup)) {",
      "580:    ret = -ENOENT;",
      "581:    goto out;",
      "582:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "630:   }",
      "631:  }",
      "635:  }",
      "",
      "[Removed Lines]",
      "633:  if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
      "634:   return -EACCES;",
      "",
      "[Added Lines]",
      "661:  if (cgroup) {",
      "662:   if (!caller_may_see_dir(fc->pid, controller, cgroup))",
      "663:    return -ENOENT;",
      "664:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
      "665:    return -EACCES;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "780:  }",
      "781:  free_key(k);",
      "783:  if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {",
      "785:   ret = -EACCES;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "814:  if (!caller_may_see_dir(fc->pid, controller, path1)) {",
      "815:   ret = -ENOENT;",
      "816:   goto out;",
      "817:  }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1563: int cg_mkdir(const char *path, mode_t mode)",
      "1564: {",
      "1565:  struct fuse_context *fc = fuse_get_context();",
      "1567:  const char *cgroup;",
      "1568:  int ret;",
      "",
      "[Removed Lines]",
      "1566:  char *fpath = NULL, *path1, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1601:  char *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1585:  else",
      "1586:   path1 = cgdir;",
      "1588:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {",
      "1589:   ret = -EACCES;",
      "1590:   goto out;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1623:  if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {",
      "1624:   if (fpath && strcmp(next, fpath) == 0)",
      "1625:    ret = -EEXIST;",
      "1626:   else",
      "1627:    ret = -ENOENT;",
      "1628:   goto out;",
      "1629:  }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1600: out:",
      "1601:  free(cgdir);",
      "1602:  return ret;",
      "1603: }",
      "1605: static int cg_rmdir(const char *path)",
      "1606: {",
      "1607:  struct fuse_context *fc = fuse_get_context();",
      "1609:  const char *cgroup;",
      "1610:  int ret;",
      "",
      "[Removed Lines]",
      "1608:  char *fpath = NULL, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1645:  free(next);",
      "1652:  char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1626:   goto out;",
      "1627:  }",
      "1631:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {",
      "1632:   ret = -EACCES;",
      "1633:   goto out;",
      "",
      "[Removed Lines]",
      "1629:  fprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",",
      "1630:    controller, cgdir, path);",
      "",
      "[Added Lines]",
      "1673:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {",
      "1674:   if (!fpath || strcmp(next, fpath) == 0)",
      "1675:    ret = -EBUSY;",
      "1676:   else",
      "1677:    ret = -ENOENT;",
      "1678:   goto out;",
      "1679:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1647: out:",
      "1648:  free(cgdir);",
      "1649:  return ret;",
      "1650: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1699:  free(next);",
      "",
      "---------------"
    ],
    "tests/test_confinement.sh||tests/test_confinement.sh": [
      "File: tests/test_confinement.sh -> tests/test_confinement.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #!/bin/bash",
      "3: set -ex",
      "5: [ $(id -u) -eq 0 ]",
      "7: d=$(mktemp -t -d tmp.XXX)",
      "8: d2=$(mktemp -t -d tmp.XXX)",
      "10: pid=-1",
      "11: cleanup() {",
      "12:  [ $pid -ne -1 ] && kill -9 $pid",
      "13:  umount -l $d || true",
      "14:  umount -l $d2 || true",
      "15:  rm -rf $d $d2",
      "16: }",
      "18: cmdline=$(realpath $0)",
      "19: dirname=$(dirname ${cmdline})",
      "20: topdir=$(dirname ${dirname})",
      "22: trap cleanup EXIT HUP INT TERM",
      "24: ${topdir}/lxcfs $d &",
      "25: pid=$!",
      "27: # put ourselves into x1",
      "28: cgm movepidabs freezer / $$",
      "29: cgm create freezer x1",
      "30: cgm movepid freezer x1 $$",
      "32: mount -t cgroup -o freezer freezer $d2",
      "33: sudo rmdir $d2/lxcfs_test_a1/lxcfs_test_a2 || true",
      "34: sudo rmdir $d2/lxcfs_test_a1 || true",
      "36: echo \"Making sure root cannot mkdir\"",
      "37: bad=0",
      "38: mkdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "39: if [ \"${bad}\" -eq 1 ]; then",
      "40:  false",
      "41: fi",
      "43: echo \"Making sure root cannot rmdir\"",
      "44: mkdir $d2/lxcfs_test_a1",
      "45: mkdir $d2/lxcfs_test_a1/lxcfs_test_a2",
      "46: rmdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "47: if [ \"${bad}\" -eq 1 ]; then",
      "48:  false",
      "49: fi",
      "50: [ -d $d2/lxcfs_test_a1 ]",
      "51: rmdir $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2 && bad=1",
      "52: if [ \"${bad}\" -eq 1 ]; then",
      "53:  false",
      "54: fi",
      "55: [ -d $d2/lxcfs_test_a1/lxcfs_test_a2 ]",
      "57: echo \"Making sure root cannot read/write\"",
      "58: sleep 200 &",
      "59: p=$!",
      "60: echo $p > $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "61: if [ \"${bad}\" -eq 1 ]; then",
      "62:  false",
      "63: fi",
      "64: cat $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "65: if [ \"${bad}\" -eq 1 ]; then",
      "66:  false",
      "67: fi",
      "68: echo $p > $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "69: if [ \"${bad}\" -eq 1 ]; then",
      "70:  false",
      "71: fi",
      "72: cat $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "73: if [ \"${bad}\" -eq 1 ]; then",
      "74:  false",
      "75: fi",
      "77: # make sure things like truncate and access don't leak info about",
      "78: # the /lxcfs_test_a1 cgroup which we shouldn't be able to reach",
      "79: echo \"Testing other system calls\"",
      "80: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1",
      "81: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2",
      "83: echo \"Making sure root can act on descendents\"",
      "84: mycg=$(cgm getpidcgroupabs freezer $$)",
      "85: newcg=${mycg}/lxcfs_test_a1",
      "86: rmdir $d2/$newcg || true  # cleanup previosu run",
      "87: mkdir $d/cgroup/freezer/$newcg",
      "88: echo $p > $d/cgroup/freezer/$newcg/tasks",
      "89: cat $d/cgroup/freezer/$newcg/tasks",
      "90: kill -9 $p",
      "91: while [ `wc -l $d/cgroup/freezer/$newcg/tasks | awk '{ print $1 }'` -ne 0 ]; do",
      "92:  sleep 1",
      "93: done",
      "94: rmdir $d/cgroup/freezer/$newcg",
      "96: echo \"All tests passed!\"",
      "",
      "---------------"
    ],
    "tests/test_syscalls.c||tests/test_syscalls.c": [
      "File: tests/test_syscalls.c -> tests/test_syscalls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #define _GNU_SOURCE",
      "2: #include <stdio.h>",
      "3: #include <stdlib.h>",
      "4: #include <string.h>",
      "5: #include <unistd.h>",
      "6: #include <sys/types.h>",
      "7: #include <sys/socket.h>",
      "8: #include <linux/un.h>",
      "9: #include <attr/xattr.h>",
      "10: #include <utime.h>",
      "11: #include <sys/stat.h>",
      "12: #include <sys/mount.h>",
      "13: #include <libgen.h>",
      "14: #include <fcntl.h>",
      "15: #include <errno.h>",
      "18: void test_open(const char *path)",
      "19: {",
      "20:  int fd = open(path, O_RDONLY);",
      "21:  if (fd >= 0) {",
      "22:   fprintf(stderr, \"leak at open of %s\\n\", path);",
      "23:   exit(1);",
      "24:  }",
      "25:  if (errno != ENOENT) {",
      "26:   fprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);",
      "27:   exit(1);",
      "28:  }",
      "29: }",
      "31: void test_stat(const char *path)",
      "32: {",
      "33:  struct stat sb;",
      "34:  if (stat(path, &sb) >= 0) {",
      "35:   fprintf(stderr, \"leak at stat of %s\\n\", path);",
      "36:   exit(1);",
      "37:  }",
      "38:  if (errno != ENOENT) {",
      "39:   fprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);",
      "40:   exit(1);",
      "41:  }",
      "42: }",
      "44: void test_access(const char *path)",
      "45: {",
      "46:  if (access(path, O_RDONLY) >= 0) {",
      "47:   fprintf(stderr, \"leak at access of %s\\n\", path);",
      "48:   exit(1);",
      "49:  }",
      "50:  if (errno != ENOENT) {",
      "51:   fprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);",
      "52:   exit(1);",
      "53:  }",
      "54: }",
      "56: void test_bind(const char *path)",
      "57: {",
      "58:  int sfd;",
      "59:  struct sockaddr_un my_addr, peer_addr;",
      "61:  sfd = socket(AF_UNIX, SOCK_STREAM, 0);",
      "63:  if (sfd < 0) {",
      "64:   fprintf(stderr, \"Failed to open a socket for bind test\\n\");",
      "65:   exit(1);",
      "66:  }",
      "67:  memset(&my_addr, 0, sizeof(struct sockaddr_un));",
      "68:  my_addr.sun_family = AF_UNIX;",
      "69:  strncpy(my_addr.sun_path, path,",
      "70:    sizeof(my_addr.sun_path) - 1);",
      "71:  if (bind(sfd, (struct sockaddr *) &my_addr,",
      "72:     sizeof(struct sockaddr_un)) != -1) {",
      "73:   fprintf(stderr, \"leak at bind of %s\\n\", path);",
      "74:   exit(1);",
      "75:  }",
      "76:  if (errno != ENOENT && errno != ENOSYS) {",
      "77:   fprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));",
      "78:   exit(1);",
      "79:  }",
      "80:  close(sfd);",
      "81: }",
      "83: void test_bindmount(const char *path)",
      "84: {",
      "85:  if (mount(path, path, \"none\", MS_BIND, NULL) == 0) {",
      "86:   fprintf(stderr, \"leak at bind mount of %s\\n\", path);",
      "87:   exit(1);",
      "88:  }",
      "89: }",
      "91: void test_truncate(const char *path)",
      "92: {",
      "93:  if (truncate(path, 0) == 0) {",
      "94:   fprintf(stderr, \"leak at truncate of %s\\n\", path);",
      "95:   exit(1);",
      "96:  }",
      "97: }",
      "99: void test_chdir(const char *path)",
      "100: {",
      "101:  if (chdir(path) == 0) {",
      "102:   fprintf(stderr, \"leak at chdir to %s\\n\", path);",
      "103:   exit(1);",
      "104:  }",
      "105: }",
      "107: void test_rename(const char *path)",
      "108: {",
      "109:  char *d = strdupa(path), *tmpname;",
      "110:  d = dirname(d);",
      "111:  size_t len = strlen(path) + 30;",
      "113:  tmpname = alloca(len);",
      "114:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "115:  if (rename(path, tmpname) == 0 || errno != ENOENT) {",
      "116:   fprintf(stderr, \"leak at rename of %s\\n\", path);",
      "117:   exit(1);",
      "118:  }",
      "119: }",
      "121: void test_mkdir(const char *path)",
      "122: {",
      "123:  size_t len = strlen(path) + 30;",
      "124:  char *tmpname = alloca(len);",
      "125:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "127:  if (mkdir(path, 0755) == 0) {",
      "128:   fprintf(stderr, \"leak at mkdir of %s\\n\", path);",
      "129:   exit(1);",
      "130:  }",
      "131:  if (errno != ENOENT) {",
      "132:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "133:   exit(1);",
      "134:  }",
      "135:  if (mkdir(tmpname, 0755) == 0) {",
      "136:   fprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);",
      "137:   exit(1);",
      "138:  }",
      "139:  if (errno != ENOENT) {",
      "140:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "141:   exit(1);",
      "142:  }",
      "143: }",
      "145: void test_rmdir(const char *path)",
      "146: {",
      "147:  size_t len = strlen(path) + 30;",
      "148:  char *tmpname = alloca(len);",
      "149:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "151:  if (rmdir(path) == 0 || errno != ENOENT) {",
      "152:   fprintf(stderr, \"leak at rmdir of %s\\n\", path);",
      "153:   exit(1);",
      "154:  }",
      "155:  if (rmdir(tmpname) == 0 || errno != ENOENT) {",
      "156:   fprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);",
      "157:   exit(1);",
      "158:  }",
      "159: }",
      "161: void test_creat(const char *path)",
      "162: {",
      "163:  if (creat(path, 0755) >= 0) {",
      "164:   fprintf(stderr, \"leak at creat of %s\\n\", path);",
      "165:   exit(1);",
      "166:  }",
      "167:  if (errno != ENOENT && errno != ENOSYS) {",
      "168:   fprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));",
      "169:   exit(1);",
      "170:  }",
      "171: }",
      "173: void test_link(const char *path)",
      "174: {",
      "175:  char *d = strdupa(path), *tmpname;",
      "176:  d = dirname(d);",
      "177:  size_t len = strlen(path) + 30;",
      "178:  tmpname = alloca(len);",
      "179:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "181:  if (link(path, tmpname) == 0) {",
      "182:   fprintf(stderr, \"leak at link of %s\\n\", path);",
      "183:   exit(1);",
      "184:  }",
      "185:  if (errno != ENOENT && errno != ENOSYS) {",
      "186:   fprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));",
      "187:   exit(1);",
      "188:  }",
      "190:  if (link(tmpname, path) == 0) {",
      "191:   fprintf(stderr, \"leak at link (2) of %s\\n\", path);",
      "192:   exit(1);",
      "193:  }",
      "194:  if (errno != ENOENT && errno != ENOSYS) {",
      "195:   fprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "196:   exit(1);",
      "197:  }",
      "198: }",
      "200: void test_unlink(const char *path)",
      "201: {",
      "202:  if (unlink(path) == 0) {",
      "203:   fprintf(stderr, \"leak at unlink of %s\\n\", path);",
      "204:   exit(1);",
      "205:  }",
      "206:  if (errno != ENOENT && errno != ENOSYS) {",
      "207:   fprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));",
      "208:   exit(1);",
      "209:  }",
      "210: }",
      "212: void test_symlink(const char *path)",
      "213: {",
      "214:  char *d = strdupa(path), *tmpname;",
      "215:  d = dirname(d);",
      "216:  size_t len = strlen(path) + 30;",
      "217:  tmpname = alloca(len);",
      "218:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "220:  if (symlink(tmpname, path) == 0) {",
      "221:   fprintf(stderr, \"leak at symlink of %s\\n\", path);",
      "222:   exit(1);",
      "223:  }",
      "224:  if (errno != ENOENT && errno != ENOSYS) {",
      "225:   fprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));",
      "226:   exit(1);",
      "227:  }",
      "228:  if (symlink(path, tmpname) == 0) {",
      "229:   fprintf(stderr, \"leak at symlink (2) of %s\\n\", path);",
      "230:   exit(1);",
      "231:  }",
      "232:  if (errno != ENOENT && errno != ENOSYS) {",
      "233:   fprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "234:   exit(1);",
      "235:  }",
      "236: }",
      "238: void test_readlink(const char *path)",
      "239: {",
      "240:  char *dest = alloca(2 * strlen(path));",
      "242:  if (readlink(path, dest, 2 * strlen(path)) >= 0) {",
      "243:   fprintf(stderr, \"leak at readlink of %s\\n\", path);",
      "244:   exit(1);",
      "245:  }",
      "246:  if (errno != ENOENT && errno != ENOSYS) {",
      "247:   fprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));",
      "248:   exit(1);",
      "249:  }",
      "250: }",
      "252: void test_chmod(const char *path)",
      "253: {",
      "254:  if (chmod(path, 0755) == 0) {",
      "255:   fprintf(stderr, \"leak at chmod of %s\\n\", path);",
      "256:   exit(1);",
      "257:  }",
      "258:  if (errno != ENOENT && errno != ENOSYS) {",
      "259:   fprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));",
      "260:   exit(1);",
      "261:  }",
      "262: }",
      "264: void test_chown(const char *path)",
      "265: {",
      "266:  if (chown(path, 0, 0) == 0) {",
      "267:   fprintf(stderr, \"leak at chown of %s\\n\", path);",
      "268:   exit(1);",
      "269:  }",
      "270:  if (errno != ENOENT && errno != ENOSYS) {",
      "271:   fprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));",
      "272:   exit(1);",
      "273:  }",
      "274: }",
      "276: void test_lchown(const char *path)",
      "277: {",
      "278:  if (lchown(path, 0, 0) == 0) {",
      "279:   fprintf(stderr, \"leak at lchown of %s\\n\", path);",
      "280:   exit(1);",
      "281:  }",
      "282:  if (errno != ENOENT && errno != ENOSYS) {",
      "283:   fprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));",
      "284:   exit(1);",
      "285:  }",
      "286: }",
      "288: void test_mknod(const char *path)",
      "289: {",
      "290:  if (mknod(path, 0755, makedev(0, 0)) == 0) {",
      "291:   fprintf(stderr, \"leak at mknod of %s\\n\", path);",
      "292:   exit(1);",
      "293:  }",
      "294:  if (errno != ENOENT && errno != ENOSYS) {",
      "295:   fprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));",
      "296:   exit(1);",
      "297:  }",
      "298: }",
      "300: void test_chroot(const char *path)",
      "301: {",
      "302:  if (chroot(path) == 0) {",
      "303:   fprintf(stderr, \"leak at chroot of %s\\n\", path);",
      "304:   exit(1);",
      "305:  }",
      "306:  if (errno != ENOENT && errno != ENOSYS) {",
      "307:   fprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));",
      "308:   exit(1);",
      "309:  }",
      "310: }",
      "312: void test_xattrs(const char *path)",
      "313: {",
      "325:   char value[200];",
      "326:   if (getxattr(path, \"security.selinux\", value, 200) >= 0) {",
      "327:   fprintf(stderr, \"leak at getxattr of %s\\n\", path);",
      "328:   exit(1);",
      "329:  }",
      "330:  if (errno != ENOENT && errno != ENOSYS) {",
      "331:   fprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));",
      "332:   exit(1);",
      "333:  }",
      "334: }",
      "336: void test_utimes(const char *path)",
      "337: {",
      "338:  struct utimbuf times;",
      "339:  times.actime = 0;",
      "340:  times.modtime = 0;",
      "342:  if (utime(path, &times) == 0) {",
      "343:   fprintf(stderr, \"leak at utime of %s\\n\", path);",
      "344:   exit(1);",
      "345:  }",
      "346:  if (errno != ENOENT && errno != ENOSYS) {",
      "347:   fprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));",
      "348:   exit(1);",
      "349:  }",
      "350: }",
      "352: void test_openat(const char *path)",
      "353: {",
      "354:  char *d = strdupa(path), *f, *tmpname;",
      "355:  int fd, fd2;",
      "356:  f = basename(d);",
      "357:  d = dirname(d);",
      "358:  fd = open(d, O_RDONLY);",
      "359:  if (fd < 0) {",
      "360:   fprintf(stderr, \"Error in openat test: could not open parent dir\\n\");",
      "361:   fprintf(stderr, \"(this is expected on the second run)\\n\");",
      "362:   return;",
      "363:  }",
      "364:  fd2 = openat(fd, f, O_RDONLY);",
      "365:  if (fd2 >= 0 || errno != ENOENT) {",
      "366:   fprintf(stderr, \"leak at openat of %s\\n\", f);",
      "367:   exit(1);",
      "368:  }",
      "369:  size_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;",
      "370:  tmpname = alloca(len);",
      "371:  snprintf(tmpname, len, \"%s/cgroup.procs\", f);",
      "372:  fd2 = openat(fd, tmpname, O_RDONLY);",
      "373:  if (fd2 >= 0 || errno != ENOENT) {",
      "374:   fprintf(stderr, \"leak at openat of %s\\n\", tmpname);",
      "375:   exit(1);",
      "376:  }",
      "377:  close(fd);",
      "378: }",
      "380: int main(int argc, char *argv[])",
      "381: {",
      "382:  char *procspath;",
      "383:  size_t len;",
      "385:  if (geteuid() != 0) {",
      "386:   fprintf(stderr, \"Run me as root\\n\");",
      "387:   exit(1);",
      "388:  }",
      "390:  if (argc != 2)  {",
      "391:   fprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);",
      "392:   exit(1);",
      "393:  }",
      "396:  len = strlen(argv[1]) + strlen(\"/cgroup.procs\") + 1;",
      "397:  procspath = alloca(len);",
      "398:  snprintf(procspath, len, \"%s/cgroup.procs\", argv[1]);",
      "400:  test_open(argv[1]);",
      "401:  test_open(procspath);",
      "402:  test_stat(argv[1]);",
      "403:  test_stat(procspath);",
      "404:  test_access(argv[1]);",
      "405:  test_access(procspath);",
      "407:  test_bind(argv[1]);",
      "408:  test_bind(procspath);",
      "409:  test_bindmount(argv[1]);",
      "410:  test_bindmount(procspath);",
      "411:  test_truncate(argv[1]);",
      "412:  test_truncate(procspath);",
      "413:  test_chdir(argv[1]);",
      "414:  test_chdir(procspath);",
      "415:  test_rename(argv[1]);",
      "416:  test_rename(procspath);",
      "417:  test_mkdir(argv[1]);",
      "418:  test_mkdir(procspath);",
      "419:  test_rmdir(argv[1]);",
      "420:  test_rmdir(procspath);",
      "421:  test_creat(argv[1]);",
      "422:  test_creat(procspath);",
      "423:  test_link(argv[1]);",
      "424:  test_link(procspath);",
      "425:  test_unlink(argv[1]);",
      "426:  test_unlink(procspath);",
      "427:  test_symlink(argv[1]);",
      "428:  test_symlink(procspath);",
      "429:  test_readlink(argv[1]);",
      "430:  test_readlink(procspath);",
      "431:  test_chmod(argv[1]);",
      "432:  test_chmod(procspath);",
      "433:  test_chown(argv[1]);",
      "434:  test_chown(procspath);",
      "435:  test_lchown(argv[1]);",
      "436:  test_lchown(procspath);",
      "437:  test_mknod(argv[1]);",
      "438:  test_mknod(procspath);",
      "439:  test_chroot(argv[1]);",
      "440:  test_chroot(procspath);",
      "441:  test_xattrs(argv[1]);",
      "442:  test_xattrs(procspath);",
      "443:  test_utimes(argv[1]);",
      "444:  test_utimes(procspath);",
      "446:  test_openat(argv[1]);",
      "449:  printf(\"All tests passed\\n\");",
      "450:  return 0;",
      "451: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3db25a353582f3779614b997a4148804b2fda31a",
      "candidate_info": {
        "commit_hash": "3db25a353582f3779614b997a4148804b2fda31a",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/3db25a353582f3779614b997a4148804b2fda31a",
        "files": [
          "lxcfs.c"
        ],
        "message": "Hide cgroups not under caller's own cgroup\n\nFor a directory, we show an empty directory.  For any attempt to getattr\na file, we return -ENOENT.\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "164:  return ((fmode & r) == r);",
          "165: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "167: static char *get_next_cgroup_dir(const char *taskcg, const char *querycg)",
          "168: {",
          "169:  char *start, *end;",
          "171:  if (strlen(taskcg) <= strlen(querycg)) {",
          "172:   fprintf(stderr, \"%s: I was fed bad input\\n\", __func__);",
          "173:   return NULL;",
          "174:  }",
          "176:  if (strcmp(querycg, \"/\") == 0)",
          "177:   start = NIH_MUST( nih_strdup(NULL, taskcg + 1) );",
          "178:  else",
          "179:   start = NIH_MUST( nih_strdup(NULL, taskcg + strlen(querycg) + 1) );",
          "180:  end = strchr(start, '/');",
          "181:  if (end)",
          "183:  return start;",
          "184: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "206:  return false;",
          "207: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "228: static void stripnewline(char *x)",
          "229: {",
          "230:  size_t l = strlen(x);",
          "231:  if (l && x[l-1] == '\\n')",
          "232:   x[l-1] = '\\0';",
          "233: }",
          "241: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
          "242: {",
          "243:  nih_local char *fnam = NULL;",
          "244:  FILE *f;",
          "245:  bool answer = false;",
          "246:  char *line = NULL;",
          "247:  size_t len = 0;",
          "249:  fnam = NIH_MUST( nih_sprintf(NULL, \"/proc/%d/cgroup\", pid) );",
          "250:  if (!(f = fopen(fnam, \"r\")))",
          "251:   return false;",
          "253:  while (getline(&line, &len, f) != -1) {",
          "254:   char *c1, *c2, *linecmp;",
          "255:   if (!line[0])",
          "256:    continue;",
          "257:   c1 = strchr(line, ':');",
          "258:   if (!c1)",
          "259:    goto out;",
          "260:   c1++;",
          "261:   c2 = strchr(c1, ':');",
          "262:   if (!c2)",
          "263:    goto out;",
          "265:   if (strcmp(c1, contrl) != 0)",
          "266:    continue;",
          "267:   c2++;",
          "268:   stripnewline(c2);",
          "273:   linecmp = *cg == '/' ? c2 : c2+1;",
          "274:   if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
          "275:    if (nextcg)",
          "277:    goto out;",
          "278:   }",
          "279:   answer = true;",
          "280:   goto out;",
          "281:  }",
          "283: out:",
          "284:  fclose(f);",
          "285:  free(line);",
          "286:  return answer;",
          "287: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "364:   return -EIO;",
          "365:  cgroup = find_cgroup_in_path(path);",
          "366:  if (!cgroup) {",
          "368:   sb->st_mode = S_IFDIR | 00755;",
          "369:   sb->st_nlink = 2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "447: empty:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "387:  if (is_child_cgroup(controller, path1, path2)) {",
          "388:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "389:    return -EPERM;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "469:   if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL))",
          "470:    goto empty;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "403:  }",
          "405:  if ((k = get_cgroup_key(controller, path1, path2)) != NULL) {",
          "406:   if (!fc_may_access(fc, controller, path1, path2, O_RDONLY))",
          "407:    return -EPERM;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "489:   if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL))",
          "490:    return -ENOENT;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "451:  const char *cgroup;",
          "452:  nih_local char *controller = NULL;",
          "453:  int i;",
          "455:  controller = pick_controller_from_path(fc, path);",
          "456:  if (!controller)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "539:  nih_local char *nextcg = NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "466:   return -EPERM;",
          "468:  if (!cgm_list_keys(controller, cgroup, &list))",
          "469:   return -EINVAL;",
          "470:  for (i = 0; list[i]; i++) {",
          "471:   if (filler(buf, list[i]->name, NULL, 0) != 0) {",
          "472:    return -EIO;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "558:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &nextcg)) {",
          "559:   if (nextcg) {",
          "560:    int ret;",
          "561:    ret = filler(buf, nextcg,  NULL, 0);",
          "562:    if (ret != 0)",
          "563:     return -EIO;",
          "564:   }",
          "565:   return 0;",
          "566:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0dcc31ea2a038e144cdf1faa3f04972e1070d167",
      "candidate_info": {
        "commit_hash": "0dcc31ea2a038e144cdf1faa3f04972e1070d167",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/0dcc31ea2a038e144cdf1faa3f04972e1070d167",
        "files": [
          "cgfs.c",
          "lxcfs.c"
        ],
        "message": "first start to converting permissions checks\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "cgfs.c||cgfs.c",
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "cgfs.c||cgfs.c": [
          "File: cgfs.c -> cgfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "691:  if (file)",
          "692:   len += strlen(file) + 1;",
          "693:  fnam = alloca(len);",
          "695:   file ? \"/\" : \"\", file ? file : \"\");",
          "697:  ret = stat(fnam, &sb);",
          "",
          "[Removed Lines]",
          "694:  snprintf(fnam, len, \"%s/%s/%s/%s\", basedir, tmpc, cgroup,",
          "",
          "[Added Lines]",
          "694:  snprintf(fnam, len, \"%s/%s/%s%s%s\", basedir, tmpc, cgroup,",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "564:   path2 = last;",
          "565:  }",
          "571:  if (is_child_cgroup(controller, path1, path2)) {",
          "573:    ret = -ENOENT;",
          "574:    goto out;",
          "575:   }",
          "578:    sb->st_mode = S_IFDIR | 00555;",
          "579:    sb->st_nlink = 2;",
          "",
          "[Removed Lines]",
          "572:   if (!caller_may_see_dir(fc->pid, controller, cgroup)) {",
          "576:   if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {",
          "",
          "[Added Lines]",
          "567:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "573:   if (!caller_may_see_dir(initpid, controller, cgroup)) {",
          "577:   if (!caller_is_in_ancestor(initpid, controller, cgroup, NULL)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "608:   sb->st_gid = k->gid;",
          "609:   sb->st_size = 0;",
          "610:   free_key(k);",
          "612:    ret = -ENOENT;",
          "613:    goto out;",
          "614:   }",
          "",
          "[Removed Lines]",
          "611:   if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {",
          "",
          "[Added Lines]",
          "612:   if (!caller_is_in_ancestor(initpid, controller, path1, NULL)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "651:   }",
          "652:  }",
          "654:  if (cgroup) {",
          "656:    return -ENOENT;",
          "657:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "658:    return -EACCES;",
          "",
          "[Removed Lines]",
          "655:   if (!caller_may_see_dir(fc->pid, controller, cgroup))",
          "",
          "[Added Lines]",
          "655:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "657:   if (!caller_may_see_dir(initpid, controller, cgroup))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "705:   goto out;",
          "706:  }",
          "709:   if (nextcg) {",
          "710:    int ret;",
          "711:    ret = filler(buf, nextcg,  NULL, 0);",
          "",
          "[Removed Lines]",
          "708:  if (!caller_is_in_ancestor(fc->pid, d->controller, d->cgroup, &nextcg)) {",
          "",
          "[Added Lines]",
          "710:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "711:  if (!caller_is_in_ancestor(initpid, d->controller, d->cgroup, &nextcg)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "804:  }",
          "805:  free_key(k);",
          "808:   ret = -ENOENT;",
          "809:   goto out;",
          "810:  }",
          "",
          "[Removed Lines]",
          "807:  if (!caller_may_see_dir(fc->pid, controller, path1)) {",
          "",
          "[Added Lines]",
          "810:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "811:  if (!caller_may_see_dir(initpid, controller, path1)) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1689:  else",
          "1690:   path1 = cgdir;",
          "1693:   if (last && strcmp(next, last) == 0)",
          "1694:    ret = -EEXIST;",
          "1695:   else",
          "",
          "[Removed Lines]",
          "1692:  if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {",
          "",
          "[Added Lines]",
          "1696:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "1697:  if (!caller_is_in_ancestor(initpid, controller, path1, &next)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1701:   ret = -EACCES;",
          "1702:   goto out;",
          "1703:  }",
          "1705:   ret = -EACCES;",
          "1706:   goto out;",
          "1707:  }",
          "",
          "[Removed Lines]",
          "1704:  if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {",
          "",
          "[Added Lines]",
          "1709:  if (!caller_is_in_ancestor(initpid, controller, path1, NULL)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1738:   goto out;",
          "1739:  }",
          "1742:   if (!last || strcmp(next, last) == 0)",
          "1743:    ret = -EBUSY;",
          "1744:   else",
          "",
          "[Removed Lines]",
          "1741:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {",
          "",
          "[Added Lines]",
          "1746:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "1747:  if (!caller_is_in_ancestor(initpid, controller, cgroup, &next)) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1750:   ret = -EACCES;",
          "1751:   goto out;",
          "1752:  }",
          "1754:   ret = -EACCES;",
          "1755:   goto out;",
          "1756:  }",
          "",
          "[Removed Lines]",
          "1753:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {",
          "",
          "[Added Lines]",
          "1759:  if (!caller_is_in_ancestor(initpid, controller, cgroup, NULL)) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1925:   return total_len;",
          "1926:  }",
          "1929:  if (!cg)",
          "1930:   return read_file(\"/proc/meminfo\", buf, size, d);",
          "",
          "[Removed Lines]",
          "1928:  cg = get_pid_cgroup(fc->pid, \"memory\");",
          "",
          "[Added Lines]",
          "1934:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "1935:  cg = get_pid_cgroup(initpid, \"memory\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2104:   return total_len;",
          "2105:  }",
          "2108:  if (!cg)",
          "2109:   return read_file(\"proc/cpuinfo\", buf, size, d);",
          "",
          "[Removed Lines]",
          "2107:  cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "",
          "[Added Lines]",
          "2114:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "2115:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2218:   return total_len;",
          "2219:  }",
          "2222:  if (!cg)",
          "2223:   return read_file(\"/proc/stat\", buf, size, d);",
          "",
          "[Removed Lines]",
          "2221:  cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "",
          "[Added Lines]",
          "2229:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "2230:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2440: static unsigned long get_reaper_busy(pid_t task)",
          "2441: {",
          "2443:  char *cgroup = NULL, *usage_str = NULL;",
          "2444:  unsigned long usage = 0;",
          "2447:   return 0;",
          "2450:  if (!cgroup)",
          "2451:   goto out;",
          "2452:  if (!cgfs_get_value(\"cpuacct\", cgroup, \"cpuacct.usage\", &usage_str))",
          "",
          "[Removed Lines]",
          "2442:  pid_t init = get_init_pid_for_task(task);",
          "2446:  if (init == -1)",
          "2449:  cgroup = get_pid_cgroup(init, \"cpuacct\");",
          "",
          "[Added Lines]",
          "2451:  pid_t initpid = get_init_pid_for_task(task);",
          "2455:  if (initpid == -1)",
          "2458:  cgroup = get_pid_cgroup(initpid, \"cpuacct\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2539:   return total_len;",
          "2540:  }",
          "2543:  if (!cg)",
          "2544:   return read_file(\"/proc/diskstats\", buf, size, d);",
          "",
          "[Removed Lines]",
          "2542:  cg = get_pid_cgroup(fc->pid, \"blkio\");",
          "",
          "[Added Lines]",
          "2551:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "2552:  cg = get_pid_cgroup(initpid, \"blkio\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b11c6ec03787d7f5a40a59b887389d2a0ba97a5e",
      "candidate_info": {
        "commit_hash": "b11c6ec03787d7f5a40a59b887389d2a0ba97a5e",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/b11c6ec03787d7f5a40a59b887389d2a0ba97a5e",
        "files": [
          "Makefile.am",
          "lxcfs.c"
        ],
        "message": "cache the init pids\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: AM_CFLAGS = -Wall -ggdb -D_GNU_SOURCE -DSBINDIR=\\\"$(SBINDIR)\\\" -pthread",
          "11: AM_CFLAGS += $(DBUS_CFLAGS) $(FUSE_CFLAGS) $(GLIB_CFLAGS) $(GLIBDBUS_CFLAGS) $(GIO_CFLAGS)",
          "12: AM_LDFLAGS = $(DBUS_LIBS) $(FUSE_LIBS) $(GLIB_LIBS) -pthread $(GLIBDBUS_LIBS) $(GIO_LIBS)",
          "14: AM_CFLAGS += -DRUNTIME_PATH=\\\"$(RUNTIME_PATH)\\\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #AM_CFLAGS += -DDEBUG",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39: pam_cgfs_la_CFLAGS = $(AM_CFLAGS)",
          "40: pam_cgfs_la_LIBADD = $(AM_LIBS) $(PAM_LIBS) -L$(top_srcdir)",
          "41: pam_cgfs_la_LDFLAGS = $(AM_LDFLAGS) -module -avoid-version -shared",
          "45: install-data-hook:     install-pamLTLIBRARIES",
          "46:  rm -f \"$(DESTDIR)$(pamdir)/pam_cgfs.la\"",
          "",
          "[Removed Lines]",
          "42: # temporary",
          "43: pam_cgfs_la_CFLAGS += -DDEBUG",
          "",
          "[Added Lines]",
          "43: #pam_cgfs_la_CFLAGS += -DDEBUG",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include <stdlib.h>",
          "21: #include <libgen.h>",
          "22: #include <sched.h>",
          "23: #include <linux/sched.h>",
          "24: #include <sys/socket.h>",
          "25: #include <sys/mount.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include <pthread.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59: #define BUF_RESERVE_SIZE 256",
          "69: {",
          "81:  }",
          "85: }",
          "89: static int wait_for_pid(pid_t pid)",
          "90: {",
          "",
          "[Removed Lines]",
          "68: static void must_strcat_pid(char **src, size_t *sz, size_t *asz, pid_t pid)",
          "70:  char tmp[30];",
          "72:  int tmplen = sprintf(tmp, \"%d\\n\", (int)pid);",
          "74:  if (!*src || tmplen + *sz + 1 >= *asz) {",
          "75:   char *tmp;",
          "76:   do {",
          "77:    tmp = realloc(*src, *asz + BUF_RESERVE_SIZE);",
          "78:   } while (!tmp);",
          "82:  memcpy((*src) +*sz , tmp, tmplen);",
          "84:  (*src)[*sz] = '\\0';",
          "87: static pid_t get_init_pid_for_task(pid_t task);",
          "",
          "[Added Lines]",
          "78: struct pidns_init_store {",
          "79:  ino_t ino;          // inode number for /proc/$pid/ns/pid",
          "80:  pid_t initpid;      // the pid of nit in that ns",
          "81:  long int ctime;     // the time at which /proc/$initpid was created",
          "82:  struct pidns_init_store *next;",
          "83: };",
          "85: struct pidns_init_store *pidns_inits;",
          "86: static pthread_mutex_t pidns_store_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "87: static void lock_mutex(pthread_mutex_t *l)",
          "89:  int ret;",
          "91:  if ((ret = pthread_mutex_lock(l)) != 0) {",
          "92:   fprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));",
          "93:   exit(1);",
          "94:  }",
          "95: }",
          "97: static void unlock_mutex(pthread_mutex_t *l)",
          "98: {",
          "99:  int ret;",
          "101:  if ((ret = pthread_mutex_unlock(l)) != 0) {",
          "102:   fprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));",
          "103:   exit(1);",
          "107: static void store_lock(void)",
          "108: {",
          "109:  lock_mutex(&pidns_store_mutex);",
          "110: }",
          "112: static void store_unlock(void)",
          "113: {",
          "114:  unlock_mutex(&pidns_store_mutex);",
          "115: }",
          "118: static bool initpid_still_valid(struct pidns_init_store *e, struct stat *nsfdsb)",
          "119: {",
          "120:  struct stat initsb;",
          "121:  char fnam[100];",
          "123:  snprintf(fnam, 100, \"/proc/%d\", e->initpid);",
          "124:  if (stat(fnam, &initsb) < 0)",
          "125:   return false;",
          "126: #if DEBUG",
          "127:  fprintf(stderr, \"comparing ctime %ld %ld for pid %d\\n\",",
          "128:   e->ctime, initsb.st_ctime, e->initpid);",
          "129: #endif",
          "130:  if (e->ctime != initsb.st_ctime)",
          "131:   return false;",
          "132:  return true;",
          "133: }",
          "136: static void remove_initpid(struct pidns_init_store *e)",
          "137: {",
          "138:  struct pidns_init_store *tmp;",
          "140: #if DEBUG",
          "141:  fprintf(stderr, \"remove_initpid: removing entry for %d\\n\", e->initpid);",
          "142: #endif",
          "143:  if (pidns_inits == e) {",
          "144:   pidns_inits = e->next;",
          "145:   free(e);",
          "146:   return;",
          "147:  }",
          "149:  tmp = pidns_inits;",
          "150:  while (tmp) {",
          "151:   if (tmp->next == e) {",
          "152:    tmp->next = e->next;",
          "153:    free(e);",
          "154:    return;",
          "155:   }",
          "156:   tmp = tmp->next;",
          "157:  }",
          "158: }",
          "161: static void save_initpid(struct stat *sb, pid_t pid)",
          "162: {",
          "163:  struct pidns_init_store *e;",
          "164:  char fpath[100];",
          "165:  struct stat procsb;",
          "167: #if DEBUG",
          "168:  fprintf(stderr, \"save_initpid: adding entry for %d\\n\", pid);",
          "169: #endif",
          "170:  snprintf(fpath, 100, \"/proc/%d\", pid);",
          "171:  if (stat(fpath, &procsb) < 0)",
          "172:   return;",
          "173:  do {",
          "174:   e = malloc(sizeof(*e));",
          "175:  } while (!e);",
          "176:  e->ino = sb->st_ino;",
          "177:  e->initpid = pid;",
          "178:  e->ctime = procsb.st_ctime;",
          "179:  e->next = pidns_inits;",
          "180:  pidns_inits = e;",
          "181: }",
          "190: static struct pidns_init_store *lookup_verify_initpid(struct stat *sb)",
          "191: {",
          "192:  struct pidns_init_store *e = pidns_inits;",
          "193:  while (e) {",
          "194:   if (e->ino == sb->st_ino) {",
          "195:    if (initpid_still_valid(e, sb))",
          "196:     return e;",
          "197:    remove_initpid(e);",
          "198:    return NULL;",
          "199:   }",
          "200:   e = e->next;",
          "201:  }",
          "203:  return NULL;",
          "204: }",
          "206: #define SEND_CREDS_OK 0",
          "207: #define SEND_CREDS_NOTSK 1",
          "208: #define SEND_CREDS_FAIL 2",
          "209: static bool recv_creds(int sock, struct ucred *cred, char *v);",
          "210: static int wait_for_pid(pid_t pid);",
          "211: static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst);",
          "218: static void write_task_init_pid_exit(int sock, pid_t target)",
          "219: {",
          "220:  struct ucred cred;",
          "221:  char fnam[100];",
          "222:  pid_t pid;",
          "223:  char v;",
          "224:  int fd, ret;",
          "226:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", (int)target);",
          "227:  if (ret < 0 || ret >= sizeof(fnam))",
          "228:   _exit(1);",
          "230:  fd = open(fnam, O_RDONLY);",
          "231:  if (fd < 0) {",
          "232:   perror(\"write_task_init_pid_exit open of ns/pid\");",
          "233:   _exit(1);",
          "234:  }",
          "235:  if (setns(fd, 0)) {",
          "236:   perror(\"write_task_init_pid_exit setns 1\");",
          "237:   close(fd);",
          "238:   _exit(1);",
          "239:  }",
          "240:  pid = fork();",
          "241:  if (pid < 0)",
          "242:   _exit(1);",
          "243:  if (pid != 0) {",
          "244:   if (!wait_for_pid(pid))",
          "245:    _exit(1);",
          "246:   _exit(0);",
          "247:  }",
          "250:  cred.uid = 0;",
          "251:  cred.gid = 0;",
          "252:  cred.pid = 1;",
          "253:  v = '1';",
          "254:  if (send_creds(sock, &cred, v, true) != SEND_CREDS_OK)",
          "255:   _exit(1);",
          "256:  _exit(0);",
          "257: }",
          "259: static pid_t get_init_pid_for_task(pid_t task)",
          "260: {",
          "261:  int sock[2];",
          "262:  pid_t pid;",
          "263:  pid_t ret = -1;",
          "264:  char v = '0';",
          "265:  struct ucred cred;",
          "267:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "268:   perror(\"socketpair\");",
          "269:   return -1;",
          "270:  }",
          "272:  pid = fork();",
          "273:  if (pid < 0)",
          "274:   goto out;",
          "275:  if (!pid) {",
          "276:   close(sock[1]);",
          "277:   write_task_init_pid_exit(sock[0], task);",
          "278:   _exit(0);",
          "279:  }",
          "281:  if (!recv_creds(sock[1], &cred, &v))",
          "282:   goto out;",
          "283:  ret = cred.pid;",
          "285: out:",
          "286:  close(sock[0]);",
          "287:  close(sock[1]);",
          "288:  if (pid > 0)",
          "289:   wait_for_pid(pid);",
          "290:  return ret;",
          "291: }",
          "293: static pid_t lookup_initpid_in_store(pid_t qpid)",
          "294: {",
          "295:  pid_t answer = 0;",
          "296:  struct stat sb;",
          "297:  struct pidns_init_store *e;",
          "298:  char fnam[100];",
          "300:  snprintf(fnam, 100, \"/proc/%d/ns/pid\", qpid);",
          "301:  store_lock();",
          "302:  if (stat(fnam, &sb) < 0)",
          "303:   goto out;",
          "304:  e = lookup_verify_initpid(&sb);",
          "305:  if (e) {",
          "306:   answer = e->initpid;",
          "307:   goto out;",
          "308:  }",
          "309:  answer = get_init_pid_for_task(qpid);",
          "310:  if (answer > 0)",
          "311:   save_initpid(&sb, answer);",
          "313: out:",
          "314:  store_unlock();",
          "315:  return answer;",
          "316: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:  return 0;",
          "108: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "347: static void must_strcat_pid(char **src, size_t *sz, size_t *asz, pid_t pid)",
          "348: {",
          "349:  char tmp[30];",
          "351:  int tmplen = sprintf(tmp, \"%d\\n\", (int)pid);",
          "353:  if (!*src || tmplen + *sz + 1 >= *asz) {",
          "354:   char *tmp;",
          "355:   do {",
          "356:    tmp = realloc(*src, *asz + BUF_RESERVE_SIZE);",
          "357:   } while (!tmp);",
          "360:  }",
          "361:  memcpy((*src) +*sz , tmp, tmplen);",
          "363:  (*src)[*sz] = '\\0';",
          "364: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "567:   path2 = last;",
          "568:  }",
          "571:  if (initpid <= 0)",
          "572:   initpid = fc->pid;",
          "",
          "[Removed Lines]",
          "570:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "826:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "657:   }",
          "658:  }",
          "661:  if (initpid <= 0)",
          "662:   initpid = fc->pid;",
          "663:  if (cgroup) {",
          "",
          "[Removed Lines]",
          "660:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "916:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "714:   goto out;",
          "715:  }",
          "718:  if (initpid <= 0)",
          "719:   initpid = fc->pid;",
          "720:  if (!caller_is_in_ancestor(initpid, d->controller, d->cgroup, &nextcg)) {",
          "",
          "[Removed Lines]",
          "717:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "973:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "816:  }",
          "817:  free_key(k);",
          "820:  if (initpid <= 0)",
          "821:   initpid = fc->pid;",
          "822:  if (!caller_may_see_dir(initpid, controller, path1)) {",
          "",
          "[Removed Lines]",
          "819:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "1075:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "890:  deltatime = (starttime + timeout) - now;",
          "891:  if (deltatime < 0) { // timeout",
          "892:   errno = 0;",
          "893:   return false;",
          "894:  }",
          "895:  ret = epoll_wait(epfd, &ev, 1, 1000*deltatime + 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1149:   close(epfd);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "912:  return recv(sockfd, buf, len, MSG_DONTWAIT);",
          "913: }",
          "918: static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst)",
          "919: {",
          "920:  struct msghdr msg = { 0 };",
          "",
          "[Removed Lines]",
          "915: #define SEND_CREDS_OK 0",
          "916: #define SEND_CREDS_NOTSK 1",
          "917: #define SEND_CREDS_FAIL 2",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1718:  else",
          "1719:   path1 = cgdir;",
          "1722:  if (initpid <= 0)",
          "1723:   initpid = fc->pid;",
          "1724:  if (!caller_is_in_ancestor(initpid, controller, path1, &next)) {",
          "",
          "[Removed Lines]",
          "1721:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "1975:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1772:   goto out;",
          "1773:  }",
          "1776:  if (initpid <= 0)",
          "1777:   initpid = fc->pid;",
          "1778:  if (!caller_is_in_ancestor(initpid, controller, cgroup, &next)) {",
          "",
          "[Removed Lines]",
          "1775:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "2029:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1962:   return total_len;",
          "1963:  }",
          "1966:  if (initpid <= 0)",
          "1967:   initpid = fc->pid;",
          "1968:  cg = get_pid_cgroup(initpid, \"memory\");",
          "",
          "[Removed Lines]",
          "1965:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "2219:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2144:   return total_len;",
          "2145:  }",
          "2148:  if (initpid <= 0)",
          "2149:   initpid = fc->pid;",
          "2150:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "",
          "[Removed Lines]",
          "2147:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "2401:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2261:   return total_len;",
          "2262:  }",
          "2265:  if (initpid <= 0)",
          "2266:   initpid = fc->pid;",
          "2267:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "",
          "[Removed Lines]",
          "2264:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "2518:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2393:  int ret;",
          "2394:  pid_t qpid;",
          "2397:  if (qpid <= 0)",
          "2398:   return 0;",
          "",
          "[Removed Lines]",
          "2396:  qpid = get_init_pid_for_task(pid);",
          "",
          "[Added Lines]",
          "2650:  qpid = lookup_initpid_in_store(pid);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2407:  return time(NULL) - sb.st_ctime;",
          "2408: }",
          "2490: static unsigned long get_reaper_busy(pid_t task)",
          "2491: {",
          "2493:  char *cgroup = NULL, *usage_str = NULL;",
          "2494:  unsigned long usage = 0;",
          "",
          "[Removed Lines]",
          "2415: void write_task_init_pid_exit(int sock, pid_t target)",
          "2416: {",
          "2417:  struct ucred cred;",
          "2418:  char fnam[100];",
          "2419:  pid_t pid;",
          "2420:  char v;",
          "2421:  int fd, ret;",
          "2423:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", (int)target);",
          "2424:  if (ret < 0 || ret >= sizeof(fnam))",
          "2425:   _exit(1);",
          "2427:  fd = open(fnam, O_RDONLY);",
          "2428:  if (fd < 0) {",
          "2429:   perror(\"write_task_init_pid_exit open of ns/pid\");",
          "2430:   _exit(1);",
          "2431:  }",
          "2432:  if (setns(fd, 0)) {",
          "2433:   perror(\"write_task_init_pid_exit setns 1\");",
          "2434:   close(fd);",
          "2435:   _exit(1);",
          "2436:  }",
          "2437:  pid = fork();",
          "2438:  if (pid < 0)",
          "2439:   _exit(1);",
          "2440:  if (pid != 0) {",
          "2441:   if (!wait_for_pid(pid))",
          "2442:    _exit(1);",
          "2443:   _exit(0);",
          "2444:  }",
          "2447:  cred.uid = 0;",
          "2448:  cred.gid = 0;",
          "2449:  cred.pid = 1;",
          "2450:  v = '1';",
          "2451:  if (send_creds(sock, &cred, v, true) != SEND_CREDS_OK)",
          "2452:   _exit(1);",
          "2453:  _exit(0);",
          "2454: }",
          "2456: static pid_t get_init_pid_for_task(pid_t task)",
          "2457: {",
          "2458:  int sock[2];",
          "2459:  pid_t pid;",
          "2460:  pid_t ret = -1;",
          "2461:  char v = '0';",
          "2462:  struct ucred cred;",
          "2464:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "2465:   perror(\"socketpair\");",
          "2466:   return -1;",
          "2467:  }",
          "2469:  pid = fork();",
          "2470:  if (pid < 0)",
          "2471:   goto out;",
          "2472:  if (!pid) {",
          "2473:   close(sock[1]);",
          "2474:   write_task_init_pid_exit(sock[0], task);",
          "2475:   _exit(0);",
          "2476:  }",
          "2478:  if (!recv_creds(sock[1], &cred, &v))",
          "2479:   goto out;",
          "2480:  ret = cred.pid;",
          "2482: out:",
          "2483:  close(sock[0]);",
          "2484:  close(sock[1]);",
          "2485:  if (pid > 0)",
          "2486:   wait_for_pid(pid);",
          "2487:  return ret;",
          "2488: }",
          "2492:  pid_t initpid = get_init_pid_for_task(task);",
          "",
          "[Added Lines]",
          "2666:  pid_t initpid = lookup_initpid_in_store(task);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2589:   return total_len;",
          "2590:  }",
          "2593:  if (initpid <= 0)",
          "2594:   initpid = fc->pid;",
          "2595:  cg = get_pid_cgroup(initpid, \"blkio\");",
          "",
          "[Removed Lines]",
          "2592:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Added Lines]",
          "2766:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2183082c2edb740c2a16ad9949b416c073a48331",
      "candidate_info": {
        "commit_hash": "2183082c2edb740c2a16ad9949b416c073a48331",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/2183082c2edb740c2a16ad9949b416c073a48331",
        "files": [
          "ChangeLog",
          "Makefile.am",
          "NEWS",
          "README",
          "bootstrap.sh",
          "cgmanager.c",
          "cgmanager.h",
          "configure.ac",
          "lxcfs.c"
        ],
        "message": "add autoconf boilerplate and cgmanager fns\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "bootstrap.sh||bootstrap.sh",
          "cgmanager.c||cgmanager.c",
          "cgmanager.h||cgmanager.h",
          "configure.ac||configure.ac",
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ACLOCAL_AMFLAGS = -I m4",
          "3: VERSION_CURRENT  = 0",
          "4: VERSION_REVISION = 0",
          "5: VERSION_AGE      = 0",
          "7: AM_CFLAGS = -Wall -ggdb -D_GNU_SOURCE -DSBINDIR=\\\"$(SBINDIR)\\\"",
          "8: AM_CFLAGS += $(DBUS_CFLAGS) $(NIH_CFLAGS) $(NIH_DBUS_CFLAGS) $(CGMANAGER_CFLAGS) $(FUSE_CFLAGS)",
          "9: AM_LDFLAGS = $(DBUS_LIBS) $(NIH_LIBS) $(NIH_DBUS_LIBS) $(CGMANAGER_LIBS) $(FUSE_LIBS)",
          "11: bin_PROGRAMS = lxcfs",
          "13: lxcfs_SOURCES = lxcfs.c cgmanager.c",
          "",
          "---------------"
        ],
        "bootstrap.sh||bootstrap.sh": [
          "File: bootstrap.sh -> bootstrap.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/bin/sh",
          "3: # lxc: linux Container library",
          "4: #",
          "5: # (C) Copyright IBM Corp. 2007, 2008",
          "6: #",
          "7: # Authors:",
          "8: # Daniel Lezcano <daniel.lezcano at free.fr>",
          "9: #",
          "10: # This library is free software; you can redistribute it and/or",
          "11: # modify it under the terms of the GNU Lesser General Public",
          "12: # License as published by the Free Software Foundation; either",
          "13: # version 2.1 of the License, or (at your option) any later version.",
          "14: #",
          "15: # This library is distributed in the hope that it will be useful,",
          "16: # but WITHOUT ANY WARRANTY; without even the implied warranty of",
          "17: # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
          "18: # Lesser General Public License for more details.",
          "19: #",
          "20: # You should have received a copy of the GNU Lesser General Public",
          "21: # License along with this library; if not, write to the Free Software",
          "22: # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA",
          "24: set -x",
          "25: set -e",
          "27: test -d autom4te.cache && rm -rf autom4te.cache",
          "28: aclocal",
          "29: libtoolize",
          "30: autoheader",
          "31: autoconf",
          "32: automake --add-missing --copy",
          "",
          "---------------"
        ],
        "cgmanager.c||cgmanager.c": [
          "File: cgmanager.c -> cgmanager.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"config.h\"",
          "27: #include <stdio.h>",
          "28: #include <stdlib.h>",
          "29: #include <errno.h>",
          "30: #include <unistd.h>",
          "31: #include <string.h>",
          "32: #include <dirent.h>",
          "33: #include <fcntl.h>",
          "34: #include <ctype.h>",
          "35: #include <pthread.h>",
          "36: #include <grp.h>",
          "37: #include <sys/types.h>",
          "38: #include <sys/stat.h>",
          "39: #include <sys/param.h>",
          "40: #include <sys/inotify.h>",
          "41: #include <sys/mount.h>",
          "42: #include <netinet/in.h>",
          "43: #include <net/if.h>",
          "44: #include <stdbool.h>",
          "46: #include <nih-dbus/dbus_connection.h>",
          "47: #include <cgmanager/cgmanager-client.h>",
          "48: #include <nih/alloc.h>",
          "49: #include <nih/error.h>",
          "50: #include <nih/string.h>",
          "52: #include \"cgmanager.h\"",
          "54: static NihDBusProxy *cgroup_manager = NULL;",
          "55: static int32_t api_version;",
          "57: static void cgm_dbus_disconnect(void)",
          "58: {",
          "59:        if (cgroup_manager) {",
          "60:         dbus_connection_flush(cgroup_manager->connection);",
          "61:         dbus_connection_close(cgroup_manager->connection);",
          "62:                nih_free(cgroup_manager);",
          "63:        }",
          "64:        cgroup_manager = NULL;",
          "65: }",
          "67: #define CGMANAGER_DBUS_SOCK \"unix:path=/sys/fs/cgroup/cgmanager/sock\"",
          "68: static bool cgm_dbus_connect(void)",
          "69: {",
          "70:  DBusError dbus_error;",
          "71:  static DBusConnection *connection;",
          "73:  dbus_error_init(&dbus_error);",
          "75:  connection = dbus_connection_open_private(CGMANAGER_DBUS_SOCK, &dbus_error);",
          "76:  if (!connection) {",
          "77:   fprintf(stderr, \"Failed opening dbus connection: %s: %s\",",
          "78:     dbus_error.name, dbus_error.message);",
          "79:   dbus_error_free(&dbus_error);",
          "80:   return false;",
          "81:  }",
          "82:  dbus_connection_set_exit_on_disconnect(connection, FALSE);",
          "83:  dbus_error_free(&dbus_error);",
          "84:  cgroup_manager = nih_dbus_proxy_new(NULL, connection,",
          "85:     NULL /* p2p */,",
          "86:     \"/org/linuxcontainers/cgmanager\", NULL, NULL);",
          "87:  dbus_connection_unref(connection);",
          "88:  if (!cgroup_manager) {",
          "89:   NihError *nerr;",
          "90:   nerr = nih_error_get();",
          "91:   fprintf(stderr, \"Error opening cgmanager proxy: %s\", nerr->message);",
          "92:   nih_free(nerr);",
          "93:   cgm_dbus_disconnect();",
          "94:   return false;",
          "95:  }",
          "98:  if (cgmanager_get_api_version_sync(NULL, cgroup_manager, &api_version) != 0) {",
          "99:   NihError *nerr;",
          "100:   nerr = nih_error_get();",
          "101:   fprintf(stderr, \"Error cgroup manager api version: %s\", nerr->message);",
          "102:   nih_free(nerr);",
          "103:   cgm_dbus_disconnect();",
          "104:   return false;",
          "105:  }",
          "106:  return true;",
          "107: }",
          "109: bool cgm_get_controllers(char ***contrls)",
          "110: {",
          "111:  if (!cgm_dbus_connect()) {",
          "112:   return false;",
          "113:  }",
          "115:  if ( cgmanager_list_controllers_sync(NULL, cgroup_manager, contrls) != 0 ) {",
          "116:   NihError *nerr;",
          "117:   nerr = nih_error_get();",
          "118:   fprintf(stderr, \"call to list_controllers failed: %s\", nerr->message);",
          "119:   nih_free(nerr);",
          "120:   cgm_dbus_disconnect();",
          "121:   return false;",
          "122:  }",
          "124:  cgm_dbus_disconnect();",
          "125:  return true;",
          "126: }",
          "128: bool cgm_list_keys(const char *controller, const char *cgroup, struct cgm_keys ***keys)",
          "129: {",
          "130:  if (!cgm_dbus_connect()) {",
          "131:   return false;",
          "132:  }",
          "134:  if ( cgmanager_list_keys_sync(NULL, cgroup_manager, controller, cgroup,",
          "135:     (CgmanagerListKeysOutputElement ***)keys) != 0 ) {",
          "136:   NihError *nerr;",
          "137:   nerr = nih_error_get();",
          "138:   fprintf(stderr, \"call to list_keys failed: %s\", nerr->message);",
          "139:   nih_free(nerr);",
          "140:   cgm_dbus_disconnect();",
          "141:   return false;",
          "142:  }",
          "144:  cgm_dbus_disconnect();",
          "145:  return true;",
          "146: }",
          "148: bool cgm_list_children(const char *controller, const char *cgroup, char ***list)",
          "149: {",
          "150:  if (!cgm_dbus_connect()) {",
          "151:   return false;",
          "152:  }",
          "154:  if ( cgmanager_list_children_sync(NULL, cgroup_manager, controller, cgroup, list) != 0 ) {",
          "155:   NihError *nerr;",
          "156:   nerr = nih_error_get();",
          "157:   fprintf(stderr, \"call to list_children failed: %s\", nerr->message);",
          "158:   nih_free(nerr);",
          "159:   cgm_dbus_disconnect();",
          "160:   return false;",
          "161:  }",
          "163:  cgm_dbus_disconnect();",
          "164:  return true;",
          "165: }",
          "167: char *cgm_get_pid_cgroup(pid_t pid, const char *controller)",
          "168: {",
          "169:  char *output = NULL;",
          "171:  if (!cgm_dbus_connect()) {",
          "172:   return NULL;",
          "173:  }",
          "175:  if ( cgmanager_get_pid_cgroup_sync(NULL, cgroup_manager, controller, pid, &output) != 0 ) {",
          "176:   NihError *nerr;",
          "177:   nerr = nih_error_get();",
          "178:   fprintf(stderr, \"call to get_pid_cgroup failed: %s\", nerr->message);",
          "179:   nih_free(nerr);",
          "180:   cgm_dbus_disconnect();",
          "181:   return NULL;",
          "182:  }",
          "184:  cgm_dbus_disconnect();",
          "185:  return output;",
          "186: }",
          "188: bool cgm_escape_cgroup(void)",
          "189: {",
          "190:  if (!cgm_dbus_connect()) {",
          "191:   return false;",
          "192:  }",
          "194:  if ( cgmanager_move_pid_abs_sync(NULL, cgroup_manager, \"all\", \"/\", (int32_t) getpid()) != 0 ) {",
          "195:   NihError *nerr;",
          "196:   nerr = nih_error_get();",
          "197:   fprintf(stderr, \"call to move_pid_abs failed: %s\", nerr->message);",
          "198:   nih_free(nerr);",
          "199:   cgm_dbus_disconnect();",
          "200:   return false;",
          "201:  }",
          "203:  cgm_dbus_disconnect();",
          "204:  return true;",
          "205: }",
          "",
          "---------------"
        ],
        "cgmanager.h||cgmanager.h": [
          "File: cgmanager.h -> cgmanager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: struct cgm_keys {",
          "2:  char *name;",
          "3:  uint32_t uid, gid;",
          "4:  uint32_t mode;",
          "5: };",
          "7: bool cgm_get_controllers(char ***contrls);",
          "8: bool cgm_list_keys(const char *controller, const char *cgroup, struct cgm_keys ***keys);",
          "9: bool cgm_list_children(const char *controller, const char *cgroup, char ***list);",
          "10: char *cgm_get_pid_cgroup(pid_t pid, const char *controller);",
          "12: bool cgm_escape_cgroup(void);",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Process this file with autoconf to produce a configure script.",
          "3: AC_PREREQ(2.61)",
          "4: AC_INIT([lxcfs], [0.01], [lxc-devel@lists.linuxcontainers.org])",
          "6: AC_GNU_SOURCE",
          "7: AC_CONFIG_HEADERS([config.h])",
          "8: AC_CONFIG_FILES([",
          "9:  Makefile ])",
          "11: AM_INIT_AUTOMAKE",
          "13: LT_INIT",
          "14: AC_PROG_CC",
          "16: AC_PROG_CC_C99",
          "18: PKG_CHECK_MODULES([NIH], [libnih >= 1.0.2])",
          "19: PKG_CHECK_MODULES([NIH_DBUS], [libnih-dbus >= 1.0.0])",
          "20: PKG_CHECK_MODULES([DBUS], [dbus-1 >= 1.2.16])",
          "21: PKG_CHECK_MODULES([CGMANAGER], [libcgmanager >= 0.0.0])",
          "22: PKG_CHECK_MODULES(FUSE, fuse)",
          "24: AC_PATH_PROG(HELP2MAN, help2man, false // No help2man //)",
          "26: AC_OUTPUT",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <stdio.h>",
          "3: int main()",
          "4: {",
          "5:  printf(\"hello, world\\n\");",
          "6: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "237e200e8d117c83c246e34248dd4b39acd7e033",
      "candidate_info": {
        "commit_hash": "237e200e8d117c83c246e34248dd4b39acd7e033",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/237e200e8d117c83c246e34248dd4b39acd7e033",
        "files": [
          ".gitignore",
          "Makefile.am",
          "bindings.c",
          "bindings.h",
          "cgfs.c",
          "cgfs.h",
          "configure.ac",
          "lxcfs.c",
          "tests/main.sh",
          "tests/test_reload.sh"
        ],
        "message": "Make the bulk of the lxcfs code reloadable\n\nMove the majority of the code (the bits most likely to have security\nbugs coming up) reloadable.  Sending USR1 signal to lxcfs will cause\nit to reload the shared library so as to immediately start using the\nfixed code.  This allows us to upgrade lxcfs in the majority of\ncases without having to restart containers.\n\nTo achieve this, some code was moved around so that lxcfs.c itself\ndoes not risk pinning any symbols from the shared library (which\nwould prevent it being unloaded).  We track the number of threads\ncurrently using the bindings, and do the reload after it hits\nzero (specifically, the next time that we turn the count from 0 to 1)\n\nAlso add a test case to make sure an updated library does in fact\nget loaded.\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "bindings.c||bindings.c",
          "bindings.h||bindings.h",
          "cgfs.c||cgfs.c",
          "cgfs.h||cgfs.h",
          "configure.ac||configure.ac",
          "lxcfs.c||lxcfs.c",
          "tests/main.sh||tests/main.sh",
          "tests/test_reload.sh||tests/test_reload.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: VERSION_AGE      = 0",
          "10: AM_CFLAGS = -Wall -ggdb -D_GNU_SOURCE -DSBINDIR=\\\"$(SBINDIR)\\\" -pthread",
          "13: #AM_CFLAGS += -DDEBUG",
          "15: AM_CFLAGS += -DRUNTIME_PATH=\\\"$(RUNTIME_PATH)\\\"",
          "21: EXTRA_DIST = \\",
          "22:  lxcfs.man.add",
          "",
          "[Removed Lines]",
          "11: AM_CFLAGS += $(DBUS_CFLAGS) $(FUSE_CFLAGS) $(GLIB_CFLAGS) $(GLIBDBUS_CFLAGS) $(GIO_CFLAGS)",
          "12: AM_LDFLAGS = $(DBUS_LIBS) $(FUSE_LIBS) $(GLIB_LIBS) -pthread $(GLIBDBUS_LIBS) $(GIO_LIBS)",
          "17: bin_PROGRAMS = lxcfs",
          "19: lxcfs_SOURCES = lxcfs.c cgfs.c cgfs.h cpuset.c",
          "",
          "[Added Lines]",
          "11: AM_CFLAGS += $(FUSE_CFLAGS)",
          "12: AM_LDFLAGS = $(FUSE_LIBS) -pthread",
          "17: liblxcfs_la_SOURCES = bindings.c cpuset.c bindings.h",
          "18: liblxcfs_la_CFLAGS = $(AM_CFLAGS)",
          "19: liblxcfs_la_LDFLAGS = $(AM_CFLAGS) -shared \\",
          "20:  -Wl,-soname,liblxcfs.so.$(firstword $(subst ., ,@LXCFS_VERSION_ABI@))",
          "22: liblxcfstest_la_SOURCES = bindings.c cpuset.c bindings.h",
          "23: liblxcfstest_la_CFLAGS = $(AM_CFLAGS) -DRELOADTEST",
          "24: liblxcfstest_la_LDFLAGS = $(AM_CFLAGS) -shared \\",
          "25:  -Wl,-soname,liblxcfs.so.$(firstword $(subst ., ,@LXCFS_VERSION_ABI@))",
          "27: noinst_HEADERS = bindings.h",
          "29: sodir=$(libdir)",
          "30: lib_LTLIBRARIES = liblxcfs.la liblxcfstest.la",
          "32: lxcfs_SOURCES = lxcfs.c",
          "33: lxcfs_LDADD = liblxcfs.la -ldl",
          "34: lxcfs_CFLAGS = $(AM_CFLAGS)",
          "35: lxcfs_LDFLAGS = $(AM_LDFLAGS)",
          "36: bin_PROGRAMS = lxcfs",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:   Makefile.in \\",
          "59:   aclocal.m4 \\",
          "60:   autom4te.cache/ \\",
          "62:   compile \\",
          "63:   config.guess \\",
          "64:   config.h \\",
          "",
          "[Removed Lines]",
          "61:   cgfs.o \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:   m4/ \\",
          "78:   missing \\",
          "79:   stamp-h1 \\",
          "",
          "[Removed Lines]",
          "80:   tests/test_syscalls",
          "",
          "[Added Lines]",
          "96:   tests/test_syscalls \\",
          "",
          "---------------"
        ],
        "bindings.c||bindings.c": [
          "File: bindings.c -> bindings.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #define FUSE_USE_VERSION 26",
          "11: #include <stdio.h>",
          "12: #include <dirent.h>",
          "13: #include <fcntl.h>",
          "14: #include <fuse.h>",
          "15: #include <unistd.h>",
          "16: #include <errno.h>",
          "17: #include <stdbool.h>",
          "18: #include <time.h>",
          "19: #include <string.h>",
          "20: #include <stdlib.h>",
          "21: #include <libgen.h>",
          "22: #include <sched.h>",
          "23: #include <pthread.h>",
          "24: #include <linux/sched.h>",
          "25: #include <sys/param.h>",
          "26: #include <sys/socket.h>",
          "27: #include <sys/mount.h>",
          "28: #include <sys/epoll.h>",
          "29: #include <wait.h>",
          "31: #ifdef FORTRAVIS",
          "32: #define GLIB_DISABLE_DEPRECATION_WARNINGS",
          "33: #include <glib-object.h>",
          "34: #endif",
          "36: #include \"bindings.h\"",
          "38: #include \"config.h\" // for VERSION",
          "40: enum {",
          "41:  LXC_TYPE_CGDIR,",
          "42:  LXC_TYPE_CGFILE,",
          "43:  LXC_TYPE_PROC_MEMINFO,",
          "44:  LXC_TYPE_PROC_CPUINFO,",
          "45:  LXC_TYPE_PROC_UPTIME,",
          "46:  LXC_TYPE_PROC_STAT,",
          "47:  LXC_TYPE_PROC_DISKSTATS,",
          "48: };",
          "50: struct file_info {",
          "51:  char *controller;",
          "52:  char *cgroup;",
          "53:  char *file;",
          "54:  int type;",
          "55:  char *buf;  // unused as of yet",
          "56:  int buflen;",
          "57:  int size; //actual data size",
          "58:  int cached;",
          "59: };",
          "62: #define BUF_RESERVE_SIZE 256",
          "78: struct pidns_init_store {",
          "79:  ino_t ino;          // inode number for /proc/$pid/ns/pid",
          "80:  pid_t initpid;      // the pid of nit in that ns",
          "81:  long int ctime;     // the time at which /proc/$initpid was created",
          "82:  struct pidns_init_store *next;",
          "83:  long int lastcheck;",
          "84: };",
          "87: #define PIDNS_HASH_SIZE 4096",
          "88: #define HASH(x) ((x) % PIDNS_HASH_SIZE)",
          "90: static struct pidns_init_store *pidns_hash_table[PIDNS_HASH_SIZE];",
          "91: static pthread_mutex_t pidns_store_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "92: static void lock_mutex(pthread_mutex_t *l)",
          "93: {",
          "94:  int ret;",
          "96:  if ((ret = pthread_mutex_lock(l)) != 0) {",
          "97:   fprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));",
          "98:   exit(1);",
          "99:  }",
          "100: }",
          "102: static void unlock_mutex(pthread_mutex_t *l)",
          "103: {",
          "104:  int ret;",
          "106:  if ((ret = pthread_mutex_unlock(l)) != 0) {",
          "107:   fprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));",
          "108:   exit(1);",
          "109:  }",
          "110: }",
          "112: static void store_lock(void)",
          "113: {",
          "114:  lock_mutex(&pidns_store_mutex);",
          "115: }",
          "117: static void store_unlock(void)",
          "118: {",
          "119:  unlock_mutex(&pidns_store_mutex);",
          "120: }",
          "123: static bool initpid_still_valid(struct pidns_init_store *e, struct stat *nsfdsb)",
          "124: {",
          "125:  struct stat initsb;",
          "126:  char fnam[100];",
          "128:  snprintf(fnam, 100, \"/proc/%d\", e->initpid);",
          "129:  if (stat(fnam, &initsb) < 0)",
          "130:   return false;",
          "131: #if DEBUG",
          "132:  fprintf(stderr, \"comparing ctime %ld %ld for pid %d\\n\",",
          "133:   e->ctime, initsb.st_ctime, e->initpid);",
          "134: #endif",
          "135:  if (e->ctime != initsb.st_ctime)",
          "136:   return false;",
          "137:  return true;",
          "138: }",
          "141: static void remove_initpid(struct pidns_init_store *e)",
          "142: {",
          "143:  struct pidns_init_store *tmp;",
          "144:  int h;",
          "146: #if DEBUG",
          "147:  fprintf(stderr, \"remove_initpid: removing entry for %d\\n\", e->initpid);",
          "148: #endif",
          "149:  h = HASH(e->ino);",
          "150:  if (pidns_hash_table[h] == e) {",
          "151:   pidns_hash_table[h] = e->next;",
          "152:   free(e);",
          "153:   return;",
          "154:  }",
          "156:  tmp = pidns_hash_table[h];",
          "157:  while (tmp) {",
          "158:   if (tmp->next == e) {",
          "159:    tmp->next = e->next;",
          "160:    free(e);",
          "161:    return;",
          "162:   }",
          "163:   tmp = tmp->next;",
          "164:  }",
          "165: }",
          "167: #define PURGE_SECS 5",
          "169: static void prune_initpid_store(void)",
          "170: {",
          "171:  static long int last_prune = 0;",
          "172:  struct pidns_init_store *e, *prev, *delme;",
          "173:  long int now, threshold;",
          "174:  int i;",
          "176:  if (!last_prune) {",
          "177:   last_prune = time(NULL);",
          "178:   return;",
          "179:  }",
          "180:  now = time(NULL);",
          "181:  if (now < last_prune + PURGE_SECS)",
          "182:   return;",
          "183: #if DEBUG",
          "184:  fprintf(stderr, \"pruning\\n\");",
          "185: #endif",
          "186:  last_prune = now;",
          "187:  threshold = now - 2 * PURGE_SECS;",
          "189:  for (i = 0; i < PIDNS_HASH_SIZE; i++) {",
          "190:   for (prev = NULL, e = pidns_hash_table[i]; e; ) {",
          "191:    if (e->lastcheck < threshold) {",
          "192: #if DEBUG",
          "193:     fprintf(stderr, \"Removing cached entry for %d\\n\", e->initpid);",
          "194: #endif",
          "195:     delme = e;",
          "196:     if (prev)",
          "197:      prev->next = e->next;",
          "198:     else",
          "199:      pidns_hash_table[i] = e->next;",
          "200:     e = e->next;",
          "201:     free(delme);",
          "202:    } else {",
          "203:     prev = e;",
          "204:     e = e->next;",
          "205:    }",
          "206:   }",
          "207:  }",
          "208: }",
          "211: static void save_initpid(struct stat *sb, pid_t pid)",
          "212: {",
          "213:  struct pidns_init_store *e;",
          "214:  char fpath[100];",
          "215:  struct stat procsb;",
          "216:  int h;",
          "218: #if DEBUG",
          "219:  fprintf(stderr, \"save_initpid: adding entry for %d\\n\", pid);",
          "220: #endif",
          "221:  snprintf(fpath, 100, \"/proc/%d\", pid);",
          "222:  if (stat(fpath, &procsb) < 0)",
          "223:   return;",
          "224:  do {",
          "225:   e = malloc(sizeof(*e));",
          "226:  } while (!e);",
          "227:  e->ino = sb->st_ino;",
          "228:  e->initpid = pid;",
          "229:  e->ctime = procsb.st_ctime;",
          "230:  h = HASH(e->ino);",
          "231:  e->next = pidns_hash_table[h];",
          "232:  e->lastcheck = time(NULL);",
          "233:  pidns_hash_table[h] = e;",
          "234: }",
          "243: static struct pidns_init_store *lookup_verify_initpid(struct stat *sb)",
          "244: {",
          "245:  int h = HASH(sb->st_ino);",
          "246:  struct pidns_init_store *e = pidns_hash_table[h];",
          "248:  while (e) {",
          "249:   if (e->ino == sb->st_ino) {",
          "250:    if (initpid_still_valid(e, sb)) {",
          "251:     e->lastcheck = time(NULL);",
          "252:     return e;",
          "253:    }",
          "254:    remove_initpid(e);",
          "255:    return NULL;",
          "256:   }",
          "257:   e = e->next;",
          "258:  }",
          "260:  return NULL;",
          "261: }",
          "263: static int is_dir(const char *path)",
          "264: {",
          "265:  struct stat statbuf;",
          "266:  int ret = stat(path, &statbuf);",
          "267:  if (ret == 0 && S_ISDIR(statbuf.st_mode))",
          "268:   return 1;",
          "269:  return 0;",
          "270: }",
          "272: static char *must_copy_string(const char *str)",
          "273: {",
          "274:  char *dup = NULL;",
          "275:  if (!str)",
          "276:   return NULL;",
          "277:  do {",
          "278:   dup = strdup(str);",
          "279:  } while (!dup);",
          "281:  return dup;",
          "282: }",
          "284: static inline void drop_trailing_newlines(char *s)",
          "285: {",
          "286:  int l;",
          "288:  for (l=strlen(s); l>0 && s[l-1] == '\\n'; l--)",
          "289:   s[l-1] = '\\0';",
          "290: }",
          "292: #define BATCH_SIZE 50",
          "293: static void dorealloc(char **mem, size_t oldlen, size_t newlen)",
          "294: {",
          "295:  int newbatches = (newlen / BATCH_SIZE) + 1;",
          "296:  int oldbatches = (oldlen / BATCH_SIZE) + 1;",
          "298:  if (!*mem || newbatches > oldbatches) {",
          "299:   char *tmp;",
          "300:   do {",
          "301:    tmp = realloc(*mem, newbatches * BATCH_SIZE);",
          "302:   } while (!tmp);",
          "304:  }",
          "305: }",
          "306: static void append_line(char **contents, size_t *len, char *line, ssize_t linelen)",
          "307: {",
          "308:  size_t newlen = *len + linelen;",
          "309:  dorealloc(contents, *len, newlen + 1);",
          "310:  memcpy(*contents + *len, line, linelen+1);",
          "312: }",
          "314: static char *slurp_file(const char *from)",
          "315: {",
          "316:  char *line = NULL;",
          "317:  char *contents = NULL;",
          "318:  FILE *f = fopen(from, \"r\");",
          "319:  size_t len = 0, fulllen = 0;",
          "320:  ssize_t linelen;",
          "322:  if (!f)",
          "323:   return NULL;",
          "325:  while ((linelen = getline(&line, &len, f)) != -1) {",
          "326:   append_line(&contents, &fulllen, line, linelen);",
          "327:  }",
          "328:  fclose(f);",
          "330:  if (contents)",
          "331:   drop_trailing_newlines(contents);",
          "332:  free(line);",
          "333:  return contents;",
          "334: }",
          "336: static bool write_string(const char *fnam, const char *string)",
          "337: {",
          "338:  FILE *f;",
          "339:  size_t len, ret;",
          "341:  if (!(f = fopen(fnam, \"w\")))",
          "342:   return false;",
          "343:  len = strlen(string);",
          "344:  ret = fwrite(string, 1, len, f);",
          "345:  if (ret != len) {",
          "346:   fprintf(stderr, \"Error writing to file: %s\\n\", strerror(errno));",
          "347:   fclose(f);",
          "348:   return false;",
          "349:  }",
          "350:  if (fclose(f) < 0) {",
          "351:   fprintf(stderr, \"Error writing to file: %s\\n\", strerror(errno));",
          "352:   return false;",
          "353:  }",
          "354:  return true;",
          "355: }",
          "360: char **hierarchies;",
          "361: int num_hierarchies;",
          "363: struct cgfs_files {",
          "364:  char *name;",
          "365:  uint32_t uid, gid;",
          "366:  uint32_t mode;",
          "367: };",
          "369: static bool store_hierarchy(char *stridx, char *h)",
          "370: {",
          "371:  int idx = atoi(stridx);",
          "372:  size_t needed_len = (idx + 1) * sizeof(char *);",
          "374:  if (idx < 0 || idx > 30) {",
          "375:   fprintf(stderr, \"Error: corrupt /proc/self/cgroup\\n\");",
          "376:   return false;",
          "377:  }",
          "379:  if (!hierarchies) {",
          "380:   hierarchies = malloc(needed_len);",
          "381:   memset(hierarchies, 0, needed_len);",
          "382:   num_hierarchies = idx + 1;",
          "383:  } else if (idx >= num_hierarchies) {",
          "384:   char **tmp;",
          "385:   size_t old_len = (num_hierarchies + 1) * sizeof(char *);",
          "386:   do {",
          "387:    tmp = malloc(needed_len);",
          "388:   } while (!tmp);",
          "389:   memset(tmp, 0, needed_len);",
          "390:   memcpy(tmp, hierarchies, old_len);",
          "391:   free(hierarchies);",
          "392:   hierarchies = tmp;",
          "393:   num_hierarchies = idx + 1;",
          "394:  }",
          "396:  if (hierarchies[idx]) {",
          "397:   fprintf(stderr, \"Error: corrupt /proc/self/cgroup\\n\");",
          "398:   return false;",
          "399:  }",
          "400:  hierarchies[idx] = must_copy_string(h);",
          "401:  return true;",
          "402: }",
          "404: static void print_subsystems(void)",
          "405: {",
          "406:  int i;",
          "408:  fprintf(stderr, \"hierarchies:\");",
          "409:  for (i = 0; i < num_hierarchies; i++) {",
          "410:   if (hierarchies[i])",
          "411:    fprintf(stderr, \" %d: %s\\n\", i, hierarchies[i]);",
          "412:  }",
          "413: }",
          "415: static bool in_comma_list(const char *needle, const char *haystack)",
          "416: {",
          "417:  const char *s = haystack, *e;",
          "418:  size_t nlen = strlen(needle);",
          "420:  while (*s && (e = index(s, ','))) {",
          "421:   if (nlen != e - s) {",
          "422:    s = e + 1;",
          "423:    continue;",
          "424:   }",
          "425:   if (strncmp(needle, s, nlen) == 0)",
          "426:    return true;",
          "427:   s = e + 1;",
          "428:  }",
          "429:  if (strcmp(needle, s) == 0)",
          "430:   return true;",
          "431:  return false;",
          "432: }",
          "435: static char *find_mounted_controller(const char *controller)",
          "436: {",
          "437:  int i;",
          "439:  for (i = 0; i < num_hierarchies; i++) {",
          "440:   if (!hierarchies[i])",
          "441:    continue;",
          "442:   if (strcmp(hierarchies[i], controller) == 0)",
          "443:    return hierarchies[i];",
          "444:   if (in_comma_list(controller, hierarchies[i]))",
          "445:    return hierarchies[i];",
          "446:  }",
          "448:  return NULL;",
          "449: }",
          "451: bool cgfs_set_value(const char *controller, const char *cgroup, const char *file,",
          "452:   const char *value)",
          "453: {",
          "454:  size_t len;",
          "455:  char *fnam, *tmpc = find_mounted_controller(controller);",
          "457:  if (!tmpc)",
          "458:   return false;",
          "460:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + strlen(file) + 4;",
          "461:  fnam = alloca(len);",
          "462:  snprintf(fnam, len, \"%s/%s/%s/%s\", basedir, tmpc, cgroup, file);",
          "464:  return write_string(fnam, value);",
          "465: }",
          "469: static void chown_all_cgroup_files(const char *dirname, uid_t uid, gid_t gid)",
          "470: {",
          "471:  struct dirent dirent, *direntp;",
          "472:  char path[MAXPATHLEN];",
          "473:  size_t len;",
          "474:  DIR *d;",
          "475:  int ret;",
          "477:  len = strlen(dirname);",
          "478:  if (len >= MAXPATHLEN) {",
          "479:   fprintf(stderr, \"chown_all_cgroup_files: pathname too long: %s\\n\", dirname);",
          "480:   return;",
          "481:  }",
          "483:  d = opendir(dirname);",
          "484:  if (!d) {",
          "485:   fprintf(stderr, \"chown_all_cgroup_files: failed to open %s\\n\", dirname);",
          "486:   return;",
          "487:  }",
          "489:  while (readdir_r(d, &dirent, &direntp) == 0 && direntp) {",
          "490:   if (!strcmp(direntp->d_name, \".\") || !strcmp(direntp->d_name, \"..\"))",
          "491:    continue;",
          "492:   ret = snprintf(path, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);",
          "493:   if (ret < 0 || ret >= MAXPATHLEN) {",
          "494:    fprintf(stderr, \"chown_all_cgroup_files: pathname too long under %s\\n\", dirname);",
          "495:    continue;",
          "496:   }",
          "497:   if (chown(path, uid, gid) < 0)",
          "498:    fprintf(stderr, \"Failed to chown file %s to %u:%u\", path, uid, gid);",
          "499:  }",
          "500:  closedir(d);",
          "501: }",
          "503: int cgfs_create(const char *controller, const char *cg, uid_t uid, gid_t gid)",
          "504: {",
          "505:  size_t len;",
          "506:  char *dirnam, *tmpc = find_mounted_controller(controller);",
          "508:  if (!tmpc)",
          "509:   return -EINVAL;",
          "511:  len = strlen(basedir) + strlen(tmpc) + strlen(cg) + 3;",
          "512:  dirnam = alloca(len);",
          "513:  snprintf(dirnam, len, \"%s/%s/%s\", basedir,tmpc, cg);",
          "515:  if (mkdir(dirnam, 0755) < 0)",
          "516:   return -errno;",
          "518:  if (uid == 0 && gid == 0)",
          "519:   return 0;",
          "521:  if (chown(dirnam, uid, gid) < 0)",
          "522:   return -errno;",
          "524:  chown_all_cgroup_files(dirnam, uid, gid);",
          "526:  return 0;",
          "527: }",
          "529: static bool recursive_rmdir(const char *dirname)",
          "530: {",
          "531:  struct dirent dirent, *direntp;",
          "532:  DIR *dir;",
          "533:  bool ret = false;",
          "534:  char pathname[MAXPATHLEN];",
          "536:  dir = opendir(dirname);",
          "537:  if (!dir) {",
          "538: #if DEBUG",
          "539:   fprintf(stderr, \"%s: failed to open %s: %s\\n\", __func__, dirname, strerror(errno));",
          "540: #endif",
          "541:   return false;",
          "542:  }",
          "544:  while (!readdir_r(dir, &dirent, &direntp)) {",
          "545:   struct stat mystat;",
          "546:   int rc;",
          "548:   if (!direntp)",
          "549:    break;",
          "551:   if (!strcmp(direntp->d_name, \".\") ||",
          "552:       !strcmp(direntp->d_name, \"..\"))",
          "553:    continue;",
          "555:   rc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);",
          "556:   if (rc < 0 || rc >= MAXPATHLEN) {",
          "557:    fprintf(stderr, \"pathname too long\\n\");",
          "558:    continue;",
          "559:   }",
          "561:   ret = lstat(pathname, &mystat);",
          "562:   if (ret) {",
          "563: #if DEBUG",
          "564:    fprintf(stderr, \"%s: failed to stat %s: %s\\n\", __func__, pathname, strerror(errno));",
          "565: #endif",
          "566:    continue;",
          "567:   }",
          "568:   if (S_ISDIR(mystat.st_mode)) {",
          "569:    if (!recursive_rmdir(pathname)) {",
          "570: #if DEBUG",
          "571:     fprintf(stderr, \"Error removing %s\\n\", pathname);",
          "572: #endif",
          "573:    }",
          "574:   }",
          "575:  }",
          "577:  ret = true;",
          "578:  if (closedir(dir) < 0) {",
          "579:   fprintf(stderr, \"%s: failed to close directory %s: %s\\n\", __func__, dirname, strerror(errno));",
          "580:   ret = false;",
          "581:  }",
          "583:  if (rmdir(dirname) < 0) {",
          "584: #if DEBUG",
          "585:   fprintf(stderr, \"%s: failed to delete %s: %s\\n\", __func__, dirname, strerror(errno));",
          "586: #endif",
          "587:   ret = false;",
          "588:  }",
          "590:  return ret;",
          "591: }",
          "593: bool cgfs_remove(const char *controller, const char *cg)",
          "594: {",
          "595:  size_t len;",
          "596:  char *dirnam, *tmpc = find_mounted_controller(controller);",
          "598:  if (!tmpc)",
          "599:   return false;",
          "601:  len = strlen(basedir) + strlen(tmpc) + strlen(cg) + 3;",
          "602:  dirnam = alloca(len);",
          "603:  snprintf(dirnam, len, \"%s/%s/%s\", basedir,tmpc, cg);",
          "604:  return recursive_rmdir(dirnam);",
          "605: }",
          "607: bool cgfs_chmod_file(const char *controller, const char *file, mode_t mode)",
          "608: {",
          "609:  size_t len;",
          "610:  char *pathname, *tmpc = find_mounted_controller(controller);",
          "612:  if (!tmpc)",
          "613:   return false;",
          "615:  len = strlen(basedir) + strlen(tmpc) + strlen(file) + 3;",
          "616:  pathname = alloca(len);",
          "617:  snprintf(pathname, len, \"%s/%s/%s\", basedir, tmpc, file);",
          "618:  if (chmod(pathname, mode) < 0)",
          "619:   return false;",
          "620:  return true;",
          "621: }",
          "623: static int chown_tasks_files(const char *dirname, uid_t uid, gid_t gid)",
          "624: {",
          "625:  size_t len;",
          "626:  char *fname;",
          "628:  len = strlen(dirname) + strlen(\"/cgroup.procs\") + 1;",
          "629:  fname = alloca(len);",
          "630:  snprintf(fname, len, \"%s/tasks\", dirname);",
          "631:  if (chown(fname, uid, gid) != 0)",
          "632:   return -errno;",
          "633:  snprintf(fname, len, \"%s/cgroup.procs\", dirname);",
          "634:  if (chown(fname, uid, gid) != 0)",
          "635:   return -errno;",
          "636:  return 0;",
          "637: }",
          "639: int cgfs_chown_file(const char *controller, const char *file, uid_t uid, gid_t gid)",
          "640: {",
          "641:  size_t len;",
          "642:  char *pathname, *tmpc = find_mounted_controller(controller);",
          "644:  if (!tmpc)",
          "645:   return -EINVAL;",
          "647:  len = strlen(basedir) + strlen(tmpc) + strlen(file) + 3;",
          "648:  pathname = alloca(len);",
          "649:  snprintf(pathname, len, \"%s/%s/%s\", basedir, tmpc, file);",
          "650:  if (chown(pathname, uid, gid) < 0)",
          "651:   return -errno;",
          "653:  if (is_dir(pathname))",
          "655:   return chown_tasks_files(pathname, uid, gid);",
          "657:  return 0;",
          "658: }",
          "660: FILE *open_pids_file(const char *controller, const char *cgroup)",
          "661: {",
          "662:  size_t len;",
          "663:  char *pathname, *tmpc = find_mounted_controller(controller);",
          "665:  if (!tmpc)",
          "666:   return NULL;",
          "668:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + 4 + strlen(\"cgroup.procs\");",
          "669:  pathname = alloca(len);",
          "670:  snprintf(pathname, len, \"%s/%s/%s/cgroup.procs\", basedir, tmpc, cgroup);",
          "671:  return fopen(pathname, \"w\");",
          "672: }",
          "674: bool cgfs_list_children(const char *controller, const char *cgroup, char ***list)",
          "675: {",
          "676:  size_t len;",
          "677:  char *dirname, *tmpc = find_mounted_controller(controller);",
          "678:  char pathname[MAXPATHLEN];",
          "679:  size_t sz = 0, asz = BATCH_SIZE;",
          "680:  struct dirent dirent, *direntp;",
          "681:  DIR *dir;",
          "682:  int ret;",
          "684:  do {",
          "686:  } while (!*list);",
          "687:  (*list)[0] = NULL;",
          "689:  if (!tmpc)",
          "690:   return NULL;",
          "693:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + 3;",
          "694:  dirname = alloca(len);",
          "695:  snprintf(dirname, len, \"%s/%s/%s\", basedir, tmpc, cgroup);",
          "697:  dir = opendir(dirname);",
          "698:  if (!dir)",
          "699:   return false;",
          "701:  while (!readdir_r(dir, &dirent, &direntp)) {",
          "702:   struct stat mystat;",
          "703:   int rc;",
          "705:   if (!direntp)",
          "706:    break;",
          "708:   if (!strcmp(direntp->d_name, \".\") ||",
          "709:       !strcmp(direntp->d_name, \"..\"))",
          "710:    continue;",
          "712:   rc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);",
          "713:   if (rc < 0 || rc >= MAXPATHLEN) {",
          "714:    fprintf(stderr, \"%s: pathname too long under %s\\n\", __func__, dirname);",
          "715:    continue;",
          "716:   }",
          "718:   ret = lstat(pathname, &mystat);",
          "719:   if (ret) {",
          "720:    fprintf(stderr, \"%s: failed to stat %s: %s\\n\", __func__, pathname, strerror(errno));",
          "721:    continue;",
          "722:   }",
          "723:   if (!S_ISDIR(mystat.st_mode))",
          "724:    continue;",
          "726:   if (sz+2 >= asz) {",
          "727:    char **tmp;",
          "728:    asz += BATCH_SIZE;",
          "729:    do {",
          "730:     tmp = realloc(*list, asz * sizeof(char *));",
          "731:    } while  (!tmp);",
          "733:   }",
          "734:   do {",
          "735:    (*list)[sz] = strdup(direntp->d_name);",
          "736:   } while (!(*list)[sz]);",
          "737:   (*list)[sz+1] = NULL;",
          "738:   sz++;",
          "739:  }",
          "740:  if (closedir(dir) < 0) {",
          "741:   fprintf(stderr, \"%s: failed closedir for %s: %s\\n\", __func__, dirname, strerror(errno));",
          "742:   return false;",
          "743:  }",
          "744:  return true;",
          "745: }",
          "747: void free_key(struct cgfs_files *k)",
          "748: {",
          "749:  if (!k)",
          "750:   return;",
          "751:  free(k->name);",
          "752:  free(k);",
          "753: }",
          "755: void free_keys(struct cgfs_files **keys)",
          "756: {",
          "757:  int i;",
          "759:  if (!keys)",
          "760:   return;",
          "761:  for (i = 0; keys[i]; i++) {",
          "762:   free_key(keys[i]);",
          "763:  }",
          "764:  free(keys);",
          "765: }",
          "767: bool cgfs_get_value(const char *controller, const char *cgroup, const char *file, char **value)",
          "768: {",
          "769:  size_t len;",
          "770:  char *fnam, *tmpc = find_mounted_controller(controller);",
          "772:  if (!tmpc)",
          "773:   return false;",
          "775:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + strlen(file) + 4;",
          "776:  fnam = alloca(len);",
          "777:  snprintf(fnam, len, \"%s/%s/%s/%s\", basedir, tmpc, cgroup, file);",
          "780:  return *value != NULL;",
          "781: }",
          "783: struct cgfs_files *cgfs_get_key(const char *controller, const char *cgroup, const char *file)",
          "784: {",
          "785:  size_t len;",
          "786:  char *fnam, *tmpc = find_mounted_controller(controller);",
          "787:  struct stat sb;",
          "788:  struct cgfs_files *newkey;",
          "789:  int ret;",
          "791:  if (!tmpc)",
          "792:   return false;",
          "794:  if (file && *file == '/')",
          "795:   file++;",
          "797:  if (file && index(file, '/'))",
          "798:   return NULL;",
          "801:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + 3;",
          "802:  if (file)",
          "803:   len += strlen(file) + 1;",
          "804:  fnam = alloca(len);",
          "805:  snprintf(fnam, len, \"%s/%s/%s%s%s\", basedir, tmpc, cgroup,",
          "806:   file ? \"/\" : \"\", file ? file : \"\");",
          "808:  ret = stat(fnam, &sb);",
          "809:  if (ret < 0)",
          "810:   return NULL;",
          "812:  do {",
          "813:   newkey = malloc(sizeof(struct cgfs_files));",
          "814:  } while (!newkey);",
          "815:  if (file)",
          "816:   newkey->name = must_copy_string(file);",
          "817:  else if (rindex(cgroup, '/'))",
          "818:   newkey->name = must_copy_string(rindex(cgroup, '/'));",
          "819:  else",
          "820:   newkey->name = must_copy_string(cgroup);",
          "821:  newkey->uid = sb.st_uid;",
          "822:  newkey->gid = sb.st_gid;",
          "823:  newkey->mode = sb.st_mode;",
          "825:  return newkey;",
          "826: }",
          "828: bool cgfs_list_keys(const char *controller, const char *cgroup, struct cgfs_files ***keys)",
          "829: {",
          "830:  size_t len;",
          "831:  char *dirname, *tmpc = find_mounted_controller(controller);",
          "832:  char pathname[MAXPATHLEN];",
          "833:  size_t sz = 0, asz = 0;",
          "834:  struct dirent dirent, *direntp;",
          "835:  DIR *dir;",
          "836:  int ret;",
          "839:  if (!tmpc)",
          "840:   return NULL;",
          "843:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + 3;",
          "844:  dirname = alloca(len);",
          "845:  snprintf(dirname, len, \"%s/%s/%s\", basedir, tmpc, cgroup);",
          "847:  dir = opendir(dirname);",
          "848:  if (!dir)",
          "849:   return false;",
          "851:  while (!readdir_r(dir, &dirent, &direntp)) {",
          "852:   struct stat mystat;",
          "853:   int rc;",
          "855:   if (!direntp)",
          "856:    break;",
          "858:   if (!strcmp(direntp->d_name, \".\") ||",
          "859:       !strcmp(direntp->d_name, \"..\"))",
          "860:    continue;",
          "862:   rc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);",
          "863:   if (rc < 0 || rc >= MAXPATHLEN) {",
          "864:    fprintf(stderr, \"%s: pathname too long under %s\\n\", __func__, dirname);",
          "865:    continue;",
          "866:   }",
          "868:   ret = lstat(pathname, &mystat);",
          "869:   if (ret) {",
          "870:    fprintf(stderr, \"%s: failed to stat %s: %s\\n\", __func__, pathname, strerror(errno));",
          "871:    continue;",
          "872:   }",
          "873:   if (!S_ISREG(mystat.st_mode))",
          "874:    continue;",
          "876:   if (sz+2 >= asz) {",
          "877:    struct cgfs_files **tmp;",
          "878:    asz += BATCH_SIZE;",
          "879:    do {",
          "880:     tmp = realloc(*keys, asz * sizeof(struct cgfs_files *));",
          "881:    } while  (!tmp);",
          "883:   }",
          "884:   (*keys)[sz] = cgfs_get_key(controller, cgroup, direntp->d_name);",
          "885:   (*keys)[sz+1] = NULL;",
          "886:   if (!(*keys)[sz]) {",
          "887:    fprintf(stderr, \"%s: Error getting files under %s:%s\\n\",",
          "888:     __func__, controller, cgroup);",
          "889:    continue;",
          "890:   }",
          "891:   sz++;",
          "892:  }",
          "893:  if (closedir(dir) < 0) {",
          "894:   fprintf(stderr, \"%s: failed closedir for %s: %s\\n\", __func__, dirname, strerror(errno));",
          "895:   return false;",
          "896:  }",
          "897:  return true;",
          "898: }",
          "900: bool is_child_cgroup(const char *controller, const char *cgroup, const char *f)",
          "901: {      size_t len;",
          "902:  char *fnam, *tmpc = find_mounted_controller(controller);",
          "903:  int ret;",
          "904:  struct stat sb;",
          "906:  if (!tmpc)",
          "907:   return false;",
          "909:  len = strlen(basedir) + strlen(tmpc) + strlen(cgroup) + strlen(f) + 4;",
          "910:  fnam = alloca(len);",
          "911:  snprintf(fnam, len, \"%s/%s/%s/%s\", basedir, tmpc, cgroup, f);",
          "913:  ret = stat(fnam, &sb);",
          "914:  if (ret < 0 || !S_ISDIR(sb.st_mode))",
          "915:   return false;",
          "916:  return true;",
          "917: }",
          "919: #define SEND_CREDS_OK 0",
          "920: #define SEND_CREDS_NOTSK 1",
          "921: #define SEND_CREDS_FAIL 2",
          "922: static bool recv_creds(int sock, struct ucred *cred, char *v);",
          "923: static int wait_for_pid(pid_t pid);",
          "924: static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst);",
          "931: static void write_task_init_pid_exit(int sock, pid_t target)",
          "932: {",
          "933:  struct ucred cred;",
          "934:  char fnam[100];",
          "935:  pid_t pid;",
          "936:  char v;",
          "937:  int fd, ret;",
          "939:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", (int)target);",
          "940:  if (ret < 0 || ret >= sizeof(fnam))",
          "941:   _exit(1);",
          "943:  fd = open(fnam, O_RDONLY);",
          "944:  if (fd < 0) {",
          "945:   perror(\"write_task_init_pid_exit open of ns/pid\");",
          "946:   _exit(1);",
          "947:  }",
          "948:  if (setns(fd, 0)) {",
          "949:   perror(\"write_task_init_pid_exit setns 1\");",
          "950:   close(fd);",
          "951:   _exit(1);",
          "952:  }",
          "953:  pid = fork();",
          "954:  if (pid < 0)",
          "955:   _exit(1);",
          "956:  if (pid != 0) {",
          "957:   if (!wait_for_pid(pid))",
          "958:    _exit(1);",
          "959:   _exit(0);",
          "960:  }",
          "963:  cred.uid = 0;",
          "964:  cred.gid = 0;",
          "965:  cred.pid = 1;",
          "966:  v = '1';",
          "967:  if (send_creds(sock, &cred, v, true) != SEND_CREDS_OK)",
          "968:   _exit(1);",
          "969:  _exit(0);",
          "970: }",
          "972: static pid_t get_init_pid_for_task(pid_t task)",
          "973: {",
          "974:  int sock[2];",
          "975:  pid_t pid;",
          "976:  pid_t ret = -1;",
          "977:  char v = '0';",
          "978:  struct ucred cred;",
          "980:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "981:   perror(\"socketpair\");",
          "982:   return -1;",
          "983:  }",
          "985:  pid = fork();",
          "986:  if (pid < 0)",
          "987:   goto out;",
          "988:  if (!pid) {",
          "989:   close(sock[1]);",
          "990:   write_task_init_pid_exit(sock[0], task);",
          "991:   _exit(0);",
          "992:  }",
          "994:  if (!recv_creds(sock[1], &cred, &v))",
          "995:   goto out;",
          "996:  ret = cred.pid;",
          "998: out:",
          "999:  close(sock[0]);",
          "1000:  close(sock[1]);",
          "1001:  if (pid > 0)",
          "1002:   wait_for_pid(pid);",
          "1003:  return ret;",
          "1004: }",
          "1006: static pid_t lookup_initpid_in_store(pid_t qpid)",
          "1007: {",
          "1008:  pid_t answer = 0;",
          "1009:  struct stat sb;",
          "1010:  struct pidns_init_store *e;",
          "1011:  char fnam[100];",
          "1013:  snprintf(fnam, 100, \"/proc/%d/ns/pid\", qpid);",
          "1014:  store_lock();",
          "1015:  if (stat(fnam, &sb) < 0)",
          "1016:   goto out;",
          "1017:  e = lookup_verify_initpid(&sb);",
          "1018:  if (e) {",
          "1019:   answer = e->initpid;",
          "1020:   goto out;",
          "1021:  }",
          "1022:  answer = get_init_pid_for_task(qpid);",
          "1023:  if (answer > 0)",
          "1024:   save_initpid(&sb, answer);",
          "1026: out:",
          "1029:  prune_initpid_store();",
          "1030:  store_unlock();",
          "1031:  return answer;",
          "1032: }",
          "1034: static int wait_for_pid(pid_t pid)",
          "1035: {",
          "1036:  int status, ret;",
          "1038:  if (pid <= 0)",
          "1039:   return -1;",
          "1041: again:",
          "1042:  ret = waitpid(pid, &status, 0);",
          "1043:  if (ret == -1) {",
          "1044:   if (errno == EINTR)",
          "1045:    goto again;",
          "1046:   return -1;",
          "1047:  }",
          "1048:  if (ret != pid)",
          "1049:   goto again;",
          "1050:  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)",
          "1051:   return -1;",
          "1052:  return 0;",
          "1053: }",
          "1063: static void must_strcat_pid(char **src, size_t *sz, size_t *asz, pid_t pid)",
          "1064: {",
          "1065:  char tmp[30];",
          "1067:  int tmplen = sprintf(tmp, \"%d\\n\", (int)pid);",
          "1069:  if (!*src || tmplen + *sz + 1 >= *asz) {",
          "1070:   char *tmp;",
          "1071:   do {",
          "1072:    tmp = realloc(*src, *asz + BUF_RESERVE_SIZE);",
          "1073:   } while (!tmp);",
          "1076:  }",
          "1077:  memcpy((*src) +*sz , tmp, tmplen);",
          "1079:  (*src)[*sz] = '\\0';",
          "1080: }",
          "1088: unsigned int",
          "1089: convert_id_to_ns(FILE *idfile, unsigned int in_id)",
          "1090: {",
          "1091:  unsigned int nsuid,   // base id for a range in the idfile's namespace",
          "1092:        hostuid, // base id for a range in the caller's namespace",
          "1093:        count;   // number of ids in this range",
          "1094:  char line[400];",
          "1095:  int ret;",
          "1097:  fseek(idfile, 0L, SEEK_SET);",
          "1098:  while (fgets(line, 400, idfile)) {",
          "1099:   ret = sscanf(line, \"%u %u %u\\n\", &nsuid, &hostuid, &count);",
          "1100:   if (ret != 3)",
          "1101:    continue;",
          "1102:   if (hostuid + count < hostuid || nsuid + count < nsuid) {",
          "1107:    fprintf(stderr, \"pid wrapparound at entry %u %u %u in %s\\n\",",
          "1108:     nsuid, hostuid, count, line);",
          "1109:    return -1;",
          "1110:   }",
          "1111:   if (hostuid <= in_id && hostuid+count > in_id) {",
          "1118:    return (in_id - hostuid) + nsuid;",
          "1119:   }",
          "1120:  }",
          "1123:  return -1;",
          "1124: }",
          "1131: #define NS_ROOT_REQD true",
          "1132: #define NS_ROOT_OPT false",
          "1134: #define PROCLEN 100",
          "1136: static bool is_privileged_over(pid_t pid, uid_t uid, uid_t victim, bool req_ns_root)",
          "1137: {",
          "1138:  char fpath[PROCLEN];",
          "1139:  int ret;",
          "1140:  bool answer = false;",
          "1141:  uid_t nsuid;",
          "1143:  if (victim == -1 || uid == -1)",
          "1144:   return false;",
          "1151:  if (!req_ns_root && uid == victim)",
          "1152:   return true;",
          "1154:  ret = snprintf(fpath, PROCLEN, \"/proc/%d/uid_map\", pid);",
          "1155:  if (ret < 0 || ret >= PROCLEN)",
          "1156:   return false;",
          "1157:  FILE *f = fopen(fpath, \"r\");",
          "1158:  if (!f)",
          "1159:   return false;",
          "1162:  nsuid = convert_id_to_ns(f, uid);",
          "1163:  if (nsuid)",
          "1164:   goto out;",
          "1171:  nsuid = convert_id_to_ns(f, victim);",
          "1172:  if (nsuid == -1)",
          "1173:   goto out;",
          "1175:  answer = true;",
          "1177: out:",
          "1178:  fclose(f);",
          "1179:  return answer;",
          "1180: }",
          "1182: static bool perms_include(int fmode, mode_t req_mode)",
          "1183: {",
          "1184:  mode_t r;",
          "1186:  switch (req_mode & O_ACCMODE) {",
          "1187:  case O_RDONLY:",
          "1188:   r = S_IROTH;",
          "1189:   break;",
          "1190:  case O_WRONLY:",
          "1191:   r = S_IWOTH;",
          "1192:   break;",
          "1193:  case O_RDWR:",
          "1194:   r = S_IROTH | S_IWOTH;",
          "1195:   break;",
          "1196:  default:",
          "1197:   return false;",
          "1198:  }",
          "1199:  return ((fmode & r) == r);",
          "1200: }",
          "1208: static char *get_next_cgroup_dir(const char *taskcg, const char *querycg)",
          "1209: {",
          "1210:  char *start, *end;",
          "1212:  if (strlen(taskcg) <= strlen(querycg)) {",
          "1213:   fprintf(stderr, \"%s: I was fed bad input\\n\", __func__);",
          "1214:   return NULL;",
          "1215:  }",
          "1217:  if (strcmp(querycg, \"/\") == 0)",
          "1218:   start =  strdup(taskcg + 1);",
          "1219:  else",
          "1220:   start = strdup(taskcg + strlen(querycg) + 1);",
          "1221:  if (!start)",
          "1222:   return NULL;",
          "1223:  end = strchr(start, '/');",
          "1224:  if (end)",
          "1226:  return start;",
          "1227: }",
          "1229: static void stripnewline(char *x)",
          "1230: {",
          "1231:  size_t l = strlen(x);",
          "1232:  if (l && x[l-1] == '\\n')",
          "1233:   x[l-1] = '\\0';",
          "1234: }",
          "1236: static char *get_pid_cgroup(pid_t pid, const char *contrl)",
          "1237: {",
          "1238:  char fnam[PROCLEN];",
          "1239:  FILE *f;",
          "1240:  char *answer = NULL;",
          "1241:  char *line = NULL;",
          "1242:  size_t len = 0;",
          "1243:  int ret;",
          "1244:  const char *h = find_mounted_controller(contrl);",
          "1245:  if (!h)",
          "1246:   return NULL;",
          "1248:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
          "1249:  if (ret < 0 || ret >= PROCLEN)",
          "1250:   return NULL;",
          "1251:  if (!(f = fopen(fnam, \"r\")))",
          "1252:   return NULL;",
          "1254:  while (getline(&line, &len, f) != -1) {",
          "1255:   char *c1, *c2;",
          "1256:   if (!line[0])",
          "1257:    continue;",
          "1258:   c1 = strchr(line, ':');",
          "1259:   if (!c1)",
          "1260:    goto out;",
          "1261:   c1++;",
          "1262:   c2 = strchr(c1, ':');",
          "1263:   if (!c2)",
          "1264:    goto out;",
          "1266:   if (strcmp(c1, h) != 0)",
          "1267:    continue;",
          "1268:   c2++;",
          "1269:   stripnewline(c2);",
          "1270:   do {",
          "1271:    answer = strdup(c2);",
          "1272:   } while (!answer);",
          "1273:   break;",
          "1274:  }",
          "1276: out:",
          "1277:  fclose(f);",
          "1278:  free(line);",
          "1279:  return answer;",
          "1280: }",
          "1293: static bool fc_may_access(struct fuse_context *fc, const char *contrl, const char *cg, const char *file, mode_t mode)",
          "1294: {",
          "1295:  struct cgfs_files *k = NULL;",
          "1296:  bool ret = false;",
          "1298:  k = cgfs_get_key(contrl, cg, file);",
          "1299:  if (!k)",
          "1300:   return false;",
          "1302:  if (is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT)) {",
          "1303:   if (perms_include(k->mode >> 6, mode)) {",
          "1304:    ret = true;",
          "1305:    goto out;",
          "1306:   }",
          "1307:  }",
          "1308:  if (fc->gid == k->gid) {",
          "1309:   if (perms_include(k->mode >> 3, mode)) {",
          "1310:    ret = true;",
          "1311:    goto out;",
          "1312:   }",
          "1313:  }",
          "1314:  ret = perms_include(k->mode, mode);",
          "1316: out:",
          "1317:  free_key(k);",
          "1318:  return ret;",
          "1319: }",
          "1321: #define INITSCOPE \"/init.scope\"",
          "1322: static void prune_init_slice(char *cg)",
          "1323: {",
          "1324:  char *point;",
          "1325:  size_t cg_len = strlen(cg), initscope_len = strlen(INITSCOPE);",
          "1327:  if (cg_len < initscope_len)",
          "1328:   return;",
          "1330:  point = cg + cg_len - initscope_len;",
          "1331:  if (strcmp(point, INITSCOPE) == 0) {",
          "1332:   if (point == cg)",
          "1334:   else",
          "1336:  }",
          "1337: }",
          "1346: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
          "1347: {",
          "1348:  bool answer = false;",
          "1349:  char *c2 = get_pid_cgroup(pid, contrl);",
          "1350:  char *linecmp;",
          "1352:  if (!c2)",
          "1353:   return false;",
          "1354:  prune_init_slice(c2);",
          "1360:  linecmp = *cg == '/' ? c2 : c2+1;",
          "1361:  if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
          "1362:   if (nextcg) {",
          "1364:   }",
          "1365:   goto out;",
          "1366:  }",
          "1367:  answer = true;",
          "1369: out:",
          "1370:  free(c2);",
          "1371:  return answer;",
          "1372: }",
          "1377: static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)",
          "1378: {",
          "1379:  bool answer = false;",
          "1380:  char *c2, *task_cg;",
          "1381:  size_t target_len, task_len;",
          "1383:  if (strcmp(cg, \"/\") == 0)",
          "1384:   return true;",
          "1386:  c2 = get_pid_cgroup(pid, contrl);",
          "1387:  if (!c2)",
          "1388:   return false;",
          "1389:  prune_init_slice(c2);",
          "1391:  task_cg = c2 + 1;",
          "1392:  target_len = strlen(cg);",
          "1393:  task_len = strlen(task_cg);",
          "1394:  if (task_len == 0) {",
          "1400:   answer = true;",
          "1401:   goto out;",
          "1402:  }",
          "1403:  if (strcmp(cg, task_cg) == 0) {",
          "1404:   answer = true;",
          "1405:   goto out;",
          "1406:  }",
          "1407:  if (target_len < task_len) {",
          "1409:   if (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')",
          "1410:    answer = true;",
          "1411:   goto out;",
          "1412:  }",
          "1413:  if (target_len > task_len) {",
          "1415:   if (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')",
          "1416:    answer = true;",
          "1417:   goto out;",
          "1418:  }",
          "1420: out:",
          "1421:  free(c2);",
          "1422:  return answer;",
          "1423: }",
          "1429: static char *pick_controller_from_path(struct fuse_context *fc, const char *path)",
          "1430: {",
          "1431:  const char *p1;",
          "1432:  char *contr, *slash;",
          "1434:  if (strlen(path) < 9)",
          "1435:   return NULL;",
          "1436:  if (*(path+7) != '/')",
          "1437:   return NULL;",
          "1438:  p1 = path+8;",
          "1439:  contr = strdupa(p1);",
          "1440:  if (!contr)",
          "1441:   return NULL;",
          "1442:  slash = strstr(contr, \"/\");",
          "1443:  if (slash)",
          "1446:  int i;",
          "1447:  for (i = 0;  i < num_hierarchies;  i++) {",
          "1448:   if (hierarchies[i] && strcmp(hierarchies[i], contr) == 0)",
          "1449:    return hierarchies[i];",
          "1450:  }",
          "1451:  return NULL;",
          "1452: }",
          "1458: static const char *find_cgroup_in_path(const char *path)",
          "1459: {",
          "1460:  const char *p1;",
          "1462:  if (strlen(path) < 9)",
          "1463:   return NULL;",
          "1464:  p1 = strstr(path+8, \"/\");",
          "1465:  if (!p1)",
          "1466:   return NULL;",
          "1467:  return p1+1;",
          "1468: }",
          "1474: static void get_cgdir_and_path(const char *cg, char **dir, char **last)",
          "1475: {",
          "1476:  char *p;",
          "1478:  do {",
          "1480:  } while (!*dir);",
          "1482:  if (!*last) {",
          "1484:   return;",
          "1485:  }",
          "1486:  p = strrchr(*dir, '/');",
          "1488: }",
          "1494: int cg_getattr(const char *path, struct stat *sb)",
          "1495: {",
          "1496:  struct timespec now;",
          "1497:  struct fuse_context *fc = fuse_get_context();",
          "1498:  char * cgdir = NULL;",
          "1499:  char *last = NULL, *path1, *path2;",
          "1500:  struct cgfs_files *k = NULL;",
          "1501:  const char *cgroup;",
          "1502:  const char *controller = NULL;",
          "1503:  int ret = -ENOENT;",
          "1506:  if (!fc)",
          "1507:   return -EIO;",
          "1509:  memset(sb, 0, sizeof(struct stat));",
          "1511:  if (clock_gettime(CLOCK_REALTIME, &now) < 0)",
          "1512:   return -EINVAL;",
          "1514:  sb->st_uid = sb->st_gid = 0;",
          "1515:  sb->st_atim = sb->st_mtim = sb->st_ctim = now;",
          "1516:  sb->st_size = 0;",
          "1518:  if (strcmp(path, \"/cgroup\") == 0) {",
          "1519:   sb->st_mode = S_IFDIR | 00755;",
          "1520:   sb->st_nlink = 2;",
          "1521:   return 0;",
          "1522:  }",
          "1524:  controller = pick_controller_from_path(fc, path);",
          "1525:  if (!controller)",
          "1526:   return -EIO;",
          "1527:  cgroup = find_cgroup_in_path(path);",
          "1528:  if (!cgroup) {",
          "1530:   sb->st_mode = S_IFDIR | 00755;",
          "1531:   sb->st_nlink = 2;",
          "1532:   return 0;",
          "1533:  }",
          "1535:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1537:  if (!last) {",
          "1538:   path1 = \"/\";",
          "1539:   path2 = cgdir;",
          "1540:  } else {",
          "1541:   path1 = cgdir;",
          "1542:   path2 = last;",
          "1543:  }",
          "1545:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "1546:  if (initpid <= 0)",
          "1547:   initpid = fc->pid;",
          "1552:  if (is_child_cgroup(controller, path1, path2)) {",
          "1553:   if (!caller_may_see_dir(initpid, controller, cgroup)) {",
          "1554:    ret = -ENOENT;",
          "1555:    goto out;",
          "1556:   }",
          "1557:   if (!caller_is_in_ancestor(initpid, controller, cgroup, NULL)) {",
          "1559:    sb->st_mode = S_IFDIR | 00555;",
          "1560:    sb->st_nlink = 2;",
          "1561:    ret = 0;",
          "1562:    goto out;",
          "1563:   }",
          "1564:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
          "1565:    ret = -EACCES;",
          "1566:    goto out;",
          "1567:   }",
          "1571:   sb->st_mode = S_IFDIR | 00755;",
          "1572:   k = cgfs_get_key(controller, cgroup, NULL);",
          "1573:   if (!k) {",
          "1574:    sb->st_uid = sb->st_gid = 0;",
          "1575:   } else {",
          "1576:    sb->st_uid = k->uid;",
          "1577:    sb->st_gid = k->gid;",
          "1578:   }",
          "1579:   free_key(k);",
          "1580:   sb->st_nlink = 2;",
          "1581:   ret = 0;",
          "1582:   goto out;",
          "1583:  }",
          "1585:  if ((k = cgfs_get_key(controller, path1, path2)) != NULL) {",
          "1586:   sb->st_mode = S_IFREG | k->mode;",
          "1587:   sb->st_nlink = 1;",
          "1588:   sb->st_uid = k->uid;",
          "1589:   sb->st_gid = k->gid;",
          "1590:   sb->st_size = 0;",
          "1591:   free_key(k);",
          "1592:   if (!caller_is_in_ancestor(initpid, controller, path1, NULL)) {",
          "1593:    ret = -ENOENT;",
          "1594:    goto out;",
          "1595:   }",
          "1596:   if (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {",
          "1597:    ret = -EACCES;",
          "1598:    goto out;",
          "1599:   }",
          "1601:   ret = 0;",
          "1602:  }",
          "1604: out:",
          "1605:  free(cgdir);",
          "1606:  return ret;",
          "1607: }",
          "1609: int cg_opendir(const char *path, struct fuse_file_info *fi)",
          "1610: {",
          "1611:  struct fuse_context *fc = fuse_get_context();",
          "1612:  const char *cgroup;",
          "1613:  struct file_info *dir_info;",
          "1614:  char *controller = NULL;",
          "1616:  if (!fc)",
          "1617:   return -EIO;",
          "1619:  if (strcmp(path, \"/cgroup\") == 0) {",
          "1620:   cgroup = NULL;",
          "1621:   controller = NULL;",
          "1622:  } else {",
          "1624:   controller = pick_controller_from_path(fc, path);",
          "1625:   if (!controller)",
          "1626:    return -EIO;",
          "1628:   cgroup = find_cgroup_in_path(path);",
          "1629:   if (!cgroup) {",
          "1631:    cgroup = \"/\";",
          "1632:   }",
          "1633:  }",
          "1635:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "1636:  if (initpid <= 0)",
          "1637:   initpid = fc->pid;",
          "1638:  if (cgroup) {",
          "1639:   if (!caller_may_see_dir(initpid, controller, cgroup))",
          "1640:    return -ENOENT;",
          "1641:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "1642:    return -EACCES;",
          "1643:  }",
          "1646:  dir_info = malloc(sizeof(*dir_info));",
          "1647:  if (!dir_info)",
          "1648:   return -ENOMEM;",
          "1649:  dir_info->controller = must_copy_string(controller);",
          "1650:  dir_info->cgroup = must_copy_string(cgroup);",
          "1651:  dir_info->type = LXC_TYPE_CGDIR;",
          "1652:  dir_info->buf = NULL;",
          "1653:  dir_info->file = NULL;",
          "1654:  dir_info->buflen = 0;",
          "1656:  fi->fh = (unsigned long)dir_info;",
          "1657:  return 0;",
          "1658: }",
          "1660: int cg_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "1661:   struct fuse_file_info *fi)",
          "1662: {",
          "1663:  struct file_info *d = (struct file_info *)fi->fh;",
          "1664:  struct cgfs_files **list = NULL;",
          "1665:  int i, ret;",
          "1666:  char *nextcg = NULL;",
          "1667:  struct fuse_context *fc = fuse_get_context();",
          "1668:  char **clist = NULL;",
          "1670:  if (d->type != LXC_TYPE_CGDIR) {",
          "1671:   fprintf(stderr, \"Internal error: file cache info used in readdir\\n\");",
          "1672:   return -EIO;",
          "1673:  }",
          "1674:  if (!d->cgroup && !d->controller) {",
          "1676:   int i;",
          "1678:   for (i = 0;  i < num_hierarchies; i++) {",
          "1679:    if (hierarchies[i] && filler(buf, hierarchies[i], NULL, 0) != 0) {",
          "1680:     return -EIO;",
          "1681:    }",
          "1682:   }",
          "1683:   return 0;",
          "1684:  }",
          "1686:  if (!cgfs_list_keys(d->controller, d->cgroup, &list)) {",
          "1688:   ret = -EINVAL;",
          "1689:   goto out;",
          "1690:  }",
          "1692:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "1693:  if (initpid <= 0)",
          "1694:   initpid = fc->pid;",
          "1695:  if (!caller_is_in_ancestor(initpid, d->controller, d->cgroup, &nextcg)) {",
          "1696:   if (nextcg) {",
          "1697:    ret = filler(buf, nextcg,  NULL, 0);",
          "1698:    free(nextcg);",
          "1699:    if (ret != 0) {",
          "1700:     ret = -EIO;",
          "1701:     goto out;",
          "1702:    }",
          "1703:   }",
          "1704:   ret = 0;",
          "1705:   goto out;",
          "1706:  }",
          "1708:  for (i = 0; list[i]; i++) {",
          "1709:   if (filler(buf, list[i]->name, NULL, 0) != 0) {",
          "1710:    ret = -EIO;",
          "1711:    goto out;",
          "1712:   }",
          "1713:  }",
          "1717:  if (!cgfs_list_children(d->controller, d->cgroup, &clist)) {",
          "1718:   ret = 0;",
          "1719:   goto out;",
          "1720:  }",
          "1721:  for (i = 0; clist[i]; i++) {",
          "1722:   if (filler(buf, clist[i], NULL, 0) != 0) {",
          "1723:    ret = -EIO;",
          "1724:    goto out;",
          "1725:   }",
          "1726:  }",
          "1727:  ret = 0;",
          "1729: out:",
          "1730:  free_keys(list);",
          "1731:  if (clist) {",
          "1732:   for (i = 0; clist[i]; i++)",
          "1733:    free(clist[i]);",
          "1734:   free(clist);",
          "1735:  }",
          "1736:  return ret;",
          "1737: }",
          "1739: static void do_release_file_info(struct file_info *f)",
          "1740: {",
          "1741:  if (!f)",
          "1742:   return;",
          "1743:  free(f->controller);",
          "1744:  free(f->cgroup);",
          "1745:  free(f->file);",
          "1746:  free(f->buf);",
          "1747:  free(f);",
          "1748: }",
          "1750: int cg_releasedir(const char *path, struct fuse_file_info *fi)",
          "1751: {",
          "1752:  struct file_info *d = (struct file_info *)fi->fh;",
          "1754:  do_release_file_info(d);",
          "1755:  return 0;",
          "1756: }",
          "1758: int cg_open(const char *path, struct fuse_file_info *fi)",
          "1759: {",
          "1760:  const char *cgroup;",
          "1761:  char *last = NULL, *path1, *path2, * cgdir = NULL, *controller;",
          "1762:  struct cgfs_files *k = NULL;",
          "1763:  struct file_info *file_info;",
          "1764:  struct fuse_context *fc = fuse_get_context();",
          "1765:  int ret;",
          "1767:  if (!fc)",
          "1768:   return -EIO;",
          "1770:  controller = pick_controller_from_path(fc, path);",
          "1771:  if (!controller)",
          "1772:   return -EIO;",
          "1773:  cgroup = find_cgroup_in_path(path);",
          "1774:  if (!cgroup)",
          "1775:   return -EINVAL;",
          "1777:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1778:  if (!last) {",
          "1779:   path1 = \"/\";",
          "1780:   path2 = cgdir;",
          "1781:  } else {",
          "1782:   path1 = cgdir;",
          "1783:   path2 = last;",
          "1784:  }",
          "1786:  k = cgfs_get_key(controller, path1, path2);",
          "1787:  if (!k) {",
          "1788:   ret = -EINVAL;",
          "1789:   goto out;",
          "1790:  }",
          "1791:  free_key(k);",
          "1793:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "1794:  if (initpid <= 0)",
          "1795:   initpid = fc->pid;",
          "1796:  if (!caller_may_see_dir(initpid, controller, path1)) {",
          "1797:   ret = -ENOENT;",
          "1798:   goto out;",
          "1799:  }",
          "1800:  if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {",
          "1802:   ret = -EACCES;",
          "1803:   goto out;",
          "1804:  }",
          "1807:  file_info = malloc(sizeof(*file_info));",
          "1808:  if (!file_info) {",
          "1809:   ret = -ENOMEM;",
          "1810:   goto out;",
          "1811:  }",
          "1812:  file_info->controller = must_copy_string(controller);",
          "1813:  file_info->cgroup = must_copy_string(path1);",
          "1814:  file_info->file = must_copy_string(path2);",
          "1815:  file_info->type = LXC_TYPE_CGFILE;",
          "1816:  file_info->buf = NULL;",
          "1817:  file_info->buflen = 0;",
          "1819:  fi->fh = (unsigned long)file_info;",
          "1820:  ret = 0;",
          "1822: out:",
          "1823:  free(cgdir);",
          "1824:  return ret;",
          "1825: }",
          "1827: int cg_release(const char *path, struct fuse_file_info *fi)",
          "1828: {",
          "1829:  struct file_info *f = (struct file_info *)fi->fh;",
          "1831:  do_release_file_info(f);",
          "1832:  return 0;",
          "1833: }",
          "1835: #define POLLIN_SET ( EPOLLIN | EPOLLHUP | EPOLLRDHUP )",
          "1837: static bool wait_for_sock(int sock, int timeout)",
          "1838: {",
          "1839:  struct epoll_event ev;",
          "1840:  int epfd, ret, now, starttime, deltatime, saved_errno;",
          "1842:  if ((starttime = time(NULL)) < 0)",
          "1843:   return false;",
          "1845:  if ((epfd = epoll_create(1)) < 0) {",
          "1846:   fprintf(stderr, \"Failed to create epoll socket: %m\\n\");",
          "1847:   return false;",
          "1848:  }",
          "1850:  ev.events = POLLIN_SET;",
          "1851:  ev.data.fd = sock;",
          "1852:  if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &ev) < 0) {",
          "1853:   fprintf(stderr, \"Failed adding socket to epoll: %m\\n\");",
          "1854:   close(epfd);",
          "1855:   return false;",
          "1856:  }",
          "1858: again:",
          "1859:  if ((now = time(NULL)) < 0) {",
          "1860:   close(epfd);",
          "1861:   return false;",
          "1862:  }",
          "1864:  deltatime = (starttime + timeout) - now;",
          "1865:  if (deltatime < 0) { // timeout",
          "1866:   errno = 0;",
          "1867:   close(epfd);",
          "1868:   return false;",
          "1869:  }",
          "1870:  ret = epoll_wait(epfd, &ev, 1, 1000*deltatime + 1);",
          "1871:  if (ret < 0 && errno == EINTR)",
          "1872:   goto again;",
          "1873:  saved_errno = errno;",
          "1874:  close(epfd);",
          "1876:  if (ret <= 0) {",
          "1877:   errno = saved_errno;",
          "1878:   return false;",
          "1879:  }",
          "1880:  return true;",
          "1881: }",
          "1883: static int msgrecv(int sockfd, void *buf, size_t len)",
          "1884: {",
          "1885:  if (!wait_for_sock(sockfd, 2))",
          "1886:   return -1;",
          "1887:  return recv(sockfd, buf, len, MSG_DONTWAIT);",
          "1888: }",
          "1890: static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst)",
          "1891: {",
          "1892:  struct msghdr msg = { 0 };",
          "1893:  struct iovec iov;",
          "1894:  struct cmsghdr *cmsg;",
          "1895:  char cmsgbuf[CMSG_SPACE(sizeof(*cred))];",
          "1896:  char buf[1];",
          "1897:  buf[0] = 'p';",
          "1899:  if (pingfirst) {",
          "1900:   if (msgrecv(sock, buf, 1) != 1) {",
          "1901:    fprintf(stderr, \"%s: Error getting reply from server over socketpair\\n\",",
          "1902:       __func__);",
          "1903:    return SEND_CREDS_FAIL;",
          "1904:   }",
          "1905:  }",
          "1907:  msg.msg_control = cmsgbuf;",
          "1908:  msg.msg_controllen = sizeof(cmsgbuf);",
          "1910:  cmsg = CMSG_FIRSTHDR(&msg);",
          "1911:  cmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));",
          "1912:  cmsg->cmsg_level = SOL_SOCKET;",
          "1913:  cmsg->cmsg_type = SCM_CREDENTIALS;",
          "1914:  memcpy(CMSG_DATA(cmsg), cred, sizeof(*cred));",
          "1916:  msg.msg_name = NULL;",
          "1917:  msg.msg_namelen = 0;",
          "1919:  buf[0] = v;",
          "1920:  iov.iov_base = buf;",
          "1921:  iov.iov_len = sizeof(buf);",
          "1922:  msg.msg_iov = &iov;",
          "1923:  msg.msg_iovlen = 1;",
          "1925:  if (sendmsg(sock, &msg, 0) < 0) {",
          "1926:   fprintf(stderr, \"%s: failed at sendmsg: %s\\n\", __func__,",
          "1927:      strerror(errno));",
          "1928:   if (errno == 3)",
          "1929:    return SEND_CREDS_NOTSK;",
          "1930:   return SEND_CREDS_FAIL;",
          "1931:  }",
          "1933:  return SEND_CREDS_OK;",
          "1934: }",
          "1936: static bool recv_creds(int sock, struct ucred *cred, char *v)",
          "1937: {",
          "1938:  struct msghdr msg = { 0 };",
          "1939:  struct iovec iov;",
          "1940:  struct cmsghdr *cmsg;",
          "1941:  char cmsgbuf[CMSG_SPACE(sizeof(*cred))];",
          "1942:  char buf[1];",
          "1943:  int ret;",
          "1944:  int optval = 1;",
          "1948:  cred->pid = -1;",
          "1949:  cred->uid = -1;",
          "1950:  cred->gid = -1;",
          "1952:  if (setsockopt(sock, SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {",
          "1953:   fprintf(stderr, \"Failed to set passcred: %s\\n\", strerror(errno));",
          "1954:   return false;",
          "1955:  }",
          "1956:  buf[0] = '1';",
          "1957:  if (write(sock, buf, 1) != 1) {",
          "1958:   fprintf(stderr, \"Failed to start write on scm fd: %s\\n\", strerror(errno));",
          "1959:   return false;",
          "1960:  }",
          "1962:  msg.msg_name = NULL;",
          "1963:  msg.msg_namelen = 0;",
          "1964:  msg.msg_control = cmsgbuf;",
          "1965:  msg.msg_controllen = sizeof(cmsgbuf);",
          "1967:  iov.iov_base = buf;",
          "1968:  iov.iov_len = sizeof(buf);",
          "1969:  msg.msg_iov = &iov;",
          "1970:  msg.msg_iovlen = 1;",
          "1972:  if (!wait_for_sock(sock, 2)) {",
          "1973:   fprintf(stderr, \"Timed out waiting for scm_cred: %s\\n\",",
          "1974:      strerror(errno));",
          "1975:   return false;",
          "1976:  }",
          "1977:  ret = recvmsg(sock, &msg, MSG_DONTWAIT);",
          "1978:  if (ret < 0) {",
          "1979:   fprintf(stderr, \"Failed to receive scm_cred: %s\\n\",",
          "1980:      strerror(errno));",
          "1981:   return false;",
          "1982:  }",
          "1984:  cmsg = CMSG_FIRSTHDR(&msg);",
          "1986:  if (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(struct ucred)) &&",
          "1987:    cmsg->cmsg_level == SOL_SOCKET &&",
          "1988:    cmsg->cmsg_type == SCM_CREDENTIALS) {",
          "1989:   memcpy(cred, CMSG_DATA(cmsg), sizeof(*cred));",
          "1990:  }",
          "1993:  return true;",
          "1994: }",
          "2002: static void pid_to_ns(int sock, pid_t tpid)",
          "2003: {",
          "2004:  char v = '0';",
          "2005:  struct ucred cred;",
          "2007:  while (recv_creds(sock, &cred, &v)) {",
          "2008:   if (v == '1')",
          "2009:    _exit(0);",
          "2010:   if (write(sock, &cred.pid, sizeof(pid_t)) != sizeof(pid_t))",
          "2011:    _exit(1);",
          "2012:  }",
          "2013:  _exit(0);",
          "2014: }",
          "2022: static void pid_to_ns_wrapper(int sock, pid_t tpid)",
          "2023: {",
          "2024:  int newnsfd = -1, ret, cpipe[2];",
          "2025:  char fnam[100];",
          "2026:  pid_t cpid;",
          "2027:  char v;",
          "2029:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", tpid);",
          "2030:  if (ret < 0 || ret >= sizeof(fnam))",
          "2031:   _exit(1);",
          "2032:  newnsfd = open(fnam, O_RDONLY);",
          "2033:  if (newnsfd < 0)",
          "2034:   _exit(1);",
          "2035:  if (setns(newnsfd, 0) < 0)",
          "2036:   _exit(1);",
          "2037:  close(newnsfd);",
          "2039:  if (pipe(cpipe) < 0)",
          "2040:   _exit(1);",
          "2042:  cpid = fork();",
          "2043:  if (cpid < 0)",
          "2044:   _exit(1);",
          "2046:  if (!cpid) {",
          "2047:   char b = '1';",
          "2048:   close(cpipe[0]);",
          "2049:   if (write(cpipe[1], &b, sizeof(char)) < 0) {",
          "2050:    fprintf(stderr, \"%s (child): erorr on write: %s\\n\",",
          "2051:     __func__, strerror(errno));",
          "2052:   }",
          "2053:   close(cpipe[1]);",
          "2054:   pid_to_ns(sock, tpid);",
          "2055:   _exit(1); // not reached",
          "2056:  }",
          "2059:  if (!wait_for_sock(cpipe[0], 1))",
          "2060:   _exit(1);",
          "2061:  ret = read(cpipe[0], &v, 1);",
          "2062:  if (ret != sizeof(char) || v != '1')",
          "2063:   _exit(1);",
          "2065:  if (!wait_for_pid(cpid))",
          "2066:   _exit(1);",
          "2067:  _exit(0);",
          "2068: }",
          "2075: bool do_read_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, char **d)",
          "2076: {",
          "2077:  int sock[2] = {-1, -1};",
          "2078:  char *tmpdata = NULL;",
          "2079:  int ret;",
          "2080:  pid_t qpid, cpid = -1;",
          "2081:  bool answer = false;",
          "2082:  char v = '0';",
          "2083:  struct ucred cred;",
          "2084:  size_t sz = 0, asz = 0;",
          "2086:  if (!cgfs_get_value(contrl, cg, file, &tmpdata))",
          "2087:   return false;",
          "2095:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "2096:   perror(\"socketpair\");",
          "2097:   free(tmpdata);",
          "2098:   return false;",
          "2099:  }",
          "2101:  cpid = fork();",
          "2102:  if (cpid == -1)",
          "2103:   goto out;",
          "2105:  if (!cpid) // child - exits when done",
          "2106:   pid_to_ns_wrapper(sock[1], tpid);",
          "2108:  char *ptr = tmpdata;",
          "2109:  cred.uid = 0;",
          "2110:  cred.gid = 0;",
          "2111:  while (sscanf(ptr, \"%d\\n\", &qpid) == 1) {",
          "2112:   cred.pid = qpid;",
          "2113:   ret = send_creds(sock[0], &cred, v, true);",
          "2115:   if (ret == SEND_CREDS_NOTSK)",
          "2116:    goto next;",
          "2117:   if (ret == SEND_CREDS_FAIL)",
          "2118:    goto out;",
          "2121:   if (!wait_for_sock(sock[0], 2)) {",
          "2122:    fprintf(stderr, \"%s: timed out waiting for pid from child: %s\\n\",",
          "2123:     __func__, strerror(errno));",
          "2124:    goto out;",
          "2125:   }",
          "2126:   if (read(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {",
          "2127:    fprintf(stderr, \"%s: error reading pid from child: %s\\n\",",
          "2128:     __func__, strerror(errno));",
          "2129:    goto out;",
          "2130:   }",
          "2131:   must_strcat_pid(d, &sz, &asz, qpid);",
          "2132: next:",
          "2133:   ptr = strchr(ptr, '\\n');",
          "2134:   if (!ptr)",
          "2135:    break;",
          "2136:   ptr++;",
          "2137:  }",
          "2139:  cred.pid = getpid();",
          "2140:  v = '1';",
          "2141:  if (send_creds(sock[0], &cred, v, true) != SEND_CREDS_OK) {",
          "2143:   fprintf(stderr, \"%s: failed to ask child to exit: %s\\n\",",
          "2144:    __func__, strerror(errno));",
          "2145:   goto out;",
          "2146:  }",
          "2148:  answer = true;",
          "2150: out:",
          "2151:  free(tmpdata);",
          "2152:  if (cpid != -1)",
          "2153:   wait_for_pid(cpid);",
          "2154:  if (sock[0] != -1) {",
          "2155:   close(sock[0]);",
          "2156:   close(sock[1]);",
          "2157:  }",
          "2158:  return answer;",
          "2159: }",
          "2161: int cg_read(const char *path, char *buf, size_t size, off_t offset,",
          "2162:   struct fuse_file_info *fi)",
          "2163: {",
          "2164:  struct fuse_context *fc = fuse_get_context();",
          "2165:  struct file_info *f = (struct file_info *)fi->fh;",
          "2166:  struct cgfs_files *k = NULL;",
          "2167:  char *data = NULL;",
          "2168:  int ret, s;",
          "2169:  bool r;",
          "2171:  if (f->type != LXC_TYPE_CGFILE) {",
          "2172:   fprintf(stderr, \"Internal error: directory cache info used in cg_read\\n\");",
          "2173:   return -EIO;",
          "2174:  }",
          "2176:  if (offset)",
          "2177:   return 0;",
          "2179:  if (!fc)",
          "2180:   return -EIO;",
          "2182:  if (!f->controller)",
          "2183:   return -EINVAL;",
          "2185:  if ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {",
          "2186:   return -EINVAL;",
          "2187:  }",
          "2188:  free_key(k);",
          "2191:  if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_RDONLY)) { // should never get here",
          "2192:   ret = -EACCES;",
          "2193:   goto out;",
          "2194:  }",
          "2196:  if (strcmp(f->file, \"tasks\") == 0 ||",
          "2197:    strcmp(f->file, \"/tasks\") == 0 ||",
          "2198:    strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "2199:    strcmp(f->file, \"cgroup.procs\") == 0)",
          "2201:   r = do_read_pids(fc->pid, f->controller, f->cgroup, f->file, &data);",
          "2202:  else",
          "2203:   r = cgfs_get_value(f->controller, f->cgroup, f->file, &data);",
          "2205:  if (!r) {",
          "2206:   ret = -EINVAL;",
          "2207:   goto out;",
          "2208:  }",
          "2210:  if (!data) {",
          "2211:   ret = 0;",
          "2212:   goto out;",
          "2213:  }",
          "2214:  s = strlen(data);",
          "2215:  if (s > size)",
          "2216:   s = size;",
          "2217:  memcpy(buf, data, s);",
          "2218:  if (s > 0 && s < size && data[s-1] != '\\n')",
          "2219:   buf[s++] = '\\n';",
          "2221:  ret = s;",
          "2223: out:",
          "2224:  free(data);",
          "2225:  return ret;",
          "2226: }",
          "2228: static void pid_from_ns(int sock, pid_t tpid)",
          "2229: {",
          "2230:  pid_t vpid;",
          "2231:  struct ucred cred;",
          "2232:  char v;",
          "2233:  int ret;",
          "2235:  cred.uid = 0;",
          "2236:  cred.gid = 0;",
          "2237:  while (1) {",
          "2238:   if (!wait_for_sock(sock, 2)) {",
          "2239:    fprintf(stderr, \"%s: timeout reading from parent\\n\", __func__);",
          "2240:    _exit(1);",
          "2241:   }",
          "2242:   if ((ret = read(sock, &vpid, sizeof(pid_t))) != sizeof(pid_t)) {",
          "2243:    fprintf(stderr, \"%s: bad read from parent: %s\\n\",",
          "2244:     __func__, strerror(errno));",
          "2245:    _exit(1);",
          "2246:   }",
          "2247:   if (vpid == -1) // done",
          "2248:    break;",
          "2249:   v = '0';",
          "2250:   cred.pid = vpid;",
          "2251:   if (send_creds(sock, &cred, v, true) != SEND_CREDS_OK) {",
          "2252:    v = '1';",
          "2253:    cred.pid = getpid();",
          "2254:    if (send_creds(sock, &cred, v, false) != SEND_CREDS_OK)",
          "2255:     _exit(1);",
          "2256:   }",
          "2257:  }",
          "2258:  _exit(0);",
          "2259: }",
          "2261: static void pid_from_ns_wrapper(int sock, pid_t tpid)",
          "2262: {",
          "2263:  int newnsfd = -1, ret, cpipe[2];",
          "2264:  char fnam[100];",
          "2265:  pid_t cpid;",
          "2266:  char v;",
          "2268:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", tpid);",
          "2269:  if (ret < 0 || ret >= sizeof(fnam))",
          "2270:   _exit(1);",
          "2271:  newnsfd = open(fnam, O_RDONLY);",
          "2272:  if (newnsfd < 0)",
          "2273:   _exit(1);",
          "2274:  if (setns(newnsfd, 0) < 0)",
          "2275:   _exit(1);",
          "2276:  close(newnsfd);",
          "2278:  if (pipe(cpipe) < 0)",
          "2279:   _exit(1);",
          "2281: loop:",
          "2282:  cpid = fork();",
          "2284:  if (cpid < 0)",
          "2285:   _exit(1);",
          "2287:  if (!cpid) {",
          "2288:   char b = '1';",
          "2289:   close(cpipe[0]);",
          "2290:   if (write(cpipe[1], &b, sizeof(char)) < 0) {",
          "2291:    fprintf(stderr, \"%s (child): erorr on write: %s\\n\",",
          "2292:     __func__, strerror(errno));",
          "2293:   }",
          "2294:   close(cpipe[1]);",
          "2295:   pid_from_ns(sock, tpid);",
          "2296:  }",
          "2300:  if (!wait_for_sock(cpipe[0], 1))",
          "2301:   goto again;",
          "2302:  ret = read(cpipe[0], &v, 1);",
          "2303:  if (ret != sizeof(char) || v != '1') {",
          "2304:   goto again;",
          "2305:  }",
          "2307:  if (!wait_for_pid(cpid))",
          "2308:   _exit(1);",
          "2309:  _exit(0);",
          "2311: again:",
          "2312:  kill(cpid, SIGKILL);",
          "2313:  wait_for_pid(cpid);",
          "2314:  goto loop;",
          "2315: }",
          "2321: bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)",
          "2322: {",
          "2323:  FILE *f;",
          "2324:  char line[400];",
          "2326:  sprintf(line, \"/proc/%d/uid_map\", pid);",
          "2327:  if ((f = fopen(line, \"r\")) == NULL) {",
          "2328:   return false;",
          "2329:  }",
          "2332:  fclose(f);",
          "2334:  if (*answer == -1)",
          "2335:   return false;",
          "2336:  return true;",
          "2337: }",
          "2344: void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)",
          "2345: {",
          "2346:  char line[400];",
          "2347:  uid_t u;",
          "2348:  gid_t g;",
          "2349:  FILE *f;",
          "2353:  sprintf(line, \"/proc/%d/status\", pid);",
          "2354:  if ((f = fopen(line, \"r\")) == NULL) {",
          "2355:   fprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));",
          "2356:   return;",
          "2357:  }",
          "2358:  while (fgets(line, 400, f)) {",
          "2359:   if (strncmp(line, \"Uid:\", 4) == 0) {",
          "2360:    if (sscanf(line+4, \"%u\", &u) != 1) {",
          "2361:     fprintf(stderr, \"bad uid line for pid %u\\n\", pid);",
          "2362:     fclose(f);",
          "2363:     return;",
          "2364:    }",
          "2366:   } else if (strncmp(line, \"Gid:\", 4) == 0) {",
          "2367:    if (sscanf(line+4, \"%u\", &g) != 1) {",
          "2368:     fprintf(stderr, \"bad gid line for pid %u\\n\", pid);",
          "2369:     fclose(f);",
          "2370:     return;",
          "2371:    }",
          "2373:   }",
          "2374:  }",
          "2375:  fclose(f);",
          "2376: }",
          "2386: bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)",
          "2387: {",
          "2388:  uid_t v_uid, tmpuid;",
          "2389:  gid_t v_gid;",
          "2391:  if (r == v)",
          "2392:   return true;",
          "2393:  if (r_uid == 0)",
          "2394:   return true;",
          "2395:  get_pid_creds(v, &v_uid, &v_gid);",
          "2396:  if (r_uid == v_uid)",
          "2397:   return true;",
          "2398:  if (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0",
          "2399:    && hostuid_to_ns(v_uid, r, &tmpuid))",
          "2400:   return true;",
          "2401:  return false;",
          "2402: }",
          "2404: static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,",
          "2405:   const char *file, const char *buf)",
          "2406: {",
          "2407:  int sock[2] = {-1, -1};",
          "2408:  pid_t qpid, cpid = -1;",
          "2409:  FILE *pids_file = NULL;",
          "2410:  bool answer = false, fail = false;",
          "2412:  pids_file = open_pids_file(contrl, cg);",
          "2413:  if (!pids_file)",
          "2414:   return false;",
          "2420:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "2421:   perror(\"socketpair\");",
          "2422:   goto out;",
          "2423:  }",
          "2425:  cpid = fork();",
          "2426:  if (cpid == -1)",
          "2427:   goto out;",
          "2429:  if (!cpid) { // child",
          "2430:   fclose(pids_file);",
          "2431:   pid_from_ns_wrapper(sock[1], tpid);",
          "2432:  }",
          "2434:  const char *ptr = buf;",
          "2435:  while (sscanf(ptr, \"%d\", &qpid) == 1) {",
          "2436:   struct ucred cred;",
          "2437:   char v;",
          "2439:   if (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {",
          "2440:    fprintf(stderr, \"%s: error writing pid to child: %s\\n\",",
          "2441:     __func__, strerror(errno));",
          "2442:    goto out;",
          "2443:   }",
          "2445:   if (recv_creds(sock[0], &cred, &v)) {",
          "2446:    if (v == '0') {",
          "2447:     if (!may_move_pid(tpid, tuid, cred.pid)) {",
          "2448:      fail = true;",
          "2449:      break;",
          "2450:     }",
          "2451:     if (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)",
          "2452:      fail = true;",
          "2453:    }",
          "2454:   }",
          "2456:   ptr = strchr(ptr, '\\n');",
          "2457:   if (!ptr)",
          "2458:    break;",
          "2459:   ptr++;",
          "2460:  }",
          "2463:  qpid = -1;",
          "2464:  if (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))",
          "2465:   fprintf(stderr, \"Warning: failed to ask child to exit\\n\");",
          "2467:  if (!fail)",
          "2468:   answer = true;",
          "2470: out:",
          "2471:  if (cpid != -1)",
          "2472:   wait_for_pid(cpid);",
          "2473:  if (sock[0] != -1) {",
          "2474:   close(sock[0]);",
          "2475:   close(sock[1]);",
          "2476:  }",
          "2477:  if (pids_file) {",
          "2478:   if (fclose(pids_file) != 0)",
          "2479:    answer = false;",
          "2480:  }",
          "2481:  return answer;",
          "2482: }",
          "2484: int cg_write(const char *path, const char *buf, size_t size, off_t offset,",
          "2485:       struct fuse_file_info *fi)",
          "2486: {",
          "2487:  struct fuse_context *fc = fuse_get_context();",
          "2488:  char *localbuf = NULL;",
          "2489:  struct cgfs_files *k = NULL;",
          "2490:  struct file_info *f = (struct file_info *)fi->fh;",
          "2491:  bool r;",
          "2493:  if (f->type != LXC_TYPE_CGFILE) {",
          "2494:   fprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");",
          "2495:   return -EIO;",
          "2496:  }",
          "2498:  if (offset)",
          "2499:   return 0;",
          "2501:  if (!fc)",
          "2502:   return -EIO;",
          "2504:  localbuf = alloca(size+1);",
          "2505:  localbuf[size] = '\\0';",
          "2506:  memcpy(localbuf, buf, size);",
          "2508:  if ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {",
          "2509:   size = -EINVAL;",
          "2510:   goto out;",
          "2511:  }",
          "2513:  if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {",
          "2514:   size = -EACCES;",
          "2515:   goto out;",
          "2516:  }",
          "2518:  if (strcmp(f->file, \"tasks\") == 0 ||",
          "2519:    strcmp(f->file, \"/tasks\") == 0 ||",
          "2520:    strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "2521:    strcmp(f->file, \"cgroup.procs\") == 0)",
          "2523:   r = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);",
          "2524:  else",
          "2525:   r = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);",
          "2527:  if (!r)",
          "2528:   size = -EINVAL;",
          "2530: out:",
          "2531:  free_key(k);",
          "2532:  return size;",
          "2533: }",
          "2535: int cg_chown(const char *path, uid_t uid, gid_t gid)",
          "2536: {",
          "2537:  struct fuse_context *fc = fuse_get_context();",
          "2538:  char *cgdir = NULL, *last = NULL, *path1, *path2, *controller;",
          "2539:  struct cgfs_files *k = NULL;",
          "2540:  const char *cgroup;",
          "2541:  int ret;",
          "2543:  if (!fc)",
          "2544:   return -EIO;",
          "2546:  if (strcmp(path, \"/cgroup\") == 0)",
          "2547:   return -EINVAL;",
          "2549:  controller = pick_controller_from_path(fc, path);",
          "2550:  if (!controller)",
          "2551:   return -EINVAL;",
          "2552:  cgroup = find_cgroup_in_path(path);",
          "2553:  if (!cgroup)",
          "2555:   return -EINVAL;",
          "2557:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "2559:  if (!last) {",
          "2560:   path1 = \"/\";",
          "2561:   path2 = cgdir;",
          "2562:  } else {",
          "2563:   path1 = cgdir;",
          "2564:   path2 = last;",
          "2565:  }",
          "2567:  if (is_child_cgroup(controller, path1, path2)) {",
          "2570:   k = cgfs_get_key(controller, cgroup, \"tasks\");",
          "2572:  } else",
          "2573:   k = cgfs_get_key(controller, path1, path2);",
          "2575:  if (!k) {",
          "2576:   ret = -EINVAL;",
          "2577:   goto out;",
          "2578:  }",
          "2586:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_REQD)) {",
          "2587:   ret = -EACCES;",
          "2588:   goto out;",
          "2589:  }",
          "2591:  ret = cgfs_chown_file(controller, cgroup, uid, gid);",
          "2593: out:",
          "2594:  free_key(k);",
          "2595:  free(cgdir);",
          "2597:  return ret;",
          "2598: }",
          "2600: int cg_chmod(const char *path, mode_t mode)",
          "2601: {",
          "2602:  struct fuse_context *fc = fuse_get_context();",
          "2603:  char * cgdir = NULL, *last = NULL, *path1, *path2, *controller;",
          "2604:  struct cgfs_files *k = NULL;",
          "2605:  const char *cgroup;",
          "2606:  int ret;",
          "2608:  if (!fc)",
          "2609:   return -EIO;",
          "2611:  if (strcmp(path, \"/cgroup\") == 0)",
          "2612:   return -EINVAL;",
          "2614:  controller = pick_controller_from_path(fc, path);",
          "2615:  if (!controller)",
          "2616:   return -EINVAL;",
          "2617:  cgroup = find_cgroup_in_path(path);",
          "2618:  if (!cgroup)",
          "2620:   return -EINVAL;",
          "2622:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "2624:  if (!last) {",
          "2625:   path1 = \"/\";",
          "2626:   path2 = cgdir;",
          "2627:  } else {",
          "2628:   path1 = cgdir;",
          "2629:   path2 = last;",
          "2630:  }",
          "2632:  if (is_child_cgroup(controller, path1, path2)) {",
          "2635:   k = cgfs_get_key(controller, cgroup, \"tasks\");",
          "2637:  } else",
          "2638:   k = cgfs_get_key(controller, path1, path2);",
          "2640:  if (!k) {",
          "2641:   ret = -EINVAL;",
          "2642:   goto out;",
          "2643:  }",
          "2651:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT)) {",
          "2652:   ret = -EPERM;",
          "2653:   goto out;",
          "2654:  }",
          "2656:  if (!cgfs_chmod_file(controller, cgroup, mode)) {",
          "2657:   ret = -EINVAL;",
          "2658:   goto out;",
          "2659:  }",
          "2661:  ret = 0;",
          "2662: out:",
          "2663:  free_key(k);",
          "2664:  free(cgdir);",
          "2665:  return ret;",
          "2666: }",
          "2668: int cg_mkdir(const char *path, mode_t mode)",
          "2669: {",
          "2670:  struct fuse_context *fc = fuse_get_context();",
          "2671:  char *last = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
          "2672:  const char *cgroup;",
          "2673:  int ret;",
          "2675:  if (!fc)",
          "2676:   return -EIO;",
          "2679:  controller = pick_controller_from_path(fc, path);",
          "2680:  if (!controller)",
          "2681:   return -EINVAL;",
          "2683:  cgroup = find_cgroup_in_path(path);",
          "2684:  if (!cgroup)",
          "2685:   return -EINVAL;",
          "2687:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "2688:  if (!last)",
          "2689:   path1 = \"/\";",
          "2690:  else",
          "2691:   path1 = cgdir;",
          "2693:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2694:  if (initpid <= 0)",
          "2695:   initpid = fc->pid;",
          "2696:  if (!caller_is_in_ancestor(initpid, controller, path1, &next)) {",
          "2697:   if (!next)",
          "2698:    ret = -EINVAL;",
          "2699:   else if (last && strcmp(next, last) == 0)",
          "2700:    ret = -EEXIST;",
          "2701:   else",
          "2702:    ret = -ENOENT;",
          "2703:   goto out;",
          "2704:  }",
          "2706:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {",
          "2707:   ret = -EACCES;",
          "2708:   goto out;",
          "2709:  }",
          "2710:  if (!caller_is_in_ancestor(initpid, controller, path1, NULL)) {",
          "2711:   ret = -EACCES;",
          "2712:   goto out;",
          "2713:  }",
          "2715:  ret = cgfs_create(controller, cgroup, fc->uid, fc->gid);",
          "2717: out:",
          "2718:  free(cgdir);",
          "2719:  free(next);",
          "2720:  return ret;",
          "2721: }",
          "2723: int cg_rmdir(const char *path)",
          "2724: {",
          "2725:  struct fuse_context *fc = fuse_get_context();",
          "2726:  char *last = NULL, *cgdir = NULL, *controller, *next = NULL;",
          "2727:  const char *cgroup;",
          "2728:  int ret;",
          "2730:  if (!fc)",
          "2731:   return -EIO;",
          "2733:  controller = pick_controller_from_path(fc, path);",
          "2734:  if (!controller)",
          "2735:   return -EINVAL;",
          "2737:  cgroup = find_cgroup_in_path(path);",
          "2738:  if (!cgroup)",
          "2739:   return -EINVAL;",
          "2741:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "2742:  if (!last) {",
          "2743:   ret = -EINVAL;",
          "2744:   goto out;",
          "2745:  }",
          "2747:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2748:  if (initpid <= 0)",
          "2749:   initpid = fc->pid;",
          "2750:  if (!caller_is_in_ancestor(initpid, controller, cgroup, &next)) {",
          "2751:   if (!last || strcmp(next, last) == 0)",
          "2752:    ret = -EBUSY;",
          "2753:   else",
          "2754:    ret = -ENOENT;",
          "2755:   goto out;",
          "2756:  }",
          "2758:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {",
          "2759:   ret = -EACCES;",
          "2760:   goto out;",
          "2761:  }",
          "2762:  if (!caller_is_in_ancestor(initpid, controller, cgroup, NULL)) {",
          "2763:   ret = -EACCES;",
          "2764:   goto out;",
          "2765:  }",
          "2767:  if (!cgfs_remove(controller, cgroup)) {",
          "2768:   ret = -EINVAL;",
          "2769:   goto out;",
          "2770:  }",
          "2772:  ret = 0;",
          "2774: out:",
          "2775:  free(cgdir);",
          "2776:  free(next);",
          "2777:  return ret;",
          "2778: }",
          "2780: static bool startswith(const char *line, const char *pref)",
          "2781: {",
          "2782:  if (strncmp(line, pref, strlen(pref)) == 0)",
          "2783:   return true;",
          "2784:  return false;",
          "2785: }",
          "2787: static void get_mem_cached(char *memstat, unsigned long *v)",
          "2788: {",
          "2789:  char *eol;",
          "2792:  while (*memstat) {",
          "2793:   if (startswith(memstat, \"total_cache\")) {",
          "2794:    sscanf(memstat + 11, \"%lu\", v);",
          "2796:    return;",
          "2797:   }",
          "2798:   eol = strchr(memstat, '\\n');",
          "2799:   if (!eol)",
          "2800:    return;",
          "2801:   memstat = eol+1;",
          "2802:  }",
          "2803: }",
          "2805: static void get_blkio_io_value(char *str, unsigned major, unsigned minor, char *iotype, unsigned long *v)",
          "2806: {",
          "2807:  char *eol;",
          "2808:  char key[32];",
          "2810:  memset(key, 0, 32);",
          "2811:  snprintf(key, 32, \"%u:%u %s\", major, minor, iotype);",
          "2813:  size_t len = strlen(key);",
          "2816:  while (*str) {",
          "2817:   if (startswith(str, key)) {",
          "2818:    sscanf(str + len, \"%lu\", v);",
          "2819:    return;",
          "2820:   }",
          "2821:   eol = strchr(str, '\\n');",
          "2822:   if (!eol)",
          "2823:    return;",
          "2824:   str = eol+1;",
          "2825:  }",
          "2826: }",
          "2828: static int read_file(const char *path, char *buf, size_t size,",
          "2829:        struct file_info *d)",
          "2830: {",
          "2831:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2832:  char *line = NULL;",
          "2833:  char *cache = d->buf;",
          "2834:  size_t cache_size = d->buflen;",
          "2835:  FILE *f = fopen(path, \"r\");",
          "2836:  if (!f)",
          "2837:   return 0;",
          "2839:  while (getline(&line, &linelen, f) != -1) {",
          "2840:   size_t l = snprintf(cache, cache_size, \"%s\", line);",
          "2841:   if (l < 0) {",
          "2842:    perror(\"Error writing to cache\");",
          "2843:    rv = 0;",
          "2844:    goto err;",
          "2845:   }",
          "2846:   if (l >= cache_size) {",
          "2847:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2848:    rv = 0;",
          "2849:    goto err;",
          "2850:   }",
          "2851:   cache += l;",
          "2852:   cache_size -= l;",
          "2853:   total_len += l;",
          "2854:  }",
          "2856:  d->size = total_len;",
          "2857:  if (total_len > size ) total_len = size;",
          "2860:  memcpy(buf, d->buf, total_len);",
          "2861:  rv = total_len;",
          "2862:   err:",
          "2863:  fclose(f);",
          "2864:  free(line);",
          "2865:  return rv;",
          "2866: }",
          "2872: static unsigned long get_memlimit(const char *cgroup)",
          "2873: {",
          "2874:  char *memlimit_str = NULL;",
          "2875:  unsigned long memlimit = -1;",
          "2877:  if (cgfs_get_value(\"memory\", cgroup, \"memory.limit_in_bytes\", &memlimit_str))",
          "2878:   memlimit = strtoul(memlimit_str, NULL, 10);",
          "2880:  free(memlimit_str);",
          "2882:  return memlimit;",
          "2883: }",
          "2885: static unsigned long get_min_memlimit(const char *cgroup)",
          "2886: {",
          "2887:  char *copy = strdupa(cgroup);",
          "2888:  unsigned long memlimit = 0, retlimit;",
          "2890:  retlimit = get_memlimit(copy);",
          "2892:  while (strcmp(copy, \"/\") != 0) {",
          "2893:   copy = dirname(copy);",
          "2894:   memlimit = get_memlimit(copy);",
          "2895:   if (memlimit != -1 && memlimit < retlimit)",
          "2896:    retlimit = memlimit;",
          "2897:  };",
          "2899:  return retlimit;",
          "2900: }",
          "2902: static int proc_meminfo_read(char *buf, size_t size, off_t offset,",
          "2903:   struct fuse_file_info *fi)",
          "2904: {",
          "2905:  struct fuse_context *fc = fuse_get_context();",
          "2906:  struct file_info *d = (struct file_info *)fi->fh;",
          "2907:  char *cg;",
          "2908:  char *memusage_str = NULL, *memstat_str = NULL,",
          "2911:  unsigned long memlimit = 0, memusage = 0, memswlimit = 0, memswusage = 0,",
          "2912:   cached = 0, hosttotal = 0;",
          "2913:  char *line = NULL;",
          "2914:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2915:  char *cache = d->buf;",
          "2916:  size_t cache_size = d->buflen;",
          "2917:  FILE *f = NULL;",
          "2919:  if (offset){",
          "2920:   if (offset > d->size)",
          "2921:    return -EINVAL;",
          "2922:   if (!d->cached)",
          "2923:    return 0;",
          "2924:   int left = d->size - offset;",
          "2925:   total_len = left > size ? size: left;",
          "2926:   memcpy(buf, cache + offset, total_len);",
          "2927:   return total_len;",
          "2928:  }",
          "2930:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2931:  if (initpid <= 0)",
          "2932:   initpid = fc->pid;",
          "2933:  cg = get_pid_cgroup(initpid, \"memory\");",
          "2934:  if (!cg)",
          "2935:   return read_file(\"/proc/meminfo\", buf, size, d);",
          "2937:  memlimit = get_min_memlimit(cg);",
          "2938:  if (!cgfs_get_value(\"memory\", cg, \"memory.usage_in_bytes\", &memusage_str))",
          "2939:   goto err;",
          "2940:  if (!cgfs_get_value(\"memory\", cg, \"memory.stat\", &memstat_str))",
          "2941:   goto err;",
          "2945:  if(cgfs_get_value(\"memory\", cg, \"memory.memsw.limit_in_bytes\", &memswlimit_str) &&",
          "2946:   cgfs_get_value(\"memory\", cg, \"memory.memsw.usage_in_bytes\", &memswusage_str))",
          "2947:  {",
          "2949:   if (!cgfs_get_value(\"memory\", \"/\", \"memory.memsw.limit_in_bytes\", &memswlimit_default_str))",
          "2950:    goto err;",
          "2951:   if (!cgfs_get_value(\"memory\", \"/\", \"memory.memsw.usage_in_bytes\", &memswusage_default_str))",
          "2952:    goto err;",
          "2954:   memswlimit = strtoul(memswlimit_str, NULL, 10);",
          "2955:   memswusage = strtoul(memswusage_str, NULL, 10);",
          "2957:   if (!strcmp(memswlimit_str, memswlimit_default_str))",
          "2958:    memswlimit = 0;",
          "2959:   if (!strcmp(memswusage_str, memswusage_default_str))",
          "2960:    memswusage = 0;",
          "2962:   memswlimit = memswlimit / 1024;",
          "2963:   memswusage = memswusage / 1024;",
          "2964:  }",
          "2966:  memusage = strtoul(memusage_str, NULL, 10);",
          "2967:  memlimit /= 1024;",
          "2968:  memusage /= 1024;",
          "2970:  get_mem_cached(memstat_str, &cached);",
          "2972:  f = fopen(\"/proc/meminfo\", \"r\");",
          "2973:  if (!f)",
          "2974:   goto err;",
          "2976:  while (getline(&line, &linelen, f) != -1) {",
          "2977:   size_t l;",
          "2978:   char *printme, lbuf[100];",
          "2980:   memset(lbuf, 0, 100);",
          "2981:   if (startswith(line, \"MemTotal:\")) {",
          "2982:    sscanf(line+14, \"%lu\", &hosttotal);",
          "2983:    if (hosttotal < memlimit)",
          "2984:     memlimit = hosttotal;",
          "2985:    snprintf(lbuf, 100, \"MemTotal:       %8lu kB\\n\", memlimit);",
          "2986:    printme = lbuf;",
          "2987:   } else if (startswith(line, \"MemFree:\")) {",
          "2988:    snprintf(lbuf, 100, \"MemFree:        %8lu kB\\n\", memlimit - memusage);",
          "2989:    printme = lbuf;",
          "2990:   } else if (startswith(line, \"MemAvailable:\")) {",
          "2991:    snprintf(lbuf, 100, \"MemAvailable:   %8lu kB\\n\", memlimit - memusage);",
          "2992:    printme = lbuf;",
          "2993:   } else if (startswith(line, \"SwapTotal:\") && memswlimit > 0) {",
          "2994:    snprintf(lbuf, 100, \"SwapTotal:      %8lu kB\\n\", memswlimit - memlimit);",
          "2995:    printme = lbuf;",
          "2996:   } else if (startswith(line, \"SwapFree:\") && memswlimit > 0 && memswusage > 0) {",
          "2997:    snprintf(lbuf, 100, \"SwapFree:       %8lu kB\\n\",",
          "2998:     (memswlimit - memlimit) - (memswusage - memusage));",
          "2999:    printme = lbuf;",
          "3000:   } else if (startswith(line, \"Buffers:\")) {",
          "3001:    snprintf(lbuf, 100, \"Buffers:        %8lu kB\\n\", 0UL);",
          "3002:    printme = lbuf;",
          "3003:   } else if (startswith(line, \"Cached:\")) {",
          "3004:    snprintf(lbuf, 100, \"Cached:         %8lu kB\\n\", cached);",
          "3005:    printme = lbuf;",
          "3006:   } else if (startswith(line, \"SwapCached:\")) {",
          "3007:    snprintf(lbuf, 100, \"SwapCached:     %8lu kB\\n\", 0UL);",
          "3008:    printme = lbuf;",
          "3009:   } else",
          "3010:    printme = line;",
          "3012:   l = snprintf(cache, cache_size, \"%s\", printme);",
          "3013:   if (l < 0) {",
          "3014:    perror(\"Error writing to cache\");",
          "3015:    rv = 0;",
          "3016:    goto err;",
          "3018:   }",
          "3019:   if (l >= cache_size) {",
          "3020:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "3021:    rv = 0;",
          "3022:    goto err;",
          "3023:   }",
          "3025:   cache += l;",
          "3026:   cache_size -= l;",
          "3027:   total_len += l;",
          "3028:  }",
          "3030:  d->cached = 1;",
          "3031:  d->size = total_len;",
          "3032:  if (total_len > size ) total_len = size;",
          "3033:  memcpy(buf, d->buf, total_len);",
          "3035:  rv = total_len;",
          "3036: err:",
          "3037:  if (f)",
          "3038:   fclose(f);",
          "3039:  free(line);",
          "3040:  free(cg);",
          "3041:  free(memusage_str);",
          "3042:  free(memswlimit_str);",
          "3043:  free(memswusage_str);",
          "3044:  free(memstat_str);",
          "3045:  free(memswlimit_default_str);",
          "3046:  free(memswusage_default_str);",
          "3047:  return rv;",
          "3048: }",
          "3054: static char *get_cpuset(const char *cg)",
          "3055: {",
          "3056:  char *answer;",
          "3058:  if (!cgfs_get_value(\"cpuset\", cg, \"cpuset.cpus\", &answer))",
          "3059:   return NULL;",
          "3060:  return answer;",
          "3061: }",
          "3063: bool cpu_in_cpuset(int cpu, const char *cpuset);",
          "3065: static bool cpuline_in_cpuset(const char *line, const char *cpuset)",
          "3066: {",
          "3067:  int cpu;",
          "3069:  if (sscanf(line, \"processor       : %d\", &cpu) != 1)",
          "3070:   return false;",
          "3071:  return cpu_in_cpuset(cpu, cpuset);",
          "3072: }",
          "3077: static bool is_processor_line(const char *line)",
          "3078: {",
          "3079:  int cpu;",
          "3081:  if (sscanf(line, \"processor       : %d\", &cpu) == 1)",
          "3082:   return true;",
          "3083:  return false;",
          "3084: }",
          "3086: static int proc_cpuinfo_read(char *buf, size_t size, off_t offset,",
          "3087:   struct fuse_file_info *fi)",
          "3088: {",
          "3089:  struct fuse_context *fc = fuse_get_context();",
          "3090:  struct file_info *d = (struct file_info *)fi->fh;",
          "3091:  char *cg;",
          "3092:  char *cpuset = NULL;",
          "3093:  char *line = NULL;",
          "3094:  size_t linelen = 0, total_len = 0, rv = 0;",
          "3095:  bool am_printing = false;",
          "3096:  int curcpu = -1;",
          "3097:  char *cache = d->buf;",
          "3098:  size_t cache_size = d->buflen;",
          "3099:  FILE *f = NULL;",
          "3101:  if (offset){",
          "3102:   if (offset > d->size)",
          "3103:    return -EINVAL;",
          "3104:   if (!d->cached)",
          "3105:    return 0;",
          "3106:   int left = d->size - offset;",
          "3107:   total_len = left > size ? size: left;",
          "3108:   memcpy(buf, cache + offset, total_len);",
          "3109:   return total_len;",
          "3110:  }",
          "3112:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "3113:  if (initpid <= 0)",
          "3114:   initpid = fc->pid;",
          "3115:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "3116:  if (!cg)",
          "3117:   return read_file(\"proc/cpuinfo\", buf, size, d);",
          "3119:  cpuset = get_cpuset(cg);",
          "3120:  if (!cpuset)",
          "3121:   goto err;",
          "3123:  f = fopen(\"/proc/cpuinfo\", \"r\");",
          "3124:  if (!f)",
          "3125:   goto err;",
          "3127:  while (getline(&line, &linelen, f) != -1) {",
          "3128:   size_t l;",
          "3129:   if (is_processor_line(line)) {",
          "3130:    am_printing = cpuline_in_cpuset(line, cpuset);",
          "3131:    if (am_printing) {",
          "3132:     curcpu ++;",
          "3133:     l = snprintf(cache, cache_size, \"processor : %d\\n\", curcpu);",
          "3134:     if (l < 0) {",
          "3135:      perror(\"Error writing to cache\");",
          "3136:      rv = 0;",
          "3137:      goto err;",
          "3138:     }",
          "3139:     if (l >= cache_size) {",
          "3140:      fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "3141:      rv = 0;",
          "3142:      goto err;",
          "3143:     }",
          "3144:     cache += l;",
          "3145:     cache_size -= l;",
          "3146:     total_len += l;",
          "3147:    }",
          "3148:    continue;",
          "3149:   }",
          "3150:   if (am_printing) {",
          "3151:    l = snprintf(cache, cache_size, \"%s\", line);",
          "3152:    if (l < 0) {",
          "3153:     perror(\"Error writing to cache\");",
          "3154:     rv = 0;",
          "3155:     goto err;",
          "3156:    }",
          "3157:    if (l >= cache_size) {",
          "3158:     fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "3159:     rv = 0;",
          "3160:     goto err;",
          "3161:    }",
          "3162:    cache += l;",
          "3163:    cache_size -= l;",
          "3164:    total_len += l;",
          "3165:   }",
          "3166:  }",
          "3168:  d->cached = 1;",
          "3169:  d->size = total_len;",
          "3170:  if (total_len > size ) total_len = size;",
          "3173:  memcpy(buf, d->buf, total_len);",
          "3174:  rv = total_len;",
          "3175: err:",
          "3176:  if (f)",
          "3177:   fclose(f);",
          "3178:  free(line);",
          "3179:  free(cpuset);",
          "3180:  free(cg);",
          "3181:  return rv;",
          "3182: }",
          "3184: static int proc_stat_read(char *buf, size_t size, off_t offset,",
          "3185:   struct fuse_file_info *fi)",
          "3186: {",
          "3187:  struct fuse_context *fc = fuse_get_context();",
          "3188:  struct file_info *d = (struct file_info *)fi->fh;",
          "3189:  char *cg;",
          "3190:  char *cpuset = NULL;",
          "3191:  char *line = NULL;",
          "3192:  size_t linelen = 0, total_len = 0, rv = 0;",
          "3194:  unsigned long user = 0, nice = 0, system = 0, idle = 0, iowait = 0, irq = 0, softirq = 0, steal = 0, guest = 0;",
          "3195:  unsigned long user_sum = 0, nice_sum = 0, system_sum = 0, idle_sum = 0, iowait_sum = 0,",
          "3196:      irq_sum = 0, softirq_sum = 0, steal_sum = 0, guest_sum = 0;",
          "3197: #define CPUALL_MAX_SIZE BUF_RESERVE_SIZE",
          "3198:  char cpuall[CPUALL_MAX_SIZE];",
          "3200:  char *cache = d->buf + CPUALL_MAX_SIZE;",
          "3201:  size_t cache_size = d->buflen - CPUALL_MAX_SIZE;",
          "3202:  FILE *f = NULL;",
          "3204:  if (offset){",
          "3205:   if (offset > d->size)",
          "3206:    return -EINVAL;",
          "3207:   if (!d->cached)",
          "3208:    return 0;",
          "3209:   int left = d->size - offset;",
          "3210:   total_len = left > size ? size: left;",
          "3211:   memcpy(buf, d->buf + offset, total_len);",
          "3212:   return total_len;",
          "3213:  }",
          "3215:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "3216:  if (initpid <= 0)",
          "3217:   initpid = fc->pid;",
          "3218:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "3219:  if (!cg)",
          "3220:   return read_file(\"/proc/stat\", buf, size, d);",
          "3222:  cpuset = get_cpuset(cg);",
          "3223:  if (!cpuset)",
          "3224:   goto err;",
          "3226:  f = fopen(\"/proc/stat\", \"r\");",
          "3227:  if (!f)",
          "3228:   goto err;",
          "3231:  if (getline(&line, &linelen, f) < 0) {",
          "3232:   fprintf(stderr, \"proc_stat_read read first line failed\\n\");",
          "3233:   goto err;",
          "3234:  }",
          "3236:  while (getline(&line, &linelen, f) != -1) {",
          "3237:   size_t l;",
          "3238:   int cpu;",
          "3240:   char *c;",
          "3242:   if (sscanf(line, \"cpu%9[^ ]\", cpu_char) != 1) {",
          "3244:    l = snprintf(cache, cache_size, \"%s\", line);",
          "3245:    if (l < 0) {",
          "3246:     perror(\"Error writing to cache\");",
          "3247:     rv = 0;",
          "3248:     goto err;",
          "3249:    }",
          "3250:    if (l >= cache_size) {",
          "3251:     fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "3252:     rv = 0;",
          "3253:     goto err;",
          "3254:    }",
          "3255:    cache += l;",
          "3256:    cache_size -= l;",
          "3257:    total_len += l;",
          "3258:    continue;",
          "3259:   }",
          "3261:   if (sscanf(cpu_char, \"%d\", &cpu) != 1)",
          "3262:    continue;",
          "3263:   if (!cpu_in_cpuset(cpu, cpuset))",
          "3264:    continue;",
          "3265:   curcpu ++;",
          "3267:   c = strchr(line, ' ');",
          "3268:   if (!c)",
          "3269:    continue;",
          "3270:   l = snprintf(cache, cache_size, \"cpu%d%s\", curcpu, c);",
          "3271:   if (l < 0) {",
          "3272:    perror(\"Error writing to cache\");",
          "3273:    rv = 0;",
          "3274:    goto err;",
          "3276:   }",
          "3277:   if (l >= cache_size) {",
          "3278:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "3279:    rv = 0;",
          "3280:    goto err;",
          "3281:   }",
          "3283:   cache += l;",
          "3284:   cache_size -= l;",
          "3285:   total_len += l;",
          "3287:   if (sscanf(line, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu\", &user, &nice, &system, &idle, &iowait, &irq,",
          "3288:    &softirq, &steal, &guest) != 9)",
          "3289:    continue;",
          "3290:   user_sum += user;",
          "3291:   nice_sum += nice;",
          "3292:   system_sum += system;",
          "3293:   idle_sum += idle;",
          "3294:   iowait_sum += iowait;",
          "3295:   irq_sum += irq;",
          "3296:   softirq_sum += softirq;",
          "3297:   steal_sum += steal;",
          "3298:   guest_sum += guest;",
          "3299:  }",
          "3301:  cache = d->buf;",
          "3303:  int cpuall_len = snprintf(cpuall, CPUALL_MAX_SIZE, \"%s %lu %lu %lu %lu %lu %lu %lu %lu %lu\\n\",",
          "3304:   \"cpu \", user_sum, nice_sum, system_sum, idle_sum, iowait_sum, irq_sum, softirq_sum, steal_sum, guest_sum);",
          "3305:  if (cpuall_len > 0 && cpuall_len < CPUALL_MAX_SIZE){",
          "3306:   memcpy(cache, cpuall, cpuall_len);",
          "3307:   cache += cpuall_len;",
          "3308:  } else{",
          "3310:   fprintf(stderr, \"proc_stat_read copy cpuall failed, cpuall_len=%d\\n\", cpuall_len);",
          "3311:   cpuall_len = 0;",
          "3312:  }",
          "3314:  memmove(cache, d->buf + CPUALL_MAX_SIZE, total_len);",
          "3315:  total_len += cpuall_len;",
          "3316:  d->cached = 1;",
          "3317:  d->size = total_len;",
          "3318:  if (total_len > size ) total_len = size;",
          "3320:  memcpy(buf, d->buf, total_len);",
          "3321:  rv = total_len;",
          "3323: err:",
          "3324:  if (f)",
          "3325:   fclose(f);",
          "3326:  free(line);",
          "3327:  free(cpuset);",
          "3328:  free(cg);",
          "3329:  return rv;",
          "3330: }",
          "3332: static long int getreaperage(pid_t pid)",
          "3333: {",
          "3334:  char fnam[100];",
          "3335:  struct stat sb;",
          "3336:  int ret;",
          "3337:  pid_t qpid;",
          "3339:  qpid = lookup_initpid_in_store(pid);",
          "3340:  if (qpid <= 0)",
          "3341:   return 0;",
          "3343:  ret = snprintf(fnam, 100, \"/proc/%d\", qpid);",
          "3344:  if (ret < 0 || ret >= 100)",
          "3345:   return 0;",
          "3347:  if (lstat(fnam, &sb) < 0)",
          "3348:   return 0;",
          "3350:  return time(NULL) - sb.st_ctime;",
          "3351: }",
          "3353: static unsigned long get_reaper_busy(pid_t task)",
          "3354: {",
          "3355:  pid_t initpid = lookup_initpid_in_store(task);",
          "3356:  char *cgroup = NULL, *usage_str = NULL;",
          "3357:  unsigned long usage = 0;",
          "3359:  if (initpid <= 0)",
          "3360:   return 0;",
          "3362:  cgroup = get_pid_cgroup(initpid, \"cpuacct\");",
          "3363:  if (!cgroup)",
          "3364:   goto out;",
          "3365:  if (!cgfs_get_value(\"cpuacct\", cgroup, \"cpuacct.usage\", &usage_str))",
          "3366:   goto out;",
          "3367:  usage = strtoul(usage_str, NULL, 10);",
          "3368:  usage /= 1000000000;",
          "3370: out:",
          "3371:  free(cgroup);",
          "3372:  free(usage_str);",
          "3373:  return usage;",
          "3374: }",
          "3376: #if RELOADTEST",
          "3377: void iwashere(void)",
          "3378: {",
          "3379:  char *name, *cwd = get_current_dir_name();",
          "3380:  size_t len;",
          "3381:  int fd;",
          "3383:  if (!cwd)",
          "3384:   exit(1);",
          "3385:  len = strlen(cwd) + strlen(\"/iwashere\") + 1;",
          "3386:  name = alloca(len);",
          "3387:  snprintf(name, len, \"%s/iwashere\", cwd);",
          "3388:  free(cwd);",
          "3389:  fd = creat(name, 0755);",
          "3390:  if (fd >= 0)",
          "3391:   close(fd);",
          "3392: }",
          "3393: #endif",
          "3400: static int proc_uptime_read(char *buf, size_t size, off_t offset,",
          "3401:   struct fuse_file_info *fi)",
          "3402: {",
          "3403:  struct fuse_context *fc = fuse_get_context();",
          "3404:  struct file_info *d = (struct file_info *)fi->fh;",
          "3405:  long int reaperage = getreaperage(fc->pid);",
          "3406:  unsigned long int busytime = get_reaper_busy(fc->pid), idletime;",
          "3407:  char *cache = d->buf;",
          "3408:  size_t total_len = 0;",
          "3410: #if RELOADTEST",
          "3411:  iwashere();",
          "3412: #endif",
          "3414:  if (offset){",
          "3415:   if (offset > d->size)",
          "3416:    return -EINVAL;",
          "3417:   if (!d->cached)",
          "3418:    return 0;",
          "3419:   int left = d->size - offset;",
          "3420:   total_len = left > size ? size: left;",
          "3421:   memcpy(buf, cache + offset, total_len);",
          "3422:   return total_len;",
          "3423:  }",
          "3425:  idletime = reaperage - busytime;",
          "3426:  if (idletime > reaperage)",
          "3427:   idletime = reaperage;",
          "3429:  total_len = snprintf(d->buf, d->size, \"%ld.0 %lu.0\\n\", reaperage, idletime);",
          "3430:  if (total_len < 0){",
          "3431:   perror(\"Error writing to cache\");",
          "3432:   return 0;",
          "3433:  }",
          "3435:  d->size = (int)total_len;",
          "3436:  d->cached = 1;",
          "3438:  if (total_len > size) total_len = size;",
          "3440:  memcpy(buf, d->buf, total_len);",
          "3441:  return total_len;",
          "3442: }",
          "3444: static int proc_diskstats_read(char *buf, size_t size, off_t offset,",
          "3445:   struct fuse_file_info *fi)",
          "3446: {",
          "3447:  char dev_name[72];",
          "3448:  struct fuse_context *fc = fuse_get_context();",
          "3449:  struct file_info *d = (struct file_info *)fi->fh;",
          "3450:  char *cg;",
          "3451:  char *io_serviced_str = NULL, *io_merged_str = NULL, *io_service_bytes_str = NULL,",
          "3453:  unsigned long read = 0, write = 0;",
          "3454:  unsigned long read_merged = 0, write_merged = 0;",
          "3455:  unsigned long read_sectors = 0, write_sectors = 0;",
          "3456:  unsigned long read_ticks = 0, write_ticks = 0;",
          "3457:  unsigned long ios_pgr = 0, tot_ticks = 0, rq_ticks = 0;",
          "3458:  unsigned long rd_svctm = 0, wr_svctm = 0, rd_wait = 0, wr_wait = 0;",
          "3459:  char *cache = d->buf;",
          "3460:  size_t cache_size = d->buflen;",
          "3461:  char *line = NULL;",
          "3462:  size_t linelen = 0, total_len = 0, rv = 0;",
          "3463:  unsigned int major = 0, minor = 0;",
          "3464:  int i = 0;",
          "3465:  FILE *f = NULL;",
          "3467:  if (offset){",
          "3468:   if (offset > d->size)",
          "3469:    return -EINVAL;",
          "3470:   if (!d->cached)",
          "3471:    return 0;",
          "3472:   int left = d->size - offset;",
          "3473:   total_len = left > size ? size: left;",
          "3474:   memcpy(buf, cache + offset, total_len);",
          "3475:   return total_len;",
          "3476:  }",
          "3478:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "3479:  if (initpid <= 0)",
          "3480:   initpid = fc->pid;",
          "3481:  cg = get_pid_cgroup(initpid, \"blkio\");",
          "3482:  if (!cg)",
          "3483:   return read_file(\"/proc/diskstats\", buf, size, d);",
          "3485:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_serviced\", &io_serviced_str))",
          "3486:   goto err;",
          "3487:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_merged\", &io_merged_str))",
          "3488:   goto err;",
          "3489:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_service_bytes\", &io_service_bytes_str))",
          "3490:   goto err;",
          "3491:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_wait_time\", &io_wait_time_str))",
          "3492:   goto err;",
          "3493:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_service_time\", &io_service_time_str))",
          "3494:   goto err;",
          "3497:  f = fopen(\"/proc/diskstats\", \"r\");",
          "3498:  if (!f)",
          "3499:   goto err;",
          "3501:  while (getline(&line, &linelen, f) != -1) {",
          "3502:   size_t l;",
          "3503:   char *printme, lbuf[256];",
          "3505:   i = sscanf(line, \"%u %u %71s\", &major, &minor, dev_name);",
          "3506:   if(i == 3){",
          "3507:    get_blkio_io_value(io_serviced_str, major, minor, \"Read\", &read);",
          "3508:    get_blkio_io_value(io_serviced_str, major, minor, \"Write\", &write);",
          "3509:    get_blkio_io_value(io_merged_str, major, minor, \"Read\", &read_merged);",
          "3510:    get_blkio_io_value(io_merged_str, major, minor, \"Write\", &write_merged);",
          "3511:    get_blkio_io_value(io_service_bytes_str, major, minor, \"Read\", &read_sectors);",
          "3512:    read_sectors = read_sectors/512;",
          "3513:    get_blkio_io_value(io_service_bytes_str, major, minor, \"Write\", &write_sectors);",
          "3514:    write_sectors = write_sectors/512;",
          "3516:    get_blkio_io_value(io_service_time_str, major, minor, \"Read\", &rd_svctm);",
          "3517:    rd_svctm = rd_svctm/1000000;",
          "3518:    get_blkio_io_value(io_wait_time_str, major, minor, \"Read\", &rd_wait);",
          "3519:    rd_wait = rd_wait/1000000;",
          "3520:    read_ticks = rd_svctm + rd_wait;",
          "3522:    get_blkio_io_value(io_service_time_str, major, minor, \"Write\", &wr_svctm);",
          "3523:    wr_svctm =  wr_svctm/1000000;",
          "3524:    get_blkio_io_value(io_wait_time_str, major, minor, \"Write\", &wr_wait);",
          "3525:    wr_wait =  wr_wait/1000000;",
          "3526:    write_ticks = wr_svctm + wr_wait;",
          "3528:    get_blkio_io_value(io_service_time_str, major, minor, \"Total\", &tot_ticks);",
          "3529:    tot_ticks =  tot_ticks/1000000;",
          "3530:   }else{",
          "3531:    continue;",
          "3532:   }",
          "3534:   memset(lbuf, 0, 256);",
          "3535:   if (read || write || read_merged || write_merged || read_sectors || write_sectors || read_ticks || write_ticks) {",
          "3536:    snprintf(lbuf, 256, \"%u       %u %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\\n\",",
          "3537:     major, minor, dev_name, read, read_merged, read_sectors, read_ticks,",
          "3538:     write, write_merged, write_sectors, write_ticks, ios_pgr, tot_ticks, rq_ticks);",
          "3539:    printme = lbuf;",
          "3540:   } else",
          "3541:    continue;",
          "3543:   l = snprintf(cache, cache_size, \"%s\", printme);",
          "3544:   if (l < 0) {",
          "3545:    perror(\"Error writing to fuse buf\");",
          "3546:    rv = 0;",
          "3547:    goto err;",
          "3548:   }",
          "3549:   if (l >= cache_size) {",
          "3550:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "3551:    rv = 0;",
          "3552:    goto err;",
          "3553:   }",
          "3554:   cache += l;",
          "3555:   cache_size -= l;",
          "3556:   total_len += l;",
          "3557:  }",
          "3559:  d->cached = 1;",
          "3560:  d->size = total_len;",
          "3561:  if (total_len > size ) total_len = size;",
          "3562:  memcpy(buf, d->buf, total_len);",
          "3564:  rv = total_len;",
          "3565: err:",
          "3566:  free(cg);",
          "3567:  if (f)",
          "3568:   fclose(f);",
          "3569:  free(line);",
          "3570:  free(io_serviced_str);",
          "3571:  free(io_merged_str);",
          "3572:  free(io_service_bytes_str);",
          "3573:  free(io_wait_time_str);",
          "3574:  free(io_service_time_str);",
          "3575:  return rv;",
          "3576: }",
          "3578: static off_t get_procfile_size(const char *which)",
          "3579: {",
          "3580:  FILE *f = fopen(which, \"r\");",
          "3581:  char *line = NULL;",
          "3582:  size_t len = 0;",
          "3583:  ssize_t sz, answer = 0;",
          "3584:  if (!f)",
          "3585:   return 0;",
          "3587:  while ((sz = getline(&line, &len, f)) != -1)",
          "3588:   answer += sz;",
          "3589:  fclose (f);",
          "3590:  free(line);",
          "3592:  return answer;",
          "3593: }",
          "3595: int proc_getattr(const char *path, struct stat *sb)",
          "3596: {",
          "3597:  struct timespec now;",
          "3599:  memset(sb, 0, sizeof(struct stat));",
          "3600:  if (clock_gettime(CLOCK_REALTIME, &now) < 0)",
          "3601:   return -EINVAL;",
          "3602:  sb->st_uid = sb->st_gid = 0;",
          "3603:  sb->st_atim = sb->st_mtim = sb->st_ctim = now;",
          "3604:  if (strcmp(path, \"/proc\") == 0) {",
          "3605:   sb->st_mode = S_IFDIR | 00555;",
          "3606:   sb->st_nlink = 2;",
          "3607:   return 0;",
          "3608:  }",
          "3609:  if (strcmp(path, \"/proc/meminfo\") == 0 ||",
          "3610:    strcmp(path, \"/proc/cpuinfo\") == 0 ||",
          "3611:    strcmp(path, \"/proc/uptime\") == 0 ||",
          "3612:    strcmp(path, \"/proc/stat\") == 0 ||",
          "3613:    strcmp(path, \"/proc/diskstats\") == 0) {",
          "3614:   sb->st_size = 0;",
          "3615:   sb->st_mode = S_IFREG | 00444;",
          "3616:   sb->st_nlink = 1;",
          "3617:   return 0;",
          "3618:  }",
          "3620:  return -ENOENT;",
          "3621: }",
          "3623: int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "3624:   struct fuse_file_info *fi)",
          "3625: {",
          "3626:  if (filler(buf, \"cpuinfo\", NULL, 0) != 0 ||",
          "3627:     filler(buf, \"meminfo\", NULL, 0) != 0 ||",
          "3628:     filler(buf, \"stat\", NULL, 0) != 0 ||",
          "3629:     filler(buf, \"uptime\", NULL, 0) != 0 ||",
          "3630:     filler(buf, \"diskstats\", NULL, 0) != 0)",
          "3631:   return -EINVAL;",
          "3632:  return 0;",
          "3633: }",
          "3635: int proc_open(const char *path, struct fuse_file_info *fi)",
          "3636: {",
          "3637:  int type = -1;",
          "3638:  struct file_info *info;",
          "3640:  if (strcmp(path, \"/proc/meminfo\") == 0)",
          "3641:   type = LXC_TYPE_PROC_MEMINFO;",
          "3642:  else if (strcmp(path, \"/proc/cpuinfo\") == 0)",
          "3643:   type = LXC_TYPE_PROC_CPUINFO;",
          "3644:  else if (strcmp(path, \"/proc/uptime\") == 0)",
          "3645:   type = LXC_TYPE_PROC_UPTIME;",
          "3646:  else if (strcmp(path, \"/proc/stat\") == 0)",
          "3647:   type = LXC_TYPE_PROC_STAT;",
          "3648:  else if (strcmp(path, \"/proc/diskstats\") == 0)",
          "3649:   type = LXC_TYPE_PROC_DISKSTATS;",
          "3650:  if (type == -1)",
          "3651:   return -ENOENT;",
          "3653:  info = malloc(sizeof(*info));",
          "3654:  if (!info)",
          "3655:   return -ENOMEM;",
          "3657:  memset(info, 0, sizeof(*info));",
          "3658:  info->type = type;",
          "3660:  info->buflen = get_procfile_size(path) + BUF_RESERVE_SIZE;",
          "3661:  do {",
          "3662:   info->buf = malloc(info->buflen);",
          "3663:  } while (!info->buf);",
          "3664:  memset(info->buf, 0, info->buflen);",
          "3666:  info->size = info->buflen;",
          "3668:  fi->fh = (unsigned long)info;",
          "3669:  return 0;",
          "3670: }",
          "3672: int proc_release(const char *path, struct fuse_file_info *fi)",
          "3673: {",
          "3674:  struct file_info *f = (struct file_info *)fi->fh;",
          "3676:  do_release_file_info(f);",
          "3677:  return 0;",
          "3678: }",
          "3680: int proc_read(const char *path, char *buf, size_t size, off_t offset,",
          "3681:   struct fuse_file_info *fi)",
          "3682: {",
          "3683:  struct file_info *f = (struct file_info *) fi->fh;",
          "3685:  switch (f->type) {",
          "3686:  case LXC_TYPE_PROC_MEMINFO:",
          "3687:   return proc_meminfo_read(buf, size, offset, fi);",
          "3688:  case LXC_TYPE_PROC_CPUINFO:",
          "3689:   return proc_cpuinfo_read(buf, size, offset, fi);",
          "3690:  case LXC_TYPE_PROC_UPTIME:",
          "3691:   return proc_uptime_read(buf, size, offset, fi);",
          "3692:  case LXC_TYPE_PROC_STAT:",
          "3693:   return proc_stat_read(buf, size, offset, fi);",
          "3694:  case LXC_TYPE_PROC_DISKSTATS:",
          "3695:   return proc_diskstats_read(buf, size, offset, fi);",
          "3696:  default:",
          "3697:   return -EINVAL;",
          "3698:  }",
          "3699: }",
          "3701: static void __attribute__((constructor)) collect_subsystems(void)",
          "3702: {",
          "3703:  FILE *f;",
          "3704:  char *line = NULL;",
          "3705:  size_t len = 0;",
          "3707:  if ((f = fopen(\"/proc/self/cgroup\", \"r\")) == NULL) {",
          "3708:   fprintf(stderr, \"Error opening /proc/self/cgroup: %s\\n\", strerror(errno));",
          "3709:   return;",
          "3710:  }",
          "3711:  while (getline(&line, &len, f) != -1) {",
          "3712:   char *p, *p2;",
          "3714:   p = strchr(line, ':');",
          "3715:   if (!p)",
          "3716:    goto out;",
          "3719:   p2 = strrchr(p, ':');",
          "3720:   if (!p2)",
          "3721:    goto out;",
          "3724:   if (!store_hierarchy(line, p))",
          "3725:    goto out;",
          "3726:  }",
          "3728:  print_subsystems();",
          "3730: out:",
          "3731:  free(line);",
          "3732:  fclose(f);",
          "3733: }",
          "3735: static void __attribute__((destructor)) free_subsystems(void)",
          "3736: {",
          "3737:  int i;",
          "3739:  for (i = 0; i < num_hierarchies; i++)",
          "3740:   if (hierarchies[i])",
          "3741:    free(hierarchies[i]);",
          "3742:  free(hierarchies);",
          "3743: }",
          "",
          "---------------"
        ],
        "bindings.h||bindings.h": [
          "File: bindings.h -> bindings.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #define basedir RUNTIME_PATH \"/lxcfs/controllers\"",
          "4: extern int cg_write(const char *path, const char *buf, size_t size, off_t offset,",
          "5:       struct fuse_file_info *fi);",
          "6: extern int cg_mkdir(const char *path, mode_t mode);",
          "7: extern int cg_chown(const char *path, uid_t uid, gid_t gid);",
          "8: extern int cg_rmdir(const char *path);",
          "9: extern int cg_chmod(const char *path, mode_t mode);",
          "10: extern int cg_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "11:   struct fuse_file_info *fi);",
          "12: extern int cg_releasedir(const char *path, struct fuse_file_info *fi);",
          "13: extern int cg_release(const char *path, struct fuse_file_info *fi);",
          "14: extern int cg_read(const char *path, char *buf, size_t size, off_t offset,",
          "15:   struct fuse_file_info *fi);",
          "16: extern int cg_opendir(const char *path, struct fuse_file_info *fi);",
          "17: extern int cg_getattr(const char *path, struct stat *sb);",
          "18: extern int cg_open(const char *path, struct fuse_file_info *fi);",
          "20: extern int proc_getattr(const char *path, struct stat *sb);",
          "21: extern int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "22:   struct fuse_file_info *fi);",
          "23: extern int proc_release(const char *path, struct fuse_file_info *fi);",
          "24: extern int proc_open(const char *path, struct fuse_file_info *fi);",
          "25: extern int proc_read(const char *path, char *buf, size_t size, off_t offset,",
          "26:   struct fuse_file_info *fi);",
          "",
          "---------------"
        ],
        "cgfs.c||cgfs.c": [
          "File: cgfs.c -> cgfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "cgfs.h||cgfs.h": [
          "File: cgfs.h -> cgfs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: AC_SUBST(ACLOCAL_AMFLAGS, \"-I m4\")",
          "6: AC_CONFIG_MACRO_DIR([m4])",
          "8: AM_INIT_AUTOMAKE([subdir-objects])",
          "10: AC_GNU_SOURCE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: AC_SUBST([LXCFS_VERSION_ABI], \"0.9.1\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:  AC_SUBST([pamdir])",
          "72: fi",
          "74: AC_OUTPUT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76: # Rootfs path, where the container mount structure is assembled",
          "77: AC_ARG_WITH([rootfs-path],",
          "78:  [AC_HELP_STRING(",
          "79:   [--with-rootfs-path=dir],",
          "80:   [lxc rootfs mount point]",
          "81:  )], [], [with_rootfs_path=['${libdir}/lxc/rootfs']])",
          "83: AS_AC_EXPAND(LIBDIR, \"$libdir\")",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include <libgen.h>",
          "22: #include <sched.h>",
          "23: #include <pthread.h>",
          "24: #include <linux/sched.h>",
          "25: #include <sys/socket.h>",
          "26: #include <sys/mount.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include <dlfcn.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: #include <glib-object.h>",
          "33: #endif",
          "36: #include \"config.h\" // for VERSION",
          "90: static void lock_mutex(pthread_mutex_t *l)",
          "91: {",
          "92:  int ret;",
          "",
          "[Removed Lines]",
          "35: #include \"cgfs.h\"",
          "38: enum {",
          "39:  LXC_TYPE_CGDIR,",
          "40:  LXC_TYPE_CGFILE,",
          "41:  LXC_TYPE_PROC_MEMINFO,",
          "42:  LXC_TYPE_PROC_CPUINFO,",
          "43:  LXC_TYPE_PROC_UPTIME,",
          "44:  LXC_TYPE_PROC_STAT,",
          "45:  LXC_TYPE_PROC_DISKSTATS,",
          "46: };",
          "48: struct file_info {",
          "49:  char *controller;",
          "50:  char *cgroup;",
          "51:  char *file;",
          "52:  int type;",
          "53:  char *buf;  // unused as of yet",
          "54:  int buflen;",
          "55:  int size; //actual data size",
          "56:  int cached;",
          "57: };",
          "60: #define BUF_RESERVE_SIZE 256",
          "76: struct pidns_init_store {",
          "77:  ino_t ino;          // inode number for /proc/$pid/ns/pid",
          "78:  pid_t initpid;      // the pid of nit in that ns",
          "79:  long int ctime;     // the time at which /proc/$initpid was created",
          "80:  struct pidns_init_store *next;",
          "81:  long int lastcheck;",
          "82: };",
          "85: #define PIDNS_HASH_SIZE 4096",
          "86: #define HASH(x) ((x) % PIDNS_HASH_SIZE)",
          "88: struct pidns_init_store *pidns_hash_table[PIDNS_HASH_SIZE];",
          "89: static pthread_mutex_t pidns_store_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "",
          "[Added Lines]",
          "37: #include \"bindings.h\"",
          "39: void *dlopen_handle;",
          "43: static int users_count;",
          "44: static pthread_mutex_t user_count_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97:  }",
          "98: }",
          "2246: {",
          "2270:  }",
          "2370:  }",
          "2390: }",
          "2397: {",
          "2403: }",
          "2408: {",
          "2414: }",
          "2420: {",
          "2426: }",
          "2429:   struct fuse_file_info *fi)",
          "2430: {",
          "2508:  }",
          "2524: }",
          "2527:   struct fuse_file_info *fi)",
          "2528: {",
          "2576:  }",
          "2654:  }",
          "2672: }",
          "2675: {",
          "2693: }",
          "2696: {",
          "2716: }",
          "2725: {",
          "2742:  }",
          "2752:  }",
          "2761: }",
          "2764:   struct fuse_file_info *fi)",
          "2765: {",
          "2795:  }",
          "2876:  }",
          "2895: }",
          "2898: {",
          "2912: }",
          "2915: {",
          "2937:  }",
          "2940: }",
          "2944: {",
          "2952: }",
          "2955: {",
          "2989: }",
          "2992: {",
          "2997: }",
          "3001: {",
          "3017:  }",
          "3018: }",
          "",
          "[Removed Lines]",
          "100: static void unlock_mutex(pthread_mutex_t *l)",
          "101: {",
          "102:  int ret;",
          "104:  if ((ret = pthread_mutex_unlock(l)) != 0) {",
          "105:   fprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));",
          "106:   exit(1);",
          "107:  }",
          "108: }",
          "110: static void store_lock(void)",
          "111: {",
          "112:  lock_mutex(&pidns_store_mutex);",
          "113: }",
          "115: static void store_unlock(void)",
          "116: {",
          "117:  unlock_mutex(&pidns_store_mutex);",
          "118: }",
          "121: static bool initpid_still_valid(struct pidns_init_store *e, struct stat *nsfdsb)",
          "122: {",
          "123:  struct stat initsb;",
          "124:  char fnam[100];",
          "126:  snprintf(fnam, 100, \"/proc/%d\", e->initpid);",
          "127:  if (stat(fnam, &initsb) < 0)",
          "128:   return false;",
          "129: #if DEBUG",
          "130:  fprintf(stderr, \"comparing ctime %ld %ld for pid %d\\n\",",
          "131:   e->ctime, initsb.st_ctime, e->initpid);",
          "132: #endif",
          "133:  if (e->ctime != initsb.st_ctime)",
          "134:   return false;",
          "135:  return true;",
          "136: }",
          "139: static void remove_initpid(struct pidns_init_store *e)",
          "140: {",
          "141:  struct pidns_init_store *tmp;",
          "142:  int h;",
          "144: #if DEBUG",
          "145:  fprintf(stderr, \"remove_initpid: removing entry for %d\\n\", e->initpid);",
          "146: #endif",
          "147:  h = HASH(e->ino);",
          "148:  if (pidns_hash_table[h] == e) {",
          "149:   pidns_hash_table[h] = e->next;",
          "150:   free(e);",
          "151:   return;",
          "152:  }",
          "154:  tmp = pidns_hash_table[h];",
          "155:  while (tmp) {",
          "156:   if (tmp->next == e) {",
          "157:    tmp->next = e->next;",
          "158:    free(e);",
          "159:    return;",
          "160:   }",
          "161:   tmp = tmp->next;",
          "162:  }",
          "163: }",
          "165: #define PURGE_SECS 5",
          "167: static void prune_initpid_store(void)",
          "168: {",
          "169:  static long int last_prune = 0;",
          "170:  struct pidns_init_store *e, *prev, *delme;",
          "171:  long int now, threshold;",
          "172:  int i;",
          "174:  if (!last_prune) {",
          "175:   last_prune = time(NULL);",
          "176:   return;",
          "177:  }",
          "178:  now = time(NULL);",
          "179:  if (now < last_prune + PURGE_SECS)",
          "180:   return;",
          "181: #if DEBUG",
          "182:  fprintf(stderr, \"pruning\\n\");",
          "183: #endif",
          "184:  last_prune = now;",
          "185:  threshold = now - 2 * PURGE_SECS;",
          "187:  for (i = 0; i < PIDNS_HASH_SIZE; i++) {",
          "188:   for (prev = NULL, e = pidns_hash_table[i]; e; ) {",
          "189:    if (e->lastcheck < threshold) {",
          "190: #if DEBUG",
          "191:     fprintf(stderr, \"Removing cached entry for %d\\n\", e->initpid);",
          "192: #endif",
          "193:     delme = e;",
          "194:     if (prev)",
          "195:      prev->next = e->next;",
          "196:     else",
          "197:      pidns_hash_table[i] = e->next;",
          "198:     e = e->next;",
          "199:     free(delme);",
          "200:    } else {",
          "201:     prev = e;",
          "202:     e = e->next;",
          "203:    }",
          "204:   }",
          "205:  }",
          "206: }",
          "209: static void save_initpid(struct stat *sb, pid_t pid)",
          "210: {",
          "211:  struct pidns_init_store *e;",
          "212:  char fpath[100];",
          "213:  struct stat procsb;",
          "214:  int h;",
          "216: #if DEBUG",
          "217:  fprintf(stderr, \"save_initpid: adding entry for %d\\n\", pid);",
          "218: #endif",
          "219:  snprintf(fpath, 100, \"/proc/%d\", pid);",
          "220:  if (stat(fpath, &procsb) < 0)",
          "221:   return;",
          "222:  do {",
          "223:   e = malloc(sizeof(*e));",
          "224:  } while (!e);",
          "225:  e->ino = sb->st_ino;",
          "226:  e->initpid = pid;",
          "227:  e->ctime = procsb.st_ctime;",
          "228:  h = HASH(e->ino);",
          "229:  e->next = pidns_hash_table[h];",
          "230:  e->lastcheck = time(NULL);",
          "231:  pidns_hash_table[h] = e;",
          "232: }",
          "241: static struct pidns_init_store *lookup_verify_initpid(struct stat *sb)",
          "242: {",
          "243:  int h = HASH(sb->st_ino);",
          "244:  struct pidns_init_store *e = pidns_hash_table[h];",
          "246:  while (e) {",
          "247:   if (e->ino == sb->st_ino) {",
          "248:    if (initpid_still_valid(e, sb)) {",
          "249:     e->lastcheck = time(NULL);",
          "250:     return e;",
          "251:    }",
          "252:    remove_initpid(e);",
          "253:    return NULL;",
          "254:   }",
          "255:   e = e->next;",
          "256:  }",
          "258:  return NULL;",
          "259: }",
          "261: #define SEND_CREDS_OK 0",
          "262: #define SEND_CREDS_NOTSK 1",
          "263: #define SEND_CREDS_FAIL 2",
          "264: static bool recv_creds(int sock, struct ucred *cred, char *v);",
          "265: static int wait_for_pid(pid_t pid);",
          "266: static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst);",
          "273: static void write_task_init_pid_exit(int sock, pid_t target)",
          "274: {",
          "275:  struct ucred cred;",
          "276:  char fnam[100];",
          "277:  pid_t pid;",
          "278:  char v;",
          "279:  int fd, ret;",
          "281:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", (int)target);",
          "282:  if (ret < 0 || ret >= sizeof(fnam))",
          "283:   _exit(1);",
          "285:  fd = open(fnam, O_RDONLY);",
          "286:  if (fd < 0) {",
          "287:   perror(\"write_task_init_pid_exit open of ns/pid\");",
          "288:   _exit(1);",
          "289:  }",
          "290:  if (setns(fd, 0)) {",
          "291:   perror(\"write_task_init_pid_exit setns 1\");",
          "292:   close(fd);",
          "293:   _exit(1);",
          "294:  }",
          "295:  pid = fork();",
          "296:  if (pid < 0)",
          "297:   _exit(1);",
          "298:  if (pid != 0) {",
          "299:   if (!wait_for_pid(pid))",
          "300:    _exit(1);",
          "301:   _exit(0);",
          "302:  }",
          "305:  cred.uid = 0;",
          "306:  cred.gid = 0;",
          "307:  cred.pid = 1;",
          "308:  v = '1';",
          "309:  if (send_creds(sock, &cred, v, true) != SEND_CREDS_OK)",
          "310:   _exit(1);",
          "311:  _exit(0);",
          "312: }",
          "314: static pid_t get_init_pid_for_task(pid_t task)",
          "315: {",
          "316:  int sock[2];",
          "317:  pid_t pid;",
          "318:  pid_t ret = -1;",
          "319:  char v = '0';",
          "320:  struct ucred cred;",
          "322:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "323:   perror(\"socketpair\");",
          "324:   return -1;",
          "325:  }",
          "327:  pid = fork();",
          "328:  if (pid < 0)",
          "329:   goto out;",
          "330:  if (!pid) {",
          "331:   close(sock[1]);",
          "332:   write_task_init_pid_exit(sock[0], task);",
          "333:   _exit(0);",
          "334:  }",
          "336:  if (!recv_creds(sock[1], &cred, &v))",
          "337:   goto out;",
          "338:  ret = cred.pid;",
          "340: out:",
          "341:  close(sock[0]);",
          "342:  close(sock[1]);",
          "343:  if (pid > 0)",
          "344:   wait_for_pid(pid);",
          "345:  return ret;",
          "346: }",
          "348: static pid_t lookup_initpid_in_store(pid_t qpid)",
          "349: {",
          "350:  pid_t answer = 0;",
          "351:  struct stat sb;",
          "352:  struct pidns_init_store *e;",
          "353:  char fnam[100];",
          "355:  snprintf(fnam, 100, \"/proc/%d/ns/pid\", qpid);",
          "356:  store_lock();",
          "357:  if (stat(fnam, &sb) < 0)",
          "358:   goto out;",
          "359:  e = lookup_verify_initpid(&sb);",
          "360:  if (e) {",
          "361:   answer = e->initpid;",
          "362:   goto out;",
          "363:  }",
          "364:  answer = get_init_pid_for_task(qpid);",
          "365:  if (answer > 0)",
          "366:   save_initpid(&sb, answer);",
          "368: out:",
          "371:  prune_initpid_store();",
          "372:  store_unlock();",
          "373:  return answer;",
          "374: }",
          "376: static int wait_for_pid(pid_t pid)",
          "377: {",
          "378:  int status, ret;",
          "380:  if (pid <= 0)",
          "381:   return -1;",
          "383: again:",
          "384:  ret = waitpid(pid, &status, 0);",
          "385:  if (ret == -1) {",
          "386:   if (errno == EINTR)",
          "387:    goto again;",
          "388:   return -1;",
          "389:  }",
          "390:  if (ret != pid)",
          "391:   goto again;",
          "392:  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)",
          "393:   return -1;",
          "394:  return 0;",
          "395: }",
          "405: static void must_strcat_pid(char **src, size_t *sz, size_t *asz, pid_t pid)",
          "406: {",
          "407:  char tmp[30];",
          "409:  int tmplen = sprintf(tmp, \"%d\\n\", (int)pid);",
          "411:  if (!*src || tmplen + *sz + 1 >= *asz) {",
          "412:   char *tmp;",
          "413:   do {",
          "414:    tmp = realloc(*src, *asz + BUF_RESERVE_SIZE);",
          "415:   } while (!tmp);",
          "418:  }",
          "419:  memcpy((*src) +*sz , tmp, tmplen);",
          "421:  (*src)[*sz] = '\\0';",
          "422: }",
          "430: unsigned int",
          "431: convert_id_to_ns(FILE *idfile, unsigned int in_id)",
          "432: {",
          "433:  unsigned int nsuid,   // base id for a range in the idfile's namespace",
          "434:        hostuid, // base id for a range in the caller's namespace",
          "435:        count;   // number of ids in this range",
          "436:  char line[400];",
          "437:  int ret;",
          "439:  fseek(idfile, 0L, SEEK_SET);",
          "440:  while (fgets(line, 400, idfile)) {",
          "441:   ret = sscanf(line, \"%u %u %u\\n\", &nsuid, &hostuid, &count);",
          "442:   if (ret != 3)",
          "443:    continue;",
          "444:   if (hostuid + count < hostuid || nsuid + count < nsuid) {",
          "449:    fprintf(stderr, \"pid wrapparound at entry %u %u %u in %s\\n\",",
          "450:     nsuid, hostuid, count, line);",
          "451:    return -1;",
          "452:   }",
          "453:   if (hostuid <= in_id && hostuid+count > in_id) {",
          "460:    return (in_id - hostuid) + nsuid;",
          "461:   }",
          "462:  }",
          "465:  return -1;",
          "466: }",
          "473: #define NS_ROOT_REQD true",
          "474: #define NS_ROOT_OPT false",
          "476: #define PROCLEN 100",
          "478: static bool is_privileged_over(pid_t pid, uid_t uid, uid_t victim, bool req_ns_root)",
          "479: {",
          "480:  char fpath[PROCLEN];",
          "481:  int ret;",
          "482:  bool answer = false;",
          "483:  uid_t nsuid;",
          "485:  if (victim == -1 || uid == -1)",
          "486:   return false;",
          "493:  if (!req_ns_root && uid == victim)",
          "494:   return true;",
          "496:  ret = snprintf(fpath, PROCLEN, \"/proc/%d/uid_map\", pid);",
          "497:  if (ret < 0 || ret >= PROCLEN)",
          "498:   return false;",
          "499:  FILE *f = fopen(fpath, \"r\");",
          "500:  if (!f)",
          "501:   return false;",
          "504:  nsuid = convert_id_to_ns(f, uid);",
          "505:  if (nsuid)",
          "506:   goto out;",
          "513:  nsuid = convert_id_to_ns(f, victim);",
          "514:  if (nsuid == -1)",
          "515:   goto out;",
          "517:  answer = true;",
          "519: out:",
          "520:  fclose(f);",
          "521:  return answer;",
          "522: }",
          "524: static bool perms_include(int fmode, mode_t req_mode)",
          "525: {",
          "526:  mode_t r;",
          "528:  switch (req_mode & O_ACCMODE) {",
          "529:  case O_RDONLY:",
          "530:   r = S_IROTH;",
          "531:   break;",
          "532:  case O_WRONLY:",
          "533:   r = S_IWOTH;",
          "534:   break;",
          "535:  case O_RDWR:",
          "536:   r = S_IROTH | S_IWOTH;",
          "537:   break;",
          "538:  default:",
          "539:   return false;",
          "540:  }",
          "541:  return ((fmode & r) == r);",
          "542: }",
          "550: static char *get_next_cgroup_dir(const char *taskcg, const char *querycg)",
          "551: {",
          "552:  char *start, *end;",
          "554:  if (strlen(taskcg) <= strlen(querycg)) {",
          "555:   fprintf(stderr, \"%s: I was fed bad input\\n\", __func__);",
          "556:   return NULL;",
          "557:  }",
          "559:  if (strcmp(querycg, \"/\") == 0)",
          "560:   start =  strdup(taskcg + 1);",
          "561:  else",
          "562:   start = strdup(taskcg + strlen(querycg) + 1);",
          "563:  if (!start)",
          "564:   return NULL;",
          "565:  end = strchr(start, '/');",
          "566:  if (end)",
          "568:  return start;",
          "569: }",
          "571: static void stripnewline(char *x)",
          "572: {",
          "573:  size_t l = strlen(x);",
          "574:  if (l && x[l-1] == '\\n')",
          "575:   x[l-1] = '\\0';",
          "576: }",
          "578: static char *get_pid_cgroup(pid_t pid, const char *contrl)",
          "579: {",
          "580:  char fnam[PROCLEN];",
          "581:  FILE *f;",
          "582:  char *answer = NULL;",
          "583:  char *line = NULL;",
          "584:  size_t len = 0;",
          "585:  int ret;",
          "586:  const char *h = find_mounted_controller(contrl);",
          "587:  if (!h)",
          "588:   return NULL;",
          "590:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
          "591:  if (ret < 0 || ret >= PROCLEN)",
          "592:   return NULL;",
          "593:  if (!(f = fopen(fnam, \"r\")))",
          "594:   return NULL;",
          "596:  while (getline(&line, &len, f) != -1) {",
          "597:   char *c1, *c2;",
          "598:   if (!line[0])",
          "599:    continue;",
          "600:   c1 = strchr(line, ':');",
          "601:   if (!c1)",
          "602:    goto out;",
          "603:   c1++;",
          "604:   c2 = strchr(c1, ':');",
          "605:   if (!c2)",
          "606:    goto out;",
          "608:   if (strcmp(c1, h) != 0)",
          "609:    continue;",
          "610:   c2++;",
          "611:   stripnewline(c2);",
          "612:   do {",
          "613:    answer = strdup(c2);",
          "614:   } while (!answer);",
          "615:   break;",
          "616:  }",
          "618: out:",
          "619:  fclose(f);",
          "620:  free(line);",
          "621:  return answer;",
          "622: }",
          "635: static bool fc_may_access(struct fuse_context *fc, const char *contrl, const char *cg, const char *file, mode_t mode)",
          "636: {",
          "637:  struct cgfs_files *k = NULL;",
          "638:  bool ret = false;",
          "640:  k = cgfs_get_key(contrl, cg, file);",
          "641:  if (!k)",
          "642:   return false;",
          "644:  if (is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT)) {",
          "645:   if (perms_include(k->mode >> 6, mode)) {",
          "646:    ret = true;",
          "647:    goto out;",
          "648:   }",
          "649:  }",
          "650:  if (fc->gid == k->gid) {",
          "651:   if (perms_include(k->mode >> 3, mode)) {",
          "652:    ret = true;",
          "653:    goto out;",
          "654:   }",
          "655:  }",
          "656:  ret = perms_include(k->mode, mode);",
          "658: out:",
          "659:  free_key(k);",
          "660:  return ret;",
          "661: }",
          "663: #define INITSCOPE \"/init.scope\"",
          "664: static void prune_init_slice(char *cg)",
          "665: {",
          "666:  char *point;",
          "667:  size_t cg_len = strlen(cg), initscope_len = strlen(INITSCOPE);",
          "669:  if (cg_len < initscope_len)",
          "670:   return;",
          "672:  point = cg + cg_len - initscope_len;",
          "673:  if (strcmp(point, INITSCOPE) == 0) {",
          "674:   if (point == cg)",
          "676:   else",
          "678:  }",
          "679: }",
          "688: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
          "689: {",
          "690:  bool answer = false;",
          "691:  char *c2 = get_pid_cgroup(pid, contrl);",
          "692:  char *linecmp;",
          "694:  if (!c2)",
          "695:   return false;",
          "696:  prune_init_slice(c2);",
          "702:  linecmp = *cg == '/' ? c2 : c2+1;",
          "703:  if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
          "704:   if (nextcg) {",
          "706:   }",
          "707:   goto out;",
          "708:  }",
          "709:  answer = true;",
          "711: out:",
          "712:  free(c2);",
          "713:  return answer;",
          "714: }",
          "719: static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)",
          "720: {",
          "721:  bool answer = false;",
          "722:  char *c2, *task_cg;",
          "723:  size_t target_len, task_len;",
          "725:  if (strcmp(cg, \"/\") == 0)",
          "726:   return true;",
          "728:  c2 = get_pid_cgroup(pid, contrl);",
          "729:  if (!c2)",
          "730:   return false;",
          "731:  prune_init_slice(c2);",
          "733:  task_cg = c2 + 1;",
          "734:  target_len = strlen(cg);",
          "735:  task_len = strlen(task_cg);",
          "736:  if (task_len == 0) {",
          "742:   answer = true;",
          "743:   goto out;",
          "744:  }",
          "745:  if (strcmp(cg, task_cg) == 0) {",
          "746:   answer = true;",
          "747:   goto out;",
          "748:  }",
          "749:  if (target_len < task_len) {",
          "751:   if (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')",
          "752:    answer = true;",
          "753:   goto out;",
          "754:  }",
          "755:  if (target_len > task_len) {",
          "757:   if (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')",
          "758:    answer = true;",
          "759:   goto out;",
          "760:  }",
          "762: out:",
          "763:  free(c2);",
          "764:  return answer;",
          "765: }",
          "771: static char *pick_controller_from_path(struct fuse_context *fc, const char *path)",
          "772: {",
          "773:  const char *p1;",
          "774:  char *contr, *slash;",
          "776:  if (strlen(path) < 9)",
          "777:   return NULL;",
          "778:  if (*(path+7) != '/')",
          "779:   return NULL;",
          "780:  p1 = path+8;",
          "781:  contr = strdupa(p1);",
          "782:  if (!contr)",
          "783:   return NULL;",
          "784:  slash = strstr(contr, \"/\");",
          "785:  if (slash)",
          "788:  int i;",
          "789:  for (i = 0;  i < num_hierarchies;  i++) {",
          "790:   if (hierarchies[i] && strcmp(hierarchies[i], contr) == 0)",
          "791:    return hierarchies[i];",
          "792:  }",
          "793:  return NULL;",
          "794: }",
          "800: static const char *find_cgroup_in_path(const char *path)",
          "801: {",
          "802:  const char *p1;",
          "804:  if (strlen(path) < 9)",
          "805:   return NULL;",
          "806:  p1 = strstr(path+8, \"/\");",
          "807:  if (!p1)",
          "808:   return NULL;",
          "809:  return p1+1;",
          "810: }",
          "816: static void get_cgdir_and_path(const char *cg, char **dir, char **last)",
          "817: {",
          "818:  char *p;",
          "820:  do {",
          "822:  } while (!*dir);",
          "824:  if (!*last) {",
          "826:   return;",
          "827:  }",
          "828:  p = strrchr(*dir, '/');",
          "830: }",
          "836: static int cg_getattr(const char *path, struct stat *sb)",
          "837: {",
          "838:  struct timespec now;",
          "839:  struct fuse_context *fc = fuse_get_context();",
          "840:  char * cgdir = NULL;",
          "841:  char *last = NULL, *path1, *path2;",
          "842:  struct cgfs_files *k = NULL;",
          "843:  const char *cgroup;",
          "844:  const char *controller = NULL;",
          "845:  int ret = -ENOENT;",
          "848:  if (!fc)",
          "849:   return -EIO;",
          "851:  memset(sb, 0, sizeof(struct stat));",
          "853:  if (clock_gettime(CLOCK_REALTIME, &now) < 0)",
          "854:   return -EINVAL;",
          "856:  sb->st_uid = sb->st_gid = 0;",
          "857:  sb->st_atim = sb->st_mtim = sb->st_ctim = now;",
          "858:  sb->st_size = 0;",
          "860:  if (strcmp(path, \"/cgroup\") == 0) {",
          "861:   sb->st_mode = S_IFDIR | 00755;",
          "862:   sb->st_nlink = 2;",
          "863:   return 0;",
          "864:  }",
          "866:  controller = pick_controller_from_path(fc, path);",
          "867:  if (!controller)",
          "868:   return -EIO;",
          "869:  cgroup = find_cgroup_in_path(path);",
          "870:  if (!cgroup) {",
          "872:   sb->st_mode = S_IFDIR | 00755;",
          "873:   sb->st_nlink = 2;",
          "874:   return 0;",
          "875:  }",
          "877:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "879:  if (!last) {",
          "880:   path1 = \"/\";",
          "881:   path2 = cgdir;",
          "882:  } else {",
          "883:   path1 = cgdir;",
          "884:   path2 = last;",
          "885:  }",
          "887:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "888:  if (initpid <= 0)",
          "889:   initpid = fc->pid;",
          "894:  if (is_child_cgroup(controller, path1, path2)) {",
          "895:   if (!caller_may_see_dir(initpid, controller, cgroup)) {",
          "896:    ret = -ENOENT;",
          "897:    goto out;",
          "898:   }",
          "899:   if (!caller_is_in_ancestor(initpid, controller, cgroup, NULL)) {",
          "901:    sb->st_mode = S_IFDIR | 00555;",
          "902:    sb->st_nlink = 2;",
          "903:    ret = 0;",
          "904:    goto out;",
          "905:   }",
          "906:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
          "907:    ret = -EACCES;",
          "908:    goto out;",
          "909:   }",
          "913:   sb->st_mode = S_IFDIR | 00755;",
          "914:   k = cgfs_get_key(controller, cgroup, NULL);",
          "915:   if (!k) {",
          "916:    sb->st_uid = sb->st_gid = 0;",
          "917:   } else {",
          "918:    sb->st_uid = k->uid;",
          "919:    sb->st_gid = k->gid;",
          "920:   }",
          "921:   free_key(k);",
          "922:   sb->st_nlink = 2;",
          "923:   ret = 0;",
          "924:   goto out;",
          "925:  }",
          "927:  if ((k = cgfs_get_key(controller, path1, path2)) != NULL) {",
          "928:   sb->st_mode = S_IFREG | k->mode;",
          "929:   sb->st_nlink = 1;",
          "930:   sb->st_uid = k->uid;",
          "931:   sb->st_gid = k->gid;",
          "932:   sb->st_size = 0;",
          "933:   free_key(k);",
          "934:   if (!caller_is_in_ancestor(initpid, controller, path1, NULL)) {",
          "935:    ret = -ENOENT;",
          "936:    goto out;",
          "937:   }",
          "938:   if (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {",
          "939:    ret = -EACCES;",
          "940:    goto out;",
          "941:   }",
          "943:   ret = 0;",
          "944:  }",
          "946: out:",
          "947:  free(cgdir);",
          "948:  return ret;",
          "949: }",
          "951: static int cg_opendir(const char *path, struct fuse_file_info *fi)",
          "952: {",
          "953:  struct fuse_context *fc = fuse_get_context();",
          "954:  const char *cgroup;",
          "955:  struct file_info *dir_info;",
          "956:  char *controller = NULL;",
          "958:  if (!fc)",
          "959:   return -EIO;",
          "961:  if (strcmp(path, \"/cgroup\") == 0) {",
          "962:   cgroup = NULL;",
          "963:   controller = NULL;",
          "964:  } else {",
          "966:   controller = pick_controller_from_path(fc, path);",
          "967:   if (!controller)",
          "968:    return -EIO;",
          "970:   cgroup = find_cgroup_in_path(path);",
          "971:   if (!cgroup) {",
          "973:    cgroup = \"/\";",
          "974:   }",
          "975:  }",
          "977:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "978:  if (initpid <= 0)",
          "979:   initpid = fc->pid;",
          "980:  if (cgroup) {",
          "981:   if (!caller_may_see_dir(initpid, controller, cgroup))",
          "982:    return -ENOENT;",
          "983:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "984:    return -EACCES;",
          "985:  }",
          "988:  dir_info = malloc(sizeof(*dir_info));",
          "989:  if (!dir_info)",
          "990:   return -ENOMEM;",
          "991:  dir_info->controller = must_copy_string(controller);",
          "992:  dir_info->cgroup = must_copy_string(cgroup);",
          "993:  dir_info->type = LXC_TYPE_CGDIR;",
          "994:  dir_info->buf = NULL;",
          "995:  dir_info->file = NULL;",
          "996:  dir_info->buflen = 0;",
          "998:  fi->fh = (unsigned long)dir_info;",
          "999:  return 0;",
          "1000: }",
          "1002: static int cg_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "1003:   struct fuse_file_info *fi)",
          "1004: {",
          "1005:  struct file_info *d = (struct file_info *)fi->fh;",
          "1006:  struct cgfs_files **list = NULL;",
          "1007:  int i, ret;",
          "1008:  char *nextcg = NULL;",
          "1009:  struct fuse_context *fc = fuse_get_context();",
          "1010:  char **clist = NULL;",
          "1012:  if (d->type != LXC_TYPE_CGDIR) {",
          "1013:   fprintf(stderr, \"Internal error: file cache info used in readdir\\n\");",
          "1014:   return -EIO;",
          "1015:  }",
          "1016:  if (!d->cgroup && !d->controller) {",
          "1018:   int i;",
          "1020:   for (i = 0;  i < num_hierarchies; i++) {",
          "1021:    if (hierarchies[i] && filler(buf, hierarchies[i], NULL, 0) != 0) {",
          "1022:     return -EIO;",
          "1023:    }",
          "1024:   }",
          "1025:   return 0;",
          "1026:  }",
          "1028:  if (!cgfs_list_keys(d->controller, d->cgroup, &list)) {",
          "1030:   ret = -EINVAL;",
          "1031:   goto out;",
          "1032:  }",
          "1034:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "1035:  if (initpid <= 0)",
          "1036:   initpid = fc->pid;",
          "1037:  if (!caller_is_in_ancestor(initpid, d->controller, d->cgroup, &nextcg)) {",
          "1038:   if (nextcg) {",
          "1039:    ret = filler(buf, nextcg,  NULL, 0);",
          "1040:    free(nextcg);",
          "1041:    if (ret != 0) {",
          "1042:     ret = -EIO;",
          "1043:     goto out;",
          "1044:    }",
          "1045:   }",
          "1046:   ret = 0;",
          "1047:   goto out;",
          "1048:  }",
          "1050:  for (i = 0; list[i]; i++) {",
          "1051:   if (filler(buf, list[i]->name, NULL, 0) != 0) {",
          "1052:    ret = -EIO;",
          "1053:    goto out;",
          "1054:   }",
          "1055:  }",
          "1059:  if (!cgfs_list_children(d->controller, d->cgroup, &clist)) {",
          "1060:   ret = 0;",
          "1061:   goto out;",
          "1062:  }",
          "1063:  for (i = 0; clist[i]; i++) {",
          "1064:   if (filler(buf, clist[i], NULL, 0) != 0) {",
          "1065:    ret = -EIO;",
          "1066:    goto out;",
          "1067:   }",
          "1068:  }",
          "1069:  ret = 0;",
          "1071: out:",
          "1072:  free_keys(list);",
          "1073:  if (clist) {",
          "1074:   for (i = 0; clist[i]; i++)",
          "1075:    free(clist[i]);",
          "1076:   free(clist);",
          "1077:  }",
          "1078:  return ret;",
          "1079: }",
          "1081: static void do_release_file_info(struct file_info *f)",
          "1082: {",
          "1083:  if (!f)",
          "1084:   return;",
          "1085:  free(f->controller);",
          "1086:  free(f->cgroup);",
          "1087:  free(f->file);",
          "1088:  free(f->buf);",
          "1089:  free(f);",
          "1090: }",
          "1092: static int cg_releasedir(const char *path, struct fuse_file_info *fi)",
          "1093: {",
          "1094:  struct file_info *d = (struct file_info *)fi->fh;",
          "1096:  do_release_file_info(d);",
          "1097:  return 0;",
          "1098: }",
          "1100: static int cg_open(const char *path, struct fuse_file_info *fi)",
          "1101: {",
          "1102:  const char *cgroup;",
          "1103:  char *last = NULL, *path1, *path2, * cgdir = NULL, *controller;",
          "1104:  struct cgfs_files *k = NULL;",
          "1105:  struct file_info *file_info;",
          "1106:  struct fuse_context *fc = fuse_get_context();",
          "1107:  int ret;",
          "1109:  if (!fc)",
          "1110:   return -EIO;",
          "1112:  controller = pick_controller_from_path(fc, path);",
          "1113:  if (!controller)",
          "1114:   return -EIO;",
          "1115:  cgroup = find_cgroup_in_path(path);",
          "1116:  if (!cgroup)",
          "1117:   return -EINVAL;",
          "1119:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1120:  if (!last) {",
          "1121:   path1 = \"/\";",
          "1122:   path2 = cgdir;",
          "1123:  } else {",
          "1124:   path1 = cgdir;",
          "1125:   path2 = last;",
          "1126:  }",
          "1128:  k = cgfs_get_key(controller, path1, path2);",
          "1129:  if (!k) {",
          "1130:   ret = -EINVAL;",
          "1131:   goto out;",
          "1132:  }",
          "1133:  free_key(k);",
          "1135:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "1136:  if (initpid <= 0)",
          "1137:   initpid = fc->pid;",
          "1138:  if (!caller_may_see_dir(initpid, controller, path1)) {",
          "1139:   ret = -ENOENT;",
          "1140:   goto out;",
          "1141:  }",
          "1142:  if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {",
          "1144:   ret = -EACCES;",
          "1145:   goto out;",
          "1146:  }",
          "1149:  file_info = malloc(sizeof(*file_info));",
          "1150:  if (!file_info) {",
          "1151:   ret = -ENOMEM;",
          "1152:   goto out;",
          "1153:  }",
          "1154:  file_info->controller = must_copy_string(controller);",
          "1155:  file_info->cgroup = must_copy_string(path1);",
          "1156:  file_info->file = must_copy_string(path2);",
          "1157:  file_info->type = LXC_TYPE_CGFILE;",
          "1158:  file_info->buf = NULL;",
          "1159:  file_info->buflen = 0;",
          "1161:  fi->fh = (unsigned long)file_info;",
          "1162:  ret = 0;",
          "1164: out:",
          "1165:  free(cgdir);",
          "1166:  return ret;",
          "1167: }",
          "1169: static int cg_release(const char *path, struct fuse_file_info *fi)",
          "1170: {",
          "1171:  struct file_info *f = (struct file_info *)fi->fh;",
          "1173:  do_release_file_info(f);",
          "1174:  return 0;",
          "1175: }",
          "1177: #define POLLIN_SET ( EPOLLIN | EPOLLHUP | EPOLLRDHUP )",
          "1179: static bool wait_for_sock(int sock, int timeout)",
          "1180: {",
          "1181:  struct epoll_event ev;",
          "1182:  int epfd, ret, now, starttime, deltatime, saved_errno;",
          "1184:  if ((starttime = time(NULL)) < 0)",
          "1185:   return false;",
          "1187:  if ((epfd = epoll_create(1)) < 0) {",
          "1188:   fprintf(stderr, \"Failed to create epoll socket: %m\\n\");",
          "1189:   return false;",
          "1190:  }",
          "1192:  ev.events = POLLIN_SET;",
          "1193:  ev.data.fd = sock;",
          "1194:  if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &ev) < 0) {",
          "1195:   fprintf(stderr, \"Failed adding socket to epoll: %m\\n\");",
          "1196:   close(epfd);",
          "1197:   return false;",
          "1198:  }",
          "1200: again:",
          "1201:  if ((now = time(NULL)) < 0) {",
          "1202:   close(epfd);",
          "1203:   return false;",
          "1204:  }",
          "1206:  deltatime = (starttime + timeout) - now;",
          "1207:  if (deltatime < 0) { // timeout",
          "1208:   errno = 0;",
          "1209:   close(epfd);",
          "1210:   return false;",
          "1211:  }",
          "1212:  ret = epoll_wait(epfd, &ev, 1, 1000*deltatime + 1);",
          "1213:  if (ret < 0 && errno == EINTR)",
          "1214:   goto again;",
          "1215:  saved_errno = errno;",
          "1216:  close(epfd);",
          "1218:  if (ret <= 0) {",
          "1219:   errno = saved_errno;",
          "1220:   return false;",
          "1221:  }",
          "1222:  return true;",
          "1223: }",
          "1225: static int msgrecv(int sockfd, void *buf, size_t len)",
          "1226: {",
          "1227:  if (!wait_for_sock(sockfd, 2))",
          "1228:   return -1;",
          "1229:  return recv(sockfd, buf, len, MSG_DONTWAIT);",
          "1230: }",
          "1232: static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst)",
          "1233: {",
          "1234:  struct msghdr msg = { 0 };",
          "1235:  struct iovec iov;",
          "1236:  struct cmsghdr *cmsg;",
          "1237:  char cmsgbuf[CMSG_SPACE(sizeof(*cred))];",
          "1238:  char buf[1];",
          "1239:  buf[0] = 'p';",
          "1241:  if (pingfirst) {",
          "1242:   if (msgrecv(sock, buf, 1) != 1) {",
          "1243:    fprintf(stderr, \"%s: Error getting reply from server over socketpair\\n\",",
          "1244:       __func__);",
          "1245:    return SEND_CREDS_FAIL;",
          "1246:   }",
          "1247:  }",
          "1249:  msg.msg_control = cmsgbuf;",
          "1250:  msg.msg_controllen = sizeof(cmsgbuf);",
          "1252:  cmsg = CMSG_FIRSTHDR(&msg);",
          "1253:  cmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));",
          "1254:  cmsg->cmsg_level = SOL_SOCKET;",
          "1255:  cmsg->cmsg_type = SCM_CREDENTIALS;",
          "1256:  memcpy(CMSG_DATA(cmsg), cred, sizeof(*cred));",
          "1258:  msg.msg_name = NULL;",
          "1259:  msg.msg_namelen = 0;",
          "1261:  buf[0] = v;",
          "1262:  iov.iov_base = buf;",
          "1263:  iov.iov_len = sizeof(buf);",
          "1264:  msg.msg_iov = &iov;",
          "1265:  msg.msg_iovlen = 1;",
          "1267:  if (sendmsg(sock, &msg, 0) < 0) {",
          "1268:   fprintf(stderr, \"%s: failed at sendmsg: %s\\n\", __func__,",
          "1269:      strerror(errno));",
          "1270:   if (errno == 3)",
          "1271:    return SEND_CREDS_NOTSK;",
          "1272:   return SEND_CREDS_FAIL;",
          "1273:  }",
          "1275:  return SEND_CREDS_OK;",
          "1276: }",
          "1278: static bool recv_creds(int sock, struct ucred *cred, char *v)",
          "1279: {",
          "1280:  struct msghdr msg = { 0 };",
          "1281:  struct iovec iov;",
          "1282:  struct cmsghdr *cmsg;",
          "1283:  char cmsgbuf[CMSG_SPACE(sizeof(*cred))];",
          "1284:  char buf[1];",
          "1285:  int ret;",
          "1286:  int optval = 1;",
          "1290:  cred->pid = -1;",
          "1291:  cred->uid = -1;",
          "1292:  cred->gid = -1;",
          "1294:  if (setsockopt(sock, SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {",
          "1295:   fprintf(stderr, \"Failed to set passcred: %s\\n\", strerror(errno));",
          "1296:   return false;",
          "1297:  }",
          "1298:  buf[0] = '1';",
          "1299:  if (write(sock, buf, 1) != 1) {",
          "1300:   fprintf(stderr, \"Failed to start write on scm fd: %s\\n\", strerror(errno));",
          "1301:   return false;",
          "1302:  }",
          "1304:  msg.msg_name = NULL;",
          "1305:  msg.msg_namelen = 0;",
          "1306:  msg.msg_control = cmsgbuf;",
          "1307:  msg.msg_controllen = sizeof(cmsgbuf);",
          "1309:  iov.iov_base = buf;",
          "1310:  iov.iov_len = sizeof(buf);",
          "1311:  msg.msg_iov = &iov;",
          "1312:  msg.msg_iovlen = 1;",
          "1314:  if (!wait_for_sock(sock, 2)) {",
          "1315:   fprintf(stderr, \"Timed out waiting for scm_cred: %s\\n\",",
          "1316:      strerror(errno));",
          "1317:   return false;",
          "1318:  }",
          "1319:  ret = recvmsg(sock, &msg, MSG_DONTWAIT);",
          "1320:  if (ret < 0) {",
          "1321:   fprintf(stderr, \"Failed to receive scm_cred: %s\\n\",",
          "1322:      strerror(errno));",
          "1323:   return false;",
          "1324:  }",
          "1326:  cmsg = CMSG_FIRSTHDR(&msg);",
          "1328:  if (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(struct ucred)) &&",
          "1329:    cmsg->cmsg_level == SOL_SOCKET &&",
          "1330:    cmsg->cmsg_type == SCM_CREDENTIALS) {",
          "1331:   memcpy(cred, CMSG_DATA(cmsg), sizeof(*cred));",
          "1332:  }",
          "1335:  return true;",
          "1336: }",
          "1344: static void pid_to_ns(int sock, pid_t tpid)",
          "1345: {",
          "1346:  char v = '0';",
          "1347:  struct ucred cred;",
          "1349:  while (recv_creds(sock, &cred, &v)) {",
          "1350:   if (v == '1')",
          "1351:    _exit(0);",
          "1352:   if (write(sock, &cred.pid, sizeof(pid_t)) != sizeof(pid_t))",
          "1353:    _exit(1);",
          "1354:  }",
          "1355:  _exit(0);",
          "1356: }",
          "1364: static void pid_to_ns_wrapper(int sock, pid_t tpid)",
          "1365: {",
          "1366:  int newnsfd = -1, ret, cpipe[2];",
          "1367:  char fnam[100];",
          "1368:  pid_t cpid;",
          "1369:  char v;",
          "1371:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", tpid);",
          "1372:  if (ret < 0 || ret >= sizeof(fnam))",
          "1373:   _exit(1);",
          "1374:  newnsfd = open(fnam, O_RDONLY);",
          "1375:  if (newnsfd < 0)",
          "1376:   _exit(1);",
          "1377:  if (setns(newnsfd, 0) < 0)",
          "1378:   _exit(1);",
          "1379:  close(newnsfd);",
          "1381:  if (pipe(cpipe) < 0)",
          "1382:   _exit(1);",
          "1384:  cpid = fork();",
          "1385:  if (cpid < 0)",
          "1386:   _exit(1);",
          "1388:  if (!cpid) {",
          "1389:   char b = '1';",
          "1390:   close(cpipe[0]);",
          "1391:   if (write(cpipe[1], &b, sizeof(char)) < 0) {",
          "1392:    fprintf(stderr, \"%s (child): erorr on write: %s\\n\",",
          "1393:     __func__, strerror(errno));",
          "1394:   }",
          "1395:   close(cpipe[1]);",
          "1396:   pid_to_ns(sock, tpid);",
          "1397:   _exit(1); // not reached",
          "1398:  }",
          "1401:  if (!wait_for_sock(cpipe[0], 1))",
          "1402:   _exit(1);",
          "1403:  ret = read(cpipe[0], &v, 1);",
          "1404:  if (ret != sizeof(char) || v != '1')",
          "1405:   _exit(1);",
          "1407:  if (!wait_for_pid(cpid))",
          "1408:   _exit(1);",
          "1409:  _exit(0);",
          "1410: }",
          "1417: static bool do_read_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, char **d)",
          "1418: {",
          "1419:  int sock[2] = {-1, -1};",
          "1420:  char *tmpdata = NULL;",
          "1421:  int ret;",
          "1422:  pid_t qpid, cpid = -1;",
          "1423:  bool answer = false;",
          "1424:  char v = '0';",
          "1425:  struct ucred cred;",
          "1426:  size_t sz = 0, asz = 0;",
          "1428:  if (!cgfs_get_value(contrl, cg, file, &tmpdata))",
          "1429:   return false;",
          "1437:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "1438:   perror(\"socketpair\");",
          "1439:   free(tmpdata);",
          "1440:   return false;",
          "1441:  }",
          "1443:  cpid = fork();",
          "1444:  if (cpid == -1)",
          "1445:   goto out;",
          "1447:  if (!cpid) // child - exits when done",
          "1448:   pid_to_ns_wrapper(sock[1], tpid);",
          "1450:  char *ptr = tmpdata;",
          "1451:  cred.uid = 0;",
          "1452:  cred.gid = 0;",
          "1453:  while (sscanf(ptr, \"%d\\n\", &qpid) == 1) {",
          "1454:   cred.pid = qpid;",
          "1455:   ret = send_creds(sock[0], &cred, v, true);",
          "1457:   if (ret == SEND_CREDS_NOTSK)",
          "1458:    goto next;",
          "1459:   if (ret == SEND_CREDS_FAIL)",
          "1460:    goto out;",
          "1463:   if (!wait_for_sock(sock[0], 2)) {",
          "1464:    fprintf(stderr, \"%s: timed out waiting for pid from child: %s\\n\",",
          "1465:     __func__, strerror(errno));",
          "1466:    goto out;",
          "1467:   }",
          "1468:   if (read(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {",
          "1469:    fprintf(stderr, \"%s: error reading pid from child: %s\\n\",",
          "1470:     __func__, strerror(errno));",
          "1471:    goto out;",
          "1472:   }",
          "1473:   must_strcat_pid(d, &sz, &asz, qpid);",
          "1474: next:",
          "1475:   ptr = strchr(ptr, '\\n');",
          "1476:   if (!ptr)",
          "1477:    break;",
          "1478:   ptr++;",
          "1479:  }",
          "1481:  cred.pid = getpid();",
          "1482:  v = '1';",
          "1483:  if (send_creds(sock[0], &cred, v, true) != SEND_CREDS_OK) {",
          "1485:   fprintf(stderr, \"%s: failed to ask child to exit: %s\\n\",",
          "1486:    __func__, strerror(errno));",
          "1487:   goto out;",
          "1488:  }",
          "1490:  answer = true;",
          "1492: out:",
          "1493:  free(tmpdata);",
          "1494:  if (cpid != -1)",
          "1495:   wait_for_pid(cpid);",
          "1496:  if (sock[0] != -1) {",
          "1497:   close(sock[0]);",
          "1498:   close(sock[1]);",
          "1499:  }",
          "1500:  return answer;",
          "1501: }",
          "1503: static int cg_read(const char *path, char *buf, size_t size, off_t offset,",
          "1504:   struct fuse_file_info *fi)",
          "1505: {",
          "1506:  struct fuse_context *fc = fuse_get_context();",
          "1507:  struct file_info *f = (struct file_info *)fi->fh;",
          "1508:  struct cgfs_files *k = NULL;",
          "1509:  char *data = NULL;",
          "1510:  int ret, s;",
          "1511:  bool r;",
          "1513:  if (f->type != LXC_TYPE_CGFILE) {",
          "1514:   fprintf(stderr, \"Internal error: directory cache info used in cg_read\\n\");",
          "1515:   return -EIO;",
          "1516:  }",
          "1518:  if (offset)",
          "1519:   return 0;",
          "1521:  if (!fc)",
          "1522:   return -EIO;",
          "1524:  if (!f->controller)",
          "1525:   return -EINVAL;",
          "1527:  if ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {",
          "1528:   return -EINVAL;",
          "1529:  }",
          "1530:  free_key(k);",
          "1533:  if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_RDONLY)) { // should never get here",
          "1534:   ret = -EACCES;",
          "1535:   goto out;",
          "1536:  }",
          "1538:  if (strcmp(f->file, \"tasks\") == 0 ||",
          "1539:    strcmp(f->file, \"/tasks\") == 0 ||",
          "1540:    strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "1541:    strcmp(f->file, \"cgroup.procs\") == 0)",
          "1543:   r = do_read_pids(fc->pid, f->controller, f->cgroup, f->file, &data);",
          "1544:  else",
          "1545:   r = cgfs_get_value(f->controller, f->cgroup, f->file, &data);",
          "1547:  if (!r) {",
          "1548:   ret = -EINVAL;",
          "1549:   goto out;",
          "1550:  }",
          "1552:  if (!data) {",
          "1553:   ret = 0;",
          "1554:   goto out;",
          "1555:  }",
          "1556:  s = strlen(data);",
          "1557:  if (s > size)",
          "1558:   s = size;",
          "1559:  memcpy(buf, data, s);",
          "1560:  if (s > 0 && s < size && data[s-1] != '\\n')",
          "1561:   buf[s++] = '\\n';",
          "1563:  ret = s;",
          "1565: out:",
          "1566:  free(data);",
          "1567:  return ret;",
          "1568: }",
          "1570: static void pid_from_ns(int sock, pid_t tpid)",
          "1571: {",
          "1572:  pid_t vpid;",
          "1573:  struct ucred cred;",
          "1574:  char v;",
          "1575:  int ret;",
          "1577:  cred.uid = 0;",
          "1578:  cred.gid = 0;",
          "1579:  while (1) {",
          "1580:   if (!wait_for_sock(sock, 2)) {",
          "1581:    fprintf(stderr, \"%s: timeout reading from parent\\n\", __func__);",
          "1582:    _exit(1);",
          "1583:   }",
          "1584:   if ((ret = read(sock, &vpid, sizeof(pid_t))) != sizeof(pid_t)) {",
          "1585:    fprintf(stderr, \"%s: bad read from parent: %s\\n\",",
          "1586:     __func__, strerror(errno));",
          "1587:    _exit(1);",
          "1588:   }",
          "1589:   if (vpid == -1) // done",
          "1590:    break;",
          "1591:   v = '0';",
          "1592:   cred.pid = vpid;",
          "1593:   if (send_creds(sock, &cred, v, true) != SEND_CREDS_OK) {",
          "1594:    v = '1';",
          "1595:    cred.pid = getpid();",
          "1596:    if (send_creds(sock, &cred, v, false) != SEND_CREDS_OK)",
          "1597:     _exit(1);",
          "1598:   }",
          "1599:  }",
          "1600:  _exit(0);",
          "1601: }",
          "1603: static void pid_from_ns_wrapper(int sock, pid_t tpid)",
          "1604: {",
          "1605:  int newnsfd = -1, ret, cpipe[2];",
          "1606:  char fnam[100];",
          "1607:  pid_t cpid;",
          "1608:  char v;",
          "1610:  ret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", tpid);",
          "1611:  if (ret < 0 || ret >= sizeof(fnam))",
          "1612:   _exit(1);",
          "1613:  newnsfd = open(fnam, O_RDONLY);",
          "1614:  if (newnsfd < 0)",
          "1615:   _exit(1);",
          "1616:  if (setns(newnsfd, 0) < 0)",
          "1617:   _exit(1);",
          "1618:  close(newnsfd);",
          "1620:  if (pipe(cpipe) < 0)",
          "1621:   _exit(1);",
          "1623: loop:",
          "1624:  cpid = fork();",
          "1626:  if (cpid < 0)",
          "1627:   _exit(1);",
          "1629:  if (!cpid) {",
          "1630:   char b = '1';",
          "1631:   close(cpipe[0]);",
          "1632:   if (write(cpipe[1], &b, sizeof(char)) < 0) {",
          "1633:    fprintf(stderr, \"%s (child): erorr on write: %s\\n\",",
          "1634:     __func__, strerror(errno));",
          "1635:   }",
          "1636:   close(cpipe[1]);",
          "1637:   pid_from_ns(sock, tpid);",
          "1638:  }",
          "1642:  if (!wait_for_sock(cpipe[0], 1))",
          "1643:   goto again;",
          "1644:  ret = read(cpipe[0], &v, 1);",
          "1645:  if (ret != sizeof(char) || v != '1') {",
          "1646:   goto again;",
          "1647:  }",
          "1649:  if (!wait_for_pid(cpid))",
          "1650:   _exit(1);",
          "1651:  _exit(0);",
          "1653: again:",
          "1654:  kill(cpid, SIGKILL);",
          "1655:  wait_for_pid(cpid);",
          "1656:  goto loop;",
          "1657: }",
          "1663: bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)",
          "1664: {",
          "1665:  FILE *f;",
          "1666:  char line[400];",
          "1668:  sprintf(line, \"/proc/%d/uid_map\", pid);",
          "1669:  if ((f = fopen(line, \"r\")) == NULL) {",
          "1670:   return false;",
          "1671:  }",
          "1674:  fclose(f);",
          "1676:  if (*answer == -1)",
          "1677:   return false;",
          "1678:  return true;",
          "1679: }",
          "1686: void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)",
          "1687: {",
          "1688:  char line[400];",
          "1689:  uid_t u;",
          "1690:  gid_t g;",
          "1691:  FILE *f;",
          "1695:  sprintf(line, \"/proc/%d/status\", pid);",
          "1696:  if ((f = fopen(line, \"r\")) == NULL) {",
          "1697:   fprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));",
          "1698:   return;",
          "1699:  }",
          "1700:  while (fgets(line, 400, f)) {",
          "1701:   if (strncmp(line, \"Uid:\", 4) == 0) {",
          "1702:    if (sscanf(line+4, \"%u\", &u) != 1) {",
          "1703:     fprintf(stderr, \"bad uid line for pid %u\\n\", pid);",
          "1704:     fclose(f);",
          "1705:     return;",
          "1706:    }",
          "1708:   } else if (strncmp(line, \"Gid:\", 4) == 0) {",
          "1709:    if (sscanf(line+4, \"%u\", &g) != 1) {",
          "1710:     fprintf(stderr, \"bad gid line for pid %u\\n\", pid);",
          "1711:     fclose(f);",
          "1712:     return;",
          "1713:    }",
          "1715:   }",
          "1716:  }",
          "1717:  fclose(f);",
          "1718: }",
          "1728: bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)",
          "1729: {",
          "1730:  uid_t v_uid, tmpuid;",
          "1731:  gid_t v_gid;",
          "1733:  if (r == v)",
          "1734:   return true;",
          "1735:  if (r_uid == 0)",
          "1736:   return true;",
          "1737:  get_pid_creds(v, &v_uid, &v_gid);",
          "1738:  if (r_uid == v_uid)",
          "1739:   return true;",
          "1740:  if (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0",
          "1741:    && hostuid_to_ns(v_uid, r, &tmpuid))",
          "1742:   return true;",
          "1743:  return false;",
          "1744: }",
          "1746: static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,",
          "1747:   const char *file, const char *buf)",
          "1748: {",
          "1749:  int sock[2] = {-1, -1};",
          "1750:  pid_t qpid, cpid = -1;",
          "1751:  FILE *pids_file = NULL;",
          "1752:  bool answer = false, fail = false;",
          "1754:  pids_file = open_pids_file(contrl, cg);",
          "1755:  if (!pids_file)",
          "1756:   return false;",
          "1762:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {",
          "1763:   perror(\"socketpair\");",
          "1764:   goto out;",
          "1765:  }",
          "1767:  cpid = fork();",
          "1768:  if (cpid == -1)",
          "1769:   goto out;",
          "1771:  if (!cpid) { // child",
          "1772:   fclose(pids_file);",
          "1773:   pid_from_ns_wrapper(sock[1], tpid);",
          "1774:  }",
          "1776:  const char *ptr = buf;",
          "1777:  while (sscanf(ptr, \"%d\", &qpid) == 1) {",
          "1778:   struct ucred cred;",
          "1779:   char v;",
          "1781:   if (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {",
          "1782:    fprintf(stderr, \"%s: error writing pid to child: %s\\n\",",
          "1783:     __func__, strerror(errno));",
          "1784:    goto out;",
          "1785:   }",
          "1787:   if (recv_creds(sock[0], &cred, &v)) {",
          "1788:    if (v == '0') {",
          "1789:     if (!may_move_pid(tpid, tuid, cred.pid)) {",
          "1790:      fail = true;",
          "1791:      break;",
          "1792:     }",
          "1793:     if (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)",
          "1794:      fail = true;",
          "1795:    }",
          "1796:   }",
          "1798:   ptr = strchr(ptr, '\\n');",
          "1799:   if (!ptr)",
          "1800:    break;",
          "1801:   ptr++;",
          "1802:  }",
          "1805:  qpid = -1;",
          "1806:  if (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))",
          "1807:   fprintf(stderr, \"Warning: failed to ask child to exit\\n\");",
          "1809:  if (!fail)",
          "1810:   answer = true;",
          "1812: out:",
          "1813:  if (cpid != -1)",
          "1814:   wait_for_pid(cpid);",
          "1815:  if (sock[0] != -1) {",
          "1816:   close(sock[0]);",
          "1817:   close(sock[1]);",
          "1818:  }",
          "1819:  if (pids_file) {",
          "1820:   if (fclose(pids_file) != 0)",
          "1821:    answer = false;",
          "1822:  }",
          "1823:  return answer;",
          "1824: }",
          "1826: int cg_write(const char *path, const char *buf, size_t size, off_t offset,",
          "1827:       struct fuse_file_info *fi)",
          "1828: {",
          "1829:  struct fuse_context *fc = fuse_get_context();",
          "1830:  char *localbuf = NULL;",
          "1831:  struct cgfs_files *k = NULL;",
          "1832:  struct file_info *f = (struct file_info *)fi->fh;",
          "1833:  bool r;",
          "1835:  if (f->type != LXC_TYPE_CGFILE) {",
          "1836:   fprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");",
          "1837:   return -EIO;",
          "1838:  }",
          "1840:  if (offset)",
          "1841:   return 0;",
          "1843:  if (!fc)",
          "1844:   return -EIO;",
          "1846:  localbuf = alloca(size+1);",
          "1847:  localbuf[size] = '\\0';",
          "1848:  memcpy(localbuf, buf, size);",
          "1850:  if ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {",
          "1851:   size = -EINVAL;",
          "1852:   goto out;",
          "1853:  }",
          "1855:  if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {",
          "1856:   size = -EACCES;",
          "1857:   goto out;",
          "1858:  }",
          "1860:  if (strcmp(f->file, \"tasks\") == 0 ||",
          "1861:    strcmp(f->file, \"/tasks\") == 0 ||",
          "1862:    strcmp(f->file, \"/cgroup.procs\") == 0 ||",
          "1863:    strcmp(f->file, \"cgroup.procs\") == 0)",
          "1865:   r = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);",
          "1866:  else",
          "1867:   r = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);",
          "1869:  if (!r)",
          "1870:   size = -EINVAL;",
          "1872: out:",
          "1873:  free_key(k);",
          "1874:  return size;",
          "1875: }",
          "1877: int cg_chown(const char *path, uid_t uid, gid_t gid)",
          "1878: {",
          "1879:  struct fuse_context *fc = fuse_get_context();",
          "1880:  char *cgdir = NULL, *last = NULL, *path1, *path2, *controller;",
          "1881:  struct cgfs_files *k = NULL;",
          "1882:  const char *cgroup;",
          "1883:  int ret;",
          "1885:  if (!fc)",
          "1886:   return -EIO;",
          "1888:  if (strcmp(path, \"/cgroup\") == 0)",
          "1889:   return -EINVAL;",
          "1891:  controller = pick_controller_from_path(fc, path);",
          "1892:  if (!controller)",
          "1893:   return -EINVAL;",
          "1894:  cgroup = find_cgroup_in_path(path);",
          "1895:  if (!cgroup)",
          "1897:   return -EINVAL;",
          "1899:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1901:  if (!last) {",
          "1902:   path1 = \"/\";",
          "1903:   path2 = cgdir;",
          "1904:  } else {",
          "1905:   path1 = cgdir;",
          "1906:   path2 = last;",
          "1907:  }",
          "1909:  if (is_child_cgroup(controller, path1, path2)) {",
          "1912:   k = cgfs_get_key(controller, cgroup, \"tasks\");",
          "1914:  } else",
          "1915:   k = cgfs_get_key(controller, path1, path2);",
          "1917:  if (!k) {",
          "1918:   ret = -EINVAL;",
          "1919:   goto out;",
          "1920:  }",
          "1928:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_REQD)) {",
          "1929:   ret = -EACCES;",
          "1930:   goto out;",
          "1931:  }",
          "1933:  ret = cgfs_chown_file(controller, cgroup, uid, gid);",
          "1935: out:",
          "1936:  free_key(k);",
          "1937:  free(cgdir);",
          "1939:  return ret;",
          "1940: }",
          "1942: int cg_chmod(const char *path, mode_t mode)",
          "1943: {",
          "1944:  struct fuse_context *fc = fuse_get_context();",
          "1945:  char * cgdir = NULL, *last = NULL, *path1, *path2, *controller;",
          "1946:  struct cgfs_files *k = NULL;",
          "1947:  const char *cgroup;",
          "1948:  int ret;",
          "1950:  if (!fc)",
          "1951:   return -EIO;",
          "1953:  if (strcmp(path, \"/cgroup\") == 0)",
          "1954:   return -EINVAL;",
          "1956:  controller = pick_controller_from_path(fc, path);",
          "1957:  if (!controller)",
          "1958:   return -EINVAL;",
          "1959:  cgroup = find_cgroup_in_path(path);",
          "1960:  if (!cgroup)",
          "1962:   return -EINVAL;",
          "1964:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "1966:  if (!last) {",
          "1967:   path1 = \"/\";",
          "1968:   path2 = cgdir;",
          "1969:  } else {",
          "1970:   path1 = cgdir;",
          "1971:   path2 = last;",
          "1972:  }",
          "1974:  if (is_child_cgroup(controller, path1, path2)) {",
          "1977:   k = cgfs_get_key(controller, cgroup, \"tasks\");",
          "1979:  } else",
          "1980:   k = cgfs_get_key(controller, path1, path2);",
          "1982:  if (!k) {",
          "1983:   ret = -EINVAL;",
          "1984:   goto out;",
          "1985:  }",
          "1993:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT)) {",
          "1994:   ret = -EPERM;",
          "1995:   goto out;",
          "1996:  }",
          "1998:  if (!cgfs_chmod_file(controller, cgroup, mode)) {",
          "1999:   ret = -EINVAL;",
          "2000:   goto out;",
          "2001:  }",
          "2003:  ret = 0;",
          "2004: out:",
          "2005:  free_key(k);",
          "2006:  free(cgdir);",
          "2007:  return ret;",
          "2008: }",
          "2010: int cg_mkdir(const char *path, mode_t mode)",
          "2011: {",
          "2012:  struct fuse_context *fc = fuse_get_context();",
          "2013:  char *last = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
          "2014:  const char *cgroup;",
          "2015:  int ret;",
          "2017:  if (!fc)",
          "2018:   return -EIO;",
          "2021:  controller = pick_controller_from_path(fc, path);",
          "2022:  if (!controller)",
          "2023:   return -EINVAL;",
          "2025:  cgroup = find_cgroup_in_path(path);",
          "2026:  if (!cgroup)",
          "2027:   return -EINVAL;",
          "2029:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "2030:  if (!last)",
          "2031:   path1 = \"/\";",
          "2032:  else",
          "2033:   path1 = cgdir;",
          "2035:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2036:  if (initpid <= 0)",
          "2037:   initpid = fc->pid;",
          "2038:  if (!caller_is_in_ancestor(initpid, controller, path1, &next)) {",
          "2039:   if (!next)",
          "2040:    ret = -EINVAL;",
          "2041:   else if (last && strcmp(next, last) == 0)",
          "2042:    ret = -EEXIST;",
          "2043:   else",
          "2044:    ret = -ENOENT;",
          "2045:   goto out;",
          "2046:  }",
          "2048:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {",
          "2049:   ret = -EACCES;",
          "2050:   goto out;",
          "2051:  }",
          "2052:  if (!caller_is_in_ancestor(initpid, controller, path1, NULL)) {",
          "2053:   ret = -EACCES;",
          "2054:   goto out;",
          "2055:  }",
          "2057:  ret = cgfs_create(controller, cgroup, fc->uid, fc->gid);",
          "2059: out:",
          "2060:  free(cgdir);",
          "2061:  free(next);",
          "2062:  return ret;",
          "2063: }",
          "2065: static int cg_rmdir(const char *path)",
          "2066: {",
          "2067:  struct fuse_context *fc = fuse_get_context();",
          "2068:  char *last = NULL, *cgdir = NULL, *controller, *next = NULL;",
          "2069:  const char *cgroup;",
          "2070:  int ret;",
          "2072:  if (!fc)",
          "2073:   return -EIO;",
          "2075:  controller = pick_controller_from_path(fc, path);",
          "2076:  if (!controller)",
          "2077:   return -EINVAL;",
          "2079:  cgroup = find_cgroup_in_path(path);",
          "2080:  if (!cgroup)",
          "2081:   return -EINVAL;",
          "2083:  get_cgdir_and_path(cgroup, &cgdir, &last);",
          "2084:  if (!last) {",
          "2085:   ret = -EINVAL;",
          "2086:   goto out;",
          "2087:  }",
          "2089:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2090:  if (initpid <= 0)",
          "2091:   initpid = fc->pid;",
          "2092:  if (!caller_is_in_ancestor(initpid, controller, cgroup, &next)) {",
          "2093:   if (!last || strcmp(next, last) == 0)",
          "2094:    ret = -EBUSY;",
          "2095:   else",
          "2096:    ret = -ENOENT;",
          "2097:   goto out;",
          "2098:  }",
          "2100:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {",
          "2101:   ret = -EACCES;",
          "2102:   goto out;",
          "2103:  }",
          "2104:  if (!caller_is_in_ancestor(initpid, controller, cgroup, NULL)) {",
          "2105:   ret = -EACCES;",
          "2106:   goto out;",
          "2107:  }",
          "2109:  if (!cgfs_remove(controller, cgroup)) {",
          "2110:   ret = -EINVAL;",
          "2111:   goto out;",
          "2112:  }",
          "2114:  ret = 0;",
          "2116: out:",
          "2117:  free(cgdir);",
          "2118:  free(next);",
          "2119:  return ret;",
          "2120: }",
          "2122: static bool startswith(const char *line, const char *pref)",
          "2123: {",
          "2124:  if (strncmp(line, pref, strlen(pref)) == 0)",
          "2125:   return true;",
          "2126:  return false;",
          "2127: }",
          "2129: static void get_mem_cached(char *memstat, unsigned long *v)",
          "2130: {",
          "2131:  char *eol;",
          "2134:  while (*memstat) {",
          "2135:   if (startswith(memstat, \"total_cache\")) {",
          "2136:    sscanf(memstat + 11, \"%lu\", v);",
          "2138:    return;",
          "2139:   }",
          "2140:   eol = strchr(memstat, '\\n');",
          "2141:   if (!eol)",
          "2142:    return;",
          "2143:   memstat = eol+1;",
          "2144:  }",
          "2145: }",
          "2147: static void get_blkio_io_value(char *str, unsigned major, unsigned minor, char *iotype, unsigned long *v)",
          "2148: {",
          "2149:  char *eol;",
          "2150:  char key[32];",
          "2152:  memset(key, 0, 32);",
          "2153:  snprintf(key, 32, \"%u:%u %s\", major, minor, iotype);",
          "2155:  size_t len = strlen(key);",
          "2158:  while (*str) {",
          "2159:   if (startswith(str, key)) {",
          "2160:    sscanf(str + len, \"%lu\", v);",
          "2161:    return;",
          "2162:   }",
          "2163:   eol = strchr(str, '\\n');",
          "2164:   if (!eol)",
          "2165:    return;",
          "2166:   str = eol+1;",
          "2167:  }",
          "2168: }",
          "2170: static int read_file(const char *path, char *buf, size_t size,",
          "2171:        struct file_info *d)",
          "2172: {",
          "2173:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2174:  char *line = NULL;",
          "2175:  char *cache = d->buf;",
          "2176:  size_t cache_size = d->buflen;",
          "2177:  FILE *f = fopen(path, \"r\");",
          "2178:  if (!f)",
          "2179:   return 0;",
          "2181:  while (getline(&line, &linelen, f) != -1) {",
          "2182:   size_t l = snprintf(cache, cache_size, \"%s\", line);",
          "2183:   if (l < 0) {",
          "2184:    perror(\"Error writing to cache\");",
          "2185:    rv = 0;",
          "2186:    goto err;",
          "2187:   }",
          "2188:   if (l >= cache_size) {",
          "2189:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2190:    rv = 0;",
          "2191:    goto err;",
          "2192:   }",
          "2193:   cache += l;",
          "2194:   cache_size -= l;",
          "2195:   total_len += l;",
          "2196:  }",
          "2198:  d->size = total_len;",
          "2199:  if (total_len > size ) total_len = size;",
          "2202:  memcpy(buf, d->buf, total_len);",
          "2203:  rv = total_len;",
          "2204:   err:",
          "2205:  fclose(f);",
          "2206:  free(line);",
          "2207:  return rv;",
          "2208: }",
          "2214: static unsigned long get_memlimit(const char *cgroup)",
          "2215: {",
          "2216:  char *memlimit_str = NULL;",
          "2217:  unsigned long memlimit = -1;",
          "2219:  if (cgfs_get_value(\"memory\", cgroup, \"memory.limit_in_bytes\", &memlimit_str))",
          "2220:   memlimit = strtoul(memlimit_str, NULL, 10);",
          "2222:  free(memlimit_str);",
          "2224:  return memlimit;",
          "2225: }",
          "2227: static unsigned long get_min_memlimit(const char *cgroup)",
          "2228: {",
          "2229:  char *copy = strdupa(cgroup);",
          "2230:  unsigned long memlimit = 0, retlimit;",
          "2232:  retlimit = get_memlimit(copy);",
          "2234:  while (strcmp(copy, \"/\") != 0) {",
          "2235:   copy = dirname(copy);",
          "2236:   memlimit = get_memlimit(copy);",
          "2237:   if (memlimit != -1 && memlimit < retlimit)",
          "2238:    retlimit = memlimit;",
          "2239:  };",
          "2241:  return retlimit;",
          "2242: }",
          "2244: static int proc_meminfo_read(char *buf, size_t size, off_t offset,",
          "2245:   struct fuse_file_info *fi)",
          "2247:  struct fuse_context *fc = fuse_get_context();",
          "2248:  struct file_info *d = (struct file_info *)fi->fh;",
          "2249:  char *cg;",
          "2250:  char *memusage_str = NULL, *memstat_str = NULL,",
          "2253:  unsigned long memlimit = 0, memusage = 0, memswlimit = 0, memswusage = 0,",
          "2254:   cached = 0, hosttotal = 0;",
          "2255:  char *line = NULL;",
          "2256:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2257:  char *cache = d->buf;",
          "2258:  size_t cache_size = d->buflen;",
          "2259:  FILE *f = NULL;",
          "2261:  if (offset){",
          "2262:   if (offset > d->size)",
          "2263:    return -EINVAL;",
          "2264:   if (!d->cached)",
          "2265:    return 0;",
          "2266:   int left = d->size - offset;",
          "2267:   total_len = left > size ? size: left;",
          "2268:   memcpy(buf, cache + offset, total_len);",
          "2269:   return total_len;",
          "2272:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2273:  if (initpid <= 0)",
          "2274:   initpid = fc->pid;",
          "2275:  cg = get_pid_cgroup(initpid, \"memory\");",
          "2276:  if (!cg)",
          "2277:   return read_file(\"/proc/meminfo\", buf, size, d);",
          "2279:  memlimit = get_min_memlimit(cg);",
          "2280:  if (!cgfs_get_value(\"memory\", cg, \"memory.usage_in_bytes\", &memusage_str))",
          "2281:   goto err;",
          "2282:  if (!cgfs_get_value(\"memory\", cg, \"memory.stat\", &memstat_str))",
          "2283:   goto err;",
          "2287:  if(cgfs_get_value(\"memory\", cg, \"memory.memsw.limit_in_bytes\", &memswlimit_str) &&",
          "2288:   cgfs_get_value(\"memory\", cg, \"memory.memsw.usage_in_bytes\", &memswusage_str))",
          "2289:  {",
          "2291:   if (!cgfs_get_value(\"memory\", \"/\", \"memory.memsw.limit_in_bytes\", &memswlimit_default_str))",
          "2292:    goto err;",
          "2293:   if (!cgfs_get_value(\"memory\", \"/\", \"memory.memsw.usage_in_bytes\", &memswusage_default_str))",
          "2294:    goto err;",
          "2296:   memswlimit = strtoul(memswlimit_str, NULL, 10);",
          "2297:   memswusage = strtoul(memswusage_str, NULL, 10);",
          "2299:   if (!strcmp(memswlimit_str, memswlimit_default_str))",
          "2300:    memswlimit = 0;",
          "2301:   if (!strcmp(memswusage_str, memswusage_default_str))",
          "2302:    memswusage = 0;",
          "2304:   memswlimit = memswlimit / 1024;",
          "2305:   memswusage = memswusage / 1024;",
          "2306:  }",
          "2308:  memusage = strtoul(memusage_str, NULL, 10);",
          "2309:  memlimit /= 1024;",
          "2310:  memusage /= 1024;",
          "2312:  get_mem_cached(memstat_str, &cached);",
          "2314:  f = fopen(\"/proc/meminfo\", \"r\");",
          "2315:  if (!f)",
          "2316:   goto err;",
          "2318:  while (getline(&line, &linelen, f) != -1) {",
          "2319:   size_t l;",
          "2320:   char *printme, lbuf[100];",
          "2322:   memset(lbuf, 0, 100);",
          "2323:   if (startswith(line, \"MemTotal:\")) {",
          "2324:    sscanf(line+14, \"%lu\", &hosttotal);",
          "2325:    if (hosttotal < memlimit)",
          "2326:     memlimit = hosttotal;",
          "2327:    snprintf(lbuf, 100, \"MemTotal:       %8lu kB\\n\", memlimit);",
          "2328:    printme = lbuf;",
          "2329:   } else if (startswith(line, \"MemFree:\")) {",
          "2330:    snprintf(lbuf, 100, \"MemFree:        %8lu kB\\n\", memlimit - memusage);",
          "2331:    printme = lbuf;",
          "2332:   } else if (startswith(line, \"MemAvailable:\")) {",
          "2333:    snprintf(lbuf, 100, \"MemAvailable:   %8lu kB\\n\", memlimit - memusage);",
          "2334:    printme = lbuf;",
          "2335:   } else if (startswith(line, \"SwapTotal:\") && memswlimit > 0) {",
          "2336:    snprintf(lbuf, 100, \"SwapTotal:      %8lu kB\\n\", memswlimit - memlimit);",
          "2337:    printme = lbuf;",
          "2338:   } else if (startswith(line, \"SwapFree:\") && memswlimit > 0 && memswusage > 0) {",
          "2339:    snprintf(lbuf, 100, \"SwapFree:       %8lu kB\\n\",",
          "2340:     (memswlimit - memlimit) - (memswusage - memusage));",
          "2341:    printme = lbuf;",
          "2342:   } else if (startswith(line, \"Buffers:\")) {",
          "2343:    snprintf(lbuf, 100, \"Buffers:        %8lu kB\\n\", 0UL);",
          "2344:    printme = lbuf;",
          "2345:   } else if (startswith(line, \"Cached:\")) {",
          "2346:    snprintf(lbuf, 100, \"Cached:         %8lu kB\\n\", cached);",
          "2347:    printme = lbuf;",
          "2348:   } else if (startswith(line, \"SwapCached:\")) {",
          "2349:    snprintf(lbuf, 100, \"SwapCached:     %8lu kB\\n\", 0UL);",
          "2350:    printme = lbuf;",
          "2351:   } else",
          "2352:    printme = line;",
          "2354:   l = snprintf(cache, cache_size, \"%s\", printme);",
          "2355:   if (l < 0) {",
          "2356:    perror(\"Error writing to cache\");",
          "2357:    rv = 0;",
          "2358:    goto err;",
          "2360:   }",
          "2361:   if (l >= cache_size) {",
          "2362:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2363:    rv = 0;",
          "2364:    goto err;",
          "2365:   }",
          "2367:   cache += l;",
          "2368:   cache_size -= l;",
          "2369:   total_len += l;",
          "2372:  d->cached = 1;",
          "2373:  d->size = total_len;",
          "2374:  if (total_len > size ) total_len = size;",
          "2375:  memcpy(buf, d->buf, total_len);",
          "2377:  rv = total_len;",
          "2378: err:",
          "2379:  if (f)",
          "2380:   fclose(f);",
          "2381:  free(line);",
          "2382:  free(cg);",
          "2383:  free(memusage_str);",
          "2384:  free(memswlimit_str);",
          "2385:  free(memswusage_str);",
          "2386:  free(memstat_str);",
          "2387:  free(memswlimit_default_str);",
          "2388:  free(memswusage_default_str);",
          "2389:  return rv;",
          "2396: static char *get_cpuset(const char *cg)",
          "2398:  char *answer;",
          "2400:  if (!cgfs_get_value(\"cpuset\", cg, \"cpuset.cpus\", &answer))",
          "2401:   return NULL;",
          "2402:  return answer;",
          "2405: bool cpu_in_cpuset(int cpu, const char *cpuset);",
          "2407: static bool cpuline_in_cpuset(const char *line, const char *cpuset)",
          "2409:  int cpu;",
          "2411:  if (sscanf(line, \"processor       : %d\", &cpu) != 1)",
          "2412:   return false;",
          "2413:  return cpu_in_cpuset(cpu, cpuset);",
          "2419: static bool is_processor_line(const char *line)",
          "2421:  int cpu;",
          "2423:  if (sscanf(line, \"processor       : %d\", &cpu) == 1)",
          "2424:   return true;",
          "2425:  return false;",
          "2428: static int proc_cpuinfo_read(char *buf, size_t size, off_t offset,",
          "2431:  struct fuse_context *fc = fuse_get_context();",
          "2432:  struct file_info *d = (struct file_info *)fi->fh;",
          "2433:  char *cg;",
          "2434:  char *cpuset = NULL;",
          "2435:  char *line = NULL;",
          "2436:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2437:  bool am_printing = false;",
          "2438:  int curcpu = -1;",
          "2439:  char *cache = d->buf;",
          "2440:  size_t cache_size = d->buflen;",
          "2441:  FILE *f = NULL;",
          "2443:  if (offset){",
          "2444:   if (offset > d->size)",
          "2445:    return -EINVAL;",
          "2446:   if (!d->cached)",
          "2447:    return 0;",
          "2448:   int left = d->size - offset;",
          "2449:   total_len = left > size ? size: left;",
          "2450:   memcpy(buf, cache + offset, total_len);",
          "2451:   return total_len;",
          "2452:  }",
          "2454:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2455:  if (initpid <= 0)",
          "2456:   initpid = fc->pid;",
          "2457:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "2458:  if (!cg)",
          "2459:   return read_file(\"proc/cpuinfo\", buf, size, d);",
          "2461:  cpuset = get_cpuset(cg);",
          "2462:  if (!cpuset)",
          "2463:   goto err;",
          "2465:  f = fopen(\"/proc/cpuinfo\", \"r\");",
          "2466:  if (!f)",
          "2467:   goto err;",
          "2469:  while (getline(&line, &linelen, f) != -1) {",
          "2470:   size_t l;",
          "2471:   if (is_processor_line(line)) {",
          "2472:    am_printing = cpuline_in_cpuset(line, cpuset);",
          "2473:    if (am_printing) {",
          "2474:     curcpu ++;",
          "2475:     l = snprintf(cache, cache_size, \"processor : %d\\n\", curcpu);",
          "2476:     if (l < 0) {",
          "2477:      perror(\"Error writing to cache\");",
          "2478:      rv = 0;",
          "2479:      goto err;",
          "2480:     }",
          "2481:     if (l >= cache_size) {",
          "2482:      fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2483:      rv = 0;",
          "2484:      goto err;",
          "2485:     }",
          "2486:     cache += l;",
          "2487:     cache_size -= l;",
          "2488:     total_len += l;",
          "2489:    }",
          "2490:    continue;",
          "2491:   }",
          "2492:   if (am_printing) {",
          "2493:    l = snprintf(cache, cache_size, \"%s\", line);",
          "2494:    if (l < 0) {",
          "2495:     perror(\"Error writing to cache\");",
          "2496:     rv = 0;",
          "2497:     goto err;",
          "2498:    }",
          "2499:    if (l >= cache_size) {",
          "2500:     fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2501:     rv = 0;",
          "2502:     goto err;",
          "2503:    }",
          "2504:    cache += l;",
          "2505:    cache_size -= l;",
          "2506:    total_len += l;",
          "2507:   }",
          "2510:  d->cached = 1;",
          "2511:  d->size = total_len;",
          "2512:  if (total_len > size ) total_len = size;",
          "2515:  memcpy(buf, d->buf, total_len);",
          "2516:  rv = total_len;",
          "2517: err:",
          "2518:  if (f)",
          "2519:   fclose(f);",
          "2520:  free(line);",
          "2521:  free(cpuset);",
          "2522:  free(cg);",
          "2523:  return rv;",
          "2526: static int proc_stat_read(char *buf, size_t size, off_t offset,",
          "2529:  struct fuse_context *fc = fuse_get_context();",
          "2530:  struct file_info *d = (struct file_info *)fi->fh;",
          "2531:  char *cg;",
          "2532:  char *cpuset = NULL;",
          "2533:  char *line = NULL;",
          "2534:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2536:  unsigned long user = 0, nice = 0, system = 0, idle = 0, iowait = 0, irq = 0, softirq = 0, steal = 0, guest = 0;",
          "2537:  unsigned long user_sum = 0, nice_sum = 0, system_sum = 0, idle_sum = 0, iowait_sum = 0,",
          "2538:      irq_sum = 0, softirq_sum = 0, steal_sum = 0, guest_sum = 0;",
          "2539: #define CPUALL_MAX_SIZE BUF_RESERVE_SIZE",
          "2540:  char cpuall[CPUALL_MAX_SIZE];",
          "2542:  char *cache = d->buf + CPUALL_MAX_SIZE;",
          "2543:  size_t cache_size = d->buflen - CPUALL_MAX_SIZE;",
          "2544:  FILE *f = NULL;",
          "2546:  if (offset){",
          "2547:   if (offset > d->size)",
          "2548:    return -EINVAL;",
          "2549:   if (!d->cached)",
          "2550:    return 0;",
          "2551:   int left = d->size - offset;",
          "2552:   total_len = left > size ? size: left;",
          "2553:   memcpy(buf, d->buf + offset, total_len);",
          "2554:   return total_len;",
          "2555:  }",
          "2557:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2558:  if (initpid <= 0)",
          "2559:   initpid = fc->pid;",
          "2560:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "2561:  if (!cg)",
          "2562:   return read_file(\"/proc/stat\", buf, size, d);",
          "2564:  cpuset = get_cpuset(cg);",
          "2565:  if (!cpuset)",
          "2566:   goto err;",
          "2568:  f = fopen(\"/proc/stat\", \"r\");",
          "2569:  if (!f)",
          "2570:   goto err;",
          "2573:  if (getline(&line, &linelen, f) < 0) {",
          "2574:   fprintf(stderr, \"proc_stat_read read first line failed\\n\");",
          "2575:   goto err;",
          "2578:  while (getline(&line, &linelen, f) != -1) {",
          "2579:   size_t l;",
          "2580:   int cpu;",
          "2582:   char *c;",
          "2584:   if (sscanf(line, \"cpu%9[^ ]\", cpu_char) != 1) {",
          "2586:    l = snprintf(cache, cache_size, \"%s\", line);",
          "2587:    if (l < 0) {",
          "2588:     perror(\"Error writing to cache\");",
          "2589:     rv = 0;",
          "2590:     goto err;",
          "2591:    }",
          "2592:    if (l >= cache_size) {",
          "2593:     fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2594:     rv = 0;",
          "2595:     goto err;",
          "2596:    }",
          "2597:    cache += l;",
          "2598:    cache_size -= l;",
          "2599:    total_len += l;",
          "2600:    continue;",
          "2601:   }",
          "2603:   if (sscanf(cpu_char, \"%d\", &cpu) != 1)",
          "2604:    continue;",
          "2605:   if (!cpu_in_cpuset(cpu, cpuset))",
          "2606:    continue;",
          "2607:   curcpu ++;",
          "2609:   c = strchr(line, ' ');",
          "2610:   if (!c)",
          "2611:    continue;",
          "2612:   l = snprintf(cache, cache_size, \"cpu%d%s\", curcpu, c);",
          "2613:   if (l < 0) {",
          "2614:    perror(\"Error writing to cache\");",
          "2615:    rv = 0;",
          "2616:    goto err;",
          "2618:   }",
          "2619:   if (l >= cache_size) {",
          "2620:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2621:    rv = 0;",
          "2622:    goto err;",
          "2623:   }",
          "2625:   cache += l;",
          "2626:   cache_size -= l;",
          "2627:   total_len += l;",
          "2629:   if (sscanf(line, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu\", &user, &nice, &system, &idle, &iowait, &irq,",
          "2630:    &softirq, &steal, &guest) != 9)",
          "2631:    continue;",
          "2632:   user_sum += user;",
          "2633:   nice_sum += nice;",
          "2634:   system_sum += system;",
          "2635:   idle_sum += idle;",
          "2636:   iowait_sum += iowait;",
          "2637:   irq_sum += irq;",
          "2638:   softirq_sum += softirq;",
          "2639:   steal_sum += steal;",
          "2640:   guest_sum += guest;",
          "2641:  }",
          "2643:  cache = d->buf;",
          "2645:  int cpuall_len = snprintf(cpuall, CPUALL_MAX_SIZE, \"%s %lu %lu %lu %lu %lu %lu %lu %lu %lu\\n\",",
          "2646:   \"cpu \", user_sum, nice_sum, system_sum, idle_sum, iowait_sum, irq_sum, softirq_sum, steal_sum, guest_sum);",
          "2647:  if (cpuall_len > 0 && cpuall_len < CPUALL_MAX_SIZE){",
          "2648:   memcpy(cache, cpuall, cpuall_len);",
          "2649:   cache += cpuall_len;",
          "2650:  } else{",
          "2652:   fprintf(stderr, \"proc_stat_read copy cpuall failed, cpuall_len=%d\\n\", cpuall_len);",
          "2653:   cpuall_len = 0;",
          "2656:  memmove(cache, d->buf + CPUALL_MAX_SIZE, total_len);",
          "2657:  total_len += cpuall_len;",
          "2658:  d->cached = 1;",
          "2659:  d->size = total_len;",
          "2660:  if (total_len > size ) total_len = size;",
          "2662:  memcpy(buf, d->buf, total_len);",
          "2663:  rv = total_len;",
          "2665: err:",
          "2666:  if (f)",
          "2667:   fclose(f);",
          "2668:  free(line);",
          "2669:  free(cpuset);",
          "2670:  free(cg);",
          "2671:  return rv;",
          "2674: static long int getreaperage(pid_t pid)",
          "2676:  char fnam[100];",
          "2677:  struct stat sb;",
          "2678:  int ret;",
          "2679:  pid_t qpid;",
          "2681:  qpid = lookup_initpid_in_store(pid);",
          "2682:  if (qpid <= 0)",
          "2683:   return 0;",
          "2685:  ret = snprintf(fnam, 100, \"/proc/%d\", qpid);",
          "2686:  if (ret < 0 || ret >= 100)",
          "2687:   return 0;",
          "2689:  if (lstat(fnam, &sb) < 0)",
          "2690:   return 0;",
          "2692:  return time(NULL) - sb.st_ctime;",
          "2695: static unsigned long get_reaper_busy(pid_t task)",
          "2697:  pid_t initpid = lookup_initpid_in_store(task);",
          "2698:  char *cgroup = NULL, *usage_str = NULL;",
          "2699:  unsigned long usage = 0;",
          "2701:  if (initpid <= 0)",
          "2702:   return 0;",
          "2704:  cgroup = get_pid_cgroup(initpid, \"cpuacct\");",
          "2705:  if (!cgroup)",
          "2706:   goto out;",
          "2707:  if (!cgfs_get_value(\"cpuacct\", cgroup, \"cpuacct.usage\", &usage_str))",
          "2708:   goto out;",
          "2709:  usage = strtoul(usage_str, NULL, 10);",
          "2710:  usage /= 1000000000;",
          "2712: out:",
          "2713:  free(cgroup);",
          "2714:  free(usage_str);",
          "2715:  return usage;",
          "2723: static int proc_uptime_read(char *buf, size_t size, off_t offset,",
          "2724:   struct fuse_file_info *fi)",
          "2726:  struct fuse_context *fc = fuse_get_context();",
          "2727:  struct file_info *d = (struct file_info *)fi->fh;",
          "2728:  long int reaperage = getreaperage(fc->pid);",
          "2729:  unsigned long int busytime = get_reaper_busy(fc->pid), idletime;",
          "2730:  char *cache = d->buf;",
          "2731:  size_t total_len = 0;",
          "2733:  if (offset){",
          "2734:   if (offset > d->size)",
          "2735:    return -EINVAL;",
          "2736:   if (!d->cached)",
          "2737:    return 0;",
          "2738:   int left = d->size - offset;",
          "2739:   total_len = left > size ? size: left;",
          "2740:   memcpy(buf, cache + offset, total_len);",
          "2741:   return total_len;",
          "2744:  idletime = reaperage - busytime;",
          "2745:  if (idletime > reaperage)",
          "2746:   idletime = reaperage;",
          "2748:  total_len = snprintf(d->buf, d->size, \"%ld.0 %lu.0\\n\", reaperage, idletime);",
          "2749:  if (total_len < 0){",
          "2750:   perror(\"Error writing to cache\");",
          "2751:   return 0;",
          "2754:  d->size = (int)total_len;",
          "2755:  d->cached = 1;",
          "2757:  if (total_len > size) total_len = size;",
          "2759:  memcpy(buf, d->buf, total_len);",
          "2760:  return total_len;",
          "2763: static int proc_diskstats_read(char *buf, size_t size, off_t offset,",
          "2766:  char dev_name[72];",
          "2767:  struct fuse_context *fc = fuse_get_context();",
          "2768:  struct file_info *d = (struct file_info *)fi->fh;",
          "2769:  char *cg;",
          "2770:  char *io_serviced_str = NULL, *io_merged_str = NULL, *io_service_bytes_str = NULL,",
          "2772:  unsigned long read = 0, write = 0;",
          "2773:  unsigned long read_merged = 0, write_merged = 0;",
          "2774:  unsigned long read_sectors = 0, write_sectors = 0;",
          "2775:  unsigned long read_ticks = 0, write_ticks = 0;",
          "2776:  unsigned long ios_pgr = 0, tot_ticks = 0, rq_ticks = 0;",
          "2777:  unsigned long rd_svctm = 0, wr_svctm = 0, rd_wait = 0, wr_wait = 0;",
          "2778:  char *cache = d->buf;",
          "2779:  size_t cache_size = d->buflen;",
          "2780:  char *line = NULL;",
          "2781:  size_t linelen = 0, total_len = 0, rv = 0;",
          "2782:  unsigned int major = 0, minor = 0;",
          "2783:  int i = 0;",
          "2784:  FILE *f = NULL;",
          "2786:  if (offset){",
          "2787:   if (offset > d->size)",
          "2788:    return -EINVAL;",
          "2789:   if (!d->cached)",
          "2790:    return 0;",
          "2791:   int left = d->size - offset;",
          "2792:   total_len = left > size ? size: left;",
          "2793:   memcpy(buf, cache + offset, total_len);",
          "2794:   return total_len;",
          "2797:  pid_t initpid = lookup_initpid_in_store(fc->pid);",
          "2798:  if (initpid <= 0)",
          "2799:   initpid = fc->pid;",
          "2800:  cg = get_pid_cgroup(initpid, \"blkio\");",
          "2801:  if (!cg)",
          "2802:   return read_file(\"/proc/diskstats\", buf, size, d);",
          "2804:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_serviced\", &io_serviced_str))",
          "2805:   goto err;",
          "2806:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_merged\", &io_merged_str))",
          "2807:   goto err;",
          "2808:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_service_bytes\", &io_service_bytes_str))",
          "2809:   goto err;",
          "2810:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_wait_time\", &io_wait_time_str))",
          "2811:   goto err;",
          "2812:  if (!cgfs_get_value(\"blkio\", cg, \"blkio.io_service_time\", &io_service_time_str))",
          "2813:   goto err;",
          "2816:  f = fopen(\"/proc/diskstats\", \"r\");",
          "2817:  if (!f)",
          "2818:   goto err;",
          "2820:  while (getline(&line, &linelen, f) != -1) {",
          "2821:   size_t l;",
          "2822:   char *printme, lbuf[256];",
          "2824:   i = sscanf(line, \"%u %u %71s\", &major, &minor, dev_name);",
          "2825:   if(i == 3){",
          "2826:    get_blkio_io_value(io_serviced_str, major, minor, \"Read\", &read);",
          "2827:    get_blkio_io_value(io_serviced_str, major, minor, \"Write\", &write);",
          "2828:    get_blkio_io_value(io_merged_str, major, minor, \"Read\", &read_merged);",
          "2829:    get_blkio_io_value(io_merged_str, major, minor, \"Write\", &write_merged);",
          "2830:    get_blkio_io_value(io_service_bytes_str, major, minor, \"Read\", &read_sectors);",
          "2831:    read_sectors = read_sectors/512;",
          "2832:    get_blkio_io_value(io_service_bytes_str, major, minor, \"Write\", &write_sectors);",
          "2833:    write_sectors = write_sectors/512;",
          "2835:    get_blkio_io_value(io_service_time_str, major, minor, \"Read\", &rd_svctm);",
          "2836:    rd_svctm = rd_svctm/1000000;",
          "2837:    get_blkio_io_value(io_wait_time_str, major, minor, \"Read\", &rd_wait);",
          "2838:    rd_wait = rd_wait/1000000;",
          "2839:    read_ticks = rd_svctm + rd_wait;",
          "2841:    get_blkio_io_value(io_service_time_str, major, minor, \"Write\", &wr_svctm);",
          "2842:    wr_svctm =  wr_svctm/1000000;",
          "2843:    get_blkio_io_value(io_wait_time_str, major, minor, \"Write\", &wr_wait);",
          "2844:    wr_wait =  wr_wait/1000000;",
          "2845:    write_ticks = wr_svctm + wr_wait;",
          "2847:    get_blkio_io_value(io_service_time_str, major, minor, \"Total\", &tot_ticks);",
          "2848:    tot_ticks =  tot_ticks/1000000;",
          "2849:   }else{",
          "2850:    continue;",
          "2851:   }",
          "2853:   memset(lbuf, 0, 256);",
          "2854:   if (read || write || read_merged || write_merged || read_sectors || write_sectors || read_ticks || write_ticks) {",
          "2855:    snprintf(lbuf, 256, \"%u       %u %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\\n\",",
          "2856:     major, minor, dev_name, read, read_merged, read_sectors, read_ticks,",
          "2857:     write, write_merged, write_sectors, write_ticks, ios_pgr, tot_ticks, rq_ticks);",
          "2858:    printme = lbuf;",
          "2859:   } else",
          "2860:    continue;",
          "2862:   l = snprintf(cache, cache_size, \"%s\", printme);",
          "2863:   if (l < 0) {",
          "2864:    perror(\"Error writing to fuse buf\");",
          "2865:    rv = 0;",
          "2866:    goto err;",
          "2867:   }",
          "2868:   if (l >= cache_size) {",
          "2869:    fprintf(stderr, \"Internal error: truncated write to cache\\n\");",
          "2870:    rv = 0;",
          "2871:    goto err;",
          "2872:   }",
          "2873:   cache += l;",
          "2874:   cache_size -= l;",
          "2875:   total_len += l;",
          "2878:  d->cached = 1;",
          "2879:  d->size = total_len;",
          "2880:  if (total_len > size ) total_len = size;",
          "2881:  memcpy(buf, d->buf, total_len);",
          "2883:  rv = total_len;",
          "2884: err:",
          "2885:  free(cg);",
          "2886:  if (f)",
          "2887:   fclose(f);",
          "2888:  free(line);",
          "2889:  free(io_serviced_str);",
          "2890:  free(io_merged_str);",
          "2891:  free(io_service_bytes_str);",
          "2892:  free(io_wait_time_str);",
          "2893:  free(io_service_time_str);",
          "2894:  return rv;",
          "2897: static off_t get_procfile_size(const char *which)",
          "2899:  FILE *f = fopen(which, \"r\");",
          "2900:  char *line = NULL;",
          "2901:  size_t len = 0;",
          "2902:  ssize_t sz, answer = 0;",
          "2903:  if (!f)",
          "2904:   return 0;",
          "2906:  while ((sz = getline(&line, &len, f)) != -1)",
          "2907:   answer += sz;",
          "2908:  fclose (f);",
          "2909:  free(line);",
          "2911:  return answer;",
          "2914: static int proc_getattr(const char *path, struct stat *sb)",
          "2916:  struct timespec now;",
          "2918:  memset(sb, 0, sizeof(struct stat));",
          "2919:  if (clock_gettime(CLOCK_REALTIME, &now) < 0)",
          "2920:   return -EINVAL;",
          "2921:  sb->st_uid = sb->st_gid = 0;",
          "2922:  sb->st_atim = sb->st_mtim = sb->st_ctim = now;",
          "2923:  if (strcmp(path, \"/proc\") == 0) {",
          "2924:   sb->st_mode = S_IFDIR | 00555;",
          "2925:   sb->st_nlink = 2;",
          "2926:   return 0;",
          "2927:  }",
          "2928:  if (strcmp(path, \"/proc/meminfo\") == 0 ||",
          "2929:    strcmp(path, \"/proc/cpuinfo\") == 0 ||",
          "2930:    strcmp(path, \"/proc/uptime\") == 0 ||",
          "2931:    strcmp(path, \"/proc/stat\") == 0 ||",
          "2932:    strcmp(path, \"/proc/diskstats\") == 0) {",
          "2933:   sb->st_size = 0;",
          "2934:   sb->st_mode = S_IFREG | 00444;",
          "2935:   sb->st_nlink = 1;",
          "2936:   return 0;",
          "2939:  return -ENOENT;",
          "2942: static int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "2943:   struct fuse_file_info *fi)",
          "2945:  if (filler(buf, \"cpuinfo\", NULL, 0) != 0 ||",
          "2946:     filler(buf, \"meminfo\", NULL, 0) != 0 ||",
          "2947:     filler(buf, \"stat\", NULL, 0) != 0 ||",
          "2948:     filler(buf, \"uptime\", NULL, 0) != 0 ||",
          "2949:     filler(buf, \"diskstats\", NULL, 0) != 0)",
          "2950:   return -EINVAL;",
          "2951:  return 0;",
          "2954: static int proc_open(const char *path, struct fuse_file_info *fi)",
          "2956:  int type = -1;",
          "2957:  struct file_info *info;",
          "2959:  if (strcmp(path, \"/proc/meminfo\") == 0)",
          "2960:   type = LXC_TYPE_PROC_MEMINFO;",
          "2961:  else if (strcmp(path, \"/proc/cpuinfo\") == 0)",
          "2962:   type = LXC_TYPE_PROC_CPUINFO;",
          "2963:  else if (strcmp(path, \"/proc/uptime\") == 0)",
          "2964:   type = LXC_TYPE_PROC_UPTIME;",
          "2965:  else if (strcmp(path, \"/proc/stat\") == 0)",
          "2966:   type = LXC_TYPE_PROC_STAT;",
          "2967:  else if (strcmp(path, \"/proc/diskstats\") == 0)",
          "2968:   type = LXC_TYPE_PROC_DISKSTATS;",
          "2969:  if (type == -1)",
          "2970:   return -ENOENT;",
          "2972:  info = malloc(sizeof(*info));",
          "2973:  if (!info)",
          "2974:   return -ENOMEM;",
          "2976:  memset(info, 0, sizeof(*info));",
          "2977:  info->type = type;",
          "2979:  info->buflen = get_procfile_size(path) + BUF_RESERVE_SIZE;",
          "2980:  do {",
          "2981:   info->buf = malloc(info->buflen);",
          "2982:  } while (!info->buf);",
          "2983:  memset(info->buf, 0, info->buflen);",
          "2985:  info->size = info->buflen;",
          "2987:  fi->fh = (unsigned long)info;",
          "2988:  return 0;",
          "2991: static int proc_release(const char *path, struct fuse_file_info *fi)",
          "2993:  struct file_info *f = (struct file_info *)fi->fh;",
          "2995:  do_release_file_info(f);",
          "2996:  return 0;",
          "2999: static int proc_read(const char *path, char *buf, size_t size, off_t offset,",
          "3000:   struct fuse_file_info *fi)",
          "3002:  struct file_info *f = (struct file_info *) fi->fh;",
          "3004:  switch (f->type) {",
          "3005:  case LXC_TYPE_PROC_MEMINFO:",
          "3006:   return proc_meminfo_read(buf, size, offset, fi);",
          "3007:  case LXC_TYPE_PROC_CPUINFO:",
          "3008:   return proc_cpuinfo_read(buf, size, offset, fi);",
          "3009:  case LXC_TYPE_PROC_UPTIME:",
          "3010:   return proc_uptime_read(buf, size, offset, fi);",
          "3011:  case LXC_TYPE_PROC_STAT:",
          "3012:   return proc_stat_read(buf, size, offset, fi);",
          "3013:  case LXC_TYPE_PROC_DISKSTATS:",
          "3014:   return proc_diskstats_read(buf, size, offset, fi);",
          "3015:  default:",
          "3016:   return -EINVAL;",
          "",
          "[Added Lines]",
          "55: static void unlock_mutex(pthread_mutex_t *l)",
          "57:  int ret;",
          "59:  if ((ret = pthread_mutex_unlock(l)) != 0) {",
          "60:   fprintf(stderr, \"pthread_mutex_unlock returned:%d %s\\n\", ret, strerror(ret));",
          "61:   exit(1);",
          "63: }",
          "65: static void users_lock(void)",
          "66: {",
          "67:  lock_mutex(&user_count_mutex);",
          "68: }",
          "70: static void users_unlock(void)",
          "71: {",
          "72:  unlock_mutex(&user_count_mutex);",
          "73: }",
          "75: static int need_reload;",
          "78: static void do_reload(void)",
          "79: {",
          "80:  if (dlopen_handle)",
          "81:   dlclose(dlopen_handle);",
          "83:  dlopen_handle = dlopen(\"liblxcfs.so\", RTLD_LAZY);",
          "84:  if (!dlopen_handle) {",
          "85:   fprintf(stderr, \"Failed to open liblxcfs\\n\");",
          "86:   _exit(1);",
          "88:  need_reload = 0;",
          "89:  fprintf(stderr, \"lxcfs: reloaded\\n\");",
          "92: static void up_users(void)",
          "94:  users_lock();",
          "95:  if (users_count == 0 && need_reload)",
          "96:   do_reload();",
          "97:  users_count++;",
          "98:  users_unlock();",
          "99: }",
          "101: static void down_users(void)",
          "102: {",
          "103:  users_lock();",
          "104:  users_count--;",
          "105:  users_unlock();",
          "108: static void reload_handler(int sig)",
          "109: {",
          "110:  fprintf(stderr, \"lxcfs: caught a SIGUSR1.  Reloading\\n\");",
          "111:  users_lock();",
          "112:  need_reload = 1;",
          "113:  users_unlock();",
          "114: }",
          "117: static int do_cg_getattr(const char *path, struct stat *sb)",
          "119:  int (*cg_getattr)(const char *path, struct stat *sb);",
          "120:  char *error;",
          "122:  cg_getattr = (int (*)(const char *, struct stat *)) dlsym(dlopen_handle, \"cg_getattr\");",
          "123:  error = dlerror();",
          "124:  if (error != NULL) {",
          "125:   fprintf(stderr, \"cg_getattr: %s\\n\", error);",
          "126:   return -1;",
          "127:  }",
          "129:  return cg_getattr(path, sb);",
          "132: static int do_proc_getattr(const char *path, struct stat *sb)",
          "134:  int (*proc_getattr)(const char *path, struct stat *sb);",
          "135:  char *error;",
          "137:  proc_getattr = (int (*)(const char *, struct stat *)) dlsym(dlopen_handle, \"proc_getattr\");",
          "138:  error = dlerror();",
          "139:  if (error != NULL) {",
          "140:   fprintf(stderr, \"proc_getattr: %s\\n\", error);",
          "141:   return -1;",
          "142:  }",
          "144:  return proc_getattr(path, sb);",
          "147: static int do_cg_read(const char *path, char *buf, size_t size, off_t offset,",
          "150:  int (*cg_read)(const char *path, char *buf, size_t size, off_t offset,",
          "151:   struct fuse_file_info *fi);",
          "152:  char *error;",
          "155:  cg_read = (int (*)(const char *, char *, size_t, off_t, struct fuse_file_info *)) dlsym(dlopen_handle, \"cg_read\");",
          "156:  error = dlerror();",
          "157:  if (error != NULL) {",
          "158:   fprintf(stderr, \"cg_read: %s\\n\", error);",
          "159:   return -1;",
          "162:  return cg_read(path, buf, size, offset, fi);",
          "165: static int do_proc_read(const char *path, char *buf, size_t size, off_t offset,",
          "168:  int (*proc_read)(const char *path, char *buf, size_t size, off_t offset,",
          "169:   struct fuse_file_info *fi);",
          "170:  char *error;",
          "173:  proc_read = (int (*)(const char *, char *, size_t, off_t, struct fuse_file_info *)) dlsym(dlopen_handle, \"proc_read\");",
          "174:  error = dlerror();",
          "175:  if (error != NULL) {",
          "176:   fprintf(stderr, \"proc_read: %s\\n\", error);",
          "177:   return -1;",
          "180:  return proc_read(path, buf, size, offset, fi);",
          "181: }",
          "183: static int do_cg_write(const char *path, const char *buf, size_t size, off_t offset,",
          "184:       struct fuse_file_info *fi)",
          "185: {",
          "186:  int (*cg_write)(const char *path, const char *buf, size_t size, off_t offset,",
          "187:       struct fuse_file_info *fi);",
          "188:  char *error;",
          "190:  cg_write = (int (*)(const char *, const char *, size_t, off_t, struct fuse_file_info *)) dlsym(dlopen_handle, \"cg_write\");",
          "191:  error = dlerror();",
          "192:  if (error != NULL) {",
          "193:   fprintf(stderr, \"cg_write: %s\\n\", error);",
          "194:   return -1;",
          "197:  return cg_write(path, buf, size, offset, fi);",
          "200: static int do_cg_mkdir(const char *path, mode_t mode)",
          "202:  int (*cg_mkdir)(const char *path, mode_t mode);",
          "203:  char *error;",
          "205:  cg_mkdir = (int (*)(const char *, mode_t)) dlsym(dlopen_handle, \"cg_mkdir\");",
          "206:  error = dlerror();",
          "207:  if (error != NULL) {",
          "208:   fprintf(stderr, \"cg_mkdir: %s\\n\", error);",
          "209:   return -1;",
          "210:  }",
          "212:  return cg_mkdir(path, mode);",
          "215: static int do_cg_chown(const char *path, uid_t uid, gid_t gid)",
          "217:  int (*cg_chown)(const char *path, uid_t uid, gid_t gid);",
          "218:  char *error;",
          "220:  cg_chown = (int (*)(const char *, uid_t, gid_t)) dlsym(dlopen_handle, \"cg_chown\");",
          "221:  error = dlerror();",
          "222:  if (error != NULL) {",
          "223:   fprintf(stderr, \"cg_chown: %s\\n\", error);",
          "224:   return -1;",
          "225:  }",
          "227:  return cg_chown(path, uid, gid);",
          "230: static int do_cg_rmdir(const char *path)",
          "232:  int (*cg_rmdir)(const char *path);",
          "233:  char *error;",
          "235:  cg_rmdir = (int (*)(const char *path)) dlsym(dlopen_handle, \"cg_rmdir\");",
          "236:  error = dlerror();",
          "237:  if (error != NULL) {",
          "238:   fprintf(stderr, \"cg_rmdir: %s\\n\", error);",
          "239:   return -1;",
          "242:  return cg_rmdir(path);",
          "243: }",
          "245: static int do_cg_chmod(const char *path, mode_t mode)",
          "246: {",
          "247:  int (*cg_chmod)(const char *path, mode_t mode);",
          "248:  char *error;",
          "250:  cg_chmod = (int (*)(const char *, mode_t)) dlsym(dlopen_handle, \"cg_chmod\");",
          "251:  error = dlerror();",
          "252:  if (error != NULL) {",
          "253:   fprintf(stderr, \"cg_chmod: %s\\n\", error);",
          "254:   return -1;",
          "257:  return cg_chmod(path, mode);",
          "260: static int do_cg_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "263:  int (*cg_readdir)(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "264:   struct fuse_file_info *fi);",
          "265:  char *error;",
          "268:  cg_readdir = (int (*)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *)) dlsym(dlopen_handle, \"cg_readdir\");",
          "269:  error = dlerror();",
          "270:  if (error != NULL) {",
          "271:   fprintf(stderr, \"cg_readdir: %s\\n\", error);",
          "272:   return -1;",
          "275:  return cg_readdir(path, buf, filler, offset, fi);",
          "276: }",
          "278: static int do_proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "279:   struct fuse_file_info *fi)",
          "280: {",
          "281:  int (*proc_readdir)(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "282:   struct fuse_file_info *fi);",
          "283:  char *error;",
          "286:  proc_readdir = (int (*)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *)) dlsym(dlopen_handle, \"proc_readdir\");",
          "287:  error = dlerror();",
          "288:  if (error != NULL) {",
          "289:   fprintf(stderr, \"proc_readdir: %s\\n\", error);",
          "290:   return -1;",
          "293:  return proc_readdir(path, buf, filler, offset, fi);",
          "296: static int do_cg_open(const char *path, struct fuse_file_info *fi)",
          "298:  int (*cg_open)(const char *path, struct fuse_file_info *fi);",
          "299:  char *error;",
          "301:  cg_open = (int (*)(const char *, struct fuse_file_info *)) dlsym(dlopen_handle, \"cg_open\");",
          "302:  error = dlerror();",
          "303:  if (error != NULL) {",
          "304:   fprintf(stderr, \"cg_open: %s\\n\", error);",
          "305:   return -1;",
          "306:  }",
          "308:  return cg_open(path, fi);",
          "311: static int do_proc_open(const char *path, struct fuse_file_info *fi)",
          "313:  int (*proc_open)(const char *path, struct fuse_file_info *fi);",
          "314:  char *error;",
          "316:  proc_open = (int (*)(const char *path, struct fuse_file_info *fi)) dlsym(dlopen_handle, \"proc_open\");",
          "317:  error = dlerror();",
          "318:  if (error != NULL) {",
          "319:   fprintf(stderr, \"proc_open: %s\\n\", error);",
          "320:   return -1;",
          "323:  return proc_open(path, fi);",
          "326: static int do_cg_release(const char *path, struct fuse_file_info *fi)",
          "328:  int (*cg_release)(const char *path, struct fuse_file_info *fi);",
          "329:  char *error;",
          "331:  cg_release = (int (*)(const char *path, struct fuse_file_info *)) dlsym(dlopen_handle, \"cg_release\");",
          "332:  error = dlerror();",
          "333:  if (error != NULL) {",
          "334:   fprintf(stderr, \"cg_release: %s\\n\", error);",
          "335:   return -1;",
          "336:  }",
          "338:  return cg_release(path, fi);",
          "341: static int do_proc_release(const char *path, struct fuse_file_info *fi)",
          "343:  int (*proc_release)(const char *path, struct fuse_file_info *fi);",
          "344:  char *error;",
          "346:  proc_release = (int (*)(const char *path, struct fuse_file_info *)) dlsym(dlopen_handle, \"proc_release\");",
          "347:  error = dlerror();",
          "348:  if (error != NULL) {",
          "349:   fprintf(stderr, \"proc_release: %s\\n\", error);",
          "350:   return -1;",
          "351:  }",
          "353:  return proc_release(path, fi);",
          "356: static int do_cg_opendir(const char *path, struct fuse_file_info *fi)",
          "358:  int (*cg_opendir)(const char *path, struct fuse_file_info *fi);",
          "359:  char *error;",
          "361:  cg_opendir = (int (*)(const char *path, struct fuse_file_info *fi)) dlsym(dlopen_handle, \"cg_opendir\");",
          "362:  error = dlerror();",
          "363:  if (error != NULL) {",
          "364:   fprintf(stderr, \"cg_opendir: %s\\n\", error);",
          "365:   return -1;",
          "366:  }",
          "368:  return cg_opendir(path, fi);",
          "371: static int do_cg_releasedir(const char *path, struct fuse_file_info *fi)",
          "373:  int (*cg_releasedir)(const char *path, struct fuse_file_info *fi);",
          "374:  char *error;",
          "376:  cg_releasedir = (int (*)(const char *path, struct fuse_file_info *)) dlsym(dlopen_handle, \"cg_releasedir\");",
          "377:  error = dlerror();",
          "378:  if (error != NULL) {",
          "379:   fprintf(stderr, \"cg_releasedir: %s\\n\", error);",
          "380:   return -1;",
          "383:  return cg_releasedir(path, fi);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3026: static int lxcfs_getattr(const char *path, struct stat *sb)",
          "3027: {",
          "3028:  if (strcmp(path, \"/\") == 0) {",
          "3029:   sb->st_mode = S_IFDIR | 00755;",
          "3030:   sb->st_nlink = 2;",
          "3031:   return 0;",
          "3032:  }",
          "3033:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "3035:  }",
          "3036:  if (strncmp(path, \"/proc\", 5) == 0) {",
          "3038:  }",
          "3039:  return -EINVAL;",
          "3040: }",
          "3042: static int lxcfs_opendir(const char *path, struct fuse_file_info *fi)",
          "3043: {",
          "3044:  if (strcmp(path, \"/\") == 0)",
          "3045:   return 0;",
          "3047:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "3049:  }",
          "3050:  if (strcmp(path, \"/proc\") == 0)",
          "3051:   return 0;",
          "",
          "[Removed Lines]",
          "3034:   return cg_getattr(path, sb);",
          "3037:   return proc_getattr(path, sb);",
          "3048:   return cg_opendir(path, fi);",
          "",
          "[Added Lines]",
          "394:  int ret;",
          "401:   up_users();",
          "402:   ret = do_cg_getattr(path, sb);",
          "403:   down_users();",
          "404:   return ret;",
          "407:   up_users();",
          "408:   ret = do_proc_getattr(path, sb);",
          "409:   down_users();",
          "410:   return ret;",
          "417:  int ret;",
          "422:   up_users();",
          "423:   ret = do_cg_opendir(path, fi);",
          "424:   down_users();",
          "425:   return ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3055: static int lxcfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "3056:   struct fuse_file_info *fi)",
          "3057: {",
          "3058:  if (strcmp(path, \"/\") == 0) {",
          "3059:   if (filler(buf, \"proc\", NULL, 0) != 0 ||",
          "3060:     filler(buf, \"cgroup\", NULL, 0) != 0)",
          "3061:    return -EINVAL;",
          "3062:   return 0;",
          "3063:  }",
          "3068:  return -EINVAL;",
          "3069: }",
          "3071: static int lxcfs_releasedir(const char *path, struct fuse_file_info *fi)",
          "3072: {",
          "3073:  if (strcmp(path, \"/\") == 0)",
          "3074:   return 0;",
          "3075:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "3077:  }",
          "3078:  if (strcmp(path, \"/proc\") == 0)",
          "3079:   return 0;",
          "",
          "[Removed Lines]",
          "3064:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3065:   return cg_readdir(path, buf, filler, offset, fi);",
          "3066:  if (strcmp(path, \"/proc\") == 0)",
          "3067:   return proc_readdir(path, buf, filler, offset, fi);",
          "3076:   return cg_releasedir(path, fi);",
          "",
          "[Added Lines]",
          "435:  int ret;",
          "442:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "443:   up_users();",
          "444:   ret = do_cg_readdir(path, buf, filler, offset, fi);",
          "445:   down_users();",
          "446:   return ret;",
          "447:  }",
          "448:  if (strcmp(path, \"/proc\") == 0) {",
          "449:   up_users();",
          "450:   ret = do_proc_readdir(path, buf, filler, offset, fi);",
          "451:   down_users();",
          "452:   return ret;",
          "453:  }",
          "459:  int ret;",
          "463:   up_users();",
          "464:   ret = do_cg_releasedir(path, fi);",
          "465:   down_users();",
          "466:   return ret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3083: static int lxcfs_open(const char *path, struct fuse_file_info *fi)",
          "3084: {",
          "3090:  return -EINVAL;",
          "3091: }",
          "",
          "[Removed Lines]",
          "3085:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3086:   return cg_open(path, fi);",
          "3087:  if (strncmp(path, \"/proc\", 5) == 0)",
          "3088:   return proc_open(path, fi);",
          "",
          "[Added Lines]",
          "475:  int ret;",
          "476:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "477:   up_users();",
          "478:   ret = do_cg_open(path, fi);",
          "479:   down_users();",
          "480:   return ret;",
          "481:  }",
          "482:  if (strncmp(path, \"/proc\", 5) == 0) {",
          "483:   up_users();",
          "484:   ret = do_proc_open(path, fi);",
          "485:   down_users();",
          "486:   return ret;",
          "487:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3093: static int lxcfs_read(const char *path, char *buf, size_t size, off_t offset,",
          "3094:   struct fuse_file_info *fi)",
          "3095: {",
          "3101:  return -EINVAL;",
          "3102: }",
          "",
          "[Removed Lines]",
          "3096:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3097:   return cg_read(path, buf, size, offset, fi);",
          "3098:  if (strncmp(path, \"/proc\", 5) == 0)",
          "3099:   return proc_read(path, buf, size, offset, fi);",
          "",
          "[Added Lines]",
          "495:  int ret;",
          "496:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "497:   up_users();",
          "498:   ret = do_cg_read(path, buf, size, offset, fi);",
          "499:   down_users();",
          "500:   return ret;",
          "501:  }",
          "502:  if (strncmp(path, \"/proc\", 5) == 0) {",
          "503:   up_users();",
          "504:   ret = do_proc_read(path, buf, size, offset, fi);",
          "505:   down_users();",
          "506:   return ret;",
          "507:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3104: int lxcfs_write(const char *path, const char *buf, size_t size, off_t offset,",
          "3105:       struct fuse_file_info *fi)",
          "3106: {",
          "3107:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "3109:  }",
          "3111:  return -EINVAL;",
          "",
          "[Removed Lines]",
          "3108:   return cg_write(path, buf, size, offset, fi);",
          "",
          "[Added Lines]",
          "515:  int ret;",
          "517:   up_users();",
          "518:   ret = do_cg_write(path, buf, size, offset, fi);",
          "519:   down_users();",
          "520:   return ret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3119: static int lxcfs_release(const char *path, struct fuse_file_info *fi)",
          "3120: {",
          "3126:  return -EINVAL;",
          "3127: }",
          "",
          "[Removed Lines]",
          "3121:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3122:   return cg_release(path, fi);",
          "3123:  if (strncmp(path, \"/proc\", 5) == 0)",
          "3124:   return proc_release(path, fi);",
          "",
          "[Added Lines]",
          "533:  int ret;",
          "534:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "535:   up_users();",
          "536:   ret = do_cg_release(path, fi);",
          "537:   down_users();",
          "538:   return ret;",
          "539:  }",
          "540:  if (strncmp(path, \"/proc\", 5) == 0) {",
          "541:   up_users();",
          "542:   ret = do_proc_release(path, fi);",
          "543:   down_users();",
          "544:   return ret;",
          "545:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3134: int lxcfs_mkdir(const char *path, mode_t mode)",
          "3135: {",
          "3139:  return -EINVAL;",
          "3140: }",
          "3142: int lxcfs_chown(const char *path, uid_t uid, gid_t gid)",
          "3143: {",
          "3147:  return -EINVAL;",
          "3148: }",
          "",
          "[Removed Lines]",
          "3136:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3137:   return cg_mkdir(path, mode);",
          "3144:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3145:   return cg_chown(path, uid, gid);",
          "",
          "[Added Lines]",
          "557:  int ret;",
          "558:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "559:   up_users();",
          "560:   ret = do_cg_mkdir(path, mode);",
          "561:   down_users();",
          "562:   return ret;",
          "563:  }",
          "570:  int ret;",
          "571:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "572:   up_users();",
          "573:   ret = do_cg_chown(path, uid, gid);",
          "574:   down_users();",
          "575:   return ret;",
          "576:  }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3162: int lxcfs_rmdir(const char *path)",
          "3163: {",
          "3166:  return -EINVAL;",
          "3167: }",
          "3169: int lxcfs_chmod(const char *path, mode_t mode)",
          "3170: {",
          "3173:  return -EINVAL;",
          "3174: }",
          "",
          "[Removed Lines]",
          "3164:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3165:   return cg_rmdir(path);",
          "3171:  if (strncmp(path, \"/cgroup\", 7) == 0)",
          "3172:   return cg_chmod(path, mode);",
          "",
          "[Added Lines]",
          "595:  int ret;",
          "596:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "597:   up_users();",
          "598:   ret = do_cg_rmdir(path);",
          "599:   down_users();",
          "600:   return ret;",
          "601:  }",
          "607:  int ret;",
          "608:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "609:   up_users();",
          "610:   ret = do_cg_chmod(path, mode);",
          "611:   down_users();",
          "612:   return ret;",
          "613:  }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3271:  }",
          "3272: }",
          "3274: int main(int argc, char *argv[])",
          "3275: {",
          "3276:  int ret = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "715: static bool mkdir_p(const char *dir, mode_t mode)",
          "716: {",
          "717:  const char *tmp = dir;",
          "718:  const char *orig = dir;",
          "719:  char *makeme;",
          "721:  do {",
          "722:   dir = tmp + strspn(tmp, \"/\");",
          "723:   tmp = dir + strcspn(dir, \"/\");",
          "724:   makeme = strndup(orig, dir - orig);",
          "725:   if (!makeme)",
          "726:    return false;",
          "727:   if (mkdir(makeme, mode) && errno != EEXIST) {",
          "728:    fprintf(stderr, \"failed to create directory '%s': %s\",",
          "729:     makeme, strerror(errno));",
          "730:    free(makeme);",
          "731:    return false;",
          "732:   }",
          "733:   free(makeme);",
          "734:  } while(tmp != dir);",
          "736:  return true;",
          "737: }",
          "739: static bool umount_if_mounted(void)",
          "740: {",
          "741:  if (umount2(basedir, MNT_DETACH) < 0 && errno != EINVAL) {",
          "742:   fprintf(stderr, \"failed to umount %s: %s\\n\", basedir,",
          "743:    strerror(errno));",
          "744:   return false;",
          "745:  }",
          "746:  return true;",
          "747: }",
          "749: static bool setup_cgfs_dir(void)",
          "750: {",
          "751:  if (!mkdir_p(basedir, 0700)) {",
          "752:   fprintf(stderr, \"Failed to create lxcfs cgdir\\n\");",
          "753:   return false;",
          "754:  }",
          "755:  if (!umount_if_mounted()) {",
          "756:   fprintf(stderr, \"Failed to clean up old lxcfs cgdir\\n\");",
          "757:   return false;",
          "758:  }",
          "759:  if (mount(\"tmpfs\", basedir, \"tmpfs\", 0, \"size=100000,mode=700\") < 0) {",
          "760:   fprintf(stderr, \"Failed to mount tmpfs for private controllers\\n\");",
          "761:   return false;",
          "762:  }",
          "763:  return true;",
          "764: }",
          "766: static bool do_mount_cgroup(char *controller)",
          "767: {",
          "768:  char *target;",
          "769:  size_t len;",
          "770:  int ret;",
          "772:  len = strlen(basedir) + strlen(controller) + 2;",
          "773:  target = alloca(len);",
          "774:  ret = snprintf(target, len, \"%s/%s\", basedir, controller);",
          "775:  if (ret < 0 || ret >= len)",
          "776:   return false;",
          "777:  if (mkdir(target, 0755) < 0 && errno != EEXIST)",
          "778:   return false;",
          "779:  if (mount(controller, target, \"cgroup\", 0, controller) < 0) {",
          "780:   fprintf(stderr, \"Failed mounting cgroup %s\\n\", controller);",
          "781:   return false;",
          "782:  }",
          "783:  return true;",
          "784: }",
          "786: static bool do_mount_cgroups(void)",
          "787: {",
          "788:  bool ret;",
          "789:  FILE *f;",
          "790:  char *line = NULL;",
          "791:  size_t len = 0;",
          "793:  if ((f = fopen(\"/proc/self/cgroup\", \"r\")) == NULL) {",
          "794:   fprintf(stderr, \"Error opening /proc/self/cgroup: %s\\n\", strerror(errno));",
          "795:   return false;",
          "796:  }",
          "798:  while (getline(&line, &len, f) != -1) {",
          "799:   char *p, *p2;",
          "801:   p = strchr(line, ':');",
          "802:   if (!p)",
          "803:    goto out;",
          "806:   p2 = strrchr(p, ':');",
          "807:   if (!p2)",
          "808:    goto out;",
          "811:   if (!do_mount_cgroup(p))",
          "812:    goto out;",
          "813:  }",
          "814:  ret = true;",
          "816: out:",
          "817:  free(line);",
          "818:  fclose(f);",
          "819:  return ret;",
          "820: }",
          "822: static bool cgfs_setup_controllers(void)",
          "823: {",
          "824:  if (!setup_cgfs_dir()) {",
          "825:   return false;",
          "826:  }",
          "828:  if (!do_mount_cgroups()) {",
          "829:   fprintf(stderr, \"Failed to set up cgroup mounts\\n\");",
          "830:   return false;",
          "831:  }",
          "833:  return true;",
          "834: }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3281:  int nargs = 5, cnt = 0;",
          "3282:  char *newargv[6];",
          "3284: #ifdef FORTRAVIS",
          "3286:  if (glib_check_version (2, 36, 0) != NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "846:  dlopen_handle = dlopen(\"liblxcfs.so\", RTLD_LAZY);",
          "847:  if (!dlopen_handle) {",
          "848:   fprintf(stderr, \"Failed to open liblxcfs\\n\");",
          "849:   exit(1);",
          "850:  }",
          "851:  signal(SIGUSR1, reload_handler);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3312:  ret = fuse_main(nargs, newargv, &lxcfs_ops, NULL);",
          "3314: out:",
          "3315:  return ret;",
          "3316: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "882:  dlclose(dlopen_handle);",
          "",
          "---------------"
        ],
        "tests/main.sh||tests/main.sh": [
          "File: tests/main.sh -> tests/main.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: RUNTEST ${dirname}/cpusetrange",
          "71: TESTCASE=\"meminfo hierarchy\"",
          "72: RUNTEST ${dirname}/test_meminfo_hierarchy.sh",
          "74: # Check for any defunct processes - children we didn't reap",
          "75: n=`ps -ef | grep lxcfs | grep defunct | wc -l`",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: TESTCASE=\"liblxcfs reloading\"",
          "74: ${dirname}/test_reload.sh",
          "",
          "---------------"
        ],
        "tests/test_reload.sh||tests/test_reload.sh": [
          "File: tests/test_reload.sh -> tests/test_reload.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/bin/bash",
          "3: set -ex",
          "5: [ $(id -u) -eq 0 ]",
          "7: cmdline=$(realpath $0)",
          "8: dirname=$(dirname ${cmdline})",
          "9: topdir=$(dirname ${dirname})",
          "11: testdir=`mktemp -t -d libs.XXX`",
          "12: installdir=`mktemp -t -d libs.XXX`",
          "13: libdir=${installdir}/usr/lib",
          "14: bindir=${installdir}/usr/bin",
          "15: lxcfspid=-1",
          "16: FAILED=1",
          "18: cleanup() {",
          "19:   if [ ${lxcfspid} -ne -1 ]; then",
          "20:     kill -9 ${lxcfspid}",
          "21:     count=1",
          "22:     while [ -d ${testdir}/proc -a $count -lt 5 ]; do",
          "23:       sleep 1",
          "24:     done",
          "25:     umount -l ${testdir}",
          "26:   fi",
          "27:   rm -rf ${testdir} ${installdir}",
          "28:   rm -f iwashere",
          "29:   if [ ${FAILED} -eq 1 ]; then",
          "30:     echo \"liblxcfs.so reload test FAILED\"",
          "31:   else",
          "32:     echo \"liblxcfs.so reload test PASSED\"",
          "33:   fi",
          "34: }",
          "36: trap cleanup EXIT SIGHUP SIGINT SIGTERM",
          "38: ( cd ${topdir}; DESTDIR=${installdir} make install )",
          "39: export LD_LIBRARY_PATH=${libdir}",
          "41: ${bindir}/lxcfs ${testdir} &",
          "42: lxcfspid=$!",
          "43: count=1",
          "44: while [ ! -d ${testdir}/proc ]; do",
          "45:   [ $count -lt 5 ]",
          "46:   sleep 1",
          "47: done",
          "49: rm -f iwashere",
          "50: cat ${testdir}/proc/uptime",
          "51: [ ! -f iwashere ]",
          "52: rm -f ${libdir}/liblxcfs.so* ${libdir}/liblxcfs.la",
          "53: ln -s liblxcfstest.so.0.0.0 ${libdir}/liblxcfs.so",
          "54: cp ${libdir}/liblxcfstest.la ${libdir}/liblxcfs.la",
          "56: kill -USR1 ${lxcfspid}",
          "58: cat ${testdir}/proc/uptime",
          "59: [ -f iwashere ]",
          "60: FAILED=0",
          "",
          "---------------"
        ]
      }
    }
  ]
}
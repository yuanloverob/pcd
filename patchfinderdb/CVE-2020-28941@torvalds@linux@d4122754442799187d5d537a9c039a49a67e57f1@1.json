{
  "cve_id": "CVE-2020-28941",
  "cve_desc": "An issue was discovered in drivers/accessibility/speakup/spk_ttyio.c in the Linux kernel through 5.9.9. Local attackers on systems with the speakup driver could cause a local denial of service attack, aka CID-d41227544427. This occurs because of an invalid free when the line discipline is used more than once.",
  "repo": "torvalds/linux",
  "patch_hash": "d4122754442799187d5d537a9c039a49a67e57f1",
  "patch_info": {
    "commit_hash": "d4122754442799187d5d537a9c039a49a67e57f1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d4122754442799187d5d537a9c039a49a67e57f1",
    "files": [
      "drivers/accessibility/speakup/spk_ttyio.c"
    ],
    "message": "speakup: Do not let the line discipline be used several times\n\nSpeakup has only one speakup_tty variable to store the tty it is managing. This\nmakes sense since its codebase currently assumes that there is only one user who\ncontrols the screen reading.\n\nThat however means that we have to forbid using the line discipline several\ntimes, otherwise the second closure would try to free a NULL ldisc_data, leading to\n\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nRIP: 0010:spk_ttyio_ldisc_close+0x2c/0x60\nCall Trace:\n tty_ldisc_release+0xa2/0x340\n tty_release_struct+0x17/0xd0\n tty_release+0x9d9/0xcc0\n __fput+0x231/0x740\n task_work_run+0x12c/0x1a0\n do_exit+0x9b5/0x2230\n ? release_task+0x1240/0x1240\n ? __do_page_fault+0x562/0xa30\n do_group_exit+0xd5/0x2a0\n __x64_sys_exit_group+0x35/0x40\n do_syscall_64+0x89/0x2b0\n ? page_fault+0x8/0x30\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nCc: stable@vger.kernel.org\nReported-by: \u79e6\u4e16\u677e <qinshisong1205@gmail.com>\nSigned-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>\nTested-by: Shisong Qin <qinshisong1205@gmail.com>\nLink: https://lore.kernel.org/r/20201110183541.fzgnlwhjpgqzjeth@function\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/accessibility/speakup/spk_ttyio.c||drivers/accessibility/speakup/spk_ttyio.c"
    ]
  },
  "patch_diff": {
    "drivers/accessibility/speakup/spk_ttyio.c||drivers/accessibility/speakup/spk_ttyio.c": [
      "File: drivers/accessibility/speakup/spk_ttyio.c -> drivers/accessibility/speakup/spk_ttyio.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "50:  if (!tty->ops->write)",
      "51:   return -EOPNOTSUPP;",
      "52:  speakup_tty = tty;",
      "54:  ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);",
      "56:   return -ENOMEM;",
      "58:  init_completion(&ldisc_data->completion);",
      "59:  ldisc_data->buf_free = true;",
      "60:  speakup_tty->disc_data = ldisc_data;",
      "62:  return 0;",
      "63: }",
      "",
      "[Removed Lines]",
      "55:  if (!ldisc_data)",
      "",
      "[Added Lines]",
      "53:  mutex_lock(&speakup_tty_mutex);",
      "54:  if (speakup_tty) {",
      "55:   mutex_unlock(&speakup_tty_mutex);",
      "56:   return -EBUSY;",
      "57:  }",
      "61:  if (!ldisc_data) {",
      "62:   speakup_tty = NULL;",
      "63:   mutex_unlock(&speakup_tty_mutex);",
      "65:  }",
      "70:  mutex_unlock(&speakup_tty_mutex);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4add4d988f95f47493500a7a19c623827061589b",
      "candidate_info": {
        "commit_hash": "4add4d988f95f47493500a7a19c623827061589b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4add4d988f95f47493500a7a19c623827061589b",
        "files": [
          "drivers/net/wireless/marvell/mwifiex/pcie.c",
          "drivers/net/wireless/marvell/mwifiex/pcie.h"
        ],
        "message": "mwifiex: pcie: skip cancel_work_sync() on reset failure path\n\nIf a reset is performed, but even the reset fails for some reasons (e.g.,\non Surface devices, the fw reset requires another quirks),\ncancel_work_sync() hangs in mwifiex_cleanup_pcie().\n\n    # firmware went into a bad state\n    [...]\n    [ 1608.281690] mwifiex_pcie 0000:03:00.0: info: shutdown mwifiex...\n    [ 1608.282724] mwifiex_pcie 0000:03:00.0: rx_pending=0, tx_pending=1,\tcmd_pending=0\n    [ 1608.292400] mwifiex_pcie 0000:03:00.0: PREP_CMD: card is removed\n    [ 1608.292405] mwifiex_pcie 0000:03:00.0: PREP_CMD: card is removed\n    # reset performed after firmware went into a bad state\n    [ 1609.394320] mwifiex_pcie 0000:03:00.0: WLAN FW already running! Skip FW dnld\n    [ 1609.394335] mwifiex_pcie 0000:03:00.0: WLAN FW is active\n    # but even the reset failed\n    [ 1619.499049] mwifiex_pcie 0000:03:00.0: mwifiex_cmd_timeout_func: Timeout cmd id = 0xfa, act = 0xe000\n    [ 1619.499094] mwifiex_pcie 0000:03:00.0: num_data_h2c_failure = 0\n    [ 1619.499103] mwifiex_pcie 0000:03:00.0: num_cmd_h2c_failure = 0\n    [ 1619.499110] mwifiex_pcie 0000:03:00.0: is_cmd_timedout = 1\n    [ 1619.499117] mwifiex_pcie 0000:03:00.0: num_tx_timeout = 0\n    [ 1619.499124] mwifiex_pcie 0000:03:00.0: last_cmd_index = 0\n    [ 1619.499133] mwifiex_pcie 0000:03:00.0: last_cmd_id: fa 00 07 01 07 01 07 01 07 01\n    [ 1619.499140] mwifiex_pcie 0000:03:00.0: last_cmd_act: 00 e0 00 00 00 00 00 00 00 00\n    [ 1619.499147] mwifiex_pcie 0000:03:00.0: last_cmd_resp_index = 3\n    [ 1619.499155] mwifiex_pcie 0000:03:00.0: last_cmd_resp_id: 07 81 07 81 07 81 07 81 07 81\n    [ 1619.499162] mwifiex_pcie 0000:03:00.0: last_event_index = 2\n    [ 1619.499169] mwifiex_pcie 0000:03:00.0: last_event: 58 00 58 00 58 00 58 00 58 00\n    [ 1619.499177] mwifiex_pcie 0000:03:00.0: data_sent=0 cmd_sent=1\n    [ 1619.499185] mwifiex_pcie 0000:03:00.0: ps_mode=0 ps_state=0\n    [ 1619.499215] mwifiex_pcie 0000:03:00.0: info: _mwifiex_fw_dpc: unregister device\n    # mwifiex_pcie_work hang happening\n    [ 1823.233923] INFO: task kworker/3:1:44 blocked for more than 122 seconds.\n    [ 1823.233932]       Tainted: G        WC OE     5.10.0-rc1-1-mainline #1\n    [ 1823.233935] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n    [ 1823.233940] task:kworker/3:1     state:D stack:    0 pid:   44 ppid:     2 flags:0x00004000\n    [ 1823.233960] Workqueue: events mwifiex_pcie_work [mwifiex_pcie]\n    [ 1823.233965] Call Trace:\n    [ 1823.233981]  __schedule+0x292/0x820\n    [ 1823.233990]  schedule+0x45/0xe0\n    [ 1823.233995]  schedule_timeout+0x11c/0x160\n    [ 1823.234003]  wait_for_completion+0x9e/0x100\n    [ 1823.234012]  __flush_work.isra.0+0x156/0x210\n    [ 1823.234018]  ? flush_workqueue_prep_pwqs+0x130/0x130\n    [ 1823.234026]  __cancel_work_timer+0x11e/0x1a0\n    [ 1823.234035]  mwifiex_cleanup_pcie+0x28/0xd0 [mwifiex_pcie]\n    [ 1823.234049]  mwifiex_free_adapter+0x24/0xe0 [mwifiex]\n    [ 1823.234060]  _mwifiex_fw_dpc+0x294/0x560 [mwifiex]\n    [ 1823.234074]  mwifiex_reinit_sw+0x15d/0x300 [mwifiex]\n    [ 1823.234080]  mwifiex_pcie_reset_done+0x50/0x80 [mwifiex_pcie]\n    [ 1823.234087]  pci_try_reset_function+0x5c/0x90\n    [ 1823.234094]  process_one_work+0x1d6/0x3a0\n    [ 1823.234100]  worker_thread+0x4d/0x3d0\n    [ 1823.234107]  ? rescuer_thread+0x410/0x410\n    [ 1823.234112]  kthread+0x142/0x160\n    [ 1823.234117]  ? __kthread_bind_mask+0x60/0x60\n    [ 1823.234124]  ret_from_fork+0x22/0x30\n    [...]\n\nThis is a deadlock caused by calling cancel_work_sync() in\nmwifiex_cleanup_pcie():\n\n- Device resets are done via mwifiex_pcie_card_reset()\n- which schedules card->work to call mwifiex_pcie_card_reset_work()\n- which calls pci_try_reset_function().\n- This leads to mwifiex_pcie_reset_done() be called on the same workqueue,\n  which in turn calls\n- mwifiex_reinit_sw() and that calls\n- _mwifiex_fw_dpc().\n\nThe problem is now that _mwifiex_fw_dpc() calls mwifiex_free_adapter()\nin case firmware initialization fails. That ends up calling\nmwifiex_cleanup_pcie().\n\nNote that all those calls are still running on the workqueue. So when\nmwifiex_cleanup_pcie() now calls cancel_work_sync(), it's really waiting\non itself to complete, causing a deadlock.\n\nThis commit fixes the deadlock by skipping cancel_work_sync() on a reset\nfailure path.\n\nAfter this commit, when reset fails, the following output is\nexpected to be shown:\n\n    kernel: mwifiex_pcie 0000:03:00.0: info: _mwifiex_fw_dpc: unregister device\n    kernel: mwifiex: Failed to bring up adapter: -5\n    kernel: mwifiex_pcie 0000:03:00.0: reinit failed: -5\n\nTo reproduce this issue, for example, try putting the root port of wifi\ninto D3 (replace \"00:1d.3\" with your setup).\n\n    # put into D3 (root port)\n    sudo setpci -v -s 00:1d.3 CAP_PM+4.b=0b\n\nCc: Maximilian Luz <luzmaximilian@gmail.com>\nSigned-off-by: Tsuchiya Yuto <kitakar@gmail.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201028142346.18355-1-kitakar@gmail.com",
        "before_after_code_files": [
          "drivers/net/wireless/marvell/mwifiex/pcie.c||drivers/net/wireless/marvell/mwifiex/pcie.c",
          "drivers/net/wireless/marvell/mwifiex/pcie.h||drivers/net/wireless/marvell/mwifiex/pcie.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/marvell/mwifiex/pcie.c||drivers/net/wireless/marvell/mwifiex/pcie.c": [
          "File: drivers/net/wireless/marvell/mwifiex/pcie.c -> drivers/net/wireless/marvell/mwifiex/pcie.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "525:  clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &card->work_flags);",
          "526:  clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags);",
          "527:  mwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);",
          "528: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "529:  card->pci_reset_ongoing = true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "553:   dev_err(&pdev->dev, \"reinit failed: %d\\n\", ret);",
          "554:  else",
          "555:   mwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);",
          "556: }",
          "558: static const struct pci_error_handlers mwifiex_pcie_err_handler = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "559:  card->pci_reset_ongoing = false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3140:  const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;",
          "3141:  u32 fw_status;",
          "3145:  mwifiex_read_reg(adapter, reg->fw_status, &fw_status);",
          "3146:  if (fw_status == FIRMWARE_READY_PCIE) {",
          "",
          "[Removed Lines]",
          "3143:  cancel_work_sync(&card->work);",
          "",
          "[Added Lines]",
          "3152:  if (!card->pci_reset_ongoing) {",
          "3153:   mwifiex_dbg(adapter, MSG, \"performing cancel_work_sync()...\\n\");",
          "3154:   cancel_work_sync(&card->work);",
          "3155:   mwifiex_dbg(adapter, MSG, \"cancel_work_sync() done\\n\");",
          "3156:  } else {",
          "3157:   mwifiex_dbg(adapter, MSG,",
          "3158:        \"skipped cancel_work_sync() because we're in card reset failure path\\n\");",
          "3159:  }",
          "",
          "---------------"
        ],
        "drivers/net/wireless/marvell/mwifiex/pcie.h||drivers/net/wireless/marvell/mwifiex/pcie.h": [
          "File: drivers/net/wireless/marvell/mwifiex/pcie.h -> drivers/net/wireless/marvell/mwifiex/pcie.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "242:  struct mwifiex_msix_context share_irq_ctx;",
          "243:  struct work_struct work;",
          "244:  unsigned long work_flags;",
          "245: };",
          "247: static inline int",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246:  bool pci_reset_ongoing;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df5b0ab3e08a156701b537809914b339b0daa526",
      "candidate_info": {
        "commit_hash": "df5b0ab3e08a156701b537809914b339b0daa526",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/df5b0ab3e08a156701b537809914b339b0daa526",
        "files": [
          "kernel/reboot.c"
        ],
        "message": "reboot: fix overflow parsing reboot cpu number\n\nLimit the CPU number to num_possible_cpus(), because setting it to a\nvalue lower than INT_MAX but higher than NR_CPUS produces the following\nerror on reboot and shutdown:\n\n    BUG: unable to handle page fault for address: ffffffff90ab1bb0\n    #PF: supervisor read access in kernel mode\n    #PF: error_code(0x0000) - not-present page\n    PGD 1c09067 P4D 1c09067 PUD 1c0a063 PMD 0\n    Oops: 0000 [#1] SMP\n    CPU: 1 PID: 1 Comm: systemd-shutdow Not tainted 5.9.0-rc8-kvm #110\n    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014\n    RIP: 0010:migrate_to_reboot_cpu+0xe/0x60\n    Code: ea ea 00 48 89 fa 48 c7 c7 30 57 f1 81 e9 fa ef ff ff 66 2e 0f 1f 84 00 00 00 00 00 53 8b 1d d5 ea ea 00 e8 14 33 fe ff 89 da <48> 0f a3 15 ea fc bd 00 48 89 d0 73 29 89 c2 c1 e8 06 65 48 8b 3c\n    RSP: 0018:ffffc90000013e08 EFLAGS: 00010246\n    RAX: ffff88801f0a0000 RBX: 0000000077359400 RCX: 0000000000000000\n    RDX: 0000000077359400 RSI: 0000000000000002 RDI: ffffffff81c199e0\n    RBP: ffffffff81c1e3c0 R08: ffff88801f41f000 R09: ffffffff81c1e348\n    R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n    R13: 00007f32bedf8830 R14: 00000000fee1dead R15: 0000000000000000\n    FS:  00007f32bedf8980(0000) GS:ffff88801f480000(0000) knlGS:0000000000000000\n    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    CR2: ffffffff90ab1bb0 CR3: 000000001d057000 CR4: 00000000000006a0\n    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n    Call Trace:\n      __do_sys_reboot.cold+0x34/0x5b\n      do_syscall_64+0x2d/0x40\n\nFixes: 1b3a5d02ee07 (\"reboot: move arch/x86 reboot= handling to generic kernel\")\nSigned-off-by: Matteo Croce <mcroce@microsoft.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Arnd Bergmann <arnd@arndb.de>\nCc: Fabian Frederick <fabf@skynet.be>\nCc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nCc: Guenter Roeck <linux@roeck-us.net>\nCc: Kees Cook <keescook@chromium.org>\nCc: Mike Rapoport <rppt@kernel.org>\nCc: Pavel Tatashin <pasha.tatashin@soleen.com>\nCc: Petr Mladek <pmladek@suse.com>\nCc: Robin Holt <robinmholt@gmail.com>\nCc: <stable@vger.kernel.org>\nLink: https://lkml.kernel.org/r/20201103214025.116799-3-mcroce@linux.microsoft.com\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "kernel/reboot.c||kernel/reboot.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/reboot.c||kernel/reboot.c": [
          "File: kernel/reboot.c -> kernel/reboot.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "558:     reboot_cpu = simple_strtoul(str+3, NULL, 0);",
          "559:    else",
          "561:    break;",
          "563:   case 'g':",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "561:    if (reboot_cpu >= num_possible_cpus()) {",
          "562:     pr_err(\"Ignoring the CPU number in reboot= option. \"",
          "563:            \"CPU %d exceeds possible cpu number %d\\n\",",
          "564:            reboot_cpu, num_possible_cpus());",
          "565:     reboot_cpu = 0;",
          "566:     break;",
          "567:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "22e4663e916321b72972c69ca0c6b962f529bd78",
      "candidate_info": {
        "commit_hash": "22e4663e916321b72972c69ca0c6b962f529bd78",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/22e4663e916321b72972c69ca0c6b962f529bd78",
        "files": [
          "mm/slub.c"
        ],
        "message": "mm/slub: fix panic in slab_alloc_node()\n\nWhile doing memory hot-unplug operation on a PowerPC VM running 1024 CPUs\nwith 11TB of ram, I hit the following panic:\n\n    BUG: Kernel NULL pointer dereference on read at 0x00000007\n    Faulting instruction address: 0xc000000000456048\n    Oops: Kernel access of bad area, sig: 11 [#2]\n    LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS= 2048 NUMA pSeries\n    Modules linked in: rpadlpar_io rpaphp\n    CPU: 160 PID: 1 Comm: systemd Tainted: G      D           5.9.0 #1\n    NIP:  c000000000456048 LR: c000000000455fd4 CTR: c00000000047b350\n    REGS: c00006028d1b77a0 TRAP: 0300   Tainted: G      D            (5.9.0)\n    MSR:  8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 24004228  XER: 00000000\n    CFAR: c00000000000f1b0 DAR: 0000000000000007 DSISR: 40000000 IRQMASK: 0\n    GPR00: c000000000455fd4 c00006028d1b7a30 c000000001bec800 0000000000000000\n    GPR04: 0000000000000dc0 0000000000000000 00000000000374ef c00007c53df99320\n    GPR08: 000007c53c980000 0000000000000000 000007c53c980000 0000000000000000\n    GPR12: 0000000000004400 c00000001e8e4400 0000000000000000 0000000000000f6a\n    GPR16: 0000000000000000 c000000001c25930 c000000001d62528 00000000000000c1\n    GPR20: c000000001d62538 c00006be469e9000 0000000fffffffe0 c0000000003c0ff8\n    GPR24: 0000000000000018 0000000000000000 0000000000000dc0 0000000000000000\n    GPR28: c00007c513755700 c000000001c236a4 c00007bc4001f800 0000000000000001\n    NIP [c000000000456048] __kmalloc_node+0x108/0x790\n    LR [c000000000455fd4] __kmalloc_node+0x94/0x790\n    Call Trace:\n      kvmalloc_node+0x58/0x110\n      mem_cgroup_css_online+0x10c/0x270\n      online_css+0x48/0xd0\n      cgroup_apply_control_enable+0x2c4/0x470\n      cgroup_mkdir+0x408/0x5f0\n      kernfs_iop_mkdir+0x90/0x100\n      vfs_mkdir+0x138/0x250\n      do_mkdirat+0x154/0x1c0\n      system_call_exception+0xf8/0x200\n      system_call_common+0xf0/0x27c\n    Instruction dump:\n    e93e0000 e90d0030 39290008 7cc9402a e94d0030 e93e0000 7ce95214 7f89502a\n    2fbc0000 419e0018 41920230 e9270010 <89290007> 7f994800 419e0220 7ee6bb78\n\nThis pointing to the following code:\n\n    mm/slub.c:2851\n            if (unlikely(!object || !node_match(page, node))) {\n    c000000000456038:       00 00 bc 2f     cmpdi   cr7,r28,0\n    c00000000045603c:       18 00 9e 41     beq     cr7,c000000000456054 <__kmalloc_node+0x114>\n    node_match():\n    mm/slub.c:2491\n            if (node != NUMA_NO_NODE && page_to_nid(page) != node)\n    c000000000456040:       30 02 92 41     beq     cr4,c000000000456270 <__kmalloc_node+0x330>\n    page_to_nid():\n    include/linux/mm.h:1294\n    c000000000456044:       10 00 27 e9     ld      r9,16(r7)\n    c000000000456048:       07 00 29 89     lbz     r9,7(r9)\t<<<< r9 = NULL\n    node_match():\n    mm/slub.c:2491\n    c00000000045604c:       00 48 99 7f     cmpw    cr7,r25,r9\n    c000000000456050:       20 02 9e 41     beq     cr7,c000000000456270 <__kmalloc_node+0x330>\n\nThe panic occurred in slab_alloc_node() when checking for the page's node:\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\nThe issue is that object is not NULL while page is NULL which is odd but\nmay happen if the cache flush happened after loading object but before\nloading page.  Thus checking for the page pointer is required too.\n\nThe cache flush is done through an inter processor interrupt when a\npiece of memory is off-lined.  That interrupt is triggered when a memory\nhot-unplug operation is initiated and offline_pages() is calling the\nslub's MEM_GOING_OFFLINE callback slab_mem_going_offline_callback()\nwhich is calling flush_cpu_slab().  If that interrupt is caught between\nthe reading of c->freelist and the reading of c->page, this could lead\nto such a situation.  That situation is expected and the later call to\nthis_cpu_cmpxchg_double() will detect the change to c->freelist and redo\nthe whole operation.\n\nIn commit 6159d0f5c03e (\"mm/slub.c: page is always non-NULL in\nnode_match()\") check on the page pointer has been removed assuming that\npage is always valid when it is called.  It happens that this is not\ntrue in that particular case, so check for page before calling\nnode_match() here.\n\nFixes: 6159d0f5c03e (\"mm/slub.c: page is always non-NULL in node_match()\")\nSigned-off-by: Laurent Dufour <ldufour@linux.ibm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nAcked-by: Vlastimil Babka <vbabka@suse.cz>\nAcked-by: Christoph Lameter <cl@linux.com>\nCc: Wei Yang <richard.weiyang@gmail.com>\nCc: Pekka Enberg <penberg@kernel.org>\nCc: David Rientjes <rientjes@google.com>\nCc: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nCc: Nathan Lynch <nathanl@linux.ibm.com>\nCc: Scott Cheloha <cheloha@linux.ibm.com>\nCc: Michal Hocko <mhocko@suse.com>\nCc: <stable@vger.kernel.org>\nLink: https://lkml.kernel.org/r/20201027190406.33283-1-ldufour@linux.ibm.com\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/slub.c||mm/slub.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/slub.c||mm/slub.c": [
          "File: mm/slub.c -> mm/slub.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2853:  object = c->freelist;",
          "2854:  page = c->page;",
          "2856:   object = __slab_alloc(s, gfpflags, node, addr, c);",
          "2857:  } else {",
          "2858:   void *next_object = get_freepointer_safe(s, object);",
          "",
          "[Removed Lines]",
          "2855:  if (unlikely(!object || !node_match(page, node))) {",
          "",
          "[Added Lines]",
          "2855:  if (unlikely(!object || !page || !node_match(page, node))) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "092561f06702dd4fdd7fb74dd3a838f1818529b7",
      "candidate_info": {
        "commit_hash": "092561f06702dd4fdd7fb74dd3a838f1818529b7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/092561f06702dd4fdd7fb74dd3a838f1818529b7",
        "files": [
          "drivers/uio/uio.c"
        ],
        "message": "uio: Fix use-after-free in uio_unregister_device()\n\nCommit 8fd0e2a6df26 (\"uio: free uio id after uio file node is freed\")\ntriggered KASAN use-after-free failure at deletion of TCM-user\nbackstores [1].\n\nIn uio_unregister_device(), struct uio_device *idev is passed to\nuio_free_minor() to refer idev->minor. However, before uio_free_minor()\ncall, idev is already freed by uio_device_release() during call to\ndevice_unregister().\n\nTo avoid reference to idev->minor after idev free, keep idev->minor\nvalue in a local variable. Also modify uio_free_minor() argument to\nreceive the value.\n\n[1]\nBUG: KASAN: use-after-free in uio_unregister_device+0x166/0x190\nRead of size 4 at addr ffff888105196508 by task targetcli/49158\n\nCPU: 3 PID: 49158 Comm: targetcli Not tainted 5.10.0-rc1 #1\nHardware name: Supermicro Super Server/X10SRL-F, BIOS 2.0 12/17/2015\nCall Trace:\n dump_stack+0xae/0xe5\n ? uio_unregister_device+0x166/0x190\n print_address_description.constprop.0+0x1c/0x210\n ? uio_unregister_device+0x166/0x190\n ? uio_unregister_device+0x166/0x190\n kasan_report.cold+0x37/0x7c\n ? kobject_put+0x80/0x410\n ? uio_unregister_device+0x166/0x190\n uio_unregister_device+0x166/0x190\n tcmu_destroy_device+0x1c4/0x280 [target_core_user]\n ? tcmu_release+0x90/0x90 [target_core_user]\n ? __mutex_unlock_slowpath+0xd6/0x5d0\n target_free_device+0xf3/0x2e0 [target_core_mod]\n config_item_cleanup+0xea/0x210\n configfs_rmdir+0x651/0x860\n ? detach_groups.isra.0+0x380/0x380\n vfs_rmdir.part.0+0xec/0x3a0\n ? __lookup_hash+0x20/0x150\n do_rmdir+0x252/0x320\n ? do_file_open_root+0x420/0x420\n ? strncpy_from_user+0xbc/0x2f0\n ? getname_flags.part.0+0x8e/0x450\n do_syscall_64+0x33/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\nRIP: 0033:0x7f9e2bfc91fb\nCode: 73 01 c3 48 8b 0d 9d ec 0c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 54 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 6d ec 0c 00 f7 d8 64 89 01 48\nRSP: 002b:00007ffdd2baafe8 EFLAGS: 00000246 ORIG_RAX: 0000000000000054\nRAX: ffffffffffffffda RBX: 00007f9e2beb44a0 RCX: 00007f9e2bfc91fb\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 00007f9e1c20be90\nRBP: 00007ffdd2bab000 R08: 0000000000000000 R09: 00007f9e2bdf2440\nR10: 00007ffdd2baaf37 R11: 0000000000000246 R12: 00000000ffffff9c\nR13: 000055f9abb7e390 R14: 000055f9abcf9558 R15: 00007f9e2be7a780\n\nAllocated by task 34735:\n kasan_save_stack+0x1b/0x40\n __kasan_kmalloc.constprop.0+0xc2/0xd0\n __uio_register_device+0xeb/0xd40\n tcmu_configure_device+0x5a0/0xbc0 [target_core_user]\n target_configure_device+0x12f/0x760 [target_core_mod]\n target_dev_enable_store+0x32/0x50 [target_core_mod]\n configfs_write_file+0x2bb/0x450\n vfs_write+0x1ce/0x610\n ksys_write+0xe9/0x1b0\n do_syscall_64+0x33/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nFreed by task 49158:\n kasan_save_stack+0x1b/0x40\n kasan_set_track+0x1c/0x30\n kasan_set_free_info+0x1b/0x30\n __kasan_slab_free+0x110/0x150\n slab_free_freelist_hook+0x5a/0x170\n kfree+0xc6/0x560\n device_release+0x9b/0x210\n kobject_put+0x13e/0x410\n uio_unregister_device+0xf9/0x190\n tcmu_destroy_device+0x1c4/0x280 [target_core_user]\n target_free_device+0xf3/0x2e0 [target_core_mod]\n config_item_cleanup+0xea/0x210\n configfs_rmdir+0x651/0x860\n vfs_rmdir.part.0+0xec/0x3a0\n do_rmdir+0x252/0x320\n do_syscall_64+0x33/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nThe buggy address belongs to the object at ffff888105196000\n which belongs to the cache kmalloc-2k of size 2048\nThe buggy address is located 1288 bytes inside of\n 2048-byte region [ffff888105196000, ffff888105196800)\nThe buggy address belongs to the page:\npage:0000000098e6ca81 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x105190\nhead:0000000098e6ca81 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x17ffffc0010200(slab|head)\nraw: 0017ffffc0010200 dead000000000100 dead000000000122 ffff888100043040\nraw: 0000000000000000 0000000000080008 00000001ffffffff ffff88810eb55c01\npage dumped because: kasan: bad access detected\npage->mem_cgroup:ffff88810eb55c01\n\nMemory state around the buggy address:\n ffff888105196400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888105196480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff888105196500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                      ^\n ffff888105196580: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888105196600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nFixes: 8fd0e2a6df26 (\"uio: free uio id after uio file node is freed\")\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Shin'ichiro Kawasaki <shinichiro.kawasaki@wdc.com>\nLink: https://lore.kernel.org/r/20201102122819.2346270-1-shinichiro.kawasaki@wdc.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/uio/uio.c||drivers/uio/uio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/uio/uio.c||drivers/uio/uio.c": [
          "File: drivers/uio/uio.c -> drivers/uio/uio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "413:  return retval;",
          "414: }",
          "417: {",
          "418:  mutex_lock(&minor_lock);",
          "420:  mutex_unlock(&minor_lock);",
          "421: }",
          "",
          "[Removed Lines]",
          "416: static void uio_free_minor(struct uio_device *idev)",
          "419:  idr_remove(&uio_idr, idev->minor);",
          "",
          "[Added Lines]",
          "416: static void uio_free_minor(unsigned long minor)",
          "419:  idr_remove(&uio_idr, minor);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "990: err_uio_dev_add_attributes:",
          "991:  device_del(&idev->dev);",
          "992: err_device_create:",
          "994:  put_device(&idev->dev);",
          "995:  return ret;",
          "996: }",
          "",
          "[Removed Lines]",
          "993:  uio_free_minor(idev);",
          "",
          "[Added Lines]",
          "993:  uio_free_minor(idev->minor);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1042: void uio_unregister_device(struct uio_info *info)",
          "1043: {",
          "1044:  struct uio_device *idev;",
          "1046:  if (!info || !info->uio_dev)",
          "1047:   return;",
          "1049:  idev = info->uio_dev;",
          "1051:  mutex_lock(&idev->info_lock);",
          "1052:  uio_dev_del_attributes(idev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1045:  unsigned long minor;",
          "1051:  minor = idev->minor;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1063:  device_unregister(&idev->dev);",
          "1067:  return;",
          "1068: }",
          "",
          "[Removed Lines]",
          "1065:  uio_free_minor(idev);",
          "",
          "[Added Lines]",
          "1067:  uio_free_minor(minor);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
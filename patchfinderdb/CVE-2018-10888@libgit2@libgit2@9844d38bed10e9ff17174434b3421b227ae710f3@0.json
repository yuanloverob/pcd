{
  "cve_id": "CVE-2018-10888",
  "cve_desc": "A flaw was found in libgit2 before version 0.27.3. A missing check in git_delta_apply function in delta.c file, may lead to an out-of-bound read while reading a binary delta file. An attacker may use this flaw to cause a Denial of Service.",
  "repo": "libgit2/libgit2",
  "patch_hash": "9844d38bed10e9ff17174434b3421b227ae710f3",
  "patch_info": {
    "commit_hash": "9844d38bed10e9ff17174434b3421b227ae710f3",
    "repo": "libgit2/libgit2",
    "commit_url": "https://github.com/libgit2/libgit2/commit/9844d38bed10e9ff17174434b3421b227ae710f3",
    "files": [
      "src/delta.c",
      "tests/delta/apply.c"
    ],
    "message": "delta: fix out-of-bounds read of delta\n\nWhen computing the offset and length of the delta base, we repeatedly\nincrement the `delta` pointer without checking whether we have advanced\npast its end already, which can thus result in an out-of-bounds read.\nFix this by repeatedly checking whether we have reached the end. Add a\ntest which would cause Valgrind to produce an error.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\nTest-provided-by: Riccardo Schirone <rschiron@redhat.com>",
    "before_after_code_files": [
      "src/delta.c||src/delta.c",
      "tests/delta/apply.c||tests/delta/apply.c"
    ]
  },
  "patch_diff": {
    "src/delta.c||src/delta.c": [
      "File: src/delta.c -> src/delta.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "569:    size_t off = 0, len = 0;",
      "579:    if (!len)       len = 0x10000;",
      "581:    if (base_len < off + len || res_sz < len)",
      "582:     goto fail;",
      "",
      "[Removed Lines]",
      "571:    if (cmd & 0x01) off = *delta++;",
      "572:    if (cmd & 0x02) off |= *delta++ << 8UL;",
      "573:    if (cmd & 0x04) off |= *delta++ << 16UL;",
      "574:    if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);",
      "576:    if (cmd & 0x10) len = *delta++;",
      "577:    if (cmd & 0x20) len |= *delta++ << 8UL;",
      "578:    if (cmd & 0x40) len |= *delta++ << 16UL;",
      "",
      "[Added Lines]",
      "571: #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }",
      "572:    if (cmd & 0x01) ADD_DELTA(off, 0UL);",
      "573:    if (cmd & 0x02) ADD_DELTA(off, 8UL);",
      "574:    if (cmd & 0x04) ADD_DELTA(off, 16UL);",
      "575:    if (cmd & 0x08) ADD_DELTA(off, 24UL);",
      "577:    if (cmd & 0x10) ADD_DELTA(len, 0UL);",
      "578:    if (cmd & 0x20) ADD_DELTA(len, 8UL);",
      "579:    if (cmd & 0x40) ADD_DELTA(len, 16UL);",
      "581: #undef ADD_DELTA",
      "",
      "---------------"
    ],
    "tests/delta/apply.c||tests/delta/apply.c": [
      "File: tests/delta/apply.c -> tests/delta/apply.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:  cl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));",
      "12: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "14: void test_delta_apply__read_after_limit(void)",
      "15: {",
      "16:  unsigned char base[16] = { 0 }, delta[] = { 0x10, 0x70, 0xff };",
      "17:  void *out;",
      "18:  size_t outlen;",
      "20:  cl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));",
      "21: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8fbd7563083a278c936a2113aed69635b409126f",
      "candidate_info": {
        "commit_hash": "8fbd7563083a278c936a2113aed69635b409126f",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/8fbd7563083a278c936a2113aed69635b409126f",
        "files": [
          "include/git2/version.h"
        ],
        "message": "version: bump to v0.27.3",
        "before_after_code_files": [
          "include/git2/version.h||include/git2/version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/4717"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/git2/version.h||include/git2/version.h": [
          "File: include/git2/version.h -> include/git2/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #ifndef INCLUDE_git_version_h__",
          "8: #define INCLUDE_git_version_h__",
          "11: #define LIBGIT2_VER_MAJOR 0",
          "12: #define LIBGIT2_VER_MINOR 27",
          "14: #define LIBGIT2_VER_PATCH 0",
          "16: #define LIBGIT2_SOVERSION 27",
          "",
          "[Removed Lines]",
          "10: #define LIBGIT2_VERSION \"0.27.2\"",
          "13: #define LIBGIT2_VER_REVISION 2",
          "",
          "[Added Lines]",
          "10: #define LIBGIT2_VERSION \"0.27.3\"",
          "13: #define LIBGIT2_VER_REVISION 3",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c1577110467b701dcbcf9439ac225ea851b47d22",
      "candidate_info": {
        "commit_hash": "c1577110467b701dcbcf9439ac225ea851b47d22",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/c1577110467b701dcbcf9439ac225ea851b47d22",
        "files": [
          "src/delta.c"
        ],
        "message": "delta: fix overflow when computing limit\n\nWhen checking whether a delta base offset and length fit into the base\nwe have in memory already, we can trigger an overflow which breaks the\ncheck. This would subsequently result in us reading memory from out of\nbounds of the base.\n\nThe issue is easily fixed by checking for overflow when adding `off` and\n`len`, thus guaranteeting that we are never indexing beyond `base_len`.\nThis corresponds to the git patch 8960844a7 (check patch_delta bounds\nmore carefully, 2006-04-07), which adds these overflow checks.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>",
        "before_after_code_files": [
          "src/delta.c||src/delta.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/4717"
        ],
        "olp_code_files": {
          "patch": [
            "src/delta.c||src/delta.c"
          ],
          "candidate": [
            "src/delta.c||src/delta.c"
          ]
        }
      },
      "candidate_diff": {
        "src/delta.c||src/delta.c": [
          "File: src/delta.c -> src/delta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "566:   unsigned char cmd = *delta++;",
          "567:   if (cmd & 0x80) {",
          "571: #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }",
          "572:    if (cmd & 0x01) ADD_DELTA(off, 0UL);",
          "",
          "[Removed Lines]",
          "569:    size_t off = 0, len = 0;",
          "",
          "[Added Lines]",
          "569:    size_t off = 0, len = 0, end;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "580:    if (!len)       len = 0x10000;",
          "581: #undef ADD_DELTA",
          "584:     goto fail;",
          "585:    memcpy(res_dp, base + off, len);",
          "586:    res_dp += len;",
          "587:    res_sz -= len;",
          "",
          "[Removed Lines]",
          "583:    if (base_len < off + len || res_sz < len)",
          "",
          "[Added Lines]",
          "583:    if (GIT_ADD_SIZET_OVERFLOW(&end, off, len) ||",
          "584:        base_len < end || res_sz < len)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3f461902dc1072acb8b7607ee65d0a0458ffac2a",
      "candidate_info": {
        "commit_hash": "3f461902dc1072acb8b7607ee65d0a0458ffac2a",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/3f461902dc1072acb8b7607ee65d0a0458ffac2a",
        "files": [
          "src/delta.c",
          "tests/delta/apply.c",
          "tests/diff/binary.c"
        ],
        "message": "delta: fix sign-extension of big left-shift\n\nOur delta code was originally adapted from JGit, which itself adapted it\nfrom git itself. Due to this heritage, we inherited a bug from git.git\nin how we compute the delta offset, which was fixed upstream in\n48fb7deb5 (Fix big left-shifts of unsigned char, 2009-06-17). As\nexplained by Linus:\n\n    Shifting 'unsigned char' or 'unsigned short' left can result in sign\n    extension errors, since the C integer promotion rules means that the\n    unsigned char/short will get implicitly promoted to a signed 'int' due to\n    the shift (or due to other operations).\n\n    This normally doesn't matter, but if you shift things up sufficiently, it\n    will now set the sign bit in 'int', and a subsequent cast to a bigger type\n    (eg 'long' or 'unsigned long') will now sign-extend the value despite the\n    original expression being unsigned.\n\n    One example of this would be something like\n\n            unsigned long size;\n            unsigned char c;\n\n            size += c << 24;\n\n    where despite all the variables being unsigned, 'c << 24' ends up being a\n    signed entity, and will get sign-extended when then doing the addition in\n    an 'unsigned long' type.\n\n    Since git uses 'unsigned char' pointers extensively, we actually have this\n    bug in a couple of places.\n\nIn our delta code, we inherited such a bogus shift when computing the\noffset at which the delta base is to be found. Due to the sign extension\nwe can end up with an offset where all the bits are set. This can allow\nan arbitrary memory read, as the addition in `base_len < off + len` can\nnow overflow if `off` has all its bits set.\n\nFix the issue by casting the result of `*delta++ << 24UL` to an unsigned\ninteger again. Add a test with a crafted delta that would actually\nsucceed with an out-of-bounds read in case where the cast wouldn't\nexist.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\nTest-provided-by: Riccardo Schirone <rschiron@redhat.com>",
        "before_after_code_files": [
          "src/delta.c||src/delta.c",
          "tests/delta/apply.c||tests/delta/apply.c",
          "tests/diff/binary.c||tests/diff/binary.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/delta.c||src/delta.c",
            "tests/delta/apply.c||tests/delta/apply.c"
          ],
          "candidate": [
            "src/delta.c||src/delta.c",
            "tests/delta/apply.c||tests/delta/apply.c"
          ]
        }
      },
      "candidate_diff": {
        "src/delta.c||src/delta.c": [
          "File: src/delta.c -> src/delta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "564:  while (delta < delta_end) {",
          "565:   unsigned char cmd = *delta++;",
          "566:   if (cmd & 0x80) {",
          "569:    size_t off = 0, len = 0;",
          "571:    if (cmd & 0x01) off = *delta++;",
          "572:    if (cmd & 0x02) off |= *delta++ << 8UL;",
          "573:    if (cmd & 0x04) off |= *delta++ << 16UL;",
          "576:    if (cmd & 0x10) len = *delta++;",
          "577:    if (cmd & 0x20) len |= *delta++ << 8UL;",
          "578:    if (cmd & 0x40) len |= *delta++ << 16UL;",
          "581:    if (base_len < off + len || res_sz < len)",
          "582:     goto fail;",
          "",
          "[Removed Lines]",
          "574:    if (cmd & 0x08) off |= *delta++ << 24UL;",
          "579:    if (!len)  len = 0x10000;",
          "",
          "[Added Lines]",
          "574:    if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);",
          "579:    if (!len)       len = 0x10000;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "584:    res_dp += len;",
          "585:    res_sz -= len;",
          "592:    if (delta_end - delta < cmd || res_sz < cmd)",
          "593:     goto fail;",
          "594:    memcpy(res_dp, delta, cmd);",
          "",
          "[Removed Lines]",
          "587:   }",
          "588:   else if (cmd) {",
          "",
          "[Added Lines]",
          "587:   } else if (cmd) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "596:    res_dp += cmd;",
          "597:    res_sz -= cmd;",
          "603:    goto fail;",
          "604:   }",
          "605:  }",
          "",
          "[Removed Lines]",
          "599:   }",
          "600:   else {",
          "",
          "[Added Lines]",
          "599:   } else {",
          "",
          "---------------"
        ],
        "tests/delta/apply.c||tests/delta/apply.c": [
          "File: tests/delta/apply.c -> tests/delta/apply.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"clar_libgit2.h\"",
          "3: #include \"delta.h\"",
          "5: void test_delta_apply__read_at_off(void)",
          "6: {",
          "7:  unsigned char base[16] = { 0 }, delta[] = { 0x10, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0x00 };",
          "8:  void *out;",
          "9:  size_t outlen;",
          "11:  cl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));",
          "12: }",
          "",
          "---------------"
        ],
        "tests/diff/binary.c||tests/diff/binary.c": [
          "File: tests/diff/binary.c -> tests/diff/binary.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"git2/sys/diff.h\"",
          "5: #include \"buffer.h\"",
          "6: #include \"filebuf.h\"",
          "7: #include \"repository.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #include \"delta.h\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "24597812220325f1cb38f61e56b095ff38d1b1cb",
      "candidate_info": {
        "commit_hash": "24597812220325f1cb38f61e56b095ff38d1b1cb",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/24597812220325f1cb38f61e56b095ff38d1b1cb",
        "files": [
          "src/delta.c",
          "tests/delta/apply.c"
        ],
        "message": "delta: fix out-of-bounds read of delta\n\nWhen computing the offset and length of the delta base, we repeatedly\nincrement the `delta` pointer without checking whether we have advanced\npast its end already, which can thus result in an out-of-bounds read.\nFix this by repeatedly checking whether we have reached the end. Add a\ntest which would cause Valgrind to produce an error.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\nTest-provided-by: Riccardo Schirone <rschiron@redhat.com>",
        "before_after_code_files": [
          "src/delta.c||src/delta.c",
          "tests/deltapply.c||tests/delta/apply.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/delta.c||src/delta.c"
          ],
          "candidate": [
            "src/delta.c||src/delta.c"
          ]
        }
      },
      "candidate_diff": {
        "src/delta.c||src/delta.c": [
          "File: src/delta.c -> src/delta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "569:    size_t off = 0, len = 0;",
          "579:    if (!len)       len = 0x10000;",
          "581:    if (base_len < off + len || res_sz < len)",
          "582:     goto fail;",
          "",
          "[Removed Lines]",
          "571:    if (cmd & 0x01) off = *delta++;",
          "572:    if (cmd & 0x02) off |= *delta++ << 8UL;",
          "573:    if (cmd & 0x04) off |= *delta++ << 16UL;",
          "574:    if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);",
          "576:    if (cmd & 0x10) len = *delta++;",
          "577:    if (cmd & 0x20) len |= *delta++ << 8UL;",
          "578:    if (cmd & 0x40) len |= *delta++ << 16UL;",
          "",
          "[Added Lines]",
          "571: #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }",
          "572:    if (cmd & 0x01) ADD_DELTA(off, 0UL);",
          "573:    if (cmd & 0x02) ADD_DELTA(off, 8UL);",
          "574:    if (cmd & 0x04) ADD_DELTA(off, 16UL);",
          "575:    if (cmd & 0x08) ADD_DELTA(off, 24UL);",
          "577:    if (cmd & 0x10) ADD_DELTA(len, 0UL);",
          "578:    if (cmd & 0x20) ADD_DELTA(len, 8UL);",
          "579:    if (cmd & 0x40) ADD_DELTA(len, 16UL);",
          "581: #undef ADD_DELTA",
          "",
          "---------------"
        ],
        "tests/deltapply.c||tests/delta/apply.c": [
          "File: tests/deltapply.c -> tests/delta/apply.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: void test_delta_apply__read_after_limit(void)",
          "15: {",
          "16:  unsigned char base[16] = { 0 }, delta[] = { 0x10, 0x70, 0xff };",
          "17:  void *out;",
          "18:  size_t outlen;",
          "20:  cl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));",
          "21: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "25d4a8c9c4a3059c7b473b43dbd5ad391fe2660a",
      "candidate_info": {
        "commit_hash": "25d4a8c9c4a3059c7b473b43dbd5ad391fe2660a",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/25d4a8c9c4a3059c7b473b43dbd5ad391fe2660a",
        "files": [
          "src/delta.c",
          "tests/delta/apply.c"
        ],
        "message": "delta: fix out-of-bounds read of delta\n\nWhen computing the offset and length of the delta base, we repeatedly\nincrement the `delta` pointer without checking whether we have advanced\npast its end already, which can thus result in an out-of-bounds read.\nFix this by repeatedly checking whether we have reached the end. Add a\ntest which would cause Valgrind to produce an error.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\nTest-provided-by: Riccardo Schirone <rschiron@redhat.com>",
        "before_after_code_files": [
          "src/delta.c||src/delta.c",
          "tests/delta/apply.c||tests/delta/apply.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/delta.c||src/delta.c",
            "tests/delta/apply.c||tests/delta/apply.c"
          ],
          "candidate": [
            "src/delta.c||src/delta.c",
            "tests/delta/apply.c||tests/delta/apply.c"
          ]
        }
      },
      "candidate_diff": {
        "src/delta.c||src/delta.c": [
          "File: src/delta.c -> src/delta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "569:    size_t off = 0, len = 0;",
          "579:    if (!len)       len = 0x10000;",
          "581:    if (base_len < off + len || res_sz < len)",
          "582:     goto fail;",
          "",
          "[Removed Lines]",
          "571:    if (cmd & 0x01) off = *delta++;",
          "572:    if (cmd & 0x02) off |= *delta++ << 8UL;",
          "573:    if (cmd & 0x04) off |= *delta++ << 16UL;",
          "574:    if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);",
          "576:    if (cmd & 0x10) len = *delta++;",
          "577:    if (cmd & 0x20) len |= *delta++ << 8UL;",
          "578:    if (cmd & 0x40) len |= *delta++ << 16UL;",
          "",
          "[Added Lines]",
          "571: #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }",
          "572:    if (cmd & 0x01) ADD_DELTA(off, 0UL);",
          "573:    if (cmd & 0x02) ADD_DELTA(off, 8UL);",
          "574:    if (cmd & 0x04) ADD_DELTA(off, 16UL);",
          "575:    if (cmd & 0x08) ADD_DELTA(off, 24UL);",
          "577:    if (cmd & 0x10) ADD_DELTA(len, 0UL);",
          "578:    if (cmd & 0x20) ADD_DELTA(len, 8UL);",
          "579:    if (cmd & 0x40) ADD_DELTA(len, 16UL);",
          "581: #undef ADD_DELTA",
          "",
          "---------------"
        ],
        "tests/delta/apply.c||tests/delta/apply.c": [
          "File: tests/delta/apply.c -> tests/delta/apply.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:  cl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));",
          "12: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: void test_delta_apply__read_after_limit(void)",
          "15: {",
          "16:  unsigned char base[16] = { 0 }, delta[] = { 0x10, 0x70, 0xff };",
          "17:  void *out;",
          "18:  size_t outlen;",
          "20:  cl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));",
          "21: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
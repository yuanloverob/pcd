{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "81185a5138577baf2b32112fa3c6f931667c23f9",
      "candidate_info": {
        "commit_hash": "81185a5138577baf2b32112fa3c6f931667c23f9",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/81185a5138577baf2b32112fa3c6f931667c23f9",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/select.c",
          "src/sqliteInt.h"
        ],
        "message": "Give the expression pointer fields of AggInfo distinctive names in order to simplify tracking of all their uses.\n\nFossilOrigin-Name: a53bdd311c4154fd5e1131efbb9665362f79db5a35ce9f7b1547f74b8ee2d8ba",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b5711b4eead10ef4b0b61f2e2c54768d215a4105f6d47d2ea78991b6e53a6831",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5738:     assert( pExpr->op==TK_AGG_COLUMN || pExpr->op==TK_AGG_FUNCTION );",
          "5739:     if( pExpr->op==TK_AGG_COLUMN ){",
          "5740:       assert( iAgg>=0 && iAgg<pAggInfo->nColumn );",
          "5742:         pExpr = sqlite3ExprDup(db, pExpr, 0);",
          "5743:         if( pExpr ){",
          "5745:           pParse->pConstExpr =",
          "5746:              sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);",
          "5747:         }",
          "5748:       }",
          "5749:     }else{",
          "5750:       assert( iAgg>=0 && iAgg<pAggInfo->nFunc );",
          "5752:         pExpr = sqlite3ExprDup(db, pExpr, 0);",
          "5753:         if( pExpr ){",
          "5755:           pParse->pConstExpr =",
          "5756:              sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);",
          "5757:         }",
          "",
          "[Removed Lines]",
          "5741:       if( pAggInfo->aCol[iAgg].pExpr==pExpr ){",
          "5744:           pAggInfo->aCol[iAgg].pExpr = pExpr;",
          "5751:       if( pAggInfo->aFunc[iAgg].pExpr==pExpr ){",
          "5754:           pAggInfo->aFunc[iAgg].pExpr = pExpr;",
          "",
          "[Added Lines]",
          "5741:       if( pAggInfo->aCol[iAgg].pCExpr==pExpr ){",
          "5744:           pAggInfo->aCol[iAgg].pCExpr = pExpr;",
          "5751:       if( pAggInfo->aFunc[iAgg].pFExpr==pExpr ){",
          "5754:           pAggInfo->aFunc[iAgg].pFExpr = pExpr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5853:               pCol->iColumn = pExpr->iColumn;",
          "5854:               pCol->iMem = ++pParse->nMem;",
          "5855:               pCol->iSorterColumn = -1;",
          "5857:               if( pAggInfo->pGroupBy ){",
          "5858:                 int j, n;",
          "5859:                 ExprList *pGB = pAggInfo->pGroupBy;",
          "",
          "[Removed Lines]",
          "5856:               pCol->pExpr = pExpr;",
          "",
          "[Added Lines]",
          "5856:               pCol->pCExpr = pExpr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5897:         struct AggInfo_func *pItem = pAggInfo->aFunc;",
          "5898:         for(i=0; i<pAggInfo->nFunc; i++, pItem++){",
          "5900:             break;",
          "5901:           }",
          "5902:         }",
          "",
          "[Removed Lines]",
          "5899:           if( sqlite3ExprCompare(0, pItem->pExpr, pExpr, -1)==0 ){",
          "",
          "[Added Lines]",
          "5899:           if( sqlite3ExprCompare(0, pItem->pFExpr, pExpr, -1)==0 ){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5908:           if( i>=0 ){",
          "5909:             assert( !ExprHasProperty(pExpr, EP_xIsSelect) );",
          "5910:             pItem = &pAggInfo->aFunc[i];",
          "5912:             pItem->iMem = ++pParse->nMem;",
          "5913:             assert( !ExprHasProperty(pExpr, EP_IntValue) );",
          "5914:             pItem->pFunc = sqlite3FindFunction(pParse->db,",
          "",
          "[Removed Lines]",
          "5911:             pItem->pExpr = pExpr;",
          "",
          "[Added Lines]",
          "5911:             pItem->pFExpr = pExpr;",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5389:   sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);",
          "5390:   for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){",
          "5391:     if( pFunc->iDistinct>=0 ){",
          "5393:       assert( !ExprHasProperty(pE, EP_xIsSelect) );",
          "5394:       if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){",
          "5395:         sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"",
          "",
          "[Removed Lines]",
          "5392:       Expr *pE = pFunc->pExpr;",
          "",
          "[Added Lines]",
          "5392:       Expr *pE = pFunc->pFExpr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5413:   int i;",
          "5414:   struct AggInfo_func *pF;",
          "5415:   for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){",
          "5418:     sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);",
          "5419:     sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);",
          "5420:   }",
          "",
          "[Removed Lines]",
          "5416:     ExprList *pList = pF->pExpr->x.pList;",
          "5417:     assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );",
          "",
          "[Added Lines]",
          "5416:     ExprList *pList = pF->pFExpr->x.pList;",
          "5417:     assert( !ExprHasProperty(pF->pFExpr, EP_xIsSelect) );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5443:     int nArg;",
          "5444:     int addrNext = 0;",
          "5445:     int regAgg;",
          "5451:       if( pAggInfo->nAccumulator",
          "5452:        && (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)",
          "5453:       ){",
          "",
          "[Removed Lines]",
          "5446:     ExprList *pList = pF->pExpr->x.pList;",
          "5447:     assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );",
          "5448:     assert( !IsWindowFunc(pF->pExpr) );",
          "5449:     if( ExprHasProperty(pF->pExpr, EP_WinFunc) ){",
          "5450:       Expr *pFilter = pF->pExpr->y.pWin->pFilter;",
          "",
          "[Added Lines]",
          "5446:     ExprList *pList = pF->pFExpr->x.pList;",
          "5447:     assert( !ExprHasProperty(pF->pFExpr, EP_xIsSelect) );",
          "5448:     assert( !IsWindowFunc(pF->pFExpr) );",
          "5449:     if( ExprHasProperty(pF->pFExpr, EP_WinFunc) ){",
          "5450:       Expr *pFilter = pF->pFExpr->y.pWin->pFilter;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5509:     addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);",
          "5510:   }",
          "5511:   for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){",
          "5513:   }",
          "5515:   pAggInfo->directMode = 0;",
          "",
          "[Removed Lines]",
          "5512:     sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);",
          "",
          "[Added Lines]",
          "5512:     sqlite3ExprCode(pParse, pC->pCExpr, pC->iMem);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6385:     }",
          "6386:     pAggInfo->nAccumulator = pAggInfo->nColumn;",
          "6387:     if( p->pGroupBy==0 && p->pHaving==0 && pAggInfo->nFunc==1 ){",
          "6389:     }else{",
          "6390:       minMaxFlag = WHERE_ORDERBY_NORMAL;",
          "6391:     }",
          "6392:     for(i=0; i<pAggInfo->nFunc; i++){",
          "6394:       assert( !ExprHasProperty(pExpr, EP_xIsSelect) );",
          "6395:       sNC.ncFlags |= NC_InAggFunc;",
          "6396:       sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);",
          "",
          "[Removed Lines]",
          "6388:       minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pExpr, &pMinMaxOrderBy);",
          "6393:       Expr *pExpr = pAggInfo->aFunc[i].pExpr;",
          "",
          "[Added Lines]",
          "6388:       minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);",
          "6393:       Expr *pExpr = pAggInfo->aFunc[i].pFExpr;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6412:       for(ii=0; ii<pAggInfo->nColumn; ii++){",
          "6413:         sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",",
          "6414:             ii, pAggInfo->aCol[ii].iMem);",
          "6416:       }",
          "6417:       for(ii=0; ii<pAggInfo->nFunc; ii++){",
          "6418:         sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",",
          "6419:             ii, pAggInfo->aFunc[ii].iMem);",
          "6421:       }",
          "6422:     }",
          "6423: #endif",
          "",
          "[Removed Lines]",
          "6415:         sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pExpr, 0);",
          "6420:         sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pExpr, 0);",
          "",
          "[Added Lines]",
          "6415:         sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pCExpr, 0);",
          "6420:         sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pFExpr, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6723:         if( pAggInfo->nAccumulator ){",
          "6724:           for(i=0; i<pAggInfo->nFunc; i++){",
          "6726:               continue;",
          "6727:             }",
          "6728:             if( pAggInfo->aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ){",
          "",
          "[Removed Lines]",
          "6725:             if( ExprHasProperty(pAggInfo->aFunc[i].pExpr, EP_WinFunc) ){",
          "",
          "[Added Lines]",
          "6725:             if( ExprHasProperty(pAggInfo->aFunc[i].pFExpr, EP_WinFunc) ){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6806: #ifdef SQLITE_DEBUG",
          "6807:   if( pAggInfo ){",
          "6808:     for(i=0; i<pAggInfo->nColumn; i++){",
          "6810:       assert( pExpr!=0 || db->mallocFailed );",
          "6811:       if( pExpr==0 ) continue;",
          "6812:       assert( pExpr->pAggInfo==pAggInfo );",
          "6813:       assert( pExpr->iAgg==i );",
          "6814:     }",
          "6815:     for(i=0; i<pAggInfo->nFunc; i++){",
          "6817:       assert( pExpr!=0 || db->mallocFailed );",
          "6818:       if( pExpr==0 ) continue;",
          "6819:       assert( pExpr->pAggInfo==pAggInfo );",
          "",
          "[Removed Lines]",
          "6809:       Expr *pExpr = pAggInfo->aCol[i].pExpr;",
          "6816:       Expr *pExpr = pAggInfo->aFunc[i].pExpr;",
          "",
          "[Added Lines]",
          "6809:       Expr *pExpr = pAggInfo->aCol[i].pCExpr;",
          "6816:       Expr *pExpr = pAggInfo->aFunc[i].pFExpr;",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ]
      }
    },
    {
      "candidate_hash": "b7cbf5c1b2a9e099eec176e1ebeb659427a20626",
      "candidate_info": {
        "commit_hash": "b7cbf5c1b2a9e099eec176e1ebeb659427a20626",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b7cbf5c1b2a9e099eec176e1ebeb659427a20626",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c",
          "src/sqliteInt.h",
          "test/selectA.test"
        ],
        "message": "Fix a defect in the query-flattener optimization identified by ticket [8f157e8010b22af0].\n\nFossilOrigin-Name: 10fa79d00f8091e5748c245f4cae5b5f499a5f8db20da741c130e05a21ede443",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "test/selectA.test||test/selectA.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 90b1169d1b200d35a3f9f0ad2ae35a1b336bdd9b1ad0494ba80a382354c8d8b8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2702:                           selectOpName(p->op)));",
          "2703:         rc = sqlite3Select(pParse, p, &uniondest);",
          "2704:         testcase( rc!=SQLITE_OK );",
          "2708:         pDelete = p->pPrior;",
          "2709:         p->pPrior = pPrior;",
          "2710:         p->pOrderBy = 0;",
          "",
          "[Removed Lines]",
          "2707:         sqlite3ExprListDelete(db, p->pOrderBy);",
          "",
          "[Added Lines]",
          "2705:         assert( p->pOrderBy==0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "4094:     if( pSub->pOrderBy ){",
          "",
          "[Added Lines]",
          "4092:     if( pSub->pOrderBy && (pParent->selFlags & SF_NoopOrderBy)==0 ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5791:     sqlite3ExprListDelete(db, p->pOrderBy);",
          "5792:     p->pOrderBy = 0;",
          "5793:     p->selFlags &= ~SF_Distinct;",
          "5794:   }",
          "5795:   sqlite3SelectPrep(pParse, p, 0);",
          "5796:   if( pParse->nErr || db->mallocFailed ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5792:     p->selFlags |= SF_NoopOrderBy;",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "test/selectA.test||test/selectA.test": [
          "File: test/selectA.test -> test/selectA.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1446:   SELECT * FROM (SELECT a FROM t1 UNION SELECT b FROM t2) WHERE a=a;",
          "1447: } {12345}",
          "1450: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1449: # 2020-06-15 ticket 8f157e8010b22af0",
          "1450: #",
          "1451: reset_db",
          "1452: do_execsql_test 7.1 {",
          "1453:   CREATE TABLE t1(c1);     INSERT INTO t1 VALUES(12),(123),(1234),(NULL),('abc');",
          "1454:   CREATE TABLE t2(c2);     INSERT INTO t2 VALUES(44),(55),(123);",
          "1455:   CREATE TABLE t3(c3,c4);  INSERT INTO t3 VALUES(66,1),(123,2),(77,3);",
          "1456:   CREATE VIEW t4 AS SELECT c3 FROM t3;",
          "1457:   CREATE VIEW t5 AS SELECT c3 FROM t3 ORDER BY c4;",
          "1458: }",
          "1459: do_execsql_test 7.2 {",
          "1460:   SELECT * FROM t1, t2 WHERE c1=(SELECT 123 INTERSECT SELECT c2 FROM t4) AND c1=123;",
          "1461: } {123 123}",
          "1462: do_execsql_test 7.3 {",
          "1463:   SELECT * FROM t1, t2 WHERE c1=(SELECT 123 INTERSECT SELECT c2 FROM t5) AND c1=123;",
          "1464: } {123 123}",
          "1465: do_execsql_test 7.4 {",
          "1466:   CREATE TABLE a(b);",
          "1467:   CREATE VIEW c(d) AS SELECT b FROM a ORDER BY b;",
          "1468:   SELECT sum(d) OVER( PARTITION BY(SELECT 0 FROM c JOIN a WHERE b =(SELECT b INTERSECT SELECT d FROM c) AND b = 123)) FROM c;",
          "1469: } {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "82b0f106ce12c3b14508f8a395d0fc2fbf95244a",
      "candidate_info": {
        "commit_hash": "82b0f106ce12c3b14508f8a395d0fc2fbf95244a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/82b0f106ce12c3b14508f8a395d0fc2fbf95244a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/date.c",
          "src/sqliteInt.h",
          "src/util.c",
          "src/vdbemem.c"
        ],
        "message": "Add the sqlite3Int64ToText() routine and use it to convert integers to text, as it is much faster than the generic text formatter.\n\nFossilOrigin-Name: 14eed318aa9e6e16d1aa13a9f34e3822aa135c39ba06c77df7743509fed6c95e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/date.c||src/date.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/util.c||src/util.c",
          "src/vdbemem.c||src/vdbemem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6d258c3c7ecafa1114e4a63739971ff527580868659c2f2c47d2c0adb92c1453",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/date.c||src/date.c": [
          "File: src/date.c -> src/date.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1112:         case 'm':  sqlite3_snprintf(3, &z[j],\"%02d\",x.M); j+=2; break;",
          "1113:         case 'M':  sqlite3_snprintf(3, &z[j],\"%02d\",x.m); j+=2; break;",
          "1114:         case 's': {",
          "1117:           j += sqlite3Strlen30(&z[j]);",
          "1118:           break;",
          "1119:         }",
          "",
          "[Removed Lines]",
          "1115:           sqlite3_snprintf(30,&z[j],\"%lld\",",
          "1116:                            (i64)(x.iJD/1000 - 21086676*(i64)10000));",
          "",
          "[Added Lines]",
          "1115:           i64 iS = (i64)(x.iJD/1000 - 21086676*(i64)10000);",
          "1116:           sqlite3Int64ToText(iS, &z[j]);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4462: int sqlite3FixExprList(DbFixer*, ExprList*);",
          "4463: int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);",
          "4464: int sqlite3RealSameAsInt(double,sqlite3_int64);",
          "4465: int sqlite3AtoF(const char *z, double*, int, u8);",
          "4466: int sqlite3GetInt32(const char *, int*);",
          "4467: int sqlite3Atoi(const char*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4465: void sqlite3Int64ToText(i64,char*);",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "595: #pragma warning(default : 4756)",
          "596: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "603: void sqlite3Int64ToText(i64 v, char *zOut){",
          "604:   int i;",
          "605:   u64 x;",
          "606:   char zTemp[22];",
          "607:   if( v<0 ){",
          "608:     x = (v==SMALLEST_INT64) ? ((u64)1)<<63 : -v;",
          "609:   }else{",
          "610:     x = v;",
          "611:   }",
          "612:   i = sizeof(zTemp)-2;",
          "613:   zTemp[sizeof(zTemp)-1] = 0;",
          "614:   do{",
          "615:     zTemp[i--] = (x%10) + '0';",
          "616:     x = x/10;",
          "617:   }while( x );",
          "618:   if( v<0 ) zTemp[i--] = '-';",
          "619:   memcpy(zOut, &zTemp[i+1], sizeof(zTemp)-1-i);",
          "620: }",
          "",
          "---------------"
        ],
        "src/vdbemem.c||src/vdbemem.c": [
          "File: src/vdbemem.c -> src/vdbemem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "104: static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){",
          "105:   StrAccum acc;",
          "106:   assert( p->flags & (MEM_Int|MEM_Real|MEM_IntReal) );",
          "108:   if( p->flags & MEM_Int ){",
          "112:   }else{",
          "114:   }",
          "117: }",
          "119: #ifdef SQLITE_DEBUG",
          "",
          "[Removed Lines]",
          "107:   sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);",
          "109:     sqlite3_str_appendf(&acc, \"%lld\", p->u.i);",
          "110:   }else if( p->flags & MEM_IntReal ){",
          "111:     sqlite3_str_appendf(&acc, \"%!.15g\", (double)p->u.i);",
          "113:     sqlite3_str_appendf(&acc, \"%!.15g\", p->u.r);",
          "115:   assert( acc.zText==zBuf && acc.mxAlloc<=0 );",
          "",
          "[Added Lines]",
          "107:   assert( sz>22 );",
          "109:     sqlite3Int64ToText(p->u.i, zBuf);",
          "111:     sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);",
          "112:     sqlite3_str_appendf(&acc, \"%!.15g\",",
          "113:          (p->flags & MEM_IntReal)!=0 ? (double)p->u.i : p->u.r);",
          "114:     assert( acc.zText==zBuf && acc.mxAlloc<=0 );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ecc05bc3fb414a0a184b4d69d5ecc38ddb24951",
      "candidate_info": {
        "commit_hash": "3ecc05bc3fb414a0a184b4d69d5ecc38ddb24951",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/3ecc05bc3fb414a0a184b4d69d5ecc38ddb24951",
        "files": [
          "manifest",
          "manifest.uuid",
          "tool/lemon.c"
        ],
        "message": "Fix goofy string formatting in lemon.c that dates from the K&amp;R-C days.\n\nFossilOrigin-Name: 48ba5e5a2227257cebafacbb09e9dd91d9b89ab2d52a8b4e4113c1d017d95f41",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "tool/lemon.c||tool/lemon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4d6d2fc046d586a1e5989bbb2757f13d0371fbfad0acf45a0e2fd77dffd8d8f9",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "910:     sp = Symbol_find(lemp->start);",
          "911:     if( sp==0 ){",
          "912:       ErrorMsg(lemp->filename,0,",
          "916:       lemp->errorcnt++;",
          "917:       sp = lemp->startRule->lhs;",
          "918:     }",
          "",
          "[Removed Lines]",
          "913: \"The specified start symbol \\\"%s\\\" is not \\",
          "914: in a nonterminal of the grammar.  \\\"%s\\\" will be used as the start \\",
          "915: symbol instead.\",lemp->start,lemp->startRule->lhs->name);",
          "",
          "[Added Lines]",
          "913:         \"The specified start symbol \\\"%s\\\" is not \"",
          "914:         \"in a nonterminal of the grammar.  \\\"%s\\\" will be used as the start \"",
          "915:         \"symbol instead.\",lemp->start,lemp->startRule->lhs->name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "928:     for(i=0; i<rp->nrhs; i++){",
          "930:         ErrorMsg(lemp->filename,0,",
          "934:         lemp->errorcnt++;",
          "935:       }",
          "936:     }",
          "",
          "[Removed Lines]",
          "931: \"The start symbol \\\"%s\\\" occurs on the \\",
          "932: right-hand side of a rule. This will result in a parser which \\",
          "933: does not work properly.\",sp->name);",
          "",
          "[Added Lines]",
          "931:           \"The start symbol \\\"%s\\\" occurs on the \"",
          "932:           \"right-hand side of a rule. This will result in a parser which \"",
          "933:           \"does not work properly.\",sp->name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2274:       }else if( x[0]=='{' ){",
          "2275:         if( psp->prevrule==0 ){",
          "2276:           ErrorMsg(psp->filename,psp->tokenlineno,",
          "2279:           psp->errorcnt++;",
          "2280:         }else if( psp->prevrule->code!=0 ){",
          "2281:           ErrorMsg(psp->filename,psp->tokenlineno,",
          "2284:           psp->errorcnt++;",
          "2285:         }else if( strcmp(x, \"{NEVER-REDUCE\")==0 ){",
          "2286:           psp->prevrule->neverReduce = 1;",
          "",
          "[Removed Lines]",
          "2277: \"There is no prior rule upon which to attach the code \\",
          "2278: fragment which begins on this line.\");",
          "2282: \"Code fragment beginning on this line is not the first \\",
          "2283: to follow the previous rule.\");",
          "",
          "[Added Lines]",
          "2277:             \"There is no prior rule upon which to attach the code \"",
          "2278:             \"fragment which begins on this line.\");",
          "2282:             \"Code fragment beginning on this line is not the first \"",
          "2283:             \"to follow the previous rule.\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2309:         psp->errorcnt++;",
          "2310:       }else if( psp->prevrule->precsym!=0 ){",
          "2311:         ErrorMsg(psp->filename,psp->tokenlineno,",
          "2314:         psp->errorcnt++;",
          "2315:       }else{",
          "2316:         psp->prevrule->precsym = Symbol_new(x);",
          "",
          "[Removed Lines]",
          "2312: \"Precedence mark on this line is not the first \\",
          "2313: to follow the previous rule.\");",
          "",
          "[Added Lines]",
          "2312:           \"Precedence mark on this line is not the first \"",
          "2313:           \"to follow the previous rule.\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2913:       }",
          "2914:       if( c==0 ){",
          "2915:         ErrorMsg(ps.filename,startline,",
          "2917:         ps.errorcnt++;",
          "2918:         nextcp = cp;",
          "2919:       }else{",
          "",
          "[Removed Lines]",
          "2916: \"String starting on this line is not terminated before the end of the file.\");",
          "",
          "[Added Lines]",
          "2916:             \"String starting on this line is not terminated before \"",
          "2917:             \"the end of the file.\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2952:       }",
          "2953:       if( c==0 ){",
          "2954:         ErrorMsg(ps.filename,ps.tokenlineno,",
          "2956:         ps.errorcnt++;",
          "2957:         nextcp = cp;",
          "2958:       }else{",
          "",
          "[Removed Lines]",
          "2955: \"C code starting on this line is not terminated before the end of the file.\");",
          "",
          "[Added Lines]",
          "2956:           \"C code starting on this line is not terminated before \"",
          "2957:           \"the end of the file.\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0add948ea5ee4796bcb65e2cfeee6e62eff9c28",
      "candidate_info": {
        "commit_hash": "d0add948ea5ee4796bcb65e2cfeee6e62eff9c28",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d0add948ea5ee4796bcb65e2cfeee6e62eff9c28",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/exclusive.test"
        ],
        "message": "Update test file exclusive.test so that it works with the \"journaltest\" permutation.\n\nFossilOrigin-Name: 4daf94d83319231e42243625c804d5db2d14f10fa5ea1a1f358c3603c47b955b",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/exclusive.test||test/exclusive.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 934ee8bdb481a5cbd3d9c5f53028073129d3bca4fee14fe4a49bbf9c0c9d74f7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/exclusive.test||test/exclusive.test": [
          "File: test/exclusive.test -> test/exclusive.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "512: } {exclusive}",
          "514: # 2019-12-26 ticket fb3b3024ea238d5c",
          "532: } ;# atomic_batch_write==0",
          "",
          "[Removed Lines]",
          "515: do_test exclusive-7.1 {",
          "516:   db close",
          "517:   forcedelete test.db test.db-journal test.db-wal",
          "518:   sqlite3 db test.db",
          "519:   # The following sequence of pragmas would trigger an assert()",
          "520:   # associated with Pager.changeCountDone inside of assert_pager_state(),",
          "521:   # prior to the fix.",
          "522:   db eval {",
          "523:     PRAGMA locking_mode = EXCLUSIVE;",
          "524:     PRAGMA journal_mode = WAL;",
          "525:     PRAGMA locking_mode = NORMAL;",
          "526:     PRAGMA user_version;",
          "527:     PRAGMA journal_mode = DELETE;",
          "528:   }",
          "529: } {exclusive wal normal 0 delete}",
          "",
          "[Added Lines]",
          "515: if {[permutation]!=\"journaltest\"} {",
          "516:   # The custom VFS used by the \"journaltest\" permutation cannot open the",
          "517:   # shared-memory file. So, while it is able to switch the db file to",
          "518:   # journal_mode=WAL when locking_mode=EXCLUSIVE, it can no longer access",
          "519:   # it once the locking_mode is changed back to NORMAL.",
          "520:   do_test exclusive-7.1 {",
          "521:     db close",
          "522:     forcedelete test.db test.db-journal test.db-wal",
          "523:     sqlite3 db test.db",
          "524:     # The following sequence of pragmas would trigger an assert()",
          "525:     # associated with Pager.changeCountDone inside of assert_pager_state(),",
          "526:     # prior to the fix.",
          "527:     db eval {",
          "528:       PRAGMA locking_mode = EXCLUSIVE;",
          "529:       PRAGMA journal_mode = WAL;",
          "530:       PRAGMA locking_mode = NORMAL;",
          "531:       PRAGMA user_version;",
          "532:       PRAGMA journal_mode = DELETE;",
          "533:     }",
          "534:   } {exclusive wal normal 0 delete}",
          "535: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-36148",
  "cve_desc": "An issue was discovered in ACRN before 2.5. dmar_free_irte in hypervisor/arch/x86/vtd.c allows an irte_alloc_bitmap buffer overflow.",
  "repo": "projectacrn/acrn-hypervisor",
  "patch_hash": "25c0e3817eb332660dd63d1d4522e63dcc94e79a",
  "patch_info": {
    "commit_hash": "25c0e3817eb332660dd63d1d4522e63dcc94e79a",
    "repo": "projectacrn/acrn-hypervisor",
    "commit_url": "https://github.com/projectacrn/acrn-hypervisor/commit/25c0e3817eb332660dd63d1d4522e63dcc94e79a",
    "files": [
      "hypervisor/arch/x86/guest/assign.c",
      "hypervisor/arch/x86/vtd.c"
    ],
    "message": "hv: validate input for dmar_free_irte function\n\n Malicious input 'index' may trigger buffer\n overflow on array 'irte_alloc_bitmap[]'.\n\n This patch validate that 'index' shall be\n less than 'CONFIG_MAX_IR_ENTRIES' and also\n remove unnecessary check on 'index' in\n 'ptirq_free_irte()' function with this fix.\n\nTracked-On: #6132\nSigned-off-by: Yonghua Huang <yonghua.huang@intel.com>",
    "before_after_code_files": [
      "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c",
      "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
    ]
  },
  "patch_diff": {
    "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c": [
      "File: hypervisor/arch/x86/guest/assign.c -> hypervisor/arch/x86/guest/assign.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "72: {",
      "73:  struct intr_source intr_src;",
      "84:  }",
      "85: }",
      "",
      "[Removed Lines]",
      "75:  if (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {",
      "76:   if (entry->intr_type == PTDEV_INTR_MSI) {",
      "77:    intr_src.is_msi = true;",
      "78:    intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
      "79:   } else {",
      "80:    intr_src.is_msi = false;",
      "81:    intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);",
      "82:   }",
      "83:   dmar_free_irte(&intr_src, entry->irte_idx);",
      "",
      "[Added Lines]",
      "75:  if (entry->intr_type == PTDEV_INTR_MSI) {",
      "76:   intr_src.is_msi = true;",
      "77:   intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
      "78:  } else {",
      "79:   intr_src.is_msi = false;",
      "80:   intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);",
      "82:  dmar_free_irte(&intr_src, entry->irte_idx);",
      "",
      "---------------"
    ],
    "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c": [
      "File: hypervisor/arch/x86/vtd.c -> hypervisor/arch/x86/vtd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1398:   dmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);",
      "1399:  }",
      "1402:   ir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);",
      "1403:   ir_entry = ir_table + index;",
      "1404:   ir_entry->bits.remap.present = 0x0UL;",
      "",
      "[Removed Lines]",
      "1401:  if (is_dmar_unit_valid(dmar_unit, sid)) {",
      "",
      "[Added Lines]",
      "1401:  if (is_dmar_unit_valid(dmar_unit, sid) && (index < CONFIG_MAX_IR_ENTRIES)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4acaeb91bdfb0e90a0b3ef02735981db5ea92e44",
      "candidate_info": {
        "commit_hash": "4acaeb91bdfb0e90a0b3ef02735981db5ea92e44",
        "repo": "projectacrn/acrn-hypervisor",
        "commit_url": "https://github.com/projectacrn/acrn-hypervisor/commit/4acaeb91bdfb0e90a0b3ef02735981db5ea92e44",
        "files": [
          "hypervisor/arch/x86/guest/vlapic.c"
        ],
        "message": "hv: remove unnecessary ASSERT in vlapic_write\n\n vlapic_write handle 'offset' that is valid and ignore\n all other invalid 'offset'. so ASSERT on this 'offset'\n input is unnecessary.\n\n This patch removes above ASSERT to avoid potential\n hypervisor crash by guest malicious input when debug\n build is used.\n\nTracked-On: #6131\nSigned-off-by: Yonghua Huang <yonghua.huang@intel.com>",
        "before_after_code_files": [
          "hypervisor/arch/x86/guest/vlapic.c||hypervisor/arch/x86/guest/vlapic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/projectacrn/acrn-hypervisor/pull/6149"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hypervisor/arch/x86/guest/vlapic.c||hypervisor/arch/x86/guest/vlapic.c": [
          "File: hypervisor/arch/x86/guest/vlapic.c -> hypervisor/arch/x86/guest/vlapic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1469:  uint32_t data32 = (uint32_t)data;",
          "1470:  int32_t ret = 0;",
          "1475:  dev_dbg(DBG_LEVEL_VLAPIC, \"vlapic write offset %#x, data %#lx\", offset, data);",
          "1477:  if (offset <= sizeof(*lapic)) {",
          "",
          "[Removed Lines]",
          "1472:  ASSERT(((offset & 0xfU) == 0U) && (offset < PAGE_SIZE),",
          "1473:   \"%s: invalid offset %#x\", __func__, offset);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "022df1fb2e6fece243b5cb82a761007dfa4ff72a",
      "candidate_info": {
        "commit_hash": "022df1fb2e6fece243b5cb82a761007dfa4ff72a",
        "repo": "projectacrn/acrn-hypervisor",
        "commit_url": "https://github.com/projectacrn/acrn-hypervisor/commit/022df1fb2e6fece243b5cb82a761007dfa4ff72a",
        "files": [
          "hypervisor/arch/x86/vtd.c",
          "hypervisor/include/arch/x86/asm/vtd.h",
          "hypervisor/include/lib/util.h",
          "misc/hv_prebuild/static_checks.c"
        ],
        "message": "hv: align the MAX_IR_ENTRIES to MAX_PT_IRQ_ENTRIES\n\nThe CONFIG_MAX_IR_ENTRIES and CONFIG_MAX_PT_IRQ_ENTRIES are separate\nconfiguration items, and they can be configured through configuration tool\n\nWhen the number of PT irq entries are more than IR entries, then some\npassthrough devices' irqs may failed to be protected by interrupt\nremapping or automatically injected by post-interrupt mechanism.\nAnd it waste memory if the CONFIG_MAX_IR_ENTRIES is larger.\n\nThis patch replace the CONFIG_MAX_IR_ENTRIES to MAX_IR_ENTRIES and\nenforce it align to CONFIG_PT_IRQ_ENTRIES and round up to > 2^n as the\nIRTA_REG spec.This way can enforce all PT irqs works with IR or PI\nmechanism.\n\nTracked-On: #6745\nSigned-off-by: Chenli Wei <chenli.wei@intel.com>\nAcked-by: Eddie Dong <eddie.dong@intel.com>\nReviewed-by: Wang, Yu1 <yu1.wang@intel.com>",
        "before_after_code_files": [
          "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c",
          "hypervisor/include/arch/x86/asm/vtd.h||hypervisor/include/arch/x86/asm/vtd.h",
          "hypervisor/include/lib/util.h||hypervisor/include/liutil.h",
          "misc/hv_prebuild/static_checks.c||misc/hv_prebuild/static_checks.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
          ],
          "candidate": [
            "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
          ]
        }
      },
      "candidate_diff": {
        "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c": [
          "File: hypervisor/arch/x86/vtd.c -> hypervisor/arch/x86/vtd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:  uint64_t root_table_addr;",
          "130:  uint64_t ir_table_addr;",
          "133:  uint64_t qi_queue;",
          "134:  uint16_t qi_tail;",
          "",
          "[Removed Lines]",
          "131:  uint64_t irte_alloc_bitmap[CONFIG_MAX_IR_ENTRIES / 64U];",
          "132:  uint64_t irte_reserved_bitmap[CONFIG_MAX_IR_ENTRIES / 64U];",
          "",
          "[Added Lines]",
          "131:  uint64_t irte_alloc_bitmap[MAX_IR_ENTRIES / 64U];",
          "132:  uint64_t irte_reserved_bitmap[MAX_IR_ENTRIES / 64U];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "152: };",
          "154: struct intr_remap_table {",
          "156: };",
          "158: static inline uint8_t *get_root_table(uint32_t dmar_index)",
          "",
          "[Removed Lines]",
          "155:  struct page tables[CONFIG_MAX_IR_ENTRIES/DMAR_NUM_IR_ENTRIES_PER_PAGE];",
          "",
          "[Added Lines]",
          "155:  struct page tables[MAX_IR_ENTRIES/DMAR_NUM_IR_ENTRIES_PER_PAGE];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "672:  spinlock_obtain(&(dmar_unit->lock));",
          "676:  address = dmar_unit->ir_table_addr | DMAR_IR_ENABLE_EIM | size;",
          "678:  iommu_write64(dmar_unit, DMAR_IRTA_REG, address);",
          "",
          "[Removed Lines]",
          "675:  size = (uint8_t) fls32(CONFIG_MAX_IR_ENTRIES) - 1U;",
          "",
          "[Added Lines]",
          "675:  size = (uint8_t) fls32(MAX_IR_ENTRIES) - 1U;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1276:  ASSERT((bitmap_weight(num) == 1U) && (num <= 32U));",
          "1278:  spinlock_obtain(&dmar_unit->lock);",
          "1280:   test_mask = mask << (irte_idx & 0x3FU);",
          "1281:   if ((dmar_unit->irte_alloc_bitmap[irte_idx >> 6U] & test_mask) == 0UL) {",
          "1282:    dmar_unit->irte_alloc_bitmap[irte_idx >> 6U] |= test_mask;",
          "",
          "[Removed Lines]",
          "1279:  for (irte_idx = 0U; irte_idx < CONFIG_MAX_IR_ENTRIES; irte_idx += num) {",
          "",
          "[Added Lines]",
          "1279:  for (irte_idx = 0U; irte_idx < MAX_IR_ENTRIES; irte_idx += num) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1285:  }",
          "1286:  spinlock_release(&dmar_unit->lock);",
          "1289: }",
          "1291: static bool is_irte_reserved(const struct dmar_drhd_rt *dmar_unit, uint16_t index)",
          "",
          "[Removed Lines]",
          "1288:  return (irte_idx < CONFIG_MAX_IR_ENTRIES) ? irte_idx: INVALID_IRTE_ID;",
          "",
          "[Added Lines]",
          "1288:  return (irte_idx < MAX_IR_ENTRIES) ? irte_idx: INVALID_IRTE_ID;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1310:  if (is_dmar_unit_valid(dmar_unit, sid)) {",
          "1313:    dmar_unit->irte_reserved_bitmap[*start_id >> 6U] |= mask << (*start_id & 0x3FU);",
          "1314:   }",
          "1315:   ret = 0;",
          "",
          "[Removed Lines]",
          "1312:   if (*start_id < CONFIG_MAX_IR_ENTRIES) {",
          "",
          "[Added Lines]",
          "1312:   if (*start_id < MAX_IR_ENTRIES) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1346:   if (idx_in == INVALID_IRTE_ID) {",
          "1348:   }",
          "1350:    ir_entry = ir_table + *idx_out;",
          "1352:    if (intr_src->pid_paddr != 0UL) {",
          "",
          "[Removed Lines]",
          "1349:   if (*idx_out < CONFIG_MAX_IR_ENTRIES) {",
          "",
          "[Added Lines]",
          "1349:   if (*idx_out < MAX_IR_ENTRIES) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1397:   dmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);",
          "1398:  }",
          "1401:   ir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);",
          "1402:   ir_entry = ir_table + index;",
          "1403:   ir_entry->bits.remap.present = 0x0UL;",
          "",
          "[Removed Lines]",
          "1400:  if (is_dmar_unit_valid(dmar_unit, sid) && (index < CONFIG_MAX_IR_ENTRIES)) {",
          "",
          "[Added Lines]",
          "1400:  if (is_dmar_unit_valid(dmar_unit, sid) && (index < MAX_IR_ENTRIES)) {",
          "",
          "---------------"
        ],
        "hypervisor/include/arch/x86/asm/vtd.h||hypervisor/include/arch/x86/asm/vtd.h": [
          "File: hypervisor/include/arch/x86/asm/vtd.h -> hypervisor/include/arch/x86/asm/vtd.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: enum acpi_dmar_scope_type {",
          "47:  ACPI_DMAR_SCOPE_TYPE_NOT_USED       = 0,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: #if (CONFIG_MAX_PT_IRQ_ENTRIES <= 256)",
          "47: #define MAX_IR_ENTRIES 256",
          "48: #else",
          "49: #define MAX_IR_ENTRIES  powerof2_roundup(CONFIG_MAX_PT_IRQ_ENTRIES)",
          "50: #endif",
          "",
          "---------------"
        ],
        "hypervisor/include/lib/util.h||hypervisor/include/liutil.h": [
          "File: hypervisor/include/lib/util.h -> hypervisor/include/liutil.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #define STRINGIFY(x) #x",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "misc/hv_prebuild/static_checks.c||misc/hv_prebuild/static_checks.c": [
          "File: misc/hv_prebuild/static_checks.c -> misc/hv_prebuild/static_checks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include <asm/guest/vcpu.h>",
          "10: #include <asm/mmu.h>",
          "11: #include <asm/guest/trusty.h>",
          "13: #define CAT__(A,B) A ## B",
          "14: #define CAT_(A,B) CAT__(A,B)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include <asm/vtd.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28: #error \"CONFIG_HV_RAM_SIZE must be integral multiple of 2MB\"",
          "29: #endif",
          "33: #endif",
          "",
          "[Removed Lines]",
          "31: #if ((CONFIG_MAX_IR_ENTRIES < 256U) || (CONFIG_MAX_IR_ENTRIES & (CONFIG_MAX_IR_ENTRIES -1)) != 0U)",
          "32: #error \"CONFIG_MAX_IR_ENTRIES must >=256 and be 2^n\"",
          "",
          "[Added Lines]",
          "32: #if ((MAX_IR_ENTRIES < 256U) || (MAX_IR_ENTRIES > 0x10000U) || (MAX_IR_ENTRIES & (MAX_IR_ENTRIES -1)) != 0U)",
          "33: #error \"MAX_IR_ENTRIES must in the region of [256,0x10000] and be 2^n\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7bfcc673a67906c54ec9762cbb440763d1d4b1f9",
      "candidate_info": {
        "commit_hash": "7bfcc673a67906c54ec9762cbb440763d1d4b1f9",
        "repo": "projectacrn/acrn-hypervisor",
        "commit_url": "https://github.com/projectacrn/acrn-hypervisor/commit/7bfcc673a67906c54ec9762cbb440763d1d4b1f9",
        "files": [
          "hypervisor/arch/x86/guest/assign.c",
          "hypervisor/arch/x86/vtd.c",
          "hypervisor/common/ptdev.c",
          "hypervisor/dm/vpci/vmsi.c",
          "hypervisor/dm/vpci/vmsix.c",
          "hypervisor/include/arch/x86/guest/assign.h",
          "hypervisor/include/common/ptdev.h"
        ],
        "message": "hv: ptirq: associate an irte with ptirq_remapping_info entry\n\nFor a ptirq_remapping_info entry, when build IRTE:\n- If the caller provides a valid IRTE, use the IRET\n- If the caller doesn't provide a valid IRTE, allocate a IRET when the\nentry doesn't have a valid IRTE, in this case, the IRET will be freed\nwhen free the entry.\n\nTracked-On:#4831\nSigned-off-by: Binbin Wu <binbin.wu@intel.com>\nAcked-by: Eddie Dong <eddie.dong@intel.com>",
        "before_after_code_files": [
          "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c",
          "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c",
          "hypervisor/common/ptdev.c||hypervisor/common/ptdev.c",
          "hypervisor/dm/vpci/vmsi.c||hypervisor/dm/vpci/vmsi.c",
          "hypervisor/dm/vpci/vmsix.c||hypervisor/dm/vpci/vmsix.c",
          "hypervisor/include/arch/x86/guest/assign.h||hypervisor/include/arch/x86/guest/assign.h",
          "hypervisor/include/common/ptdev.h||hypervisor/include/common/ptdev.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c",
            "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
          ],
          "candidate": [
            "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c",
            "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
          ]
        }
      },
      "candidate_diff": {
        "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c": [
          "File: hypervisor/arch/x86/guest/assign.c -> hypervisor/arch/x86/guest/assign.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71: {",
          "72:  struct intr_source intr_src;",
          "80:  }",
          "83: }",
          "",
          "[Removed Lines]",
          "74:  if (entry->intr_type == PTDEV_INTR_MSI) {",
          "75:   intr_src.is_msi = true;",
          "76:   intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
          "77:  } else {",
          "78:   intr_src.is_msi = false;",
          "79:   intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);",
          "82:  dmar_free_irte(&intr_src, (uint16_t)entry->allocated_pirq);",
          "",
          "[Added Lines]",
          "74:  if (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {",
          "75:   if (entry->intr_type == PTDEV_INTR_MSI) {",
          "76:    intr_src.is_msi = true;",
          "77:    intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
          "78:   } else {",
          "79:    intr_src.is_msi = false;",
          "80:    intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);",
          "81:   }",
          "82:   dmar_free_irte(&intr_src, entry->irte_idx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91: static void ptirq_build_physical_msi(struct acrn_vm *vm,",
          "93: {",
          "94:  uint64_t vdmask, pdmask;",
          "95:  uint32_t dest, delmode, dest_mask;",
          "",
          "[Removed Lines]",
          "92:  struct ptirq_remapping_info *entry, uint32_t vector, uint64_t pid_paddr)",
          "",
          "[Added Lines]",
          "93:  struct ptirq_remapping_info *entry, uint32_t vector, uint64_t pid_paddr, uint16_t irte_idx)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:  intr_src.is_msi = true;",
          "127:  intr_src.pid_paddr = pid_paddr;",
          "128:  intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
          "131:  if (ret == 0) {",
          "132:   entry->pmsi.data.full = 0U;",
          "133:   entry->pmsi.addr.full = 0UL;",
          "134:   if (ir_index.index != INVALID_IRTE_ID) {",
          "",
          "[Removed Lines]",
          "129:  ret = dmar_assign_irte(&intr_src, &irte, (uint16_t)entry->allocated_pirq, &ir_index.index);",
          "",
          "[Added Lines]",
          "130:  if (entry->irte_idx == INVALID_IRTE_ID) {",
          "131:   entry->irte_idx = irte_idx;",
          "132:  }",
          "133:  ret = dmar_assign_irte(&intr_src, &irte, entry->irte_idx, &ir_index.index);",
          "138:   entry->irte_idx = ir_index.index;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "223:   intr_src.is_msi = false;",
          "224:   intr_src.pid_paddr = 0UL;",
          "225:   intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(phys_irq);",
          "228:   if (ret == 0) {",
          "229:    if (ir_index.index != INVALID_IRTE_ID) {",
          "230:     rte.ir_bits.vector = vector;",
          "231:     rte.ir_bits.constant = 0U;",
          "",
          "[Removed Lines]",
          "226:   ret = dmar_assign_irte(&intr_src, &irte, (uint16_t)phys_irq, &ir_index.index);",
          "",
          "[Added Lines]",
          "231:   ret = dmar_assign_irte(&intr_src, &irte, entry->irte_idx, &ir_index.index);",
          "234:    entry->irte_idx = ir_index.index;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "320:   intr_src.is_msi = true;",
          "321:   intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
          "324:   dev_dbg(DBG_LEVEL_IRQ, \"VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d\",",
          "325:    vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);",
          "",
          "[Removed Lines]",
          "322:   dmar_free_irte(&intr_src, (uint16_t)entry->allocated_pirq);",
          "",
          "[Added Lines]",
          "328:   dmar_free_irte(&intr_src, entry->irte_idx);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "408:    intr_src.is_msi = false;",
          "409:    intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(phys_irq);",
          "412:    dev_dbg(DBG_LEVEL_IRQ,",
          "413:     \"deactive %s intx entry:pgsi=%d, pirq=%d \",",
          "414:     (vgsi_ctlr == INTX_CTLR_PIC) ? \"vPIC\" : \"vIOAPIC\",",
          "",
          "[Removed Lines]",
          "411:    dmar_free_irte(&intr_src, (uint16_t)phys_irq);",
          "",
          "[Added Lines]",
          "417:    dmar_free_irte(&intr_src, entry->irte_idx);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "565: int32_t ptirq_prepare_msix_remap(struct acrn_vm *vm, uint16_t virt_bdf, uint16_t phys_bdf,",
          "567: {",
          "568:  struct ptirq_remapping_info *entry;",
          "569:  int32_t ret = -ENODEV;",
          "",
          "[Removed Lines]",
          "566:     uint16_t entry_nr, struct msi_info *info)",
          "",
          "[Added Lines]",
          "572:     uint16_t entry_nr, struct msi_info *info, uint16_t irte_idx)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "594:    } else if (vlapic_state == VM_VLAPIC_XAPIC) {",
          "600:    } else if (vlapic_state == VM_VLAPIC_TRANSITION) {",
          "",
          "[Removed Lines]",
          "593:     ptirq_build_physical_msi(vm, entry, (uint32_t)info->data.bits.vector, 0UL);",
          "599:     ptirq_build_physical_msi(vm, entry, irq_to_vector(entry->allocated_pirq), 0UL);",
          "",
          "[Added Lines]",
          "599:     ptirq_build_physical_msi(vm, entry, (uint32_t)info->data.bits.vector, 0UL, irte_idx);",
          "605:     ptirq_build_physical_msi(vm, entry, irq_to_vector(entry->allocated_pirq), 0UL, irte_idx);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "615:    if (is_pi_capable(vm) && (vcpu != NULL)) {",
          "616:     ptirq_build_physical_msi(vm, entry,",
          "618:    } else {",
          "621:    }",
          "622:   }",
          "",
          "[Removed Lines]",
          "617:      (uint32_t)info->data.bits.vector, hva2hpa(get_pi_desc(vcpu)));",
          "620:     ptirq_build_physical_msi(vm, entry, irq_to_vector(entry->allocated_pirq), 0UL);",
          "",
          "[Added Lines]",
          "623:      (uint32_t)info->data.bits.vector, hva2hpa(get_pi_desc(vcpu)), irte_idx);",
          "626:     ptirq_build_physical_msi(vm, entry, irq_to_vector(entry->allocated_pirq), 0UL, irte_idx);",
          "",
          "---------------"
        ],
        "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c": [
          "File: hypervisor/arch/x86/vtd.c -> hypervisor/arch/x86/vtd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:  uint64_t root_table_addr;",
          "130:  uint64_t ir_table_addr;",
          "132:  uint64_t qi_queue;",
          "133:  uint16_t qi_tail;",
          "",
          "[Removed Lines]",
          "131:  uint64_t irte_alloc_bitmap[CONFIG_MAX_IR_ENTRIES/64U];",
          "",
          "[Added Lines]",
          "131:  uint64_t irte_alloc_bitmap[CONFIG_MAX_IR_ENTRIES / 64U];",
          "132:  uint64_t irte_reserved_bitmap[CONFIG_MAX_IR_ENTRIES / 64U];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1284:  return (irte_idx < CONFIG_MAX_IR_ENTRIES) ? irte_idx: INVALID_IRTE_ID;",
          "1285: }",
          "1287: int32_t dmar_assign_irte(const struct intr_source *intr_src, union dmar_ir_entry *irte,",
          "1288:  uint16_t idx_in, uint16_t *idx_out)",
          "1289: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1288: static bool is_irte_reserved(const struct dmar_drhd_rt *dmar_unit, uint16_t index)",
          "1289: {",
          "1290:  return ((dmar_unit->irte_reserved_bitmap[index >> 6U] & (1UL << (index & 0x3FU))) != 0UL);",
          "1291: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1369:   iommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));",
          "1370:   dmar_invalid_iec(dmar_unit, index, 0U, false);",
          "1371:  }",
          "1373: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1378:   if (!is_irte_reserved(dmar_unit, index)) {",
          "1379:    spinlock_obtain(&dmar_unit->lock);",
          "1380:    bitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);",
          "1381:    spinlock_release(&dmar_unit->lock);",
          "1382:   }",
          "",
          "---------------"
        ],
        "hypervisor/common/ptdev.c||hypervisor/common/ptdev.c": [
          "File: hypervisor/common/ptdev.c -> hypervisor/common/ptdev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include <ptdev.h>",
          "12: #include <irq.h>",
          "13: #include <logmsg.h>",
          "15: #define PTIRQ_ENTRY_HASHBITS 9U",
          "16: #define PTIRQ_ENTRY_HASHSIZE (1U << PTIRQ_ENTRY_HASHBITS)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include <vtd.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127:   entry->intr_type = intr_type;",
          "128:   entry->vm = vm;",
          "129:   entry->intr_count = 0UL;",
          "131:   INIT_LIST_HEAD(&entry->softirq_node);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131:   entry->irte_idx = INVALID_IRTE_ID;",
          "",
          "---------------"
        ],
        "hypervisor/dm/vpci/vmsi.c||hypervisor/dm/vpci/vmsi.c": [
          "File: hypervisor/dm/vpci/vmsi.c -> hypervisor/dm/vpci/vmsi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #include <ptdev.h>",
          "32: #include <assign.h>",
          "33: #include <vpci.h>",
          "34: #include \"vpci_priv.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: #include <vtd.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:  info.addr.full = (uint64_t)vmsi_addrlo | ((uint64_t)vmsi_addrhi << 32U);",
          "79:  info.data.full = vmsi_msgdata;",
          "82:   pci_pdev_write_cfg(pbdf, capoff + PCIR_MSI_ADDR, 0x4U, (uint32_t)info.addr.full);",
          "83:   if (vdev->msi.is_64bit) {",
          "84:    pci_pdev_write_cfg(pbdf, capoff + PCIR_MSI_ADDR_HIGH, 0x4U,",
          "",
          "[Removed Lines]",
          "81:  if (ptirq_prepare_msix_remap(vm, vdev->bdf.value, pbdf.value, 0U, &info) == 0) {",
          "",
          "[Added Lines]",
          "82:  if (ptirq_prepare_msix_remap(vm, vdev->bdf.value, pbdf.value, 0U, &info, INVALID_IRTE_ID) == 0) {",
          "",
          "---------------"
        ],
        "hypervisor/dm/vpci/vmsix.c||hypervisor/dm/vpci/vmsix.c": [
          "File: hypervisor/dm/vpci/vmsix.c -> hypervisor/dm/vpci/vmsix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #include <ept.h>",
          "37: #include <mmu.h>",
          "38: #include <logmsg.h>",
          "39: #include \"vpci_priv.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: #include <vtd.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:   info.addr.full = vdev->msix.table_entries[index].addr;",
          "88:   info.data.full = vdev->msix.table_entries[index].data;",
          "91:   if (ret == 0) {",
          "93:    pentry = get_msix_table_entry(vdev, index);",
          "",
          "[Removed Lines]",
          "90:   ret = ptirq_prepare_msix_remap(vpci2vm(vdev->vpci), vdev->bdf.value, vdev->pdev->bdf.value, (uint16_t)index, &info);",
          "",
          "[Added Lines]",
          "91:   ret = ptirq_prepare_msix_remap(vpci2vm(vdev->vpci), vdev->bdf.value, vdev->pdev->bdf.value,",
          "92:             (uint16_t)index, &info, INVALID_IRTE_ID);",
          "",
          "---------------"
        ],
        "hypervisor/include/arch/x86/guest/assign.h||hypervisor/include/arch/x86/guest/assign.h": [
          "File: hypervisor/include/arch/x86/guest/assign.h -> hypervisor/include/arch/x86/guest/assign.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: int32_t ptirq_prepare_msix_remap(struct acrn_vm *vm, uint16_t virt_bdf,  uint16_t phys_bdf,",
          "",
          "[Removed Lines]",
          "65:     uint16_t entry_nr, struct msi_info *info);",
          "",
          "[Added Lines]",
          "66:     uint16_t entry_nr, struct msi_info *info, uint16_t irte_idx);",
          "",
          "---------------"
        ],
        "hypervisor/include/common/ptdev.h||hypervisor/include/common/ptdev.h": [
          "File: hypervisor/include/common/ptdev.h -> hypervisor/include/common/ptdev.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:  struct list_head softirq_node;",
          "134:  struct msi_info vmsi;",
          "135:  struct msi_info pmsi;",
          "137:  uint64_t intr_count;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136:  uint16_t irte_idx;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "31980ce34536cdb4551a432fa83e7a64a06024c4",
      "candidate_info": {
        "commit_hash": "31980ce34536cdb4551a432fa83e7a64a06024c4",
        "repo": "projectacrn/acrn-hypervisor",
        "commit_url": "https://github.com/projectacrn/acrn-hypervisor/commit/31980ce34536cdb4551a432fa83e7a64a06024c4",
        "files": [
          "hypervisor/arch/x86/guest/assign.c",
          "hypervisor/arch/x86/vtd.c"
        ],
        "message": "hv: validate input for dmar_free_irte function\n\n Malicious input 'index' may trigger buffer\n overflow on array 'irte_alloc_bitmap[]'.\n\n This patch validate that 'index' shall be\n less than 'CONFIG_MAX_IR_ENTRIES' and also\n remove unnecessary check on 'index' in\n function 'ptirq_free_irte()' function with\n this fix.\n\nTracked-On: #6132\nSigned-off-by: Yonghua Huang <yonghua.huang@intel.com>",
        "before_after_code_files": [
          "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c",
          "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c",
            "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
          ],
          "candidate": [
            "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c",
            "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c"
          ]
        }
      },
      "candidate_diff": {
        "hypervisor/arch/x86/guest/assign.c||hypervisor/arch/x86/guest/assign.c": [
          "File: hypervisor/arch/x86/guest/assign.c -> hypervisor/arch/x86/guest/assign.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: {",
          "73:  struct intr_source intr_src;",
          "84:  }",
          "85: }",
          "",
          "[Removed Lines]",
          "75:  if (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {",
          "76:   if (entry->intr_type == PTDEV_INTR_MSI) {",
          "77:    intr_src.is_msi = true;",
          "78:    intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
          "79:   } else {",
          "80:    intr_src.is_msi = false;",
          "81:    intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);",
          "82:   }",
          "83:   dmar_free_irte(&intr_src, entry->irte_idx);",
          "",
          "[Added Lines]",
          "75:  if (entry->intr_type == PTDEV_INTR_MSI) {",
          "76:   intr_src.is_msi = true;",
          "77:   intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;",
          "78:  } else {",
          "79:   intr_src.is_msi = false;",
          "80:   intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);",
          "82:  dmar_free_irte(&intr_src, entry->irte_idx);",
          "",
          "---------------"
        ],
        "hypervisor/arch/x86/vtd.c||hypervisor/arch/x86/vtd.c": [
          "File: hypervisor/arch/x86/vtd.c -> hypervisor/arch/x86/vtd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1398:   dmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);",
          "1399:  }",
          "1402:   ir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);",
          "1403:   ir_entry = ir_table + index;",
          "1404:   ir_entry->bits.remap.present = 0x0UL;",
          "",
          "[Removed Lines]",
          "1401:  if (is_dmar_unit_valid(dmar_unit, sid)) {",
          "",
          "[Added Lines]",
          "1401:  if (is_dmar_unit_valid(dmar_unit, sid) && (index < CONFIG_MAX_IR_ENTRIES)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
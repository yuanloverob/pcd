{
  "cve_id": "CVE-2017-13715",
  "cve_desc": "The __skb_flow_dissect function in net/core/flow_dissector.c in the Linux kernel before 4.3 does not ensure that n_proto, ip_proto, and thoff are initialized, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a single crafted MPLS packet.",
  "repo": "torvalds/linux",
  "patch_hash": "a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
  "patch_info": {
    "commit_hash": "a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
    "files": [
      "net/core/flow_dissector.c"
    ],
    "message": "flow_dissector: Jump to exit code in __skb_flow_dissect\n\nInstead of returning immediately (on a parsing failure for instance) we\njump to cleanup code. This always sets protocol values in key_control\n(even on a failure there is still valid information in the key_tags that\nwas set before the problem was hit).\n\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/core/flow_dissector.c||net/core/flow_dissector.c"
    ]
  },
  "patch_diff": {
    "net/core/flow_dissector.c||net/core/flow_dissector.c": [
      "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130:  struct flow_dissector_key_tags *key_tags;",
      "131:  struct flow_dissector_key_keyid *key_keyid;",
      "132:  u8 ip_proto = 0;",
      "134:  if (!data) {",
      "135:   data = skb->data;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:  bool ret = false;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "171: ip:",
      "172:   iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);",
      "173:   if (!iph || iph->ihl < 5)",
      "175:   nhoff += iph->ihl * 4;",
      "177:   ip_proto = iph->protocol;",
      "",
      "[Removed Lines]",
      "174:    return false;",
      "",
      "[Added Lines]",
      "175:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "197: ipv6:",
      "198:   iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);",
      "199:   if (!iph)",
      "202:   ip_proto = iph->nexthdr;",
      "203:   nhoff += sizeof(struct ipv6hdr);",
      "",
      "[Removed Lines]",
      "200:    return false;",
      "",
      "[Added Lines]",
      "201:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "235:   vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);",
      "236:   if (!vlan)",
      "239:   if (skb_flow_dissector_uses_key(flow_dissector,",
      "240:       FLOW_DISSECTOR_KEY_VLANID)) {",
      "",
      "[Removed Lines]",
      "237:    return false;",
      "",
      "[Added Lines]",
      "238:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "256:   } *hdr, _hdr;",
      "257:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
      "258:   if (!hdr)",
      "260:   proto = hdr->proto;",
      "261:   nhoff += PPPOE_SES_HLEN;",
      "262:   switch (proto) {",
      "",
      "[Removed Lines]",
      "259:    return false;",
      "",
      "[Added Lines]",
      "260:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "265:   case htons(PPP_IPV6):",
      "266:    goto ipv6;",
      "267:   default:",
      "269:   }",
      "270:  }",
      "271:  case htons(ETH_P_TIPC): {",
      "",
      "[Removed Lines]",
      "268:    return false;",
      "",
      "[Added Lines]",
      "269:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "275:   } *hdr, _hdr;",
      "276:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
      "277:   if (!hdr)",
      "282:   if (skb_flow_dissector_uses_key(flow_dissector,",
      "283:       FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {",
      "",
      "[Removed Lines]",
      "278:    return false;",
      "279:   key_basic->n_proto = proto;",
      "280:   key_control->thoff = (u16)nhoff;",
      "",
      "[Added Lines]",
      "279:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "287:    key_addrs->tipcaddrs.srcnode = hdr->srcnode;",
      "288:    key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;",
      "289:   }",
      "291:  }",
      "293:  case htons(ETH_P_MPLS_UC):",
      "",
      "[Removed Lines]",
      "290:   return true;",
      "",
      "[Added Lines]",
      "289:   goto out_good;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "297:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,",
      "298:         hlen, &_hdr);",
      "299:   if (!hdr)",
      "302:   if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>",
      "303:        MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {",
      "",
      "[Removed Lines]",
      "300:    return false;",
      "",
      "[Added Lines]",
      "299:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "310:      htonl(MPLS_LS_LABEL_MASK);",
      "311:    }",
      "318:   }",
      "321:  }",
      "323:  case htons(ETH_P_FCOE):",
      "324:   key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
      "326:  default:",
      "328:  }",
      "330: ip_proto_again:",
      "",
      "[Removed Lines]",
      "313:    key_basic->n_proto = proto;",
      "314:    key_basic->ip_proto = ip_proto;",
      "315:    key_control->thoff = (u16)nhoff;",
      "317:    return true;",
      "320:   return true;",
      "327:   return false;",
      "",
      "[Added Lines]",
      "312:    goto out_good;",
      "315:   goto out_good;",
      "322:   goto out_bad;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "338:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
      "339:   if (!hdr)",
      "",
      "[Removed Lines]",
      "340:    return false;",
      "",
      "[Added Lines]",
      "335:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "357:            data, hlen, &_keyid);",
      "359:    if (!keyid)",
      "362:    if (skb_flow_dissector_uses_key(flow_dissector,",
      "363:        FLOW_DISSECTOR_KEY_GRE_KEYID)) {",
      "",
      "[Removed Lines]",
      "360:     return false;",
      "",
      "[Added Lines]",
      "355:     goto out_bad;",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "378:          sizeof(_eth),",
      "379:          data, hlen, &_eth);",
      "380:    if (!eth)",
      "382:    proto = eth->h_proto;",
      "383:    nhoff += sizeof(*eth);",
      "384:   }",
      "",
      "[Removed Lines]",
      "381:     return false;",
      "",
      "[Added Lines]",
      "376:     goto out_bad;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "395:   opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),",
      "396:            data, hlen, &_opthdr);",
      "397:   if (!opthdr)",
      "400:   ip_proto = opthdr[0];",
      "401:   nhoff += (opthdr[1] + 1) << 3;",
      "",
      "[Removed Lines]",
      "398:    return false;",
      "",
      "[Added Lines]",
      "393:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "415:   break;",
      "416:  }",
      "422:  if (skb_flow_dissector_uses_key(flow_dissector,",
      "423:      FLOW_DISSECTOR_KEY_PORTS)) {",
      "424:   key_ports = skb_flow_dissector_target(flow_dissector,",
      "",
      "[Removed Lines]",
      "418:  key_basic->n_proto = proto;",
      "419:  key_basic->ip_proto = ip_proto;",
      "420:  key_control->thoff = (u16)nhoff;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "428:        data, hlen);",
      "429:  }",
      "432: }",
      "433: EXPORT_SYMBOL(__skb_flow_dissect);",
      "",
      "[Removed Lines]",
      "431:  return true;",
      "",
      "[Added Lines]",
      "422: out_good:",
      "423:  ret = true;",
      "425: out_bad:",
      "426:  key_basic->n_proto = proto;",
      "427:  key_basic->ip_proto = ip_proto;",
      "428:  key_control->thoff = (u16)nhoff;",
      "430:  return ret;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1fdd512c92003cf2d671ba22753d13302bf8cd1d",
      "candidate_info": {
        "commit_hash": "1fdd512c92003cf2d671ba22753d13302bf8cd1d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1fdd512c92003cf2d671ba22753d13302bf8cd1d",
        "files": [
          "include/net/flow_dissector.h",
          "net/core/flow_dissector.c"
        ],
        "message": "net: Add GRE keyid in flow_keys\n\nIn flow dissector if a GRE header contains a keyid this is saved in the\nnew keyid field of flow_keys. The GRE keyid is then represented\nin the flow hash function input.\n\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/flow_dissector.h||include/net/flow_dissector.h",
          "net/core/flow_dissector.c||net/core/flow_dissector.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/flow_dissector.h||include/net/flow_dissector.h": [
          "File: include/net/flow_dissector.h -> include/net/flow_dissector.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:   flow_label:20;",
          "33: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: struct flow_dissector_key_keyid {",
          "36:  __be32 keyid;",
          "37: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150: #define FLOW_KEYS_HASH_START_FIELD basic",
          "151:  struct flow_dissector_key_basic basic;",
          "152:  struct flow_dissector_key_tags tags;",
          "153:  struct flow_dissector_key_ports ports;",
          "154:  struct flow_dissector_key_addrs addrs;",
          "155: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:  struct flow_dissector_key_keyid keyid;",
          "",
          "---------------"
        ],
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "127:  struct flow_dissector_key_addrs *key_addrs;",
          "128:  struct flow_dissector_key_ports *key_ports;",
          "129:  struct flow_dissector_key_tags *key_tags;",
          "130:  u8 ip_proto;",
          "132:  if (!data) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "130:  struct flow_dissector_key_keyid *key_keyid;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "315:   nhoff += 4;",
          "316:   if (hdr->flags & GRE_CSUM)",
          "317:    nhoff += 4;",
          "319:    nhoff += 4;",
          "320:   if (hdr->flags & GRE_SEQ)",
          "321:    nhoff += 4;",
          "322:   if (proto == htons(ETH_P_TEB)) {",
          "",
          "[Removed Lines]",
          "318:   if (hdr->flags & GRE_KEY)",
          "",
          "[Added Lines]",
          "319:   if (hdr->flags & GRE_KEY) {",
          "320:    const __be32 *keyid;",
          "321:    __be32 _keyid;",
          "323:    keyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),",
          "324:            data, hlen, &_keyid);",
          "326:    if (!keyid)",
          "327:     return false;",
          "329:    if (skb_flow_dissector_uses_key(flow_dissector,",
          "330:        FLOW_DISSECTOR_KEY_GRE_KEYID)) {",
          "331:     key_keyid = skb_flow_dissector_target(flow_dissector,",
          "332:               FLOW_DISSECTOR_KEY_GRE_KEYID,",
          "333:               target_container);",
          "334:     key_keyid->keyid = *keyid;",
          "335:    }",
          "337:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "650:   .key_id = FLOW_DISSECTOR_KEY_FLOW_LABEL,",
          "651:   .offset = offsetof(struct flow_keys, tags),",
          "652:  },",
          "653: };",
          "655: static const struct flow_dissector_key flow_keys_buf_dissector_keys[] = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "671:  {",
          "672:   .key_id = FLOW_DISSECTOR_KEY_GRE_KEYID,",
          "673:   .offset = offsetof(struct flow_keys, keyid),",
          "674:  },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ce3b5355477ce99bffa60a6a215f2e11db4b649c",
      "candidate_info": {
        "commit_hash": "ce3b5355477ce99bffa60a6a215f2e11db4b649c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ce3b5355477ce99bffa60a6a215f2e11db4b649c",
        "files": [
          "net/core/flow_dissector.c"
        ],
        "message": "net: Simplify GRE case in flow_dissector\n\nDo break when we see routing flag or a non-zero version number in GRE\nheader.\n\nAcked-by: Jiri Pirko <jiri@resnulli.us>\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/core/flow_dissector.c||net/core/flow_dissector.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:    nhoff += 4;",
          "333:   }",
          "335:  }",
          "336:  case IPPROTO_IPIP:",
          "337:   proto = htons(ETH_P_IP);",
          "",
          "[Removed Lines]",
          "311:   if (!(hdr->flags & (GRE_VERSION|GRE_ROUTING))) {",
          "312:    proto = hdr->proto;",
          "314:    if (hdr->flags & GRE_CSUM)",
          "315:     nhoff += 4;",
          "316:    if (hdr->flags & GRE_KEY)",
          "317:     nhoff += 4;",
          "318:    if (hdr->flags & GRE_SEQ)",
          "319:     nhoff += 4;",
          "320:    if (proto == htons(ETH_P_TEB)) {",
          "321:     const struct ethhdr *eth;",
          "322:     struct ethhdr _eth;",
          "324:     eth = __skb_header_pointer(skb, nhoff,",
          "325:           sizeof(_eth),",
          "326:           data, hlen, &_eth);",
          "327:     if (!eth)",
          "328:      return false;",
          "329:     proto = eth->h_proto;",
          "330:     nhoff += sizeof(*eth);",
          "331:    }",
          "332:    goto again;",
          "334:   break;",
          "",
          "[Added Lines]",
          "311:   if (hdr->flags & (GRE_VERSION | GRE_ROUTING))",
          "312:    break;",
          "314:   proto = hdr->proto;",
          "315:   nhoff += 4;",
          "316:   if (hdr->flags & GRE_CSUM)",
          "318:   if (hdr->flags & GRE_KEY)",
          "319:    nhoff += 4;",
          "320:   if (hdr->flags & GRE_SEQ)",
          "321:    nhoff += 4;",
          "322:   if (proto == htons(ETH_P_TEB)) {",
          "323:    const struct ethhdr *eth;",
          "324:    struct ethhdr _eth;",
          "326:    eth = __skb_header_pointer(skb, nhoff,",
          "327:          sizeof(_eth),",
          "328:          data, hlen, &_eth);",
          "329:    if (!eth)",
          "330:     return false;",
          "331:    proto = eth->h_proto;",
          "332:    nhoff += sizeof(*eth);",
          "334:   goto again;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b3baa0fbd02a1a9d493d8cb92ae4a4491b9e9d13",
      "candidate_info": {
        "commit_hash": "b3baa0fbd02a1a9d493d8cb92ae4a4491b9e9d13",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b3baa0fbd02a1a9d493d8cb92ae4a4491b9e9d13",
        "files": [
          "include/net/flow_dissector.h",
          "net/core/flow_dissector.c"
        ],
        "message": "mpls: Add MPLS entropy label in flow_keys\n\nIn flow dissector if an MPLS header contains an entropy label this is\nsaved in the new keyid field of flow_keys. The entropy label is\nthen represented in the flow hash function input.\n\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/flow_dissector.h||include/net/flow_dissector.h",
          "net/core/flow_dissector.c||net/core/flow_dissector.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/flow_dissector.h||include/net/flow_dissector.h": [
          "File: include/net/flow_dissector.h -> include/net/flow_dissector.h"
        ],
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include <linux/ppp_defs.h>",
          "16: #include <linux/stddef.h>",
          "17: #include <linux/if_ether.h>",
          "18: #include <net/flow_dissector.h>",
          "19: #include <scsi/fc/fc_fcoe.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <linux/mpls.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "288:   }",
          "289:   return true;",
          "290:  }",
          "291:  case htons(ETH_P_FCOE):",
          "292:   key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:  case htons(ETH_P_MPLS_UC):",
          "294:  case htons(ETH_P_MPLS_MC): {",
          "295:   struct mpls_label *hdr, _hdr[2];",
          "296: mpls:",
          "297:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,",
          "298:         hlen, &_hdr);",
          "299:   if (!hdr)",
          "300:    return false;",
          "302:   if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) ==",
          "303:        MPLS_LABEL_ENTROPY) {",
          "304:    if (skb_flow_dissector_uses_key(flow_dissector,",
          "305:        FLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {",
          "306:     key_keyid = skb_flow_dissector_target(flow_dissector,",
          "307:               FLOW_DISSECTOR_KEY_MPLS_ENTROPY,",
          "308:               target_container);",
          "309:     key_keyid->keyid = hdr[1].entry &",
          "310:      htonl(MPLS_LS_LABEL_MASK);",
          "311:    }",
          "313:    key_basic->n_proto = proto;",
          "314:    key_basic->ip_proto = ip_proto;",
          "315:    key_control->thoff = (u16)nhoff;",
          "317:    return true;",
          "318:   }",
          "320:   return true;",
          "321:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "357:  case IPPROTO_IPV6:",
          "358:   proto = htons(ETH_P_IPV6);",
          "359:   goto ipv6;",
          "360:  default:",
          "361:   break;",
          "362:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "392:  case IPPROTO_MPLS:",
          "393:   proto = htons(ETH_P_MPLS_UC);",
          "394:   goto mpls;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5af7fb6e3e92c2797ee30d66138cf6aa6b29240d",
      "candidate_info": {
        "commit_hash": "5af7fb6e3e92c2797ee30d66138cf6aa6b29240d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5af7fb6e3e92c2797ee30d66138cf6aa6b29240d",
        "files": [
          "net/core/flow_dissector.c"
        ],
        "message": "flow-dissector: Fix alignment issue in __skb_flow_get_ports\n\nThis patch addresses a kernel unaligned access bug seen on a sparc64 system\nwith an igb adapter.  Specifically the __skb_flow_get_ports was returning a\nbe32 pointer which was then having the value directly returned.\n\nIn order to prevent this it is actually easier to simply not populate the\nports or address values when an skb is not present.  In this case the\nassumption is that the data isn't needed and rather than slow down the\nfaster aligned accesses by making them have to assume the unaligned path on\narchitectures that don't support efficent unaligned access it makes more\nsense to simply switch off the bits that were copying the source and\ndestination address/port for the case where we only care about the protocol\ntypes and lengths which are normally 16 bit fields anyway.\n\nReported-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/core/flow_dissector.c||net/core/flow_dissector.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:   if (ip_is_fragment(iph))",
          "101:    ip_proto = 0;",
          "103:   iph_to_flow_copy_addrs(flow, iph);",
          "104:   break;",
          "105:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107:   if (!skb)",
          "108:    break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:    return false;",
          "116:   ip_proto = iph->nexthdr;",
          "119:   nhoff += sizeof(struct ipv6hdr);",
          "125:   if (!skb)",
          "126:    break;",
          "128:   flow_label = ip6_flowlabel(iph);",
          "129:   if (flow_label) {",
          "",
          "[Removed Lines]",
          "117:   flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);",
          "118:   flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);",
          "",
          "[Added Lines]",
          "130:   flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);",
          "131:   flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232:  flow->n_proto = proto;",
          "233:  flow->ip_proto = ip_proto;",
          "235:  flow->thoff = (u16) nhoff;",
          "237:  return true;",
          "238: }",
          "239: EXPORT_SYMBOL(__skb_flow_dissect);",
          "",
          "[Removed Lines]",
          "234:  flow->ports = __skb_flow_get_ports(skb, nhoff, ip_proto, data, hlen);",
          "",
          "[Added Lines]",
          "242:  if (skb)",
          "243:   flow->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,",
          "244:          data, hlen);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "335:  switch (keys->ip_proto) {",
          "336:  case IPPROTO_TCP: {",
          "343:    return poff;",
          "346:   break;",
          "347:  }",
          "348:  case IPPROTO_UDP:",
          "",
          "[Removed Lines]",
          "337:   const struct tcphdr *tcph;",
          "338:   struct tcphdr _tcph;",
          "340:   tcph = __skb_header_pointer(skb, poff, sizeof(_tcph),",
          "341:          data, hlen, &_tcph);",
          "342:   if (!tcph)",
          "345:   poff += max_t(u32, sizeof(struct tcphdr), tcph->doff * 4);",
          "",
          "[Added Lines]",
          "347:   const u8 *doff;",
          "348:   u8 _doff;",
          "350:   doff = __skb_header_pointer(skb, poff + 12, sizeof(_doff),",
          "351:          data, hlen, &_doff);",
          "352:   if (!doff)",
          "355:   poff += max_t(u32, sizeof(struct tcphdr), (*doff & 0xF0) >> 2);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56193d1bce2b2759cb4bdcc00cd05544894a0c90",
      "candidate_info": {
        "commit_hash": "56193d1bce2b2759cb4bdcc00cd05544894a0c90",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/56193d1bce2b2759cb4bdcc00cd05544894a0c90",
        "files": [
          "include/linux/etherdevice.h",
          "include/linux/skbuff.h",
          "include/net/flow_keys.h",
          "net/core/filter.c",
          "net/core/flow_dissector.c",
          "net/ethernet/eth.c"
        ],
        "message": "net: Add function for parsing the header length out of linear ethernet frames\n\nThis patch updates some of the flow_dissector api so that it can be used to\nparse the length of ethernet buffers stored in fragments.  Most of the\nchanges needed were to __skb_get_poff as it needed to be updated to support\nsending a linear buffer instead of a skb.\n\nI have split __skb_get_poff into two functions, the first is skb_get_poff\nand it retains the functionality of the original __skb_get_poff.  The other\nfunction is __skb_get_poff which now works much like __skb_flow_dissect in\nrelation to skb_flow_dissect in that it provides the same functionality but\nworks with just a data buffer and hlen instead of needing an skb.\n\nSigned-off-by: Alexander Duyck <alexander.h.duyck@intel.com>\nAcked-by: Alexei Starovoitov <ast@plumgrid.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/etherdevice.h||include/linux/etherdevice.h",
          "include/linux/skbuff.h||include/linux/skbuff.h",
          "include/net/flow_keys.h||include/net/flow_keys.h",
          "net/core/filter.c||net/core/filter.c",
          "net/core/flow_dissector.c||net/core/flow_dissector.c",
          "net/ethernet/eth.c||net/ethernet/eth.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/etherdevice.h||include/linux/etherdevice.h": [
          "File: include/linux/etherdevice.h -> include/linux/etherdevice.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <asm/bitsperlong.h>",
          "31: #ifdef __KERNEL__",
          "32: __be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev);",
          "33: extern const struct header_ops eth_header_ops;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: u32 eth_get_headlen(void *data, unsigned int max_len);",
          "",
          "---------------"
        ],
        "include/linux/skbuff.h||include/linux/skbuff.h": [
          "File: include/linux/skbuff.h -> include/linux/skbuff.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3219: int skb_checksum_setup(struct sk_buff *skb, bool recalculate);",
          "",
          "[Removed Lines]",
          "3221: u32 __skb_get_poff(const struct sk_buff *skb);",
          "",
          "[Added Lines]",
          "3221: u32 skb_get_poff(const struct sk_buff *skb);",
          "3222: u32 __skb_get_poff(const struct sk_buff *skb, void *data,",
          "3223:      const struct flow_keys *keys, int hlen);",
          "",
          "---------------"
        ],
        "include/net/flow_keys.h||include/net/flow_keys.h": [
          "File: include/net/flow_keys.h -> include/net/flow_keys.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:  return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);",
          "41: }",
          "42: u32 flow_hash_from_keys(struct flow_keys *keys);",
          "43: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: unsigned int flow_get_hlen(const unsigned char *data, unsigned int max_len,",
          "44:       __be16 protocol);",
          "",
          "---------------"
        ],
        "net/core/filter.c||net/core/filter.c": [
          "File: net/core/filter.c -> net/core/filter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "114: static u64 __skb_get_pay_offset(u64 ctx, u64 a, u64 x, u64 r4, u64 r5)",
          "115: {",
          "117: }",
          "119: static u64 __skb_get_nlattr(u64 ctx, u64 a, u64 x, u64 r4, u64 r5)",
          "",
          "[Removed Lines]",
          "116:  return __skb_get_poff((struct sk_buff *)(unsigned long) ctx);",
          "",
          "[Added Lines]",
          "116:  return skb_get_poff((struct sk_buff *)(unsigned long) ctx);",
          "",
          "---------------"
        ],
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include <linux/if_pppox.h>",
          "14: #include <linux/ppp_defs.h>",
          "15: #include <net/flow_keys.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <scsi/fc/fc_fcoe.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "117:   flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);",
          "118:   nhoff += sizeof(struct ipv6hdr);",
          "120:   flow_label = ip6_flowlabel(iph);",
          "121:   if (flow_label) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125:   if (!skb)",
          "126:    break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:    return false;",
          "166:   }",
          "167:  }",
          "168:  default:",
          "169:   return false;",
          "170:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:  case htons(ETH_P_FCOE):",
          "177:   flow->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "316: }",
          "317: EXPORT_SYMBOL(__skb_tx_hash);",
          "325: {",
          "334:  case IPPROTO_TCP: {",
          "335:   const struct tcphdr *tcph;",
          "336:   struct tcphdr _tcph;",
          "339:   if (!tcph)",
          "340:    return poff;",
          "",
          "[Removed Lines]",
          "324: u32 __skb_get_poff(const struct sk_buff *skb)",
          "326:  struct flow_keys keys;",
          "327:  u32 poff = 0;",
          "329:  if (!skb_flow_dissect(skb, &keys))",
          "330:   return 0;",
          "332:  poff += keys.thoff;",
          "333:  switch (keys.ip_proto) {",
          "338:   tcph = skb_header_pointer(skb, poff, sizeof(_tcph), &_tcph);",
          "",
          "[Added Lines]",
          "330: u32 __skb_get_poff(const struct sk_buff *skb, void *data,",
          "331:      const struct flow_keys *keys, int hlen)",
          "333:  u32 poff = keys->thoff;",
          "335:  switch (keys->ip_proto) {",
          "340:   tcph = __skb_header_pointer(skb, poff, sizeof(_tcph),",
          "341:          data, hlen, &_tcph);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "369:  return poff;",
          "370: }",
          "372: static inline int get_xps_queue(struct net_device *dev, struct sk_buff *skb)",
          "373: {",
          "374: #ifdef CONFIG_XPS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "380: u32 skb_get_poff(const struct sk_buff *skb)",
          "381: {",
          "382:  struct flow_keys keys;",
          "384:  if (!skb_flow_dissect(skb, &keys))",
          "385:   return 0;",
          "387:  return __skb_get_poff(skb, skb->data, &keys, skb_headlen(skb));",
          "388: }",
          "",
          "---------------"
        ],
        "net/ethernet/eth.c||net/ethernet/eth.c": [
          "File: net/ethernet/eth.c -> net/ethernet/eth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "145: }",
          "146: EXPORT_SYMBOL(eth_rebuild_header);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156: u32 eth_get_headlen(void *data, unsigned int len)",
          "157: {",
          "158:  const struct ethhdr *eth = (const struct ethhdr *)data;",
          "159:  struct flow_keys keys;",
          "162:  if (len < sizeof(*eth))",
          "163:   return len;",
          "166:  if (!__skb_flow_dissect(NULL, &keys, data,",
          "167:     eth->h_proto, sizeof(*eth), len))",
          "168:   return max_t(u32, keys.thoff, sizeof(*eth));",
          "171:  return min_t(u32, __skb_get_poff(NULL, data, &keys, len), len);",
          "172: }",
          "173: EXPORT_SYMBOL(eth_get_headlen);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
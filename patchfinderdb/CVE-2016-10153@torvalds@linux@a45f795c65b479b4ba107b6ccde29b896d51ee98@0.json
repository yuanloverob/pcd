{
  "cve_id": "CVE-2016-10153",
  "cve_desc": "The crypto scatterlist API in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging reliance on earlier net/ceph/crypto.c code.",
  "repo": "torvalds/linux",
  "patch_hash": "a45f795c65b479b4ba107b6ccde29b896d51ee98",
  "patch_info": {
    "commit_hash": "a45f795c65b479b4ba107b6ccde29b896d51ee98",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a45f795c65b479b4ba107b6ccde29b896d51ee98",
    "files": [
      "net/ceph/crypto.c",
      "net/ceph/crypto.h"
    ],
    "message": "libceph: introduce ceph_crypt() for in-place en/decryption\n\nStarting with 4.9, kernel stacks may be vmalloced and therefore not\nguaranteed to be physically contiguous; the new CONFIG_VMAP_STACK\noption is enabled by default on x86.  This makes it invalid to use\non-stack buffers with the crypto scatterlist API, as sg_set_buf()\nexpects a logical address and won't work with vmalloced addresses.\n\nThere isn't a different (e.g. kvec-based) crypto API we could switch\nnet/ceph/crypto.c to and the current scatterlist.h API isn't getting\nupdated to accommodate this use case.  Allocating a new header and\npadding for each operation is a non-starter, so do the en/decryption\nin-place on a single pre-assembled (header + data + padding) heap\nbuffer.  This is explicitly supported by the crypto API:\n\n    \"... the caller may provide the same scatter/gather list for the\n     plaintext and cipher text. After the completion of the cipher\n     operation, the plaintext data is replaced with the ciphertext data\n     in case of an encryption and vice versa for a decryption.\"\n\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>\nReviewed-by: Sage Weil <sage@redhat.com>",
    "before_after_code_files": [
      "net/ceph/crypto.c||net/ceph/crypto.c",
      "net/ceph/crypto.h||net/ceph/crypto.h"
    ]
  },
  "patch_diff": {
    "net/ceph/crypto.c||net/ceph/crypto.c": [
      "File: net/ceph/crypto.c -> net/ceph/crypto.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "526:  }",
      "527: }",
      "529: static int ceph_key_preparse(struct key_preparsed_payload *prep)",
      "530: {",
      "531:  struct ceph_crypto_key *ckey;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "529: static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,",
      "530:      void *buf, int buf_len, int in_len, int *pout_len)",
      "531: {",
      "532:  struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();",
      "533:  SKCIPHER_REQUEST_ON_STACK(req, tfm);",
      "534:  struct sg_table sgt;",
      "535:  struct scatterlist prealloc_sg;",
      "536:  char iv[AES_BLOCK_SIZE];",
      "537:  int pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));",
      "538:  int crypt_len = encrypt ? in_len + pad_byte : in_len;",
      "539:  int ret;",
      "541:  if (IS_ERR(tfm))",
      "542:   return PTR_ERR(tfm);",
      "544:  WARN_ON(crypt_len > buf_len);",
      "545:  if (encrypt)",
      "546:   memset(buf + in_len, pad_byte, pad_byte);",
      "547:  ret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);",
      "548:  if (ret)",
      "549:   goto out_tfm;",
      "551:  crypto_skcipher_setkey((void *)tfm, key->key, key->len);",
      "552:  memcpy(iv, aes_iv, AES_BLOCK_SIZE);",
      "554:  skcipher_request_set_tfm(req, tfm);",
      "555:  skcipher_request_set_callback(req, 0, NULL, NULL);",
      "556:  skcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);",
      "559:  print_hex_dump(KERN_ERR, \"key: \", DUMP_PREFIX_NONE, 16, 1,",
      "560:          key->key, key->len, 1);",
      "561:  print_hex_dump(KERN_ERR, \" in: \", DUMP_PREFIX_NONE, 16, 1,",
      "562:          buf, crypt_len, 1);",
      "564:  if (encrypt)",
      "565:   ret = crypto_skcipher_encrypt(req);",
      "566:  else",
      "567:   ret = crypto_skcipher_decrypt(req);",
      "568:  skcipher_request_zero(req);",
      "569:  if (ret) {",
      "570:   pr_err(\"%s %scrypt failed: %d\\n\", __func__,",
      "571:          encrypt ? \"en\" : \"de\", ret);",
      "572:   goto out_sgt;",
      "573:  }",
      "575:  print_hex_dump(KERN_ERR, \"out: \", DUMP_PREFIX_NONE, 16, 1,",
      "576:          buf, crypt_len, 1);",
      "579:  if (encrypt) {",
      "581:  } else {",
      "582:   pad_byte = *(char *)(buf + in_len - 1);",
      "583:   if (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&",
      "584:       in_len >= pad_byte) {",
      "586:   } else {",
      "587:    pr_err(\"%s got bad padding %d on in_len %d\\n\",",
      "588:           __func__, pad_byte, in_len);",
      "589:    ret = -EPERM;",
      "590:    goto out_sgt;",
      "591:   }",
      "592:  }",
      "594: out_sgt:",
      "595:  teardown_sgtable(&sgt);",
      "596: out_tfm:",
      "597:  crypto_free_skcipher(tfm);",
      "598:  return ret;",
      "599: }",
      "601: int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,",
      "602:         void *buf, int buf_len, int in_len, int *pout_len)",
      "603: {",
      "604:  switch (key->type) {",
      "605:  case CEPH_CRYPTO_NONE:",
      "607:   return 0;",
      "608:  case CEPH_CRYPTO_AES:",
      "609:   return ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,",
      "610:           pout_len);",
      "611:  default:",
      "612:   return -ENOTSUPP;",
      "613:  }",
      "614: }",
      "",
      "---------------"
    ],
    "net/ceph/crypto.h||net/ceph/crypto.h": [
      "File: net/ceph/crypto.h -> net/ceph/crypto.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "43:     void *dst, size_t *dst_len,",
      "44:     const void *src1, size_t src1_len,",
      "45:     const void *src2, size_t src2_len);",
      "46: int ceph_crypto_init(void);",
      "47: void ceph_crypto_shutdown(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "46: int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,",
      "47:         void *buf, int buf_len, int in_len, int *pout_len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7af3ea189a9a13f090de51c97f676215dabc1205",
      "candidate_info": {
        "commit_hash": "7af3ea189a9a13f090de51c97f676215dabc1205",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7af3ea189a9a13f090de51c97f676215dabc1205",
        "files": [
          "net/ceph/crypto.c",
          "net/ceph/crypto.h"
        ],
        "message": "libceph: stop allocating a new cipher on every crypto request\n\nThis is useless and more importantly not allowed on the writeback path,\nbecause crypto_alloc_skcipher() allocates memory with GFP_KERNEL, which\ncan recurse back into the filesystem:\n\n    kworker/9:3     D ffff92303f318180     0 20732      2 0x00000080\n    Workqueue: ceph-msgr ceph_con_workfn [libceph]\n     ffff923035dd4480 ffff923038f8a0c0 0000000000000001 000000009eb27318\n     ffff92269eb28000 ffff92269eb27338 ffff923036b145ac ffff923035dd4480\n     00000000ffffffff ffff923036b145b0 ffffffff951eb4e1 ffff923036b145a8\n    Call Trace:\n     [<ffffffff951eb4e1>] ? schedule+0x31/0x80\n     [<ffffffff951eb77a>] ? schedule_preempt_disabled+0xa/0x10\n     [<ffffffff951ed1f4>] ? __mutex_lock_slowpath+0xb4/0x130\n     [<ffffffff951ed28b>] ? mutex_lock+0x1b/0x30\n     [<ffffffffc0a974b3>] ? xfs_reclaim_inodes_ag+0x233/0x2d0 [xfs]\n     [<ffffffff94d92ba5>] ? move_active_pages_to_lru+0x125/0x270\n     [<ffffffff94f2b985>] ? radix_tree_gang_lookup_tag+0xc5/0x1c0\n     [<ffffffff94dad0f3>] ? __list_lru_walk_one.isra.3+0x33/0x120\n     [<ffffffffc0a98331>] ? xfs_reclaim_inodes_nr+0x31/0x40 [xfs]\n     [<ffffffff94e05bfe>] ? super_cache_scan+0x17e/0x190\n     [<ffffffff94d919f3>] ? shrink_slab.part.38+0x1e3/0x3d0\n     [<ffffffff94d9616a>] ? shrink_node+0x10a/0x320\n     [<ffffffff94d96474>] ? do_try_to_free_pages+0xf4/0x350\n     [<ffffffff94d967ba>] ? try_to_free_pages+0xea/0x1b0\n     [<ffffffff94d863bd>] ? __alloc_pages_nodemask+0x61d/0xe60\n     [<ffffffff94ddf42d>] ? cache_grow_begin+0x9d/0x560\n     [<ffffffff94ddfb88>] ? fallback_alloc+0x148/0x1c0\n     [<ffffffff94ed84e7>] ? __crypto_alloc_tfm+0x37/0x130\n     [<ffffffff94de09db>] ? __kmalloc+0x1eb/0x580\n     [<ffffffffc09fe2db>] ? crush_choose_firstn+0x3eb/0x470 [libceph]\n     [<ffffffff94ed84e7>] ? __crypto_alloc_tfm+0x37/0x130\n     [<ffffffff94ed9c19>] ? crypto_spawn_tfm+0x39/0x60\n     [<ffffffffc08b30a3>] ? crypto_cbc_init_tfm+0x23/0x40 [cbc]\n     [<ffffffff94ed857c>] ? __crypto_alloc_tfm+0xcc/0x130\n     [<ffffffff94edcc23>] ? crypto_skcipher_init_tfm+0x113/0x180\n     [<ffffffff94ed7cc3>] ? crypto_create_tfm+0x43/0xb0\n     [<ffffffff94ed83b0>] ? crypto_larval_lookup+0x150/0x150\n     [<ffffffff94ed7da2>] ? crypto_alloc_tfm+0x72/0x120\n     [<ffffffffc0a01dd7>] ? ceph_aes_encrypt2+0x67/0x400 [libceph]\n     [<ffffffffc09fd264>] ? ceph_pg_to_up_acting_osds+0x84/0x5b0 [libceph]\n     [<ffffffff950d40a0>] ? release_sock+0x40/0x90\n     [<ffffffff95139f94>] ? tcp_recvmsg+0x4b4/0xae0\n     [<ffffffffc0a02714>] ? ceph_encrypt2+0x54/0xc0 [libceph]\n     [<ffffffffc0a02b4d>] ? ceph_x_encrypt+0x5d/0x90 [libceph]\n     [<ffffffffc0a02bdf>] ? calcu_signature+0x5f/0x90 [libceph]\n     [<ffffffffc0a02ef5>] ? ceph_x_sign_message+0x35/0x50 [libceph]\n     [<ffffffffc09e948c>] ? prepare_write_message_footer+0x5c/0xa0 [libceph]\n     [<ffffffffc09ecd18>] ? ceph_con_workfn+0x2258/0x2dd0 [libceph]\n     [<ffffffffc09e9903>] ? queue_con_delay+0x33/0xd0 [libceph]\n     [<ffffffffc09f68ed>] ? __submit_request+0x20d/0x2f0 [libceph]\n     [<ffffffffc09f6ef8>] ? ceph_osdc_start_request+0x28/0x30 [libceph]\n     [<ffffffffc0b52603>] ? rbd_queue_workfn+0x2f3/0x350 [rbd]\n     [<ffffffff94c94ec0>] ? process_one_work+0x160/0x410\n     [<ffffffff94c951bd>] ? worker_thread+0x4d/0x480\n     [<ffffffff94c95170>] ? process_one_work+0x410/0x410\n     [<ffffffff94c9af8d>] ? kthread+0xcd/0xf0\n     [<ffffffff951efb2f>] ? ret_from_fork+0x1f/0x40\n     [<ffffffff94c9aec0>] ? kthread_create_on_node+0x190/0x190\n\nAllocating the cipher along with the key fixes the issue - as long the\nkey doesn't change, a single cipher context can be used concurrently in\nmultiple requests.\n\nWe still can't take that GFP_KERNEL allocation though.  Both\nceph_crypto_key_clone() and ceph_crypto_key_decode() are called from\nGFP_NOFS context, so resort to memalloc_noio_{save,restore}() here.\n\nReported-by: Lucas Stach <l.stach@pengutronix.de>\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>\nReviewed-by: Sage Weil <sage@redhat.com>",
        "before_after_code_files": [
          "net/ceph/crypto.c||net/ceph/crypto.c",
          "net/ceph/crypto.h||net/ceph/crypto.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ceph/crypto.c||net/ceph/crypto.c",
            "net/ceph/crypto.h||net/ceph/crypto.h"
          ],
          "candidate": [
            "net/ceph/crypto.c||net/ceph/crypto.c",
            "net/ceph/crypto.h||net/ceph/crypto.h"
          ]
        }
      },
      "candidate_diff": {
        "net/ceph/crypto.c||net/ceph/crypto.c": [
          "File: net/ceph/crypto.c -> net/ceph/crypto.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include <linux/ceph/decode.h>",
          "14: #include \"crypto.h\"",
          "16: int ceph_crypto_key_clone(struct ceph_crypto_key *dst,",
          "17:      const struct ceph_crypto_key *src)",
          "18: {",
          "19:  memcpy(dst, src, sizeof(struct ceph_crypto_key));",
          "24: }",
          "26: int ceph_crypto_key_encode(struct ceph_crypto_key *key, void **p, void *end)",
          "",
          "[Removed Lines]",
          "20:  dst->key = kmemdup(src->key, src->len, GFP_NOFS);",
          "21:  if (!dst->key)",
          "22:   return -ENOMEM;",
          "23:  return 0;",
          "",
          "[Added Lines]",
          "20: static int set_secret(struct ceph_crypto_key *key, void *buf)",
          "21: {",
          "22:  unsigned int noio_flag;",
          "23:  int ret;",
          "25:  key->key = NULL;",
          "26:  key->tfm = NULL;",
          "28:  switch (key->type) {",
          "29:  case CEPH_CRYPTO_NONE:",
          "31:  case CEPH_CRYPTO_AES:",
          "32:   break;",
          "33:  default:",
          "34:   return -ENOTSUPP;",
          "35:  }",
          "37:  WARN_ON(!key->len);",
          "38:  key->key = kmemdup(buf, key->len, GFP_NOIO);",
          "39:  if (!key->key) {",
          "40:   ret = -ENOMEM;",
          "41:   goto fail;",
          "42:  }",
          "45:  noio_flag = memalloc_noio_save();",
          "46:  key->tfm = crypto_alloc_skcipher(\"cbc(aes)\", 0, CRYPTO_ALG_ASYNC);",
          "47:  memalloc_noio_restore(noio_flag);",
          "48:  if (IS_ERR(key->tfm)) {",
          "49:   ret = PTR_ERR(key->tfm);",
          "50:   key->tfm = NULL;",
          "51:   goto fail;",
          "52:  }",
          "54:  ret = crypto_skcipher_setkey(key->tfm, key->key, key->len);",
          "55:  if (ret)",
          "56:   goto fail;",
          "58:  return 0;",
          "60: fail:",
          "61:  ceph_crypto_key_destroy(key);",
          "62:  return ret;",
          "63: }",
          "69:  return set_secret(dst, src->key);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: int ceph_crypto_key_decode(struct ceph_crypto_key *key, void **p, void *end)",
          "39: {",
          "40:  ceph_decode_need(p, end, 2*sizeof(u16) + sizeof(key->created), bad);",
          "41:  key->type = ceph_decode_16(p);",
          "42:  ceph_decode_copy(p, &key->created, sizeof(key->created));",
          "43:  key->len = ceph_decode_16(p);",
          "44:  ceph_decode_need(p, end, key->len, bad);",
          "51: bad:",
          "52:  dout(\"failed to decode crypto key\\n\");",
          "",
          "[Removed Lines]",
          "45:  key->key = kmalloc(key->len, GFP_NOFS);",
          "46:  if (!key->key)",
          "47:   return -ENOMEM;",
          "48:  ceph_decode_copy(p, key->key, key->len);",
          "49:  return 0;",
          "",
          "[Added Lines]",
          "86:  int ret;",
          "93:  ret = set_secret(key, *p);",
          "95:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:  if (key) {",
          "86:   kfree(key->key);",
          "87:   key->key = NULL;",
          "88:  }",
          "89: }",
          "96: static const u8 *aes_iv = (u8 *)CEPH_AES_IV;",
          "",
          "[Removed Lines]",
          "91: static struct crypto_skcipher *ceph_crypto_alloc_cipher(void)",
          "92: {",
          "93:  return crypto_alloc_skcipher(\"cbc(aes)\", 0, CRYPTO_ALG_ASYNC);",
          "94: }",
          "",
          "[Added Lines]",
          "134:   crypto_free_skcipher(key->tfm);",
          "135:   key->tfm = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168: static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,",
          "169:      void *buf, int buf_len, int in_len, int *pout_len)",
          "170: {",
          "173:  struct sg_table sgt;",
          "174:  struct scatterlist prealloc_sg;",
          "175:  char iv[AES_BLOCK_SIZE];",
          "",
          "[Removed Lines]",
          "171:  struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();",
          "172:  SKCIPHER_REQUEST_ON_STACK(req, tfm);",
          "",
          "[Added Lines]",
          "214:  SKCIPHER_REQUEST_ON_STACK(req, key->tfm);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "177:  int crypt_len = encrypt ? in_len + pad_byte : in_len;",
          "178:  int ret;",
          "183:  WARN_ON(crypt_len > buf_len);",
          "184:  if (encrypt)",
          "185:   memset(buf + in_len, pad_byte, pad_byte);",
          "186:  ret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);",
          "187:  if (ret)",
          "191:  memcpy(iv, aes_iv, AES_BLOCK_SIZE);",
          "194:  skcipher_request_set_callback(req, 0, NULL, NULL);",
          "195:  skcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);",
          "",
          "[Removed Lines]",
          "180:  if (IS_ERR(tfm))",
          "181:   return PTR_ERR(tfm);",
          "188:   goto out_tfm;",
          "190:  crypto_skcipher_setkey((void *)tfm, key->key, key->len);",
          "193:  skcipher_request_set_tfm(req, tfm);",
          "",
          "[Added Lines]",
          "227:   return ret;",
          "230:  skcipher_request_set_tfm(req, key->tfm);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "233: out_sgt:",
          "234:  teardown_sgtable(&sgt);",
          "237:  return ret;",
          "238: }",
          "",
          "[Removed Lines]",
          "235: out_tfm:",
          "236:  crypto_free_skcipher(tfm);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "net/ceph/crypto.h||net/ceph/crypto.h": [
          "File: net/ceph/crypto.h -> net/ceph/crypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:  struct ceph_timespec created;",
          "13:  int len;",
          "14:  void *key;",
          "15: };",
          "17: int ceph_crypto_key_clone(struct ceph_crypto_key *dst,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15:  struct crypto_skcipher *tfm;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "90255b814923d03eb68c33f60ed29fbbbe977e31",
      "candidate_info": {
        "commit_hash": "90255b814923d03eb68c33f60ed29fbbbe977e31",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/90255b814923d03eb68c33f60ed29fbbbe977e31",
        "files": [
          "ext/rbu/rbufault2.test",
          "ext/rbu/rbumisc.test",
          "ext/rbu/sqlite3rbu.c",
          "manifest",
          "manifest.uuid",
          "src/test_vfs.c"
        ],
        "message": "Add tests for the RBU module.\n\nFossilOrigin-Name: a194e53670e25a48c2bb51b54755abff88ed6ae2596c5858fb4aac16cb452bdf",
        "before_after_code_files": [
          "ext/rbu/rbufault2.test||ext/rbu/rbufault2.test",
          "ext/rbu/rbumisc.test||ext/rbu/rbumisc.test",
          "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c",
          "manifest.uuid||manifest.uuid",
          "src/test_vfs.c||src/test_vfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/rbu/rbufault2.test||ext/rbu/rbufault2.test": [
          "File: ext/rbu/rbufault2.test -> ext/rbu/rbufault2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: }",
          "57: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: sqlite3rbu_create_vfs -default rbu \"\"",
          "56: sqlite3 db test.db",
          "57: set ::vfsname [file_control_vfsname db]",
          "58: do_faultsim_test 2 -faults oom* -prep {",
          "59: } -body {",
          "60:   file_control_vfsname db",
          "61: }",
          "62: db close",
          "63: sqlite3rbu_destroy_vfs rbu",
          "",
          "---------------"
        ],
        "ext/rbu/rbumisc.test||ext/rbu/rbumisc.test": [
          "File: ext/rbu/rbumisc.test -> ext/rbu/rbumisc.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: sqlite3_config_uri 1",
          "19: reset_db",
          "29:   forcedelete rbu.db",
          "30:   sqlite3 rbu rbu.db",
          "31:   rbu eval {",
          "",
          "[Removed Lines]",
          "21: #-------------------------------------------------------------------------",
          "22: # Ensure that RBU is not confused by oddly named tables in an RBU",
          "23: # database.",
          "24: #",
          "25: do_execsql_test 1.0 {",
          "26:   CREATE TABLE x1(a, b, c INTEGER PRIMARY KEY);",
          "27: }",
          "28: do_test 1.1 {",
          "",
          "[Added Lines]",
          "21: proc populate_rbu_db {} {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:     INSERT INTO dat VALUES(3, 3, 3, 0);",
          "45:   }",
          "46:   rbu close",
          "47: } {}",
          "49: do_test 1.2 {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: }",
          "42: #-------------------------------------------------------------------------",
          "43: # Ensure that RBU is not confused by oddly named tables in an RBU",
          "44: # database.",
          "45: #",
          "46: do_execsql_test 1.0 {",
          "47:   CREATE TABLE x1(a, b, c INTEGER PRIMARY KEY);",
          "48: }",
          "49: do_test 1.1 {",
          "50:   populate_rbu_db",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63: do_test 1.4 {",
          "64:   db eval { DELETE FROM x1 }",
          "69:   sqlite3rbu rbu test.db rbu.db",
          "70:   rbu step",
          "",
          "[Removed Lines]",
          "65:   sqlite3 rbu rbu.db",
          "66:   rbu eval { DELETE FROM rbu_state }",
          "67:   rbu close",
          "",
          "[Added Lines]",
          "69:   populate_rbu_db",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "77:   list [catch { rbu close } msg] $msg",
          "78: } {1 {SQLITE_ERROR - cannot update wal mode database}}",
          "80: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82: #-------------------------------------------------------------------------",
          "83: # Test the effect of a wal file appearing after the target database has",
          "84: # been opened, but before it has been locked.",
          "85: #",
          "86: catch { db close }",
          "87: testvfs tvfs -default 1",
          "89: for {set N 1} {$N < 10} {incr N} {",
          "90:   reset_db",
          "91:   populate_rbu_db",
          "92:   do_execsql_test 2.$N.0 {",
          "93:     CREATE TABLE x1(a, b, c INTEGER PRIMARY KEY);",
          "94:   }",
          "96:   set nAccessCnt 0",
          "97:   do_test 2.$N.1 {",
          "98:     sqlite3rbu rbu test.db rbu.db",
          "99:     rbu step",
          "100:     rbu step",
          "101:     rbu close",
          "102:   } {SQLITE_OK}",
          "104:   tvfs script xAccess",
          "105:   tvfs filter xAccess",
          "106:   set nAccessCnt 0",
          "107:   proc xAccess {method file args} {",
          "108:     global nAccessCnt",
          "109:     if {[file tail $file]==\"test.db-wal\"} {",
          "110:       incr nAccessCnt -1",
          "111:       if {$nAccessCnt==0} {",
          "112:         set fd [open test.db-wal w]",
          "113:         puts -nonewline $fd [string repeat 0 2000]",
          "114:         close $fd",
          "115:       }",
          "116:     }",
          "117:     return SQLITE_OK",
          "118:   }",
          "120:   foreach r {",
          "121:      {1 {SQLITE_ERROR - cannot update wal mode database}}",
          "122:      {0 SQLITE_OK}",
          "123:      {1 {SQLITE_CANTOPEN - unable to open database file}}",
          "124:   } {",
          "125:     set RES($r) 1",
          "126:   }",
          "127:   do_test 2.$N.2 {",
          "128:     set ::nAccessCnt $N",
          "129:     set res [list [catch {",
          "130:       sqlite3rbu rbu test.db rbu.db",
          "131:       rbu step",
          "132:       rbu close",
          "133:     } msg ] $msg]",
          "134:     set RES($res)",
          "135:   } {1}",
          "136:   catch {rbu close}",
          "137: }",
          "138: catch {db close}",
          "139: catch {tvfs delete}",
          "141: #-------------------------------------------------------------------------",
          "142: testvfs tvfs -default 1",
          "143: reset_db",
          "144: populate_rbu_db",
          "145: do_execsql_test 3.0 {",
          "146:   CREATE TABLE x1(a, b, c INTEGER PRIMARY KEY);",
          "147: }",
          "149: tvfs script xFileControl",
          "150: tvfs filter xFileControl",
          "152: proc xFileControl {method file verb args} {",
          "153:   if {$verb==\"ZIPVFS\" && [info exists ::zipvfs_filecontrol]} {",
          "154:     return $::zipvfs_filecontrol",
          "155:   }",
          "156:   return \"SQLITE_NOTFOUND\"",
          "157: }",
          "159: breakpoint",
          "160: foreach {tn ret err} {",
          "161:   1 SQLITE_OK           0",
          "162:   2 SQLITE_ERROR        1",
          "163:   3 SQLITE_NOTFOUND     0",
          "164:   4 SQLITE_OMIT         1",
          "165: } {",
          "166:   set ::zipvfs_filecontrol $ret",
          "167:   do_test 3.$tn.1 {",
          "168:     catch {",
          "169:       sqlite3rbu rbu test.db rbu.db",
          "170:       rbu step",
          "171:       rbu close",
          "172:     }",
          "173:   } $err",
          "174: }",
          "175: catch {db close}",
          "176: catch {tvfs delete}",
          "178: #-------------------------------------------------------------------------",
          "",
          "---------------"
        ],
        "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c": [
          "File: ext/rbu/sqlite3rbu.c -> ext/rbu/sqlite3rbu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4707:       }else if( rc==SQLITE_NOTFOUND ){",
          "4708:         pRbu->pTargetFd = p;",
          "4709:         p->pRbu = pRbu;",
          "4713:         if( p->pWalFd ) p->pWalFd->pRbu = pRbu;",
          "4714:         rc = SQLITE_OK;",
          "4715:       }",
          "",
          "[Removed Lines]",
          "4710:         if( p->openFlags & SQLITE_OPEN_MAIN_DB ){",
          "4711:           rbuMainlistAdd(p);",
          "4712:         }",
          "",
          "[Added Lines]",
          "4710:         rbuMainlistAdd(p);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4772:     if( ofst==WAL_LOCK_CKPT && n==1 ) rc = SQLITE_BUSY;",
          "4773:   }else{",
          "4774:     int bCapture = 0;",
          "4779:       bCapture = 1;",
          "4780:     }",
          "",
          "[Removed Lines]",
          "4775:     if( n==1 && (flags & SQLITE_SHM_EXCLUSIVE)",
          "4776:      && pRbu && pRbu->eStage==RBU_STAGE_CAPTURE",
          "4777:      && (ofst==WAL_LOCK_WRITE || ofst==WAL_LOCK_CKPT || ofst==WAL_LOCK_READ0)",
          "4778:     ){",
          "",
          "[Added Lines]",
          "4773:     if( pRbu && pRbu->eStage==RBU_STAGE_CAPTURE ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4810:   assert( p->openFlags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB) );",
          "4822:     }",
          "4825:       char *pNew = (char*)sqlite3_malloc64(szRegion);",
          "4826:       if( pNew==0 ){",
          "4827:         rc = SQLITE_NOMEM;",
          "",
          "[Removed Lines]",
          "4811:   if( eStage==RBU_STAGE_OAL || eStage==RBU_STAGE_MOVE ){",
          "4812:     if( iRegion<=p->nShm ){",
          "4813:       sqlite3_int64 nByte = (iRegion+1) * sizeof(char*);",
          "4814:       char **apNew = (char**)sqlite3_realloc64(p->apShm, nByte);",
          "4815:       if( apNew==0 ){",
          "4816:         rc = SQLITE_NOMEM;",
          "4817:       }else{",
          "4818:         memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));",
          "4819:         p->apShm = apNew;",
          "4820:         p->nShm = iRegion+1;",
          "4821:       }",
          "4824:     if( rc==SQLITE_OK && p->apShm[iRegion]==0 ){",
          "",
          "[Added Lines]",
          "4806:   if( eStage==RBU_STAGE_OAL ){",
          "4807:     sqlite3_int64 nByte = (iRegion+1) * sizeof(char*);",
          "4808:     char **apNew = (char**)sqlite3_realloc64(p->apShm, nByte);",
          "4814:     assert( iRegion==p->nShm );",
          "4815:     if( apNew==0 ){",
          "4816:       rc = SQLITE_NOMEM;",
          "4817:     }else{",
          "4818:       memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));",
          "4819:       p->apShm = apNew;",
          "4820:       p->nShm = iRegion+1;",
          "4823:     if( rc==SQLITE_OK ){",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 956ca2a452aa3707bca553007a7ef221af3d4f6b0af747d17070926e000f2362",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_vfs.c||src/test_vfs.c": [
          "File: src/test_vfs.c -> src/test_vfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "235:     { SQLITE_BUSY,     \"SQLITE_BUSY\"   },",
          "236:     { SQLITE_READONLY, \"SQLITE_READONLY\"   },",
          "237:     { SQLITE_READONLY_CANTINIT, \"SQLITE_READONLY_CANTINIT\"   },",
          "238:     { -1,              \"SQLITE_OMIT\"   },",
          "239:   };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:     { SQLITE_NOTFOUND, \"SQLITE_NOTFOUND\"   },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "552:     } aF[] = {",
          "553:       { SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, \"BEGIN_ATOMIC_WRITE\" },",
          "554:       { SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, \"COMMIT_ATOMIC_WRITE\" },",
          "555:     };",
          "556:     int i;",
          "557:     for(i=0; i<sizeof(aF)/sizeof(aF[0]); i++){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "556:       { SQLITE_FCNTL_ZIPVFS, \"ZIPVFS\" },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "565:           0, 0",
          "566:       );",
          "567:       tvfsResultCode(p, &rc);",
          "569:     }",
          "570:   }",
          "571:   return sqlite3OsFileControl(pFd->pReal, op, pArg);",
          "",
          "[Removed Lines]",
          "568:       if( rc ) return rc;",
          "",
          "[Added Lines]",
          "570:       if( rc ) return (rc<0 ? SQLITE_OK : rc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b6ce71bd265314f65ad95ecdb2735af54121a4dd",
      "candidate_info": {
        "commit_hash": "b6ce71bd265314f65ad95ecdb2735af54121a4dd",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b6ce71bd265314f65ad95ecdb2735af54121a4dd",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/wherecode.c",
          "test/affinity2.test"
        ],
        "message": "Retain the affinity of an expression in a WHERE clause when it is transformed to a reference to an index column on the same expression. Fix for [f043b113].\n\nFossilOrigin-Name: 511da0815673ca4a176aa61dc23a8231b2ab77e8363fc184a78b6e17dba64d49",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/wherecode.c||src/wherecode.c",
          "test/affinity2.test||test/affinity2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ec4c63e00c957f98d61ddc1b9d20406c7e1072d6ab0c12ac6939db6c63d90cb8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1117: static int whereIndexExprTransNode(Walker *p, Expr *pExpr){",
          "1118:   IdxExprTrans *pX = p->u.pIdxTrans;",
          "1119:   if( sqlite3ExprCompare(0, pExpr, pX->pIdxExpr, pX->iTabCur)==0 ){",
          "1120:     pExpr->op = TK_COLUMN;",
          "1121:     pExpr->iTable = pX->iIdxCur;",
          "1122:     pExpr->iColumn = pX->iIdxCol;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1120:     pExpr->affExpr = sqlite3ExprAffinity(pExpr);",
          "",
          "---------------"
        ],
        "test/affinity2.test||test/affinity2.test": [
          "File: test/affinity2.test -> test/affinity2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "18: do_execsql_test affinity2-100 {",
          "19:   CREATE TABLE t1(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: set testprefix affinity2",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:   SELECT rowid, xt==+xi, xt==xi, xt==xb FROM t1 ORDER BY rowid;",
          "59: } {1 1 1 0 2 1 1 1 3 0 1 1}",
          "61: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #-------------------------------------------------------------------------",
          "63: do_execsql_test 400 {",
          "64:   CREATE TABLE ttt(c0, c1);",
          "65:   CREATE INDEX ii ON ttt(CAST(c0 AS NUMERIC));",
          "66:   INSERT INTO ttt VALUES('abc', '-1');",
          "67: }",
          "68: do_execsql_test 410 {",
          "69:   SELECT * FROM ttt WHERE CAST(c0 AS NUMERIC) > c1 GROUP BY rowid;",
          "70: } {abc -1}",
          "71: do_execsql_test 420 {",
          "72:   SELECT * FROM ttt INDEXED BY ii WHERE CAST(c0 AS NUMERIC) > c1 GROUP BY rowid;",
          "73: } {abc -1}",
          "75: do_execsql_test 430 {",
          "76:   CREATE TABLE t3(a, b, c INTEGER);",
          "77:   CREATE INDEX t3ac ON t3(a, c-1);",
          "78:   INSERT INTO t3 VALUES(1, 1, 1);",
          "79:   INSERT INTO t3 VALUES(2, 1, 0);",
          "80:   INSERT INTO t3 VALUES(3, 1, 1);",
          "81:   INSERT INTO t3 VALUES(4, 1, 0);",
          "82:   INSERT INTO t3 VALUES(5, 1, 1);",
          "83: }",
          "84: do_execsql_test 440 {",
          "85:   SELECT * FROM t3 WHERE c='0' ORDER BY a;",
          "86: } {2 1 0 4 1 0}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe03dac236fb191c03bef60c30abbfa35e648e4c",
      "candidate_info": {
        "commit_hash": "fe03dac236fb191c03bef60c30abbfa35e648e4c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/fe03dac236fb191c03bef60c30abbfa35e648e4c",
        "files": [
          "Makefile.in",
          "Makefile.msc",
          "manifest",
          "manifest.uuid",
          "tool/lemon.c"
        ],
        "message": "Add the new -S option to the lemon parser generator to cause it to output SQL that describes the input grammar.\n\nFossilOrigin-Name: 4dbd398d640852d4a696d68c72ee039968023d402a8053b5e6b4ef1d75e982a8",
        "before_after_code_files": [
          "Makefile.in||Makefile.in",
          "Makefile.msc||Makefile.msc",
          "manifest.uuid||manifest.uuid",
          "tool/lemon.c||tool/lemon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.in||Makefile.in": [
          "File: Makefile.in -> Makefile.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "1053: parse.c: $(TOP)/src/parse.y lemon$(BEXE)",
          "1054:  cp $(TOP)/src/parse.y .",
          "1057: sqlite3.h: $(TOP)/src/sqlite.h.in $(TOP)/manifest mksourceid$(BEXE) $(TOP)/VERSION",
          "1058:  $(TCLSH_CMD) $(TOP)/tool/mksqlite3h.tcl $(TOP) >sqlite3.h",
          "",
          "[Removed Lines]",
          "1055:  ./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) parse.y",
          "",
          "[Added Lines]",
          "1055:  ./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) -S parse.y",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1180: fts5parse.c: $(TOP)/ext/fts5/fts5parse.y lemon",
          "1181:  cp $(TOP)/ext/fts5/fts5parse.y .",
          "1182:  rm -f fts5parse.h",
          "1185: fts5parse.h: fts5parse.c",
          "",
          "[Removed Lines]",
          "1183:  ./lemon$(BEXE) $(OPTS) fts5parse.y",
          "",
          "[Added Lines]",
          "1183:  ./lemon$(BEXE) $(OPTS) -S fts5parse.y",
          "",
          "---------------"
        ],
        "Makefile.msc||Makefile.msc": [
          "File: Makefile.msc -> Makefile.msc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2141: parse.c: $(TOP)\\src\\parse.y lemon.exe",
          "2142:  del /Q parse.y parse.h parse.h.temp 2>NUL",
          "2143:  copy $(TOP)\\src\\parse.y .",
          "2146: $(SQLITE3H): $(TOP)\\src\\sqlite.h.in $(TOP)\\manifest mksourceid.exe $(TOP)\\VERSION",
          "2147:  $(TCLSH_CMD) $(TOP)\\tool\\mksqlite3h.tcl $(TOP:\\=/) > $(SQLITE3H) $(MKSQLITE3H_ARGS)",
          "",
          "[Removed Lines]",
          "2144:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) parse.y",
          "",
          "[Added Lines]",
          "2144:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) -S parse.y",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2301: fts5parse.c: $(TOP)\\ext\\fts5\\fts5parse.y lemon.exe",
          "2302:  copy $(TOP)\\ext\\fts5\\fts5parse.y .",
          "2303:  del /Q fts5parse.h 2>NUL",
          "2306: fts5parse.h: fts5parse.c",
          "",
          "[Removed Lines]",
          "2304:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) fts5parse.y",
          "",
          "[Added Lines]",
          "2304:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) -S fts5parse.y",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 5d9a369301a65f320a0696fcf1f062ca5976ef34350590c07aecf5335c66d872",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "219: void Reprint(struct lemon *);",
          "220: void ReportOutput(struct lemon *);",
          "222: void ReportHeader(struct lemon *);",
          "223: void CompressTables(struct lemon *);",
          "224: void ResortStates(struct lemon *);",
          "",
          "[Removed Lines]",
          "221: void ReportTable(struct lemon *, int);",
          "",
          "[Added Lines]",
          "221: void ReportTable(struct lemon *, int, int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1632:   static int mhflag = 0;",
          "1633:   static int nolinenosflag = 0;",
          "1634:   static int noResort = 0;",
          "1636:   static struct s_options options[] = {",
          "1637:     {OPT_FLAG, \"b\", (char*)&basisflag, \"Print only the basis in report.\"},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1635:   static int sqlFlag = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1650:     {OPT_FLAG, \"r\", (char*)&noResort, \"Do not sort or renumber states\"},",
          "1651:     {OPT_FLAG, \"s\", (char*)&statistics,",
          "1652:                                    \"Print parser stats to standard output.\"},",
          "1653:     {OPT_FLAG, \"x\", (char*)&version, \"Print the version number.\"},",
          "1654:     {OPT_FSTR, \"T\", (char*)handle_T_option, \"Specify a template file.\"},",
          "1655:     {OPT_FSTR, \"W\", 0, \"Ignored.  (Placeholder for '-W' compiler options.)\"},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1654:     {OPT_FLAG, \"S\", (char*)&sqlFlag,",
          "1655:                     \"Generate the *.sql file describing the parser tables.\"},",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1758:     if( !quiet ) ReportOutput(&lem);",
          "",
          "[Removed Lines]",
          "1761:     ReportTable(&lem, mhflag);",
          "",
          "[Added Lines]",
          "1764:     ReportTable(&lem, mhflag, sqlFlag);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4144: void ReportTable(",
          "4145:   struct lemon *lemp,",
          "4147: ){",
          "4149:   char line[LINESIZE];",
          "4150:   int  lineno;",
          "4151:   struct state *stp;",
          "",
          "[Removed Lines]",
          "4148:   FILE *out, *in;",
          "",
          "[Added Lines]",
          "4152:   FILE *out, *in, *sql;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4175:     fclose(in);",
          "4176:     return;",
          "4177:   }",
          "4178:   lineno = 1;",
          "4179:   tplt_xfer(lemp->name,in,out,&lineno);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4182:   if( sqlFlag==0 ){",
          "4183:     sql = 0;",
          "4184:   }else{",
          "4185:     sql = file_open(lemp, \".sql\", \"wb\");",
          "4186:     if( sql==0 ){",
          "4187:       fclose(in);",
          "4188:       fclose(out);",
          "4189:       return;",
          "4190:     }",
          "4191:     fprintf(sql,",
          "4192:        \"CREATE TABLE symbol(\\n\"",
          "4193:        \"  id INTEGER PRIMARY KEY,\\n\"",
          "4194:        \"  name TEXT NOT NULL,\\n\"",
          "4195:        \"  isTerminal BOOLEAN NOT NULL,\\n\"",
          "4196:        \"  fallback INTEGER REFERENCES symbol\\n\"",
          "4197:        \");\\n\"",
          "4198:     );",
          "4199:     for(i=0; i<lemp->nsymbol; i++){",
          "4200:       fprintf(sql,",
          "4201:          \"INSERT INTO symbol(id,name,isTerminal,fallback)\"",
          "4202:          \"VALUES(%d,'%s',%s\",",
          "4203:          i, lemp->symbols[i]->name,",
          "4204:          i<lemp->nterminal ? \"TRUE\" : \"FALSE\"",
          "4205:       );",
          "4206:       if( lemp->symbols[i]->fallback ){",
          "4207:         fprintf(sql, \",%d);\\n\", lemp->symbols[i]->fallback->index);",
          "4208:       }else{",
          "4209:         fprintf(sql, \",NULL);\\n\");",
          "4210:       }",
          "4211:     }",
          "4212:     fprintf(sql,",
          "4213:       \"CREATE TABLE rule(\\n\"",
          "4214:       \"  ruleid INTEGER PRIMARY KEY,\\n\"",
          "4215:       \"  lhs INTEGER REFERENCES symbol(id)\\n\"",
          "4216:       \");\\n\"",
          "4217:       \"CREATE TABLE rulerhs(\\n\"",
          "4218:       \"  ruleid INTEGER REFERENCES rule(ruleid),\\n\"",
          "4219:       \"  pos INTEGER,\\n\"",
          "4220:       \"  sym INTEGER REFERENCES symbol(id)\\n\"",
          "4221:       \");\\n\"",
          "4222:     );",
          "4223:     for(i=0, rp=lemp->rule; rp; rp=rp->next, i++){",
          "4224:       assert( i==rp->iRule );",
          "4225:       fprintf(sql,",
          "4226:         \"INSERT INTO rule(ruleid,lhs)VALUES(%d,%d);\\n\",",
          "4227:         rp->iRule, rp->lhs->index",
          "4228:       );",
          "4229:       for(j=0; j<rp->nrhs; j++){",
          "4230:         struct symbol *sp = rp->rhs[j];",
          "4231:         if( sp->type!=MULTITERMINAL ){",
          "4232:           fprintf(sql,",
          "4233:             \"INSERT INTO rulerhs(ruleid,pos,sym)VALUES(%d,%d,%d);\\n\",",
          "4234:             i,j,sp->index",
          "4235:           );",
          "4236:         }else{",
          "4237:           int k;",
          "4238:           for(k=0; k<sp->nsubsym; k++){",
          "4239:             fprintf(sql,",
          "4240:               \"INSERT INTO rulerhs(ruleid,pos,sym)VALUES(%d,%d,%d);\\n\",",
          "4241:               i,j,sp->subsym[k]->index",
          "4242:             );",
          "4243:           }",
          "4244:         }",
          "4245:       }",
          "4246:     }",
          "4247:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4697:   acttab_free(pActtab);",
          "4698:   fclose(in);",
          "4699:   fclose(out);",
          "4700:   return;",
          "4701: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4770:   if( sql ) fclose(sql);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68cb86ef23e3bc9e6362fec4937968a65ec025b5",
      "candidate_info": {
        "commit_hash": "68cb86ef23e3bc9e6362fec4937968a65ec025b5",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/68cb86ef23e3bc9e6362fec4937968a65ec025b5",
        "files": [
          "ext/misc/dbdata.c",
          "main.mk",
          "manifest",
          "manifest.uuid",
          "src/shell.c.in",
          "tool/mkshellc.tcl"
        ],
        "message": "Add the \".recovery\" command to the shell tool. For recovering the maximum amount data from corrupt databases. Still needs work.\n\nFossilOrigin-Name: 7461d2e120f2149315ddac2676d51d7445bcdb8e97543effd9c30603517ef9da",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "main.mk||main.mk",
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in",
          "tool/mkshellc.tcl||tool/mkshellc.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: #include \"sqlite3ext.h\"",
          "69: typedef unsigned char u8;",
          "72: #endif",
          "73: SQLITE_EXTENSION_INIT1",
          "",
          "[Removed Lines]",
          "66: #if !defined(SQLITEINT_H)",
          "70: typedef unsigned int u32;",
          "",
          "[Added Lines]",
          "66: #if !defined(SQLITEINT_H)",
          "70: typedef unsigned long u32;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:   u8 *pHdrPtr;",
          "100:   u8 *pPtr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "306:   return 9;",
          "307: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312: static int dbdataValueBytes(int eType){",
          "313:   switch( eType ){",
          "314:     case 0: case 8: case 9:",
          "315:     case 10: case 11:",
          "316:       return 0;",
          "317:     case 1:",
          "318:       return 1;",
          "319:     case 2:",
          "320:       return 2;",
          "321:     case 3:",
          "322:       return 3;",
          "323:     case 4:",
          "324:       return 4;",
          "325:     case 5:",
          "326:       return 6;",
          "327:     case 6:",
          "328:     case 7:",
          "329:       return 8;",
          "330:     default:",
          "331:       return ((eType-12) / 2);",
          "332:   }",
          "333: }",
          "335: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "336:   switch( eType ){",
          "337:     case 0:",
          "338:     case 10:",
          "339:     case 11:",
          "340:       sqlite3_result_null(pCtx);",
          "341:       break;",
          "343:     case 8:",
          "344:       sqlite3_result_int(pCtx, 0);",
          "345:       break;",
          "346:     case 9:",
          "347:       sqlite3_result_int(pCtx, 1);",
          "348:       break;",
          "350:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "351:       sqlite3_uint64 v = (signed char)pData[0];",
          "352:       pData++;",
          "353:       switch( eType ){",
          "354:         case 7:",
          "355:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "356:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "357:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "358:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "359:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "360:       }",
          "362:       if( eType==7 ){",
          "363:         double r;",
          "364:         memcpy(&r, &v, sizeof(r));",
          "365:         sqlite3_result_double(pCtx, r);",
          "366:       }else{",
          "367:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "368:       }",
          "369:       break;",
          "370:     }",
          "372:     default: {",
          "373:       int n = ((eType-12) / 2);",
          "374:       if( eType % 2 ){",
          "375:         sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "376:       }else{",
          "377:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "378:       }",
          "379:     }",
          "380:   }",
          "381: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "435:           }",
          "436:         }",
          "440:         iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);",
          "445:         }",
          "448:       }",
          "",
          "[Removed Lines]",
          "439:         pCsr->nField = 0;",
          "441:         while( iHdr<nHdr ){",
          "442:           sqlite3_int64 iDummy;",
          "443:           iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iDummy);",
          "444:           pCsr->nField++;",
          "447:         pCsr->iField = (bHasRowid ? -2 : -1);",
          "450:       pCsr->iField++;",
          "451:       if( pCsr->iField<pCsr->nField ) return SQLITE_OK;",
          "",
          "[Added Lines]",
          "514:         pCsr->nHdr = nHdr;",
          "515:         pCsr->pHdrPtr = &pCsr->pRec[iHdr];",
          "516:         pCsr->pPtr = &pCsr->pRec[pCsr->nHdr];",
          "517:         pCsr->iField = (bHasRowid ? -1 : 0);",
          "518:       }else{",
          "519:         pCsr->iField++;",
          "520:         if( pCsr->iField>0 ){",
          "521:           sqlite3_int64 iType;",
          "522:           pCsr->pHdrPtr += dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "523:           pCsr->pPtr += dbdataValueBytes(iType);",
          "527:       if( pCsr->iField<0 || pCsr->pHdrPtr<&pCsr->pRec[pCsr->nHdr] ){",
          "528:         return SQLITE_OK;",
          "529:       }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "485:   dbdataResetCursor(pCsr);",
          "486:   assert( pCsr->iPgno==1 );",
          "487:   if( idxNum & 0x01 ){",
          "489:   }",
          "490:   if( idxNum & 0x02 ){",
          "491:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);",
          "",
          "[Removed Lines]",
          "488:     zSchema = sqlite3_value_text(argv[0]);",
          "",
          "[Added Lines]",
          "566:     zSchema = (const char*)sqlite3_value_text(argv[0]);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "498:   );",
          "499:   if( rc==SQLITE_OK ){",
          "500:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);",
          "501:   }",
          "502:   if( rc==SQLITE_OK ){",
          "503:     rc = dbdataNext(pCursor);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "579:   }else{",
          "580:     pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(pTab->db));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "505:   return rc;",
          "506: }",
          "580: static int dbdataColumn(",
          "581:   sqlite3_vtab_cursor *pCursor,",
          "",
          "[Removed Lines]",
          "508: static int dbdataValueBytes(int eType){",
          "509:   switch( eType ){",
          "510:     case 0: case 8: case 9:",
          "511:     case 10: case 11:",
          "512:       return 0;",
          "513:     case 1:",
          "514:       return 1;",
          "515:     case 2:",
          "516:       return 2;",
          "517:     case 3:",
          "518:       return 3;",
          "519:     case 4:",
          "520:       return 4;",
          "521:     case 5:",
          "522:       return 6;",
          "523:     case 6:",
          "524:     case 7:",
          "525:       return 8;",
          "526:     default:",
          "527:       return ((eType-12) / 2);",
          "528:   }",
          "529: }",
          "531: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "532:   switch( eType ){",
          "533:     case 0:",
          "534:     case 10:",
          "535:     case 11:",
          "536:       sqlite3_result_null(pCtx);",
          "537:       break;",
          "539:     case 8:",
          "540:       sqlite3_result_int(pCtx, 0);",
          "541:       break;",
          "542:     case 9:",
          "543:       sqlite3_result_int(pCtx, 1);",
          "544:       break;",
          "546:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "547:       sqlite3_uint64 v = (signed char)pData[0];",
          "548:       pData++;",
          "549:       switch( eType ){",
          "550:         case 7:",
          "551:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "552:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "553:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "554:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "555:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "556:       }",
          "558:       if( eType==7 ){",
          "559:         double r;",
          "560:         memcpy(&r, &v, sizeof(r));",
          "561:         sqlite3_result_double(pCtx, r);",
          "562:       }else{",
          "563:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "564:       }",
          "565:       break;",
          "566:     }",
          "568:     default: {",
          "569:       int n = ((eType-12) / 2);",
          "570:       if( eType % 2 ){",
          "571:         sqlite3_result_text(pCtx, pData, n, SQLITE_TRANSIENT);",
          "572:       }else{",
          "573:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "574:       }",
          "575:     }",
          "576:   }",
          "577: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "616:         if( pCsr->iField<0 ){",
          "617:           sqlite3_result_int64(ctx, pCsr->iIntkey);",
          "618:         }else{",
          "620:           sqlite3_int64 iType;",
          "631:         }",
          "632:         break;",
          "633:       }",
          "",
          "[Removed Lines]",
          "619:           int iHdr;",
          "621:           sqlite3_int64 iOff;",
          "622:           int i;",
          "623:           iHdr = dbdataGetVarint(pCsr->pRec, &iOff);",
          "624:           for(i=0; i<pCsr->iField; i++){",
          "625:             iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "626:             iOff += dbdataValueBytes(iType);",
          "627:           }",
          "628:           dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "630:           dbdataValue(ctx, iType, &pCsr->pRec[iOff]);",
          "",
          "[Added Lines]",
          "629:           dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "630:           dbdataValue(ctx, iType, pCsr->pPtr);",
          "",
          "---------------"
        ],
        "main.mk||main.mk": [
          "File: main.mk -> main.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:  $(TOP)/ext/expert/sqlite3expert.h \\",
          "739:  $(TOP)/ext/misc/zipfile.c \\",
          "740:  $(TOP)/ext/misc/memtrace.c \\",
          "741:         $(TOP)/src/test_windirent.c",
          "743: shell.c: $(SHELL_SRC) $(TOP)/tool/mkshellc.tcl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741:  $(TOP)/ext/misc/dbdata.c \\",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3213a15f2133afbb0a4fec3b8f6e0eeca8c0befafd6658c41074e84f589d5d32",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "948: INCLUDE ../ext/expert/sqlite3expert.h",
          "949: INCLUDE ../ext/expert/sqlite3expert.c",
          "951: #if defined(SQLITE_ENABLE_SESSION)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951: INCLUDE ../ext/misc/dbdata.c",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3999:     sqlite3_fileio_init(p->db, 0, 0);",
          "4000:     sqlite3_shathree_init(p->db, 0, 0);",
          "4001:     sqlite3_completion_init(p->db, 0, 0);",
          "4002: #ifdef SQLITE_HAVE_ZLIB",
          "4003:     sqlite3_zipfile_init(p->db, 0, 0);",
          "4004:     sqlite3_sqlar_init(p->db, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4005:     sqlite3_dbdata_init(p->db, 0, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6033: static void shellExec(sqlite3 *db, int *pRc, const char *zSql){",
          "6034:   int rc = *pRc;",
          "6035:   if( rc==SQLITE_OK ){",
          "6036:     char *zErr = 0;",
          "6037:     rc = sqlite3_exec(db, zSql, 0, 0, &zErr);",
          "6038:     if( rc!=SQLITE_OK ){",
          "6039:       raw_printf(stderr, \"SQL error: %s\\n\", zErr);",
          "6040:     }",
          "6042:   }",
          "6043: }",
          "6045: static void *shellMalloc(int *pRc, sqlite3_int64 nByte){",
          "6046:   void *pRet = 0;",
          "6047:   if( *pRc==SQLITE_OK ){",
          "6048:     pRet = sqlite3_malloc64(nByte);",
          "6049:     if( pRet==0 ){",
          "6051:     }else{",
          "6052:       memset(pRet, 0, nByte);",
          "6053:     }",
          "6054:   }",
          "6055:   return pRet;",
          "6056: }",
          "6058: static char *shellMPrintf(int *pRc, const char *zFmt, ...){",
          "6059:   char *z = 0;",
          "6060:   if( *pRc==SQLITE_OK ){",
          "6061:     va_list ap;",
          "6062:     va_start(ap, zFmt);",
          "6063:     z = sqlite3_vmprintf(zFmt, ap);",
          "6064:     va_end(ap);",
          "6065:     if( z==0 ){",
          "6067:     }",
          "6068:   }",
          "6069:   return z;",
          "6070: }",
          "6072: typedef struct RecoverTable RecoverTable;",
          "6073: struct RecoverTable {",
          "6079: };",
          "6084: static void recoverFreeTable(RecoverTable *pTab){",
          "6085:   if( pTab ){",
          "6086:     sqlite3_free(pTab->zName);",
          "6087:     sqlite3_free(pTab->zQuoted);",
          "6088:     sqlite3_free(pTab->zCreate);",
          "6089:     if( pTab->azlCol ){",
          "6090:       int i;",
          "6091:       for(i=0; i<pTab->nCol; i++){",
          "6092:         sqlite3_free(pTab->azlCol[i]);",
          "6093:       }",
          "6094:       sqlite3_free(pTab->azlCol);",
          "6095:     }",
          "6096:     sqlite3_free(pTab);",
          "6097:   }",
          "6098: }",
          "6100: static RecoverTable *recoverNewTable(",
          "6101:   ShellState *pState,",
          "6102:   int *pRc,",
          "6103:   int iRoot,",
          "6104:   int nCol",
          "6105: ){",
          "6106:   RecoverTable *pRet = 0;",
          "6108:   pRet = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6109:   if( pRet ){",
          "6110:     sqlite3_stmt *pStmt = 0;",
          "6111:     pRet->zName = shellMPrintf(pRc, \"orphan_%d_%d\", nCol, iRoot);",
          "6112:     pRet->zQuoted = shellMPrintf(pRc, \"%Q\", pRet->zName);",
          "6113:     pRet->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * nCol);",
          "6114:     pRet->nCol = nCol;",
          "6116:     shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6117:       \"WITH s(i) AS (\"",
          "6118:       \"  SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<%d\"",
          "6119:       \")\"",
          "6120:       \"SELECT i-1, group_concat('c' || i, ', ') OVER (ORDER BY i) FROM s\",",
          "6121:       nCol",
          "6122:     );",
          "6123:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6124:       int idx = sqlite3_column_int(pStmt, 0);",
          "6125:       const char *zText = (const char*)sqlite3_column_text(pStmt, 1);",
          "6126:       pRet->azlCol[idx] = shellMPrintf(pRc, \"%s\", zText);",
          "6127:     }",
          "6128:     shellFinalize(pRc, pStmt);",
          "6130:     pRet->zCreate = shellMPrintf(pRc, \"CREATE TABLE %Q (id, %s)\",",
          "6131:         pRet->zName, pRet->azlCol[nCol-1]",
          "6132:     );",
          "6133:   }",
          "6135:   if( *pRc!=SQLITE_OK ){",
          "6136:     recoverFreeTable(pRet);",
          "6137:     pRet = 0;",
          "6138:   }",
          "6140:   return pRet;",
          "6141: }",
          "6148: static int recoverDatabaseCmd(ShellState *pState){",
          "6149:   const char *zSql;",
          "6150:   int rc = SQLITE_OK;",
          "6153:   shellExec(pState->db, &rc,",
          "6156:     \"ATTACH '' AS recovery;\"",
          "6157:     \"CREATE TABLE recovery.dbptr(\"",
          "6158:     \"      pgno, child, PRIMARY KEY(child, pgno)\"",
          "6159:     \") WITHOUT ROWID;\"",
          "6160:     \"INSERT OR IGNORE INTO dbptr(pgno, child) SELECT * FROM sqlite_dbptr;\"",
          "6164:     \"DELETE FROM recovery.dbptr WHERE child = 1;\"",
          "6169:     \"DELETE FROM recovery.dbptr WHERE child IN (\"",
          "6170:     \"  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1\"",
          "6171:     \");\"",
          "6176:     \"CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, maxlen INT, root INT);\"",
          "6181:     \"WITH pages(i, maxlen) AS (\"",
          "6182:     \"  SELECT page_count, max(field+1) \"",
          "6183:     \"      FROM pragma_page_count, sqlite_dbdata WHERE pgno=page_count\"",
          "6184:     \"    UNION ALL\"",
          "6185:     \"  SELECT * FROM (SELECT i-1, max(field+1)\"",
          "6186:     \"      FROM pages, sqlite_dbdata WHERE pgno=i-1 AND i>=2)\"",
          "6187:     \")\"",
          "6188:     \"INSERT INTO recovery.map(pgno, maxlen, root) SELECT i, maxlen, (\"",
          "6189:     \"    WITH p(orig, pgno, parent) AS (\"",
          "6190:     \"      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)\"",
          "6191:     \"        UNION ALL\"",
          "6192:     \"      SELECT i, p.parent, \"",
          "6193:     \"        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p\"",
          "6194:     \"    )\"",
          "6195:     \"    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)\"",
          "6196:     \") \"",
          "6197:     \"FROM pages WHERE maxlen > 0;\"",
          "6201:     \"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\"",
          "6202:     \"INSERT INTO recovery.schema SELECT \"",
          "6203:     \"  max(CASE WHEN field=0 THEN value ELSE NULL END),\"",
          "6204:     \"  max(CASE WHEN field=1 THEN value ELSE NULL END),\"",
          "6205:     \"  max(CASE WHEN field=2 THEN value ELSE NULL END),\"",
          "6206:     \"  max(CASE WHEN field=3 THEN value ELSE NULL END),\"",
          "6207:     \"  max(CASE WHEN field=4 THEN value ELSE NULL END)\"",
          "6208:     \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6209:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6210:     \")\"",
          "6211:     \"GROUP BY pgno, cell;\"",
          "6212:   );",
          "6214: #if 0",
          "6215:   zSql = \"SELECT type ||','|| name ||','|| tbl_name ||','|| rootpage ||','|| sql FROM recovery.schema;\";",
          "6216:   shellPrepare(pState->db, &rc, zSql, &pLoop);",
          "6217:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6218:     raw_printf(pState->out, \"%s\\n\", (const char*)sqlite3_column_text(pLoop, 0));",
          "6219:   }",
          "6220:   shellFinalize(&rc, pLoop);",
          "6221:   return rc;",
          "6222: #endif",
          "6225:   zSql = \"SELECT root,max(maxlen) FROM recovery.map WHERE root>1 GROUP BY root\";",
          "6226:   shellPrepare(pState->db, &rc, zSql, &pLoop);",
          "6227:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6228:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6229:     int nCol = sqlite3_column_int(pLoop, 1);",
          "6230:     RecoverTable *pTab;",
          "6232:     pTab = recoverNewTable(pState, &rc, iRoot, nCol);",
          "6233:     if( pTab ){",
          "6234:       sqlite3_stmt *pData = 0;",
          "6235:       raw_printf(pState->out, \"%s;\\n\", pTab->zCreate);",
          "6236:       shellPreparePrintf(pState->db, &rc, &pData,",
          "6237:         \"SELECT max(field), group_concat(quote(value), ', ') \"",
          "6238:         \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6239:         \"  SELECT pgno FROM recovery.map WHERE root=%d\"",
          "6240:         \")\"",
          "6241:         \"GROUP BY pgno, cell;\", iRoot",
          "6242:       );",
          "6243:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pData) ){",
          "6244:         int iMax = sqlite3_column_int(pData, 0);",
          "6245:         const char *zVal = (const char*)sqlite3_column_text(pData, 1);",
          "6246:         if( iMax+1==pTab->nCol ){",
          "6247:           raw_printf(pState->out, \"INSERT INTO %s VALUES( %s );\\n\",",
          "6248:               pTab->zQuoted, zVal);",
          "6249:         }else{",
          "6250:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6251:               pTab->zQuoted, pTab->azlCol[iMax], zVal",
          "6252:           );",
          "6253:         }",
          "6254:       }",
          "6255:       shellFinalize(&rc, pData);",
          "6256:     }",
          "6257:     recoverFreeTable(pTab);",
          "6258:   }",
          "6259:   shellFinalize(&rc, pLoop);",
          "6261:   sqlite3_exec(pState->db, \"DETACH recovery\", 0, 0, 0);",
          "6262:   return rc;",
          "6263: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6313:     rc = shell_dbinfo_command(p, nArg, azArg);",
          "6314:   }else",
          "6316:   if( c=='d' && strncmp(azArg[0], \"dump\", n)==0 ){",
          "6317:     const char *zLike = 0;",
          "6318:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6552:   if( c=='r' && strncmp(azArg[0], \"recover\", n)==0 ){",
          "6553:     open_db(p, 0);",
          "6554:     rc = recoverDatabaseCmd(p);",
          "6555:   }else",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6365:     p->nErr = 0;",
          "6366:     if( zLike==0 ){",
          "6367:       run_schema_dump_query(p,",
          "6371:       run_schema_dump_query(p,",
          "6375:       run_table_dump_query(p,",
          "6379:     }else{",
          "6380:       char *zSql;",
          "6381:       zSql = sqlite3_mprintf(",
          "6385:       run_schema_dump_query(p,zSql);",
          "6386:       sqlite3_free(zSql);",
          "6387:       zSql = sqlite3_mprintf(",
          "6392:       run_table_dump_query(p, zSql, 0);",
          "6393:       sqlite3_free(zSql);",
          "6394:     }",
          "",
          "[Removed Lines]",
          "6368:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6369:         \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "6370:       );",
          "6372:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6373:         \"WHERE name=='sqlite_sequence'\"",
          "6374:       );",
          "6376:         \"SELECT sql FROM sqlite_master \"",
          "6377:         \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "6378:       );",
          "6382:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6383:         \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "6384:         \"  AND sql NOT NULL\", zLike);",
          "6388:         \"SELECT sql FROM sqlite_master \"",
          "6389:         \"WHERE sql NOT NULL\"",
          "6390:         \"  AND type IN ('index','trigger','view')\"",
          "6391:         \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "[Added Lines]",
          "6611:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6612:           \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "6613:           );",
          "6615:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6616:           \"WHERE name=='sqlite_sequence'\"",
          "6617:           );",
          "6619:           \"SELECT sql FROM sqlite_master \"",
          "6620:           \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "6621:           );",
          "6625:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6626:           \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "6627:           \"  AND sql NOT NULL\", zLike);",
          "6631:           \"SELECT sql FROM sqlite_master \"",
          "6632:           \"WHERE sql NOT NULL\"",
          "6633:           \"  AND type IN ('index','trigger','view')\"",
          "6634:           \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6398:     }",
          "6399:     sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);",
          "6400:     sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);",
          "6402:     p->showHeader = savedShowHeader;",
          "6403:     p->shellFlgs = savedShellFlags;",
          "6404:   }else",
          "",
          "[Removed Lines]",
          "6401:     raw_printf(p->out, p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");",
          "",
          "[Added Lines]",
          "6644:     raw_printf(p->out, p->nErr?\"ROLLBACK; -- due to errors\\n\":\"COMMIT;\\n\");",
          "",
          "---------------"
        ],
        "tool/mkshellc.tcl||tool/mkshellc.tcl": [
          "File: tool/mkshellc.tcl -> tool/mkshellc.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   }",
          "41:   return $line",
          "42: }",
          "43: while {1} {",
          "44:   set lx [omit_redundant_typedefs [gets $in]]",
          "45:   if {[eof $in]} break;",
          "46:   if {[regexp {^INCLUDE } $lx]} {",
          "47:     set cfile [lindex $lx 1]",
          "48:     puts $out \"/************************* Begin $cfile ******************/\"",
          "49:     set in2 [open $topdir/src/$cfile rb]",
          "50:     while {![eof $in2]} {",
          "51:       set lx [omit_redundant_typedefs [gets $in2]]",
          "53:       if {[regexp {^# *include \"test_windirent.h\"} $lx]} {",
          "54:         set lx \"/* $lx */\"",
          "55:       }",
          "",
          "[Removed Lines]",
          "52:       if {[regexp {^#include \"sqlite} $lx]} continue",
          "",
          "[Added Lines]",
          "43: set iLine 0",
          "47:   incr iLine",
          "51:     puts $out \"#line 1 \\\"$cfile\\\"\"",
          "55:       if {[regexp {^#include \"sqlite} $lx]} {",
          "56:         set lx \"/* $lx */\"",
          "57:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     }",
          "59:     close $in2",
          "60:     puts $out \"/************************* End $cfile ********************/\"",
          "61:     continue",
          "62:   }",
          "63:   puts $out $lx",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:     puts $out \"#line [expr $iLine+1] \\\"shell.c.in\\\"\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bf00f6d7ece6a1e207e096a9a94e039594fb6d77",
      "candidate_info": {
        "commit_hash": "bf00f6d7ece6a1e207e096a9a94e039594fb6d77",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/bf00f6d7ece6a1e207e096a9a94e039594fb6d77",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/window.c"
        ],
        "message": "Enhanced VdbeCoverage() macros in the new windows function code.\n\nFossilOrigin-Name: f24066f8dd847dfb656f26c4a8142e7fb6a412ffe325aea6254cb122cfbb3e1c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: bb643bac535ac7d5fb4c13edb8782cd13540bbc7d2b2deb689f4ca8d1914f422",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1835:   sqlite3VdbeJumpHere(v, addrGe);",
          "1836:   sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1);",
          "1837:   sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);",
          "1840:   sqlite3ReleaseTempReg(pParse, reg1);",
          "1841:   sqlite3ReleaseTempReg(pParse, reg2);",
          "",
          "[Removed Lines]",
          "1838:   VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "1838:   assert( op==OP_Ge || op==OP_Gt || op==OP_Le );",
          "1839:   VdbeCoverageIf(v, op==OP_Ge);",
          "1840:   VdbeCoverageIf(v, op==OP_Gt);",
          "1841:   VdbeCoverageIf(v, op==OP_Le);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2533:   if( pMWin->eStart==pMWin->eEnd && regStart ){",
          "2534:     int op = ((pMWin->eStart==TK_FOLLOWING) ? OP_Ge : OP_Le);",
          "2535:     int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);",
          "2537:     windowAggFinal(&s, 0);",
          "2538:     sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);",
          "2539:     VdbeCoverageNeverTaken(v);",
          "",
          "[Removed Lines]",
          "2536:     VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "2539:     VdbeCoverageIf(v, op==OP_Ge);",
          "2540:     VdbeCoverageIf(v, op==OP_Le);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
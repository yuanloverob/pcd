{
  "cve_id": "CVE-2021-41864",
  "cve_desc": "prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.",
  "repo": "torvalds/linux",
  "patch_hash": "30e29a9a2bc6a4888335a6ede968b75cd329657a",
  "patch_info": {
    "commit_hash": "30e29a9a2bc6a4888335a6ede968b75cd329657a",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/30e29a9a2bc6a4888335a6ede968b75cd329657a",
    "files": [
      "kernel/bpf/stackmap.c"
    ],
    "message": "bpf: Fix integer overflow in prealloc_elems_and_freelist()\n\nIn prealloc_elems_and_freelist(), the multiplication to calculate the\nsize passed to bpf_map_area_alloc() could lead to an integer overflow.\nAs a result, out-of-bounds write could occur in pcpu_freelist_populate()\nas reported by KASAN:\n\n[...]\n[   16.968613] BUG: KASAN: slab-out-of-bounds in pcpu_freelist_populate+0xd9/0x100\n[   16.969408] Write of size 8 at addr ffff888104fc6ea0 by task crash/78\n[   16.970038]\n[   16.970195] CPU: 0 PID: 78 Comm: crash Not tainted 5.15.0-rc2+ #1\n[   16.970878] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n[   16.972026] Call Trace:\n[   16.972306]  dump_stack_lvl+0x34/0x44\n[   16.972687]  print_address_description.constprop.0+0x21/0x140\n[   16.973297]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.973777]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.974257]  kasan_report.cold+0x7f/0x11b\n[   16.974681]  ? pcpu_freelist_populate+0xd9/0x100\n[   16.975190]  pcpu_freelist_populate+0xd9/0x100\n[   16.975669]  stack_map_alloc+0x209/0x2a0\n[   16.976106]  __sys_bpf+0xd83/0x2ce0\n[...]\n\nThe possibility of this overflow was originally discussed in [0], but\nwas overlooked.\n\nFix the integer overflow by changing elem_size to u64 from u32.\n\n  [0] https://lore.kernel.org/bpf/728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/\n\nFixes: 557c0c6e7df8 (\"bpf: convert stackmap to pre-allocation\")\nSigned-off-by: Tatsuhiko Yasumatsu <th.yasumatsu@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20210930135545.173698-1-th.yasumatsu@gmail.com",
    "before_after_code_files": [
      "kernel/bpf/stackmap.c||kernel/bpf/stackmap.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/stackmap.c||kernel/bpf/stackmap.c": [
      "File: kernel/bpf/stackmap.c -> kernel/bpf/stackmap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "64: static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)",
      "65: {",
      "67:  int err;",
      "69:  smap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,",
      "",
      "[Removed Lines]",
      "66:  u32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;",
      "",
      "[Added Lines]",
      "66:  u64 elem_size = sizeof(struct stack_map_bucket) +",
      "67:    (u64)smap->map.value_size;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "49054556289e8787501630b7c7a9d407da02e296",
      "candidate_info": {
        "commit_hash": "49054556289e8787501630b7c7a9d407da02e296",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/49054556289e8787501630b7c7a9d407da02e296",
        "files": [
          "include/net/sock.h",
          "net/core/sock.c",
          "net/mptcp/protocol.c"
        ],
        "message": "net: introduce and use lock_sock_fast_nested()\n\nSyzkaller reported a false positive deadlock involving\nthe nl socket lock and the subflow socket lock:\n\nMPTCP: kernel_bind error, err=-98\n============================================\nWARNING: possible recursive locking detected\n5.15.0-rc1-syzkaller #0 Not tainted\n--------------------------------------------\nsyz-executor998/6520 is trying to acquire lock:\nffff8880795718a0 (k-sk_lock-AF_INET){+.+.}-{0:0}, at: mptcp_close+0x267/0x7b0 net/mptcp/protocol.c:2738\n\nbut task is already holding lock:\nffff8880787c8c60 (k-sk_lock-AF_INET){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1612 [inline]\nffff8880787c8c60 (k-sk_lock-AF_INET){+.+.}-{0:0}, at: mptcp_close+0x23/0x7b0 net/mptcp/protocol.c:2720\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(k-sk_lock-AF_INET);\n  lock(k-sk_lock-AF_INET);\n\n *** DEADLOCK ***\n\n May be due to missing lock nesting notation\n\n3 locks held by syz-executor998/6520:\n #0: ffffffff8d176c50 (cb_lock){++++}-{3:3}, at: genl_rcv+0x15/0x40 net/netlink/genetlink.c:802\n #1: ffffffff8d176d08 (genl_mutex){+.+.}-{3:3}, at: genl_lock net/netlink/genetlink.c:33 [inline]\n #1: ffffffff8d176d08 (genl_mutex){+.+.}-{3:3}, at: genl_rcv_msg+0x3e0/0x580 net/netlink/genetlink.c:790\n #2: ffff8880787c8c60 (k-sk_lock-AF_INET){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1612 [inline]\n #2: ffff8880787c8c60 (k-sk_lock-AF_INET){+.+.}-{0:0}, at: mptcp_close+0x23/0x7b0 net/mptcp/protocol.c:2720\n\nstack backtrace:\nCPU: 1 PID: 6520 Comm: syz-executor998 Not tainted 5.15.0-rc1-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_deadlock_bug kernel/locking/lockdep.c:2944 [inline]\n check_deadlock kernel/locking/lockdep.c:2987 [inline]\n validate_chain kernel/locking/lockdep.c:3776 [inline]\n __lock_acquire.cold+0x149/0x3ab kernel/locking/lockdep.c:5015\n lock_acquire kernel/locking/lockdep.c:5625 [inline]\n lock_acquire+0x1ab/0x510 kernel/locking/lockdep.c:5590\n lock_sock_fast+0x36/0x100 net/core/sock.c:3229\n mptcp_close+0x267/0x7b0 net/mptcp/protocol.c:2738\n inet_release+0x12e/0x280 net/ipv4/af_inet.c:431\n __sock_release net/socket.c:649 [inline]\n sock_release+0x87/0x1b0 net/socket.c:677\n mptcp_pm_nl_create_listen_socket+0x238/0x2c0 net/mptcp/pm_netlink.c:900\n mptcp_nl_cmd_add_addr+0x359/0x930 net/mptcp/pm_netlink.c:1170\n genl_family_rcv_msg_doit+0x228/0x320 net/netlink/genetlink.c:731\n genl_family_rcv_msg net/netlink/genetlink.c:775 [inline]\n genl_rcv_msg+0x328/0x580 net/netlink/genetlink.c:792\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2504\n genl_rcv+0x24/0x40 net/netlink/genetlink.c:803\n netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]\n netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1340\n netlink_sendmsg+0x86d/0xdb0 net/netlink/af_netlink.c:1929\n sock_sendmsg_nosec net/socket.c:704 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:724\n sock_no_sendpage+0x101/0x150 net/core/sock.c:2980\n kernel_sendpage.part.0+0x1a0/0x340 net/socket.c:3504\n kernel_sendpage net/socket.c:3501 [inline]\n sock_sendpage+0xe5/0x140 net/socket.c:1003\n pipe_to_sendpage+0x2ad/0x380 fs/splice.c:364\n splice_from_pipe_feed fs/splice.c:418 [inline]\n __splice_from_pipe+0x43e/0x8a0 fs/splice.c:562\n splice_from_pipe fs/splice.c:597 [inline]\n generic_splice_sendpage+0xd4/0x140 fs/splice.c:746\n do_splice_from fs/splice.c:767 [inline]\n direct_splice_actor+0x110/0x180 fs/splice.c:936\n splice_direct_to_actor+0x34b/0x8c0 fs/splice.c:891\n do_splice_direct+0x1b3/0x280 fs/splice.c:979\n do_sendfile+0xae9/0x1240 fs/read_write.c:1249\n __do_sys_sendfile64 fs/read_write.c:1314 [inline]\n __se_sys_sendfile64 fs/read_write.c:1300 [inline]\n __x64_sys_sendfile64+0x1cc/0x210 fs/read_write.c:1300\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f215cb69969\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffc96bb3868 EFLAGS: 00000246 ORIG_RAX: 0000000000000028\nRAX: ffffffffffffffda RBX: 00007f215cbad072 RCX: 00007f215cb69969\nRDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000005\nRBP: 0000000000000000 R08: 00007ffc96bb3a08 R09: 00007ffc96bb3a08\nR10: 0000000100000002 R11: 0000000000000246 R12: 00007ffc96bb387c\nR13: 431bde82d7b634db R14: 0000000000000000 R15: 0000000000000000\n\nthe problem originates from uncorrect lock annotation in the mptcp\ncode and is only visible since commit 2dcb96bacce3 (\"net: core: Correct\nthe sock::sk_lock.owned lockdep annotations\"), but is present since\nthe port-based endpoint support initial implementation.\n\nThis patch addresses the issue introducing a nested variant of\nlock_sock_fast() and using it in the relevant code path.\n\nFixes: 1729cf186d8a (\"mptcp: create the listening socket for new port\")\nFixes: 2dcb96bacce3 (\"net: core: Correct the sock::sk_lock.owned lockdep annotations\")\nSuggested-by: Thomas Gleixner <tglx@linutronix.de>\nReported-and-tested-by: syzbot+1dd53f7a89b299d59eaf@syzkaller.appspotmail.com\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/sock.h||include/net/sock.h",
          "net/core/sock.c||net/core/sock.c",
          "net/mptcp/protocol.c||net/mptcp/protocol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/net/sock.h||include/net/sock.h": [
          "File: include/net/sock.h -> include/net/sock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1623:     SINGLE_DEPTH_NESTING)",
          "1624: #define bh_unlock_sock(__sk) spin_unlock(&((__sk)->sk_lock.slock))",
          "",
          "[Removed Lines]",
          "1626: bool lock_sock_fast(struct sock *sk) __acquires(&sk->sk_lock.slock);",
          "",
          "[Added Lines]",
          "1626: bool __lock_sock_fast(struct sock *sk) __acquires(&sk->sk_lock.slock);",
          "1641: static inline bool lock_sock_fast(struct sock *sk)",
          "1642: {",
          "1644:  mutex_acquire(&sk->sk_lock.dep_map, 0, 0, _RET_IP_);",
          "1646:  return __lock_sock_fast(sk);",
          "1647: }",
          "1650: static inline bool lock_sock_fast_nested(struct sock *sk)",
          "1651: {",
          "1652:  mutex_acquire(&sk->sk_lock.dep_map, SINGLE_DEPTH_NESTING, 0, _RET_IP_);",
          "1654:  return __lock_sock_fast(sk);",
          "1655: }",
          "",
          "---------------"
        ],
        "net/core/sock.c||net/core/sock.c": [
          "File: net/core/sock.c -> net/core/sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3210: }",
          "3211: EXPORT_SYMBOL(release_sock);",
          "3227: {",
          "3231:  might_sleep();",
          "3232:  spin_lock_bh(&sk->sk_lock.slock);",
          "",
          "[Removed Lines]",
          "3226: bool lock_sock_fast(struct sock *sk) __acquires(&sk->sk_lock.slock)",
          "3229:  mutex_acquire(&sk->sk_lock.dep_map, 0, 0, _RET_IP_);",
          "",
          "[Added Lines]",
          "3213: bool __lock_sock_fast(struct sock *sk) __acquires(&sk->sk_lock.slock)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3256:  spin_unlock_bh(&sk->sk_lock.slock);",
          "3257:  return true;",
          "3258: }",
          "3261: int sock_gettstamp(struct socket *sock, void __user *userstamp,",
          "3262:      bool timeval, bool time32)",
          "",
          "[Removed Lines]",
          "3259: EXPORT_SYMBOL(lock_sock_fast);",
          "",
          "[Added Lines]",
          "3243: EXPORT_SYMBOL(__lock_sock_fast);",
          "",
          "---------------"
        ],
        "net/mptcp/protocol.c||net/mptcp/protocol.c": [
          "File: net/mptcp/protocol.c -> net/mptcp/protocol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2735:  inet_csk(sk)->icsk_mtup.probe_timestamp = tcp_jiffies32;",
          "2736:  mptcp_for_each_subflow(mptcp_sk(sk), subflow) {",
          "2737:   struct sock *ssk = mptcp_subflow_tcp_sock(subflow);",
          "2740:   sock_orphan(ssk);",
          "2741:   unlock_sock_fast(ssk, slow);",
          "",
          "[Removed Lines]",
          "2738:   bool slow = lock_sock_fast(ssk);",
          "",
          "[Added Lines]",
          "2738:   bool slow = lock_sock_fast_nested(ssk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f46993d83ff4abb310ef7b4beced56ba96f0d9d",
      "candidate_info": {
        "commit_hash": "2f46993d83ff4abb310ef7b4beced56ba96f0d9d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2f46993d83ff4abb310ef7b4beced56ba96f0d9d",
        "files": [
          "Documentation/admin-guide/hw-vuln/spectre.rst",
          "Documentation/admin-guide/kernel-parameters.txt",
          "arch/x86/kernel/cpu/bugs.c"
        ],
        "message": "x86: change default to spec_store_bypass_disable=prctl spectre_v2_user=prctl\n\nSwitch the kernel default of SSBD and STIBP to the ones with\nCONFIG_SECCOMP=n (i.e. spec_store_bypass_disable=prctl\nspectre_v2_user=prctl) even if CONFIG_SECCOMP=y.\n\nSeveral motivations listed below:\n\n- If SMT is enabled the seccomp jail can still attack the rest of the\n  system even with spectre_v2_user=seccomp by using MDS-HT (except on\n  XEON PHI where MDS can be tamed with SMT left enabled, but that's a\n  special case). Setting STIBP become a very expensive window dressing\n  after MDS-HT was discovered.\n\n- The seccomp jail cannot attack the kernel with spectre-v2-HT\n  regardless (even if STIBP is not set), but with MDS-HT the seccomp\n  jail can attack the kernel too.\n\n- With spec_store_bypass_disable=prctl the seccomp jail can attack the\n  other userland (guest or host mode) using spectre-v2-HT, but the\n  userland attack is already mitigated by both ASLR and pid namespaces\n  for host userland and through virt isolation with libkrun or\n  kata. (if something if somebody is worried about spectre-v2-HT it's\n  best to mount proc with hidepid=2,gid=proc on workstations where not\n  all apps may run under container runtimes, rather than slowing down\n  all seccomp jails, but the best is to add pid namespaces to the\n  seccomp jail). As opposed MDS-HT is not mitigated and the seccomp\n  jail can still attack all other host and guest userland if SMT is\n  enabled even with spec_store_bypass_disable=seccomp.\n\n- If full security is required then MDS-HT must also be mitigated with\n  nosmt and then spectre_v2_user=prctl and spectre_v2_user=seccomp\n  would become identical.\n\n- Setting spectre_v2_user=seccomp is overall lower priority than to\n  setting javascript.options.wasm false in about:config to protect\n  against remote wasm MDS-HT, instead of worrying about Spectre-v2-HT\n  and STIBP which again is already statistically well mitigated by\n  other means in userland and it's fully mitigated in kernel with\n  retpolines (unlike the wasm assist call with MDS-HT).\n\n- SSBD is needed to prevent reading the JIT memory and the primary\n  user being the OpenJDK. However the primary user of SSBD wouldn't be\n  covered by spec_store_bypass_disable=seccomp because it doesn't use\n  seccomp and the primary user also explicitly declined to set\n  PR_SET_SPECULATION_CTRL+PR_SPEC_STORE_BYPASS despite it easily\n  could. In fact it would need to set it only when the sandboxing\n  mechanism is enabled for javaws applets, but it still declined it by\n  declaring security within the same user address space as an\n  untenable objective for their JIT, even in the sandboxing case where\n  performance would be a lesser concern (for the record: I kind of\n  disagree in not setting PR_SPEC_STORE_BYPASS in the sandbox case and\n  I prefer to run javaws through a wrapper that sets\n  PR_SPEC_STORE_BYPASS if I need). In turn it can be inferred that\n  even if the primary user of SSBD would use seccomp, they would\n  invoke it with SECCOMP_FILTER_FLAG_SPEC_ALLOW by now.\n\n- runc/crun already set SECCOMP_FILTER_FLAG_SPEC_ALLOW by default, k8s\n  and podman have a default json seccomp allowlist that cannot be\n  slowed down, so for the #1 seccomp user this change is already a\n  noop.\n\n- systemd/sshd or other apps that use seccomp, if they really need\n  STIBP or SSBD, they need to explicitly set the\n  PR_SET_SPECULATION_CTRL by now. The stibp/ssbd seccomp blind\n  catch-all approach was done probably initially with a wishful\n  thinking objective to pretend to have a peace of mind that it could\n  magically fix it all. That was wishful thinking before MDS-HT was\n  discovered, but after MDS-HT has been discovered it become just\n  window dressing.\n\n- For qemu \"-sandbox\" seccomp jail it wouldn't make sense to set STIBP\n  or SSBD. SSBD doesn't help with KVM because there's no JIT (if it's\n  needed with TCG it should be an opt-in with\n  PR_SET_SPECULATION_CTRL+PR_SPEC_STORE_BYPASS and it shouldn't\n  slowdown KVM for nothing). For qemu+KVM STIBP would be even more\n  window dressing than it is for all other apps, because in the\n  qemu+KVM case there's not only the MDS attack to worry about with\n  SMT enabled. Even after disabling SMT, there's still a theoretical\n  spectre-v2 attack possible within the same thread context from guest\n  mode to host ring3 that the host kernel retpoline mitigation has no\n  theoretical chance to mitigate. On some kernels a\n  ibrs-always/ibrs-retpoline opt-in model is provided that will\n  enabled IBRS in the qemu host ring3 userland which fixes this\n  theoretical concern. Only after enabling IBRS in the host userland\n  it would then make sense to proceed and worry about STIBP and an\n  attack on the other host userland, but then again SMT would need to\n  be disabled for full security anyway, so that would render STIBP\n  again a noop.\n\n- last but not the least: the lack of \"spec_store_bypass_disable=prctl\n  spectre_v2_user=prctl\" means the moment a guest boots and\n  sshd/systemd runs, the guest kernel will write to SPEC_CTRL MSR\n  which will make the guest vmexit forever slower, forcing KVM to\n  issue a very slow rdmsr instruction at every vmexit. So the end\n  result is that SPEC_CTRL MSR is only available in GCE. Most other\n  public cloud providers don't expose SPEC_CTRL, which means that not\n  only STIBP/SSBD isn't available, but IBPB isn't available either\n  (which would cause no overhead to the guest or the hypervisor\n  because it's write only and requires no reading during vmexit). So\n  the current default already net loss in security (missing IBPB)\n  which means most public cloud providers cannot achieve a fully\n  secure guest with nosmt (and nosmt is enough to fully mitigate\n  MDS-HT). It also means GCE and is unfairly penalized in performance\n  because it provides the option to enable full security in the guest\n  as an opt-in (i.e. nosmt and IBPB). So this change will allow all\n  cloud providers to expose SPEC_CTRL without incurring into any\n  hypervisor slowdown and at the same time it will remove the unfair\n  penalization of GCE performance for doing the right thing and it'll\n  allow to get full security with nosmt with IBPB being available (and\n  STIBP becoming meaningless).\n\nExample to put things in prospective: the STIBP enabled in seccomp has\nnever been about protecting apps using seccomp like sshd from an\nattack from a malicious userland, but to the contrary it has always\nbeen about protecting the system from an attack from sshd, after a\nsuccessful remote network exploit against sshd. In fact initially it\nwasn't obvious STIBP would work both ways (STIBP was about preventing\nthe task that runs with STIBP to be attacked with spectre-v2-HT, but\naccidentally in the STIBP case it also prevents the attack in the\nother direction). In the hypothetical case that sshd has been remotely\nexploited the last concern should be STIBP being set, because it'll be\nstill possible to obtain info even from the kernel by using MDS if\nnosmt wasn't set (and if it was set, STIBP is a noop in the first\nplace). As opposed kernel cannot leak anything with spectre-v2 HT\nbecause of retpolines and the userland is mitigated by ASLR already\nand ideally PID namespaces too. If something it'd be worth checking if\nsshd run the seccomp thread under pid namespaces too if available in\nthe running kernel. SSBD also would be a noop for sshd, since sshd\nuses no JIT. If sshd prefers to keep doing the STIBP window dressing\nexercise, it still can even after this change of defaults by opting-in\nwith PR_SPEC_INDIRECT_BRANCH.\n\nUltimately setting SSBD and STIBP by default for all seccomp jails is\na bad sweet spot and bad default with more cons than pros that end up\nreducing security in the public cloud (by giving an huge incentive to\nnot expose SPEC_CTRL which would be needed to get full security with\nIBPB after setting nosmt in the guest) and by excessively hurting\nperformance to more secure apps using seccomp that end up having to\nopt out with SECCOMP_FILTER_FLAG_SPEC_ALLOW.\n\nThe following is the verified result of the new default with SMT\nenabled:\n\n(gdb) print spectre_v2_user_stibp\n$1 = SPECTRE_V2_USER_PRCTL\n(gdb) print spectre_v2_user_ibpb\n$2 = SPECTRE_V2_USER_PRCTL\n(gdb) print ssb_mode\n$3 = SPEC_STORE_BYPASS_PRCTL\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nLink: https://lore.kernel.org/r/20201104235054.5678-1-aarcange@redhat.com\nAcked-by: Josh Poimboeuf <jpoimboe@redhat.com>\nLink: https://lore.kernel.org/lkml/AAA2EF2C-293D-4D5B-BFA6-FF655105CD84@redhat.com\nAcked-by: Waiman Long <longman@redhat.com>\nLink: https://lore.kernel.org/lkml/c0722838-06f7-da6b-138f-e0f26362f16a@redhat.com",
        "before_after_code_files": [
          "arch/x86/kernel/cpu/bugs.c||arch/x86/kernel/cpu/bugs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/kernel/cpu/bugs.c||arch/x86/kernel/cpu/bugs.c": [
          "File: arch/x86/kernel/cpu/bugs.c -> arch/x86/kernel/cpu/bugs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "758:  case SPECTRE_V2_USER_CMD_FORCE:",
          "759:   mode = SPECTRE_V2_USER_STRICT;",
          "760:   break;",
          "761:  case SPECTRE_V2_USER_CMD_PRCTL:",
          "762:  case SPECTRE_V2_USER_CMD_PRCTL_IBPB:",
          "763:   mode = SPECTRE_V2_USER_PRCTL;",
          "764:   break;",
          "766:  case SPECTRE_V2_USER_CMD_SECCOMP:",
          "767:  case SPECTRE_V2_USER_CMD_SECCOMP_IBPB:",
          "768:   if (IS_ENABLED(CONFIG_SECCOMP))",
          "",
          "[Removed Lines]",
          "765:  case SPECTRE_V2_USER_CMD_AUTO:",
          "",
          "[Added Lines]",
          "761:  case SPECTRE_V2_USER_CMD_AUTO:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1169:   return mode;",
          "1171:  switch (cmd) {",
          "1173:  case SPEC_STORE_BYPASS_CMD_SECCOMP:",
          "",
          "[Removed Lines]",
          "1172:  case SPEC_STORE_BYPASS_CMD_AUTO:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1183:  case SPEC_STORE_BYPASS_CMD_ON:",
          "1184:   mode = SPEC_STORE_BYPASS_DISABLE;",
          "1185:   break;",
          "1186:  case SPEC_STORE_BYPASS_CMD_PRCTL:",
          "1187:   mode = SPEC_STORE_BYPASS_PRCTL;",
          "1188:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1185:  case SPEC_STORE_BYPASS_CMD_AUTO:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1da3b0141e74c18c2377d4c2655406a90a87742f",
      "candidate_info": {
        "commit_hash": "1da3b0141e74c18c2377d4c2655406a90a87742f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1da3b0141e74c18c2377d4c2655406a90a87742f",
        "files": [
          "drivers/scsi/ufs/ufshpb.c"
        ],
        "message": "scsi: ufs: core: Fix NULL pointer dereference\n\nCalling ufshcd_rpm_{get/put}_sync() prior to ufshcd_scsi_add_wlus() being\ncalled will trigger a NULL pointer dereference. This is because\nhba->sdev_ufs_device is initialized in ufshcd_scsi_add_wlus().\n\n    Unable to handle kernel NULL pointer dereference at virtual address\n    0000000000000348\n    Mem abort info:\n      ESR = 0x96000004\n      EC = 0x25: DABT (current EL), IL = 32 bits\n      SET = 0, FnV = 0\n      EA = 0, S1PTW = 0\n      FSC = 0x04: level 0 translation fault\n    Data abort info:\n      ISV = 0, ISS = 0x00000004\n      CM = 0, WnR = 0\n    [0000000000000348] user address but active_mm is swapper\n    Internal error: Oops: 96000004 [#1] PREEMPT SMP\n    Modules linked in:\n    CPU: 0 PID: 91 Comm: kworker/u16:1 Not tainted 5.15.0-rc1-beanhuo-linaro-1423\n    Hardware name: MicronRB (DT)\n    Workqueue: events_unbound async_run_entry_fn\n    pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n    pc : pm_runtime_drop_link+0x128/0x338\n    lr : ufshpb_get_dev_info+0x8c/0x148\n    sp : ffff800012573c10\n    x29: ffff800012573c10 x28: 0000000000000000 x27: 0000000000000003\n    x26: ffff000001d21298 x25: 000000005abcea60 x24: ffff800011d89000\n    x23: 0000000000000001 x22: ffff000001d21880 x21: ffff000001ec9300\n    x20: 0000000000000004 x19: 0000000000000198 x18: ffffffffffffffff\n    x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000041400\n    x14: 5eee00201100200a x13: 000000000000bb03 x12: 0000000000000000\n    x11: 0000000000000100 x10: 0200000000000000 x9 : bb0000021a162c01\n    x8 : 0302010021021003 x7 : 0000000000000000 x6 : ffff800012573af0\n    x5 : 0000000000000001 x4 : 0000000000000001 x3 : 0000000000000200\n    x2 : 0000000000000348 x1 : 0000000000000348 x0 : ffff80001095308c\n    Call trace:\n     pm_runtime_drop_link+0x128/0x338\n     ufshpb_get_dev_info+0x8c/0x148\n     ufshcd_probe_hba+0xda0/0x11b8\n     ufshcd_async_scan+0x34/0x330\n     async_run_entry_fn+0x38/0x180\n     process_one_work+0x1f4/0x498\n     worker_thread+0x48/0x480\n     kthread+0x140/0x158\n     ret_from_fork+0x10/0x20\n    Code: 88027c01 35ffffa2 17fff6c4 f9800051 (885f7c40)\n    ---[ end trace 2ba541335f595c95 ]\n\nufshpb_get_dev_info() is only called during asynchronous scanning and at\nthat time pm_runtime_get_sync() has been called:\n\n    ...\n    /* Hold auto suspend until async scan completes */\n    pm_runtime_get_sync(dev);\n    atomic_set(&hba->scsi_block_reqs_cnt, 0);\n    ...\n    ufshcd_async_scan()\n        ufshcd_probe_hba(hba, true);\n            ufshcd_device_params_init(hba);\n                ufshpb_get_dev_info();\n    ...\n        pm_runtime_put_sync(hba->dev);\n\nRemove ufshcd_rpm_{get/put}_sync() from ufshpb_get_dev_info() to fix this\nproblem.\n\nLink: https://lore.kernel.org/r/20210929200640.828611-2-huobean@gmail.com\nFixes: 351b3a849ac7 (\"scsi: ufs: ufshpb: Use proper power management API\")\nSigned-off-by: Bean Huo <beanhuo@micron.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/ufs/ufshpb.c||drivers/scsi/ufs/ufshpb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/ufs/ufshpb.c||drivers/scsi/ufs/ufshpb.c": [
          "File: drivers/scsi/ufs/ufshpb.c -> drivers/scsi/ufs/ufshpb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2877:  if (version == HPB_SUPPORT_LEGACY_VERSION)",
          "2878:   hpb_dev_info->is_legacy = true;",
          "2881:  ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR,",
          "2882:   QUERY_ATTR_IDN_MAX_HPB_SINGLE_CMD, 0, 0, &max_hpb_single_cmd);",
          "2885:  if (ret)",
          "2886:   dev_err(hba->dev, \"%s: idn: read max size of single hpb cmd query request failed\",",
          "2887:    __func__);",
          "",
          "[Removed Lines]",
          "2880:  ufshcd_rpm_get_sync(hba);",
          "2883:  ufshcd_rpm_put_sync(hba);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5b09e88e1bf7fe86540fab4b5f3eece8abead39e",
      "candidate_info": {
        "commit_hash": "5b09e88e1bf7fe86540fab4b5f3eece8abead39e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5b09e88e1bf7fe86540fab4b5f3eece8abead39e",
        "files": [
          "drivers/net/ethernet/hisilicon/hns3/hns3_enet.c"
        ],
        "message": "net: hns3: do not allow call hns3_nic_net_open repeatedly\n\nhns3_nic_net_open() is not allowed to called repeatly, but there\nis no checking for this. When doing device reset and setup tc\nconcurrently, there is a small oppotunity to call hns3_nic_net_open\nrepeatedly, and cause kernel bug by calling napi_enable twice.\n\nThe calltrace information is like below:\n[ 3078.222780] ------------[ cut here ]------------\n[ 3078.230255] kernel BUG at net/core/dev.c:6991!\n[ 3078.236224] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n[ 3078.243431] Modules linked in: hns3 hclgevf hclge hnae3 vfio_iommu_type1 vfio_pci vfio_virqfd vfio pv680_mii(O)\n[ 3078.258880] CPU: 0 PID: 295 Comm: kworker/u8:5 Tainted: G           O      5.14.0-rc4+ #1\n[ 3078.269102] Hardware name:  , BIOS KpxxxFPGA 1P B600 V181 08/12/2021\n[ 3078.276801] Workqueue: hclge hclge_service_task [hclge]\n[ 3078.288774] pstate: 60400009 (nZCv daif +PAN -UAO -TCO BTYPE=--)\n[ 3078.296168] pc : napi_enable+0x80/0x84\ntc qdisc sho[w  3d0e7v8 .e3t0h218 79] lr : hns3_nic_net_open+0x138/0x510 [hns3]\n\n[ 3078.314771] sp : ffff8000108abb20\n[ 3078.319099] x29: ffff8000108abb20 x28: 0000000000000000 x27: ffff0820a8490300\n[ 3078.329121] x26: 0000000000000001 x25: ffff08209cfc6200 x24: 0000000000000000\n[ 3078.339044] x23: ffff0820a8490300 x22: ffff08209cd76000 x21: ffff0820abfe3880\n[ 3078.349018] x20: 0000000000000000 x19: ffff08209cd76900 x18: 0000000000000000\n[ 3078.358620] x17: 0000000000000000 x16: ffffc816e1727a50 x15: 0000ffff8f4ff930\n[ 3078.368895] x14: 0000000000000000 x13: 0000000000000000 x12: 0000259e9dbeb6b4\n[ 3078.377987] x11: 0096a8f7e764eb40 x10: 634615ad28d3eab5 x9 : ffffc816ad8885b8\n[ 3078.387091] x8 : ffff08209cfc6fb8 x7 : ffff0820ac0da058 x6 : ffff0820a8490344\n[ 3078.396356] x5 : 0000000000000140 x4 : 0000000000000003 x3 : ffff08209cd76938\n[ 3078.405365] x2 : 0000000000000000 x1 : 0000000000000010 x0 : ffff0820abfe38a0\n[ 3078.414657] Call trace:\n[ 3078.418517]  napi_enable+0x80/0x84\n[ 3078.424626]  hns3_reset_notify_up_enet+0x78/0xd0 [hns3]\n[ 3078.433469]  hns3_reset_notify+0x64/0x80 [hns3]\n[ 3078.441430]  hclge_notify_client+0x68/0xb0 [hclge]\n[ 3078.450511]  hclge_reset_rebuild+0x524/0x884 [hclge]\n[ 3078.458879]  hclge_reset_service_task+0x3c4/0x680 [hclge]\n[ 3078.467470]  hclge_service_task+0xb0/0xb54 [hclge]\n[ 3078.475675]  process_one_work+0x1dc/0x48c\n[ 3078.481888]  worker_thread+0x15c/0x464\n[ 3078.487104]  kthread+0x160/0x170\n[ 3078.492479]  ret_from_fork+0x10/0x18\n[ 3078.498785] Code: c8027c81 35ffffa2 d50323bf d65f03c0 (d4210000)\n[ 3078.506889] ---[ end trace 8ebe0340a1b0fb44 ]---\n\nOnce hns3_nic_net_open() is excute success, the flag\nHNS3_NIC_STATE_DOWN will be cleared. So add checking for this\nflag, directly return when HNS3_NIC_STATE_DOWN is no set.\n\nFixes: e888402789b9 (\"net: hns3: call hns3_nic_net_open() while doing HNAE3_UP_CLIENT\")\nSigned-off-by: Jian Shen <shenjian15@huawei.com>\nSigned-off-by: Guangbin Huang <huangguangbin2@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/hisilicon/hns3/hns3_enet.c||drivers/net/ethernet/hisilicon/hns3/hns3_enet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/hisilicon/hns3/hns3_enet.c||drivers/net/ethernet/hisilicon/hns3/hns3_enet.c": [
          "File: drivers/net/ethernet/hisilicon/hns3/hns3_enet.c -> drivers/net/ethernet/hisilicon/hns3/hns3_enet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "779:  if (hns3_nic_resetting(netdev))",
          "780:   return -EBUSY;",
          "782:  netif_carrier_off(netdev);",
          "784:  ret = hns3_nic_set_real_num_queue(netdev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "782:  if (!test_bit(HNS3_NIC_STATE_DOWN, &priv->state)) {",
          "783:   netdev_warn(netdev, \"net open repeatedly!\\n\");",
          "784:   return 0;",
          "785:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bb8958d5dc79acbd071397abb57b8756375fe1ce",
      "candidate_info": {
        "commit_hash": "bb8958d5dc79acbd071397abb57b8756375fe1ce",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bb8958d5dc79acbd071397abb57b8756375fe1ce",
        "files": [
          "arch/riscv/mm/cacheflush.c"
        ],
        "message": "riscv: Flush current cpu icache before other cpus\n\nOn SiFive Unmatched, I recently fell onto the following BUG when booting:\n\n[    0.000000] ftrace: allocating 36610 entries in 144 pages\n[    0.000000] Oops - illegal instruction [#1]\n[    0.000000] Modules linked in:\n[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.13.1+ #5\n[    0.000000] Hardware name: SiFive HiFive Unmatched A00 (DT)\n[    0.000000] epc : riscv_cpuid_to_hartid_mask+0x6/0xae\n[    0.000000]  ra : __sbi_rfence_v02+0xc8/0x10a\n[    0.000000] epc : ffffffff80007240 ra : ffffffff80009964 sp : ffffffff81803e10\n[    0.000000]  gp : ffffffff81a1ea70 tp : ffffffff8180f500 t0 : ffffffe07fe30000\n[    0.000000]  t1 : 0000000000000004 t2 : 0000000000000000 s0 : ffffffff81803e60\n[    0.000000]  s1 : 0000000000000000 a0 : ffffffff81a22238 a1 : ffffffff81803e10\n[    0.000000]  a2 : 0000000000000000 a3 : 0000000000000000 a4 : 0000000000000000\n[    0.000000]  a5 : 0000000000000000 a6 : ffffffff8000989c a7 : 0000000052464e43\n[    0.000000]  s2 : ffffffff81a220c8 s3 : 0000000000000000 s4 : 0000000000000000\n[    0.000000]  s5 : 0000000000000000 s6 : 0000000200000100 s7 : 0000000000000001\n[    0.000000]  s8 : ffffffe07fe04040 s9 : ffffffff81a22c80 s10: 0000000000001000\n[    0.000000]  s11: 0000000000000004 t3 : 0000000000000001 t4 : 0000000000000008\n[    0.000000]  t5 : ffffffcf04000808 t6 : ffffffe3ffddf188\n[    0.000000] status: 0000000200000100 badaddr: 0000000000000000 cause: 0000000000000002\n[    0.000000] [<ffffffff80007240>] riscv_cpuid_to_hartid_mask+0x6/0xae\n[    0.000000] [<ffffffff80009474>] sbi_remote_fence_i+0x1e/0x26\n[    0.000000] [<ffffffff8000b8f4>] flush_icache_all+0x12/0x1a\n[    0.000000] [<ffffffff8000666c>] patch_text_nosync+0x26/0x32\n[    0.000000] [<ffffffff8000884e>] ftrace_init_nop+0x52/0x8c\n[    0.000000] [<ffffffff800f051e>] ftrace_process_locs.isra.0+0x29c/0x360\n[    0.000000] [<ffffffff80a0e3c6>] ftrace_init+0x80/0x130\n[    0.000000] [<ffffffff80a00f8c>] start_kernel+0x5c4/0x8f6\n[    0.000000] ---[ end trace f67eb9af4d8d492b ]---\n[    0.000000] Kernel panic - not syncing: Attempted to kill the idle task!\n[    0.000000] ---[ end Kernel panic - not syncing: Attempted to kill the idle task! ]---\n\nWhile ftrace is looping over a list of addresses to patch, it always failed\nwhen patching the same function: riscv_cpuid_to_hartid_mask. Looking at the\nbacktrace, the illegal instruction is encountered in this same function.\nHowever, patch_text_nosync, after patching the instructions, calls\nflush_icache_range. But looking at what happens in this function:\n\nflush_icache_range -> flush_icache_all\n                   -> sbi_remote_fence_i\n                   -> __sbi_rfence_v02\n                   -> riscv_cpuid_to_hartid_mask\n\nThe icache and dcache of the current cpu are never synchronized between the\npatching of riscv_cpuid_to_hartid_mask and calling this same function.\n\nSo fix this by flushing the current cpu's icache before asking for the other\ncpus to do the same.\n\nSigned-off-by: Alexandre Ghiti <alex@ghiti.fr>\nFixes: fab957c11efe (\"RISC-V: Atomic and Locking Code\")\nCc: stable@vger.kernel.org\nSigned-off-by: Palmer Dabbelt <palmerdabbelt@google.com>",
        "before_after_code_files": [
          "arch/riscv/mm/cacheflush.c||arch/riscv/mm/cacheflush.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/riscv/mm/cacheflush.c||arch/riscv/mm/cacheflush.c": [
          "File: arch/riscv/mm/cacheflush.c -> arch/riscv/mm/cacheflush.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: void flush_icache_all(void)",
          "18: {",
          "19:  if (IS_ENABLED(CONFIG_RISCV_SBI))",
          "20:   sbi_remote_fence_i(NULL);",
          "21:  else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19:  local_flush_icache_all();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-2889",
  "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0225.",
  "repo": "vim/vim",
  "patch_hash": "91c7cbfe31bbef57d5fcf7d76989fc159f73ef15",
  "patch_info": {
    "commit_hash": "91c7cbfe31bbef57d5fcf7d76989fc159f73ef15",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15",
    "files": [
      "src/eval.c",
      "src/proto/eval.pro",
      "src/testdir/test_vim9_script.vim",
      "src/userfunc.c",
      "src/version.c"
    ],
    "message": "patch 9.0.0225: using freed memory with multiple line breaks in expression\n\nProblem:    Using freed memory with multiple line breaks in expression.\nSolution:   Free eval_tofree later.",
    "before_after_code_files": [
      "src/eval.c||src/eval.c",
      "src/proto/eval.pro||src/proto/eval.pro",
      "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
      "src/userfunc.c||src/userfunc.c",
      "src/version.c||src/version.c"
    ]
  },
  "patch_diff": {
    "src/eval.c||src/eval.c": [
      "File: src/eval.c -> src/eval.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "353:     return retval;",
      "354: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "359:     void",
      "360: init_evalarg(evalarg_T *evalarg)",
      "361: {",
      "362:     CLEAR_POINTER(evalarg);",
      "363:     ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);",
      "364: }",
      "370:     static void",
      "371: free_eval_tofree_later(evalarg_T *evalarg)",
      "372: {",
      "373:     if (evalarg->eval_tofree != NULL)",
      "374:     {",
      "375:  if (ga_grow(&evalarg->eval_tofree_ga, 1) == OK)",
      "376:      ((char_u **)evalarg->eval_tofree_ga.ga_data)",
      "377:   [evalarg->eval_tofree_ga.ga_len++]",
      "378:   = evalarg->eval_tofree;",
      "379:  else",
      "380:      vim_free(evalarg->eval_tofree);",
      "381:     }",
      "382: }",
      "387:     void",
      "388: clear_evalarg(evalarg_T *evalarg, exarg_T *eap)",
      "389: {",
      "390:     if (evalarg != NULL)",
      "391:     {",
      "392:  if (evalarg->eval_tofree != NULL)",
      "393:  {",
      "394:      if (eap != NULL)",
      "395:      {",
      "399:   vim_free(eap->cmdline_tofree);",
      "400:   eap->cmdline_tofree = *eap->cmdlinep;",
      "402:      }",
      "403:      else",
      "404:   vim_free(evalarg->eval_tofree);",
      "405:      evalarg->eval_tofree = NULL;",
      "406:  }",
      "408:  ga_clear_strings(&evalarg->eval_tofree_ga);",
      "409:  VIM_CLEAR(evalarg->eval_tofree_lambda);",
      "410:     }",
      "411: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "440:   evalarg->eval_tofree =",
      "441:         ((char_u **)gap->ga_data)[gap->ga_len - 1];",
      "442:   ((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;",
      "",
      "[Removed Lines]",
      "439:   vim_free(evalarg->eval_tofree);",
      "",
      "[Added Lines]",
      "496:   free_eval_tofree_later(evalarg);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2274:     }",
      "2275:     else if (evalarg->eval_cookie != NULL)",
      "2276:     {",
      "2278:  evalarg->eval_tofree = line;",
      "2279:     }",
      "",
      "[Removed Lines]",
      "2277:  vim_free(evalarg->eval_tofree);",
      "",
      "[Added Lines]",
      "2334:  free_eval_tofree_later(evalarg);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2301:     return p;",
      "2302: }",
      "",
      "[Removed Lines]",
      "2307:     void",
      "2308: init_evalarg(evalarg_T *evalarg)",
      "2309: {",
      "2310:     CLEAR_POINTER(evalarg);",
      "2311:     ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);",
      "2312: }",
      "2317:     void",
      "2318: clear_evalarg(evalarg_T *evalarg, exarg_T *eap)",
      "2319: {",
      "2320:     if (evalarg != NULL)",
      "2321:     {",
      "2322:  if (evalarg->eval_tofree != NULL)",
      "2323:  {",
      "2324:      if (eap != NULL)",
      "2325:      {",
      "2329:   vim_free(eap->cmdline_tofree);",
      "2330:   eap->cmdline_tofree = *eap->cmdlinep;",
      "2332:      }",
      "2333:      else",
      "2334:   vim_free(evalarg->eval_tofree);",
      "2335:      evalarg->eval_tofree = NULL;",
      "2336:  }",
      "2338:  ga_clear_strings(&evalarg->eval_tofree_ga);",
      "2339:  VIM_CLEAR(evalarg->eval_tofree_lambda);",
      "2340:     }",
      "2341: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/proto/eval.pro||src/proto/eval.pro": [
      "File: src/proto/eval.pro -> src/proto/eval.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "9: int eval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv);",
      "10: int eval_expr_to_bool(typval_T *expr, int *error);",
      "11: char_u *eval_to_string_skip(char_u *arg, exarg_T *eap, int skip);",
      "12: int skip_expr(char_u **pp, evalarg_T *evalarg);",
      "13: int skip_expr_concatenate(char_u **arg, char_u **start, char_u **end, evalarg_T *evalarg);",
      "14: char_u *typval2string(typval_T *tv, int convert);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: void init_evalarg(evalarg_T *evalarg);",
      "13: void clear_evalarg(evalarg_T *evalarg, exarg_T *eap);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "34: char_u *eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext);",
      "35: char_u *eval_next_line(char_u *arg, evalarg_T *evalarg);",
      "36: char_u *skipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg);",
      "39: int eval0(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg);",
      "40: int eval0_retarg(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg, char_u **retarg);",
      "41: int eval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg);",
      "",
      "[Removed Lines]",
      "37: void init_evalarg(evalarg_T *evalarg);",
      "38: void clear_evalarg(evalarg_T *evalarg, exarg_T *eap);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim": [
      "File: src/testdir/test_vim9_script.vim -> src/testdir/test_vim9_script.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "1560:   v9.CheckScriptFailure(lines, 'E1073:')",
      "1561: enddef",
      "1563: def Test_fixed_size_list()",
      "1564:   # will be allocated as one piece of memory, check that changes work",
      "1565:   var l = [1, 2, 3, 4]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1563: def Test_lambda_split()",
      "1564:   # this was using freed memory, because of the split expression",
      "1565:   var lines =<< trim END",
      "1566:       vim9script",
      "1567:       try",
      "1568:       0",
      "1569:       0->(0",
      "1570:         ->a.0(",
      "1571:         ->u",
      "1572:   END",
      "1573:   v9.CheckScriptFailure(lines, 'E1050:')",
      "1574: enddef",
      "",
      "---------------"
    ],
    "src/userfunc.c||src/userfunc.c": [
      "File: src/userfunc.c -> src/userfunc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1372:     char_u *start, *end;",
      "1373:     int  *old_eval_lavars = eval_lavars_used;",
      "1374:     int  eval_lavars = FALSE;",
      "1376:     char_u *tofree2 = NULL;",
      "1377:     int  equal_arrow = **arg == '(';",
      "1378:     int  white_error = FALSE;",
      "",
      "[Removed Lines]",
      "1375:     char_u *tofree1 = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1457:     ret = skip_expr_concatenate(arg, &start, &end, evalarg);",
      "1458:     if (ret == FAIL)",
      "1459:  goto errret;",
      "1467:     if (!equal_arrow)",
      "1468:     {",
      "",
      "[Removed Lines]",
      "1460:     if (evalarg != NULL)",
      "1461:     {",
      "1463:  tofree1 = evalarg->eval_tofree;",
      "1464:  evalarg->eval_tofree = NULL;",
      "1465:     }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1586: theend:",
      "1587:     eval_lavars_used = old_eval_lavars;",
      "1592:     vim_free(tofree2);",
      "1593:     if (types_optional)",
      "1594:  ga_clear_strings(&argtypes);",
      "",
      "[Removed Lines]",
      "1588:     if (evalarg != NULL && evalarg->eval_tofree == NULL)",
      "1589:  evalarg->eval_tofree = tofree1;",
      "1590:     else",
      "1591:  vim_free(tofree1);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1607:     }",
      "1608:     vim_free(fp);",
      "1609:     vim_free(pt);",
      "1614:     vim_free(tofree2);",
      "1615:     eval_lavars_used = old_eval_lavars;",
      "1616:     return FAIL;",
      "",
      "[Removed Lines]",
      "1610:     if (evalarg != NULL && evalarg->eval_tofree == NULL)",
      "1611:  evalarg->eval_tofree = tofree1;",
      "1612:     else",
      "1613:  vim_free(tofree1);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "732: static int included_patches[] =",
      "735:     224,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "735:     225,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d5f400c607182db6d4fbe2964471d796277f67e8",
      "candidate_info": {
        "commit_hash": "d5f400c607182db6d4fbe2964471d796277f67e8",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/d5f400c607182db6d4fbe2964471d796277f67e8",
        "files": [
          "runtime/doc/vim9.txt",
          "src/errors.h",
          "src/eval.c",
          "src/evalvars.c",
          "src/proto/eval.pro",
          "src/proto/evalvars.pro",
          "src/proto/vim9script.pro",
          "src/structs.h",
          "src/testdir/test_vim9_assign.vim",
          "src/testdir/test_vim9_script.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c",
          "src/vim9execute.c",
          "src/vim9expr.c",
          "src/vim9script.c"
        ],
        "message": "patch 8.2.4019: Vim9: import mechanism is too complicated\n\nProblem:    Vim9: import mechanism is too complicated.\nSolution:   Do not use the Javascript mechanism but a much simpler one.",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/eval.c||src/eval.c",
          "src/evalvars.c||src/evalvars.c",
          "src/proto/eval.pro||src/proto/eval.pro",
          "src/proto/evalvars.pro||src/proto/evalvars.pro",
          "src/proto/vim9script.pro||src/proto/vim9script.pro",
          "src/structs.h||src/structs.h",
          "src/testdir/test_vim9_assign.vim||src/testdir/test_vim9_assign.vim",
          "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9execute.c||src/vim9execute.c",
          "src/vim9expr.c||src/vim9expr.c",
          "src/vim9script.c||src/vim9script.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/eval.c||src/eval.c",
            "src/proto/eval.pro||src/proto/eval.pro",
            "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/eval.c||src/eval.c",
            "src/proto/eval.pro||src/proto/eval.pro",
            "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2500:  INIT(= N_(\"E1069: White space required after '%s': %s\"));",
          "2501: EXTERN char e_missing_from[]",
          "2502:  INIT(= N_(\"E1070: Missing \\\"from\\\"\"));",
          "2505: EXTERN char e_cannot_compare_str_with_str[]",
          "2506:  INIT(= N_(\"E1072: Cannot compare %s with %s\"));",
          "2507: EXTERN char e_name_already_defined_str[]",
          "",
          "[Removed Lines]",
          "2503: EXTERN char e_invalid_string_after_from[]",
          "2504:  INIT(= N_(\"E1071: Invalid string after \\\"from\\\"\"));",
          "",
          "[Added Lines]",
          "2503: EXTERN char e_invalid_string_for_import_str[]",
          "2504:  INIT(= N_(\"E1071: Invalid string for :import: %s\"));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2839:  INIT(= N_(\"E1234: legacy must be followed by a command\"));",
          "2840: EXTERN char e_function_reference_is_not_set[]",
          "2841:  INIT(= N_(\"E1235: Function reference is not set\"));",
          "2844: EXTERN char e_no_such_user_defined_command_in_current_buffer_str[]",
          "2845:  INIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));",
          "2846: EXTERN char e_blob_required_for_argument_nr[]",
          "",
          "[Removed Lines]",
          "2842: EXTERN char e_cannot_use_str_itself_it_is_imported_with_star[]",
          "2843:  INIT(= N_(\"E1236: Cannot use %s itself, it is imported with '*'\"));",
          "",
          "[Added Lines]",
          "2842: EXTERN char e_cannot_use_str_itself_it_is_imported[]",
          "2843:  INIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2881:  INIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));",
          "2882: EXTERN char e_string_or_function_required_for_argument_nr[]",
          "2883:  INIT(= N_(\"E1256: String or function required for argument %d\"));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2884: EXTERN char e_imported_script_must_end_in_dot_vim_str[]",
          "2885:  INIT(= N_(\"E1257: Imported script must end in .vim: %s\"));",
          "2886: EXTERN char e_no_dot_after_imported_name_str[]",
          "2887:  INIT(= N_(\"E1258: No '.' after imported name: %s\"));",
          "2888: EXTERN char e_missing_name_after_imported_name_str[]",
          "2889:  INIT(= N_(\"E1259: Missing name after imported name: %s\"));",
          "2890: EXTERN char e_cannot_unlet_imported_item_str[]",
          "2891:  INIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));",
          "",
          "---------------"
        ],
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: static int free_unref_items(int copyID);",
          "58: static char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);",
          "",
          "[Removed Lines]",
          "59: static char_u *eval_next_line(evalarg_T *evalarg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "922:      }",
          "923:  }",
          "924:     }",
          "928:  return p;",
          "930:     if (in_vim9script() && lval_root != NULL)",
          "",
          "[Removed Lines]",
          "927:     if ((*p != '[' && *p != '.') || lp->ll_name == NULL)",
          "",
          "[Added Lines]",
          "924:     if (lp->ll_name == NULL)",
          "925:  return p;",
          "927:     if (*p == '.' && in_vim9script())",
          "928:     {",
          "929:  imported_T *import = find_imported(lp->ll_name, p - lp->ll_name, NULL);",
          "930:  if (import != NULL)",
          "931:  {",
          "932:      ufunc_T *ufunc;",
          "933:      type_T *type;",
          "935:      lp->ll_sid = import->imp_sid;",
          "936:      lp->ll_name = skipwhite(p + 1);",
          "937:      p = find_name_end(lp->ll_name, NULL, NULL, fne_flags);",
          "938:      lp->ll_name_end = p;",
          "941:      cc = *p;",
          "943:      if (find_exported(import->imp_sid, lp->ll_name, &ufunc, &type,",
          "944:             NULL, TRUE) == -1)",
          "945:      {",
          "947:   return FAIL;",
          "948:      }",
          "950:  }",
          "951:     }",
          "954:     if ((*p != '[' && *p != '.'))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "997:   && lp->ll_tv == &v->di_tv",
          "998:   && ht != NULL && ht == get_script_local_ht())",
          "999:  {",
          "1003:      if (sv != NULL)",
          "",
          "[Removed Lines]",
          "1000:      svar_T  *sv = find_typval_in_script(lp->ll_tv);",
          "",
          "[Added Lines]",
          "1027:      svar_T  *sv = find_typval_in_script(lp->ll_tv, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1360:      di = NULL;",
          "1361:      if (eval_variable(lp->ll_name, (int)STRLEN(lp->ll_name),",
          "1363:      {",
          "1364:   if ((di == NULL",
          "1365:     || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)",
          "1366:       && !tv_check_lock(&di->di_tv, lp->ll_name, FALSE)))",
          "1367:    && tv_op(&tv, rettv, op) == OK)",
          "1369:            ASSIGN_NO_DECL, 0);",
          "1370:   clear_tv(&tv);",
          "1371:      }",
          "",
          "[Removed Lines]",
          "1362:           &tv, &di, EVAL_VAR_VERBOSE) == OK)",
          "1368:       set_var_const(lp->ll_name, NULL, &tv, FALSE,",
          "",
          "[Added Lines]",
          "1389:      lp->ll_sid, &tv, &di, EVAL_VAR_VERBOSE) == OK)",
          "1395:       set_var_const(lp->ll_name, lp->ll_sid, NULL, &tv, FALSE,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1375:      if (lp->ll_type != NULL && check_typval_arg_type(lp->ll_type, rettv,",
          "1376:              NULL, 0) == FAIL)",
          "1377:   return;",
          "1379:               flags, var_idx);",
          "1380:  }",
          "",
          "[Removed Lines]",
          "1378:      set_var_const(lp->ll_name, lp->ll_type, rettv, copy,",
          "",
          "[Added Lines]",
          "1405:      set_var_const(lp->ll_name, lp->ll_sid, lp->ll_type, rettv, copy,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1389:  if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))",
          "1390:           && (flags & ASSIGN_FOR_LOOP) == 0)",
          "1391:  {",
          "1393:      return;",
          "1394:  }",
          "",
          "[Removed Lines]",
          "1392:      emsg(_(\"E996: Cannot lock a range\"));",
          "",
          "[Added Lines]",
          "1419:      emsg(_(e_cannot_lock_range));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1404:  if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))",
          "1405:           && (flags & ASSIGN_FOR_LOOP) == 0)",
          "1406:  {",
          "1408:      return;",
          "1409:  }",
          "",
          "[Removed Lines]",
          "1407:      emsg(_(\"E996: Cannot lock a list or dict\"));",
          "",
          "[Added Lines]",
          "1434:      emsg(_(e_cannot_lock_list_or_dict));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2093: eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)",
          "2094: {",
          "2095:     char_u *p = skipwhite(arg);",
          "",
          "[Removed Lines]",
          "2092:     static char_u *",
          "",
          "[Added Lines]",
          "2119:     char_u *",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2124: eval_next_line(evalarg_T *evalarg)",
          "2125: {",
          "2126:     garray_T *gap = &evalarg->eval_ga;",
          "",
          "[Removed Lines]",
          "2123:     static char_u *",
          "",
          "[Added Lines]",
          "2150:     char_u *",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2235:     typval_T *rettv,",
          "2236:     exarg_T *eap,",
          "2237:     evalarg_T *evalarg)",
          "2238: {",
          "2239:     int  ret;",
          "2240:     char_u *p;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2265: {",
          "2266:     return eval0_retarg(arg, rettv, eap, evalarg, NULL);",
          "2267: }",
          "2273:     int",
          "2274: eval0_retarg(",
          "2275:     char_u *arg,",
          "2276:     typval_T *rettv,",
          "2277:     exarg_T *eap,",
          "2278:     evalarg_T *evalarg,",
          "2279:     char_u **retarg)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2242:     int  did_emsg_before = did_emsg;",
          "2243:     int  called_emsg_before = called_emsg;",
          "2244:     int  flags = evalarg == NULL ? 0 : evalarg->eval_flags;",
          "2246:     int  end_error = FALSE;",
          "2248:     p = skipwhite(arg);",
          "",
          "[Removed Lines]",
          "2245:     int  check_for_end = TRUE;",
          "",
          "[Added Lines]",
          "2287:     int  check_for_end = retarg == NULL;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2257:  while (*p == '#')",
          "2258:  {",
          "2259:      char_u *nl = vim_strchr(p, NL);",
          "",
          "[Removed Lines]",
          "2256:     if (in_vim9script() && p > expr_end)",
          "",
          "[Added Lines]",
          "2298:     if (in_vim9script() && p > expr_end && retarg == NULL)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2298:  return FAIL;",
          "2299:     }",
          "2302:  set_nextcmd(eap, p);",
          "2304:     return ret;",
          "",
          "[Removed Lines]",
          "2301:     if (check_for_end && eap != NULL)",
          "",
          "[Added Lines]",
          "2343:     if (retarg != NULL)",
          "2345:     else if (check_for_end && eap != NULL)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3669:       ret = OK;",
          "3670:   }",
          "3671:   else",
          "3673:         EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);",
          "3674:      }",
          "3675:      else",
          "",
          "[Removed Lines]",
          "3672:       ret = eval_variable(s, len, rettv, NULL,",
          "",
          "[Added Lines]",
          "3716:       ret = eval_variable(s, len, 0, rettv, NULL,",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5934:   rettv->v_type = VAR_FUNC;",
          "5935:   rettv->vval.v_string = vim_strsave(ufunc->uf_name);",
          "5936:      }",
          "5937:  }",
          "5939:  if ((**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5981:      continue;",
          "",
          "---------------"
        ],
        "src/evalvars.c||src/evalvars.c": [
          "File: src/evalvars.c -> src/evalvars.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1232:   arg = skipwhite(arg);",
          "1233:   if (tofree != NULL)",
          "1234:       name = tofree;",
          "1236:            EVAL_VAR_VERBOSE) == FAIL)",
          "1237:       error = TRUE;",
          "1238:   else",
          "",
          "[Removed Lines]",
          "1235:   if (eval_variable(name, len, &tv, NULL,",
          "",
          "[Added Lines]",
          "1235:   if (eval_variable(name, len, 0, &tv, NULL,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2645: eval_variable(",
          "2646:     char_u *name,",
          "2647:     int  len,  // length of \"name\"",
          "2648:     typval_T *rettv,  // NULL when only checking existence",
          "2649:     dictitem_T **dip,  // non-NULL when typval's dict item is needed",
          "2650:     int  flags)  // EVAL_VAR_ flags",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2648:     scid_T sid,  // script ID for imported item or zero",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2679:     if (tv == NULL && (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0))",
          "2680:     {",
          "2682:  char_u     *p = STRNCMP(name, \"s:\", 2) == 0 ? name + 2 : name;",
          "2688:  {",
          "2690:      {",
          "2693:   {",
          "2696:   }",
          "2701:   {",
          "2702:       if (flags & EVAL_VAR_VERBOSE)",
          "2703:    emsg(_(e_import_as_name_not_supported_here));",
          "2704:       ret = FAIL;",
          "2705:   }",
          "2715:      }",
          "2716:      else",
          "2717:      {",
          "2723:      }",
          "2724:  }",
          "2725:  else if (in_vim9script() && (flags & EVAL_VAR_NO_FUNC) == 0)",
          "",
          "[Removed Lines]",
          "2681:  imported_T  *import;",
          "2684:  import = find_imported(p, 0, NULL);",
          "2687:  if (import != NULL)",
          "2689:      if (import->imp_funcname != NULL)",
          "2691:   found = TRUE;",
          "2692:   if (rettv != NULL)",
          "2694:       rettv->v_type = VAR_FUNC;",
          "2695:       rettv->vval.v_string = vim_strsave(import->imp_funcname);",
          "2697:      }",
          "2698:      else if (import->imp_flags & IMP_FLAGS_STAR)",
          "2699:      {",
          "2700:   if ((flags & EVAL_VAR_IMPORT) == 0)",
          "2706:   else",
          "2707:   {",
          "2708:       if (rettv != NULL)",
          "2709:       {",
          "2710:    rettv->v_type = VAR_ANY;",
          "2711:    rettv->vval.v_number = import->imp_sid;",
          "2712:       }",
          "2713:       found = TRUE;",
          "2714:   }",
          "2718:   scriptitem_T    *si = SCRIPT_ITEM(import->imp_sid);",
          "2719:   svar_T  *sv = ((svar_T *)si->sn_var_vals.ga_data)",
          "2720:           + import->imp_var_vals_idx;",
          "2721:   tv = sv->sv_tv;",
          "2722:   type = sv->sv_type;",
          "",
          "[Added Lines]",
          "2682:  imported_T  *import = NULL;",
          "2685:  if (sid == 0)",
          "2686:      import = find_imported(p, 0, NULL);",
          "2689:  if (import != NULL || sid != 0)",
          "2691:      if ((flags & EVAL_VAR_IMPORT) == 0)",
          "2693:   if (sid != 0 && SCRIPT_ID_VALID(sid))",
          "2695:       ht = &SCRIPT_VARS(sid);",
          "2696:       if (ht != NULL)",
          "2697:       {",
          "2698:    dictitem_T *v = find_var_in_ht(ht, 0, name,",
          "2699:         flags & EVAL_VAR_NOAUTOLOAD);",
          "2701:    if (v != NULL)",
          "2702:    {",
          "2703:        tv = &v->di_tv;",
          "2704:        if (dip != NULL)",
          "2706:    }",
          "2707:    else",
          "2708:        ht = NULL;",
          "2709:       }",
          "2711:   else",
          "2720:   if (rettv != NULL)",
          "2721:   {",
          "2722:       rettv->v_type = VAR_ANY;",
          "2723:       rettv->vval.v_number = sid != 0 ? sid : import->imp_sid;",
          "2724:   }",
          "2725:   found = TRUE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2760:      if (ht != NULL && ht == get_script_local_ht()",
          "2761:       && tv != &SCRIPT_SV(current_sctx.sc_sid)->sv_var.di_tv)",
          "2762:      {",
          "2765:   if (sv != NULL)",
          "2766:       type = sv->sv_type;",
          "",
          "[Removed Lines]",
          "2763:   svar_T *sv = find_typval_in_script(tv);",
          "",
          "[Added Lines]",
          "2766:   svar_T *sv = find_typval_in_script(tv, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3278:     typval_T *tv,",
          "3279:     int  copy)     // make copy of value in \"tv\"",
          "3280: {",
          "3282: }",
          "3289:     void",
          "3290: set_var_const(",
          "3291:     char_u *name,",
          "3292:     type_T *type_arg,",
          "3293:     typval_T *tv_arg,",
          "3294:     int  copy,     // make copy of value in \"tv\"",
          "",
          "[Removed Lines]",
          "3281:     set_var_const(name, NULL, tv, copy, ASSIGN_DECL, 0);",
          "",
          "[Added Lines]",
          "3284:     set_var_const(name, 0, NULL, tv, copy, ASSIGN_DECL, 0);",
          "3296:     scid_T sid,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3301:     dictitem_T *di;",
          "3302:     typval_T *dest_tv = NULL;",
          "3303:     char_u *varname;",
          "3305:     int  is_script_local;",
          "3306:     int  vim9script = in_vim9script();",
          "3307:     int  var_in_vim9script;",
          "3308:     int  flags = flags_arg;",
          "3309:     int  free_tv_arg = !copy;  // free tv_arg if not used",
          "3312:     if (ht == NULL || *varname == NUL)",
          "3313:     {",
          "3314:  semsg(_(e_illegal_variable_name_str), name);",
          "3315:  goto failed;",
          "3316:     }",
          "3319:     if (vim9script",
          "3320:      && !is_script_local",
          "",
          "[Removed Lines]",
          "3304:     hashtab_T *ht;",
          "3311:     ht = find_var_ht(name, &varname);",
          "3317:     is_script_local = ht == get_script_local_ht();",
          "",
          "[Added Lines]",
          "3309:     hashtab_T *ht = NULL;",
          "3316:     if (sid != 0)",
          "3317:     {",
          "3318:  if (SCRIPT_ID_VALID(sid))",
          "3319:      ht = &SCRIPT_VARS(sid);",
          "3320:  varname = name;",
          "3321:     }",
          "3322:     else",
          "3323:  ht = find_var_ht(name, &varname);",
          "3329:     is_script_local = ht == get_script_local_ht() || sid != 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3348:  if (import != NULL)",
          "3349:  {",
          "3355:      if ((flags & ASSIGN_NO_DECL) == 0)",
          "3356:      {",
          "3357:   semsg(_(e_redefining_imported_item_str), name);",
          "3358:   goto failed;",
          "3359:      }",
          "3377:  }",
          "3378:     }",
          "",
          "[Removed Lines]",
          "3350:      scriptitem_T    *si = SCRIPT_ITEM(import->imp_sid);",
          "3351:      svar_T     *sv;",
          "3352:      where_T     where = WHERE_INIT;",
          "3360:      if (import->imp_flags & IMP_FLAGS_STAR)",
          "3361:      {",
          "3362:   semsg(_(e_cannot_use_str_itself_it_is_imported_with_star),",
          "3363:           name);",
          "3364:   goto failed;",
          "3365:      }",
          "3366:      sv = ((svar_T *)si->sn_var_vals.ga_data) + import->imp_var_vals_idx;",
          "3368:      where.wt_variable = TRUE;",
          "3369:      if (check_typval_type(sv->sv_type, tv, where) == FAIL",
          "3370:       || value_check_lock(sv->sv_tv->v_lock, name, FALSE))",
          "3371:      {",
          "3372:   goto failed;",
          "3373:      }",
          "3375:      dest_tv = sv->sv_tv;",
          "3376:      clear_tv(dest_tv);",
          "",
          "[Added Lines]",
          "3368:      semsg(_(e_cannot_use_str_itself_it_is_imported), name);",
          "3369:      goto failed;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3419:   if (var_in_vim9script && (flags & ASSIGN_FOR_LOOP) == 0)",
          "3420:   {",
          "3421:       where_T where = WHERE_INIT;",
          "3424:       if (sv != NULL)",
          "3425:       {",
          "",
          "[Removed Lines]",
          "3422:       svar_T  *sv = find_typval_in_script(&di->di_tv);",
          "",
          "[Added Lines]",
          "3415:       svar_T  *sv = find_typval_in_script(&di->di_tv, sid);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3956:     {",
          "3957:  if (tofree != NULL)",
          "3958:      name = tofree;",
          "3960:      EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT) == OK);",
          "3961:  if (n)",
          "3962:  {",
          "",
          "[Removed Lines]",
          "3959:  n = (eval_variable(name, len, &tv, NULL,",
          "",
          "[Added Lines]",
          "3952:  n = (eval_variable(name, len, 0, &tv, NULL,",
          "",
          "---------------"
        ],
        "src/proto/eval.pro||src/proto/eval.pro": [
          "File: src/proto/eval.pro -> src/proto/eval.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: void free_for_info(void *fi_void);",
          "34: void set_context_for_expression(expand_T *xp, char_u *arg, cmdidx_T cmdidx);",
          "35: int pattern_match(char_u *pat, char_u *text, int ic);",
          "36: char_u *skipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg);",
          "37: void init_evalarg(evalarg_T *evalarg);",
          "38: void clear_evalarg(evalarg_T *evalarg, exarg_T *eap);",
          "39: int eval0(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg);",
          "40: int eval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg);",
          "41: void eval_addblob(typval_T *tv1, typval_T *tv2);",
          "42: int eval_addlist(typval_T *tv1, typval_T *tv2);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: char_u *eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext);",
          "37: char_u *eval_next_line(evalarg_T *evalarg);",
          "42: int eval0_retarg(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg, char_u **retarg);",
          "",
          "---------------"
        ],
        "src/proto/evalvars.pro||src/proto/evalvars.pro": [
          "File: src/proto/evalvars.pro -> src/proto/evalvars.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: char_u *v_exception(char_u *oldval);",
          "58: char_u *v_throwpoint(char_u *oldval);",
          "59: char_u *set_cmdarg(exarg_T *eap, char_u *oldarg);",
          "61: void check_vars(char_u *name, int len);",
          "62: dictitem_T *find_var(char_u *name, hashtab_T **htp, int no_autoload);",
          "63: dictitem_T *find_var_in_ht(hashtab_T *ht, int htname, char_u *varname, int no_autoload);",
          "",
          "[Removed Lines]",
          "60: int eval_variable(char_u *name, int len, typval_T *rettv, dictitem_T **dip, int flags);",
          "",
          "[Added Lines]",
          "60: int eval_variable(char_u *name, int len, scid_T sid, typval_T *rettv, dictitem_T **dip, int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72: void vars_clear_ext(hashtab_T *ht, int free_val);",
          "73: void delete_var(hashtab_T *ht, hashitem_T *hi);",
          "74: void set_var(char_u *name, typval_T *tv, int copy);",
          "76: int var_check_permission(dictitem_T *di, char_u *name);",
          "77: int var_check_ro(int flags, char_u *name, int use_gettext);",
          "78: int var_check_lock(int flags, char_u *name, int use_gettext);",
          "",
          "[Removed Lines]",
          "75: void set_var_const(char_u *name, type_T *type_arg, typval_T *tv_arg, int copy, int flags_arg, int var_idx);",
          "",
          "[Added Lines]",
          "75: void set_var_const(char_u *name, scid_T sid, type_T *type_arg, typval_T *tv_arg, int copy, int flags_arg, int var_idx);",
          "",
          "---------------"
        ],
        "src/proto/vim9script.pro||src/proto/vim9script.pro": [
          "File: src/proto/vim9script.pro -> src/proto/vim9script.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: char_u *vim9_declare_scriptvar(exarg_T *eap, char_u *arg);",
          "16: void update_vim9_script_var(int create, dictitem_T *di, int flags, typval_T *tv, type_T **type, int do_member);",
          "17: void hide_script_var(scriptitem_T *si, int idx, int func_defined);",
          "19: int check_script_var_type(svar_T *sv, typval_T *value, char_u *name, where_T where);",
          "20: int check_reserved_name(char_u *name);",
          "",
          "[Removed Lines]",
          "18: svar_T *find_typval_in_script(typval_T *dest);",
          "",
          "[Added Lines]",
          "18: svar_T *find_typval_in_script(typval_T *dest, scid_T sid);",
          "",
          "---------------"
        ],
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1823: typedef struct {",
          "1824:     char_u *imp_name;     // name imported as (allocated)",
          "1827:     int  imp_flags;     // IMP_FLAGS_ values",
          "1835: } imported_T;",
          "1838: #define IMP_FLAGS_RELOAD 2   // script reloaded, OK to redefine",
          "",
          "[Removed Lines]",
          "1825:     int  imp_sid;     // script ID of \"from\"",
          "1830:     type_T *imp_type;",
          "1831:     int  imp_var_vals_idx;   // index in sn_var_vals of \"from\"",
          "1834:     char_u *imp_funcname;     // user func name (NOT allocated)",
          "1837: #define IMP_FLAGS_STAR  1   // using \"import * as Name\"",
          "",
          "[Added Lines]",
          "1825:     scid_T imp_sid;     // script ID of \"from\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4264:     char_u *ll_name_end; // end of variable name (can be NULL)",
          "4265:     type_T *ll_type; // type of variable (can be NULL)",
          "4266:     char_u *ll_exp_name; // NULL or expanded name in allocated memory.",
          "4267:     typval_T *ll_tv;  // Typeval of item being used.  If \"newkey\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4259:     scid_T ll_sid;  // for an imported item: the script ID it was",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_assign.vim||src/testdir/test_vim9_assign.vim": [
          "File: src/testdir/test_vim9_assign.vim -> src/testdir/test_vim9_assign.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "2109:   writefile(['vim9script', 'export var svar = 1234'], 'XunletExport.vim')",
          "2110:   var lines =<< trim END",
          "2111:     vim9script",
          "2113:     def UnletSvar()",
          "2115:     enddef",
          "2116:     defcompile",
          "2117:   END",
          "2119:   delete('XunletExport.vim')",
          "2121:   $ENVVAR = 'foobar'",
          "",
          "[Removed Lines]",
          "2112:     import svar from './XunletExport.vim'",
          "2114:       unlet svar",
          "2118:   CheckScriptFailure(lines, 'E1081:', 1)",
          "",
          "[Added Lines]",
          "2112:     import './XunletExport.vim' as exp",
          "2114:       unlet exp.svar",
          "2118:   CheckScriptFailure(lines, 'E1260:', 1)",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim": [
          "File: src/testdir/test_vim9_script.vim -> src/testdir/test_vim9_script.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1172: enddef",
          "1174: def Test_vim9_import_export()",
          "1175:   var import_script_lines =<< trim END",
          "1176:     vim9script",
          "1194:     def GetExported(): string",
          "1196:       return local_dict.ref()",
          "1197:     enddef",
          "1198:     g:funcref_result = GetExported()",
          "1211:   END",
          "1213:   writefile(import_script_lines, 'Ximport.vim')",
          "1216:   source Ximport.vim",
          "1218:   assert_equal('bobbie', g:result)",
          "",
          "[Removed Lines]",
          "1177:     import {exported, Exported, ExportedValue} from './Xexport.vim'",
          "1178:     g:exported1 = exported",
          "1179:     exported += 3",
          "1180:     g:exported2 = exported",
          "1181:     g:exported3 = ExportedValue()",
          "1183:     import ExportedInc from './Xexport.vim'",
          "1184:     ExportedInc()",
          "1185:     g:exported_i1 = exported",
          "1186:     g:exported_i2 = ExportedValue()",
          "1188:     exported = 11",
          "1189:     g:exported_s1 = exported",
          "1190:     g:exported_s2 = ExportedValue()",
          "1192:     g:imported_func = Exported()",
          "1195:       var local_dict = {ref: Exported}",
          "1200:     var dir = './'",
          "1201:     var ext = \".vim\"",
          "1202:     import {exp_name} from dir .. 'Xexport' .. ext",
          "1203:     g:imported_name = exp_name",
          "1204:     exp_name ..= ' Doe'",
          "1205:     g:imported_name_appended = exp_name",
          "1206:     g:exported_later = exported",
          "1208:     import theList from './Xexport.vim'",
          "1209:     theList->add(2)",
          "1210:     assert_equal([1, 2], theList)",
          "1214:   writefile(s:export_script_lines, 'Xexport.vim')",
          "",
          "[Added Lines]",
          "1175:   writefile(s:export_script_lines, 'Xexport.vim')",
          "1178:     var dir = './'",
          "1179:     var ext = \".vim\"",
          "1180:     import dir .. 'Xexport' .. ext as expo",
          "1182:     g:exported1 = expo.exported",
          "1183:     expo.exported += 3",
          "1184:     g:exported2 = expo.exported",
          "1185:     g:exported3 = expo.ExportedValue()",
          "1187:     expo.ExportedInc()",
          "1188:     g:exported_i1 = expo.exported",
          "1189:     g:exported_i2 = expo.ExportedValue()",
          "1191:     expo.exported = 11",
          "1192:     g:exported_s1 = expo.exported",
          "1193:     g:exported_s2 = expo.ExportedValue()",
          "1195:     g:imported_func = expo.Exported()",
          "1198:       var local_dict = {ref: expo.Exported}",
          "1203:     g:imported_name = expo.exp_name",
          "1204:     expo.exp_name ..= ' Doe'",
          "1205:     g:imported_name_appended = expo.exp_name",
          "1206:     g:exported_later = expo.exported",
          "1208:     expo.theList->add(2)",
          "1209:     assert_equal([1, 2], expo.theList)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1248:   # similar, with line breaks",
          "1249:   var import_line_break_script_lines =<< trim END",
          "1250:     vim9script",
          "1261:   END",
          "1262:   writefile(import_line_break_script_lines, 'Ximport_lbr.vim')",
          "1263:   source Ximport_lbr.vim",
          "",
          "[Removed Lines]",
          "1251:     import {",
          "1252:         exported,",
          "1253:         Exported,",
          "1254:         }",
          "1255:         from",
          "1256:         './Xexport.vim'",
          "1257:     g:exported = exported",
          "1258:     exported += 7",
          "1259:     g:exported_added = exported",
          "1260:     g:imported_func = Exported()",
          "",
          "[Added Lines]",
          "1247:     import './Xexport.vim'",
          "1248:         as expo",
          "1249:     g:exported = expo.exported",
          "1250:     expo.exported += 7",
          "1251:     g:exported_added = expo.exported",
          "1252:     g:imported_func = expo.Exported()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1276:   var import_star_as_lines =<< trim END",
          "1277:     vim9script",
          "1279:     def UseExport()",
          "1280:       g:exported_def = Export.exported",
          "1281:     enddef",
          "",
          "[Removed Lines]",
          "1278:     import * as Export from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1270:     import './Xexport.vim' as Export",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1295:   var import_star_as_lines_no_dot =<< trim END",
          "1296:     vim9script",
          "1298:     def Func()",
          "1299:       var dummy = 1",
          "1300:       var imported = Export + dummy",
          "",
          "[Removed Lines]",
          "1297:     import * as Export from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1289:     import './Xexport.vim' as Export",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1307:   var import_star_as_lines_dot_space =<< trim END",
          "1308:     vim9script",
          "1310:     def Func()",
          "1311:       var imported = Export . exported",
          "1312:     enddef",
          "",
          "[Removed Lines]",
          "1309:     import * as Export from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1301:     import './Xexport.vim' as Export",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1318:   var import_func_duplicated =<< trim END",
          "1319:     vim9script",
          "1323:     ExportedInc()",
          "1324:   END",
          "",
          "[Removed Lines]",
          "1320:     import ExportedInc from './Xexport.vim'",
          "1321:     import ExportedInc from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1312:     import './Xexport.vim' as expo",
          "1313:     import './Xexport.vim' as expo",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1328:   var import_star_as_duplicated =<< trim END",
          "1329:     vim9script",
          "1331:     var some = 'other'",
          "1333:     defcompile",
          "1334:   END",
          "1335:   writefile(import_star_as_duplicated, 'Ximport.vim')",
          "",
          "[Removed Lines]",
          "1330:     import * as Export from './Xexport.vim'",
          "1332:     import * as Export from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1322:     import './Xexport.vim' as Export",
          "1324:     import './Xexport.vim' as Export",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1338:   var import_star_as_lines_script_no_dot =<< trim END",
          "1339:     vim9script",
          "1341:     g:imported_script = Export exported",
          "1342:   END",
          "1343:   writefile(import_star_as_lines_script_no_dot, 'Ximport.vim')",
          "",
          "[Removed Lines]",
          "1340:     import * as Export from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1332:     import './Xexport.vim' as Export",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1346:   var import_star_as_lines_script_space_after_dot =<< trim END",
          "1347:     vim9script",
          "1349:     g:imported_script = Export. exported",
          "1350:   END",
          "1351:   writefile(import_star_as_lines_script_space_after_dot, 'Ximport.vim')",
          "",
          "[Removed Lines]",
          "1348:     import * as Export from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1340:     import './Xexport.vim' as Export",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1354:   var import_star_as_lines_missing_name =<< trim END",
          "1355:     vim9script",
          "1357:     def Func()",
          "1358:       var imported = Export.",
          "1359:     enddef",
          "",
          "[Removed Lines]",
          "1356:     import * as Export from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1348:     import './Xexport.vim' as Export",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1365:   var import_star_as_lbr_lines =<< trim END",
          "1366:     vim9script",
          "1368:         as Export",
          "1371:     def UseExport()",
          "1372:       g:exported = Export.exported",
          "1373:     enddef",
          "",
          "[Removed Lines]",
          "1367:     import *",
          "1369:         from",
          "1370:         './Xexport.vim'",
          "",
          "[Added Lines]",
          "1359:     import './Xexport.vim'",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1378:   assert_equal(18, g:exported)",
          "1379:   unlet g:exported",
          "1389:   var import_not_exported_lines =<< trim END",
          "1390:     vim9script",
          "1392:   END",
          "1393:   writefile(import_not_exported_lines, 'Ximport.vim')",
          "1396:   # try to import something that is already defined",
          "1397:   var import_already_defined =<< trim END",
          "1398:     vim9script",
          "1399:     var exported = 'something'",
          "1419:   END",
          "1420:   writefile(import_already_defined, 'Ximport.vim')",
          "1421:   assert_fails('source Ximport.vim', 'E1054:', '', 3, 'Ximport.vim')",
          "",
          "[Removed Lines]",
          "1381:   var import_star_lines =<< trim END",
          "1382:     vim9script",
          "1383:     import * from './Xexport.vim'",
          "1384:   END",
          "1385:   writefile(import_star_lines, 'Ximport.vim')",
          "1386:   assert_fails('source Ximport.vim', 'E1045:', '', 2, 'Ximport.vim')",
          "1388:   # try to import something that exists but is not exported",
          "1391:     import name from './Xexport.vim'",
          "1394:   assert_fails('source Ximport.vim', 'E1049:', '', 2, 'Ximport.vim')",
          "1400:     import exported from './Xexport.vim'",
          "1401:   END",
          "1402:   writefile(import_already_defined, 'Ximport.vim')",
          "1403:   assert_fails('source Ximport.vim', 'E1054:', '', 3, 'Ximport.vim')",
          "1405:   # try to import something that is already defined",
          "1406:   import_already_defined =<< trim END",
          "1407:     vim9script",
          "1408:     var exported = 'something'",
          "1409:     import * as exported from './Xexport.vim'",
          "1410:   END",
          "1411:   writefile(import_already_defined, 'Ximport.vim')",
          "1412:   assert_fails('source Ximport.vim', 'E1054:', '', 3, 'Ximport.vim')",
          "1414:   # try to import something that is already defined",
          "1415:   import_already_defined =<< trim END",
          "1416:     vim9script",
          "1417:     var exported = 'something'",
          "1418:     import {exported} from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1371:   # try to use something that exists but is not exported",
          "1374:     import './Xexport.vim' as expo",
          "1375:     echo expo.name",
          "1378:   assert_fails('source Ximport.vim', 'E1049:', '', 3, 'Ximport.vim')",
          "1384:     import './Xexport.vim' as exported",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1423:   # try changing an imported const",
          "1424:   var import_assign_to_const =<< trim END",
          "1425:     vim9script",
          "1427:     def Assign()",
          "1429:     enddef",
          "1430:     defcompile",
          "1431:   END",
          "",
          "[Removed Lines]",
          "1426:     import CONST from './Xexport.vim'",
          "1428:       CONST = 987",
          "",
          "[Added Lines]",
          "1392:     import './Xexport.vim' as expo",
          "1394:       expo.CONST = 987",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1435:   # try changing an imported final",
          "1436:   var import_assign_to_final =<< trim END",
          "1437:     vim9script",
          "1439:     def Assign()",
          "1441:     enddef",
          "1442:     defcompile",
          "1443:   END",
          "1444:   writefile(import_assign_to_final, 'Ximport.vim')",
          "1445:   assert_fails('source Ximport.vim', 'E46:', '', 1, '_Assign')",
          "1449:     vim9script",
          "1451:   END",
          "1462:   var import_invalid_string_lines =<< trim END",
          "1463:     vim9script",
          "1465:   END",
          "1466:   writefile(import_invalid_string_lines, 'Ximport.vim')",
          "1467:   assert_fails('source Ximport.vim', 'E121:', '', 2, 'Ximport.vim')",
          "1469:   var import_wrong_name_lines =<< trim END",
          "1470:     vim9script",
          "1472:   END",
          "1473:   writefile(import_wrong_name_lines, 'Ximport.vim')",
          "1474:   assert_fails('source Ximport.vim', 'E1053:', '', 2, 'Ximport.vim')",
          "1483:   var import_redefining_lines =<< trim END",
          "1484:     vim9script",
          "1486:     var exported = 5",
          "1487:   END",
          "1488:   writefile(import_redefining_lines, 'Ximport.vim')",
          "",
          "[Removed Lines]",
          "1438:     import theList from './Xexport.vim'",
          "1440:       theList = [2]",
          "1447:   # import a very long name, requires making a copy",
          "1448:   var import_long_name_lines =<< trim END",
          "1450:     import name012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 from './Xexport.vim'",
          "1452:   writefile(import_long_name_lines, 'Ximport.vim')",
          "1453:   assert_fails('source Ximport.vim', 'E1048:', '', 2, 'Ximport.vim')",
          "1455:   var import_no_from_lines =<< trim END",
          "1456:     vim9script",
          "1457:     import name './Xexport.vim'",
          "1458:   END",
          "1459:   writefile(import_no_from_lines, 'Ximport.vim')",
          "1460:   assert_fails('source Ximport.vim', 'E1070:', '', 2, 'Ximport.vim')",
          "1464:     import name from Xexport.vim",
          "1471:     import name from './XnoExport.vim'",
          "1476:   var import_missing_comma_lines =<< trim END",
          "1477:     vim9script",
          "1478:     import {exported name} from './Xexport.vim'",
          "1479:   END",
          "1480:   writefile(import_missing_comma_lines, 'Ximport3.vim')",
          "1481:   assert_fails('source Ximport3.vim', 'E1046:', '', 2, 'Ximport3.vim')",
          "1485:     import exported from './Xexport.vim'",
          "",
          "[Added Lines]",
          "1404:     import './Xexport.vim' as expo",
          "1406:       expo.theList = [2]",
          "1413:   var import_no_as_lines =<< trim END",
          "1415:     import './Xexport.vim' name",
          "1417:   writefile(import_no_as_lines, 'Ximport.vim')",
          "1418:   assert_fails('source Ximport.vim', 'E488:', '', 2, 'Ximport.vim')",
          "1422:     import Xexport.vim",
          "1429:     import './XnoExport.vim'",
          "1436:     import './Xexport.vim' as exported",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1491:   var import_assign_wrong_type_lines =<< trim END",
          "1492:     vim9script",
          "1495:   END",
          "1496:   writefile(import_assign_wrong_type_lines, 'Ximport.vim')",
          "1497:   assert_fails('source Ximport.vim', 'E1012: Type mismatch; expected number but got string', '', 3)",
          "1499:   var import_assign_const_lines =<< trim END",
          "1500:     vim9script",
          "1503:   END",
          "1504:   writefile(import_assign_const_lines, 'Ximport.vim')",
          "1507:   delete('Ximport.vim')",
          "1508:   delete('Ximport3.vim')",
          "",
          "[Removed Lines]",
          "1493:     import exported from './Xexport.vim'",
          "1494:     exported = 'xxx'",
          "1501:     import CONST from './Xexport.vim'",
          "1502:     CONST = 4321",
          "1505:   assert_fails('source Ximport.vim', 'E741: Value is locked: CONST', '', 3)",
          "",
          "[Added Lines]",
          "1444:     import './Xexport.vim' as expo",
          "1445:     expo.exported = 'xxx'",
          "1452:     import './Xexport.vim' as expo",
          "1453:     expo.CONST = 4321",
          "1456:   assert_fails('source Ximport.vim', 'E46: Cannot change read-only variable \"CONST\"', '', 3)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1542:   lines =<< trim END",
          "1543:       vim9script",
          "1546:       assert_equal(42, Foo)",
          "1548:       def DoTest()",
          "1550:         assert_equal(42, Goo)",
          "1551:       enddef",
          "1552:       DoTest()",
          "",
          "[Removed Lines]",
          "1544:       import {G} from './Xlib.vim'",
          "1545:       const Foo = G()",
          "1549:         const Goo = G()",
          "",
          "[Added Lines]",
          "1495:       import './Xlib.vim' as lib",
          "1496:       const Foo = lib.G()",
          "1500:         const Goo = lib.G()",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1559: def Test_import_star_fails()",
          "1560:   writefile([], 'Xfoo.vim')",
          "1561:   var lines =<< trim END",
          "1563:       foo = 'bar'",
          "1564:   END",
          "1565:   CheckDefAndScriptFailure(lines, ['E1094:', 'E1236: Cannot use foo itself'])",
          "1566:   lines =<< trim END",
          "1567:       vim9script",
          "1569:       var that = foo",
          "1570:   END",
          "1571:   CheckScriptFailure(lines, 'E1029: Expected ''.''')",
          "1573:   lines =<< trim END",
          "1574:       vim9script",
          "1576:   END",
          "1577:   CheckScriptFailure(lines, 'E1047:')",
          "1578:   lines =<< trim END",
          "1579:       vim9script",
          "1581:   END",
          "1582:   CheckScriptFailure(lines, 'E1047:')",
          "1583:   lines =<< trim END",
          "1584:       vim9script",
          "1586:   END",
          "1587:   CheckScriptFailure(lines, 'E1047:')",
          "",
          "[Removed Lines]",
          "1562:       import * as foo from './Xfoo.vim'",
          "1568:       import * as foo from './Xfoo.vim'",
          "1575:       import * as 9foo from './Xfoo.vim'",
          "1580:       import * as the#foo from './Xfoo.vim'",
          "1585:       import * as g:foo from './Xfoo.vim'",
          "",
          "[Added Lines]",
          "1513:       import './Xfoo.vim' as foo",
          "1519:       import './Xfoo.vim' as foo",
          "1526:       import './Xfoo.vim' as 9foo",
          "1531:       import './Xfoo.vim' as the#foo",
          "1536:       import './Xfoo.vim' as g:foo",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1597:   END",
          "1598:   writefile([], 'Xthat.vim')",
          "1599:   lines =<< trim END",
          "1601:       That()",
          "1602:   END",
          "1603:   CheckDefAndScriptFailure(lines, ['E1094:', 'E1236: Cannot use That itself'])",
          "1604:   delete('Xthat.vim')",
          "1605: enddef",
          "1647: func g:Trigger()",
          "1648:   source Ximport.vim",
          "1649:   return \"echo 'yes'\\<CR>\"",
          "",
          "[Removed Lines]",
          "1600:       import * as That from './Xthat.vim'",
          "1607: def Test_import_as()",
          "1608:   var export_lines =<< trim END",
          "1609:     vim9script",
          "1610:     export var one = 1",
          "1611:     export var yes = 'yes'",
          "1612:     export var slist: list<string>",
          "1613:   END",
          "1614:   writefile(export_lines, 'XexportAs')",
          "1616:   var import_lines =<< trim END",
          "1617:     vim9script",
          "1618:     var one = 'notused'",
          "1619:     var yes = 777",
          "1620:     import one as thatOne from './XexportAs'",
          "1621:     assert_equal(1, thatOne)",
          "1622:     import yes as yesYes from './XexportAs'",
          "1623:     assert_equal('yes', yesYes)",
          "1624:   END",
          "1625:   CheckScriptSuccess(import_lines)",
          "1627:   import_lines =<< trim END",
          "1628:     vim9script",
          "1629:     import {one as thatOne, yes as yesYes} from './XexportAs'",
          "1630:     assert_equal(1, thatOne)",
          "1631:     assert_equal('yes', yesYes)",
          "1632:     assert_fails('echo one', 'E121:')",
          "1633:     assert_fails('echo yes', 'E121:')",
          "1634:   END",
          "1635:   CheckScriptSuccess(import_lines)",
          "1637:   import_lines =<< trim END",
          "1638:     vim9script",
          "1639:     import {slist as impSlist} from './XexportAs'",
          "1640:     impSlist->add(123)",
          "1641:   END",
          "1642:   CheckScriptFailure(import_lines, 'E1012: Type mismatch; expected string but got number')",
          "1644:   delete('XexportAs')",
          "1645: enddef",
          "",
          "[Added Lines]",
          "1551:       import './Xthat.vim' as That",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1662:   var import_lines =<< trim END",
          "1663:     vim9script",
          "1666:   END",
          "1667:   writefile(import_lines, 'Ximport.vim')",
          "",
          "[Removed Lines]",
          "1664:     import That from './Xexport_that.vim'",
          "1665:     assert_equal('yes', That())",
          "",
          "[Added Lines]",
          "1575:     import './Xexport_that.vim' as that",
          "1576:     assert_equal('yes', that.That())",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1686:   var import_lines =<< trim END",
          "1687:     vim9script",
          "1690:     g:did_load_mytpe = 1",
          "1691:   END",
          "1692:   writefile(import_lines, 'ftplugin/qf.vim')",
          "",
          "[Removed Lines]",
          "1688:     import That from './Xexport_ft.vim'",
          "1689:     assert_equal('yes', That)",
          "",
          "[Added Lines]",
          "1599:     import './Xexport_ft.vim' as ft",
          "1600:     assert_equal('yes', ft.That)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1704:   &rtp = save_rtp",
          "1705: enddef",
          "1732: def Test_vim9script_mix()",
          "1733:   var lines =<< trim END",
          "",
          "[Removed Lines]",
          "1707: def Test_use_import_in_mapping()",
          "1708:   var lines =<< trim END",
          "1709:       vim9script",
          "1710:       export def Funcx()",
          "1711:         g:result = 42",
          "1712:       enddef",
          "1713:   END",
          "1714:   writefile(lines, 'XsomeExport.vim')",
          "1715:   lines =<< trim END",
          "1716:       vim9script",
          "1717:       import Funcx from './XsomeExport.vim'",
          "1718:       nnoremap <F3> :call <sid>Funcx()<cr>",
          "1719:   END",
          "1720:   writefile(lines, 'Xmapscript.vim')",
          "1722:   source Xmapscript.vim",
          "1723:   feedkeys(\"\\<F3>\", \"xt\")",
          "1724:   assert_equal(42, g:result)",
          "1726:   unlet g:result",
          "1727:   delete('XsomeExport.vim')",
          "1728:   delete('Xmapscript.vim')",
          "1729:   nunmap <F3>",
          "1730: enddef",
          "",
          "[Added Lines]",
          "1618: \" FIXME",
          "1619: \"def Test_use_import_in_mapping()",
          "1620: \"  var lines =<< trim END",
          "1621: \"      vim9script",
          "1622: \"      export def Funcx()",
          "1623: \"        g:result = 42",
          "1624: \"      enddef",
          "1625: \"  END",
          "1626: \"  writefile(lines, 'XsomeExport.vim')",
          "1627: \"  lines =<< trim END",
          "1628: \"      vim9script",
          "1629: \"      import './XsomeExport.vim' as some",
          "1630: \"      var Funcy = some.Funcx",
          "1631: \"      nnoremap <F3> :call <sid>Funcy()<cr>",
          "1632: \"  END",
          "1633: \"  writefile(lines, 'Xmapscript.vim')",
          "1634: \"",
          "1635: \"  source Xmapscript.vim",
          "1636: \"  feedkeys(\"\\<F3>\", \"xt\")",
          "1637: \"  assert_equal(42, g:result)",
          "1638: \"",
          "1639: \"  unlet g:result",
          "1640: \"  delete('XsomeExport.vim')",
          "1641: \"  delete('Xmapscript.vim')",
          "1642: \"  nunmap <F3>",
          "1643: \"enddef",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1754:   CheckScriptFailure(['scriptversion 2', 'vim9script'], 'E1039:')",
          "1755:   CheckScriptFailure(['vim9script', 'scriptversion 2'], 'E1040:')",
          "1756:   CheckScriptFailure(['export var some = 123'], 'E1042:')",
          "1758:   CheckScriptFailure(['vim9script', 'export var g:some'], 'E1022:')",
          "1759:   CheckScriptFailure(['vim9script', 'export echo 134'], 'E1043:')",
          "",
          "[Removed Lines]",
          "1757:   CheckScriptFailure(['import some from \"./Xexport.vim\"'], 'E1048:')",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1802:     vim9script noclear",
          "1803:     g:loadCount += 1",
          "1804:     var s:reloaded = 'init'",
          "1807:     def Again(): string",
          "1808:       return 'again'",
          "1809:     enddef",
          "1814:     if exists('s:loaded') | finish | endif",
          "1815:     var s:loaded = true",
          "",
          "[Removed Lines]",
          "1805:     import exported from './XExportReload'",
          "1811:     import TheFunc from './XExportReload'",
          "1812:     TheFunc()",
          "",
          "[Added Lines]",
          "1717:     import './XExportReload' as exp",
          "1723:     exp.TheFunc()",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1817:     var s:notReloaded = 'yes'",
          "1818:     s:reloaded = 'first'",
          "1819:     def g:Values(): list<string>",
          "1821:     enddef",
          "1823:     def Once(): string",
          "",
          "[Removed Lines]",
          "1820:       return [s:reloaded, s:notReloaded, Again(), Once(), exported]",
          "",
          "[Added Lines]",
          "1731:       return [s:reloaded, s:notReloaded, Again(), Once(), exp.exported]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2023:   var lines =<< trim END",
          "2024:     vim9script",
          "2026:     def Test()",
          "2028:     enddef",
          "2029:     Test()",
          "2031:     # using a function imported with \"as\"",
          "2033:     assert_equal('yes', anAlias.GetString('yes'))",
          "2035:     # using the function from a compiled function",
          "",
          "[Removed Lines]",
          "2025:     import FastSort from './Xsort.vim'",
          "2027:       g:result = FastSort()",
          "2032:     import * as anAlias from './Xsort.vim'",
          "",
          "[Added Lines]",
          "1936:     import './Xsort.vim'",
          "1938:       g:result = Xsort.FastSort()",
          "1943:     import './Xsort.vim' as anAlias",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2076:   var lines =<< trim END",
          "2077:     vim9script",
          "2079:     def Test()",
          "2081:     enddef",
          "2082:     Test()",
          "2083:     def TestDirect()",
          "2085:     enddef",
          "2086:     TestDirect()",
          "2087:   END",
          "",
          "[Removed Lines]",
          "2078:     import {FilterFunc, FastFilter, FastFilterDirect} from './Xfilter.vim'",
          "2080:       var x: list<number> = FastFilter()",
          "2084:       var x: list<number> = FastFilterDirect()",
          "",
          "[Added Lines]",
          "1989:     import './Xfilter.vim' as filter",
          "1991:       var x: list<number> = filter.FastFilter()",
          "1995:       var x: list<number> = filter.FastFilterDirect()",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2155: def Test_import_absolute()",
          "2156:   var import_lines = [",
          "2157:         'vim9script',",
          "2159:         'def UseExported()',",
          "2163:         'enddef',",
          "2164:         'UseExported()',",
          "2165:         'g:import_disassembled = execute(\"disass UseExported\")',",
          "",
          "[Removed Lines]",
          "2158:         'import exported from \"' .. escape(getcwd(), '\\') .. '/Xexport_abs.vim\"',",
          "2160:         '  g:imported_abs = exported',",
          "2161:         '  exported = 8888',",
          "2162:         '  g:imported_after = exported',",
          "",
          "[Added Lines]",
          "2069:         'import \"' .. escape(getcwd(), '\\') .. '/Xexport_abs.vim\" as abs',",
          "2071:         '  g:imported_abs = abs.exported',",
          "2072:         '  abs.exported = 8888',",
          "2073:         '  g:imported_after = abs.exported',",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2172:   assert_equal(9876, g:imported_abs)",
          "2173:   assert_equal(8888, g:imported_after)",
          "2174:   assert_match('<SNR>\\d\\+_UseExported\\_s*' ..",
          "2176:           '0 LOADSCRIPT exported-2 from .*Xexport_abs.vim\\_s*' ..",
          "2177:           '1 STOREG g:imported_abs\\_s*' ..",
          "2179:           '2 PUSHNR 8888\\_s*' ..",
          "2180:           '3 STORESCRIPT exported-2 in .*Xexport_abs.vim\\_s*' ..",
          "2182:           '4 LOADSCRIPT exported-2 from .*Xexport_abs.vim\\_s*' ..",
          "2183:           '5 STOREG g:imported_after',",
          "2184:         g:import_disassembled)",
          "",
          "[Removed Lines]",
          "2175:           'g:imported_abs = exported\\_s*' ..",
          "2178:           'exported = 8888\\_s*' ..",
          "2181:           'g:imported_after = exported\\_s*' ..",
          "",
          "[Added Lines]",
          "2086:           'g:imported_abs = abs.exported\\_s*' ..",
          "2089:           'abs.exported = 8888\\_s*' ..",
          "2092:           'g:imported_after = abs.exported\\_s*' ..",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2194: def Test_import_rtp()",
          "2195:   var import_lines = [",
          "2196:         'vim9script',",
          "2199:         ]",
          "2200:   writefile(import_lines, 'Ximport_rtp.vim')",
          "2201:   mkdir('import', 'p')",
          "",
          "[Removed Lines]",
          "2197:         'import exported from \"Xexport_rtp.vim\"',",
          "2198:         'g:imported_rtp = exported',",
          "",
          "[Added Lines]",
          "2108:         'import \"Xexport_rtp.vim\" as rtp',",
          "2109:         'g:imported_rtp = rtp.exported',",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2226:   var import_lines = [",
          "2227:         'vim9script',",
          "2229:         'def ImpFunc()',",
          "2231:         'enddef',",
          "2232:         'defcompile',",
          "2233:         ]",
          "",
          "[Removed Lines]",
          "2228:         'import ExpFunc from \"./Xexported.vim\"',",
          "2230:         '  echo ExpFunc()',",
          "",
          "[Added Lines]",
          "2139:         'import \"./Xexported.vim\" as expo',",
          "2141:         '  echo expo.ExpFunc()',",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2280:   var lines =<< trim END",
          "2281:     vim9script",
          "2283:     def Func()",
          "2284:       echo 'local to function'",
          "2285:     enddef",
          "2286:   END",
          "2289:   lines =<< trim END",
          "2290:     vim9script",
          "2292:     def Outer()",
          "2293:       def Func()",
          "2294:         echo 'local to function'",
          "",
          "[Removed Lines]",
          "2282:     import Func from './XexportedFunc.vim'",
          "2287:   CheckScriptFailure(lines, 'E1041:')",
          "2291:     import Func from './XexportedFunc.vim'",
          "",
          "[Added Lines]",
          "2193:     import './XexportedFunc.vim' as Func",
          "2198:   CheckScriptFailure(lines, 'E1236:')",
          "2202:     import './XexportedFunc.vim' as Func",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2296:     enddef",
          "2297:     defcompile",
          "2298:   END",
          "2301:   delete('XexportedFunc.vim')",
          "2302: enddef",
          "",
          "[Removed Lines]",
          "2299:   CheckScriptFailure(lines, 'E1073:')",
          "",
          "[Added Lines]",
          "2210:   CheckScriptFailure(lines, 'E1236:')",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3941:     call assert_equal('global', global)",
          "3942:     call assert_equal('global', g:global)",
          "3953:   END",
          "3954:   writefile(legacy_lines, 'Xlegacy_script.vim')",
          "",
          "[Removed Lines]",
          "3944:     \" imported variable becomes script-local",
          "3945:     import exported from './Xvim9_script.vim'",
          "3946:     call assert_equal('exported', s:exported)",
          "3947:     call assert_false(exists('exported'))",
          "3949:     \" imported function becomes script-local",
          "3950:     import GetText from './Xvim9_script.vim'",
          "3951:     call assert_equal('text', s:GetText())",
          "3952:     call assert_false(exists('*GetText'))",
          "",
          "[Added Lines]",
          "3855:     \"\" imported variable becomes script-local",
          "3856:     \"import exported from './Xvim9_script.vim'",
          "3857:     \"call assert_equal('exported', s:exported)",
          "3858:     \"call assert_false(exists('exported'))",
          "3860:     \"\" imported function becomes script-local",
          "3861:     \"import GetText from './Xvim9_script.vim'",
          "3862:     \"call assert_equal('text', s:GetText())",
          "3863:     \"call assert_false(exists('*GetText'))",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "4248:   writefile(export_lines, 'rtp/syntax/Xexport.vim')",
          "4249:   var import_lines =<< trim END",
          "4250:     vim9script",
          "4252:   END",
          "4253:   writefile(import_lines, 'rtp/syntax/vim.vim')",
          "4254:   var save_rtp = &rtp",
          "",
          "[Removed Lines]",
          "4251:     import That from './Xexport.vim'",
          "",
          "[Added Lines]",
          "4162:     import './Xexport.vim' as exp",
          "4163:     echo exp.That",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "4594:   unlet g:guard",
          "4595: enddef",
          "4628: def Test_unsupported_commands()",
          "4629:   var lines =<< trim END",
          "",
          "[Removed Lines]",
          "4597: def Test_import_gone_when_sourced_twice()",
          "4598:   var exportlines =<< trim END",
          "4599:       vim9script",
          "4600:       if exists('g:guard')",
          "4601:         finish",
          "4602:       endif",
          "4603:       g:guard = 1",
          "4604:       export var name = 'someName'",
          "4605:   END",
          "4606:   writefile(exportlines, 'XexportScript.vim')",
          "4608:   var lines =<< trim END",
          "4609:       vim9script",
          "4610:       import name from './XexportScript.vim'",
          "4611:       def g:GetName(): string",
          "4612:         return name",
          "4613:       enddef",
          "4614:   END",
          "4615:   writefile(lines, 'XscriptImport.vim')",
          "4616:   so XscriptImport.vim",
          "4617:   assert_equal('someName', g:GetName())",
          "4619:   so XexportScript.vim",
          "4620:   assert_fails('call g:GetName()', 'E1149:')",
          "4622:   delfunc g:GetName",
          "4623:   delete('XexportScript.vim')",
          "4624:   delete('XscriptImport.vim')",
          "4625:   unlet g:guard",
          "4626: enddef",
          "",
          "[Added Lines]",
          "4509: \"def Test_import_gone_when_sourced_twice()",
          "4510: \"  var exportlines =<< trim END",
          "4511: \"      vim9script",
          "4512: \"      if exists('g:guard')",
          "4513: \"        finish",
          "4514: \"      endif",
          "4515: \"      g:guard = 1",
          "4516: \"      export var name = 'someName'",
          "4517: \"  END",
          "4518: \"  writefile(exportlines, 'XexportScript.vim')",
          "4519: \"",
          "4520: \"  var lines =<< trim END",
          "4521: \"      vim9script",
          "4522: \"      import name from './XexportScript.vim'",
          "4523: \"      def g:GetName(): string",
          "4524: \"        return name",
          "4525: \"      enddef",
          "4526: \"  END",
          "4527: \"  writefile(lines, 'XscriptImport.vim')",
          "4528: \"  so XscriptImport.vim",
          "4529: \"  assert_equal('someName', g:GetName())",
          "4530: \"",
          "4531: \"  so XexportScript.vim",
          "4532: \"  assert_fails('call g:GetName()', 'E1149:')",
          "4533: \"",
          "4534: \"  delfunc g:GetName",
          "4535: \"  delete('XexportScript.vim')",
          "4536: \"  delete('XscriptImport.vim')",
          "4537: \"  unlet g:guard",
          "4538: \"enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1608:  }",
          "1609:  import = find_imported(p, len, NULL);",
          "1612:  if (import != NULL)",
          "1613:  {",
          "1639:  }",
          "1640:     }",
          "",
          "[Removed Lines]",
          "1614:      if (import->imp_funcname != NULL)",
          "1615:      {",
          "1616:   s = import->imp_funcname;",
          "1618:   return s;",
          "1619:      }",
          "1620:      if (import->imp_flags & IMP_FLAGS_STAR)",
          "1621:      {",
          "1622:   name[len] = NUL;",
          "1623:   semsg(_(e_cannot_use_str_itself_it_is_imported_with_star),",
          "1624:           name);",
          "1625:   name[len] = cc;",
          "1627:   return (char_u *)\"\"; // just in case",
          "1628:      }",
          "1629:      else",
          "1630:      {",
          "1631:   scriptitem_T    *si = SCRIPT_ITEM(import->imp_sid);",
          "1632:   svar_T  *sv = ((svar_T *)si->sn_var_vals.ga_data)",
          "1633:           + import->imp_var_vals_idx;",
          "1634:   tv = sv->sv_tv;",
          "1635:   if (type != NULL)",
          "1637:   did_type = TRUE;",
          "1638:      }",
          "",
          "[Added Lines]",
          "1614:      name[len] = NUL;",
          "1615:      semsg(_(e_cannot_use_str_itself_it_is_imported), name);",
          "1616:      name[len] = cc;",
          "1618:      return (char_u *)\"\"; // just in case",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1673:  {",
          "1674:      if (!did_type && type != NULL && ht == get_script_local_ht())",
          "1675:      {",
          "1678:   if (sv != NULL)",
          "",
          "[Removed Lines]",
          "1676:   svar_T  *sv = find_typval_in_script(tv);",
          "",
          "[Added Lines]",
          "1656:   svar_T  *sv = find_typval_in_script(tv, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1907:     ufunc_T *",
          "1909: {",
          "1910:     hashitem_T *hi;",
          "1911:     ufunc_T *func;",
          "1914:     if (!is_global)",
          "1915:     {",
          "1918:  int find_script_local = in_vim9script() && eval_isnamec1(*name)",
          "1919:         && (name[1] != ':' || *name == 's');",
          "",
          "[Removed Lines]",
          "1908: find_func_even_dead(char_u *name, int is_global, cctx_T *cctx)",
          "1912:     imported_T *imported;",
          "1916:  char_u *after_script = NULL;",
          "1917:  long sid = 0;",
          "",
          "[Added Lines]",
          "1888: find_func_even_dead(char_u *name, int is_global, cctx_T *cctx UNUSED)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1926:      if (func != NULL)",
          "1927:   return func;",
          "1928:  }",
          "1958:     }",
          "1960:     hi = hash_find(&func_hashtab,",
          "",
          "[Removed Lines]",
          "1930:  if (name[0] == K_SPECIAL",
          "1931:   && name[1] == KS_EXTRA",
          "1932:   && name[2] == KE_SNR)",
          "1933:  {",
          "1936:      after_script = name + 3;",
          "1937:      sid = getdigits(&after_script);",
          "1938:      if (*after_script == '_')",
          "1939:   ++after_script;",
          "1940:      else",
          "1941:   after_script = NULL;",
          "1942:  }",
          "1943:  if (find_script_local || after_script != NULL)",
          "1944:  {",
          "1946:      if (after_script != NULL && sid != current_sctx.sc_sid)",
          "1947:   imported = find_imported_in_script(after_script, 0, sid);",
          "1948:      else",
          "1949:   imported = find_imported(after_script == NULL",
          "1950:             ? name : after_script, 0, cctx);",
          "1951:      if (imported != NULL && imported->imp_funcname != NULL)",
          "1952:      {",
          "1953:   hi = hash_find(&func_hashtab, imported->imp_funcname);",
          "1954:   if (!HASHITEM_EMPTY(hi))",
          "1955:       return HI2UF(hi);",
          "1956:      }",
          "1957:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4259:      if (vim9script && *arg == K_SPECIAL",
          "4262:            + EVAL_VAR_NO_FUNC) == OK)",
          "4263:      {",
          "4264:   semsg(_(e_redefining_script_item_str), name_base);",
          "",
          "[Removed Lines]",
          "4260:   && eval_variable(name_base, (int)STRLEN(name_base), NULL, NULL,",
          "4261:     EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT",
          "",
          "[Added Lines]",
          "4208:   && eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,",
          "4209:       NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     4018,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     4019,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1358:       lhs->lhs_scriptvar_sid = current_sctx.sc_sid;",
          "1359:       if (import != NULL)",
          "1360:    lhs->lhs_scriptvar_sid = import->imp_sid;",
          "1361:       if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))",
          "1362:       {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1360:       {",
          "1361:    char_u *dot = vim_strchr(var_start, '.');",
          "1362:    char_u *p;",
          "1365:    if (dot == NULL)",
          "1366:    {",
          "1367:        semsg(_(e_no_dot_after_imported_name_str),",
          "1368:             var_start);",
          "1369:        return FAIL;",
          "1370:    }",
          "1371:    p = skipwhite(dot + 1);",
          "1372:    var_end = to_name_end(p, TRUE);",
          "1373:    if (var_end == p)",
          "1374:    {",
          "1375:        semsg(_(e_missing_name_after_imported_name_str),",
          "1376:             var_start);",
          "1377:        return FAIL;",
          "1378:    }",
          "1379:    vim_free(lhs->lhs_name);",
          "1380:    lhs->lhs_varlen = var_end - p;",
          "1381:    lhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);",
          "1382:    if (lhs->lhs_name == NULL)",
          "1383:        return FAIL;",
          "1384:    rawname = lhs->lhs_name;",
          "1390:    lhs->lhs_has_index = lhs->lhs_dest_end",
          "1391:          > skipwhite(var_end);",
          "1392:       }",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1160:     if (tv->v_lock)",
          "1161:  flags |= ASSIGN_CONST;",
          "1162:     save_funccal(&entry);",
          "1164:     restore_funccal();",
          "1165: }",
          "",
          "[Removed Lines]",
          "1163:     set_var_const(name, NULL, tv, FALSE, flags, 0);",
          "",
          "[Added Lines]",
          "1163:     set_var_const(name, 0, NULL, tv, FALSE, flags, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2252:       if (GA_GROW_FAILS(&ectx->ec_stack, 1))",
          "2253:    goto theend;",
          "2254:       SOURCING_LNUM = iptr->isn_lnum;",
          "2256:          STACK_TV_BOT(0), NULL, EVAL_VAR_VERBOSE) == FAIL)",
          "2257:    goto on_error;",
          "2258:       ++ectx->ec_stack.ga_len;",
          "",
          "[Removed Lines]",
          "2255:       if (eval_variable(name, (int)STRLEN(name),",
          "",
          "[Added Lines]",
          "2255:       if (eval_variable(name, (int)STRLEN(name), 0,",
          "",
          "---------------"
        ],
        "src/vim9expr.c||src/vim9expr.c": [
          "File: src/vim9expr.c -> src/vim9expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "240:  cctx_T *cctx,",
          "241:  char_u *name,     // variable NUL terminated",
          "242:  char_u *start,     // start of variable",
          "244:  int    error)     // when TRUE may give error",
          "245: {",
          "246:     scriptitem_T    *si;",
          "",
          "[Removed Lines]",
          "243:  char_u **end,     // end of variable",
          "",
          "[Added Lines]",
          "243:  char_u **end,     // end of variable, may be NULL",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "266:  return OK;",
          "267:     }",
          "270:     if (import != NULL)",
          "271:     {",
          "273:  {",
          "286:      ++p;",
          "301:            cctx, TRUE);",
          "307:      {",
          "314:      }",
          "320:  }",
          "328:  return OK;",
          "329:     }",
          "",
          "[Removed Lines]",
          "269:     import = find_imported(name, 0, cctx);",
          "272:  if (import->imp_flags & IMP_FLAGS_STAR)",
          "274:      char_u *p = skipwhite(*end);",
          "275:      char_u *exp_name;",
          "276:      int  cc;",
          "277:      ufunc_T *ufunc;",
          "278:      type_T *type;",
          "281:      if (*p != '.')",
          "282:      {",
          "283:   semsg(_(e_expected_dot_after_name_str), start);",
          "284:   return FAIL;",
          "285:      }",
          "287:      if (VIM_ISWHITE(*p))",
          "288:      {",
          "289:   emsg(_(e_no_white_space_allowed_after_dot));",
          "290:   return FAIL;",
          "291:      }",
          "294:      exp_name = p;",
          "295:      while (eval_isnamec(*p))",
          "296:   ++p;",
          "297:      cc = *p;",
          "300:      idx = find_exported(import->imp_sid, exp_name, &ufunc, &type,",
          "303:      p = skipwhite(p);",
          "306:      if (idx < 0)",
          "308:   if (*p == '(' && ufunc != NULL)",
          "309:   {",
          "310:       generate_PUSHFUNC(cctx, ufunc->uf_name, import->imp_type);",
          "311:       return OK;",
          "312:   }",
          "313:   return FAIL;",
          "316:      generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "317:       import->imp_sid,",
          "318:       idx,",
          "319:       type);",
          "321:  else if (import->imp_funcname != NULL)",
          "322:      generate_PUSHFUNC(cctx, import->imp_funcname, import->imp_type);",
          "323:  else",
          "324:      generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "325:       import->imp_sid,",
          "326:       import->imp_var_vals_idx,",
          "327:       import->imp_type);",
          "",
          "[Added Lines]",
          "269:     import = end == NULL ? NULL : find_imported(name, 0, cctx);",
          "272:  char_u *p = skipwhite(*end);",
          "273:  char_u *exp_name;",
          "274:  int cc;",
          "275:  ufunc_T *ufunc;",
          "276:  type_T *type;",
          "279:  if (*p != '.')",
          "280:  {",
          "281:      semsg(_(e_expected_dot_after_name_str), start);",
          "282:      return FAIL;",
          "283:  }",
          "284:  ++p;",
          "285:  if (VIM_ISWHITE(*p))",
          "287:      emsg(_(e_no_white_space_allowed_after_dot));",
          "288:      return FAIL;",
          "289:  }",
          "292:  exp_name = p;",
          "293:  while (eval_isnamec(*p))",
          "295:  cc = *p;",
          "298:  idx = find_exported(import->imp_sid, exp_name, &ufunc, &type,",
          "301:  p = skipwhite(p);",
          "304:  if (idx < 0)",
          "305:  {",
          "306:      if (ufunc != NULL)",
          "309:   generate_PUSHFUNC(cctx, ufunc->uf_name, NULL);",
          "310:   return OK;",
          "312:      return FAIL;",
          "315:  generate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,",
          "316:   import->imp_sid,",
          "317:   idx,",
          "318:   type);",
          "",
          "---------------"
        ],
        "src/vim9script.c||src/vim9script.c": [
          "File: src/vim9script.c -> src/vim9script.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "363:  void     *cctx)",
          "364: {",
          "365:     char_u *arg = arg_start;",
          "367:     int  ret = FAIL;",
          "368:     typval_T tv;",
          "369:     int  sid = -1;",
          "370:     int  res;",
          "374:     long start_lnum = SOURCING_LNUM;",
          "472:     if (ret == FAIL)",
          "473:  goto erret;",
          "474:     if (tv.v_type != VAR_STRING",
          "475:          || tv.vval.v_string == NULL || *tv.vval.v_string == NUL)",
          "476:     {",
          "478:  goto erret;",
          "479:     }",
          "483:     SOURCING_LNUM = start_lnum;",
          "",
          "[Removed Lines]",
          "366:     char_u *cmd_end = NULL;",
          "371:     int  mult = FALSE;",
          "372:     garray_T names;",
          "373:     garray_T as_names;",
          "376:     tv.v_type = VAR_UNKNOWN;",
          "377:     ga_init2(&names, sizeof(char_u *), 10);",
          "378:     ga_init2(&as_names, sizeof(char_u *), 10);",
          "379:     if (*arg == '{')",
          "380:     {",
          "382:  mult = TRUE;",
          "383:  arg = skipwhite_and_linebreak(arg + 1, evalarg);",
          "384:     }",
          "386:     for (;;)",
          "387:     {",
          "388:  char_u     *p = arg;",
          "389:  int     had_comma = FALSE;",
          "390:  char_u     *as_name = NULL;",
          "393:  if (!mult && arg[0] == '*' && IS_WHITE_OR_NUL(arg[1]))",
          "394:      ++arg;",
          "395:  else",
          "396:      while (eval_isnamec(*arg))",
          "397:   ++arg;",
          "398:  if (p == arg)",
          "399:      break;",
          "400:  if (ga_grow(&names, 1) == FAIL || ga_grow(&as_names, 1) == FAIL)",
          "401:      goto erret;",
          "402:  ((char_u **)names.ga_data)[names.ga_len] = vim_strnsave(p, arg - p);",
          "403:  ++names.ga_len;",
          "405:  arg = skipwhite_and_linebreak(arg, evalarg);",
          "406:  if (STRNCMP(\"as\", arg, 2) == 0 && IS_WHITE_OR_NUL(arg[2]))",
          "407:  {",
          "410:      arg = skipwhite(arg + 2);",
          "411:      p = arg;",
          "412:      if (eval_isnamec1(*arg))",
          "413:   while (ASCII_ISALNUM(*arg) || *arg == '_')",
          "414:       ++arg;",
          "415:      if (p == arg || !(IS_WHITE_OR_NUL(*arg)",
          "416:       || (mult && (*arg == ',' || *arg == '}'))))",
          "417:      {",
          "418:   semsg(_(e_syntax_error_in_import_str), p);",
          "419:   goto erret;",
          "420:      }",
          "421:      if (check_defined(p, arg - p, cctx, FALSE) == FAIL)",
          "422:   goto erret;",
          "423:      as_name = vim_strnsave(p, arg - p);",
          "424:      arg = skipwhite_and_linebreak(arg, evalarg);",
          "425:  }",
          "426:  else if (*arg_start == '*')",
          "427:  {",
          "428:      emsg(_(e_missing_as_after_star));",
          "429:      goto erret;",
          "430:  }",
          "432:  ((char_u **)as_names.ga_data)[as_names.ga_len] = as_name;",
          "433:  ++as_names.ga_len;",
          "435:  if (!mult)",
          "436:      break;",
          "437:  if (*arg == ',')",
          "438:  {",
          "439:      had_comma = TRUE;",
          "440:      ++arg;",
          "441:  }",
          "442:  arg = skipwhite_and_linebreak(arg, evalarg);",
          "443:  if (*arg == '}')",
          "444:  {",
          "445:      ++arg;",
          "446:      break;",
          "447:  }",
          "448:  if (!had_comma)",
          "449:  {",
          "450:      emsg(_(e_missing_comma_in_import));",
          "451:      goto erret;",
          "452:  }",
          "453:     }",
          "454:     arg = skipwhite_and_linebreak(arg, evalarg);",
          "456:     if (names.ga_len == 0)",
          "457:     {",
          "458:  semsg(_(e_syntax_error_in_import_str), arg_start);",
          "459:  goto erret;",
          "460:     }",
          "462:     if (STRNCMP(\"from\", arg, 4) != 0 || !IS_WHITE_OR_NUL(arg[4]))",
          "463:     {",
          "464:  emsg(_(e_missing_from));",
          "465:  goto erret;",
          "466:     }",
          "470:     arg = skipwhite_and_linebreak(arg + 4, evalarg);",
          "471:     ret = eval0(arg, &tv, NULL, evalarg);",
          "477:  emsg(_(e_invalid_string_after_from));",
          "480:     cmd_end = arg;",
          "",
          "[Added Lines]",
          "366:     char_u *nextarg;",
          "367:     int  getnext;",
          "368:     char_u *expr_end;",
          "370:     char_u *as_name = NULL;",
          "378:     ret = eval0_retarg(arg, &tv, NULL, evalarg, &expr_end);",
          "384:  semsg(_(e_invalid_string_for_import_str), arg);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "532:  goto erret;",
          "533:     }",
          "536:     {",
          "537:  imported_T  *imported;",
          "541:  imported = find_imported(as_name, STRLEN(as_name), cctx);",
          "542:  if (imported != NULL && imported->imp_sid == sid)",
          "543:  {",
          "",
          "[Removed Lines]",
          "535:     if (*arg_start == '*')",
          "538:  char_u     *as_name = ((char_u **)as_names.ga_data)[0];",
          "",
          "[Added Lines]",
          "442:     nextarg = eval_next_non_blank(expr_end, evalarg, &getnext);",
          "443:     if (STRNCMP(\"as\", nextarg, 2) == 0 && IS_WHITE_OR_NUL(nextarg[2]))",
          "444:     {",
          "445:  char_u *p;",
          "447:  if (getnext)",
          "448:      arg = eval_next_line(evalarg);",
          "449:  else",
          "450:      arg = nextarg;",
          "454:  arg = skipwhite(arg + 2);",
          "455:  p = arg;",
          "456:  if (eval_isnamec1(*arg))",
          "457:      while (ASCII_ISALNUM(*arg) || *arg == '_')",
          "458:   ++arg;",
          "459:  if (p == arg || !IS_WHITE_OR_NUL(*arg))",
          "460:  {",
          "461:      semsg(_(e_syntax_error_in_import_str), p);",
          "462:      goto erret;",
          "463:  }",
          "464:  as_name = vim_strnsave(p, arg - p);",
          "465:  arg = skipwhite(arg);",
          "466:     }",
          "467:     else",
          "468:     {",
          "469:  char_u *p = gettail(tv.vval.v_string);",
          "470:  char_u *end = (char_u *)strstr((char *)p, \".vim\");",
          "472:  if (!ends_excmd2(arg_start, expr_end))",
          "473:  {",
          "474:      semsg(_(e_trailing_characters_str), expr_end);",
          "475:      goto erret;",
          "476:  }",
          "478:  if (end == NULL)",
          "479:  {",
          "480:      semsg(_(e_imported_script_must_end_in_dot_vim_str), p);",
          "481:      goto erret;",
          "482:  }",
          "483:  as_name = vim_strnsave(p, end - p);",
          "484:     }",
          "486:     if (as_name != NULL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "550:   goto erret;",
          "551:      }",
          "552:  }",
          "554:  imported = new_imported(gap != NULL ? gap",
          "555:      : &SCRIPT_ITEM(import_sid)->sn_imports);",
          "556:  if (imported == NULL)",
          "557:      goto erret;",
          "558:  imported->imp_name = as_name;",
          "560:  imported->imp_sid = sid;",
          "562:     }",
          "638: erret:",
          "639:     clear_tv(&tv);",
          "643: }",
          "655:     void",
          "656: ex_import(exarg_T *eap)",
          "",
          "[Removed Lines]",
          "559:  ((char_u **)as_names.ga_data)[0] = NULL;",
          "561:  imported->imp_flags = IMP_FLAGS_STAR;",
          "563:     else",
          "564:     {",
          "565:  int i;",
          "567:  arg = arg_start;",
          "568:  if (*arg == '{')",
          "569:      arg = skipwhite(arg + 1);",
          "570:  for (i = 0; i < names.ga_len; ++i)",
          "571:  {",
          "572:      char_u *name = ((char_u **)names.ga_data)[i];",
          "573:      char_u *as_name = ((char_u **)as_names.ga_data)[i];",
          "574:      size_t len = STRLEN(name);",
          "575:      int  idx;",
          "576:      imported_T *imported;",
          "577:      ufunc_T *ufunc = NULL;",
          "578:      type_T *type;",
          "580:      idx = find_exported(sid, name, &ufunc, &type, cctx, TRUE);",
          "582:      if (idx < 0 && ufunc == NULL)",
          "583:   goto erret;",
          "588:      imported = find_imported(name, len, cctx);",
          "589:      if (imported != NULL",
          "590:       && (imported->imp_flags & IMP_FLAGS_RELOAD)",
          "591:       && imported->imp_sid == sid",
          "592:       && (idx >= 0",
          "593:    ? (equal_type(imported->imp_type, type, 0)",
          "594:        && imported->imp_var_vals_idx == idx)",
          "595:    : (equal_type(imported->imp_type, ufunc->uf_func_type,",
          "596:             ETYPE_ARG_UNKNOWN)",
          "597:        && STRCMP(imported->imp_funcname,",
          "598:        ufunc->uf_name) == 0)))",
          "599:      {",
          "600:   imported->imp_flags &= ~IMP_FLAGS_RELOAD;",
          "601:      }",
          "602:      else",
          "603:      {",
          "604:   if (as_name == NULL",
          "605:          && check_defined(name, len, cctx, FALSE) == FAIL)",
          "606:       goto erret;",
          "608:   imported = new_imported(gap != NULL ? gap",
          "609:            : &SCRIPT_ITEM(import_sid)->sn_imports);",
          "610:   if (imported == NULL)",
          "611:       goto erret;",
          "613:   if (as_name == NULL)",
          "614:   {",
          "615:       imported->imp_name = name;",
          "616:       ((char_u **)names.ga_data)[i] = NULL;",
          "617:   }",
          "618:   else",
          "619:   {",
          "621:       imported->imp_name = as_name;",
          "622:       ((char_u **)as_names.ga_data)[i] = NULL;",
          "623:   }",
          "624:   imported->imp_sid = sid;",
          "625:   if (idx >= 0)",
          "626:   {",
          "627:       imported->imp_type = type;",
          "628:       imported->imp_var_vals_idx = idx;",
          "629:   }",
          "630:   else",
          "631:   {",
          "632:       imported->imp_type = ufunc->uf_func_type;",
          "633:       imported->imp_funcname = ufunc->uf_name;",
          "634:   }",
          "635:      }",
          "636:  }",
          "637:     }",
          "640:     ga_clear_strings(&names);",
          "641:     ga_clear_strings(&as_names);",
          "642:     return cmd_end;",
          "",
          "[Added Lines]",
          "502:  else if (check_defined(as_name, STRLEN(as_name), cctx, FALSE) == FAIL)",
          "503:      goto erret;",
          "510:  as_name = NULL;",
          "516:     vim_free(as_name);",
          "517:     return arg;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "807:  init_tv.v_type = VAR_NUMBER;",
          "808:     else",
          "809:  init_tv.v_type = type->tt_type;",
          "812:     vim_free(name);",
          "813:     return p;",
          "",
          "[Removed Lines]",
          "810:     set_var_const(name, type, &init_tv, FALSE, 0, 0);",
          "",
          "[Added Lines]",
          "679:     set_var_const(name, 0, type, &init_tv, FALSE, 0, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "902:     }",
          "903:     else",
          "904:     {",
          "906:     }",
          "907:     if (sv != NULL)",
          "908:     {",
          "",
          "[Removed Lines]",
          "905:  sv = find_typval_in_script(&di->di_tv);",
          "",
          "[Added Lines]",
          "774:  sv = find_typval_in_script(&di->di_tv, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "996:     svar_T *",
          "998: {",
          "1000:     int      idx;",
          "1002:     if (si->sn_version != SCRIPT_VERSION_VIM9)",
          "",
          "[Removed Lines]",
          "997: find_typval_in_script(typval_T *dest)",
          "999:     scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);",
          "",
          "[Added Lines]",
          "867: find_typval_in_script(typval_T *dest, scid_T sid)",
          "869:     scriptitem_T    *si = SCRIPT_ITEM(sid == 0 ? current_sctx.sc_sid : sid);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f8addf1ca1d8c7801f6dded2341b7084d2b93e5e",
      "candidate_info": {
        "commit_hash": "f8addf1ca1d8c7801f6dded2341b7084d2b93e5e",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/f8addf1ca1d8c7801f6dded2341b7084d2b93e5e",
        "files": [
          "src/eval.c",
          "src/testdir/test_vim9_func.vim",
          "src/version.c",
          "src/vim9expr.c"
        ],
        "message": "patch 9.0.0554: using freed memory when command follows lambda\n\nProblem:    Using freed memory when command follows lambda.\nSolution:   Don't free what is still in use. (closes #11201)",
        "before_after_code_files": [
          "src/eval.c||src/eval.c",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/version.c||src/version.c",
          "src/vim9expr.c||src/vim9expr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/eval.c||src/eval.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/eval.c||src/eval.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "382: {",
          "383:     if (evalarg != NULL)",
          "384:     {",
          "386:  {",
          "387:      if (eap != NULL)",
          "388:      {",
          "392:   vim_free(eap->cmdline_tofree);",
          "393:   eap->cmdline_tofree = *eap->cmdlinep;",
          "395:      }",
          "396:      else",
          "397:   vim_free(evalarg->eval_tofree);",
          "398:      evalarg->eval_tofree = NULL;",
          "399:  }",
          "402:  VIM_CLEAR(evalarg->eval_tofree_lambda);",
          "403:     }",
          "404: }",
          "",
          "[Removed Lines]",
          "385:  if (evalarg->eval_tofree != NULL)",
          "401:  ga_clear_strings(&evalarg->eval_tofree_ga);",
          "",
          "[Added Lines]",
          "385:  garray_T *etga = &evalarg->eval_tofree_ga;",
          "387:  if (evalarg->eval_tofree != NULL || evalarg->eval_using_cmdline)",
          "397:   if (evalarg->eval_using_cmdline && etga->ga_len > 0)",
          "398:   {",
          "401:       --etga->ga_len;",
          "403:   }",
          "404:   else",
          "412:  ga_clear_strings(etga);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1515:   v9.CheckDefAndScriptFailure(lines, 'E488: Trailing characters: | echo')",
          "1516: enddef",
          "1518: def Test_pass_legacy_lambda_to_def_func()",
          "1519:   var lines =<< trim END",
          "1520:       vim9script",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1518: def Test_lambda_with_following_cmd()",
          "1519:   var lines =<< trim END",
          "1520:       set ts=2",
          "1521:       var Lambda = () => {",
          "1522:           set ts=4",
          "1523:         } | set ts=3",
          "1524:       assert_equal(3, &ts)",
          "1525:       Lambda()",
          "1526:       assert_equal(4, &ts)",
          "1527:   END",
          "1528:   v9.CheckDefAndScriptSuccess(lines)",
          "1529:   set ts=8",
          "1530: enddef",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "700: static int included_patches[] =",
          "703:     553,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "703:     554,",
          "",
          "---------------"
        ],
        "src/vim9expr.c||src/vim9expr.c": [
          "File: src/vim9expr.c -> src/vim9expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "522:      {",
          "523:   type = lvar.lv_type;",
          "524:   idx = lvar.lv_idx;",
          "527:   if (lvar.lv_from_outer != 0)",
          "528:       gen_load_outer = lvar.lv_from_outer;",
          "529:   else",
          "530:       gen_load = TRUE;",
          "531:      }",
          "",
          "[Removed Lines]",
          "525:   outer_loop_depth = lvar.lv_loop_depth;",
          "526:   outer_loop_idx = lvar.lv_loop_idx;",
          "",
          "[Added Lines]",
          "526:   {",
          "528:       outer_loop_depth = lvar.lv_loop_depth;",
          "529:       outer_loop_idx = lvar.lv_loop_idx;",
          "530:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1098:           + off;",
          "1099:     }",
          "1101:     clear_evalarg(&evalarg, NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1101:  evalarg.eval_using_cmdline = FALSE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "87c1cbbe984e60582f2536e4d3c2ce88cd474bb7",
      "candidate_info": {
        "commit_hash": "87c1cbbe984e60582f2536e4d3c2ce88cd474bb7",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/87c1cbbe984e60582f2536e4d3c2ce88cd474bb7",
        "files": [
          "src/dict.c",
          "src/edit.c",
          "src/eval.c",
          "src/version.c"
        ],
        "message": "patch 9.0.1105: code is indented too much\n\nProblem:    Code is indented too much.\nSolution:   Use an early return. (Yegappan Lakshmanan, closes #11756)",
        "before_after_code_files": [
          "src/dict.c||src/dict.c",
          "src/edit.c||src/edit.c",
          "src/eval.c||src/eval.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/eval.c||src/eval.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/eval.c||src/eval.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/dict.c||src/dict.c": [
          "File: src/dict.c -> src/dict.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1270:  return;",
          "1271:     }",
          "1272:     d2 = argvars[1].vval.v_dict;",
          "1305:      return;",
          "1309:  {",
          "1313:  }",
          "1316:     }",
          "1317: }",
          "",
          "[Removed Lines]",
          "1273:     if ((is_new || !value_check_lock(d1->dv_lock, arg_errmsg, TRUE))",
          "1274:      && d2 != NULL)",
          "1275:     {",
          "1276:  if (is_new)",
          "1277:  {",
          "1278:      d1 = dict_copy(d1, FALSE, TRUE, get_copyID());",
          "1279:      if (d1 == NULL)",
          "1280:   return;",
          "1281:  }",
          "1284:  if (argvars[2].v_type != VAR_UNKNOWN)",
          "1285:  {",
          "1286:      static char *(av[]) = {\"keep\", \"force\", \"error\"};",
          "1288:      action = tv_get_string_chk(&argvars[2]);",
          "1289:      if (action == NULL)",
          "1290:   return;",
          "1291:      for (i = 0; i < 3; ++i)",
          "1292:   if (STRCMP(action, av[i]) == 0)",
          "1293:       break;",
          "1294:      if (i == 3)",
          "1295:      {",
          "1296:   semsg(_(e_invalid_argument_str), action);",
          "1297:   return;",
          "1298:      }",
          "1299:  }",
          "1300:  else",
          "1301:      action = (char_u *)\"force\";",
          "1303:  if (type != NULL && check_typval_arg_type(type, &argvars[1],",
          "1304:         func_name, 2) == FAIL)",
          "1306:  dict_extend(d1, d2, action, func_name);",
          "1308:  if (is_new)",
          "1310:      rettv->v_type = VAR_DICT;",
          "1311:      rettv->vval.v_dict = d1;",
          "1312:      rettv->v_lock = FALSE;",
          "1314:  else",
          "1315:      copy_tv(&argvars[0], rettv);",
          "",
          "[Added Lines]",
          "1273:     if (d2 == NULL)",
          "1274:  return;",
          "1276:     if (!is_new && value_check_lock(d1->dv_lock, arg_errmsg, TRUE))",
          "1277:  return;",
          "1279:     if (is_new)",
          "1280:     {",
          "1281:  d1 = dict_copy(d1, FALSE, TRUE, get_copyID());",
          "1282:  if (d1 == NULL)",
          "1284:     }",
          "1287:     if (argvars[2].v_type != VAR_UNKNOWN)",
          "1288:     {",
          "1289:  static char *(av[]) = {\"keep\", \"force\", \"error\"};",
          "1291:  action = tv_get_string_chk(&argvars[2]);",
          "1292:  if (action == NULL)",
          "1293:      return;",
          "1294:  for (i = 0; i < 3; ++i)",
          "1295:      if (STRCMP(action, av[i]) == 0)",
          "1296:   break;",
          "1297:  if (i == 3)",
          "1299:      semsg(_(e_invalid_argument_str), action);",
          "1300:      return;",
          "1303:     else",
          "1304:  action = (char_u *)\"force\";",
          "1306:     if (type != NULL && check_typval_arg_type(type, &argvars[1],",
          "1307:   func_name, 2) == FAIL)",
          "1308:  return;",
          "1309:     dict_extend(d1, d2, action, func_name);",
          "1311:     if (is_new)",
          "1312:     {",
          "1313:  rettv->v_type = VAR_DICT;",
          "1314:  rettv->vval.v_dict = d1;",
          "1315:  rettv->v_lock = FALSE;",
          "1316:     }",
          "1317:     else",
          "1318:  copy_tv(&argvars[0], rettv);",
          "",
          "---------------"
        ],
        "src/edit.c||src/edit.c": [
          "File: src/edit.c -> src/edit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1664: {",
          "1665:     int     attr;",
          "1678: #ifdef FEAT_RIGHTLEFT",
          "1680:  {",
          "1692:      }",
          "1693:  }",
          "1695: #endif",
          "1709:     }",
          "1710: }",
          "1712: #if defined(FEAT_JOB_CHANNEL) || defined(PROTO)",
          "",
          "[Removed Lines]",
          "1667:     if (ScreenLines != NULL)",
          "1668:     {",
          "1669:  update_topline(); // just in case w_topline isn't valid",
          "1670:  validate_cursor();",
          "1671:  if (highlight)",
          "1672:      attr = HL_ATTR(HLF_8);",
          "1673:  else",
          "1674:      attr = 0;",
          "1675:  pc_row = W_WINROW(curwin) + curwin->w_wrow;",
          "1676:  pc_col = curwin->w_wincol;",
          "1677:  pc_status = PC_STATUS_UNSET;",
          "1679:  if (curwin->w_p_rl)",
          "1681:      pc_col += curwin->w_width - 1 - curwin->w_wcol;",
          "1682:      if (has_mbyte)",
          "1683:      {",
          "1684:   int fix_col = mb_fix_col(pc_col, pc_row);",
          "1686:   if (fix_col != pc_col)",
          "1687:   {",
          "1688:       screen_putchar(' ', pc_row, fix_col, attr);",
          "1689:       --curwin->w_wcol;",
          "1690:       pc_status = PC_STATUS_RIGHT;",
          "1691:   }",
          "1694:  else",
          "1696:  {",
          "1697:      pc_col += curwin->w_wcol;",
          "1698:      if (mb_lefthalve(pc_row, pc_col))",
          "1699:   pc_status = PC_STATUS_LEFT;",
          "1700:  }",
          "1703:  if (pc_status == PC_STATUS_UNSET)",
          "1704:  {",
          "1705:      screen_getbytes(pc_row, pc_col, pc_bytes, &pc_attr);",
          "1706:      pc_status = PC_STATUS_SET;",
          "1707:  }",
          "1708:  screen_putchar(c, pc_row, pc_col, attr);",
          "",
          "[Added Lines]",
          "1667:     if (ScreenLines == NULL)",
          "1668:  return;",
          "1670:     update_topline(); // just in case w_topline isn't valid",
          "1671:     validate_cursor();",
          "1672:     if (highlight)",
          "1673:  attr = HL_ATTR(HLF_8);",
          "1674:     else",
          "1675:  attr = 0;",
          "1676:     pc_row = W_WINROW(curwin) + curwin->w_wrow;",
          "1677:     pc_col = curwin->w_wincol;",
          "1678:     pc_status = PC_STATUS_UNSET;",
          "1680:     if (curwin->w_p_rl)",
          "1681:     {",
          "1682:  pc_col += curwin->w_width - 1 - curwin->w_wcol;",
          "1683:  if (has_mbyte)",
          "1685:      int fix_col = mb_fix_col(pc_col, pc_row);",
          "1687:      if (fix_col != pc_col)",
          "1688:      {",
          "1689:   screen_putchar(' ', pc_row, fix_col, attr);",
          "1690:   --curwin->w_wcol;",
          "1691:   pc_status = PC_STATUS_RIGHT;",
          "1694:     }",
          "1695:     else",
          "1697:     {",
          "1698:  pc_col += curwin->w_wcol;",
          "1699:  if (mb_lefthalve(pc_row, pc_col))",
          "1700:      pc_status = PC_STATUS_LEFT;",
          "1701:     }",
          "1704:     if (pc_status == PC_STATUS_UNSET)",
          "1705:     {",
          "1706:  screen_getbytes(pc_row, pc_col, pc_bytes, &pc_attr);",
          "1707:  pc_status = PC_STATUS_SET;",
          "1709:     screen_putchar(c, pc_row, pc_col, attr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1782:     void",
          "1783: undisplay_dollar(void)",
          "1784: {",
          "1790: }",
          "",
          "[Removed Lines]",
          "1785:     if (dollar_vcol >= 0)",
          "1786:     {",
          "1787:  dollar_vcol = -1;",
          "1788:  redrawWinline(curwin, curwin->w_cursor.lnum);",
          "1789:     }",
          "",
          "[Added Lines]",
          "1785:     if (dollar_vcol < 0)",
          "1786:  return;",
          "1788:     dollar_vcol = -1;",
          "1789:     redrawWinline(curwin, curwin->w_cursor.lnum);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2555:     vim_free(last_insert);",
          "2556:     last_insert = alloc(MB_MAXBYTES * 3 + 5);",
          "2568: }",
          "2570: #if defined(EXITFREE) || defined(PROTO)",
          "",
          "[Removed Lines]",
          "2557:     if (last_insert != NULL)",
          "2558:     {",
          "2559:  s = last_insert;",
          "2561:  if (c < ' ' || c == DEL)",
          "2563:  s = add_char2buf(c, s);",
          "2566:  last_insert_skip = 0;",
          "2567:     }",
          "",
          "[Added Lines]",
          "2557:     if (last_insert == NULL)",
          "2558:  return;",
          "2560:     s = last_insert;",
          "2562:     if (c < ' ' || c == DEL)",
          "2564:     s = add_char2buf(c, s);",
          "2567:     last_insert_skip = 0;",
          "",
          "---------------"
        ],
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128: {",
          "129:     init_evalarg(evalarg);",
          "130:     evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;",
          "132:     {",
          "139:     }",
          "140: }",
          "",
          "[Removed Lines]",
          "131:     if (eap != NULL)",
          "133:  evalarg->eval_cstack = eap->cstack;",
          "134:  if (sourcing_a_script(eap) || eap->getline == get_list_line)",
          "135:  {",
          "136:      evalarg->eval_getline = eap->getline;",
          "137:      evalarg->eval_cookie = eap->cookie;",
          "138:  }",
          "",
          "[Added Lines]",
          "132:     if (eap == NULL)",
          "133:  return;",
          "135:     evalarg->eval_cstack = eap->cstack;",
          "136:     if (sourcing_a_script(eap) || eap->getline == get_list_line)",
          "138:  evalarg->eval_getline = eap->getline;",
          "139:  evalarg->eval_cookie = eap->cookie;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "404:     static void",
          "405: free_eval_tofree_later(evalarg_T *evalarg)",
          "406: {",
          "416: }",
          "",
          "[Removed Lines]",
          "407:     if (evalarg->eval_tofree != NULL)",
          "408:     {",
          "409:  if (ga_grow(&evalarg->eval_tofree_ga, 1) == OK)",
          "410:      ((char_u **)evalarg->eval_tofree_ga.ga_data)",
          "411:   [evalarg->eval_tofree_ga.ga_len++]",
          "412:   = evalarg->eval_tofree;",
          "413:  else",
          "414:      vim_free(evalarg->eval_tofree);",
          "415:     }",
          "",
          "[Added Lines]",
          "408:     if (evalarg->eval_tofree == NULL)",
          "409:  return;",
          "411:     if (ga_grow(&evalarg->eval_tofree_ga, 1) == OK)",
          "412:  ((char_u **)evalarg->eval_tofree_ga.ga_data)",
          "413:      [evalarg->eval_tofree_ga.ga_len++]",
          "414:      = evalarg->eval_tofree;",
          "415:     else",
          "416:  vim_free(evalarg->eval_tofree);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "421:     void",
          "422: clear_evalarg(evalarg_T *evalarg, exarg_T *eap)",
          "423: {",
          "429:  {",
          "448:      }",
          "449:      else",
          "452:  }",
          "456:     }",
          "457: }",
          "",
          "[Removed Lines]",
          "424:     if (evalarg != NULL)",
          "425:     {",
          "426:  garray_T *etga = &evalarg->eval_tofree_ga;",
          "428:  if (evalarg->eval_tofree != NULL || evalarg->eval_using_cmdline)",
          "430:      if (eap != NULL)",
          "431:      {",
          "435:   vim_free(eap->cmdline_tofree);",
          "436:   eap->cmdline_tofree = *eap->cmdlinep;",
          "438:   if (evalarg->eval_using_cmdline && etga->ga_len > 0)",
          "439:   {",
          "442:       --etga->ga_len;",
          "444:       vim_free(evalarg->eval_tofree);",
          "445:   }",
          "446:   else",
          "450:   vim_free(evalarg->eval_tofree);",
          "451:      evalarg->eval_tofree = NULL;",
          "454:  ga_clear_strings(etga);",
          "455:  VIM_CLEAR(evalarg->eval_tofree_lambda);",
          "",
          "[Added Lines]",
          "425:     if (evalarg == NULL)",
          "426:  return;",
          "428:     garray_T *etga = &evalarg->eval_tofree_ga;",
          "430:     if (evalarg->eval_tofree != NULL || evalarg->eval_using_cmdline)",
          "431:     {",
          "432:  if (eap != NULL)",
          "437:      vim_free(eap->cmdline_tofree);",
          "438:      eap->cmdline_tofree = *eap->cmdlinep;",
          "440:      if (evalarg->eval_using_cmdline && etga->ga_len > 0)",
          "441:      {",
          "444:   --etga->ga_len;",
          "446:   vim_free(evalarg->eval_tofree);",
          "451:  else",
          "452:      vim_free(evalarg->eval_tofree);",
          "453:  evalarg->eval_tofree = NULL;",
          "456:     ga_clear_strings(etga);",
          "457:     VIM_CLEAR(evalarg->eval_tofree_lambda);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3219:     blob_T  *b = blob_alloc();",
          "3220:     int     i;",
          "3232: }",
          "",
          "[Removed Lines]",
          "3222:     if (b != NULL)",
          "3223:     {",
          "3224:  for (i = 0; i < blob_len(b1); i++)",
          "3225:      ga_append(&b->bv_ga, blob_get(b1, i));",
          "3226:  for (i = 0; i < blob_len(b2); i++)",
          "3227:      ga_append(&b->bv_ga, blob_get(b2, i));",
          "3229:  clear_tv(tv1);",
          "3230:  rettv_blob_set(tv1, b);",
          "3231:     }",
          "",
          "[Added Lines]",
          "3223:     if (b == NULL)",
          "3224:  return;",
          "3226:     for (i = 0; i < blob_len(b1); i++)",
          "3227:  ga_append(&b->bv_ga, blob_get(b1, i));",
          "3228:     for (i = 0; i < blob_len(b2); i++)",
          "3229:  ga_append(&b->bv_ga, blob_get(b2, i));",
          "3231:     clear_tv(tv1);",
          "3232:     rettv_blob_set(tv1, b);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4818:   || check_for_opt_number_arg(argvars, 2) == FAIL))",
          "4819:  return;",
          "4828: }",
          "",
          "[Removed Lines]",
          "4821:     if (check_can_index(argvars, TRUE, FALSE) == OK)",
          "4822:     {",
          "4823:  copy_tv(argvars, rettv);",
          "4824:  eval_index_inner(rettv, TRUE, argvars + 1,",
          "4825:   argvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,",
          "4826:   TRUE, NULL, 0, FALSE);",
          "4827:     }",
          "",
          "[Added Lines]",
          "4822:     if (check_can_index(argvars, TRUE, FALSE) != OK)",
          "4823:  return;",
          "4825:     copy_tv(argvars, rettv);",
          "4826:     eval_index_inner(rettv, TRUE, argvars + 1,",
          "4827:      argvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,",
          "4828:      TRUE, NULL, 0, FALSE);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5045:     void",
          "5046: partial_unref(partial_T *pt)",
          "5047: {",
          "5071:       break;",
          "5073:  }",
          "5074:     }",
          "5075: }",
          "",
          "[Removed Lines]",
          "5048:     if (pt != NULL)",
          "5049:     {",
          "5050:  int done = FALSE;",
          "5052:  if (--pt->pt_refcount <= 0)",
          "5053:      partial_free(pt);",
          "5057:  else if (pt->pt_refcount == 1)",
          "5058:  {",
          "5061:      if (pt->pt_funcstack != NULL)",
          "5062:   done = funcstack_check_refcount(pt->pt_funcstack);",
          "5064:      if (!done)",
          "5065:      {",
          "5066:   int depth;",
          "5068:   for (depth = 0; depth < MAX_LOOP_DEPTH; ++depth)",
          "5069:       if (pt->pt_loopvars[depth] != NULL",
          "5070:        && loopvars_check_refcount(pt->pt_loopvars[depth]))",
          "5072:      }",
          "",
          "[Added Lines]",
          "5049:     if (pt == NULL)",
          "5050:  return;",
          "5052:     int done = FALSE;",
          "5054:     if (--pt->pt_refcount <= 0)",
          "5055:  partial_free(pt);",
          "5059:     else if (pt->pt_refcount == 1)",
          "5060:     {",
          "5063:  if (pt->pt_funcstack != NULL)",
          "5064:      done = funcstack_check_refcount(pt->pt_funcstack);",
          "5066:  if (!done)",
          "5067:  {",
          "5068:      int depth;",
          "5070:      for (depth = 0; depth < MAX_LOOP_DEPTH; ++depth)",
          "5071:   if (pt->pt_loopvars[depth] != NULL",
          "5072:    && loopvars_check_refcount(pt->pt_loopvars[depth]))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "7225: {",
          "7226:     char_u *p;",
          "7229:     {",
          "7244:     }",
          "7245: }",
          "7247: #endif // FEAT_EVAL",
          "",
          "[Removed Lines]",
          "7228:     if (script_ctx.sc_sid != 0)",
          "7230:  p = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));",
          "7231:  if (p != NULL)",
          "7232:  {",
          "7233:      verbose_enter();",
          "7234:      msg_puts(_(\"\\n\\tLast set from \"));",
          "7235:      msg_puts((char *)p);",
          "7236:      if (script_ctx.sc_lnum > 0)",
          "7237:      {",
          "7238:   msg_puts(_(line_msg));",
          "7239:   msg_outnum((long)script_ctx.sc_lnum);",
          "7240:      }",
          "7241:      verbose_leave();",
          "7242:      vim_free(p);",
          "7243:  }",
          "",
          "[Added Lines]",
          "7229:     if (script_ctx.sc_sid == 0)",
          "7230:  return;",
          "7232:     p = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));",
          "7233:     if (p == NULL)",
          "7234:  return;",
          "7236:     verbose_enter();",
          "7237:     msg_puts(_(\"\\n\\tLast set from \"));",
          "7238:     msg_puts((char *)p);",
          "7239:     if (script_ctx.sc_lnum > 0)",
          "7241:  msg_puts(_(line_msg));",
          "7242:  msg_outnum((long)script_ctx.sc_lnum);",
          "7244:     verbose_leave();",
          "7245:     vim_free(p);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696: static int included_patches[] =",
          "699:     1104,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:     1105,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ef9156b4284e4a52613c36e3d4667245273a28d",
      "candidate_info": {
        "commit_hash": "2ef9156b4284e4a52613c36e3d4667245273a28d",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/2ef9156b4284e4a52613c36e3d4667245273a28d",
        "files": [
          "src/eval.c",
          "src/proto/userfunc.pro",
          "src/structs.h",
          "src/testdir/test_functions.vim",
          "src/testdir/test_vim9_func.vim",
          "src/testdir/test_vim9_script.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9execute.c"
        ],
        "message": "patch 8.2.3783: confusing error for using a variable as a function\n\nProblem:    Confusing error for using a variable as a function.\nSolution:   If a function is not found but there is a variable, give a more\n            useful error. (issue #9310)",
        "before_after_code_files": [
          "src/eval.c||src/eval.c",
          "src/proto/userfunc.pro||src/proto/userfunc.pro",
          "src/structs.h||src/structs.h",
          "src/testdir/test_functions.vim||src/testdir/test_functions.vim",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9execute.c||src/vim9execute.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/eval.c||src/eval.c",
            "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/eval.c||src/eval.c",
            "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1988:     partial_T *partial;",
          "1989:     int  ret = OK;",
          "1990:     type_T *type = NULL;",
          "1992:     if (!evaluate)",
          "1993:  check_vars(s, len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1991:     int  found_var = FALSE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1997:     s = deref_func_name(s, &len, &partial,",
          "",
          "[Removed Lines]",
          "1998:         in_vim9script() ? &type : NULL, !evaluate);",
          "",
          "[Added Lines]",
          "1999:    in_vim9script() ? &type : NULL, !evaluate, &found_var);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2014:  funcexe.partial = partial;",
          "2015:  funcexe.basetv = basetv;",
          "2016:  funcexe.check_type = type;",
          "2017:  ret = get_func_tv(s, len, rettv, arg, evalarg, &funcexe);",
          "2018:     }",
          "2019:     vim_free(s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2018:  funcexe.fe_found_var = found_var;",
          "",
          "---------------"
        ],
        "src/proto/userfunc.pro||src/proto/userfunc.pro": [
          "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: char_u *get_lambda_name(void);",
          "5: char_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state);",
          "6: int get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);",
          "8: void emsg_funcname(char *ermsg, char_u *name);",
          "9: int get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, evalarg_T *evalarg, funcexe_T *funcexe);",
          "10: char_u *fname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error);",
          "",
          "[Removed Lines]",
          "7: char_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, type_T **type, int no_autoload);",
          "",
          "[Added Lines]",
          "7: char_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, type_T **type, int no_autoload, int *found_var);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: int get_callback_depth(void);",
          "31: int call_callback(callback_T *callback, int len, typval_T *rettv, int argcount, typval_T *argvars);",
          "32: varnumber_T call_callback_retnr(callback_T *callback, int argcount, typval_T *argvars);",
          "34: int call_func(char_u *funcname, int len, typval_T *rettv, int argcount_in, typval_T *argvars_in, funcexe_T *funcexe);",
          "35: char_u *printable_func_name(ufunc_T *fp);",
          "36: char_u *trans_function_name(char_u **pp, int *is_global, int skip, int flags, funcdict_T *fdp, partial_T **partial, type_T **type);",
          "",
          "[Removed Lines]",
          "33: void user_func_error(int error, char_u *name);",
          "",
          "[Added Lines]",
          "33: void user_func_error(int error, char_u *name, funcexe_T *funcexe);",
          "",
          "---------------"
        ],
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2001:     dict_T *selfdict; // Dictionary for \"self\"",
          "2002:     typval_T *basetv; // base for base->method()",
          "2003:     type_T *check_type; // type from funcref or NULL",
          "2004: } funcexe_T;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2004:     int  fe_found_var; // if the function is not found then give an",
          "",
          "---------------"
        ],
        "src/testdir/test_functions.vim||src/testdir/test_functions.vim": [
          "File: src/testdir/test_functions.vim -> src/testdir/test_functions.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "2234:   call call(test_null_partial(), [])",
          "2235:   call assert_fails('call test_null_function()()', 'E1192:')",
          "2236:   call assert_fails('call test_null_partial()()', 'E117:')",
          "2237: endfunc",
          "2239: func Test_char2nr()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2238:   let lines =<< trim END",
          "2239:       let Time = 'localtime'",
          "2240:       call Time()",
          "2241:   END",
          "2242:   CheckScriptFailure(lines, 'E1085:')",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1459: def Test_call_funcref()",
          "1460:   g:SomeFunc('abc')->assert_equal(3)",
          "1461:   assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call",
          "1464:   var lines =<< trim END",
          "1465:     vim9script",
          "",
          "[Removed Lines]",
          "1462:   assert_fails('g:NotAFunc()', 'E117:', '', 3, 'Test_call_funcref')",
          "",
          "[Added Lines]",
          "1462:   assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim": [
          "File: src/testdir/test_vim9_script.vim -> src/testdir/test_vim9_script.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1922:   CheckDefAndScriptFailure(lines, 'E1207:', 2)",
          "1923: enddef",
          "1925: def s:RetSome(): string",
          "1926:   return 'some'",
          "1927: enddef",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1925: def Test_vim9script_call_wrong_type()",
          "1926:   var lines =<< trim END",
          "1927:       vim9script",
          "1928:       var Time = 'localtime'",
          "1929:       Time()",
          "1930:   END",
          "1931:   CheckScriptFailure(lines, 'E1085:')",
          "1932: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1551:  int     *lenp,",
          "1552:  partial_T   **partialp,",
          "1553:  type_T     **type,",
          "1555: {",
          "1556:     dictitem_T *v;",
          "1557:     typval_T *tv = NULL;",
          "",
          "[Removed Lines]",
          "1554:  int     no_autoload)",
          "",
          "[Added Lines]",
          "1555:  int     no_autoload,",
          "1556:  int     *found_var)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1610:     if (tv != NULL)",
          "1611:     {",
          "1612:  if (tv->v_type == VAR_FUNC)",
          "1613:  {",
          "1614:      if (tv->vval.v_string == NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1614:  if (found_var != NULL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3201:     void",
          "3203: {",
          "3204:     switch (error)",
          "3205:     {",
          "3206:  case FCERR_UNKNOWN:",
          "3208:   break;",
          "3209:  case FCERR_NOTMETHOD:",
          "3210:   emsg_funcname(",
          "",
          "[Removed Lines]",
          "3202: user_func_error(int error, char_u *name)",
          "3207:   emsg_funcname(e_unknownfunc, name);",
          "",
          "[Added Lines]",
          "3206: user_func_error(int error, char_u *name, funcexe_T *funcexe)",
          "3211:   if (funcexe->fe_found_var)",
          "3212:       semsg(_(e_not_callable_type_str), name);",
          "3213:   else",
          "3214:       emsg_funcname(e_unknownfunc, name);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3449:     if (!aborting())",
          "3450:     {",
          "3452:     }",
          "",
          "[Removed Lines]",
          "3451:  user_func_error(error, (name != NULL) ? name : funcname);",
          "",
          "[Added Lines]",
          "3458:  user_func_error(error, (name != NULL) ? name : funcname, funcexe);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3677:     {",
          "3678:  len = (int)STRLEN(lv.ll_exp_name);",
          "3679:  name = deref_func_name(lv.ll_exp_name, &len, partial, type,",
          "3681:  if (name == lv.ll_exp_name)",
          "3682:      name = NULL;",
          "3683:     }",
          "",
          "[Removed Lines]",
          "3680:            flags & TFN_NO_AUTOLOAD);",
          "",
          "[Added Lines]",
          "3687:       flags & TFN_NO_AUTOLOAD, NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3685:     {",
          "3686:  len = (int)(end - *pp);",
          "3687:  name = deref_func_name(*pp, &len, partial, type,",
          "3689:  if (name == *pp)",
          "3690:      name = NULL;",
          "3691:     }",
          "",
          "[Removed Lines]",
          "3688:             flags & TFN_NO_AUTOLOAD);",
          "",
          "[Added Lines]",
          "3695:       flags & TFN_NO_AUTOLOAD, NULL);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5004:     partial_T *partial = NULL;",
          "5005:     evalarg_T evalarg;",
          "5006:     type_T *type = NULL;",
          "5008:     fill_evalarg_from_eap(&evalarg, eap, eap->skip);",
          "5009:     if (eap->skip)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5014:     int  found_var = FALSE;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5041:     len = (int)STRLEN(tofree);",
          "5042:     name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,",
          "",
          "[Removed Lines]",
          "5043:    in_vim9script() && type == NULL ? &type : NULL, FALSE);",
          "",
          "[Added Lines]",
          "5051:      in_vim9script() && type == NULL ? &type : NULL, FALSE, &found_var);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5096:  funcexe.partial = partial;",
          "5097:  funcexe.selfdict = fudi.fd_dict;",
          "5098:  funcexe.check_type = type;",
          "5099:  rettv.v_type = VAR_UNKNOWN; // clear_tv() uses this",
          "5100:  if (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)",
          "5101:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5107:  funcexe.fe_found_var = found_var;",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "754: static int included_patches[] =",
          "757:     3782,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "757:     3783,",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "891:     if (error != FCERR_NONE)",
          "892:     {",
          "894:  return FAIL;",
          "895:     }",
          "896:     if (did_emsg > did_emsg_before)",
          "",
          "[Removed Lines]",
          "893:  user_func_error(error, ufunc->uf_name);",
          "",
          "[Added Lines]",
          "893:  user_func_error(error, ufunc->uf_name, &funcexe);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2343:       long n = 0;",
          "2344:       char_u *s = NULL;",
          "2345:       char *msg;",
          "2348:       --ectx->ec_stack.ga_len;",
          "2349:       tv = STACK_TV_BOT(0);",
          "",
          "[Removed Lines]",
          "2346:       callback_T cb = {NULL, NULL, 0};",
          "",
          "[Added Lines]",
          "2346:       char_u numbuf[NUMBUFLEN];",
          "2347:       char_u *tofree = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2356:       else if (iptr->isn_type == ISN_STOREFUNCOPT)",
          "2357:       {",
          "2358:    SOURCING_LNUM = iptr->isn_lnum;",
          "2361:    {",
          "2362:        clear_tv(tv);",
          "2364:        goto on_error;",
          "2365:    }",
          "2367:       }",
          "2368:       else",
          "2370:    n = tv->vval.v_number;",
          "2371:       msg = set_option_value(opt_name, n, s, opt_flags);",
          "2372:       clear_tv(tv);",
          "2373:       if (msg != NULL)",
          "2374:       {",
          "2375:    SOURCING_LNUM = iptr->isn_lnum;",
          "2376:    emsg(_(msg));",
          "2377:    goto on_error;",
          "2378:       }",
          "2381:   }",
          "2382:   break;",
          "",
          "[Removed Lines]",
          "2359:    cb = get_callback(tv);",
          "2360:    if (cb.cb_name == NULL || *cb.cb_name == NUL)",
          "2363:        free_callback(&cb);",
          "2366:    s = cb.cb_name;",
          "2379:       if (cb.cb_name != NULL)",
          "2380:    free_callback(&cb);",
          "",
          "[Added Lines]",
          "2364:    s = tv2string(tv, &tofree, numbuf, 0);",
          "2365:    if (s == NULL || *s == NUL)",
          "2376:       vim_free(tofree);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "86fb3f8b99d155fe6bcbb553b5596c3e9fd570a9",
      "candidate_info": {
        "commit_hash": "86fb3f8b99d155fe6bcbb553b5596c3e9fd570a9",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/86fb3f8b99d155fe6bcbb553b5596c3e9fd570a9",
        "files": [
          "src/eval.c",
          "src/version.c"
        ],
        "message": "patch 9.0.0556: leaking memory with nested functions\n\nProblem:    Leaking memory with nested functions.\nSolution:   Free saved pointer.",
        "before_after_code_files": [
          "src/eval.c||src/eval.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/eval.c||src/eval.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/eval.c||src/eval.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "401:       --etga->ga_len;",
          "403:   }",
          "404:   else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "403:       vim_free(evalarg->eval_tofree);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "700: static int included_patches[] =",
          "703:     555,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "703:     556,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
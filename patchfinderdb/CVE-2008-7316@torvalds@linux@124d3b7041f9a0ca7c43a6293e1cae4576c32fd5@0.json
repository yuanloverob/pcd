{
  "cve_id": "CVE-2008-7316",
  "cve_desc": "mm/filemap.c in the Linux kernel before 2.6.25 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers an iovec of zero length, followed by a page fault for an iovec of nonzero length.",
  "repo": "torvalds/linux",
  "patch_hash": "124d3b7041f9a0ca7c43a6293e1cae4576c32fd5",
  "patch_info": {
    "commit_hash": "124d3b7041f9a0ca7c43a6293e1cae4576c32fd5",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5",
    "files": [
      "mm/filemap.c"
    ],
    "message": "fix writev regression: pan hanging unkillable and un-straceable\n\nFrederik Himpe reported an unkillable and un-straceable pan process.\n\nZero length iovecs can go into an infinite loop in writev, because the\niovec iterator does not always advance over them.\n\nThe sequence required to trigger this is not trivial. I think it\nrequires that a zero-length iovec be followed by a non-zero-length iovec\nwhich causes a pagefault in the atomic usercopy. This causes the writev\ncode to drop back into single-segment copy mode, which then tries to\ncopy the 0 bytes of the zero-length iovec; a zero length copy looks like\na failure though, so it loops.\n\nPut a test into iov_iter_advance to catch zero-length iovecs. We could\njust put the test in the fallback path, but I feel it is more robust to\nskip over zero-length iovecs throughout the code (iovec iterator may be\nused in filesystems too, so it should be robust).\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/filemap.c||mm/filemap.c"
    ]
  },
  "patch_diff": {
    "mm/filemap.c||mm/filemap.c": [
      "File: mm/filemap.c -> mm/filemap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1750:   const struct iovec *iov = i->iov;",
      "1751:   size_t base = i->iov_offset;",
      "1754:    int copy = min(bytes, iov->iov_len - base);",
      "1756:    bytes -= copy;",
      "",
      "[Removed Lines]",
      "1753:   while (bytes) {",
      "",
      "[Added Lines]",
      "1757:   while (bytes || !iov->iov_len) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2269:   cond_resched();",
      "2271:   if (unlikely(copied == 0)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2275:   iov_iter_advance(i, copied);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2281:       iov_iter_single_seg_count(i));",
      "2282:    goto again;",
      "2283:   }",
      "2285:   pos += copied;",
      "2286:   written += copied;",
      "",
      "[Removed Lines]",
      "2284:   iov_iter_advance(i, copied);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f7009264c519603b8ec67c881bd368a56703cfc9",
      "candidate_info": {
        "commit_hash": "f7009264c519603b8ec67c881bd368a56703cfc9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f7009264c519603b8ec67c881bd368a56703cfc9",
        "files": [
          "mm/filemap.c"
        ],
        "message": "iov_iter_advance() fix\n\niov_iter_advance() skips over zero-length iovecs, however it does not properly\nterminate at the end of the iovec array.  Fix this by checking against\ni->count before we skip a zero-length iov.\n\nThe bug was reproduced with a test program that continually randomly creates\niovs to writev.  The fix was also verified with the same program and also it\ncould verify that the correct data was contained in the file after each\nwritev.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nTested-by: \"Kevin Coffman\" <kwc@citi.umich.edu>\nCc: \"Alexey Dobriyan\" <adobriyan@gmail.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/filemap.c||mm/filemap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/filemap.c||mm/filemap.c"
          ],
          "candidate": [
            "mm/filemap.c||mm/filemap.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/filemap.c||mm/filemap.c": [
          "File: mm/filemap.c -> mm/filemap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1742: }",
          "1743: EXPORT_SYMBOL(iov_iter_copy_from_user);",
          "1746: {",
          "1747:  if (likely(i->nr_segs == 1)) {",
          "1748:   i->iov_offset += bytes;",
          "1749:  } else {",
          "1750:   const struct iovec *iov = i->iov;",
          "1751:   size_t base = i->iov_offset;",
          "1760:    bytes -= copy;",
          "1761:    base += copy;",
          "1762:    if (iov->iov_len == base) {",
          "",
          "[Removed Lines]",
          "1745: static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)",
          "1757:   while (bytes || !iov->iov_len) {",
          "1758:    int copy = min(bytes, iov->iov_len - base);",
          "",
          "[Added Lines]",
          "1745: void iov_iter_advance(struct iov_iter *i, size_t bytes)",
          "1747:  BUG_ON(i->count < bytes);",
          "1751:   i->count -= bytes;",
          "1760:   while (bytes || unlikely(!iov->iov_len && i->count)) {",
          "1761:    int copy;",
          "1763:    copy = min(bytes, iov->iov_len - base);",
          "1764:    BUG_ON(!i->count || i->count < copy);",
          "1765:    i->count -= copy;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1768:   i->iov_offset = base;",
          "1769:  }",
          "1770: }",
          "1779: EXPORT_SYMBOL(iov_iter_advance);",
          "",
          "[Removed Lines]",
          "1772: void iov_iter_advance(struct iov_iter *i, size_t bytes)",
          "1773: {",
          "1774:  BUG_ON(i->count < bytes);",
          "1776:  __iov_iter_advance_iov(i, bytes);",
          "1777:  i->count -= bytes;",
          "1778: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94ad374a0751f40d25e22e036c37f7263569d24c",
      "candidate_info": {
        "commit_hash": "94ad374a0751f40d25e22e036c37f7263569d24c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/94ad374a0751f40d25e22e036c37f7263569d24c",
        "files": [
          "mm/filemap.c"
        ],
        "message": "Fix off-by-one error in iov_iter_advance()\n\nThe iov_iter_advance() function would look at the iov->iov_len entry\neven though it might have iterated over the whole array, and iov was\npointing past the end.  This would cause DEBUG_PAGEALLOC to trigger a\nkernel page fault if the allocation was at the end of a page, and the\nnext page was unallocated.\n\nThe quick fix is to just change the order of the tests: check that there\nis any iovec data left before we check the iov entry itself.\n\nThanks to Alexey Dobriyan for finding this case, and testing the fix.\n\nReported-and-tested-by: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Nick Piggin <npiggin@suse.de>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: <stable@kernel.org> [2.6.25.x, 2.6.26.x]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/filemap.c||mm/filemap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/filemap.c||mm/filemap.c"
          ],
          "candidate": [
            "mm/filemap.c||mm/filemap.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/filemap.c||mm/filemap.c": [
          "File: mm/filemap.c -> mm/filemap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1883:    int copy;",
          "1885:    copy = min(bytes, iov->iov_len - base);",
          "",
          "[Removed Lines]",
          "1882:   while (bytes || unlikely(!iov->iov_len && i->count)) {",
          "",
          "[Added Lines]",
          "1882:   while (bytes || unlikely(i->count && !iov->iov_len)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "afddba49d18f346e5cc2938b6ed7c512db18ca68",
      "candidate_info": {
        "commit_hash": "afddba49d18f346e5cc2938b6ed7c512db18ca68",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/afddba49d18f346e5cc2938b6ed7c512db18ca68",
        "files": [
          "Documentation/filesystems/Locking",
          "Documentation/filesystems/vfs.txt",
          "drivers/block/loop.c",
          "fs/buffer.c",
          "fs/libfs.c",
          "fs/namei.c",
          "fs/splice.c",
          "include/linux/buffer_head.h",
          "include/linux/fs.h",
          "include/linux/pagemap.h",
          "mm/filemap.c"
        ],
        "message": "fs: introduce write_begin, write_end, and perform_write aops\n\nThese are intended to replace prepare_write and commit_write with more\nflexible alternatives that are also able to avoid the buffered write\ndeadlock problems efficiently (which prepare_write is unable to do).\n\n[mark.fasheh@oracle.com: API design contributions, code review and fixes]\n[akpm@linux-foundation.org: various fixes]\n[dmonakhov@sw.ru: new aop block_write_begin fix]\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nSigned-off-by: Mark Fasheh <mark.fasheh@oracle.com>\nSigned-off-by: Dmitriy Monakhov <dmonakhov@openvz.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "drivers/block/loop.c||drivers/block/loop.c",
          "fs/buffer.c||fs/buffer.c",
          "fs/libfs.c||fs/libfs.c",
          "fs/namei.c||fs/namei.c",
          "fs/splice.c||fs/splice.c",
          "include/linux/buffer_head.h||include/linux/buffer_head.h",
          "include/linux/fs.h||include/linux/fs.h",
          "include/linux/pagemap.h||include/linux/pagemap.h",
          "mm/filemap.c||mm/filemap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/filemap.c||mm/filemap.c"
          ],
          "candidate": [
            "mm/filemap.c||mm/filemap.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/block/loop.c||drivers/block/loop.c": [
          "File: drivers/block/loop.c -> drivers/block/loop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "209: static int do_lo_send_aops(struct loop_device *lo, struct bio_vec *bvec,",
          "211: {",
          "213:  struct address_space *mapping = file->f_mapping;",
          "215:  pgoff_t index;",
          "216:  unsigned offset, bv_offs;",
          "217:  int len, ret;",
          "",
          "[Removed Lines]",
          "210:   int bsize, loff_t pos, struct page *page)",
          "214:  const struct address_space_operations *aops = mapping->a_ops;",
          "",
          "[Added Lines]",
          "210:   int bsize, loff_t pos, struct page *unused)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:  len = bvec->bv_len;",
          "224:  while (len > 0) {",
          "225:   sector_t IV;",
          "227:   int transfer_result;",
          "229:   IV = ((sector_t)index << (PAGE_CACHE_SHIFT - 9))+(offset >> 9);",
          "230:   size = PAGE_CACHE_SIZE - offset;",
          "231:   if (size > len)",
          "232:    size = len;",
          "235:    goto fail;",
          "245:   transfer_result = lo_do_transfer(lo, WRITE, page, offset,",
          "246:     bvec->bv_page, bv_offs, size, IV);",
          "266:   if (unlikely(transfer_result))",
          "270:   offset = 0;",
          "271:   index++;",
          "275:  }",
          "276:  ret = 0;",
          "277: out:",
          "278:  mutex_unlock(&mapping->host->i_mutex);",
          "279:  return ret;",
          "283: fail:",
          "284:  ret = -1;",
          "285:  goto out;",
          "",
          "[Removed Lines]",
          "226:   unsigned size;",
          "233:   page = grab_cache_page(mapping, index);",
          "234:   if (unlikely(!page))",
          "236:   ret = aops->prepare_write(file, page, offset,",
          "237:        offset + size);",
          "238:   if (unlikely(ret)) {",
          "239:    if (ret == AOP_TRUNCATED_PAGE) {",
          "240:     page_cache_release(page);",
          "241:     continue;",
          "242:    }",
          "243:    goto unlock;",
          "244:   }",
          "247:   if (unlikely(transfer_result)) {",
          "252:    printk(KERN_ERR \"loop: transfer error block %llu\\n\",",
          "253:           (unsigned long long)index);",
          "254:    zero_user_page(page, offset, size, KM_USER0);",
          "255:   }",
          "256:   flush_dcache_page(page);",
          "257:   ret = aops->commit_write(file, page, offset,",
          "258:       offset + size);",
          "259:   if (unlikely(ret)) {",
          "260:    if (ret == AOP_TRUNCATED_PAGE) {",
          "261:     page_cache_release(page);",
          "262:     continue;",
          "263:    }",
          "264:    goto unlock;",
          "265:   }",
          "267:    goto unlock;",
          "268:   bv_offs += size;",
          "269:   len -= size;",
          "272:   pos += size;",
          "273:   unlock_page(page);",
          "274:   page_cache_release(page);",
          "280: unlock:",
          "281:  unlock_page(page);",
          "282:  page_cache_release(page);",
          "",
          "[Added Lines]",
          "225:   unsigned size, copied;",
          "227:   struct page *page;",
          "228:   void *fsdata;",
          "235:   ret = pagecache_write_begin(file, mapping, pos, size, 0,",
          "236:        &page, &fsdata);",
          "237:   if (ret)",
          "242:   copied = size;",
          "244:    copied = 0;",
          "246:   ret = pagecache_write_end(file, mapping, pos, size, copied,",
          "247:        page, fsdata);",
          "248:   if (ret < 0)",
          "249:    goto fail;",
          "250:   if (ret < copied)",
          "251:    copied = ret;",
          "253:   if (unlikely(transfer_result))",
          "254:    goto fail;",
          "256:   bv_offs += copied;",
          "257:   len -= copied;",
          "260:   pos += copied;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "781:   if (!file->f_op->splice_read)",
          "782:    goto out_putf;",
          "784:    lo_flags |= LO_FLAGS_USE_AOPS;",
          "785:   if (!(lo_flags & LO_FLAGS_USE_AOPS) && !file->f_op->write)",
          "786:    lo_flags |= LO_FLAGS_READ_ONLY;",
          "",
          "[Removed Lines]",
          "783:   if (aops->prepare_write && aops->commit_write)",
          "",
          "[Added Lines]",
          "766:   if (aops->prepare_write || aops->write_begin)",
          "",
          "---------------"
        ],
        "fs/buffer.c||fs/buffer.c": [
          "File: fs/buffer.c -> fs/buffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1770:  goto done;",
          "1771: }",
          "1773: static int __block_prepare_write(struct inode *inode, struct page *page,",
          "1774:   unsigned from, unsigned to, get_block_t *get_block)",
          "1775: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1778: void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)",
          "1779: {",
          "1780:  unsigned int block_start, block_end;",
          "1781:  struct buffer_head *head, *bh;",
          "1783:  BUG_ON(!PageLocked(page));",
          "1784:  if (!page_has_buffers(page))",
          "1785:   return;",
          "1787:  bh = head = page_buffers(page);",
          "1788:  block_start = 0;",
          "1789:  do {",
          "1790:   block_end = block_start + bh->b_size;",
          "1792:   if (buffer_new(bh)) {",
          "1793:    if (block_end > from && block_start < to) {",
          "1794:     if (!PageUptodate(page)) {",
          "1795:      unsigned start, size;",
          "1797:      start = max(from, block_start);",
          "1798:      size = min(to, block_end) - start;",
          "1800:      zero_user_page(page, start, size, KM_USER0);",
          "1801:      set_buffer_uptodate(bh);",
          "1802:     }",
          "1804:     clear_buffer_new(bh);",
          "1805:     mark_buffer_dirty(bh);",
          "1806:    }",
          "1807:   }",
          "1809:   block_start = block_end;",
          "1810:   bh = bh->b_this_page;",
          "1811:  } while (bh != head);",
          "1812: }",
          "1813: EXPORT_SYMBOL(page_zero_new_buffers);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1854:   if (!buffer_uptodate(*wait_bh))",
          "1855:    err = -EIO;",
          "1856:  }",
          "1889:  return err;",
          "1890: }",
          "",
          "[Removed Lines]",
          "1857:  if (!err) {",
          "1858:   bh = head;",
          "1859:   do {",
          "1860:    if (buffer_new(bh))",
          "1861:     clear_buffer_new(bh);",
          "1862:   } while ((bh = bh->b_this_page) != head);",
          "1863:   return 0;",
          "1864:  }",
          "1871:  bh = head;",
          "1872:  block_start = 0;",
          "1873:  do {",
          "1874:   block_end = block_start+blocksize;",
          "1875:   if (block_end <= from)",
          "1876:    goto next_bh;",
          "1877:   if (block_start >= to)",
          "1878:    break;",
          "1879:   if (buffer_new(bh)) {",
          "1880:    clear_buffer_new(bh);",
          "1881:    zero_user_page(page, block_start, bh->b_size, KM_USER0);",
          "1882:    set_buffer_uptodate(bh);",
          "1883:    mark_buffer_dirty(bh);",
          "1884:   }",
          "1885: next_bh:",
          "1886:   block_start = block_end;",
          "1887:   bh = bh->b_this_page;",
          "1888:  } while (bh != head);",
          "",
          "[Added Lines]",
          "1899:  if (unlikely(err))",
          "1900:   page_zero_new_buffers(page, from, to);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1910:    set_buffer_uptodate(bh);",
          "1911:    mark_buffer_dirty(bh);",
          "1912:   }",
          "1913:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1925:   clear_buffer_new(bh);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1923:  return 0;",
          "1924: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1947: int block_write_begin(struct file *file, struct address_space *mapping,",
          "1948:    loff_t pos, unsigned len, unsigned flags,",
          "1949:    struct page **pagep, void **fsdata,",
          "1950:    get_block_t *get_block)",
          "1951: {",
          "1952:  struct inode *inode = mapping->host;",
          "1953:  int status = 0;",
          "1954:  struct page *page;",
          "1955:  pgoff_t index;",
          "1956:  unsigned start, end;",
          "1957:  int ownpage = 0;",
          "1959:  index = pos >> PAGE_CACHE_SHIFT;",
          "1960:  start = pos & (PAGE_CACHE_SIZE - 1);",
          "1961:  end = start + len;",
          "1963:  page = *pagep;",
          "1964:  if (page == NULL) {",
          "1965:   ownpage = 1;",
          "1966:   page = __grab_cache_page(mapping, index);",
          "1967:   if (!page) {",
          "1968:    status = -ENOMEM;",
          "1969:    goto out;",
          "1970:   }",
          "1972:  } else",
          "1973:   BUG_ON(!PageLocked(page));",
          "1975:  status = __block_prepare_write(inode, page, start, end, get_block);",
          "1976:  if (unlikely(status)) {",
          "1977:   ClearPageUptodate(page);",
          "1979:   if (ownpage) {",
          "1980:    unlock_page(page);",
          "1981:    page_cache_release(page);",
          "1989:    if (pos + len > inode->i_size)",
          "1990:     vmtruncate(inode, inode->i_size);",
          "1991:   }",
          "1992:   goto out;",
          "1993:  }",
          "1995: out:",
          "1996:  return status;",
          "1997: }",
          "1998: EXPORT_SYMBOL(block_write_begin);",
          "2000: int block_write_end(struct file *file, struct address_space *mapping,",
          "2001:    loff_t pos, unsigned len, unsigned copied,",
          "2002:    struct page *page, void *fsdata)",
          "2003: {",
          "2004:  struct inode *inode = mapping->host;",
          "2005:  unsigned start;",
          "2007:  start = pos & (PAGE_CACHE_SIZE - 1);",
          "2009:  if (unlikely(copied < len)) {",
          "2022:   if (!PageUptodate(page))",
          "2023:    copied = 0;",
          "2025:   page_zero_new_buffers(page, start+copied, start+len);",
          "2026:  }",
          "2027:  flush_dcache_page(page);",
          "2030:  __block_commit_write(inode, page, start, start+copied);",
          "2032:  return copied;",
          "2033: }",
          "2034: EXPORT_SYMBOL(block_write_end);",
          "2036: int generic_write_end(struct file *file, struct address_space *mapping,",
          "2037:    loff_t pos, unsigned len, unsigned copied,",
          "2038:    struct page *page, void *fsdata)",
          "2039: {",
          "2040:  struct inode *inode = mapping->host;",
          "2042:  copied = block_write_end(file, mapping, pos, len, copied, page, fsdata);",
          "2051:  if (pos+copied > inode->i_size) {",
          "2052:   i_size_write(inode, pos+copied);",
          "2053:   mark_inode_dirty(inode);",
          "2054:  }",
          "2056:  unlock_page(page);",
          "2057:  page_cache_release(page);",
          "2059:  return copied;",
          "2060: }",
          "2061: EXPORT_SYMBOL(generic_write_end);",
          "",
          "---------------"
        ],
        "fs/libfs.c||fs/libfs.c": [
          "File: fs/libfs.c -> fs/libfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "351:  return 0;",
          "352: }",
          "354: int simple_commit_write(struct file *file, struct page *page,",
          "355:    unsigned from, unsigned to)",
          "356: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "354: int simple_write_begin(struct file *file, struct address_space *mapping,",
          "355:    loff_t pos, unsigned len, unsigned flags,",
          "356:    struct page **pagep, void **fsdata)",
          "357: {",
          "358:  struct page *page;",
          "359:  pgoff_t index;",
          "360:  unsigned from;",
          "362:  index = pos >> PAGE_CACHE_SHIFT;",
          "363:  from = pos & (PAGE_CACHE_SIZE - 1);",
          "365:  page = __grab_cache_page(mapping, index);",
          "366:  if (!page)",
          "367:   return -ENOMEM;",
          "371:  return simple_prepare_write(file, page, from, from+len);",
          "372: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "369:  return 0;",
          "370: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "392: int simple_write_end(struct file *file, struct address_space *mapping,",
          "393:    loff_t pos, unsigned len, unsigned copied,",
          "394:    struct page *page, void *fsdata)",
          "395: {",
          "396:  unsigned from = pos & (PAGE_CACHE_SIZE - 1);",
          "399:  if (copied < len) {",
          "400:   void *kaddr = kmap_atomic(page, KM_USER0);",
          "401:   memset(kaddr + from + copied, 0, len - copied);",
          "402:   flush_dcache_page(page);",
          "403:   kunmap_atomic(kaddr, KM_USER0);",
          "404:  }",
          "406:  simple_commit_write(file, page, from, from+copied);",
          "408:  unlock_page(page);",
          "409:  page_cache_release(page);",
          "411:  return copied;",
          "412: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "642: EXPORT_SYMBOL(dcache_readdir);",
          "643: EXPORT_SYMBOL(generic_read_dir);",
          "644: EXPORT_SYMBOL(get_sb_pseudo);",
          "645: EXPORT_SYMBOL(simple_commit_write);",
          "646: EXPORT_SYMBOL(simple_dir_inode_operations);",
          "647: EXPORT_SYMBOL(simple_dir_operations);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "687: EXPORT_SYMBOL(simple_write_begin);",
          "688: EXPORT_SYMBOL(simple_write_end);",
          "",
          "---------------"
        ],
        "fs/namei.c||fs/namei.c": [
          "File: fs/namei.c -> fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2729: {",
          "2730:  struct address_space *mapping = inode->i_mapping;",
          "2731:  struct page *page;",
          "2732:  int err;",
          "2733:  char *kaddr;",
          "2735: retry:",
          "2745:  if (err)",
          "2747:  kaddr = kmap_atomic(page, KM_USER0);",
          "2748:  memcpy(kaddr, symname, len-1);",
          "2749:  kunmap_atomic(kaddr, KM_USER0);",
          "2772:  if (err < 0)",
          "2773:   goto fail;",
          "2774:  mark_inode_dirty(inode);",
          "2775:  return 0;",
          "2779: fail:",
          "2780:  return err;",
          "2781: }",
          "",
          "[Removed Lines]",
          "2736:  err = -ENOMEM;",
          "2737:  page = find_or_create_page(mapping, 0, gfp_mask);",
          "2738:  if (!page)",
          "2739:   goto fail;",
          "2740:  err = mapping->a_ops->prepare_write(NULL, page, 0, len-1);",
          "2741:  if (err == AOP_TRUNCATED_PAGE) {",
          "2742:   page_cache_release(page);",
          "2743:   goto retry;",
          "2744:  }",
          "2746:   goto fail_map;",
          "2750:  err = mapping->a_ops->commit_write(NULL, page, 0, len-1);",
          "2751:  if (err == AOP_TRUNCATED_PAGE) {",
          "2752:   page_cache_release(page);",
          "2753:   goto retry;",
          "2754:  }",
          "2755:  if (err)",
          "2756:   goto fail_map;",
          "2764:  if (!PageUptodate(page)) {",
          "2765:   err = mapping->a_ops->readpage(NULL, page);",
          "2766:   if (err != AOP_TRUNCATED_PAGE)",
          "2767:    wait_on_page_locked(page);",
          "2768:  } else {",
          "2769:   unlock_page(page);",
          "2770:  }",
          "2771:  page_cache_release(page);",
          "2776: fail_map:",
          "2777:  unlock_page(page);",
          "2778:  page_cache_release(page);",
          "",
          "[Added Lines]",
          "2732:  void *fsdata;",
          "2737:  err = pagecache_write_begin(NULL, mapping, 0, len-1,",
          "2738:     AOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);",
          "2740:   goto fail;",
          "2746:  err = pagecache_write_end(NULL, mapping, 0, len-1, len-1,",
          "2747:        page, fsdata);",
          "2750:  if (err < len-1)",
          "2751:   goto retry;",
          "",
          "---------------"
        ],
        "fs/splice.c||fs/splice.c": [
          "File: fs/splice.c -> fs/splice.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "563:  struct address_space *mapping = file->f_mapping;",
          "564:  unsigned int offset, this_len;",
          "565:  struct page *page;",
          "567:  int ret;",
          "",
          "[Removed Lines]",
          "566:  pgoff_t index;",
          "",
          "[Added Lines]",
          "566:  void *fsdata;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "573:  if (unlikely(ret))",
          "574:   return ret;",
          "577:  offset = sd->pos & ~PAGE_CACHE_MASK;",
          "579:  this_len = sd->len;",
          "580:  if (this_len + offset > PAGE_CACHE_SIZE)",
          "581:   this_len = PAGE_CACHE_SIZE - offset;",
          "620:  if (buf->page != page) {",
          "",
          "[Removed Lines]",
          "576:  index = sd->pos >> PAGE_CACHE_SHIFT;",
          "583: find_page:",
          "584:  page = find_lock_page(mapping, index);",
          "585:  if (!page) {",
          "586:   ret = -ENOMEM;",
          "587:   page = page_cache_alloc_cold(mapping);",
          "588:   if (unlikely(!page))",
          "589:    goto out_ret;",
          "594:   ret = add_to_page_cache_lru(page, mapping, index,",
          "595:          GFP_KERNEL);",
          "596:   if (unlikely(ret))",
          "597:    goto out_release;",
          "598:  }",
          "600:  ret = mapping->a_ops->prepare_write(file, page, offset, offset+this_len);",
          "601:  if (unlikely(ret)) {",
          "602:   loff_t isize = i_size_read(mapping->host);",
          "604:   if (ret != AOP_TRUNCATED_PAGE)",
          "605:    unlock_page(page);",
          "606:   page_cache_release(page);",
          "607:   if (ret == AOP_TRUNCATED_PAGE)",
          "608:    goto find_page;",
          "614:   if (sd->pos + this_len > isize)",
          "615:    vmtruncate(mapping->host, isize);",
          "617:   goto out_ret;",
          "618:  }",
          "",
          "[Added Lines]",
          "582:  ret = pagecache_write_begin(file, mapping, sd->pos, this_len,",
          "583:     AOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);",
          "584:  if (unlikely(ret))",
          "585:   goto out;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "629:   kunmap_atomic(dst, KM_USER1);",
          "630:   buf->ops->unmap(pipe, buf, src);",
          "631:  }",
          "652: out:",
          "657:  return ret;",
          "658: }",
          "",
          "[Removed Lines]",
          "633:  ret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);",
          "634:  if (ret) {",
          "635:   if (ret == AOP_TRUNCATED_PAGE) {",
          "636:    page_cache_release(page);",
          "637:    goto find_page;",
          "638:   }",
          "639:   if (ret < 0)",
          "640:    goto out;",
          "645:  } else",
          "646:   ret = this_len;",
          "651:  mark_page_accessed(page);",
          "653:  unlock_page(page);",
          "654: out_release:",
          "655:  page_cache_release(page);",
          "656: out_ret:",
          "",
          "[Added Lines]",
          "599:  ret = pagecache_write_end(file, mapping, sd->pos, this_len, this_len,",
          "600:     page, fsdata);",
          "",
          "---------------"
        ],
        "include/linux/buffer_head.h||include/linux/buffer_head.h": [
          "File: include/linux/buffer_head.h -> include/linux/buffer_head.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "203: int block_write_full_page(struct page *page, get_block_t *get_block,",
          "204:     struct writeback_control *wbc);",
          "205: int block_read_full_page(struct page*, get_block_t*);",
          "206: int block_prepare_write(struct page*, unsigned, unsigned, get_block_t*);",
          "207: int cont_prepare_write(struct page*, unsigned, unsigned, get_block_t*,",
          "208:     loff_t *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206: int block_write_begin(struct file *, struct address_space *,",
          "207:     loff_t, unsigned, unsigned,",
          "208:     struct page **, void **, get_block_t*);",
          "209: int block_write_end(struct file *, struct address_space *,",
          "210:     loff_t, unsigned, unsigned,",
          "211:     struct page *, void *);",
          "212: int generic_write_end(struct file *, struct address_space *,",
          "213:     loff_t, unsigned, unsigned,",
          "214:     struct page *, void *);",
          "215: void page_zero_new_buffers(struct page *page, unsigned from, unsigned to);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "413: size_t iov_iter_copy_from_user(struct page *page,",
          "414:   struct iov_iter *i, unsigned long offset, size_t bytes);",
          "415: void iov_iter_advance(struct iov_iter *i, size_t bytes);",
          "417: size_t iov_iter_single_seg_count(struct iov_iter *i);",
          "419: static inline void iov_iter_init(struct iov_iter *i,",
          "",
          "[Removed Lines]",
          "416: int iov_iter_fault_in_readable(struct iov_iter *i);",
          "",
          "[Added Lines]",
          "418: int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "455:  int (*prepare_write)(struct file *, struct page *, unsigned, unsigned);",
          "456:  int (*commit_write)(struct file *, struct page *, unsigned, unsigned);",
          "458:  sector_t (*bmap)(struct address_space *, sector_t);",
          "459:  void (*invalidatepage) (struct page *, unsigned long);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "460:  int (*write_begin)(struct file *, struct address_space *mapping,",
          "461:     loff_t pos, unsigned len, unsigned flags,",
          "462:     struct page **pagep, void **fsdata);",
          "463:  int (*write_end)(struct file *, struct address_space *mapping,",
          "464:     loff_t pos, unsigned len, unsigned copied,",
          "465:     struct page *page, void *fsdata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "468:  int (*launder_page) (struct page *);",
          "469: };",
          "471: struct backing_dev_info;",
          "472: struct address_space {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "485: int pagecache_write_begin(struct file *, struct address_space *mapping,",
          "486:     loff_t pos, unsigned len, unsigned flags,",
          "487:     struct page **pagep, void **fsdata);",
          "489: int pagecache_write_end(struct file *, struct address_space *mapping,",
          "490:     loff_t pos, unsigned len, unsigned copied,",
          "491:     struct page *page, void *fsdata);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1866:    unsigned offset, unsigned to);",
          "1867: extern int simple_commit_write(struct file *file, struct page *page,",
          "1868:     unsigned offset, unsigned to);",
          "1870: extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);",
          "1871: extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1891: extern int simple_write_begin(struct file *file, struct address_space *mapping,",
          "1892:    loff_t pos, unsigned len, unsigned flags,",
          "1893:    struct page **pagep, void **fsdata);",
          "1894: extern int simple_write_end(struct file *file, struct address_space *mapping,",
          "1895:    loff_t pos, unsigned len, unsigned copied,",
          "1896:    struct page *page, void *fsdata);",
          "",
          "---------------"
        ],
        "include/linux/pagemap.h||include/linux/pagemap.h": [
          "File: include/linux/pagemap.h -> include/linux/pagemap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "96: unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,",
          "97:    int tag, unsigned int nr_pages, struct page **pages);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99: struct page *__grab_cache_page(struct address_space *mapping, pgoff_t index);",
          "",
          "---------------"
        ],
        "mm/filemap.c||mm/filemap.c": [
          "File: mm/filemap.c -> mm/filemap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1742:  i->count -= bytes;",
          "1743: }",
          "1746: {",
          "1748:  char __user *buf = i->iov->iov_base + i->iov_offset;",
          "1750: }",
          "",
          "[Removed Lines]",
          "1745: int iov_iter_fault_in_readable(struct iov_iter *i)",
          "1747:  size_t seglen = min(i->iov->iov_len - i->iov_offset, i->count);",
          "1749:  return fault_in_pages_readable(buf, seglen);",
          "",
          "[Added Lines]",
          "1754: int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes)",
          "1757:  bytes = min(bytes, i->iov->iov_len - i->iov_offset);",
          "1758:  return fault_in_pages_readable(buf, bytes);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1843: }",
          "1844: EXPORT_SYMBOL(generic_write_checks);",
          "1846: ssize_t",
          "1847: generic_file_direct_write(struct kiocb *iocb, const struct iovec *iov,",
          "1848:   unsigned long *nr_segs, loff_t pos, loff_t *ppos,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1855: int pagecache_write_begin(struct file *file, struct address_space *mapping,",
          "1856:     loff_t pos, unsigned len, unsigned flags,",
          "1857:     struct page **pagep, void **fsdata)",
          "1858: {",
          "1859:  const struct address_space_operations *aops = mapping->a_ops;",
          "1861:  if (aops->write_begin) {",
          "1862:   return aops->write_begin(file, mapping, pos, len, flags,",
          "1863:        pagep, fsdata);",
          "1864:  } else {",
          "1865:   int ret;",
          "1866:   pgoff_t index = pos >> PAGE_CACHE_SHIFT;",
          "1867:   unsigned offset = pos & (PAGE_CACHE_SIZE - 1);",
          "1868:   struct inode *inode = mapping->host;",
          "1869:   struct page *page;",
          "1870: again:",
          "1871:   page = __grab_cache_page(mapping, index);",
          "1873:   if (!page)",
          "1874:    return -ENOMEM;",
          "1876:   if (flags & AOP_FLAG_UNINTERRUPTIBLE && !PageUptodate(page)) {",
          "1884:    ret = aops->readpage(file, page);",
          "1885:    page_cache_release(page);",
          "1886:    if (ret) {",
          "1887:     if (ret == AOP_TRUNCATED_PAGE)",
          "1888:      goto again;",
          "1889:     return ret;",
          "1890:    }",
          "1891:    goto again;",
          "1892:   }",
          "1894:   ret = aops->prepare_write(file, page, offset, offset+len);",
          "1895:   if (ret) {",
          "1896:    if (ret != AOP_TRUNCATED_PAGE)",
          "1897:     unlock_page(page);",
          "1898:    page_cache_release(page);",
          "1899:    if (pos + len > inode->i_size)",
          "1900:     vmtruncate(inode, inode->i_size);",
          "1901:    if (ret == AOP_TRUNCATED_PAGE)",
          "1902:     goto again;",
          "1903:   }",
          "1904:   return ret;",
          "1905:  }",
          "1906: }",
          "1907: EXPORT_SYMBOL(pagecache_write_begin);",
          "1909: int pagecache_write_end(struct file *file, struct address_space *mapping,",
          "1910:     loff_t pos, unsigned len, unsigned copied,",
          "1911:     struct page *page, void *fsdata)",
          "1912: {",
          "1913:  const struct address_space_operations *aops = mapping->a_ops;",
          "1914:  int ret;",
          "1916:  if (aops->write_end) {",
          "1917:   mark_page_accessed(page);",
          "1918:   ret = aops->write_end(file, mapping, pos, len, copied,",
          "1919:        page, fsdata);",
          "1920:  } else {",
          "1921:   unsigned offset = pos & (PAGE_CACHE_SIZE - 1);",
          "1922:   struct inode *inode = mapping->host;",
          "1924:   flush_dcache_page(page);",
          "1925:   ret = aops->commit_write(file, page, offset, offset+len);",
          "1926:   unlock_page(page);",
          "1927:   mark_page_accessed(page);",
          "1928:   page_cache_release(page);",
          "1931:   if (ret < 0) {",
          "1932:    if (pos + len > inode->i_size)",
          "1933:     vmtruncate(inode, inode->i_size);",
          "1934:   } else if (ret > 0)",
          "1935:    ret = min_t(size_t, copied, ret);",
          "1936:   else",
          "1937:    ret = copied;",
          "1938:  }",
          "1940:  return ret;",
          "1941: }",
          "1942: EXPORT_SYMBOL(pagecache_write_end);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1891: {",
          "1892:  int status;",
          "1893:  struct page *page;",
          "",
          "[Removed Lines]",
          "1889: static struct page *__grab_cache_page(struct address_space *mapping,",
          "1890:        pgoff_t index)",
          "",
          "[Added Lines]",
          "1987: struct page *__grab_cache_page(struct address_space *mapping, pgoff_t index)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1908:  }",
          "1909:  return page;",
          "1910: }",
          "1916: {",
          "1918:  struct address_space *mapping = file->f_mapping;",
          "1919:  const struct address_space_operations *a_ops = mapping->a_ops;",
          "1926:  do {",
          "1927:   struct page *src_page;",
          "",
          "[Removed Lines]",
          "1912: ssize_t",
          "1913: generic_file_buffered_write(struct kiocb *iocb, const struct iovec *iov,",
          "1914:   unsigned long nr_segs, loff_t pos, loff_t *ppos,",
          "1915:   size_t count, ssize_t written)",
          "1917:  struct file *file = iocb->ki_filp;",
          "1920:  struct inode  *inode = mapping->host;",
          "1921:  long  status = 0;",
          "1922:  struct iov_iter i;",
          "1924:  iov_iter_init(&i, iov, nr_segs, count, written);",
          "",
          "[Added Lines]",
          "2008: EXPORT_SYMBOL(__grab_cache_page);",
          "2010: static ssize_t generic_perform_write_2copy(struct file *file,",
          "2011:     struct iov_iter *i, loff_t pos)",
          "2015:  struct inode *inode = mapping->host;",
          "2016:  long status = 0;",
          "2017:  ssize_t written = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1934:   offset = (pos & (PAGE_CACHE_SIZE - 1));",
          "1935:   index = pos >> PAGE_CACHE_SHIFT;",
          "1936:   bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,",
          "",
          "[Removed Lines]",
          "1937:       iov_iter_count(&i));",
          "",
          "[Added Lines]",
          "2030:       iov_iter_count(i));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1956:    status = -EFAULT;",
          "1957:    break;",
          "1958:   }",
          "",
          "[Removed Lines]",
          "1955:   if (unlikely(iov_iter_fault_in_readable(&i))) {",
          "",
          "[Added Lines]",
          "2048:   if (unlikely(iov_iter_fault_in_readable(i, bytes))) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1987:         offset, bytes);",
          "1988:    if (unlikely(copied == 0)) {",
          "1989:     status = -EFAULT;",
          "",
          "[Removed Lines]",
          "1986:    copied = iov_iter_copy_from_user(src_page, &i,",
          "",
          "[Added Lines]",
          "2079:    copied = iov_iter_copy_from_user(src_page, i,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2032:    pagefault_disable();",
          "2034:         offset, bytes);",
          "2035:    pagefault_enable();",
          "2036:   } else {",
          "",
          "[Removed Lines]",
          "2033:    copied = iov_iter_copy_from_user_atomic(page, &i,",
          "",
          "[Added Lines]",
          "2125:    copied = iov_iter_copy_from_user_atomic(page, i,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2056:   if (src_page)",
          "2057:    page_cache_release(src_page);",
          "2061:   pos += copied;",
          "2063:   balance_dirty_pages_ratelimited(mapping);",
          "2064:   cond_resched();",
          "",
          "[Removed Lines]",
          "2059:   iov_iter_advance(&i, copied);",
          "2060:   written += copied;",
          "",
          "[Added Lines]",
          "2151:   iov_iter_advance(i, copied);",
          "2153:   written += copied;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2082:    continue;",
          "2083:   else",
          "2084:    break;",
          "2091:  if (likely(status >= 0)) {",
          "2092:   if (unlikely((file->f_flags & O_SYNC) || IS_SYNC(inode))) {",
          "2093:    if (!a_ops->writepage || !is_sync_kiocb(iocb))",
          "2094:     status = generic_osync_inode(inode, mapping,",
          "",
          "[Removed Lines]",
          "2085:  } while (iov_iter_count(&i));",
          "",
          "[Added Lines]",
          "2177:  } while (iov_iter_count(i));",
          "2179:  return written ? written : status;",
          "2180: }",
          "2182: static ssize_t generic_perform_write(struct file *file,",
          "2183:     struct iov_iter *i, loff_t pos)",
          "2184: {",
          "2185:  struct address_space *mapping = file->f_mapping;",
          "2186:  const struct address_space_operations *a_ops = mapping->a_ops;",
          "2187:  long status = 0;",
          "2188:  ssize_t written = 0;",
          "2190:  do {",
          "2191:   struct page *page;",
          "2196:   void *fsdata;",
          "2198:   offset = (pos & (PAGE_CACHE_SIZE - 1));",
          "2199:   index = pos >> PAGE_CACHE_SHIFT;",
          "2200:   bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,",
          "2201:       iov_iter_count(i));",
          "2203: again:",
          "2215:   if (unlikely(iov_iter_fault_in_readable(i, bytes))) {",
          "2216:    status = -EFAULT;",
          "2217:    break;",
          "2218:   }",
          "2220:   status = a_ops->write_begin(file, mapping, pos, bytes, 0,",
          "2221:       &page, &fsdata);",
          "2222:   if (unlikely(status))",
          "2223:    break;",
          "2225:   pagefault_disable();",
          "2226:   copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);",
          "2227:   pagefault_enable();",
          "2228:   flush_dcache_page(page);",
          "2230:   status = a_ops->write_end(file, mapping, pos, bytes, copied,",
          "2231:       page, fsdata);",
          "2232:   if (unlikely(status < 0))",
          "2233:    break;",
          "2234:   copied = status;",
          "2236:   cond_resched();",
          "2238:   if (unlikely(copied == 0)) {",
          "2247:    bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,",
          "2248:       iov_iter_single_seg_count(i));",
          "2249:    goto again;",
          "2250:   }",
          "2251:   iov_iter_advance(i, copied);",
          "2252:   pos += copied;",
          "2253:   written += copied;",
          "2255:   balance_dirty_pages_ratelimited(mapping);",
          "2257:  } while (iov_iter_count(i));",
          "2259:  return written ? written : status;",
          "2260: }",
          "2262: ssize_t",
          "2263: generic_file_buffered_write(struct kiocb *iocb, const struct iovec *iov,",
          "2264:   unsigned long nr_segs, loff_t pos, loff_t *ppos,",
          "2265:   size_t count, ssize_t written)",
          "2266: {",
          "2267:  struct file *file = iocb->ki_filp;",
          "2268:  struct address_space *mapping = file->f_mapping;",
          "2269:  const struct address_space_operations *a_ops = mapping->a_ops;",
          "2270:  struct inode *inode = mapping->host;",
          "2271:  ssize_t status;",
          "2272:  struct iov_iter i;",
          "2274:  iov_iter_init(&i, iov, nr_segs, count, written);",
          "2275:  if (a_ops->write_begin)",
          "2276:   status = generic_perform_write(file, &i, pos);",
          "2277:  else",
          "2278:   status = generic_perform_write_2copy(file, &i, pos);",
          "2281:   written += status;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f718ffc16c43a435d12919c75dbfad518abd056",
      "candidate_info": {
        "commit_hash": "2f718ffc16c43a435d12919c75dbfad518abd056",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2f718ffc16c43a435d12919c75dbfad518abd056",
        "files": [
          "include/linux/fs.h",
          "mm/filemap.c",
          "mm/filemap.h"
        ],
        "message": "mm: buffered write iterator\n\nAdd an iterator data structure to operate over an iovec.  Add usercopy\noperators needed by generic_file_buffered_write, and convert that function\nover.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/fs.h||include/linux/fs.h",
          "mm/filemap.c||mm/filemap.c",
          "mm/filemap.h||mm/filemap.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/filemap.c||mm/filemap.c"
          ],
          "candidate": [
            "mm/filemap.c||mm/filemap.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "401: struct address_space;",
          "402: struct writeback_control;",
          "404: struct address_space_operations {",
          "405:  int (*writepage)(struct page *page, struct writeback_control *wbc);",
          "406:  int (*readpage)(struct file *, struct page *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "404: struct iov_iter {",
          "405:  const struct iovec *iov;",
          "406:  unsigned long nr_segs;",
          "407:  size_t iov_offset;",
          "408:  size_t count;",
          "409: };",
          "411: size_t iov_iter_copy_from_user_atomic(struct page *page,",
          "412:   struct iov_iter *i, unsigned long offset, size_t bytes);",
          "413: size_t iov_iter_copy_from_user(struct page *page,",
          "414:   struct iov_iter *i, unsigned long offset, size_t bytes);",
          "415: void iov_iter_advance(struct iov_iter *i, size_t bytes);",
          "416: int iov_iter_fault_in_readable(struct iov_iter *i);",
          "417: size_t iov_iter_single_seg_count(struct iov_iter *i);",
          "419: static inline void iov_iter_init(struct iov_iter *i,",
          "420:    const struct iovec *iov, unsigned long nr_segs,",
          "421:    size_t count, size_t written)",
          "422: {",
          "423:  i->iov = iov;",
          "424:  i->nr_segs = nr_segs;",
          "425:  i->iov_offset = 0;",
          "426:  i->count = count + written;",
          "428:  iov_iter_advance(i, written);",
          "429: }",
          "431: static inline size_t iov_iter_count(struct iov_iter *i)",
          "432: {",
          "433:  return i->count;",
          "434: }",
          "",
          "---------------"
        ],
        "mm/filemap.c||mm/filemap.c": [
          "File: mm/filemap.c -> mm/filemap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include <linux/security.h>",
          "31: #include <linux/syscalls.h>",
          "32: #include <linux/cpuset.h>",
          "34: #include \"internal.h\"",
          "",
          "[Removed Lines]",
          "33: #include \"filemap.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1635: }",
          "1636: EXPORT_SYMBOL(remove_suid);",
          "1640:    const struct iovec *iov, size_t base, size_t bytes)",
          "1641: {",
          "1642:  size_t copied = 0, left = 0;",
          "",
          "[Removed Lines]",
          "1638: size_t",
          "1639: __filemap_copy_from_user_iovec_inatomic(char *vaddr,",
          "",
          "[Added Lines]",
          "1638: static size_t __iovec_copy_from_user_inatomic(char *vaddr,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1658:  return copied - left;",
          "1659: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1665: size_t iov_iter_copy_from_user_atomic(struct page *page,",
          "1666:   struct iov_iter *i, unsigned long offset, size_t bytes)",
          "1667: {",
          "1668:  char *kaddr;",
          "1669:  size_t copied;",
          "1671:  BUG_ON(!in_atomic());",
          "1672:  kaddr = kmap_atomic(page, KM_USER0);",
          "1673:  if (likely(i->nr_segs == 1)) {",
          "1674:   int left;",
          "1675:   char __user *buf = i->iov->iov_base + i->iov_offset;",
          "1676:   left = __copy_from_user_inatomic_nocache(kaddr + offset,",
          "1677:        buf, bytes);",
          "1678:   copied = bytes - left;",
          "1679:  } else {",
          "1680:   copied = __iovec_copy_from_user_inatomic(kaddr + offset,",
          "1681:       i->iov, i->iov_offset, bytes);",
          "1682:  }",
          "1683:  kunmap_atomic(kaddr, KM_USER0);",
          "1685:  return copied;",
          "1686: }",
          "1694: size_t iov_iter_copy_from_user(struct page *page,",
          "1695:   struct iov_iter *i, unsigned long offset, size_t bytes)",
          "1696: {",
          "1697:  char *kaddr;",
          "1698:  size_t copied;",
          "1700:  kaddr = kmap(page);",
          "1701:  if (likely(i->nr_segs == 1)) {",
          "1702:   int left;",
          "1703:   char __user *buf = i->iov->iov_base + i->iov_offset;",
          "1704:   left = __copy_from_user_nocache(kaddr + offset, buf, bytes);",
          "1705:   copied = bytes - left;",
          "1706:  } else {",
          "1707:   copied = __iovec_copy_from_user_inatomic(kaddr + offset,",
          "1708:       i->iov, i->iov_offset, bytes);",
          "1709:  }",
          "1710:  kunmap(page);",
          "1711:  return copied;",
          "1712: }",
          "1714: static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)",
          "1715: {",
          "1716:  if (likely(i->nr_segs == 1)) {",
          "1717:   i->iov_offset += bytes;",
          "1718:  } else {",
          "1719:   const struct iovec *iov = i->iov;",
          "1720:   size_t base = i->iov_offset;",
          "1722:   while (bytes) {",
          "1723:    int copy = min(bytes, iov->iov_len - base);",
          "1725:    bytes -= copy;",
          "1726:    base += copy;",
          "1727:    if (iov->iov_len == base) {",
          "1728:     iov++;",
          "1729:     base = 0;",
          "1730:    }",
          "1731:   }",
          "1732:   i->iov = iov;",
          "1733:   i->iov_offset = base;",
          "1734:  }",
          "1735: }",
          "1737: void iov_iter_advance(struct iov_iter *i, size_t bytes)",
          "1738: {",
          "1739:  BUG_ON(i->count < bytes);",
          "1741:  __iov_iter_advance_iov(i, bytes);",
          "1742:  i->count -= bytes;",
          "1743: }",
          "1745: int iov_iter_fault_in_readable(struct iov_iter *i)",
          "1746: {",
          "1747:  size_t seglen = min(i->iov->iov_len - i->iov_offset, i->count);",
          "1748:  char __user *buf = i->iov->iov_base + i->iov_offset;",
          "1749:  return fault_in_pages_readable(buf, seglen);",
          "1750: }",
          "1755: size_t iov_iter_single_seg_count(struct iov_iter *i)",
          "1756: {",
          "1757:  const struct iovec *iov = i->iov;",
          "1758:  if (i->nr_segs == 1)",
          "1759:   return i->count;",
          "1760:  else",
          "1761:   return min(i->count, iov->iov_len - i->iov_offset);",
          "1762: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1816:  const struct address_space_operations *a_ops = mapping->a_ops;",
          "1817:  struct inode  *inode = mapping->host;",
          "1818:  long  status = 0;",
          "1828:  do {",
          "1829:   struct page *src_page;",
          "1830:   struct page *page;",
          "1838:   offset = (pos & (PAGE_CACHE_SIZE - 1));",
          "1839:   index = pos >> PAGE_CACHE_SHIFT;",
          "",
          "[Removed Lines]",
          "1821:  char __user *buf;",
          "1826:  filemap_set_next_iovec(&cur_iov, nr_segs, &iov_offset, written);",
          "1837:   buf = cur_iov->iov_base + iov_offset;",
          "1840:   bytes = PAGE_CACHE_SIZE - offset;",
          "1841:   if (bytes > count)",
          "1842:    bytes = count;",
          "",
          "[Added Lines]",
          "1922:  struct iov_iter i;",
          "1924:  iov_iter_init(&i, iov, nr_segs, count, written);",
          "1936:   bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,",
          "1937:       iov_iter_count(&i));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1848:   src_page = NULL;",
          "",
          "[Removed Lines]",
          "1850:   seglen = cur_iov->iov_len - iov_offset;",
          "1851:   if (seglen > bytes)",
          "1852:    seglen = bytes;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1865:    status = -EFAULT;",
          "1866:    break;",
          "1867:   }",
          "",
          "[Removed Lines]",
          "1864:   if (unlikely(fault_in_pages_readable(buf, seglen))) {",
          "",
          "[Added Lines]",
          "1955:   if (unlikely(iov_iter_fault_in_readable(&i))) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1897:    if (unlikely(copied == 0)) {",
          "1898:     status = -EFAULT;",
          "1899:     page_cache_release(page);",
          "",
          "[Removed Lines]",
          "1895:    copied = filemap_copy_from_user(src_page, offset,",
          "1896:      cur_iov, nr_segs, iov_offset, bytes);",
          "",
          "[Added Lines]",
          "1986:    copied = iov_iter_copy_from_user(src_page, &i,",
          "1987:         offset, bytes);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1941:    pagefault_disable();",
          "1944:    pagefault_enable();",
          "1945:   } else {",
          "1946:    void *src, *dst;",
          "",
          "[Removed Lines]",
          "1942:    copied = filemap_copy_from_user_atomic(page, offset,",
          "1943:      cur_iov, nr_segs, iov_offset, bytes);",
          "",
          "[Added Lines]",
          "2033:    copied = iov_iter_copy_from_user_atomic(page, &i,",
          "2034:         offset, bytes);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1965:   if (src_page)",
          "1966:    page_cache_release(src_page);",
          "1968:   written += copied;",
          "1970:   pos += copied;",
          "1973:   balance_dirty_pages_ratelimited(mapping);",
          "1974:   cond_resched();",
          "",
          "[Removed Lines]",
          "1969:   count -= copied;",
          "1971:   filemap_set_next_iovec(&cur_iov, nr_segs, &iov_offset, copied);",
          "",
          "[Added Lines]",
          "2059:   iov_iter_advance(&i, copied);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1992:    continue;",
          "1993:   else",
          "1994:    break;",
          "",
          "[Removed Lines]",
          "1995:  } while (count);",
          "",
          "[Added Lines]",
          "2085:  } while (iov_iter_count(&i));",
          "",
          "---------------"
        ],
        "mm/filemap.h||mm/filemap.h": [
          "File: mm/filemap.h -> mm/filemap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
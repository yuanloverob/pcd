{
  "cve_id": "CVE-2014-3646",
  "cve_desc": "arch/x86/kvm/vmx.c in the KVM subsystem in the Linux kernel through 3.17.2 does not have an exit handler for the INVVPID instruction, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "a642fc305053cc1c6e47e4f4df327895747ab485",
  "patch_info": {
    "commit_hash": "a642fc305053cc1c6e47e4f4df327895747ab485",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a642fc305053cc1c6e47e4f4df327895747ab485",
    "files": [
      "arch/x86/include/uapi/asm/vmx.h",
      "arch/x86/kvm/vmx.c"
    ],
    "message": "kvm: vmx: handle invvpid vm exit gracefully\n\nOn systems with invvpid instruction support (corresponding bit in\nIA32_VMX_EPT_VPID_CAP MSR is set) guest invocation of invvpid\ncauses vm exit, which is currently not handled and results in\npropagation of unknown exit to userspace.\n\nFix this by installing an invvpid vm exit handler.\n\nThis is CVE-2014-3646.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/include/uapi/asm/vmx.h||arch/x86/include/uapi/asm/vmx.h",
      "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
    ]
  },
  "patch_diff": {
    "arch/x86/include/uapi/asm/vmx.h||arch/x86/include/uapi/asm/vmx.h": [
      "File: arch/x86/include/uapi/asm/vmx.h -> arch/x86/include/uapi/asm/vmx.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "67: #define EXIT_REASON_EPT_MISCONFIG       49",
      "68: #define EXIT_REASON_INVEPT              50",
      "69: #define EXIT_REASON_PREEMPTION_TIMER    52",
      "70: #define EXIT_REASON_WBINVD              54",
      "71: #define EXIT_REASON_XSETBV              55",
      "72: #define EXIT_REASON_APIC_WRITE          56",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "70: #define EXIT_REASON_INVVPID             53",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "114:  { EXIT_REASON_EOI_INDUCED,           \"EOI_INDUCED\" }, \\",
      "115:  { EXIT_REASON_INVALID_STATE,         \"INVALID_STATE\" }, \\",
      "116:  { EXIT_REASON_INVD,                  \"INVD\" }, \\",
      "117:  { EXIT_REASON_INVPCID,               \"INVPCID\" }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "118:  { EXIT_REASON_INVVPID,               \"INVVPID\" }, \\",
      "",
      "---------------"
    ],
    "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
      "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6746:  return 1;",
      "6747: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6749: static int handle_invvpid(struct kvm_vcpu *vcpu)",
      "6750: {",
      "6751:  kvm_queue_exception(vcpu, UD_VECTOR);",
      "6752:  return 1;",
      "6753: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "6791:  [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_mwait,",
      "6792:  [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,",
      "6793:  [EXIT_REASON_INVEPT]                  = handle_invept,",
      "6794: };",
      "6796: static const int kvm_vmx_max_exit_handlers =",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6800:  [EXIT_REASON_INVVPID]                 = handle_invvpid,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "7026:  case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:",
      "7027:  case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:",
      "7028:  case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:",
      "",
      "[Removed Lines]",
      "7029:  case EXIT_REASON_INVEPT:",
      "",
      "[Added Lines]",
      "7036:  case EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "99b83ac893b84ed1a62ad6d1f2b6cc32026b9e85",
      "candidate_info": {
        "commit_hash": "99b83ac893b84ed1a62ad6d1f2b6cc32026b9e85",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/99b83ac893b84ed1a62ad6d1f2b6cc32026b9e85",
        "files": [
          "arch/x86/include/asm/vmx.h",
          "arch/x86/kvm/vmx.c"
        ],
        "message": "KVM: nVMX: emulate the INVVPID instruction\n\nAdd the INVVPID instruction emulation.\n\nReviewed-by: Wincy Van <fanwenyi0529@gmail.com>\nSigned-off-by: Wanpeng Li <wanpeng.li@hotmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/include/asm/vmx.h||arch/x86/include/asm/vmx.h",
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/include/asm/vmx.h||arch/x86/include/asm/vmx.h": [
          "File: arch/x86/include/asm/vmx.h -> arch/x86/include/asm/vmx.h"
        ],
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "442:  u32 nested_vmx_misc_low;",
          "443:  u32 nested_vmx_misc_high;",
          "444:  u32 nested_vmx_ept_caps;",
          "445: };",
          "447: #define POSTED_INTR_ON  0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "445:  u32 nested_vmx_vpid_caps;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2612:  } else",
          "2613:   vmx->nested.nested_vmx_ept_caps = 0;",
          "2615:  if (enable_unrestricted_guest)",
          "2616:   vmx->nested.nested_vmx_secondary_ctls_high |=",
          "2617:    SECONDARY_EXEC_UNRESTRICTED_GUEST;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2616:  vmx->nested.nested_vmx_vpid_caps = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7330: static int handle_invvpid(struct kvm_vcpu *vcpu)",
          "7331: {",
          "7333:  return 1;",
          "7334: }",
          "",
          "[Removed Lines]",
          "7332:  kvm_queue_exception(vcpu, UD_VECTOR);",
          "",
          "[Added Lines]",
          "7335:  struct vcpu_vmx *vmx = to_vmx(vcpu);",
          "7336:  u32 vmx_instruction_info;",
          "7337:  unsigned long type, types;",
          "7338:  gva_t gva;",
          "7339:  struct x86_exception e;",
          "7340:  int vpid;",
          "7342:  if (!(vmx->nested.nested_vmx_secondary_ctls_high &",
          "7343:        SECONDARY_EXEC_ENABLE_VPID) ||",
          "7344:    !(vmx->nested.nested_vmx_vpid_caps & VMX_VPID_INVVPID_BIT)) {",
          "7345:   kvm_queue_exception(vcpu, UD_VECTOR);",
          "7346:   return 1;",
          "7347:  }",
          "7349:  if (!nested_vmx_check_permission(vcpu))",
          "7350:   return 1;",
          "7352:  vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);",
          "7353:  type = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);",
          "7355:  types = (vmx->nested.nested_vmx_vpid_caps >> 8) & 0x7;",
          "7357:  if (!(types & (1UL << type))) {",
          "7358:   nested_vmx_failValid(vcpu,",
          "7359:    VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);",
          "7360:   return 1;",
          "7361:  }",
          "7366:  if (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),",
          "7367:    vmx_instruction_info, false, &gva))",
          "7368:   return 1;",
          "7369:  if (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vpid,",
          "7370:     sizeof(u32), &e)) {",
          "7371:   kvm_inject_page_fault(vcpu, &e);",
          "7372:   return 1;",
          "7373:  }",
          "7375:  switch (type) {",
          "7376:  case VMX_VPID_EXTENT_ALL_CONTEXT:",
          "7377:   if (get_vmcs12(vcpu)->virtual_processor_id == 0) {",
          "7378:    nested_vmx_failValid(vcpu,",
          "7379:     VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);",
          "7380:    return 1;",
          "7381:   }",
          "7382:   vmx_flush_tlb(vcpu);",
          "7383:   nested_vmx_succeed(vcpu);",
          "7384:   break;",
          "7385:  default:",
          "7387:   BUG_ON(1);",
          "7388:   break;",
          "7389:  }",
          "7391:  skip_emulated_instruction(vcpu);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5c614b3583e7b6dab0c86356fa36c2bcbb8322a0",
      "candidate_info": {
        "commit_hash": "5c614b3583e7b6dab0c86356fa36c2bcbb8322a0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5c614b3583e7b6dab0c86356fa36c2bcbb8322a0",
        "files": [
          "arch/x86/kvm/vmx.c"
        ],
        "message": "KVM: nVMX: nested VPID emulation\n\nVPID is used to tag address space and avoid a TLB flush. Currently L0 use\nthe same VPID to run L1 and all its guests. KVM flushes VPID when switching\nbetween L1 and L2.\n\nThis patch advertises VPID to the L1 hypervisor, then address space of L1\nand L2 can be separately treated and avoid TLB flush when swithing between\nL1 and L2. For each nested vmentry, if vpid12 is changed, reuse shadow vpid\nw/ an invvpid.\n\nPerformance:\n\nrun lmbench on L2 w/ 3.5 kernel.\n\nContext switching - times in microseconds - smaller is better\n-------------------------------------------------------------------------\nHost                 OS  2p/0K 2p/16K 2p/64K 8p/16K 8p/64K 16p/16K 16p/64K\n                         ctxsw  ctxsw  ctxsw ctxsw  ctxsw   ctxsw   ctxsw\n--------- ------------- ------ ------ ------ ------ ------ ------- -------\nkernel    Linux 3.5.0-1 1.2200 1.3700 1.4500 4.7800 2.3300 5.60000 2.88000  nested VPID\nkernel    Linux 3.5.0-1 1.2600 1.4300 1.5600   12.7   12.9 3.49000 7.46000  vanilla\n\nReviewed-by: Jan Kiszka <jan.kiszka@siemens.com>\nReviewed-by: Wincy Van <fanwenyi0529@gmail.com>\nSigned-off-by: Wanpeng Li <wanpeng.li@hotmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "427:  u64 vmcs01_debugctl;",
          "429:  u32 nested_vmx_procbased_ctls_low;",
          "430:  u32 nested_vmx_procbased_ctls_high;",
          "431:  u32 nested_vmx_true_procbased_ctls_low;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "429:  u16 vpid02;",
          "430:  u16 last_vpid;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1213:  return nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);",
          "1214: }",
          "1216: static inline bool nested_cpu_has_apic_reg_virt(struct vmcs12 *vmcs12)",
          "1217: {",
          "1218:  return nested_cpu_has2(vmcs12, SECONDARY_EXEC_APIC_REGISTER_VIRT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1219: static inline bool nested_cpu_has_vpid(struct vmcs12 *vmcs12)",
          "1220: {",
          "1221:  return nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VPID);",
          "1222: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2590:   SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |",
          "2591:   SECONDARY_EXEC_RDTSCP |",
          "2592:   SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |",
          "2593:   SECONDARY_EXEC_APIC_REGISTER_VIRT |",
          "2594:   SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |",
          "2595:   SECONDARY_EXEC_WBINVD_EXITING |",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2601:   SECONDARY_EXEC_ENABLE_VPID |",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6818:   return;",
          "6820:  vmx->nested.vmxon = false;",
          "6821:  nested_release_vmcs12(vmx);",
          "6822:  if (enable_shadow_vmcs)",
          "6823:   free_vmcs(vmx->nested.current_shadow_vmcs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6830:  free_vpid(vmx->nested.vpid02);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7379:     VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);",
          "7380:    return 1;",
          "7381:   }",
          "7383:   nested_vmx_succeed(vcpu);",
          "7384:   break;",
          "7385:  default:",
          "",
          "[Removed Lines]",
          "7382:   vmx_flush_tlb(vcpu);",
          "",
          "[Added Lines]",
          "7392:   __vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8759:    goto free_vmcs;",
          "8760:  }",
          "8763:   nested_vmx_setup_ctls_msrs(vmx);",
          "8765:  vmx->nested.posted_intr_nv = -1;",
          "8766:  vmx->nested.current_vmptr = -1ull;",
          "",
          "[Removed Lines]",
          "8762:  if (nested)",
          "",
          "[Added Lines]",
          "8772:  if (nested) {",
          "8774:   vmx->nested.vpid02 = allocate_vpid();",
          "8775:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8781:  return &vmx->vcpu;",
          "8783: free_vmcs:",
          "8784:  free_loaded_vmcs(vmx->loaded_vmcs);",
          "8785: free_msrs:",
          "8786:  kfree(vmx->guest_msrs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8796:  free_vpid(vmx->nested.vpid02);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "9666:  if (enable_vpid) {",
          "9674:  }",
          "9676:  if (nested_cpu_has_ept(vmcs12)) {",
          "",
          "[Removed Lines]",
          "9672:   vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);",
          "9673:   vmx_flush_tlb(vcpu);",
          "",
          "[Added Lines]",
          "9688:   if (nested_cpu_has_vpid(vmcs12) && vmx->nested.vpid02) {",
          "9689:    vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->nested.vpid02);",
          "9690:    if (vmcs12->virtual_processor_id != vmx->nested.last_vpid) {",
          "9691:     vmx->nested.last_vpid = vmcs12->virtual_processor_id;",
          "9692:     __vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);",
          "9693:    }",
          "9694:   } else {",
          "9695:    vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);",
          "9696:    vmx_flush_tlb(vcpu);",
          "9697:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
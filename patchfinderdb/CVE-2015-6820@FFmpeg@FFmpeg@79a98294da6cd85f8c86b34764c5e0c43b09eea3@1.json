{
  "cve_id": "CVE-2015-6820",
  "cve_desc": "The ff_sbr_apply function in libavcodec/aacsbr.c in FFmpeg before 2.7.2 does not check for a matching AAC frame syntax element before proceeding with Spectral Band Replication calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted AAC data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "79a98294da6cd85f8c86b34764c5e0c43b09eea3",
  "patch_info": {
    "commit_hash": "79a98294da6cd85f8c86b34764c5e0c43b09eea3",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/79a98294da6cd85f8c86b34764c5e0c43b09eea3",
    "files": [
      "libavcodec/aacsbr.c",
      "libavcodec/sbr.h"
    ],
    "message": "avcodec/aacsbr: check that the element type matches before applying SBR\n\nFixes out of array access\nFixes: signal_sigsegv_3670fc0_2818_cov_2307326154_moon.mux\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/aacsbr.c||libavcodec/aacsbr.c",
      "libavcodec/sbr.h||libavcodec/sbr.h"
    ]
  },
  "patch_diff": {
    "libavcodec/aacsbr.c||libavcodec/aacsbr.c": [
      "File: libavcodec/aacsbr.c -> libavcodec/aacsbr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1019: {",
      "1020:     unsigned int cnt = get_bits_count(gb);",
      "1022:     if (id_aac == TYPE_SCE || id_aac == TYPE_CCE) {",
      "1023:         if (read_sbr_single_channel_element(ac, sbr, gb)) {",
      "1024:             sbr_turnoff(sbr);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1022:     sbr->id_aac = id_aac;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1695:     int nch = (id_aac == TYPE_CPE) ? 2 : 1;",
      "1696:     int err;",
      "1698:     if (!sbr->kx_and_m_pushed) {",
      "1699:         sbr->kx[0] = sbr->kx[1];",
      "1700:         sbr->m[0] = sbr->m[1];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1700:     if (id_aac != sbr->id_aac) {",
      "1701:         av_log(ac->avctx, AV_LOG_ERROR,",
      "1702:             \"element type mismatch %d != %d\\n\", id_aac, sbr->id_aac);",
      "1703:         sbr_turnoff(sbr);",
      "1704:     }",
      "",
      "---------------"
    ],
    "libavcodec/sbr.h||libavcodec/sbr.h": [
      "File: libavcodec/sbr.h -> libavcodec/sbr.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "137: struct SpectralBandReplication {",
      "138:     int                sample_rate;",
      "139:     int                start;",
      "140:     int                reset;",
      "141:     SpectrumParameters spectrum_params;",
      "142:     int                bs_amp_res_header;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "140:     int                id_aac;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5499467d5d3d517f0d65ede72a6ac22cf6059eca",
      "candidate_info": {
        "commit_hash": "5499467d5d3d517f0d65ede72a6ac22cf6059eca",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/5499467d5d3d517f0d65ede72a6ac22cf6059eca",
        "files": [
          "libavcodec/aacsbr.c",
          "libavcodec/aacsbr.h",
          "libavcodec/aacsbr_template.c",
          "libavcodec/sbrdsp.c",
          "libavcodec/sbrdsp_template.c"
        ],
        "message": "avcodec: Template creation for AAC decoder (SBR-module)\n\nMove the existing code to a new template file.\n\nSigned-off-by: Nedeljko Babic <nedeljko.babic@imgtec.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/aacsbr.c||libavcodec/aacsbr.c",
          "libavcodec/aacsbr.h||libavcodec/aacsbr.h",
          "libavcodec/aacsbr_template.c||libavcodec/aacsbr_template.c",
          "libavcodec/sbrdsp.c||libavcodec/sbrdsp.c",
          "libavcodec/sbrdsp_template.c||libavcodec/sbrdsp_template.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/aacsbr.c||libavcodec/aacsbr.c"
          ],
          "candidate": [
            "libavcodec/aacsbr.c||libavcodec/aacsbr.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/aacsbr.c||libavcodec/aacsbr.c": [
          "File: libavcodec/aacsbr.c -> libavcodec/aacsbr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #include <float.h>",
          "43: #include <math.h>",
          "48: #if ARCH_MIPS",
          "49: #include \"mips/aacsbr_mips.h\"",
          "82: static VLC vlc_sbr[10];",
          "95: static void aacsbr_func_ptr_init(AACSBRContext *c);",
          "291: static void make_bands(int16_t* bands, int start, int stop, int num_bands)",
          "292: {",
          "293:     int k, previous, present;",
          "",
          "[Removed Lines]",
          "45: #define ENVELOPE_ADJUSTMENT_OFFSET 2",
          "46: #define NOISE_FLOOR_OFFSET 6.0f",
          "55: enum {",
          "56:     T_HUFFMAN_ENV_1_5DB,",
          "57:     F_HUFFMAN_ENV_1_5DB,",
          "58:     T_HUFFMAN_ENV_BAL_1_5DB,",
          "59:     F_HUFFMAN_ENV_BAL_1_5DB,",
          "60:     T_HUFFMAN_ENV_3_0DB,",
          "61:     F_HUFFMAN_ENV_3_0DB,",
          "62:     T_HUFFMAN_ENV_BAL_3_0DB,",
          "63:     F_HUFFMAN_ENV_BAL_3_0DB,",
          "64:     T_HUFFMAN_NOISE_3_0DB,",
          "65:     T_HUFFMAN_NOISE_BAL_3_0DB,",
          "66: };",
          "71: enum {",
          "72:     FIXFIX,",
          "73:     FIXVAR,",
          "74:     VARFIX,",
          "75:     VARVAR,",
          "76: };",
          "78: enum {",
          "79:     EXTENSION_ID_PS = 2,",
          "80: };",
          "83: static const int8_t vlc_sbr_lav[10] =",
          "84:     { 60, 60, 24, 24, 31, 31, 12, 12, 31, 12 };",
          "86: #define SBR_INIT_VLC_STATIC(num, size) \\",
          "87:     INIT_VLC_STATIC(&vlc_sbr[num], 9, sbr_tmp[num].table_size / sbr_tmp[num].elem_size,     \\",
          "88:                     sbr_tmp[num].sbr_bits ,                      1,                      1, \\",
          "89:                     sbr_tmp[num].sbr_codes, sbr_tmp[num].elem_size, sbr_tmp[num].elem_size, \\",
          "90:                     size)",
          "92: #define SBR_VLC_ROW(name) \\",
          "93:     { name ## _codes, name ## _bits, sizeof(name ## _codes), sizeof(name ## _codes[0]) }",
          "97: av_cold void ff_aac_sbr_init(void)",
          "98: {",
          "99:     static const struct {",
          "100:         const void *sbr_codes, *sbr_bits;",
          "101:         const unsigned int table_size, elem_size;",
          "102:     } sbr_tmp[] = {",
          "103:         SBR_VLC_ROW(t_huffman_env_1_5dB),",
          "104:         SBR_VLC_ROW(f_huffman_env_1_5dB),",
          "105:         SBR_VLC_ROW(t_huffman_env_bal_1_5dB),",
          "106:         SBR_VLC_ROW(f_huffman_env_bal_1_5dB),",
          "107:         SBR_VLC_ROW(t_huffman_env_3_0dB),",
          "108:         SBR_VLC_ROW(f_huffman_env_3_0dB),",
          "109:         SBR_VLC_ROW(t_huffman_env_bal_3_0dB),",
          "110:         SBR_VLC_ROW(f_huffman_env_bal_3_0dB),",
          "111:         SBR_VLC_ROW(t_huffman_noise_3_0dB),",
          "112:         SBR_VLC_ROW(t_huffman_noise_bal_3_0dB),",
          "113:     };",
          "116:     SBR_INIT_VLC_STATIC(0, 1098);",
          "117:     SBR_INIT_VLC_STATIC(1, 1092);",
          "118:     SBR_INIT_VLC_STATIC(2, 768);",
          "119:     SBR_INIT_VLC_STATIC(3, 1026);",
          "120:     SBR_INIT_VLC_STATIC(4, 1058);",
          "121:     SBR_INIT_VLC_STATIC(5, 1052);",
          "122:     SBR_INIT_VLC_STATIC(6, 544);",
          "123:     SBR_INIT_VLC_STATIC(7, 544);",
          "124:     SBR_INIT_VLC_STATIC(8, 592);",
          "125:     SBR_INIT_VLC_STATIC(9, 512);",
          "127:     aacsbr_tableinit();",
          "129:     ff_ps_init();",
          "130: }",
          "133: static void sbr_turnoff(SpectralBandReplication *sbr) {",
          "134:     sbr->start = 0;",
          "136:     sbr->kx[1] = 32; //Typo in spec, kx' inits to 32",
          "137:     sbr->m[1] = 0;",
          "139:     sbr->data[0].e_a[1] = sbr->data[1].e_a[1] = -1;",
          "140:     memset(&sbr->spectrum_params, -1, sizeof(SpectrumParameters));",
          "141: }",
          "143: av_cold void ff_aac_sbr_ctx_init(AACContext *ac, SpectralBandReplication *sbr)",
          "144: {",
          "145:     if(sbr->mdct.mdct_bits)",
          "146:         return;",
          "147:     sbr->kx[0] = sbr->kx[1];",
          "148:     sbr_turnoff(sbr);",
          "149:     sbr->data[0].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);",
          "150:     sbr->data[1].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);",
          "154:     ff_mdct_init(&sbr->mdct,     7, 1, 1.0 / (64 * 32768.0));",
          "155:     ff_mdct_init(&sbr->mdct_ana, 7, 1, -2.0 * 32768.0);",
          "156:     ff_ps_ctx_init(&sbr->ps);",
          "157:     ff_sbrdsp_init(&sbr->dsp);",
          "158:     aacsbr_func_ptr_init(&sbr->c);",
          "159: }",
          "161: av_cold void ff_aac_sbr_ctx_close(SpectralBandReplication *sbr)",
          "162: {",
          "163:     ff_mdct_end(&sbr->mdct);",
          "164:     ff_mdct_end(&sbr->mdct_ana);",
          "165: }",
          "167: static int qsort_comparison_function_int16(const void *a, const void *b)",
          "168: {",
          "169:     return *(const int16_t *)a - *(const int16_t *)b;",
          "170: }",
          "172: static inline int in_table_int16(const int16_t *table, int last_el, int16_t needle)",
          "173: {",
          "174:     int i;",
          "175:     for (i = 0; i <= last_el; i++)",
          "176:         if (table[i] == needle)",
          "177:             return 1;",
          "178:     return 0;",
          "179: }",
          "182: static void sbr_make_f_tablelim(SpectralBandReplication *sbr)",
          "183: {",
          "184:     int k;",
          "185:     if (sbr->bs_limiter_bands > 0) {",
          "186:         static const float bands_warped[3] = { 1.32715174233856803909f,   //2^(0.49/1.2)",
          "187:                                                1.18509277094158210129f,   //2^(0.49/2)",
          "188:                                                1.11987160404675912501f }; //2^(0.49/3)",
          "189:         const float lim_bands_per_octave_warped = bands_warped[sbr->bs_limiter_bands - 1];",
          "190:         int16_t patch_borders[7];",
          "191:         uint16_t *in = sbr->f_tablelim + 1, *out = sbr->f_tablelim;",
          "193:         patch_borders[0] = sbr->kx[1];",
          "194:         for (k = 1; k <= sbr->num_patches; k++)",
          "195:             patch_borders[k] = patch_borders[k-1] + sbr->patch_num_subbands[k-1];",
          "197:         memcpy(sbr->f_tablelim, sbr->f_tablelow,",
          "198:                (sbr->n[0] + 1) * sizeof(sbr->f_tablelow[0]));",
          "199:         if (sbr->num_patches > 1)",
          "200:             memcpy(sbr->f_tablelim + sbr->n[0] + 1, patch_borders + 1,",
          "201:                    (sbr->num_patches - 1) * sizeof(patch_borders[0]));",
          "203:         qsort(sbr->f_tablelim, sbr->num_patches + sbr->n[0],",
          "204:               sizeof(sbr->f_tablelim[0]),",
          "205:               qsort_comparison_function_int16);",
          "207:         sbr->n_lim = sbr->n[0] + sbr->num_patches - 1;",
          "208:         while (out < sbr->f_tablelim + sbr->n_lim) {",
          "209:             if (*in >= *out * lim_bands_per_octave_warped) {",
          "211:             } else if (*in == *out ||",
          "212:                 !in_table_int16(patch_borders, sbr->num_patches, *in)) {",
          "213:                 in++;",
          "214:                 sbr->n_lim--;",
          "215:             } else if (!in_table_int16(patch_borders, sbr->num_patches, *out)) {",
          "217:                 sbr->n_lim--;",
          "218:             } else {",
          "220:             }",
          "221:         }",
          "222:     } else {",
          "223:         sbr->f_tablelim[0] = sbr->f_tablelow[0];",
          "224:         sbr->f_tablelim[1] = sbr->f_tablelow[sbr->n[0]];",
          "225:         sbr->n_lim = 1;",
          "226:     }",
          "227: }",
          "229: static unsigned int read_sbr_header(SpectralBandReplication *sbr, GetBitContext *gb)",
          "230: {",
          "231:     unsigned int cnt = get_bits_count(gb);",
          "232:     uint8_t bs_header_extra_1;",
          "233:     uint8_t bs_header_extra_2;",
          "234:     int old_bs_limiter_bands = sbr->bs_limiter_bands;",
          "235:     SpectrumParameters old_spectrum_params;",
          "237:     sbr->start = 1;",
          "240:     memcpy(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters));",
          "242:     sbr->bs_amp_res_header              = get_bits1(gb);",
          "243:     sbr->spectrum_params.bs_start_freq  = get_bits(gb, 4);",
          "244:     sbr->spectrum_params.bs_stop_freq   = get_bits(gb, 4);",
          "245:     sbr->spectrum_params.bs_xover_band  = get_bits(gb, 3);",
          "246:                                           skip_bits(gb, 2); // bs_reserved",
          "248:     bs_header_extra_1 = get_bits1(gb);",
          "249:     bs_header_extra_2 = get_bits1(gb);",
          "251:     if (bs_header_extra_1) {",
          "252:         sbr->spectrum_params.bs_freq_scale  = get_bits(gb, 2);",
          "253:         sbr->spectrum_params.bs_alter_scale = get_bits1(gb);",
          "254:         sbr->spectrum_params.bs_noise_bands = get_bits(gb, 2);",
          "255:     } else {",
          "256:         sbr->spectrum_params.bs_freq_scale  = 2;",
          "257:         sbr->spectrum_params.bs_alter_scale = 1;",
          "258:         sbr->spectrum_params.bs_noise_bands = 2;",
          "259:     }",
          "262:     if (memcmp(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters)))",
          "263:         sbr->reset = 1;",
          "265:     if (bs_header_extra_2) {",
          "266:         sbr->bs_limiter_bands  = get_bits(gb, 2);",
          "267:         sbr->bs_limiter_gains  = get_bits(gb, 2);",
          "268:         sbr->bs_interpol_freq  = get_bits1(gb);",
          "269:         sbr->bs_smoothing_mode = get_bits1(gb);",
          "270:     } else {",
          "271:         sbr->bs_limiter_bands  = 2;",
          "272:         sbr->bs_limiter_gains  = 2;",
          "273:         sbr->bs_interpol_freq  = 1;",
          "274:         sbr->bs_smoothing_mode = 1;",
          "275:     }",
          "277:     if (sbr->bs_limiter_bands != old_bs_limiter_bands && !sbr->reset)",
          "278:         sbr_make_f_tablelim(sbr);",
          "280:     return get_bits_count(gb) - cnt;",
          "281: }",
          "283: static int array_min_int16(const int16_t *array, int nel)",
          "284: {",
          "285:     int i, min = array[0];",
          "286:     for (i = 1; i < nel; i++)",
          "287:         min = FFMIN(array[i], min);",
          "288:     return min;",
          "289: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "306:     bands[num_bands-1] = stop - previous;",
          "307: }",
          "1127: static void sbr_dequant(SpectralBandReplication *sbr, int id_aac)",
          "1128: {",
          "",
          "[Removed Lines]",
          "309: static int check_n_master(AVCodecContext *avctx, int n_master, int bs_xover_band)",
          "310: {",
          "312:     if (n_master <= 0) {",
          "313:         av_log(avctx, AV_LOG_ERROR, \"Invalid n_master: %d\\n\", n_master);",
          "314:         return -1;",
          "315:     }",
          "316:     if (bs_xover_band >= n_master) {",
          "317:         av_log(avctx, AV_LOG_ERROR,",
          "318:                \"Invalid bitstream, crossover band index beyond array bounds: %d\\n\",",
          "319:                bs_xover_band);",
          "320:         return -1;",
          "321:     }",
          "322:     return 0;",
          "323: }",
          "326: static int sbr_make_f_master(AACContext *ac, SpectralBandReplication *sbr,",
          "327:                              SpectrumParameters *spectrum)",
          "328: {",
          "329:     unsigned int temp, max_qmf_subbands = 0;",
          "330:     unsigned int start_min, stop_min;",
          "331:     int k;",
          "332:     const int8_t *sbr_offset_ptr;",
          "333:     int16_t stop_dk[13];",
          "335:     if (sbr->sample_rate < 32000) {",
          "336:         temp = 3000;",
          "337:     } else if (sbr->sample_rate < 64000) {",
          "338:         temp = 4000;",
          "339:     } else",
          "340:         temp = 5000;",
          "342:     switch (sbr->sample_rate) {",
          "343:     case 16000:",
          "344:         sbr_offset_ptr = sbr_offset[0];",
          "345:         break;",
          "346:     case 22050:",
          "347:         sbr_offset_ptr = sbr_offset[1];",
          "348:         break;",
          "349:     case 24000:",
          "350:         sbr_offset_ptr = sbr_offset[2];",
          "351:         break;",
          "352:     case 32000:",
          "353:         sbr_offset_ptr = sbr_offset[3];",
          "354:         break;",
          "355:     case 44100: case 48000: case 64000:",
          "356:         sbr_offset_ptr = sbr_offset[4];",
          "357:         break;",
          "358:     case 88200: case 96000: case 128000: case 176400: case 192000:",
          "359:         sbr_offset_ptr = sbr_offset[5];",
          "360:         break;",
          "361:     default:",
          "362:         av_log(ac->avctx, AV_LOG_ERROR,",
          "363:                \"Unsupported sample rate for SBR: %d\\n\", sbr->sample_rate);",
          "364:         return -1;",
          "365:     }",
          "367:     start_min = ((temp << 7) + (sbr->sample_rate >> 1)) / sbr->sample_rate;",
          "368:     stop_min  = ((temp << 8) + (sbr->sample_rate >> 1)) / sbr->sample_rate;",
          "370:     sbr->k[0] = start_min + sbr_offset_ptr[spectrum->bs_start_freq];",
          "372:     if (spectrum->bs_stop_freq < 14) {",
          "373:         sbr->k[2] = stop_min;",
          "374:         make_bands(stop_dk, stop_min, 64, 13);",
          "375:         qsort(stop_dk, 13, sizeof(stop_dk[0]), qsort_comparison_function_int16);",
          "376:         for (k = 0; k < spectrum->bs_stop_freq; k++)",
          "377:             sbr->k[2] += stop_dk[k];",
          "378:     } else if (spectrum->bs_stop_freq == 14) {",
          "379:         sbr->k[2] = 2*sbr->k[0];",
          "380:     } else if (spectrum->bs_stop_freq == 15) {",
          "381:         sbr->k[2] = 3*sbr->k[0];",
          "382:     } else {",
          "383:         av_log(ac->avctx, AV_LOG_ERROR,",
          "384:                \"Invalid bs_stop_freq: %d\\n\", spectrum->bs_stop_freq);",
          "385:         return -1;",
          "386:     }",
          "387:     sbr->k[2] = FFMIN(64, sbr->k[2]);",
          "390:     if (sbr->sample_rate <= 32000) {",
          "391:         max_qmf_subbands = 48;",
          "392:     } else if (sbr->sample_rate == 44100) {",
          "393:         max_qmf_subbands = 35;",
          "394:     } else if (sbr->sample_rate >= 48000)",
          "395:         max_qmf_subbands = 32;",
          "396:     else",
          "397:         av_assert0(0);",
          "399:     if (sbr->k[2] - sbr->k[0] > max_qmf_subbands) {",
          "400:         av_log(ac->avctx, AV_LOG_ERROR,",
          "401:                \"Invalid bitstream, too many QMF subbands: %d\\n\", sbr->k[2] - sbr->k[0]);",
          "402:         return -1;",
          "403:     }",
          "405:     if (!spectrum->bs_freq_scale) {",
          "406:         int dk, k2diff;",
          "408:         dk = spectrum->bs_alter_scale + 1;",
          "409:         sbr->n_master = ((sbr->k[2] - sbr->k[0] + (dk&2)) >> dk) << 1;",
          "410:         if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))",
          "411:             return -1;",
          "413:         for (k = 1; k <= sbr->n_master; k++)",
          "414:             sbr->f_master[k] = dk;",
          "416:         k2diff = sbr->k[2] - sbr->k[0] - sbr->n_master * dk;",
          "417:         if (k2diff < 0) {",
          "418:             sbr->f_master[1]--;",
          "419:             sbr->f_master[2]-= (k2diff < -1);",
          "420:         } else if (k2diff) {",
          "421:             sbr->f_master[sbr->n_master]++;",
          "422:         }",
          "424:         sbr->f_master[0] = sbr->k[0];",
          "425:         for (k = 1; k <= sbr->n_master; k++)",
          "426:             sbr->f_master[k] += sbr->f_master[k - 1];",
          "428:     } else {",
          "429:         int half_bands = 7 - spectrum->bs_freq_scale;      // bs_freq_scale  = {1,2,3}",
          "430:         int two_regions, num_bands_0;",
          "431:         int vdk0_max, vdk1_min;",
          "432:         int16_t vk0[49];",
          "434:         if (49 * sbr->k[2] > 110 * sbr->k[0]) {",
          "435:             two_regions = 1;",
          "436:             sbr->k[1] = 2 * sbr->k[0];",
          "437:         } else {",
          "438:             two_regions = 0;",
          "439:             sbr->k[1] = sbr->k[2];",
          "440:         }",
          "442:         num_bands_0 = lrintf(half_bands * log2f(sbr->k[1] / (float)sbr->k[0])) * 2;",
          "444:         if (num_bands_0 <= 0) { // Requirements (14496-3 sp04 p205)",
          "445:             av_log(ac->avctx, AV_LOG_ERROR, \"Invalid num_bands_0: %d\\n\", num_bands_0);",
          "446:             return -1;",
          "447:         }",
          "449:         vk0[0] = 0;",
          "451:         make_bands(vk0+1, sbr->k[0], sbr->k[1], num_bands_0);",
          "453:         qsort(vk0 + 1, num_bands_0, sizeof(vk0[1]), qsort_comparison_function_int16);",
          "454:         vdk0_max = vk0[num_bands_0];",
          "456:         vk0[0] = sbr->k[0];",
          "457:         for (k = 1; k <= num_bands_0; k++) {",
          "458:             if (vk0[k] <= 0) { // Requirements (14496-3 sp04 p205)",
          "459:                 av_log(ac->avctx, AV_LOG_ERROR, \"Invalid vDk0[%d]: %d\\n\", k, vk0[k]);",
          "460:                 return -1;",
          "461:             }",
          "462:             vk0[k] += vk0[k-1];",
          "463:         }",
          "465:         if (two_regions) {",
          "466:             int16_t vk1[49];",
          "467:             float invwarp = spectrum->bs_alter_scale ? 0.76923076923076923077f",
          "468:                                                      : 1.0f; // bs_alter_scale = {0,1}",
          "469:             int num_bands_1 = lrintf(half_bands * invwarp *",
          "470:                                      log2f(sbr->k[2] / (float)sbr->k[1])) * 2;",
          "472:             make_bands(vk1+1, sbr->k[1], sbr->k[2], num_bands_1);",
          "474:             vdk1_min = array_min_int16(vk1 + 1, num_bands_1);",
          "476:             if (vdk1_min < vdk0_max) {",
          "477:                 int change;",
          "478:                 qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);",
          "479:                 change = FFMIN(vdk0_max - vk1[1], (vk1[num_bands_1] - vk1[1]) >> 1);",
          "480:                 vk1[1]           += change;",
          "481:                 vk1[num_bands_1] -= change;",
          "482:             }",
          "484:             qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);",
          "486:             vk1[0] = sbr->k[1];",
          "487:             for (k = 1; k <= num_bands_1; k++) {",
          "488:                 if (vk1[k] <= 0) { // Requirements (14496-3 sp04 p205)",
          "489:                     av_log(ac->avctx, AV_LOG_ERROR, \"Invalid vDk1[%d]: %d\\n\", k, vk1[k]);",
          "490:                     return -1;",
          "491:                 }",
          "492:                 vk1[k] += vk1[k-1];",
          "493:             }",
          "495:             sbr->n_master = num_bands_0 + num_bands_1;",
          "496:             if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))",
          "497:                 return -1;",
          "498:             memcpy(&sbr->f_master[0],               vk0,",
          "499:                    (num_bands_0 + 1) * sizeof(sbr->f_master[0]));",
          "500:             memcpy(&sbr->f_master[num_bands_0 + 1], vk1 + 1,",
          "501:                     num_bands_1      * sizeof(sbr->f_master[0]));",
          "503:         } else {",
          "504:             sbr->n_master = num_bands_0;",
          "505:             if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))",
          "506:                 return -1;",
          "507:             memcpy(sbr->f_master, vk0, (num_bands_0 + 1) * sizeof(sbr->f_master[0]));",
          "508:         }",
          "509:     }",
          "511:     return 0;",
          "512: }",
          "515: static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)",
          "516: {",
          "517:     int i, k, last_k = -1, last_msb = -1, sb = 0;",
          "518:     int msb = sbr->k[0];",
          "519:     int usb = sbr->kx[1];",
          "520:     int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;",
          "522:     sbr->num_patches = 0;",
          "524:     if (goal_sb < sbr->kx[1] + sbr->m[1]) {",
          "525:         for (k = 0; sbr->f_master[k] < goal_sb; k++) ;",
          "526:     } else",
          "527:         k = sbr->n_master;",
          "529:     do {",
          "530:         int odd = 0;",
          "531:         if (k == last_k && msb == last_msb) {",
          "532:             av_log(ac->avctx, AV_LOG_ERROR, \"patch construction failed\\n\");",
          "533:             return AVERROR_INVALIDDATA;",
          "534:         }",
          "535:         last_k = k;",
          "536:         last_msb = msb;",
          "537:         for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {",
          "538:             sb = sbr->f_master[i];",
          "539:             odd = (sb + sbr->k[0]) & 1;",
          "540:         }",
          "546:         if (sbr->num_patches > 5) {",
          "547:             av_log(ac->avctx, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);",
          "548:             return -1;",
          "549:         }",
          "551:         sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);",
          "552:         sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];",
          "554:         if (sbr->patch_num_subbands[sbr->num_patches] > 0) {",
          "555:             usb = sb;",
          "556:             msb = sb;",
          "557:             sbr->num_patches++;",
          "558:         } else",
          "559:             msb = sbr->kx[1];",
          "561:         if (sbr->f_master[k] - sb < 3)",
          "562:             k = sbr->n_master;",
          "563:     } while (sb != sbr->kx[1] + sbr->m[1]);",
          "565:     if (sbr->num_patches > 1 &&",
          "566:         sbr->patch_num_subbands[sbr->num_patches - 1] < 3)",
          "567:         sbr->num_patches--;",
          "569:     return 0;",
          "570: }",
          "573: static int sbr_make_f_derived(AACContext *ac, SpectralBandReplication *sbr)",
          "574: {",
          "575:     int k, temp;",
          "577:     sbr->n[1] = sbr->n_master - sbr->spectrum_params.bs_xover_band;",
          "578:     sbr->n[0] = (sbr->n[1] + 1) >> 1;",
          "580:     memcpy(sbr->f_tablehigh, &sbr->f_master[sbr->spectrum_params.bs_xover_band],",
          "581:            (sbr->n[1] + 1) * sizeof(sbr->f_master[0]));",
          "582:     sbr->m[1] = sbr->f_tablehigh[sbr->n[1]] - sbr->f_tablehigh[0];",
          "583:     sbr->kx[1] = sbr->f_tablehigh[0];",
          "586:     if (sbr->kx[1] + sbr->m[1] > 64) {",
          "587:         av_log(ac->avctx, AV_LOG_ERROR,",
          "588:                \"Stop frequency border too high: %d\\n\", sbr->kx[1] + sbr->m[1]);",
          "589:         return -1;",
          "590:     }",
          "591:     if (sbr->kx[1] > 32) {",
          "592:         av_log(ac->avctx, AV_LOG_ERROR, \"Start frequency border too high: %d\\n\", sbr->kx[1]);",
          "593:         return -1;",
          "594:     }",
          "596:     sbr->f_tablelow[0] = sbr->f_tablehigh[0];",
          "597:     temp = sbr->n[1] & 1;",
          "598:     for (k = 1; k <= sbr->n[0]; k++)",
          "599:         sbr->f_tablelow[k] = sbr->f_tablehigh[2 * k - temp];",
          "601:     sbr->n_q = FFMAX(1, lrintf(sbr->spectrum_params.bs_noise_bands *",
          "602:                                log2f(sbr->k[2] / (float)sbr->kx[1]))); // 0 <= bs_noise_bands <= 3",
          "603:     if (sbr->n_q > 5) {",
          "604:         av_log(ac->avctx, AV_LOG_ERROR, \"Too many noise floor scale factors: %d\\n\", sbr->n_q);",
          "605:         return -1;",
          "606:     }",
          "608:     sbr->f_tablenoise[0] = sbr->f_tablelow[0];",
          "609:     temp = 0;",
          "610:     for (k = 1; k <= sbr->n_q; k++) {",
          "611:         temp += (sbr->n[0] - temp) / (sbr->n_q + 1 - k);",
          "612:         sbr->f_tablenoise[k] = sbr->f_tablelow[temp];",
          "613:     }",
          "615:     if (sbr_hf_calc_npatches(ac, sbr) < 0)",
          "616:         return -1;",
          "618:     sbr_make_f_tablelim(sbr);",
          "620:     sbr->data[0].f_indexnoise = 0;",
          "621:     sbr->data[1].f_indexnoise = 0;",
          "623:     return 0;",
          "624: }",
          "626: static av_always_inline void get_bits1_vector(GetBitContext *gb, uint8_t *vec,",
          "627:                                               int elements)",
          "628: {",
          "629:     int i;",
          "630:     for (i = 0; i < elements; i++) {",
          "631:         vec[i] = get_bits1(gb);",
          "632:     }",
          "633: }",
          "636: static const int8_t ceil_log2[] = {",
          "637:     0, 1, 2, 2, 3, 3,",
          "638: };",
          "640: static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,",
          "641:                          GetBitContext *gb, SBRData *ch_data)",
          "642: {",
          "643:     int i;",
          "644:     int bs_pointer = 0;",
          "646:     int abs_bord_trail = 16;",
          "647:     int num_rel_lead, num_rel_trail;",
          "648:     unsigned bs_num_env_old = ch_data->bs_num_env;",
          "650:     ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];",
          "651:     ch_data->bs_amp_res = sbr->bs_amp_res_header;",
          "652:     ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];",
          "654:     switch (ch_data->bs_frame_class = get_bits(gb, 2)) {",
          "655:     case FIXFIX:",
          "656:         ch_data->bs_num_env                 = 1 << get_bits(gb, 2);",
          "657:         num_rel_lead                        = ch_data->bs_num_env - 1;",
          "658:         if (ch_data->bs_num_env == 1)",
          "659:             ch_data->bs_amp_res = 0;",
          "661:         if (ch_data->bs_num_env > 4) {",
          "662:             av_log(ac->avctx, AV_LOG_ERROR,",
          "663:                    \"Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\\n\",",
          "664:                    ch_data->bs_num_env);",
          "665:             return -1;",
          "666:         }",
          "668:         ch_data->t_env[0]                   = 0;",
          "669:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "671:         abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /",
          "672:                    ch_data->bs_num_env;",
          "673:         for (i = 0; i < num_rel_lead; i++)",
          "674:             ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;",
          "676:         ch_data->bs_freq_res[1] = get_bits1(gb);",
          "677:         for (i = 1; i < ch_data->bs_num_env; i++)",
          "678:             ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];",
          "679:         break;",
          "680:     case FIXVAR:",
          "681:         abs_bord_trail                     += get_bits(gb, 2);",
          "682:         num_rel_trail                       = get_bits(gb, 2);",
          "683:         ch_data->bs_num_env                 = num_rel_trail + 1;",
          "684:         ch_data->t_env[0]                   = 0;",
          "685:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "687:         for (i = 0; i < num_rel_trail; i++)",
          "688:             ch_data->t_env[ch_data->bs_num_env - 1 - i] =",
          "689:                 ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;",
          "691:         bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);",
          "693:         for (i = 0; i < ch_data->bs_num_env; i++)",
          "694:             ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);",
          "695:         break;",
          "696:     case VARFIX:",
          "697:         ch_data->t_env[0]                   = get_bits(gb, 2);",
          "698:         num_rel_lead                        = get_bits(gb, 2);",
          "699:         ch_data->bs_num_env                 = num_rel_lead + 1;",
          "700:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "702:         for (i = 0; i < num_rel_lead; i++)",
          "703:             ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;",
          "705:         bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);",
          "707:         get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);",
          "708:         break;",
          "709:     case VARVAR:",
          "710:         ch_data->t_env[0]                   = get_bits(gb, 2);",
          "711:         abs_bord_trail                     += get_bits(gb, 2);",
          "712:         num_rel_lead                        = get_bits(gb, 2);",
          "713:         num_rel_trail                       = get_bits(gb, 2);",
          "714:         ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;",
          "716:         if (ch_data->bs_num_env > 5) {",
          "717:             av_log(ac->avctx, AV_LOG_ERROR,",
          "718:                    \"Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\\n\",",
          "719:                    ch_data->bs_num_env);",
          "720:             return -1;",
          "721:         }",
          "723:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "725:         for (i = 0; i < num_rel_lead; i++)",
          "726:             ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;",
          "727:         for (i = 0; i < num_rel_trail; i++)",
          "728:             ch_data->t_env[ch_data->bs_num_env - 1 - i] =",
          "729:                 ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;",
          "731:         bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);",
          "733:         get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);",
          "734:         break;",
          "735:     }",
          "737:     av_assert0(bs_pointer >= 0);",
          "738:     if (bs_pointer > ch_data->bs_num_env + 1) {",
          "739:         av_log(ac->avctx, AV_LOG_ERROR,",
          "740:                \"Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\\n\",",
          "741:                bs_pointer);",
          "742:         return -1;",
          "743:     }",
          "745:     for (i = 1; i <= ch_data->bs_num_env; i++) {",
          "746:         if (ch_data->t_env[i-1] > ch_data->t_env[i]) {",
          "747:             av_log(ac->avctx, AV_LOG_ERROR, \"Non monotone time borders\\n\");",
          "748:             return -1;",
          "749:         }",
          "750:     }",
          "752:     ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;",
          "754:     ch_data->t_q[0]                     = ch_data->t_env[0];",
          "755:     ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];",
          "756:     if (ch_data->bs_num_noise > 1) {",
          "757:         int idx;",
          "758:         if (ch_data->bs_frame_class == FIXFIX) {",
          "759:             idx = ch_data->bs_num_env >> 1;",
          "760:         } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR",
          "761:             idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);",
          "762:         } else { // VARFIX",
          "763:             if (!bs_pointer)",
          "764:                 idx = 1;",
          "765:             else if (bs_pointer == 1)",
          "766:                 idx = ch_data->bs_num_env - 1;",
          "767:             else // bs_pointer > 1",
          "768:                 idx = bs_pointer - 1;",
          "769:         }",
          "770:         ch_data->t_q[1] = ch_data->t_env[idx];",
          "771:     }",
          "773:     ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev",
          "774:     ch_data->e_a[1] = -1;",
          "775:     if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0",
          "776:         ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;",
          "777:     } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1",
          "778:         ch_data->e_a[1] = bs_pointer - 1;",
          "780:     return 0;",
          "781: }",
          "783: static void copy_sbr_grid(SBRData *dst, const SBRData *src) {",
          "785:     dst->bs_freq_res[0]    = dst->bs_freq_res[dst->bs_num_env];",
          "786:     dst->t_env_num_env_old = dst->t_env[dst->bs_num_env];",
          "787:     dst->e_a[0]            = -(dst->e_a[1] != dst->bs_num_env);",
          "790:     memcpy(dst->bs_freq_res+1, src->bs_freq_res+1, sizeof(dst->bs_freq_res)-sizeof(*dst->bs_freq_res));",
          "791:     memcpy(dst->t_env,         src->t_env,         sizeof(dst->t_env));",
          "792:     memcpy(dst->t_q,           src->t_q,           sizeof(dst->t_q));",
          "793:     dst->bs_num_env        = src->bs_num_env;",
          "794:     dst->bs_amp_res        = src->bs_amp_res;",
          "795:     dst->bs_num_noise      = src->bs_num_noise;",
          "796:     dst->bs_frame_class    = src->bs_frame_class;",
          "797:     dst->e_a[1]            = src->e_a[1];",
          "798: }",
          "801: static void read_sbr_dtdf(SpectralBandReplication *sbr, GetBitContext *gb,",
          "802:                           SBRData *ch_data)",
          "803: {",
          "804:     get_bits1_vector(gb, ch_data->bs_df_env,   ch_data->bs_num_env);",
          "805:     get_bits1_vector(gb, ch_data->bs_df_noise, ch_data->bs_num_noise);",
          "806: }",
          "809: static void read_sbr_invf(SpectralBandReplication *sbr, GetBitContext *gb,",
          "810:                           SBRData *ch_data)",
          "811: {",
          "812:     int i;",
          "814:     memcpy(ch_data->bs_invf_mode[1], ch_data->bs_invf_mode[0], 5 * sizeof(uint8_t));",
          "815:     for (i = 0; i < sbr->n_q; i++)",
          "816:         ch_data->bs_invf_mode[0][i] = get_bits(gb, 2);",
          "817: }",
          "819: static void read_sbr_envelope(SpectralBandReplication *sbr, GetBitContext *gb,",
          "820:                               SBRData *ch_data, int ch)",
          "821: {",
          "822:     int bits;",
          "823:     int i, j, k;",
          "824:     VLC_TYPE (*t_huff)[2], (*f_huff)[2];",
          "825:     int t_lav, f_lav;",
          "826:     const int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;",
          "827:     const int odd = sbr->n[1] & 1;",
          "829:     if (sbr->bs_coupling && ch) {",
          "830:         if (ch_data->bs_amp_res) {",
          "831:             bits   = 5;",
          "832:             t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_3_0DB].table;",
          "833:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_3_0DB];",
          "834:             f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;",
          "835:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];",
          "836:         } else {",
          "837:             bits   = 6;",
          "838:             t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_1_5DB].table;",
          "839:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_1_5DB];",
          "840:             f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_1_5DB].table;",
          "841:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_1_5DB];",
          "842:         }",
          "843:     } else {",
          "844:         if (ch_data->bs_amp_res) {",
          "845:             bits   = 6;",
          "846:             t_huff = vlc_sbr[T_HUFFMAN_ENV_3_0DB].table;",
          "847:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_3_0DB];",
          "848:             f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;",
          "849:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];",
          "850:         } else {",
          "851:             bits   = 7;",
          "852:             t_huff = vlc_sbr[T_HUFFMAN_ENV_1_5DB].table;",
          "853:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_1_5DB];",
          "854:             f_huff = vlc_sbr[F_HUFFMAN_ENV_1_5DB].table;",
          "855:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_1_5DB];",
          "856:         }",
          "857:     }",
          "859:     for (i = 0; i < ch_data->bs_num_env; i++) {",
          "860:         if (ch_data->bs_df_env[i]) {",
          "862:             if (ch_data->bs_freq_res[i + 1] == ch_data->bs_freq_res[i]) {",
          "863:                 for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)",
          "864:                     ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);",
          "865:             } else if (ch_data->bs_freq_res[i + 1]) {",
          "866:                 for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {",
          "867:                     k = (j + odd) >> 1; // find k such that f_tablelow[k] <= f_tablehigh[j] < f_tablelow[k + 1]",
          "868:                     ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);",
          "869:                 }",
          "870:             } else {",
          "871:                 for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {",
          "872:                     k = j ? 2*j - odd : 0; // find k such that f_tablehigh[k] == f_tablelow[j]",
          "873:                     ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);",
          "874:                 }",
          "875:             }",
          "876:         } else {",
          "877:             ch_data->env_facs[i + 1][0] = delta * get_bits(gb, bits); // bs_env_start_value_balance",
          "878:             for (j = 1; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)",
          "879:                 ch_data->env_facs[i + 1][j] = ch_data->env_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);",
          "880:         }",
          "881:     }",
          "884:     memcpy(ch_data->env_facs[0], ch_data->env_facs[ch_data->bs_num_env],",
          "885:            sizeof(ch_data->env_facs[0]));",
          "886: }",
          "888: static void read_sbr_noise(SpectralBandReplication *sbr, GetBitContext *gb,",
          "889:                            SBRData *ch_data, int ch)",
          "890: {",
          "891:     int i, j;",
          "892:     VLC_TYPE (*t_huff)[2], (*f_huff)[2];",
          "893:     int t_lav, f_lav;",
          "894:     int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;",
          "896:     if (sbr->bs_coupling && ch) {",
          "897:         t_huff = vlc_sbr[T_HUFFMAN_NOISE_BAL_3_0DB].table;",
          "898:         t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_BAL_3_0DB];",
          "899:         f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;",
          "900:         f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];",
          "901:     } else {",
          "902:         t_huff = vlc_sbr[T_HUFFMAN_NOISE_3_0DB].table;",
          "903:         t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_3_0DB];",
          "904:         f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;",
          "905:         f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];",
          "906:     }",
          "908:     for (i = 0; i < ch_data->bs_num_noise; i++) {",
          "909:         if (ch_data->bs_df_noise[i]) {",
          "910:             for (j = 0; j < sbr->n_q; j++)",
          "911:                 ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 2) - t_lav);",
          "912:         } else {",
          "913:             ch_data->noise_facs[i + 1][0] = delta * get_bits(gb, 5); // bs_noise_start_value_balance or bs_noise_start_value_level",
          "914:             for (j = 1; j < sbr->n_q; j++)",
          "915:                 ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);",
          "916:         }",
          "917:     }",
          "920:     memcpy(ch_data->noise_facs[0], ch_data->noise_facs[ch_data->bs_num_noise],",
          "921:            sizeof(ch_data->noise_facs[0]));",
          "922: }",
          "924: static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,",
          "925:                                GetBitContext *gb,",
          "926:                                int bs_extension_id, int *num_bits_left)",
          "927: {",
          "928:     switch (bs_extension_id) {",
          "929:     case EXTENSION_ID_PS:",
          "930:         if (!ac->oc[1].m4ac.ps) {",
          "931:             av_log(ac->avctx, AV_LOG_ERROR, \"Parametric Stereo signaled to be not-present but was found in the bitstream.\\n\");",
          "932:             skip_bits_long(gb, *num_bits_left); // bs_fill_bits",
          "934:         } else {",
          "935: #if 1",
          "937:             ac->avctx->profile = FF_PROFILE_AAC_HE_V2;",
          "938: #else",
          "939:             avpriv_report_missing_feature(ac->avctx, \"Parametric Stereo\");",
          "940:             skip_bits_long(gb, *num_bits_left); // bs_fill_bits",
          "942: #endif",
          "943:         }",
          "944:         break;",
          "945:     default:",
          "947:         if (bs_extension_id || *num_bits_left > 16 || show_bits(gb, *num_bits_left))",
          "948:             avpriv_request_sample(ac->avctx, \"Reserved SBR extensions\");",
          "949:         skip_bits_long(gb, *num_bits_left); // bs_fill_bits",
          "951:         break;",
          "952:     }",
          "953: }",
          "955: static int read_sbr_single_channel_element(AACContext *ac,",
          "956:                                             SpectralBandReplication *sbr,",
          "957:                                             GetBitContext *gb)",
          "958: {",
          "959:     if (get_bits1(gb)) // bs_data_extra",
          "960:         skip_bits(gb, 4); // bs_reserved",
          "962:     if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))",
          "963:         return -1;",
          "964:     read_sbr_dtdf(sbr, gb, &sbr->data[0]);",
          "965:     read_sbr_invf(sbr, gb, &sbr->data[0]);",
          "966:     read_sbr_envelope(sbr, gb, &sbr->data[0], 0);",
          "967:     read_sbr_noise(sbr, gb, &sbr->data[0], 0);",
          "969:     if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))",
          "970:         get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);",
          "972:     return 0;",
          "973: }",
          "975: static int read_sbr_channel_pair_element(AACContext *ac,",
          "976:                                           SpectralBandReplication *sbr,",
          "977:                                           GetBitContext *gb)",
          "978: {",
          "979:     if (get_bits1(gb))    // bs_data_extra",
          "980:         skip_bits(gb, 8); // bs_reserved",
          "982:     if ((sbr->bs_coupling = get_bits1(gb))) {",
          "983:         if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))",
          "984:             return -1;",
          "985:         copy_sbr_grid(&sbr->data[1], &sbr->data[0]);",
          "986:         read_sbr_dtdf(sbr, gb, &sbr->data[0]);",
          "987:         read_sbr_dtdf(sbr, gb, &sbr->data[1]);",
          "988:         read_sbr_invf(sbr, gb, &sbr->data[0]);",
          "989:         memcpy(sbr->data[1].bs_invf_mode[1], sbr->data[1].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));",
          "990:         memcpy(sbr->data[1].bs_invf_mode[0], sbr->data[0].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));",
          "991:         read_sbr_envelope(sbr, gb, &sbr->data[0], 0);",
          "992:         read_sbr_noise(sbr, gb, &sbr->data[0], 0);",
          "993:         read_sbr_envelope(sbr, gb, &sbr->data[1], 1);",
          "994:         read_sbr_noise(sbr, gb, &sbr->data[1], 1);",
          "995:     } else {",
          "996:         if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]) ||",
          "997:             read_sbr_grid(ac, sbr, gb, &sbr->data[1]))",
          "998:             return -1;",
          "999:         read_sbr_dtdf(sbr, gb, &sbr->data[0]);",
          "1000:         read_sbr_dtdf(sbr, gb, &sbr->data[1]);",
          "1001:         read_sbr_invf(sbr, gb, &sbr->data[0]);",
          "1002:         read_sbr_invf(sbr, gb, &sbr->data[1]);",
          "1003:         read_sbr_envelope(sbr, gb, &sbr->data[0], 0);",
          "1004:         read_sbr_envelope(sbr, gb, &sbr->data[1], 1);",
          "1005:         read_sbr_noise(sbr, gb, &sbr->data[0], 0);",
          "1006:         read_sbr_noise(sbr, gb, &sbr->data[1], 1);",
          "1007:     }",
          "1009:     if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))",
          "1010:         get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);",
          "1011:     if ((sbr->data[1].bs_add_harmonic_flag = get_bits1(gb)))",
          "1012:         get_bits1_vector(gb, sbr->data[1].bs_add_harmonic, sbr->n[1]);",
          "1014:     return 0;",
          "1015: }",
          "1017: static unsigned int read_sbr_data(AACContext *ac, SpectralBandReplication *sbr,",
          "1018:                                   GetBitContext *gb, int id_aac)",
          "1019: {",
          "1020:     unsigned int cnt = get_bits_count(gb);",
          "1022:     sbr->id_aac = id_aac;",
          "1024:     if (id_aac == TYPE_SCE || id_aac == TYPE_CCE) {",
          "1025:         if (read_sbr_single_channel_element(ac, sbr, gb)) {",
          "1026:             sbr_turnoff(sbr);",
          "1027:             return get_bits_count(gb) - cnt;",
          "1028:         }",
          "1029:     } else if (id_aac == TYPE_CPE) {",
          "1030:         if (read_sbr_channel_pair_element(ac, sbr, gb)) {",
          "1031:             sbr_turnoff(sbr);",
          "1032:             return get_bits_count(gb) - cnt;",
          "1033:         }",
          "1034:     } else {",
          "1035:         av_log(ac->avctx, AV_LOG_ERROR,",
          "1036:             \"Invalid bitstream - cannot apply SBR to element type %d\\n\", id_aac);",
          "1037:         sbr_turnoff(sbr);",
          "1038:         return get_bits_count(gb) - cnt;",
          "1039:     }",
          "1040:     if (get_bits1(gb)) { // bs_extended_data",
          "1041:         int num_bits_left = get_bits(gb, 4); // bs_extension_size",
          "1042:         if (num_bits_left == 15)",
          "1043:             num_bits_left += get_bits(gb, 8); // bs_esc_count",
          "1045:         num_bits_left <<= 3;",
          "1046:         while (num_bits_left > 7) {",
          "1047:             num_bits_left -= 2;",
          "1048:             read_sbr_extension(ac, sbr, gb, get_bits(gb, 2), &num_bits_left); // bs_extension_id",
          "1049:         }",
          "1050:         if (num_bits_left < 0) {",
          "1051:             av_log(ac->avctx, AV_LOG_ERROR, \"SBR Extension over read.\\n\");",
          "1052:         }",
          "1053:         if (num_bits_left > 0)",
          "1054:             skip_bits(gb, num_bits_left);",
          "1055:     }",
          "1057:     return get_bits_count(gb) - cnt;",
          "1058: }",
          "1060: static void sbr_reset(AACContext *ac, SpectralBandReplication *sbr)",
          "1061: {",
          "1062:     int err;",
          "1063:     err = sbr_make_f_master(ac, sbr, &sbr->spectrum_params);",
          "1064:     if (err >= 0)",
          "1065:         err = sbr_make_f_derived(ac, sbr);",
          "1066:     if (err < 0) {",
          "1067:         av_log(ac->avctx, AV_LOG_ERROR,",
          "1068:                \"SBR reset failed. Switching SBR to pure upsampling mode.\\n\");",
          "1069:         sbr_turnoff(sbr);",
          "1070:     }",
          "1071: }",
          "1081: int ff_decode_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,",
          "1082:                             GetBitContext *gb_host, int crc, int cnt, int id_aac)",
          "1083: {",
          "1084:     unsigned int num_sbr_bits = 0, num_align_bits;",
          "1085:     unsigned bytes_read;",
          "1086:     GetBitContext gbc = *gb_host, *gb = &gbc;",
          "1087:     skip_bits_long(gb_host, cnt*8 - 4);",
          "1089:     sbr->reset = 0;",
          "1091:     if (!sbr->sample_rate)",
          "1092:         sbr->sample_rate = 2 * ac->oc[1].m4ac.sample_rate; //TODO use the nominal sample rate for arbitrary sample rate support",
          "1093:     if (!ac->oc[1].m4ac.ext_sample_rate)",
          "1094:         ac->oc[1].m4ac.ext_sample_rate = 2 * ac->oc[1].m4ac.sample_rate;",
          "1096:     if (crc) {",
          "1097:         skip_bits(gb, 10); // bs_sbr_crc_bits; TODO - implement CRC check",
          "1098:         num_sbr_bits += 10;",
          "1099:     }",
          "1102:     sbr->kx[0] = sbr->kx[1];",
          "1103:     sbr->m[0] = sbr->m[1];",
          "1104:     sbr->kx_and_m_pushed = 1;",
          "1106:     num_sbr_bits++;",
          "1107:     if (get_bits1(gb)) // bs_header_flag",
          "1108:         num_sbr_bits += read_sbr_header(sbr, gb);",
          "1110:     if (sbr->reset)",
          "1111:         sbr_reset(ac, sbr);",
          "1113:     if (sbr->start)",
          "1114:         num_sbr_bits  += read_sbr_data(ac, sbr, gb, id_aac);",
          "1116:     num_align_bits = ((cnt << 3) - 4 - num_sbr_bits) & 7;",
          "1117:     bytes_read = ((num_sbr_bits + num_align_bits + 4) >> 3);",
          "1119:     if (bytes_read > cnt) {",
          "1120:         av_log(ac->avctx, AV_LOG_ERROR,",
          "1121:                \"Expected to read %d SBR bytes actually read %d.\\n\", cnt, bytes_read);",
          "1122:     }",
          "1123:     return cnt;",
          "1124: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1181:     }",
          "1182: }",
          "",
          "[Removed Lines]",
          "1190: #ifndef sbr_qmf_analysis",
          "1191: static void sbr_qmf_analysis(AVFloatDSPContext *dsp, FFTContext *mdct,",
          "1192:                              SBRDSPContext *sbrdsp, const float *in, float *x,",
          "1193:                              float z[320], float W[2][32][32][2], int buf_idx)",
          "1194: {",
          "1195:     int i;",
          "1196:     memcpy(x    , x+1024, (320-32)*sizeof(x[0]));",
          "1197:     memcpy(x+288, in,         1024*sizeof(x[0]));",
          "1198:     for (i = 0; i < 32; i++) { // numTimeSlots*RATE = 16*2 as 960 sample frames",
          "1200:         dsp->vector_fmul_reverse(z, sbr_qmf_window_ds, x, 320);",
          "1201:         sbrdsp->sum64x5(z);",
          "1202:         sbrdsp->qmf_pre_shuffle(z);",
          "1203:         mdct->imdct_half(mdct, z, z+64);",
          "1204:         sbrdsp->qmf_post_shuffle(W[buf_idx][i], z);",
          "1205:         x += 32;",
          "1206:     }",
          "1207: }",
          "1208: #endif",
          "1214: #ifndef sbr_qmf_synthesis",
          "1215: static void sbr_qmf_synthesis(FFTContext *mdct,",
          "1216:                               SBRDSPContext *sbrdsp, AVFloatDSPContext *dsp,",
          "1217:                               float *out, float X[2][38][64],",
          "1218:                               float mdct_buf[2][64],",
          "1219:                               float *v0, int *v_off, const unsigned int div)",
          "1220: {",
          "1221:     int i, n;",
          "1222:     const float *sbr_qmf_window = div ? sbr_qmf_window_ds : sbr_qmf_window_us;",
          "1223:     const int step = 128 >> div;",
          "1224:     float *v;",
          "1225:     for (i = 0; i < 32; i++) {",
          "1226:         if (*v_off < step) {",
          "1227:             int saved_samples = (1280 - 128) >> div;",
          "1228:             memcpy(&v0[SBR_SYNTHESIS_BUF_SIZE - saved_samples], v0, saved_samples * sizeof(float));",
          "1230:         } else {",
          "1232:         }",
          "1233:         v = v0 + *v_off;",
          "1234:         if (div) {",
          "1235:             for (n = 0; n < 32; n++) {",
          "1236:                 X[0][i][   n] = -X[0][i][n];",
          "1237:                 X[0][i][32+n] =  X[1][i][31-n];",
          "1238:             }",
          "1239:             mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);",
          "1240:             sbrdsp->qmf_deint_neg(v, mdct_buf[0]);",
          "1241:         } else {",
          "1242:             sbrdsp->neg_odd_64(X[1][i]);",
          "1243:             mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);",
          "1244:             mdct->imdct_half(mdct, mdct_buf[1], X[1][i]);",
          "1245:             sbrdsp->qmf_deint_bfly(v, mdct_buf[1], mdct_buf[0]);",
          "1246:         }",
          "1247:         dsp->vector_fmul    (out, v                , sbr_qmf_window                       , 64 >> div);",
          "1248:         dsp->vector_fmul_add(out, v + ( 192 >> div), sbr_qmf_window + ( 64 >> div), out   , 64 >> div);",
          "1249:         dsp->vector_fmul_add(out, v + ( 256 >> div), sbr_qmf_window + (128 >> div), out   , 64 >> div);",
          "1250:         dsp->vector_fmul_add(out, v + ( 448 >> div), sbr_qmf_window + (192 >> div), out   , 64 >> div);",
          "1251:         dsp->vector_fmul_add(out, v + ( 512 >> div), sbr_qmf_window + (256 >> div), out   , 64 >> div);",
          "1252:         dsp->vector_fmul_add(out, v + ( 704 >> div), sbr_qmf_window + (320 >> div), out   , 64 >> div);",
          "1253:         dsp->vector_fmul_add(out, v + ( 768 >> div), sbr_qmf_window + (384 >> div), out   , 64 >> div);",
          "1254:         dsp->vector_fmul_add(out, v + ( 960 >> div), sbr_qmf_window + (448 >> div), out   , 64 >> div);",
          "1255:         dsp->vector_fmul_add(out, v + (1024 >> div), sbr_qmf_window + (512 >> div), out   , 64 >> div);",
          "1256:         dsp->vector_fmul_add(out, v + (1216 >> div), sbr_qmf_window + (576 >> div), out   , 64 >> div);",
          "1257:         out += 64 >> div;",
          "1258:     }",
          "1259: }",
          "1260: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1338:     }",
          "1339: }",
          "",
          "[Removed Lines]",
          "1342: static int sbr_lf_gen(AACContext *ac, SpectralBandReplication *sbr,",
          "1343:                       float X_low[32][40][2], const float W[2][32][32][2],",
          "1344:                       int buf_idx)",
          "1345: {",
          "1346:     int i, k;",
          "1347:     const int t_HFGen = 8;",
          "1348:     const int i_f = 32;",
          "1349:     memset(X_low, 0, 32*sizeof(*X_low));",
          "1350:     for (k = 0; k < sbr->kx[1]; k++) {",
          "1351:         for (i = t_HFGen; i < i_f + t_HFGen; i++) {",
          "1352:             X_low[k][i][0] = W[buf_idx][i - t_HFGen][k][0];",
          "1353:             X_low[k][i][1] = W[buf_idx][i - t_HFGen][k][1];",
          "1354:         }",
          "1355:     }",
          "1356:     buf_idx = 1-buf_idx;",
          "1357:     for (k = 0; k < sbr->kx[0]; k++) {",
          "1358:         for (i = 0; i < t_HFGen; i++) {",
          "1359:             X_low[k][i][0] = W[buf_idx][i + i_f - t_HFGen][k][0];",
          "1360:             X_low[k][i][1] = W[buf_idx][i + i_f - t_HFGen][k][1];",
          "1361:         }",
          "1362:     }",
          "1363:     return 0;",
          "1364: }",
          "1367: static int sbr_hf_gen(AACContext *ac, SpectralBandReplication *sbr,",
          "1368:                       float X_high[64][40][2], const float X_low[32][40][2],",
          "1369:                       const float (*alpha0)[2], const float (*alpha1)[2],",
          "1370:                       const float bw_array[5], const uint8_t *t_env,",
          "1371:                       int bs_num_env)",
          "1372: {",
          "1373:     int j, x;",
          "1374:     int g = 0;",
          "1375:     int k = sbr->kx[1];",
          "1376:     for (j = 0; j < sbr->num_patches; j++) {",
          "1377:         for (x = 0; x < sbr->patch_num_subbands[j]; x++, k++) {",
          "1378:             const int p = sbr->patch_start_subband[j] + x;",
          "1379:             while (g <= sbr->n_q && k >= sbr->f_tablenoise[g])",
          "1380:                 g++;",
          "1381:             g--;",
          "1383:             if (g < 0) {",
          "1384:                 av_log(ac->avctx, AV_LOG_ERROR,",
          "1385:                        \"ERROR : no subband found for frequency %d\\n\", k);",
          "1386:                 return -1;",
          "1387:             }",
          "1389:             sbr->dsp.hf_gen(X_high[k] + ENVELOPE_ADJUSTMENT_OFFSET,",
          "1390:                             X_low[p]  + ENVELOPE_ADJUSTMENT_OFFSET,",
          "1391:                             alpha0[p], alpha1[p], bw_array[g],",
          "1392:                             2 * t_env[0], 2 * t_env[bs_num_env]);",
          "1393:         }",
          "1394:     }",
          "1395:     if (k < sbr->m[1] + sbr->kx[1])",
          "1396:         memset(X_high + k, 0, (sbr->m[1] + sbr->kx[1] - k) * sizeof(*X_high));",
          "1398:     return 0;",
          "1399: }",
          "1402: static int sbr_x_gen(SpectralBandReplication *sbr, float X[2][38][64],",
          "1403:                      const float Y0[38][64][2], const float Y1[38][64][2],",
          "1404:                      const float X_low[32][40][2], int ch)",
          "1405: {",
          "1406:     int k, i;",
          "1407:     const int i_f = 32;",
          "1408:     const int i_Temp = FFMAX(2*sbr->data[ch].t_env_num_env_old - i_f, 0);",
          "1409:     memset(X, 0, 2*sizeof(*X));",
          "1410:     for (k = 0; k < sbr->kx[0]; k++) {",
          "1411:         for (i = 0; i < i_Temp; i++) {",
          "1412:             X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];",
          "1413:             X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];",
          "1414:         }",
          "1415:     }",
          "1416:     for (; k < sbr->kx[0] + sbr->m[0]; k++) {",
          "1417:         for (i = 0; i < i_Temp; i++) {",
          "1418:             X[0][i][k] = Y0[i + i_f][k][0];",
          "1419:             X[1][i][k] = Y0[i + i_f][k][1];",
          "1420:         }",
          "1421:     }",
          "1423:     for (k = 0; k < sbr->kx[1]; k++) {",
          "1424:         for (i = i_Temp; i < 38; i++) {",
          "1425:             X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];",
          "1426:             X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];",
          "1427:         }",
          "1428:     }",
          "1429:     for (; k < sbr->kx[1] + sbr->m[1]; k++) {",
          "1430:         for (i = i_Temp; i < i_f; i++) {",
          "1431:             X[0][i][k] = Y1[i][k][0];",
          "1432:             X[1][i][k] = Y1[i][k][1];",
          "1433:         }",
          "1434:     }",
          "1435:     return 0;",
          "1436: }",
          "1441: static int sbr_mapping(AACContext *ac, SpectralBandReplication *sbr,",
          "1442:                         SBRData *ch_data, int e_a[2])",
          "1443: {",
          "1444:     int e, i, m;",
          "1446:     memset(ch_data->s_indexmapped[1], 0, 7*sizeof(ch_data->s_indexmapped[1]));",
          "1447:     for (e = 0; e < ch_data->bs_num_env; e++) {",
          "1448:         const unsigned int ilim = sbr->n[ch_data->bs_freq_res[e + 1]];",
          "1449:         uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;",
          "1450:         int k;",
          "1452:         if (sbr->kx[1] != table[0]) {",
          "1453:             av_log(ac->avctx, AV_LOG_ERROR, \"kx != f_table{high,low}[0]. \"",
          "1454:                    \"Derived frequency tables were not regenerated.\\n\");",
          "1455:             sbr_turnoff(sbr);",
          "1456:             return AVERROR_BUG;",
          "1457:         }",
          "1458:         for (i = 0; i < ilim; i++)",
          "1459:             for (m = table[i]; m < table[i + 1]; m++)",
          "1460:                 sbr->e_origmapped[e][m - sbr->kx[1]] = ch_data->env_facs[e+1][i];",
          "1463:         k = (ch_data->bs_num_noise > 1) && (ch_data->t_env[e] >= ch_data->t_q[1]);",
          "1464:         for (i = 0; i < sbr->n_q; i++)",
          "1465:             for (m = sbr->f_tablenoise[i]; m < sbr->f_tablenoise[i + 1]; m++)",
          "1466:                 sbr->q_mapped[e][m - sbr->kx[1]] = ch_data->noise_facs[k+1][i];",
          "1468:         for (i = 0; i < sbr->n[1]; i++) {",
          "1469:             if (ch_data->bs_add_harmonic_flag) {",
          "1470:                 const unsigned int m_midpoint =",
          "1471:                     (sbr->f_tablehigh[i] + sbr->f_tablehigh[i + 1]) >> 1;",
          "1473:                 ch_data->s_indexmapped[e + 1][m_midpoint - sbr->kx[1]] = ch_data->bs_add_harmonic[i] *",
          "1474:                     (e >= e_a[1] || (ch_data->s_indexmapped[0][m_midpoint - sbr->kx[1]] == 1));",
          "1475:             }",
          "1476:         }",
          "1478:         for (i = 0; i < ilim; i++) {",
          "1479:             int additional_sinusoid_present = 0;",
          "1480:             for (m = table[i]; m < table[i + 1]; m++) {",
          "1481:                 if (ch_data->s_indexmapped[e + 1][m - sbr->kx[1]]) {",
          "1482:                     additional_sinusoid_present = 1;",
          "1483:                     break;",
          "1484:                 }",
          "1485:             }",
          "1486:             memset(&sbr->s_mapped[e][table[i] - sbr->kx[1]], additional_sinusoid_present,",
          "1487:                    (table[i + 1] - table[i]) * sizeof(sbr->s_mapped[e][0]));",
          "1488:         }",
          "1489:     }",
          "1491:     memcpy(ch_data->s_indexmapped[0], ch_data->s_indexmapped[ch_data->bs_num_env], sizeof(ch_data->s_indexmapped[0]));",
          "1492:     return 0;",
          "1493: }",
          "1496: static void sbr_env_estimate(float (*e_curr)[48], float X_high[64][40][2],",
          "1497:                              SpectralBandReplication *sbr, SBRData *ch_data)",
          "1498: {",
          "1499:     int e, m;",
          "1500:     int kx1 = sbr->kx[1];",
          "1502:     if (sbr->bs_interpol_freq) {",
          "1503:         for (e = 0; e < ch_data->bs_num_env; e++) {",
          "1504:             const float recip_env_size = 0.5f / (ch_data->t_env[e + 1] - ch_data->t_env[e]);",
          "1505:             int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1506:             int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1508:             for (m = 0; m < sbr->m[1]; m++) {",
          "1509:                 float sum = sbr->dsp.sum_square(X_high[m+kx1] + ilb, iub - ilb);",
          "1510:                 e_curr[e][m] = sum * recip_env_size;",
          "1511:             }",
          "1512:         }",
          "1513:     } else {",
          "1514:         int k, p;",
          "1516:         for (e = 0; e < ch_data->bs_num_env; e++) {",
          "1517:             const int env_size = 2 * (ch_data->t_env[e + 1] - ch_data->t_env[e]);",
          "1518:             int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1519:             int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1520:             const uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;",
          "1522:             for (p = 0; p < sbr->n[ch_data->bs_freq_res[e + 1]]; p++) {",
          "1523:                 float sum = 0.0f;",
          "1524:                 const int den = env_size * (table[p + 1] - table[p]);",
          "1526:                 for (k = table[p]; k < table[p + 1]; k++) {",
          "1527:                     sum += sbr->dsp.sum_square(X_high[k] + ilb, iub - ilb);",
          "1528:                 }",
          "1529:                 sum /= den;",
          "1530:                 for (k = table[p]; k < table[p + 1]; k++) {",
          "1531:                     e_curr[e][k - kx1] = sum;",
          "1532:                 }",
          "1533:             }",
          "1534:         }",
          "1535:     }",
          "1536: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1689:     ch_data->f_indexsine  = indexsine;",
          "1690: }",
          "",
          "[Removed Lines]",
          "1692: void ff_sbr_apply(AACContext *ac, SpectralBandReplication *sbr, int id_aac,",
          "1693:                   float* L, float* R)",
          "1694: {",
          "1695:     int downsampled = ac->oc[1].m4ac.ext_sample_rate < sbr->sample_rate;",
          "1696:     int ch;",
          "1697:     int nch = (id_aac == TYPE_CPE) ? 2 : 1;",
          "1698:     int err;",
          "1700:     if (id_aac != sbr->id_aac) {",
          "1701:         av_log(ac->avctx, AV_LOG_ERROR,",
          "1702:             \"element type mismatch %d != %d\\n\", id_aac, sbr->id_aac);",
          "1703:         sbr_turnoff(sbr);",
          "1704:     }",
          "1706:     if (!sbr->kx_and_m_pushed) {",
          "1707:         sbr->kx[0] = sbr->kx[1];",
          "1708:         sbr->m[0] = sbr->m[1];",
          "1709:     } else {",
          "1710:         sbr->kx_and_m_pushed = 0;",
          "1711:     }",
          "1713:     if (sbr->start) {",
          "1714:         sbr_dequant(sbr, id_aac);",
          "1715:     }",
          "1716:     for (ch = 0; ch < nch; ch++) {",
          "1718:         sbr_qmf_analysis(ac->fdsp, &sbr->mdct_ana, &sbr->dsp, ch ? R : L, sbr->data[ch].analysis_filterbank_samples,",
          "1719:                          (float*)sbr->qmf_filter_scratch,",
          "1720:                          sbr->data[ch].W, sbr->data[ch].Ypos);",
          "1721:         sbr->c.sbr_lf_gen(ac, sbr, sbr->X_low,",
          "1722:                           (const float (*)[32][32][2]) sbr->data[ch].W,",
          "1723:                           sbr->data[ch].Ypos);",
          "1724:         sbr->data[ch].Ypos ^= 1;",
          "1725:         if (sbr->start) {",
          "1726:             sbr->c.sbr_hf_inverse_filter(&sbr->dsp, sbr->alpha0, sbr->alpha1,",
          "1727:                                          (const float (*)[40][2]) sbr->X_low, sbr->k[0]);",
          "1728:             sbr_chirp(sbr, &sbr->data[ch]);",
          "1729:             av_assert0(sbr->data[ch].bs_num_env > 0);",
          "1730:             sbr_hf_gen(ac, sbr, sbr->X_high,",
          "1731:                        (const float (*)[40][2]) sbr->X_low,",
          "1732:                        (const float (*)[2]) sbr->alpha0,",
          "1733:                        (const float (*)[2]) sbr->alpha1,",
          "1734:                        sbr->data[ch].bw_array, sbr->data[ch].t_env,",
          "1735:                        sbr->data[ch].bs_num_env);",
          "1738:             err = sbr_mapping(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);",
          "1739:             if (!err) {",
          "1740:                 sbr_env_estimate(sbr->e_curr, sbr->X_high, sbr, &sbr->data[ch]);",
          "1741:                 sbr_gain_calc(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);",
          "1742:                 sbr->c.sbr_hf_assemble(sbr->data[ch].Y[sbr->data[ch].Ypos],",
          "1743:                                 (const float (*)[40][2]) sbr->X_high,",
          "1744:                                 sbr, &sbr->data[ch],",
          "1745:                                 sbr->data[ch].e_a);",
          "1746:             }",
          "1747:         }",
          "1750:         sbr->c.sbr_x_gen(sbr, sbr->X[ch],",
          "1751:                   (const float (*)[64][2]) sbr->data[ch].Y[1-sbr->data[ch].Ypos],",
          "1752:                   (const float (*)[64][2]) sbr->data[ch].Y[  sbr->data[ch].Ypos],",
          "1753:                   (const float (*)[40][2]) sbr->X_low, ch);",
          "1754:     }",
          "1756:     if (ac->oc[1].m4ac.ps == 1) {",
          "1757:         if (sbr->ps.start) {",
          "1758:             ff_ps_apply(ac->avctx, &sbr->ps, sbr->X[0], sbr->X[1], sbr->kx[1] + sbr->m[1]);",
          "1759:         } else {",
          "1760:             memcpy(sbr->X[1], sbr->X[0], sizeof(sbr->X[0]));",
          "1761:         }",
          "1762:         nch = 2;",
          "1763:     }",
          "1765:     sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp, ac->fdsp,",
          "1766:                       L, sbr->X[0], sbr->qmf_filter_scratch,",
          "1767:                       sbr->data[0].synthesis_filterbank_samples,",
          "1768:                       &sbr->data[0].synthesis_filterbank_samples_offset,",
          "1769:                       downsampled);",
          "1770:     if (nch == 2)",
          "1771:         sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp, ac->fdsp,",
          "1772:                           R, sbr->X[1], sbr->qmf_filter_scratch,",
          "1773:                           sbr->data[1].synthesis_filterbank_samples,",
          "1774:                           &sbr->data[1].synthesis_filterbank_samples_offset,",
          "1775:                           downsampled);",
          "1776: }",
          "1778: static void aacsbr_func_ptr_init(AACSBRContext *c)",
          "1779: {",
          "1780:     c->sbr_lf_gen            = sbr_lf_gen;",
          "1781:     c->sbr_hf_assemble       = sbr_hf_assemble;",
          "1782:     c->sbr_x_gen             = sbr_x_gen;",
          "1783:     c->sbr_hf_inverse_filter = sbr_hf_inverse_filter;",
          "1785:     if(ARCH_MIPS)",
          "1786:         ff_aacsbr_func_ptr_init_mips(c);",
          "1787: }",
          "",
          "[Added Lines]",
          "361: #include \"aacsbr_template.c\"",
          "",
          "---------------"
        ],
        "libavcodec/aacsbr.h||libavcodec/aacsbr.h": [
          "File: libavcodec/aacsbr.h -> libavcodec/aacsbr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include \"aac.h\"",
          "34: #include \"sbr.h\"",
          "37: void ff_aac_sbr_init(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: #define ENVELOPE_ADJUSTMENT_OFFSET 2",
          "37: #define NOISE_FLOOR_OFFSET FIXR(6.0f)",
          "42: enum {",
          "43:     T_HUFFMAN_ENV_1_5DB,",
          "44:     F_HUFFMAN_ENV_1_5DB,",
          "45:     T_HUFFMAN_ENV_BAL_1_5DB,",
          "46:     F_HUFFMAN_ENV_BAL_1_5DB,",
          "47:     T_HUFFMAN_ENV_3_0DB,",
          "48:     F_HUFFMAN_ENV_3_0DB,",
          "49:     T_HUFFMAN_ENV_BAL_3_0DB,",
          "50:     F_HUFFMAN_ENV_BAL_3_0DB,",
          "51:     T_HUFFMAN_NOISE_3_0DB,",
          "52:     T_HUFFMAN_NOISE_BAL_3_0DB,",
          "53: };",
          "58: enum {",
          "59:     FIXFIX,",
          "60:     FIXVAR,",
          "61:     VARFIX,",
          "62:     VARVAR,",
          "63: };",
          "65: enum {",
          "66:     EXTENSION_ID_PS = 2,",
          "67: };",
          "69: static const int8_t vlc_sbr_lav[10] =",
          "70:     { 60, 60, 24, 24, 31, 31, 12, 12, 31, 12 };",
          "72: #define SBR_INIT_VLC_STATIC(num, size) \\",
          "73:     INIT_VLC_STATIC(&vlc_sbr[num], 9, sbr_tmp[num].table_size / sbr_tmp[num].elem_size,     \\",
          "74:                     sbr_tmp[num].sbr_bits ,                      1,                      1, \\",
          "75:                     sbr_tmp[num].sbr_codes, sbr_tmp[num].elem_size, sbr_tmp[num].elem_size, \\",
          "76:                     size)",
          "78: #define SBR_VLC_ROW(name) \\",
          "79:     { name ## _codes, name ## _bits, sizeof(name ## _codes), sizeof(name ## _codes[0]) }",
          "",
          "---------------"
        ],
        "libavcodec/aacsbr_template.c||libavcodec/aacsbr_template.c": [
          "File: libavcodec/aacsbr_template.c -> libavcodec/aacsbr_template.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: av_cold void ff_aac_sbr_init(void)",
          "30: {",
          "31:     static const struct {",
          "32:         const void *sbr_codes, *sbr_bits;",
          "33:         const unsigned int table_size, elem_size;",
          "34:     } sbr_tmp[] = {",
          "35:         SBR_VLC_ROW(t_huffman_env_1_5dB),",
          "36:         SBR_VLC_ROW(f_huffman_env_1_5dB),",
          "37:         SBR_VLC_ROW(t_huffman_env_bal_1_5dB),",
          "38:         SBR_VLC_ROW(f_huffman_env_bal_1_5dB),",
          "39:         SBR_VLC_ROW(t_huffman_env_3_0dB),",
          "40:         SBR_VLC_ROW(f_huffman_env_3_0dB),",
          "41:         SBR_VLC_ROW(t_huffman_env_bal_3_0dB),",
          "42:         SBR_VLC_ROW(f_huffman_env_bal_3_0dB),",
          "43:         SBR_VLC_ROW(t_huffman_noise_3_0dB),",
          "44:         SBR_VLC_ROW(t_huffman_noise_bal_3_0dB),",
          "45:     };",
          "48:     SBR_INIT_VLC_STATIC(0, 1098);",
          "49:     SBR_INIT_VLC_STATIC(1, 1092);",
          "50:     SBR_INIT_VLC_STATIC(2, 768);",
          "51:     SBR_INIT_VLC_STATIC(3, 1026);",
          "52:     SBR_INIT_VLC_STATIC(4, 1058);",
          "53:     SBR_INIT_VLC_STATIC(5, 1052);",
          "54:     SBR_INIT_VLC_STATIC(6, 544);",
          "55:     SBR_INIT_VLC_STATIC(7, 544);",
          "56:     SBR_INIT_VLC_STATIC(8, 592);",
          "57:     SBR_INIT_VLC_STATIC(9, 512);",
          "59:     aacsbr_tableinit();",
          "61:     ff_ps_init();",
          "62: }",
          "65: static void sbr_turnoff(SpectralBandReplication *sbr) {",
          "66:     sbr->start = 0;",
          "68:     sbr->kx[1] = 32; //Typo in spec, kx' inits to 32",
          "69:     sbr->m[1] = 0;",
          "71:     sbr->data[0].e_a[1] = sbr->data[1].e_a[1] = -1;",
          "72:     memset(&sbr->spectrum_params, -1, sizeof(SpectrumParameters));",
          "73: }",
          "75: av_cold void ff_aac_sbr_ctx_init(AACContext *ac, SpectralBandReplication *sbr)",
          "76: {",
          "77:     if(sbr->mdct.mdct_bits)",
          "78:         return;",
          "79:     sbr->kx[0] = sbr->kx[1];",
          "80:     sbr_turnoff(sbr);",
          "81:     sbr->data[0].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);",
          "82:     sbr->data[1].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);",
          "86:     ff_mdct_init(&sbr->mdct,     7, 1, 1.0 / (64 * 32768.0));",
          "87:     ff_mdct_init(&sbr->mdct_ana, 7, 1, -2.0 * 32768.0);",
          "88:     ff_ps_ctx_init(&sbr->ps);",
          "89:     ff_sbrdsp_init(&sbr->dsp);",
          "90:     aacsbr_func_ptr_init(&sbr->c);",
          "91: }",
          "93: av_cold void ff_aac_sbr_ctx_close(SpectralBandReplication *sbr)",
          "94: {",
          "95:     ff_mdct_end(&sbr->mdct);",
          "96:     ff_mdct_end(&sbr->mdct_ana);",
          "97: }",
          "99: static int qsort_comparison_function_int16(const void *a, const void *b)",
          "100: {",
          "101:     return *(const int16_t *)a - *(const int16_t *)b;",
          "102: }",
          "104: static inline int in_table_int16(const int16_t *table, int last_el, int16_t needle)",
          "105: {",
          "106:     int i;",
          "107:     for (i = 0; i <= last_el; i++)",
          "108:         if (table[i] == needle)",
          "109:             return 1;",
          "110:     return 0;",
          "111: }",
          "114: static void sbr_make_f_tablelim(SpectralBandReplication *sbr)",
          "115: {",
          "116:     int k;",
          "117:     if (sbr->bs_limiter_bands > 0) {",
          "118:         static const float bands_warped[3] = { 1.32715174233856803909f,   //2^(0.49/1.2)",
          "119:                                                1.18509277094158210129f,   //2^(0.49/2)",
          "120:                                                1.11987160404675912501f }; //2^(0.49/3)",
          "121:         const float lim_bands_per_octave_warped = bands_warped[sbr->bs_limiter_bands - 1];",
          "122:         int16_t patch_borders[7];",
          "123:         uint16_t *in = sbr->f_tablelim + 1, *out = sbr->f_tablelim;",
          "125:         patch_borders[0] = sbr->kx[1];",
          "126:         for (k = 1; k <= sbr->num_patches; k++)",
          "127:             patch_borders[k] = patch_borders[k-1] + sbr->patch_num_subbands[k-1];",
          "129:         memcpy(sbr->f_tablelim, sbr->f_tablelow,",
          "130:                (sbr->n[0] + 1) * sizeof(sbr->f_tablelow[0]));",
          "131:         if (sbr->num_patches > 1)",
          "132:             memcpy(sbr->f_tablelim + sbr->n[0] + 1, patch_borders + 1,",
          "133:                    (sbr->num_patches - 1) * sizeof(patch_borders[0]));",
          "135:         qsort(sbr->f_tablelim, sbr->num_patches + sbr->n[0],",
          "136:               sizeof(sbr->f_tablelim[0]),",
          "137:               qsort_comparison_function_int16);",
          "139:         sbr->n_lim = sbr->n[0] + sbr->num_patches - 1;",
          "140:         while (out < sbr->f_tablelim + sbr->n_lim) {",
          "141:             if (*in >= *out * lim_bands_per_octave_warped) {",
          "143:             } else if (*in == *out ||",
          "144:                 !in_table_int16(patch_borders, sbr->num_patches, *in)) {",
          "145:                 in++;",
          "146:                 sbr->n_lim--;",
          "147:             } else if (!in_table_int16(patch_borders, sbr->num_patches, *out)) {",
          "149:                 sbr->n_lim--;",
          "150:             } else {",
          "152:             }",
          "153:         }",
          "154:     } else {",
          "155:         sbr->f_tablelim[0] = sbr->f_tablelow[0];",
          "156:         sbr->f_tablelim[1] = sbr->f_tablelow[sbr->n[0]];",
          "157:         sbr->n_lim = 1;",
          "158:     }",
          "159: }",
          "161: static unsigned int read_sbr_header(SpectralBandReplication *sbr, GetBitContext *gb)",
          "162: {",
          "163:     unsigned int cnt = get_bits_count(gb);",
          "164:     uint8_t bs_header_extra_1;",
          "165:     uint8_t bs_header_extra_2;",
          "166:     int old_bs_limiter_bands = sbr->bs_limiter_bands;",
          "167:     SpectrumParameters old_spectrum_params;",
          "169:     sbr->start = 1;",
          "172:     memcpy(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters));",
          "174:     sbr->bs_amp_res_header              = get_bits1(gb);",
          "175:     sbr->spectrum_params.bs_start_freq  = get_bits(gb, 4);",
          "176:     sbr->spectrum_params.bs_stop_freq   = get_bits(gb, 4);",
          "177:     sbr->spectrum_params.bs_xover_band  = get_bits(gb, 3);",
          "178:                                           skip_bits(gb, 2); // bs_reserved",
          "180:     bs_header_extra_1 = get_bits1(gb);",
          "181:     bs_header_extra_2 = get_bits1(gb);",
          "183:     if (bs_header_extra_1) {",
          "184:         sbr->spectrum_params.bs_freq_scale  = get_bits(gb, 2);",
          "185:         sbr->spectrum_params.bs_alter_scale = get_bits1(gb);",
          "186:         sbr->spectrum_params.bs_noise_bands = get_bits(gb, 2);",
          "187:     } else {",
          "188:         sbr->spectrum_params.bs_freq_scale  = 2;",
          "189:         sbr->spectrum_params.bs_alter_scale = 1;",
          "190:         sbr->spectrum_params.bs_noise_bands = 2;",
          "191:     }",
          "194:     if (memcmp(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters)))",
          "195:         sbr->reset = 1;",
          "197:     if (bs_header_extra_2) {",
          "198:         sbr->bs_limiter_bands  = get_bits(gb, 2);",
          "199:         sbr->bs_limiter_gains  = get_bits(gb, 2);",
          "200:         sbr->bs_interpol_freq  = get_bits1(gb);",
          "201:         sbr->bs_smoothing_mode = get_bits1(gb);",
          "202:     } else {",
          "203:         sbr->bs_limiter_bands  = 2;",
          "204:         sbr->bs_limiter_gains  = 2;",
          "205:         sbr->bs_interpol_freq  = 1;",
          "206:         sbr->bs_smoothing_mode = 1;",
          "207:     }",
          "209:     if (sbr->bs_limiter_bands != old_bs_limiter_bands && !sbr->reset)",
          "210:         sbr_make_f_tablelim(sbr);",
          "212:     return get_bits_count(gb) - cnt;",
          "213: }",
          "215: static int array_min_int16(const int16_t *array, int nel)",
          "216: {",
          "217:     int i, min = array[0];",
          "218:     for (i = 1; i < nel; i++)",
          "219:         min = FFMIN(array[i], min);",
          "220:     return min;",
          "221: }",
          "223: static int check_n_master(AVCodecContext *avctx, int n_master, int bs_xover_band)",
          "224: {",
          "226:     if (n_master <= 0) {",
          "227:         av_log(avctx, AV_LOG_ERROR, \"Invalid n_master: %d\\n\", n_master);",
          "228:         return -1;",
          "229:     }",
          "230:     if (bs_xover_band >= n_master) {",
          "231:         av_log(avctx, AV_LOG_ERROR,",
          "232:                \"Invalid bitstream, crossover band index beyond array bounds: %d\\n\",",
          "233:                bs_xover_band);",
          "234:         return -1;",
          "235:     }",
          "236:     return 0;",
          "237: }",
          "240: static int sbr_make_f_master(AACContext *ac, SpectralBandReplication *sbr,",
          "241:                              SpectrumParameters *spectrum)",
          "242: {",
          "243:     unsigned int temp, max_qmf_subbands = 0;",
          "244:     unsigned int start_min, stop_min;",
          "245:     int k;",
          "246:     const int8_t *sbr_offset_ptr;",
          "247:     int16_t stop_dk[13];",
          "249:     if (sbr->sample_rate < 32000) {",
          "250:         temp = 3000;",
          "251:     } else if (sbr->sample_rate < 64000) {",
          "252:         temp = 4000;",
          "253:     } else",
          "254:         temp = 5000;",
          "256:     switch (sbr->sample_rate) {",
          "257:     case 16000:",
          "258:         sbr_offset_ptr = sbr_offset[0];",
          "259:         break;",
          "260:     case 22050:",
          "261:         sbr_offset_ptr = sbr_offset[1];",
          "262:         break;",
          "263:     case 24000:",
          "264:         sbr_offset_ptr = sbr_offset[2];",
          "265:         break;",
          "266:     case 32000:",
          "267:         sbr_offset_ptr = sbr_offset[3];",
          "268:         break;",
          "269:     case 44100: case 48000: case 64000:",
          "270:         sbr_offset_ptr = sbr_offset[4];",
          "271:         break;",
          "272:     case 88200: case 96000: case 128000: case 176400: case 192000:",
          "273:         sbr_offset_ptr = sbr_offset[5];",
          "274:         break;",
          "275:     default:",
          "276:         av_log(ac->avctx, AV_LOG_ERROR,",
          "277:                \"Unsupported sample rate for SBR: %d\\n\", sbr->sample_rate);",
          "278:         return -1;",
          "279:     }",
          "281:     start_min = ((temp << 7) + (sbr->sample_rate >> 1)) / sbr->sample_rate;",
          "282:     stop_min  = ((temp << 8) + (sbr->sample_rate >> 1)) / sbr->sample_rate;",
          "284:     sbr->k[0] = start_min + sbr_offset_ptr[spectrum->bs_start_freq];",
          "286:     if (spectrum->bs_stop_freq < 14) {",
          "287:         sbr->k[2] = stop_min;",
          "288:         make_bands(stop_dk, stop_min, 64, 13);",
          "289:         qsort(stop_dk, 13, sizeof(stop_dk[0]), qsort_comparison_function_int16);",
          "290:         for (k = 0; k < spectrum->bs_stop_freq; k++)",
          "291:             sbr->k[2] += stop_dk[k];",
          "292:     } else if (spectrum->bs_stop_freq == 14) {",
          "293:         sbr->k[2] = 2*sbr->k[0];",
          "294:     } else if (spectrum->bs_stop_freq == 15) {",
          "295:         sbr->k[2] = 3*sbr->k[0];",
          "296:     } else {",
          "297:         av_log(ac->avctx, AV_LOG_ERROR,",
          "298:                \"Invalid bs_stop_freq: %d\\n\", spectrum->bs_stop_freq);",
          "299:         return -1;",
          "300:     }",
          "301:     sbr->k[2] = FFMIN(64, sbr->k[2]);",
          "304:     if (sbr->sample_rate <= 32000) {",
          "305:         max_qmf_subbands = 48;",
          "306:     } else if (sbr->sample_rate == 44100) {",
          "307:         max_qmf_subbands = 35;",
          "308:     } else if (sbr->sample_rate >= 48000)",
          "309:         max_qmf_subbands = 32;",
          "310:     else",
          "311:         av_assert0(0);",
          "313:     if (sbr->k[2] - sbr->k[0] > max_qmf_subbands) {",
          "314:         av_log(ac->avctx, AV_LOG_ERROR,",
          "315:                \"Invalid bitstream, too many QMF subbands: %d\\n\", sbr->k[2] - sbr->k[0]);",
          "316:         return -1;",
          "317:     }",
          "319:     if (!spectrum->bs_freq_scale) {",
          "320:         int dk, k2diff;",
          "322:         dk = spectrum->bs_alter_scale + 1;",
          "323:         sbr->n_master = ((sbr->k[2] - sbr->k[0] + (dk&2)) >> dk) << 1;",
          "324:         if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))",
          "325:             return -1;",
          "327:         for (k = 1; k <= sbr->n_master; k++)",
          "328:             sbr->f_master[k] = dk;",
          "330:         k2diff = sbr->k[2] - sbr->k[0] - sbr->n_master * dk;",
          "331:         if (k2diff < 0) {",
          "332:             sbr->f_master[1]--;",
          "333:             sbr->f_master[2]-= (k2diff < -1);",
          "334:         } else if (k2diff) {",
          "335:             sbr->f_master[sbr->n_master]++;",
          "336:         }",
          "338:         sbr->f_master[0] = sbr->k[0];",
          "339:         for (k = 1; k <= sbr->n_master; k++)",
          "340:             sbr->f_master[k] += sbr->f_master[k - 1];",
          "342:     } else {",
          "343:         int half_bands = 7 - spectrum->bs_freq_scale;      // bs_freq_scale  = {1,2,3}",
          "344:         int two_regions, num_bands_0;",
          "345:         int vdk0_max, vdk1_min;",
          "346:         int16_t vk0[49];",
          "348:         if (49 * sbr->k[2] > 110 * sbr->k[0]) {",
          "349:             two_regions = 1;",
          "350:             sbr->k[1] = 2 * sbr->k[0];",
          "351:         } else {",
          "352:             two_regions = 0;",
          "353:             sbr->k[1] = sbr->k[2];",
          "354:         }",
          "356:         num_bands_0 = lrintf(half_bands * log2f(sbr->k[1] / (float)sbr->k[0])) * 2;",
          "358:         if (num_bands_0 <= 0) { // Requirements (14496-3 sp04 p205)",
          "359:             av_log(ac->avctx, AV_LOG_ERROR, \"Invalid num_bands_0: %d\\n\", num_bands_0);",
          "360:             return -1;",
          "361:         }",
          "363:         vk0[0] = 0;",
          "365:         make_bands(vk0+1, sbr->k[0], sbr->k[1], num_bands_0);",
          "367:         qsort(vk0 + 1, num_bands_0, sizeof(vk0[1]), qsort_comparison_function_int16);",
          "368:         vdk0_max = vk0[num_bands_0];",
          "370:         vk0[0] = sbr->k[0];",
          "371:         for (k = 1; k <= num_bands_0; k++) {",
          "372:             if (vk0[k] <= 0) { // Requirements (14496-3 sp04 p205)",
          "373:                 av_log(ac->avctx, AV_LOG_ERROR, \"Invalid vDk0[%d]: %d\\n\", k, vk0[k]);",
          "374:                 return -1;",
          "375:             }",
          "376:             vk0[k] += vk0[k-1];",
          "377:         }",
          "379:         if (two_regions) {",
          "380:             int16_t vk1[49];",
          "381:             float invwarp = spectrum->bs_alter_scale ? 0.76923076923076923077f",
          "382:                                                      : 1.0f; // bs_alter_scale = {0,1}",
          "383:             int num_bands_1 = lrintf(half_bands * invwarp *",
          "384:                                      log2f(sbr->k[2] / (float)sbr->k[1])) * 2;",
          "386:             make_bands(vk1+1, sbr->k[1], sbr->k[2], num_bands_1);",
          "388:             vdk1_min = array_min_int16(vk1 + 1, num_bands_1);",
          "390:             if (vdk1_min < vdk0_max) {",
          "391:                 int change;",
          "392:                 qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);",
          "393:                 change = FFMIN(vdk0_max - vk1[1], (vk1[num_bands_1] - vk1[1]) >> 1);",
          "394:                 vk1[1]           += change;",
          "395:                 vk1[num_bands_1] -= change;",
          "396:             }",
          "398:             qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);",
          "400:             vk1[0] = sbr->k[1];",
          "401:             for (k = 1; k <= num_bands_1; k++) {",
          "402:                 if (vk1[k] <= 0) { // Requirements (14496-3 sp04 p205)",
          "403:                     av_log(ac->avctx, AV_LOG_ERROR, \"Invalid vDk1[%d]: %d\\n\", k, vk1[k]);",
          "404:                     return -1;",
          "405:                 }",
          "406:                 vk1[k] += vk1[k-1];",
          "407:             }",
          "409:             sbr->n_master = num_bands_0 + num_bands_1;",
          "410:             if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))",
          "411:                 return -1;",
          "412:             memcpy(&sbr->f_master[0],               vk0,",
          "413:                    (num_bands_0 + 1) * sizeof(sbr->f_master[0]));",
          "414:             memcpy(&sbr->f_master[num_bands_0 + 1], vk1 + 1,",
          "415:                     num_bands_1      * sizeof(sbr->f_master[0]));",
          "417:         } else {",
          "418:             sbr->n_master = num_bands_0;",
          "419:             if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))",
          "420:                 return -1;",
          "421:             memcpy(sbr->f_master, vk0, (num_bands_0 + 1) * sizeof(sbr->f_master[0]));",
          "422:         }",
          "423:     }",
          "425:     return 0;",
          "426: }",
          "429: static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)",
          "430: {",
          "431:     int i, k, last_k = -1, last_msb = -1, sb = 0;",
          "432:     int msb = sbr->k[0];",
          "433:     int usb = sbr->kx[1];",
          "434:     int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;",
          "436:     sbr->num_patches = 0;",
          "438:     if (goal_sb < sbr->kx[1] + sbr->m[1]) {",
          "439:         for (k = 0; sbr->f_master[k] < goal_sb; k++) ;",
          "440:     } else",
          "441:         k = sbr->n_master;",
          "443:     do {",
          "444:         int odd = 0;",
          "445:         if (k == last_k && msb == last_msb) {",
          "446:             av_log(ac->avctx, AV_LOG_ERROR, \"patch construction failed\\n\");",
          "447:             return AVERROR_INVALIDDATA;",
          "448:         }",
          "449:         last_k = k;",
          "450:         last_msb = msb;",
          "451:         for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {",
          "452:             sb = sbr->f_master[i];",
          "453:             odd = (sb + sbr->k[0]) & 1;",
          "454:         }",
          "460:         if (sbr->num_patches > 5) {",
          "461:             av_log(ac->avctx, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);",
          "462:             return -1;",
          "463:         }",
          "465:         sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);",
          "466:         sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];",
          "468:         if (sbr->patch_num_subbands[sbr->num_patches] > 0) {",
          "469:             usb = sb;",
          "470:             msb = sb;",
          "471:             sbr->num_patches++;",
          "472:         } else",
          "473:             msb = sbr->kx[1];",
          "475:         if (sbr->f_master[k] - sb < 3)",
          "476:             k = sbr->n_master;",
          "477:     } while (sb != sbr->kx[1] + sbr->m[1]);",
          "479:     if (sbr->num_patches > 1 &&",
          "480:         sbr->patch_num_subbands[sbr->num_patches - 1] < 3)",
          "481:         sbr->num_patches--;",
          "483:     return 0;",
          "484: }",
          "487: static int sbr_make_f_derived(AACContext *ac, SpectralBandReplication *sbr)",
          "488: {",
          "489:     int k, temp;",
          "491:     sbr->n[1] = sbr->n_master - sbr->spectrum_params.bs_xover_band;",
          "492:     sbr->n[0] = (sbr->n[1] + 1) >> 1;",
          "494:     memcpy(sbr->f_tablehigh, &sbr->f_master[sbr->spectrum_params.bs_xover_band],",
          "495:            (sbr->n[1] + 1) * sizeof(sbr->f_master[0]));",
          "496:     sbr->m[1] = sbr->f_tablehigh[sbr->n[1]] - sbr->f_tablehigh[0];",
          "497:     sbr->kx[1] = sbr->f_tablehigh[0];",
          "500:     if (sbr->kx[1] + sbr->m[1] > 64) {",
          "501:         av_log(ac->avctx, AV_LOG_ERROR,",
          "502:                \"Stop frequency border too high: %d\\n\", sbr->kx[1] + sbr->m[1]);",
          "503:         return -1;",
          "504:     }",
          "505:     if (sbr->kx[1] > 32) {",
          "506:         av_log(ac->avctx, AV_LOG_ERROR, \"Start frequency border too high: %d\\n\", sbr->kx[1]);",
          "507:         return -1;",
          "508:     }",
          "510:     sbr->f_tablelow[0] = sbr->f_tablehigh[0];",
          "511:     temp = sbr->n[1] & 1;",
          "512:     for (k = 1; k <= sbr->n[0]; k++)",
          "513:         sbr->f_tablelow[k] = sbr->f_tablehigh[2 * k - temp];",
          "515:     sbr->n_q = FFMAX(1, lrintf(sbr->spectrum_params.bs_noise_bands *",
          "516:                                log2f(sbr->k[2] / (float)sbr->kx[1]))); // 0 <= bs_noise_bands <= 3",
          "517:     if (sbr->n_q > 5) {",
          "518:         av_log(ac->avctx, AV_LOG_ERROR, \"Too many noise floor scale factors: %d\\n\", sbr->n_q);",
          "519:         return -1;",
          "520:     }",
          "522:     sbr->f_tablenoise[0] = sbr->f_tablelow[0];",
          "523:     temp = 0;",
          "524:     for (k = 1; k <= sbr->n_q; k++) {",
          "525:         temp += (sbr->n[0] - temp) / (sbr->n_q + 1 - k);",
          "526:         sbr->f_tablenoise[k] = sbr->f_tablelow[temp];",
          "527:     }",
          "529:     if (sbr_hf_calc_npatches(ac, sbr) < 0)",
          "530:         return -1;",
          "532:     sbr_make_f_tablelim(sbr);",
          "534:     sbr->data[0].f_indexnoise = 0;",
          "535:     sbr->data[1].f_indexnoise = 0;",
          "537:     return 0;",
          "538: }",
          "540: static av_always_inline void get_bits1_vector(GetBitContext *gb, uint8_t *vec,",
          "541:                                               int elements)",
          "542: {",
          "543:     int i;",
          "544:     for (i = 0; i < elements; i++) {",
          "545:         vec[i] = get_bits1(gb);",
          "546:     }",
          "547: }",
          "550: static const int8_t ceil_log2[] = {",
          "551:     0, 1, 2, 2, 3, 3,",
          "552: };",
          "554: static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,",
          "555:                          GetBitContext *gb, SBRData *ch_data)",
          "556: {",
          "557:     int i;",
          "558:     int bs_pointer = 0;",
          "560:     int abs_bord_trail = 16;",
          "561:     int num_rel_lead, num_rel_trail;",
          "562:     unsigned bs_num_env_old = ch_data->bs_num_env;",
          "564:     ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];",
          "565:     ch_data->bs_amp_res = sbr->bs_amp_res_header;",
          "566:     ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];",
          "568:     switch (ch_data->bs_frame_class = get_bits(gb, 2)) {",
          "569:     case FIXFIX:",
          "570:         ch_data->bs_num_env                 = 1 << get_bits(gb, 2);",
          "571:         num_rel_lead                        = ch_data->bs_num_env - 1;",
          "572:         if (ch_data->bs_num_env == 1)",
          "573:             ch_data->bs_amp_res = 0;",
          "575:         if (ch_data->bs_num_env > 4) {",
          "576:             av_log(ac->avctx, AV_LOG_ERROR,",
          "577:                    \"Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\\n\",",
          "578:                    ch_data->bs_num_env);",
          "579:             return -1;",
          "580:         }",
          "582:         ch_data->t_env[0]                   = 0;",
          "583:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "585:         abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /",
          "586:                    ch_data->bs_num_env;",
          "587:         for (i = 0; i < num_rel_lead; i++)",
          "588:             ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;",
          "590:         ch_data->bs_freq_res[1] = get_bits1(gb);",
          "591:         for (i = 1; i < ch_data->bs_num_env; i++)",
          "592:             ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];",
          "593:         break;",
          "594:     case FIXVAR:",
          "595:         abs_bord_trail                     += get_bits(gb, 2);",
          "596:         num_rel_trail                       = get_bits(gb, 2);",
          "597:         ch_data->bs_num_env                 = num_rel_trail + 1;",
          "598:         ch_data->t_env[0]                   = 0;",
          "599:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "601:         for (i = 0; i < num_rel_trail; i++)",
          "602:             ch_data->t_env[ch_data->bs_num_env - 1 - i] =",
          "603:                 ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;",
          "605:         bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);",
          "607:         for (i = 0; i < ch_data->bs_num_env; i++)",
          "608:             ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);",
          "609:         break;",
          "610:     case VARFIX:",
          "611:         ch_data->t_env[0]                   = get_bits(gb, 2);",
          "612:         num_rel_lead                        = get_bits(gb, 2);",
          "613:         ch_data->bs_num_env                 = num_rel_lead + 1;",
          "614:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "616:         for (i = 0; i < num_rel_lead; i++)",
          "617:             ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;",
          "619:         bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);",
          "621:         get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);",
          "622:         break;",
          "623:     case VARVAR:",
          "624:         ch_data->t_env[0]                   = get_bits(gb, 2);",
          "625:         abs_bord_trail                     += get_bits(gb, 2);",
          "626:         num_rel_lead                        = get_bits(gb, 2);",
          "627:         num_rel_trail                       = get_bits(gb, 2);",
          "628:         ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;",
          "630:         if (ch_data->bs_num_env > 5) {",
          "631:             av_log(ac->avctx, AV_LOG_ERROR,",
          "632:                    \"Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\\n\",",
          "633:                    ch_data->bs_num_env);",
          "634:             return -1;",
          "635:         }",
          "637:         ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;",
          "639:         for (i = 0; i < num_rel_lead; i++)",
          "640:             ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;",
          "641:         for (i = 0; i < num_rel_trail; i++)",
          "642:             ch_data->t_env[ch_data->bs_num_env - 1 - i] =",
          "643:                 ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;",
          "645:         bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);",
          "647:         get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);",
          "648:         break;",
          "649:     }",
          "651:     av_assert0(bs_pointer >= 0);",
          "652:     if (bs_pointer > ch_data->bs_num_env + 1) {",
          "653:         av_log(ac->avctx, AV_LOG_ERROR,",
          "654:                \"Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\\n\",",
          "655:                bs_pointer);",
          "656:         return -1;",
          "657:     }",
          "659:     for (i = 1; i <= ch_data->bs_num_env; i++) {",
          "660:         if (ch_data->t_env[i-1] > ch_data->t_env[i]) {",
          "661:             av_log(ac->avctx, AV_LOG_ERROR, \"Non monotone time borders\\n\");",
          "662:             return -1;",
          "663:         }",
          "664:     }",
          "666:     ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;",
          "668:     ch_data->t_q[0]                     = ch_data->t_env[0];",
          "669:     ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];",
          "670:     if (ch_data->bs_num_noise > 1) {",
          "671:         int idx;",
          "672:         if (ch_data->bs_frame_class == FIXFIX) {",
          "673:             idx = ch_data->bs_num_env >> 1;",
          "674:         } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR",
          "675:             idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);",
          "676:         } else { // VARFIX",
          "677:             if (!bs_pointer)",
          "678:                 idx = 1;",
          "679:             else if (bs_pointer == 1)",
          "680:                 idx = ch_data->bs_num_env - 1;",
          "681:             else // bs_pointer > 1",
          "682:                 idx = bs_pointer - 1;",
          "683:         }",
          "684:         ch_data->t_q[1] = ch_data->t_env[idx];",
          "685:     }",
          "687:     ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev",
          "688:     ch_data->e_a[1] = -1;",
          "689:     if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0",
          "690:         ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;",
          "691:     } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1",
          "692:         ch_data->e_a[1] = bs_pointer - 1;",
          "694:     return 0;",
          "695: }",
          "697: static void copy_sbr_grid(SBRData *dst, const SBRData *src) {",
          "699:     dst->bs_freq_res[0]    = dst->bs_freq_res[dst->bs_num_env];",
          "700:     dst->t_env_num_env_old = dst->t_env[dst->bs_num_env];",
          "701:     dst->e_a[0]            = -(dst->e_a[1] != dst->bs_num_env);",
          "704:     memcpy(dst->bs_freq_res+1, src->bs_freq_res+1, sizeof(dst->bs_freq_res)-sizeof(*dst->bs_freq_res));",
          "705:     memcpy(dst->t_env,         src->t_env,         sizeof(dst->t_env));",
          "706:     memcpy(dst->t_q,           src->t_q,           sizeof(dst->t_q));",
          "707:     dst->bs_num_env        = src->bs_num_env;",
          "708:     dst->bs_amp_res        = src->bs_amp_res;",
          "709:     dst->bs_num_noise      = src->bs_num_noise;",
          "710:     dst->bs_frame_class    = src->bs_frame_class;",
          "711:     dst->e_a[1]            = src->e_a[1];",
          "712: }",
          "715: static void read_sbr_dtdf(SpectralBandReplication *sbr, GetBitContext *gb,",
          "716:                           SBRData *ch_data)",
          "717: {",
          "718:     get_bits1_vector(gb, ch_data->bs_df_env,   ch_data->bs_num_env);",
          "719:     get_bits1_vector(gb, ch_data->bs_df_noise, ch_data->bs_num_noise);",
          "720: }",
          "723: static void read_sbr_invf(SpectralBandReplication *sbr, GetBitContext *gb,",
          "724:                           SBRData *ch_data)",
          "725: {",
          "726:     int i;",
          "728:     memcpy(ch_data->bs_invf_mode[1], ch_data->bs_invf_mode[0], 5 * sizeof(uint8_t));",
          "729:     for (i = 0; i < sbr->n_q; i++)",
          "730:         ch_data->bs_invf_mode[0][i] = get_bits(gb, 2);",
          "731: }",
          "733: static void read_sbr_envelope(SpectralBandReplication *sbr, GetBitContext *gb,",
          "734:                               SBRData *ch_data, int ch)",
          "735: {",
          "736:     int bits;",
          "737:     int i, j, k;",
          "738:     VLC_TYPE (*t_huff)[2], (*f_huff)[2];",
          "739:     int t_lav, f_lav;",
          "740:     const int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;",
          "741:     const int odd = sbr->n[1] & 1;",
          "743:     if (sbr->bs_coupling && ch) {",
          "744:         if (ch_data->bs_amp_res) {",
          "745:             bits   = 5;",
          "746:             t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_3_0DB].table;",
          "747:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_3_0DB];",
          "748:             f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;",
          "749:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];",
          "750:         } else {",
          "751:             bits   = 6;",
          "752:             t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_1_5DB].table;",
          "753:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_1_5DB];",
          "754:             f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_1_5DB].table;",
          "755:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_1_5DB];",
          "756:         }",
          "757:     } else {",
          "758:         if (ch_data->bs_amp_res) {",
          "759:             bits   = 6;",
          "760:             t_huff = vlc_sbr[T_HUFFMAN_ENV_3_0DB].table;",
          "761:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_3_0DB];",
          "762:             f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;",
          "763:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];",
          "764:         } else {",
          "765:             bits   = 7;",
          "766:             t_huff = vlc_sbr[T_HUFFMAN_ENV_1_5DB].table;",
          "767:             t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_1_5DB];",
          "768:             f_huff = vlc_sbr[F_HUFFMAN_ENV_1_5DB].table;",
          "769:             f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_1_5DB];",
          "770:         }",
          "771:     }",
          "773:     for (i = 0; i < ch_data->bs_num_env; i++) {",
          "774:         if (ch_data->bs_df_env[i]) {",
          "776:             if (ch_data->bs_freq_res[i + 1] == ch_data->bs_freq_res[i]) {",
          "777:                 for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)",
          "778:                     ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);",
          "779:             } else if (ch_data->bs_freq_res[i + 1]) {",
          "780:                 for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {",
          "781:                     k = (j + odd) >> 1; // find k such that f_tablelow[k] <= f_tablehigh[j] < f_tablelow[k + 1]",
          "782:                     ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);",
          "783:                 }",
          "784:             } else {",
          "785:                 for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {",
          "786:                     k = j ? 2*j - odd : 0; // find k such that f_tablehigh[k] == f_tablelow[j]",
          "787:                     ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);",
          "788:                 }",
          "789:             }",
          "790:         } else {",
          "791:             ch_data->env_facs[i + 1][0] = delta * get_bits(gb, bits); // bs_env_start_value_balance",
          "792:             for (j = 1; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)",
          "793:                 ch_data->env_facs[i + 1][j] = ch_data->env_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);",
          "794:         }",
          "795:     }",
          "798:     memcpy(ch_data->env_facs[0], ch_data->env_facs[ch_data->bs_num_env],",
          "799:            sizeof(ch_data->env_facs[0]));",
          "800: }",
          "802: static void read_sbr_noise(SpectralBandReplication *sbr, GetBitContext *gb,",
          "803:                            SBRData *ch_data, int ch)",
          "804: {",
          "805:     int i, j;",
          "806:     VLC_TYPE (*t_huff)[2], (*f_huff)[2];",
          "807:     int t_lav, f_lav;",
          "808:     int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;",
          "810:     if (sbr->bs_coupling && ch) {",
          "811:         t_huff = vlc_sbr[T_HUFFMAN_NOISE_BAL_3_0DB].table;",
          "812:         t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_BAL_3_0DB];",
          "813:         f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;",
          "814:         f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];",
          "815:     } else {",
          "816:         t_huff = vlc_sbr[T_HUFFMAN_NOISE_3_0DB].table;",
          "817:         t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_3_0DB];",
          "818:         f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;",
          "819:         f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];",
          "820:     }",
          "822:     for (i = 0; i < ch_data->bs_num_noise; i++) {",
          "823:         if (ch_data->bs_df_noise[i]) {",
          "824:             for (j = 0; j < sbr->n_q; j++)",
          "825:                 ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 2) - t_lav);",
          "826:         } else {",
          "827:             ch_data->noise_facs[i + 1][0] = delta * get_bits(gb, 5); // bs_noise_start_value_balance or bs_noise_start_value_level",
          "828:             for (j = 1; j < sbr->n_q; j++)",
          "829:                 ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);",
          "830:         }",
          "831:     }",
          "834:     memcpy(ch_data->noise_facs[0], ch_data->noise_facs[ch_data->bs_num_noise],",
          "835:            sizeof(ch_data->noise_facs[0]));",
          "836: }",
          "838: static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,",
          "839:                                GetBitContext *gb,",
          "840:                                int bs_extension_id, int *num_bits_left)",
          "841: {",
          "842:     switch (bs_extension_id) {",
          "843:     case EXTENSION_ID_PS:",
          "844:         if (!ac->oc[1].m4ac.ps) {",
          "845:             av_log(ac->avctx, AV_LOG_ERROR, \"Parametric Stereo signaled to be not-present but was found in the bitstream.\\n\");",
          "846:             skip_bits_long(gb, *num_bits_left); // bs_fill_bits",
          "848:         } else {",
          "849: #if 1",
          "851:             ac->avctx->profile = FF_PROFILE_AAC_HE_V2;",
          "852: #else",
          "853:             avpriv_report_missing_feature(ac->avctx, \"Parametric Stereo\");",
          "854:             skip_bits_long(gb, *num_bits_left); // bs_fill_bits",
          "856: #endif",
          "857:         }",
          "858:         break;",
          "859:     default:",
          "861:         if (bs_extension_id || *num_bits_left > 16 || show_bits(gb, *num_bits_left))",
          "862:             avpriv_request_sample(ac->avctx, \"Reserved SBR extensions\");",
          "863:         skip_bits_long(gb, *num_bits_left); // bs_fill_bits",
          "865:         break;",
          "866:     }",
          "867: }",
          "869: static int read_sbr_single_channel_element(AACContext *ac,",
          "870:                                             SpectralBandReplication *sbr,",
          "871:                                             GetBitContext *gb)",
          "872: {",
          "873:     if (get_bits1(gb)) // bs_data_extra",
          "874:         skip_bits(gb, 4); // bs_reserved",
          "876:     if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))",
          "877:         return -1;",
          "878:     read_sbr_dtdf(sbr, gb, &sbr->data[0]);",
          "879:     read_sbr_invf(sbr, gb, &sbr->data[0]);",
          "880:     read_sbr_envelope(sbr, gb, &sbr->data[0], 0);",
          "881:     read_sbr_noise(sbr, gb, &sbr->data[0], 0);",
          "883:     if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))",
          "884:         get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);",
          "886:     return 0;",
          "887: }",
          "889: static int read_sbr_channel_pair_element(AACContext *ac,",
          "890:                                           SpectralBandReplication *sbr,",
          "891:                                           GetBitContext *gb)",
          "892: {",
          "893:     if (get_bits1(gb))    // bs_data_extra",
          "894:         skip_bits(gb, 8); // bs_reserved",
          "896:     if ((sbr->bs_coupling = get_bits1(gb))) {",
          "897:         if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))",
          "898:             return -1;",
          "899:         copy_sbr_grid(&sbr->data[1], &sbr->data[0]);",
          "900:         read_sbr_dtdf(sbr, gb, &sbr->data[0]);",
          "901:         read_sbr_dtdf(sbr, gb, &sbr->data[1]);",
          "902:         read_sbr_invf(sbr, gb, &sbr->data[0]);",
          "903:         memcpy(sbr->data[1].bs_invf_mode[1], sbr->data[1].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));",
          "904:         memcpy(sbr->data[1].bs_invf_mode[0], sbr->data[0].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));",
          "905:         read_sbr_envelope(sbr, gb, &sbr->data[0], 0);",
          "906:         read_sbr_noise(sbr, gb, &sbr->data[0], 0);",
          "907:         read_sbr_envelope(sbr, gb, &sbr->data[1], 1);",
          "908:         read_sbr_noise(sbr, gb, &sbr->data[1], 1);",
          "909:     } else {",
          "910:         if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]) ||",
          "911:             read_sbr_grid(ac, sbr, gb, &sbr->data[1]))",
          "912:             return -1;",
          "913:         read_sbr_dtdf(sbr, gb, &sbr->data[0]);",
          "914:         read_sbr_dtdf(sbr, gb, &sbr->data[1]);",
          "915:         read_sbr_invf(sbr, gb, &sbr->data[0]);",
          "916:         read_sbr_invf(sbr, gb, &sbr->data[1]);",
          "917:         read_sbr_envelope(sbr, gb, &sbr->data[0], 0);",
          "918:         read_sbr_envelope(sbr, gb, &sbr->data[1], 1);",
          "919:         read_sbr_noise(sbr, gb, &sbr->data[0], 0);",
          "920:         read_sbr_noise(sbr, gb, &sbr->data[1], 1);",
          "921:     }",
          "923:     if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))",
          "924:         get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);",
          "925:     if ((sbr->data[1].bs_add_harmonic_flag = get_bits1(gb)))",
          "926:         get_bits1_vector(gb, sbr->data[1].bs_add_harmonic, sbr->n[1]);",
          "928:     return 0;",
          "929: }",
          "931: static unsigned int read_sbr_data(AACContext *ac, SpectralBandReplication *sbr,",
          "932:                                   GetBitContext *gb, int id_aac)",
          "933: {",
          "934:     unsigned int cnt = get_bits_count(gb);",
          "936:     sbr->id_aac = id_aac;",
          "938:     if (id_aac == TYPE_SCE || id_aac == TYPE_CCE) {",
          "939:         if (read_sbr_single_channel_element(ac, sbr, gb)) {",
          "940:             sbr_turnoff(sbr);",
          "941:             return get_bits_count(gb) - cnt;",
          "942:         }",
          "943:     } else if (id_aac == TYPE_CPE) {",
          "944:         if (read_sbr_channel_pair_element(ac, sbr, gb)) {",
          "945:             sbr_turnoff(sbr);",
          "946:             return get_bits_count(gb) - cnt;",
          "947:         }",
          "948:     } else {",
          "949:         av_log(ac->avctx, AV_LOG_ERROR,",
          "950:             \"Invalid bitstream - cannot apply SBR to element type %d\\n\", id_aac);",
          "951:         sbr_turnoff(sbr);",
          "952:         return get_bits_count(gb) - cnt;",
          "953:     }",
          "954:     if (get_bits1(gb)) { // bs_extended_data",
          "955:         int num_bits_left = get_bits(gb, 4); // bs_extension_size",
          "956:         if (num_bits_left == 15)",
          "957:             num_bits_left += get_bits(gb, 8); // bs_esc_count",
          "959:         num_bits_left <<= 3;",
          "960:         while (num_bits_left > 7) {",
          "961:             num_bits_left -= 2;",
          "962:             read_sbr_extension(ac, sbr, gb, get_bits(gb, 2), &num_bits_left); // bs_extension_id",
          "963:         }",
          "964:         if (num_bits_left < 0) {",
          "965:             av_log(ac->avctx, AV_LOG_ERROR, \"SBR Extension over read.\\n\");",
          "966:         }",
          "967:         if (num_bits_left > 0)",
          "968:             skip_bits(gb, num_bits_left);",
          "969:     }",
          "971:     return get_bits_count(gb) - cnt;",
          "972: }",
          "974: static void sbr_reset(AACContext *ac, SpectralBandReplication *sbr)",
          "975: {",
          "976:     int err;",
          "977:     err = sbr_make_f_master(ac, sbr, &sbr->spectrum_params);",
          "978:     if (err >= 0)",
          "979:         err = sbr_make_f_derived(ac, sbr);",
          "980:     if (err < 0) {",
          "981:         av_log(ac->avctx, AV_LOG_ERROR,",
          "982:                \"SBR reset failed. Switching SBR to pure upsampling mode.\\n\");",
          "983:         sbr_turnoff(sbr);",
          "984:     }",
          "985: }",
          "995: int ff_decode_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,",
          "996:                             GetBitContext *gb_host, int crc, int cnt, int id_aac)",
          "997: {",
          "998:     unsigned int num_sbr_bits = 0, num_align_bits;",
          "999:     unsigned bytes_read;",
          "1000:     GetBitContext gbc = *gb_host, *gb = &gbc;",
          "1001:     skip_bits_long(gb_host, cnt*8 - 4);",
          "1003:     sbr->reset = 0;",
          "1005:     if (!sbr->sample_rate)",
          "1006:         sbr->sample_rate = 2 * ac->oc[1].m4ac.sample_rate; //TODO use the nominal sample rate for arbitrary sample rate support",
          "1007:     if (!ac->oc[1].m4ac.ext_sample_rate)",
          "1008:         ac->oc[1].m4ac.ext_sample_rate = 2 * ac->oc[1].m4ac.sample_rate;",
          "1010:     if (crc) {",
          "1011:         skip_bits(gb, 10); // bs_sbr_crc_bits; TODO - implement CRC check",
          "1012:         num_sbr_bits += 10;",
          "1013:     }",
          "1016:     sbr->kx[0] = sbr->kx[1];",
          "1017:     sbr->m[0] = sbr->m[1];",
          "1018:     sbr->kx_and_m_pushed = 1;",
          "1020:     num_sbr_bits++;",
          "1021:     if (get_bits1(gb)) // bs_header_flag",
          "1022:         num_sbr_bits += read_sbr_header(sbr, gb);",
          "1024:     if (sbr->reset)",
          "1025:         sbr_reset(ac, sbr);",
          "1027:     if (sbr->start)",
          "1028:         num_sbr_bits  += read_sbr_data(ac, sbr, gb, id_aac);",
          "1030:     num_align_bits = ((cnt << 3) - 4 - num_sbr_bits) & 7;",
          "1031:     bytes_read = ((num_sbr_bits + num_align_bits + 4) >> 3);",
          "1033:     if (bytes_read > cnt) {",
          "1034:         av_log(ac->avctx, AV_LOG_ERROR,",
          "1035:                \"Expected to read %d SBR bytes actually read %d.\\n\", cnt, bytes_read);",
          "1036:     }",
          "1037:     return cnt;",
          "1038: }",
          "1046: #ifndef sbr_qmf_analysis",
          "1047: static void sbr_qmf_analysis(AVFloatDSPContext *dsp, FFTContext *mdct,",
          "1048:                              SBRDSPContext *sbrdsp, const float *in, float *x,",
          "1049:                              float z[320], float W[2][32][32][2], int buf_idx)",
          "1050: {",
          "1051:     int i;",
          "1052:     memcpy(x    , x+1024, (320-32)*sizeof(x[0]));",
          "1053:     memcpy(x+288, in,         1024*sizeof(x[0]));",
          "1054:     for (i = 0; i < 32; i++) { // numTimeSlots*RATE = 16*2 as 960 sample frames",
          "1056:         dsp->vector_fmul_reverse(z, sbr_qmf_window_ds, x, 320);",
          "1057:         sbrdsp->sum64x5(z);",
          "1058:         sbrdsp->qmf_pre_shuffle(z);",
          "1059:         mdct->imdct_half(mdct, z, z+64);",
          "1060:         sbrdsp->qmf_post_shuffle(W[buf_idx][i], z);",
          "1061:         x += 32;",
          "1062:     }",
          "1063: }",
          "1064: #endif",
          "1070: #ifndef sbr_qmf_synthesis",
          "1071: static void sbr_qmf_synthesis(FFTContext *mdct,",
          "1072:                               SBRDSPContext *sbrdsp, AVFloatDSPContext *dsp,",
          "1073:                               float *out, float X[2][38][64],",
          "1074:                               float mdct_buf[2][64],",
          "1075:                               float *v0, int *v_off, const unsigned int div)",
          "1076: {",
          "1077:     int i, n;",
          "1078:     const float *sbr_qmf_window = div ? sbr_qmf_window_ds : sbr_qmf_window_us;",
          "1079:     const int step = 128 >> div;",
          "1080:     float *v;",
          "1081:     for (i = 0; i < 32; i++) {",
          "1082:         if (*v_off < step) {",
          "1083:             int saved_samples = (1280 - 128) >> div;",
          "1084:             memcpy(&v0[SBR_SYNTHESIS_BUF_SIZE - saved_samples], v0, saved_samples * sizeof(float));",
          "1086:         } else {",
          "1088:         }",
          "1089:         v = v0 + *v_off;",
          "1090:         if (div) {",
          "1091:             for (n = 0; n < 32; n++) {",
          "1092:                 X[0][i][   n] = -X[0][i][n];",
          "1093:                 X[0][i][32+n] =  X[1][i][31-n];",
          "1094:             }",
          "1095:             mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);",
          "1096:             sbrdsp->qmf_deint_neg(v, mdct_buf[0]);",
          "1097:         } else {",
          "1098:             sbrdsp->neg_odd_64(X[1][i]);",
          "1099:             mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);",
          "1100:             mdct->imdct_half(mdct, mdct_buf[1], X[1][i]);",
          "1101:             sbrdsp->qmf_deint_bfly(v, mdct_buf[1], mdct_buf[0]);",
          "1102:         }",
          "1103:         dsp->vector_fmul    (out, v                , sbr_qmf_window                       , 64 >> div);",
          "1104:         dsp->vector_fmul_add(out, v + ( 192 >> div), sbr_qmf_window + ( 64 >> div), out   , 64 >> div);",
          "1105:         dsp->vector_fmul_add(out, v + ( 256 >> div), sbr_qmf_window + (128 >> div), out   , 64 >> div);",
          "1106:         dsp->vector_fmul_add(out, v + ( 448 >> div), sbr_qmf_window + (192 >> div), out   , 64 >> div);",
          "1107:         dsp->vector_fmul_add(out, v + ( 512 >> div), sbr_qmf_window + (256 >> div), out   , 64 >> div);",
          "1108:         dsp->vector_fmul_add(out, v + ( 704 >> div), sbr_qmf_window + (320 >> div), out   , 64 >> div);",
          "1109:         dsp->vector_fmul_add(out, v + ( 768 >> div), sbr_qmf_window + (384 >> div), out   , 64 >> div);",
          "1110:         dsp->vector_fmul_add(out, v + ( 960 >> div), sbr_qmf_window + (448 >> div), out   , 64 >> div);",
          "1111:         dsp->vector_fmul_add(out, v + (1024 >> div), sbr_qmf_window + (512 >> div), out   , 64 >> div);",
          "1112:         dsp->vector_fmul_add(out, v + (1216 >> div), sbr_qmf_window + (576 >> div), out   , 64 >> div);",
          "1113:         out += 64 >> div;",
          "1114:     }",
          "1115: }",
          "1116: #endif",
          "1119: static int sbr_lf_gen(AACContext *ac, SpectralBandReplication *sbr,",
          "1120:                       float X_low[32][40][2], const float W[2][32][32][2],",
          "1121:                       int buf_idx)",
          "1122: {",
          "1123:     int i, k;",
          "1124:     const int t_HFGen = 8;",
          "1125:     const int i_f = 32;",
          "1126:     memset(X_low, 0, 32*sizeof(*X_low));",
          "1127:     for (k = 0; k < sbr->kx[1]; k++) {",
          "1128:         for (i = t_HFGen; i < i_f + t_HFGen; i++) {",
          "1129:             X_low[k][i][0] = W[buf_idx][i - t_HFGen][k][0];",
          "1130:             X_low[k][i][1] = W[buf_idx][i - t_HFGen][k][1];",
          "1131:         }",
          "1132:     }",
          "1133:     buf_idx = 1-buf_idx;",
          "1134:     for (k = 0; k < sbr->kx[0]; k++) {",
          "1135:         for (i = 0; i < t_HFGen; i++) {",
          "1136:             X_low[k][i][0] = W[buf_idx][i + i_f - t_HFGen][k][0];",
          "1137:             X_low[k][i][1] = W[buf_idx][i + i_f - t_HFGen][k][1];",
          "1138:         }",
          "1139:     }",
          "1140:     return 0;",
          "1141: }",
          "1144: static int sbr_hf_gen(AACContext *ac, SpectralBandReplication *sbr,",
          "1145:                       float X_high[64][40][2], const float X_low[32][40][2],",
          "1146:                       const float (*alpha0)[2], const float (*alpha1)[2],",
          "1147:                       const float bw_array[5], const uint8_t *t_env,",
          "1148:                       int bs_num_env)",
          "1149: {",
          "1150:     int j, x;",
          "1151:     int g = 0;",
          "1152:     int k = sbr->kx[1];",
          "1153:     for (j = 0; j < sbr->num_patches; j++) {",
          "1154:         for (x = 0; x < sbr->patch_num_subbands[j]; x++, k++) {",
          "1155:             const int p = sbr->patch_start_subband[j] + x;",
          "1156:             while (g <= sbr->n_q && k >= sbr->f_tablenoise[g])",
          "1157:                 g++;",
          "1158:             g--;",
          "1160:             if (g < 0) {",
          "1161:                 av_log(ac->avctx, AV_LOG_ERROR,",
          "1162:                        \"ERROR : no subband found for frequency %d\\n\", k);",
          "1163:                 return -1;",
          "1164:             }",
          "1166:             sbr->dsp.hf_gen(X_high[k] + ENVELOPE_ADJUSTMENT_OFFSET,",
          "1167:                             X_low[p]  + ENVELOPE_ADJUSTMENT_OFFSET,",
          "1168:                             alpha0[p], alpha1[p], bw_array[g],",
          "1169:                             2 * t_env[0], 2 * t_env[bs_num_env]);",
          "1170:         }",
          "1171:     }",
          "1172:     if (k < sbr->m[1] + sbr->kx[1])",
          "1173:         memset(X_high + k, 0, (sbr->m[1] + sbr->kx[1] - k) * sizeof(*X_high));",
          "1175:     return 0;",
          "1176: }",
          "1179: static int sbr_x_gen(SpectralBandReplication *sbr, float X[2][38][64],",
          "1180:                      const float Y0[38][64][2], const float Y1[38][64][2],",
          "1181:                      const float X_low[32][40][2], int ch)",
          "1182: {",
          "1183:     int k, i;",
          "1184:     const int i_f = 32;",
          "1185:     const int i_Temp = FFMAX(2*sbr->data[ch].t_env_num_env_old - i_f, 0);",
          "1186:     memset(X, 0, 2*sizeof(*X));",
          "1187:     for (k = 0; k < sbr->kx[0]; k++) {",
          "1188:         for (i = 0; i < i_Temp; i++) {",
          "1189:             X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];",
          "1190:             X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];",
          "1191:         }",
          "1192:     }",
          "1193:     for (; k < sbr->kx[0] + sbr->m[0]; k++) {",
          "1194:         for (i = 0; i < i_Temp; i++) {",
          "1195:             X[0][i][k] = Y0[i + i_f][k][0];",
          "1196:             X[1][i][k] = Y0[i + i_f][k][1];",
          "1197:         }",
          "1198:     }",
          "1200:     for (k = 0; k < sbr->kx[1]; k++) {",
          "1201:         for (i = i_Temp; i < 38; i++) {",
          "1202:             X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];",
          "1203:             X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];",
          "1204:         }",
          "1205:     }",
          "1206:     for (; k < sbr->kx[1] + sbr->m[1]; k++) {",
          "1207:         for (i = i_Temp; i < i_f; i++) {",
          "1208:             X[0][i][k] = Y1[i][k][0];",
          "1209:             X[1][i][k] = Y1[i][k][1];",
          "1210:         }",
          "1211:     }",
          "1212:     return 0;",
          "1213: }",
          "1218: static int sbr_mapping(AACContext *ac, SpectralBandReplication *sbr,",
          "1219:                         SBRData *ch_data, int e_a[2])",
          "1220: {",
          "1221:     int e, i, m;",
          "1223:     memset(ch_data->s_indexmapped[1], 0, 7*sizeof(ch_data->s_indexmapped[1]));",
          "1224:     for (e = 0; e < ch_data->bs_num_env; e++) {",
          "1225:         const unsigned int ilim = sbr->n[ch_data->bs_freq_res[e + 1]];",
          "1226:         uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;",
          "1227:         int k;",
          "1229:         if (sbr->kx[1] != table[0]) {",
          "1230:             av_log(ac->avctx, AV_LOG_ERROR, \"kx != f_table{high,low}[0]. \"",
          "1231:                    \"Derived frequency tables were not regenerated.\\n\");",
          "1232:             sbr_turnoff(sbr);",
          "1233:             return AVERROR_BUG;",
          "1234:         }",
          "1235:         for (i = 0; i < ilim; i++)",
          "1236:             for (m = table[i]; m < table[i + 1]; m++)",
          "1237:                 sbr->e_origmapped[e][m - sbr->kx[1]] = ch_data->env_facs[e+1][i];",
          "1240:         k = (ch_data->bs_num_noise > 1) && (ch_data->t_env[e] >= ch_data->t_q[1]);",
          "1241:         for (i = 0; i < sbr->n_q; i++)",
          "1242:             for (m = sbr->f_tablenoise[i]; m < sbr->f_tablenoise[i + 1]; m++)",
          "1243:                 sbr->q_mapped[e][m - sbr->kx[1]] = ch_data->noise_facs[k+1][i];",
          "1245:         for (i = 0; i < sbr->n[1]; i++) {",
          "1246:             if (ch_data->bs_add_harmonic_flag) {",
          "1247:                 const unsigned int m_midpoint =",
          "1248:                     (sbr->f_tablehigh[i] + sbr->f_tablehigh[i + 1]) >> 1;",
          "1250:                 ch_data->s_indexmapped[e + 1][m_midpoint - sbr->kx[1]] = ch_data->bs_add_harmonic[i] *",
          "1251:                     (e >= e_a[1] || (ch_data->s_indexmapped[0][m_midpoint - sbr->kx[1]] == 1));",
          "1252:             }",
          "1253:         }",
          "1255:         for (i = 0; i < ilim; i++) {",
          "1256:             int additional_sinusoid_present = 0;",
          "1257:             for (m = table[i]; m < table[i + 1]; m++) {",
          "1258:                 if (ch_data->s_indexmapped[e + 1][m - sbr->kx[1]]) {",
          "1259:                     additional_sinusoid_present = 1;",
          "1260:                     break;",
          "1261:                 }",
          "1262:             }",
          "1263:             memset(&sbr->s_mapped[e][table[i] - sbr->kx[1]], additional_sinusoid_present,",
          "1264:                    (table[i + 1] - table[i]) * sizeof(sbr->s_mapped[e][0]));",
          "1265:         }",
          "1266:     }",
          "1268:     memcpy(ch_data->s_indexmapped[0], ch_data->s_indexmapped[ch_data->bs_num_env], sizeof(ch_data->s_indexmapped[0]));",
          "1269:     return 0;",
          "1270: }",
          "1273: static void sbr_env_estimate(float (*e_curr)[48], float X_high[64][40][2],",
          "1274:                              SpectralBandReplication *sbr, SBRData *ch_data)",
          "1275: {",
          "1276:     int e, m;",
          "1277:     int kx1 = sbr->kx[1];",
          "1279:     if (sbr->bs_interpol_freq) {",
          "1280:         for (e = 0; e < ch_data->bs_num_env; e++) {",
          "1281:             const float recip_env_size = 0.5f / (ch_data->t_env[e + 1] - ch_data->t_env[e]);",
          "1282:             int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1283:             int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1285:             for (m = 0; m < sbr->m[1]; m++) {",
          "1286:                 float sum = sbr->dsp.sum_square(X_high[m+kx1] + ilb, iub - ilb);",
          "1287:                 e_curr[e][m] = sum * recip_env_size;",
          "1288:             }",
          "1289:         }",
          "1290:     } else {",
          "1291:         int k, p;",
          "1293:         for (e = 0; e < ch_data->bs_num_env; e++) {",
          "1294:             const int env_size = 2 * (ch_data->t_env[e + 1] - ch_data->t_env[e]);",
          "1295:             int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1296:             int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;",
          "1297:             const uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;",
          "1299:             for (p = 0; p < sbr->n[ch_data->bs_freq_res[e + 1]]; p++) {",
          "1300:                 float sum = 0.0f;",
          "1301:                 const int den = env_size * (table[p + 1] - table[p]);",
          "1303:                 for (k = table[p]; k < table[p + 1]; k++) {",
          "1304:                     sum += sbr->dsp.sum_square(X_high[k] + ilb, iub - ilb);",
          "1305:                 }",
          "1306:                 sum /= den;",
          "1307:                 for (k = table[p]; k < table[p + 1]; k++) {",
          "1308:                     e_curr[e][k - kx1] = sum;",
          "1309:                 }",
          "1310:             }",
          "1311:         }",
          "1312:     }",
          "1313: }",
          "1315: void ff_sbr_apply(AACContext *ac, SpectralBandReplication *sbr, int id_aac,",
          "1316:                   float* L, float* R)",
          "1317: {",
          "1318:     int downsampled = ac->oc[1].m4ac.ext_sample_rate < sbr->sample_rate;",
          "1319:     int ch;",
          "1320:     int nch = (id_aac == TYPE_CPE) ? 2 : 1;",
          "1321:     int err;",
          "1323:     if (id_aac != sbr->id_aac) {",
          "1324:         av_log(ac->avctx, AV_LOG_ERROR,",
          "1325:             \"element type mismatch %d != %d\\n\", id_aac, sbr->id_aac);",
          "1326:         sbr_turnoff(sbr);",
          "1327:     }",
          "1329:     if (!sbr->kx_and_m_pushed) {",
          "1330:         sbr->kx[0] = sbr->kx[1];",
          "1331:         sbr->m[0] = sbr->m[1];",
          "1332:     } else {",
          "1333:         sbr->kx_and_m_pushed = 0;",
          "1334:     }",
          "1336:     if (sbr->start) {",
          "1337:         sbr_dequant(sbr, id_aac);",
          "1338:     }",
          "1339:     for (ch = 0; ch < nch; ch++) {",
          "1341:         sbr_qmf_analysis(ac->fdsp, &sbr->mdct_ana, &sbr->dsp, ch ? R : L, sbr->data[ch].analysis_filterbank_samples,",
          "1342:                          (float*)sbr->qmf_filter_scratch,",
          "1343:                          sbr->data[ch].W, sbr->data[ch].Ypos);",
          "1344:         sbr->c.sbr_lf_gen(ac, sbr, sbr->X_low,",
          "1345:                           (const float (*)[32][32][2]) sbr->data[ch].W,",
          "1346:                           sbr->data[ch].Ypos);",
          "1347:         sbr->data[ch].Ypos ^= 1;",
          "1348:         if (sbr->start) {",
          "1349:             sbr->c.sbr_hf_inverse_filter(&sbr->dsp, sbr->alpha0, sbr->alpha1,",
          "1350:                                          (const float (*)[40][2]) sbr->X_low, sbr->k[0]);",
          "1351:             sbr_chirp(sbr, &sbr->data[ch]);",
          "1352:             av_assert0(sbr->data[ch].bs_num_env > 0);",
          "1353:             sbr_hf_gen(ac, sbr, sbr->X_high,",
          "1354:                        (const float (*)[40][2]) sbr->X_low,",
          "1355:                        (const float (*)[2]) sbr->alpha0,",
          "1356:                        (const float (*)[2]) sbr->alpha1,",
          "1357:                        sbr->data[ch].bw_array, sbr->data[ch].t_env,",
          "1358:                        sbr->data[ch].bs_num_env);",
          "1361:             err = sbr_mapping(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);",
          "1362:             if (!err) {",
          "1363:                 sbr_env_estimate(sbr->e_curr, sbr->X_high, sbr, &sbr->data[ch]);",
          "1364:                 sbr_gain_calc(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);",
          "1365:                 sbr->c.sbr_hf_assemble(sbr->data[ch].Y[sbr->data[ch].Ypos],",
          "1366:                                 (const float (*)[40][2]) sbr->X_high,",
          "1367:                                 sbr, &sbr->data[ch],",
          "1368:                                 sbr->data[ch].e_a);",
          "1369:             }",
          "1370:         }",
          "1373:         sbr->c.sbr_x_gen(sbr, sbr->X[ch],",
          "1374:                   (const float (*)[64][2]) sbr->data[ch].Y[1-sbr->data[ch].Ypos],",
          "1375:                   (const float (*)[64][2]) sbr->data[ch].Y[  sbr->data[ch].Ypos],",
          "1376:                   (const float (*)[40][2]) sbr->X_low, ch);",
          "1377:     }",
          "1379:     if (ac->oc[1].m4ac.ps == 1) {",
          "1380:         if (sbr->ps.start) {",
          "1381:             ff_ps_apply(ac->avctx, &sbr->ps, sbr->X[0], sbr->X[1], sbr->kx[1] + sbr->m[1]);",
          "1382:         } else {",
          "1383:             memcpy(sbr->X[1], sbr->X[0], sizeof(sbr->X[0]));",
          "1384:         }",
          "1385:         nch = 2;",
          "1386:     }",
          "1388:     sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp, ac->fdsp,",
          "1389:                       L, sbr->X[0], sbr->qmf_filter_scratch,",
          "1390:                       sbr->data[0].synthesis_filterbank_samples,",
          "1391:                       &sbr->data[0].synthesis_filterbank_samples_offset,",
          "1392:                       downsampled);",
          "1393:     if (nch == 2)",
          "1394:         sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp, ac->fdsp,",
          "1395:                           R, sbr->X[1], sbr->qmf_filter_scratch,",
          "1396:                           sbr->data[1].synthesis_filterbank_samples,",
          "1397:                           &sbr->data[1].synthesis_filterbank_samples_offset,",
          "1398:                           downsampled);",
          "1399: }",
          "1401: static void aacsbr_func_ptr_init(AACSBRContext *c)",
          "1402: {",
          "1403:     c->sbr_lf_gen            = sbr_lf_gen;",
          "1404:     c->sbr_hf_assemble       = sbr_hf_assemble;",
          "1405:     c->sbr_x_gen             = sbr_x_gen;",
          "1406:     c->sbr_hf_inverse_filter = sbr_hf_inverse_filter;",
          "1408:     if(ARCH_MIPS)",
          "1409:         ff_aacsbr_func_ptr_init_mips(c);",
          "1410: }",
          "",
          "---------------"
        ],
        "libavcodec/sbrdsp.c||libavcodec/sbrdsp.c": [
          "File: libavcodec/sbrdsp.c -> libavcodec/sbrdsp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #include \"libavutil/intfloat.h\"",
          "26: #include \"sbrdsp.h\"",
          "37: static float sbr_sum_square_c(float (*x)[2], int n)",
          "38: {",
          "39:     float sum0 = 0.0f, sum1 = 0.0f;",
          "",
          "[Removed Lines]",
          "28: static void sbr_sum64x5_c(float *z)",
          "29: {",
          "30:     int k;",
          "31:     for (k = 0; k < 64; k++) {",
          "32:         float f = z[k] + z[k + 64] + z[k + 128] + z[k + 192] + z[k + 256];",
          "33:         z[k] = f;",
          "34:     }",
          "35: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101:     }",
          "102: }",
          "114: #if 0",
          "",
          "[Removed Lines]",
          "104: static void sbr_qmf_deint_bfly_c(float *v, const float *src0, const float *src1)",
          "105: {",
          "106:     int i;",
          "107:     for (i = 0; i < 64; i++) {",
          "108:         v[      i] = src0[i] - src1[63 - i];",
          "109:         v[127 - i] = src0[i] + src1[63 - i];",
          "110:     }",
          "111: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "238:     }",
          "239: }",
          "",
          "[Removed Lines]",
          "241: static void sbr_hf_apply_noise_0(float (*Y)[2], const float *s_m,",
          "242:                                  const float *q_filt, int noise,",
          "243:                                  int kx, int m_max)",
          "244: {",
          "245:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, 1.0, 0.0, m_max);",
          "246: }",
          "248: static void sbr_hf_apply_noise_1(float (*Y)[2], const float *s_m,",
          "249:                                  const float *q_filt, int noise,",
          "250:                                  int kx, int m_max)",
          "251: {",
          "252:     float phi_sign = 1 - 2 * (kx & 1);",
          "253:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, 0.0, phi_sign, m_max);",
          "254: }",
          "256: static void sbr_hf_apply_noise_2(float (*Y)[2], const float *s_m,",
          "257:                                  const float *q_filt, int noise,",
          "258:                                  int kx, int m_max)",
          "259: {",
          "260:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, -1.0, 0.0, m_max);",
          "261: }",
          "263: static void sbr_hf_apply_noise_3(float (*Y)[2], const float *s_m,",
          "264:                                  const float *q_filt, int noise,",
          "265:                                  int kx, int m_max)",
          "266: {",
          "267:     float phi_sign = 1 - 2 * (kx & 1);",
          "268:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, 0.0, -phi_sign, m_max);",
          "269: }",
          "271: av_cold void ff_sbrdsp_init(SBRDSPContext *s)",
          "272: {",
          "273:     s->sum64x5 = sbr_sum64x5_c;",
          "274:     s->sum_square = sbr_sum_square_c;",
          "275:     s->neg_odd_64 = sbr_neg_odd_64_c;",
          "276:     s->qmf_pre_shuffle = sbr_qmf_pre_shuffle_c;",
          "277:     s->qmf_post_shuffle = sbr_qmf_post_shuffle_c;",
          "278:     s->qmf_deint_neg = sbr_qmf_deint_neg_c;",
          "279:     s->qmf_deint_bfly = sbr_qmf_deint_bfly_c;",
          "280:     s->autocorrelate = sbr_autocorrelate_c;",
          "281:     s->hf_gen = sbr_hf_gen_c;",
          "282:     s->hf_g_filt = sbr_hf_g_filt_c;",
          "284:     s->hf_apply_noise[0] = sbr_hf_apply_noise_0;",
          "285:     s->hf_apply_noise[1] = sbr_hf_apply_noise_1;",
          "286:     s->hf_apply_noise[2] = sbr_hf_apply_noise_2;",
          "287:     s->hf_apply_noise[3] = sbr_hf_apply_noise_3;",
          "289:     if (ARCH_ARM)",
          "290:         ff_sbrdsp_init_arm(s);",
          "291:     if (ARCH_X86)",
          "292:         ff_sbrdsp_init_x86(s);",
          "293:     if (ARCH_MIPS)",
          "294:         ff_sbrdsp_init_mips(s);",
          "295: }",
          "",
          "[Added Lines]",
          "222: #include \"sbrdsp_template.c\"",
          "",
          "---------------"
        ],
        "libavcodec/sbrdsp_template.c||libavcodec/sbrdsp_template.c": [
          "File: libavcodec/sbrdsp_template.c -> libavcodec/sbrdsp_template.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: static void sbr_sum64x5_c(float *z)",
          "24: {",
          "25:     int k;",
          "26:     for (k = 0; k < 64; k++) {",
          "27:         float f = z[k] + z[k + 64] + z[k + 128] + z[k + 192] + z[k + 256];",
          "28:         z[k] = f;",
          "29:     }",
          "30: }",
          "32: static void sbr_qmf_deint_bfly_c(float *v, const float *src0, const float *src1)",
          "33: {",
          "34:     int i;",
          "35:     for (i = 0; i < 64; i++) {",
          "36:         v[      i] = src0[i] - src1[63 - i];",
          "37:         v[127 - i] = src0[i] + src1[63 - i];",
          "38:     }",
          "39: }",
          "41: static void sbr_hf_apply_noise_0(float (*Y)[2], const float *s_m,",
          "42:                                  const float *q_filt, int noise,",
          "43:                                  int kx, int m_max)",
          "44: {",
          "45:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, 1.0, 0.0, m_max);",
          "46: }",
          "48: static void sbr_hf_apply_noise_1(float (*Y)[2], const float *s_m,",
          "49:                                  const float *q_filt, int noise,",
          "50:                                  int kx, int m_max)",
          "51: {",
          "52:     float phi_sign = 1 - 2 * (kx & 1);",
          "53:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, 0.0, phi_sign, m_max);",
          "54: }",
          "56: static void sbr_hf_apply_noise_2(float (*Y)[2], const float *s_m,",
          "57:                                  const float *q_filt, int noise,",
          "58:                                  int kx, int m_max)",
          "59: {",
          "60:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, -1.0, 0.0, m_max);",
          "61: }",
          "63: static void sbr_hf_apply_noise_3(float (*Y)[2], const float *s_m,",
          "64:                                  const float *q_filt, int noise,",
          "65:                                  int kx, int m_max)",
          "66: {",
          "67:     float phi_sign = 1 - 2 * (kx & 1);",
          "68:     sbr_hf_apply_noise(Y, s_m, q_filt, noise, 0.0, -phi_sign, m_max);",
          "69: }",
          "71: av_cold void ff_sbrdsp_init(SBRDSPContext *s)",
          "72: {",
          "73:     s->sum64x5 = sbr_sum64x5_c;",
          "74:     s->sum_square = sbr_sum_square_c;",
          "75:     s->neg_odd_64 = sbr_neg_odd_64_c;",
          "76:     s->qmf_pre_shuffle = sbr_qmf_pre_shuffle_c;",
          "77:     s->qmf_post_shuffle = sbr_qmf_post_shuffle_c;",
          "78:     s->qmf_deint_neg = sbr_qmf_deint_neg_c;",
          "79:     s->qmf_deint_bfly = sbr_qmf_deint_bfly_c;",
          "80:     s->autocorrelate = sbr_autocorrelate_c;",
          "81:     s->hf_gen = sbr_hf_gen_c;",
          "82:     s->hf_g_filt = sbr_hf_g_filt_c;",
          "84:     s->hf_apply_noise[0] = sbr_hf_apply_noise_0;",
          "85:     s->hf_apply_noise[1] = sbr_hf_apply_noise_1;",
          "86:     s->hf_apply_noise[2] = sbr_hf_apply_noise_2;",
          "87:     s->hf_apply_noise[3] = sbr_hf_apply_noise_3;",
          "89:     if (ARCH_ARM)",
          "90:         ff_sbrdsp_init_arm(s);",
          "91:     if (ARCH_X86)",
          "92:         ff_sbrdsp_init_x86(s);",
          "93:     if (ARCH_MIPS)",
          "94:         ff_sbrdsp_init_mips(s);",
          "95: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
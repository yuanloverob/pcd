{
  "cve_id": "CVE-2017-9229",
  "cve_desc": "An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A SIGSEGV occurs in left_adjust_char_head() during regular expression compilation. Invalid handling of reg->dmax in forward_search_range() could result in an invalid pointer dereference, normally as an immediate denial-of-service condition.",
  "repo": "kkos/oniguruma",
  "patch_hash": "b690371bbf97794b4a1d3f295d4fb9a8b05d402d",
  "patch_info": {
    "commit_hash": "b690371bbf97794b4a1d3f295d4fb9a8b05d402d",
    "repo": "kkos/oniguruma",
    "commit_url": "https://github.com/kkos/oniguruma/commit/b690371bbf97794b4a1d3f295d4fb9a8b05d402d",
    "files": [
      "src/regexec.c"
    ],
    "message": "fix #59 : access to invalid address by reg->dmax value",
    "before_after_code_files": [
      "src/regexec.c||src/regexec.c"
    ]
  },
  "patch_diff": {
    "src/regexec.c||src/regexec.c": [
      "File: src/regexec.c -> src/regexec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3235:     }",
      "3236:     else {",
      "3237:       if (reg->dmax != ONIG_INFINITE_DISTANCE) {",
      "3245:         }",
      "3246:         else {",
      "3250:         }",
      "3251:       }",
      "3252:     }",
      "",
      "[Removed Lines]",
      "3239:         if (*low > s) {",
      "3242:           if (low_prev && IS_NULL(*low_prev))",
      "3244:                                                    (pprev ? pprev : s), *low);",
      "3247:           if (low_prev)",
      "3249:                                                    (pprev ? pprev : str), *low);",
      "",
      "[Added Lines]",
      "3238:         if (p - str < reg->dmax) {",
      "3240:           if (low_prev)",
      "3245:           if (*low > s) {",
      "3248:             if (low_prev && IS_NULL(*low_prev))",
      "3250:                                                      (pprev ? pprev : s), *low);",
      "3251:           }",
      "3252:           else {",
      "3253:             if (low_prev)",
      "3255:                                                      (pprev ? pprev : str), *low);",
      "3256:           }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "80aca8b13c6d1c05e6de28b08dd39e58f0837209",
      "candidate_info": {
        "commit_hash": "80aca8b13c6d1c05e6de28b08dd39e58f0837209",
        "repo": "kkos/oniguruma",
        "commit_url": "https://github.com/kkos/oniguruma/commit/80aca8b13c6d1c05e6de28b08dd39e58f0837209",
        "files": [
          "src/regexec.c"
        ],
        "message": "fix indent",
        "before_after_code_files": [
          "src/regexec.c||src/regexec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/regexec.c||src/regexec.c"
          ],
          "candidate": [
            "src/regexec.c||src/regexec.c"
          ]
        }
      },
      "candidate_diff": {
        "src/regexec.c||src/regexec.c": [
          "File: src/regexec.c -> src/regexec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1108:     }",
          "1109:     else if (level == nest) {",
          "1110:       if (k->type == STK_MEM_START) {",
          "1133:       }",
          "1134:       else if (k->type == STK_MEM_END) {",
          "1138:       }",
          "1139:     }",
          "1140:     k--;",
          "",
          "[Removed Lines]",
          "1111:  if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {",
          "1112:    pstart = k->u.mem.pstr;",
          "1113:    if (pend != NULL_UCHARP) {",
          "1115:      p  = pstart;",
          "1116:      ss = *s;",
          "1118:      if (ignore_case != 0) {",
          "1119:        if (string_cmp_ic(reg->enc, case_fold_flag,",
          "1120:     pstart, &ss, (int )(pend - pstart)) == 0)",
          "1122:      }",
          "1123:      else {",
          "1124:        while (p < pend) {",
          "1126:        }",
          "1127:      }",
          "1130:      return 1;",
          "1131:    }",
          "1132:  }",
          "1135:  if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {",
          "1136:    pend = k->u.mem.pstr;",
          "1137:  }",
          "",
          "[Added Lines]",
          "1111:         if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {",
          "1112:           pstart = k->u.mem.pstr;",
          "1113:           if (pend != NULL_UCHARP) {",
          "1115:             p  = pstart;",
          "1116:             ss = *s;",
          "1118:             if (ignore_case != 0) {",
          "1119:               if (string_cmp_ic(reg->enc, case_fold_flag,",
          "1120:                                 pstart, &ss, (int )(pend - pstart)) == 0)",
          "1122:             }",
          "1123:             else {",
          "1124:               while (p < pend) {",
          "1126:               }",
          "1127:             }",
          "1130:             return 1;",
          "1131:           }",
          "1132:         }",
          "1135:         if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {",
          "1136:           pend = k->u.mem.pstr;",
          "1137:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1316:     case OP_END:  MOP_IN(OP_END);",
          "1317:       n = s - sstart;",
          "1318:       if (n > best_len) {",
          "1320: #ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE",
          "1328:         }",
          "1329: #endif",
          "1333: #ifdef USE_POSIX_API_REGION_OPTION",
          "1375: #ifdef USE_CAPTURE_HISTORY",
          "1377:               int r;",
          "1378:               OnigCaptureTreeNode* node;",
          "",
          "[Removed Lines]",
          "1319:  OnigRegion* region;",
          "1321:  if (IS_FIND_LONGEST(option)) {",
          "1322:    if (n > msa->best_len) {",
          "1323:      msa->best_len = n;",
          "1324:      msa->best_s   = (UChar* )sstart;",
          "1325:    }",
          "1326:    else",
          "1327:      goto end_best_len;",
          "1330:  best_len = n;",
          "1331:  region = msa->region;",
          "1332:  if (region) {",
          "1334:    if (IS_POSIX_REGION(msa->options)) {",
          "1335:      posix_regmatch_t* rmt = (posix_regmatch_t* )region;",
          "1337:      rmt[0].rm_so = sstart - str;",
          "1338:      rmt[0].rm_eo = s      - str;",
          "1339:      for (i = 1; i <= num_mem; i++) {",
          "1340:        if (mem_end_stk[i] != INVALID_STACK_INDEX) {",
          "1341:   if (BIT_STATUS_AT(reg->bt_mem_start, i))",
          "1342:     rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;",
          "1343:   else",
          "1344:     rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;",
          "1346:   rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)",
          "1347:     ? STACK_AT(mem_end_stk[i])->u.mem.pstr",
          "1348:     : (UChar* )((void* )mem_end_stk[i])) - str;",
          "1349:        }",
          "1350:        else {",
          "1351:   rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;",
          "1352:        }",
          "1353:      }",
          "1354:    }",
          "1355:    else {",
          "1357:      region->beg[0] = sstart - str;",
          "1358:      region->end[0] = s      - str;",
          "1359:      for (i = 1; i <= num_mem; i++) {",
          "1360:        if (mem_end_stk[i] != INVALID_STACK_INDEX) {",
          "1361:   if (BIT_STATUS_AT(reg->bt_mem_start, i))",
          "1362:     region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;",
          "1363:   else",
          "1364:     region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;",
          "1366:   region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)",
          "1367:       ? STACK_AT(mem_end_stk[i])->u.mem.pstr",
          "1368:       : (UChar* )((void* )mem_end_stk[i])) - str;",
          "1369:        }",
          "1370:        else {",
          "1371:   region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;",
          "1372:        }",
          "1373:      }",
          "1376:      if (reg->capture_history != 0) {",
          "",
          "[Added Lines]",
          "1319:         OnigRegion* region;",
          "1321:         if (IS_FIND_LONGEST(option)) {",
          "1322:           if (n > msa->best_len) {",
          "1323:             msa->best_len = n;",
          "1324:             msa->best_s   = (UChar* )sstart;",
          "1325:           }",
          "1326:           else",
          "1327:             goto end_best_len;",
          "1330:         best_len = n;",
          "1331:         region = msa->region;",
          "1332:         if (region) {",
          "1334:           if (IS_POSIX_REGION(msa->options)) {",
          "1335:             posix_regmatch_t* rmt = (posix_regmatch_t* )region;",
          "1337:             rmt[0].rm_so = sstart - str;",
          "1338:             rmt[0].rm_eo = s      - str;",
          "1339:             for (i = 1; i <= num_mem; i++) {",
          "1340:               if (mem_end_stk[i] != INVALID_STACK_INDEX) {",
          "1341:                 if (BIT_STATUS_AT(reg->bt_mem_start, i))",
          "1342:                   rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;",
          "1343:                 else",
          "1344:                   rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;",
          "1346:                 rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)",
          "1347:                                 ? STACK_AT(mem_end_stk[i])->u.mem.pstr",
          "1348:                                 : (UChar* )((void* )mem_end_stk[i])) - str;",
          "1349:               }",
          "1350:               else {",
          "1351:                 rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;",
          "1352:               }",
          "1353:             }",
          "1354:           }",
          "1355:           else {",
          "1357:             region->beg[0] = sstart - str;",
          "1358:             region->end[0] = s      - str;",
          "1359:             for (i = 1; i <= num_mem; i++) {",
          "1360:               if (mem_end_stk[i] != INVALID_STACK_INDEX) {",
          "1361:                 if (BIT_STATUS_AT(reg->bt_mem_start, i))",
          "1362:                   region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;",
          "1363:                 else",
          "1364:                   region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;",
          "1366:                 region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)",
          "1367:                                   ? STACK_AT(mem_end_stk[i])->u.mem.pstr",
          "1368:                                   : (UChar* )((void* )mem_end_stk[i])) - str;",
          "1369:               }",
          "1370:               else {",
          "1371:                 region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;",
          "1372:               }",
          "1373:             }",
          "1376:             if (reg->capture_history != 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1398:                 goto finish;",
          "1399:               }",
          "1402: #ifdef USE_POSIX_API_REGION_OPTION",
          "1404: #endif",
          "1408: #ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE",
          "",
          "[Removed Lines]",
          "1400:      }",
          "",
          "[Added Lines]",
          "1400:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1411:       MOP_OUT;",
          "1413:       if (IS_FIND_CONDITION(option)) {",
          "1421:       }",
          "",
          "[Removed Lines]",
          "1414:  if (IS_FIND_NOT_EMPTY(option) && s == sstart) {",
          "1415:    best_len = ONIG_MISMATCH;",
          "1417:  }",
          "1418:  if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {",
          "1420:  }",
          "",
          "[Added Lines]",
          "1414:         if (IS_FIND_NOT_EMPTY(option) && s == sstart) {",
          "1415:           best_len = ONIG_MISMATCH;",
          "1417:         }",
          "1418:         if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {",
          "1420:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1439:     case OP_EXACT1_IC:  MOP_IN(OP_EXACT1_IC);",
          "1440:       {",
          "1453:             goto fail;",
          "1454:           }",
          "1457:       }",
          "1458:       MOP_OUT;",
          "1459:       break;",
          "",
          "[Removed Lines]",
          "1441:  int len;",
          "1442:  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];",
          "1444:  DATA_ENSURE(1);",
          "1445:  len = ONIGENC_MBC_CASE_FOLD(encode,",
          "1447:       case_fold_flag,",
          "1448:       &s, end, lowbuf);",
          "1449:  DATA_ENSURE(0);",
          "1450:  q = lowbuf;",
          "1451:  while (len-- > 0) {",
          "1452:    if (*p != *q) {",
          "1455:    p++; q++;",
          "1456:  }",
          "",
          "[Added Lines]",
          "1441:         int len;",
          "1442:         UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];",
          "1444:         DATA_ENSURE(1);",
          "1445:         len = ONIGENC_MBC_CASE_FOLD(encode,",
          "1447:                                     case_fold_flag,",
          "1448:                                     &s, end, lowbuf);",
          "1449:         DATA_ENSURE(0);",
          "1450:         q = lowbuf;",
          "1451:         while (len-- > 0) {",
          "1452:           if (*p != *q) {",
          "1455:           p++; q++;",
          "1456:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1518:       GET_LENGTH_INC(tlen, p);",
          "1519:       DATA_ENSURE(tlen);",
          "1520:       while (tlen-- > 0) {",
          "1522:       }",
          "1523:       sprev = s - 1;",
          "1524:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1521:  if (*p++ != *s++) goto fail;",
          "",
          "[Added Lines]",
          "1521:         if (*p++ != *s++) goto fail;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1528:     case OP_EXACTN_IC:  MOP_IN(OP_EXACTN_IC);",
          "1529:       {",
          "1550:       }",
          "1552:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1530:  int len;",
          "1531:  UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];",
          "1533:  GET_LENGTH_INC(tlen, p);",
          "1534:  endp = p + tlen;",
          "1536:  while (p < endp) {",
          "1537:    sprev = s;",
          "1538:    DATA_ENSURE(1);",
          "1539:    len = ONIGENC_MBC_CASE_FOLD(encode,",
          "1541:         case_fold_flag,",
          "1542:         &s, end, lowbuf);",
          "1543:    DATA_ENSURE(0);",
          "1544:    q = lowbuf;",
          "1545:    while (len-- > 0) {",
          "1546:      if (*p != *q) goto fail;",
          "1547:      p++; q++;",
          "1548:    }",
          "1549:  }",
          "",
          "[Added Lines]",
          "1530:         int len;",
          "1531:         UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];",
          "1533:         GET_LENGTH_INC(tlen, p);",
          "1534:         endp = p + tlen;",
          "1536:         while (p < endp) {",
          "1537:           sprev = s;",
          "1538:           DATA_ENSURE(1);",
          "1539:           len = ONIGENC_MBC_CASE_FOLD(encode,",
          "1541:                                       case_fold_flag,",
          "1542:                                       &s, end, lowbuf);",
          "1543:           DATA_ENSURE(0);",
          "1544:           q = lowbuf;",
          "1545:           while (len-- > 0) {",
          "1546:             if (*p != *q) goto fail;",
          "1547:             p++; q++;",
          "1548:           }",
          "1549:         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1600:       GET_LENGTH_INC(tlen, p);",
          "1601:       DATA_ENSURE(tlen * 2);",
          "1602:       while (tlen-- > 0) {",
          "1607:       }",
          "1608:       sprev = s - 2;",
          "1609:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1603:  if (*p != *s) goto fail;",
          "1604:  p++; s++;",
          "1605:  if (*p != *s) goto fail;",
          "1606:  p++; s++;",
          "",
          "[Added Lines]",
          "1603:         if (*p != *s) goto fail;",
          "1604:         p++; s++;",
          "1605:         if (*p != *s) goto fail;",
          "1606:         p++; s++;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1614:       GET_LENGTH_INC(tlen, p);",
          "1615:       DATA_ENSURE(tlen * 3);",
          "1616:       while (tlen-- > 0) {",
          "1623:       }",
          "1624:       sprev = s - 3;",
          "1625:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1617:  if (*p != *s) goto fail;",
          "1618:  p++; s++;",
          "1619:  if (*p != *s) goto fail;",
          "1620:  p++; s++;",
          "1621:  if (*p != *s) goto fail;",
          "1622:  p++; s++;",
          "",
          "[Added Lines]",
          "1617:         if (*p != *s) goto fail;",
          "1618:         p++; s++;",
          "1619:         if (*p != *s) goto fail;",
          "1620:         p++; s++;",
          "1621:         if (*p != *s) goto fail;",
          "1622:         p++; s++;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1632:       tlen2 *= tlen;",
          "1633:       DATA_ENSURE(tlen2);",
          "1634:       while (tlen2-- > 0) {",
          "1637:       }",
          "1638:       sprev = s - tlen;",
          "1639:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1635:  if (*p != *s) goto fail;",
          "1636:  p++; s++;",
          "",
          "[Added Lines]",
          "1635:         if (*p != *s) goto fail;",
          "1636:         p++; s++;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1654:     cclass_mb:",
          "1655:       GET_LENGTH_INC(tlen, p);",
          "1656:       {",
          "1668: #ifdef PLATFORM_UNALIGNED_WORD_ACCESS",
          "1670: #else",
          "1674: #endif",
          "1675:       }",
          "1676:       p += tlen;",
          "",
          "[Removed Lines]",
          "1657:  OnigCodePoint code;",
          "1658:  UChar *ss;",
          "1659:  int mb_len;",
          "1661:  DATA_ENSURE(1);",
          "1662:  mb_len = enclen(encode, s);",
          "1663:  DATA_ENSURE(mb_len);",
          "1664:  ss = s;",
          "1665:  s += mb_len;",
          "1666:  code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "1669:  if (! onig_is_in_code_range(p, code)) goto fail;",
          "1671:  q = p;",
          "1672:  ALIGNMENT_RIGHT(q);",
          "1673:  if (! onig_is_in_code_range(q, code)) goto fail;",
          "",
          "[Added Lines]",
          "1657:         OnigCodePoint code;",
          "1658:         UChar *ss;",
          "1659:         int mb_len;",
          "1661:         DATA_ENSURE(1);",
          "1662:         mb_len = enclen(encode, s);",
          "1663:         DATA_ENSURE(mb_len);",
          "1664:         ss = s;",
          "1665:         s += mb_len;",
          "1666:         code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "1669:         if (! onig_is_in_code_range(p, code)) goto fail;",
          "1671:         q = p;",
          "1672:         ALIGNMENT_RIGHT(q);",
          "1673:         if (! onig_is_in_code_range(q, code)) goto fail;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1680:     case OP_CCLASS_MIX:  MOP_IN(OP_CCLASS_MIX);",
          "1681:       DATA_ENSURE(1);",
          "1682:       if (ONIGENC_IS_MBC_HEAD(encode, s)) {",
          "1685:       }",
          "1686:       else {",
          "1694:       }",
          "1695:       MOP_OUT;",
          "1696:       break;",
          "",
          "[Removed Lines]",
          "1683:  p += SIZE_BITSET;",
          "1684:  goto cclass_mb;",
          "1687:  if (BITSET_AT(((BitSetRef )p), *s) == 0)",
          "1688:    goto fail;",
          "1690:  p += SIZE_BITSET;",
          "1691:  GET_LENGTH_INC(tlen, p);",
          "1692:  p += tlen;",
          "1693:  s++;",
          "",
          "[Added Lines]",
          "1683:         p += SIZE_BITSET;",
          "1684:         goto cclass_mb;",
          "1687:         if (BITSET_AT(((BitSetRef )p), *s) == 0)",
          "1688:           goto fail;",
          "1690:         p += SIZE_BITSET;",
          "1691:         GET_LENGTH_INC(tlen, p);",
          "1692:         p += tlen;",
          "1693:         s++;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1706:     case OP_CCLASS_MB_NOT:  MOP_IN(OP_CCLASS_MB_NOT);",
          "1707:       DATA_ENSURE(1);",
          "1708:       if (! ONIGENC_IS_MBC_HEAD(encode, s)) {",
          "1713:       }",
          "1715:     cclass_mb_not:",
          "1716:       GET_LENGTH_INC(tlen, p);",
          "1717:       {",
          "1723:           DATA_ENSURE(1);",
          "1733: #ifdef PLATFORM_UNALIGNED_WORD_ACCESS",
          "1735: #else",
          "1739: #endif",
          "1740:       }",
          "1741:       p += tlen;",
          "",
          "[Removed Lines]",
          "1709:  s++;",
          "1710:  GET_LENGTH_INC(tlen, p);",
          "1711:  p += tlen;",
          "1712:  goto cc_mb_not_success;",
          "1718:  OnigCodePoint code;",
          "1719:  UChar *ss;",
          "1720:  int mb_len = enclen(encode, s);",
          "1722:  if (! DATA_ENSURE_CHECK(mb_len)) {",
          "1724:    s = (UChar* )end;",
          "1725:    p += tlen;",
          "1726:    goto cc_mb_not_success;",
          "1727:  }",
          "1729:  ss = s;",
          "1730:  s += mb_len;",
          "1731:  code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "1734:  if (onig_is_in_code_range(p, code)) goto fail;",
          "1736:  q = p;",
          "1737:  ALIGNMENT_RIGHT(q);",
          "1738:  if (onig_is_in_code_range(q, code)) goto fail;",
          "",
          "[Added Lines]",
          "1709:         s++;",
          "1710:         GET_LENGTH_INC(tlen, p);",
          "1711:         p += tlen;",
          "1712:         goto cc_mb_not_success;",
          "1718:         OnigCodePoint code;",
          "1719:         UChar *ss;",
          "1720:         int mb_len = enclen(encode, s);",
          "1722:         if (! DATA_ENSURE_CHECK(mb_len)) {",
          "1724:           s = (UChar* )end;",
          "1725:           p += tlen;",
          "1726:           goto cc_mb_not_success;",
          "1727:         }",
          "1729:         ss = s;",
          "1730:         s += mb_len;",
          "1731:         code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "1734:         if (onig_is_in_code_range(p, code)) goto fail;",
          "1736:         q = p;",
          "1737:         ALIGNMENT_RIGHT(q);",
          "1738:         if (onig_is_in_code_range(q, code)) goto fail;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1747:     case OP_CCLASS_MIX_NOT:  MOP_IN(OP_CCLASS_MIX_NOT);",
          "1748:       DATA_ENSURE(1);",
          "1749:       if (ONIGENC_IS_MBC_HEAD(encode, s)) {",
          "1752:       }",
          "1753:       else {",
          "1761:       }",
          "1762:       MOP_OUT;",
          "1763:       break;",
          "1765:     case OP_CCLASS_NODE:  MOP_IN(OP_CCLASS_NODE);",
          "1766:       {",
          "1768:         void *node;",
          "1769:         int mb_len;",
          "1770:         UChar *ss;",
          "1772:         DATA_ENSURE(1);",
          "1773:         GET_POINTER_INC(node, p);",
          "1780:       }",
          "1781:       MOP_OUT;",
          "1782:       break;",
          "",
          "[Removed Lines]",
          "1750:  p += SIZE_BITSET;",
          "1751:  goto cclass_mb_not;",
          "1754:  if (BITSET_AT(((BitSetRef )p), *s) != 0)",
          "1755:    goto fail;",
          "1757:  p += SIZE_BITSET;",
          "1758:  GET_LENGTH_INC(tlen, p);",
          "1759:  p += tlen;",
          "1760:  s++;",
          "1767:  OnigCodePoint code;",
          "1774:  mb_len = enclen(encode, s);",
          "1775:  ss = s;",
          "1776:  s += mb_len;",
          "1777:  DATA_ENSURE(0);",
          "1778:  code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "1779:  if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;",
          "",
          "[Added Lines]",
          "1750:         p += SIZE_BITSET;",
          "1751:         goto cclass_mb_not;",
          "1754:         if (BITSET_AT(((BitSetRef )p), *s) != 0)",
          "1755:           goto fail;",
          "1757:         p += SIZE_BITSET;",
          "1758:         GET_LENGTH_INC(tlen, p);",
          "1759:         p += tlen;",
          "1760:         s++;",
          "1767:         OnigCodePoint code;",
          "1774:         mb_len = enclen(encode, s);",
          "1775:         ss = s;",
          "1776:         s += mb_len;",
          "1777:         DATA_ENSURE(0);",
          "1778:         code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "1779:         if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1801:     case OP_ANYCHAR_STAR:  MOP_IN(OP_ANYCHAR_STAR);",
          "1802:       while (DATA_ENSURE_CHECK1) {",
          "1805:         DATA_ENSURE(n);",
          "1806:         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;",
          "1807:         sprev = s;",
          "",
          "[Removed Lines]",
          "1803:  STACK_PUSH_ALT(p, s, sprev);",
          "1804:  n = enclen(encode, s);",
          "",
          "[Added Lines]",
          "1803:         STACK_PUSH_ALT(p, s, sprev);",
          "1804:         n = enclen(encode, s);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1813:     case OP_ANYCHAR_ML_STAR:  MOP_IN(OP_ANYCHAR_ML_STAR);",
          "1814:       while (DATA_ENSURE_CHECK1) {",
          "1826:       }",
          "1827:       MOP_OUT;",
          "1828:       break;",
          "1830:     case OP_ANYCHAR_STAR_PEEK_NEXT:  MOP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);",
          "1831:       while (DATA_ENSURE_CHECK1) {",
          "1836:         DATA_ENSURE(n);",
          "1837:         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;",
          "1838:         sprev = s;",
          "",
          "[Removed Lines]",
          "1815:  STACK_PUSH_ALT(p, s, sprev);",
          "1816:  n = enclen(encode, s);",
          "1817:  if (n > 1) {",
          "1818:    DATA_ENSURE(n);",
          "1819:    sprev = s;",
          "1820:    s += n;",
          "1821:  }",
          "1822:  else {",
          "1823:    sprev = s;",
          "1824:    s++;",
          "1825:  }",
          "1832:  if (*p == *s) {",
          "1833:    STACK_PUSH_ALT(p + 1, s, sprev);",
          "1834:  }",
          "1835:  n = enclen(encode, s);",
          "",
          "[Added Lines]",
          "1815:         STACK_PUSH_ALT(p, s, sprev);",
          "1816:         n = enclen(encode, s);",
          "1817:         if (n > 1) {",
          "1818:           DATA_ENSURE(n);",
          "1819:           sprev = s;",
          "1820:           s += n;",
          "1821:         }",
          "1822:         else {",
          "1823:           sprev = s;",
          "1824:           s++;",
          "1825:         }",
          "1832:         if (*p == *s) {",
          "1833:           STACK_PUSH_ALT(p + 1, s, sprev);",
          "1834:         }",
          "1835:         n = enclen(encode, s);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1845:     case OP_ANYCHAR_ML_STAR_PEEK_NEXT:MOP_IN(OP_ANYCHAR_ML_STAR_PEEK_NEXT);",
          "1846:       while (DATA_ENSURE_CHECK1) {",
          "1860:       }",
          "1861:       p++;",
          "1862:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1847:  if (*p == *s) {",
          "1848:    STACK_PUSH_ALT(p + 1, s, sprev);",
          "1849:  }",
          "1850:  n = enclen(encode, s);",
          "1851:  if (n > 1) {",
          "1852:    DATA_ENSURE(n);",
          "1853:    sprev = s;",
          "1854:    s += n;",
          "1855:  }",
          "1856:  else {",
          "1857:    sprev = s;",
          "1858:    s++;",
          "1859:  }",
          "",
          "[Added Lines]",
          "1847:         if (*p == *s) {",
          "1848:           STACK_PUSH_ALT(p + 1, s, sprev);",
          "1849:         }",
          "1850:         n = enclen(encode, s);",
          "1851:         if (n > 1) {",
          "1852:           DATA_ENSURE(n);",
          "1853:           sprev = s;",
          "1854:           s += n;",
          "1855:         }",
          "1856:         else {",
          "1857:           sprev = s;",
          "1858:           s++;",
          "1859:         }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1866:     case OP_STATE_CHECK_ANYCHAR_STAR:  MOP_IN(OP_STATE_CHECK_ANYCHAR_STAR);",
          "1867:       GET_STATE_CHECK_NUM_INC(mem, p);",
          "1868:       while (DATA_ENSURE_CHECK1) {",
          "1874:         DATA_ENSURE(n);",
          "1875:         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;",
          "1876:         sprev = s;",
          "",
          "[Removed Lines]",
          "1869:  STATE_CHECK_VAL(scv, mem);",
          "1870:  if (scv) goto fail;",
          "1872:  STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);",
          "1873:  n = enclen(encode, s);",
          "",
          "[Added Lines]",
          "1869:         STATE_CHECK_VAL(scv, mem);",
          "1870:         if (scv) goto fail;",
          "1872:         STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);",
          "1873:         n = enclen(encode, s);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1885:       GET_STATE_CHECK_NUM_INC(mem, p);",
          "1886:       while (DATA_ENSURE_CHECK1) {",
          "1901:       }",
          "1902:       MOP_OUT;",
          "1903:       break;",
          "",
          "[Removed Lines]",
          "1887:  STATE_CHECK_VAL(scv, mem);",
          "1888:  if (scv) goto fail;",
          "1890:  STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);",
          "1891:  n = enclen(encode, s);",
          "1892:  if (n > 1) {",
          "1893:    DATA_ENSURE(n);",
          "1894:    sprev = s;",
          "1895:    s += n;",
          "1896:  }",
          "1897:  else {",
          "1898:    sprev = s;",
          "1899:    s++;",
          "1900:  }",
          "",
          "[Added Lines]",
          "1887:         STATE_CHECK_VAL(scv, mem);",
          "1888:         if (scv) goto fail;",
          "1890:         STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);",
          "1891:         n = enclen(encode, s);",
          "1892:         if (n > 1) {",
          "1893:           DATA_ENSURE(n);",
          "1894:           sprev = s;",
          "1895:           s += n;",
          "1896:         }",
          "1897:         else {",
          "1898:           sprev = s;",
          "1899:           s++;",
          "1900:         }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1906:     case OP_WORD:  MOP_IN(OP_WORD);",
          "1907:       DATA_ENSURE(1);",
          "1908:       if (! ONIGENC_IS_MBC_WORD(encode, s, end))",
          "1911:       s += enclen(encode, s);",
          "1912:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1909:  goto fail;",
          "",
          "[Added Lines]",
          "1909:         goto fail;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1915:     case OP_NOT_WORD:  MOP_IN(OP_NOT_WORD);",
          "1916:       DATA_ENSURE(1);",
          "1917:       if (ONIGENC_IS_MBC_WORD(encode, s, end))",
          "1920:       s += enclen(encode, s);",
          "1921:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "1918:  goto fail;",
          "",
          "[Added Lines]",
          "1918:         goto fail;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1924:     case OP_WORD_BOUND:  MOP_IN(OP_WORD_BOUND);",
          "1925:       if (ON_STR_BEGIN(s)) {",
          "1929:       }",
          "1930:       else if (ON_STR_END(s)) {",
          "1933:       }",
          "1934:       else {",
          "1938:       }",
          "1939:       MOP_OUT;",
          "1940:       continue;",
          "",
          "[Removed Lines]",
          "1926:  DATA_ENSURE(1);",
          "1927:  if (! ONIGENC_IS_MBC_WORD(encode, s, end))",
          "1928:    goto fail;",
          "1931:  if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1932:    goto fail;",
          "1935:  if (ONIGENC_IS_MBC_WORD(encode, s, end)",
          "1936:      == ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1937:    goto fail;",
          "",
          "[Added Lines]",
          "1926:         DATA_ENSURE(1);",
          "1927:         if (! ONIGENC_IS_MBC_WORD(encode, s, end))",
          "1928:           goto fail;",
          "1931:         if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1932:           goto fail;",
          "1935:         if (ONIGENC_IS_MBC_WORD(encode, s, end)",
          "1936:             == ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1937:           goto fail;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1943:     case OP_NOT_WORD_BOUND:  MOP_IN(OP_NOT_WORD_BOUND);",
          "1944:       if (ON_STR_BEGIN(s)) {",
          "1947:       }",
          "1948:       else if (ON_STR_END(s)) {",
          "1951:       }",
          "1952:       else {",
          "1956:       }",
          "1957:       MOP_OUT;",
          "1958:       continue;",
          "",
          "[Removed Lines]",
          "1945:  if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))",
          "1946:    goto fail;",
          "1949:  if (ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1950:    goto fail;",
          "1953:  if (ONIGENC_IS_MBC_WORD(encode, s, end)",
          "1954:      != ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1955:    goto fail;",
          "",
          "[Added Lines]",
          "1945:         if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))",
          "1946:           goto fail;",
          "1949:         if (ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1950:           goto fail;",
          "1953:         if (ONIGENC_IS_MBC_WORD(encode, s, end)",
          "1954:             != ONIGENC_IS_MBC_WORD(encode, sprev, end))",
          "1955:           goto fail;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1961: #ifdef USE_WORD_BEGIN_END",
          "1962:     case OP_WORD_BEGIN:  MOP_IN(OP_WORD_BEGIN);",
          "1963:       if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end)) {",
          "1968:       }",
          "1969:       goto fail;",
          "1970:       break;",
          "1972:     case OP_WORD_END:  MOP_IN(OP_WORD_END);",
          "1973:       if (!ON_STR_BEGIN(s) && ONIGENC_IS_MBC_WORD(encode, sprev, end)) {",
          "1978:       }",
          "1979:       goto fail;",
          "1980:       break;",
          "",
          "[Removed Lines]",
          "1964:  if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {",
          "1965:    MOP_OUT;",
          "1966:    continue;",
          "1967:  }",
          "1974:  if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {",
          "1975:    MOP_OUT;",
          "1976:    continue;",
          "1977:  }",
          "",
          "[Added Lines]",
          "1964:         if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {",
          "1965:           MOP_OUT;",
          "1966:           continue;",
          "1967:         }",
          "1974:         if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {",
          "1975:           MOP_OUT;",
          "1976:           continue;",
          "1977:         }",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1997:     case OP_BEGIN_LINE:  MOP_IN(OP_BEGIN_LINE);",
          "1998:       if (ON_STR_BEGIN(s)) {",
          "2002:       }",
          "2003:       else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {",
          "2006:       }",
          "2007:       goto fail;",
          "2008:       break;",
          "",
          "[Removed Lines]",
          "1999:  if (IS_NOTBOL(msa->options)) goto fail;",
          "2000:  MOP_OUT;",
          "2001:  continue;",
          "2004:  MOP_OUT;",
          "2005:  continue;",
          "",
          "[Added Lines]",
          "1999:         if (IS_NOTBOL(msa->options)) goto fail;",
          "2000:         MOP_OUT;",
          "2001:         continue;",
          "2004:         MOP_OUT;",
          "2005:         continue;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2010:     case OP_END_LINE:  MOP_IN(OP_END_LINE);",
          "2011:       if (ON_STR_END(s)) {",
          "2012: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "2014: #endif",
          "2018: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "2020: #endif",
          "2021:       }",
          "2022:       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {",
          "2025:       }",
          "2026: #ifdef USE_CRNL_AS_LINE_TERMINATOR",
          "2027:       else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {",
          "2030:       }",
          "2031: #endif",
          "2032:       goto fail;",
          "",
          "[Removed Lines]",
          "2013:  if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {",
          "2015:    if (IS_NOTEOL(msa->options)) goto fail;",
          "2016:    MOP_OUT;",
          "2017:    continue;",
          "2019:  }",
          "2023:  MOP_OUT;",
          "2024:  continue;",
          "2028:  MOP_OUT;",
          "2029:  continue;",
          "",
          "[Added Lines]",
          "2013:         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {",
          "2015:           if (IS_NOTEOL(msa->options)) goto fail;",
          "2016:           MOP_OUT;",
          "2017:           continue;",
          "2019:         }",
          "2023:         MOP_OUT;",
          "2024:         continue;",
          "2028:         MOP_OUT;",
          "2029:         continue;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2035:     case OP_SEMI_END_BUF:  MOP_IN(OP_SEMI_END_BUF);",
          "2036:       if (ON_STR_END(s)) {",
          "2037: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "2039: #endif",
          "2043: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "2045: #endif",
          "2046:       }",
          "2047:       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&",
          "2051:       }",
          "2052: #ifdef USE_CRNL_AS_LINE_TERMINATOR",
          "2053:       else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {",
          "2054:         UChar* ss = s + enclen(encode, s);",
          "2056:         if (ON_STR_END(ss)) {",
          "2057:           MOP_OUT;",
          "2058:           continue;",
          "",
          "[Removed Lines]",
          "2038:  if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {",
          "2040:    if (IS_NOTEOL(msa->options)) goto fail;",
          "2041:    MOP_OUT;",
          "2042:    continue;",
          "2044:  }",
          "2048:         ON_STR_END(s + enclen(encode, s))) {",
          "2049:  MOP_OUT;",
          "2050:  continue;",
          "2055:  ss += enclen(encode, ss);",
          "",
          "[Added Lines]",
          "2038:         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {",
          "2040:           if (IS_NOTEOL(msa->options)) goto fail;",
          "2041:           MOP_OUT;",
          "2042:           continue;",
          "2044:         }",
          "2048:                ON_STR_END(s + enclen(encode, s))) {",
          "2049:         MOP_OUT;",
          "2050:         continue;",
          "2055:         ss += enclen(encode, ss);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2065:     case OP_BEGIN_POSITION:  MOP_IN(OP_BEGIN_POSITION);",
          "2066:       if (s != msa->start)",
          "2069:       MOP_OUT;",
          "2070:       continue;",
          "",
          "[Removed Lines]",
          "2067:  goto fail;",
          "",
          "[Added Lines]",
          "2067:         goto fail;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2114:       STACK_GET_MEM_START(mem, stkp);",
          "2116:       if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2118:       else",
          "2121:       STACK_PUSH_MEM_END_MARK(mem);",
          "2122:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "2117:  mem_start_stk[mem] = GET_STACK_INDEX(stkp);",
          "2119:  mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);",
          "",
          "[Added Lines]",
          "2117:         mem_start_stk[mem] = GET_STACK_INDEX(stkp);",
          "2119:         mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2138:       GET_MEMNUM_INC(mem, p);",
          "2139:     backref:",
          "2140:       {",
          "2167:       }",
          "2168:       break;",
          "2170:     case OP_BACKREFN_IC:  MOP_IN(OP_BACKREFN_IC);",
          "2171:       GET_MEMNUM_INC(mem, p);",
          "2172:       {",
          "2199:       }",
          "2200:       break;",
          "2202:     case OP_BACKREF_MULTI:  MOP_IN(OP_BACKREF_MULTI);",
          "2203:       {",
          "2238:       }",
          "2239:       break;",
          "2241:     case OP_BACKREF_MULTI_IC:  MOP_IN(OP_BACKREF_MULTI_IC);",
          "2242:       {",
          "2277:       }",
          "2278:       break;",
          "2280: #ifdef USE_BACKREF_WITH_LEVEL",
          "2281:     case OP_BACKREF_WITH_LEVEL:",
          "2282:       {",
          "2304:       }",
          "2306:       break;",
          "2307: #endif",
          "",
          "[Removed Lines]",
          "2141:  int len;",
          "2142:  UChar *pstart, *pend;",
          "2146:  if (mem > num_mem) goto fail;",
          "2147:  if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;",
          "2148:  if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;",
          "2150:  if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2151:    pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2152:  else",
          "2153:    pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2155:  pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2156:   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2157:   : (UChar* )((void* )mem_end_stk[mem]));",
          "2158:  n = pend - pstart;",
          "2159:  DATA_ENSURE(n);",
          "2160:  sprev = s;",
          "2161:  STRING_CMP(pstart, s, n);",
          "2162:  while (sprev + (len = enclen(encode, sprev)) < s)",
          "2163:    sprev += len;",
          "2165:  MOP_OUT;",
          "2166:  continue;",
          "2173:  int len;",
          "2174:  UChar *pstart, *pend;",
          "2178:  if (mem > num_mem) goto fail;",
          "2179:  if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;",
          "2180:  if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;",
          "2182:  if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2183:    pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2184:  else",
          "2185:    pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2187:  pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2188:   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2189:   : (UChar* )((void* )mem_end_stk[mem]));",
          "2190:  n = pend - pstart;",
          "2191:  DATA_ENSURE(n);",
          "2192:  sprev = s;",
          "2193:  STRING_CMP_IC(case_fold_flag, pstart, &s, n);",
          "2194:  while (sprev + (len = enclen(encode, sprev)) < s)",
          "2195:    sprev += len;",
          "2197:  MOP_OUT;",
          "2198:  continue;",
          "2204:  int len, is_fail;",
          "2205:  UChar *pstart, *pend, *swork;",
          "2207:  GET_LENGTH_INC(tlen, p);",
          "2208:  for (i = 0; i < tlen; i++) {",
          "2209:    GET_MEMNUM_INC(mem, p);",
          "2211:    if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;",
          "2212:    if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;",
          "2214:    if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2215:      pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2216:    else",
          "2217:      pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2219:    pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2220:     ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2221:     : (UChar* )((void* )mem_end_stk[mem]));",
          "2222:    n = pend - pstart;",
          "2223:    DATA_ENSURE(n);",
          "2224:    sprev = s;",
          "2225:    swork = s;",
          "2226:    STRING_CMP_VALUE(pstart, swork, n, is_fail);",
          "2227:    if (is_fail) continue;",
          "2228:    s = swork;",
          "2229:    while (sprev + (len = enclen(encode, sprev)) < s)",
          "2230:      sprev += len;",
          "2232:    p += (SIZE_MEMNUM * (tlen - i - 1));",
          "2234:  }",
          "2235:  if (i == tlen) goto fail;",
          "2236:  MOP_OUT;",
          "2237:  continue;",
          "2243:  int len, is_fail;",
          "2244:  UChar *pstart, *pend, *swork;",
          "2246:  GET_LENGTH_INC(tlen, p);",
          "2247:  for (i = 0; i < tlen; i++) {",
          "2248:    GET_MEMNUM_INC(mem, p);",
          "2250:    if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;",
          "2251:    if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;",
          "2253:    if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2254:      pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2255:    else",
          "2256:      pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2258:    pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2259:     ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2260:     : (UChar* )((void* )mem_end_stk[mem]));",
          "2261:    n = pend - pstart;",
          "2262:    DATA_ENSURE(n);",
          "2263:    sprev = s;",
          "2264:    swork = s;",
          "2265:    STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);",
          "2266:    if (is_fail) continue;",
          "2267:    s = swork;",
          "2268:    while (sprev + (len = enclen(encode, sprev)) < s)",
          "2269:      sprev += len;",
          "2271:    p += (SIZE_MEMNUM * (tlen - i - 1));",
          "2273:  }",
          "2274:  if (i == tlen) goto fail;",
          "2275:  MOP_OUT;",
          "2276:  continue;",
          "2283:  int len;",
          "2284:  OnigOptionType ic;",
          "2285:  LengthType level;",
          "2287:  GET_OPTION_INC(ic,    p);",
          "2288:  GET_LENGTH_INC(level, p);",
          "2289:  GET_LENGTH_INC(tlen,  p);",
          "2291:  sprev = s;",
          "2292:  if (backref_match_at_nested_level(reg, stk, stk_base, ic",
          "2293:     , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {",
          "2294:    while (sprev + (len = enclen(encode, sprev)) < s)",
          "2295:      sprev += len;",
          "2297:    p += (SIZE_MEMNUM * tlen);",
          "2298:  }",
          "2299:  else",
          "2300:    goto fail;",
          "2302:  MOP_OUT;",
          "2303:  continue;",
          "",
          "[Added Lines]",
          "2141:         int len;",
          "2142:         UChar *pstart, *pend;",
          "2146:         if (mem > num_mem) goto fail;",
          "2147:         if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;",
          "2148:         if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;",
          "2150:         if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2151:           pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2152:         else",
          "2153:           pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2155:         pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2156:                 ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2157:                 : (UChar* )((void* )mem_end_stk[mem]));",
          "2158:         n = pend - pstart;",
          "2159:         DATA_ENSURE(n);",
          "2160:         sprev = s;",
          "2161:         STRING_CMP(pstart, s, n);",
          "2162:         while (sprev + (len = enclen(encode, sprev)) < s)",
          "2163:           sprev += len;",
          "2165:         MOP_OUT;",
          "2166:         continue;",
          "2173:         int len;",
          "2174:         UChar *pstart, *pend;",
          "2178:         if (mem > num_mem) goto fail;",
          "2179:         if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;",
          "2180:         if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;",
          "2182:         if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2183:           pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2184:         else",
          "2185:           pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2187:         pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2188:                 ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2189:                 : (UChar* )((void* )mem_end_stk[mem]));",
          "2190:         n = pend - pstart;",
          "2191:         DATA_ENSURE(n);",
          "2192:         sprev = s;",
          "2193:         STRING_CMP_IC(case_fold_flag, pstart, &s, n);",
          "2194:         while (sprev + (len = enclen(encode, sprev)) < s)",
          "2195:           sprev += len;",
          "2197:         MOP_OUT;",
          "2198:         continue;",
          "2204:         int len, is_fail;",
          "2205:         UChar *pstart, *pend, *swork;",
          "2207:         GET_LENGTH_INC(tlen, p);",
          "2208:         for (i = 0; i < tlen; i++) {",
          "2209:           GET_MEMNUM_INC(mem, p);",
          "2211:           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;",
          "2212:           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;",
          "2214:           if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2215:             pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2216:           else",
          "2217:             pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2219:           pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2220:                   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2221:                   : (UChar* )((void* )mem_end_stk[mem]));",
          "2222:           n = pend - pstart;",
          "2223:           DATA_ENSURE(n);",
          "2224:           sprev = s;",
          "2225:           swork = s;",
          "2226:           STRING_CMP_VALUE(pstart, swork, n, is_fail);",
          "2227:           if (is_fail) continue;",
          "2228:           s = swork;",
          "2229:           while (sprev + (len = enclen(encode, sprev)) < s)",
          "2230:             sprev += len;",
          "2232:           p += (SIZE_MEMNUM * (tlen - i - 1));",
          "2234:         }",
          "2235:         if (i == tlen) goto fail;",
          "2236:         MOP_OUT;",
          "2237:         continue;",
          "2243:         int len, is_fail;",
          "2244:         UChar *pstart, *pend, *swork;",
          "2246:         GET_LENGTH_INC(tlen, p);",
          "2247:         for (i = 0; i < tlen; i++) {",
          "2248:           GET_MEMNUM_INC(mem, p);",
          "2250:           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;",
          "2251:           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;",
          "2253:           if (BIT_STATUS_AT(reg->bt_mem_start, mem))",
          "2254:             pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;",
          "2255:           else",
          "2256:             pstart = (UChar* )((void* )mem_start_stk[mem]);",
          "2258:           pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)",
          "2259:                   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr",
          "2260:                   : (UChar* )((void* )mem_end_stk[mem]));",
          "2261:           n = pend - pstart;",
          "2262:           DATA_ENSURE(n);",
          "2263:           sprev = s;",
          "2264:           swork = s;",
          "2265:           STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);",
          "2266:           if (is_fail) continue;",
          "2267:           s = swork;",
          "2268:           while (sprev + (len = enclen(encode, sprev)) < s)",
          "2269:             sprev += len;",
          "2271:           p += (SIZE_MEMNUM * (tlen - i - 1));",
          "2273:         }",
          "2274:         if (i == tlen) goto fail;",
          "2275:         MOP_OUT;",
          "2276:         continue;",
          "2283:         int len;",
          "2284:         OnigOptionType ic;",
          "2285:         LengthType level;",
          "2287:         GET_OPTION_INC(ic,    p);",
          "2288:         GET_LENGTH_INC(level, p);",
          "2289:         GET_LENGTH_INC(tlen,  p);",
          "2291:         sprev = s;",
          "2292:         if (backref_match_at_nested_level(reg, stk, stk_base, ic",
          "2293:                      , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {",
          "2294:           while (sprev + (len = enclen(encode, sprev)) < s)",
          "2295:             sprev += len;",
          "2297:           p += (SIZE_MEMNUM * tlen);",
          "2298:         }",
          "2299:         else",
          "2300:           goto fail;",
          "2302:         MOP_OUT;",
          "2303:         continue;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2332:     case OP_NULL_CHECK_END:  MOP_IN(OP_NULL_CHECK_END);",
          "2333:       {",
          "2339: #ifdef ONIG_DEBUG_MATCH",
          "2361:       }",
          "2362:       MOP_OUT;",
          "2363:       continue;",
          "",
          "[Removed Lines]",
          "2334:  int isnull;",
          "2337:  STACK_NULL_CHECK(isnull, mem, s);",
          "2338:  if (isnull) {",
          "2340:    fprintf(stderr, \"NULL_CHECK_END: skip  id:%d, s:%d\\n\",",
          "2341:     (int )mem, (int )s);",
          "2342: #endif",
          "2343:  null_check_found:",
          "2345:    switch (*p++) {",
          "2346:    case OP_JUMP:",
          "2347:    case OP_PUSH:",
          "2348:      p += SIZE_RELADDR;",
          "2349:      break;",
          "2350:    case OP_REPEAT_INC:",
          "2351:    case OP_REPEAT_INC_NG:",
          "2352:    case OP_REPEAT_INC_SG:",
          "2353:    case OP_REPEAT_INC_NG_SG:",
          "2354:      p += SIZE_MEMNUM;",
          "2355:      break;",
          "2356:    default:",
          "2357:      goto unexpected_bytecode_error;",
          "2358:      break;",
          "2359:    }",
          "2360:  }",
          "",
          "[Added Lines]",
          "2333:         int isnull;",
          "2336:         STACK_NULL_CHECK(isnull, mem, s);",
          "2337:         if (isnull) {",
          "2339:           fprintf(stderr, \"NULL_CHECK_END: skip  id:%d, s:%d\\n\",",
          "2340:                   (int )mem, (int )s);",
          "2341: #endif",
          "2342:         null_check_found:",
          "2344:           switch (*p++) {",
          "2345:           case OP_JUMP:",
          "2346:           case OP_PUSH:",
          "2347:             p += SIZE_RELADDR;",
          "2348:             break;",
          "2349:           case OP_REPEAT_INC:",
          "2350:           case OP_REPEAT_INC_NG:",
          "2351:           case OP_REPEAT_INC_SG:",
          "2352:           case OP_REPEAT_INC_NG_SG:",
          "2353:             p += SIZE_MEMNUM;",
          "2354:             break;",
          "2355:           default:",
          "2356:             goto unexpected_bytecode_error;",
          "2357:             break;",
          "2358:           }",
          "2359:         }",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2366: #ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT",
          "2367:     case OP_NULL_CHECK_END_MEMST:  MOP_IN(OP_NULL_CHECK_END_MEMST);",
          "2368:       {",
          "2374: #ifdef ONIG_DEBUG_MATCH",
          "2377: #endif",
          "2381:       }",
          "2382:       MOP_OUT;",
          "2383:       continue;",
          "",
          "[Removed Lines]",
          "2369:  int isnull;",
          "2372:  STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);",
          "2373:  if (isnull) {",
          "2375:    fprintf(stderr, \"NULL_CHECK_END_MEMST: skip  id:%d, s:%d\\n\",",
          "2376:     (int )mem, (int )s);",
          "2378:    if (isnull == -1) goto fail;",
          "2379:    goto  null_check_found;",
          "2380:  }",
          "",
          "[Added Lines]",
          "2368:         int isnull;",
          "2371:         STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);",
          "2372:         if (isnull) {",
          "2374:           fprintf(stderr, \"NULL_CHECK_END_MEMST: skip  id:%d, s:%d\\n\",",
          "2375:                   (int )mem, (int )s);",
          "2377:           if (isnull == -1) goto fail;",
          "2378:           goto  null_check_found;",
          "2379:         }",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2388:     case OP_NULL_CHECK_END_MEMST_PUSH:",
          "2389:       MOP_IN(OP_NULL_CHECK_END_MEMST_PUSH);",
          "2390:       {",
          "2394: #ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT",
          "2396: #else",
          "2398: #endif",
          "2400: #ifdef ONIG_DEBUG_MATCH",
          "2403: #endif",
          "2410:       }",
          "2411:       MOP_OUT;",
          "2412:       continue;",
          "",
          "[Removed Lines]",
          "2391:  int isnull;",
          "2395:  STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);",
          "2397:  STACK_NULL_CHECK_REC(isnull, mem, s);",
          "2399:  if (isnull) {",
          "2401:    fprintf(stderr, \"NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\\n\",",
          "2402:     (int )mem, (int )s);",
          "2404:    if (isnull == -1) goto fail;",
          "2405:    goto  null_check_found;",
          "2406:  }",
          "2407:  else {",
          "2408:    STACK_PUSH_NULL_CHECK_END(mem);",
          "2409:  }",
          "",
          "[Added Lines]",
          "2390:         int isnull;",
          "2394:         STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);",
          "2396:         STACK_NULL_CHECK_REC(isnull, mem, s);",
          "2398:         if (isnull) {",
          "2400:           fprintf(stderr, \"NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\\n\",",
          "2401:                   (int )mem, (int )s);",
          "2403:           if (isnull == -1) goto fail;",
          "2404:           goto  null_check_found;",
          "2405:         }",
          "2406:         else {",
          "2407:           STACK_PUSH_NULL_CHECK_END(mem);",
          "2408:         }",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2445:       GET_RELADDR_INC(addr, p);",
          "2446:       STATE_CHECK_VAL(scv, mem);",
          "2447:       if (scv) {",
          "2449:       }",
          "2450:       else {",
          "2452:       }",
          "2453:       MOP_OUT;",
          "2454:       continue;",
          "",
          "[Removed Lines]",
          "2448:  p += addr;",
          "2451:  STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);",
          "",
          "[Added Lines]",
          "2447:         p += addr;",
          "2450:         STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2474:     case OP_PUSH_OR_JUMP_EXACT1:  MOP_IN(OP_PUSH_OR_JUMP_EXACT1);",
          "2475:       GET_RELADDR_INC(addr, p);",
          "2476:       if (*p == *s && DATA_ENSURE_CHECK1) {",
          "2481:       }",
          "2482:       p += (addr + 1);",
          "2483:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "2477:  p++;",
          "2478:  STACK_PUSH_ALT(p + addr, s, sprev);",
          "2479:  MOP_OUT;",
          "2480:  continue;",
          "",
          "[Added Lines]",
          "2476:         p++;",
          "2477:         STACK_PUSH_ALT(p + addr, s, sprev);",
          "2478:         MOP_OUT;",
          "2479:         continue;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2487:     case OP_PUSH_IF_PEEK_NEXT:  MOP_IN(OP_PUSH_IF_PEEK_NEXT);",
          "2488:       GET_RELADDR_INC(addr, p);",
          "2489:       if (*p == *s) {",
          "2494:       }",
          "2495:       p++;",
          "2496:       MOP_OUT;",
          "",
          "[Removed Lines]",
          "2490:  p++;",
          "2491:  STACK_PUSH_ALT(p + addr, s, sprev);",
          "2492:  MOP_OUT;",
          "2493:  continue;",
          "",
          "[Added Lines]",
          "2489:         p++;",
          "2490:         STACK_PUSH_ALT(p + addr, s, sprev);",
          "2491:         MOP_OUT;",
          "2492:         continue;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2500:     case OP_REPEAT:  MOP_IN(OP_REPEAT);",
          "2501:       {",
          "2512:       }",
          "2513:       MOP_OUT;",
          "2514:       continue;",
          "",
          "[Removed Lines]",
          "2503:  GET_RELADDR_INC(addr, p);",
          "2505:  STACK_ENSURE(1);",
          "2506:  repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "2507:  STACK_PUSH_REPEAT(mem, p);",
          "2509:  if (reg->repeat_range[mem].lower == 0) {",
          "2510:    STACK_PUSH_ALT(p + addr, s, sprev);",
          "2511:  }",
          "",
          "[Added Lines]",
          "2502:         GET_RELADDR_INC(addr, p);",
          "2504:         STACK_ENSURE(1);",
          "2505:         repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "2506:         STACK_PUSH_REPEAT(mem, p);",
          "2508:         if (reg->repeat_range[mem].lower == 0) {",
          "2509:           STACK_PUSH_ALT(p + addr, s, sprev);",
          "2510:         }",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2517:     case OP_REPEAT_NG:  MOP_IN(OP_REPEAT_NG);",
          "2518:       {",
          "2530:       }",
          "2531:       MOP_OUT;",
          "2532:       continue;",
          "",
          "[Removed Lines]",
          "2520:  GET_RELADDR_INC(addr, p);",
          "2522:  STACK_ENSURE(1);",
          "2523:  repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "2524:  STACK_PUSH_REPEAT(mem, p);",
          "2526:  if (reg->repeat_range[mem].lower == 0) {",
          "2527:    STACK_PUSH_ALT(p, s, sprev);",
          "2528:    p += addr;",
          "2529:  }",
          "",
          "[Added Lines]",
          "2519:         GET_RELADDR_INC(addr, p);",
          "2521:         STACK_ENSURE(1);",
          "2522:         repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "2523:         STACK_PUSH_REPEAT(mem, p);",
          "2525:         if (reg->repeat_range[mem].lower == 0) {",
          "2526:           STACK_PUSH_ALT(p, s, sprev);",
          "2527:           p += addr;",
          "2528:         }",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2605:     case OP_POP_POS:  MOP_IN(OP_POP_POS);",
          "2606:       {",
          "2610:       }",
          "2611:       MOP_OUT;",
          "2612:       continue;",
          "",
          "[Removed Lines]",
          "2607:  STACK_POS_END(stkp);",
          "2608:  s     = stkp->u.state.pstr;",
          "2609:  sprev = stkp->u.state.pstr_prev;",
          "",
          "[Added Lines]",
          "2606:         STACK_POS_END(stkp);",
          "2607:         s     = stkp->u.state.pstr;",
          "2608:         sprev = stkp->u.state.pstr_prev;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "2650:       GET_LENGTH_INC(tlen, p);",
          "2651:       q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);",
          "2652:       if (IS_NULL(q)) {",
          "2657:       }",
          "2658:       else {",
          "2662:       }",
          "2663:       MOP_OUT;",
          "2664:       continue;",
          "",
          "[Removed Lines]",
          "2655:  p += addr;",
          "2659:  STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);",
          "2660:  s = q;",
          "2661:  sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);",
          "",
          "[Added Lines]",
          "2654:         p += addr;",
          "2658:         STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);",
          "2659:         s = q;",
          "2660:         sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2755:       p = s + 1;",
          "2756:       t = target + 1;",
          "2757:       while (t < target_end) {",
          "2761:       }",
          "2762:       if (t == target_end)",
          "2764:     }",
          "2765:     s += enclen(enc, s);",
          "2766:   }",
          "",
          "[Removed Lines]",
          "2758:  if (*t != *p++)",
          "2759:    break;",
          "2760:  t++;",
          "2763:  return s;",
          "",
          "[Added Lines]",
          "2757:         if (*t != *p++)",
          "2758:           break;",
          "2759:         t++;",
          "2762:         return s;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2832:       p = s + 1;",
          "2833:       t = target + 1;",
          "2834:       while (t < target_end) {",
          "2838:       }",
          "2839:       if (t == target_end)",
          "2841:     }",
          "2842:     s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);",
          "2843:   }",
          "",
          "[Removed Lines]",
          "2835:  if (*t != *p++)",
          "2836:    break;",
          "2837:  t++;",
          "2840:  return s;",
          "",
          "[Added Lines]",
          "2834:         if (*t != *p++)",
          "2835:           break;",
          "2836:         t++;",
          "2839:         return s;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2898:       p = se = s + tlen1;",
          "2899:       t = tail;",
          "2900:       while (*p == *t) {",
          "2903:       }",
          "2904:       skip = reg->map[*se];",
          "2905:       t = s;",
          "",
          "[Removed Lines]",
          "2901:  if (t == target) return (UChar* )s;",
          "2902:  p--; t--;",
          "",
          "[Added Lines]",
          "2900:         if (t == target) return (UChar* )s;",
          "2901:         p--; t--;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2913:       p = se = s + tlen1;",
          "2914:       t = tail;",
          "2915:       while (*p == *t) {",
          "2918:       }",
          "2919:       skip = reg->int_map[*se];",
          "2920:       t = s;",
          "",
          "[Removed Lines]",
          "2916:  if (t == target) return (UChar* )s;",
          "2917:  p--; t--;",
          "",
          "[Added Lines]",
          "2915:         if (t == target) return (UChar* )s;",
          "2916:         p--; t--;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2945:       p = s;",
          "2946:       t = tail;",
          "2947:       while (*p == *t) {",
          "2950:       }",
          "2951:       s += reg->map[*s];",
          "2952:     }",
          "",
          "[Removed Lines]",
          "2948:  if (t == target) return (UChar* )p;",
          "2949:  p--; t--;",
          "",
          "[Added Lines]",
          "2947:         if (t == target) return (UChar* )p;",
          "2948:         p--; t--;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2956:       p = s;",
          "2957:       t = tail;",
          "2958:       while (*p == *t) {",
          "2961:       }",
          "2962:       s += reg->int_map[*s];",
          "2963:     }",
          "",
          "[Removed Lines]",
          "2959:  if (t == target) return (UChar* )p;",
          "2960:  p--; t--;",
          "",
          "[Added Lines]",
          "2958:         if (t == target) return (UChar* )p;",
          "2959:         p--; t--;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3145:       switch (reg->sub_anchor) {",
          "3146:       case ANCHOR_BEGIN_LINE:",
          "3155:       case ANCHOR_END_LINE:",
          "3157: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "3162: #endif",
          "3165: #ifdef USE_CRNL_AS_LINE_TERMINATOR",
          "3167: #endif",
          "3171:       }",
          "3172:     }",
          "3174:     if (reg->dmax == 0) {",
          "3176:       if (low_prev) {",
          "3182:       }",
          "3183:     }",
          "3184:     else {",
          "3185:       if (reg->dmax != ONIG_INFINITE_DISTANCE) {",
          "3199:       }",
          "3200:     }",
          "",
          "[Removed Lines]",
          "3147:  if (!ON_STR_BEGIN(p)) {",
          "3148:    prev = onigenc_get_prev_char_head(reg->enc,",
          "3149:          (pprev ? pprev : str), p);",
          "3150:    if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))",
          "3151:      goto retry_gate;",
          "3152:  }",
          "3153:  break;",
          "3156:  if (ON_STR_END(p)) {",
          "3158:    prev = (UChar* )onigenc_get_prev_char_head(reg->enc,",
          "3159:          (pprev ? pprev : str), p);",
          "3160:    if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))",
          "3161:      goto retry_gate;",
          "3163:  }",
          "3164:  else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)",
          "3166:               && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)",
          "3168:                 )",
          "3169:    goto retry_gate;",
          "3170:  break;",
          "3177:  if (*low > s)",
          "3179:  else",
          "3181:        (pprev ? pprev : str), p);",
          "3187:  if (*low > s) {",
          "3190:    if (low_prev && IS_NULL(*low_prev))",
          "3192:          (pprev ? pprev : s), *low);",
          "3193:  }",
          "3194:  else {",
          "3195:    if (low_prev)",
          "3197:             (pprev ? pprev : str), *low);",
          "3198:  }",
          "",
          "[Added Lines]",
          "3146:         if (!ON_STR_BEGIN(p)) {",
          "3147:           prev = onigenc_get_prev_char_head(reg->enc,",
          "3148:                                             (pprev ? pprev : str), p);",
          "3149:           if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))",
          "3150:             goto retry_gate;",
          "3151:         }",
          "3152:         break;",
          "3155:         if (ON_STR_END(p)) {",
          "3157:           prev = (UChar* )onigenc_get_prev_char_head(reg->enc,",
          "3158:                                                      (pprev ? pprev : str), p);",
          "3159:           if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))",
          "3160:             goto retry_gate;",
          "3162:         }",
          "3163:         else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)",
          "3165:                  && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)",
          "3167:                  )",
          "3168:           goto retry_gate;",
          "3169:         break;",
          "3176:         if (*low > s)",
          "3178:         else",
          "3180:                                                  (pprev ? pprev : str), p);",
          "3186:         if (*low > s) {",
          "3189:           if (low_prev && IS_NULL(*low_prev))",
          "3191:                                                    (pprev ? pprev : s), *low);",
          "3192:         }",
          "3193:         else {",
          "3194:           if (low_prev)",
          "3196:                                                    (pprev ? pprev : str), *low);",
          "3197:         }",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3246:       int r;",
          "3248:       if (s - range < BM_BACKWARD_SEARCH_LENGTH_THRESHOLD)",
          "3251:       r = set_bm_backward_skip(reg->exact, reg->exact_end, reg->enc,",
          "3253:       if (r) return r;",
          "3254:     }",
          "3255:     p = bm_search_backward(reg, reg->exact, reg->exact_end, range, adjrange,",
          "3257: #else",
          "3258:     goto exact_method;",
          "3259: #endif",
          "",
          "[Removed Lines]",
          "3249:  goto exact_method;",
          "3252:           &(reg->int_map_backward));",
          "3256:       end, p);",
          "",
          "[Added Lines]",
          "3248:         goto exact_method;",
          "3251:                                &(reg->int_map_backward));",
          "3255:                            end, p);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3271:       switch (reg->sub_anchor) {",
          "3272:       case ANCHOR_BEGIN_LINE:",
          "3282:       case ANCHOR_END_LINE:",
          "3284: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "3294: #ifdef USE_CRNL_AS_LINE_TERMINATOR",
          "3296: #endif",
          "3303:       }",
          "3304:     }",
          "",
          "[Removed Lines]",
          "3273:  if (!ON_STR_BEGIN(p)) {",
          "3274:    prev = onigenc_get_prev_char_head(reg->enc, str, p);",
          "3275:    if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {",
          "3276:      p = prev;",
          "3277:      goto retry;",
          "3278:    }",
          "3279:  }",
          "3280:  break;",
          "3283:  if (ON_STR_END(p)) {",
          "3285:    prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);",
          "3286:    if (IS_NULL(prev)) goto fail;",
          "3287:    if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {",
          "3288:      p = prev;",
          "3289:      goto retry;",
          "3290:    }",
          "3291: #endif",
          "3292:  }",
          "3293:  else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)",
          "3295:               && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)",
          "3297:                 ) {",
          "3298:    p = onigenc_get_prev_char_head(reg->enc, adjrange, p);",
          "3299:    if (IS_NULL(p)) goto fail;",
          "3300:    goto retry;",
          "3301:  }",
          "3302:  break;",
          "",
          "[Added Lines]",
          "3272:         if (!ON_STR_BEGIN(p)) {",
          "3273:           prev = onigenc_get_prev_char_head(reg->enc, str, p);",
          "3274:           if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {",
          "3275:             p = prev;",
          "3276:             goto retry;",
          "3277:           }",
          "3278:         }",
          "3279:         break;",
          "3282:         if (ON_STR_END(p)) {",
          "3284:           prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);",
          "3285:           if (IS_NULL(prev)) goto fail;",
          "3286:           if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {",
          "3287:             p = prev;",
          "3288:             goto retry;",
          "3289:           }",
          "3290: #endif",
          "3291:         }",
          "3292:         else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)",
          "3294:                  && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)",
          "3296:                  ) {",
          "3297:           p = onigenc_get_prev_char_head(reg->enc, adjrange, p);",
          "3298:           if (IS_NULL(p)) goto fail;",
          "3299:           goto retry;",
          "3300:         }",
          "3301:         break;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3411:     begin_position:",
          "3412:       if (range > start)",
          "3414:       else",
          "3416:     }",
          "3417:     else if (reg->anchor & ANCHOR_BEGIN_BUF) {",
          "3419:       if (range > start) {",
          "3422:       }",
          "3423:       else {",
          "3430:       }",
          "3431:     }",
          "3432:     else if (reg->anchor & ANCHOR_END_BUF) {",
          "",
          "[Removed Lines]",
          "3413:  range = start + 1;",
          "3415:  range = start;",
          "3420:  if (start != str) goto mismatch_no_msa;",
          "3421:  range = str + 1;",
          "3424:  if (range <= str) {",
          "3425:    start = str;",
          "3426:    range = str;",
          "3427:  }",
          "3428:  else",
          "3429:    goto mismatch_no_msa;",
          "",
          "[Added Lines]",
          "3412:         range = start + 1;",
          "3414:         range = start;",
          "3419:         if (start != str) goto mismatch_no_msa;",
          "3420:         range = str + 1;",
          "3423:         if (range <= str) {",
          "3424:           start = str;",
          "3425:           range = str;",
          "3426:         }",
          "3427:         else",
          "3428:           goto mismatch_no_msa;",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3437:  goto mismatch_no_msa;",
          "3439:       if (range > start) {",
          "3453:       }",
          "3454:       else {",
          "3463:       }",
          "3464:     }",
          "3465:     else if (reg->anchor & ANCHOR_SEMI_END_BUF) {",
          "",
          "[Removed Lines]",
          "3440:  if ((OnigDistance )(min_semi_end - start) > reg->anchor_dmax) {",
          "3441:    start = min_semi_end - reg->anchor_dmax;",
          "3442:    if (start < end)",
          "3443:      start = onigenc_get_right_adjust_char_head(reg->enc, str, start);",
          "3445:      start = onigenc_get_prev_char_head(reg->enc, str, end);",
          "3446:    }",
          "3447:  }",
          "3448:  if ((OnigDistance )(max_semi_end - (range - 1)) < reg->anchor_dmin) {",
          "3449:    range = max_semi_end - reg->anchor_dmin + 1;",
          "3450:  }",
          "3452:  if (start >= range) goto mismatch_no_msa;",
          "3455:  if ((OnigDistance )(min_semi_end - range) > reg->anchor_dmax) {",
          "3456:    range = min_semi_end - reg->anchor_dmax;",
          "3457:  }",
          "3458:  if ((OnigDistance )(max_semi_end - start) < reg->anchor_dmin) {",
          "3459:    start = max_semi_end - reg->anchor_dmin;",
          "3460:    start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start);",
          "3461:  }",
          "3462:  if (range > start) goto mismatch_no_msa;",
          "",
          "[Added Lines]",
          "3439:         if ((OnigDistance )(min_semi_end - start) > reg->anchor_dmax) {",
          "3440:           start = min_semi_end - reg->anchor_dmax;",
          "3441:           if (start < end)",
          "3442:             start = onigenc_get_right_adjust_char_head(reg->enc, str, start);",
          "3444:             start = onigenc_get_prev_char_head(reg->enc, str, end);",
          "3445:           }",
          "3446:         }",
          "3447:         if ((OnigDistance )(max_semi_end - (range - 1)) < reg->anchor_dmin) {",
          "3448:           range = max_semi_end - reg->anchor_dmin + 1;",
          "3449:         }",
          "3451:         if (start >= range) goto mismatch_no_msa;",
          "3454:         if ((OnigDistance )(min_semi_end - range) > reg->anchor_dmax) {",
          "3455:           range = min_semi_end - reg->anchor_dmax;",
          "3456:         }",
          "3457:         if ((OnigDistance )(max_semi_end - start) < reg->anchor_dmin) {",
          "3458:           start = max_semi_end - reg->anchor_dmin;",
          "3459:           start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start);",
          "3460:         }",
          "3461:         if (range > start) goto mismatch_no_msa;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3468:       max_semi_end = (UChar* )end;",
          "3469:       if (ONIGENC_IS_MBC_NEWLINE(reg->enc, pre_end, end)) {",
          "3472: #ifdef USE_CRNL_AS_LINE_TERMINATOR",
          "3478: #endif",
          "3482:       }",
          "3483:       else {",
          "3486:       }",
          "3487:     }",
          "3488:     else if ((reg->anchor & ANCHOR_ANYCHAR_STAR_ML)) {",
          "",
          "[Removed Lines]",
          "3470:  min_semi_end = pre_end;",
          "3473:  pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, 1);",
          "3474:  if (IS_NOT_NULL(pre_end) &&",
          "3475:      ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {",
          "3476:    min_semi_end = pre_end;",
          "3477:  }",
          "3479:  if (min_semi_end > str && start <= min_semi_end) {",
          "3480:    goto end_buf;",
          "3481:  }",
          "3484:  min_semi_end = (UChar* )end;",
          "3485:  goto end_buf;",
          "",
          "[Added Lines]",
          "3469:         min_semi_end = pre_end;",
          "3472:         pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, 1);",
          "3473:         if (IS_NOT_NULL(pre_end) &&",
          "3474:             ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {",
          "3475:           min_semi_end = pre_end;",
          "3476:         }",
          "3478:         if (min_semi_end > str && start <= min_semi_end) {",
          "3479:           goto end_buf;",
          "3480:         }",
          "3483:         min_semi_end = (UChar* )end;",
          "3484:         goto end_buf;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3538:       sch_range = (UChar* )range;",
          "3539:       if (reg->dmax != 0) {",
          "3546:       }",
          "3548:       if ((end - start) < reg->threshold_len)",
          "3549:         goto mismatch;",
          "3551:       if (reg->dmax != ONIG_INFINITE_DISTANCE) {",
          "3566:       }",
          "3571:         if ((reg->anchor & ANCHOR_ANYCHAR_STAR) != 0) {",
          "3572:           do {",
          "",
          "[Removed Lines]",
          "3540:  if (reg->dmax == ONIG_INFINITE_DISTANCE)",
          "3541:    sch_range = (UChar* )end;",
          "3542:  else {",
          "3543:    sch_range += reg->dmax;",
          "3544:    if (sch_range > end) sch_range = (UChar* )end;",
          "3545:  }",
          "3552:  do {",
          "3553:    if (! forward_search_range(reg, str, end, s, sch_range,",
          "3554:          &low, &high, &low_prev)) goto mismatch;",
          "3555:    if (s < low) {",
          "3556:      s    = low;",
          "3557:      prev = low_prev;",
          "3558:    }",
          "3559:    while (s <= high) {",
          "3560:      MATCH_AND_RETURN_CHECK(orig_range);",
          "3561:      prev = s;",
          "3562:      s += enclen(reg->enc, s);",
          "3563:    }",
          "3564:  } while (s < range);",
          "3565:  goto mismatch;",
          "3568:  if (! forward_search_range(reg, str, end, s, sch_range,",
          "3569:        &low, &high, (UChar** )NULL)) goto mismatch;",
          "",
          "[Added Lines]",
          "3539:         if (reg->dmax == ONIG_INFINITE_DISTANCE)",
          "3540:           sch_range = (UChar* )end;",
          "3541:         else {",
          "3542:           sch_range += reg->dmax;",
          "3543:           if (sch_range > end) sch_range = (UChar* )end;",
          "3544:         }",
          "3551:         do {",
          "3552:           if (! forward_search_range(reg, str, end, s, sch_range,",
          "3553:                                      &low, &high, &low_prev)) goto mismatch;",
          "3554:           if (s < low) {",
          "3555:             s    = low;",
          "3556:             prev = low_prev;",
          "3557:           }",
          "3558:           while (s <= high) {",
          "3559:             MATCH_AND_RETURN_CHECK(orig_range);",
          "3560:             prev = s;",
          "3561:             s += enclen(reg->enc, s);",
          "3562:           }",
          "3563:         } while (s < range);",
          "3564:         goto mismatch;",
          "3567:         if (! forward_search_range(reg, str, end, s, sch_range,",
          "3568:                                    &low, &high, (UChar** )NULL)) goto mismatch;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3604:       UChar *low, *high, *adjrange, *sch_start;",
          "3606:       if (range < end)",
          "3608:       else",
          "3611:       if (reg->dmax != ONIG_INFINITE_DISTANCE &&",
          "3630:       }",
          "3648:       }",
          "3649:     }",
          "",
          "[Removed Lines]",
          "3607:  adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range);",
          "3609:  adjrange = (UChar* )end;",
          "3612:    (end - range) >= reg->threshold_len) {",
          "3613:  do {",
          "3614:    sch_start = s + reg->dmax;",
          "3615:    if (sch_start > end) sch_start = (UChar* )end;",
          "3616:    if (backward_search_range(reg, str, end, sch_start, range, adjrange,",
          "3617:         &low, &high) <= 0)",
          "3618:      goto mismatch;",
          "3620:    if (s > high)",
          "3621:      s = high;",
          "3623:    while (s >= low) {",
          "3624:      prev = onigenc_get_prev_char_head(reg->enc, str, s);",
          "3625:      MATCH_AND_RETURN_CHECK(orig_start);",
          "3626:      s = prev;",
          "3627:    }",
          "3628:  } while (s >= range);",
          "3629:  goto mismatch;",
          "3632:  if ((end - range) < reg->threshold_len) goto mismatch;",
          "3634:  sch_start = s;",
          "3635:  if (reg->dmax != 0) {",
          "3636:    if (reg->dmax == ONIG_INFINITE_DISTANCE)",
          "3637:      sch_start = (UChar* )end;",
          "3638:    else {",
          "3639:      sch_start += reg->dmax;",
          "3640:      if (sch_start > end) sch_start = (UChar* )end;",
          "3641:      else",
          "3642:        sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,",
          "3643:           start, sch_start);",
          "3644:    }",
          "3645:  }",
          "3646:  if (backward_search_range(reg, str, end, sch_start, range, adjrange,",
          "3647:       &low, &high) <= 0) goto mismatch;",
          "",
          "[Added Lines]",
          "3606:         adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range);",
          "3608:         adjrange = (UChar* )end;",
          "3611:           (end - range) >= reg->threshold_len) {",
          "3612:         do {",
          "3613:           sch_start = s + reg->dmax;",
          "3614:           if (sch_start > end) sch_start = (UChar* )end;",
          "3615:           if (backward_search_range(reg, str, end, sch_start, range, adjrange,",
          "3616:                                     &low, &high) <= 0)",
          "3617:             goto mismatch;",
          "3619:           if (s > high)",
          "3620:             s = high;",
          "3622:           while (s >= low) {",
          "3623:             prev = onigenc_get_prev_char_head(reg->enc, str, s);",
          "3624:             MATCH_AND_RETURN_CHECK(orig_start);",
          "3625:             s = prev;",
          "3626:           }",
          "3627:         } while (s >= range);",
          "3628:         goto mismatch;",
          "3631:         if ((end - range) < reg->threshold_len) goto mismatch;",
          "3633:         sch_start = s;",
          "3634:         if (reg->dmax != 0) {",
          "3635:           if (reg->dmax == ONIG_INFINITE_DISTANCE)",
          "3636:             sch_start = (UChar* )end;",
          "3637:           else {",
          "3638:             sch_start += reg->dmax;",
          "3639:             if (sch_start > end) sch_start = (UChar* )end;",
          "3640:             else",
          "3641:               sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,",
          "3642:                                                         start, sch_start);",
          "3643:           }",
          "3644:         }",
          "3645:         if (backward_search_range(reg, str, end, sch_start, range, adjrange,",
          "3646:                                   &low, &high) <= 0) goto mismatch;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
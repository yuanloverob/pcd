{
  "cve_id": "CVE-2012-2330",
  "cve_desc": "The Update method in src/node_http_parser.cc in Node.js before 0.6.17 and 0.7 before 0.7.8 does not properly check the length of a string, which allows remote attackers to obtain sensitive information (request header contents) and possibly spoof HTTP headers via a zero length string.",
  "repo": "joyent/node",
  "patch_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
  "patch_info": {
    "commit_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
    "repo": "joyent/node",
    "commit_url": "https://github.com/joyent/node/commit/c9a231d",
    "files": [
      "src/node_http_parser.cc"
    ],
    "message": "typo in node_http_parser",
    "before_after_code_files": [
      "src/node_http_parser.cc||src/node_http_parser.cc"
    ]
  },
  "patch_diff": {
    "src/node_http_parser.cc||src/node_http_parser.cc": [
      "File: src/node_http_parser.cc -> src/node_http_parser.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:   void Update(const char* str, size_t size) {",
      "192:     if (str_ == NULL)",
      "193:       str_ = str;",
      "197:       char* s = new char[size_ + size];",
      "",
      "[Removed Lines]",
      "194:     else if (on_heap_ || str_ + size != str) {",
      "",
      "[Added Lines]",
      "194:     else if (on_heap_ || str_ + size_ != str) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b788c5e77b564183826a4ccb69ec9a43a758a54a",
      "candidate_info": {
        "commit_hash": "b788c5e77b564183826a4ccb69ec9a43a758a54a",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/b788c5e77b564183826a4ccb69ec9a43a758a54a",
        "files": [
          "deps/uv/include/uv-private/uv-darwin.h",
          "deps/uv/include/uv-private/uv-unix.h",
          "deps/uv/include/uv.h",
          "deps/uv/src/unix/fsevents.c",
          "deps/uv/src/unix/kqueue.c",
          "deps/uv/src/unix/linux/inotify.c",
          "deps/uv/src/unix/pipe.c",
          "deps/uv/src/unix/stream.c",
          "deps/uv/src/unix/sunos.c",
          "deps/uv/src/unix/tcp.c",
          "deps/uv/src/unix/udp.c",
          "deps/uv/src/win/fs-event.c",
          "deps/uv/src/win/pipe.c",
          "deps/uv/src/win/tcp.c",
          "deps/uv/src/win/udp.c",
          "deps/uv/test/benchmark-list.h",
          "deps/uv/test/benchmark-multi-accept.c",
          "deps/uv/test/dns-server.c",
          "deps/uv/test/test-fs-event.c",
          "deps/uv/test/test-list.h",
          "deps/uv/test/test-tcp-open.c",
          "deps/uv/test/test-udp-open.c",
          "deps/uv/uv.gyp"
        ],
        "message": "uv: Upgrade to 778144f0\n\njoyent/libuv@778144f0b5bc14fe55d79854d0a67124ceaa4b22",
        "before_after_code_files": [
          "deps/uv/include/uv-private/uv-darwin.h||deps/uv/include/uv-private/uv-darwin.h",
          "deps/uv/include/uv-private/uv-unix.h||deps/uv/include/uv-private/uv-unix.h",
          "deps/uv/include/uv.h||deps/uv/include/uv.h",
          "deps/uv/src/unix/fsevents.c||deps/uv/src/unix/fsevents.c",
          "deps/uv/src/unix/kqueue.c||deps/uv/src/unix/kqueue.c",
          "deps/uv/src/unix/linux/inotify.c||deps/uv/src/unix/linux/inotify.c",
          "deps/uv/src/unix/pipe.c||deps/uv/src/unix/pipe.c",
          "deps/uv/src/unix/stream.c||deps/uv/src/unix/stream.c",
          "deps/uv/src/unix/sunos.c||deps/uv/src/unix/sunos.c",
          "deps/uv/src/unix/tcp.c||deps/uv/src/unix/tcp.c",
          "deps/uv/src/unix/udp.c||deps/uv/src/unix/udp.c",
          "deps/uv/src/win/fs-event.c||deps/uv/src/win/fs-event.c",
          "deps/uv/src/win/pipe.c||deps/uv/src/win/pipe.c",
          "deps/uv/src/win/tcp.c||deps/uv/src/win/tcp.c",
          "deps/uv/src/win/udp.c||deps/uv/src/win/udp.c",
          "deps/uv/test/benchmark-list.h||deps/uv/test/benchmark-list.h",
          "deps/uv/test/benchmark-multi-accept.c||deps/uv/test/benchmark-multi-accept.c",
          "deps/uv/test/dns-server.c||deps/uv/test/dns-server.c",
          "deps/uv/test/test-fs-event.c||deps/uv/test/test-fs-event.c",
          "deps/uv/test/test-list.h||deps/uv/test/test-list.h",
          "deps/uv/test/test-tcp-open.c||deps/uv/test/test-tcp-open.c",
          "deps/uv/test/test-udp-open.c||deps/uv/test/test-udp-open.c",
          "deps/uv/uv.gyp||deps/uv/uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/uv/include/uv-private/uv-darwin.h||deps/uv/include/uv-private/uv-darwin.h": [
          "File: deps/uv/include/uv-private/uv-darwin.h -> deps/uv/include/uv-private/uv-darwin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:   ev_io event_watcher;                                                        \\",
          "42:   int fflags;                                                                 \\",
          "43:   int fd;                                                                     \\",
          "44:   void* cf_eventstream;                                                       \\",
          "45:   uv_async_t* cf_cb;                                                          \\",
          "46:   ngx_queue_t cf_events;                                                      \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44:   char* realpath;                                                             \\",
          "45:   int realpath_len;                                                           \\",
          "46:   int cf_flags;                                                               \\",
          "",
          "---------------"
        ],
        "deps/uv/include/uv-private/uv-unix.h||deps/uv/include/uv-private/uv-unix.h": [
          "File: deps/uv/include/uv-private/uv-unix.h -> deps/uv/include/uv-private/uv-unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "185:   int fd;                                                                     \\",
          "186:   UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           \\",
          "191: #define UV_UDP_PRIVATE_FIELDS                                                 \\",
          "192:   int fd;                                                                     \\",
          "",
          "[Removed Lines]",
          "188: #define UV_TCP_PRIVATE_FIELDS                                                 \\",
          "189:   uv_idle_t* idle_handle;  /* for UV_TCP_SINGLE_ACCEPT handles */             \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "deps/uv/include/uv.h||deps/uv/include/uv.h": [
          "File: deps/uv/include/uv.h -> deps/uv/include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "600: UV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);",
          "603: UV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "605: UV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "704: UV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "714: UV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "945: UV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);",
          "",
          "[Removed Lines]",
          "943: UV_EXTERN void uv_pipe_open(uv_pipe_t*, uv_file file);",
          "",
          "[Added Lines]",
          "953: UV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1669: };",
          "",
          "[Removed Lines]",
          "1668:   UV_FS_EVENT_STAT = 2",
          "",
          "[Added Lines]",
          "1678:   UV_FS_EVENT_STAT = 2,",
          "1685:   UV_FS_EVENT_RECURSIVE = 3",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/fsevents.c||deps/uv/src/unix/fsevents.c": [
          "File: deps/uv/src/unix/fsevents.c -> deps/uv/src/unix/fsevents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:   handle = cb->data;",
          "68:   UV__FSEVENTS_WALK(handle, {",
          "70:       handle->cb(handle, event->path, event->events, 0);",
          "71:   })",
          "73:   if ((handle->flags & (UV_CLOSING | UV_CLOSED)) == 0 && handle->fd == -1)",
          "",
          "[Removed Lines]",
          "69:     if (handle->fd != -1)",
          "",
          "[Added Lines]",
          "69:     if (handle->fd != -1) {",
          "70: #ifdef MAC_OS_X_VERSION_10_7",
          "72: #else",
          "73:       handle->cb(handle, NULL, event->events, 0);",
          "75:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:   size_t i;",
          "85:   int len;",
          "86:   char** paths;",
          "87:   uv_fs_event_t* handle;",
          "88:   uv__fsevents_event_t* event;",
          "89:   ngx_queue_t add_list;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "92:   char* path;",
          "93:   char* pos;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "99:                          kFSEventStreamEventFlagEventIdsWrapped |",
          "100:                          kFSEventStreamEventFlagHistoryDone |",
          "101:                          kFSEventStreamEventFlagMount |",
          "103:       continue;",
          "104:     }",
          "108:     event = malloc(sizeof(*event) + len);",
          "109:     if (event == NULL)",
          "110:       break;",
          "114:     if (eventFlags[i] & kFSEventStreamEventFlagItemModified)",
          "115:       event->events = UV_CHANGE;",
          "",
          "[Removed Lines]",
          "102:                          kFSEventStreamEventFlagUnmount)) {",
          "107:     len = strlen(paths[i]);",
          "112:     memcpy(event->path, paths[i], len + 1);",
          "",
          "[Added Lines]",
          "109:                          kFSEventStreamEventFlagUnmount |",
          "110:                          kFSEventStreamEventFlagRootChanged)) {",
          "115:     path = paths[i];",
          "116:     len = strlen(path);",
          "119:     if (strstr(path, handle->realpath) == path) {",
          "120:       path += handle->realpath_len;",
          "121:       len -= handle->realpath_len;",
          "124:       if (*path != 0) {",
          "125:         path++;",
          "126:         len--;",
          "127:       }",
          "128:     }",
          "130: #ifdef MAC_OS_X_VERSION_10_7",
          "132:     if (len == 0)",
          "133:       continue;",
          "137:     pos = strchr(path, '/');",
          "138:     if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 &&",
          "139:         pos != NULL &&",
          "140:         pos != path + 1)",
          "141:       continue;",
          "143: #ifndef MAC_OS_X_VERSION_10_7",
          "144:     path = \"\";",
          "145:     len = 0;",
          "152:     memcpy(event->path, path, len + 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "153:   ctx.release = NULL;",
          "154:   ctx.copyDescription = NULL;",
          "157:   path = CFStringCreateWithCString(NULL,",
          "158:                                    handle->filename,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197:   handle->realpath = realpath(handle->filename, NULL);",
          "198:   if (handle->realpath != NULL)",
          "199:     handle->realpath_len = strlen(handle->realpath);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "221:   uv_mutex_destroy(&handle->cf_mutex);",
          "222:   uv_sem_destroy(&handle->cf_sem);",
          "224:   return 0;",
          "225: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "268:   free(handle->realpath);",
          "269:   handle->realpath = NULL;",
          "270:   handle->realpath_len = 0;",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/kqueue.c||deps/uv/src/unix/kqueue.c": [
          "File: deps/uv/src/unix/kqueue.c -> deps/uv/src/unix/kqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:   struct stat statbuf;",
          "100:   if ((fd = open(filename, O_RDONLY)) == -1) {",
          "101:     uv__set_sys_error(loop, errno);",
          "",
          "[Removed Lines]",
          "97:   assert(!flags);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112: #if defined(__APPLE__)",
          "114:   handle->cf_eventstream = NULL;",
          "116:   if (fstat(fd, &statbuf))",
          "117:     goto fallback;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112:   handle->realpath = NULL;",
          "113:   handle->realpath_len = 0;",
          "114:   handle->cf_flags = flags;",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/linux/inotify.c||deps/uv/src/unix/linux/inotify.c": [
          "File: deps/uv/src/unix/linux/inotify.c -> deps/uv/src/unix/linux/inotify.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "176:   int events;",
          "177:   int wd;",
          "182:   if (init_inotify(loop)) return -1;",
          "184:   events = UV__IN_ATTRIB",
          "",
          "[Removed Lines]",
          "180:   assert(!flags);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/pipe.c||deps/uv/src/unix/pipe.c": [
          "File: deps/uv/src/unix/pipe.c -> deps/uv/src/unix/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "156: }",
          "163: }",
          "",
          "[Removed Lines]",
          "159: void uv_pipe_open(uv_pipe_t* handle, uv_file fd) {",
          "160:   uv__stream_open((uv_stream_t*)handle,",
          "161:                   fd,",
          "162:                   UV_STREAM_READABLE | UV_STREAM_WRITABLE);",
          "",
          "[Added Lines]",
          "159: int uv_pipe_open(uv_pipe_t* handle, uv_file fd) {",
          "160:   return uv__stream_open((uv_stream_t*)handle,",
          "161:                          fd,",
          "162:                          UV_STREAM_READABLE | UV_STREAM_WRITABLE);",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/stream.c||deps/uv/src/unix/stream.c": [
          "File: deps/uv/src/unix/stream.c -> deps/uv/src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "386: }",
          "",
          "[Removed Lines]",
          "389: static void uv__next_accept(uv_idle_t* idle, int status) {",
          "390:   uv_stream_t* stream = idle->data;",
          "392:   uv_idle_stop(idle);",
          "394:   if (stream->accepted_fd == -1)",
          "395:     uv__io_start(stream->loop, &stream->read_watcher);",
          "396: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "497:     stream->accepted_fd = fd;",
          "498:     stream->connection_cb(stream, 0);",
          "503:       uv__io_stop(loop, &stream->read_watcher);",
          "505:     }",
          "534:   }",
          "535: }",
          "",
          "[Removed Lines]",
          "500:     if (stream->accepted_fd != -1 ||",
          "501:         (stream->type == UV_TCP && stream->flags == UV_TCP_SINGLE_ACCEPT)) {",
          "504:       break;",
          "506:   }",
          "508:   if (stream->fd != -1 &&",
          "509:       stream->accepted_fd == -1 &&",
          "510:       (stream->type == UV_TCP && stream->flags == UV_TCP_SINGLE_ACCEPT))",
          "511:   {",
          "532:     uv_tcp_t* tcp = (uv_tcp_t*) stream;",
          "533:     uv_idle_start(tcp->idle_handle, uv__next_accept);",
          "",
          "[Added Lines]",
          "490:     if (stream->accepted_fd != -1) {",
          "493:       return;",
          "496:     if (stream->type == UV_TCP && (stream->flags & UV_TCP_SINGLE_ACCEPT)) {",
          "498:       struct timespec timeout = { 0, 1 };",
          "499:       nanosleep(&timeout, NULL);",
          "500:     }",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/sunos.c||deps/uv/src/unix/sunos.c": [
          "File: deps/uv/src/unix/sunos.c -> deps/uv/src/unix/sunos.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "196:   int portfd;",
          "197:   int first_run = 0;",
          "201:   if (loop->fs_fd == -1) {",
          "202:     if ((portfd = port_create()) == -1) {",
          "203:       uv__set_sys_error(loop, errno);",
          "",
          "[Removed Lines]",
          "200:   assert(!flags);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/tcp.c||deps/uv/src/unix/tcp.c": [
          "File: deps/uv/src/unix/tcp.c -> deps/uv/src/unix/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* tcp) {",
          "32:   uv__stream_init(loop, (uv_stream_t*)tcp, UV_TCP);",
          "34:   return 0;",
          "35: }",
          "",
          "[Removed Lines]",
          "33:   tcp->idle_handle = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153: }",
          "156: int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,",
          "157:     int* namelen) {",
          "158:   socklen_t socklen;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "155: int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {",
          "156:   return uv__stream_open((uv_stream_t*)handle,",
          "157:                          sock,",
          "158:                          UV_STREAM_READABLE | UV_STREAM_WRITABLE);",
          "159: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "239:   }",
          "255:   if (maybe_new_socket(tcp, AF_INET, UV_STREAM_READABLE))",
          "256:     return -1;",
          "",
          "[Removed Lines]",
          "241:   if (!single_accept)",
          "242:     goto no_single_accept;",
          "244:   tcp->idle_handle = malloc(sizeof(*tcp->idle_handle));",
          "245:   if (tcp->idle_handle == NULL)",
          "246:     return uv__set_sys_error(tcp->loop, ENOMEM);",
          "248:   if (uv_idle_init(tcp->loop, tcp->idle_handle))",
          "249:     abort();",
          "250:   tcp->idle_handle->flags |= UV__HANDLE_INTERNAL;",
          "252:   tcp->flags |= UV_TCP_SINGLE_ACCEPT;",
          "254: no_single_accept:",
          "",
          "[Added Lines]",
          "247:   if (single_accept)",
          "248:     tcp->flags |= UV_TCP_SINGLE_ACCEPT;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "392: void uv__tcp_close(uv_tcp_t* handle) {",
          "396:   uv__stream_close((uv_stream_t*)handle);",
          "397: }",
          "",
          "[Removed Lines]",
          "393:   if (handle->idle_handle)",
          "394:     uv_close((uv_handle_t*)handle->idle_handle, (uv_close_cb)free);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/udp.c||deps/uv/src/unix/udp.c": [
          "File: deps/uv/src/unix/udp.c -> deps/uv/src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "316:     goto out;",
          "317:   }",
          "328:   }",
          "330:   yes = 1;",
          "331:   if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes) == -1) {",
          "332:     uv__set_sys_error(handle->loop, errno);",
          "",
          "[Removed Lines]",
          "320:   if (handle->fd != -1) {",
          "321:     uv__set_artificial_error(handle->loop, UV_EALREADY);",
          "322:     goto out;",
          "323:   }",
          "325:   if ((fd = uv__socket(domain, SOCK_DGRAM, 0)) == -1) {",
          "326:     uv__set_sys_error(handle->loop, errno);",
          "327:     goto out;",
          "",
          "[Added Lines]",
          "319:   if (handle->fd == -1) {",
          "320:     if ((fd = uv__socket(domain, SOCK_DGRAM, 0)) == -1) {",
          "321:       uv__set_sys_error(handle->loop, errno);",
          "322:       goto out;",
          "323:     }",
          "324:     handle->fd = fd;",
          "327:   fd = handle->fd;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "367:     goto out;",
          "368:   }",
          "371:   status = 0;",
          "373: out:",
          "377:   errno = saved_errno;",
          "378:   return status;",
          "",
          "[Removed Lines]",
          "370:   handle->fd = fd;",
          "374:   if (status)",
          "375:     close(fd);",
          "",
          "[Added Lines]",
          "371:   if (status) {",
          "372:     close(handle->fd);",
          "373:     handle->fd = -1;",
          "374:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "486: }",
          "489: int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr,",
          "490:   const char* interface_addr, uv_membership membership) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "488: int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {",
          "489:   int saved_errno;",
          "490:   int status;",
          "491:   int yes;",
          "493:   saved_errno = errno;",
          "494:   status = -1;",
          "497:   if (handle->fd != -1) {",
          "498:     uv__set_artificial_error(handle->loop, UV_EALREADY);",
          "499:     goto out;",
          "500:   }",
          "502:   yes = 1;",
          "503:   if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes) == -1) {",
          "504:     uv__set_sys_error(handle->loop, errno);",
          "505:     goto out;",
          "506:   }",
          "516: #ifdef SO_REUSEPORT",
          "517:   yes = 1;",
          "518:   if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof yes) == -1) {",
          "519:     uv__set_sys_error(handle->loop, errno);",
          "520:     goto out;",
          "521:   }",
          "522: #endif",
          "524:   handle->fd = sock;",
          "525:   status = 0;",
          "527: out:",
          "528:   errno = saved_errno;",
          "529:   return status;",
          "530: }",
          "",
          "---------------"
        ],
        "deps/uv/src/win/fs-event.c||deps/uv/src/win/fs-event.c": [
          "File: deps/uv/src/win/fs-event.c -> deps/uv/src/win/fs-event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:   WCHAR* dir = NULL, *dir_to_watch, *filenamew = NULL;",
          "139:   WCHAR short_path[MAX_PATH];",
          "144:   uv_fs_event_init_handle(loop, handle, filename, cb);",
          "",
          "[Removed Lines]",
          "142:   assert(!flags);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "deps/uv/src/win/pipe.c||deps/uv/src/win/pipe.c": [
          "File: deps/uv/src/win/pipe.c -> deps/uv/src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1634: }",
          "1638:   HANDLE os_handle = (HANDLE)_get_osfhandle(file);",
          "1640:   if (os_handle == INVALID_HANDLE_VALUE ||",
          "1641:       uv_set_pipe_handle(pipe->loop, pipe, os_handle, 0) == -1) {",
          "1643:   }",
          "1645:   uv_pipe_connection_init(pipe);",
          "",
          "[Removed Lines]",
          "1637: void uv_pipe_open(uv_pipe_t* pipe, uv_file file) {",
          "1642:     return;",
          "",
          "[Added Lines]",
          "1637: int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {",
          "1642:     uv__set_sys_error(pipe->loop, WSAEINVAL);",
          "1643:     return -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1651:     pipe->ipc_pid = uv_parent_pid();",
          "1652:     assert(pipe->ipc_pid != -1);",
          "1653:   }",
          "1654: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1655:   return 0;",
          "",
          "---------------"
        ],
        "deps/uv/src/win/tcp.c||deps/uv/src/win/tcp.c": [
          "File: deps/uv/src/win/tcp.c -> deps/uv/src/win/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1378:     uv_want_endgame(tcp->loop, (uv_handle_t*)tcp);",
          "1379:   }",
          "1380: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1383: int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {",
          "1385:   if (!SetHandleInformation((HANDLE) sock, HANDLE_FLAG_INHERIT, 0)) {",
          "1386:     uv__set_sys_error(handle->loop, GetLastError());",
          "1387:     return -1;",
          "1388:   }",
          "1390:   if (uv_tcp_set_socket(handle->loop, handle, sock, 0) == -1) {",
          "1391:     return -1;",
          "1392:   }",
          "1394:   return 0;",
          "1395: }",
          "",
          "---------------"
        ],
        "deps/uv/src/win/udp.c||deps/uv/src/win/udp.c": [
          "File: deps/uv/src/win/udp.c -> deps/uv/src/win/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "653: }",
          "656: #define SOCKOPT_SETTER(name, option4, option6, validate)                      \\",
          "657:   int uv_udp_set_##name(uv_udp_t* handle, int value) {                        \\",
          "658:     DWORD optval = (DWORD) value;                                             \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656: int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {",
          "657:   int r;",
          "658:   DWORD yes = 1;",
          "660:   if (uv_udp_set_socket(handle->loop, handle, sock) == -1) {",
          "661:     return -1;",
          "662:   }",
          "664:   r = setsockopt(handle->socket,",
          "665:                  SOL_SOCKET,",
          "666:                  SO_REUSEADDR,",
          "667:                  (char*) &yes,",
          "668:                  sizeof yes);",
          "669:   if (r == SOCKET_ERROR) {",
          "670:     uv__set_sys_error(handle->loop, WSAGetLastError());",
          "671:     return -1;",
          "672:   }",
          "674:   return 0;",
          "675: }",
          "",
          "---------------"
        ],
        "deps/uv/test/benchmark-list.h||deps/uv/test/benchmark-list.h": [
          "File: deps/uv/test/benchmark-list.h -> deps/uv/test/benchmark-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: BENCHMARK_DECLARE (pipe_pump100_client)",
          "34: BENCHMARK_DECLARE (pipe_pump1_client)",
          "37: BENCHMARK_DECLARE (udp_pummel_1v1)",
          "38: BENCHMARK_DECLARE (udp_pummel_1v10)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: BENCHMARK_DECLARE (tcp_multi_accept2)",
          "37: BENCHMARK_DECLARE (tcp_multi_accept4)",
          "38: BENCHMARK_DECLARE (tcp_multi_accept8)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112:   BENCHMARK_ENTRY  (pipe_pound_1000)",
          "113:   BENCHMARK_HELPER (pipe_pound_1000, pipe_echo_server)",
          "115:   BENCHMARK_ENTRY  (udp_pummel_1v1)",
          "116:   BENCHMARK_ENTRY  (udp_pummel_1v10)",
          "117:   BENCHMARK_ENTRY  (udp_pummel_1v100)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119:   BENCHMARK_ENTRY  (tcp_multi_accept2)",
          "120:   BENCHMARK_ENTRY  (tcp_multi_accept4)",
          "121:   BENCHMARK_ENTRY  (tcp_multi_accept8)",
          "",
          "---------------"
        ],
        "deps/uv/test/benchmark-multi-accept.c||deps/uv/test/benchmark-multi-accept.c": [
          "File: deps/uv/test/benchmark-multi-accept.c -> deps/uv/test/benchmark-multi-accept.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"task.h\"",
          "23: #include \"uv.h\"",
          "25: #define IPC_PIPE_NAME TEST_PIPENAME",
          "26: #define NUM_CONNECTS  (250 * 1000)",
          "28: union stream_handle {",
          "29:   uv_pipe_t pipe;",
          "30:   uv_tcp_t tcp;",
          "31: };",
          "36: typedef unsigned char handle_storage_t[sizeof(union stream_handle)];",
          "48: struct ipc_server_ctx {",
          "49:   handle_storage_t server_handle;",
          "50:   unsigned int num_connects;",
          "51:   uv_pipe_t ipc_pipe;",
          "52: };",
          "54: struct ipc_peer_ctx {",
          "55:   handle_storage_t peer_handle;",
          "56:   uv_write_t write_req;",
          "57: };",
          "59: struct ipc_client_ctx {",
          "60:   uv_connect_t connect_req;",
          "61:   uv_stream_t* server_handle;",
          "62:   uv_pipe_t ipc_pipe;",
          "63:   char scratch[16];",
          "64: };",
          "67: struct server_ctx {",
          "68:   handle_storage_t server_handle;",
          "69:   unsigned int num_connects;",
          "70:   uv_async_t async_handle;",
          "71:   uv_thread_t thread_id;",
          "72:   uv_sem_t semaphore;",
          "73: };",
          "75: struct client_ctx {",
          "76:   handle_storage_t client_handle;",
          "77:   unsigned int num_connects;",
          "78:   uv_connect_t connect_req;",
          "79:   uv_idle_t idle_handle;",
          "80: };",
          "82: static void ipc_connection_cb(uv_stream_t* ipc_pipe, int status);",
          "83: static void ipc_write_cb(uv_write_t* req, int status);",
          "84: static void ipc_close_cb(uv_handle_t* handle);",
          "85: static void ipc_connect_cb(uv_connect_t* req, int status);",
          "86: static void ipc_read2_cb(uv_pipe_t* ipc_pipe,",
          "87:                          ssize_t nread,",
          "88:                          uv_buf_t buf,",
          "89:                          uv_handle_type type);",
          "90: static uv_buf_t ipc_alloc_cb(uv_handle_t* handle, size_t suggested_size);",
          "92: static void sv_async_cb(uv_async_t* handle, int status);",
          "93: static void sv_connection_cb(uv_stream_t* server_handle, int status);",
          "94: static void sv_read_cb(uv_stream_t* handle, ssize_t nread, uv_buf_t buf);",
          "95: static uv_buf_t sv_alloc_cb(uv_handle_t* handle, size_t suggested_size);",
          "97: static void cl_connect_cb(uv_connect_t* req, int status);",
          "98: static void cl_idle_cb(uv_idle_t* handle, int status);",
          "99: static void cl_close_cb(uv_handle_t* handle);",
          "101: static struct sockaddr_in listen_addr;",
          "104: static void ipc_connection_cb(uv_stream_t* ipc_pipe, int status) {",
          "105:   struct ipc_server_ctx* sc;",
          "106:   struct ipc_peer_ctx* pc;",
          "107:   uv_loop_t* loop;",
          "108:   uv_buf_t buf;",
          "110:   loop = ipc_pipe->loop;",
          "111:   buf = uv_buf_init(\"PING\", 4);",
          "112:   sc = container_of(ipc_pipe, struct ipc_server_ctx, ipc_pipe);",
          "113:   pc = calloc(1, sizeof(*pc));",
          "114:   ASSERT(pc != NULL);",
          "116:   if (ipc_pipe->type == UV_TCP)",
          "117:     ASSERT(0 == uv_tcp_init(loop, (uv_tcp_t*) &pc->peer_handle));",
          "118:   else if (ipc_pipe->type == UV_NAMED_PIPE)",
          "119:     ASSERT(0 == uv_pipe_init(loop, (uv_pipe_t*) &pc->peer_handle, 1));",
          "120:   else",
          "121:     ASSERT(0);",
          "123:   ASSERT(0 == uv_accept(ipc_pipe, (uv_stream_t*) &pc->peer_handle));",
          "124:   ASSERT(0 == uv_write2(&pc->write_req,",
          "125:                         (uv_stream_t*) &pc->peer_handle,",
          "126:                         &buf,",
          "127:                         1,",
          "128:                         (uv_stream_t*) &sc->server_handle,",
          "129:                         ipc_write_cb));",
          "131:   if (--sc->num_connects == 0)",
          "132:     uv_close((uv_handle_t*) ipc_pipe, NULL);",
          "133: }",
          "136: static void ipc_write_cb(uv_write_t* req, int status) {",
          "137:   struct ipc_peer_ctx* ctx;",
          "138:   ctx = container_of(req, struct ipc_peer_ctx, write_req);",
          "139:   uv_close((uv_handle_t*) &ctx->peer_handle, ipc_close_cb);",
          "140: }",
          "143: static void ipc_close_cb(uv_handle_t* handle) {",
          "144:   struct ipc_peer_ctx* ctx;",
          "145:   ctx = container_of(handle, struct ipc_peer_ctx, peer_handle);",
          "146:   free(ctx);",
          "147: }",
          "150: static void ipc_connect_cb(uv_connect_t* req, int status) {",
          "151:   struct ipc_client_ctx* ctx;",
          "152:   ctx = container_of(req, struct ipc_client_ctx, connect_req);",
          "153:   ASSERT(0 == status);",
          "154:   ASSERT(0 == uv_read2_start((uv_stream_t*) &ctx->ipc_pipe,",
          "155:                              ipc_alloc_cb,",
          "156:                              ipc_read2_cb));",
          "157: }",
          "160: static uv_buf_t ipc_alloc_cb(uv_handle_t* handle, size_t suggested_size) {",
          "161:   struct ipc_client_ctx* ctx;",
          "162:   ctx = container_of(handle, struct ipc_client_ctx, ipc_pipe);",
          "163:   return uv_buf_init(ctx->scratch, sizeof(ctx->scratch));",
          "164: }",
          "167: static void ipc_read2_cb(uv_pipe_t* ipc_pipe,",
          "168:                          ssize_t nread,",
          "169:                          uv_buf_t buf,",
          "170:                          uv_handle_type type) {",
          "171:   struct ipc_client_ctx* ctx;",
          "172:   uv_loop_t* loop;",
          "174:   ctx = container_of(ipc_pipe, struct ipc_client_ctx, ipc_pipe);",
          "175:   loop = ipc_pipe->loop;",
          "177:   if (type == UV_TCP)",
          "178:     ASSERT(0 == uv_tcp_init(loop, (uv_tcp_t*) ctx->server_handle));",
          "179:   else if (type == UV_NAMED_PIPE)",
          "180:     ASSERT(0 == uv_pipe_init(loop, (uv_pipe_t*) ctx->server_handle, 0));",
          "181:   else",
          "182:     ASSERT(0);",
          "184:   ASSERT(0 == uv_accept((uv_stream_t*) &ctx->ipc_pipe, ctx->server_handle));",
          "185:   uv_close((uv_handle_t*) &ctx->ipc_pipe, NULL);",
          "186: }",
          "193: static void send_listen_handles(uv_handle_type type,",
          "194:                                 unsigned int num_servers,",
          "195:                                 struct server_ctx* servers) {",
          "196:   struct ipc_server_ctx ctx;",
          "197:   uv_loop_t* loop;",
          "198:   unsigned int i;",
          "200:   loop = uv_default_loop();",
          "201:   ctx.num_connects = num_servers;",
          "203:   if (type == UV_TCP) {",
          "204:     ASSERT(0 == uv_tcp_init(loop, (uv_tcp_t*) &ctx.server_handle));",
          "205:     ASSERT(0 == uv_tcp_bind((uv_tcp_t*) &ctx.server_handle, listen_addr));",
          "206:   }",
          "207:   else if (type == UV_NAMED_PIPE) {",
          "208:     ASSERT(0 == uv_pipe_init(loop, (uv_pipe_t*) &ctx.server_handle, 0));",
          "209:     ASSERT(0 == uv_pipe_bind((uv_pipe_t*) &ctx.server_handle, IPC_PIPE_NAME));",
          "210:   }",
          "211:   else",
          "212:     ASSERT(0);",
          "214:   ASSERT(0 == uv_pipe_init(loop, &ctx.ipc_pipe, 1));",
          "215:   ASSERT(0 == uv_pipe_bind(&ctx.ipc_pipe, IPC_PIPE_NAME));",
          "216:   ASSERT(0 == uv_listen((uv_stream_t*) &ctx.ipc_pipe, 128, ipc_connection_cb));",
          "218:   for (i = 0; i < num_servers; i++)",
          "219:     uv_sem_post(&servers[i].semaphore);",
          "221:   ASSERT(0 == uv_run(loop));",
          "222:   uv_close((uv_handle_t*) &ctx.server_handle, NULL);",
          "223:   ASSERT(0 == uv_run(loop));",
          "225:   for (i = 0; i < num_servers; i++)",
          "226:     uv_sem_wait(&servers[i].semaphore);",
          "227: }",
          "230: static void get_listen_handle(uv_loop_t* loop, uv_stream_t* server_handle) {",
          "231:   struct ipc_client_ctx ctx;",
          "233:   ctx.server_handle = server_handle;",
          "234:   ctx.server_handle->data = \"server handle\";",
          "236:   ASSERT(0 == uv_pipe_init(loop, &ctx.ipc_pipe, 1));",
          "237:   uv_pipe_connect(&ctx.connect_req,",
          "238:                   &ctx.ipc_pipe,",
          "239:                   IPC_PIPE_NAME,",
          "240:                   ipc_connect_cb);",
          "241:   ASSERT(0 == uv_run(loop));",
          "242: }",
          "245: static void server_cb(void *arg) {",
          "246:   struct server_ctx *ctx;",
          "247:   uv_loop_t* loop;",
          "249:   ctx = arg;",
          "250:   loop = uv_loop_new();",
          "251:   ASSERT(loop != NULL);",
          "253:   ASSERT(0 == uv_async_init(loop, &ctx->async_handle, sv_async_cb));",
          "254:   uv_unref((uv_handle_t*) &ctx->async_handle);",
          "257:   uv_sem_wait(&ctx->semaphore);",
          "258:   get_listen_handle(loop, (uv_stream_t*) &ctx->server_handle);",
          "259:   uv_sem_post(&ctx->semaphore);",
          "262:   ASSERT(0 == uv_listen((uv_stream_t*) &ctx->server_handle,",
          "263:                         128,",
          "264:                         sv_connection_cb));",
          "265:   ASSERT(0 == uv_run(loop));",
          "267:   uv_loop_delete(loop);",
          "268: }",
          "271: static void sv_async_cb(uv_async_t* handle, int status) {",
          "272:   struct server_ctx* ctx;",
          "273:   ctx = container_of(handle, struct server_ctx, async_handle);",
          "274:   uv_close((uv_handle_t*) &ctx->server_handle, NULL);",
          "275:   uv_close((uv_handle_t*) &ctx->async_handle, NULL);",
          "276: }",
          "279: static void sv_connection_cb(uv_stream_t* server_handle, int status) {",
          "280:   handle_storage_t* storage;",
          "281:   struct server_ctx* ctx;",
          "283:   ctx = container_of(server_handle, struct server_ctx, server_handle);",
          "284:   ASSERT(status == 0);",
          "286:   storage = malloc(sizeof(*storage));",
          "287:   ASSERT(storage != NULL);",
          "289:   if (server_handle->type == UV_TCP)",
          "290:     ASSERT(0 == uv_tcp_init(server_handle->loop, (uv_tcp_t*) storage));",
          "291:   else if (server_handle->type == UV_NAMED_PIPE)",
          "292:     ASSERT(0 == uv_pipe_init(server_handle->loop, (uv_pipe_t*) storage, 0));",
          "293:   else",
          "294:     ASSERT(0);",
          "296:   ASSERT(0 == uv_accept(server_handle, (uv_stream_t*) storage));",
          "297:   ASSERT(0 == uv_read_start((uv_stream_t*) storage, sv_alloc_cb, sv_read_cb));",
          "298:   ctx->num_connects++;",
          "299: }",
          "302: static uv_buf_t sv_alloc_cb(uv_handle_t* handle, size_t suggested_size) {",
          "303:   static char buf[32];",
          "304:   return uv_buf_init(buf, sizeof(buf));",
          "305: }",
          "308: static void sv_read_cb(uv_stream_t* handle, ssize_t nread, uv_buf_t buf) {",
          "309:   ASSERT(nread == -1);",
          "310:   ASSERT(uv_last_error(handle->loop).code == UV_EOF);",
          "311:   uv_close((uv_handle_t*) handle, (uv_close_cb) free);",
          "312: }",
          "315: static void cl_connect_cb(uv_connect_t* req, int status) {",
          "316:   struct client_ctx* ctx = container_of(req, struct client_ctx, connect_req);",
          "317:   uv_idle_start(&ctx->idle_handle, cl_idle_cb);",
          "318:   ASSERT(0 == status);",
          "319: }",
          "322: static void cl_idle_cb(uv_idle_t* handle, int status) {",
          "323:   struct client_ctx* ctx = container_of(handle, struct client_ctx, idle_handle);",
          "324:   uv_close((uv_handle_t*) &ctx->client_handle, cl_close_cb);",
          "325:   uv_idle_stop(&ctx->idle_handle);",
          "326: }",
          "329: static void cl_close_cb(uv_handle_t* handle) {",
          "330:   struct client_ctx* ctx;",
          "332:   ctx = container_of(handle, struct client_ctx, client_handle);",
          "334:   if (--ctx->num_connects == 0) {",
          "335:     uv_close((uv_handle_t*) &ctx->idle_handle, NULL);",
          "336:     return;",
          "337:   }",
          "339:   ASSERT(0 == uv_tcp_init(handle->loop, (uv_tcp_t*) &ctx->client_handle));",
          "340:   ASSERT(0 == uv_tcp_connect(&ctx->connect_req,",
          "341:                              (uv_tcp_t*) &ctx->client_handle,",
          "342:                              listen_addr,",
          "343:                              cl_connect_cb));",
          "344: }",
          "347: static int test_tcp(unsigned int num_servers, unsigned int num_clients) {",
          "348:   struct server_ctx* servers;",
          "349:   struct client_ctx* clients;",
          "350:   uv_loop_t* loop;",
          "351:   uv_tcp_t* handle;",
          "352:   unsigned int i;",
          "353:   double time;",
          "355:   listen_addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);",
          "356:   loop = uv_default_loop();",
          "358:   servers = calloc(num_servers, sizeof(servers[0]));",
          "359:   clients = calloc(num_clients, sizeof(clients[0]));",
          "360:   ASSERT(servers != NULL);",
          "361:   ASSERT(clients != NULL);",
          "367:   for (i = 0; i < num_servers; i++) {",
          "368:     struct server_ctx* ctx = servers + i;",
          "369:     ASSERT(0 == uv_sem_init(&ctx->semaphore, 0));",
          "370:     ASSERT(0 == uv_thread_create(&ctx->thread_id, server_cb, ctx));",
          "371:   }",
          "373:   send_listen_handles(UV_TCP, num_servers, servers);",
          "375:   for (i = 0; i < num_clients; i++) {",
          "376:     struct client_ctx* ctx = clients + i;",
          "377:     ctx->num_connects = NUM_CONNECTS / num_clients;",
          "378:     handle = (uv_tcp_t*) &ctx->client_handle;",
          "379:     handle->data = \"client handle\";",
          "380:     ASSERT(0 == uv_tcp_init(loop, handle));",
          "381:     ASSERT(0 == uv_tcp_connect(&ctx->connect_req,",
          "382:                                handle,",
          "383:                                listen_addr,",
          "384:                                cl_connect_cb));",
          "385:     ASSERT(0 == uv_idle_init(loop, &ctx->idle_handle));",
          "386:   }",
          "388:   {",
          "389:     uint64_t t = uv_hrtime();",
          "390:     ASSERT(0 == uv_run(loop));",
          "391:     t = uv_hrtime() - t;",
          "392:     time = t / 1e9;",
          "393:   }",
          "395:   for (i = 0; i < num_servers; i++) {",
          "396:     struct server_ctx* ctx = servers + i;",
          "397:     uv_async_send(&ctx->async_handle);",
          "398:     ASSERT(0 == uv_thread_join(&ctx->thread_id));",
          "399:     uv_sem_destroy(&ctx->semaphore);",
          "400:   }",
          "402:   printf(\"accept%u: %.0f accepts/sec (%u total)\\n\",",
          "403:          num_servers,",
          "404:          NUM_CONNECTS / time,",
          "405:          NUM_CONNECTS);",
          "407:   for (i = 0; i < num_servers; i++) {",
          "408:     struct server_ctx* ctx = servers + i;",
          "409:     printf(\"  thread #%u: %.0f accepts/sec (%u total, %.1f%%)\\n\",",
          "410:            i,",
          "411:            ctx->num_connects / time,",
          "412:            ctx->num_connects,",
          "413:            ctx->num_connects * 100.0 / NUM_CONNECTS);",
          "414:   }",
          "416:   free(clients);",
          "417:   free(servers);",
          "420:   return 0;",
          "421: }",
          "424: BENCHMARK_IMPL(tcp_multi_accept2) {",
          "425:   return test_tcp(2, 40);",
          "426: }",
          "429: BENCHMARK_IMPL(tcp_multi_accept4) {",
          "430:   return test_tcp(4, 40);",
          "431: }",
          "434: BENCHMARK_IMPL(tcp_multi_accept8) {",
          "435:   return test_tcp(8, 40);",
          "436: }",
          "",
          "---------------"
        ],
        "deps/uv/test/dns-server.c||deps/uv/test/dns-server.c": [
          "File: deps/uv/test/dns-server.c -> deps/uv/test/dns-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "153:           hdrbuf_remaining = DNSREC_LEN - readbuf_remaining;",
          "154:           break;",
          "155:         } else {",
          "158:           memcpy(&hdrbuf[DNSREC_LEN - hdrbuf_remaining], dnsreq, hdrbuf_remaining);",
          "159:           dnsreq += hdrbuf_remaining;",
          "",
          "[Removed Lines]",
          "156:           short int reclen_n;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "161:           hdrbuf_remaining = 0;",
          "166:         }",
          "167:       }",
          "",
          "[Removed Lines]",
          "164:           reclen_n = *((short int*)hdrbuf);",
          "165:           rec_remaining = ntohs(reclen_n) - (DNSREC_LEN - 2);",
          "",
          "[Added Lines]",
          "163:           rec_remaining = (unsigned) hdrbuf[0] * 256 + (unsigned) hdrbuf[1];",
          "164:           rec_remaining -= (DNSREC_LEN - 2);",
          "",
          "---------------"
        ],
        "deps/uv/test/test-fs-event.c||deps/uv/test/test-fs-event.c": [
          "File: deps/uv/test/test-fs-event.c -> deps/uv/test/test-fs-event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:   ASSERT(handle == &fs_event);",
          "99:   ASSERT(status == 0);",
          "100:   ASSERT(events == UV_RENAME);",
          "103:   uv_close((uv_handle_t*)handle, close_cb);",
          "104: }",
          "",
          "[Removed Lines]",
          "101:   ASSERT(filename == NULL || strcmp(filename, \"file1\") == 0 ||",
          "102:          strstr(filename, \"watch_dir\") != NULL);",
          "",
          "[Added Lines]",
          "101:   ASSERT(filename == NULL || strcmp(filename, \"file1\") == 0);",
          "",
          "---------------"
        ],
        "deps/uv/test/test-list.h||deps/uv/test/test-list.h": [
          "File: deps/uv/test/test-list.h -> deps/uv/test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: TEST_DECLARE   (delayed_accept)",
          "41: TEST_DECLARE   (multiple_listen)",
          "42: TEST_DECLARE   (tcp_writealot)",
          "43: TEST_DECLARE   (tcp_connect_error_after_write)",
          "44: TEST_DECLARE   (tcp_shutdown_after_write)",
          "45: TEST_DECLARE   (tcp_bind_error_addrinuse)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: TEST_DECLARE   (tcp_open)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69: TEST_DECLARE   (udp_dual_stack)",
          "70: TEST_DECLARE   (udp_ipv6_only)",
          "71: TEST_DECLARE   (udp_options)",
          "72: TEST_DECLARE   (pipe_bind_error_addrinuse)",
          "73: TEST_DECLARE   (pipe_bind_error_addrnotavail)",
          "74: TEST_DECLARE   (pipe_bind_error_inval)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: TEST_DECLARE   (udp_open)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "237:   TEST_ENTRY  (tcp_writealot)",
          "238:   TEST_HELPER (tcp_writealot, tcp4_echo_server)",
          "240:   TEST_ENTRY  (tcp_shutdown_after_write)",
          "241:   TEST_HELPER (tcp_shutdown_after_write, tcp4_echo_server)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242:   TEST_ENTRY  (tcp_open)",
          "243:   TEST_HELPER (tcp_open, tcp4_echo_server)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "271:   TEST_ENTRY  (udp_multicast_join)",
          "272:   TEST_ENTRY  (udp_multicast_ttl)",
          "274:   TEST_ENTRY  (pipe_bind_error_addrinuse)",
          "275:   TEST_ENTRY  (pipe_bind_error_addrnotavail)",
          "276:   TEST_ENTRY  (pipe_bind_error_inval)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279:   TEST_ENTRY  (udp_open)",
          "280:   TEST_HELPER (udp_open, udp4_echo_server)",
          "",
          "---------------"
        ],
        "deps/uv/test/test-tcp-open.c||deps/uv/test/test-tcp-open.c": [
          "File: deps/uv/test/test-tcp-open.c -> deps/uv/test/test-tcp-open.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"uv.h\"",
          "23: #include \"task.h\"",
          "24: #include <stdio.h>",
          "25: #include <stdlib.h>",
          "26: #include <string.h>",
          "28: #ifndef _WIN32",
          "29: # include <unistd.h>",
          "30: #endif",
          "32: static int shutdown_cb_called = 0;",
          "33: static int connect_cb_called = 0;",
          "34: static int write_cb_called = 0;",
          "35: static int close_cb_called = 0;",
          "37: static uv_connect_t connect_req;",
          "38: static uv_shutdown_t shutdown_req;",
          "39: static uv_write_t write_req;",
          "42: static void startup(void) {",
          "43: #ifdef _WIN32",
          "44:     struct WSAData wsa_data;",
          "45:     int r = WSAStartup(MAKEWORD(2, 2), &wsa_data);",
          "46:     ASSERT(r == 0);",
          "47: #endif",
          "48: }",
          "51: static uv_os_sock_t create_tcp_socket(void) {",
          "52:   uv_os_sock_t sock;",
          "53:   int r;",
          "55:   sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);",
          "56: #ifdef _WIN32",
          "57:   ASSERT(sock != INVALID_SOCKET);",
          "58: #else",
          "59:   ASSERT(sock >= 0);",
          "60: #endif",
          "62: #ifndef _WIN32",
          "63:   {",
          "65:     int yes = 1;",
          "66:     r = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes);",
          "67:     ASSERT(r == 0);",
          "68:   }",
          "69: #endif",
          "71:   return sock;",
          "72: }",
          "75: static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size) {",
          "76:   static char slab[65536];",
          "77:   ASSERT(suggested_size <= sizeof slab);",
          "78:   return uv_buf_init(slab, sizeof slab);",
          "79: }",
          "82: static void close_cb(uv_handle_t* handle) {",
          "83:   ASSERT(handle != NULL);",
          "84:   close_cb_called++;",
          "85: }",
          "88: static void shutdown_cb(uv_shutdown_t* req, int status) {",
          "89:   ASSERT(req == &shutdown_req);",
          "90:   ASSERT(status == 0);",
          "93:   shutdown_cb_called++;",
          "94: }",
          "97: static void read_cb(uv_stream_t* tcp, ssize_t nread, uv_buf_t buf) {",
          "98:   ASSERT(tcp != NULL);",
          "100:   if (nread >= 0) {",
          "101:     ASSERT(nread == 4);",
          "102:     ASSERT(memcmp(\"PING\", buf.base, nread) == 0);",
          "103:   }",
          "104:   else {",
          "105:     ASSERT(uv_last_error(uv_default_loop()).code == UV_EOF);",
          "106:     printf(\"GOT EOF\\n\");",
          "107:     uv_close((uv_handle_t*)tcp, close_cb);",
          "108:   }",
          "109: }",
          "112: static void write_cb(uv_write_t* req, int status) {",
          "113:   ASSERT(req != NULL);",
          "115:   if (status) {",
          "116:     uv_err_t err = uv_last_error(uv_default_loop());",
          "117:     fprintf(stderr, \"uv_write error: %s\\n\", uv_strerror(err));",
          "118:     ASSERT(0);",
          "119:   }",
          "121:   write_cb_called++;",
          "122: }",
          "125: static void connect_cb(uv_connect_t* req, int status) {",
          "126:   uv_buf_t buf = uv_buf_init(\"PING\", 4);",
          "127:   uv_stream_t* stream;",
          "128:   int r;",
          "130:   ASSERT(req == &connect_req);",
          "131:   ASSERT(status == 0);",
          "133:   stream = req->handle;",
          "134:   connect_cb_called++;",
          "136:   r = uv_write(&write_req, stream, &buf, 1, write_cb);",
          "137:   ASSERT(r == 0);",
          "140:   r = uv_shutdown(&shutdown_req, stream, shutdown_cb);",
          "141:   ASSERT(r == 0);",
          "144:   r = uv_read_start(stream, alloc_cb, read_cb);",
          "145:   ASSERT(r == 0);",
          "146: }",
          "149: TEST_IMPL(tcp_open) {",
          "150:   struct sockaddr_in addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);",
          "151:   uv_tcp_t client;",
          "152:   uv_os_sock_t sock;",
          "153:   int r;",
          "155:   startup();",
          "156:   sock = create_tcp_socket();",
          "158:   r = uv_tcp_init(uv_default_loop(), &client);",
          "159:   ASSERT(r == 0);",
          "161:   r = uv_tcp_open(&client, sock);",
          "162:   ASSERT(r == 0);",
          "164:   r = uv_tcp_connect(&connect_req, &client, addr, connect_cb);",
          "165:   ASSERT(r == 0);",
          "167:   uv_run(uv_default_loop());",
          "169:   ASSERT(shutdown_cb_called == 1);",
          "170:   ASSERT(connect_cb_called == 1);",
          "171:   ASSERT(write_cb_called == 1);",
          "172:   ASSERT(close_cb_called == 1);",
          "174:   return 0;",
          "175: }",
          "",
          "---------------"
        ],
        "deps/uv/test/test-udp-open.c||deps/uv/test/test-udp-open.c": [
          "File: deps/uv/test/test-udp-open.c -> deps/uv/test/test-udp-open.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"uv.h\"",
          "23: #include \"task.h\"",
          "24: #include <stdio.h>",
          "25: #include <stdlib.h>",
          "26: #include <string.h>",
          "28: #ifndef _WIN32",
          "29: # include <unistd.h>",
          "30: #endif",
          "32: static int send_cb_called = 0;",
          "33: static int close_cb_called = 0;",
          "35: static uv_udp_send_t send_req;",
          "38: static void startup(void) {",
          "39: #ifdef _WIN32",
          "40:     struct WSAData wsa_data;",
          "41:     int r = WSAStartup(MAKEWORD(2, 2), &wsa_data);",
          "42:     ASSERT(r == 0);",
          "43: #endif",
          "44: }",
          "47: static uv_os_sock_t create_udp_socket(void) {",
          "48:   uv_os_sock_t sock;",
          "49:   int r;",
          "51:   sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);",
          "52: #ifdef _WIN32",
          "53:   ASSERT(sock != INVALID_SOCKET);",
          "54: #else",
          "55:   ASSERT(sock >= 0);",
          "56: #endif",
          "58: #ifndef _WIN32",
          "59:   {",
          "61:     int yes = 1;",
          "62:     r = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes);",
          "63:     ASSERT(r == 0);",
          "64:   }",
          "65: #endif",
          "67:   return sock;",
          "68: }",
          "71: static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size) {",
          "72:   static char slab[65536];",
          "73:   ASSERT(suggested_size <= sizeof slab);",
          "74:   return uv_buf_init(slab, sizeof slab);",
          "75: }",
          "78: static void close_cb(uv_handle_t* handle) {",
          "79:   ASSERT(handle != NULL);",
          "80:   close_cb_called++;",
          "81: }",
          "84: static void recv_cb(uv_udp_t* handle,",
          "85:                        ssize_t nread,",
          "86:                        uv_buf_t buf,",
          "87:                        struct sockaddr* addr,",
          "88:                        unsigned flags) {",
          "89:   int r;",
          "91:   if (nread < 0) {",
          "92:     ASSERT(0 && \"unexpected error\");",
          "93:   }",
          "95:   if (nread == 0) {",
          "98:     ASSERT(addr == NULL);",
          "99:     return;",
          "100:   }",
          "102:   ASSERT(flags == 0);",
          "104:   ASSERT(addr != NULL);",
          "105:   ASSERT(nread == 4);",
          "106:   ASSERT(memcmp(\"PING\", buf.base, nread) == 0);",
          "108:   r = uv_udp_recv_stop(handle);",
          "109:   ASSERT(r == 0);",
          "111:   uv_close((uv_handle_t*) handle, close_cb);",
          "112: }",
          "115: static void send_cb(uv_udp_send_t* req, int status) {",
          "116:   ASSERT(req != NULL);",
          "117:   ASSERT(status == 0);",
          "119:   send_cb_called++;",
          "120: }",
          "123: TEST_IMPL(udp_open) {",
          "124:   struct sockaddr_in addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);",
          "125:   uv_buf_t buf = uv_buf_init(\"PING\", 4);",
          "126:   uv_udp_t client;",
          "127:   uv_os_sock_t sock;",
          "128:   int r;",
          "130:   startup();",
          "131:   sock = create_udp_socket();",
          "133:   r = uv_udp_init(uv_default_loop(), &client);",
          "134:   ASSERT(r == 0);",
          "136:   r = uv_udp_open(&client, sock);",
          "137:   ASSERT(r == 0);",
          "139:   r = uv_udp_bind(&client, addr, 0);",
          "140:   ASSERT(r == 0);",
          "142:   r = uv_udp_recv_start(&client, alloc_cb, recv_cb);",
          "143:   ASSERT(r == 0);",
          "145:   r = uv_udp_send(&send_req, &client, &buf, 1, addr, send_cb);",
          "146:   ASSERT(r == 0);",
          "148:   uv_run(uv_default_loop());",
          "150:   ASSERT(send_cb_called == 1);",
          "151:   ASSERT(close_cb_called == 1);",
          "153:   return 0;",
          "154: }",
          "",
          "---------------"
        ],
        "deps/uv/uv.gyp||deps/uv/uv.gyp": [
          "File: deps/uv/uv.gyp -> deps/uv/uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "305:         'test/test-tcp-connect-error.c',",
          "306:         'test/test-tcp-connect-timeout.c',",
          "307:         'test/test-tcp-connect6-error.c',",
          "308:         'test/test-tcp-write-error.c',",
          "309:         'test/test-tcp-write-to-half-open-connection.c',",
          "310:         'test/test-tcp-writealot.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "308:         'test/test-tcp-open.c',",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "318:         'test/test-tty.c',",
          "319:         'test/test-udp-dgram-too-big.c',",
          "320:         'test/test-udp-ipv6.c',",
          "321:         'test/test-udp-options.c',",
          "322:         'test/test-udp-send-and-recv.c',",
          "323:         'test/test-udp-multicast-join.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "322:         'test/test-udp-open.c',",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "370:         'test/benchmark-list.h',",
          "371:         'test/benchmark-loop-count.c',",
          "372:         'test/benchmark-million-timers.c',",
          "373:         'test/benchmark-ping-pongs.c',",
          "374:         'test/benchmark-pound.c',",
          "375:         'test/benchmark-pump.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "375:         'test/benchmark-multi-accept.c',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "436a9b69f3732938a607196a023b890e9e804c64",
      "candidate_info": {
        "commit_hash": "436a9b69f3732938a607196a023b890e9e804c64",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/436a9b69f3732938a607196a023b890e9e804c64",
        "files": [
          "lib/net.js",
          "test/simple/test-http-localaddress-bind-error.js",
          "test/simple/test-https-localaddress-bind-error.js"
        ],
        "message": "net: signal localAddress bind failure in connect",
        "before_after_code_files": [
          "lib/net.js||linet.js",
          "test/simple/test-http-localaddress-bind-error.js||test/simple/test-http-localaddress-bind-error.js",
          "test/simple/test-https-localaddress-bind-error.js||test/simple/test-https-localaddress-bind-error.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/net.js||linet.js": [
          "File: lib/net.js -> linet.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "566:   assert.ok(self._connecting);",
          "568:   var connectReq;",
          "569:   if (addressType == 6) {",
          "573:     connectReq = self._handle.connect6(address, port);",
          "574:   } else if (addressType == 4) {",
          "578:     connectReq = self._handle.connect(address, port);",
          "579:   } else {",
          "583:     connectReq = self._handle.connect(address, afterConnect);",
          "584:   }",
          "",
          "[Removed Lines]",
          "570:     if (localAddress) {",
          "571:       self._handle.bind6(localAddress);",
          "572:     }",
          "575:     if (localAddress) {",
          "576:       self._handle.bind(localAddress);",
          "577:     }",
          "580:     if (localAddress) {",
          "581:       self._handle.bind(localAddress);",
          "582:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/simple/test-http-localaddress-bind-error.js||test/simple/test-http-localaddress-bind-error.js": [
          "File: test/simple/test-http-localaddress-bind-error.js -> test/simple/test-http-localaddress-bind-error.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: var common = require('../common');",
          "23: var assert = require('assert');",
          "24: var http = require('http');",
          "26: var invalidLocalAddress = '1.2.3.4';",
          "27: var gotError = false;",
          "29: var server = http.createServer(function(req, res) {",
          "30:   console.log(\"Connect from: \" + req.connection.remoteAddress);",
          "32:   req.on('end', function() {",
          "33:     res.writeHead(200, { 'Content-Type': 'text/plain' });",
          "34:     res.end('You are from: ' + req.connection.remoteAddress);",
          "35:   });",
          "36: });",
          "38: server.listen(common.PORT, \"127.0.0.1\", function() {",
          "39:   var req = http.request({",
          "40:     host: 'localhost',",
          "41:     port: common.PORT,",
          "42:     path: '/',",
          "43:     method: 'GET',",
          "44:     localAddress: invalidLocalAddress",
          "45:   }, function(res) {",
          "46:     assert.fail('unexpectedly got response from server');",
          "47:   }).on('error', function(e) {",
          "48:     console.log('client got error: ' + e.message);",
          "49:     gotError = true;",
          "50:     server.close();",
          "51:   }).end();",
          "52: });",
          "54: process.on('exit', function() {",
          "55:   assert.ok(gotError);",
          "56: });",
          "",
          "---------------"
        ],
        "test/simple/test-https-localaddress-bind-error.js||test/simple/test-https-localaddress-bind-error.js": [
          "File: test/simple/test-https-localaddress-bind-error.js -> test/simple/test-https-localaddress-bind-error.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: var common = require('../common');",
          "23: var assert = require('assert');",
          "24: var https = require('https');",
          "25: var fs = require('fs');",
          "27: var options = {",
          "28:   key: fs.readFileSync(common.fixturesDir + '/keys/agent1-key.pem'),",
          "29:   cert: fs.readFileSync(common.fixturesDir + '/keys/agent1-cert.pem')",
          "30: };",
          "32: var invalidLocalAddress = '1.2.3.4';",
          "33: var gotError = false;",
          "35: var server = https.createServer(options, function(req, res) {",
          "36:   console.log(\"Connect from: \" + req.connection.remoteAddress);",
          "38:   req.on('end', function() {",
          "39:     res.writeHead(200, { 'Content-Type': 'text/plain' });",
          "40:     res.end('You are from: ' + req.connection.remoteAddress);",
          "41:   });",
          "42: });",
          "44: server.listen(common.PORT, \"127.0.0.1\", function() {",
          "45:   var req = https.request({",
          "46:     host: 'localhost',",
          "47:     port: common.PORT,",
          "48:     path: '/',",
          "49:     method: 'GET',",
          "50:     localAddress: invalidLocalAddress",
          "51:   }, function(res) {",
          "52:     assert.fail('unexpectedly got response from server');",
          "53:   }).on('error', function(e) {",
          "54:     console.log('client got error: ' + e.message);",
          "55:     gotError = true;",
          "56:     server.close();",
          "57:   }).end();",
          "58: });",
          "60: process.on('exit', function() {",
          "61:   assert.ok(gotError);",
          "62: });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f41901cdf6e6236de3f588051b81340e9c1dd61f",
      "candidate_info": {
        "commit_hash": "f41901cdf6e6236de3f588051b81340e9c1dd61f",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/f41901cdf6e6236de3f588051b81340e9c1dd61f",
        "files": [
          "doc/api/readline.markdown",
          "doc/api/repl.markdown",
          "lib/readline.js",
          "lib/repl.js",
          "test/simple/test-repl-end-emits-exit.js"
        ],
        "message": "repl: make ^D emit an 'end' event on the readline instance\n\nAlso emit 'exit' on the repl when 'end' is emitted on the readline.\n\nFixes `node debug test/fixtures/breakpoints.js` when ^D is pressed.",
        "before_after_code_files": [
          "lib/readline.js||lireadline.js",
          "lib/repl.js||lirepl.js",
          "test/simple/test-repl-end-emits-exit.js||test/simple/test-repl-end-emits-exit.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/readline.js||lireadline.js": [
          "File: lib/readline.js -> lireadline.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:     input.on('data', function(data) {",
          "91:       self._normalWrite(data);",
          "92:     });",
          "94:   } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "575:       case 'd': // delete right or EOF",
          "576:         if (this.cursor === 0 && this.line.length === 0) {",
          "577:           this.pause();",
          "578:         } else if (this.cursor < this.line.length) {",
          "579:           this._deleteRight();",
          "580:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/repl.js||lirepl.js": [
          "File: lib/repl.js -> lirepl.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:   rli.setPrompt(self.prompt);",
          "171:   var sawSIGINT = false;",
          "172:   rli.on('SIGINT', function() {",
          "173:     var empty = rli.line.length === 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/simple/test-repl-end-emits-exit.js||test/simple/test-repl-end-emits-exit.js": [
          "File: test/simple/test-repl-end-emits-exit.js -> test/simple/test-repl-end-emits-exit.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: var common = require('../common'),",
          "23:     assert = require('assert'),",
          "24:     Stream = require('stream'),",
          "25:     repl = require('repl'),",
          "26:     gotTerminalExit = false,",
          "27:     gotRegularExit = false;",
          "30: var stream = new Stream();",
          "31: stream.write = stream.pause = stream.resume = function(){};",
          "32: stream.readable = stream.writable = true;",
          "34: function testTerminalMode() {",
          "35:   var r1 = repl.start({",
          "36:     input: stream,",
          "37:     output: stream,",
          "38:     terminal: true",
          "39:   });",
          "41:   process.nextTick(function() {",
          "43:     stream.emit('data', '\\u0004');",
          "44:   });",
          "46:   r1.on('exit', function() {",
          "48:     gotTerminalExit = true;",
          "49:     testRegularMode();",
          "50:   });",
          "51: }",
          "53: function testRegularMode() {",
          "54:   var r2 = repl.start({",
          "55:     input: stream,",
          "56:     output: stream,",
          "57:     terminal: false",
          "58:   });",
          "60:   process.nextTick(function() {",
          "61:     stream.emit('end');",
          "62:   });",
          "64:   r2.on('exit', function() {",
          "66:     gotRegularExit = true;",
          "67:   });",
          "68: }",
          "70: process.on('exit', function() {",
          "71:   assert(gotTerminalExit);",
          "72:   assert(gotRegularExit);",
          "73: });",
          "77: testTerminalMode();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6b426a2edd69364c095c1208171410cd29ccbd15",
      "candidate_info": {
        "commit_hash": "6b426a2edd69364c095c1208171410cd29ccbd15",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/6b426a2edd69364c095c1208171410cd29ccbd15",
        "files": [
          "deps/v8/build/common.gypi"
        ],
        "message": "Revert \"v8: fix \"pure virtual method called\" runtime error\"\n\nIt makes mksnapshot die with a segmentation fault on sunos with gcc 4.5.2.\n\nThis reverts commit c21c51a6fce878a4625c30032e669660ce6cbcaf.",
        "before_after_code_files": [
          "deps/v8/build/common.gypi||deps/v8/build/common.gypi"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/v8/build/common.gypi||deps/v8/build/common.gypi": [
          "File: deps/v8/build/common.gypi -> deps/v8/build/common.gypi",
          "--- Hunk 1 ---",
          "[Context before]",
          "271:           }],",
          "272:           [ 'v8_no_strict_aliasing==1', {",
          "273:             'cflags': [ '-fno-strict-aliasing' ],",
          "282:           }],",
          "283:         ],  # conditions",
          "284:       }],",
          "",
          "[Removed Lines]",
          "274:           }, {",
          "275:             # gcc 4.4.6 has a regression in non-strict aliasing mode that",
          "276:             # makes a lookup in CodeStub::FindCodeInCache() abort with a",
          "277:             # \"pure virtual method called\" runtime error.",
          "278:             #",
          "279:             # This bites node.js because it sets -fno-strict-aliasing in its",
          "280:             # cflags, which then leak into our cflags.",
          "281:             'cflags!': [ '-fno-strict-aliasing' ],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1eb1fe32250fc88cb5b0a97cddf3e02be02e3f4a",
      "candidate_info": {
        "commit_hash": "1eb1fe32250fc88cb5b0a97cddf3e02be02e3f4a",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/1eb1fe32250fc88cb5b0a97cddf3e02be02e3f4a",
        "files": [
          "AUTHORS",
          "ChangeLog",
          "doc/about/index.html",
          "doc/community/index.html",
          "doc/index.html",
          "doc/logos/index.html",
          "doc/template.html",
          "src/node_version.h"
        ],
        "message": "2012.02.17 Version 0.6.11 (stable)\n\n* http: allow multiple WebSocket RFC6455 headers (Einar Otto Stangvik)\n\n* http: allow multiple WWW-Authenticate headers (Ben Noordhuis)\n\n* windows: support unicode argv and environment variables (Bert Belder)\n\n* tls: mitigate session renegotiation attacks (Ben Noordhuis)\n\n* tcp, pipe: don't assert on uv_accept() errors (Ben Noordhuis)\n\n* tls: Allow establishing secure connection on the existing socket (koichik)\n\n* dgram: handle close of dgram socket before DNS lookup completes (Seth Fitzsimmons)\n\n* windows: Support half-duplex pipes (Igor Zinkovsky)\n\n* build: disable omit-frame-pointer on solaris systems (Dave Pacheco)\n\n* debugger: fix --debug-brk (Ben Noordhuis)\n\n* net: fix large file downloads failing (koichik)\n\n* fs: fix ReadStream failure to read from existing fd (Christopher Jeffrey)\n\n* net: destroy socket on DNS error (Stefan Rusu)\n\n* dtrace: add missing translator (Dave Pacheco)\n\n* unix: don't flush tty on switch to raw mode (Ben Noordhuis)\n\n* windows: reset brightness when reverting to default text color (Bert Belder)\n\n* npm: update to 1.1.1\n  - Update which, fstream, mkdirp, request, and rimraf\n  - Fix #2123 Set path properly for lifecycle scripts on windows\n  - Mark the root as seen, so we don't recurse into it. Fixes #1838. (Martin Cooper)",
        "before_after_code_files": [
          "src/node_version.h||src/node_version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/node_version.h||src/node_version.h": [
          "File: src/node_version.h -> src/node_version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #define NODE_MAJOR_VERSION 0",
          "30: #define NODE_MINOR_VERSION 6",
          "31: #define NODE_PATCH_VERSION 11",
          "34: #ifndef NODE_STRINGIFY",
          "35: #define NODE_STRINGIFY(n) NODE_STRINGIFY_HELPER(n)",
          "",
          "[Removed Lines]",
          "32: #define NODE_VERSION_IS_RELEASE 0",
          "",
          "[Added Lines]",
          "32: #define NODE_VERSION_IS_RELEASE 1",
          "",
          "---------------"
        ]
      }
    }
  ]
}
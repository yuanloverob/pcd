{
  "cve_id": "CVE-2012-2119",
  "cve_desc": "Buffer overflow in the macvtap device driver in the Linux kernel before 3.4.5, when running in certain configurations, allows privileged KVM guest users to cause a denial of service (crash) via a long descriptor with a long vector length.",
  "repo": "torvalds/linux",
  "patch_hash": "b92946e2919134ebe2a4083e4302236295ea2a73",
  "patch_info": {
    "commit_hash": "b92946e2919134ebe2a4083e4302236295ea2a73",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b92946e2919134ebe2a4083e4302236295ea2a73",
    "files": [
      "drivers/net/macvtap.c"
    ],
    "message": "macvtap: zerocopy: validate vectors before building skb\n\nThere're several reasons that the vectors need to be validated:\n\n- Return error when caller provides vectors whose num is greater than UIO_MAXIOV.\n- Linearize part of skb when userspace provides vectors grater than MAX_SKB_FRAGS.\n- Return error when userspace provides vectors whose total length may exceed\n- MAX_SKB_FRAGS * PAGE_SIZE.\n\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>",
    "before_after_code_files": [
      "drivers/net/macvtap.c||drivers/net/macvtap.c"
    ]
  },
  "patch_diff": {
    "drivers/net/macvtap.c||drivers/net/macvtap.c": [
      "File: drivers/net/macvtap.c -> drivers/net/macvtap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "529:   }",
      "530:   base = (unsigned long)from->iov_base + offset;",
      "531:   size = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;",
      "532:   num_pages = get_user_pages_fast(base, size, 0, &page[i]);",
      "535:    for (i = 0; i < num_pages; i++)",
      "536:     put_page(page[i]);",
      "537:    return -EFAULT;",
      "",
      "[Removed Lines]",
      "533:   if ((num_pages != size) ||",
      "534:       (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {",
      "",
      "[Added Lines]",
      "532:   if (i + size > MAX_SKB_FRAGS)",
      "533:    return -EMSGSIZE;",
      "535:   if (num_pages != size) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "651:  int err;",
      "652:  struct virtio_net_hdr vnet_hdr = { 0 };",
      "653:  int vnet_hdr_len = 0;",
      "655:  bool zerocopy = false;",
      "657:  if (q->flags & IFF_VNET_HDR) {",
      "",
      "[Removed Lines]",
      "654:  int copylen;",
      "",
      "[Added Lines]",
      "655:  int copylen = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "680:  if (unlikely(len < ETH_HLEN))",
      "681:   goto err;",
      "683:  if (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))",
      "684:   zerocopy = true;",
      "686:  if (zerocopy) {",
      "692:   if (!copylen)",
      "693:    copylen = GOODCOPY_LEN;",
      "694:  } else",
      "",
      "[Removed Lines]",
      "691:   copylen = vnet_hdr.hdr_len;",
      "",
      "[Added Lines]",
      "684:  err = -EMSGSIZE;",
      "685:  if (unlikely(count > UIO_MAXIOV))",
      "686:   goto err;",
      "696:   if (count > MAX_SKB_FRAGS) {",
      "697:    copylen = iov_length(iv, count - MAX_SKB_FRAGS);",
      "698:    if (copylen < vnet_hdr_len)",
      "699:     copylen = 0;",
      "700:    else",
      "701:     copylen -= vnet_hdr_len;",
      "702:   }",
      "707:   if (copylen < vnet_hdr.hdr_len)",
      "708:    copylen = vnet_hdr.hdr_len;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "97bc3633bec7ed0fdfbda6b9cf86c51e4f58f8e2",
      "candidate_info": {
        "commit_hash": "97bc3633bec7ed0fdfbda6b9cf86c51e4f58f8e2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/97bc3633bec7ed0fdfbda6b9cf86c51e4f58f8e2",
        "files": [
          "drivers/net/macvtap.c"
        ],
        "message": "macvtap: macvtapTX zero-copy support\n\nOnly 128 bytes is copied, the rest of data is DMA mapped directly from\nuserspace.\n\nSigned-off-by: Shirley Ma <xma@...ibm.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/macvtap.c||drivers/net/macvtap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/net/macvtap.c||drivers/net/macvtap.c"
          ],
          "candidate": [
            "drivers/net/macvtap.c||drivers/net/macvtap.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/macvtap.c||drivers/net/macvtap.c": [
          "File: drivers/net/macvtap.c -> drivers/net/macvtap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: static dev_t macvtap_major;",
          "62: #define MACVTAP_NUM_DEVS 65536",
          "63: static struct class *macvtap_class;",
          "64: static struct cdev macvtap_cdev;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: #define GOODCOPY_LEN 128",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340: {",
          "341:  struct net *net = current->nsproxy->net_ns;",
          "342:  struct net_device *dev = dev_get_by_index(net, iminor(inode));",
          "343:  struct macvtap_queue *q;",
          "344:  int err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "344:  struct macvlan_dev *vlan = netdev_priv(dev);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "369:  q->flags = IFF_VNET_HDR | IFF_NO_PI | IFF_TAP;",
          "370:  q->vnet_hdr_sz = sizeof(struct virtio_net_hdr);",
          "372:  err = macvtap_set_queue(dev, file, q);",
          "373:  if (err)",
          "374:   sock_put(&q->sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "378:  if (vlan) {",
          "379:   if ((vlan->lowerdev->features & NETIF_F_HIGHDMA) &&",
          "380:       (vlan->lowerdev->features & NETIF_F_SG))",
          "381:    sock_set_flag(&q->sk, SOCK_ZEROCOPY);",
          "382:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "433:  return skb;",
          "434: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "449: static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,",
          "450:       int offset, size_t count)",
          "451: {",
          "452:  int len = iov_length(from, count) - offset;",
          "453:  int copy = skb_headlen(skb);",
          "454:  int size, offset1 = 0;",
          "455:  int i = 0;",
          "456:  skb_frag_t *f;",
          "459:  while (count && (offset >= from->iov_len)) {",
          "460:   offset -= from->iov_len;",
          "461:   ++from;",
          "462:   --count;",
          "463:  }",
          "466:  while (count && (copy > 0)) {",
          "467:   size = min_t(unsigned int, copy, from->iov_len - offset);",
          "468:   if (copy_from_user(skb->data + offset1, from->iov_base + offset,",
          "469:        size))",
          "470:    return -EFAULT;",
          "471:   if (copy > size) {",
          "472:    ++from;",
          "473:    --count;",
          "474:   }",
          "475:   copy -= size;",
          "476:   offset1 += size;",
          "477:   offset = 0;",
          "478:  }",
          "480:  if (len == offset1)",
          "481:   return 0;",
          "483:  while (count--) {",
          "484:   struct page *page[MAX_SKB_FRAGS];",
          "485:   int num_pages;",
          "486:   unsigned long base;",
          "488:   len = from->iov_len - offset1;",
          "489:   if (!len) {",
          "490:    offset1 = 0;",
          "491:    ++from;",
          "492:    continue;",
          "493:   }",
          "494:   base = (unsigned long)from->iov_base + offset1;",
          "495:   size = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;",
          "496:   num_pages = get_user_pages_fast(base, size, 0, &page[i]);",
          "497:   if ((num_pages != size) ||",
          "498:       (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags))",
          "500:    return -EFAULT;",
          "501:   skb->data_len += len;",
          "502:   skb->len += len;",
          "503:   skb->truesize += len;",
          "504:   atomic_add(len, &skb->sk->sk_wmem_alloc);",
          "505:   while (len) {",
          "506:    f = &skb_shinfo(skb)->frags[i];",
          "507:    f->page = page[i];",
          "508:    f->page_offset = base & ~PAGE_MASK;",
          "509:    f->size = min_t(int, len, PAGE_SIZE - f->page_offset);",
          "510:    skb_shinfo(skb)->nr_frags++;",
          "512:    base += f->size;",
          "513:    len -= f->size;",
          "514:    i++;",
          "515:   }",
          "516:   offset1 = 0;",
          "517:   ++from;",
          "518:  }",
          "519:  return 0;",
          "520: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "523: {",
          "524:  struct sk_buff *skb;",
          "525:  struct macvlan_dev *vlan;",
          "527:  int err;",
          "528:  struct virtio_net_hdr vnet_hdr = { 0 };",
          "529:  int vnet_hdr_len = 0;",
          "531:  if (q->flags & IFF_VNET_HDR) {",
          "532:   vnet_hdr_len = q->vnet_hdr_sz;",
          "",
          "[Removed Lines]",
          "520: static ssize_t macvtap_get_user(struct macvtap_queue *q,",
          "521:     const struct iovec *iv, size_t count,",
          "522:     int noblock)",
          "526:  size_t len = count;",
          "",
          "[Added Lines]",
          "606: static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,",
          "607:     const struct iovec *iv, unsigned long total_len,",
          "608:     size_t count, int noblock)",
          "612:  unsigned long len = total_len;",
          "616:  int copylen;",
          "617:  bool zerocopy = false;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "554:  if (unlikely(len < ETH_HLEN))",
          "555:   goto err;",
          "559:  if (!skb)",
          "560:   goto err;",
          "563:  if (err)",
          "564:   goto err_kfree;",
          "",
          "[Removed Lines]",
          "557:  skb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, len, vnet_hdr.hdr_len,",
          "558:     noblock, &err);",
          "562:  err = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len, len);",
          "",
          "[Added Lines]",
          "645:  if (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))",
          "646:   zerocopy = true;",
          "648:  if (zerocopy) {",
          "653:   copylen = vnet_hdr.hdr_len;",
          "654:   if (!copylen)",
          "655:    copylen = GOODCOPY_LEN;",
          "656:  } else",
          "657:   copylen = len;",
          "659:  skb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,",
          "660:     vnet_hdr.hdr_len, noblock, &err);",
          "664:  if (zerocopy) {",
          "665:   err = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);",
          "666:   skb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;",
          "667:  } else",
          "668:   err = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,",
          "669:          len);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "576:  rcu_read_lock_bh();",
          "577:  vlan = rcu_dereference_bh(q->vlan);",
          "578:  if (vlan)",
          "579:   macvlan_start_xmit(skb, vlan->dev);",
          "580:  else",
          "581:   kfree_skb(skb);",
          "582:  rcu_read_unlock_bh();",
          "586: err_kfree:",
          "587:  kfree_skb(skb);",
          "",
          "[Removed Lines]",
          "584:  return count;",
          "",
          "[Added Lines]",
          "686:  if (zerocopy)",
          "687:   skb_shinfo(skb)->destructor_arg = m->msg_control;",
          "694:  return total_len;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "603:  ssize_t result = -ENOLINK;",
          "604:  struct macvtap_queue *q = file->private_data;",
          "608:  return result;",
          "609: }",
          "",
          "[Removed Lines]",
          "606:  result = macvtap_get_user(q, iv, iov_length(iv, count),",
          "607:          file->f_flags & O_NONBLOCK);",
          "",
          "[Added Lines]",
          "716:  result = macvtap_get_user(q, NULL, iv, iov_length(iv, count), count,",
          "717:       file->f_flags & O_NONBLOCK);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "817:       struct msghdr *m, size_t total_len)",
          "818: {",
          "819:  struct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);",
          "821:        m->msg_flags & MSG_DONTWAIT);",
          "822: }",
          "",
          "[Removed Lines]",
          "820:  return macvtap_get_user(q, m->msg_iov, total_len,",
          "",
          "[Added Lines]",
          "930:  return macvtap_get_user(q, m, m->msg_iov, total_len, m->msg_iovlen,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
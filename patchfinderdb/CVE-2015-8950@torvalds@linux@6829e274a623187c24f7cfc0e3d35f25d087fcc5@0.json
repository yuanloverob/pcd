{
  "cve_id": "CVE-2015-8950",
  "cve_desc": "arch/arm64/mm/dma-mapping.c in the Linux kernel before 4.0.3, as used in the ION subsystem in Android and other products, does not initialize certain data structures, which allows local users to obtain sensitive information from kernel memory by triggering a dma_mmap call.",
  "repo": "torvalds/linux",
  "patch_hash": "6829e274a623187c24f7cfc0e3d35f25d087fcc5",
  "patch_info": {
    "commit_hash": "6829e274a623187c24f7cfc0e3d35f25d087fcc5",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5",
    "files": [
      "arch/arm64/mm/dma-mapping.c"
    ],
    "message": "arm64: dma-mapping: always clear allocated buffers\n\nBuffers allocated by dma_alloc_coherent() are always zeroed on Alpha,\nARM (32bit), MIPS, PowerPC, x86/x86_64 and probably other architectures.\nIt turned out that some drivers rely on this 'feature'. Allocated buffer\nmight be also exposed to userspace with dma_mmap() call, so clearing it\nis desired from security point of view to avoid exposing random memory\nto userspace. This patch unifies dma_alloc_coherent() behavior on ARM64\narchitecture with other implementations by unconditionally zeroing\nallocated buffer.\n\nCc: <stable@vger.kernel.org> # v3.14+\nSigned-off-by: Marek Szyprowski <m.szyprowski@samsung.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
    "before_after_code_files": [
      "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c"
    ]
  },
  "patch_diff": {
    "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c": [
      "File: arch/arm64/mm/dma-mapping.c -> arch/arm64/mm/dma-mapping.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "69:   ptr = (void *)val;",
      "72:  }",
      "74:  return ptr;",
      "",
      "[Removed Lines]",
      "70:   if (flags & __GFP_ZERO)",
      "71:    memset(ptr, 0, size);",
      "",
      "[Added Lines]",
      "70:   memset(ptr, 0, size);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "115:   addr = page_address(page);",
      "118:   return addr;",
      "119:  } else {",
      "120:   return swiotlb_alloc_coherent(dev, size, dma_handle, flags);",
      "",
      "[Removed Lines]",
      "116:   if (flags & __GFP_ZERO)",
      "117:    memset(addr, 0, size);",
      "",
      "[Added Lines]",
      "115:   memset(addr, 0, size);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7132813c384515c9dede1ae20e56f3895feb7f1e",
      "candidate_info": {
        "commit_hash": "7132813c384515c9dede1ae20e56f3895feb7f1e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7132813c384515c9dede1ae20e56f3895feb7f1e",
        "files": [
          "arch/arm64/mm/dma-mapping.c"
        ],
        "message": "arm64: Honor __GFP_ZERO in dma allocations\n\nCurrent implementation doesn't zero out the pages allocated.\nHonor the __GFP_ZERO flag and zero out if set.\n\nCc: <stable@vger.kernel.org> # v3.14+\nAcked-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>\nSigned-off-by: Catalin Marinas <catalin.marinas@arm.com>",
        "before_after_code_files": [
          "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c"
          ],
          "candidate": [
            "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c": [
          "File: arch/arm64/mm/dma-mapping.c -> arch/arm64/mm/dma-mapping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: }",
          "52: early_param(\"coherent_pool\", early_coherent_pool);",
          "55: {",
          "56:  unsigned long val;",
          "57:  void *ptr = NULL;",
          "",
          "[Removed Lines]",
          "54: static void *__alloc_from_pool(size_t size, struct page **ret_page)",
          "",
          "[Added Lines]",
          "54: static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:   ptr = (void *)val;",
          "70:  }",
          "72:  return ptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70:   if (flags & __GFP_ZERO)",
          "71:    memset(ptr, 0, size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "101:   flags |= GFP_DMA;",
          "102:  if (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {",
          "103:   struct page *page;",
          "105:   size = PAGE_ALIGN(size);",
          "106:   page = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:   void *addr;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "109:    return NULL;",
          "113:  } else {",
          "114:   return swiotlb_alloc_coherent(dev, size, dma_handle, flags);",
          "115:  }",
          "",
          "[Removed Lines]",
          "112:   return page_address(page);",
          "",
          "[Added Lines]",
          "115:   addr = page_address(page);",
          "116:   if (flags & __GFP_ZERO)",
          "117:    memset(addr, 0, size);",
          "118:   return addr;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "147:  if (!coherent && !(flags & __GFP_WAIT)) {",
          "148:   struct page *page = NULL;",
          "151:   if (addr)",
          "",
          "[Removed Lines]",
          "149:   void *addr = __alloc_from_pool(size, &page);",
          "",
          "[Added Lines]",
          "155:   void *addr = __alloc_from_pool(size, &page, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4932f9e81ae7a7bf3c3967e48373909b9c98ee5",
      "candidate_info": {
        "commit_hash": "d4932f9e81ae7a7bf3c3967e48373909b9c98ee5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d4932f9e81ae7a7bf3c3967e48373909b9c98ee5",
        "files": [
          "arch/arm64/Kconfig",
          "arch/arm64/mm/dma-mapping.c"
        ],
        "message": "arm64: add atomic pool for non-coherent and CMA allocations\n\nNeither CMA nor noncoherent allocations support atomic allocations.\nAdd a dedicated atomic pool to support this.\n\nReviewed-by: Catalin Marinas <catalin.marinas@arm.com>\nSigned-off-by: Laura Abbott <lauraa@codeaurora.org>\nCc: Arnd Bergmann <arnd@arndb.de>\nCc: David Riley <davidriley@chromium.org>\nCc: Olof Johansson <olof@lixom.net>\nCc: Ritesh Harjain <ritesh.harjani@gmail.com>\nCc: Russell King <linux@arm.linux.org.uk>\nCc: Thierry Reding <thierry.reding@gmail.com>\nCc: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c"
          ],
          "candidate": [
            "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/mm/dma-mapping.c||arch/arm64/mm/dma-mapping.c": [
          "File: arch/arm64/mm/dma-mapping.c -> arch/arm64/mm/dma-mapping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include <linux/gfp.h>",
          "21: #include <linux/export.h>",
          "22: #include <linux/slab.h>",
          "23: #include <linux/dma-mapping.h>",
          "24: #include <linux/dma-contiguous.h>",
          "25: #include <linux/vmalloc.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include <linux/genalloc.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:  return prot;",
          "39: }",
          "41: static void *__dma_alloc_coherent(struct device *dev, size_t size,",
          "42:       dma_addr_t *dma_handle, gfp_t flags,",
          "43:       struct dma_attrs *attrs)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: static struct gen_pool *atomic_pool;",
          "44: #define DEFAULT_DMA_COHERENT_POOL_SIZE  SZ_256K",
          "45: static size_t atomic_pool_size = DEFAULT_DMA_COHERENT_POOL_SIZE;",
          "47: static int __init early_coherent_pool(char *p)",
          "48: {",
          "49:  atomic_pool_size = memparse(p, &p);",
          "50:  return 0;",
          "51: }",
          "52: early_param(\"coherent_pool\", early_coherent_pool);",
          "54: static void *__alloc_from_pool(size_t size, struct page **ret_page)",
          "55: {",
          "56:  unsigned long val;",
          "57:  void *ptr = NULL;",
          "59:  if (!atomic_pool) {",
          "60:   WARN(1, \"coherent pool not initialised!\\n\");",
          "61:   return NULL;",
          "62:  }",
          "64:  val = gen_pool_alloc(atomic_pool, size);",
          "65:  if (val) {",
          "66:   phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);",
          "69:   ptr = (void *)val;",
          "70:  }",
          "72:  return ptr;",
          "73: }",
          "75: static bool __in_atomic_pool(void *start, size_t size)",
          "76: {",
          "77:  return addr_in_gen_pool(atomic_pool, (unsigned long)start, size);",
          "78: }",
          "80: static int __free_from_pool(void *start, size_t size)",
          "81: {",
          "82:  if (!__in_atomic_pool(start, size))",
          "83:   return 0;",
          "85:  gen_pool_free(atomic_pool, (unsigned long)start, size);",
          "87:  return 1;",
          "88: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "50:  if (IS_ENABLED(CONFIG_ZONE_DMA) &&",
          "51:      dev->coherent_dma_mask <= DMA_BIT_MASK(32))",
          "52:   flags |= GFP_DMA;",
          "54:   struct page *page;",
          "56:   size = PAGE_ALIGN(size);",
          "",
          "[Removed Lines]",
          "53:  if (IS_ENABLED(CONFIG_DMA_CMA)) {",
          "",
          "[Added Lines]",
          "102:  if (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:     void *vaddr, dma_addr_t dma_handle,",
          "71:     struct dma_attrs *attrs)",
          "72: {",
          "73:  if (dev == NULL) {",
          "74:   WARN_ONCE(1, \"Use an actual device structure for DMA allocation\\n\");",
          "75:   return;",
          "76:  }",
          "82:      phys_to_page(paddr),",
          "83:      size >> PAGE_SHIFT);",
          "85:   swiotlb_free_coherent(dev, size, vaddr, dma_handle);",
          "87: }",
          "89: static void *__dma_alloc_noncoherent(struct device *dev, size_t size,",
          "90:          dma_addr_t *dma_handle, gfp_t flags,",
          "91:          struct dma_attrs *attrs)",
          "92: {",
          "94:  void *ptr, *coherent_ptr;",
          "97:  size = PAGE_ALIGN(size);",
          "100:  ptr = __dma_alloc_coherent(dev, size, dma_handle, flags, attrs);",
          "101:  if (!ptr)",
          "102:   goto no_mem;",
          "108:  __dma_flush_range(ptr, ptr + size);",
          "111:  page = virt_to_page(ptr);",
          "117:  if (!coherent_ptr)",
          "118:   goto no_map;",
          "",
          "[Removed Lines]",
          "78:  if (IS_ENABLED(CONFIG_DMA_CMA)) {",
          "79:   phys_addr_t paddr = dma_to_phys(dev, dma_handle);",
          "81:   dma_release_from_contiguous(dev,",
          "84:  } else {",
          "86:  }",
          "93:  struct page *page, **map;",
          "95:  int order, i;",
          "98:  order = get_order(size);",
          "103:  map = kmalloc(sizeof(struct page *) << order, flags & ~GFP_DMA);",
          "104:  if (!map)",
          "105:   goto no_map;",
          "112:  for (i = 0; i < (size >> PAGE_SHIFT); i++)",
          "113:   map[i] = page + i;",
          "114:  coherent_ptr = vmap(map, size >> PAGE_SHIFT, VM_MAP,",
          "115:        __get_dma_pgprot(attrs, __pgprot(PROT_NORMAL_NC), false));",
          "116:  kfree(map);",
          "",
          "[Added Lines]",
          "122:  bool freed;",
          "123:  phys_addr_t paddr = dma_to_phys(dev, dma_handle);",
          "130:  freed = dma_release_from_contiguous(dev,",
          "133:  if (!freed)",
          "141:  struct page *page;",
          "146:  if (!(flags & __GFP_WAIT)) {",
          "147:   struct page *page = NULL;",
          "148:   void *addr = __alloc_from_pool(size, &page);",
          "150:   if (addr)",
          "153:   return addr;",
          "155:  }",
          "166:  coherent_ptr = dma_common_contiguous_remap(page, size, VM_USERMAP,",
          "167:     __get_dma_pgprot(attrs,",
          "168:      __pgprot(PROT_NORMAL_NC), false),",
          "169:      NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "132: {",
          "133:  void *swiotlb_addr = phys_to_virt(dma_to_phys(dev, dma_handle));",
          "135:  vunmap(vaddr);",
          "136:  __dma_free_coherent(dev, size, swiotlb_addr, dma_handle, attrs);",
          "137: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "188:  if (__free_from_pool(vaddr, size))",
          "189:   return;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "308: extern int swiotlb_late_init_with_default_size(size_t default_size);",
          "310: static int __init swiotlb_late_init(void)",
          "311: {",
          "312:  size_t swiotlb_size = min(SZ_64M, MAX_ORDER_NR_PAGES << PAGE_SHIFT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "365: static int __init atomic_pool_init(void)",
          "366: {",
          "367:  pgprot_t prot = __pgprot(PROT_NORMAL_NC);",
          "368:  unsigned long nr_pages = atomic_pool_size >> PAGE_SHIFT;",
          "369:  struct page *page;",
          "370:  void *addr;",
          "371:  unsigned int pool_size_order = get_order(atomic_pool_size);",
          "373:  if (dev_get_cma_area(NULL))",
          "374:   page = dma_alloc_from_contiguous(NULL, nr_pages,",
          "375:        pool_size_order);",
          "376:  else",
          "377:   page = alloc_pages(GFP_DMA, pool_size_order);",
          "379:  if (page) {",
          "380:   int ret;",
          "381:   void *page_addr = page_address(page);",
          "383:   memset(page_addr, 0, atomic_pool_size);",
          "384:   __dma_flush_range(page_addr, page_addr + atomic_pool_size);",
          "386:   atomic_pool = gen_pool_create(PAGE_SHIFT, -1);",
          "387:   if (!atomic_pool)",
          "388:    goto free_page;",
          "390:   addr = dma_common_contiguous_remap(page, atomic_pool_size,",
          "391:      VM_USERMAP, prot, atomic_pool_init);",
          "393:   if (!addr)",
          "394:    goto destroy_genpool;",
          "396:   ret = gen_pool_add_virt(atomic_pool, (unsigned long)addr,",
          "397:      page_to_phys(page),",
          "398:      atomic_pool_size, -1);",
          "399:   if (ret)",
          "400:    goto remove_mapping;",
          "402:   gen_pool_set_algo(atomic_pool,",
          "403:       gen_pool_first_fit_order_align,",
          "404:       (void *)PAGE_SHIFT);",
          "406:   pr_info(\"DMA: preallocated %zu KiB pool for atomic allocations\\n\",",
          "407:    atomic_pool_size / 1024);",
          "408:   return 0;",
          "409:  }",
          "410:  goto out;",
          "412: remove_mapping:",
          "413:  dma_common_free_remap(addr, atomic_pool_size, VM_USERMAP);",
          "414: destroy_genpool:",
          "415:  gen_pool_destroy(atomic_pool);",
          "416:  atomic_pool = NULL;",
          "417: free_page:",
          "418:  if (!dma_release_from_contiguous(NULL, page, nr_pages))",
          "419:   __free_pages(page, pool_size_order);",
          "420: out:",
          "421:  pr_err(\"DMA: failed to allocate %zu KiB pool for atomic coherent allocation\\n\",",
          "422:   atomic_pool_size / 1024);",
          "423:  return -ENOMEM;",
          "424: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "316:  return swiotlb_late_init_with_default_size(swiotlb_size);",
          "317: }",
          "320: #define PREALLOC_DMA_DEBUG_ENTRIES 4096",
          "",
          "[Removed Lines]",
          "318: arch_initcall(swiotlb_late_init);",
          "",
          "[Added Lines]",
          "435: static int __init arm64_dma_init(void)",
          "436: {",
          "437:  int ret = 0;",
          "439:  ret |= swiotlb_late_init();",
          "440:  ret |= atomic_pool_init();",
          "442:  return ret;",
          "443: }",
          "444: arch_initcall(arm64_dma_init);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
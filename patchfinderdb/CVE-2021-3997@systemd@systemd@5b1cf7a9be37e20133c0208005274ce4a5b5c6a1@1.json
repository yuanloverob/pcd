{
  "cve_id": "CVE-2021-3997",
  "cve_desc": "A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.",
  "repo": "systemd/systemd",
  "patch_hash": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
  "patch_info": {
    "commit_hash": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
    "repo": "systemd/systemd",
    "commit_url": "https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
    "files": [
      "src/shared/rm-rf.c"
    ],
    "message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.",
    "before_after_code_files": [
      "src/shared/rm-rf.c||src/shared/rm-rf.c"
    ]
  },
  "patch_diff": {
    "src/shared/rm-rf.c||src/shared/rm-rf.c": [
      "File: src/shared/rm-rf.c -> src/shared/rm-rf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "116:         return 0;",
      "117: }",
      "120:                 int fd,",
      "121:                 const char *fname,",
      "122:                 int is_dir,",
      "123:                 RemoveFlags flags,",
      "126:         struct stat st;",
      "127:         int r, q = 0;",
      "",
      "[Removed Lines]",
      "119: static int rm_rf_children_inner(",
      "124:                 const struct stat *root_dev) {",
      "",
      "[Added Lines]",
      "118: static int rm_rf_inner_child(",
      "123:                 const struct stat *root_dev,",
      "124:                 bool allow_recursion) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "141:         }",
      "143:         if (is_dir) {",
      "147:                 if (root_dev && st.st_dev != root_dev->st_dev)",
      "148:                         return 0;",
      "",
      "[Removed Lines]",
      "144:                 _cleanup_close_ int subdir_fd = -1;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "169:                                 return 1;",
      "170:                 }",
      "173:                 if (subdir_fd < 0)",
      "174:                         return -errno;",
      "180:         } else if (flags & REMOVE_ONLY_DIRECTORIES)",
      "181:                 return 0;",
      "",
      "[Removed Lines]",
      "172:                 subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
      "178:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
      "",
      "[Added Lines]",
      "169:                 if (!allow_recursion)",
      "170:                         return -EISDIR;",
      "172:                 int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
      "178:                 q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "188:         return 1;",
      "189: }",
      "191: int rm_rf_children(",
      "192:                 int fd,",
      "193:                 RemoveFlags flags,",
      "194:                 const struct stat *root_dev) {",
      "197:         int ret = 0, r;",
      "248:         return ret;",
      "249: }",
      "",
      "[Removed Lines]",
      "196:         _cleanup_closedir_ DIR *d = NULL;",
      "199:         assert(fd >= 0);",
      "204:         d = fdopendir(fd);",
      "205:         if (!d) {",
      "206:                 safe_close(fd);",
      "207:                 return -errno;",
      "208:         }",
      "210:         if (!(flags & REMOVE_PHYSICAL)) {",
      "211:                 struct statfs sfs;",
      "213:                 if (fstatfs(dirfd(d), &sfs) < 0)",
      "214:                         return -errno;",
      "216:                 if (is_physical_fs(&sfs)) {",
      "221:                         _cleanup_free_ char *path = NULL;",
      "223:                         (void) fd_get_path(fd, &path);",
      "224:                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
      "225:                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
      "226:                                                strna(path));",
      "227:                 }",
      "228:         }",
      "230:         FOREACH_DIRENT_ALL(de, d, return -errno) {",
      "231:                 int is_dir;",
      "233:                 if (dot_or_dot_dot(de->d_name))",
      "234:                         continue;",
      "236:                 is_dir =",
      "237:                         de->d_type == DT_UNKNOWN ? -1 :",
      "238:                         de->d_type == DT_DIR;",
      "240:                 r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);",
      "241:                 if (r < 0 && r != -ENOENT && ret == 0)",
      "242:                         ret = r;",
      "243:         }",
      "245:         if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)",
      "246:                 ret = -errno;",
      "",
      "[Added Lines]",
      "191: typedef struct TodoEntry {",
      "194: } TodoEntry;",
      "196: static void free_todo_entries(TodoEntry **todos) {",
      "197:         for (TodoEntry *x = *todos; x && x->dir; x++) {",
      "198:                 closedir(x->dir);",
      "199:                 free(x->dirname);",
      "200:         }",
      "202:         freep(todos);",
      "203: }",
      "210:         _cleanup_(free_todo_entries) TodoEntry *todos = NULL;",
      "211:         size_t n_todo = 0;",
      "219:                 _cleanup_closedir_ DIR *d = NULL;",
      "221:                 if (n_todo > 0) {",
      "224:                         assert(dirname);",
      "225:                         r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);",
      "226:                         if (r < 0 && r != -ENOENT && ret == 0)",
      "227:                                 ret = r;",
      "228:                         dirname = mfree(dirname);",
      "231:                         n_todo --;",
      "232:                         d = TAKE_PTR(todos[n_todo].dir);",
      "233:                         dirname = TAKE_PTR(todos[n_todo].dirname);",
      "235:                         assert(d);",
      "237:                         assert(fd >= 0);",
      "238:                 } else {",
      "239:         next_fd:",
      "240:                         assert(fd >= 0);",
      "241:                         d = fdopendir(fd);",
      "242:                         if (!d) {",
      "243:                                 safe_close(fd);",
      "244:                                 return -errno;",
      "245:                         }",
      "246:                         fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have",
      "250:                         if (!(flags & REMOVE_PHYSICAL)) {",
      "251:                                 struct statfs sfs;",
      "253:                                 if (fstatfs(fd, &sfs) < 0)",
      "254:                                         return -errno;",
      "256:                                 if (is_physical_fs(&sfs)) {",
      "261:                                         _cleanup_free_ char *path = NULL;",
      "263:                                         (void) fd_get_path(fd, &path);",
      "264:                                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
      "265:                                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
      "266:                                                                strna(path));",
      "267:                                 }",
      "268:                         }",
      "269:                 }",
      "271:                 FOREACH_DIRENT_ALL(de, d, return -errno) {",
      "272:                         int is_dir;",
      "274:                         if (dot_or_dot_dot(de->d_name))",
      "275:                                 continue;",
      "277:                         is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;",
      "279:                         r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);",
      "280:                         if (r == -EISDIR) {",
      "283:                                  if (!GREEDY_REALLOC0(todos, n_todo + 2))",
      "284:                                          return log_oom();",
      "286:                                  _cleanup_free_ char *newdirname = strdup(de->d_name);",
      "287:                                  if (!newdirname)",
      "288:                                          return log_oom();",
      "290:                                  int newfd = openat(fd, de->d_name,",
      "291:                                                     O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
      "292:                                  if (newfd >= 0) {",
      "293:                                          todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };",
      "294:                                          fd = newfd;",
      "295:                                          dirname = TAKE_PTR(newdirname);",
      "297:                                          goto next_fd;",
      "299:                                  } else if (errno != -ENOENT && ret == 0)",
      "300:                                          ret = -errno;",
      "302:                         } else if (r < 0 && r != -ENOENT && ret == 0)",
      "303:                                 ret = r;",
      "304:                 }",
      "306:                 if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)",
      "307:                         ret = -errno;",
      "309:                 if (n_todo == 0)",
      "310:                         break;",
      "311:         }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "335:         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))",
      "336:                 return -EINVAL;",
      "339: }",
      "",
      "[Removed Lines]",
      "338:         return rm_rf_children_inner(fd, name, -1, flags, NULL);",
      "",
      "[Added Lines]",
      "403:         return rm_rf_inner_child(fd, name, -1, flags, NULL, true);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3bac86abfa1b1720180840ffb9d06b3d54841c11",
      "candidate_info": {
        "commit_hash": "3bac86abfa1b1720180840ffb9d06b3d54841c11",
        "repo": "systemd/systemd",
        "commit_url": "https://github.com/systemd/systemd/commit/3bac86abfa1b1720180840ffb9d06b3d54841c11",
        "files": [
          "src/shared/rm-rf.c"
        ],
        "message": "shared/rm_rf: refactor rm_rf_children_inner() to shorten code a bit",
        "before_after_code_files": [
          "src/shared/rm-rf.c||src/shared/rm-rf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/systemd/systemd/pull/22070"
        ],
        "olp_code_files": {
          "patch": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ],
          "candidate": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/shared/rm-rf.c||src/shared/rm-rf.c": [
          "File: src/shared/rm-rf.c -> src/shared/rm-rf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:                 const struct stat *root_dev) {",
          "126:         struct stat st;",
          "129:         assert(fd >= 0);",
          "130:         assert(fname);",
          "",
          "[Removed Lines]",
          "127:         int r;",
          "",
          "[Added Lines]",
          "127:         int r, q = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143:         if (is_dir) {",
          "144:                 _cleanup_close_ int subdir_fd = -1;",
          "148:                 if (root_dev && st.st_dev != root_dev->st_dev)",
          "",
          "[Removed Lines]",
          "145:                 int q;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "179:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
          "198: }",
          "200: int rm_rf_children(",
          "",
          "[Removed Lines]",
          "181:                 r = unlinkat_harder(fd, fname, AT_REMOVEDIR, flags);",
          "182:                 if (r < 0)",
          "183:                         return r;",
          "184:                 if (q < 0)",
          "185:                         return q;",
          "187:                 return 1;",
          "189:         } else if (!(flags & REMOVE_ONLY_DIRECTORIES)) {",
          "190:                 r = unlinkat_harder(fd, fname, 0, flags);",
          "191:                 if (r < 0)",
          "192:                         return r;",
          "194:                 return 1;",
          "195:         }",
          "197:         return 0;",
          "",
          "[Added Lines]",
          "180:         } else if (flags & REMOVE_ONLY_DIRECTORIES)",
          "181:                 return 0;",
          "183:         r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);",
          "184:         if (r < 0)",
          "185:                 return r;",
          "186:         if (q < 0)",
          "187:                 return q;",
          "188:         return 1;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
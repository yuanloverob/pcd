{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d63b69b8a2fe0afbc62ffb850b7f17d4862244fa",
      "candidate_info": {
        "commit_hash": "d63b69b8a2fe0afbc62ffb850b7f17d4862244fa",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d63b69b8a2fe0afbc62ffb850b7f17d4862244fa",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c",
          "test/altertab3.test"
        ],
        "message": "Ensure that an ALWAYS() in the rename logic really is always true, even for faulty inputs.\n\nFossilOrigin-Name: 54410f0e7710542d5159d0449898598d2b7f7676bfd993644ca47da1bf1fcdac",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c",
          "test/altertab3.test||test/altertab3.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 75b04a4b0d2e65bfcd02cf4e0b6d8f1954957c590814a9b8f9a9ee2adc2ec022",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "757: static int renameUnmapSelectCb(Walker *pWalker, Select *p){",
          "758:   Parse *pParse = pWalker->pParse;",
          "759:   int i;",
          "760:   if( ALWAYS(p->pEList) ){",
          "761:     ExprList *pList = p->pEList;",
          "762:     for(i=0; i<pList->nExpr; i++){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "760:   if( pParse->nErr ) return WRC_Abort;",
          "",
          "---------------"
        ],
        "test/altertab3.test||test/altertab3.test": [
          "File: test/altertab3.test -> test/altertab3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "465:   } $res",
          "466: }",
          "469: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "468: # Verify that the \"if( pParse->nErr ) return WRC_Abort\" at the top of the",
          "469: # renameUnmapSelectCb() routine in alter.c (2019-12-04) is really required.",
          "470: #",
          "471: sqlite3 db :memory:",
          "472: do_catchsql_test 20.10 {",
          "473:   CREATE TABLE s(a, b, c);",
          "474:   CREATE INDEX k ON s( (WITH s AS( SELECT * ) VALUES(2) ) IN () );",
          "475:   ALTER TABLE s RENAME a TO a2;",
          "476: } {1 {error in index k: no tables specified}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f78a528d551d53ce53ce2ccdd26263066ed4150",
      "candidate_info": {
        "commit_hash": "8f78a528d551d53ce53ce2ccdd26263066ed4150",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/8f78a528d551d53ce53ce2ccdd26263066ed4150",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbeaux.c",
          "src/vdbevtab.c"
        ],
        "message": "Add the tables_used() table-valued function as a variation on bytecode().\n\nFossilOrigin-Name: 6283c677d57220e54375a6463f453c6d068e042263558df16cff1055d1b0d3f5",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbeaux.c||src/vdbeaux.c",
          "src/vdbevtab.c||src/vdbevtab.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: d7db09101878102e192ee7a81437e8f6f2e317ddf110852673a2e81d1f80ae0e",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2035:         nRow += aOp[i].p4.pProgram->nOp;",
          "2036:       }",
          "2037:     }",
          "2041:   }",
          "",
          "[Removed Lines]",
          "2038:     if( !bEqp ) break;",
          "2039:     if( aOp[i].opcode==OP_Explain ) break;",
          "2040:     if( aOp[i].opcode==OP_Init && p->pc>1 ) break;",
          "",
          "[Added Lines]",
          "2038:     if( eMode==0 ) break;",
          "2039: #ifdef SQLITE_ENABLE_BYTECODE_VTAB",
          "2040:     if( eMode==2 ){",
          "2041:       Op *pOp = aOp + i;",
          "2042:       if( pOp->opcode==OP_OpenRead ) break;",
          "2043:       if( pOp->opcode==OP_OpenWrite && (pOp->p5 & OPFLAG_P2ISREG)==0 ) break;",
          "2044:       if( pOp->opcode==OP_ReopenIdx ) break;",
          "2045:     }else",
          "2046: #endif",
          "2047:     {",
          "2048:       assert( eMode==1 );",
          "2049:       if( aOp[i].opcode==OP_Explain ) break;",
          "2050:       if( aOp[i].opcode==OP_Init && p->pc>1 ) break;",
          "2051:     }",
          "",
          "---------------"
        ],
        "src/vdbevtab.c||src/vdbevtab.c": [
          "File: src/vdbevtab.c -> src/vdbevtab.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: ){",
          "53:   bytecodevtab *pNew;",
          "54:   int rc;",
          "70:   if( rc==SQLITE_OK ){",
          "71:     pNew = sqlite3_malloc( sizeof(*pNew) );",
          "73:     if( pNew==0 ) return SQLITE_NOMEM;",
          "74:     memset(pNew, 0, sizeof(*pNew));",
          "75:     pNew->db = db;",
          "76:   }",
          "77:   return rc;",
          "78: }",
          "",
          "[Removed Lines]",
          "56:   rc = sqlite3_declare_vtab(db,",
          "57:          \"CREATE TABLE x(\"",
          "58:            \"addr INT,\"",
          "59:            \"opcode TEXT,\"",
          "60:            \"p1 INT,\"",
          "61:            \"p2 INT,\"",
          "62:            \"p3 INT,\"",
          "63:            \"p4 TEXT,\"",
          "64:            \"p5 INT,\"",
          "65:            \"comment TEXT,\"",
          "66:            \"subprog TEXT,\"",
          "67:            \"stmt HIDDEN\"",
          "68:          \");\"",
          "69:        );",
          "",
          "[Added Lines]",
          "59:   int isTabUsed = pAux!=0;",
          "60:   const char *azSchema[2] = {",
          "62:     \"CREATE TABLE x(\"",
          "63:       \"addr INT,\"",
          "64:       \"opcode TEXT,\"",
          "65:       \"p1 INT,\"",
          "66:       \"p2 INT,\"",
          "67:       \"p3 INT,\"",
          "68:       \"p4 TEXT,\"",
          "69:       \"p5 INT,\"",
          "70:       \"comment TEXT,\"",
          "71:       \"subprog TEXT,\"",
          "72:       \"stmt HIDDEN\"",
          "73:     \");\",",
          "76:     \"CREATE TABLE x(\"",
          "77:       \"type TEXT,\"",
          "78:       \"schema TEXT,\"",
          "79:       \"name TEXT,\"",
          "80:       \"wr INT,\"",
          "81:       \"subprog TEXT,\"",
          "82:       \"stmt HIDDEN\"",
          "83:    \");\"",
          "84:   };",
          "86:   rc = sqlite3_declare_vtab(db, azSchema[isTabUsed]);",
          "93:     pNew->bTablesUsed = isTabUsed*2;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:   }",
          "114:   pCur->pStmt = 0;",
          "115:   pCur->needFinalize = 0;",
          "116: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134:   pCur->zType = 0;",
          "135:   pCur->zSchema = 0;",
          "136:   pCur->zName = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "132: static int bytecodevtabNext(sqlite3_vtab_cursor *cur){",
          "133:   bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;",
          "134:   int rc;",
          "135:   if( pCur->zP4 ){",
          "136:     sqlite3_free(pCur->zP4);",
          "137:     pCur->zP4 = 0;",
          "138:   }",
          "139:   rc = sqlite3VdbeNextOpcode(",
          "140:            (Vdbe*)pCur->pStmt,",
          "141:            pCur->showSubprograms ? &pCur->sub : 0,",
          "143:            &pCur->iRowid,",
          "144:            &pCur->iAddr,",
          "145:            &pCur->aOp);",
          "",
          "[Removed Lines]",
          "142:            0,",
          "",
          "[Added Lines]",
          "155:   bytecodevtab *pTab = (bytecodevtab*)cur->pVtab;",
          "161:   if( pCur->zName ){",
          "162:     pCur->zName = 0;",
          "163:     pCur->zType = 0;",
          "164:     pCur->zSchema = 0;",
          "165:   }",
          "169:            pTab->bTablesUsed,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "170: ){",
          "171:   bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;",
          "173:   Op *pOp = pCur->aOp + pCur->iAddr;",
          "174:   switch( i ){",
          "176:       sqlite3_result_int(ctx, pCur->iAddr);",
          "",
          "[Removed Lines]",
          "172:   bytecodevtab *pVTab;",
          "",
          "[Added Lines]",
          "199:   bytecodevtab *pVTab = (bytecodevtab*)cur->pVtab;",
          "201:   if( pVTab->bTablesUsed ){",
          "202:     if( i==4 ){",
          "203:       i = 8;",
          "204:     }else{",
          "205:       if( i<=2 && pCur->zType==0 ){",
          "206:         Schema *pSchema;",
          "207:         HashElem *k;",
          "208:         int iDb = pOp->p3;",
          "209:         int iRoot = pOp->p2;",
          "210:         sqlite3 *db = pVTab->db;",
          "211:         pSchema = db->aDb[iDb].pSchema;",
          "212:         pCur->zSchema = db->aDb[iDb].zDbSName;",
          "213:         for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){",
          "214:           Table *pTab = (Table*)sqliteHashData(k);",
          "215:           if( !IsVirtual(pTab) && pTab->tnum==iRoot ){",
          "216:             pCur->zName = pTab->zName;",
          "217:             pCur->zType = \"table\";",
          "218:             break;",
          "219:           }",
          "220:         }",
          "221:         if( pCur->zName==0 ){",
          "222:           for(k=sqliteHashFirst(&pSchema->idxHash); k; k=sqliteHashNext(k)){",
          "223:             Index *pIdx = (Index*)sqliteHashData(k);",
          "224:             if( pIdx->tnum==iRoot ){",
          "225:               pCur->zName = pIdx->zName;",
          "226:               pCur->zType = \"index\";",
          "227:               break;",
          "228:             }",
          "229:           }",
          "230:         }",
          "231:       }",
          "232:       i += 10;",
          "233:     }",
          "234:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "190:       break;",
          "194:       if( pCur->zP4==0 ){",
          "195:         pCur->zP4 = sqlite3VdbeDisplayP4(pVTab->db, pOp);",
          "196:       }",
          "",
          "[Removed Lines]",
          "193:       pVTab = (bytecodevtab*)cur->pVtab;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "219:       }",
          "220:       break;",
          "221:     }",
          "222:   }",
          "223:   return SQLITE_OK;",
          "224: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283:       sqlite3_result_text(ctx, pCur->zType, -1, SQLITE_STATIC);",
          "284:       break;",
          "286:       sqlite3_result_text(ctx, pCur->zSchema, -1, SQLITE_STATIC);",
          "287:       break;",
          "289:       sqlite3_result_text(ctx, pCur->zName, -1, SQLITE_STATIC);",
          "290:       break;",
          "292:       sqlite3_result_int(ctx, pOp->opcode==OP_OpenWrite);",
          "293:       break;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "266:   }",
          "267:   if( pCur->pStmt==0 ){",
          "268:     pVTab->base.zErrMsg = sqlite3_mprintf(",
          "270:     );",
          "271:     rc = SQLITE_ERROR;",
          "272:   }else{",
          "",
          "[Removed Lines]",
          "269:        \"argument to bytecode() is not a valid SQL statement\"",
          "",
          "[Added Lines]",
          "341:        \"argument to %s() is not a valid SQL statement\",",
          "342:        pVTab->bTablesUsed ? \"tables_used\" : \"bytecode\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "287:   int i;",
          "288:   int rc = SQLITE_CONSTRAINT;",
          "289:   struct sqlite3_index_constraint *p;",
          "290:   pIdxInfo->estimatedCost = (double)100;",
          "291:   pIdxInfo->estimatedRows = 100;",
          "292:   pIdxInfo->idxNum = 0;",
          "293:   for(i=0, p=pIdxInfo->aConstraint; i<pIdxInfo->nConstraint; i++, p++){",
          "294:     if( p->usable==0 ) continue;",
          "296:       rc = SQLITE_OK;",
          "297:       pIdxInfo->aConstraintUsage[i].omit = 1;",
          "298:       pIdxInfo->aConstraintUsage[i].argvIndex = 1;",
          "299:     }",
          "301:       pIdxInfo->aConstraintUsage[i].omit = 1;",
          "302:       pIdxInfo->idxNum = 1;",
          "303:     }",
          "",
          "[Removed Lines]",
          "295:     if( p->op==SQLITE_INDEX_CONSTRAINT_EQ && p->iColumn==9 ){",
          "300:     if( p->op==SQLITE_INDEX_CONSTRAINT_ISNULL && p->iColumn==8 ){",
          "",
          "[Added Lines]",
          "363:   bytecodevtab *pVTab = (bytecodevtab*)tab;",
          "364:   int iBaseCol = pVTab->bTablesUsed ? 4 : 8;",
          "370:     if( p->op==SQLITE_INDEX_CONSTRAINT_EQ && p->iColumn==iBaseCol+1 ){",
          "375:     if( p->op==SQLITE_INDEX_CONSTRAINT_ISNULL && p->iColumn==iBaseCol ){",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "340: int sqlite3VdbeBytecodeVtabInit(sqlite3 *db){",
          "341:   int rc;",
          "342:   rc = sqlite3_create_module(db, \"bytecode\", &bytecodevtabModule, 0);",
          "343:   return rc;",
          "344: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "418:   if( rc==SQLITE_OK ){",
          "419:     rc = sqlite3_create_module(db, \"tables_used\", &bytecodevtabModule, &db);",
          "420:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e6068027ca584a1263d2d659f48eded07fc4a297",
      "candidate_info": {
        "commit_hash": "e6068027ca584a1263d2d659f48eded07fc4a297",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e6068027ca584a1263d2d659f48eded07fc4a297",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/main.c",
          "src/malloc.c",
          "src/sqliteInt.h",
          "src/status.c"
        ],
        "message": "Cleanup and performance enhancements for mini-lookaside.\n\nFossilOrigin-Name: 74805668430051032ae9b256c84e252755ee03075fc08293c948675ed40ec280",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/main.c||src/main.c",
          "src/malloc.c||src/malloc.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/status.c||src/status.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9c471195f6d3e4b00e2d0f909b306a4036352082dca5f016a8eece226e82163d",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "708:     sqlite3BeginBenignMalloc();",
          "710:     sqlite3EndBenignMalloc();",
          "712:   }else{",
          "713:     pStart = pBuf;",
          "714:   }",
          "715:   db->lookaside.pStart = pStart;",
          "716:   db->lookaside.pInit = 0;",
          "717:   db->lookaside.pFree = 0;",
          "727:   db->lookaside.sz = (u16)sz;",
          "728:   db->lookaside.szTrue = (u16)sz;",
          "729:   if( pStart ){",
          "730:     int i;",
          "731:     LookasideSlot *p;",
          "732:     assert( sz > (int)sizeof(LookasideSlot*) );",
          "734:     p = (LookasideSlot*)pStart;",
          "736:       p->pNext = db->lookaside.pInit;",
          "737:       db->lookaside.pInit = p;",
          "738:       p = (LookasideSlot*)&((u8*)p)[sz];",
          "739:     }",
          "740: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "741:     db->lookaside.pMiddle = p;",
          "744:       p->pNext = db->lookaside.pMiniInit;",
          "745:       db->lookaside.pMiniInit = p;",
          "747:       p = (LookasideSlot*)&((u8*)p)[MINI_SZ];",
          "748:     }",
          "750:     db->lookaside.pEnd = p;",
          "751:     db->lookaside.bDisable = 0;",
          "752:     db->lookaside.bMalloced = pBuf==0 ?1:0;",
          "753:   }else{",
          "754:     db->lookaside.pStart = db;",
          "755:     db->lookaside.pEnd = db;",
          "756:     db->lookaside.bDisable = 1;",
          "757:     db->lookaside.sz = 0;",
          "758:     db->lookaside.bMalloced = 0;",
          "759:     db->lookaside.nSlot = 0;",
          "760:   }",
          "762:   return SQLITE_OK;",
          "763: }",
          "",
          "[Removed Lines]",
          "711:     if( pStart ) cnt = sqlite3MallocSize(pStart)/sz;",
          "718: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "719:   db->lookaside.pMiniInit = 0;",
          "720:   db->lookaside.pMiniFree = 0;",
          "725:   cnt = szAlloc/(3*MINI_SZ+sz);",
          "726: #endif",
          "733:     db->lookaside.nSlot = cnt;",
          "735:     for(i=cnt-1; i>=0; i--){",
          "743:     while(p<=(LookasideSlot*)&((u8*)pStart)[szAlloc-MINI_SZ]){",
          "746:       db->lookaside.nSlot++;",
          "749: #endif",
          "",
          "[Added Lines]",
          "713:     if( pStart ) szAlloc = sqlite3MallocSize(pStart);",
          "717: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "718:   if( sz>=MINI_SZ*3 ){",
          "719:     nBig = szAlloc/(3*MINI_SZ+sz);",
          "720:     nSm = (szAlloc - sz*nBig)/MINI_SZ;",
          "721:   }else if( sz>=MINI_SZ*2 ){",
          "722:     nBig = szAlloc/(MINI_SZ+sz);",
          "723:     nSm = (szAlloc - sz*nBig)/MINI_SZ;",
          "724:   }else",
          "726:   if( sz>0 ){",
          "727:     nBig = szAlloc/sz;",
          "728:     nSm = 0;",
          "729:   }else{",
          "730:     nBig = nSm = 0;",
          "731:   }",
          "742:     for(i=0; i<nBig; i++){",
          "748:     db->lookaside.pMiniInit = 0;",
          "749:     db->lookaside.pMiniFree = 0;",
          "751:     for(i=0; i<nSm; i++){",
          "757:     assert( ((uptr)p)<=szAlloc + (uptr)pStart );",
          "761:     db->lookaside.nSlot = nBig+nSm;",
          "764: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "765:     db->lookaside.pMiniInit = 0;",
          "766:     db->lookaside.pMiniFree = 0;",
          "767:     db->lookaside.pMiddle = db;",
          "775:   assert( sqlite3LookasideUsed(db,0)==0 );",
          "",
          "---------------"
        ],
        "src/malloc.c||src/malloc.c": [
          "File: src/malloc.c -> src/malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "341: }",
          "342: int sqlite3DbMallocSize(sqlite3 *db, void *p){",
          "343:   assert( p!=0 );",
          "345: #ifdef SQLITE_DEBUG",
          "346:     if( db==0 ){",
          "347:       assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );",
          "348:       assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );",
          "",
          "[Removed Lines]",
          "344:   if( db==0 || !isLookaside(db,p) ){",
          "",
          "[Added Lines]",
          "345:   if( db==0 || !isLookaside(db,p) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "350:       assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );",
          "351:       assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );",
          "352:     }",
          "353: #endif",
          "358:   }",
          "359: }",
          "360: sqlite3_uint64 sqlite3_msize(void *p){",
          "361:   assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );",
          "",
          "[Removed Lines]",
          "354:     return sqlite3GlobalConfig.m.xSize(p);",
          "355:   }else{",
          "356:     assert( sqlite3_mutex_held(db->mutex) );",
          "357:     return lookasideMallocSize(db, p);",
          "",
          "[Added Lines]",
          "353:   }",
          "355:   if( db ){",
          "356:     if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){",
          "357: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "358:       if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){",
          "359:         assert( sqlite3_mutex_held(db->mutex) );",
          "360:         return MINI_SZ;",
          "361:       }",
          "362: #endif",
          "363:       if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){",
          "364:         assert( sqlite3_mutex_held(db->mutex) );",
          "365:         return db->lookaside.szTrue;",
          "366:       }",
          "367:     }",
          "369:   return sqlite3GlobalConfig.m.xSize(p);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "402:       measureAllocationSize(db, p);",
          "403:       return;",
          "404:     }",
          "407: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "413:         pBuf->pNext = db->lookaside.pMiniFree;",
          "414:         db->lookaside.pMiniFree = pBuf;",
          "415:         return;",
          "416:       }",
          "418: #ifdef SQLITE_DEBUG",
          "421: #endif",
          "425:     }",
          "426:   }",
          "427:   assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );",
          "",
          "[Removed Lines]",
          "405:     if( isLookaside(db, p) ){",
          "406:       LookasideSlot *pBuf = (LookasideSlot*)p;",
          "408:       if( p>=db->lookaside.pMiddle ){",
          "409: # ifdef SQLITE_DEBUG",
          "411:         memset(p, 0xaa, MINI_SZ);",
          "412: # endif",
          "417: #endif",
          "420:       memset(p, 0xaa, db->lookaside.szTrue);",
          "422:       pBuf->pNext = db->lookaside.pFree;",
          "423:       db->lookaside.pFree = pBuf;",
          "424:       return;",
          "",
          "[Added Lines]",
          "416:     if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){",
          "418:       if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){",
          "419:         LookasideSlot *pBuf = (LookasideSlot*)p;",
          "420: #ifdef SQLITE_DEBUG",
          "422: #endif",
          "428:       if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){",
          "429:         LookasideSlot *pBuf = (LookasideSlot*)p;",
          "433:         pBuf->pNext = db->lookaside.pFree;",
          "434:         db->lookaside.pFree = pBuf;",
          "435:         return;",
          "436:       }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "585:     }",
          "586:     return dbMallocRawFinish(db, n);",
          "587:   }",
          "589:   if( n<=MINI_SZ ){",
          "590:     if( (pBuf = db->lookaside.pMiniFree)!=0 ){",
          "591:       db->lookaside.pMiniFree = pBuf->pNext;",
          "",
          "[Removed Lines]",
          "588: # ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "",
          "[Added Lines]",
          "600: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "597:       return (void*)pBuf;",
          "598:     }",
          "599:   }",
          "601:   if( (pBuf = db->lookaside.pFree)!=0 ){",
          "602:     db->lookaside.pFree = pBuf->pNext;",
          "603:     db->lookaside.anStat[0]++;",
          "",
          "[Removed Lines]",
          "600: # endif",
          "",
          "[Added Lines]",
          "612: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "631:   assert( db!=0 );",
          "632:   if( p==0 ) return sqlite3DbMallocRawNN(db, n);",
          "633:   assert( sqlite3_mutex_held(db->mutex) );",
          "635:   return dbReallocFinish(db, p, n);",
          "636: }",
          "637: static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){",
          "",
          "[Removed Lines]",
          "634:   if( isLookaside(db,p) && n<lookasideMallocSize(db, p) ) return p;",
          "",
          "[Added Lines]",
          "646:   if( ((uptr)p)<(uptr)db->lookaside.pEnd ){",
          "647: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "648:     if( ((uptr)p)>=(uptr)db->lookaside.pMiddle ){",
          "649:       if( n<=MINI_SZ ) return p;",
          "650:     }else",
          "651: #endif",
          "652:     if( ((uptr)p)>=(uptr)db->lookaside.pStart ){",
          "653:       if( n<=db->lookaside.szTrue ) return p;",
          "654:     }",
          "655:   }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1290: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "1297: };",
          "",
          "[Removed Lines]",
          "1294: #endif",
          "",
          "[Added Lines]",
          "1312:   void *pMiddle;          /* First byte past end of full-size buffers and",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1304:    db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue",
          "",
          "[Removed Lines]",
          "1307: #define MINI_SZ           128",
          "",
          "[Added Lines]",
          "1327: #ifdef SQLITE_OMIT_MINI_LOOKASIDE",
          "1328: #  define MINI_SZ           0",
          "1329: #else",
          "1330: #  define MINI_SZ         128",
          "1331: #endif",
          "",
          "---------------"
        ],
        "src/status.c||src/status.c": [
          "File: src/status.c -> src/status.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "191: #ifndef SQLITE_OMIT_MINI_LOOKASIDE",
          "192:   nInit += countLookasideSlots(db->lookaside.pMiniInit);",
          "193:   nFree += countLookasideSlots(db->lookaside.pMiniFree);",
          "195:   if( pHighwater ) *pHighwater = db->lookaside.nSlot - nInit;",
          "196:   return db->lookaside.nSlot - (nInit+nFree);",
          "197: }",
          "",
          "[Removed Lines]",
          "194: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "db5ed35609338f6960975433ed16cb86dfd4fc0f",
      "candidate_info": {
        "commit_hash": "db5ed35609338f6960975433ed16cb86dfd4fc0f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/db5ed35609338f6960975433ed16cb86dfd4fc0f",
        "files": [
          "ext/fts5/fts5_config.c",
          "ext/fts5/test/fts5eb.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Avoid a buffer overread in fts5 that could occur when parsing corrupt configuration records.\n\nFossilOrigin-Name: 355afd77df21a2265871ca6d075f26b1fa121c7c2682cf512281944ff0c2186d",
        "before_after_code_files": [
          "ext/fts5/fts5_config.c||ext/fts5/fts5_config.c",
          "ext/fts5/test/fts5eb.test||ext/fts5/test/fts5eb.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/fts5_config.c||ext/fts5/fts5_config.c": [
          "File: ext/fts5/fts5_config.c -> ext/fts5/fts5_config.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:   assert( q=='[' || q=='\\'' || q=='\"' || q=='`' );",
          "151:   if( q=='[' ) q = ']';",
          "154:     if( z[iIn]==q ){",
          "155:       if( z[iIn+1]!=q ){",
          "",
          "[Removed Lines]",
          "153:   while( ALWAYS(z[iIn]) ){",
          "",
          "[Added Lines]",
          "153:   while( z[iIn] ){",
          "",
          "---------------"
        ],
        "ext/fts5/test/fts5eb.test||ext/fts5/test/fts5eb.test": [
          "File: ext/fts5/test/fts5eb.test -> ext/fts5/test/fts5eb.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:   SELECT fts5_expr(NULL, NULL)",
          "76: } {1 {parse error in \"\"}}",
          "79: do_execsql_test 3.0 {",
          "80:   CREATE VIRTUAL TABLE e1 USING fts5(text, tokenize = 'porter unicode61');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78: for {set i 0} {$i < 255} {incr i} {",
          "79:   do_test 2.6.$i {",
          "80:     lindex [catchsql {sELECT fts5_expr(NULL, char($i));}] 0",
          "81:   } 1",
          "82: }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: d47d66e3d360d8aa6203a855228d2bc40d9a00d69c15f5066b7632d8fb1ed2cc",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ca74fbf6f164ad6fa9c6bd79050dc57cdcd69388",
      "candidate_info": {
        "commit_hash": "ca74fbf6f164ad6fa9c6bd79050dc57cdcd69388",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ca74fbf6f164ad6fa9c6bd79050dc57cdcd69388",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c",
          "src/treeview.c"
        ],
        "message": "Improvements to parse-tree tracing logic.  No changes in deliverable code.\n\nFossilOrigin-Name: f7e5a68a7ebbb97a5beb050a75b3b4cf2fd6adc54653da993a8950fb3a5799f7",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c",
          "src/treeview.c||src/treeview.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: efdbb2b499bda8ffcfe54f5d6ece08a2c58fe7a490d9550785d806bd404abb8c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6422: #if SELECTTRACE_ENABLED",
          "6423:     if( sqlite3SelectTrace & 0x400 ){",
          "6424:       int ii;",
          "6426:       sqlite3TreeViewSelect(0, p, 0);",
          "6427:       for(ii=0; ii<sAggInfo.nColumn; ii++){",
          "6428:         sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",",
          "",
          "[Removed Lines]",
          "6425:       SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));",
          "",
          "[Added Lines]",
          "6425:       SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis %p:\\n\", &sAggInfo));",
          "",
          "---------------"
        ],
        "src/treeview.c||src/treeview.c": [
          "File: src/treeview.c -> src/treeview.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "582: #endif",
          "583:       }",
          "584:       if( pExpr->op==TK_AGG_FUNCTION ){",
          "587:       }else if( pExpr->op2!=0 ){",
          "588:         const char *zOp2;",
          "589:         char zBuf[8];",
          "",
          "[Removed Lines]",
          "585:         sqlite3TreeViewLine(pView, \"AGG_FUNCTION%d %Q%s\",",
          "586:                              pExpr->op2, pExpr->u.zToken, zFlgs);",
          "",
          "[Added Lines]",
          "585:         sqlite3TreeViewLine(pView, \"AGG_FUNCTION%d %Q%s iAgg=%d agg=%p\",",
          "586:                              pExpr->op2, pExpr->u.zToken, zFlgs,",
          "587:                              pExpr->iAgg, pExpr->pAggInfo);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
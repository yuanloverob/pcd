{
  "cve_id": "CVE-2012-2330",
  "cve_desc": "The Update method in src/node_http_parser.cc in Node.js before 0.6.17 and 0.7 before 0.7.8 does not properly check the length of a string, which allows remote attackers to obtain sensitive information (request header contents) and possibly spoof HTTP headers via a zero length string.",
  "repo": "joyent/node",
  "patch_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
  "patch_info": {
    "commit_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
    "repo": "joyent/node",
    "commit_url": "https://github.com/joyent/node/commit/c9a231d",
    "files": [
      "src/node_http_parser.cc"
    ],
    "message": "typo in node_http_parser",
    "before_after_code_files": [
      "src/node_http_parser.cc||src/node_http_parser.cc"
    ]
  },
  "patch_diff": {
    "src/node_http_parser.cc||src/node_http_parser.cc": [
      "File: src/node_http_parser.cc -> src/node_http_parser.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:   void Update(const char* str, size_t size) {",
      "192:     if (str_ == NULL)",
      "193:       str_ = str;",
      "197:       char* s = new char[size_ + size];",
      "",
      "[Removed Lines]",
      "194:     else if (on_heap_ || str_ + size != str) {",
      "",
      "[Added Lines]",
      "194:     else if (on_heap_ || str_ + size_ != str) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "80ab9a891aa502458c4689dd1bf0bee7a428eae1",
      "candidate_info": {
        "commit_hash": "80ab9a891aa502458c4689dd1bf0bee7a428eae1",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/80ab9a891aa502458c4689dd1bf0bee7a428eae1",
        "files": [
          "deps/uv/include/uv-private/uv-win.h",
          "deps/uv/include/uv.h",
          "deps/uv/src/unix/sunos.c",
          "deps/uv/src/win/fs.c",
          "deps/uv/src/win/process-stdio.c",
          "deps/uv/src/win/winapi.h",
          "deps/uv/test/test-tcp-unexpected-read.c"
        ],
        "message": "uv: upgrade to 69c2ef8",
        "before_after_code_files": [
          "deps/uv/include/uv-private/uv-win.h||deps/uv/include/uv-private/uv-win.h",
          "deps/uv/include/uv.h||deps/uv/include/uv.h",
          "deps/uv/src/unix/sunos.c||deps/uv/src/unix/sunos.c",
          "deps/uv/src/win/fs.c||deps/uv/src/win/fs.c",
          "deps/uv/src/win/process-stdio.c||deps/uv/src/win/process-stdio.c",
          "deps/uv/src/win/winapi.h||deps/uv/src/win/winapi.h",
          "deps/uv/test/test-tcp-unexpected-read.c||deps/uv/test/test-tcp-unexpected-read.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/uv/include/uv-private/uv-win.h||deps/uv/include/uv-private/uv-win.h": [
          "File: deps/uv/include/uv-private/uv-win.h -> deps/uv/include/uv-private/uv-win.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: # define _WIN32_WINNT   0x0502",
          "24: #endif",
          "26: #include <process.h>",
          "27: #include <stdint.h>",
          "28: #include <winsock2.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)",
          "27: typedef intptr_t ssize_t;",
          "28: # define _SSIZE_T_",
          "29: # define _SSIZE_T_DEFINED",
          "30: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "470:   int flags;                              \\",
          "471:   DWORD sys_errno_;                       \\",
          "472:   union {                                 \\",
          "475:   };                                      \\",
          "476:   union {                                 \\",
          "477:     struct {                              \\",
          "478:       int mode;                           \\",
          "480:       int file_flags;                     \\",
          "482:       void* buf;                          \\",
          "483:       size_t length;                      \\",
          "484:       int64_t offset;                     \\",
          "",
          "[Removed Lines]",
          "473:     wchar_t* pathw;                       \\",
          "474:     int file;                             \\",
          "479:       wchar_t* new_pathw;                 \\",
          "481:       int file_out;                       \\",
          "",
          "[Added Lines]",
          "480:     WCHAR* pathw;                         \\",
          "481:     int fd;                               \\",
          "486:       WCHAR* new_pathw;                   \\",
          "488:       int fd_out;                         \\",
          "",
          "---------------"
        ],
        "deps/uv/include/uv.h||deps/uv/include/uv.h": [
          "File: deps/uv/include/uv.h -> deps/uv/include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #include \"ares.h\"",
          "66: #if defined(__unix__) || defined(__POSIX__) || defined(__APPLE__)",
          "67: # include \"uv-private/uv-unix.h\"",
          "68: #else",
          "",
          "[Removed Lines]",
          "60: #if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)",
          "61:   typedef intptr_t ssize_t;",
          "62: # define _SSIZE_T_",
          "63: # define _SSIZE_T_DEFINED",
          "64: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1410:   uv_fs_cb cb;",
          "1411:   ssize_t result;",
          "1412:   void* ptr;",
          "1415:   UV_FS_PRIVATE_FIELDS",
          "1416: };",
          "",
          "[Removed Lines]",
          "1413:   char* path;",
          "1414:   int errorno;",
          "",
          "[Added Lines]",
          "1407:   const char* path;",
          "1408:   uv_err_code errorno;",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/sunos.c||deps/uv/src/unix/sunos.c": [
          "File: deps/uv/src/unix/sunos.c -> deps/uv/src/unix/sunos.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "131: static void uv__fs_event_read(EV_P_ ev_io* w, int revents) {",
          "133:   uv_loop_t *loop_;",
          "134:   timespec_t timeout;",
          "135:   port_event_t pe;",
          "",
          "[Removed Lines]",
          "132:   uv_fs_event_t *handle;",
          "",
          "[Added Lines]",
          "132:   uv_fs_event_t *handle = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:   loop_ = container_of(w, uv_loop_t, fs_event_watcher);",
          "141:   do {",
          "143:     do {",
          "144:       memset(&timeout, 0, sizeof timeout);",
          "146:     }",
          "147:     while (r == -1 && errno == EINTR);",
          "150:       break;",
          "151:     handle = (uv_fs_event_t *)pe.portev_user;",
          "152:     assert((r == 0) && \"unexpected port_get() error\");",
          "",
          "[Removed Lines]",
          "145:       r = port_get(loop_->fs_fd, &pe, &timeout);",
          "149:     if (r == -1 && errno == ETIME)",
          "",
          "[Added Lines]",
          "142:     uint_t n = 1;",
          "154:       r = port_getn(loop_->fs_fd, &pe, 1, &n, &timeout);",
          "158:     if ((r == -1 && errno == ETIME) || n == 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "162:   }",
          "163:   while (handle->fd != PORT_DELETED);",
          "166:     uv__fs_event_rearm(handle);",
          "167: }",
          "",
          "[Removed Lines]",
          "165:   if (handle->fd != PORT_DELETED)",
          "",
          "[Added Lines]",
          "175:   if (handle != NULL && handle->fd != PORT_DELETED)",
          "",
          "---------------"
        ],
        "deps/uv/src/win/fs.c||deps/uv/src/win/fs.c": [
          "File: deps/uv/src/win/fs.c -> deps/uv/src/win/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #include \"req-inl.h\"",
          "41: #define UV_FS_FREE_PTR           0x0008",
          "42: #define UV_FS_CLEANEDUP          0x0010",
          "56: #define QUEUE_FS_TP_JOB(loop, req)                                          \\",
          "57:   if (!QueueUserWorkItem(&uv_fs_thread_proc,                                \\",
          "58:                          req,                                               \\",
          "",
          "[Removed Lines]",
          "38: #define UV_FS_ASYNC_QUEUED       0x0001",
          "39: #define UV_FS_FREE_PATH          0x0002",
          "40: #define UV_FS_FREE_NEW_PATH      0x0004",
          "45: #define UTF8_TO_UTF16(s, t)                                                 \\",
          "46:   size = uv_utf8_to_utf16(s, NULL, 0) * sizeof(wchar_t);                    \\",
          "47:   t = (wchar_t*)malloc(size);                                               \\",
          "48:   if (!t) {                                                                 \\",
          "49:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");                            \\",
          "50:   }                                                                         \\",
          "51:   if (!uv_utf8_to_utf16(s, t, size / sizeof(wchar_t))) {                    \\",
          "52:     uv__set_sys_error(loop, GetLastError());                                \\",
          "53:     return -1;                                                              \\",
          "54:   }",
          "",
          "[Added Lines]",
          "38: #define UV_FS_FREE_PATHS         0x0002",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:     uv__set_sys_error((loop), GetLastError());                              \\",
          "61:     return -1;                                                              \\",
          "62:   }                                                                         \\",
          "64:   uv__req_register(loop, req);",
          "66: #define SET_UV_LAST_ERROR_FROM_REQ(req)                                     \\",
          "",
          "[Removed Lines]",
          "63:   req->flags |= UV_FS_ASYNC_QUEUED;                                         \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83:   req->sys_errno_ = (sys_errno);                                            \\",
          "84:   req->errorno = (uv_errno);",
          "88:     req->result = -1;                                                       \\",
          "89:     req->errorno = UV_EBADF;                                                \\",
          "90:     req->sys_errno_ = ERROR_INVALID_HANDLE;                                 \\",
          "",
          "[Removed Lines]",
          "86: #define VERIFY_UV_FILE(file, req)                                           \\",
          "87:   if (file == -1) {                                                         \\",
          "",
          "[Added Lines]",
          "72: #define VERIFY_FD(fd, req)                                                  \\",
          "73:   if (fd == -1) {                                                           \\",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "105: #define IS_LETTER(c) (((c) >= L'a' && (c) <= L'z') || \\",
          "106:   ((c) >= L'A' && (c) <= L'Z'))",
          "115: void uv_fs_init() {",
          "",
          "[Removed Lines]",
          "108: const wchar_t JUNCTION_PREFIX[] = L\"\\\\??\\\\\";",
          "109: const wchar_t JUNCTION_PREFIX_LEN = 4;",
          "111: const wchar_t LONG_PATH_PREFIX[] = L\"\\\\\\\\?\\\\\";",
          "112: const wchar_t LONG_PATH_PREFIX_LEN = 4;",
          "",
          "[Added Lines]",
          "94: const WCHAR JUNCTION_PREFIX[] = L\"\\\\??\\\\\";",
          "95: const WCHAR JUNCTION_PREFIX_LEN = 4;",
          "97: const WCHAR LONG_PATH_PREFIX[] = L\"\\\\\\\\?\\\\\";",
          "98: const WCHAR LONG_PATH_PREFIX_LEN = 4;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "117: }",
          "135: }",
          "140:   uv_req_init(loop, (uv_req_t*) req);",
          "141:   req->type = UV_FS;",
          "142:   req->loop = loop;",
          "143:   req->flags = 0;",
          "144:   req->fs_type = fs_type;",
          "145:   req->result = 0;",
          "146:   req->ptr = NULL;",
          "147:   req->path = NULL;",
          "150: }",
          "154:   DWORD attr = GetFileAttributesW(path);",
          "156:   if (attr != INVALID_FILE_ATTRIBUTES) {",
          "",
          "[Removed Lines]",
          "120: static void uv_fs_req_init_async(uv_loop_t* loop, uv_fs_t* req,",
          "121:     uv_fs_type fs_type, const char* path, const wchar_t* pathw, uv_fs_cb cb) {",
          "122:   uv_req_init(loop, (uv_req_t*) req);",
          "123:   req->type = UV_FS;",
          "124:   req->loop = loop;",
          "125:   req->flags = 0;",
          "126:   req->fs_type = fs_type;",
          "127:   req->cb = cb;",
          "128:   req->result = 0;",
          "129:   req->ptr = NULL;",
          "130:   req->path = path ? strdup(path) : NULL;",
          "131:   req->pathw = (wchar_t*)pathw;",
          "132:   req->errorno = 0;",
          "133:   req->sys_errno_ = 0;",
          "134:   memset(&req->overlapped, 0, sizeof(req->overlapped));",
          "138: static void uv_fs_req_init_sync(uv_loop_t* loop, uv_fs_t* req,",
          "139:     uv_fs_type fs_type) {",
          "148:   req->pathw = NULL;",
          "149:   req->errorno = 0;",
          "153: static int is_path_dir(const wchar_t* path) {",
          "",
          "[Added Lines]",
          "106: INLINE static int fs__capture_path(uv_loop_t* loop, uv_fs_t* req,",
          "107:     const char* path, const char* new_path, const int copy_path) {",
          "108:   char* buf;",
          "109:   char* pos;",
          "110:   ssize_t buf_sz = 0, path_len, pathw_len, new_pathw_len;",
          "113:   assert(new_path == NULL || path != NULL);",
          "115:   if (path != NULL) {",
          "116:     pathw_len = MultiByteToWideChar(CP_UTF8,",
          "117:                                     0,",
          "118:                                     path,",
          "119:                                     -1,",
          "120:                                     NULL,",
          "121:                                     0);",
          "122:     if (pathw_len == 0) {",
          "123:       uv__set_sys_error(loop, GetLastError());",
          "124:       return -1;",
          "125:     }",
          "127:     buf_sz += pathw_len * sizeof(WCHAR);",
          "128:   }",
          "130:   if (path != NULL && copy_path) {",
          "131:     path_len = 1 + strlen(path);",
          "132:     buf_sz += path_len;",
          "133:   }",
          "135:   if (new_path != NULL) {",
          "136:     new_pathw_len = MultiByteToWideChar(CP_UTF8,",
          "137:                                         0,",
          "138:                                         new_path,",
          "139:                                         -1,",
          "140:                                         NULL,",
          "141:                                         0);",
          "142:     if (new_pathw_len == 0) {",
          "143:       uv__set_sys_error(loop, GetLastError());",
          "144:       return -1;",
          "145:     }",
          "147:     buf_sz += new_pathw_len * sizeof(WCHAR);",
          "148:   }",
          "151:   if (buf_sz == 0) {",
          "152:     req->pathw = NULL;",
          "153:     req->new_pathw = NULL;",
          "154:     req->path = NULL;",
          "155:     return 0;",
          "156:   }",
          "158:   buf = (char*) malloc(buf_sz);",
          "159:   if (buf == NULL) {",
          "160:     uv__set_artificial_error(loop, UV_ENOMEM);",
          "161:     return -1;",
          "162:   }",
          "164:   pos = buf;",
          "166:   if (path != NULL) {",
          "167:     DWORD r = MultiByteToWideChar(CP_UTF8,",
          "168:                                   0,",
          "169:                                   path,",
          "170:                                   -1,",
          "171:                                   (WCHAR*) pos,",
          "172:                                   pathw_len);",
          "173:     assert(r == pathw_len);",
          "174:     req->pathw = (WCHAR*) pos;",
          "175:     pos += r * sizeof(WCHAR);",
          "176:   } else {",
          "177:     req->pathw = NULL;",
          "178:   }",
          "180:   if (new_path != NULL) {",
          "181:     DWORD r = MultiByteToWideChar(CP_UTF8,",
          "182:                                   0,",
          "183:                                   new_path,",
          "184:                                   -1,",
          "185:                                   (WCHAR*) pos,",
          "186:                                   new_pathw_len);",
          "187:     assert(r == new_pathw_len);",
          "188:     req->new_pathw = (WCHAR*) pos;",
          "189:     pos += r * sizeof(WCHAR);",
          "190:   } else {",
          "191:     req->new_pathw = NULL;",
          "192:   }",
          "194:   if (!copy_path) {",
          "195:     req->path = path;",
          "196:   } else if (path) {",
          "197:     memcpy(pos, path, path_len);",
          "198:     assert(path_len == buf_sz - (pos - buf));",
          "199:     req->path = pos;",
          "200:   } else {",
          "201:     req->path = NULL;",
          "202:   }",
          "204:   req->flags |= UV_FS_FREE_PATHS;",
          "206:   return 0;",
          "211: INLINE static void uv_fs_req_init(uv_loop_t* loop, uv_fs_t* req,",
          "212:     uv_fs_type fs_type, const uv_fs_cb cb) {",
          "221:   req->errorno = UV_OK;",
          "224:   if (cb != NULL) {",
          "225:     req->cb = cb;",
          "226:     memset(&req->overlapped, 0, sizeof(req->overlapped));",
          "227:   }",
          "231: static int is_path_dir(const WCHAR* path) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "231:         (reparse_data->MountPointReparseBuffer.SubstituteNameOffset /",
          "232:         sizeof(WCHAR));",
          "233:     w_target_len = reparse_data->MountPointReparseBuffer.SubstituteNameLength /",
          "",
          "[Removed Lines]",
          "234:         sizeof(wchar_t);",
          "",
          "[Added Lines]",
          "312:         sizeof(WCHAR);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "261:     return -1;",
          "262:   }",
          "275:   }",
          "",
          "[Removed Lines]",
          "265:   target_len = WideCharToMultiByte(CP_UTF8,",
          "266:                                    0,",
          "267:                                    w_target,",
          "268:                                    w_target_len,",
          "269:                                    NULL,",
          "270:                                    0,",
          "271:                                    NULL,",
          "272:                                    NULL);",
          "273:   if (target_len == 0) {",
          "274:     return -1;",
          "",
          "[Added Lines]",
          "343:   if (target_ptr != NULL || target_len_ptr != NULL) {",
          "345:     target_len = WideCharToMultiByte(CP_UTF8,",
          "346:                                      0,",
          "347:                                      w_target,",
          "348:                                      w_target_len,",
          "349:                                      NULL,",
          "350:                                      0,",
          "351:                                      NULL,",
          "352:                                      NULL);",
          "353:     if (target_len == 0) {",
          "354:       return -1;",
          "355:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "305: }",
          "309:   DWORD access;",
          "310:   DWORD share;",
          "311:   DWORD disposition;",
          "312:   DWORD attributes;",
          "313:   HANDLE file;",
          "314:   int result, current_umask;",
          "",
          "[Removed Lines]",
          "308: void fs__open(uv_fs_t* req, const wchar_t* path, int flags, int mode) {",
          "",
          "[Added Lines]",
          "389: void fs__open(uv_fs_t* req) {",
          "396:   int flags = req->file_flags;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "374:   attributes = FILE_ATTRIBUTE_NORMAL;",
          "375:   if (flags & _O_CREAT) {",
          "377:       attributes |= FILE_ATTRIBUTE_READONLY;",
          "378:     }",
          "379:   }",
          "",
          "[Removed Lines]",
          "376:     if (!((mode & ~current_umask) & _S_IWRITE)) {",
          "",
          "[Added Lines]",
          "458:     if (!((req->mode & ~current_umask) & _S_IWRITE)) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "405:   attributes |= FILE_FLAG_BACKUP_SEMANTICS;",
          "408:                      access,",
          "409:                      share,",
          "410:                      NULL,",
          "",
          "[Removed Lines]",
          "407:   file = CreateFileW(path,",
          "",
          "[Added Lines]",
          "489:   file = CreateFileW(req->pathw,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "423:     }",
          "424:     return;",
          "425:   }",
          "427: end:",
          "428:   SET_REQ_RESULT(req, result);",
          "429: }",
          "432:   int result;",
          "437:   SET_REQ_RESULT(req, result);",
          "438: }",
          "443:   HANDLE handle;",
          "444:   OVERLAPPED overlapped, *overlapped_ptr;",
          "445:   LARGE_INTEGER offset_;",
          "446:   DWORD bytes;",
          "447:   DWORD error;",
          "452:   if (handle == INVALID_HANDLE_VALUE) {",
          "453:     SET_REQ_RESULT(req, -1);",
          "454:     return;",
          "",
          "[Removed Lines]",
          "426:   result = _open_osfhandle((intptr_t)file, flags);",
          "431: void fs__close(uv_fs_t* req, uv_file file) {",
          "434:   VERIFY_UV_FILE(file, req);",
          "436:   result = _close(file);",
          "441: void fs__read(uv_fs_t* req, uv_file file, void *buf, size_t length,",
          "442:     int64_t offset) {",
          "449:   VERIFY_UV_FILE(file, req);",
          "451:   handle = (HANDLE) _get_osfhandle(file);",
          "",
          "[Added Lines]",
          "508:   result = _open_osfhandle((intptr_t) file, flags);",
          "513: void fs__close(uv_fs_t* req) {",
          "514:   int fd = req->fd;",
          "517:   VERIFY_FD(fd, req);",
          "519:   result = _close(fd);",
          "524: void fs__read(uv_fs_t* req) {",
          "525:   int fd = req->fd;",
          "526:   size_t length = req->length;",
          "527:   int64_t offset = req->offset;",
          "534:   VERIFY_FD(fd, req);",
          "536:   handle = (HANDLE) _get_osfhandle(fd);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "471:     overlapped_ptr = NULL;",
          "472:   }",
          "475:     SET_REQ_RESULT(req, bytes);",
          "476:   } else {",
          "477:     error = GetLastError();",
          "",
          "[Removed Lines]",
          "474:   if (ReadFile(handle, buf, length, &bytes, overlapped_ptr)) {",
          "",
          "[Added Lines]",
          "559:   if (ReadFile(handle, req->buf, req->length, &bytes, overlapped_ptr)) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "484: }",
          "489:   HANDLE handle;",
          "490:   OVERLAPPED overlapped, *overlapped_ptr;",
          "491:   LARGE_INTEGER offset_;",
          "492:   DWORD bytes;",
          "497:   if (handle == INVALID_HANDLE_VALUE) {",
          "498:     SET_REQ_RESULT(req, -1);",
          "499:     return;",
          "",
          "[Removed Lines]",
          "487: void fs__write(uv_fs_t* req, uv_file file, void *buf, size_t length,",
          "488:     int64_t offset) {",
          "494:   VERIFY_UV_FILE(file, req);",
          "496:   handle = (HANDLE) _get_osfhandle(file);",
          "",
          "[Added Lines]",
          "572: void fs__write(uv_fs_t* req) {",
          "573:   int fd = req->fd;",
          "574:   size_t length = req->length;",
          "575:   int64_t offset = req->offset;",
          "581:   VERIFY_FD(fd, req);",
          "583:   handle = (HANDLE) _get_osfhandle(fd);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "516:     overlapped_ptr = NULL;",
          "517:   }",
          "520:     SET_REQ_RESULT(req, bytes);",
          "521:   } else {",
          "522:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "",
          "[Removed Lines]",
          "519:   if (WriteFile(handle, buf, length, &bytes, overlapped_ptr)) {",
          "",
          "[Added Lines]",
          "606:   if (WriteFile(handle, req->buf, length, &bytes, overlapped_ptr)) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "524: }",
          "529:   SET_REQ_RESULT(req, result);",
          "530: }",
          "535:   HANDLE handle;",
          "536:   BY_HANDLE_FILE_INFORMATION info;",
          "542:                        NULL,",
          "543:                        OPEN_EXISTING,",
          "544:                        FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,",
          "",
          "[Removed Lines]",
          "527: void fs__rmdir(uv_fs_t* req, const wchar_t* path) {",
          "528:   int result = _wrmdir(path);",
          "533: void fs__unlink(uv_fs_t* req, const wchar_t* path) {",
          "534:   int result;",
          "537:   int is_dir_symlink;",
          "539:   handle = CreateFileW(path,",
          "540:                        0,",
          "541:                        0,",
          "",
          "[Added Lines]",
          "614: void fs__rmdir(uv_fs_t* req) {",
          "615:   int result = _wrmdir(req->pathw);",
          "620: void fs__unlink(uv_fs_t* req) {",
          "621:   const WCHAR* pathw = req->pathw;",
          "624:   FILE_DISPOSITION_INFORMATION disposition;",
          "625:   IO_STATUS_BLOCK iosb;",
          "626:   NTSTATUS status;",
          "628:   handle = CreateFileW(pathw,",
          "629:                        FILE_READ_ATTRIBUTES | DELETE,",
          "630:                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "555:     return;",
          "556:   }",
          "566:   } else {",
          "569:   }",
          "570: }",
          "575:   SET_REQ_RESULT(req, result);",
          "576: }",
          "580:   int result, size;",
          "582:   HANDLE dir;",
          "585:   size_t buf_char_len = 4096;",
          "593:     req->result = -1;",
          "594:     req->errorno = UV_ENOTDIR;",
          "595:     req->sys_errno_ = ERROR_SUCCESS;",
          "596:     return;",
          "597:   }",
          "600:   if (!path2) {",
          "601:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "602:   }",
          "604: #ifdef _MSC_VER",
          "606: #else",
          "608: #endif",
          "609:   dir = FindFirstFileW(path2, &ent);",
          "610:   free(path2);",
          "",
          "[Removed Lines]",
          "558:   is_dir_symlink = (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&",
          "559:                    (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT);",
          "561:   CloseHandle(handle);",
          "564:   if (is_dir_symlink) {",
          "565:     fs__rmdir(req, path);",
          "567:     result = _wunlink(path);",
          "568:     SET_REQ_RESULT(req, result);",
          "573: void fs__mkdir(uv_fs_t* req, const wchar_t* path, int mode) {",
          "574:   int result = _wmkdir(path);",
          "579: void fs__readdir(uv_fs_t* req, const wchar_t* path, int flags) {",
          "581:   wchar_t* buf = NULL, *ptr, *name;",
          "583:   WIN32_FIND_DATAW ent = {0};",
          "584:   size_t len = wcslen(path);",
          "586:   wchar_t* path2;",
          "587:   const wchar_t* fmt = !len                                         ? L\"./*\"",
          "588:                 : (path[len - 1] == L'/' || path[len - 1] == L'\\\\') ? L\"%s*\"",
          "589:                 :                                                     L\"%s\\\\*\";",
          "592:   if (!(GetFileAttributesW(path) & FILE_ATTRIBUTE_DIRECTORY)) {",
          "599:   path2 = (wchar_t*)malloc(sizeof(wchar_t) * (len + 4));",
          "605:   swprintf(path2, len + 3, fmt, path);",
          "607:   swprintf(path2, fmt, path);",
          "",
          "[Added Lines]",
          "647:   if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {",
          "653:     if (!(info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {",
          "654:       SET_REQ_WIN32_ERROR(req, ERROR_ACCESS_DENIED);",
          "655:       CloseHandle(handle);",
          "656:       return;",
          "657:     }",
          "661:     if (fs__readlink_handle(handle, NULL, NULL) < 0) {",
          "662:       DWORD error = GetLastError();",
          "663:       if (error == ERROR_SYMLINK_NOT_SUPPORTED)",
          "664:         error = ERROR_ACCESS_DENIED;",
          "665:       SET_REQ_WIN32_ERROR(req, error);",
          "666:       CloseHandle(handle);",
          "667:       return;",
          "668:     }",
          "669:   }",
          "672:   disposition.DeleteFile = TRUE;",
          "673:   status = pNtSetInformationFile(handle,",
          "674:                                  &iosb,",
          "675:                                  &disposition,",
          "676:                                  sizeof disposition,",
          "677:                                  FileDispositionInformation);",
          "678:   if (NT_SUCCESS(status)) {",
          "679:     SET_REQ_SUCCESS(req);",
          "681:     SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(status));",
          "684:   CloseHandle(handle);",
          "688: void fs__mkdir(uv_fs_t* req) {",
          "690:   int result = _wmkdir(req->pathw);",
          "695: void fs__readdir(uv_fs_t* req) {",
          "696:   WCHAR* pathw = req->pathw;",
          "697:   size_t len = wcslen(pathw);",
          "699:   WCHAR* buf = NULL, *ptr, *name;",
          "701:   WIN32_FIND_DATAW ent = { 0 };",
          "703:   WCHAR* path2;",
          "704:   const WCHAR* fmt;",
          "706:   if (len == 0) {",
          "707:     fmt = L\"./*\";",
          "708:   } else if (pathw[len - 1] == L'/' || pathw[len - 1] == L'\\\\') {",
          "709:     fmt = L\"%s*\";",
          "710:   } else {",
          "711:     fmt = L\"%s\\\\*\";",
          "712:   }",
          "715:   if (!(GetFileAttributesW(pathw) & FILE_ATTRIBUTE_DIRECTORY)) {",
          "722:   path2 = (WCHAR*)malloc(sizeof(WCHAR) * (len + 4));",
          "728:   swprintf(path2, len + 3, fmt, pathw);",
          "730:   swprintf(path2, fmt, pathw);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "623:       len = wcslen(name);",
          "625:       if (!buf) {",
          "627:         if (!buf) {",
          "628:           uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "629:         }",
          "",
          "[Removed Lines]",
          "626:         buf = (wchar_t*)malloc(buf_char_len * sizeof(wchar_t));",
          "",
          "[Added Lines]",
          "749:         buf = (WCHAR*)malloc(buf_char_len * sizeof(WCHAR));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "634:       while ((ptr - buf) + len + 1 > buf_char_len) {",
          "635:         buf_char_len *= 2;",
          "636:         path2 = buf;",
          "638:         if (!buf) {",
          "639:           uv_fatal_error(ERROR_OUTOFMEMORY, \"realloc\");",
          "640:         }",
          "",
          "[Removed Lines]",
          "637:         buf = (wchar_t*)realloc(buf, buf_char_len * sizeof(wchar_t));",
          "",
          "[Added Lines]",
          "760:         buf = (WCHAR*)realloc(buf, buf_char_len * sizeof(WCHAR));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "732: }",
          "736:   HANDLE handle;",
          "737:   DWORD flags;",
          "740:   flags = FILE_FLAG_BACKUP_SEMANTICS;",
          "742:   if (do_lstat) {",
          "743:     flags |= FILE_FLAG_OPEN_REPARSE_POINT;",
          "744:   }",
          "747:                        FILE_READ_ATTRIBUTES,",
          "748:                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,",
          "749:                        NULL,",
          "",
          "[Removed Lines]",
          "735: INLINE static void fs__stat(uv_fs_t* req, const wchar_t* path, int do_lstat) {",
          "739:   req->ptr = NULL;",
          "746:   handle = CreateFileW(path,",
          "",
          "[Added Lines]",
          "858: INLINE static void fs__stat_prepare_path(WCHAR* pathw) {",
          "859:   size_t len = wcslen(pathw);",
          "862:   if (len > 1 && pathw[len - 2] != L':' &&",
          "863:       (pathw[len - 1] == L'\\\\' || pathw[len - 1] == L'/')) {",
          "864:     pathw[len - 1] = '\\0';",
          "865:   }",
          "866: }",
          "869: INLINE static void fs__stat_impl(uv_fs_t* req, int do_lstat) {",
          "878:   handle = CreateFileW(req->pathw,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "759:     DWORD error = GetLastError();",
          "760:     if (do_lstat && error == ERROR_SYMLINK_NOT_SUPPORTED) {",
          "764:     } else {",
          "",
          "[Removed Lines]",
          "762:       fs__stat(req, path, 0);",
          "",
          "[Added Lines]",
          "894:       fs__stat_impl(req, 0);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "776: }",
          "788:   if (handle == INVALID_HANDLE_VALUE) {",
          "789:     SET_REQ_WIN32_ERROR(req, ERROR_INVALID_HANDLE);",
          "",
          "[Removed Lines]",
          "779: void fs__fstat(uv_fs_t* req, uv_file file) {",
          "780:   HANDLE handle;",
          "782:   req->ptr = NULL;",
          "784:   VERIFY_UV_FILE(file, req);",
          "786:   handle = (HANDLE) _get_osfhandle(file);",
          "",
          "[Added Lines]",
          "911: static void fs__stat(uv_fs_t* req) {",
          "912:   fs__stat_prepare_path(req->pathw);",
          "913:   fs__stat_impl(req, 0);",
          "914: }",
          "917: static void fs__lstat(uv_fs_t* req) {",
          "918:   fs__stat_prepare_path(req->pathw);",
          "919:   fs__stat_impl(req, 1);",
          "920: }",
          "923: static void fs__fstat(uv_fs_t* req) {",
          "924:   int fd = req->fd;",
          "925:   HANDLE handle;",
          "927:   VERIFY_FD(fd, req);",
          "929:   handle = (HANDLE) _get_osfhandle(fd);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "800: }",
          "805:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "806:     return;",
          "807:   }",
          "",
          "[Removed Lines]",
          "803: void fs__rename(uv_fs_t* req, const wchar_t* path, const wchar_t* new_path) {",
          "804:   if (!MoveFileExW(path, new_path, MOVEFILE_REPLACE_EXISTING)) {",
          "",
          "[Added Lines]",
          "946: static void fs__rename(uv_fs_t* req) {",
          "947:   if (!MoveFileExW(req->pathw, req->new_pathw, MOVEFILE_REPLACE_EXISTING)) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "810: }",
          "814:   int result;",
          "819:   if (result == -1) {",
          "820:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "821:   } else {",
          "",
          "[Removed Lines]",
          "813: void fs__fsync(uv_fs_t* req, uv_file file) {",
          "816:   VERIFY_UV_FILE(file, req);",
          "818:   result = FlushFileBuffers((HANDLE)_get_osfhandle(file)) ? 0 : -1;",
          "",
          "[Added Lines]",
          "956: INLINE static void fs__sync_impl(uv_fs_t* req) {",
          "957:   int fd = req->fd;",
          "960:   VERIFY_FD(fd, req);",
          "962:   result = FlushFileBuffers((HANDLE) _get_osfhandle(fd)) ? 0 : -1;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "824: }",
          "828:   HANDLE handle;",
          "829:   NTSTATUS status;",
          "830:   IO_STATUS_BLOCK io_status;",
          "831:   FILE_END_OF_FILE_INFORMATION eof_info;",
          "839:   status = pNtSetInformationFile(handle,",
          "840:                                  &io_status,",
          "",
          "[Removed Lines]",
          "827: void fs__ftruncate(uv_fs_t* req, uv_file file, int64_t offset) {",
          "833:   VERIFY_UV_FILE(file, req);",
          "835:   handle = (HANDLE)_get_osfhandle(file);",
          "837:   eof_info.EndOfFile.QuadPart = offset;",
          "",
          "[Added Lines]",
          "971: static void fs__fsync(uv_fs_t* req) {",
          "972:   fs__sync_impl(req);",
          "973: }",
          "976: static void fs__fdatasync(uv_fs_t* req) {",
          "977:   fs__sync_impl(req);",
          "978: }",
          "981: static void fs__ftruncate(uv_fs_t* req) {",
          "982:   int fd = req->fd;",
          "988:   VERIFY_FD(fd, req);",
          "990:   handle = (HANDLE)_get_osfhandle(fd);",
          "992:   eof_info.EndOfFile.QuadPart = req->offset;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "850: }",
          "855:   const size_t max_buf_size = 65536;",
          "856:   size_t buf_size = length < max_buf_size ? length : max_buf_size;",
          "857:   int n, result = 0;",
          "858:   int64_t result_offset = 0;",
          "860:   if (!buf) {",
          "861:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "862:   }",
          "866:   }",
          "868:   if (result_offset == -1) {",
          "869:     result = -1;",
          "870:   } else {",
          "871:     while (length > 0) {",
          "873:       if (n == 0) {",
          "874:         break;",
          "875:       } else if (n == -1) {",
          "",
          "[Removed Lines]",
          "853: void fs__sendfile(uv_fs_t* req, uv_file out_file, uv_file in_file,",
          "854:     int64_t in_offset, size_t length) {",
          "859:   char* buf = (char*)malloc(buf_size);",
          "864:   if (in_offset != -1) {",
          "865:     result_offset = _lseeki64(in_file, in_offset, SEEK_SET);",
          "872:       n = _read(in_file, buf, length < buf_size ? length : buf_size);",
          "",
          "[Added Lines]",
          "1008: static void fs__sendfile(uv_fs_t* req) {",
          "1009:   int fd_in = req->fd, fd_out = req->fd_out;",
          "1010:   size_t length = req->length;",
          "1011:   int64_t offset = req->offset;",
          "1016:   char* buf = (char*) malloc(buf_size);",
          "1021:   if (offset != -1) {",
          "1022:     result_offset = _lseeki64(fd_in, offset, SEEK_SET);",
          "1029:       n = _read(fd_in, buf, length < buf_size ? length : buf_size);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "880:       length -= n;",
          "883:       if (n == -1) {",
          "884:         result = -1;",
          "885:         break;",
          "",
          "[Removed Lines]",
          "882:       n = _write(out_file, buf, n);",
          "",
          "[Added Lines]",
          "1039:       n = _write(fd_out, buf, n);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "893: }",
          "898:   SET_REQ_RESULT(req, result);",
          "899: }",
          "903:   int result;",
          "904:   HANDLE handle;",
          "905:   NTSTATUS nt_status;",
          "906:   IO_STATUS_BLOCK io_status;",
          "907:   FILE_BASIC_INFORMATION file_info;",
          "913:   nt_status = pNtQueryInformationFile(handle,",
          "914:                                       &io_status,",
          "",
          "[Removed Lines]",
          "896: void fs__chmod(uv_fs_t* req, const wchar_t* path, int mode) {",
          "897:   int result = _wchmod(path, mode);",
          "902: void fs__fchmod(uv_fs_t* req, uv_file file, int mode) {",
          "909:   VERIFY_UV_FILE(file, req);",
          "911:   handle = (HANDLE)_get_osfhandle(file);",
          "",
          "[Added Lines]",
          "1053: static void fs__chmod(uv_fs_t* req) {",
          "1054:   int result = _wchmod(req->pathw, req->mode);",
          "1059: static void fs__fchmod(uv_fs_t* req) {",
          "1060:   int fd = req->fd;",
          "1067:   VERIFY_FD(fd, req);",
          "1069:   handle = (HANDLE)_get_osfhandle(fd);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "921:     goto done;",
          "922:   }",
          "925:     file_info.FileAttributes &= ~FILE_ATTRIBUTE_READONLY;",
          "926:   } else {",
          "927:     file_info.FileAttributes |= FILE_ATTRIBUTE_READONLY;",
          "",
          "[Removed Lines]",
          "924:   if (mode & _S_IWRITE) {",
          "",
          "[Added Lines]",
          "1082:   if (req->mode & _S_IWRITE) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "959: }",
          "963:   HANDLE handle;",
          "966:                        FILE_WRITE_ATTRIBUTES,",
          "967:                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,",
          "968:                        NULL,",
          "",
          "[Removed Lines]",
          "962: void fs__utime(uv_fs_t* req, const wchar_t* path, double atime, double mtime) {",
          "965:   handle = CreateFileW(path,",
          "",
          "[Added Lines]",
          "1120: static void fs__utime(uv_fs_t* req) {",
          "1123:   handle = CreateFileW(req->pathw,",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "975:     return;",
          "976:   }",
          "979:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "980:     return;",
          "981:   }",
          "",
          "[Removed Lines]",
          "978:   if (fs__utime_handle(handle, atime, mtime) != 0) {",
          "",
          "[Added Lines]",
          "1136:   if (fs__utime_handle(handle, req->atime, req->mtime) != 0) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "984: }",
          "988:   HANDLE handle;",
          "993:   if (handle == INVALID_HANDLE_VALUE) {",
          "994:     SET_REQ_WIN32_ERROR(req, ERROR_INVALID_HANDLE);",
          "995:     return;",
          "996:   }",
          "999:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "1000:     return;",
          "1001:   }",
          "",
          "[Removed Lines]",
          "987: void fs__futime(uv_fs_t* req, uv_file file, double atime, double mtime) {",
          "989:   VERIFY_UV_FILE(file, req);",
          "991:   handle = (HANDLE) _get_osfhandle(file);",
          "998:   if (fs__utime_handle(handle, atime, mtime) != 0) {",
          "",
          "[Added Lines]",
          "1145: static void fs__futime(uv_fs_t* req) {",
          "1146:   int fd = req->fd;",
          "1148:   VERIFY_FD(fd, req);",
          "1150:   handle = (HANDLE) _get_osfhandle(fd);",
          "1157:   if (fs__utime_handle(handle, req->atime, req->mtime) != 0) {",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1004: }",
          "1010:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "1011:   } else {",
          "1013:   }",
          "1014: }",
          "1018:   HANDLE handle = INVALID_HANDLE_VALUE;",
          "1019:   REPARSE_DATA_BUFFER *buffer = NULL;",
          "1020:   int created = 0;",
          "",
          "[Removed Lines]",
          "1007: void fs__link(uv_fs_t* req, const wchar_t* path, const wchar_t* new_path) {",
          "1008:   int result = CreateHardLinkW(new_path, path, NULL) ? 0 : -1;",
          "1009:   if (result == -1) {",
          "1012:     SET_REQ_RESULT(req, result);",
          "1017: void fs__create_junction(uv_fs_t* req, const wchar_t* path, const wchar_t* new_path) {",
          "",
          "[Added Lines]",
          "1166: static void fs__link(uv_fs_t* req) {",
          "1167:   DWORD r = CreateHardLinkW(req->new_pathw, req->pathw, NULL);",
          "1168:   if (r == 0) {",
          "1171:     req->result = 0;",
          "1176: static void fs__create_junction(uv_fs_t* req, const WCHAR* path,",
          "1177:     const WCHAR* new_path) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1024:   int start, len, i;",
          "1025:   int add_slash;",
          "1026:   DWORD bytes;",
          "1029:   target_len = wcslen(path);",
          "1030:   is_long_path = wcsncmp(path, LONG_PATH_PREFIX, LONG_PATH_PREFIX_LEN) == 0;",
          "",
          "[Removed Lines]",
          "1027:   wchar_t* path_buf;",
          "",
          "[Added Lines]",
          "1187:   WCHAR* path_buf;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1046:   needed_buf_size =",
          "1047:       FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +",
          "1052:   buffer = (REPARSE_DATA_BUFFER*)malloc(needed_buf_size);",
          "",
          "[Removed Lines]",
          "1048:       JUNCTION_PREFIX_LEN * sizeof(wchar_t) +",
          "1049:       2 * (target_len + 2) * sizeof(wchar_t);",
          "",
          "[Added Lines]",
          "1208:       JUNCTION_PREFIX_LEN * sizeof(WCHAR) +",
          "1209:       2 * (target_len + 2) * sizeof(WCHAR);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1055:   }",
          "1059:   path_buf_len = 0;",
          "1062:   start = path_buf_len;",
          "1065:     JUNCTION_PREFIX_LEN);",
          "1066:   path_buf_len += JUNCTION_PREFIX_LEN;",
          "",
          "[Removed Lines]",
          "1058:   path_buf = (wchar_t*)&(buffer->MountPointReparseBuffer.PathBuffer);",
          "1064:   wcsncpy((wchar_t*)&path_buf[path_buf_len], JUNCTION_PREFIX,",
          "",
          "[Added Lines]",
          "1218:   path_buf = (WCHAR*)&(buffer->MountPointReparseBuffer.PathBuffer);",
          "1224:   wcsncpy((WCHAR*)&path_buf[path_buf_len], JUNCTION_PREFIX,",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1083:   len = path_buf_len - start;",
          "1090:   path_buf[path_buf_len++] = L'\\0';",
          "",
          "[Removed Lines]",
          "1086:   buffer->MountPointReparseBuffer.SubstituteNameOffset = start * sizeof(wchar_t);",
          "1087:   buffer->MountPointReparseBuffer.SubstituteNameLength = len * sizeof(wchar_t);",
          "",
          "[Added Lines]",
          "1246:   buffer->MountPointReparseBuffer.SubstituteNameOffset = start * sizeof(WCHAR);",
          "1247:   buffer->MountPointReparseBuffer.SubstituteNameLength = len * sizeof(WCHAR);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1112:   }",
          "1119:   path_buf[path_buf_len++] = L'\\0';",
          "1122:   used_buf_size = FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +",
          "1124:   used_data_size = used_buf_size -",
          "1125:     FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer);",
          "",
          "[Removed Lines]",
          "1115:   buffer->MountPointReparseBuffer.PrintNameOffset = start * sizeof(wchar_t);",
          "1116:   buffer->MountPointReparseBuffer.PrintNameLength = len * sizeof(wchar_t);",
          "1123:     path_buf_len * sizeof(wchar_t);",
          "",
          "[Added Lines]",
          "1275:   buffer->MountPointReparseBuffer.PrintNameOffset = start * sizeof(WCHAR);",
          "1276:   buffer->MountPointReparseBuffer.PrintNameLength = len * sizeof(WCHAR);",
          "1283:     path_buf_len * sizeof(WCHAR);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1183: }",
          "1188:   int result;",
          "1190:   if (flags & UV_FS_SYMLINK_JUNCTION) {",
          "1192:   } else if (pCreateSymbolicLinkW) {",
          "1195:                                   flags & UV_FS_SYMLINK_DIR ? SYMBOLIC_LINK_FLAG_DIRECTORY : 0) ? 0 : -1;",
          "1196:     if (result == -1) {",
          "1197:       SET_REQ_WIN32_ERROR(req, GetLastError());",
          "",
          "[Removed Lines]",
          "1186: void fs__symlink(uv_fs_t* req, const wchar_t* path, const wchar_t* new_path,",
          "1187:                  int flags) {",
          "1191:     fs__create_junction(req, path, new_path);",
          "1193:     result = pCreateSymbolicLinkW(new_path,",
          "1194:                                   path,",
          "",
          "[Added Lines]",
          "1346: static void fs__symlink(uv_fs_t* req) {",
          "1347:   WCHAR* pathw = req->pathw;",
          "1348:   WCHAR* new_pathw = req->new_pathw;",
          "1349:   int flags = req->file_flags;",
          "1354:     fs__create_junction(req, pathw, new_pathw);",
          "1356:     result = pCreateSymbolicLinkW(new_pathw,",
          "1357:                                   pathw,",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1204: }",
          "1208:   HANDLE handle;",
          "1211:                        0,",
          "1212:                        0,",
          "1213:                        NULL,",
          "",
          "[Removed Lines]",
          "1207: void fs__readlink(uv_fs_t* req, const wchar_t* path) {",
          "1210:   handle = CreateFileW(path,",
          "",
          "[Added Lines]",
          "1370: static void fs__readlink(uv_fs_t* req) {",
          "1373:   handle = CreateFileW(req->pathw,",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1233: }",
          "1237:   req->result = 0;",
          "1238: }",
          "",
          "[Removed Lines]",
          "1236: void fs__nop(uv_fs_t* req) {",
          "",
          "[Added Lines]",
          "1400: static void fs__chown(uv_fs_t* req) {",
          "1401:   req->result = 0;",
          "1402: }",
          "1405: static void fs__fchown(uv_fs_t* req) {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1245:   assert(req != NULL);",
          "1246:   assert(req->type == UV_FS);",
          "1248:   switch (req->fs_type) {",
          "1320:     default:",
          "1321:       assert(!\"bad uv_fs_type\");",
          "1322:   }",
          "1324:   POST_COMPLETION_FOR_REQ(loop, req);",
          "1326:   return 0;",
          "1327: }",
          "1330: int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,",
          "1331:     int mode, uv_fs_cb cb) {",
          "1338:   if (cb) {",
          "1342:     QUEUE_FS_TP_JOB(loop, req);",
          "1343:   } else {",
          "1347:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1348:     return req->result;",
          "1349:   }",
          "1352: }",
          "1356:   if (cb) {",
          "1359:     QUEUE_FS_TP_JOB(loop, req);",
          "1360:   } else {",
          "1363:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1364:     return req->result;",
          "1365:   }",
          "1368: }",
          "1372:     size_t length, int64_t offset, uv_fs_cb cb) {",
          "1373:   if (cb) {",
          "1379:     QUEUE_FS_TP_JOB(loop, req);",
          "1380:   } else {",
          "1383:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1384:     return req->result;",
          "1385:   }",
          "1388: }",
          "1392:     size_t length, int64_t offset, uv_fs_cb cb) {",
          "1393:   if (cb) {",
          "1399:     QUEUE_FS_TP_JOB(loop, req);",
          "1400:   } else {",
          "1403:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1404:     return req->result;",
          "1405:   }",
          "1408: }",
          "1411: int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,",
          "1412:     uv_fs_cb cb) {",
          "1419:   if (cb) {",
          "1421:     QUEUE_FS_TP_JOB(loop, req);",
          "1422:   } else {",
          "1426:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1427:     return req->result;",
          "1428:   }",
          "1431: }",
          "1434: int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,",
          "1435:     uv_fs_cb cb) {",
          "1442:   if (cb) {",
          "1445:     QUEUE_FS_TP_JOB(loop, req);",
          "1446:   } else {",
          "1450:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1451:     return req->result;",
          "1452:   }",
          "1455: }",
          "1458: int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {",
          "1465:   if (cb) {",
          "1467:     QUEUE_FS_TP_JOB(loop, req);",
          "1468:   } else {",
          "1472:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1473:     return req->result;",
          "1474:   }",
          "1477: }",
          "1480: int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,",
          "1481:     uv_fs_cb cb) {",
          "1488:   if (cb) {",
          "1491:     QUEUE_FS_TP_JOB(loop, req);",
          "1492:   } else {",
          "1496:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1497:     return req->result;",
          "1498:   }",
          "1501: }",
          "1504: int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,",
          "1505:     const char* new_path, uv_fs_cb cb) {",
          "1514:   if (cb) {",
          "1518:     QUEUE_FS_TP_JOB(loop, req);",
          "1519:   } else {",
          "1524:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1525:     return req->result;",
          "1526:   }",
          "1529: }",
          "1532: int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,",
          "1533:     const char* new_path, int flags, uv_fs_cb cb) {",
          "1542:   if (cb) {",
          "1547:     QUEUE_FS_TP_JOB(loop, req);",
          "1548:   } else {",
          "1553:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1554:     return req->result;",
          "1555:   }",
          "1558: }",
          "1561: int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,",
          "1562:     uv_fs_cb cb) {",
          "1569:   if (cb) {",
          "1571:     QUEUE_FS_TP_JOB(loop, req);",
          "1572:   } else {",
          "1576:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1577:     return req->result;",
          "1578:   }",
          "1581: }",
          "1584: int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, int uid,",
          "1585:     int gid, uv_fs_cb cb) {",
          "1592:   if (cb) {",
          "1594:     QUEUE_FS_TP_JOB(loop, req);",
          "1595:   } else {",
          "1599:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1600:     return req->result;",
          "1601:   }",
          "1604: }",
          "1608:     int gid, uv_fs_cb cb) {",
          "1609:   if (cb) {",
          "1611:     QUEUE_FS_TP_JOB(loop, req);",
          "1612:   } else {",
          "1615:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1616:     return req->result;",
          "1617:   }",
          "1620: }",
          "1623: int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {",
          "1637:   }",
          "1639:   if (cb) {",
          "1649:     QUEUE_FS_TP_JOB(loop, req);",
          "1650:   } else {",
          "1658:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1659:     return req->result;",
          "1660:   }",
          "1663: }",
          "1667: int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {",
          "1681:   }",
          "1683:   if (cb) {",
          "1693:     QUEUE_FS_TP_JOB(loop, req);",
          "1694:   } else {",
          "1702:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1703:     return req->result;",
          "1704:   }",
          "1707: }",
          "1711:   if (cb) {",
          "1714:     QUEUE_FS_TP_JOB(loop, req);",
          "1715:   } else {",
          "1718:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1719:     return req->result;",
          "1720:   }",
          "1723: }",
          "1726: int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,",
          "1727:     const char* new_path, uv_fs_cb cb) {",
          "1736:   if (cb) {",
          "1740:     QUEUE_FS_TP_JOB(loop, req);",
          "1741:   } else {",
          "1746:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1747:     return req->result;",
          "1748:   }",
          "1751: }",
          "1755:   if (cb) {",
          "1758:     QUEUE_FS_TP_JOB(loop, req);",
          "1759:   } else {",
          "1762:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1763:     return req->result;",
          "1764:   }",
          "1767: }",
          "1771:   if (cb) {",
          "1774:     QUEUE_FS_TP_JOB(loop, req);",
          "1775:   } else {",
          "1778:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1779:     return req->result;",
          "1780:   }",
          "1783: }",
          "1787:     int64_t offset, uv_fs_cb cb) {",
          "1788:   if (cb) {",
          "1792:     QUEUE_FS_TP_JOB(loop, req);",
          "1793:   } else {",
          "1796:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1797:     return req->result;",
          "1798:   }",
          "1801: }",
          "1806:   if (cb) {",
          "1812:     QUEUE_FS_TP_JOB(loop, req);",
          "1813:   } else {",
          "1816:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1817:     return req->result;",
          "1818:   }",
          "1821: }",
          "1824: int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,",
          "1825:     uv_fs_cb cb) {",
          "1832:   if (cb) {",
          "1835:     QUEUE_FS_TP_JOB(loop, req);",
          "1836:   } else {",
          "1840:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1841:     return req->result;",
          "1842:   }",
          "1845: }",
          "1849:     uv_fs_cb cb) {",
          "1850:   if (cb) {",
          "1854:     QUEUE_FS_TP_JOB(loop, req);",
          "1855:   } else {",
          "1858:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1859:     return req->result;",
          "1860:   }",
          "1863: }",
          "1866: int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,",
          "1867:     double mtime, uv_fs_cb cb) {",
          "1874:   if (cb) {",
          "1878:     QUEUE_FS_TP_JOB(loop, req);",
          "1879:   } else {",
          "1883:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1884:     return req->result;",
          "1885:   }",
          "1888: }",
          "1892:     double mtime, uv_fs_cb cb) {",
          "1893:   if (cb) {",
          "1898:     QUEUE_FS_TP_JOB(loop, req);",
          "1899:   } else {",
          "1902:     SET_UV_LAST_ERROR_FROM_REQ(req);",
          "1903:     return req->result;",
          "1904:   }",
          "1907: }",
          "",
          "[Removed Lines]",
          "1249:     case UV_FS_OPEN:",
          "1250:       fs__open(req, req->pathw, req->file_flags, (int)req->mode);",
          "1251:       break;",
          "1252:     case UV_FS_CLOSE:",
          "1253:       fs__close(req, req->file);",
          "1254:       break;",
          "1255:     case UV_FS_READ:",
          "1256:       fs__read(req, req->file, req->buf, req->length, req->offset);",
          "1257:       break;",
          "1258:     case UV_FS_WRITE:",
          "1259:       fs__write(req, req->file, req->buf, req->length, req->offset);",
          "1260:       break;",
          "1261:     case UV_FS_UNLINK:",
          "1262:       fs__unlink(req, req->pathw);",
          "1263:       break;",
          "1264:     case UV_FS_MKDIR:",
          "1265:       fs__mkdir(req, req->pathw, req->mode);",
          "1266:       break;",
          "1267:     case UV_FS_RMDIR:",
          "1268:       fs__rmdir(req, req->pathw);",
          "1269:       break;",
          "1270:     case UV_FS_READDIR:",
          "1271:       fs__readdir(req, req->pathw, req->file_flags);",
          "1272:       break;",
          "1273:     case UV_FS_STAT:",
          "1274:       fs__stat(req, req->pathw, 0);",
          "1275:       break;",
          "1276:     case UV_FS_LSTAT:",
          "1277:       fs__stat(req, req->pathw, 1);",
          "1278:       break;",
          "1279:     case UV_FS_FSTAT:",
          "1280:       fs__fstat(req, req->file);",
          "1281:       break;",
          "1282:     case UV_FS_RENAME:",
          "1283:       fs__rename(req, req->pathw, req->new_pathw);",
          "1284:       break;",
          "1285:     case UV_FS_FSYNC:",
          "1286:     case UV_FS_FDATASYNC:",
          "1287:       fs__fsync(req, req->file);",
          "1288:       break;",
          "1289:     case UV_FS_FTRUNCATE:",
          "1290:       fs__ftruncate(req, req->file, req->offset);",
          "1291:       break;",
          "1292:     case UV_FS_SENDFILE:",
          "1293:       fs__sendfile(req, req->file_out, req->file, req->offset, req->length);",
          "1294:       break;",
          "1295:     case UV_FS_CHMOD:",
          "1296:       fs__chmod(req, req->pathw, req->mode);",
          "1297:       break;",
          "1298:     case UV_FS_FCHMOD:",
          "1299:       fs__fchmod(req, req->file, req->mode);",
          "1300:       break;",
          "1301:     case UV_FS_UTIME:",
          "1302:       fs__utime(req, req->pathw, req->atime, req->mtime);",
          "1303:       break;",
          "1304:     case UV_FS_FUTIME:",
          "1305:       fs__futime(req, req->file, req->atime, req->mtime);",
          "1306:       break;",
          "1307:     case UV_FS_LINK:",
          "1308:       fs__link(req, req->pathw, req->new_pathw);",
          "1309:       break;",
          "1310:     case UV_FS_SYMLINK:",
          "1311:       fs__symlink(req, req->pathw, req->new_pathw, req->file_flags);",
          "1312:       break;",
          "1313:     case UV_FS_READLINK:",
          "1314:       fs__readlink(req, req->pathw);",
          "1315:       break;",
          "1316:     case UV_FS_CHOWN:",
          "1317:     case UV_FS_FCHOWN:",
          "1318:       fs__nop(req);",
          "1319:       break;",
          "1332:   wchar_t* pathw;",
          "1333:   int size;",
          "1336:   UTF8_TO_UTF16(path, pathw);",
          "1339:     uv_fs_req_init_async(loop, req, UV_FS_OPEN, path, pathw, cb);",
          "1340:     req->file_flags = flags;",
          "1341:     req->mode = mode;",
          "1344:     uv_fs_req_init_sync(loop, req, UV_FS_OPEN);",
          "1345:     fs__open(req, pathw, flags, mode);",
          "1346:     free(pathw);",
          "1351:   return 0;",
          "1355: int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {",
          "1357:     uv_fs_req_init_async(loop, req, UV_FS_CLOSE, NULL, NULL, cb);",
          "1358:     req->file = file;",
          "1361:     uv_fs_req_init_sync(loop, req, UV_FS_CLOSE);",
          "1362:     fs__close(req, file);",
          "1367:   return 0;",
          "1371: int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,",
          "1374:     uv_fs_req_init_async(loop, req, UV_FS_READ, NULL, NULL, cb);",
          "1375:     req->file = file;",
          "1376:     req->buf = buf;",
          "1377:     req->length = length;",
          "1378:     req->offset = offset;",
          "1381:     uv_fs_req_init_sync(loop, req, UV_FS_READ);",
          "1382:     fs__read(req, file, buf, length, offset);",
          "1387:   return 0;",
          "1391: int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,",
          "1394:     uv_fs_req_init_async(loop, req, UV_FS_WRITE, NULL, NULL, cb);",
          "1395:     req->file = file;",
          "1396:     req->buf = buf;",
          "1397:     req->length = length;",
          "1398:     req->offset = offset;",
          "1401:     uv_fs_req_init_sync(loop, req, UV_FS_WRITE);",
          "1402:     fs__write(req, file, buf, length, offset);",
          "1407:   return 0;",
          "1413:   wchar_t* pathw;",
          "1414:   int size;",
          "1417:   UTF8_TO_UTF16(path, pathw);",
          "1420:     uv_fs_req_init_async(loop, req, UV_FS_UNLINK, path, pathw, cb);",
          "1423:     uv_fs_req_init_sync(loop, req, UV_FS_UNLINK);",
          "1424:     fs__unlink(req, pathw);",
          "1425:     free(pathw);",
          "1430:   return 0;",
          "1436:   wchar_t* pathw;",
          "1437:   int size;",
          "1440:   UTF8_TO_UTF16(path, pathw);",
          "1443:     uv_fs_req_init_async(loop, req, UV_FS_MKDIR, path, pathw, cb);",
          "1444:     req->mode = mode;",
          "1447:     uv_fs_req_init_sync(loop, req, UV_FS_MKDIR);",
          "1448:     fs__mkdir(req, pathw, mode);",
          "1449:     free(pathw);",
          "1454:   return 0;",
          "1459:   wchar_t* pathw;",
          "1460:   int size;",
          "1463:   UTF8_TO_UTF16(path, pathw);",
          "1466:     uv_fs_req_init_async(loop, req, UV_FS_RMDIR, path, pathw, cb);",
          "1469:     uv_fs_req_init_sync(loop, req, UV_FS_RMDIR);",
          "1470:     fs__rmdir(req, pathw);",
          "1471:     free(pathw);",
          "1476:   return 0;",
          "1482:   wchar_t* pathw;",
          "1483:   int size;",
          "1486:   UTF8_TO_UTF16(path, pathw);",
          "1489:     uv_fs_req_init_async(loop, req, UV_FS_READDIR, path, pathw, cb);",
          "1490:     req->file_flags = flags;",
          "1493:     uv_fs_req_init_sync(loop, req, UV_FS_READDIR);",
          "1494:     fs__readdir(req, pathw, flags);",
          "1495:     free(pathw);",
          "1500:   return 0;",
          "1506:   wchar_t* pathw;",
          "1507:   wchar_t* new_pathw;",
          "1508:   int size;",
          "1511:   UTF8_TO_UTF16(path, pathw);",
          "1512:   UTF8_TO_UTF16(new_path, new_pathw);",
          "1515:     uv_fs_req_init_async(loop, req, UV_FS_LINK, path, pathw, cb);",
          "1516:     req->new_pathw = new_pathw;",
          "1517:     req->flags |= UV_FS_FREE_NEW_PATH;",
          "1520:     uv_fs_req_init_sync(loop, req, UV_FS_LINK);",
          "1521:     fs__link(req, pathw, new_pathw);",
          "1522:     free(pathw);",
          "1523:     free(new_pathw);",
          "1528:   return 0;",
          "1534:   wchar_t* pathw;",
          "1535:   wchar_t* new_pathw;",
          "1536:   int size;",
          "1539:   UTF8_TO_UTF16(path, pathw);",
          "1540:   UTF8_TO_UTF16(new_path, new_pathw);",
          "1543:     uv_fs_req_init_async(loop, req, UV_FS_SYMLINK, path, pathw, cb);",
          "1544:     req->new_pathw = new_pathw;",
          "1545:     req->file_flags = flags;",
          "1546:     req->flags |= UV_FS_FREE_NEW_PATH;",
          "1549:     uv_fs_req_init_sync(loop, req, UV_FS_SYMLINK);",
          "1550:     fs__symlink(req, pathw, new_pathw, flags);",
          "1551:     free(pathw);",
          "1552:     free(new_pathw);",
          "1557:   return 0;",
          "1563:   wchar_t* pathw;",
          "1564:   int size;",
          "1567:   UTF8_TO_UTF16(path, pathw);",
          "1570:     uv_fs_req_init_async(loop, req, UV_FS_READLINK, path, pathw, cb);",
          "1573:     uv_fs_req_init_sync(loop, req, UV_FS_READLINK);",
          "1574:     fs__readlink(req, pathw);",
          "1575:     free(pathw);",
          "1580:   return 0;",
          "1586:   wchar_t* pathw;",
          "1587:   int size;",
          "1590:   UTF8_TO_UTF16(path, pathw);",
          "1593:     uv_fs_req_init_async(loop, req, UV_FS_CHOWN, path, pathw, cb);",
          "1596:     uv_fs_req_init_sync(loop, req, UV_FS_CHOWN);",
          "1597:     fs__nop(req);",
          "1598:     free(pathw);",
          "1603:   return 0;",
          "1607: int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, int uid,",
          "1610:     uv_fs_req_init_async(loop, req, UV_FS_FCHOWN, NULL, NULL, cb);",
          "1613:     uv_fs_req_init_sync(loop, req, UV_FS_FCHOWN);",
          "1614:     fs__nop(req);",
          "1619:   return 0;",
          "1624:   int len = strlen(path);",
          "1625:   char* path2 = NULL;",
          "1626:   wchar_t* pathw;",
          "1627:   int size;",
          "1629:   if (len > 1 && path[len - 2] != ':' &&",
          "1630:       (path[len - 1] == '\\\\' || path[len - 1] == '/')) {",
          "1631:     path2 = strdup(path);",
          "1632:     if (!path2) {",
          "1633:       uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "1634:     }",
          "1636:     path2[len - 1] = '\\0';",
          "1640:     uv_fs_req_init_async(loop, req, UV_FS_STAT, NULL, NULL, cb);",
          "1641:     if (path2) {",
          "1642:       req->path = path2;",
          "1643:       UTF8_TO_UTF16(path2, req->pathw);",
          "1644:     } else {",
          "1645:       req->path = strdup(path);",
          "1646:       UTF8_TO_UTF16(path, req->pathw);",
          "1647:     }",
          "1651:     uv_fs_req_init_sync(loop, req, UV_FS_STAT);",
          "1652:     UTF8_TO_UTF16(path2 ? path2 : path, pathw);",
          "1653:     fs__stat(req, pathw, 0);",
          "1654:     if (path2) {",
          "1655:       free(path2);",
          "1656:     }",
          "1657:     free(pathw);",
          "1662:   return 0;",
          "1668:   int len = strlen(path);",
          "1669:   char* path2 = NULL;",
          "1670:   wchar_t* pathw;",
          "1671:   int size;",
          "1673:   if (len > 1 && path[len - 2] != ':' &&",
          "1674:       (path[len - 1] == '\\\\' || path[len - 1] == '/')) {",
          "1675:     path2 = strdup(path);",
          "1676:     if (!path2) {",
          "1677:       uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "1678:     }",
          "1680:     path2[len - 1] = '\\0';",
          "1684:     uv_fs_req_init_async(loop, req, UV_FS_LSTAT, NULL, NULL, cb);",
          "1685:      if (path2) {",
          "1686:       req->path = path2;",
          "1687:       UTF8_TO_UTF16(path2, req->pathw);",
          "1688:     } else {",
          "1689:       req->path = strdup(path);",
          "1690:       UTF8_TO_UTF16(path, req->pathw);",
          "1691:     }",
          "1695:     uv_fs_req_init_sync(loop, req, UV_FS_LSTAT);",
          "1696:     UTF8_TO_UTF16(path2 ? path2 : path, pathw);",
          "1697:     fs__stat(req, pathw, 1);",
          "1698:     if (path2) {",
          "1699:       free(path2);",
          "1700:     }",
          "1701:     free(pathw);",
          "1706:   return 0;",
          "1710: int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {",
          "1712:     uv_fs_req_init_async(loop, req, UV_FS_FSTAT, NULL, NULL, cb);",
          "1713:     req->file = file;",
          "1716:     uv_fs_req_init_sync(loop, req, UV_FS_FSTAT);",
          "1717:     fs__fstat(req, file);",
          "1722:   return 0;",
          "1728:   wchar_t* pathw;",
          "1729:   wchar_t* new_pathw;",
          "1730:   int size;",
          "1733:   UTF8_TO_UTF16(path, pathw);",
          "1734:   UTF8_TO_UTF16(new_path, new_pathw);",
          "1737:     uv_fs_req_init_async(loop, req, UV_FS_RENAME, path, pathw, cb);",
          "1738:     req->new_pathw = new_pathw;",
          "1739:     req->flags |= UV_FS_FREE_NEW_PATH;",
          "1742:     uv_fs_req_init_sync(loop, req, UV_FS_RENAME);",
          "1743:     fs__rename(req, pathw, new_pathw);",
          "1744:     free(pathw);",
          "1745:     free(new_pathw);",
          "1750:   return 0;",
          "1754: int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {",
          "1756:     uv_fs_req_init_async(loop, req, UV_FS_FDATASYNC, NULL, NULL, cb);",
          "1757:     req->file = file;",
          "1760:     uv_fs_req_init_sync(loop, req, UV_FS_FDATASYNC);",
          "1761:     fs__fsync(req, file);",
          "1766:   return 0;",
          "1770: int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {",
          "1772:     uv_fs_req_init_async(loop, req, UV_FS_FSYNC, NULL, NULL, cb);",
          "1773:     req->file = file;",
          "1776:     uv_fs_req_init_sync(loop, req, UV_FS_FSYNC);",
          "1777:     fs__fsync(req, file);",
          "1782:   return 0;",
          "1786: int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,",
          "1789:     uv_fs_req_init_async(loop, req, UV_FS_FTRUNCATE, NULL, NULL, cb);",
          "1790:     req->file = file;",
          "1791:     req->offset = offset;",
          "1794:     uv_fs_req_init_sync(loop, req, UV_FS_FTRUNCATE);",
          "1795:     fs__ftruncate(req, file, offset);",
          "1800:   return 0;",
          "1804: int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,",
          "1805:     uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb) {",
          "1807:     uv_fs_req_init_async(loop, req, UV_FS_SENDFILE, NULL, NULL, cb);",
          "1808:     req->file_out = out_fd;",
          "1809:     req->file = in_fd;",
          "1810:     req->offset = in_offset;",
          "1811:     req->length = length;",
          "1814:     uv_fs_req_init_sync(loop, req, UV_FS_SENDFILE);",
          "1815:     fs__sendfile(req, out_fd, in_fd, in_offset, length);",
          "1820:   return 0;",
          "1826:   wchar_t* pathw;",
          "1827:   int size;",
          "1830:   UTF8_TO_UTF16(path, pathw);",
          "1833:     uv_fs_req_init_async(loop, req, UV_FS_CHMOD, path, pathw, cb);",
          "1834:     req->mode = mode;",
          "1837:     uv_fs_req_init_sync(loop, req, UV_FS_CHMOD);",
          "1838:     fs__chmod(req, pathw, mode);",
          "1839:     free(pathw);",
          "1844:   return 0;",
          "1848: int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode,",
          "1851:     uv_fs_req_init_async(loop, req, UV_FS_FCHMOD, NULL, NULL, cb);",
          "1852:     req->file = file;",
          "1853:     req->mode = mode;",
          "1856:     uv_fs_req_init_sync(loop, req, UV_FS_FCHMOD);",
          "1857:     fs__fchmod(req, file, mode);",
          "1862:   return 0;",
          "1868:   wchar_t* pathw;",
          "1869:   int size;",
          "1872:   UTF8_TO_UTF16(path, pathw);",
          "1875:     uv_fs_req_init_async(loop, req, UV_FS_UTIME, path, pathw, cb);",
          "1876:     req->atime = atime;",
          "1877:     req->mtime = mtime;",
          "1880:     uv_fs_req_init_sync(loop, req, UV_FS_UTIME);",
          "1881:     fs__utime(req, pathw, atime, mtime);",
          "1882:     free(pathw);",
          "1887:   return 0;",
          "1891: int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime,",
          "1894:     uv_fs_req_init_async(loop, req, UV_FS_FUTIME, NULL, NULL, cb);",
          "1895:     req->file = file;",
          "1896:     req->atime = atime;",
          "1897:     req->mtime = mtime;",
          "1900:     uv_fs_req_init_sync(loop, req, UV_FS_FUTIME);",
          "1901:     fs__futime(req, file, atime, mtime);",
          "1906:   return 0;",
          "",
          "[Added Lines]",
          "1417: #define XX(uc, lc)  case UV_FS_##uc: fs__##lc(req); break;",
          "1419:     XX(OPEN, open)",
          "1420:     XX(CLOSE, close)",
          "1421:     XX(READ, read)",
          "1422:     XX(WRITE, write)",
          "1423:     XX(SENDFILE, sendfile)",
          "1424:     XX(STAT, stat)",
          "1425:     XX(LSTAT, lstat)",
          "1426:     XX(FSTAT, fstat)",
          "1427:     XX(FTRUNCATE, ftruncate)",
          "1428:     XX(UTIME, utime)",
          "1429:     XX(FUTIME, futime)",
          "1430:     XX(CHMOD, chmod)",
          "1431:     XX(FCHMOD, fchmod)",
          "1432:     XX(FSYNC, fsync)",
          "1433:     XX(FDATASYNC, fdatasync)",
          "1434:     XX(UNLINK, unlink)",
          "1435:     XX(RMDIR, rmdir)",
          "1436:     XX(MKDIR, mkdir)",
          "1437:     XX(RENAME, rename)",
          "1438:     XX(READDIR, readdir)",
          "1439:     XX(LINK, link)",
          "1440:     XX(SYMLINK, symlink)",
          "1441:     XX(READLINK, readlink)",
          "1442:     XX(CHOWN, chown)",
          "1443:     XX(FCHOWN, fchown);",
          "1455:   uv_fs_req_init(loop, req, UV_FS_OPEN, cb);",
          "1457:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1458:     return -1;",
          "1459:   }",
          "1461:   req->file_flags = flags;",
          "1462:   req->mode = mode;",
          "1466:     return 0;",
          "1468:     fs__open(req);",
          "1475: int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {",
          "1476:   uv_fs_req_init(loop, req, UV_FS_CLOSE, cb);",
          "1477:   req->fd = fd;",
          "1481:     return 0;",
          "1483:     fs__close(req);",
          "1490: int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,",
          "1492:   uv_fs_req_init(loop, req, UV_FS_READ, cb);",
          "1494:   req->fd = fd;",
          "1495:   req->buf = buf;",
          "1496:   req->length = length;",
          "1497:   req->offset = offset;",
          "1501:     return 0;",
          "1503:     fs__read(req);",
          "1510: int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,",
          "1512:   uv_fs_req_init(loop, req, UV_FS_WRITE, cb);",
          "1514:   req->fd = fd;",
          "1515:   req->buf = buf;",
          "1516:   req->length = length;",
          "1517:   req->offset = offset;",
          "1521:     return 0;",
          "1523:     fs__write(req);",
          "1532:   uv_fs_req_init(loop, req, UV_FS_UNLINK, cb);",
          "1534:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1535:     return -1;",
          "1536:   }",
          "1540:     return 0;",
          "1542:     fs__unlink(req);",
          "1551:   uv_fs_req_init(loop, req, UV_FS_MKDIR, cb);",
          "1553:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1554:     return -1;",
          "1555:   }",
          "1557:   req->mode = mode;",
          "1561:     return 0;",
          "1563:     fs__mkdir(req);",
          "1571:   uv_fs_req_init(loop, req, UV_FS_RMDIR, cb);",
          "1573:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1574:     return -1;",
          "1575:   }",
          "1579:     return 0;",
          "1581:     fs__rmdir(req);",
          "1590:   uv_fs_req_init(loop, req, UV_FS_READDIR, cb);",
          "1592:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1593:     return -1;",
          "1594:   }",
          "1596:   req->file_flags;",
          "1600:     return 0;",
          "1602:     fs__readdir(req);",
          "1611:   uv_fs_req_init(loop, req, UV_FS_LINK, cb);",
          "1613:   if (fs__capture_path(loop, req, path, new_path, cb != NULL) < 0) {",
          "1614:     return -1;",
          "1615:   }",
          "1619:     return 0;",
          "1621:     fs__link(req);",
          "1630:   uv_fs_req_init(loop, req, UV_FS_SYMLINK, cb);",
          "1632:   if (fs__capture_path(loop, req, path, new_path, cb != NULL) < 0) {",
          "1633:     return -1;",
          "1634:   }",
          "1636:   req->file_flags = flags;",
          "1640:     return 0;",
          "1642:     fs__symlink(req);",
          "1651:   uv_fs_req_init(loop, req, UV_FS_READLINK, cb);",
          "1653:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1654:     return -1;",
          "1655:   }",
          "1659:     return 0;",
          "1661:     fs__readlink(req);",
          "1670:   uv_fs_req_init(loop, req, UV_FS_CHOWN, cb);",
          "1672:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1673:     return -1;",
          "1674:   }",
          "1678:     return 0;",
          "1680:     fs__chown(req);",
          "1687: int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file fd, int uid,",
          "1689:   uv_fs_req_init(loop, req, UV_FS_FCHOWN, cb);",
          "1693:     return 0;",
          "1695:     fs__fchown(req);",
          "1703:   uv_fs_req_init(loop, req, UV_FS_STAT, cb);",
          "1705:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1706:     return -1;",
          "1711:     return 0;",
          "1713:     fs__stat(req);",
          "1721:   uv_fs_req_init(loop, req, UV_FS_LSTAT, cb);",
          "1723:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1724:     return -1;",
          "1729:     return 0;",
          "1731:     fs__lstat(req);",
          "1738: int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {",
          "1739:   uv_fs_req_init(loop, req, UV_FS_FSTAT, cb);",
          "1740:   req->fd = fd;",
          "1744:     return 0;",
          "1746:     fs__fstat(req);",
          "1755:   uv_fs_req_init(loop, req, UV_FS_RENAME, cb);",
          "1757:   if (fs__capture_path(loop, req, path, new_path, cb != NULL) < 0) {",
          "1758:     return -1;",
          "1759:   }",
          "1763:     return 0;",
          "1765:     fs__rename(req);",
          "1772: int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {",
          "1773:   uv_fs_req_init(loop, req, UV_FS_FSYNC, cb);",
          "1774:   req->fd = fd;",
          "1778:     return 0;",
          "1780:     fs__fsync(req);",
          "1787: int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {",
          "1788:   uv_fs_req_init(loop, req, UV_FS_FDATASYNC, cb);",
          "1789:   req->fd = fd;",
          "1793:     return 0;",
          "1795:     fs__fdatasync(req);",
          "1802: int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file fd,",
          "1804:   uv_fs_req_init(loop, req, UV_FS_FTRUNCATE, cb);",
          "1806:   req->fd = fd;",
          "1807:   req->offset = offset;",
          "1811:     return 0;",
          "1813:     fs__ftruncate(req);",
          "1821: int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file fd_out,",
          "1822:     uv_file fd_in, int64_t in_offset, size_t length, uv_fs_cb cb) {",
          "1823:   uv_fs_req_init(loop, req, UV_FS_SENDFILE, cb);",
          "1825:   req->fd = fd_in;",
          "1826:   req->fd_out = fd_out;",
          "1827:   req->offset = in_offset;",
          "1828:   req->length = length;",
          "1832:     return 0;",
          "1834:     fs__sendfile(req);",
          "1843:   uv_fs_req_init(loop, req, UV_FS_CHMOD, cb);",
          "1845:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1846:     return -1;",
          "1847:   }",
          "1849:   req->mode = mode;",
          "1853:     return 0;",
          "1855:     fs__chmod(req);",
          "1862: int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file fd, int mode,",
          "1864:   uv_fs_req_init(loop, req, UV_FS_FCHMOD, cb);",
          "1866:   req->fd = fd;",
          "1867:   req->mode = mode;",
          "1871:     return 0;",
          "1873:     fs__fchmod(req);",
          "1882:   uv_fs_req_init(loop, req, UV_FS_UTIME, cb);",
          "1884:   if (fs__capture_path(loop, req, path, NULL, cb != NULL) < 0) {",
          "1885:     return -1;",
          "1886:   }",
          "1888:   req->atime = atime;",
          "1889:   req->mtime = mtime;",
          "1893:     return 0;",
          "1895:     fs__utime(req);",
          "1902: int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file fd, double atime,",
          "1904:   uv_fs_req_init(loop, req, UV_FS_FUTIME, cb);",
          "1906:   req->fd = fd;",
          "1907:   req->atime = atime;",
          "1908:   req->mtime = mtime;",
          "1912:     return 0;",
          "1914:     fs__futime(req);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1918: void uv_fs_req_cleanup(uv_fs_t* req) {",
          "1922:     return;",
          "1926:     free(req->pathw);",
          "1936:     free(req->ptr);",
          "1939:   req->ptr = NULL;",
          "1946:   req->flags |= UV_FS_CLEANEDUP;",
          "1947: }",
          "",
          "[Removed Lines]",
          "1919:   uv_loop_t* loop = req->loop;",
          "1921:   if (req->flags & UV_FS_CLEANEDUP) {",
          "1923:   }",
          "1925:   if (req->flags & UV_FS_FREE_PATH && req->pathw) {",
          "1927:     req->pathw = NULL;",
          "1928:   }",
          "1930:   if (req->flags & UV_FS_FREE_NEW_PATH && req->new_pathw) {",
          "1931:     free(req->new_pathw);",
          "1932:     req->new_pathw = NULL;",
          "1933:   }",
          "1935:   if (req->flags & UV_FS_FREE_PTR && req->ptr) {",
          "1937:   }",
          "1941:   if (req->path) {",
          "1942:     free(req->path);",
          "1943:     req->path = NULL;",
          "1944:   }",
          "",
          "[Added Lines]",
          "1930:   if (req->flags & UV_FS_CLEANEDUP)",
          "1933:   if (req->flags & UV_FS_FREE_PATHS)",
          "1936:   if (req->flags & UV_FS_FREE_PTR)",
          "1939:   req->path = NULL;",
          "1940:   req->pathw = NULL;",
          "1941:   req->new_pathw = NULL;",
          "",
          "---------------"
        ],
        "deps/uv/src/win/process-stdio.c||deps/uv/src/win/process-stdio.c": [
          "File: deps/uv/src/win/process-stdio.c -> deps/uv/src/win/process-stdio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "332:         if (uv__duplicate_fd(loop, fdopt.data.fd, &child_handle) < 0) {",
          "333:           goto error;",
          "334:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "335:           if (fdopt.data.fd <= 2 && loop->last_err.code == UV_EBADF) {",
          "336:             CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;",
          "337:             CHILD_STDIO_HANDLE(buffer, i) = NULL;",
          "338:             break;",
          "339:           }",
          "",
          "---------------"
        ],
        "deps/uv/src/win/winapi.h||deps/uv/src/win/winapi.h": [
          "File: deps/uv/src/win/winapi.h -> deps/uv/src/win/winapi.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4132:   DWORD FileAttributes;",
          "4133: } FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;",
          "4135: typedef struct _FILE_MODE_INFORMATION {",
          "4136:   ULONG Mode;",
          "4137: } FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4135: typedef struct _FILE_DISPOSITION_INFORMATION {",
          "4136:   BOOLEAN DeleteFile;",
          "4137: } FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4375: # define ENABLE_EXTENDED_FLAGS 0x80",
          "4376: #endif",
          "4378: typedef BOOL (WINAPI *sGetQueuedCompletionStatusEx)",
          "4379:              (HANDLE CompletionPort,",
          "4380:               LPOVERLAPPED_ENTRY lpCompletionPortEntries,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4383: #ifndef ERROR_SYMLINK_NOT_SUPPORTED",
          "4384: # define ERROR_SYMLINK_NOT_SUPPORTED 1464",
          "4385: #endif",
          "",
          "---------------"
        ],
        "deps/uv/test/test-tcp-unexpected-read.c||deps/uv/test/test-tcp-unexpected-read.c": [
          "File: deps/uv/test/test-tcp-unexpected-read.c -> deps/uv/test/test-tcp-unexpected-read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size) {",
          "51:   ASSERT(0 && \"alloc_cb should not have been called\");",
          "52: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53:   return uv_buf_init(NULL, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f68f256cfac319fba1c47f60f5aab008fbb170e",
      "candidate_info": {
        "commit_hash": "7f68f256cfac319fba1c47f60f5aab008fbb170e",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/7f68f256cfac319fba1c47f60f5aab008fbb170e",
        "files": [
          "benchmark/http_simple.js"
        ],
        "message": "Benchmark: clean up http_simple.js",
        "before_after_code_files": [
          "benchmark/http_simple.js||benchmark/http_simple.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "benchmark/http_simple.js||benchmark/http_simple.js": [
          "File: benchmark/http_simple.js -> benchmark/http_simple.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: console.log('pid ' + process.pid);",
          "17: var useDomains = process.env.NODE_USE_DOMAINS;",
          "",
          "[Removed Lines]",
          "1: path = require(\"path\");",
          "2: exec = require(\"child_process\").exec;",
          "3: http = require(\"http\");",
          "5: port = parseInt(process.env.PORT || 8000);",
          "9: fixed = \"\"",
          "10: for (var i = 0; i < 20*1024; i++) {",
          "11:   fixed += \"C\";",
          "12: }",
          "14: stored = {};",
          "15: storedBuffer = {};",
          "",
          "[Added Lines]",
          "1: var path = require('path'),",
          "2:     exec = require('child_process').exec,",
          "3:     http = require('http');",
          "5: var port = parseInt(process.env.PORT || 8000);",
          "9: var fixed = makeString(20 * 1024, 'C'),",
          "10:     storedBytes = {},",
          "11:     storedBuffer = {};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28: }",
          "30: var server = http.createServer(function (req, res) {",
          "32:   if (useDomains) {",
          "33:     var dom = domain.create();",
          "34:     dom.add(req);",
          "35:     dom.add(res);",
          "36:   }",
          "39:   var command = commands[1];",
          "41:   var arg = commands[2];",
          "42:   var n_chunks = parseInt(commands[3], 10);",
          "43:   var status = 200;",
          "47:     if (n <= 0)",
          "55:     }",
          "61:     if (storedBuffer[n] === undefined) {",
          "63:       storedBuffer[n] = new Buffer(n);",
          "64:       for (var i = 0; i < n; i++) {",
          "66:       }",
          "67:     }",
          "68:     body = storedBuffer[n];",
          "71:     res.connection.server.close();",
          "75:     body = fixed;",
          "80:     req.pipe(res);",
          "81:     return;",
          "83:   } else {",
          "84:     status = 404;",
          "86:   }",
          "90:   if (n_chunks > 0) {",
          "94:     var len = body.length;",
          "95:     var step = ~~(len / n_chunks) || len;",
          "",
          "[Removed Lines]",
          "38:   var commands = req.url.split(\"/\");",
          "40:   var body = \"\";",
          "45:   if (command == \"bytes\") {",
          "46:     var n = parseInt(arg, 10)",
          "48:       throw \"bytes called with n <= 0\"",
          "49:     if (stored[n] === undefined) {",
          "50:       console.log(\"create stored[n]\");",
          "51:       stored[n] = \"\";",
          "52:       for (var i = 0; i < n; i++) {",
          "53:         stored[n] += \"C\"",
          "54:       }",
          "56:     body = stored[n];",
          "58:   } else if (command == \"buffer\") {",
          "59:     var n = parseInt(arg, 10)",
          "60:     if (n <= 0) throw new Error(\"bytes called with n <= 0\");",
          "62:       console.log(\"create storedBuffer[n]\");",
          "65:         storedBuffer[n][i] = \"C\".charCodeAt(0);",
          "70:   } else if (command == \"quit\") {",
          "72:     body = \"quitting\";",
          "74:   } else if (command == \"fixed\") {",
          "77:   } else if (command == \"echo\") {",
          "78:     res.writeHead(200, { \"Content-Type\": \"text/plain\",",
          "79:                          \"Transfer-Encoding\": \"chunked\" });",
          "85:     body = \"not found\\n\";",
          "91:     res.writeHead(status, { \"Content-Type\": \"text/plain\",",
          "92:                             \"Transfer-Encoding\": \"chunked\" });",
          "",
          "[Added Lines]",
          "33:   var commands = req.url.split('/');",
          "35:   var body = '';",
          "40:   if (command == 'bytes') {",
          "41:     var n = ~~arg;",
          "43:       throw new Error('bytes called with n <= 0')",
          "44:     if (storedBytes[n] === undefined) {",
          "45:       console.log('create storedBytes[n]');",
          "46:       storedBytes[n] = makeString(n, 'C');",
          "48:     body = storedBytes[n];",
          "50:   } else if (command == 'buffer') {",
          "51:     var n = ~~arg;",
          "52:     if (n <= 0)",
          "53:       throw new Error('buffer called with n <= 0');",
          "55:       console.log('create storedBuffer[n]');",
          "58:         storedBuffer[n][i] = 'C'.charCodeAt(0);",
          "63:   } else if (command == 'quit') {",
          "65:     body = 'quitting';",
          "67:   } else if (command == 'fixed') {",
          "70:   } else if (command == 'echo') {",
          "71:     res.writeHead(200, { 'Content-Type': 'text/plain',",
          "72:                          'Transfer-Encoding': 'chunked' });",
          "78:     body = 'not found\\n';",
          "84:     res.writeHead(status, { 'Content-Type': 'text/plain',",
          "85:                             'Transfer-Encoding': 'chunked' });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "102:   } else {",
          "103:     var content_length = body.length.toString();",
          "107:     res.end(body);",
          "108:   }",
          "110: });",
          "112: server.listen(port, function () {",
          "113:   console.log('Listening at http://127.0.0.1:'+port+'/');",
          "114: });",
          "",
          "[Removed Lines]",
          "105:     res.writeHead(status, { \"Content-Type\": \"text/plain\",",
          "106:                             \"Content-Length\": content_length });",
          "",
          "[Added Lines]",
          "98:     res.writeHead(status, { 'Content-Type': 'text/plain',",
          "99:                             'Content-Length': content_length });",
          "104: function makeString(size, c) {",
          "105:   var s = '';",
          "106:   while (s.length < size) {",
          "107:     s += c;",
          "108:   }",
          "109:   return s;",
          "110: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "352febe2519b0bb0e004086fa06a27217bdbebbb",
      "candidate_info": {
        "commit_hash": "352febe2519b0bb0e004086fa06a27217bdbebbb",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/352febe2519b0bb0e004086fa06a27217bdbebbb",
        "files": [
          "deps/uv/src/unix/udp.c"
        ],
        "message": "uv: upgrade to 9c76d0d",
        "before_after_code_files": [
          "deps/uv/src/unix/udp.c||deps/uv/src/unix/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/uv/src/unix/udp.c||deps/uv/src/unix/udp.c": [
          "File: deps/uv/src/unix/udp.c -> deps/uv/src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "340:     goto out;",
          "341:   }",
          "343:   if (flags & UV_UDP_IPV6ONLY) {",
          "344: #ifdef IPV6_V6ONLY",
          "345:     yes = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "344:   yes = 1;",
          "345:   if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof yes) == -1) {",
          "346:     uv__set_sys_error(handle->loop, errno);",
          "347:     goto out;",
          "348:   }",
          "349: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b88c3902b241cf934e75443b934f2033ad3915b1",
      "candidate_info": {
        "commit_hash": "b88c3902b241cf934e75443b934f2033ad3915b1",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/b88c3902b241cf934e75443b934f2033ad3915b1",
        "files": [
          "ChangeLog",
          "src/node_version.h"
        ],
        "message": "2012.09.11, Version 0.8.9 (Stable)\n\n* v8: upgrade to 3.11.10.22\n\n* GYP: upgrade to r1477\n\n* npm: Upgrade to 1.1.61\n\n* npm: Don't create world-writable files (isaacs)\n\n* windows: fix single-accept mode for shared server sockets (Bert Belder)\n\n* windows: fix uninitialized memory access in uv_update_time() (Bert Belder)\n\n* windows: don't throw when a signal handler is attached (Bert Belder)\n\n* unix: fix memory leak in udp (Ben Noordhuis)\n\n* unix: map errno ESPIPE (Ben Noordhuis)\n\n* unix, windows: fix memory corruption in fs-poll.c (Ben Noordhuis)\n\n* sunos: fix os.cpus() on x86_64 (Ben Noordhuis)\n\n* child process: fix processes with IPC channel don't emit 'close' (Bert Belder)\n\n* build: add a \"--dest-os\" option to force a gyp \"flavor\" (Nathan Rajlich)\n\n* build: set `process.platform` to \"sunos\" on SunOS (Nathan Rajlich)\n\n* build: fix `make -j` fails after `make clean` (Bearice Ren)\n\n* build: fix openssl configuration for \"arm\" builds (Nathan Rajlich)\n\n* tls: support unix domain socket/named pipe in tls.connect (Shigeki Ohtsu)\n\n* https: make https.get() accept a URL (koichik)\n\n* http: respect HTTP/1.0 TE header (Ben Noordhuis)\n\n* crypto, tls: Domainify setSNICallback, pbkdf2, randomBytes (Ben Noordhuis)\n\n* stream.pipe: Don't call destroy() unless it's a function (isaacs)",
        "before_after_code_files": [
          "src/node_version.h||src/node_version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/node_version.h||src/node_version.h": [
          "File: src/node_version.h -> src/node_version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #define NODE_MAJOR_VERSION 0",
          "26: #define NODE_MINOR_VERSION 8",
          "27: #define NODE_PATCH_VERSION 9",
          "30: #ifndef NODE_STRINGIFY",
          "31: #define NODE_STRINGIFY(n) NODE_STRINGIFY_HELPER(n)",
          "",
          "[Removed Lines]",
          "28: #define NODE_VERSION_IS_RELEASE 0",
          "",
          "[Added Lines]",
          "28: #define NODE_VERSION_IS_RELEASE 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a4a04f932ed99a8195f6d44227b1e89f5b9ea381",
      "candidate_info": {
        "commit_hash": "a4a04f932ed99a8195f6d44227b1e89f5b9ea381",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/a4a04f932ed99a8195f6d44227b1e89f5b9ea381",
        "files": [
          "src/node_internals.h"
        ],
        "message": "node: provide snprintf implementation on windows\n\n_snprintf() doesn't zero-terminate the buffer on overflow.",
        "before_after_code_files": [
          "src/node_internals.h||src/node_internals.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/node_internals.h||src/node_internals.h": [
          "File: src/node_internals.h -> src/node_internals.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: namespace node {",
          "29: #ifdef _WIN32",
          "31: #endif",
          "33: #ifndef offset_of",
          "",
          "[Removed Lines]",
          "30: # define snprintf _snprintf",
          "",
          "[Added Lines]",
          "32: #include <stdarg.h>",
          "33: inline static int snprintf(char* buf, unsigned int len, const char* fmt, ...) {",
          "34:   va_list ap;",
          "35:   va_start(ap, fmt);",
          "36:   int n = _vsprintf_p(buf, len, fmt, ap);",
          "37:   if (len) buf[len - 1] = '\\0';",
          "38:   va_end(ap);",
          "39:   return n;",
          "40: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}